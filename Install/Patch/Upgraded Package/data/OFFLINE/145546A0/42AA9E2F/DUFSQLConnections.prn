Compiling Program: C:\Projects\DF18\DbUpdateFramework\AppSrc\DUFSQLConnections.src
Memory Available: 2147483646
1>Use DFAllEnt.pkg
Using pre-compiled package DFALLENT.PKG
Including file: dfallent.pkd    (C:\Program Files (x86)\DataFlex 19.0\Pkg\dfallent.pkd)
79228>Use cCJStandardCommandBarSystem.pkg
Including file: cCJStandardCommandBarSystem.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJStandardCommandBarSystem.pkg)
79228>>>// these are all the packages used in a standard MDI menubar/toolbar system
79228>>>
79228>>>Use cCJCommandBarSystem.pkg
79228>>>Use cCJStandardMenuItemClasses.pkg
Including file: cCJStandardMenuItemClasses.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJStandardMenuItemClasses.pkg)
79228>>>>>Use Dfpanel.pkg
79228>>>>>Use cCJCommandBarSystem.pkg
79228>>>>>Use LanguageText.pkg
79228>>>>>
79228>>>>>
79228>>>>>Class cCJUndoMenuItem is a cCJMenuItem
79229>>>>>    
79229>>>>>    Procedure Construct_Object
79231>>>>>        Forward Send Construct_Object
79233>>>>>        Set psCaption   to C_$CaptionUndo
79234>>>>>        Set psToolTip to C_$ToolTipUndo
79235>>>>>        Set psDescription to C_$DescUndo
79236>>>>>        Set psImage to "ActionUndo.ico"
79237>>>>>        Set pbActiveUpdate to True
79238>>>>>        Set psCategory to C_$CategoryEdit
79239>>>>>        Set psShortcut to C_$Key_Ctrl_Z
79240>>>>>    End_Procedure
79241>>>>>
79241>>>>>    Procedure OnExecute Variant vCommandBarControl
79243>>>>>        Send Undo of (focus(Self))
79244>>>>>    End_Procedure
79245>>>>>    
79245>>>>>    Function IsEnabled Returns Boolean
79247>>>>>        Boolean bEnabled
79247>>>>>        Get CanUndo of (Focus(Self)) to bEnabled
79248>>>>>        Function_Return bEnabled
79249>>>>>    End_Function
79250>>>>>         
79250>>>>>End_Class
79251>>>>>
79251>>>>>
79251>>>>>Class cCJDeleteEditMenuItem is a cCJMenuItem
79252>>>>>    
79252>>>>>    Procedure Construct_Object
79254>>>>>        Forward Send Construct_Object
79256>>>>>        Set psCaption   to C_$CaptionDelete
79257>>>>>        Set psToolTip to C_$ToolTipDelete
79258>>>>>        Set psDescription to C_$DescDelete
79259>>>>>        Set psImage to "actionDelete.ico"
79260>>>>>        Set psShortcut to C_$Key_Delete
79261>>>>>        Set pbActiveUpdate to True
79262>>>>>        Set psCategory to C_$CategoryEdit
79263>>>>>    End_Procedure
79264>>>>>
79264>>>>>
79264>>>>>    Procedure OnExecute Variant vCommandBarControl
79266>>>>>        Send Delete of (focus(Self))
79267>>>>>    End_Procedure
79268>>>>>    
79268>>>>>    Function IsEnabled Returns Boolean
79270>>>>>        Boolean bEnabled
79270>>>>>        Get CanDelete of (Focus(Self)) to bEnabled
79271>>>>>        Function_Return bEnabled
79272>>>>>    End_Function
79273>>>>>         
79273>>>>>End_Class
79274>>>>>
79274>>>>>
79274>>>>>Class cCJCutMenuItem is a cCJMenuItem
79275>>>>>    
79275>>>>>    Procedure Construct_Object
79277>>>>>        Forward Send Construct_Object
79279>>>>>        Set psCaption   to C_$CaptionCut
79280>>>>>        Set psToolTip to C_$TooltipCut
79281>>>>>        Set psDescription to C_$DescCut
79282>>>>>        Set psImage to "actionCut.ico"
79283>>>>>        Set psShortcut to C_$Key_Ctrl_X
79284>>>>>        Set pbActiveUpdate to True
79285>>>>>        Set psCategory to C_$CategoryEdit
79286>>>>>    End_Procedure
79287>>>>>
79287>>>>>
79287>>>>>    Procedure OnExecute Variant vCommandBarControl
79289>>>>>        Send Cut of (focus(Self))
79290>>>>>    End_Procedure
79291>>>>>    
79291>>>>>    Function IsEnabled Returns Boolean
79293>>>>>        Boolean bEnabled
79293>>>>>        Get CanCut of (Focus(Self)) to bEnabled
79294>>>>>        Function_Return bEnabled
79295>>>>>    End_Function
79296>>>>>         
79296>>>>>End_Class
79297>>>>>
79297>>>>>
79297>>>>>Class cCJCopyMenuItem is a cCJMenuItem
79298>>>>>    
79298>>>>>    Procedure Construct_Object
79300>>>>>        Forward Send Construct_Object
79302>>>>>        Set psCaption   to C_$CaptionCopy
79303>>>>>        Set psToolTip to C_$ToolTipCopy
79304>>>>>        Set psDescription to C_$DescCopy
79305>>>>>        Set psImage to "actionCopy.ico"
79306>>>>>        Set psShortcut to C_$Key_Ctrl_C
79307>>>>>        Set pbActiveUpdate to True
79308>>>>>        Set psCategory to C_$CategoryEdit
79309>>>>>    End_Procedure
79310>>>>>
79310>>>>>
79310>>>>>    Procedure OnExecute Variant vCommandBarControl
79312>>>>>        Send Copy of (focus(Self))
79313>>>>>    End_Procedure
79314>>>>>    
79314>>>>>    Function IsEnabled Returns Boolean
79316>>>>>        Boolean bEnabled
79316>>>>>        Get CanCopy of (Focus(Self)) to bEnabled
79317>>>>>        Function_Return bEnabled
79318>>>>>    End_Function
79319>>>>>         
79319>>>>>End_Class
79320>>>>>
79320>>>>>
79320>>>>>Class cCJPasteMenuItem is a cCJMenuItem
79321>>>>>    
79321>>>>>    Procedure Construct_Object
79323>>>>>        Forward Send Construct_Object
79325>>>>>        Set psCaption   to C_$CaptionPaste
79326>>>>>        Set psToolTip to C_$ToolTipPaste
79327>>>>>        Set psDescription to C_$DescPaste
79328>>>>>        Set psImage to "actionPaste.ico"
79329>>>>>        Set pbActiveUpdate to True
79330>>>>>        Set psShortcut to C_$Key_Ctrl_V
79331>>>>>        Set psCategory to C_$CategoryEdit
79332>>>>>    End_Procedure
79333>>>>>
79333>>>>>
79333>>>>>    Procedure OnExecute Variant vCommandBarControl
79335>>>>>        Send Paste of (focus(Self))
79336>>>>>    End_Procedure
79337>>>>>    
79337>>>>>    Function IsEnabled Returns Boolean
79339>>>>>        Boolean bEnabled
79339>>>>>        Get CanPaste of (Focus(Self)) to bEnabled
79340>>>>>        Function_Return bEnabled
79341>>>>>    End_Function
79342>>>>>         
79342>>>>>End_Class
79343>>>>>
79343>>>>>Class cCJSelectAllMenuItem is a cCJMenuItem
79344>>>>>    
79344>>>>>    Procedure Construct_Object
79346>>>>>        Forward Send Construct_Object
79348>>>>>        Set psCaption   to C_$CaptionSelectAll
79349>>>>>        Set psToolTip to C_$ToolTipSelectAll
79350>>>>>        Set psDescription to C_$DescSelectAll
79351>>>>>        Set pbActiveUpdate to True
79352>>>>>        Set psShortcut to C_$Key_Ctrl_A
79353>>>>>        Set psCategory to C_$CategoryEdit
79354>>>>>    End_Procedure
79355>>>>>
79355>>>>>
79355>>>>>    Procedure OnExecute Variant vCommandBarControl
79357>>>>>        Send Select_All of (focus(Self))
79358>>>>>    End_Procedure
79359>>>>>    
79359>>>>>    Function IsEnabled Returns Boolean
79361>>>>>        Boolean bEnabled
79361>>>>>        Get CanSelect of (Focus(Self)) to bEnabled
79362>>>>>        Function_Return bEnabled
79363>>>>>    End_Function
79364>>>>>         
79364>>>>>End_Class
79365>>>>>
79365>>>>> 
79365>>>>>Class cCJExitMenuItem is a cCJMenuItem
79366>>>>>
79366>>>>>    Procedure Construct_Object
79368>>>>>        Forward Send Construct_Object
79370>>>>>        Set psCaption to C_$CaptionExit
79371>>>>>        Set psToolTip to C_$ToolTipExit
79372>>>>>        Set psDescription to C_$ToolTipExit
79373>>>>>        Set psShortcut to C_$Key_Alt_F4
79374>>>>>        Set psCategory to C_$CategoryFile
79375>>>>>    End_Procedure
79376>>>>>
79376>>>>>    Procedure OnExecute Variant vCommandBarControl
79378>>>>>        Send Exit_Application of Desktop
79379>>>>>    End_Procedure
79380>>>>>
79380>>>>>End_Class           
79381>>>>>
79381>>>>>Class cCJHelpMenuItem is a cCJMenuItem    
79382>>>>>
79382>>>>>    Procedure Construct_Object
79384>>>>>        Forward Send Construct_Object
79386>>>>>        Set psCaption to C_$CaptionHelp
79387>>>>>        Set psDescription to C_$ToolTipHelp
79388>>>>>        Set psToolTip to C_$DescHelp
79389>>>>>        Set psImage to "ActionHelp.ico"
79390>>>>>        Set psShortcut to "F1"
79391>>>>>        Set psCategory to C_$CategoryHelp
79392>>>>>    End_Procedure
79393>>>>>    
79393>>>>>    Procedure OnExecute Variant vCommandBarControl
79395>>>>>        Send Help of (Focus(Self))
79396>>>>>    End_Procedure
79397>>>>>
79397>>>>>End_Class
79398>>>>>
79398>>>>>Class cCJStatusbarMenuItem is a cCJMenuItem
79399>>>>>
79399>>>>>    Procedure Construct_Object
79401>>>>>        Forward Send Construct_Object
79403>>>>>        Set psCaption to C_$CaptionAddStatusbar
79404>>>>>        Set psToolTip to C_$ToolTipAddStatusbar
79405>>>>>        Set psDescription to  C_$DescAddStatusbar
79406>>>>>        Set psCategory to C_$CategoryWindow
79407>>>>>    End_Procedure
79408>>>>>
79408>>>>>    Procedure OnExecute Variant vCommandBarControl
79410>>>>>        Handle hoCommandBars hoClientArea
79410>>>>>        Get CommandBarSystemObject to hoCommandBars
79411>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79412>>>>>        If hoClientArea Begin
79414>>>>>            // the clientarea's parent panel has message
79414>>>>>            Send Toggle_StatusBar of (Parent(hoClientArea))
79415>>>>>        End
79415>>>>>>
79415>>>>>    End_Procedure
79416>>>>>
79416>>>>>     Function IsChecked Returns Boolean
79418>>>>>        Boolean bOn
79418>>>>>        Handle hoCommandBars hoClientArea
79418>>>>>        Get CommandBarSystemObject to hoCommandBars
79419>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79420>>>>>        If hoClientArea Begin
79422>>>>>            // the clientarea's parent panel has message
79422>>>>>            Get StatusBar_State of (Parent(hoClientArea)) to bOn
79423>>>>>        End
79423>>>>>>
79423>>>>>        Function_Return bOn
79424>>>>>     End_Function
79425>>>>>End_Class
79426>>>>>
79426>>>>>Class cCJAutoArrangeIconsMenuItem is a cCJMenuItem
79427>>>>>
79427>>>>>    Procedure Construct_Object
79429>>>>>        Forward Send Construct_Object
79431>>>>>        Set psCaption to C_$CaptionAutoArrangeIcons
79432>>>>>        Set psToolTip to C_$ToolTipAutoArrangeIcons
79433>>>>>        Set psDescription to C_$DescAutoArrangeIcons
79434>>>>>        Set psCategory to C_$CategoryWindow
79435>>>>>    End_Procedure
79436>>>>>
79436>>>>>    Procedure OnExecute Variant vCommandBarControl
79438>>>>>        Handle hoCommandBars hoClientArea
79438>>>>>        Get CommandBarSystemObject to hoCommandBars
79439>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79440>>>>>        If hoClientArea Begin
79442>>>>>            // the clientarea's parent panel has message
79442>>>>>            Send Toggle_Auto_Arrange_Icons of (Parent(hoClientArea))
79443>>>>>        End
79443>>>>>>
79443>>>>>    End_Procedure
79444>>>>>    
79444>>>>>     Function IsChecked Returns Boolean
79446>>>>>        Boolean bOn
79446>>>>>        Handle hoCommandBars hoClientArea
79446>>>>>        Get CommandBarSystemObject to hoCommandBars
79447>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79448>>>>>        If hoClientArea Begin
79450>>>>>            // the clientarea's parent panel has message
79450>>>>>            Get Auto_Arrange_Icons_State of (Parent(hoClientArea)) to bOn
79451>>>>>        End
79451>>>>>>
79451>>>>>        Function_Return bOn
79452>>>>>     End_Function
79453>>>>>End_Class
79454>>>>>
79454>>>>>Class cCJRestoreMenusMenuItem is a cCJMenuItem
79455>>>>>
79455>>>>>    Procedure Construct_Object
79457>>>>>        Forward Send Construct_Object
79459>>>>>        Set psCaption to C_$CaptionRestoreMenus
79460>>>>>        Set psToolTip to C_$ToolTipRestoreMenus
79461>>>>>        Set psDescription to C_$DescRestoreMenus
79462>>>>>        Set psCategory to C_$CategoryWindow
79463>>>>>    End_Procedure
79464>>>>>
79464>>>>>    Procedure OnExecute Variant vCommandBarControl
79466>>>>>        Handle hoCommandBars
79466>>>>>        Get CommandBarSystemObject to hoCommandBars
79467>>>>>        Send RestoreLayout of hoCommandBars
79468>>>>>    End_Procedure
79469>>>>>    
79469>>>>>End_Class
79470>>>>>
79470>>>>>Class cCJCascadeMenuItem is a cCJMenuItem
79471>>>>>
79471>>>>>    Procedure Construct_Object
79473>>>>>        Forward Send Construct_Object
79475>>>>>        Set psCaption to C_$CaptionCascade
79476>>>>>        Set psToolTip to C_$ToolTipCascade
79477>>>>>        Set psDescription to  C_$DescCascade
79478>>>>>        Set psImage to "ActionCascade.ico"
79479>>>>>        Set psCategory to C_$CategoryWindow
79480>>>>>    End_Procedure
79481>>>>>    
79481>>>>>    Procedure OnExecute Variant vCommandBarControl
79483>>>>>        Handle hoCommandBars hoClientArea
79483>>>>>        Get CommandBarSystemObject to hoCommandBars
79484>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79485>>>>>        If hoClientArea Begin
79487>>>>>            Send Cascade_Windows of hoClientArea
79488>>>>>        End
79488>>>>>>
79488>>>>>    End_Procedure
79489>>>>>End_Class
79490>>>>>
79490>>>>>Class cCJTileHorizontally is a cCJMenuItem
79491>>>>>
79491>>>>>    Procedure Construct_Object
79493>>>>>        Forward Send Construct_Object
79495>>>>>        Set psCaption to C_$CaptionTileHorizontally 
79496>>>>>        Set psToolTip to C_$ToolTipTileHorizontally  
79497>>>>>        Set psDescription to  C_$DescTileHorizontally
79498>>>>>        Set psImage to "ActionTileHorizontally.ico"
79499>>>>>        Set psCategory to C_$CategoryWindow
79500>>>>>    End_Procedure
79501>>>>>
79501>>>>>    Procedure OnExecute Variant vCommandBarControl
79503>>>>>        Handle hoCommandBars hoClientArea
79503>>>>>        Get CommandBarSystemObject to hoCommandBars
79504>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79505>>>>>        If hoClientArea Begin
79507>>>>>            Send Tile_Windows_Horizontal of hoClientArea
79508>>>>>        End
79508>>>>>>
79508>>>>>    End_Procedure
79509>>>>>End_Class
79510>>>>>
79510>>>>>Class cCJTileVertically is a cCJMenuItem
79511>>>>>
79511>>>>>    Procedure Construct_Object
79513>>>>>        Forward Send Construct_Object
79515>>>>>        Set psCaption to C_$CaptionTileVertically  
79516>>>>>        Set psToolTip to C_$ToolTipTileVertically
79517>>>>>        Set psDescription to  C_$DescTileVertically
79518>>>>>        Set psImage to "ActionTileVertically.ico"
79519>>>>>        Set psCategory to C_$CategoryWindow
79520>>>>>    End_Procedure
79521>>>>>
79521>>>>>    Procedure OnExecute Variant vCommandBarControl
79523>>>>>        Handle hoCommandBars hoClientArea
79523>>>>>        Get CommandBarSystemObject to hoCommandBars
79524>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79525>>>>>        If hoClientArea Begin
79527>>>>>            Send Tile_Windows_Vertical of hoClientArea
79528>>>>>        End
79528>>>>>>
79528>>>>>    End_Procedure
79529>>>>>End_Class
79530>>>>>
79530>>>>>Class cCJMinimizeWindowsMenuItem is a cCJMenuItem
79531>>>>>
79531>>>>>    Procedure Construct_Object
79533>>>>>        Forward Send Construct_Object
79535>>>>>        Set psCaption to C_$CaptionMinimizeWindows 
79536>>>>>        Set psToolTip to C_$ToolTipMinimizeWindows
79537>>>>>        Set psDescription to  C_$DescMinimizeWindows
79538>>>>>        Set psCategory to C_$CategoryWindow
79539>>>>>    End_Procedure
79540>>>>>
79540>>>>>    Procedure OnExecute Variant vCommandBarControl
79542>>>>>        Handle hoCommandBars hoClientArea
79542>>>>>        Get CommandBarSystemObject to hoCommandBars
79543>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79544>>>>>        If hoClientArea Begin
79546>>>>>            // the clientarea's parent panel has message
79546>>>>>            Send Minimize_all_Windows of (Parent(hoClientArea))
79547>>>>>        End
79547>>>>>>
79547>>>>>    End_Procedure
79548>>>>>End_Class
79549>>>>>
79549>>>>>
79549>>>>>Class cCJRestoreWindowsMenuItem is a cCJMenuItem
79550>>>>>
79550>>>>>    Procedure Construct_Object
79552>>>>>        Forward Send Construct_Object
79554>>>>>        Set psCaption to C_$CaptionRestoreWindows
79555>>>>>        Set psToolTip to C_$ToolTipRestoreWindows
79556>>>>>        Set psDescription to  C_$DescRestoreWindows
79557>>>>>        Set psCategory to C_$CategoryWindow
79558>>>>>    End_Procedure
79559>>>>>
79559>>>>>    Procedure OnExecute Variant vCommandBarControl
79561>>>>>        Handle hoCommandBars hoClientArea
79561>>>>>        Get CommandBarSystemObject to hoCommandBars
79562>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79563>>>>>        If hoClientArea Begin
79565>>>>>            // the clientarea's parent panel has message
79565>>>>>            Send Restore_all_Windows of (Parent(hoClientArea))
79566>>>>>        End
79566>>>>>>
79566>>>>>    End_Procedure
79567>>>>>End_Class
79568>>>>>
79568>>>>>Class cCJArrangeIconsMenuItem is a cCJMenuItem
79569>>>>>
79569>>>>>    Procedure Construct_Object
79571>>>>>        Forward Send Construct_Object
79573>>>>>        Set psCaption to C_$CaptionArrangeIcons  
79574>>>>>        Set psToolTip to C_$ToolTipArrangeIcons
79575>>>>>        Set psDescription to  C_$DescArrangeIcons
79576>>>>>        Set psCategory to C_$CategoryWindow
79577>>>>>    End_Procedure
79578>>>>>
79578>>>>>    Procedure OnExecute Variant vCommandBarControl
79580>>>>>        Handle hoCommandBars hoClientArea
79580>>>>>        Get CommandBarSystemObject to hoCommandBars
79581>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79582>>>>>        If hoClientArea Begin
79584>>>>>            Send Arrange_Icons of hoClientArea
79585>>>>>        End
79585>>>>>>
79585>>>>>    End_Procedure
79586>>>>>
79586>>>>>End_Class
79587>>>>>    
79587>>>Use cCJAboutMenuItem.pkg
Including file: cCJAboutMenuItem.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJAboutMenuItem.pkg)
79587>>>>>Use cCJCommandBarSystem.pkg
79587>>>>>Use LanguageText.pkg
79587>>>>>
79587>>>>>// It is expected that if you use this class that you provide an about object that is
79587>>>>>// activated via activate_about such as DfAbout.pkg. We don't use this for you automatically
79587>>>>>// because you may wish to create your own custom about package.
79587>>>>>
79587>>>>>Class cCJAboutMenuItem is a cCJMenuItem    
79588>>>>>
79588>>>>>    Procedure Construct_Object
79590>>>>>        Forward Send Construct_Object
79592>>>>>        Set psCaption to C_$CaptionAbout
79593>>>>>        Set psDescription to C_$ToolTipAbout
79594>>>>>        Set psToolTip to C_$DescAbout
79595>>>>>        Set psImage to "ActionAbout.ico"
79596>>>>>        Set psCategory to C_$CategoryHelp
79597>>>>>    End_Procedure
79598>>>>>    
79598>>>>>    Procedure OnExecute Variant vCommandBarControl
79600>>>>>        Handle hoCommandBars hoClientArea
79600>>>>>        Get CommandBarSystemObject to hoCommandBars
79601>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79602>>>>>        If hoClientArea Begin
79604>>>>>            Send Activate_About of hoClientArea
79605>>>>>        End
79605>>>>>>
79605>>>>>    End_Procedure
79606>>>>>
79606>>>>>End_Class
79607>>>>>
79607>>>>>
79607>>>Use cCJDeoMenuItemClasses.pkg
79607>>>Use cCJMDIWindowsMenuItem.pkg
Including file: cCJMDIWindowsMenuItem.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJMDIWindowsMenuItem.pkg)
79607>>>>>Use cCJCommandBarSystem.pkg
79607>>>>>
79607>>>>>Register_Function Client_ID Returns Integer
79607>>>>>
79607>>>>>// only used by cCJMDIWIndowsMenuItem
79607>>>>>Class cCJMDIWindowItem is a cCJMenuItem
79608>>>>>
79608>>>>>    Procedure Construct_Object
79610>>>>>        Forward Send Construct_Object
79612>>>>>        Property Handle phWindow 0 // object id of view
79613>>>>>        Set pbControlFlagNoMovable to True
79614>>>>>        Set pbActiveUpdate to True
79615>>>>>    End_Procedure
79616>>>>>    
79616>>>>>    Procedure OnExecute Variant vCommandBarControl
79618>>>>>        Handle hWindow
79618>>>>>        Get phWindow to hWindow
79619>>>>>        Send Activate_View of hWindow
79620>>>>>    End_Procedure
79621>>>>>    
79621>>>>>End_Class                
79622>>>>>
79622>>>>>
79622>>>>>Class cCJMDIWindowsMenuItem is a cCJMenuItem
79623>>>>>    
79623>>>>>    Procedure Construct_Object
79625>>>>>        Forward Send Construct_Object
79627>>>>>        Property Handle[] phArrayOfWindows
79628>>>>>        Set peControlType to xtpControlPopup
79629>>>>>        Set psCategory to C_$CategoryWindow
79630>>>>>    End_Procedure
79631>>>>>    
79631>>>>>     // This adds MDI windows to the existing menu items.
79631>>>>>     // This removes any existing windows menus and always adds a new set to the end
79631>>>>>
79631>>>>>     Procedure OnPopupInit Variant vCommandBarControl Handle hCommandBarControls
79633>>>>>        Handle  hClientArea hView
79633>>>>>        String  sLabel
79633>>>>>        Integer i iWindows
79633>>>>>        Handle[] hArrayOfWindows
79634>>>>>        Variant vItem
79634>>>>>        
79634>>>>>        // delete all windows actions and menu items. Assume we have an array of DF action objects for the windows
79634>>>>>        // also assume that destroying an action removes all menu instances of that action
79634>>>>>        Get phArrayOfWindows to hArrayOfWindows
79635>>>>>        Move (SizeOfArray(hArrayOfWindows)) to iWindows
79636>>>>>        For i from 0 to (iWindows-1)
79642>>>>>>
79642>>>>>            Send Destroy of hArrayOfWindows[i] // assume this removes all menu items of this action
79643>>>>>        Loop
79644>>>>>>
79644>>>>>        Move (ResizeArray(hArrayOfWindows,0)) to hArrayOfWindows
79645>>>>>
79645>>>>>        // Add all views to this menu. Create the action and add the item
79645>>>>>        Move 0 to i
79646>>>>>        Get Client_Id to hClientArea // object id of client area
79647>>>>>        If (hClientArea > 0) Begin
79649>>>>>            Get Next_Mdi_Dialog of hClientArea True to hView // find first view
79650>>>>>            While (hView <> 0)
79654>>>>>                If (Active_State(hView)) Begin
79656>>>>>                    // create the action
79656>>>>>                    Get Create U_cCJMDIWindowItem to hArrayOfWindows[i]
79657>>>>>                    Get Label of hView to sLabel // caption bar (name) of view
79658>>>>>                    Set psCaption of hArrayOfWindows[i] to sLabel
79659>>>>>                    Set psDescription of hArrayOfWindows[i] to ("Make this view (" - trim(sLabel) - ") the active window.")
79660>>>>>                    If (current_scope(desktop)=hView and View_mode(hView)<>VIEWMODE_ICONIZE) Begin
79662>>>>>                        Set pbChecked of hArrayOfWindows[i] to True
79663>>>>>                    End
79663>>>>>>
79663>>>>>                    Set phWindow of hArrayOfWindows[i] to hView // used by custom OnExecute
79664>>>>>                    If (i=0) Begin
79666>>>>>                        Set pbControlBeginGroup of hArrayOfWindows[i] to True
79667>>>>>                    End
79667>>>>>>
79667>>>>>                    // Create a menu item for this action
79667>>>>>                    Get AddDynamicControl of hArrayOfWindows[i] hCommandBarControls to vItem
79668>>>>>                    Increment i
79669>>>>>                End
79669>>>>>>
79669>>>>>                Get Next_Mdi_Dialog of hClientArea False to hView // find next
79670>>>>>            Loop
79671>>>>>>
79671>>>>>        End
79671>>>>>>
79671>>>>>
79671>>>>>        Set phArrayOfWindows to hArrayOfWindows
79672>>>>>
79672>>>>>     End_Procedure
79673>>>>>     
79673>>>>>End_Class
79674>>>>>
79674>Use vWin32fh.pkg
Including file: vWin32fh.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\vWin32fh.pkg)
79674>>>// This code is part of VDF GUIdance
79674>>>// Visit us @ http://www.vdf-guidance.com
79674>>>// e-Mail us @ info@vdf-guidance.com
79674>>>// VDF GUIdance is a mutual project of
79674>>>// Frank Vandervelpen - Vandervelpen Systems and
79674>>>// Wil van Antwerpen  - Antwise Solutions
79674>>>// All software source code should be used <<AS IS>> without any warranty.
79674>>>//
79674>>>//
79674>>>// *** Windows 32bit file handling wrapper class ***
79674>>>//
79674>>>
79674>>>// 05-09-2000 **WvA: Changed namingconvention of all classes and methods to new standard
79674>>>//                   This may be painfull for some of you, but it was really needed as it was
79674>>>//                   getting messy. The "vs" -prefix we used before was confusing and could
79674>>>//                   unintentionally have been interpreted as "Vdf-GUIdance String".
79674>>>//
79674>>>// The used naming-convention is:
79674>>>//     - a prefix of "vWin32_" for every external function declaration
79674>>>//     - a prefix of the letter "v" for the full API name for the vdf-wrapper function.
79674>>>//
79674>>>// By using this we are guarding ourselves for conflicts with variable declarations
79674>>>// of DataAccess in the future.
79674>>>// Or at least almost as the letter "v" is now also synonym for variant (duh~!)
79674>>>//
79674>>>// mm-dd-yyyy Author Description
79674>>>//
79674>>>//                   vSHGetFolderPath added to retrieve the new shell folders
79674>>>//                   vGetWindowsDirectory
79674>>>//
79674>>>//                   vGetTempFileName
79674>>>//                   vGetTempPath
79674>>>// 11-17-2001 **WvA: Removed User Interface Error popups such as Error handling.
79674>>>//                   This is an absolute need for WebApp. We expect you to handle the
79674>>>//                   error in your application anyways. Changed this for:
79674>>>//                   vDeleteFile, vCopyFile, vMoveFile and vRenameFile
79674>>>// 03-02-2002 **WvA: vRemoveDirectory added
79674>>>// 03-11-2002 **WvA: The parameter lpdword in the external function declaration for
79674>>>//                   vWin32_SHBrowsForFolder can cause compiler errors.
79674>>>//                   It is renamed too avoid this.
79674>>>// 11-11-2002 **WvA: Codecleanup, vcSelectFile_Dialog is now cvSelectFile_Dialog, its
79674>>>//                   function vSelectedFileName is now just SelectedFileName
79674>>>//                   Removed the local keyword in the variable declarations
79674>>>// 10-17-2003 **WvA: Cleaned up function vSelect_File and added code to destroy the dynamically
79674>>>//                   created file-open dialog
79674>>>// 02-12-2004 **WvA: Allan Ankerstjeme pointed me into a bug for the vCreateTempFileInPath
79674>>>//                   in that it didn't exactly return the correct filename of the file created.
79674>>>//                   This has now been taken care of.
79674>>>// 02-19-2004 **WvA: Removed all API declarations from the package itself to improve readability
79674>>>//                   These declarations are now included from the vWin32fh header file.
79674>>>// 02-19-2004 **WvA: Changed the default way in which the standard file handling works
79674>>>//                   Before today one could always undo the operation, as of now you cannot as
79674>>>//                   the default was a silly one using unnecessary resources (mainly diskspace)
79674>>>//                   Since i don't really expect someone to use that feature it has been removed.
79674>>>//                   One can however restore to the old way of handling by simply calling the
79674>>>//                   vWin32fhCompatibilityMode procedure ONE time before accessing any of the
79674>>>//                   filehandling operations
79674>>>// 02-19-2004 **WvA: The functions ParseFolderName, ParseFileName and ParseFileExtenstion added
79674>>>//                   as well as the StringFromRightOfChar function.
79674>>>// 02-19-2004 **WvA: sfoFormatDisk function added which can use to format a floppydisk
79674>>>//                   DISABLED now as testing shows that it does not work as advertised...
79674>>>// 02-20-2004 **WvA: The function vDDE_Error_Handler didn't pass the errornumber on to the DDE_Error_To_String function
79674>>>//                   Moved the hardcoded strings from vDDE_Error_Handler to define declarations for easier translation later on.
79674>>>// 09-10-2004 **WvA: Added the ToAnsi function to the fileoperations method so that
79674>>>//                   extended characters are treated ok too.
79674>>>//                   Reported by Flemming from
79674>>>// 12-17-2004 **WvA: Changed vFilePathExists to be global, reported by Peter van Mil
79674>>>// 12-28-2004 **WvA: WebApp compatibility added by introducing compiler directives
79674>>>// 03-10-2006 **WvA: Added more CSIDL types to our header file for use with the vSHGetFolderPath function
79674>>>// 01-02-2007 **WvA: Set NoChangeDir_State on vSelect_File and vSelectSaveFile to True but changed it back due to side effects.
79674>>>//                   Added vSelectSavefile function to create a file save dialog
79674>>>//                   Fixed ParseFolderName which was horribly broken (thanks for the reports)
79674>>>//                   Added vParentPath function to retrieve the parent "node" of a path
79674>>>// 01-04-2008 **WvA: Fixed vCreateTempFileInPath as the function wasn't working
79674>>>// 10-04-2009 **WvA: Added vshCreateDirectoryEx from Micheal Mullan, moved filedialogs to cvFileDialogs.pkg
79674>>>// 01-11-2010 **WvA: Added vWin32_APIFilesize as supplied by Renato Villa, to get the filesize of the specified file. See http://support.dataaccess.com/forums/showthread.php?t=41982
79674>>>// 10-02-2011 **WvA: Added vCSIDL_SYSTEMX86, courtesy of Ola Eldoy for pointing this out and providing the define statement.
79674>>>// 20-12-2012 **WvA: Default behavior on copy/move is now to autocreate subfolders, tip by Frank Cheng
79674>>>// 29-09-2014 **WvA: Added function vFolderFileCount to count the number of files in a folder, add vCSIDL_PROGRAM_FILESx86
79674>>>// 04-10-2014 **WvA: Added extra checks on vFilePathExists and vFolderExists courtesy of Nils Svedmyr
79674>>>
79674>>>//Use Case.mac
79674>>>Use File_Dlg.pkg      // Contains OpenDialog class definition
79674>>>Use cvFileDialogs.pkg
Including file: cvFileDialogs.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cvFileDialogs.pkg)
79674>>>>>//***************************************************************************
79674>>>>>//*
79674>>>>>//* Class:        cvSaveAsDialog
79674>>>>>//* Package Name: cvFileDialogs.pkg
79674>>>>>//*
79674>>>>>//***************************************************************************
79674>>>>>
79674>>>>>Use File_dlg.pkg
79674>>>>>
79674>>>>>// *WvA: 13-01-1999 Created
79674>>>>>// The Class cSelectFile_Dialog is created to support the function Select_File
79674>>>>>// This function opens the Windows standard file open dialog and returns the selected
79674>>>>>// file_name.
79674>>>>>Class cvSelectFile_Dialog Is An OpenDialog
79675>>>>>
79675>>>>>  Procedure Construct_Object Integer iImage_Id
79677>>>>>    Forward Send Construct_Object iImage_Id
79679>>>>>    Set HideReadOnly_State To True
79680>>>>>  End_Procedure // Construct_Object
79681>>>>>
79681>>>>>  Function SelectedFileName Returns String
79683>>>>>    String sFileName
79683>>>>>    Move "" To sFileName
79684>>>>>    If (Show_Dialog(Self)) Begin
79686>>>>>      Move (RTrim(File_Name(Self))) To sFileName
79687>>>>>    End
79687>>>>>>
79687>>>>>    Function_Return sFileName
79688>>>>>  End_Function // SelectedFileName
79689>>>>>End_Class // cvSelectFile_Dialog
79690>>>>>
79690>>>>>
79690>>>>>// *WvA: 13-01-1999 Created
79690>>>>>// This function opens the Windows standard file open dialog and returns the selected
79690>>>>>// file_name. Returns '' if the user didn't make a selection.
79690>>>>>// **WvA: 17-10-2003 Cleaned up and added code to destroy the dynamically created
79690>>>>>//                   file-open dialog
79690>>>>>Function vSelect_File Global String sSupportedFileTypes String sCaptionText String sInitialFolder Returns String
79692>>>>>  String sSelectedFile
79692>>>>>  Integer hoOpenFileDialog
79692>>>>>
79692>>>>>  Object oOpenFileDialog Is A cvSelectFile_Dialog
79694>>>>>
79694>>>>>    Set Dialog_Caption    To sCaptionText
79695>>>>>    Set Filter_String     To sSupportedFileTypes
79696>>>>>    Set Initial_Folder    To sInitialFolder
79697>>>>>
79697>>>>>    Move Self       To hoOpenFileDialog
79698>>>>>  End_Object // oOpenFileDialog
79699>>>>>
79699>>>>>  Get SelectedFileName Of hoOpenFileDialog To sSelectedFile
79700>>>>>  Send Destroy_Object To hoOpenFileDialog
79701>>>>>  Function_Return sSelectedFile
79702>>>>>End_Function // vSelect_File
79703>>>>>
79703>>>>>
79703>>>>>Class cvSaveAsDialog is a SaveAsDialog
79704>>>>>
79704>>>>>  Procedure Construct_Object
79706>>>>>    Forward Send Construct_Object
79708>>>>>    Set HideReadOnly_State To True
79709>>>>>  End_Procedure // Construct_Object
79710>>>>>
79710>>>>>  Function SelectedFileName Returns String
79712>>>>>    String sFileName
79712>>>>>    Move "" To sFileName
79713>>>>>    If (Show_Dialog(Self)) Begin
79715>>>>>      Move (RTrim(File_Name(Self))) To sFileName
79716>>>>>    End
79716>>>>>>
79716>>>>>    Function_Return sFileName
79717>>>>>  End_Function // SelectedFileName
79718>>>>>
79718>>>>>End_Class // cvSaveAsDialog
79719>>>>>
79719>>>>>// Added optional default filename as suggested by Nils
79719>>>>>Function vSelectSaveFile Global String sSupportedFileTypes String sCaptionText String sInitialFolder String sDefaultFileName Returns String
79721>>>>>  String sSelectedFile
79721>>>>>  Integer hoDialog
79721>>>>>
79721>>>>>  Move "" To sSelectedFile
79722>>>>>  Get Create U_cvSaveAsDialog To hoDialog
79723>>>>>  If (hoDialog) Begin
79725>>>>>    //Set NoChangeDir_State Of hoDialog To True
79725>>>>>    Set Dialog_Caption    Of hoDialog To sCaptionText
79726>>>>>    Set Filter_String     Of hoDialog To sSupportedFileTypes
79727>>>>>    Set Initial_Folder    Of hoDialog To sInitialFolder
79728>>>>>    If (Num_Arguments = 4) Begin
79730>>>>>      Set File_Title        of hoDialog to sDefaultFileName
79731>>>>>    End
79731>>>>>>
79731>>>>>    Get SelectedFileName  Of hoDialog To sSelectedFile
79732>>>>>    Send Destroy Of hoDialog
79733>>>>>  End
79733>>>>>>
79733>>>>>  Function_Return sSelectedFile
79734>>>>>End_Function // vSelectSaveFile
79735>>>Use Seq_chnl.pkg
79735>>>
79735>>>Use Windows.pkg
79735>>>//Use Dferror
79735>>>Use Dll.pkg
79735>>>Use vWin32fh.h       // Header file with WinAPI declarations
Including file: vwin32fh.h    (C:\Projects\DF18\DbUpdateFramework\AppSrc\vwin32fh.h)
79735>>>>>//TH-Header
79735>>>>>//*****************************************************************************************
79735>>>>>// Copyright (c)  2004 KURANT Project
79735>>>>>// All rights reserved.
79735>>>>>//
79735>>>>>// $FileName    : G:\Projects\vWin32fh\vWin32fh.h
79735>>>>>// $ProjectName : Windows 32 bits file handling
79735>>>>>// $Authors     : Wil van Antwerpen
79735>>>>>// $Created     : 19.02.2004  19:25
79735>>>>>// $Type        : BSD (as in do with it whatever you like)
79735>>>>>//
79735>>>>>// Contents:
79735>>>>>//  This file contains the Windows API external function call definitions and
79735>>>>>//  constants as they are used in the vWin32fh package.
79735>>>>>//*****************************************************************************************
79735>>>>>//TH-RevisionStart
79735>>>>>//TH-RevisionEnd
79735>>>>>
79735>>>>>Define CS_DDE_ERR_FILE_NOT_FOUND  For "The specified file was not found.\n"
79735>>>>>Define CS_DDE_ERR_PATH_NOT_FOUND  For "The specified path was not found.\n"
79735>>>>>Define CS_DDE_ERR_BAD_FORMAT      For "The .EXE file is invalid.\n"
79735>>>>>Define CS_DDE_ERR_ACCESSDENIED    For "The operating system denied access to the specified file.\n"
79735>>>>>Define CS_DDE_ERR_ASSOCINCOMPLETE For "The filename association is incomplete or invalid.\n"
79735>>>>>Define CS_DDE_ERR_DDEBUSY         For "The DDE transaction could not be completed because other DDE\ntransactions were being processed.\n"
79735>>>>>Define CS_DDE_ERR_DDEFAIL         For "The DDE transaction failed.\n"
79735>>>>>Define CS_DDE_ERR_DDETIMEOUT      For "The DDE transaction could not be completed,\nbecause the request timed out.\n"
79735>>>>>Define CS_DDE_ERR_DLLNOTFOUND     For "The specified dynamic-link library was not found.\n"
79735>>>>>Define CS_DDE_ERR_NOASSOC         For "There is no application associated with the given filename extension.\n"
79735>>>>>Define CS_DDE_ERR_OOM             For "There is not enough free memory available to complete the operation.\n"
79735>>>>>Define CS_DDE_ERR_PNF             For "The specified path was not found.\n"
79735>>>>>Define CS_DDE_ERR_SHARE           For "A sharing violation occurred.\n"
79735>>>>>Define CS_DDE_ERR_UNKNOWN_LINE1   For "Unknown DDE-error occurred.\nErrornumber"
79735>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
79735>>>>>Define CS_DDE_ERR_HANDL_PAKTC     For "\nPress a key to continue...\n\n"
79735>>>>>Define CS_DDE_ERR_HANDL_CAPTION   For "a DDE-error occurred"
79735>>>>>
79735>>>>>
79735>>>>>Define vMax_Path     For |CI260
79735>>>>>Define vMinChar      For |CI$80
79735>>>>>Define vMaxChar      For |CI$7F
79735>>>>>Define vMinShort     For |CI$8000
79735>>>>>Define vMaxShort     For |CI$7FFF
79735>>>>>Define vMinLong      For |CI$80000000
79735>>>>>Define vMaxLong      For |CI$7FFFFFFF
79735>>>>>Define vMaxByte      For |CI$FF
79735>>>>>Define vMaxWord      For |CI$FFFF
79735>>>>>Define vMaxDword     For |CI$FFFFFFFF
79735>>>>>
79735>>>>>
79735>>>>>
79735>>>>>// For FindFirstFile
79735>>>>>Define vINVALID_HANDLE_VALUE   For |CI-1
79735>>>>>Define vINVALID_FILE_SIZE      For |CI$FFFFFFFF
79735>>>>>Define vERROR_NO_MORE_FILES    For |CI18
79735>>>>>
79735>>>>>// The defines below can be used to find out what kind of error has occurred if
79735>>>>>// the API-call ShellExecute is used.
79735>>>>>Define vERROR_FILE_NOT_FOUND   For |CI0002
79735>>>>>Define vERROR_PATH_NOT_FOUND   For |CI0003
79735>>>>>Define vERROR_BAD_FORMAT       For |CI0011
79735>>>>>Define vSE_ERR_ACCESSDENIED    For |CI0005
79735>>>>>Define vSE_ERR_ASSOCINCOMPLETE For |CI0027
79735>>>>>Define vSE_ERR_DDEBUSY         For |CI0030
79735>>>>>Define vSE_ERR_DDEFAIL         For |CI0029
79735>>>>>Define vSE_ERR_DDETIMEOUT      For |CI0028
79735>>>>>Define vSE_ERR_DLLNOTFOUND     For |CI0032
79735>>>>>Define vSE_ERR_FNF             For |CI0002
79735>>>>>Define vSE_ERR_NOASSOC         For |CI0031
79735>>>>>Define vSE_ERR_OOM             For |CI0008
79735>>>>>Define vSE_ERR_PNF             For |CI0003
79735>>>>>Define vSE_ERR_SHARE           For |CI0026
79735>>>>>
79735>>>>>
79735>>>>>// C-Structure
79735>>>>>//typedef struct _browseinfo {
79735>>>>>//    HWND hwndOwner;
79735>>>>>//    LPCITEMIDLIST pidlRoot;
79735>>>>>//    LPSTR pszDisplayName;
79735>>>>>//    LPCSTR lpszTitle;
79735>>>>>//    UINT ulFlags;
79735>>>>>//    BFFCALLBACK lpfn;
79735>>>>>//    LPARAM lParam;
79735>>>>>//    int iImage;
79735>>>>>//} BROWSEINFO, *PBROWSEINFO, *LPBROWSEINFO;
79735>>>>>
79735>>>>>//declare C structure struct_browseinfo
79735>>>>>//as documented in MSDN under Windows Shell API
79735>>>>>Type vtBrowseInfo
79735>>>>>  Field vtBrowseInfo.hWndOwner      as Handle
79735>>>>>  Field vtBrowseInfo.pIDLRoot       as Pointer
79735>>>>>  Field vtBrowseInfo.pszDisplayName as Pointer
79735>>>>>  Field vtBrowseInfo.lpszTitle      as Pointer
79735>>>>>  Field vtBrowseInfo.ulFlags        as dWord
79735>>>>>  Field vtBrowseInfo.lpfnCallback   as Pointer
79735>>>>>  Field vtBrowseInfo.lParam         as dWord
79735>>>>>  Field vtBrowseInfo.iImage         as dWord
79735>>>>>End_Type // tBrowseInfo
79735>>>>>
79735>>>>>// Browsing for directory.
79735>>>>>Define vBIF_RETURNONLYFSDIRS   For |CI$0001  // For finding a folder to start document searching
79735>>>>>Define vBIF_DONTGOBELOWDOMAIN  For |CI$0002  // For starting the Find Computer
79735>>>>>Define vBIF_STATUSTEXT         For |CI$0004  // Includes a status area in the dialog box.
79735>>>>>                                            // The callback function can set the status text by
79735>>>>>                                            // sending messages to the dialog box.
79735>>>>>Define vBIF_RETURNFSANCESTORS  For |CI$0008  // Only returns file system ancestors.
79735>>>>>
79735>>>>>Define vBIF_BROWSEFORCOMPUTER  For |CI$1000  // Browsing for Computers.
79735>>>>>Define vBIF_BROWSEFORPRINTER   For |CI$2000  // Browsing for Printers
79735>>>>>
79735>>>>>// message from browser
79735>>>>>//Define BFFM_INITIALIZED        1
79735>>>>>//Define BFFM_SELCHANGED         2
79735>>>>>
79735>>>>>// messages to browser
79735>>>>>//Define BFFM_SETSTATUSTEXT      (WM_USER + 100)
79735>>>>>//Define BFFM_ENABLEOK           (WM_USER + 101)
79735>>>>>//Define BFFM_SETSELECTION       (WM_USER + 102)
79735>>>>>
79735>>>>>
79735>>>>>External_function vWin32_SHBrowseForFolder "SHBrowseForFolder" shell32.dll ;  Pointer lpsBrowseInfo Returns dWord
79736>>>>>
79736>>>>>External_function vWin32_SHGetPathFromIDList "SHGetPathFromIDList" shell32.dll ;  Pointer pidList Pointer lpBuffer Returns dWord
79737>>>>>
79737>>>>>External_function vWin32_CoTaskMemFree "CoTaskMemFree" ole32.dll Pointer pV Returns Integer
79738>>>>>
79738>>>>>
79738>>>>>
79738>>>>>
79738>>>>>Type vtSecurity_attributes
79738>>>>>  Field vtSecurity_attributes.nLength        as dWord
79738>>>>>  Field vtSecurity_attributes.lpDescriptor   as Pointer
79738>>>>>  Field vtSecurity_attributes.bInheritHandle as Integer
79738>>>>>End_Type // vtSecurity_attributes
79738>>>>>
79738>>>>>//nLength:
79738>>>>>// Specifies the size, in bytes, of this structure. Set this value to the size of the
79738>>>>>// SECURITY_ATTRIBUTES structure.
79738>>>>>// Windows NT: Some functions that use the SECURITY_ATTRIBUTES structure do not verify the
79738>>>>>// value of the nLength member. However, an application should still set it properly.
79738>>>>>// That ensures current, future, and cross-platform compatibility.
79738>>>>>//
79738>>>>>//lpSecurityDescriptor:
79738>>>>>// Points to a security descriptor for the object that controls the sharing of it.
79738>>>>>// If NULL is specified for this member, the object may be assigned the default security
79738>>>>>// descriptor of the calling process.
79738>>>>>//
79738>>>>>//bInheritHandle:
79738>>>>>// Specifies whether the returned handle is inherited when a new process is created.
79738>>>>>// If this member is TRUE, the new process inherits the handle.
79738>>>>>
79738>>>>>
79738>>>>>// BOOL CreateDirectory(
79738>>>>>//    LPCTSTR lpPathName,
79738>>>>>//    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // pointer to a security descriptor
79738>>>>>//   );
79738>>>>>//
79738>>>>>// lpPathName
79738>>>>>//  Points to a null-terminated string that specifies the path of the directory
79738>>>>>//  to be created.
79738>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
79738>>>>>//  This limit is related to how the CreateDirectory function parses paths.
79738>>>>>// lpSecurityAttributes
79738>>>>>//  Pointer to a SECURITY_ATTRIBUTES structure als called a security descriptor that
79738>>>>>//  determines whether the returned handle can be inherited by child processes.
79738>>>>>//  If lpSecurityAttributes is NULL, the handle cannot be inherited.
79738>>>>>// Returns:
79738>>>>>//  If the function succeeds, the return value is nonzero.
79738>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
79738>>>>>External_function vWin32_CreateDirectory "CreateDirectoryA" kernel32.dll ;  Pointer lpPathName Pointer lpSecurity_Attributes Returns Integer
79739>>>>>
79739>>>>>
79739>>>>>// lpPathName
79739>>>>>//  Points to a null-terminated string that specifies the path of the directory
79739>>>>>//  to be removed.
79739>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
79739>>>>>// Returns:
79739>>>>>//  If the function succeeds, the return value is nonzero.
79739>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
79739>>>>>External_function vWin32_RemoveDirectory "RemoveDirectoryA" kernel32.dll ;  Pointer lpPathName Returns Integer
79740>>>>>
79740>>>>>
79740>>>>>
79740>>>>>// The ShellExecute function opens or prints a specified file. The file can be an
79740>>>>>// executable file or a document file.
79740>>>>>//
79740>>>>>// Operation can be one of the following:
79740>>>>>//    "OPEN"  The function opens the file specified by lpFile.
79740>>>>>//            The file can be an executable file or a document file.
79740>>>>>//            The file can be a folder to open.
79740>>>>>//    "PRINT" The function prints the file specified by lpFile.
79740>>>>>//            The file should be a document file. If the file is an executable file,
79740>>>>>//            the function opens the file, as if "open" had been specified.
79740>>>>>//  "EXPLORE" The function explores the folder specified by lpFile.
79740>>>>>//
79740>>>>>// Return Values:
79740>>>>>//
79740>>>>>// If the function succeeds, the return value is the instance handle of the application that
79740>>>>>// was run, or the handle of a dynamic data exchange (DDE) server application.
79740>>>>>// If the function fails, the return value is an error value that is less than or equal to 32.
79740>>>>>//
79740>>>>>// The following table lists these error values:
79740>>>>>// Public Const ERROR_FILE_NOT_FOUND = 2&
79740>>>>>// Public Const ERROR_PATH_NOT_FOUND = 3&
79740>>>>>// Public Const ERROR_BAD_FORMAT = 11&
79740>>>>>// Public Const SE_ERR_ACCESSDENIED = 5
79740>>>>>// Public Const SE_ERR_ASSOCINCOMPLETE = 27
79740>>>>>// Public Const SE_ERR_DDEBUSY = 30
79740>>>>>// Public Const SE_ERR_DDEFAIL = 29
79740>>>>>// Public Const SE_ERR_DDETIMEOUT = 28
79740>>>>>// Public Const SE_ERR_DLLNOTFOUND = 32
79740>>>>>// Public Const SE_ERR_FNF = 2
79740>>>>>// Public Const SE_ERR_NOASSOC = 31
79740>>>>>// Public Const SE_ERR_OOM = 8
79740>>>>>// Public Const SE_ERR_PNF = 3
79740>>>>>// Public Const SE_ERR_SHARE = 26
79740>>>>>
79740>>>>>
79740>>>>>
79740>>>>>// Code to open the program that is associated with the selected file.
79740>>>>>//
79740>>>>>// External function call used in Procedure DoStartDocument
79740>>>>>External_function vWin32_ShellExecute "ShellExecuteA" shell32.dll ;  Handle hWnd ;  Pointer lpOperation ;  Pointer lpFile ;  Pointer lpParameters ;  Pointer lpDirectory ;  Dword iShowCmd Returns Handle
79741>>>>>
79741>>>>>
79741>>>>>
79741>>>>>
79741>>>>>
79741>>>>>                                          // Must be freed using SHFreeNameMappings
79741>>>>>
79741>>>>>Type vtShFileOpStruct
79741>>>>>  Field vtShFileOpStruct.hWnd                   as Handle
79741>>>>>  Field vtShFileOpStruct.wFunc                  as Integer
79741>>>>>  Field vtShFileOpStruct.pFrom                  as Pointer
79741>>>>>  Field vtShFileOpStruct.pTo                    as Pointer
79741>>>>>  Field vtShFileOpStruct.fFlags                 as Short
79741>>>>>  Field vtShFileOpStruct.fAnyOperationsAborted  as Short
79741>>>>>  Field vtShFileOpStruct.hNameMappings          as Pointer
79741>>>>>  Field vtShFileOpStruct.lpszProgressTitle      as Pointer // only used if FOF_SIMPLEPROGRESS
79741>>>>>End_Type // tShFileOpStruct
79741>>>>>
79741>>>>>// hwnd
79741>>>>>//   Handle of the dialog box to use to display information about the status of the operation.
79741>>>>>
79741>>>>>// wFunc
79741>>>>>//   Operation to perform. This member can be one of the following values:
79741>>>>>//     FO_COPY     Copies the files specified by pFrom to the location specified by pTo.
79741>>>>>//     FO_DELETE   Deletes the files specified by pFrom (pTo is ignored).
79741>>>>>//     FO_MOVE     Moves the files specified by pFrom to the location specified by pTo.
79741>>>>>//     FO_RENAME   Renames the files specified by pFrom.
79741>>>>>
79741>>>>>// pFrom
79741>>>>>//   Pointer to a buffer that specifies one or more source file names. Multiple names must
79741>>>>>//   be null-separated. The list of names must be double null-terminated.
79741>>>>>
79741>>>>>// pTo
79741>>>>>//   Pointer to a buffer that contains the name of the destination file or directory. The
79741>>>>>//   buffer can contain mutiple destination file names if the fFlags member specifies
79741>>>>>//   FOF_MULTIDESTFILES. Multiple names must be null-separated. The list of names must be
79741>>>>>//   double null-terminated.
79741>>>>>
79741>>>>>// fAnyOperationsAborted
79741>>>>>//   Value that receives TRUE if the user aborted any file operations before they
79741>>>>>//   were completed or FALSE otherwise.
79741>>>>>
79741>>>>>
79741>>>>>// Performs a copy, move, rename, or delete operation on a file system object.
79741>>>>>// This can be a file or a folder.
79741>>>>>// With thanks to Andrew S Kaplan
79741>>>>>External_function vWin32_SHFileOperation "SHFileOperationA" Shell32.dll ;        Pointer lpFileOp Returns Integer
79742>>>>>
79742>>>>>
79742>>>>>// Thanks To Oliver Nelson for posting this code on the newsgroups
79742>>>>>External_function vWin32_GetWindowsDirectory "GetWindowsDirectoryA" kernel32.dll ;                           Pointer lpBuffer Integer nSize Returns Integer
79743>>>>>
79743>>>>>
79743>>>>>
79743>>>>>// Courtesy Of Vincent Oorsprong
79743>>>>>//External_Function vWin32_GetTempFileName "GetTempFileNameA" Kernel32.Dll ;
79743>>>>>//   Pointer lpPathName ;
79743>>>>>//   Pointer lpPrefixString ;
79743>>>>>//   Integer uUnique ;
79743>>>>>//   Pointer lpTempFileName ;
79743>>>>>//   Returns Integer
79743>>>>>// **WvA: 28-04-2005 Changed string parameter type into pointers
79743>>>>>External_function vWin32_GetTempFileName "GetTempFileNameA" kernel32.dll Pointer lpsPath ;        Pointer lpsPrefix Integer iUnique Pointer pLoad Returns Integer
79744>>>>>
79744>>>>>External_function vWin32_GetTempPath "GetTempPathA" Kernel32.Dll ;   Dword nBufferLength ;   Pointer lpBuffer ;   Returns Integer
79745>>>>>
79745>>>>>External_function vWin32_DeleteFile "DeleteFileA" Kernel32.Dll ;   Pointer lpFileName ;   Returns Integer
79746>>>>>                  
79746>>>>>// from:
79746>>>>>// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/shell/reference/enums/csidl.asp
79746>>>>>//
79746>>>>>Define vCSIDL_FLAG_CREATE       For |CI$8000 // IE5+, use this to create a special folder
79746>>>>>Define vCSIDL_ADMIN_TOOLS       For |CI$0030 // IE5+, The file system directory that is used to store administrative tools for an individual user
79746>>>>>Define vCSIDL_ALT_STARTUP       For |CI$001D // The file system directory that corresponds to the user's nonlocalized Startup program group
79746>>>>>Define vCSIDL_APPDATA           For |CI$001A // Version 4.71. The file system directory that serves as a common repository for application-specific data. A typical path is C:\Documents and Settings\<username>\Application Data
79746>>>>>Define vCSIDL_BITBUCKET         For |CI$000A // The virtual folder containing the objects in the user's Recycle Bin
79746>>>>>Define vCSIDL_CDBURN_AREA       For |CI$003B // IE6+ The file system directory acting as a staging area for files waiting to be written to CD. A typical path is C:\Documents and Settings\<username>\Local Settings\Application Data\Microsoft\CD Burning
79746>>>>>Define vCSIDL_COMMON_ADMINTOOLS For |CI$002F // IE5+ The file system directory containing administrative tools for all users of the computer
79746>>>>>Define vCSIDL_COMMON_ALTSTARTUP For |CI$001E // The file system directory that corresponds to the nonlocalized Startup program group for all users
79746>>>>>Define vCSIDL_COMMON_APPDATA    For |CI$0023 // IE5+ The file system directory containing application data for all users. A typical path is C:\Documents and Settings\All Users\Application Data
79746>>>>>Define vCSIDL_COMMON_DESKTOPDIRECTORY for |CI$0019 // WinNT+ Only, The file system directory that contains files and folders that appear on the desktop for all users. A typical path is C:\Documents and Settings\All Users\Desktop
79746>>>>>Define vCSIDL_COMMON_DOCUMENTS  For |CI$002E // IE5+ The file system directory that contains documents that are common to all users. A typical paths is C:\Documents and Settings\All Users\Documents
79746>>>>>Define vCSIDL_COMMON_FAVORITES  For |CI$001F // The file system directory that serves as a common repository for favorite items common to all users
79746>>>>>Define vCSIDL_COMMON_MUSIC      For |CI$0035 // IE6+ The file system directory that serves as a repository for music files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Music
79746>>>>>Define vCSIDL_COMMON_PICTURES   For |CI$0036 // The file system directory that serves as a repository for image files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Pictures
79746>>>>>Define vCSIDL_COMMON_PROGRAMS   For |CI$0017 // WinNT+ The file system directory that contains the directories for the common program groups that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs
79746>>>>>Define vCSIDL_COMMON_STARTMENU  For |CI$0016 // WinNT+ The file system directory that contains the programs and folders that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu
79746>>>>>Define vCSIDL_COMMON_STARTUP    For |CI$0018 // WinNT+ The file system directory that contains the programs that appear in the Startup folder for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs\Startup
79746>>>>>Define vCSIDL_COMMON_TEMPLATES  For |CI$002D // WinNT+ The file system directory that contains the templates that are available to all users. A typical path is C:\Documents and Settings\All Users\Templates
79746>>>>>Define vCSIDL_COMMON_VIDEO      For |CI$0037 // IE6+ The file system directory that serves as a repository for video files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Videos
79746>>>>>Define vCSIDL_COMPUTERSNEARME   For |CI$003D // The folder representing other machines in your workgroup
79746>>>>>Define vCSIDL_CONNECTIONS       For |CI$0031 // The virtual folder representing Network Connections, containing network and dial-up connections
79746>>>>>Define vCSIDL_CONTROLS          For |CI$0003 // The virtual folder containing icons for the Control Panel applications
79746>>>>>Define vCSIDL_COOKIES           For |CI$0021 // The file system directory that serves as a common repository for Internet cookies. A typical path is C:\Documents and Settings\username\Cookies
79746>>>>>Define vCSIDL_DESKTOP           For |CI$0000 // The virtual folder representing the Windows desktop, the root of the namespace
79746>>>>>Define vCSIDL_DESKTOPDIRECTORY  For |CI$0010 // The file system directory used to physically store file objects on the desktop (not to be confused with the desktop folder itself). A typical path is C:\Documents and Settings\username\Desktop
79746>>>>>Define vCSIDL_DRIVES            For |CI$0011 // The virtual folder representing My Computer, containing everything on the local computer: storage devices, printers, and Control Panel. The folder may also contain mapped network drives
79746>>>>>Define vCSIDL_FAVORITES         For |CI$0006 // The file system directory that serves as a common repository for the user's favorite items. A typical path is C:\Documents and Settings\username\Favorites
79746>>>>>Define vCSIDL_FONTS             For |CI$0014 // A virtual folder containing fonts. A typical path is C:\Windows\Fonts
79746>>>>>Define vCSIDL_HISTORY           For |CI$0022 // The file system directory that serves as a common repository for Internet history items
79746>>>>>Define vCSIDL_INTERNET          For |CI$0001 // A virtual folder representing the Internet
79746>>>>>Define vCSIDL_INTERNET_CACHE    For |CI$0020 // Comctl4.72+, The file system directory that serves as a common repository for temporary Internet files. A typical path is C:\Documents and Settings\username\Local Settings\Temporary Internet Files
79746>>>>>Define vCSIDL_LOCAL_APPDATA     For |CI$001C // IE5+ The file system directory that serves as a data repository for local (nonroaming) applications. A typical path is C:\Documents and Settings\username\Local Settings\Application Data
79746>>>>>Define vCSIDL_MYDOCUMENTS       For |CI$000C // IE6+ The virtual folder representing the My Documents desktop item
79746>>>>>Define vCSIDL_MYMUSIC           For |CI$000D // The file system directory that serves as a common repository for music files. A typical path is C:\Documents and Settings\User\My Documents\My Music
79746>>>>>Define vCSIDL_MYPICTURES        For |CI$0027 // IE5+ The file system directory that serves as a common repository for image files. A typical path is C:\Documents and Settings\username\My Documents\My Pictures
79746>>>>>Define vCSIDL_MYVIDEO           For |CI$000E // IE6+ The file system directory that serves as a common repository for video files. A typical path is C:\Documents and Settings\username\My Documents\My Videos
79746>>>>>Define vCSIDL_NETHOOD           For |CI$0013 // A file system directory containing the link objects that may exist in the My Network Places virtual folder. It is not the same as CSIDL_NETWORK, which represents the network namespace root. A typical path is C:\Documents and Settings\username\NetHood
79746>>>>>Define vCSIDL_NETWORK           For |CI$0012 // A virtual folder representing Network Neighborhood, the root of the network namespace hierarchy
79746>>>>>Define vCSIDL_PERSONAL          For |CI$0005 // (Documents folder) IE6 The virtual folder representing the My Documents desktop item.
79746>>>>>                                             // This is equivalent to CSIDL_MYDOCUMENTS. Previous to Version 6.0. The file system directory used to physically store a user's common repository of documents. A typical path is C:\Documents and Settings\username\My Documents
79746>>>>>Define vCSIDL_PHOTOALBUMS       For |CI$0045 // Vista+ The virtual folder used to store photo albums, typically username\My Pictures\Photo Albums
79746>>>>>Define vCSIDL_PLAYLISTS         For |CI$003F // Vista+ The virtual folder used to store play albums, typically username\My Music\Playlists
79746>>>>>Define vCSIDL_PRINTERS          For |CI$0004 // The virtual folder containing installed printers
79746>>>>>Define vCSIDL_PRINTHOOD         For |CI$001B // The file system directory that contains the link objects that can exist in the Printers virtual folder. A typical path is C:\Documents and Settings\username\PrintHood
79746>>>>>Define vCSIDL_PROFILE           For |CI$0028 // IE5+ The user's profile folder. A typical path is C:\Documents and Settings\username
79746>>>>>Define vCSIDL_PROGRAM_FILES     For |CI$0026 // IE5+ The Program Files folder. A typical path is C:\Program Files
79746>>>>>Define vCSIDL_PROGRAM_FILESx86  for |CI$002A // The Program Files folder for x86 programs. A typical path is C:\Program Files (x86)
79746>>>>>Define vCSIDL_PROGRAM_FILES_COMMON For |CI$002B // IE5+, WinNT+ A folder for components that are shared across applications. A typical path is C:\Program Files\Common
79746>>>>>Define vCSIDL_PROGRAMS          For |CI$0002 // The file system directory that contains the user's program groups (which are themselves file system directories). A typical path is C:\Documents and Settings\username\Start Menu\Programs
79746>>>>>Define vCSIDL_RECENT            For |CI$0008 // The file system directory that contains shortcuts to the user's most recently used documents. A typical path is C:\Documents and Settings\username\My Recent Documents
79746>>>>>Define vCSIDL_RESOURCES         For |CI$0038 // undocumented
79746>>>>>Define vCSIDL_SAMPLE_MUSIC      For |CI$0040 // Vista+, The file system directory that contains sample music. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Music
79746>>>>>Define vCSIDL_SAMPLE_PLAYLISTS  For |CI$0041 // Vista+, The file system directory that contains sample playlists. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Playlists
79746>>>>>Define vCSIDL_SAMPLE_PICTURES   For |CI$0042 // Vista+, The file system directory that contains sample pictures. A typical path is C:\Documents and Settings\username\My Documents\My Pictures\Sample Pictures
79746>>>>>Define vCSIDL_SAMPLE_VIDEOS     For |CI$0043 // Vista+, The file system directory that contains sample videos. A typical path is C:\Documents and Settings\username\My Documents\My Videos\Sample Videos
79746>>>>>Define vCSIDL_SENDTO            For |CI$0009 // The file system directory that contains Send To menu items. A typical path is C:\Documents and Settings\username\SendTo
79746>>>>>Define vCSIDL_STARTMENU         For |CI$000B // The file system directory containing Start menu items. A typical path is C:\Documents and Settings\username\Start Menu
79746>>>>>Define vCSIDL_STARTUP           For |CI$0007 // The file system directory that corresponds to the user's Startup program group. The system starts these programs whenever any user logs onto Windows NT or starts Windows 95. A typical path is C:\Documents and Settings\username\Start Menu\Programs\Startup
79746>>>>>Define vCSIDL_SYSTEM            For |CI$0025 // The Windows System folder. A typical path is C:\Windows\System32
79746>>>>>Define vCSIDL_SYSTEMX86         For |CI$0029 //
79746>>>>>Define vCSIDL_TEMPLATES         For |CI$0015 // The file system directory that serves as a common repository for document templates. A typical path is C:\Documents and Settings\username\Templates
79746>>>>>Define vCSIDL_WINDOWS           For |CI$0024 // The Windows directory or SYSROOT. This corresponds to the %windir% or %SYSTEMROOT% environment variables. A typical path is C:\Windows
79746>>>>>
79746>>>>>
79746>>>>>//HRESULT SHGetFolderPath(
79746>>>>>//    HWND hwndOwner,
79746>>>>>//    int nFolder,
79746>>>>>//    HANDLE hToken,
79746>>>>>//    DWORD dwFlags,
79746>>>>>//    LPTSTR pszPath
79746>>>>>//);
79746>>>>>// This function is a superset of SHGetSpecialFolderPath, included with earlier versions of
79746>>>>>// the shell. It is implemented in a redistributable DLL, SHFolder.dll, that also simulates
79746>>>>>// many of the new shell folders on older platforms such as Windows 95, Windows 98, and
79746>>>>>// Windows NT 4.0. This DLL always calls the current platform's version of this function.
79746>>>>>// If that fails, it will try to simulate the appropriate behavior.
79746>>>>>//
79746>>>>>External_function vWin32_SHGetFolderPath "SHGetFolderPathA" SHFolder.Dll ;   Pointer hWnd ;   Integer nFolder ;   Pointer hToken ;   DWord   dwFlags ;   Pointer lpszPath ;   Returns Integer
79747>>>>>
79747>>>>>
79747>>>>>
79747>>>>>Type vWin32_Find_Data
79747>>>>>  Field vWin32_Find_Data.dwFileAttributes As Dword
79747>>>>>  Field vWin32_Find_Data.ftCreationLowDateTime As Dword
79747>>>>>  Field vWin32_Find_Data.ftCreationHighDateTime As Dword
79747>>>>>  Field vWin32_Find_Data.ftLastAccessLowDateTime As dword
79747>>>>>  Field vWin32_Find_Data.ftLastAccessHighDateTime As Dword
79747>>>>>  Field vWin32_Find_Data.ftLastWriteLowDateTime As Dword
79747>>>>>  Field vWin32_Find_Data.ftLastWriteHighDateTime As Dword
79747>>>>>  Field vWin32_Find_Data.nFileSizeHigh As Dword
79747>>>>>  Field vWin32_Find_Data.nFileSizeLow As Dword
79747>>>>>  Field vWin32_Find_Data.dwReserved0 As Dword
79747>>>>>  Field vWin32_Find_Data.dwReserved1 As Dword
79747>>>>>  Field vWin32_Find_Data.cFileName As Char vMax_Path
79747>>>>>  Field vWin32_Find_Data.cAlternateFileName As Char 14
79747>>>>>End_Type // vWin32_Find_Data
79747>>>>>
79747>>>>>// Courtesy Of Vincent Oorsprong
79747>>>>>// lpFileName      : address of name of file to search for
79747>>>>>// lpFindFileData  : address of returned information
79747>>>>>External_function vWin32_FindFirstFile "FindFirstFileA"  Kernel32.dll Pointer lpFileName ;          Pointer lpFindFileData Returns Handle
79748>>>>>
79748>>>>>// Courtesy Of Vincent Oorsprong
79748>>>>>// hFindFile       : handle of search
79748>>>>>// lpFindFileData  : address of structure for data on found file
79748>>>>>External_function vWin32_FindNextFile "FindNextFileA" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
79749>>>>>
79749>>>>>// Courtesy Of Vincent Oorsprong
79749>>>>>//  hFindFile      : file search handle
79749>>>>>External_function vWin32_FindClose "FindClose" Kernel32.dll Handle hFindFile Returns Integer
79750>>>>>
79750>>>>>
79750>>>>>
79750>>>>>Type vFileTime
79750>>>>>  Field vFileTime.dwLowDateTime As Dword
79750>>>>>  Field vFileTime.dwHighDateTime As Dword
79750>>>>>End_Type // vFileTime
79750>>>>>
79750>>>>>
79750>>>>>Type vSystemTime
79750>>>>>  Field vSystemTime.wYear As Word
79750>>>>>  Field vSystemTime.wMonth As Word
79750>>>>>  Field vSystemTime.wDayOfWeek As Word
79750>>>>>  Field vSystemTime.wDay As Word
79750>>>>>  Field vSystemTime.wHour As Word
79750>>>>>  Field vSystemTime.wMinute As Word
79750>>>>>  Field vSystemTime.wSecond As Word
79750>>>>>  Field vSystemTime.wMilliSeconds As Word
79750>>>>>End_Type // vSystemTime
79750>>>>>
79750>>>>>
79750>>>>>// Courtesy Of Vincent Oorsprong
79750>>>>>//  lpFileTime     : pointer to file time to convert
79750>>>>>//  lpSystemTime   : pointer to structure to receive system time
79750>>>>>External_function vWin32_FileTimeToSystemTime "FileTimeToSystemTime" Kernel32.Dll ;          Pointer lpFileTime Pointer lpsystemTime Returns Integer
79751>>>>>
79751>>>>>// Courtesy Of Vincent Oorsprong
79751>>>>>// This function formats the time in a picture-string passed
79751>>>>>//
79751>>>>>// Picture      Meaning
79751>>>>>//    h         Hours with no leading zero for single-digit hours; 12-hour clock
79751>>>>>//    hh        Hours with leading zero for single-digit hours; 12-hour clock
79751>>>>>//    H         Hours with no leading zero for single-digit hours; 24-hour clock
79751>>>>>//    HH        Hours with leading zero for single-digit hours; 24-hour clock
79751>>>>>//    m         Minutes with no leading zero for single-digit minutes
79751>>>>>//    mm        Minutes with leading zero for single-digit minutes
79751>>>>>//    s         Seconds with no leading zero for single-digit seconds
79751>>>>>//    ss        Seconds with leading zero for single-digit seconds
79751>>>>>//    t         One character time marker string, such as A or P
79751>>>>>//    tt        Multicharacter time marker string, such as AM or PM
79751>>>>>//
79751>>>>>// For example, to get the time string  "11:29:40 PM"
79751>>>>>//    use the following picture string: "hh" : "mm" : "ss tt"
79751>>>>>
79751>>>>>External_function vWin32_GetTimeFormat "GetTimeFormatA" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpTimeStr ;  Integer cchTime Returns Integer
79752>>>>>
79752>>>>>
79752>>>>>// Courtesy Of Vincent Oorsprong
79752>>>>>// This function formats the date in a picture-string passed
79752>>>>>//
79752>>>>>// Picture      Meaning
79752>>>>>//    d         Day of month as digits with no leading zero for single-digit days.
79752>>>>>//    dd        Day of month as digits with leading zero for single-digit days.
79752>>>>>//    ddd       Day of week as a three-letter abbreviation. The function uses the
79752>>>>>//              LOCALE_SABBREVOAYMAME value associated with the specified locale.
79752>>>>>//    dddd      Day of week as its full name. The function uses the LOCALE_SDAYNAME
79752>>>>>//              value associated with the specified locale.
79752>>>>>//    M         Month as digits with no leading zero for single-digit months.
79752>>>>>//    MM        Month as digits with leading zero for single-digit months.
79752>>>>>//    MMM       Month as a three-letter abbreviation. The function uses the
79752>>>>>//              LOCALE_SABBREVMONTHNAME value associated with the specified locale.
79752>>>>>//    MMMM      Month as its full name. The function uses the LOCALE_SMONTHNAME value
79752>>>>>//              associated with the specified locale.
79752>>>>>//    y         Year as last two digits, but with no leading zero for years less than 10.
79752>>>>>//    yy        Year as last two digits, but with leading zero for years less than 10.
79752>>>>>//    yyyy      Year represented hy full four digits.
79752>>>>>//    gg        Period/era string. The function uses the CAL_SERASTRING value associated
79752>>>>>//              with the specified locale. This element is ignored if the date to be formatted
79752>>>>>//              does not have an associated era or period string.
79752>>>>>// For example, to get the date string  "Wed, Aug 31 94"
79752>>>>>// use the following picture string:    "ddd","MMM dd yy"
79752>>>>>
79752>>>>>External_function vWin32_GetDateFormat "GetDateFormatA" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpDateStr ;  Integer cchDate Returns Integer
79753>>>>>
79753>>>>>Define LOCALE_NOUSEROVERRIDE    For |CI$80000000  //  do not use user overrides
79753>>>>>Define TIME_NOMIHUTESORSECONDS  For |CI$0000000l  //  do not use minutes or seconds
79753>>>>>Define TIME_NOSECONDS           For |CI$00000002  //  do not use seconds
79753>>>>>Define TIME_NOTIMEMARKER        For |CI$00000004  //  do not use time marker
79753>>>>>Define TIME_FORCE24HOURFORMAT   For |CI$00000008  //  always use 24 hour format
79753>>>>>
79753>>>>>//  Date Flags for GetDateFormatW.
79753>>>>>//
79753>>>>>Define DATE_SHORTDATE           For |CI$0000000l  //  use short date picture
79753>>>>>Define DATE_LONGDATE            For |CI$00000002  //  use long date picture
79753>>>>>Define DATE_USE_ALT_CALENDAR    For |CI$00000004  //  use alternate calendar (if any)
79753>>>>>
79753>>>>>
79753>>>>>External_function vWin32_SetLastError "SetLastError" Kernel32.Dll Dword dwLastError Returns Integer
79754>>>>>
79754>>>>>
79754>>>>>// **WvA: 20-02-2004
79754>>>>>// While i was testing the format capabilities i stumbled over a very
79754>>>>>// weird problem where it looks like that the integer value gets somehow translated
79754>>>>>// incorrectly into an unsigned integer.
79754>>>>>// I don't have the time to dive into this.. so added a workaround (and removed it again)
79754>>>>>// It does smell a bit fishy though
79754>>>>>// Tested it with the same results on both VDF7 and VDF9.1
79754>>>>>
79754>>>>>Define SHFMT_ID_DEFAULT        For |CI$0000FFFF // The default format ID
79754>>>>>Define SHFMT_OPT_DEFAULT       For |CI$00000000 // The default "Quick Format" option.
79754>>>>>Define SHFMT_OPT_FULL          For |CI$00000001 // Deselects the "Quick Format" option, providing a full format instead. This is useful when an unformatted disk is detected.
79754>>>>>Define SHFMT_OPT_SYSONLY       For |CI$00000002 // Selects the "Create an MS-DOS startup disk" option, creating a system boot disk.
79754>>>>>
79754>>>>>// Possible errors that can be returned by the shellformat function
79754>>>>>Define SHFMT_ERROR             For (|CI$FFFFFFFF+1) // An error occurred during the last format or no drive parameter passed. This does not indicate that the disk is unformatable.
79754>>>>>Define SHFMT_CANCEL            For (|CI$FFFFFFFE+1) // The last format was canceled.
79754>>>>>Define SHFMT_NOFORMAT          For (|CI$FFFFFFFD+1) // The drive cannot be formatted.
79754>>>>>                                                
79754>>>>>
79754>>>>> // Courtesy Of Steve Walter,
79754>>>>> // USA Software, Inc
79754>>>>> // Format a disk
79754>>>>> // Called By:  Move (vWin32_ShFormatDrive(hWnd,0,$FFFF,1)) To dwReturn
79754>>>>>External_function vWin32_ShFormatDrive "SHFormatDrive" shell32.dll Handle hWnd ;         Integer iDrive Integer iFormatID Integer iOptions Returns DWORD
79755>>>>>
79755>>>>>// Michael Mullan.  I Wanted to create all the folders in one statement...
79755>>>>>
79755>>>>>// SHCreateDirectoryEx
79755>>>>>
79755>>>>>//    Note  This function is available through Microsoft Windows XP Service Pack 2 (SP2) and Windows Server 2003.
79755>>>>>//    It might be altered or unavailable in subsequent versions of Windows.
79755>>>>>//
79755>>>>>//    This function creates a file system folder whose fully qualified path is given by pszPath. If one or more
79755>>>>>//    of the intermediate folders do not exist, they are created as well. SHCreateDirectoryEx also verifies that
79755>>>>>//    the files are visible. If they are not visible, expect one of the following:
79755>>>>>//
79755>>>>>//        * If hwnd is set to a valid window handle, a message box is displayed warning the user that he or she
79755>>>>>//        might not be able to access the files. If the user chooses not to proceed, the function returns
79755>>>>>//        ERROR_CANCELLED.
79755>>>>>//        * If hwnd is set to NULL, no user interface is displayed and the function returns ERROR_CANCELLED.
79755>>>>>
79755>>>>>//        Returns ERROR_SUCCESS if successful. If the operation fails, other error codes can be returned,
79755>>>>>//        including those listed here. For values not specifically listed, see System Error Codes.
79755>>>>>//      161  ERROR_BAD_PATHNAME                The pszPath parameter was set to a relative path.
79755>>>>>//      206  ERROR_FILENAME_EXCED_RANGE     The path pointed to by pszPath is too long.
79755>>>>>//      3    ERROR_PATH_NOT_FOUND            The system cannot find the path pointed to by pszPath. The path may contain an invalid entry.
79755>>>>>//      80   ERROR_FILE_EXISTS                The directory exists.
79755>>>>>//      183  ERROR_ALREADY_EXISTS            The directory exists.
79755>>>>>//      1223 ERROR_CANCELLED                The user canceled the operation.
79755>>>>>
79755>>>>>//        int SHCreateDirectoryEx(
79755>>>>>//            HWND hwnd,
79755>>>>>//            LPCTSTR pszPath,
79755>>>>>//            const SECURITY_ATTRIBUTES *psa
79755>>>>>//        );
79755>>>>>
79755>>>>>External_function vWin32_SHCreateDirectoryEx "SHCreateDirectoryExA" shell32.dll Handle hWnd;                  pointer pszPath  Pointer lpSecurity_Attributes Returns Integer
79756>>>
79756>>>
79756>>>
79756>>>
79756>>>
79756>>>//
79756>>>// Gets the string from the right of the last sStopChar in sFrom
79756>>>// If sStopChar has no occurences in the string an empty string is
79756>>>// returned.
79756>>>Function StringFromRightOfChar Global String sFrom String sStopChar Returns String
79758>>>  String  sRetVal
79758>>>  String  sChar
79758>>>  Integer iLength
79758>>>  Integer iPos
79758>>>  Boolean bStopChar
79758>>>  Move "" To sRetval
79759>>>  Move (Length(sFrom)) To iLength
79760>>>  If ((iLength>0) And (Pos(sStopChar,sFrom) <> 0)) Begin
79762>>>    Move iLength   To iPos
79763>>>    Move (False)   To bStopChar
79764>>>    While Not bStopChar
79768>>>      Move (Mid(sFrom,1,iPos)) To sChar
79769>>>      Decrement iPos
79770>>>      If ((sChar=sStopChar) Or (iPos<1)) Begin
79772>>>        Move (True) To bStopChar
79773>>>      End
79773>>>>
79773>>>      Else Begin
79774>>>        Move (sChar+sRetVal) To sRetVal
79775>>>      End
79775>>>>
79775>>>    Loop
79776>>>>
79776>>>  End
79776>>>>
79776>>>  Function_Return sRetVal
79777>>>End_Function // StringFromRightOfChar
79778>>>
79778>>>
79778>>>// Pre:  sFileName contains the complete path of the file.
79778>>>// Post: returns the complete path of the file.
79778>>>// This function is inspired on function SEQ_ExtractPathFromFileName of Sture Andersen.
79778>>>Function ParseFolderName Global String sFileName Returns String
79780>>>  String sFile
79780>>>  String sFolderName
79780>>>  String sDirSep // this is "\" for windows, or "/" for unix
79780>>>  MOve "" To sFolderName
79781>>>  Move (sysconf(SYSCONF_DIR_SEPARATOR)) To sDirSep
79782>>>  If sDirSep In sFileName Begin
79784>>>    Move (StringFromRightOfChar(sFileName,sDirSep)) To sFile
79785>>>    Move (Replace(sFile,sFileName,"")) To sFolderName
79786>>>  End
79786>>>>
79786>>>  Else If ":" In sFileName Begin
79789>>>    Move (StringFromRightOfChar(sFileName,":")) To sFile
79790>>>    Move (Replace(sFile,sFileName,"")) To sFolderName
79791>>>  End
79791>>>>
79791>>>  Function_Return sFolderName
79792>>>End_Function // ParseFolderName
79793>>>
79793>>>
79793>>>// Pre:  sFileName contains the complete path of the file.
79793>>>// post: The returned filename has it's path removed, but will have a extension
79793>>>Function ParseFileName Global String sFileName Returns String
79795>>>  String sFolderName
79795>>>  String sDirSep // this is "\" for windows, or "/" for unix
79795>>>  Move (sysconf(SYSCONF_DIR_SEPARATOR)) To sDirSep
79796>>>  Get ParseFolderName sFileName To sFolderName
79797>>>  If (sFolderName <> "") Begin
79799>>>    Move (Replace(sFolderName,sFileName,"")) to sFileName
79800>>>  End
79800>>>>
79800>>>  Move (Replace(sDirSep,sFileName,"")) To sFileName
79801>>>  Function_Return sFilename
79802>>>End_Function // ParseFileName
79803>>>
79803>>>
79803>>>// Pre:  sFileName may contain the complete path of the file.
79803>>>//       or contain multiple dots in the filename, so temp.gif.bak will
79803>>>//       return "bak" as the extension and not "gif"
79803>>>// Post: returns the extension only, this extension can be a valid unixlike extension
79803>>>//       such as "html" or "java"
79803>>>Function ParseFileExtension Global String sFileName Returns String
79805>>>  String  sFileExtension
79805>>>  Get StringFromRightOfChar sFileName "." To sFileExtension
79806>>>  Function_Return sFileExtension
79807>>>End_Function // ParseFileExtension
79808>>>
79808>>>
79808>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
79808>>>
79808>>>
79808>>>Function DDE_Error_To_String Integer iErrorID Returns String
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
79810>>>  String sMessage
79810>>>  Case Begin
79810>>>    Case (iErrorID = vERROR_FILE_NOT_FOUND)
79812>>>      Move CS_DDE_ERR_FILE_NOT_FOUND To sMessage
79813>>>      Case Break
79814>>>    Case (iErrorID = vERROR_PATH_NOT_FOUND)
79817>>>      Move CS_DDE_ERR_PATH_NOT_FOUND To sMessage
79818>>>      Case Break
79819>>>    Case (iErrorID = vERROR_BAD_FORMAT)
79822>>>      Move CS_DDE_ERR_BAD_FORMAT To sMessage
79823>>>      Case Break
79824>>>    Case (iErrorID = vSE_ERR_ACCESSDENIED)
79827>>>      Move CS_DDE_ERR_ACCESSDENIED To sMessage
79828>>>      Case Break
79829>>>    Case (iErrorID = vSE_ERR_ASSOCINCOMPLETE)
79832>>>      Move CS_DDE_ERR_ASSOCINCOMPLETE To sMessage
79833>>>      Case Break
79834>>>    Case (iErrorID = vSE_ERR_DDEBUSY)
79837>>>      Move CS_DDE_ERR_DDEBUSY To sMessage
79838>>>      Case Break
79839>>>    Case (iErrorID = vSE_ERR_DDEFAIL)
79842>>>      Move CS_DDE_ERR_DDEFAIL To sMessage
79843>>>      Case Break
79844>>>    Case (iErrorID = vSE_ERR_DDETIMEOUT)
79847>>>      Move CS_DDE_ERR_DDETIMEOUT To sMessage
79848>>>      Case Break
79849>>>    Case (iErrorID = vSE_ERR_DLLNOTFOUND)
79852>>>      Move CS_DDE_ERR_DLLNOTFOUND To sMessage
79853>>>      Case Break
79854>>>    Case (iErrorID = vSE_ERR_NOASSOC)
79857>>>      Move CS_DDE_ERR_NOASSOC To sMessage
79858>>>      Case Break
79859>>>    Case ((iErrorID = vSE_ERR_OOM) Or (iErrorID = 0))
79862>>>      Move CS_DDE_ERR_OOM To sMessage
79863>>>      Case Break
79864>>>    Case (iErrorID = vSE_ERR_PNF)
79867>>>      Move CS_DDE_ERR_PNF To sMessage
79868>>>      Case Break
79869>>>    Case (iErrorID = vSE_ERR_SHARE)
79872>>>      Move CS_DDE_ERR_SHARE To sMessage
79873>>>      Case Break
79874>>>    Case Else
79874>>>      Move CS_DDE_ERR_UNKNOWN_LINE1 To sMessage
79875>>>      Move (sMessage*Trim(iErrorID)*CS_DDE_ERR_UNKNOWN_LINE2) To sMessage
79876>>>      Case Break
79877>>>  Case End
79877>>>  Function_Return sMessage
79878>>>End_Function // DDE_Error_To_String
79879>>>
79879>>>
79879>>>Procedure vDDE_Error_Handler Integer iErrorID
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
79881>>>  String sMessage
79881>>>  Get DDE_Error_To_String iErrorID To sMessage
79882>>>  Append sMessage CS_DDE_ERR_HANDL_PAKTC //  "Press a key to continue..."
79883>>>  Send Stop_Box sMessage CS_DDE_ERR_HANDL_CAPTION
79884>>>End_Procedure // vDDE_Error_Handler hInstance
79885>>>
79885>>>
79885>>>// Does the directory exist? - No = 0, Yes = 1
79885>>>// This also works with UNC path encoding and wildcards
79885>>>Function vFolderExists Global String sFolderName Returns Integer
79887>>>  String  sFolder sTmp
79887>>>  Integer bFolderExists iCh
79887>>>
79887>>>  // 2013-09-29 NGS Check for empty folder name and convert to ANSI
79887>>>  Move (ToANSI(Trim(sFolderName))) to sFolderName
79888>>>  If (sFolderName = "") Begin
79890>>>    Function_Return False
79891>>>  End
79891>>>>
79891>>>
79891>>>  Move dfTrue To bFolderExists
79892>>>  Move "dir:" To sFolder
79893>>>  Append sFolder sFolderName
79894>>>  Get Seq_New_Channel To iCh  // get free channel for input
79895>>>  Direct_Input Channel iCh sFolder
79897>>>    Repeat
79897>>>>
79897>>>      Readln Channel iCh sTmp
79899>>>      If (Trim(sTmp)="") Begin
79901>>>        Move False to bFolderExists
79902>>>      End
79902>>>>
79902>>>      Else Begin
79903>>>        Move True to bFolderExists
79904>>>        Move True to SeqEof // end loop
79905>>>        End
79905>>>>
79905>>>    Until (seqeof)
79907>>>  Close_Input Channel iCh
79909>>>  Send Seq_Release_Channel iCh
79910>>>  Function_Return bFolderExists
79911>>>End_Function  // vFolderExists
79912>>>
79912>>>
79912>>>// returns folder name if a folder was selected, otherwise returns ""
79912>>>Function vSHBrowseForFolder Global String sDialogTitle Returns String
79914>>>  String sFolder sBrowseInfo sTitle
79914>>>  Pointer lpItemIdList lpsFolder lpsBrowseInfo lpsTitle
79914>>>  Integer iFolderSelected iRetval
79914>>>
79914>>>  // fill string variable with null characters
79914>>>  ZeroType vtBrowseInfo To sBrowseInfo
79915>>>
79915>>>  If (sDialogTitle<>"") Begin
79917>>>    Move sDialogTitle To sTitle
79918>>>    // Torben Lund suggested converting the string with toansi. Doing it like that
79918>>>    // disables showing some commonly used ascii characters like ascii 137 ()
79918>>>    // These chars are correctly shown if no toansi is used.
79918>>>    // I can imagine that he wanted to path to be ANSI, but as long as it isa just
79918>>>    // selected it will always be valid.
79918>>>    Move (AddressOf(sTitle)) to lpsTitle
79919>>>    Put lpsTitle To sBrowseInfo At vtBrowseInfo.lpszTitle
79920>>>  End
79920>>>>
79920>>>
79920>>>  Put vBIF_RETURNONLYFSDIRS To sBrowseInfo At vtBrowseInfo.ulFlags
79921>>>
79921>>>  // Torben Lund added line below. Move handle of focus object to structure before
79921>>>  // calling function. Otherwise, the folderdialog will be started as a seperate task.
79921>>>  Put (window_handle(focus(desktop))) To sBrowseInfo At vtBrowseInfo.hWndOwner
79922>>>
79922>>>  Move (AddressOf(sBrowseInfo)) to lpsBrowseInfo
79923>>>
79923>>>  // null 128 chars into var (make space)
79923>>>  Move (Repeat(Character(0), vMAX_PATH)) To sFolder
79924>>>  Move (AddressOf(sFolder)) to lpsFolder
79925>>>
79925>>>  // select folder
79925>>>  Move (vWin32_SHBrowseForFolder(lpsBrowseInfo)) To lpItemIdList
79926>>>  // get selected folder name
79926>>>  Move (vWin32_SHGetPathFromIDList(lpItemIdList, lpsFolder)) To iFolderSelected
79927>>>
79927>>>  // release memory resources that are used by the ItemIdList
79927>>>  Move (vWin32_CoTaskMemFree(lpItemIdList)) To iRetval
79928>>>
79928>>>  If (iFolderSelected<>0) Begin
79930>>>    Function_Return (CString(sFolder))
79931>>>  End
79931>>>>
79931>>>  Else Begin
79932>>>    Function_Return ""
79933>>>  End
79933>>>>
79933>>>End_Function // vSHBrowseForFolder
79934>>>
79934>>>
79934>>>// returns 0 if the folder is created.
79934>>>//         1 if the API-call returned an error.
79934>>>Function vCreateDirectory Global String sNewFolder Returns Integer
79936>>>  String  sFolder sSA
79936>>>  Pointer lpsFolder lpsSecurity_Attributes lpDescriptor
79936>>>  Integer iRetval bFolderCreated bInheritHandle
79936>>>
79936>>>  Move (False) To bFolderCreated
79937>>>  // fill string variable with null characters
79937>>>  ZeroType vtSecurity_attributes To sSA
79938>>>
79938>>>  // null MAX_PATH chars into var (make space)
79938>>>  Move (Repeat(Character(0), vMAX_PATH)) To sFolder
79939>>>
79939>>>  If (sNewFolder <> "") Begin
79941>>>
79941>>>    Move dfTrue To  bInheritHandle
79942>>>    // Setting this to NULL is already done by the zerotype command
79942>>>    // Move NULL   To  lpDescriptor
79942>>>    Put (length(sSA))   To sSA At vtSecurity_attributes.nLength
79943>>>    //Put lpDescriptor To sSA at vtSecurity_attributes.lpDescriptor
79943>>>    Put bInheritHandle To sSA At vtSecurity_attributes.bInheritHandle
79944>>>
79944>>>    Move (AddressOf(sSA)) to lpsSecurity_Attributes
79945>>>
79945>>>    //
79945>>>    Move sNewFolder To sFolder
79946>>>    Move (AddressOf(sFolder)) to lpsFolder
79947>>>    Move (vWin32_CreateDirectory(lpsFolder, lpsSecurity_Attributes)) To bFolderCreated
79948>>>  End
79948>>>>
79948>>>
79948>>>  If (not(bFolderCreated)) Begin
79950>>>    Move 1 to iRetVal
79951>>>  End
79951>>>>
79951>>>  Function_Return iRetVal
79952>>>End_Function // vCreateDirectory
79953>>>
79953>>>
79953>>>// **WvA: 03-02-2002 Function created.
79953>>>// With this function one can remove a directory.
79953>>>// returns 0 if the folder is removed.
79953>>>//         1 if the API-call returned an error (Use GetLastError API to get the details)
79953>>>//         2 if the folder did not exist
79953>>>//         3 if the sFolder parameter passed is equal to ""
79953>>>Function vRemoveDirectory Global String sFolder Returns Integer
79955>>>  String  sPath
79955>>>  Pointer lpsPath
79955>>>  Integer iRetval bRemoved
79955>>>
79955>>>  Move (False) To bRemoved
79956>>>  Move 0 To iRetVal
79957>>>  Move (Trim(sFolder)) To sFolder
79958>>>  If (sFolder="") Begin
79960>>>    Move 3 To iRetVal
79961>>>  End
79961>>>>
79961>>>  If (vFolderExists(sFolder)=False) Begin
79963>>>    Move 2 To iRetVal
79964>>>  End
79964>>>>
79964>>>  If (iRetVal=0) Begin
79966>>>    // null MAX_PATH chars into var (make space)
79966>>>    Move (Repeat(Character(0), vMAX_PATH)) To sPath
79967>>>    //
79967>>>    Move (Insert(sFolder,sPath,1)) To sPath
79968>>>    Move (AddressOf(sPath)) to lpsPath
79969>>>    Move (vWin32_RemoveDirectory(lpsPath)) To bRemoved
79970>>>  End
79970>>>>
79970>>>
79970>>>  If ((iRetVal=0) And (bRemoved=False)) Begin
79972>>>    Move 1 To iRetVal
79973>>>  End
79973>>>>
79973>>>  Function_Return iRetVal
79974>>>End_Function // vRemoveDirectory
79975>>>
79975>>>
79975>>>
79975>>>// This function informs the user that he entered a yet unknown folder and
79975>>>// asks if he/she wants to create the folder (Yes/No)
79975>>>// Choice: "Yes" - this creates the folder
79975>>>//                 if successful, the function returns false
79975>>>//                 else it will be true.
79975>>>// Choice: "No"  - returns TRUE, This allows the programmer to take action
79975>>>//                 For example: to stop a save
79975>>>// Precondition: A foldername must be entered. We do not check for empty paths
79975>>>// This function returns a non-zero value if the folder isn't created afterwards
79975>>>Function vVerifyNewFolder Global String sFolderName Returns Integer
79977>>>  Integer bIsNotValid
79977>>>  Integer iUsers_Choice
79977>>>  String  sMessage
79977>>>
79977>>>  If (vFolderExists(sFolderName) Eq 0) Begin
79979>>>    Move "The folder '" To sMessage
79980>>>    Append sMessage sFolderName
79981>>>    Append sMessage "' does not yet exist,\n"
79982>>>    Append sMessage "Do you want to create it now?"
79983>>>    Get YesNo_Box sMessage "Confirm" MB_DefButton1 To iUsers_Choice
79984>>>    Case Begin
79984>>>      Case (iUsers_Choice = MBR_Yes)
79986>>>        Move (vCreateDirectory(sFolderName)) To bIsNotValid
79987>>>        If bIsNotValid Begin
79989>>>          Move "An error occurred while trying to create folder '" To sMessage
79990>>>          Append sMessage sFolderName "'.\n\n"
79992>>>          Send Info_Box sMessage "Info"
79993>>>          End
79993>>>>
79993>>>        Case Break
79994>>>      Case (iUsers_Choice = MBR_No)
79997>>>        Move dfTrue To bIsNotValid // Cancel the save
79998>>>        Case Break
79999>>>    Case End
79999>>>  End
79999>>>>
79999>>>  Function_Return bIsNotValid
80000>>>End_Function // vVerifyNewFolder
80001>>>
80001>>>
80001>>>// This will perform an operation on a file (e.g. open) with the application
80001>>>// registered in the Windows Registry to open that type of file (via its extension)
80001>>>// sOperation would be "OPEN" (it could also be "PRINT" etc).
80001>>>Procedure vShellExecute global String sOperation String sDocument String sParameters String sPath
80003>>>  Handle  hInstance hWnd
80003>>>  Pointer lpsOperation
80003>>>  Pointer lpsDocument
80003>>>  Pointer lpsParameters
80003>>>  Pointer lpsPath
80003>>>  // remove any leading/trailing spaces in the string
80003>>>  Move (Trim(sDocument)) To sDocument
80004>>>  Move (Trim(sPath))     To sPath
80005>>>  // Make the strings readable for windows API, by converting them to null-terminated
80005>>>  Append sOperation   (Character(0))
80006>>>  Append sDocument    (Character(0))
80007>>>  Append sParameters  (Character(0))
80008>>>  Append sPath        (Character(0))
80009>>>  // Connect the corresponding pointers to the strings
80009>>>  Move (AddressOf(sOperation))  to lpsOperation
80010>>>  Move (AddressOf(sDocument))   to lpsDocument
80011>>>  Move (AddressOf(sParameters)) To lpsParameters
80012>>>  Move (AddressOf(sPath))       to lpsPath
80013>>>
80013>>>  Get Window_Handle To hWnd
80014>>>  Move (vWin32_ShellExecute (hWnd, lpsOperation, lpsDocument, lpsParameters, lpsPath, 1)) To hInstance
80015>>>  If (hInstance <= 32) Begin
80017>>>    Send vDDE_Error_Handler hInstance
80018>>>  End
80018>>>>
80018>>>End_Procedure // vShellExecute
80019>>>
80019>>>
80019>>>Class cShellFileOperations Is a Array
80020>>>
80020>>>  Procedure Construct_Object
80022>>>    Forward Send Construct_Object
80024>>>    Property Integer piDeleteFlags 0
80025>>>    Property Integer piCopyFlags   0
80026>>>    Property Integer piMoveFlags   0
80027>>>    Property Integer piRenameFlags 0
80028>>>
80028>>>    Set piDeleteFlags To (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
80029>>>    Set piCopyFlags   To (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR Ior vFOF_NOCONFIRMATION)
80030>>>    Set piMoveFlags   To (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR iOr vFOF_NOCONFIRMATION)
80031>>>    Set piRenameFlags To (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
80032>>>  End_Procedure // Construct_Object
80033>>>
80033>>>
80033>>>  // This function uses the shell API to perform a file operation on the
80033>>>  // files supplied.
80033>>>  //
80033>>>  Function FileOperation String sSource String sDestination Integer iOperation Integer iFlags Returns Integer
80035>>>    String   sShFileOp
80035>>>    Pointer  lpShFileOp
80035>>>    Pointer  lpsSource
80035>>>    Pointer  lpsDestination
80035>>>    Integer  iRetVal
80035>>>    Integer  bUserAbort
80035>>>
80035>>>    ZeroType vtShFileOpStruct To sShFileOp
80036>>>    Move (ToAnsi(sSource)+Character(0)+Character(0))      To sSource
80037>>>    Move (ToAnsi(sDestination)+Character(0)+Character(0)) To sDestination
80038>>>    Move (AddressOf(sSource))    To lpsSource
80039>>>    If iOperation Ne vFO_DELETE Begin
80041>>>      Move (AddressOf(sDestination))      To lpsDestination
80042>>>      Put lpsDestination To sShFileOp At vtShFileOpStruct.pTo
80043>>>    End
80043>>>>
80043>>>
80043>>>    Put iOperation     To sShFileOp At vtShFileOpStruct.wFunc
80044>>>    Put lpsSource      To sShFileOp At vtShFileOpStruct.pFrom
80045>>>    Put iFlags         To sShFileOp At vtShFileOpStruct.fFlags
80046>>>
80046>>>    Move (AddressOf(sShFileOp)) to lpShFileOp
80047>>>
80047>>>    Move (vWin32_SHFileOperation(lpShFileOp)) To iRetVal
80048>>>    GetBuff From sShFileOp At vtShFileOpStruct.fAnyOperationsAborted To bUserAbort
80049>>>    If (bUserAbort <> 0) Begin
80051>>>      Move 80 To iRetVal  // file Operation Aborted by USER
80052>>>    End
80052>>>>
80052>>>    Function_Return (iRetVal)
80053>>>  End_Function // FileOperation
80054>>>
80054>>>
80054>>>  Function sfoDeleteFile String sFileName Returns Integer
80056>>>    Integer  iRetVal
80056>>>    Integer  iFlags
80056>>>
80056>>>    Get piDeleteFlags To iFlags
80057>>>    Get FileOperation sFileName "" vFO_DELETE iFlags To iRetVal
80058>>>    Function_Return iRetVal
80059>>>  End_Function // sfoDeleteFile
80060>>>
80060>>>
80060>>>  Function sfoCopyFile String sSource String sDestination Returns Integer
80062>>>    Integer  iRetVal
80062>>>    Integer  iFlags
80062>>>
80062>>>    Get piCopyFlags To iFlags
80063>>>    Get FileOperation sSource sDestination vFO_COPY iFlags To iRetVal
80064>>>    Function_Return iRetVal
80065>>>  End_Function // sfoCopyFile
80066>>>
80066>>>
80066>>>  Function sfoMoveFile String sSource String sDestination Returns Integer
80068>>>    Integer  iRetVal
80068>>>    Integer  iFlags
80068>>>
80068>>>    Get piMoveFlags To iFlags
80069>>>    Get FileOperation sSource sDestination vFO_MOVE iFlags To iRetVal
80070>>>    Function_Return iRetVal
80071>>>  End_Function // sfoMoveFile
80072>>>
80072>>>
80072>>>  // Rename a file or folder
80072>>>  // Returns a nonzero value if the operation failed.
80072>>>  Function sfoRenameFile String sSource String sDestination Returns Integer
80074>>>    Integer  iRetVal
80074>>>    Integer  iFlags
80074>>>
80074>>>    Get piRenameFlags To iFlags
80075>>>    Get FileOperation sSource sDestination vFO_RENAME iFlags To iRetVal
80076>>>    Function_Return iRetVal
80077>>>  End_Function // sfoRenameFile
80078>>>
80078>>>  // Courtesy Of Steve Walter
80078>>>  // Requires Windows 2000 and up according to msdn but it was
80078>>>  //  in fact available before that as an unpublished API call
80078>>>  //  a little google search shows that this was already available
80078>>>  //  in windows 95 and NT
80078>>>  //
80078>>>  // The format is controlled by the dialog interface.
80078>>>  // That is, the user must click the OK button To actually Begin the format
80078>>>  // the format cannot be started programmatically.
80078>>>  // An alternative to this functionality would be to use a controlpanel
80078>>>  //  http://www.vdf-guidance.com/ContribPage.asp?Page=PKGCLSDFCPLAPP&ContribRecId=93
80078>>>  //
80078>>>  // hWnd = The windows handle of the object from which the format Function
80078>>>  //        is called.
80078>>>  // To Get this,
80078>>>  //          use:  Get Window_Handle Of <object>
80078>>>  //          For instance, in this app, we're going to use the Report_Panel:
80078>>>  //                  Get Window_Handle Of (Report_Panel(Main(Self))) To hWind
80078>>>  //
80078>>>  // sDrive = The drive letter. At this moment only A and B are valid
80078>>>  //
80078>>>  // iOptions = Format options.
80078>>>  //  SHFMT_OPT_DEFAULT = Quick format
80078>>>  //  SHFMT_OPT_FULL    = Full Format
80078>>>  //  SHFMT_OPT_SYSONLY = System only
80078>>>  //  3                 = Full format with system. (unsupported)
80078>>>  //
80078>>>  // Return Values:
80078>>>  //  SHFMT_ERROR    = Error on format or no drive specified.
80078>>>  //  SHFMT_CANCEL   = Format cancelled by user.
80078>>>  //  SHFMT_NOFORMAT = Drive is not formatable.
80078>>>  //
80078>>>  //
80078>>>  // *** ATTENTION: This function has been disabled as it doesn't
80078>>>  //                seem to work, i must have made a silly mistake
80078>>>  //                somewhere.
80078>>>  //
80078>>>  Function sfoFormatDisk String sDrive Integer iOptions Returns DWORD
80080>>>    Handle   hWnd
80080>>>    Integer  iObj
80080>>>    DWORD    dwReturnVal
80080>>>    Integer iDrive
80080>>>
80080>>>    Function_Return (1) // STOP HERE
80081>>>
80081>>>    Move (Trim(sDrive)) To sDrive
80082>>>    If ( sDrive <> '' ) Begin
80084>>>      If ( sDrive contains ':' ) Begin
80086>>>        Move (Replace(':',sDrive,'')) to sDrive
80087>>>      End
80087>>>>
80087>>>      If (not( 'AB' contains sDrive )) Begin
80089>>>         Function_Return (SHFMT_NOFORMAT)
80090>>>      End
80090>>>>
80090>>>      If ( sDrive = 'A') Begin
80092>>>        Move 0 to iDrive
80093>>>      End
80093>>>>
80093>>>      Else If ( sDrive = 'B') Begin
80096>>>        Move 1 to iDrive
80097>>>      End
80097>>>>
80097>>>      // Window_Handle Of Desktop equals to 0
80097>>>
80097>>>      Get focus Of desktop To iObj
80098>>>      If (iObj>desktop) ;          Get Container_Handle Of iObj To hWnd
80101>>>      While (hWnd=0 And iObj<>Desktop)
80105>>>          Get Parent Of iObj To iObj
80106>>>          Get Container_Handle Of iObj To hWnd
80107>>>      End
80108>>>>
80108>>>
80108>>>      //Showln "hWnd = " hWnd " iDrive " iDrive " iOptions " iOptions
80108>>>      Move (vWin32_ShFormatDrive(hWnd, iDrive, SHFMT_ID_DEFAULT, iOptions)) To dwReturnVal
80109>>>    End
80109>>>>
80109>>>    Else Begin
80110>>>      Move (SHFMT_ERROR) To dwReturnVal
80111>>>    End
80111>>>>
80111>>>    Function_Return dwReturnVal
80112>>>  End_Function // sfoFormatDisk
80113>>>
80113>>>  //Example:
80113>>>  // Get sfoFormatDisk 'A' 0 To dReturnVal    // Formats drive A in QuickFormat
80113>>>  //                                          mode.
80113>>>
80113>>>End_Class // cShellFileOperations
80114>>>
80114>>>
80114>>>Object oShellFileOperations Is a cShellFileOperations
80116>>>End_Object // oShellFileOperations
80117>>>
80117>>>
80117>>>// Restore to the old way of working with the shell file operations.
80117>>>// or.. to put lay man terms, allow any of the operations vDeleteFile
80117>>>// vCopyFile/vMoveFile/vRenameFile to have an UNDO
80117>>>Procedure vWin32fhCompatibilityMode
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
80119>>>  Integer hoSFO
80119>>>  Integer iFlags
80119>>>
80119>>>  Move (vFOF_SILENT Ior vFOF_NOCONFIRMATION Ior vFOF_ALLOWUNDO) To iFlags
80120>>>  Move (oShellFileOperations(Self)) To hoSFO
80121>>>
80121>>>  Set piDeleteFlags Of hoSFO To iFlags
80122>>>  Set piCopyFlags   Of hoSFO To iFlags
80123>>>  Set piMoveFlags   Of hoSFO To iFlags
80124>>>  Set piRenameFlags Of hoSFO To iFlags
80125>>>End_Procedure // vWin32fhCompatibilityMode
80126>>>
80126>>>
80126>>>Function vDeleteFile Global String sFileName Returns Integer
80128>>>  Integer  iRetVal
80128>>>
80128>>>  Get sfoDeleteFile Of (oShellFileOperations(Self)) sFileName To iRetVal
80129>>>  Function_Return iRetVal
80130>>>End_Function // vDeleteFile
80131>>>
80131>>>
80131>>>Function vCopyFile Global String sSource String sDestination Returns Integer
80133>>>  Integer  iRetVal
80133>>>
80133>>>  Get sfoCopyFile Of (oShellFileOperations(Self)) sSource sDestination To iRetVal
80134>>>  Function_Return iRetVal
80135>>>End_Function // vCopyFile
80136>>>
80136>>>
80136>>>Function vMoveFile Global String sSource String sDestination Returns Integer
80138>>>  Integer  iRetVal
80138>>>
80138>>>  Get sfoMoveFile Of (oShellFileOperations(Self)) sSource sDestination To iRetVal
80139>>>  Function_Return iRetVal
80140>>>End_Function // vMoveFile
80141>>>
80141>>>
80141>>>// Rename a file or folder
80141>>>// Returns a nonzero value if the operation failed.
80141>>>Function vRenameFile Global String sSource String sDestination Returns Integer
80143>>>  Integer  iRetVal
80143>>>
80143>>>  Get sfoRenameFile Of (oShellFileOperations(Self)) sSource sDestination To iRetVal
80144>>>  Function_Return iRetVal
80145>>>End_Function // vRenameFile
80146>>>
80146>>>
80146>>>
80146>>>Function vGetWindowsDirectory Returns String
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
80148>>>  String  sDirectory
80148>>>  Pointer lpDirectory
80148>>>  Integer iVoid
80148>>>
80148>>>  ZeroString vMAX_PATH To sDirectory
80149>>>  Move (AddressOf(sDirectory)) to lpDirectory
80150>>>
80150>>>  Move (vWin32_GetWindowsDirectory(lpDirectory, vMAX_PATH)) To iVoid
80151>>>  Function_Return (CString(sDirectory))  // **WvA: Changed to CString()
80152>>>End_Function // vGetWindowsDirectory
80153>>>
80153>>>
80153>>>
80153>>>
80153>>>// Courtesy of Marco Kuipers
80153>>>Function vMakeTempFile Returns String
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
80155>>>    Integer iRetval
80155>>>    String  sTempPath sTempFileName sPrefixString
80155>>>    Pointer lpTempPath lpTempFileName lpPrefixString
80155>>>
80155>>>    Move (Repeat (Character (0), 255)) To sTempPath
80156>>>    Move (AddressOf(sTempPath)) to lpTempPath
80157>>>    Move (vWin32_GetTempPath (255, lpTempPath)) To iRetVal
80158>>>
80158>>>    If (sTempPath = "") Begin
80160>>>       Get_Current_Directory To sTempPath
80161>>>    End
80161>>>>
80161>>>    Move (pad(sTempPath,vMax_Path-14)) To sTempPath // *WvA: 28-04-2005 Quote from msdn: The string cannot be longer than MAX_PATH-14 characters.
80162>>>    Move (Repeat (Character (0), 255)) To sTempFileName
80163>>>    Move (AddressOf(sTempFileName)) To lpTempFileName
80164>>>    Move ("tmp"+character(0)) To sPrefixString // **WvA: 28-04-2005 Added a null
80165>>>    Move (AddressOf(sPrefixString)) To lpPrefixString
80166>>>    Move (AddressOf(sTempPath)) to lpTempPath
80167>>>    Move (vWin32_GetTempFileName (lpTempPath, lpPrefixString, 0, lpTempFileName)) To iRetval
80168>>>    If (iRetval = 0) Begin  // **WvA: 28-04-2005 Changed condition, the api call returns 0 if an error occurs
80170>>>        Move "" To sTempFileName
80171>>>    End
80171>>>>
80171>>>
80171>>>    Function_Return (Cstring(sTempFileName)) // **WvA: 28-04-2005 Cstring added
80172>>>End_Function // vMakeTempFile
80173>>>
80173>>>
80173>>>// This function creates a uniquely named temporary file in folder sPath
80173>>>// The file created will have a prefix based on the first 3 characters in sPrefix
80173>>>// Note that you will have to cleanup the tempfile yourself as the function
80173>>>// does not take care of that.
80173>>>Function vCreateTempFileInPath String sPath String sPrefix Returns String
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
80175>>>    String sTempFileName
80175>>>    Integer iRetVal
80175>>>    Pointer lpTempFileName
80175>>>    Pointer lpPath
80175>>>    Pointer lpPrefix
80175>>>
80175>>>    Move (ToAnsi(sPath)+Character(0))   To sPath
80176>>>    Move (ToAnsi(sPrefix)+Character(0)) To sPrefix
80177>>>    Move (pad("", vMAX_PATH)) To sTempFileName
80178>>>    Move (AddressOf(sTempFileName)) To lpTempFileName
80179>>>    Move (AddressOf(sPath))         To lpPath
80180>>>    Move (AddressOf(sPrefix))       to lpPrefix
80181>>>
80181>>>    Move (vWin32_GetTempFileName(lpPath, lpPrefix, 0, lpTempFileName)) To iRetVal
80182>>>    Move (Trim(Cstring(sTempFileName))) To sTempFileName
80183>>>    Function_Return sTempFileName
80184>>>End_Function // vCreateTempFileInPath
80185>>>
80185>>>//
80185>>>// Get a specific shell folder for example to get the desktop folder
80185>>>// simply call this function and pass it vCSIDL_DESKTOP
80185>>>//
80185>>>Function vSHGetFolderPath Integer eFolder Returns String
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
80187>>>  String  sFolder
80187>>>  Integer iVoid
80187>>>  Pointer lpsFolder
80187>>>  Handle  hWnd
80187>>>  Move (Window_Handle(focus(desktop))) To hWnd
80188>>>
80188>>>  Move (Repeat(Character(0), vMAX_PATH)) To sFolder
80189>>>  Move (AddressOf(sFolder)) To lpsFolder
80190>>>
80190>>>  Move (vWin32_SHGetFolderPath(hWnd,eFolder, 0, 0,lpsFolder)) To iVoid
80191>>>  Function_Return (CString(sFolder))
80192>>>End_Function // vSHGetFolderPath
80193>>>
80193>>>
80193>>>
80193>>>// Courtesy Of Vincent Oorsprong
80193>>>Function vConvertFileDateTime Global Dword dwLowDateTime Dword dwHighDateTime Returns String
80195>>>  String  sftTime sSystemTime sFormattedTime sFormattedDate
80195>>>  Pointer lpsftTime lpsSystemTime lpsFormattedTime lpsFormattedDate
80195>>>  Integer iSuccess iLenCcTime iDataLength iLenCcDate
80195>>>
80195>>>  ZeroType vFileTime  To sftTime
80196>>>  Put dwLowDateTime  To sftTime At vFileTime.dwLowDateTime
80197>>>  Put dwHighDateTime To sftTime At vFileTime.dwHighDateTime
80198>>>  Move (AddressOf(sftTime)) to lpsftTime
80199>>>
80199>>>  ZeroType vSystemTime To sSystemTime
80200>>>  Move (AddressOf(sSystemTime)) To lpsSystemTime
80201>>>
80201>>>  Move (vWin32_FileTimeToSystemTime (lpsftTime, lpsSystemTime)) To iSuccess
80202>>>  If iSuccess Eq DfTrue Begin
80204>>>    ZeroString 255 To sFormattedTime
80205>>>    Move (AddressOf(sFormattedTime)) To lpsFormattedTime
80206>>>    Length sFormattedTime To iLenCcTime
80207>>>>
80207>>>    Move (vWin32_GetTimeFormat (LOCALE_USER_DEFAULT, 0, lpsSystemTime, 0, ;                             lpsFormattedTime, iLenCcTime)) To iDataLength
80208>>>    ZeroString 255 To sFormattedDate
80209>>>    Move (AddressOf(sFormattedDate)) to lpsFormattedDate
80210>>>    Move (Length(sFormattedDate)) to iLenCcDate
80211>>>    Move (vWin32_GetDateFormat (LOCALE_USER_DEFAULT, 0, lpsSystemTime, 0, ;                             lpsFormattedDate, iLenCcDate)) To iDataLength
80212>>>    Function_Return (Cstring (sFormattedDate)  * Cstring (sFormattedTime))
80213>>>  End // iSuccess
80213>>>>
80213>>>End_Function // vConvertFileDateTime
80214>>>
80214>>>
80214>>>// **WvA Removed, See the cFileSet class for an alternative
80214>>>//Procedure DoBrowseDir String sFilePath
80214>>>//End_Procedure // DoBrowseDir
80214>>>
80214>>>// **WvA:
80214>>>// A windows replacement for the standard function FileExists.
80214>>>// This version will also return (true) for a file when it is open by an application.
80214>>>// Note that you can apply normal windows mask-signs in the filename such as * and ?
80214>>>// Example: Get vFilePathExists "C:\config.sy?"
80214>>>// This will return true if you have a file matching these conditions. (aka config.sys)
80214>>>Function vFilePathExists Global String sFilePathMask Returns Integer
80216>>>  String  sWin32FindData
80216>>>  String  sDirSep
80216>>>  Pointer lpsFilePathMask lpsWin32FindData
80216>>>  Handle  hFindFile
80216>>>  Integer iVoid
80216>>>
80216>>>  Move vINVALID_HANDLE_VALUE To hFindFile
80217>>>  Move (ToANSI(trim(sFilePathMask))) To sFilePathMask
80218>>>
80218>>>  If (length(sFilePathMask)>0) Begin
80220>>>    // 2014-09-29 NGS Remove any trailing dir separators, as they make the function fail.
80220>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
80221>>>    While (Right(sFilePathMask, 1) = sDirSep)
80225>>>      Move (Left(sFilePathMask, Length(sFilePathMask) -1)) to sFilePathMask
80226>>>    Loop
80227>>>>
80227>>>
80227>>>    Move (AddressOf(sFilePathMask)) To lpsFilePathMask
80228>>>    ZeroType vWin32_Find_Data To sWin32FindData
80229>>>    Move (AddressOf(sWin32FindData)) to lpswin32FindData
80230>>>    Move (vWin32_FindFirstFile (lpsFilePathMask, lpsWin32FindData)) To hFindFile
80231>>>    Move (vWin32_FindClose (hFindFile)) To iVoid
80232>>>  End
80232>>>>
80232>>>  Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
80233>>>End_Function // vFilePathExists
80234>>>
80234>>>
80234>>>// **WvA
80234>>>// Formats a foldername by first trimming it and after that by sticking a
80234>>>// directory separator (/\) to the end if it doesn't have one there already.
80234>>>// The folder may contain a drive letter or UNC encoding.
80234>>>Function vFolderFormat Global String sFolderName Returns String
80236>>>  String sDirSep
80236>>>  Move (sysconf(SYSCONF_DIR_SEPARATOR)) To sDirSep  // normally \ (backslash)
80237>>>  Move (Trim(sFolderName)) To sFolderName
80238>>>  If (Right(sFolderName,1)<>sDirSep) Begin
80240>>>    Move (sFolderName+sDirSep) To sFolderName
80241>>>  End
80241>>>>
80241>>>  Function_Return sFolderName
80242>>>End_Function // vFolderFormat
80243>>>//
80243>>>// Returns the amount of files in the folder (if it exists)
80243>>>// Returns -1 if folder doesn't exist.
80243>>>// The files "." and ".." are not counted.
80243>>>//
80243>>>Function vFolderFileCount Global String sFolderName Returns Integer
80245>>>  Boolean bFound
80245>>>  Handle  hFindFile
80245>>>  Integer iCount  iVoid
80245>>>  Integer iSuccess
80245>>>  Pointer lpsFolderName lpsWin32FindData
80245>>>  String  sWin32FindData
80245>>>  String  sFileName
80245>>>
80245>>>  Move -1 To iCount
80246>>>  Get vFolderFormat sFolderName To sFolderName
80247>>>  Move (sFolderName+"*") To sFolderName // match any filename in the folder
80248>>>  Move (AddressOf(sFolderName)) To lpsFolderName
80249>>>  ZeroType vWin32_Find_Data To sWin32FindData
80250>>>  Move (AddressOf(sWin32FindData)) to lpswin32FindData
80251>>>  Move (vWin32_FindFirstFile (lpsFolderName, lpsWin32FindData)) To hFindFile
80252>>>  Move (hFindFile<>vINVALID_HANDLE_VALUE) To bFound
80253>>>  If (bFound) Begin
80255>>>    Move 0 to iCount
80256>>>  End
80256>>>>
80256>>>  While (bFound)
80260>>>    Increment iCount
80261>>>    GetBuff_String From sWin32FindData At vWin32_Find_Data.cFileName To sFileName
80262>>>    If (sFileName="." or sFileName="..") Begin
80264>>>        Decrement iCount
80265>>>    End
80265>>>>
80265>>>    Move (vWin32_FindNextFile(hFindFile, lpsWin32FindData)) To iSuccess
80266>>>    Move (iSuccess<>0) To bFound
80267>>>  Loop
80268>>>>
80268>>>  Move (vWin32_FindClose (hFindFile)) To iVoid
80269>>>  Function_Return iCount
80270>>>End_Function // vFolderFileCount
80271>>>
80271>>>
80271>>>//
80271>>>// Gets the parent path of the currently supplied path
80271>>>// Returns "" when we are at the root folder.
80271>>>//
80271>>>Function vParentPath Global String sPath Returns String
80273>>>  String sStrip
80273>>>  Integer iLength
80273>>>
80273>>>  If (Right(sPath,1)="\") Begin
80275>>>    Move (Left(sPath,Length(sPath)-1)) To sPath
80276>>>  End
80276>>>>
80276>>>  If (Pos("\",sPath)) Begin
80278>>>    Move (StringFromRightOfChar(sPath,"\")) to sStrip
80279>>>    Move (Length(sStrip)) to iLength
80280>>>    Move (Left(sPath, (Length(sPath) - iLength -1))) to sPath
80281>>>//    Move (Replace(sStrip,sPath,"")) To sPath
80281>>>  End
80281>>>>
80281>>>  Else Begin
80282>>>    Move "" To sPath
80283>>>  End
80283>>>>
80283>>>  Function_Return sPath
80284>>>End_Function // vParentPath
80285>>>
80285>>>// Create the folder, including intermediate directories.
80285>>>// Don't panic if the folder already exists.
80285>>>// Michael Mullan June 2009.
80285>>>Function vshCreateDirectoryEX Global String sNewFolder Returns Integer
80287>>>  String  sFolder sSA
80287>>>  Pointer lpsFolder lpsSecurity_Attributes
80287>>>  Integer iRetval bFolderCreated bInheritHandle
80287>>>  Move (False) to bFolderCreated
80288>>>  // fill string variable with null characters
80288>>>  ZeroType vtSecurity_attributes to sSA
80289>>>  // null MAX_PATH chars into var (make space)
80289>>>  Move (Repeat(Character(0), vMAX_PATH)) to sFolder
80290>>>  If (sNewFolder <> "") Begin
80292>>>    Move dfTrue to  bInheritHandle
80293>>>    // Setting this to NULL is already done by the zerotype command
80293>>>    // Move NULL   To  lpDescriptor
80293>>>    Put (length(sSA))   to sSA At vtSecurity_attributes.nLength
80294>>>    //Put lpDescriptor To sSA at vtSecurity_attributes.lpDescriptor
80294>>>    Put bInheritHandle to sSA At vtSecurity_attributes.bInheritHandle
80295>>>    Move (AddressOf(sSA)) to lpsSecurity_Attributes
80296>>>    //
80296>>>    Move sNewFolder to sFolder
80297>>>    Move (AddressOf(sFolder)) to lpsFolder
80298>>>    Move (vWin32_SHCreateDirectoryEx(0,lpsFolder, lpsSecurity_Attributes)) to bFolderCreated
80299>>>  End
80299>>>>
80299>>>
80299>>>  If (bFolderCreated <> 0) Begin
80301>>>    Move 1 to iRetVal
80302>>>
80302>>>    If (bFolderCreated = 161 ) Begin
80304>>>        Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_BAD_PATHNAME)")
80305>>>>
80305>>>    End
80305>>>>
80305>>>    Else If (bFolderCreated = 206 ) Begin
80308>>>        Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_FILENAME_EXCED_RANGE)")
80309>>>>
80309>>>    End
80309>>>>
80309>>>    Else If (bFolderCreated = 3   ) Begin
80312>>>        Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_PATH_NOT_FOUND)")
80313>>>>
80313>>>    End
80313>>>>
80313>>>    Else If (bFolderCreated = 80  ) Begin
80316>>>        Move 0 to iRetval // "ERROR_FILE_EXISTS"     not really an error
80317>>>    End
80317>>>>
80317>>>    Else If (bFolderCreated = 183 ) Begin
80320>>>        Move 0 to iRetval //  "ERROR_ALREADY_EXISTS"     not really an error
80321>>>    End
80321>>>>
80321>>>    Else If (bFolderCreated = 1223) Begin
80324>>>        Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_CANCELLED)")
80325>>>>
80325>>>    End
80325>>>>
80325>>>    Else Begin
80326>>>        Error DFERR_OPERATOR ("Folder Creation Error # " + String(bfoldercreated) + "\n" + sNewFolder + "(FILE_CREATION_ERROR)")
80327>>>>
80327>>>    End
80327>>>>
80327>>>  End
80327>>>>
80327>>>  Function_Return iRetVal
80328>>>End_Function // vshCreateDirectoryEX
80329>>>
80329>>>
80329>>>Function vWin32_APIFileSize Global string sFileName returns integer
80331>>>     dWord dwFileSizeHigh dwFileSizeLow
80331>>>     integer iFileSize iVoid
80331>>>     handle hFindFile
80331>>>     pointer lpsFilePath lpsWin32FindData
80331>>>     string sWin32FindData
80331>>>
80331>>>     Move (AddressOf(sFileName)) to lpsFilePath
80332>>>
80332>>>     ZeroType vWin32_Find_Data to sWin32FindData
80333>>>     Move (AddressOf(sWin32FindData)) to lpsWin32FindData
80334>>>
80334>>>     move (vWin32_FindFirstFile (lpsFilePath, lpsWin32FindData)) to hFindFile
80335>>>     if (hFindFile<>vINVALID_HANDLE_VALUE) begin
80337>>>         GetBuff From sWin32FindData At vWin32_Find_Data.nFileSizeHigh To dwFileSizeHigh
80338>>>         GetBuff From sWin32FindData At vWin32_Find_Data.nFileSizeLow To dwFileSizeLow
80339>>>     end
80339>>>>
80339>>>     move (vWin32_FindClose (hFindFile)) to iVoid
80340>>>
80340>>>     Move ((dwFileSizeHigh * vMaxDword) + dwFileSizeLow) to iFileSize
80341>>>
80341>>>     function_return iFileSize
80342>>>End_Function  // vWin32_APIFileSize
80343>>>
80343>>>
80343>Use cCJSkinFramework.pkg
Including file: cCJSkinFramework.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJSkinFramework.pkg)
80343>>>Use windows.pkg
80343>>>Use cCJComSkinFramework.pkg
Including file: cCJComSkinFramework.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJComSkinFramework.pkg)
80343>>>>>// DataFlex COM proxy classes generated from C:\Program Files (x86)\Codejock Software\ActiveX\Xtreme SuitePro ActiveX v17.3.0\Bin\Codejock.SkinFramework.v17.3.0.ocx
80343>>>>>Use FlexCom20.pkg
80343>>>>>
80343>>>>>// Changes to Imported package
80343>>>>>//     OLEXTPxx to XTPxx
80343>>>>>//     OLExtpxx to xtpxx
80343>>>>>//     OLESkinFramework to SkinFramework
80343>>>>>//     OLESTDxxx and OLEXPxxxx to STD/XP
80343>>>>>//     cCom classes to cCJ
80343>>>>>//     cCJAutomationObject back to cComAutomationObject
80343>>>>>//     cCJActiveXControl back to cComActiveXControl
80343>>>>>//     cCJSkinFramework to cCJComSkinFramework
80343>>>>>//     Use statements as noted below (classes moved to these files)
80343>>>>>//     Set classlibrary of all cComAutomation objects to Windows (for class doc)
80343>>>>>
80343>>>>>// These have been extracted from this class and moved into seperate packages
80343>>>>>// because other Codejock classes use these.
80343>>>>>Use cCJColorManager.pkg     // cCJColorManager
80343>>>>>
80343>>>>>Define SkinFrameworkApplyOptions for Integer
80343>>>>>    Define xtpSkinApplyMetrics for 1
80343>>>>>    Define xtpSkinApplyFrame for 2
80343>>>>>    Define xtpSkinApplyColors for 4
80343>>>>>    Define xtpSkinApplyMenus for 8
80343>>>>>
80343>>>>>// CLSID: {AFA0E6A1-28D7-4F2C-87A7-7266367B4655}
80343>>>>>// Dispatch interface for SkinFramework Control
80343>>>>>Class cCJ_DSkinFramework is a Mixin
80344>>>>>
80344>>>>>    Function ComApplyOptions Returns SkinFrameworkApplyOptions
80346>>>>>        SkinFrameworkApplyOptions retVal
80346>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to retVal
80347>>>>>        Function_Return retVal
80348>>>>>    End_Function
80349>>>>>
80349>>>>>    Procedure Set ComApplyOptions SkinFrameworkApplyOptions value
80351>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to value
80352>>>>>    End_Procedure
80353>>>>>
80353>>>>>    Function ComAutoApplyNewWindows Returns Boolean
80355>>>>>        Boolean retVal
80355>>>>>        Get ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to retVal
80356>>>>>        Function_Return retVal
80357>>>>>    End_Function
80358>>>>>
80358>>>>>    Procedure Set ComAutoApplyNewWindows Boolean value
80360>>>>>        Set ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to value
80361>>>>>    End_Procedure
80362>>>>>
80362>>>>>    Function ComAutoApplyNewThreads Returns Boolean
80364>>>>>        Boolean retVal
80364>>>>>        Get ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to retVal
80365>>>>>        Function_Return retVal
80366>>>>>    End_Function
80367>>>>>
80367>>>>>    Procedure Set ComAutoApplyNewThreads Boolean value
80369>>>>>        Set ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to value
80370>>>>>    End_Procedure
80371>>>>>
80371>>>>>    Function ComLoadSkin String llResourcePath String llIniFileName Returns Boolean
80373>>>>>        Handle hDispatchDriver
80373>>>>>        Boolean retVal
80373>>>>>        Get phDispatchDriver to hDispatchDriver
80374>>>>>        Send PrepareParams to hDispatchDriver 2
80375>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
80376>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
80377>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_BOOL to retVal
80378>>>>>        Function_Return retVal
80379>>>>>    End_Function
80380>>>>>
80380>>>>>    Procedure ComApplyWindow OLE_HANDLE llhWnd
80382>>>>>        Handle hDispatchDriver
80382>>>>>        Get phDispatchDriver to hDispatchDriver
80383>>>>>        Send PrepareParams to hDispatchDriver 1
80384>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
80385>>>>>        Send InvokeComMethod to hDispatchDriver 3 OLE_VT_VOID
80386>>>>>    End_Procedure
80387>>>>>
80387>>>>>    Procedure ComEnableThemeDialogTexture OLE_HANDLE llhWnd Integer llFlags
80389>>>>>        Handle hDispatchDriver
80389>>>>>        Get phDispatchDriver to hDispatchDriver
80390>>>>>        Send PrepareParams to hDispatchDriver 2
80391>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
80392>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llFlags
80393>>>>>        Send InvokeComMethod to hDispatchDriver 4 OLE_VT_VOID
80394>>>>>    End_Procedure
80395>>>>>
80395>>>>>    Procedure ComRemoveWindow OLE_HANDLE llhWnd
80397>>>>>        Handle hDispatchDriver
80397>>>>>        Get phDispatchDriver to hDispatchDriver
80398>>>>>        Send PrepareParams to hDispatchDriver 1
80399>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
80400>>>>>        Send InvokeComMethod to hDispatchDriver 6 OLE_VT_VOID
80401>>>>>    End_Procedure
80402>>>>>
80402>>>>>    Procedure ComRemoveAllWindows
80404>>>>>        Handle hDispatchDriver
80404>>>>>        Get phDispatchDriver to hDispatchDriver
80405>>>>>        Send InvokeComMethod to hDispatchDriver 7 OLE_VT_VOID
80406>>>>>    End_Procedure
80407>>>>>
80407>>>>>    Procedure ComAddWindowClass String llClassName String llBaseClassName
80409>>>>>        Handle hDispatchDriver
80409>>>>>        Get phDispatchDriver to hDispatchDriver
80410>>>>>        Send PrepareParams to hDispatchDriver 2
80411>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
80412>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llBaseClassName
80413>>>>>        Send InvokeComMethod to hDispatchDriver 8 OLE_VT_VOID
80414>>>>>    End_Procedure
80415>>>>>
80415>>>>>    Procedure ComRemoveWindowClass String llClassName
80417>>>>>        Handle hDispatchDriver
80417>>>>>        Get phDispatchDriver to hDispatchDriver
80418>>>>>        Send PrepareParams to hDispatchDriver 1
80419>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
80420>>>>>        Send InvokeComMethod to hDispatchDriver 9 OLE_VT_VOID
80421>>>>>    End_Procedure
80422>>>>>
80422>>>>>    Function ComEnumerateSkinDirectory String llPath Boolean llRecursive Returns Variant
80424>>>>>        Handle hDispatchDriver
80424>>>>>        Variant retVal
80424>>>>>        Get phDispatchDriver to hDispatchDriver
80425>>>>>        Send PrepareParams to hDispatchDriver 2
80426>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
80427>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BOOL llRecursive
80428>>>>>        Get InvokeComMethod of hDispatchDriver 11 OLE_VT_DISPATCH to retVal
80429>>>>>        Function_Return retVal
80430>>>>>    End_Function
80431>>>>>
80431>>>>>    Function ComEnumerateSkinFile String llPath Returns Variant
80433>>>>>        Handle hDispatchDriver
80433>>>>>        Variant retVal
80433>>>>>        Get phDispatchDriver to hDispatchDriver
80434>>>>>        Send PrepareParams to hDispatchDriver 1
80435>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
80436>>>>>        Get InvokeComMethod of hDispatchDriver 12 OLE_VT_DISPATCH to retVal
80437>>>>>        Function_Return retVal
80438>>>>>    End_Function
80439>>>>>
80439>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
80441>>>>>        Handle hDispatchDriver
80441>>>>>        OLE_COLOR retVal
80441>>>>>        Get phDispatchDriver to hDispatchDriver
80442>>>>>        Send PrepareParams to hDispatchDriver 1
80443>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
80444>>>>>        Get InvokeComMethod of hDispatchDriver 14 OLE_VT_I4 to retVal
80445>>>>>        Function_Return retVal
80446>>>>>    End_Function
80447>>>>>
80447>>>>>    Procedure ComExcludeModule String llModuleName
80449>>>>>        Handle hDispatchDriver
80449>>>>>        Get phDispatchDriver to hDispatchDriver
80450>>>>>        Send PrepareParams to hDispatchDriver 1
80451>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llModuleName
80452>>>>>        Send InvokeComMethod to hDispatchDriver 15 OLE_VT_VOID
80453>>>>>    End_Procedure
80454>>>>>
80454>>>>>    Function ComCreateSchema String llResourcePath String llIniFileName Returns Variant
80456>>>>>        Handle hDispatchDriver
80456>>>>>        Variant retVal
80456>>>>>        Get phDispatchDriver to hDispatchDriver
80457>>>>>        Send PrepareParams to hDispatchDriver 2
80458>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
80459>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
80460>>>>>        Get InvokeComMethod of hDispatchDriver 16 OLE_VT_DISPATCH to retVal
80461>>>>>        Function_Return retVal
80462>>>>>    End_Function
80463>>>>>
80463>>>>>    Procedure ComSetWindowTheme OLE_HANDLE llhWnd Variant llSchema
80465>>>>>        Handle hDispatchDriver
80465>>>>>        Get phDispatchDriver to hDispatchDriver
80466>>>>>        Send PrepareParams to hDispatchDriver 2
80467>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
80468>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llSchema
80469>>>>>        Send InvokeComMethod to hDispatchDriver 17 OLE_VT_VOID
80470>>>>>    End_Procedure
80471>>>>>
80471>>>>>    Procedure ComAboutBox
80473>>>>>        Handle hDispatchDriver
80473>>>>>        Get phDispatchDriver to hDispatchDriver
80474>>>>>        Send InvokeComMethod to hDispatchDriver -552 OLE_VT_VOID
80475>>>>>    End_Procedure
80476>>>>>End_Class
80477>>>>>
80477>>>>>// CLSID: {40217CB8-4463-4030-B324-AC6A8075FEC8}
80477>>>>>// Event interface for SkinFramework Control
80477>>>>>Class cCJ_DSkinFrameworkEvents is a Mixin
80478>>>>>
80478>>>>>    Procedure RegisterComEvents
80480>>>>>    End_Procedure
80481>>>>>End_Class
80482>>>>>
80482>>>>>// CoClass
80482>>>>>// ProgID: Codejock.SkinFramework.17.3.0
80482>>>>>// CLSID: {DE67160B-9A3E-4EA6-846E-8C9A72F9F203}
80482>>>>>// SkinFramework Control
80482>>>>>Class cCJComSkinFramework is a cComActiveXControl
80483>>>>>    Import_Class_Protocol cCJ_DSkinFramework
80484>>>>>    Import_Class_Protocol cCJ_DSkinFrameworkEvents
80485>>>>>
80485>>>>>    Procedure Construct_Object
80487>>>>>        Forward Send Construct_Object
80489>>>>>        Set psProgID to "{DE67160B-9A3E-4EA6-846E-8C9A72F9F203}"
80490>>>>>        Set psEventId to "{40217CB8-4463-4030-B324-AC6A8075FEC8}"
80491>>>>>        Set psLicenseKey to ("Skin Framework Control Copyright (c) 1998-2016 Codejock Software"+ Character(13)+ Character(10)+;                             "PRODUCT-ID: Codejock.SkinFramework.ActiveX.v17.3"+ Character(13)+ Character(10)+;                             "VALIDATE-CODE: GGE-OLD-QQR-EJS")
80492>>>>>        Set peAutoCreate to acAutoCreate
80493>>>>>    End_Procedure
80494>>>>>End_Class
80495>>>>>
80495>>>>>// CLSID: {06E8A85B-70E4-4F71-A0FC-D1D5658C7E17}
80495>>>>>// SkinFramework Global Settings
80495>>>>>Class cCJISkinFrameworkGlobalSettings is a Mixin
80496>>>>>
80496>>>>>    Function ComLicense Returns String
80498>>>>>        String retVal
80498>>>>>        Get ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to retVal
80499>>>>>        Function_Return retVal
80500>>>>>    End_Function
80501>>>>>
80501>>>>>    Procedure Set ComLicense String value
80503>>>>>        Set ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to value
80504>>>>>    End_Procedure
80505>>>>>
80505>>>>>    Function ComTitle Returns String
80507>>>>>        String retVal
80507>>>>>        Get ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to retVal
80508>>>>>        Function_Return retVal
80509>>>>>    End_Function
80510>>>>>
80510>>>>>    Procedure Set ComTitle String value
80512>>>>>        Set ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to value
80513>>>>>    End_Procedure
80514>>>>>
80514>>>>>    Function ComVersion Returns String
80516>>>>>        Handle hDispatchDriver
80516>>>>>        String retVal
80516>>>>>        Get phDispatchDriver to hDispatchDriver
80517>>>>>        Get InvokeComMethod of hDispatchDriver 104 OLE_VT_BSTR to retVal
80518>>>>>        Function_Return retVal
80519>>>>>    End_Function
80520>>>>>
80520>>>>>    Function ComUnicode Returns Boolean
80522>>>>>        Handle hDispatchDriver
80522>>>>>        Boolean retVal
80522>>>>>        Get phDispatchDriver to hDispatchDriver
80523>>>>>        Get InvokeComMethod of hDispatchDriver 105 OLE_VT_BOOL to retVal
80524>>>>>        Function_Return retVal
80525>>>>>    End_Function
80526>>>>>
80526>>>>>    Function ComOcxPath Returns String
80528>>>>>        Handle hDispatchDriver
80528>>>>>        String retVal
80528>>>>>        Get phDispatchDriver to hDispatchDriver
80529>>>>>        Get InvokeComMethod of hDispatchDriver 106 OLE_VT_BSTR to retVal
80530>>>>>        Function_Return retVal
80531>>>>>    End_Function
80532>>>>>End_Class
80533>>>>>
80533>>>>>// CoClass
80533>>>>>// ProgID: Codejock.SkinFrameworkGlobalSettings.17.3.0
80533>>>>>// CLSID: {C4136A4A-67FD-4FC1-BA62-A715B4D60808}
80533>>>>>// SkinFramework Global Settings
80533>>>>>Class cCJComSkinFrameworkGlobalSettings is a cComAutomationObject
80534>>>>>    Import_Class_Protocol cCJISkinFrameworkGlobalSettings
80535>>>>>
80535>>>>>    Procedure Construct_Object
80537>>>>>        Forward Send Construct_Object
80539>>>>>        Set psProgID to "{C4136A4A-67FD-4FC1-BA62-A715B4D60808}"
80540>>>>>        Set peAutoCreate to acNoAutoCreate
80541>>>>>    End_Procedure
80542>>>>>End_Class
80543>>>>>
80543>>>>>// CLSID: {27E4AC9B-4A2D-4FBB-A782-BD76BEFA4345}
80543>>>>>Class cCJSkinIniFile is a cComAutomationObject
80544>>>>>
80544>>>>>    Function ComColorScheme Returns String
80546>>>>>        String retVal
80546>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
80547>>>>>        Function_Return retVal
80548>>>>>    End_Function
80549>>>>>
80549>>>>>    Procedure Set ComColorScheme String value
80551>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
80552>>>>>    End_Procedure
80553>>>>>
80553>>>>>    Function ComFontSize Returns String
80555>>>>>        String retVal
80555>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
80556>>>>>        Function_Return retVal
80557>>>>>    End_Function
80558>>>>>
80558>>>>>    Procedure Set ComFontSize String value
80560>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
80561>>>>>    End_Procedure
80562>>>>>
80562>>>>>    Function ComIniFileName Returns String
80564>>>>>        String retVal
80564>>>>>        Get ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to retVal
80565>>>>>        Function_Return retVal
80566>>>>>    End_Function
80567>>>>>
80567>>>>>    Procedure Set ComIniFileName String value
80569>>>>>        Set ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to value
80570>>>>>    End_Procedure
80571>>>>>End_Class
80572>>>>>
80572>>>>>// CLSID: {5005F22B-A30E-4B12-B142-E97F62A927A6}
80572>>>>>Class cCJSkinDescription is a cComAutomationObject
80573>>>>>
80573>>>>>    Function ComName Returns String
80575>>>>>        String retVal
80575>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
80576>>>>>        Function_Return retVal
80577>>>>>    End_Function
80578>>>>>
80578>>>>>    Procedure Set ComName String value
80580>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
80581>>>>>    End_Procedure
80582>>>>>
80582>>>>>    Function ComPath Returns String
80584>>>>>        String retVal
80584>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
80585>>>>>        Function_Return retVal
80586>>>>>    End_Function
80587>>>>>
80587>>>>>    Procedure Set ComPath String value
80589>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
80590>>>>>    End_Procedure
80591>>>>>
80591>>>>>    Function ComCount Returns Integer
80593>>>>>        Handle hDispatchDriver
80593>>>>>        Integer retVal
80593>>>>>        Get phDispatchDriver to hDispatchDriver
80594>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
80595>>>>>        Function_Return retVal
80596>>>>>    End_Function
80597>>>>>
80597>>>>>    Function ComIniFile Integer llIndex Returns Variant
80599>>>>>        Handle hDispatchDriver
80599>>>>>        Variant retVal
80599>>>>>        Get phDispatchDriver to hDispatchDriver
80600>>>>>        Send PrepareParams to hDispatchDriver 1
80601>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
80602>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
80603>>>>>        Function_Return retVal
80604>>>>>    End_Function
80605>>>>>
80605>>>>>    Function Com_NewEnum Returns Variant
80607>>>>>        Handle hDispatchDriver
80607>>>>>        Variant retVal
80607>>>>>        Get phDispatchDriver to hDispatchDriver
80608>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
80609>>>>>        Function_Return retVal
80610>>>>>    End_Function
80611>>>>>End_Class
80612>>>>>
80612>>>>>// CLSID: {C4367A33-2A7C-4CC6-BF0C-C50383B34B51}
80612>>>>>Class cCJSkinDescriptions is a cComAutomationObject
80613>>>>>
80613>>>>>    Function ComCount Returns Integer
80615>>>>>        Handle hDispatchDriver
80615>>>>>        Integer retVal
80615>>>>>        Get phDispatchDriver to hDispatchDriver
80616>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
80617>>>>>        Function_Return retVal
80618>>>>>    End_Function
80619>>>>>
80619>>>>>    Function ComSkin Integer llIndex Returns Variant
80621>>>>>        Handle hDispatchDriver
80621>>>>>        Variant retVal
80621>>>>>        Get phDispatchDriver to hDispatchDriver
80622>>>>>        Send PrepareParams to hDispatchDriver 1
80623>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
80624>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
80625>>>>>        Function_Return retVal
80626>>>>>    End_Function
80627>>>>>
80627>>>>>    Function Com_NewEnum Returns Variant
80629>>>>>        Handle hDispatchDriver
80629>>>>>        Variant retVal
80629>>>>>        Get phDispatchDriver to hDispatchDriver
80630>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
80631>>>>>        Function_Return retVal
80632>>>>>    End_Function
80633>>>>>End_Class
80634>>>>>
80634>>>>>// CLSID: {128507E0-C56F-43C0-BCF1-8193B35FE4C4}
80634>>>>>Class cCJSkinSchema is a cComAutomationObject
80635>>>>>End_Class
80636>>>Use cApplication.pkg
80636>>>
80636>>>Struct tSkinInformation
80636>>>    String sName     // description of the skin
80636>>>    String sSkinfile // file path. Can be relative or full
80636>>>    String sSkinIni  // section name
80636>>>End_Struct
80636>>>
80636>>>
80636>>>Class cCJSkinFramework is a cCJComSkinFramework
80637>>>    
80637>>>    Procedure Construct_Object
80639>>>        Forward Send Construct_Object
80641>>>        
80641>>>        Property String psSkinFile ""
80642>>>        Property String psSkinIni ""
80643>>>        Property Boolean pbLoadPreference False
80644>>>        
80644>>>        Set peAutoCreate to acAutoCreate
80645>>>        
80645>>>        Move Self to ghoSkinFramework
80646>>>    End_Procedure
80647>>>    
80647>>>    // return the default skin path, which is the programs directory.
80647>>>    // This requires an application object.
80647>>>    // If you want to different skin path, override this.
80647>>>    Function SkinPath Returns String
80649>>>        String sPath sPaths
80649>>>        Handle hoWorkspace
80649>>>        If ghoApplication Begin
80651>>>            Get phoWorkspace of ghoApplication to hoWorkspace
80652>>>            Get psProgramPath of hoWorkspace to sPaths
80653>>>            Get PathAtIndex of hoWorkspace sPaths 1 to sPath
80654>>>        End
80654>>>>
80654>>>        Else Begin
80655>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
80656>>>>
80656>>>        End
80656>>>>
80656>>>        Function_Return sPath
80657>>>    End_Function
80658>>>    
80658>>>    // Returns the Qualified name of psSkinFile. If the file is already qualified it just
80658>>>    // returns itself. If it is not, it uses SkinPath to get the path.
80658>>>    Function SkinQFile Returns String
80660>>>        String sFile sPath sSep
80660>>>        Boolean bQualified
80660>>>        Get psSkinFile to sFile
80661>>>        If not (IsFileNameQualified(sFile)) Begin
80663>>>            Get SkinPath to sPath
80664>>>            Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
80665>>>            Move (sPath - sSep - sFile) to sFile
80666>>>        End
80666>>>>
80666>>>        Function_Return sFile
80667>>>    End_Function
80668>>>        
80668>>>    // defines the default VDF window class mapping.    
80668>>>    Procedure OnAddVDFWindowClasses
80670>>>        Send ComAddWindowClass "DFlistbox"               "ListBox"
80671>>>        Send ComAddWindowClass "DFentry"                 "Edit"
80672>>>        Send ComAddWindowClass "DFtextbox"               "Edit"
80673>>>        Send ComAddWindowClass "DFRichEditCtrl"          "Edit"
80674>>>        Send ComAddWindowClass "DFcombobox"              "ComboBox"
80675>>>        Send ComAddWindowClass "DFformlist"              "Edit"
80676>>>        Send ComAddWindowClass "DFFormListHeader"        "SysHeader32"
80677>>>        Send ComAddWindowClass "DFbutton"                "Button"
80678>>>        Send ComAddWindowClass "HPromptBtn"              "Button"
80679>>>        Send ComAddWindowClass "Hspinbtn"                "msctls_updown32"
80680>>>        Send ComAddWindowClass "DFSysTabControl32"       "SysTabControl32"
80681>>>        Send ComAddWindowClass "DFMDIClient"             "MDIClient" 
80682>>>        Send ComAddWindowClass "DFedit"                  "edit"
80683>>>        Send ComAddWindowClass "DFlistedit"              "edit"
80684>>>        Send ComAddWindowClass "DFscrollbar"             "scrollbar"
80685>>>        Send ComAddWindowClass "DFgroup"                 "Button"
80686>>>        Send ComAddWindowClass "DFComboGrid"             "ComboBox"
80687>>>        // External class
80687>>>        Send ComAddWindowClass "cVdfAnimation"           "SysAnimate32"
80688>>>        Send ComAddWindowClass "cVdfProgressBar"         "msctls_progress32"
80689>>>        Send ComAddWindowClass "cVdfStatusBar"           "msctls_statusbar32"
80690>>>        Send ComAddWindowClass "cVdfToolbar"             "ToolbarWindow32"
80691>>>        Send ComAddWindowClass "cObsoleteVdfProgressBar" "msctls_progress32"
80692>>>        Send ComAddWindowClass "cVdfTrackBar"            "msctls_trackbar32"
80693>>>        Send ComAddWindowClass "cObsoleteBasicStatusBar" "msctls_statusbar32"
80694>>>        Send ComAddWindowClass "cVdfTreeView"            "SysTreeView32"
80695>>>    End_Procedure
80696>>>    
80696>>>    // Used to support developer designed class mappings (e.g. COM controls)
80696>>>    Procedure OnAddCustomWindowClasses
80698>>>    End_Procedure
80699>>>
80699>>>    // called when object is created during end_construct_object.
80699>>>    Procedure OnCreate
80701>>>        Integer iOpts
80701>>>        Boolean bUseWindowsFont
80701>>>        Forward Send OnCreate
80703>>>        
80703>>>        // if we are using the windows fonts we will disable the apply metrics which
80703>>>        // never really looked good anyway. This test only exists or legacy purposes
80703>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
80704>>>        If bUseWindowsFont Begin
80706>>>            Get ComApplyOptions to iOpts
80707>>>            Set ComApplyOptions to (RemoveBitValue(xtpSkinApplyMetrics, iOpts))
80708>>>        End
80708>>>>
80708>>>
80708>>>        // this works around a CJ issue where skins applied to other threads causes an exception upon close down. 
80708>>>        // We saw this with our mssql driver but it could occur elsewhere. This has been reported in the CJ newsgroup
80708>>>        // and this was the suggested workaround.
80708>>>        Set ComAutoApplyNewThreads to False
80709>>>
80709>>>        Send OnAddVDFWindowClasses
80710>>>        Send OnAddCustomWindowClasses
80711>>>        
80711>>>        // if preferences are used, it will set psSkinFile and psSkinIni
80711>>>        If (pbLoadPreference(Self)) Begin
80713>>>            Send LoadSkinPreference
80714>>>        End
80714>>>>
80714>>>        // if a skin file name exists, we apply the skin.    
80714>>>        If (psSkinFile(Self)<>"") Begin
80716>>>            Send ApplySkin
80717>>>        End        
80717>>>>
80717>>>    End_Procedure
80718>>>    
80718>>>    // called by framework as part of application exit.
80718>>>    Procedure Broadcast_Notify_Exit_Application
80720>>>        Send Notify_Exit_Application
80721>>>    End_Procedure // Notify_Exit_Application
80722>>>
80722>>>    Procedure Notify_Exit_Application
80724>>>        If (pbLoadPreference(Self)) Begin
80726>>>            Send SaveSkinPreference
80727>>>        End
80727>>>>
80727>>>    End_Procedure
80728>>>
80728>>>    Procedure NotifyPreApplySkin
80730>>>        Broadcast Send OnPreApplySkin of Desktop True       
80732>>>    End_Procedure
80733>>>
80733>>>    Procedure NotifyPostApplySkin
80735>>>        Broadcast Send OnPostApplySkin of Desktop True       
80737>>>    End_Procedure
80738>>>    
80738>>>    // returns an array of all skins in the path. If path is "", use the default path.
80738>>>    // If the default path is used, returns the file names as relative names, else use full path.
80738>>>    Function EnumerateSkins String sPath Boolean bRecursive Returns tSkinInformation[]
80740>>>        tSkinInformation[] Skins
80740>>>        tSkinInformation[] Skins
80741>>>        String sSkinName sSkinFile sDefaultPath sSep
80741>>>        Variant vSkinDescriptions vSkinDescription vSkinIniFile
80741>>>        Handle hSkinDescriptions hSkinDescription hSkinIniFile
80741>>>        Integer iSkinsCount iSkinFilesCount iNumSkins iNumSkinFiles iArrayItem
80741>>>        Integer iPos iDfltLen
80741>>>        Boolean bUseRelativePath
80741>>>        
80741>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
80742>>>        
80742>>>        Get SkinPath to sDefaultPath
80743>>>        If (sPath="") Begin
80745>>>            Move sDefaultPath to sPath
80746>>>        End
80746>>>>
80746>>>        Move (Uppercase(sDefaultPath)) to sDefaultPath
80747>>>        Move (Length(sDefaultPath)) to iDfltLen
80748>>>        Move (sDefaultPath=Uppercase(sPath)) to bUseRelativePath
80749>>>
80749>>>        Get ComEnumerateSkinDirectory sPath bRecursive to vSkinDescriptions
80750>>>        If (not(IsNullComObject(vSkinDescriptions))) Begin
80752>>>
80752>>>            Get Create U_cCJSkinDescriptions to hSkinDescriptions
80753>>>            Get Create U_cCJSkinDescription to hSkinDescription
80754>>>            Get Create U_cCJSkinIniFile to hSkinIniFile
80755>>>            
80755>>>            Set pvComObject of hSkinDescriptions to vSkinDescriptions
80756>>>            Get ComCount of hSkinDescriptions to iNumSkinFiles
80757>>>            
80757>>>            For iSkinFilesCount from 0 to (iNumSkinFiles-1)
80763>>>>
80763>>>                Get ComSkin of hSkinDescriptions iSkinFilesCount to vSkinDescription
80764>>>                Set pvComObject of hSkinDescription to vSkinDescription
80765>>>
80765>>>                Get ComCount of hSkinDescription to iNumSkins
80766>>>                    
80766>>>                For iSkinsCount from 0 to (iNumSkins-1)
80772>>>>
80772>>>                    Get ComIniFile of hSkinDescription iSkinsCount to vSkinIniFile
80773>>>                    Set pvComObject of hSkinIniFile to vSkinIniFile
80774>>>
80774>>>                    Get ComName of hSkinDescription to Skins[iArrayItem].sName
80775>>>                    Get ComPath of hSkinDescription to sSkinFile
80776>>>                    If bUseRelativePath Begin
80778>>>                        Move (pos(sDefaultPath,uppercase(sSkinFile))) to iPos
80779>>>                        If iPos Begin
80781>>>                            Move (Remove(sSkinFile,iPos,iDfltLen)) to sSkinFile   
80782>>>                            While (Left(sSkinFile,1)=sSep)
80786>>>                                Move (Remove(sSkinFile,1,1)) to sSkinFile   
80787>>>                            Loop                         
80788>>>>
80788>>>                        End
80788>>>>
80788>>>                    End
80788>>>>
80788>>>                    Move sSkinFile to Skins[iArrayItem].sSkinfile
80789>>>                    Get ComIniFileName of hSkinIniFile to Skins[iArrayItem].sSkinIni
80790>>>
80790>>>                    Increment iArrayItem
80791>>>                Loop
80792>>>>
80792>>>            Loop
80793>>>>
80793>>>                            
80793>>>            Send Destroy of hSkinDescriptions
80794>>>            Send Destroy of hSkinDescription
80795>>>            Send Destroy of hSkinIniFile
80796>>>                
80796>>>        End
80796>>>>
80796>>>        Function_Return Skins
80797>>>    End_Function 
80798>>>    
80798>>>    // Save the skin preference. This requires an application object.
80798>>>    // Only do this if the application object allows it. 
80798>>>    // This is called during startup if pbLoadPreference is True
80798>>>    // Suitable for override
80798>>>    Procedure SaveSkinPreference 
80800>>>        String sSkin sIni
80800>>>        If ghoApplication Begin
80802>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
80804>>>                Get psSkinFile to sSkin
80805>>>                Get psSkinIni to sIni
80806>>>                Send WriteString of ghoApplication "Preferences" "SkinFile" sSkin
80807>>>                Send WriteString of ghoApplication "Preferences" "SkinIni" sIni
80808>>>            End
80808>>>>
80808>>>        End
80808>>>>
80808>>>        Else Begin
80809>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
80810>>>>
80810>>>        End
80810>>>>
80810>>>    End_Procedure
80811>>>
80811>>>    // Load the skin preference. This requires an application object.
80811>>>    // Only do this if the application object allows it. 
80811>>>    // This is called during startup if pbLoadPreference is True
80811>>>    // Suitable for override
80811>>>    Procedure LoadSkinPreference 
80813>>>        String sSkin sIni
80813>>>        Boolean bExists
80813>>>        If ghoApplication Begin
80815>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
80817>>>                Get ValueExists of ghoApplication "Preferences" "SkinFile" to bExists
80818>>>                If bExists Begin
80820>>>                    Get ReadString of ghoApplication "Preferences" "SkinFile" "" to sSkin
80821>>>                    Get ReadString of ghoApplication "Preferences" "SkinIni" "" to sIni
80822>>>                    Set psSkinFile to sSkin
80823>>>                    Set psSkinIni to sIni
80824>>>                End
80824>>>>
80824>>>            End
80824>>>>
80824>>>        End
80824>>>>
80824>>>        Else Begin
80825>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
80826>>>>
80826>>>        End
80826>>>>
80826>>>    End_Procedure
80827>>>
80827>>>    // Can be called to apply the current skin.
80827>>>    Procedure ApplySkin
80829>>>        Boolean bOk
80829>>>        String sSkin sIni
80829>>>        If (IsComObjectCreated(Self)) Begin
80831>>>            Get SkinQFile to sSkin
80832>>>            Get psSkinIni to sIni
80833>>>            
80833>>>            Send NotifyPreApplySkin
80834>>>            // when skins are used we don't want to use built in Visual Styles
80834>>>            Send EnableVisualStyles of Desktop (sSkin="")
80835>>>            Get ComLoadSkin sSkin sIni to bOK
80836>>>            If (sSkin<>"" and not(bOk)) Begin
80838>>>                // if not ok, no skin was appied. Enable visual styles
80838>>>                Send EnableVisualStyles of Desktop True
80839>>>            End
80839>>>>
80839>>>            Send NotifyPostApplySkin
80840>>>        End
80840>>>>
80840>>>    End_Procedure
80841>>>
80841>>>
80841>>>End_Class
80842>
80842>Object oHtmlHelp is a cHtmlHelp
80844>End_Object
80845>
80845>Object oApplication is a cApplication
80847>    Set peHelpType to htHtmlHelp
80848>    Set psHelpFile to "DataFlex.chm"
80849>    Set psCompany to "RDC Tools International"
80850>    Set psProduct to "The Database Update Framework - SQL Connections Manager"
80851>    Set psVersion to (String(piVersionMajor(phoVersionInfo(Self))) + "." + String(piVersionMinor(phoVersionInfo(Self))))
80852>    Set psAutoOpenWorkspace to ""
80853>
80853>    Property String psCommandLineIniFilePath ""
80855>    Property Boolean pbIniFileExists False
80857>
80857>    Procedure OnCreate
80860>        Integer eOpened
80860>        Handle hoCmdLine
80860>        String sArgument sPath sFileName sWsFile
80860>        Integer iRetval
80860>        Boolean bExists
80860>
80860>        Get phoCommandLine to hoCmdLine
80861>        Get Argument of hoCmdLine 1 to sArgument
80862>        If (sArgument <> "") Begin
80864>            Get ParseFolderName sArgument to sPath
80865>            Get vFolderExists sPath to iRetval
80866>            If (iRetval = True) Begin
80868>                Set psCommandLineIniFilePath to sPath
80869>                Get vFilePathExists (sPath + "SQLConnections.ini") to bExists
80870>                Set pbIniFileExists to bExists
80871>            End
80871>        End
80871>
80871>        Get OpenWorkspaceFile of (phoWorkspace(Self)) "config.ws" to eOpened
80872>        If (eOpened <> wsWorkspaceOpened) Begin
80874>            Get GetApplicationPath to sPath
80875>            Get vSelect_File "Workspace Files (*.ws)|*.ws|All Files (*.*)|*.*" "Please select a Workspace file (*.ws)" sPath to sWsFile
80876>            Get vFilePathExists sWsFile to bExists
80877>            If (bExists = False) Begin
80879>                Send Stop_Box "No Workspace file selected. Cannot continue!"
80880>                Send Exit_Application
80881>            End
80881>            Get OpenWorkspaceFile of (phoWorkspace(Self)) sWsFile to eOpened
80882>            If (eOpened <> wsWorkspaceOpened) Begin
80884>                Set psHome          of (phoWorkspace(Self)) to sPath
80885>                Set psProgramPath   of (phoWorkspace(Self)) to sPath
80886>                Set psDataPath      of (phoWorkspace(Self)) to sPath
80887>                Set psFileList      of (phoWorkspace(Self)) to sPath
80888>                Set psHelpPath      of (phoWorkspace(Self)) to sPath
80889>                Set psBitmapPath    of (phoWorkspace(Self)) to sPath
80890>            End
80890>        End
80890>    End_Procedure
80891>
80891>
80891>End_Object
80892>
80892>// Unmark these Define lines if using Mertech drivers!
80892>Define DUF_Use_Mertech_Drivers
80892>
80892>Use cSQLConnectionHandler.pkg
Including file: cSQLConnectionHandler.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cSQLConnectionHandler.pkg)
80892>>>//****************************************************************************
80892>>>// $Module type: Class
80892>>>// $Module name: cSQLConnectionHandler.pkg
80892>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
80892>>>// Web-site    : http://www.rdctools.com
80892>>>// Created     : 2015-08-11 @ 16:02 (Military date format: YY-MM-DD)
80892>>>//
80892>>>// Description : A handler class for using CLI connection ID's to login to a database server.
80892>>>//
80892>>>// $Rev History:
80892>>>//    2015-08-11  Module header created
80892>>>//    2016-09-26  Changed name of the objecthandle from ghoCreateConnectionID to ghoSQLConnectionHandler.
80892>>>//                Added a new structure for passing connection data back & forth.
80892>>>//                Added better error handling.
80892>>>//                Added a decompose message for the connection string.
80892>>>//    2017-01-09  Added support for Mertech drivers
80892>>>//                Big overhaul to comply better with "Managed Connections" (DF 19)
80892>>>//                These changes make the class compatible with DFConnId.ini (can read/write DAW connection ini-files)
80892>>>//    2017-02-12  Reworked the whole connection property interface.
80892>>>//                Now there is one struct property that is the at cencter of a connection.
80892>>>//****************************************************************************
80892>>>Use cli.pkg
80892>>>Use MSSqldrv.pkg
Including file: MSSqldrv.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\MSSqldrv.pkg)
80892>>>>>//*****************************************************************************
80892>>>>>//*** MSSQLDRV.PKG                                                          ***
80892>>>>>//***                                                                       ***
80892>>>>>//*** Author: Ben Weijers                                                   ***
80892>>>>>//***         Data Access Nederland                                         ***
80892>>>>>//***         29 June 1998                                                  ***
80892>>>>>//***                                                                       ***
80892>>>>>//***                                                                       ***
80892>>>>>//*** Purpose:                                                              ***
80892>>>>>//***   Package that declares MS SQL driver constants and functions.        ***
80892>>>>>//****                                                                      ***
80892>>>>>//***   This package can be used by developers who want to add Data Access  ***
80892>>>>>//***   MS SQL Client specific code to a DataFlex application.              ***
80892>>>>>//***   Updated:  June 4th 2012 (Current CK build: 5.1.0.96)                ***
80892>>>>>//***             Changed EnumerateServers function to use the highest      ***
80892>>>>>//***             available SQL Server client driver.                       ***
80892>>>>>//***             Moved SQL Server client constants from cli.pkg to         ***
80892>>>>>//***             mssqldrv.pkg                                              ***
80892>>>>>//***   Updated:  November 6th 2013 (Current CK build: 6.0.0.19)            ***
80892>>>>>//***             Added constants for SQL Server specific native types      ***
80892>>>>>//***             ( var...(max) types, money types, datetime types)         ***
80892>>>>>//*****************************************************************************
80892>>>>>
80892>>>>>Use Cli.pkg
80892>>>>>Use SQL.pkg
80892>>>>>
80892>>>>>//*** Driver Indentification
80892>>>>>
80892>>>>>//*** Error number constants
80892>>>>>
80892>>>>>
80892>>>>>//*** Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
80892>>>>>
80892>>>>>
80892>>>>>
80892>>>>>
80892>>>>>
80892>>>>>
80892>>>>>// SQL Server spcific types. 
80892>>>>>Define SQL_SS_TIMESTAMPOFFSET   for   (-155) //SQL server datetimeoffset type */
80892>>>>>Define SQL_SS_TIME2             for   (-154) //SQL server time type */
80892>>>>>Define SQL_SS_XML               for   (-152) //SQL server xml type */
80892>>>>>Define SQL_SS_VARIANT           for   (-150) //SQL server variant type */
80892>>>>>
80892>>>>>// SQL Server spcific types. 
80892>>>>>Define SQL_TYPE_TIMESTAMP2      for   (-200) //SQL server datetime2 type */
80892>>>>>Define SQL_VARCHARMAX           for   (-201) //SQL server varchar(max) type */
80892>>>>>Define SQL_WVARCHARMAX          for   (-202) //SQL server wvarchar(max) type */
80892>>>>>Define SQL_VARBINARYMAX         for   (-203) //SQL server varbinary(max) type */
80892>>>>>Define SQL_TYPE_MONEY           for   (-204) //SQL server money type */
80892>>>>>Define SQL_TYPE_SMALLMONEY      for   (-205) //SQL server smallmoney type */
80892>>>>>Define SQL_TYPE_SMALLDATETIME   for   (-206) //SQL server smalldatetype type */
80892>>>>>
80892>>>>>
80892>>>>>//*****************************************************************************
80892>>>>>//*** MSSQL_SetConstraint <FileNum> <ConstraintText>                        ***
80892>>>>>//***                                                                       ***
80892>>>>>//***   Setup a constraint for a file.                                      ***
80892>>>>>//*****************************************************************************
80892>>>>>
80892>>>>>
80892>>>>>
80892>>>>>Class cMSSQLHandler Is A cCLIHandler
80893>>>>>
80893>>>>>    Procedure Construct_Object
80895>>>>>        Forward Send Construct_Object
80897>>>>>
80897>>>>>        Set psDriverID To MSSQLDRV_ID
80898>>>>>    End_Procedure // Construct_Object
80899>>>>>
80899>>>>>
80899>>>>>
80899>>>>>    //***
80899>>>>>    //*** Function: ExtractList
80899>>>>>    //*** Purpose : Extract the list from the out connect string.
80899>>>>>    //***
80899>>>>>
80899>>>>>    Function ExtractList String sOutConnStr Integer hoStore Returns Integer
80901>>>>>        Local String  sItem
80901>>>>>        Local Integer iStart
80901>>>>>        Local Integer iEnd
80901>>>>>
80901>>>>>        If (hoStore = 0) ;            Move Current_object To hoStore
80904>>>>>
80904>>>>>        Send Delete_Data To hoStore
80905>>>>>        Move (Pos("{", sOutConnStr)) To iStart
80906>>>>>        While (iStart > 0)
80910>>>>>            Move (Right(sOutConnStr, Length(sOutConnStr) - iStart)) To sOutConnStr
80911>>>>>            If (Left(sOutConnStr, 1) = "}") ;                Move 0 To iStart
80914>>>>>            Else Begin
80915>>>>>                Move (Pos(",", sOutConnStr)) To iStart
80916>>>>>                Move (Pos("}", sOutConnStr)) To iEnd
80917>>>>>                If ((iStart = 0) Or (iEnd < iStart)) ;                    Move iEnd To iStart
80920>>>>>
80920>>>>>                If (iStart > 0) ;                    Set Value Of hoStore Item (Item_Count(Current_Object)) To (Left(sOutConnStr, iStart - 1))
80923>>>>>
80923>>>>>                If (iStart = iEnd) ;                    Move 0 To iStart
80926>>>>>            End
80926>>>>>>
80926>>>>>        Loop
80927>>>>>>
80927>>>>>
80927>>>>>        Function_Return (Item_Count(hoStore))
80928>>>>>    End_Procedure // ExtractList
80929>>>>>
80929>>>>>
80929>>>>>
80929>>>>>    //***
80929>>>>>    //*** Function: BrowseConnect
80929>>>>>    //*** Purpose : Call the driver's browse connect function
80929>>>>>    //***
80929>>>>>
80929>>>>>    Function BrowseConnect String sInConnStr Returns String
80931>>>>>        Local String  sDriver
80931>>>>>        Local String  sOutConnStr
80931>>>>>        Local Integer iArg
80931>>>>>        Local Integer iRetval
80931>>>>>
80931>>>>>        Get psDriverID To sDriver
80932>>>>>        If (sDriver <> "") Begin
80934>>>>>            Move (Repeat(" ", 8192)) To sOutConnStr
80935>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
80940>>>>>        End
80940>>>>>>
80940>>>>>
80940>>>>>        Function_Return sOutConnStr
80941>>>>>    End_Function// BrowseConnect
80942>>>>>
80942>>>>>
80942>>>>>    Function BrowseConnectLocal String sInConnStr Returns String
80944>>>>>        Local String  sDriver
80944>>>>>        Local String  sOutConnStr
80944>>>>>        Local Integer iArg
80944>>>>>        Local Integer iRetval
80944>>>>>        
80944>>>>>        Move 1 to iArg // Browses only local
80945>>>>>
80945>>>>>        Get psDriverID to sDriver
80946>>>>>        If (sDriver <> "") Begin
80948>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
80949>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
80954>>>>>        End
80954>>>>>>
80954>>>>>
80954>>>>>        Function_Return sOutConnStr
80955>>>>>    End_Function// BrowseConnect
80956>>>>>
80956>>>>>
80956>>>>>    Function DriverIndex String sDriver Returns Integer
80958>>>>>    
80958>>>>>        Local String  sCurrentDriver
80958>>>>>        Local Integer iNumberOfDrivers iDriver iCount
80958>>>>>    
80958>>>>>        Move 0 to iDriver
80959>>>>>    
80959>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
80962>>>>>        For iCount from 1 to iNumberOfDrivers
80968>>>>>>
80968>>>>>    
80968>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
80971>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriver) ) Begin
80973>>>>>                Move iCount to iDriver
80974>>>>>            End
80974>>>>>>
80974>>>>>        Loop
80975>>>>>>
80975>>>>>    
80975>>>>>        Function_Return iDriver
80976>>>>>    
80976>>>>>    End_Function 
80977>>>>>
80977>>>>>    Function EnumerateServersNetworkOrLocal Integer iNetworkLocal  Returns Integer
80979>>>>>        
80979>>>>>        Local String  sServerList
80979>>>>>        Local Integer iNumServers
80979>>>>>        Local Integer iDriver
80979>>>>>        Local Integer iClientVersion
80979>>>>>        Local String  sDriver
80979>>>>>        
80979>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
80980>>>>>
80980>>>>>        If (iDriver) Begin
80982>>>>>                
80982>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
80985>>>>>            
80985>>>>>            Case Begin
80985>>>>>    
80985>>>>>                Case (iClientVersion = SQLSERVER2016CLIENT)
80987>>>>>                    Move SQLSERVER2016DRVRSTR to sDriver
80988>>>>>                    Case Break
80989>>>>>    
80989>>>>>                Case (iClientVersion = SQLSERVER2014CLIENT)
80992>>>>>                    Move SQLSERVER2014DRVRSTR to sDriver
80993>>>>>                    Case Break
80994>>>>>            
80994>>>>>                Case (iClientVersion = SQLSERVER2012CLIENT)
80997>>>>>                    Move SQLSERVER2012DRVRSTR to sDriver
80998>>>>>                    Case Break
80999>>>>>    
80999>>>>>                Case (iClientVersion = SQLSERVER2008CLIENT)
81002>>>>>                    Move SQLSERVER2008DRVRSTR to sDriver
81003>>>>>                    Case Break
81004>>>>>    
81004>>>>>                Case (iClientVersion = SQLSERVER2005CLIENT)
81007>>>>>                    Move SQLSERVER2005DRVRSTR to sDriver
81008>>>>>                    Case Break
81009>>>>>            
81009>>>>>                Case (iClientVersion = SQLSERVER2000CLIENT)
81012>>>>>                    Move SQLSERVER2000DRVRSTR to sDriver
81013>>>>>                    Case Break
81014>>>>>            
81014>>>>>                Case Else
81014>>>>>                    Move SQLSERVER2000DRVRSTR to sDriver
81015>>>>>            
81015>>>>>            Case End
81015>>>>>    
81015>>>>>            Move ("DRIVER={" + sDriver + "};") to sDriver
81016>>>>>            If (iNetworkLocal = 0) Begin
81018>>>>>                Get BrowseConnect sDriver to sServerList
81019>>>>>            End
81019>>>>>>
81019>>>>>            Else Begin
81020>>>>>                Get BrowseConnectLocal sDriver to sServerList
81021>>>>>            End
81021>>>>>>
81021>>>>>            Get ExtractList sServerList Current_object to iNumServers
81022>>>>>        End
81022>>>>>>
81022>>>>>        
81022>>>>>        Function_Return iNumServers
81023>>>>>        
81023>>>>>    End_Function
81024>>>>>
81024>>>>>    //***
81024>>>>>    //*** Procedure: EnumerateServers
81024>>>>>    //*** Purpose  : Enumerate the available SQL Server database servers
81024>>>>>    //***            This function will return all SQL Server instances on the network. 
81024>>>>>    //***            This may take a long time. 
81024>>>>>    //***            To enumerate only local SQL Server instances use EnumerateServersLocal 
81024>>>>>    Function EnumerateServers Returns Integer
81026>>>>>
81026>>>>>        Local Integer iNumServers
81026>>>>>        Local Integer iNetworkLocal
81026>>>>>        
81026>>>>>        Move 0 to iNetworkLocal // 0 = enumerate network servers
81027>>>>>        
81027>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
81028>>>>>        
81028>>>>>        Function_Return iNumServers
81029>>>>>        
81029>>>>>    End_Function
81030>>>>>
81030>>>>>
81030>>>>>    //***
81030>>>>>    //*** Procedure: EnumerateServersLocal
81030>>>>>    //*** Purpose  : Enumerate the available SQL Server database servers
81030>>>>>    //***            This function will return only return SQL Server instance on the local machine
81030>>>>>    //***            To enumerate all SQL Server instances in a network use EnumerateServers
81030>>>>>    Function EnumerateServersLocal Returns Integer
81032>>>>>
81032>>>>>        Local Integer iNumServers
81032>>>>>        Local Integer iNetworkLocal
81032>>>>>        
81032>>>>>        Move 1 to iNetworkLocal // 1 = enumerate local servers
81033>>>>>        
81033>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
81034>>>>>        
81034>>>>>        Function_Return iNumServers
81035>>>>>        
81035>>>>>    End_Function
81036>>>>>
81036>>>>>    
81036>>>>>
81036>>>>>    //***
81036>>>>>    //*** Function: EnumerateDatabases
81036>>>>>    //*** Purpose : Enumerate database in a given server.
81036>>>>>    //***
81036>>>>>
81036>>>>>    Function EnumerateDatabases String sServer String sUser String sPassWord Returns Integer
81038>>>>>        Local Integer hoSQL
81038>>>>>        Local String  sConnect
81038>>>>>        Local String  sDatabase
81038>>>>>        Local Integer hdbc
81038>>>>>        Local Integer hstmt
81038>>>>>        Local Integer iFetchResult
81038>>>>>
81038>>>>>        If (Num_Arguments < 3) ;            Move "" To sPassWord
81041>>>>>        If (Num_Arguments < 2) ;            Move "" To sUser
81044>>>>>
81044>>>>>        If (sUser <> "") ;            Move ("SERVER=" + Trim(sServer) + ";UID=" + Trim(sUser) + ";PWD=" + Trim(sPassword) + ";") To sConnect
81047>>>>>        Else ;            Move ("SERVER=" + Trim(sServer) + ";Trusted_Connection=yes") To sConnect
81049>>>>>
81049>>>>>        Object oEnumDBSQLmanager Is A cSQLHandleManager
81051>>>>>            Move Current_Object To hoSQL
81052>>>>>        End_Object // oEnumDBSQLManager
81053>>>>>
81053>>>>>        If (hoSQL <> 0) Begin
81055>>>>>            Get SQLConnect Of hoSQL "MSSQLDRV" sConnect To hdbc
81056>>>>>            If (hdbc <> 0) Begin
81058>>>>>                Get SQLOpen Of hdbc To hstmt
81059>>>>>                If (hstmt <> 0) Begin
81061>>>>>                    //*** We could do a direct select on the sysdatabases table but we use
81061>>>>>                    //*** the stored procedure sp_database instead. SQL Server recommends this
81061>>>>>                    //*** approach in case meta data might change, the stored procedure will
81061>>>>>                    //*** stay the same.
81061>>>>>                    Send SQLSetProcedureName To hstmt "sp_databases"
81062>>>>>                    Send SQLCall To hstmt
81063>>>>>                    Repeat
81063>>>>>>
81063>>>>>                        Get SQLFetch Of hstmt To iFetchResult
81064>>>>>                        If (iFetchResult <> 0) Begin
81066>>>>>                            Get SQLColumnValue Of hstmt 1 To sDatabase
81067>>>>>                            Set Value Item (Item_Count(Current_Object)) To sDatabase
81068>>>>>                        End
81068>>>>>>
81068>>>>>                    Until (iFetchResult = 0)
81070>>>>>
81070>>>>>                    Send SQLClose To hstmt
81071>>>>>                End
81071>>>>>>
81071>>>>>                Send SQLDisconnect To hdbc
81072>>>>>            End
81072>>>>>>
81072>>>>>        End
81072>>>>>>
81072>>>>>        Send Destroy_Object To hoSQL
81073>>>>>
81073>>>>>        Function_return (Item_Count(Current_Object))
81074>>>>>    End_Function // EnumerateDatabases
81075>>>>>
81075>>>>>
81075>>>>>    Function SqlServerClientVersionName Integer iClientVersion  Returns String
81077>>>>>        
81077>>>>>        Local String  sSqlServerClientVersionName
81077>>>>>        
81077>>>>>            
81077>>>>>        Case Begin
81077>>>>>
81077>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
81079>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
81080>>>>>                Case Break
81081>>>>>
81081>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
81084>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
81085>>>>>                Case Break
81086>>>>>        
81086>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
81089>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
81090>>>>>                Case Break
81091>>>>>
81091>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
81094>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
81095>>>>>                Case Break
81096>>>>>
81096>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
81099>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
81100>>>>>                Case Break
81101>>>>>        
81101>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
81104>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
81105>>>>>                Case Break
81106>>>>>        
81106>>>>>            Case Else
81106>>>>>                Move SQLSERVERUNKNOWNCLIENTNAME to sSqlServerClientVersionName
81107>>>>>        
81107>>>>>        Case End
81107>>>>>    
81107>>>>>        
81107>>>>>        Function_Return sSqlServerClientVersionName
81108>>>>>        
81108>>>>>    End_Function
81109>>>>>
81109>>>>>
81109>>>>>End_Class // cMSSQLHandler
81110>>>>>
81110>>>Use db2_drv.pkg
Including file: db2_drv.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\db2_drv.pkg)
81110>>>>>//*****************************************************************************
81110>>>>>//*** DB2_DRV.PKG                                                           ***
81110>>>>>//***                                                                       ***
81110>>>>>//*** Author: Ben Weijers                                                   ***
81110>>>>>//***         Data Access Nederland                                         ***
81110>>>>>//***         30 July 1998                                                  ***
81110>>>>>//***                                                                       ***
81110>>>>>//*** Last updated: May 2, 2007                                                                      ***
81110>>>>>//***                                                                       ***
81110>>>>>//*** Purpose:                                                              ***
81110>>>>>//***   Package that declares DB2 driver constants and functions.           ***
81110>>>>>//****                                                                      ***
81110>>>>>//***   This package can be used by developers who want to add DB2 driver   ***
81110>>>>>//***   specific code to a DataFlex application.                            ***
81110>>>>>//*****************************************************************************
81110>>>>>
81110>>>>>Use Cli.pkg
81110>>>>>
81110>>>>>//*** Driver attributes
81110>>>>>
81110>>>>>
81110>>>>>//*** Driver Indentification
81110>>>>>
81110>>>>>//*** Error number constants
81110>>>>>
81110>>>>>//*** Call driver function identifiers
81110>>>>>
81110>>>>>// DB2 specific data types
81110>>>>>Define SQL_CLOB           for   (-99)  
81110>>>>>Define SQL_BLOB           for   (-98)  
81110>>>>>Define SQL_XML            for   (-370) 
81110>>>>>// DB2 Graphic types are Unicode types
81110>>>>>Define SQL_GRAPHIC        for   (-95)  
81110>>>>>Define SQL_VARGRAPHIC     for   (-96)  
81110>>>>>Define SQL_LONGVARGRAPHIC for   (-97)  
81110>>>>>Define SQL_DBCLOB         for   (-350) 
81110>>>>>
81110>>>>>
81110>>>>>//*** Extra DB2 commands
81110>>>>>
81110>>>>>
81110>>>>>//*****************************************************************************
81110>>>>>//*** DB2_CheckTrigger <NewState>                                           ***
81110>>>>>//***                                                                       ***
81110>>>>>//*** This command will set the trigger check at open on or off.            ***
81110>>>>>//*****************************************************************************
81110>>>>>
81110>>>>>
81110>>>>>
81110>>>>>//*****************************************************************************
81110>>>>>//*** DB2_SetConstraint <FileNum> <ConstraintText>                          ***
81110>>>>>//***                                                                       ***
81110>>>>>//***   Setup a constraint for a file.                                      ***
81110>>>>>//*****************************************************************************
81110>>>>>
81110>>>>>
81110>>>>>
81110>>>>>Class cDB2Handler Is A cCLIHandler
81111>>>>>
81111>>>>>    Procedure Construct_Object
81113>>>>>        Forward Send Construct_Object
81115>>>>>
81115>>>>>        Set psDriverID To DB2_DRV_ID
81116>>>>>    End_Procedure // Construct_Object
81117>>>>>
81117>>>>>
81117>>>>>
81117>>>>>    //***
81117>>>>>    //*** Procedure: SeedDataSources
81117>>>>>    //*** Purpose  : Reset the datasource list to the beginning
81117>>>>>    //***
81117>>>>>
81117>>>>>    Procedure SeedDataSources
81119>>>>>        Local String  sDriver
81119>>>>>        Local String  sVoid
81119>>>>>        Local Integer iRetval
81119>>>>>
81119>>>>>        Get psDriverID To sDriver
81120>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid SQL_FETCH_ALL Result iRetval
81127>>>>>    End_Procedure // SeedDataSources
81128>>>>>
81128>>>>>
81128>>>>>
81128>>>>>    //***
81128>>>>>    //*** Function: DataSources
81128>>>>>    //*** Purpose : Call the driver's data sources function
81128>>>>>    //***
81128>>>>>
81128>>>>>    Function DataSources Returns String
81130>>>>>        Local String  sDriver
81130>>>>>        Local String  sDataSource
81130>>>>>        Local String  sDescription
81130>>>>>        Local Integer iLength
81130>>>>>        Local Integer iRetval
81130>>>>>
81130>>>>>        Get psDriverID To sDriver
81131>>>>>        If (sDriver <> "") Begin
81133>>>>>            Move 8192 To iLength
81134>>>>>            Move (Repeat(" ", iLength)) To sDataSource
81135>>>>>            Move (Repeat(" ", iLength)) To sDescription
81136>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
81141>>>>>        End
81141>>>>>>
81141>>>>>
81141>>>>>        If (sDataSource <> "" Or sDescription <> "") ;            Function_Return (sDataSource + "," +  sDescription)
81144>>>>>        Else ;            Function_Return ""
81146>>>>>    End_Function// DataSources
81147>>>>>
81147>>>>>End_Class // cODBCHandler
81148>>>>>
81148>>>>>
81148>>>Use odbc_drv.pkg
Including file: odbc_drv.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\odbc_drv.pkg)
81148>>>>>//*****************************************************************************
81148>>>>>//*** ODBC_DRV.PKG                                                          ***
81148>>>>>//***                                                                       ***
81148>>>>>//*** Author: Ben Weijers                                                   ***
81148>>>>>//***         Data Access Nederland                                         ***
81148>>>>>//***         3 February 1998                                               ***
81148>>>>>//***                                                                       ***
81148>>>>>//*** Last updated: May 2, 2007                                                                      ***
81148>>>>>//***                                                                       ***
81148>>>>>//*** Purpose:                                                              ***
81148>>>>>//***   Package that declares ODBC driver constants and functions.          ***
81148>>>>>//****                                                                      ***
81148>>>>>//***   This package can be used by developers who want to add Data Access  ***
81148>>>>>//***   ODBC Client specific code to a DataFlex application.                ***
81148>>>>>//*****************************************************************************
81148>>>>>
81148>>>>>Use Cli.pkg
81148>>>>>
81148>>>>>//*** Driver Indentification
81148>>>>>
81148>>>>>//*** Error number constants
81148>>>>>
81148>>>>>//*** Call driver function identifiers
81148>>>>>
81148>>>>>//*** Extra ODBC commands
81148>>>>>
81148>>>>>
81148>>>>>//*****************************************************************************
81148>>>>>//*** ODBCManage                                                            ***
81148>>>>>//***                                                                       ***
81148>>>>>//*** Start the ODBC manager.                                               ***
81148>>>>>//*****************************************************************************
81148>>>>>
81148>>>>>
81148>>>>>
81148>>>>>//*****************************************************************************
81148>>>>>//*** ODBCNumberOfDataSources To <NumDSN>                                   ***
81148>>>>>//***                                                                       ***
81148>>>>>//*** Returns the number of data sources.                                   ***
81148>>>>>//*****************************************************************************
81148>>>>>
81148>>>>>
81148>>>>>//*****************************************************************************
81148>>>>>//*** ODBCDSNName <DSNNumber> To <DSNName>                                  ***
81148>>>>>//***                                                                       ***
81148>>>>>//*** Returns the name of the data source.                                  ***
81148>>>>>//*****************************************************************************
81148>>>>>
81148>>>>>
81148>>>>>//*****************************************************************************
81148>>>>>//*** ODBCEnumerateTables <DSNName> To <TableNum>                           ***
81148>>>>>//***                                                                       ***
81148>>>>>//*** Builds internal table array and returns the number of tables in the   ***
81148>>>>>//*** DSN.                                                                  ***
81148>>>>>//*****************************************************************************
81148>>>>>
81148>>>>>
81148>>>>>//*****************************************************************************
81148>>>>>//*** ODBCTableName <TableNum> To <TableName>                               ***
81148>>>>>//***                                                                       ***
81148>>>>>//*** Returns the name of the table.                                        ***
81148>>>>>//*****************************************************************************
81148>>>>>
81148>>>>>
81148>>>>>//*****************************************************************************
81148>>>>>//*** ODBCSchemaName <TableNum> To <SchemaName>                             ***
81148>>>>>//***                                                                       ***
81148>>>>>//*** Returns the schema name of the table.                                 ***
81148>>>>>//*****************************************************************************
81148>>>>>
81148>>>>>
81148>>>>>//*****************************************************************************
81148>>>>>//*** ODBCNumberOfFields <DSNName> <TableName> To <NumDSN>                  ***
81148>>>>>//***                                                                       ***
81148>>>>>//*** Returns the number of fields.                                         ***
81148>>>>>//*****************************************************************************
81148>>>>>
81148>>>>>
81148>>>>>//*****************************************************************************
81148>>>>>//*** ODBCFieldName <FieldNumber> To <FieldName>                            ***
81148>>>>>//***                                                                       ***
81148>>>>>//*** Returns the name of the field.                                  ***
81148>>>>>//*****************************************************************************
81148>>>>>
81148>>>>>
81148>>>>>
81148>>>>>//*****************************************************************************
81148>>>>>//*** ODBC_SetConstraint <FileNum> <ConstraintText>                         ***
81148>>>>>//***                                                                       ***
81148>>>>>//***   Setup a constraint for a file.                                      ***
81148>>>>>//*****************************************************************************
81148>>>>>
81148>>>>>
81148>>>>>
81148>>>>>Class cODBCHandler Is A cCLIHandler
81149>>>>>
81149>>>>>    Procedure Construct_Object
81151>>>>>        Forward Send Construct_Object
81153>>>>>
81153>>>>>        Set psDriverID To ODBC_DRV_ID
81154>>>>>    End_Procedure // Construct_Object
81155>>>>>
81155>>>>>
81155>>>>>
81155>>>>>    //***
81155>>>>>    //*** Procedure Set: DataSourceType
81155>>>>>    //*** Purpose      : Setup the type of data sources returned by the datasources function
81155>>>>>    //***
81155>>>>>
81155>>>>>    Procedure Set DataSourceType Integer iNewType
81157>>>>>        Local String  sDriver
81157>>>>>        Local String  sVoid
81157>>>>>        Local Integer iRetval
81157>>>>>
81157>>>>>        Get psDriverID To sDriver
81158>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid iNewType Result iRetval
81165>>>>>    End_Procedure // Set DataSourceType
81166>>>>>
81166>>>>>
81166>>>>>
81166>>>>>    //***
81166>>>>>    //*** Function: DataSources
81166>>>>>    //*** Purpose : Call the driver's data sources function
81166>>>>>    //***
81166>>>>>
81166>>>>>    Function DataSources Returns String
81168>>>>>        Local String  sDriver
81168>>>>>        Local String  sDataSource
81168>>>>>        Local String  sDescription
81168>>>>>        Local Integer iLength
81168>>>>>        Local Integer iRetval
81168>>>>>
81168>>>>>        Get psDriverID To sDriver
81169>>>>>        If (sDriver <> "") Begin
81171>>>>>            Move 8192 To iLength
81172>>>>>            Move (Repeat(" ", iLength)) To sDataSource
81173>>>>>            Move (Repeat(" ", iLength)) To sDescription
81174>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
81179>>>>>        End
81179>>>>>>
81179>>>>>
81179>>>>>        If (sDataSource <> "" Or sDescription <> "") ;            Function_Return (sDataSource + "," +  sDescription)
81182>>>>>        Else ;            Function_Return ""
81184>>>>>    End_Function// DataSources
81185>>>>>
81185>>>>>End_Class // cODBCHandler
81186>>>Use cSQLConnectionIniFile.pkg
Including file: cSQLConnectionIniFile.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.pkg)
81186>>>>>//****************************************************************************
81186>>>>>// $Module type: Class
81186>>>>>// $Module name: cSQLConnectionIniFile.pkg
81186>>>>>//
81186>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
81186>>>>>// Copyright (c) 2012 RDC Tools International
81186>>>>>// E-mail      : support@rdctools.com
81186>>>>>// Web-site    : http://www.rdctools.com
81186>>>>>//
81186>>>>>// Created     : 2012-09-20 @ 18:04 (Military date format - Year-Month-Day)
81186>>>>>//
81186>>>>>// Note        : The file must be USEd after declaration of the ghoApplication object, as it uses
81186>>>>>//               properties of that object.
81186>>>>>//
81186>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
81186>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
81186>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
81186>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
81186>>>>>// in the help folder for more details.
81186>>>>>//
81186>>>>>Use cSQLConnectionIniFile.inc
Including file: cSQLConnectionIniFile.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.inc)
81186>>>>>>>//****************************************************************************
81186>>>>>>>// $Module type: Include file
81186>>>>>>>// $Module name: cSQLConnectionIniFile.inc
81186>>>>>>>//
81186>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
81186>>>>>>>// Copyright (c) 2012 RDC Tools International
81186>>>>>>>// E-mail      : support@rdctools.com
81186>>>>>>>// Web-site    : http://www.rdctools.com
81186>>>>>>>//
81186>>>>>>>// Created     : 2017-01-18 @ 13:04 (Military date format - Year-Month-Day)
81186>>>>>>>//
81186>>>>>>>// Note        : Header file with constant declarations for the cSQLConnectionIniFile class.
81186>>>>>>>//
81186>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
81186>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
81186>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
81186>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
81186>>>>>>>// in the help folder for more details.
81186>>>>>>>//
81186>>>>>>>Use Winkern.pkg
81186>>>>>>>Use cIniFile.pkg
81186>>>>>>>Use cCryptographer.pkg
Including file: cCryptographer.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCryptographer.pkg)
81186>>>>>>>>>Use VdfBase.pkg
81186>>>>>>>>>
81186>>>>>>>>>Use CryptographerConstants.pkg
Including file: CryptographerConstants.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\CryptographerConstants.pkg)
81186>>>>>>>>>>>//                                      
81186>>>>>>>>>>>// File    : CryptographerConstants.pkg
81186>>>>>>>>>>>//
81186>>>>>>>>>>>//   Author  : Ulbe Stellema
81186>>>>>>>>>>>//             Data Access Worldwide
81186>>>>>>>>>>>//
81186>>>>>>>>>>>//   Date    : October 4, 2009
81186>>>>>>>>>>>//
81186>>>>>>>>>>>
81186>>>>>>>>>>>
81186>>>>>>>>>>>
81186>>>>>>>>>>>// Algorithm classes
81186>>>>>>>>>>>Define ALG_CLASS_ANY                    for |CI$00000000 // (0)
81186>>>>>>>>>>>Define ALG_CLASS_SIGNATURE              for |CI$00002000 // (1 << 13)
81186>>>>>>>>>>>Define ALG_CLASS_MSG_ENCRYPT            for |CI$00004000 // (2 << 13)
81186>>>>>>>>>>>Define ALG_CLASS_DATA_ENCRYPT           for |CI$00006000 // (3 << 13)
81186>>>>>>>>>>>Define ALG_CLASS_HASH                   for |CI$00008000 // (4 << 13)
81186>>>>>>>>>>>Define ALG_CLASS_KEY_EXCHANGE           for |CI$0000A000 // (5 << 13)
81186>>>>>>>>>>>Define ALG_CLASS_ALL                    for |CI$0000E000 // (7 << 13)
81186>>>>>>>>>>>
81186>>>>>>>>>>>// Algorithm types
81186>>>>>>>>>>>Define ALG_TYPE_ANY                     for |CI$00000000 // (0)
81186>>>>>>>>>>>Define ALG_TYPE_DSS                     for |CI$00000200 // (1 << 9)
81186>>>>>>>>>>>Define ALG_TYPE_RSA                     for |CI$00000400 // (2 << 9)
81186>>>>>>>>>>>Define ALG_TYPE_BLOCK                   for |CI$00000600 // (3 << 9)
81186>>>>>>>>>>>Define ALG_TYPE_STREAM                  for |CI$00000800 // (4 << 9)
81186>>>>>>>>>>>Define ALG_TYPE_DH                      for |CI$00000A00 // (5 << 9)
81186>>>>>>>>>>>Define ALG_TYPE_SECURECHANNEL           for |CI$00000C00 // (6 << 9)
81186>>>>>>>>>>>
81186>>>>>>>>>>>// Generic sub-ids
81186>>>>>>>>>>>Define ALG_SID_ANY                      for |CI$00000000 // (0)
81186>>>>>>>>>>>
81186>>>>>>>>>>>// RSA sub-ids
81186>>>>>>>>>>>Define ALG_SID_RSA_ANY                  for 0
81186>>>>>>>>>>>Define ALG_SID_RSA_PKCS                 for 1
81186>>>>>>>>>>>Define ALG_SID_RSA_MSATWORK             for 2
81186>>>>>>>>>>>Define ALG_SID_RSA_ENTRUST              for 3
81186>>>>>>>>>>>Define ALG_SID_RSA_PGP                  for 4
81186>>>>>>>>>>>
81186>>>>>>>>>>>// DSS sub-ids
81186>>>>>>>>>>>Define ALG_SID_DSS_ANY                  for 0
81186>>>>>>>>>>>Define ALG_SID_DSS_PKCS                 for 1
81186>>>>>>>>>>>Define ALG_SID_DSS_DMS                  for 2
81186>>>>>>>>>>>
81186>>>>>>>>>>>// DES sub_ids
81186>>>>>>>>>>>Define ALG_SID_DES                      for 1
81186>>>>>>>>>>>Define ALG_SID_3DES                     for 3
81186>>>>>>>>>>>Define ALG_SID_DESX                     for 4
81186>>>>>>>>>>>Define ALG_SID_IDEA                     for 5
81186>>>>>>>>>>>Define ALG_SID_CAST                     for 6
81186>>>>>>>>>>>Define ALG_SID_SAFERSK64                for 7
81186>>>>>>>>>>>Define ALG_SID_SAFERSK128               for 8
81186>>>>>>>>>>>Define ALG_SID_3DES_112                 for 9
81186>>>>>>>>>>>Define ALG_SID_CYLINK_MEK               for 12
81186>>>>>>>>>>>Define ALG_SID_RC5                      for 13
81186>>>>>>>>>>>Define ALG_SID_AES_128                  for 14
81186>>>>>>>>>>>Define ALG_SID_AES_192                  for 15
81186>>>>>>>>>>>Define ALG_SID_AES_256                  for 16
81186>>>>>>>>>>>Define ALG_SID_AES                      for 17
81186>>>>>>>>>>>
81186>>>>>>>>>>>// Fortezza sub-ids
81186>>>>>>>>>>>Define ALG_SID_SKIPJACK                 for 10
81186>>>>>>>>>>>Define ALG_SID_TEK                      for 11
81186>>>>>>>>>>>
81186>>>>>>>>>>>// RC2 sub-ids
81186>>>>>>>>>>>Define ALG_SID_RC2                      for 2
81186>>>>>>>>>>>
81186>>>>>>>>>>>// Stream cipher sub-ids
81186>>>>>>>>>>>Define ALG_SID_RC4                      for 1
81186>>>>>>>>>>>Define ALG_SID_SEAL                     for 2
81186>>>>>>>>>>>
81186>>>>>>>>>>>// Diffie-Hellman sub-ids
81186>>>>>>>>>>>Define ALG_SID_DH_SANDF                 for 1
81186>>>>>>>>>>>Define ALG_SID_DH_EPHEM                 for 2
81186>>>>>>>>>>>Define ALG_SID_AGREED_KEY_ANY           for 3
81186>>>>>>>>>>>Define ALG_SID_KEA                      for 4
81186>>>>>>>>>>>
81186>>>>>>>>>>>// Hash sub ids
81186>>>>>>>>>>>Define ALG_SID_MD2                      for 1
81186>>>>>>>>>>>Define ALG_SID_MD4                      for 2
81186>>>>>>>>>>>Define ALG_SID_MD5                      for 3
81186>>>>>>>>>>>Define ALG_SID_SHA                      for 4
81186>>>>>>>>>>>Define ALG_SID_SHA1                     for 4
81186>>>>>>>>>>>Define ALG_SID_MAC                      for 5
81186>>>>>>>>>>>Define ALG_SID_RIPEMD                   for 6
81186>>>>>>>>>>>Define ALG_SID_RIPEMD160                for 7
81186>>>>>>>>>>>Define ALG_SID_SSL3SHAMD5               for 8
81186>>>>>>>>>>>Define ALG_SID_HMAC                     for 9
81186>>>>>>>>>>>Define ALG_SID_TLS1PRF                  for 10
81186>>>>>>>>>>>Define ALG_SID_HASH_REPLACE_OWF         for 11
81186>>>>>>>>>>>Define ALG_SID_SHA_256                  for 12
81186>>>>>>>>>>>Define ALG_SID_SHA_384                  for 13
81186>>>>>>>>>>>Define ALG_SID_SHA_512                  for 14
81186>>>>>>>>>>>
81186>>>>>>>>>>>// secure channel sub ids
81186>>>>>>>>>>>Define ALG_SID_SSL3_MASTER              for 1
81186>>>>>>>>>>>Define ALG_SID_SCHANNEL_MASTER_HASH     for 2
81186>>>>>>>>>>>Define ALG_SID_SCHANNEL_MAC_KEY         for 3
81186>>>>>>>>>>>Define ALG_SID_PCT1_MASTER              for 4
81186>>>>>>>>>>>Define ALG_SID_SSL2_MASTER              for 5
81186>>>>>>>>>>>Define ALG_SID_TLS1_MASTER              for 6
81186>>>>>>>>>>>Define ALG_SID_SCHANNEL_ENC_KEY         for 7
81186>>>>>>>>>>>
81186>>>>>>>>>>>// algorithm identifier definitions
81186>>>>>>>>>>>Define CALG_MD2                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD2)
81186>>>>>>>>>>>Define CALG_MD4                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD4)
81186>>>>>>>>>>>Define CALG_MD5                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD5)
81186>>>>>>>>>>>Define CALG_SHA                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA)
81186>>>>>>>>>>>Define CALG_SHA1                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA1)
81186>>>>>>>>>>>Define CALG_MAC                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MAC)
81186>>>>>>>>>>>Define CALG_RSA_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
81186>>>>>>>>>>>Define CALG_DSS_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_DSS ior ALG_SID_DSS_ANY)
81186>>>>>>>>>>>Define CALG_NO_SIGN                     for (ALG_CLASS_SIGNATURE ior ALG_TYPE_ANY ior ALG_SID_ANY)
81186>>>>>>>>>>>Define CALG_RSA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
81186>>>>>>>>>>>Define CALG_DES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DES)
81186>>>>>>>>>>>Define CALG_3DES_112                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES_112)
81186>>>>>>>>>>>Define CALG_3DES                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES)
81186>>>>>>>>>>>Define CALG_DESX                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DESX)
81186>>>>>>>>>>>Define CALG_RC2                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC2)
81186>>>>>>>>>>>Define CALG_RC4                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_RC4)
81186>>>>>>>>>>>Define CALG_SEAL                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_SEAL)
81186>>>>>>>>>>>Define CALG_DH_SF                       for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_SANDF)
81186>>>>>>>>>>>Define CALG_DH_EPHEM                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_EPHEM)
81186>>>>>>>>>>>Define CALG_AGREEDKEY_ANY               for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_AGREED_KEY_ANY)
81186>>>>>>>>>>>Define CALG_KEA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_KEA)
81186>>>>>>>>>>>Define CALG_HUGHES_MD5                  for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_ANY ior ALG_SID_MD5)
81186>>>>>>>>>>>Define CALG_SKIPJACK                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_SKIPJACK)
81186>>>>>>>>>>>Define CALG_TEK                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_TEK)
81186>>>>>>>>>>>Define CALG_CYLINK_MEK                  for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_CYLINK_MEK)
81186>>>>>>>>>>>Define CALG_SSL3_SHAMD5                 for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SSL3SHAMD5)
81186>>>>>>>>>>>Define CALG_SSL3_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL3_MASTER)
81186>>>>>>>>>>>Define CALG_SCHANNEL_MASTER_HASH        for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MASTER_HASH)
81186>>>>>>>>>>>Define CALG_SCHANNEL_MAC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MAC_KEY)
81186>>>>>>>>>>>Define CALG_SCHANNEL_ENC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_ENC_KEY)
81186>>>>>>>>>>>Define CALG_PCT1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_PCT1_MASTER)
81186>>>>>>>>>>>Define CALG_SSL2_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL2_MASTER)
81186>>>>>>>>>>>Define CALG_TLS1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_TLS1_MASTER)
81186>>>>>>>>>>>Define CALG_RC5                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC5)
81186>>>>>>>>>>>Define CALG_HMAC                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HMAC)
81186>>>>>>>>>>>Define CALG_TLS1PRF                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_TLS1PRF)
81186>>>>>>>>>>>Define CALG_HASH_REPLACE_OWF            for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HASH_REPLACE_OWF)
81186>>>>>>>>>>>Define CALG_AES_128                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_128)
81186>>>>>>>>>>>Define CALG_AES_192                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_192)
81186>>>>>>>>>>>Define CALG_AES_256                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_256)
81186>>>>>>>>>>>Define CALG_AES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES)
81186>>>>>>>>>>>Define CALG_SHA_256                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_256)
81186>>>>>>>>>>>Define CALG_SHA_384                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_384)
81186>>>>>>>>>>>Define CALG_SHA_512                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_512)
81186>>>>>>>>>>>
81186>>>>>>>>>>>// Providers
81186>>>>>>>>>>>Define MS_DEF_PROV                      for "Microsoft Base Cryptographic Provider v1.0"
81186>>>>>>>>>>>Define MS_ENHANCED_PROV                 for "Microsoft Enhanced Cryptographic Provider v1.0"
81186>>>>>>>>>>>Define MS_STRONG_PROV                   for "Microsoft Strong Cryptographic Provider"
81186>>>>>>>>>>>Define MS_DEF_RSA_SIG_PROV              for "Microsoft RSA Signature Cryptographic Provider"
81186>>>>>>>>>>>Define MS_DEF_RSA_SCHANNEL_PROV         for "Microsoft RSA SChannel Cryptographic Provider"
81186>>>>>>>>>>>Define MS_DEF_DSS_PROV                  for "Microsoft Base DSS Cryptographic Provider"
81186>>>>>>>>>>>Define MS_DEF_DSS_DH_PROV               for "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
81186>>>>>>>>>>>Define MS_ENH_DSS_DH_PROV               for "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
81186>>>>>>>>>>>Define MS_DEF_DH_SCHANNEL_PROV          for "Microsoft DH SChannel Cryptographic Provider"
81186>>>>>>>>>>>Define MS_SCARD_PROV                    for "Microsoft Base Smart Card Crypto Provider"
81186>>>>>>>>>>>Define MS_ENH_RSA_AES_PROV              for "Microsoft Enhanced RSA and AES Cryptographic Provider"
81186>>>>>>>>>>>
81186>>>>>>>>>>>// dwFlags definitions for CryptAcquireContext
81186>>>>>>>>>>>Define CRYPT_VERIFYCONTEXT              for |CI$F0000000
81186>>>>>>>>>>>Define CRYPT_NEWKEYSET                  for |CI$00000008
81186>>>>>>>>>>>Define CRYPT_DELETEKEYSET               for |CI$00000010
81186>>>>>>>>>>>Define CRYPT_MACHINE_KEYSET             for |CI$00000020
81186>>>>>>>>>>>Define CRYPT_SILENT                     for |CI$00000040
81186>>>>>>>>>>>
81186>>>>>>>>>>>// dwFlag definitions for CryptGenKey
81186>>>>>>>>>>>Define CRYPT_EXPORTABLE                 for |CI$00000001
81186>>>>>>>>>>>Define CRYPT_USER_PROTECTED             for |CI$00000002
81186>>>>>>>>>>>Define CRYPT_CREATE_SALT                for |CI$00000004
81186>>>>>>>>>>>Define CRYPT_UPDATE_KEY                 for |CI$00000008
81186>>>>>>>>>>>Define CRYPT_NO_SALT                    for |CI$00000010
81186>>>>>>>>>>>Define CRYPT_PREGEN                     for |CI$00000040
81186>>>>>>>>>>>Define CRYPT_RECIPIENT                  for |CI$00000010
81186>>>>>>>>>>>Define CRYPT_INITIATOR                  for |CI$00000040
81186>>>>>>>>>>>Define CRYPT_ONLINE                     for |CI$00000080
81186>>>>>>>>>>>Define CRYPT_SF                         for |CI$00000100
81186>>>>>>>>>>>Define CRYPT_CREATE_IV                  for |CI$00000200
81186>>>>>>>>>>>Define CRYPT_KEK                        for |CI$00000400
81186>>>>>>>>>>>Define CRYPT_DATA_KEY                   for |CI$00000800
81186>>>>>>>>>>>Define CRYPT_VOLATILE                   for |CI$00001000
81186>>>>>>>>>>>Define CRYPT_SGCKEY                     for |CI$00002000
81186>>>>>>>>>>>Define CRYPT_ARCHIVABLE                 for |CI$00004000
81186>>>>>>>>>>>
81186>>>>>>>>>>>// Provider types
81186>>>>>>>>>>>Define PROV_RSA_FULL                    for 1
81186>>>>>>>>>>>Define PROV_RSA_SIG                     for 2
81186>>>>>>>>>>>Define PROV_DSS                         for 3
81186>>>>>>>>>>>Define PROV_FORTEZZA                    for 4
81186>>>>>>>>>>>Define PROV_MS_EXCHANGE                 for 5
81186>>>>>>>>>>>Define PROV_SSL                         for 6
81186>>>>>>>>>>>Define PROV_RSA_SCHANNEL                for 12
81186>>>>>>>>>>>Define PROV_DSS_DH                      for 13
81186>>>>>>>>>>>Define PROV_EC_ECDSA_SIG                for 14
81186>>>>>>>>>>>Define PROV_EC_ECNRA_SIG                for 15
81186>>>>>>>>>>>Define PROV_EC_ECDSA_FULL               for 16
81186>>>>>>>>>>>Define PROV_EC_ECNRA_FULL               for 17
81186>>>>>>>>>>>Define PROV_DH_SCHANNEL                 for 18
81186>>>>>>>>>>>Define PROV_SPYRUS_LYNKS                for 20
81186>>>>>>>>>>>Define PROV_RNG                         for 21
81186>>>>>>>>>>>Define PROV_INTEL_SEC                   for 22
81186>>>>>>>>>>>Define PROV_REPLACE_OWF                 for 23
81186>>>>>>>>>>>Define PROV_RSA_AES                     for 24
81186>>>>>>>>>>>
81186>>>>>>>>>>>// KP_MODE
81186>>>>>>>>>>>// KP_MODE
81186>>>>>>>>>>>Define CRYPT_MODE_CBC                   for 1       // Cipher block chaining
81186>>>>>>>>>>>Define CRYPT_MODE_ECB                   for 2       // Electronic code book
81186>>>>>>>>>>>Define CRYPT_MODE_OFB                   for 3       // Output feedback mode
81186>>>>>>>>>>>Define CRYPT_MODE_CFB                   for 4       // Cipher feedback mode
81186>>>>>>>>>>>Define CRYPT_MODE_CTS                   for 5       // Ciphertext stealing mode
81186>>>>>>>>>>>Define CRYPT_MODE_CBCI                  for 6       // ANSI CBC Interleaved
81186>>>>>>>>>>>Define CRYPT_MODE_CFBP                  for 7       // ANSI CFB Pipelined
81186>>>>>>>>>>>Define CRYPT_MODE_OFBP                  for 8       // ANSI OFB Pipelined
81186>>>>>>>>>>>Define CRYPT_MODE_CBCOFM                for 9       // ANSI CBC + OF Masking
81186>>>>>>>>>>>Define CRYPT_MODE_CBCOFMI               for 10      // ANSI CBC + OFM Interleaved
81186>>>>>>>>>>>
81186>>>>>>>>>>>// dwParam definitions for CryptGetKeyParam
81186>>>>>>>>>>>Define KP_IV                            for 1       // Initialization vector
81186>>>>>>>>>>>Define KP_SALT                          for 2       // Salt value
81186>>>>>>>>>>>Define KP_PADDING                       for 3       // Padding values
81186>>>>>>>>>>>Define KP_MODE                          for 4       // Mode of the cipher
81186>>>>>>>>>>>Define KP_MODE_BITS                     for 5       // Number of bits to feedback
81186>>>>>>>>>>>Define KP_PERMISSIONS                   for 6       // Key permissions DWORD
81186>>>>>>>>>>>Define KP_ALGID                         for 7       // Key algorithm
81186>>>>>>>>>>>Define KP_BLOCKLEN                      for 8       // Block size of the cipher
81186>>>>>>>>>>>Define KP_KEYLEN                        for 9       // Length of key in bits
81186>>>>>>>>>>>Define KP_SALT_EX                       for 10      // Length of salt in bytes
81186>>>>>>>>>>>Define KP_P                             for 11      // DSS/Diffie-Hellman P value
81186>>>>>>>>>>>Define KP_G                             for 12      // DSS/Diffie-Hellman G value
81186>>>>>>>>>>>Define KP_Q                             for 13      // DSS Q value
81186>>>>>>>>>>>Define KP_X                             for 14      // Diffie-Hellman X value
81186>>>>>>>>>>>Define KP_Y                             for 15      // Y value
81186>>>>>>>>>>>Define KP_RA                            for 16      // Fortezza RA value
81186>>>>>>>>>>>Define KP_RB                            for 17      // Fortezza RB value
81186>>>>>>>>>>>Define KP_INFO                          for 18      // for putting information into an RSA envelope
81186>>>>>>>>>>>Define KP_EFFECTIVE_KEYLEN              for 19      // setting and getting RC2 effective key length
81186>>>>>>>>>>>Define KP_SCHANNEL_ALG                  for 20      // for setting the Secure Channel algorithms
81186>>>>>>>>>>>Define KP_CLIENT_RANDOM                 for 21      // for setting the Secure Channel client random data
81186>>>>>>>>>>>Define KP_SERVER_RANDOM                 for 22      // for setting the Secure Channel server random data
81186>>>>>>>>>>>Define KP_RP                            for 23
81186>>>>>>>>>>>Define KP_PRECOMP_MD5                   for 24
81186>>>>>>>>>>>Define KP_PRECOMP_SHA                   for 25
81186>>>>>>>>>>>Define KP_CERTIFICATE                   for 26      // for setting Secure Channel certificate data (PCT1)
81186>>>>>>>>>>>Define KP_CLEAR_KEY                     for 27      // for setting Secure Channel clear key data (PCT1)
81186>>>>>>>>>>>Define KP_PUB_EX_LEN                    for 28
81186>>>>>>>>>>>Define KP_PUB_EX_VAL                    for 29
81186>>>>>>>>>>>Define KP_KEYVAL                        for 30
81186>>>>>>>>>>>Define KP_ADMIN_PIN                     for 31
81186>>>>>>>>>>>Define KP_KEYEXCHANGE_PIN               for 32
81186>>>>>>>>>>>Define KP_SIGNATURE_PIN                 for 33
81186>>>>>>>>>>>Define KP_PREHASH                       for 34
81186>>>>>>>>>>>Define KP_ROUNDS                        for 35
81186>>>>>>>>>>>Define KP_OAEP_PARAMS                   for 36      // for setting OAEP params on RSA keys
81186>>>>>>>>>>>Define KP_CMS_KEY_INFO                  for 37
81186>>>>>>>>>>>Define KP_CMS_DH_KEY_INFO               for 38
81186>>>>>>>>>>>Define KP_PUB_PARAMS                    for 39      // for setting public parameters
81186>>>>>>>>>>>Define KP_VERIFY_PARAMS                 for 40      // for verifying DSA and DH parameters
81186>>>>>>>>>>>Define KP_HIGHEST_VERSION               for 41      // for TLS protocol version setting
81186>>>>>>>>>>>Define KP_GET_USE_COUNT                 for 42      // for use with PP_CRYPT_COUNT_KEY_USE contexts
81186>>>>>>>>>>>
81186>>>>>>>>>>>// dwParam definitions for CryptGetHashParam
81186>>>>>>>>>>>Define HP_ALGID                         for |CI$0001  // Hash algorithm
81186>>>>>>>>>>>Define HP_HASHVAL                       for |CI$0002  // Hash value
81186>>>>>>>>>>>Define HP_HASHSIZE                      for |CI$0004  // Hash value size
81186>>>>>>>>>>>Define HP_HMAC_INFO                     for |CI$0005  // information for creating an HMA
81186>>>>>>>>>>>
81186>>>>>>>>>>>// key BLOB types
81186>>>>>>>>>>>Define KEYSTATEBLOB                     for |CI$0C
81186>>>>>>>>>>>Define OPAQUEKEYBLOB                    for |CI$09
81186>>>>>>>>>>>Define PLAINTEXTKEYBLOB                 for |CI$08
81186>>>>>>>>>>>Define PRIVATEKEYBLOB                   for |CI$07
81186>>>>>>>>>>>Define PUBLICKEYBLOB                    for |CI$06
81186>>>>>>>>>>>Define PUBLICKEYBLOBEX                  for |CI$0A
81186>>>>>>>>>>>Define SIMPLEBLOB                       for |CI$01
81186>>>>>>>>>>>Define SYMMETRICWRAPKEYBLOB             for |CI$0B
81186>>>>>>>>>>>
81186>>>>>>>>>>>Define CUR_BLOB_VERSION                 for 2
81186>>>>>>>>>>>
81186>>>>>>>>>>>//  Structure cryptimportkey
81186>>>>>>>>>>>Struct PUBLICKEYSTRUC
81186>>>>>>>>>>>    UChar    bType
81186>>>>>>>>>>>    UChar    bVersion
81186>>>>>>>>>>>    UShort   reserved
81186>>>>>>>>>>>    UInteger aiKeyAlg
81186>>>>>>>>>>>End_Struct
81186>>>>>>>>>>>
81186>>>>>>>>>>>Struct tPLAINTEXTKEYBLOB
81186>>>>>>>>>>>    PUBLICKEYSTRUC hdr
81186>>>>>>>>>>>    PUBLICKEYSTRUC hdr
81186>>>>>>>>>>>    UInteger       dwKeySize
81186>>>>>>>>>>>//    UChar[]        rgbKeyData
81186>>>>>>>>>>>End_Struct
81186>>>>>>>>>>>
81186>>>>>>>>>>>
81186>>>>>>>>>>>
81186>>>>>>>>>>>//  Structure for specifying the inner and outer strings when calculating HMAC hash (use with CryptSetHashParam)
81186>>>>>>>>>>>Struct HMAC_INFO
81186>>>>>>>>>>>    UInteger HashAlgid
81186>>>>>>>>>>>    Pointer pbInnerString
81186>>>>>>>>>>>    DWord cbInnerString
81186>>>>>>>>>>>    Pointer pbOuterString
81186>>>>>>>>>>>    DWord cbOuterString
81186>>>>>>>>>>>End_Struct
81186>>>>>>>>>>>
81186>>>>>>>>>>>
81186>>>>>>>>>>>External_Function CryptAcquireContext "CryptAcquireContextA" advapi32.dll ;    Pointer phProv ;    Pointer szContainer ;    Pointer szProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
81187>>>>>>>>>>>
81187>>>>>>>>>>>External_Function CryptReleaseContext "CryptReleaseContext" advapi32.dll ;    Handle hProv ;    Integer dwFlags ;    Returns Boolean
81188>>>>>>>>>>>
81188>>>>>>>>>>>External_Function CryptCreateHash "CryptCreateHash" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hKey ;    Integer dwFlags ;    Pointer phHash ;    Returns Boolean
81189>>>>>>>>>>>
81189>>>>>>>>>>>External_Function CryptDestroyHash "CryptDestroyHash" advapi32.dll ;    Handle hHash ;    Returns Boolean
81190>>>>>>>>>>>
81190>>>>>>>>>>>External_Function CryptHashData "CryptHashData" advapi32.dll ;    Handle hHash ;    Pointer pbData ;    Integer dwDataLen ;    Integer dwFlags ;    Returns Boolean
81191>>>>>>>>>>>
81191>>>>>>>>>>>External_Function CryptDeriveKey "CryptDeriveKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hBaseData ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
81192>>>>>>>>>>>
81192>>>>>>>>>>>External_Function CryptGetHashParam "CryptGetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    DWord dwFlags ;    Returns Integer
81193>>>>>>>>>>>
81193>>>>>>>>>>>External_Function CryptDestroyKey "CryptDestroyKey" advapi32.dll ;    Handle hKey ;    Returns Boolean
81194>>>>>>>>>>>
81194>>>>>>>>>>>External_Function CryptImportKey "CryptImportKey" advapi32.dll ;    Handle hProv ;    Pointer pbData ;    Integer dwDataLen ;    Handle hPubKey ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
81195>>>>>>>>>>>
81195>>>>>>>>>>>External_Function CryptGetKeyParam "CryptGetKeyParam" advapi32.dll ;    Handle hKey ;    Integer dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwFlags ;    Returns Boolean
81196>>>>>>>>>>>    
81196>>>>>>>>>>>External_Function CryptSetKeyParam "CryptSetKeyParam" advapi32.dll ;    Handle   hKey ;    UInteger dwParam ;    Pointer  pbdata ;    UInteger dwFlags ;    Returns  Boolean
81197>>>>>>>>>>>
81197>>>>>>>>>>>External_Function CryptEncrypt "CryptEncrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwBufLen ;    Returns Boolean
81198>>>>>>>>>>>
81198>>>>>>>>>>>External_Function CryptDecrypt "CryptDecrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
81199>>>>>>>>>>>
81199>>>>>>>>>>>External_Function CryptGenRandom "CryptGenRandom" advapi32.dll ;    Handle hProv ;    DWord dwLen ;    Pointer pbBuffer ;    Returns Boolean
81200>>>>>>>>>>>    
81200>>>>>>>>>>>External_Function CryptSetHashParam "CryptSetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Integer dwFlags ;    Returns Boolean
81201>>>>>>>>>>>    
81201>>>>>>>>>
81201>>>>>>>>>Class cCryptographer is a cObject
81202>>>>>>>>>    
81202>>>>>>>>>    // Procedure : Construct_Object
81202>>>>>>>>>    // Purpose   : Object constructor
81202>>>>>>>>>    Procedure Construct_Object
81204>>>>>>>>>        Forward Send Construct_Object
81206>>>>>>>>>
81206>>>>>>>>>        Property String     psProvider  MS_ENHANCED_PROV
81207>>>>>>>>>        Property Integer    piProvider  PROV_RSA_FULL
81208>>>>>>>>>        Property Integer    piCipher    CALG_RC4
81209>>>>>>>>>        Property Integer    piHash      CALG_MD5
81210>>>>>>>>>        
81210>>>>>>>>>        // Private properties
81210>>>>>>>>>        Property Handle     Private_phProv
81211>>>>>>>>>    End_Procedure
81212>>>>>>>>>    
81212>>>>>>>>>    
81212>>>>>>>>>    // Function : AcquireContext
81212>>>>>>>>>    // Purpose  : Acquire key container handle
81212>>>>>>>>>    Function AcquireContext Returns Handle
81214>>>>>>>>>        Integer iProvider
81214>>>>>>>>>        String sProvider
81214>>>>>>>>>        Handle hProv
81214>>>>>>>>>        Boolean bOk
81214>>>>>>>>>        Address addrProv
81214>>>>>>>>>        
81214>>>>>>>>>        Move 0 to hProv
81215>>>>>>>>>        Get piProvider to iProvider
81216>>>>>>>>>        Get psProvider to sProvider
81217>>>>>>>>>        
81217>>>>>>>>>        //  Determine address to be passed as provider
81217>>>>>>>>>        If (Trim(sProvider) <> "") Begin
81219>>>>>>>>>            Move (AddressOf(sProvider)) to addrProv
81220>>>>>>>>>        End
81220>>>>>>>>>>
81220>>>>>>>>>        Else Begin
81221>>>>>>>>>            Move 0 to addrProv
81222>>>>>>>>>        End
81222>>>>>>>>>>
81222>>>>>>>>>        
81222>>>>>>>>>        //  Acquire Crypto Context
81222>>>>>>>>>        Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_VERIFYCONTEXT)) to bOk
81223>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
81225>>>>>>>>>            Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_NEWKEYSET ior CRYPT_VERIFYCONTEXT)) to bOk
81226>>>>>>>>>        End
81226>>>>>>>>>>
81226>>>>>>>>>        
81226>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
81228>>>>>>>>>            // Fallback to original
81228>>>>>>>>>            Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,0)) to bOk
81229>>>>>>>>>            
81229>>>>>>>>>            If (not(bOk) or hProv = 0) Begin
81231>>>>>>>>>                Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_NEWKEYSET)) to bOk
81232>>>>>>>>>            End
81232>>>>>>>>>>
81232>>>>>>>>>        End
81232>>>>>>>>>>
81232>>>>>>>>>        Set Private_phProv to hProv
81233>>>>>>>>>        
81233>>>>>>>>>        Function_Return hProv
81234>>>>>>>>>    End_Function
81235>>>>>>>>>    
81235>>>>>>>>>    // Function : ReleaseContext
81235>>>>>>>>>    // Purpose  : Releases key container handle
81235>>>>>>>>>    Function ReleaseContext Handle hProv Returns Boolean
81237>>>>>>>>>        Function_Return (CryptReleaseContext(hProv,0))
81238>>>>>>>>>    End_Function
81239>>>>>>>>>    
81239>>>>>>>>>    // Function : CreateHash
81239>>>>>>>>>    // Purpose  : Creates hash object
81239>>>>>>>>>    Function CreateHash Handle hProv Returns Handle
81241>>>>>>>>>        Integer iAlgorithm
81241>>>>>>>>>        Handle hHash
81241>>>>>>>>>        Boolean bOk
81241>>>>>>>>>        
81241>>>>>>>>>        Move 0 to hHash
81242>>>>>>>>>        Get piHash to iAlgorithm
81243>>>>>>>>>        Move (CryptCreateHash(hProv,iAlgorithm,0,0,AddressOf(hHash))) to bOk
81244>>>>>>>>>        
81244>>>>>>>>>        Function_Return hHash
81245>>>>>>>>>    End_Function
81246>>>>>>>>>    
81246>>>>>>>>>    // Function : DestroyHash
81246>>>>>>>>>    // Purpose  : Destroys the hash object
81246>>>>>>>>>    Function DestroyHash Handle hHash Returns Boolean
81248>>>>>>>>>        Function_Return (CryptDestroyHash(hHash))
81249>>>>>>>>>    End_Function
81250>>>>>>>>>    
81250>>>>>>>>>    // Function : HashData
81250>>>>>>>>>    // Purpose  : Adds data to hash object
81250>>>>>>>>>    Function HashData Handle hHash String sData Returns Boolean
81252>>>>>>>>>        Function_Return (CryptHashData(hHash,AddressOf(sData),Length(sData),0))
81253>>>>>>>>>    End_Function
81254>>>>>>>>>    
81254>>>>>>>>>    // Function : DeriveKey
81254>>>>>>>>>    // Purpose  : Generates session key
81254>>>>>>>>>    Function DeriveKey Handle hProv Handle hHash Returns Handle
81256>>>>>>>>>        Integer iAlgorithm
81256>>>>>>>>>        Handle hKey
81256>>>>>>>>>        Boolean bOk
81256>>>>>>>>>        
81256>>>>>>>>>        Move 0 to hKey
81257>>>>>>>>>        Get piCipher to iAlgorithm
81258>>>>>>>>>        Move (CryptDeriveKey(hProv,iAlgorithm,hHash,CRYPT_EXPORTABLE,AddressOf(hKey))) to bOk
81259>>>>>>>>>        
81259>>>>>>>>>        Function_Return hKey
81260>>>>>>>>>    End_Function
81261>>>>>>>>>    
81261>>>>>>>>>    // Function : ImportPlainTextKey
81261>>>>>>>>>    // Purpose  : Imports a plain text key
81261>>>>>>>>>    Function ImportPlainTextKey Handle hProv UChar[] ucaKey Returns Handle
81263>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
81263>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
81263>>>>>>>>>        Boolean   bSuccess
81263>>>>>>>>>        Handle    hKey
81263>>>>>>>>>        Integer   iHeadSize iKeySize
81263>>>>>>>>>        UChar[]   ucaKeyblob
81264>>>>>>>>>        Integer iVoid
81264>>>>>>>>>    
81264>>>>>>>>>        Move (SizeOfType(tPLAINTEXTKEYBLOB)) to iHeadSize
81265>>>>>>>>>        Move (SizeOfArray(ucaKey)) to iKeySize
81266>>>>>>>>>    
81266>>>>>>>>>        Move PLAINTEXTKEYBLOB to blobhead.hdr.bType
81267>>>>>>>>>        Move CUR_BLOB_VERSION   to blobhead.hdr.bVersion
81268>>>>>>>>>        Get piCipher            to blobhead.hdr.aiKeyAlg
81269>>>>>>>>>        Move iKeySize           to blobhead.dwKeySize
81270>>>>>>>>>    
81270>>>>>>>>>        Move (ResizeArray(ucaKeyblob, iHeadSize)) to ucaKeyblob
81271>>>>>>>>>        Move (CopyMemory(AddressOf(ucaKeyblob), AddressOf(blobhead), iHeadSize)) to iVoid
81272>>>>>>>>>        Move (AppendArray(ucaKeyblob, ucaKey)) to ucaKeyblob
81273>>>>>>>>>    
81273>>>>>>>>>        Move 0 to hKey
81274>>>>>>>>>        Move (CryptImportKey(hProv, AddressOf(ucaKeyblob), SizeOfArray(ucaKeyblob), 0, 0, AddressOf(hKey))) to bSuccess
81275>>>>>>>>>        If (not(bSuccess)) Begin 
81277>>>>>>>>>            Move (ShowLastError()) to iVoid
81278>>>>>>>>>        End
81278>>>>>>>>>>
81278>>>>>>>>>    
81278>>>>>>>>>        Function_Return hKey
81279>>>>>>>>>    End_Function
81280>>>>>>>>>
81280>>>>>>>>>    // Function : DestroyKey
81280>>>>>>>>>    // Purpose  : Destroys the key
81280>>>>>>>>>    Function DestroyKey Handle hKey Returns Boolean
81282>>>>>>>>>        Function_Return (CryptDestroyKey(hKey))
81283>>>>>>>>>    End_Function
81284>>>>>>>>>    
81284>>>>>>>>>    // Function : KeyParameter
81284>>>>>>>>>    // Purpose  : Retrieves key data
81284>>>>>>>>>    Function KeyParameter Handle hKey Integer iQuery Returns Integer
81286>>>>>>>>>        Integer iBuffer iLen
81286>>>>>>>>>        Boolean bOk
81286>>>>>>>>>        
81286>>>>>>>>>        Move (SizeOfType(Integer)) to iLen
81287>>>>>>>>>        Move (CryptGetKeyParam(hKey,iQuery,AddressOf(iBuffer),AddressOf(iLen),0)) to bOk
81288>>>>>>>>>        Function_Return iBuffer
81289>>>>>>>>>    End_Function
81290>>>>>>>>>    
81290>>>>>>>>>    // Function : HashValue
81290>>>>>>>>>    // Purpose  : Retrieves a hash value
81290>>>>>>>>>    Function HashValue Handle lhHash Returns String
81292>>>>>>>>>        Pointer lpSize
81292>>>>>>>>>        Pointer lpHash
81292>>>>>>>>>        String  lsSize
81292>>>>>>>>>        String  lsHash
81292>>>>>>>>>        Integer liResult
81292>>>>>>>>>
81292>>>>>>>>>        Move (Repeat(Character(0),4)) to lsSize
81293>>>>>>>>>        GetAddress of lsSize to lpSize
81294>>>>>>>>>
81294>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,0,lpSize,0)) to liResult
81295>>>>>>>>>        If (liResult = 0) Function_Return ""
81298>>>>>>>>>
81298>>>>>>>>>        Move (Repeat(Character(0),BytesTodWord(lsSize,1))) to lsHash
81299>>>>>>>>>        GetAddress of lsHash to lpHash
81300>>>>>>>>>
81300>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,lpHash,lpSize,0)) to liResult
81301>>>>>>>>>        If (liResult = 0) Function_Return ""
81304>>>>>>>>>
81304>>>>>>>>>        Function_Return lsHash
81305>>>>>>>>>    End_Function  // HashValue
81306>>>>>>>>>    
81306>>>>>>>>>            
81306>>>>>>>>>    // Function : Encrypt
81306>>>>>>>>>    // Purpose  : Encrypts data
81306>>>>>>>>>    Function Encrypt String sPassword String sData Returns String
81308>>>>>>>>>        Handle hProv hHash hKey
81308>>>>>>>>>        Integer iAlgorithm iDataLen iCipherLen iErr
81308>>>>>>>>>        Boolean bOk
81308>>>>>>>>>        
81308>>>>>>>>>        Get AcquireContext to hProv
81309>>>>>>>>>        If (hProv) Begin
81311>>>>>>>>>            Get CreateHash hProv to hHash
81312>>>>>>>>>            If (hHash) Begin
81314>>>>>>>>>                Get HashData hHash sPassword to bOk
81315>>>>>>>>>                If (bOk) Begin
81317>>>>>>>>>                    Get piCipher to iAlgorithm
81318>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
81319>>>>>>>>>                End // If (bOk) Begin            
81319>>>>>>>>>>
81319>>>>>>>>>                Get DestroyHash hHash to bOk
81320>>>>>>>>>            End // If (hHash) Begin
81320>>>>>>>>>>
81320>>>>>>>>>            
81320>>>>>>>>>            If (hKey) Begin
81322>>>>>>>>>                //  First call to determine resulting data size
81322>>>>>>>>>                Move (Length(sData)) to iDataLen
81323>>>>>>>>>                Move (Length(sData)) to iCipherLen
81324>>>>>>>>>                Move (CryptEncrypt(hKey, 0, True, 0, 0, AddressOf(iCipherLen), iDataLen)) to bOk
81325>>>>>>>>>                
81325>>>>>>>>>                //  Reserve space in string
81325>>>>>>>>>                If (iDataLen < iCipherLen) Begin
81327>>>>>>>>>                    Move (sData + Repeat(" ", iCipherLen - iDataLen)) to sData
81328>>>>>>>>>                End
81328>>>>>>>>>>
81328>>>>>>>>>                
81328>>>>>>>>>                //  Call to really decrypt
81328>>>>>>>>>                Move (CryptEncrypt(hKey,0,True,0,AddressOf(sData),AddressOf(iDataLen),Length(sData))) to bOk
81329>>>>>>>>>                //If (not(bOk)) Begin
81329>>>>>>>>>                    //Move "" to sData
81329>>>>>>>>>                    //Move (GetLastError()) to iErr
81329>>>>>>>>>                //End
81329>>>>>>>>>                
81329>>>>>>>>>                Get DestroyKey hKey to bOk
81330>>>>>>>>>            End // If (hKey) Begin
81330>>>>>>>>>>
81330>>>>>>>>>            Get ReleaseContext hProv to bOk
81331>>>>>>>>>        End // If (hProv) Begin
81331>>>>>>>>>>
81331>>>>>>>>>        Function_Return sData
81332>>>>>>>>>    End_Function
81333>>>>>>>>>    
81333>>>>>>>>>    // Function : Decrypt
81333>>>>>>>>>    // Purpose  : Decrypts data
81333>>>>>>>>>    Function Decrypt String sPassword String sData Returns String
81335>>>>>>>>>        Handle hProv hHash hKey
81335>>>>>>>>>        Integer iAlgorithm iDataLen
81335>>>>>>>>>        Boolean bOk
81335>>>>>>>>>        
81335>>>>>>>>>        Get AcquireContext to hProv
81336>>>>>>>>>        If (hProv) Begin
81338>>>>>>>>>            Get CreateHash hProv to hHash
81339>>>>>>>>>            If (hHash) Begin
81341>>>>>>>>>                Get HashData hHash sPassword to bOk
81342>>>>>>>>>                If (bOk) Begin
81344>>>>>>>>>                    Get piCipher to iAlgorithm
81345>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
81346>>>>>>>>>                End // If (bOk) Begin            
81346>>>>>>>>>>
81346>>>>>>>>>                Get DestroyHash hHash to bOk
81347>>>>>>>>>            End // If (hHash) Begin
81347>>>>>>>>>>
81347>>>>>>>>>            
81347>>>>>>>>>            If (hKey) Begin
81349>>>>>>>>>                Move (Length(sData)) to iDataLen
81350>>>>>>>>>                Move (CryptDecrypt(hKey,0,True,0,AddressOf(sData),AddressOf(iDataLen))) to bOk
81351>>>>>>>>>                //If (bOk = False) Move "" to sData
81351>>>>>>>>>                
81351>>>>>>>>>                //  Resulting dat can be shorter as the input string, in that case we shorten the result string
81351>>>>>>>>>                If (Length(sData) > iDataLen) Begin
81353>>>>>>>>>                    Move (Left(sData, iDataLen)) to sData
81354>>>>>>>>>                End
81354>>>>>>>>>>
81354>>>>>>>>>                
81354>>>>>>>>>                Get DestroyKey hKey to bOk
81355>>>>>>>>>            End // If (hKey) Begin
81355>>>>>>>>>>
81355>>>>>>>>>            Get ReleaseContext hProv to bOk
81356>>>>>>>>>        End // If (hProv) Begin
81356>>>>>>>>>>
81356>>>>>>>>>        Function_Return sData
81357>>>>>>>>>    End_Function
81358>>>>>>>>>    
81358>>>>>>>>>    //  Function : GenerateRandom
81358>>>>>>>>>    //  Purpose  : Generates random data.
81358>>>>>>>>>    Function GenerateRandom Integer iBytes Returns UChar[]
81360>>>>>>>>>        Handle hProv
81360>>>>>>>>>        UChar[] uaResult
81361>>>>>>>>>        Boolean bRes
81361>>>>>>>>>        
81361>>>>>>>>>        Get AcquireContext to hProv
81362>>>>>>>>>        
81362>>>>>>>>>        Move (ResizeArray(uaResult, iBytes)) to uaResult
81363>>>>>>>>>        Move (CryptGenRandom(hProv, iBytes, AddressOf(uaResult))) to bRes
81364>>>>>>>>>        
81364>>>>>>>>>        Get ReleaseContext hProv to bRes
81365>>>>>>>>>        
81365>>>>>>>>>        Function_Return uaResult
81366>>>>>>>>>    End_Function
81367>>>>>>>>>    
81367>>>>>>>>>    //  Function : GenerateRandomString
81367>>>>>>>>>    //  Purpose  : Generates random data and does a base64 encoding to properly present it as a string.
81367>>>>>>>>>    Function GenerateRandomString Integer iLenght Returns String
81369>>>>>>>>>        String sResult
81369>>>>>>>>>        UChar[] aData
81370>>>>>>>>>        Address pBase64
81370>>>>>>>>>        Integer iVoid
81370>>>>>>>>>
81370>>>>>>>>>        Get GenerateRandom iLenght to aData
81371>>>>>>>>>        
81371>>>>>>>>>        Move (Base64Encode(AddressOf(aData), iLenght)) to pBase64
81372>>>>>>>>>        Move pBase64 to sResult
81373>>>>>>>>>        Move (Free(pBase64)) to iVoid    
81374>>>>>>>>>        
81374>>>>>>>>>        Function_Return (Left(sResult, iLenght))
81375>>>>>>>>>    End_Function
81376>>>>>>>>>
81376>>>>>>>>>End_Class
81377>>>>>>>Use Base64Functions.pkg
Including file: Base64Functions.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\Base64Functions.pkg)
81377>>>>>>>>>//> This package enables base64 encoding and decoding of strings:
81377>>>>>>>>>//>
81377>>>>>>>>>//>     Get EncodeString of oBase64Functions sValue to sValue
81377>>>>>>>>>//>     Get DecodeString of oBase64Functions sValue to sValue
81377>>>>>>>>>//>
81377>>>>>>>>>//> Remember to set the "max argument size" if dealing with very large
81377>>>>>>>>>//> strings.
81377>>>>>>>>>//>
81377>>>>>>>>>//> For 17.1 and later the functionality of this package is based on two functions (Base64Encode and
81377>>>>>>>>>//> Base64Decode) that are built into the runtime.
81377>>>>>>>>>//>
81377>>>>>>>>>//> But for versions up to and including 17.0 it's based on the vdfBase64.dll file that was obtained
81377>>>>>>>>>//> from DAE that have kindly allowed me to distribute it to other DF developers. Programs including
81377>>>>>>>>>//> this package will give off an error on start-up if vdfBase64.dll is not found in the /bin folder
81377>>>>>>>>>//> if the VDF runtime. You will find the DLL in the /programs folder of the StureApsPublicLib workspace
81377>>>>>>>>>
81377>>>>>>>>>Use VdfBase.pkg
81377>>>>>>>>>
81377>>>>>>>>>// Functions in vdfBase64.dll
81377>>>>>>>>>External_Function xxBase64Encode "vdfbase64Encode" vdfBase64.dll Pointer pBuffer Returns Integer
81378>>>>>>>>>External_Function xxBase64Decode "vdfbase64Decode" vdfBase64.dll Pointer pBuffer Returns Integer
81379>>>>>>>>>External_Function xxBase64Free   "vdfbase64Free"   vdfBase64.dll Pointer pBuffer Returns Integer
81380>>>>>>>>>
81380>>>>>>>>>// Structure
81380>>>>>>>>>Struct txxfBase64Buffer
81380>>>>>>>>>    Pointer pData
81380>>>>>>>>>    Integer iLength
81380>>>>>>>>>End_Struct
81380>>>>>>>>>
81380>>>>>>>>>Global_Variable Integer oBase64Functions
81380>>>>>>>>>
81380>>>>>>>>>Object _oBase64Functions is a cObject
81382>>>>>>>>>    Move Self to oBase64Functions
81383>>>>>>>>>
81383>>>>>>>>>
81383>>>>>>>>>    Function EncodeString String sValue Returns String
81386>>>>>>>>>        Address pBase64
81386>>>>>>>>>        String sResult
81386>>>>>>>>>        Integer iVoid
81386>>>>>>>>>        Move (Base64Encode(AddressOf(sValue), Length(sValue))) to pBase64
81387>>>>>>>>>        Move pBase64 to sResult
81388>>>>>>>>>        Move (Free(pBase64)) to iVoid
81389>>>>>>>>>        Function_Return sResult
81390>>>>>>>>>    End_Function
81391>>>>>>>>>
81391>>>>>>>>>    Function DecodeString String sValue Returns String
81394>>>>>>>>>        Address pBinary
81394>>>>>>>>>        String sBinary
81394>>>>>>>>>        Integer iVoid iLen
81394>>>>>>>>>        Move (Base64Decode(AddressOf(sValue), &iLen)) to pBinary
81395>>>>>>>>>        Move (Repeat(Character(0), iLen)) to sBinary
81396>>>>>>>>>        Move (MemCopy(AddressOf(sBinary), pBinary, iLen)) to iVoid
81397>>>>>>>>>        Move (Free(pBinary)) to iVoid
81398>>>>>>>>>        Function_Return sBinary
81399>>>>>>>>>    End_Function
81400>>>>>>>>>
81400>>>>>>>>>End_Object
81401>>>>>>>Use MSSqldrv.pkg
81401>>>>>>>Use db2_drv.pkg
81401>>>>>>>Use odbc_drv.pkg
81401>>>>>>>Use vWin32fh.pkg
81401>>>>>>>
81401>>>>>>>Use DUFLanguageConstants.inc
Including file: DUFLanguageConstants.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\DUFLanguageConstants.inc)
81401>>>>>>>>>//
81401>>>>>>>>>// *** The Database Update Framework Include file ***
81401>>>>>>>>>// Language constant declarations for all classes included in "DUF - The Database Update Framework"
81401>>>>>>>>>// They have all been placed in this central spot to make translations to various languages more convenient.
81401>>>>>>>>>//
81401>>>>>>>>>//
81401>>>>>>>>>Use LanguageText.Pkg
81401>>>>>>>>>
81401>>>>>>>>>// *** cSQLConnectionsIniFile Class Language Constants ***
81401>>>>>>>>>//
81401>>>>>>>>>    Define CS_DUF_DuplicateConnectionIDPre  for "Cannot register connection ID"
81401>>>>>>>>>    Define CS_DUF_DuplicateConnectionIDPost for "This ID already exists."
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>// *** cSQLConnectionsHandler Class Language Constants ***
81401>>>>>>>>>//
81401>>>>>>>>>    Define CS_DUF_SetupErrorcConnection  for "Cannot login to the database server as the cConnection hasn't been setup properly. Can't continue. Program will now exit."
81401>>>>>>>>>    Define CS_DUF_CannotLoginToServer    for "Could not login to the database server. Can't continue. Program will now exit."
81401>>>>>>>>>    Define CS_DUF_ErrorText              for "\n\nError Text:"
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>// *** cDbUpdateFunctionLibrary Class Language Constants ***
81401>>>>>>>>>//
81401>>>>>>>>>    Define CS_SQLConnectError       for "SQL error. Could not connect to the SQL database manager"
81401>>>>>>>>>    Define CS_SQLAttachError        for "Could not attach to the database:"
81401>>>>>>>>>    Define CS_SQLDeletingIndex      for "Deleting index"
81401>>>>>>>>>    Define CS_SQLCopyingData        for "Copying data"
81401>>>>>>>>>    Define CS_SQLCreatingIndex      for "Creating index"
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>// *** cDbUpdateVersion Class Language Constants ***
81401>>>>>>>>>//
81401>>>>>>>>>    Define CS_UpdateVersion     for "Updating database"
81401>>>>>>>>>    Define CS_UpdateFromVersion for "from version"
81401>>>>>>>>>    Define CS_UpdateToVersion   for "to version:"
81401>>>>>>>>>    Define CS_DbUpdateTableMissing for "Cannot open the 'DbVersion' table that is used when updating the database! Cannot continue!"
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>// *** cDbUpdateHandler.inc Class Language Constants ***
81401>>>>>>>>>//
81401>>>>>>>>>    Define CS_DatabaseInUseShort  for "There are others using the application/database. Are you sure you still want to update the database?"
81401>>>>>>>>>    Define CS_DatabaseNeedsUpdate for ("The database needs to be updated." + "\n\nATTENTION! The database may not be in use while this work is performed. Make sure that nobody else is using the application before clicking 'Yes' below.\n\n" + "Start update now?")
81401>>>>>>>>>    Define CS_HeaderUpdateText    for "Important!"
81401>>>>>>>>>    Define CS_DatabaseInUseText   for "There are others using the application/database or at least one table could NOT be opened exclusively. Please close all other applications using the database and try again. The Application will now close."
81401>>>>>>>>>    Define CS_WorkingHeaderText   for "Working!"
81401>>>>>>>>>    Define CS_WorkingUpdateText   for "The database is being updated. Please wait..."
81401>>>>>>>>>    Define CS_DatabaseUpdatedText for "Ready! The database was updated."
81401>>>>>>>>>    Define CS_DatabaseCheckedText for "Ready! The database was checked but no updates was needed."
81401>>>>>>>>>    Define CS_DbUpdatedErrorText  for "One or more errors occured while the database was updated. Please check the logfile.\n\nThe program will now close."
81401>>>>>>>>>    Define CS_UpdateInProgressTxt for ("System locked!\n\nThe database is being updated. Please try again later...\n\n" * "The program will now close.")
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>Use MertechDUF.pkg
Including file: MertechDUF.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\MertechDUF.pkg)
81401>>>>>>>>>//
81401>>>>>>>>>// Use of Mertech drivers:
81401>>>>>>>>>// Put the line "Define DUF_Use_Mertech_Drivers in YOUR code prior the "Use" statement for this package if using Mertech drivers!
81401>>>>>>>>>// And put the line right before the "Use cDbUpdateHandler.pkg" line.
81401>>>>>>>>>//Define DUF_Use_Mertech_Drivers
81401>>>>>>>>>//
#REM USE MERTECH.INC
81401>>>>>>>>>    Use Flex2SQLDUF.pkg
Including file: Flex2SQLDUF.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\Flex2SQLDUF.pkg)
81401>>>>>>>>>>>//*************************************************************************
81401>>>>>>>>>>>//*                                                                       *
81401>>>>>>>>>>>//*  Confidential Trade Secret.                                           *
81401>>>>>>>>>>>//*  Copyright (c) 1997-2014 Mertech Data Systems Inc, Miami Florida      *
81401>>>>>>>>>>>//*  All rights reserved.                                                 *
81401>>>>>>>>>>>//*  DataFlex is a registered trademark of Data Access Corporation.       *
81401>>>>>>>>>>>//*                                                                       *
81401>>>>>>>>>>>//*  NOTE: This version of Flex2SQL is specially adapted to be used with  *
81401>>>>>>>>>>>// * the Database Update Framework (DUF)                                  *
81401>>>>>>>>>>>// *                                                                      *
81401>>>>>>>>>>>//*************************************************************************
81401>>>>>>>>>>>Use mertech.inc
Including file: mertech.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\mertech.inc)
81401>>>>>>>>>>>>>//*************************************************************************
81401>>>>>>>>>>>>>//*                                                                       *
81401>>>>>>>>>>>>>//*  Confidential Trade Secret.                                           *
81401>>>>>>>>>>>>>//*  Copyright (c) 1997-2014 Mertech Data Systems Inc, Miami Florida      *
81401>>>>>>>>>>>>>//*  All rights reserved.                                                 *
81401>>>>>>>>>>>>>//*  DataFlex is a registered trademark of Data Access Corporation.       *
81401>>>>>>>>>>>>>//*                                                                       *
81401>>>>>>>>>>>>>//*************************************************************************
81401>>>>>>>>>>>>>Use UI
81401>>>>>>>>>>>>>Use SEQ_CHNL.PKG
81401>>>>>>>>>>>>>
#REM -----------------------------------------------
#REM MERTECH DATA SYSTEMS INC. - WWW.MERTECHDATA.COM
#REM MERTECH.INC VERSION 3.1.1
#REM -----------------------------------------------
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>// #DEFINE's
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//Currently Unsupported Attribute
81401>>>>>>>>>>>>>Define DF_FILE_PRIMARY_KEY                          For (DF_FILE_RECORD_REREAD+1)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// TODO: This is probably deprecated. Investigate.
81401>>>>>>>>>>>>>Define DF_FILE_NUMBER_INVERSE_KEYS                  For (DF_FILE_RECORD_REREAD+3)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_SET_MODE
81401>>>>>>>>>>>>>/// @Description Allows switching between set-oriented and record oriented fetch modes.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// If DF_FILE_SET_MODE is set to True, the driver will fetch a set of records
81401>>>>>>>>>>>>>/// for each find. If DF_FILE_SET_MODE is False, the driver will fetch only one
81401>>>>>>>>>>>>>/// record at a time. This attribute can also be specified in the .INT file during
81401>>>>>>>>>>>>>/// migration through Flex2SQL. This settings is normally used alongside
81401>>>>>>>>>>>>>/// DF_FILE_MAX_ROWS to set the number of rows to return and DF_FILE_CACHE_MODE
81401>>>>>>>>>>>>>/// to turn on local caching.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Note: Turning off set-mode can have a detrimental impact on performance. Unless
81401>>>>>>>>>>>>>/// there is a specific reason to do otherwise, this option should be left on.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Default value: True
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
81401>>>>>>>>>>>>>/// @See DF_FILE_MAX_ROWS DF_FILE_CACHE_MODE
81401>>>>>>>>>>>>>/// @INTOPT OPTIMIZE {FOR_SET | ONE_ROW}
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_SET_MODE of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_SET_MODE of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Mode for the FileNumber. True for set-mode, False for one-row mode.
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Orderhea
81401>>>>>>>>>>>>>/// Set_Attribute DF_FILE_SET_MODE of Orderhea.File_Number to True
81401>>>>>>>>>>>>>/// Get_Attribute DF_FILE_SET_MODE of Orderhea.File_Number to boolVar
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>Define DF_FILE_SET_MODE                             For (DF_FILE_RECORD_REREAD+5)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_DATABASENAME
81401>>>>>>>>>>>>>/// @Description Returns a string containing the name of the database where the
81401>>>>>>>>>>>>>/// table referenced by the passed File Number resides. This is a READ ONLY
81401>>>>>>>>>>>>>/// attribute. Note that because Oracle doesn't support the concept of multiple
81401>>>>>>>>>>>>>/// databases on one server, this attribute is not valid for Oracle.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     SQLFlex, MySQLFlex, PGFlex
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_DATABASENAME of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Name of the Database
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Orderhea
81401>>>>>>>>>>>>>/// Get_Attribute DF_FILE_DATABASENAME of Orderhea.File_Number to strVal
81401>>>>>>>>>>>>>Define DF_FILE_DATABASENAME                         For (DF_FILE_RECORD_REREAD+6)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_MAX_ROWS
81401>>>>>>>>>>>>>/// @Description Controls the maximum number of rows retrieved by a Find GT/LT
81401>>>>>>>>>>>>>/// operation. The driver will automatically retrieve and cache this many rows
81401>>>>>>>>>>>>>/// for future find GT/LT operations. Setting this property to a very high
81401>>>>>>>>>>>>>/// value can be inefficient from a UI perspective but may be advisable for
81401>>>>>>>>>>>>>/// local processing of rows (such as in a batch process).
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Default value: 10
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
81401>>>>>>>>>>>>>/// @See DF_FILE_SET_MODE DF_FILE_CACHE_MODE
81401>>>>>>>>>>>>>/// @INTOPT MAX_ROWS_TO_QUERY {integer}
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_DATABASENAME of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Attribute Value
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Orderhea
81401>>>>>>>>>>>>>/// Set_Attribute DF_FILE_MAX_ROWS of Orderhea.File_Number to 10
81401>>>>>>>>>>>>>/// Get_Attribute DF_FILE_MAX_ROWS of Orderhea.File_Number to intVal
81401>>>>>>>>>>>>>Define DF_FILE_MAX_ROWS                             For (DF_FILE_RECORD_REREAD+7)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_TABLE_NAME
81401>>>>>>>>>>>>>/// @Description Use this attribute to set or get the name of the SQL table
81401>>>>>>>>>>>>>/// corresponding to the specified file number. In a restructure operation
81401>>>>>>>>>>>>>/// this attribute may be used to permanently change the table that a filelist
81401>>>>>>>>>>>>>/// entry is pointing to.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>/// @INTOPT DATABASE_NAME {string}
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_TABLE_NAME of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_TABLE_NAME of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Name of the SQL Table.
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Orderhea
81401>>>>>>>>>>>>>/// Get_Attribute DF_FILE_TABLE_NAME of Orderhea.File_Number to strVal
81401>>>>>>>>>>>>>Define DF_FILE_TABLE_NAME                           For (DF_FILE_RECORD_REREAD+8)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_CACHE_MODE
81401>>>>>>>>>>>>>/// @Description Activates or deactivates the local cache for set-oriented searches.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Through the DF_FILE_CACHE_MODE attribute, we can activate or deactivate the
81401>>>>>>>>>>>>>/// local cache. When the cache is active in a set-oriented search, a fixed
81401>>>>>>>>>>>>>/// number of records are pre-fetched and kept in the local cache. If a record
81401>>>>>>>>>>>>>/// is not found in the local cache, a new set is fetched. The number of records
81401>>>>>>>>>>>>>/// fetched is controlled via the DF_FILE_MAX_ROWS attribute. Set-mode vs. one-row
81401>>>>>>>>>>>>>/// mode is controlled via the DF_FILE_SET_MODE attribute.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Note: Turning off the cache can have significant detrimental effects on performance.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Default value: True
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
81401>>>>>>>>>>>>>/// @See         DF_FILE_MAX_ROWS DF_FILE_SET_MODE
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_CACHE_MODE of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_CACHE_MODE of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Mode for FileNumber. True for active. False for inactive.
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Orderhea
81401>>>>>>>>>>>>>/// Set_Attribute DF_FILE_CACHE_MODE of Orderhea.File_Number to True
81401>>>>>>>>>>>>>/// Get_Attribute DF_FILE_CACHE_MODE of Orderhea.File_Number to boolVal
81401>>>>>>>>>>>>>Define DF_FILE_CACHE_MODE                           For (DF_FILE_RECORD_REREAD+9)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//Currently Unsupported Attribute
81401>>>>>>>>>>>>>Define DF_FILE_STORAGE_BASE                         For (DF_FILE_RECORD_REREAD+10)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_STATIC
81401>>>>>>>>>>>>>/// @Description Activates or deactivates a special table mode where all rows
81401>>>>>>>>>>>>>/// from the table are loaded into a local cache. When active, all searches are
81401>>>>>>>>>>>>>/// done in memory and the actual table is not accessed.  The driver does not allow
81401>>>>>>>>>>>>>/// editing of a table in static mode.  This is a very useful feature especially
81401>>>>>>>>>>>>>/// when a table contains configuration or static information used in
81401>>>>>>>>>>>>>/// calculations, (i.e., Tax Rate tables, etc.) By keeping this table locally
81401>>>>>>>>>>>>>/// in memory, network round trips are saved resulting in significant
81401>>>>>>>>>>>>>/// performance improvements. This attribute is also useful for batch
81401>>>>>>>>>>>>>/// processes that make extensive table IO requests for reading static information.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Note: Because the entire table is loaded into memory, it is inadvisable to use
81401>>>>>>>>>>>>>/// this on very large tables.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Default value: False
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_STATIC of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Static Mode for FileNumber. True for static. False for dynamic.
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Orderhea
81401>>>>>>>>>>>>>/// Set_Attribute DF_FILE_STATIC of Orderhea.File_Number to True
81401>>>>>>>>>>>>>/// Get_Attribute DF_FILE_STATIC of Orderhea.File_Number to boolVal
81401>>>>>>>>>>>>>Define DF_FILE_STATIC                               For (DF_FILE_RECORD_REREAD+11)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_SERVER_NAME
81401>>>>>>>>>>>>>/// @Description Use this attribute to set or get the name of the database server
81401>>>>>>>>>>>>>/// corresponding to the specified file number. In a restructure operation
81401>>>>>>>>>>>>>/// this attribute may be used to permanently change the server that a filelist
81401>>>>>>>>>>>>>/// entry is pointing to.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>/// @INTOPT SERVER_NAME {string}
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_SERVER_NAME of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_SERVER_NAME of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Name of the database server.
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Orderhea
81401>>>>>>>>>>>>>/// Set_Attribute DF_FILE_SERVER_NAME of Orderhea.File_Number to "(localdb)\v11.0"
81401>>>>>>>>>>>>>/// Get_Attribute DF_FILE_SERVER_NAME of Orderhea.File_Number to strVal
81401>>>>>>>>>>>>>Define DF_FILE_SERVER_NAME                          For (DF_FILE_RECORD_REREAD+12)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FETCH_FIELD_COUNT
81401>>>>>>>>>>>>>/// @Description This attribute is used to get the number of fields or columns
81401>>>>>>>>>>>>>/// in the given table. Note that this is referring to the columns in the SQL
81401>>>>>>>>>>>>>/// backend and may not necessarily reflect the number of columns in DataFlex.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// This is a readonly attribute.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     MsSQLFlex MySQLFlex
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-14 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>/// @INTOPT
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FETCH_FIELD_COUNT of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Name of the Tablespace.
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>/// Get_Attribute DF_FETCH_FIELD_COUNT of hFile To "INDXS"
81401>>>>>>>>>>>>>Define DF_FETCH_FIELD_COUNT                         For (DF_FILE_RECORD_REREAD+13)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_TABLESPACE_NAME
81401>>>>>>>>>>>>>/// @Description A tablespace is a container of segments (objects that have an
81401>>>>>>>>>>>>>/// allotted amount of space), i.e. tables and indexes. This attribute is
81401>>>>>>>>>>>>>/// used to get or set the name of the tablespace being used for the data tables.
81401>>>>>>>>>>>>>/// To set or get the tablespace name for indexes, use the DF_FILE_INDEXTABLESPACE_NAME
81401>>>>>>>>>>>>>/// attribute. Setting the tablespace name can only be done during a Structure_Start
81401>>>>>>>>>>>>>/// (during table creation).  Getting the name, however can be done at
81401>>>>>>>>>>>>>/// anytime.  Note that when setting the tablespace name, it must be set to an
81401>>>>>>>>>>>>>/// already existing tablespace, this attribute does not create the tablespace itself.
81401>>>>>>>>>>>>>/// Even though MYSQL uses tablespaces, this this attribute is only supported
81401>>>>>>>>>>>>>/// in Oracle and PostgreSQL.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     ORAFlex PGFlex
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-25 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See         DF_FILE_INDEXTABLESPACE_NAME
81401>>>>>>>>>>>>>/// @INTOPT
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_TABLESPACE_NAME of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_TABLESPACE_NAME of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Name of the Tablespace.
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Handle hFile
81401>>>>>>>>>>>>>/// move 0 to hFile
81401>>>>>>>>>>>>>/// Structure_Start hFile "ORA_DRV"
81401>>>>>>>>>>>>>///     Set_Attribute DF_FILE_TABLESPACE_NAME      of hFile To "USERS"
81401>>>>>>>>>>>>>///     Set_Attribute DF_FILE_INDEXTABLESPACE_NAME of hFile To "INDXS"
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>///             // More table creation here
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Structure_End hFile DF_STRUCTEND_OPT_NONE "." 0
81401>>>>>>>>>>>>>Define DF_FILE_TABLESPACE_NAME                      For (DF_FILE_RECORD_REREAD+14)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// TODO: This is probably deprecated. Investigate.
81401>>>>>>>>>>>>>Define DF_FETCH_FIELDNUMBER                         For (DF_FILE_RECORD_REREAD+15)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_INDEXTABLESPACE_NAME
81401>>>>>>>>>>>>>/// @Description This attribute is used to get or set the name of the tablespace
81401>>>>>>>>>>>>>/// being used for the index segment of a database. For a description of tablespaces,
81401>>>>>>>>>>>>>/// see the description above for DF_FILE_TABLESPACE_NAME. Similar to the Tablespace
81401>>>>>>>>>>>>>/// name attribute, setting the index tablespace name can only be done during creation
81401>>>>>>>>>>>>>/// and must use an already existing tablespace as the variable. This attribute is
81401>>>>>>>>>>>>>/// only available for Oracle and Postgre.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     ORAFlex PGFlex
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-25 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See         DF_FILE_TABLESPACE_NAME
81401>>>>>>>>>>>>>/// @INTOPT
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_INDEXTABLESPACE_NAME of {File Number} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_INDEXTABLESPACE_NAME of {File Number} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Name of the Tablespace
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Handle hFile
81401>>>>>>>>>>>>>/// move 0 to hFile
81401>>>>>>>>>>>>>/// Structure_Start hFile "ORA_DRV"
81401>>>>>>>>>>>>>///     Set_Attribute DF_FILE_TABLESPACE_NAME      of hFile To "USERS"
81401>>>>>>>>>>>>>///     Set_Attribute DF_FILE_INDEXTABLESPACE_NAME of hFile To "INDXS"
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>///             // More table creation here
81401>>>>>>>>>>>>>///             //
81401>>>>>>>>>>>>>/// Structure_End hFile DF_STRUCTEND_OPT_NONE "." 0
81401>>>>>>>>>>>>>Define DF_FILE_INDEXTABLESPACE_NAME                 For (DF_FILE_RECORD_REREAD+16)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_RETRIEVE_RECNUM
81401>>>>>>>>>>>>>/// @Description When creating records on a table with RECNUM support, the
81401>>>>>>>>>>>>>/// record number is returned after creation. When this attribute is false, the newly
81401>>>>>>>>>>>>>/// created record's RECNUM is not returned from the server. This could result in a
81401>>>>>>>>>>>>>/// slight performance improvement when many records are being created in a loop.
81401>>>>>>>>>>>>>/// The optimization, however, is negligible.  Having this attribute set to false can
81401>>>>>>>>>>>>>/// have detrimental effects if used improperly; i.e. DD-based saves or UI-based
81401>>>>>>>>>>>>>/// operations. Thus, this should almost always be set to true unless there is a
81401>>>>>>>>>>>>>/// compelling reason to do otherwise.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Default Value: True
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-31 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>/// @INTOPT
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_RETRIEVE_RECNUM of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_RETRIEVE_RECNUM of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Boolean variable. false to not retrieve record number, true otherwise.
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// open ORDERHEA
81401>>>>>>>>>>>>>/// Handle  hFile
81401>>>>>>>>>>>>>/// Boolean bRetrieve
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Set_Attribute DF_FILE_RETRIEVE_RECNUM of hFile to false
81401>>>>>>>>>>>>>/// Get_Attribute DF_FILE_RETRIEVE_RECNUM of hFile To bRetrieve
81401>>>>>>>>>>>>>Define DF_FILE_RETRIEVE_RECNUM                      For (DF_FILE_RECORD_REREAD+17)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_NAME_SPACE
81401>>>>>>>>>>>>>/// @Description In Postgres, schemas are objects where all the tables,views and indexes
81401>>>>>>>>>>>>>/// are stored. Separate schemas are used to specify relational data. This attribute is
81401>>>>>>>>>>>>>/// used to set the name of the schema where a table is created. Schema's do not account
81401>>>>>>>>>>>>>/// for any physical space but are merely used as theory to explain the order of a database.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     PGFlex
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-25 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>/// @INTOPT
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_NAME_SPACE of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_NAME_SPACE of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Name of the Schema
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// open ORDERHEA
81401>>>>>>>>>>>>>/// Handle hFile
81401>>>>>>>>>>>>>/// String sSchemaName
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Set_Attribute DF_FILE_NAME_SPACE of hFile to "ORDERHEA"
81401>>>>>>>>>>>>>/// Get_Attribute DF_FILE_NAME_SPACE of hFile To sSchemaName
81401>>>>>>>>>>>>>Define DF_FILE_NAME_SPACE                           For (DF_FILE_RECORD_REREAD+18)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// Currently does not serve any function. May be included in future versions.
81401>>>>>>>>>>>>>Define DF_FILE_STORAGE_PCTFREE                      For (DF_FILE_RECORD_REREAD+19)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// Currently does not serve any function. May be included in future versions.
81401>>>>>>>>>>>>>Define DF_FILE_STORAGE_PCTUSED                      For (DF_FILE_RECORD_REREAD+21)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// Currently does not serve any function. May be included in future versions.
81401>>>>>>>>>>>>>Define DF_FILE_STORAGE_INITIAL                      For (DF_FILE_RECORD_REREAD+23)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// Currently does not serve any function. May be included in future versions.
81401>>>>>>>>>>>>>Define DF_FILE_STORAGE_NEXT                         For (DF_FILE_RECORD_REREAD+25)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// Currently does not serve any function. May be included in future versions.
81401>>>>>>>>>>>>>Define DF_FILE_ALLOW_NULL                           For (DF_FILE_RECORD_REREAD+27)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_GET_SERVERNAME_FROM_LOGIN
81401>>>>>>>>>>>>>/// @Description Use this attribute to specify whether the SERVER_NAME option will
81401>>>>>>>>>>>>>/// be included in the INT file.  If set to True, the SERVER_NAME option will not
81401>>>>>>>>>>>>>/// be included in the INT file, if set to false, the SERVER_NAME option will be
81401>>>>>>>>>>>>>/// included in the INT file. This has two uses. The first is during a Structure_Start
81401>>>>>>>>>>>>>/// i.e. table creation/modification. The other is when using the OUTPUT_INT_FILE
81401>>>>>>>>>>>>>/// command. Set this attribute before the OUTPUT_INT_FILE to indicate how the INT
81401>>>>>>>>>>>>>/// file will be written. This name indicates a backwards logic so take note that
81401>>>>>>>>>>>>>/// setting it to true will NOT include the SERVER_NAME in the INT file.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Default Value: False
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Deprecated
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See         DF_FILE_SUPPRESS_SERVERNAME_OUTPUT
81401>>>>>>>>>>>>>/// @INTOPT              SERVER_NAME
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_GET_SERVERNAME_FROM_LOGIN of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_GET_SERVERNAME_FROM_LOGIN of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Customer
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>///     Set_Attribute DF_FILE_GET_SERVERNAME_FROM_LOGIN of Customer.File_Number to True
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>///     OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Close Customer
81401>>>>>>>>>>>>>Define DF_FILE_GET_SERVERNAME_FROM_LOGIN            For (DF_FILE_RECORD_REREAD+29)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_SUPPRESS_SERVERNAME_OUTPUT
81401>>>>>>>>>>>>>/// @Description Use this attribute to specify whether the SERVER_NAME option will be included
81401>>>>>>>>>>>>>/// in the INT file.  If set to True, the server name will not be included in the INT file,
81401>>>>>>>>>>>>>/// if set to false, the server name will be included in the INT file. This has two uses.
81401>>>>>>>>>>>>>/// The first is during a Structure_Start i.e. table creation/modification. The other is
81401>>>>>>>>>>>>>/// when using the OUTPUT_INT_FILE command. Set this attribute before the OUTPUT_INT_FILE
81401>>>>>>>>>>>>>/// to indicate how the INT file will be written.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Default Value: False
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See         DF_FILE_SUPPRESS_DATABASENAME_OUTPUT DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT
81401>>>>>>>>>>>>>/// @INTOPT              SERVER_NAME
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_SUPPRESS_SERVERNAME_OUTPUT of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_SUPPRESS_SERVERNAME_OUTPUT of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Customer
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>///   Set_Attribute DF_FILE_SUPPRESS_SERVERNAME_OUTPUT of Customer.File_Number to True
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>///   OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Close Customer
81401>>>>>>>>>>>>>Define DF_FILE_SUPPRESS_SERVERNAME_OUTPUT                       For DF_FILE_GET_SERVERNAME_FROM_LOGIN
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_GET_DATABASENAME_FROM_LOGIN
81401>>>>>>>>>>>>>/// @Description Use this attribute to specify whether the DATABASE_NAME option will
81401>>>>>>>>>>>>>/// be included in the INT file.  If set to True, the DATABASE_NAME option will not
81401>>>>>>>>>>>>>/// be included in the INT file, if set to false, the DATABASE_NAME option will be
81401>>>>>>>>>>>>>/// included in the INT file. This has two uses. The first is during a Structure_Start
81401>>>>>>>>>>>>>/// i.e. table creation/modification. The other is when using the OUTPUT_INT_FILE
81401>>>>>>>>>>>>>/// command. Set this attribute before the OUTPUT_INT_FILE to indicate how the INT
81401>>>>>>>>>>>>>/// file will be written. This name indicates a backwards logic so take note that
81401>>>>>>>>>>>>>/// setting it to true will NOT include the DATABASE_NAME in the INT file.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Default Value: False
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Deprecated
81401>>>>>>>>>>>>>/// @Drivers     PGFlex SQLFlex MySQLFlex
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See         DF_FILE_SUPPRESS_DATABASENAME_OUTPUT
81401>>>>>>>>>>>>>/// @INTOPT              DATABASE_NAME
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_GET_DATABASENAME_FROM_LOGIN of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_GET_DATABASENAME_FROM_LOGIN of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Customer
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>///     Set_Attribute DF_FILE_GET_DATABASENAME_FROM_LOGIN of Customer.File_Number to True
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>///     OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Close Customer
81401>>>>>>>>>>>>>Define DF_FILE_GET_DATABASENAME_FROM_LOGIN          For (DF_FILE_RECORD_REREAD+31)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_SUPPRESS_DATABASENAME_OUTPUT
81401>>>>>>>>>>>>>/// @Description Use this attribute to specify whether the DATABASE_NAME option will
81401>>>>>>>>>>>>>/// be included in the INT file.  If set to True, the DATABASE_NAME option will not
81401>>>>>>>>>>>>>/// be included in the INT file, if set to false, the DATABASE_NAME option will be
81401>>>>>>>>>>>>>/// included in the INT file. This has two uses. The first is during a Structure_Start
81401>>>>>>>>>>>>>/// i.e. table creation/modification. The other is when using the OUTPUT_INT_FILE
81401>>>>>>>>>>>>>/// command. Set this attribute before the OUTPUT_INT_FILE to indicate how the INT
81401>>>>>>>>>>>>>/// file will be written. This name indicates a backwards logic so take note that
81401>>>>>>>>>>>>>/// setting it to true will NOT include the DATABASE_NAME in the INT file.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Default Value: False
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     PGFlex SQLFlex MySQLFlex
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See         DF_FILE_SUPPRESS_SERVERNAME_OUTPUT DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT
81401>>>>>>>>>>>>>/// @INTOPT              DATABASE_NAME
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_SUPPRESS_DATABASENAME_OUTPUT of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_SUPPRESS_DATABASENAME_OUTPUT of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Customer
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>///     Set_Attribute DF_FILE_SUPPRESS_DATABASENAME_OUTPUT of Customer.File_Number to True
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>///     OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Close Customer
81401>>>>>>>>>>>>>Define DF_FILE_SUPPRESS_DATABASENAME_OUTPUT                     For DF_FILE_GET_DATABASENAME_FROM_LOGIN
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_GET_SCHEMANAME_FROM_LOGIN
81401>>>>>>>>>>>>>/// @Description Use this attribute to specify whether the SCHEMA_NAME option will
81401>>>>>>>>>>>>>/// be included in the INT file.  If set to True, the SCHEMA_NAME option will not
81401>>>>>>>>>>>>>/// be included in the INT file, if set to false, the SCHEMA_NAME option will be
81401>>>>>>>>>>>>>/// included in the INT file. This has two uses. The first is during a Structure_Start
81401>>>>>>>>>>>>>/// i.e. table creation/modification. The other is when using the OUTPUT_INT_FILE
81401>>>>>>>>>>>>>/// command. Set this attribute before the OUTPUT_INT_FILE to indicate how the INT
81401>>>>>>>>>>>>>/// file will be written. This name indicates a backwards logic so take note that
81401>>>>>>>>>>>>>/// setting it to true will NOT include the SCHEMA_NAME in the INT file.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Default Value: False
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Deprecated
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See         DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT
81401>>>>>>>>>>>>>/// @INTOPT              SCHEMA_NAME
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_GET_SCHEMANAME_FROM_LOGIN of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_GET_SCHEMANAME_FROM_LOGIN of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Customer
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>///     Set_Attribute DF_FILE_GET_SCHEMANAME_FROM_LOGIN of Customer.File_Number to True
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>///     OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Close Customer
81401>>>>>>>>>>>>>Define DF_FILE_GET_SCHEMANAME_FROM_LOGIN            For (DF_FILE_RECORD_REREAD+33)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT
81401>>>>>>>>>>>>>/// @Description Use this attribute to specify whether the SCHEMA_NAME option will
81401>>>>>>>>>>>>>/// be included in the INT file.  If set to True, the SCHEMA_NAME option will not
81401>>>>>>>>>>>>>/// be included in the INT file, if set to false, the SCHEMA_NAME option will be
81401>>>>>>>>>>>>>/// included in the INT file. This has two uses. The first is during a Structure_Start
81401>>>>>>>>>>>>>/// i.e. table creation/modification. The other is when using the OUTPUT_INT_FILE
81401>>>>>>>>>>>>>/// command. Set this attribute before the OUTPUT_INT_FILE to indicate how the INT
81401>>>>>>>>>>>>>/// file will be written. This name indicates a backwards logic so take note that
81401>>>>>>>>>>>>>/// setting it to true will NOT include the SCHEMA_NAME in the INT file.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Default Value: False
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See         DF_FILE_SUPPRESS_DATABASENAME_OUTPUT DF_FILE_SUPPRESS_SERVERNAME_OUTPUT
81401>>>>>>>>>>>>>/// @INTOPT              SCHEMA_NAME
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Customer
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>///     Set_Attribute DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT of Customer.File_Number to True
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>///     OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Close Customer
81401>>>>>>>>>>>>>Define DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT           For DF_FILE_GET_SCHEMANAME_FROM_LOGIN
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//TODO
81401>>>>>>>>>>>>>Define DF_FILE_PRESERVE_RECNUM                      For 184
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// Currently Unsupported Attribute
81401>>>>>>>>>>>>>Define DF_FILE_NATIVE_RECORD_LENGTH                 For 194
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_OEM_TRANSLATION
81401>>>>>>>>>>>>>/// @Description There are two sets of code pages used in windows, ANSI and
81401>>>>>>>>>>>>>/// OEM. ANSI is what is commonly used now, but some data still uses the OEM
81401>>>>>>>>>>>>>/// code pages. When migrating data, this attribute is used to determine whether
81401>>>>>>>>>>>>>/// the OEM data will be translated to ANSI during the migration. For example,
81401>>>>>>>>>>>>>/// migrating passwords with special characters may call for different code pages.
81401>>>>>>>>>>>>>/// Setting this attribute to true will convert the OEM data to ANSI, setting it
81401>>>>>>>>>>>>>/// to false will not.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-15 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>/// @INTOPT
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_OEM_TRANSLATION of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_OEM_TRANSLATION of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Indicates if OEM data will be converted to ANSI. True converts it, false does not.
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// open Customer
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Handle hFile
81401>>>>>>>>>>>>>/// Boolean bTranslate
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Structure_Start hFile
81401>>>>>>>>>>>>>///     Set_Attribute DF_FILE_OEM_TRANSLATION of hFile to True
81401>>>>>>>>>>>>>///     Get_Attribute DF_FILE_OEM_TRANSLATION of hFile to bTranslate
81401>>>>>>>>>>>>>/// Structure_End hFile
81401>>>>>>>>>>>>>Define DF_FILE_OEM_TRANSLATION                      For (DF_FILE_RECORD_REREAD+51)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_EPOCH_YEAR
81401>>>>>>>>>>>>>/// @Description When dealing with two-digit years, an epoch year must be used
81401>>>>>>>>>>>>>/// to determine which century the date is referring to. For example if the
81401>>>>>>>>>>>>>/// epoch year is set to 30, then any two digit year greater than 30 will be
81401>>>>>>>>>>>>>/// considered in the 20th Century, anything less than or equal to 30 will be
81401>>>>>>>>>>>>>/// considered in the 21st Century.  This attribute is used to turn on or off
81401>>>>>>>>>>>>>/// this feature. To use this feature, set this attribute to whatever the epoch
81401>>>>>>>>>>>>>/// year is expected to be. To disable this feature, set this attribute to 0
81401>>>>>>>>>>>>>/// or false. Note that setting this attribute must be done at table creation
81401>>>>>>>>>>>>>/// or inside of a Structure_Start.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-15 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>/// @INTOPT      EPOCH_YEAR
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_EPOCH_YEAR of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_EPOCH_YEAR of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Indicates what the epoch year is. 0 to disable
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// open Customer
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Handle hFile
81401>>>>>>>>>>>>>/// Boolean bEpoch
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Structure_Start hFile
81401>>>>>>>>>>>>>///     Set_Attribute DF_FILE_EPOCH_YEAR of hFile to 30
81401>>>>>>>>>>>>>///     Get_Attribute DF_FILE_EPOCH_YEAR of hFile to bEpoch
81401>>>>>>>>>>>>>/// Structure_End hFile
81401>>>>>>>>>>>>>Define DF_FILE_EPOCH_YEAR                           For (DF_FILE_RECORD_REREAD+53)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>Define DF_FILE_USE_ROWCOUNT_IN_TRANSACTIONS         For 628
81401>>>>>>>>>>>>>Define DF_FILE_ICF_STATUS                           For 630
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_LOCK_RECORD_STATUS
81401>>>>>>>>>>>>>/// @Description Table locking is done during transactions to maintain atomicity.
81401>>>>>>>>>>>>>/// In DataFlex, this is usually done with the REREAD/UNLOCK commands. This
81401>>>>>>>>>>>>>/// attribute is used to get the status of a table lock. If a table is currently
81401>>>>>>>>>>>>>/// in a REREAD, or locked, then the attribute will return true. Otherwise, it
81401>>>>>>>>>>>>>/// returns false. It is a read-only attribute so no setting can be done.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-06 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>/// @INTOPT
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_LOCK_RECORD_STATUS of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Indicates the status of the file lock
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// open Customer
81401>>>>>>>>>>>>>/// Handle hFile
81401>>>>>>>>>>>>>/// Integer bLocked
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Get_Attribute DF_FILE_LOCK_RECORD_STATUS of hFile to bLocked
81401>>>>>>>>>>>>>Define DF_FILE_LOCK_RECORD_STATUS                   For 632
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_CASING
81401>>>>>>>>>>>>>/// @Description Controls the filename and column name casing.
81401>>>>>>>>>>>>>/// You can set this to either keep the file case, force to lower case or force
81401>>>>>>>>>>>>>/// to uppercase.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2014-04-28 by Wil van Antwerpen
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>/// @INTOPT
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_CASING of {FileNumber} to {FILE_CASING_KEEP|FILE_CASING_LOWER|FILE_CASING_UPPER}
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_CASING of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber          Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              integer set to one of the above values.
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// open Customer
81401>>>>>>>>>>>>>/// Handle hFile
81401>>>>>>>>>>>>>/// Integer eCasing
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Structure_Start hFile "ORA_DRV"
81401>>>>>>>>>>>>>///    Set_Attribute DF_FILE_CASING of hFile to FILE_CASING_KEEP
81401>>>>>>>>>>>>>/// Structure_End hFile
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Get_Attribute DF_FILE_CASING of hFile to eCasing
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>Define DF_FILE_CASING                               For 634
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>Define DF_FIELD_INVERSE_KEY_NAME                    For (DF_FIELD_NATIVE_LENGTH+1)
81401>>>>>>>>>>>>>Define DF_FIELD_INVERSE_KEY_TYPE                    For (DF_FIELD_NATIVE_LENGTH+2)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//TODO
81401>>>>>>>>>>>>>Define DF_FIELD_TEXT_SEGMENT_NAME                   For (DF_FIELD_NATIVE_LENGTH+3)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//TODO
81401>>>>>>>>>>>>>Define DF_FIELD_TEXT_NUM_SEGMENTS                   For (DF_FIELD_NATIVE_LENGTH+4)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FIELD_DEFAULT_VALUE
81401>>>>>>>>>>>>>/// @Description Use this attribute to get or set the default value for a given column.
81401>>>>>>>>>>>>>/// Setting the default value can only be done during a structure_start or during table
81401>>>>>>>>>>>>>/// creation. If this attribute is not set, it is defaulted to the driver default.
81401>>>>>>>>>>>>>/// See Mertech.cfg
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-06 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>/// @INTOPT
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FIELD_DEFAULT_VALUE of {FileNumber} {FieldNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FIELD_DEFAULT_VALUE of {FileNumber} {FieldNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  FieldNumber           Number of the field
81401>>>>>>>>>>>>>/// @Param  variable              Variable for the default value of the field
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// open Customer
81401>>>>>>>>>>>>>/// String sDefault
81401>>>>>>>>>>>>>/// Handle hFile
81401>>>>>>>>>>>>>/// Integer iColumn
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Move "California" to sDefault
81401>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
81401>>>>>>>>>>>>>/// Move 3 to iColumn
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Structure_Start hFile "ORA_DRV"
81401>>>>>>>>>>>>>///    Set_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefault
81401>>>>>>>>>>>>>/// Structure_End hFile
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Get_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefault
81401>>>>>>>>>>>>>Define DF_FIELD_DEFAULT_VALUE                       For (DF_FIELD_NATIVE_LENGTH+5)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// Currently Unsupported Attribute
81401>>>>>>>>>>>>>Define DF_FIELD_TEXT_LENGTH_SEGMENT                 For (DF_FIELD_NATIVE_LENGTH+6)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//TODO
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FIELD_TIME_ON
81401>>>>>>>>>>>>>/// @Description Assign a field to retrieve Time Stamp value from a DATETIME
81401>>>>>>>>>>>>>/// column in a table.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// This option was implemented because some versions of DataFlex do not support
81401>>>>>>>>>>>>>/// DATETIME fields normally supported by SQL databases.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// To use this: Change the type of a date field in your FD to string type,
81401>>>>>>>>>>>>>/// Set the attribute DF_FIELD_TIME_ON of this field to TRUE and
81401>>>>>>>>>>>>>/// recompile your program.
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FIELD_TIME_ON of <FileNumber|FileName FieldNumber> to DFTRUE | DFFALSE
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  FileName              Name of the file
81401>>>>>>>>>>>>>/// @Param  FieldNumber           Number of the field
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// #INCLUDE MERTECH.INC
81401>>>>>>>>>>>>>/// string sDateTime sDatabaseName
81401>>>>>>>>>>>>>/// open ORDERHEA
81401>>>>>>>>>>>>>/// Set_Attribute DF_FIELD_TIME_ON of 30 3 to dfTrue
81401>>>>>>>>>>>>>/// find GE ORDERHEA by recnum
81401>>>>>>>>>>>>>/// move ORDERHEA.ORDER_DATE to sDateTime
81401>>>>>>>>>>>>>/// showln "sDateTime: " sDateTime
81401>>>>>>>>>>>>>Define DF_FIELD_TIME_ON                             For (DF_FIELD_NATIVE_LENGTH+8)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FIELD_NATIVE_NAME
81401>>>>>>>>>>>>>/// @Description This attribute is used to get the name of the desired column
81401>>>>>>>>>>>>>/// on the SQL backend. Currently this attribute is ReadOnly and so setting
81401>>>>>>>>>>>>>/// or modifying a column name cannot be done using this attribute.  In most
81401>>>>>>>>>>>>>/// cases, the field name on the SQL backend will be the same as the Dataflex name.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// This is a ReadOnly attribute.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>/// @INTOPT
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FIELD_NATIVE_NAME of {FileNumber} {FieldNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber          Number of the file
81401>>>>>>>>>>>>>/// @Param  FieldNumber                 Number of the Field
81401>>>>>>>>>>>>>/// @Param  variable                    String containing the name of the field
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Customer
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// String sName
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Get_Attribute DF_FIELD_NATIVE_NAME of Customer.File_Number 3 to sName
81401>>>>>>>>>>>>>Define DF_FIELD_NATIVE_NAME                         For (DF_FIELD_NATIVE_LENGTH+9)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FIELD_NULL
81401>>>>>>>>>>>>>/// @Description Use this attribute to get or set whether a column in a table will
81401>>>>>>>>>>>>>/// allow null values. When set to true, the column accepts null values. Setting
81401>>>>>>>>>>>>>/// this attribute to false will keep it from accepting null values. Although,
81401>>>>>>>>>>>>>/// getting the value of this attribute can be done at anytime, setting it must
81401>>>>>>>>>>>>>/// be done in a Structure_Start or during table creation.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>/// @INTOPT
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FIELD_NULL of {FileNumber} {FieldNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FIELD_NULL of {FileNumber} {FieldNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber          Number of the file
81401>>>>>>>>>>>>>/// @Param  FieldNumber                 Number of the Field
81401>>>>>>>>>>>>>/// @Param  variable                    Boolean variable
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Customer
81401>>>>>>>>>>>>>/// Handle hFile
81401>>>>>>>>>>>>>/// Integer iColumn
81401>>>>>>>>>>>>>/// Boolean bAllowNull
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
81401>>>>>>>>>>>>>/// Move 3 to iColumn
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Structure_Start hFile "ORA_DRV"
81401>>>>>>>>>>>>>///    Set_Attribute DF_FIELD_NULL of hFile iColumn to True
81401>>>>>>>>>>>>>/// Structure_End hFile
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Get_Attribute DF_FIELD_NULL of hFile iColumn to bAllowNull
81401>>>>>>>>>>>>>Define DF_FIELD_NULL                                For (DF_FIELD_NATIVE_LENGTH+10)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FIELD_NATIVE_TYPE
81401>>>>>>>>>>>>>/// @Description Use this attribute to get or set the Native type for a specific
81401>>>>>>>>>>>>>/// field in a table.  The native type refers to the data type of the field on the
81401>>>>>>>>>>>>>/// SQL backend. Setting this attribute can only be done during table creation or
81401>>>>>>>>>>>>>/// inside of a Structure_Start. When setting this attribute, it is good practice
81401>>>>>>>>>>>>>/// to use the constants mentioned below instead of the integers. For a list of
81401>>>>>>>>>>>>>/// these constants, refer to the sections: "Oracle Data Types", "MySQL Data Types",
81401>>>>>>>>>>>>>/// "PostgreSQL Data Types", and "SQL Server Data Types" included in this document.
81401>>>>>>>>>>>>>/// Note that when getting the value for this attribute, an integer will be returned
81401>>>>>>>>>>>>>/// so these lists of constants can again prove useful.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>/// @INTOPT      FIELD_TYPE
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FIELD_NATIVE_TYPE of {FileNumber} {FieldNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FIELD_NATIVE_TYPE of {FileNumber} {FieldNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber          Number of the file
81401>>>>>>>>>>>>>/// @Param  FieldNumber         Number of the field
81401>>>>>>>>>>>>>/// @Param  variable                    variable for the native data type
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// open Customer
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Integer iColumn iType
81401>>>>>>>>>>>>>/// Handle hFile
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
81401>>>>>>>>>>>>>/// Structure_Start hFile
81401>>>>>>>>>>>>>///     Set_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to "eSQLServer_DATE"
81401>>>>>>>>>>>>>///     Get_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to iType
81401>>>>>>>>>>>>>///     Structure_End hFile
81401>>>>>>>>>>>>>Define DF_FIELD_NATIVE_TYPE                         For (DF_FIELD_NATIVE_LENGTH+12)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// Currently Unsupported Attribute (readOnly used by DataFlex 18.0 Studio)
81401>>>>>>>>>>>>>Define DF_FIELD_NATIVE_TYPE_NAME                    For 711
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// Currently Unsupported Attribute
81401>>>>>>>>>>>>>Define DF_FIELD_NATIVE_OFFSET                       For (DF_FIELD_NATIVE_LENGTH+14)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FIELD_AUTO_INCREMENT
81401>>>>>>>>>>>>>/// @Description Auto incrementing is a technique used in Dataflex usually for
81401>>>>>>>>>>>>>/// fields that are set as the unique identifier. Instead of generating a value
81401>>>>>>>>>>>>>/// or manually inserting data into the column, when a field auto increments,
81401>>>>>>>>>>>>>/// the value of the field increases by one (usually) with each record.  This
81401>>>>>>>>>>>>>/// field is used to get or set whether the field uses this technique or not.
81401>>>>>>>>>>>>>/// The attribute, however, can only be set inside of a Structure_Start or during
81401>>>>>>>>>>>>>/// table creation. Getting the attribute's value can be done at anytime. The
81401>>>>>>>>>>>>>/// value is stored as a boolean, either true or false.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-12 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>/// @INTOPT      FIELD_AUTOINCREMENT_TYPE
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FIELD_AUTO_INCREMENT of {FileNumber} {FieldNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FIELD_AUTO_INCREMENT of {FileNumber} {FieldNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber          Number of the file
81401>>>>>>>>>>>>>/// @Param  FieldNumber         Number of the field
81401>>>>>>>>>>>>>/// @Param  variable                    Boolean variable indicating if the field auto increments.
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// open Customer
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Integer iColumn
81401>>>>>>>>>>>>>/// Boolean bIncrement
81401>>>>>>>>>>>>>/// Handle hFile
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Structure_Start hFile
81401>>>>>>>>>>>>>///     Set_Attribute DF_FIELD_AUTO_INCREMENT of hFile iColumn to True
81401>>>>>>>>>>>>>///     Get_Attribute DF_FIELD_AUTO_INCREMENT of hFile iColumn to bIncrement
81401>>>>>>>>>>>>>///     Structure_End hFile
81401>>>>>>>>>>>>>Define DF_FIELD_AUTO_INCREMENT                      For (DF_FIELD_NATIVE_LENGTH+16)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//Currently Unsupported Attribute
81401>>>>>>>>>>>>>Define DF_FIELD_GENERATE_ALWAYS                     For (DF_FIELD_NATIVE_LENGTH+18)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// Currently Unsupported Attribute
81401>>>>>>>>>>>>>Define DF_FIELD_SEND_LONG_DATA                      For 702
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_INDEX_NATIVE_CREATED
81401>>>>>>>>>>>>>/// @Description Use this attribute to verify if the index that maps to the DataFlex
81401>>>>>>>>>>>>>/// index was created correctly at the SQL backend
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// This is a ReadOnly attribute
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2014-04-30 by Wil van Antwerpen
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>/// @INTOPT
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_INDEX_NATIVE_CREATED of {FileNumber} {IndexNumber} to variable
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  IndexNumber           Number of the index
81401>>>>>>>>>>>>>/// @Param  variable              True if created, false if not
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Customer
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Handle  hFile
81401>>>>>>>>>>>>>/// Integer iIndex
81401>>>>>>>>>>>>>/// Boolean bCreated
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
81401>>>>>>>>>>>>>/// Move 1 To iIndex
81401>>>>>>>>>>>>>/// Get_Attribute DF_INDEX_NATIVE_CREATED of hFile iIndex to bCreated
81401>>>>>>>>>>>>>Define DF_INDEX_NATIVE_CREATED                      For (DF_INDEX_KEY_LENGTH+1)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_INDEX_NAME
81401>>>>>>>>>>>>>/// @Description Use this attribute to get the name of the index on the SQL backend
81401>>>>>>>>>>>>>/// that maps to the numbered index in Dataflex.  This is because, unlike Dataflex,
81401>>>>>>>>>>>>>/// all indexes in SQL are stored as names, not numbers. Since this attribute is
81401>>>>>>>>>>>>>/// currently only a ReadOnly attribute, it can not be used to set or modify a named
81401>>>>>>>>>>>>>/// index.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// This is a ReadOnly attribute
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>/// @INTOPT
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_INDEX_NAME of {FileNumber} {IndexNumber} to variable
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  IndexNumber           Number of the index
81401>>>>>>>>>>>>>/// @Param  variable              Name of the index
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Integer iFile iIndex iIndexes
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Open Orderhea
81401>>>>>>>>>>>>>/// Move Orderhea.File_Number to iFile
81401>>>>>>>>>>>>>/// Get_Attribute DF_FILE_LAST_INDEX_NUMBER of iFile to iIndexes
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// For iIndex From 0 to iIndexes
81401>>>>>>>>>>>>>///     Get_Attribute DF_INDEX_NAME of iFile iIndex to sIndexName
81401>>>>>>>>>>>>>///     Showln "Orderhea.Index." iIndex " : " sIndexName
81401>>>>>>>>>>>>>/// Loop
81401>>>>>>>>>>>>>Define DF_INDEX_NAME                                For (DF_INDEX_KEY_LENGTH+2)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_PRIMARY_KEY
81401>>>>>>>>>>>>>/// @Description This attribute is used to get or set the index number
81401>>>>>>>>>>>>>/// being used for the primary key. Getting the index number can be
81401>>>>>>>>>>>>>/// done at any time, but setting the index must be during a
81401>>>>>>>>>>>>>/// Structure_Start or during table creation.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Deprecated
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See                 DF_INDEX_PRIMARY_KEY
81401>>>>>>>>>>>>>/// @INTOPT
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_PRIMARY_KEY of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_PRIMARY_KEY of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Index number being used with primary key
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Customer
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Integer iKey
81401>>>>>>>>>>>>>/// Handle hFile
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Structure_Start hFile
81401>>>>>>>>>>>>>///     Set_Attribute DF_PRIMARY_KEY of hFile to 2
81401>>>>>>>>>>>>>///     Get_Attribute DF_PRIMARY_KEY of hFile to iKey
81401>>>>>>>>>>>>>/// Structure_End hFile
81401>>>>>>>>>>>>>Define DF_PRIMARY_KEY                               For (DF_INDEX_KEY_LENGTH+3)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_INDEX_PRIMARY_KEY
81401>>>>>>>>>>>>>/// @Description This attribute is used to get or set the index number
81401>>>>>>>>>>>>>/// being used for the primary key. Getting the index number can be
81401>>>>>>>>>>>>>/// done at any time, but setting the index must be during a
81401>>>>>>>>>>>>>/// Structure_Start or during table creation.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>/// @INTOPT              PRIMARY_KEY
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_INDEX_PRIMARY_KEY of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_INDEX_PRIMARY_KEY of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Index number being used with primary key
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Customer
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Integer iKey
81401>>>>>>>>>>>>>/// Handle hFile
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Structure_Start hFile
81401>>>>>>>>>>>>>///     Set_Attribute DF_INDEX_PRIMARY_KEY of hFile to 2
81401>>>>>>>>>>>>>///     Get_Attribute DF_INDEX_PRIMARY_KEY of hFile to iKey
81401>>>>>>>>>>>>>/// Structure_End hFile
81401>>>>>>>>>>>>>Define DF_INDEX_PRIMARY_KEY                         For (DF_INDEX_KEY_LENGTH+3)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_INDEX_STATUS
81401>>>>>>>>>>>>>/// @Description Oracle has an attribute for indexes called "STATUS" which indicates
81401>>>>>>>>>>>>>/// whether or not an index is valid for use. This attribute can only be used to get
81401>>>>>>>>>>>>>/// the value of the "STATUS" property in Oracle. It currently does not support setting
81401>>>>>>>>>>>>>/// the attribute. The two values for this attribute are "VALID" or "UNUSABLE".
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// This is a ReadOnly attribute
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     ORAFlex
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>/// @INTOPT
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_INDEX_STATUS of {FileNumber} {IndexNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  FieldNumber           Number of the index
81401>>>>>>>>>>>>>/// @Param  variable              String indicating validity
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Customer
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// String sIndexStatus
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Get_Attribute DF_INDEX_STATUS of Customer.File_Number 1 to sIndexStatus
81401>>>>>>>>>>>>>Define DF_INDEX_STATUS                              For (DF_INDEX_KEY_LENGTH+4)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//Currently Unsupported Attribute
81401>>>>>>>>>>>>>Define DF_INDEX_STORAGE_PCTFREE                     For (DF_INDEX_KEY_LENGTH+5)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_INDEX_UNIQUE
81401>>>>>>>>>>>>>/// @Description An index on a column that is unique is considered so if it
81401>>>>>>>>>>>>>/// does not have two equal values in that column in two different rows. This
81401>>>>>>>>>>>>>/// attribute is used to find out whether or not the specified index is unique.
81401>>>>>>>>>>>>>/// If it is, this attribute will return "U" indicating that it is indeed unique.
81401>>>>>>>>>>>>>/// This is important to note because when getting the value of this attribute,
81401>>>>>>>>>>>>>/// a string variable must be used. Since this is a ReadOnly attribute, setting
81401>>>>>>>>>>>>>/// an idex to unique cannot be done with this attribute.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-14 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>/// @INTOPT
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_INDEX_UNIQUE of {FileNumber} {IndexNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  FieldNumber           Number of the index
81401>>>>>>>>>>>>>/// @Param  variable              String indicating if unique
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Customer
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// String sIndexUnique
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Get_Attribute DF_INDEX_UNIQUE of Customer.File_Number 1 to sIndexUnique
81401>>>>>>>>>>>>>Define DF_INDEX_UNIQUE                              For (DF_INDEX_KEY_LENGTH+6)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//Currently Unsupported Attribute
81401>>>>>>>>>>>>>Define DF_INDEX_STORAGE_BASE                        For (DF_INDEX_KEY_LENGTH+7)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//Currently Unsupported Attribute
81401>>>>>>>>>>>>>Define DF_INDEX_STORAGE_INITIAL                     For (DF_INDEX_KEY_LENGTH+8)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//Currently Unsupported Attribute
81401>>>>>>>>>>>>>Define DF_INDEX_STORAGE_NEXT                        For (DF_INDEX_KEY_LENGTH+10)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//Currently Unsupported Attribute
81401>>>>>>>>>>>>>Define DF_INDEX_NATIVE_TYPE                         For (DF_INDEX_KEY_LENGTH+13)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//TODO
81401>>>>>>>>>>>>>Define DF_INDEX_TABLESPACE                          For (DF_INDEX_KEY_LENGTH+14)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//TODO
81401>>>>>>>>>>>>>Define DF_FIELD_PROGRAMMATIC_DEFAULT                For 701
81401>>>>>>>>>>>>>Define DF_FIELD_TIME                                For 703
81401>>>>>>>>>>>>>Define DF_FIELD_IS_NULL                             For 704
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FIELD_IS_LOB
81401>>>>>>>>>>>>>/// @Description In databases a LOB data type is any type that is considered
81401>>>>>>>>>>>>>/// a "Large Object" i.e. XML types, Binary types etc.  This attribute is a
81401>>>>>>>>>>>>>/// ReadOnly attribute used to indicate whether the given field is considered
81401>>>>>>>>>>>>>/// a LOB data type. Since it is ReadOnly, this attribute cannot set a field
81401>>>>>>>>>>>>>/// to a LOB data type.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-13 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>/// @INTOPT
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FIELD_IS_LOB of {FileNumber} {FieldNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param      FieldNumber                       Number of the field
81401>>>>>>>>>>>>>/// @Param  variable              Boolean variable indicating if LOB
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Customer
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Boolean bIsLOB
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Get_Attribute DF_FIELD_IS_LOB of Customer.File_Number 6 to bIsLOB
81401>>>>>>>>>>>>>Define DF_FIELD_IS_LOB                              For 706
81401>>>>>>>>>>>>>Define DF_FIELD_DEFAULT_FUNCTION                    For 707
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//Currently Unsupported Attribute
81401>>>>>>>>>>>>>Define DF_FIELD_HANDLE_AS_LOB                       For 708
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//TODO
81401>>>>>>>>>>>>>Define DF_FIELD_PARTIAL_OVERLAP                     For 710
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_NUMBER_SQL_RELATIONS
81401>>>>>>>>>>>>>/// @Description This attribute is used to get the number of foreign keys
81401>>>>>>>>>>>>>/// for a given table on the SQL backend. Foreign keys are used to specify
81401>>>>>>>>>>>>>/// relationships between tables. Since this attribute is ReadOnly, it cannot
81401>>>>>>>>>>>>>/// be used to set the number of foreign keys in a table.  Note that this
81401>>>>>>>>>>>>>/// attribute returns only the number of foreign keys, no other information
81401>>>>>>>>>>>>>/// is provided with this attribute.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// This is a ReadOnly attribute
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-13 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>/// @INTOPT
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_NUMBER_SQL_RELATIONS of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Integer variable showing number of relationships
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Customer
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Integer iRelations
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Get_Attribute DF_FILE_NUMBER_SQL_RELATIONS of Customer.File_Number to iRelations
81401>>>>>>>>>>>>>Define DF_FILE_NUMBER_SQL_RELATIONS                 For 626
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//TODO
81401>>>>>>>>>>>>>Define DF_SQL_RELATION_COLUMN                       For 716
81401>>>>>>>>>>>>>Define DF_SQL_RELATION_RELATED_SCHEMA               For 717
81401>>>>>>>>>>>>>Define DF_SQL_RELATION_RELATED_TABLE                For 719
81401>>>>>>>>>>>>>Define DF_SQL_RELATION_RELATED_COLUMN               For 721
81401>>>>>>>>>>>>>Define DF_SQL_RELATION_NAME                         For 723
81401>>>>>>>>>>>>>Define DF_SQL_RELATION_STATUS                       For 724
81401>>>>>>>>>>>>>Define DF_SQL_RELATION_DELETE_REF_ACTION            For 726
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//Currently Unsupported Attribute
81401>>>>>>>>>>>>>Define DF_FIELD_OVERLAP_START                       For 728
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//Currently Unsupported Attribute
81401>>>>>>>>>>>>>Define DF_FIELD_OVERLAP_END                         For 730
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//Currently Unsupported Attribute
81401>>>>>>>>>>>>>Define DF_FIELD_OVERLAP_OFFSET_START                For 732
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//Currently Unsupported Attribute
81401>>>>>>>>>>>>>Define DF_FIELD_OVERLAP_OFFSET_END                  For 734
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_RECNUM_TABLE
81401>>>>>>>>>>>>>/// @Description Dataflex's embedded database, by default, uses a Recnum column
81401>>>>>>>>>>>>>/// as the unique identifier for a table instead of a primary key. A table can
81401>>>>>>>>>>>>>/// easily be changed to use another column though and this attribute gets or
81401>>>>>>>>>>>>>/// sets whether the Recnum is being used for a table. Getting the value of this
81401>>>>>>>>>>>>>/// attribute can be done at any time for any driver. The setting of this attribute,
81401>>>>>>>>>>>>>/// however, can only be done in certain situations. Only if an alternative primary
81401>>>>>>>>>>>>>/// key is set up already can this attribute be set to false and only during a
81401>>>>>>>>>>>>>/// Structure_Start. Also, the attribute can only be turned off (set to false),
81401>>>>>>>>>>>>>/// it can not be turned back on (set to True).
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Note: In Postgres, this attribute is a ReadOnly attribute and can not be set.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public (PGFlex ReadOnly)
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-12 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See                 DF_FILE_RECNUM_NAME DF_FILE_PRIMARY_INDEX
81401>>>>>>>>>>>>>/// @INTOPT
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_RECNUM_TABLE of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_RECNUM_TABLE of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Boolean variable indicating if recnum is used
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Customer
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Boolean bRecnum
81401>>>>>>>>>>>>>/// Handle hFile
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Structure_Start hFile
81401>>>>>>>>>>>>>///     Set_Attribute DF_FILE_RECNUM_TABLE of Customer.File_Number to False
81401>>>>>>>>>>>>>///     Get_Attribute DF_FILE_RECNUM_TABLE of Customer.File_Number to bRecnum
81401>>>>>>>>>>>>>/// Structure_End hFile
81401>>>>>>>>>>>>>Define DF_FILE_RECNUM_TABLE                         For 1401
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_PRIMARY_INDEX
81401>>>>>>>>>>>>>/// @Description This attribute gets or sets the index which is used as the
81401>>>>>>>>>>>>>/// primary key for a table. The variable used for this attribute is an integer
81401>>>>>>>>>>>>>/// containing the numbered index used. Getting the value of this attribute can
81401>>>>>>>>>>>>>/// be done at any time, whereas setting can only be done at table creation or
81401>>>>>>>>>>>>>/// during a Structure_Start. If a RECNUM is used as the unique identifier then
81401>>>>>>>>>>>>>/// 0 is returned.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Note: In Postgres this attribute is ReadOnly, so it can only be used to get
81401>>>>>>>>>>>>>/// the index used as the primary key.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public (PGFlex ReadOnly)
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-12 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See                 DF_FILE_RECNUM_NAME
81401>>>>>>>>>>>>>/// @INTOPT
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_PRIMARY_INDEX of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_PRIMARY_INDEX of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Boolean variable indicating if a primary key is used
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Customer
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Boolean bPrimary
81401>>>>>>>>>>>>>/// Handle hFile
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Structure_Start hFile
81401>>>>>>>>>>>>>///     Set_Attribute DF_FILE_PRIMARY_INDEX of Customer.File_Number to False
81401>>>>>>>>>>>>>///     Get_Attribute DF_FILE_PRIMARY_INDEX of Customer.File_Number to bPrimary
81401>>>>>>>>>>>>>/// Structure_End hFile
81401>>>>>>>>>>>>>Define DF_FILE_PRIMARY_INDEX                        For 1402
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_RECNUM_NAME
81401>>>>>>>>>>>>>/// @Description This attribute is used to get the name of the Recnum field
81401>>>>>>>>>>>>>/// in the table, if one exists. It is a ReadOnly attribute so it can only
81401>>>>>>>>>>>>>/// be used in getting the name of the recnum field to a string variable.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-12 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See                 DF_FILE_RECNUM_TABLE
81401>>>>>>>>>>>>>/// @INTOPT
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_RECNUM_NAME of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              String name of recnum field
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Customer
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// String sRecnum
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Get_Attribute DF_FILE_RECNUM_NAME of Customer.File_Number to sRecnum
81401>>>>>>>>>>>>>Define DF_FILE_RECNUM_NAME                          For 1403
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>Define DF_FETCH_ALL                                 For -1
81401>>>>>>>>>>>>>Define DF_FETCH_TRUE                                For "TRUE"
81401>>>>>>>>>>>>>Define DF_FETCH_FALSE                               For "FALSE"
81401>>>>>>>>>>>>>Define DF_BIND_ALL_COLUMNS                          For -1
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// SQLFlex Lock Type
81401>>>>>>>>>>>>>Define DF_LOCK_TYPE_PAGE                            For 3
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// Extended Callback Types
81401>>>>>>>>>>>>>Define DF_MESSAGE_ERROR                             For 9
81401>>>>>>>>>>>>>Define DF_MESSAGE_PROGRESS_STATUS                   For 20
81401>>>>>>>>>>>>>Define DF_MESSAGE_PROGRESS_CONTINUE                 For 21
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//Drivers
81401>>>>>>>>>>>>>Define ORAFLEX                                      For "ORA_DRV"
81401>>>>>>>>>>>>>Define SQLFLEX                                      For "SQL_DRV"
81401>>>>>>>>>>>>>Define MDSDB2                                       For "MDS_DB2"
81401>>>>>>>>>>>>>Define MDSPgSQL                                     For "MDSPGSQL"
81401>>>>>>>>>>>>>Define PgFlex                                       For "MDSPGSQL"
81401>>>>>>>>>>>>>Define MDSMySQL                                     For "MDSMYSQL"
81401>>>>>>>>>>>>>Define MySQLFlex                                    For "MDSMYSQL"
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// Delimiter for SQL ID objects
81401>>>>>>>>>>>>>Define DB2_ID_DELIM                                 For '"'
81401>>>>>>>>>>>>>Define MYSQL_ID_DELIM                               For "`"
81401>>>>>>>>>>>>>Define ORACLE_ID_DELIM                              For '"'
81401>>>>>>>>>>>>>Define PGSQL_ID_DELIM                               For '"'
81401>>>>>>>>>>>>>Define SQLSERVER_ID_DELIM                           For '"'
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// dfStructureEnd Option bits
81401>>>>>>>>>>>>>Define DF_STRUCTEND_OPT_INDEX_ONLY                  For 16    // Internal Use Only
81401>>>>>>>>>>>>>Define DF_STRUCTEND_OPT_FORCE_INVK                  For 32
81401>>>>>>>>>>>>>Define DF_STRUCTEND_OPT_OLD_INVK_NAME               For 64
81401>>>>>>>>>>>>>Define DF_STRUCTEND_OPT_FORCE_NOT_NULL              For 128
81401>>>>>>>>>>>>>Define DF_STRUCTEND_OPT_CREATE_ROWID_TABLE          For 256
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//Additional Data Types
81401>>>>>>>>>>>>>Define DF_DATETIME                                  For 7
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//Call_Driver Functions
81401>>>>>>>>>>>>>Define CALLDRV_LICENSE_ENVIRONMENT_SET              For 0
81401>>>>>>>>>>>>>Define CALLDRV_ORA_CURRENT_SQL_SERVER               For 6
81401>>>>>>>>>>>>>Define CALLDRV_SQL_ERROR_MESSAGE                    For 14
81401>>>>>>>>>>>>>Define CALLDRV_CURRENT_SQL_SERVER                   for 19
81401>>>>>>>>>>>>>Define CALLDRV_SQL_NEXT_RESULTSET                                       for 22
81401>>>>>>>>>>>>>Define CALLDRV_BIND_PARAMETER                       for 23
81401>>>>>>>>>>>>>Define CALLDRV_SQL_MAX_CURSORS                      For 26
81401>>>>>>>>>>>>>Define CALLDRV_SQLLOADER_FIELDS_TERM                For 30
81401>>>>>>>>>>>>>Define CALLDRV_CREATE_TABLE_FROM_DAT                For 30
81401>>>>>>>>>>>>>Define CALLDRV_SQLLOADER_DECIMAL_SEP                For 31
81401>>>>>>>>>>>>>Define CALLDRV_CONVERT_DAT_FILE                     For 32
81401>>>>>>>>>>>>>Define CALLDRV_SQLFLEX_MAX_CURSORS                  For 37
81401>>>>>>>>>>>>>Define CALLDRV_NATIVE_OPTIMIZATION                  For 38
81401>>>>>>>>>>>>>Define CALLDRV_GET_RETURNED_COLUMNS                 For 39
81401>>>>>>>>>>>>>Define CALLDRV_GET_RETURNED_ROWS                    For 40
81401>>>>>>>>>>>>>Define CALLDRV_GET_COLUMN_ATTRIBUTE                 For 41
81401>>>>>>>>>>>>>Define CALLDRV_START_TXTGEN_AFTER_RECNUM            For 42
81401>>>>>>>>>>>>>Define CALLDRV_FINISH_TXTGEN_AFTER_RECNUM           For 43
81401>>>>>>>>>>>>>Define CALLDRV_SET_ISOLATION_LEVEL                  For 44
81401>>>>>>>>>>>>>Define CALLDRV_GET_SERVER_CFG                       For 45
81401>>>>>>>>>>>>>Define CALLDRV_SET_SQL_LOCK_TIMEOUT                 For 46
81401>>>>>>>>>>>>>Define CALLDRV_GET_SQL_LOCK_TIMEOUT                 For 47
81401>>>>>>>>>>>>>Define CALLDRV_GET_RESULTS                          For 48
81401>>>>>>>>>>>>>Define CALLDRV_GET_MORE_RESULTS                     For 49
81401>>>>>>>>>>>>>Define CALLDRV_GET_CURRENT_USER_NAME                For 50
81401>>>>>>>>>>>>>Define CALLDRV_OPEN_EMBEDDED_CURSOR                 For 51
81401>>>>>>>>>>>>>Define CALLDRV_CLOSE_EMBEDDED_CURSOR                For 52
81401>>>>>>>>>>>>>Define CALLDRV_SET_CURRENT_EMBEDDED_CURSOR          For 53
81401>>>>>>>>>>>>>Define CALLDRV_GET_CURRENT_EMBEDDED_CURSOR          For 54
81401>>>>>>>>>>>>>Define CALLDRV_SET_MAX_EMBEDDED_CURSOR              For 55
81401>>>>>>>>>>>>>Define CALLDRV_GET_MAX_EMBEDDED_CURSOR              For 56
81401>>>>>>>>>>>>>Define CALLDRV_SQL_TRANSACTION                      For 57
81401>>>>>>>>>>>>>Define CALLDRV_LOCAL_TD_PATH                        For 58
81401>>>>>>>>>>>>>Define CALLDRV_CREATE_DB                            For 59
81401>>>>>>>>>>>>>Define CALLDRV_ESCAPE_STRING                        For 60
81401>>>>>>>>>>>>>Define CALLDRV_SET_PROC_ATTRIBUTE_TYPE              For 61
81401>>>>>>>>>>>>>Define CALLDRV_SQL_REFRESH_CACHE                    For 62
81401>>>>>>>>>>>>>Define CALLDRV_GET_SQL_STMT                         For 63
81401>>>>>>>>>>>>>Define CALLDRV_DIRECT_PATH_LOAD                     For 64
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>Define CALLDRV_READ_LOB                             For 65
81401>>>>>>>>>>>>>Define CALLDRV_WRITE_LOB                            For 66
81401>>>>>>>>>>>>>Define CALLDRV_APPEND_LOB                           For 67
81401>>>>>>>>>>>>>Define CALLDRV_LENGTH_LOB                           For 68
81401>>>>>>>>>>>>>Define CALLDRV_LOADFROMFILE_LOB                     For 69
81401>>>>>>>>>>>>>Define CALLDRV_ERASE_LOB                            For 70
81401>>>>>>>>>>>>>Define CALLDRV_TRUNCATE_LOB                         For 71
81401>>>>>>>>>>>>>Define CALLDRV_INITIALIZE_SEQUENCE                  For 72
81401>>>>>>>>>>>>>Define CALLDRV_CLIENT_CFG                           For 73
81401>>>>>>>>>>>>>Define CALLDRV_END_SAVERECORD                       For 74
81401>>>>>>>>>>>>>Define CALLDRV_ENABLE_RECONNECT                     For 75
81401>>>>>>>>>>>>>Define CALLDRV_ENUMERATE_SERVER                     For 76
81401>>>>>>>>>>>>>Define CALLDRV_USE_ROWCOUNT_IN_TRANSACTIONS         For 77
81401>>>>>>>>>>>>>Define CALLDRV_USE_DFLEX_DATE_FORMAT                For 78
81401>>>>>>>>>>>>>Define CALLDRV_FORCE_FIELDS_NOT_NULL                For 79
81401>>>>>>>>>>>>>Define CALLDRV_ORA_CREATE_TABLE_FROM_DAT            For 80
81401>>>>>>>>>>>>>Define CALLDRV_MAX_DATA_SIZE                        For 81
81401>>>>>>>>>>>>>Define CALLDRV_CHUNK_SIZE                           For 82
81401>>>>>>>>>>>>>Define CALLDRV_GET_DATA_CHUNK                       For 83
81401>>>>>>>>>>>>>Define CALLDRV_MIRROR_SERVER                        For 84
81401>>>>>>>>>>>>>Define CALLDRV_COPY_DATA                            For 85
81401>>>>>>>>>>>>>Define CALLDRV_SET_SQL_CURSOR_TYPE                  For 86
81401>>>>>>>>>>>>>Define CALLDRV_ICF                                  For 87
81401>>>>>>>>>>>>>Define CALLDRV_CLEAR_INT_CACHE                      For 88
81401>>>>>>>>>>>>>Define CALLDRV_GET_CURRENT_USER_PASSWORD            For 89
81401>>>>>>>>>>>>>Define CALLDRV_FORCE_FIELDS_NULL                    For 90
81401>>>>>>>>>>>>>Define CALLDRV_TRANSACTIONS_ALLOWED                 For 91
81401>>>>>>>>>>>>>Define CALLDRV_SQL_ERROR_MESSAGE2                   For 92
81401>>>>>>>>>>>>>Define CALLDRV_PGSQL_NAME_SPACE                     For 93
81401>>>>>>>>>>>>>Define CALLDRV_EMBEDDED_SQL_TYPE                    For 94
81401>>>>>>>>>>>>>Define CALLDRV_CREATE_INVK_FUNCTIONS                For 95
81401>>>>>>>>>>>>>Define CALLDRV_DEFAULT_FILE_CASING                  For 96
81401>>>>>>>>>>>>>Define CALLDRV_GLOBAL_SETTING                       For 97
81401>>>>>>>>>>>>>Define CALLDRV_RESTRUCTURE_SCRIPT                   For 98
81401>>>>>>>>>>>>>Define CALLDRV_CURRENT_SQL_SERVER_CONNECTION        For 99
81401>>>>>>>>>>>>>Define CALLDRV_100                                  For 100
81401>>>>>>>>>>>>>Define CALLDRV_FILE_STRUCT_DYNAMIC_ONLINE           For 101
81401>>>>>>>>>>>>>Define CALLDRV_SET_FIXED_FILE_RECORDS_USED          For 102
81401>>>>>>>>>>>>>Define CALLDRV_GET_FIXED_FILE_RECORDS_USED          For 103
81401>>>>>>>>>>>>>Define CALLDRV_LOB_EX_WRITE                         For 104
81401>>>>>>>>>>>>>Define CALLDRV_LOB_EX_APPEND                        For 105
81401>>>>>>>>>>>>>Define CALLDRV_LOB_EX_READ                          For 106
81401>>>>>>>>>>>>>Define CALLDRV_LOB_EX_GET_LENGTH                    For 107
81401>>>>>>>>>>>>>Define CALLDRV_LOB_EX_SET_LENGTH                    For 108
81401>>>>>>>>>>>>>Define CALLDRV_LOB_EX_TEST                          For 109
81401>>>>>>>>>>>>>Define CALLDRV_LOB_EX_SET_NULL                      For 110
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// License and environment settings
81401>>>>>>>>>>>>>Define CALLDRV_DRIVER_REVISION                      For 0
81401>>>>>>>>>>>>>Define CALLDRV_COMPANY_NAME                         For 1
81401>>>>>>>>>>>>>Define CALLDRV_SERIAL_NUMBER                        For 2
81401>>>>>>>>>>>>>Define CALLDRV_LICENSED_USERS                       For 3
81401>>>>>>>>>>>>>Define CALLDRV_MAJOR_REVISION                       For 4
81401>>>>>>>>>>>>>Define CALLDRV_VERSION_COMMENTS                     For 5
81401>>>>>>>>>>>>>Define CALLDRV_OLEDB_OEM_TRANSLATION                For 6
81401>>>>>>>>>>>>>Define CALLDRV_SET_DB_PORT                          For 7
81401>>>>>>>>>>>>>Define CALLDRV_GET_DB_PORT                          For 8
81401>>>>>>>>>>>>>Define CALLDRV_SET_DB_SOCKET                        For 9
81401>>>>>>>>>>>>>Define CALLDRV_GET_DB_SOCKET                        For 10
81401>>>>>>>>>>>>>Define CALLDRV_SET_AS_SYSDBA                        For 11
81401>>>>>>>>>>>>>Define CALLDRV_OEM_TRANSLATION_STATE                For 12
81401>>>>>>>>>>>>>Define CALLDRV_TIME_TO_LIC_EXPIRATION               For 13
81401>>>>>>>>>>>>>Define CALLDRV_LICENSE_EXPIRATION_WARN              For 14
81401>>>>>>>>>>>>>Define CALLDRV_LICENSE_PATH                         For 15
81401>>>>>>>>>>>>>Define CALLDRV_AUTO_NUMERIC_REMAPPING               For 16
81401>>>>>>>>>>>>>Define CALLDRV_FORCE_DATE_FORMAT_INIT               For 17
81401>>>>>>>>>>>>>Define CALLDRV_STATIC_TABLE_OPT                     For 18
81401>>>>>>>>>>>>>Define CALLDRV_MAX_OBJECT_NAME_LENGTH               For 19
81401>>>>>>>>>>>>>Define CALLDRV_USE_LAZY_OPEN_MODE                   For 20
81401>>>>>>>>>>>>>Define CALLDRV_SET_CUSTOM_OEM_TO_ANSI               For 21
81401>>>>>>>>>>>>>Define CALLDRV_GET_CUSTOM_OEM_TO_ANSI               For 22
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//CALLDRV_ENUMERATE_SERVER_OPTION
81401>>>>>>>>>>>>>Define CALLDRV_ENUMERATE_SERVER_COUNT               For 0
81401>>>>>>>>>>>>>Define CALLDRV_ENUMERATE_SERVER_SERVER              For 1
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//CALLDRV_DEFAULT_FILE_CASING
81401>>>>>>>>>>>>>Define FILE_CASING_UPPER                            For 0
81401>>>>>>>>>>>>>Define FILE_CASING_LOWER                            For 1
81401>>>>>>>>>>>>>Define FILE_CASING_KEEP                             For 2
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// CALLDRV_GLOBAL_SETTING
81401>>>>>>>>>>>>>Define GLOBAL_SETTING_TABLESPACE_SET                For 0
81401>>>>>>>>>>>>>Define GLOBAL_SETTING_TABLESPACE_GET                For 1
81401>>>>>>>>>>>>>Define GLOBAL_SETTING_INDEX_TABLESPACE_SET          For 2
81401>>>>>>>>>>>>>Define GLOBAL_SETTING_INDEX_TABLESPACE_GET          For 3
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// CALLDRV_RESTRUCTURE_SCRIPT
81401>>>>>>>>>>>>>Define CALLDRV_RESTRUCTURE_SCRIPT_ENABLE            For 0
81401>>>>>>>>>>>>>Define CALLDRV_RESTRUCTURE_SCRIPT_DISABLE           For 1
81401>>>>>>>>>>>>>Define CALLDRV_RESTRUCTURE_SCRIPT_GET_CHUNK_SQL     For 2
81401>>>>>>>>>>>>>Define CALLDRV_RESTRUCTURE_SCRIPT_GET_CHUNK_INT     For 3
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// DF_SQL_RELATION_STATUS attributes
81401>>>>>>>>>>>>>Define FOREIGN_KEY_NONE                             For -1
81401>>>>>>>>>>>>>Define FOREIGN_KEY_CREATE                           For  0
81401>>>>>>>>>>>>>Define FOREIGN_KEY_ENABLE                           For  1
81401>>>>>>>>>>>>>Define FOREIGN_KEY_DISABLE                          For  2
81401>>>>>>>>>>>>>Define FOREIGN_KEY_DROP                             For  3
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// DF_SQL_RELATION_DELETE_REF_ACTION attributes
81401>>>>>>>>>>>>>Define DELETE_REF_NONE                              For 0
81401>>>>>>>>>>>>>Define DELETE_REF_CASCADE                           For 1
81401>>>>>>>>>>>>>Define DELETE_REF_SET_NULL                          For 2
81401>>>>>>>>>>>>>Define DELETE_REF_SET_DEFAULT                       For 3
81401>>>>>>>>>>>>>Define DELETE_REF_RESTRICT                          For 4
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//Embedded SQL Cursor Types
81401>>>>>>>>>>>>>Define CALLDRV_ENUMERATE_CURSOR_TYPE_NONE           For 0
81401>>>>>>>>>>>>>Define CALLDRV_ENUMERATE_CURSOR_TYPE_CLIENT         For 1
81401>>>>>>>>>>>>>Define CALLDRV_ENUMERATE_CURSOR_TYPE_SERVER         For 2
81401>>>>>>>>>>>>>Define CALLDRV_ENUMERATE_CURSOR_TYPE_PARAMETERIZED  For 3
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//Driver Call Direction
81401>>>>>>>>>>>>>Define CALLDRV_VALUE_GET                            For 0
81401>>>>>>>>>>>>>Define CALLDRV_VALUE_SET                            For 1
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//Inverse Key types
81401>>>>>>>>>>>>>Define REGULAR_SEG                                  For -1
81401>>>>>>>>>>>>>Define INVK_CASE_SEG                                For 0
81401>>>>>>>>>>>>>Define INVK_DESC_SEG                                For 1
81401>>>>>>>>>>>>>Define INVK_DESC_AND_CASE_SEG                       For 2
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//DB2 Index Types
81401>>>>>>>>>>>>>Define REG_INDEX                                    For 0
81401>>>>>>>>>>>>>Define REV_INDEX                                    For 1
81401>>>>>>>>>>>>>Define CLUST_INDEX                                  For 2
81401>>>>>>>>>>>>>Define REV_CLUST_INDEX                              For 3
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//Oracle Procedure Arguments type
81401>>>>>>>>>>>>>Define IS_NONE                                      For 0
81401>>>>>>>>>>>>>Define IS_IN                                        For 1
81401>>>>>>>>>>>>>Define IS_OUT                                       For 2
81401>>>>>>>>>>>>>Define IS_IN_OUT                                    For 3
81401>>>>>>>>>>>>>Define IS_RSET                                      For 4
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// SQL_GET_COL Attributes
81401>>>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_SIZE                      For 1
81401>>>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_DECIMALS                  For 2
81401>>>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_LABEL                     For 3
81401>>>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_COLUMN_NAME               For 4
81401>>>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_TABLE_NAME                For 5
81401>>>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_SQLTYPE                   For 6
81401>>>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_NULLABLE                  For 7
81401>>>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_DFTYPE                    For 8
81401>>>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_DATA_LENGTH               For 9
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// MySQL Data Types
81401>>>>>>>>>>>>>Define eMySQL_DECIMAL                               For 0
81401>>>>>>>>>>>>>Define eMySQL_TINY                                  For 1
81401>>>>>>>>>>>>>Define eMySQL_SHORT                                 For 2
81401>>>>>>>>>>>>>Define eMySQL_LONG                                  For 3
81401>>>>>>>>>>>>>Define eMySQL_FLOAT                                 For 4
81401>>>>>>>>>>>>>Define eMySQL_DOUBLE                                For 5
81401>>>>>>>>>>>>>Define eMySQL_NULL                                  For 6
81401>>>>>>>>>>>>>Define eMySQL_TIMESTAMP                             For 7
81401>>>>>>>>>>>>>Define eMySQL_LONGLONG                              For 8
81401>>>>>>>>>>>>>Define eMySQL_INT24                                 For 9
81401>>>>>>>>>>>>>Define eMySQL_DATE                                  For 10
81401>>>>>>>>>>>>>Define eMySQL_TIME                                  For 11
81401>>>>>>>>>>>>>Define eMySQL_DATETIME                              For 12
81401>>>>>>>>>>>>>Define eMySQL_YEAR                                  For 13
81401>>>>>>>>>>>>>Define eMySQL_NEWDATE                               For 14
81401>>>>>>>>>>>>>Define eMySQL_BIT                                   For 16
81401>>>>>>>>>>>>>Define eMySQL_NEWDECIMAL                            For 246
81401>>>>>>>>>>>>>Define eMySQL_ENUM                                  For 247
81401>>>>>>>>>>>>>Define eMySQL_SET                                   For 248
81401>>>>>>>>>>>>>Define eMySQL_TINY_BLOB                             For 249
81401>>>>>>>>>>>>>Define eMySQL_MEDIUM_BLOB                           For 250
81401>>>>>>>>>>>>>Define eMySQL_LONG_BLOB                             For 251
81401>>>>>>>>>>>>>Define eMySQL_BLOB                                  For 252
81401>>>>>>>>>>>>>Define eMySQL_VAR_STRING                            For 253
81401>>>>>>>>>>>>>Define eMySQL_STRING                                For 254
81401>>>>>>>>>>>>>Define eMySQL_TINY_TEXT                             For -249
81401>>>>>>>>>>>>>Define eMySQL_MEDIUM_TEXT                           For -250
81401>>>>>>>>>>>>>Define eMySQL_LONG_TEXT                             For -251
81401>>>>>>>>>>>>>Define eMySQL_TEXT                                  For -252
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// Oracle Data Types
81401>>>>>>>>>>>>>Define eOracle_VARCHAR2                             For   1
81401>>>>>>>>>>>>>Define eOracle_NUMBER                               For   2
81401>>>>>>>>>>>>>Define eOracle_INT                                  For   3
81401>>>>>>>>>>>>>Define eOracle_FLOAT                                For   4
81401>>>>>>>>>>>>>Define eOracle_STRING                               For   5
81401>>>>>>>>>>>>>Define eOracle_LONG                                 For   8
81401>>>>>>>>>>>>>Define eOracle_ROWID                                For  11
81401>>>>>>>>>>>>>Define eOracle_DATE                                 For  12
81401>>>>>>>>>>>>>Define eOracle_RAW                                  For  23
81401>>>>>>>>>>>>>Define eOracle_LONGRAW                              For  24
81401>>>>>>>>>>>>>Define eOracle_CHAR                                 For  96
81401>>>>>>>>>>>>>Define eOracle_MSLABEL                              For 106
81401>>>>>>>>>>>>>Define eOracle_CLOB                                 For 112
81401>>>>>>>>>>>>>Define eOracle_BLOB                                 For 113
81401>>>>>>>>>>>>>Define eOracle_TIMESTAMP                            For 187
81401>>>>>>>>>>>>>Define eOracle_TIMESTAMPTZ                          For 188
81401>>>>>>>>>>>>>Define eOracle_INTERVALYM                           For 189
81401>>>>>>>>>>>>>Define eOracle_INTERVALDS                           For 190
81401>>>>>>>>>>>>>Define eOracle_TIMESTAMPLTZ                         For 232
81401>>>>>>>>>>>>>Define eOracle_NCHAR                                For 286
81401>>>>>>>>>>>>>Define eOracle_NVARCHAR2                            For 287
81401>>>>>>>>>>>>>Define eOracle_NCLOB                                For 288
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// PostgreSQL Data Types
81401>>>>>>>>>>>>>Define ePgSQL_CIRCLE                                For  718
81401>>>>>>>>>>>>>Define ePgSQL_MONEY                                 For  790
81401>>>>>>>>>>>>>Define ePgSQL_BOOL                                  For   16
81401>>>>>>>>>>>>>Define ePgSQL_BYTEA                                 For   17
81401>>>>>>>>>>>>>Define ePgSQL_CHAR                                  For   18
81401>>>>>>>>>>>>>Define ePgSQL_INT2                                  For   21
81401>>>>>>>>>>>>>Define ePgSQL_INT4                                  For   23
81401>>>>>>>>>>>>>Define ePgSQL_REGPROC                               For   24
81401>>>>>>>>>>>>>Define ePgSQL_REGPROCEDURE                          For 2202
81401>>>>>>>>>>>>>Define ePgSQL_REGOPER                               For 2203
81401>>>>>>>>>>>>>Define ePgSQL_REGOPERATOR                           For 2204
81401>>>>>>>>>>>>>Define ePgSQL_REGCLASS                              For 2205
81401>>>>>>>>>>>>>Define ePgSQL_REGTYPE                               For 2206
81401>>>>>>>>>>>>>Define ePgSQL_TEXT                                  For   25
81401>>>>>>>>>>>>>Define ePgSQL_CITEXT                                For  -25
81401>>>>>>>>>>>>>Define ePgSQL_OID                                   For   26
81401>>>>>>>>>>>>>Define ePgSQL_TID                                   For   27
81401>>>>>>>>>>>>>Define ePgSQL_XID                                   For   28
81401>>>>>>>>>>>>>Define ePgSQL_CID                                   For   29
81401>>>>>>>>>>>>>Define ePgSQL_XML                                   For  142
81401>>>>>>>>>>>>>Define ePgSQL_BPCHAR                                For 1042
81401>>>>>>>>>>>>>Define ePgSQL_VARCHAR                               For 1043
81401>>>>>>>>>>>>>Define ePgSQL_INT8                                  For   20
81401>>>>>>>>>>>>>Define ePgSQL_PATH                                  For  602
81401>>>>>>>>>>>>>Define ePgSQL_FLOAT4                                For  700
81401>>>>>>>>>>>>>Define ePgSQL_FLOAT8                                For  701
81401>>>>>>>>>>>>>Define ePgSQL_ABSTIME                               For  702
81401>>>>>>>>>>>>>Define ePgSQL_RELTIME                               For  703
81401>>>>>>>>>>>>>Define ePgSQL_TINTERVAL                             For  704
81401>>>>>>>>>>>>>Define ePgSQL_POINT                                 For  600
81401>>>>>>>>>>>>>Define ePgSQL_LINE                                  For  628
81401>>>>>>>>>>>>>Define ePgSQL_LSEG                                  For  601
81401>>>>>>>>>>>>>Define ePgSQL_BOX                                   For  603
81401>>>>>>>>>>>>>Define ePgSQL_POLYGON                               For  604
81401>>>>>>>>>>>>>Define ePgSQL_ACLITEM                               For 1033
81401>>>>>>>>>>>>>Define ePgSQL_MACADDR                               For  829
81401>>>>>>>>>>>>>Define ePgSQL_INET                                  For  869
81401>>>>>>>>>>>>>Define ePgSQL_CIDR                                  For  650
81401>>>>>>>>>>>>>Define ePgSQL_TIMESTAMP                             For 1114
81401>>>>>>>>>>>>>Define ePgSQL_DATE                                  For 1082
81401>>>>>>>>>>>>>Define ePgSQL_TIME                                  For 1083
81401>>>>>>>>>>>>>Define ePgSQL_TIMESTAMPTZ                           For 1184
81401>>>>>>>>>>>>>Define ePgSQL_INTERVAL                              For 1186
81401>>>>>>>>>>>>>Define ePgSQL_NUMERIC                               For 1700
81401>>>>>>>>>>>>>Define ePgSQL_TIMETZ                                For 1266
81401>>>>>>>>>>>>>Define ePgSQL_BIT                                   For 1560
81401>>>>>>>>>>>>>Define ePgSQL_VARBIT                                For 1562
81401>>>>>>>>>>>>>Define ePgSQL_UUID                                  For 2950
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// SQL Server Data Types
81401>>>>>>>>>>>>>Define eSQLServer_NA                                For    0
81401>>>>>>>>>>>>>Define eSQLServer_CHAR                              For    1
81401>>>>>>>>>>>>>Define eSQLServer_NUMERIC                           For    2
81401>>>>>>>>>>>>>Define eSQLServer_DECIMAL                           For    3
81401>>>>>>>>>>>>>Define eSQLServer_INT                               For    4
81401>>>>>>>>>>>>>Define eSQLServer_SMALLINT                          For    5
81401>>>>>>>>>>>>>Define eSQLServer_FLOAT                             For    6
81401>>>>>>>>>>>>>Define eSQLServer_REAL                              For    7
81401>>>>>>>>>>>>>Define eSQLServer_DOUBLE                            For    8
81401>>>>>>>>>>>>>Define eSQLServer_DATETIME                          For   11
81401>>>>>>>>>>>>>Define eSQLServer_VARCHAR                           For   12
81401>>>>>>>>>>>>>Define eSQLServer_DATE                              For   40
81401>>>>>>>>>>>>>Define eSQLServer_TIME                              For   41
81401>>>>>>>>>>>>>Define eSQLServer_DATETIME2                         For   42
81401>>>>>>>>>>>>>Define eSQLServer_DATETIMEOFFSET                    For   43
81401>>>>>>>>>>>>>Define eSQLServer_SMALLDATETIME                     For   58
81401>>>>>>>>>>>>>Define eSQLServer_TIMESTAMP                         For   93
81401>>>>>>>>>>>>>Define eSQLServer_HIERARCHYID                       For  128
81401>>>>>>>>>>>>>Define eSQLServer_GEOMETRY                          For  129
81401>>>>>>>>>>>>>Define eSQLServer_GEOGRAPHY                         For  130
81401>>>>>>>>>>>>>Define eSQLServer_TEXT                              For   -1
81401>>>>>>>>>>>>>Define eSQLServer_BINARY                            For   -2
81401>>>>>>>>>>>>>Define eSQLServer_VARBINARY                         For   -3
81401>>>>>>>>>>>>>Define eSQLServer_IMAGE                             For   -4
81401>>>>>>>>>>>>>Define eSQLServer_BIGINT                            For   -5
81401>>>>>>>>>>>>>Define eSQLServer_TINYINT                           For   -6
81401>>>>>>>>>>>>>Define eSQLServer_BIT                               For   -7
81401>>>>>>>>>>>>>Define eSQLServer_NCHAR                             For   -8
81401>>>>>>>>>>>>>Define eSQLServer_NVARCHAR                          For   -9
81401>>>>>>>>>>>>>Define eSQLServer_NTEXT                             For  -10
81401>>>>>>>>>>>>>Define eSQLServer_GUID                              For  -11
81401>>>>>>>>>>>>>Define eSQLServer_VARBINARYMAX                      For  -98
81401>>>>>>>>>>>>>Define eSQLServer_VARCHARMAX                        For  -99
81401>>>>>>>>>>>>>Define eSQLServer_NVARCHARMAX                       For -100
81401>>>>>>>>>>>>>Define eSQLServer_SQLVARIANT                        For -150
81401>>>>>>>>>>>>>Define eSQLServer_XML                               For -370
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>//Error Text
81401>>>>>>>>>>>>>//==========
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>//Define Self if needed
81401>>>>>>>>>>>>>//=====================
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>//Define varibles we need
81401>>>>>>>>>>>>>//=======================
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>    Define MertechInc_Variables_Defined
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>    Indicator MertechInc_bThereIsBinding
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>    Integer MertechInc_FileNumber      //Replaces _SAVEFILENUMBER# and FILENUMBER
81401>>>>>>>>>>>>>    Integer MertechInc_iArg            //Replaces _LLONG#
81401>>>>>>>>>>>>>    Integer MertechInc_iCallBack       //Replaces _CALLBACK#
81401>>>>>>>>>>>>>    Integer MertechInc_iCount          //General loop limit integer
81401>>>>>>>>>>>>>    Integer MertechInc_iDecSep         //Holds the decimal seperator
81401>>>>>>>>>>>>>    Integer MertechInc_iFunction       //Replaces _FID#    ??? check is this is need when tidy is complete
81401>>>>>>>>>>>>>    Integer MertechInc_iLoop           //General loop integer
81401>>>>>>>>>>>>>    Integer Mertech_iMySQLParam        //Replaces _ALL_PAR_POS#
81401>>>>>>>>>>>>>    Integer MertechInc_iParamCount     //Replaces _NPAR#
81401>>>>>>>>>>>>>    Integer MertechInc_iRet            //Replaces _RET#
81401>>>>>>>>>>>>>    Integer MertechInc_iSaveCount      //Replaces _NPOS#
81401>>>>>>>>>>>>>    Integer MertechInc_iWork           //General work integer
81401>>>>>>>>>>>>>    Integer MertechInc_iWork2
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>    String MertechInc_Blank            //Replaces _BLANK#
81401>>>>>>>>>>>>>    String MertechInc_DriverName       //Replaces _DRIVERNAME#
81401>>>>>>>>>>>>>    String MertechInc_sArg1 255        //Replaces _ARG1#
81401>>>>>>>>>>>>>    String MertechInc_sArg2 255        //Replaces _ARG2#
81401>>>>>>>>>>>>>    String MertechInc_sWork 255        //General work string
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>    String MertechInc_CurrentDriver    //Keep the current driver name
81401>>>>>>>>>>>>>    //Global string are created pre-filled with spaces. We need an empty string
81401>>>>>>>>>>>>>    Move "" to MertechInc_Blank
81402>>>>>>>>>>>>>    Move "" to MertechInc_CurrentDriver
81403>>>>>>>>>>>>>
81403>>>>>>>>>>>>>
81403>>>>>>>>>>>>>//=============================================================================
81403>>>>>>>>>>>>>//Use Obsolete Code
81403>>>>>>>>>>>>>//=================
81403>>>>>>>>>>>>>
81403>>>>>>>>>>>>>
81403>>>>>>>>>>>>>
81403>>>>>>>>>>>>>//=============================================================================
81403>>>>>>>>>>>>>//Comment Block Template
81403>>>>>>>>>>>>>//======================
81403>>>>>>>>>>>>>
81403>>>>>>>>>>>>>/// @Name {Name of the command for indexing} (used for documentation)
81403>>>>>>>>>>>>>/// @Description {Short Command Description} (used for documentation)
81403>>>>>>>>>>>>>///     The description can be multiple lines, and contain HTML tags.
81403>>>>>>>>>>>>>///     The other tokens will have HTML encoded so we can show stuff
81403>>>>>>>>>>>>>///     like <param1> properly. A blank line will automatically be
81403>>>>>>>>>>>>>///         translated into a paragraph break in the documentation, so
81403>>>>>>>>>>>>>///     no need for <br> or <p> tags.
81403>>>>>>>>>>>>>///
81403>>>>>>>>>>>>>/// @Assumptions {Assumptions made in order for the command to work}
81403>>>>>>>>>>>>>/// @Status {Obsolete, Internal, or Public} (used for documentation)
81403>>>>>>>>>>>>>/// @Drivers {DB2Flex, MySQLFlex, ORAFlex, PgFlex, SQLFlex or All} (used for documentation)
81403>>>>>>>>>>>>>/// @VersionNote {Date and author of the last revision}
81403>>>>>>>>>>>>>/// @See {list of related commands}
81403>>>>>>>>>>>>>///
81403>>>>>>>>>>>>>/// @Syntax {Syntax of use} (used for documentation)
81403>>>>>>>>>>>>>/// @Param {Each parameter with a brief description} (used for documentation)
81403>>>>>>>>>>>>>/// @DBMS {List of supported databases}
81403>>>>>>>>>>>>>/// @DataFlex {List of supported DataFlex versions}
81403>>>>>>>>>>>>>/// @Usage {Different uses command can have multiple syntaxes} (used for documentation)
81403>>>>>>>>>>>>>///
81403>>>>>>>>>>>>>/// @Example {An example of the command being used} (used for documentation)
81403>>>>>>>>>>>>>
81403>>>>>>>>>>>>>//=============================================================================
81403>>>>>>>>>>>>>/// @Name        DO_GETFILENUMBER_DRIVERNAME
81403>>>>>>>>>>>>>/// @Description Retrieves the current driver name and or the file number
81403>>>>>>>>>>>>>/// that will be used by the macro commands.
81403>>>>>>>>>>>>>///
81403>>>>>>>>>>>>>/// @Assumptions
81403>>>>>>>>>>>>>/// @Status      Internal Use Only
81403>>>>>>>>>>>>>/// @Drivers     All
81403>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-07-14 By Ian Smith
81403>>>>>>>>>>>>>/// @See
81403>>>>>>>>>>>>>
81403>>>>>>>>>>>>>//Most commands use DO_GETFILENUMBER_DRIVERNAME so this code was being duplicated
81403>>>>>>>>>>>>>//all the time. It has been moved to this method to remove that duplication.
81403>>>>>>>>>>>>>Procedure MertechInc_Get_Driver_name Global
81405>>>>>>>>>>>>>    //If we have a file number get its driver, else find first loaded Mertech driver
81405>>>>>>>>>>>>>    If MertechInc_FileNumber GT 0 ;        Get_Attribute DF_FILE_DRIVER of MertechInc_FileNumber to MertechInc_DriverName
81410>>>>>>>>>>>>>    Else Begin
81411>>>>>>>>>>>>>        If (MertechInc_CurrentDriver > "") Move MertechInc_CurrentDriver to MertechInc_DriverName
81414>>>>>>>>>>>>>        Else Begin
81415>>>>>>>>>>>>>            Get_Attribute DF_NUMBER_DRIVERS to MertechInc_iCount
81418>>>>>>>>>>>>>            For MertechInc_iLoop from 1 to MertechInc_iCount
81424>>>>>>>>>>>>>>
81424>>>>>>>>>>>>>                Get_Attribute DF_DRIVER_NAME of MertechInc_iLoop to MertechInc_DriverName
81427>>>>>>>>>>>>>                Move (UPPERCASE(MertechInc_DriverName)) to MertechInc_DriverName
81428>>>>>>>>>>>>>                If (MertechInc_DriverName EQ ORAFLEX  or MertechInc_DriverName EQ SQLFLEX or MertechInc_DriverName EQ MDSDB2 or ;                    MertechInc_DriverName EQ MDSPgSQL or MertechInc_DriverName EQ MDSMySQL) Move MertechInc_iCount to MertechInc_iLoop
81431>>>>>>>>>>>>>                Else Move "" to MertechInc_DriverName
81433>>>>>>>>>>>>>            Loop
81434>>>>>>>>>>>>>>
81434>>>>>>>>>>>>>        End
81434>>>>>>>>>>>>>>
81434>>>>>>>>>>>>>    End
81434>>>>>>>>>>>>>>
81434>>>>>>>>>>>>>
81434>>>>>>>>>>>>>    //Ensure that we return a valid Mertech driver.
81434>>>>>>>>>>>>>    If (MertechInc_DriverName NE ORAFLEX  and ;        MertechInc_DriverName NE SQLFLEX  and ;        MertechInc_DriverName NE MDSDB2   and ;        MertechInc_DriverName NE MDSPgSQL and ;        MertechInc_DriverName NE MDSMySQL     ) ;        Begin
81436>>>>>>>>>>>>>
81436>>>>>>>>>>>>>        //Report invalid driver
81436>>>>>>>>>>>>>//        Error 25100 ("Invalid Driver - file" * String(MertechInc_FileNumber))
81436>>>>>>>>>>>>>//        Error 25100 ("Mertech.inc - Not a Mertech driver (file number " * String(MertechInc_FileNumber) * ")")
81436>>>>>>>>>>>>>        Error 25100 ("Mertech.inc - Not a Mertech driver. File" * String(MertechInc_FileNumber) * "Driver" * Trim(MertechInc_DriverName) )
81437>>>>>>>>>>>>>>
81437>>>>>>>>>>>>>
81437>>>>>>>>>>>>>        //Set MertechInc_FileNumber to MertechInc_Invalid_Driver so that the commands can
81437>>>>>>>>>>>>>        //determine if the driver is valid. MertechInc_FileNumber is use instead of
81437>>>>>>>>>>>>>        //MertechInc_DriverName as integer conparisons are quicker than string conparisons
81437>>>>>>>>>>>>>        Move MertechInc_Invalid_Driver to MertechInc_FileNumber
81438>>>>>>>>>>>>>    End
81438>>>>>>>>>>>>>>
81438>>>>>>>>>>>>>End_Procedure
81439>>>>>>>>>>>>>
81439>>>>>>>>>>>>>//=============================================================================
81439>>>>>>>>>>>>>/// @Name        MertechInc_Pre_Size_String
81439>>>>>>>>>>>>>/// @Description Returns a string full of spaces.
81439>>>>>>>>>>>>>///
81439>>>>>>>>>>>>>/// @Assumptions
81439>>>>>>>>>>>>>/// @Status      Internal
81439>>>>>>>>>>>>>/// @Drivers     n/a
81439>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-12-02 By Gandalf Hernandez
81439>>>>>>>>>>>>>/// @See
81439>>>>>>>>>>>>>Function MertechInc_Pre_Size_String Global Integer iSize Returns String
81441>>>>>>>>>>>>>   String sWork
81441>>>>>>>>>>>>>   Integer iBlocks iRemainder
81441>>>>>>>>>>>>>
81441>>>>>>>>>>>>>   If (iSize <= 1) Begin
81443>>>>>>>>>>>>>      // marcelo 06/28/2000 implemented logic to avoid VDF 7 crashing problems
81443>>>>>>>>>>>>>          If FMAC_VERSION eq 7 Move 1000 to iSize
81446>>>>>>>>>>>>>          Else Move 16384 to iSize
81448>>>>>>>>>>>>>   End
81448>>>>>>>>>>>>>>
81448>>>>>>>>>>>>>
81448>>>>>>>>>>>>>   // Build the string in blocks of 32, to speed things up
81448>>>>>>>>>>>>>   // If the string is less than 32 bytes, just fill it up regularly
81448>>>>>>>>>>>>>   Move (iSize / 32) to iBlocks
81449>>>>>>>>>>>>>   Move (Mod(iSize, 32)) to iRemainder
81450>>>>>>>>>>>>>
81450>>>>>>>>>>>>>   If (iBlocks > 0) Begin
81452>>>>>>>>>>>>>      Move (Repeat("                                ", iBlocks)) to sWork
81453>>>>>>>>>>>>>      Move (Append (sWork, (Repeat(" ", iRemainder)))) to sWork
81454>>>>>>>>>>>>>   End
81454>>>>>>>>>>>>>>
81454>>>>>>>>>>>>>   Else Move (Repeat(" ", iSize)) to sWork
81456>>>>>>>>>>>>>
81456>>>>>>>>>>>>>   Function_Return sWork
81457>>>>>>>>>>>>>End_Function
81458>>>>>>>>>>>>>
81458>>>>>>>>>>>>>//=============================================================================
81458>>>>>>>>>>>>>/// @Name        MertechInc_Set_DecSep
81458>>>>>>>>>>>>>/// @Description Saves the current decimal separator and sets the decimal
81458>>>>>>>>>>>>>/// separator to '.'.
81458>>>>>>>>>>>>>///
81458>>>>>>>>>>>>>/// @Assumptions
81458>>>>>>>>>>>>>/// @Status      Internal
81458>>>>>>>>>>>>>/// @Drivers     n/a
81458>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-17 By Ian Smith
81458>>>>>>>>>>>>>Procedure MertechInc_Set_DecSep Global
81460>>>>>>>>>>>>>    Get_Attribute DF_DECIMAL_SEPARATOR to MertechInc_iDecSep
81463>>>>>>>>>>>>>    If MertechInc_iDecSep Ne 46 Set_Attribute DF_DECIMAL_SEPARATOR to 46 // (.) WILL BE DECIMAL SEPARATOR
81468>>>>>>>>>>>>>End_Procedure
81469>>>>>>>>>>>>>
81469>>>>>>>>>>>>>//=============================================================================
81469>>>>>>>>>>>>>/// @Name        MertechInc_Reset_DecSep
81469>>>>>>>>>>>>>/// @Description Sets the decimal separator to the saved value.
81469>>>>>>>>>>>>>///
81469>>>>>>>>>>>>>/// @Status      Internal
81469>>>>>>>>>>>>>/// @Drivers     n/a
81469>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-17 By Ian Smith
81469>>>>>>>>>>>>>///
81469>>>>>>>>>>>>>Procedure MertechInc_Reset_DecSep Global
81471>>>>>>>>>>>>>    If MertechInc_iDecSep Ne 46 Set_Attribute DF_DECIMAL_SEPARATOR to MertechInc_iDecSep
81476>>>>>>>>>>>>>End_Procedure
81477>>>>>>>>>>>>>
81477>>>>>>>>>>>>>//=============================================================================
81477>>>>>>>>>>>>>/// @Name        FETCH_FIELD
81477>>>>>>>>>>>>>/// @Description Selects or de-selects the fields to be fetched during the
81477>>>>>>>>>>>>>/// next FIND (query).
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// @Status      Internal
81477>>>>>>>>>>>>>/// @Drivers     All
81477>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-07-16 By Ian Smith
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// @Syntax FETCH_FIELD <FileNum> <FieldStart> THRU <FieldEnd> TO DF_FETCH_TRUE
81477>>>>>>>>>>>>>/// @Param  FileNum    is the File Number
81477>>>>>>>>>>>>>/// @Param  FieldStart is the Field Name or Number that will start the selection range
81477>>>>>>>>>>>>>/// @Param  FieldEnd   is the Field Name or Number that will finish the selection range
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// @Syntax FETCH_FIELD <FileNum> <Field1> TO DF_FETCH_TRUE
81477>>>>>>>>>>>>>/// @Param  FileNum  is the File Number
81477>>>>>>>>>>>>>/// @Param  Field1 Fields Name or Number to be selected
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>
81477>>>>>>>>>>>>>//=============================================================================
81477>>>>>>>>>>>>>/// @Name        SQL_TEXT_MESSAGE
81477>>>>>>>>>>>>>/// @Description Use this command to manually insert a string into a trace
81477>>>>>>>>>>>>>/// file. This can be useful for readability within the trace file to log
81477>>>>>>>>>>>>>/// what is actually happening at certain points.
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// @Assumptions The text string is less than 80 characters long.
81477>>>>>>>>>>>>>/// @Status      Public
81477>>>>>>>>>>>>>/// @Drivers     All
81477>>>>>>>>>>>>>/// @VersionNote Last Revised: 20013-08-19 by Aaron Gulack
81477>>>>>>>>>>>>>/// @See         ENABLE_TRACE_ON DISABLE_TRACE_ON
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// @Syntax SQL_TEXT_MESSAGE {variable}
81477>>>>>>>>>>>>>/// @Param  {variable}          The string to insert into the trace file.
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// @Example
81477>>>>>>>>>>>>>/// Login "localhost" "mds" "mertech" "ora_drv"
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// ENABLE_TRACE_ON to "c:\trace.txt" DEBUG_LEVEL
81477>>>>>>>>>>>>>/// open Customer
81477>>>>>>>>>>>>>/// SQL_TEXT_MESSAGE "The table has been opened"
81477>>>>>>>>>>>>>
81477>>>>>>>>>>>>>//=============================================================================
81477>>>>>>>>>>>>>/// @Name       SELECT_COLUMNS_FIND
81477>>>>>>>>>>>>>/// @Description This command is used to fetch only a certain number of fields
81477>>>>>>>>>>>>>/// while doing a "find". When specifying the field number to start from and
81477>>>>>>>>>>>>>/// field number to end on, the find will only fetch the given fields from the
81477>>>>>>>>>>>>>/// record. It is important to always use this command after first deselecting
81477>>>>>>>>>>>>>/// all columns i.e. setting RESET_FETCH_FIELDS to DF_FETCH_FALSE. Also, after
81477>>>>>>>>>>>>>/// using this command, all columns need to be reselected i.e. setting
81477>>>>>>>>>>>>>/// RESET_FETCH_FIELDS to DF_FETCH_TRUE. Note that fields used as a part the
81477>>>>>>>>>>>>>/// index segment associated with the find will always be fetched regardless.
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// @Assumptions
81477>>>>>>>>>>>>>/// @Status      Public
81477>>>>>>>>>>>>>/// @Drivers     All
81477>>>>>>>>>>>>>/// @VersionNote Last Revised: 20014-04-30 by Marcello Yo
81477>>>>>>>>>>>>>/// @See         RESET_FETCH_FIELDS DISABLE_SELECT_COLUMNS_ERRORS
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// @Syntax SELECT_COLUMNS_FIND {FileNumber} {fieldStart} THRU {fieldEnd}
81477>>>>>>>>>>>>>/// @Param  FileNumber          The number of the file
81477>>>>>>>>>>>>>/// @Param  fieldStart          The field number to start the fetch from
81477>>>>>>>>>>>>>/// @Param  FieldEnd            The field number to end the fetch at
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// @Example
81477>>>>>>>>>>>>>/// Open Customer
81477>>>>>>>>>>>>>/// RESET_FETCH_FIELDS  CUSTOMER DF_FETCH_FALSE
81477>>>>>>>>>>>>>/// SELECT_COLUMNS_FIND CUSTOMER CUSTOMER_NUMBER NAME
81477>>>>>>>>>>>>>/// DISABLE_SELECT_COLUMNS_ERRORS DISABLED
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// Clear Customer
81477>>>>>>>>>>>>>/// Repeat
81477>>>>>>>>>>>>>///    Find Gt Customer by Index.1
81477>>>>>>>>>>>>>///    If (Found) Showln Customer.Customer_Number '-' Customer.Name
81477>>>>>>>>>>>>>/// Until (Not(Found))
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// RESET_FETCH_FIELDS Customer DF_FETCH_TRUE
81477>>>>>>>>>>>>>
81477>>>>>>>>>>>>>
81477>>>>>>>>>>>>>//=============================================================================
81477>>>>>>>>>>>>>/// @Name        RESET_FETCH_FIELDS
81477>>>>>>>>>>>>>/// @Description This command is used to specify whether to retrieve all columns
81477>>>>>>>>>>>>>/// or no columns when performing a find. It is usually used with the command
81477>>>>>>>>>>>>>/// SELECT_COLUMNS_FIND to reset the column fetching. This command can either be
81477>>>>>>>>>>>>>/// set to DF_FETCH_TRUE, which will fetch all columns or set to DF_FETCH_FALSE,
81477>>>>>>>>>>>>>/// which will fetch no columns.
81477>>>>>>>>>>>>>/// @Assumptions
81477>>>>>>>>>>>>>/// @Status      Public
81477>>>>>>>>>>>>>/// @Drivers     All
81477>>>>>>>>>>>>>/// @VersionNote Last Revised: 2014-04-30 by Marcello Yo
81477>>>>>>>>>>>>>/// @See         SELECT_COLUMNS_FIND DISABLE_SELECT_COLUMNS_ERRORS
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// @Syntax RESET_FETCH_FIELDS {FileNumber} {DF_FETCH_TRUE/DF_FETCH_FALSE}
81477>>>>>>>>>>>>>/// @Param  FileNumber                  The number of the file
81477>>>>>>>>>>>>>/// @Param  DF_FETCH_TRUE               fetch all columns
81477>>>>>>>>>>>>>/// @Param  DF_FETCH_FALSE              fetch no columns
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// @Example
81477>>>>>>>>>>>>>/// Open Customer
81477>>>>>>>>>>>>>/// RESET_FETCH_FIELDS  CUSTOMER DF_FETCH_FALSE
81477>>>>>>>>>>>>>/// SELECT_COLUMNS_FIND CUSTOMER CUSTOMER_NUMBER NAME
81477>>>>>>>>>>>>>/// DISABLE_SELECT_COLUMNS_ERRORS DISABLED
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// Clear Customer
81477>>>>>>>>>>>>>/// Repeat
81477>>>>>>>>>>>>>///    Find Gt Customer by Index.1
81477>>>>>>>>>>>>>///    If (Found) Showln Customer.Customer_Number '-' Customer.Name
81477>>>>>>>>>>>>>/// Until (Not(Found))
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// RESET_FETCH_FIELDS Customer DF_FETCH_TRUE
81477>>>>>>>>>>>>>
81477>>>>>>>>>>>>>//=============================================================================
81477>>>>>>>>>>>>>/// @Name        SQL_FOR_ONEROW
81477>>>>>>>>>>>>>/// @Description This command will instruct the driver to fetch one row
81477>>>>>>>>>>>>>/// per query
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// @Assumptions
81477>>>>>>>>>>>>>/// @Status      Deprecated
81477>>>>>>>>>>>>>/// @Drivers     All
81477>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-19 by Aaron Gulack
81477>>>>>>>>>>>>>/// @See
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// @Syntax SQL_FOR_ONEROW {FileNumber}
81477>>>>>>>>>>>>>/// @Param  FileNumber          The number of the file
81477>>>>>>>>>>>>>/// @Example
81477>>>>>>>>>>>>>///     open Customer
81477>>>>>>>>>>>>>///     SQL_FOR_ONEROW Customer.File_Number
81477>>>>>>>>>>>>>///     Repeat
81477>>>>>>>>>>>>>///             find gt Customer by Recnum
81477>>>>>>>>>>>>>///         If (Found) Begin
81477>>>>>>>>>>>>>///             showln "Sales name is " Customer.FirstName
81477>>>>>>>>>>>>>///         end
81477>>>>>>>>>>>>>///     until (Customer.ID = 10)
81477>>>>>>>>>>>>>
81477>>>>>>>>>>>>>//=============================================================================
81477>>>>>>>>>>>>>/// @Name        SQL_REFRESH_CACHE
81477>>>>>>>>>>>>>/// @Description For optimization during record retrieval, a set number of
81477>>>>>>>>>>>>>/// records are stored in a local cache. This command forces a refresh, by
81477>>>>>>>>>>>>>/// making the next find retrieve the record from the database instead of
81477>>>>>>>>>>>>>/// the cache.
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// @Assumptions
81477>>>>>>>>>>>>>/// @Status      Public
81477>>>>>>>>>>>>>/// @Drivers     All
81477>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-19 by Aaron Gulack
81477>>>>>>>>>>>>>/// @See
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// @Syntax SQL_REFRESH_CACHE OF {FileNumber}
81477>>>>>>>>>>>>>/// @Param  FileNumber          The number of the file
81477>>>>>>>>>>>>>/// @Example
81477>>>>>>>>>>>>>/// Open Customer
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// Find gt Customer by Index.1
81477>>>>>>>>>>>>>/// While (Found) Begin
81477>>>>>>>>>>>>>///     showln "Customer name is " CUSTOMER.CUSTOMER
81477>>>>>>>>>>>>>/// Loop
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// SQL_REFRESH_CACHE of CUSTOMER
81477>>>>>>>>>>>>>
81477>>>>>>>>>>>>>//=============================================================================
81477>>>>>>>>>>>>>/// @Name        SQL_FOR_SET
81477>>>>>>>>>>>>>/// @Description Use this command during LT or GT finds to only fetch a set
81477>>>>>>>>>>>>>/// number of rows. An option is also available for this command to disable
81477>>>>>>>>>>>>>/// the local cash by passing NOCACHE at the end of the command call. Note
81477>>>>>>>>>>>>>/// that if the rowcount is set low, too many round-trips to the server may
81477>>>>>>>>>>>>>/// result, effecting performance significantly. Also, if the rowcount is set
81477>>>>>>>>>>>>>/// too high a large number of records can be pre-fetched and end up not being
81477>>>>>>>>>>>>>/// used by the application. Because of this, the default of 10 rows and a cache
81477>>>>>>>>>>>>>/// will be adequate for most situations.
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// @Assumptions
81477>>>>>>>>>>>>>/// @Status      Public
81477>>>>>>>>>>>>>/// @Drivers     All
81477>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
81477>>>>>>>>>>>>>/// @See
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// @Syntax SQL_FOR_SET {FileNumber} MAXROWS {variable} {CACHE/NOCACHE}
81477>>>>>>>>>>>>>/// @Param  FileNumber          The number of the file
81477>>>>>>>>>>>>>/// @Param  variable            The maximum number of rows to retrieve
81477>>>>>>>>>>>>>/// @Param  CACHE               fetched rows will be kept at the local cache
81477>>>>>>>>>>>>>/// @Param  NOCACHE             fetched rows will not be kept at the local cache
81477>>>>>>>>>>>>>/// @Example
81477>>>>>>>>>>>>>/// Open Customer
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// SQL_FOR_SET Customer MAXROWS 15 CACHE
81477>>>>>>>>>>>>>/// find gt Customer by Index.1
81477>>>>>>>>>>>>>
81477>>>>>>>>>>>>>//=============================================================================
81477>>>>>>>>>>>>>/// @Name        SQL_SET
81477>>>>>>>>>>>>>/// @Description Initializes and sets an initial statement for embedded
81477>>>>>>>>>>>>>/// sql execution.
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
81477>>>>>>>>>>>>>/// @Status      Deprecated
81477>>>>>>>>>>>>>/// @Drivers     All
81477>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
81477>>>>>>>>>>>>>/// @See         SQL_SET_STMT
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// @Syntax SQL_SET {FileNumber}
81477>>>>>>>>>>>>>/// @Param  FileNumber          The number of the file
81477>>>>>>>>>>>>>
81477>>>>>>>>>>>>>Procedure MertechInc_SQL_SET Global String sStatement
81479>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function 1 CALLBACK 0 PASSING MertechInc_Blank sStatement 0 RESULT MertechInc_iRet
81484>>>>>>>>>>>>>End_Procedure
81485>>>>>>>>>>>>>
81485>>>>>>>>>>>>>//=============================================================================
81485>>>>>>>>>>>>>/// @Name        SQL_APPEND
81485>>>>>>>>>>>>>/// @Description Appends a string value to the current embedded sql statement
81485>>>>>>>>>>>>>/// already set.
81485>>>>>>>>>>>>>///
81485>>>>>>>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
81485>>>>>>>>>>>>>/// @Status      Deprecated
81485>>>>>>>>>>>>>/// @Drivers     All
81485>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
81485>>>>>>>>>>>>>/// @See                 SQL_APPEND_STMT
81485>>>>>>>>>>>>>
81485>>>>>>>>>>>>>Procedure MertechInc_SQL_APPEND Global String sStatement
81487>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function 2 CALLBACK 0 PASSING MertechInc_Blank sStatement 0 RESULT MertechInc_iRet
81492>>>>>>>>>>>>>End_Procedure
81493>>>>>>>>>>>>>
81493>>>>>>>>>>>>>//=============================================================================
81493>>>>>>>>>>>>>/// @Name        SQL_EXECUTE
81493>>>>>>>>>>>>>/// @Description Executes the current embedded SQL statement set and commits
81493>>>>>>>>>>>>>/// finishing any pending transaction.
81493>>>>>>>>>>>>>///
81493>>>>>>>>>>>>>/// @Assumptions
81493>>>>>>>>>>>>>/// @Status      Deprecated
81493>>>>>>>>>>>>>/// @Drivers     All
81493>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
81493>>>>>>>>>>>>>/// @See                 SQL_EXECUTE_STMT
81493>>>>>>>>>>>>>
81493>>>>>>>>>>>>>//=============================================================================
81493>>>>>>>>>>>>>/// @Name        LOCK_TABLE
81493>>>>>>>>>>>>>/// @Description Locks a table. This is equivalent to locking a DAT file.
81493>>>>>>>>>>>>>///
81493>>>>>>>>>>>>>/// @Assumptions
81493>>>>>>>>>>>>>/// @Status      Deprecated
81493>>>>>>>>>>>>>/// @Drivers     DB2Flex, and ORAFlex 3.x
81493>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
81493>>>>>>>>>>>>>/// @See
81493>>>>>>>>>>>>>///
81493>>>>>>>>>>>>>/// @Syntax LOCK_TABLE {FileName} {FileName1} {FileName2} {FileName3}...
81493>>>>>>>>>>>>>/// @Param  FileName            The name of file to be locked. Can be more than one
81493>>>>>>>>>>>>>
81493>>>>>>>>>>>>>//=============================================================================
81493>>>>>>>>>>>>>/// @Name        SQL_CHECK_TABLE
81493>>>>>>>>>>>>>/// @Description Use this command to verify that a given table exists on the
81493>>>>>>>>>>>>>/// SQL backend. This command takes three arguments, a string containing the
81493>>>>>>>>>>>>>/// name of the database, a string containing the name of the user and finally
81493>>>>>>>>>>>>>/// a string containing the name of the table being checked. If the table exists,
81493>>>>>>>>>>>>>/// the program proceeds normally. If the table does not exist then the flag
81493>>>>>>>>>>>>>/// "finderr" is set to true. Note that in order to handle the error a check must
81493>>>>>>>>>>>>>/// be done on the "finderr" variable.
81493>>>>>>>>>>>>>///
81493>>>>>>>>>>>>>/// @Assumptions All three parameters are less than 256 characters long.
81493>>>>>>>>>>>>>/// @Status      Public
81493>>>>>>>>>>>>>/// @Drivers     All
81493>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
81493>>>>>>>>>>>>>/// @See
81493>>>>>>>>>>>>>///
81493>>>>>>>>>>>>>/// @Syntax SQL_CHECK_TABLE {database} {username} {table}
81493>>>>>>>>>>>>>/// @Param  database            Name of the database
81493>>>>>>>>>>>>>/// @Param  username            Name of the user
81493>>>>>>>>>>>>>/// @Param  table                       Name of the table being checked
81493>>>>>>>>>>>>>///
81493>>>>>>>>>>>>>/// @Example
81493>>>>>>>>>>>>>/// SQL_CHECK_TABLE "testDB" "user" "Customer"
81493>>>>>>>>>>>>>/// If (finderr) Begin
81493>>>>>>>>>>>>>///     Showln "This table does not exist"
81493>>>>>>>>>>>>>/// End
81493>>>>>>>>>>>>>
81493>>>>>>>>>>>>>//=============================================================================
81493>>>>>>>>>>>>>/// @Name        SET_SQL_CONSTRAINT
81493>>>>>>>>>>>>>/// @Description This command allows you to put an additional constraint on
81493>>>>>>>>>>>>>/// your finds, moving filtering to the SQL backend. Using this command can
81493>>>>>>>>>>>>>/// result in significantly improved performance, since the server network traffic
81493>>>>>>>>>>>>>/// reduced. Note that the SQL statement passed for this command is added onto
81493>>>>>>>>>>>>>/// the predefined Database SQL statement so treat it as such. Because of this,
81493>>>>>>>>>>>>>/// it will almost always begin with "AND" followed by the desired constraint.
81493>>>>>>>>>>>>>///
81493>>>>>>>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
81493>>>>>>>>>>>>>/// @Status      Public
81493>>>>>>>>>>>>>/// @Drivers     All
81493>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
81493>>>>>>>>>>>>>/// @See         SQL_CONSTRAINT GET_SQL_CONSTRAINT DF_FIELD_PROGRAMMATIC_DEFAULT
81493>>>>>>>>>>>>>///
81493>>>>>>>>>>>>>/// @Syntax SET_SQL_CONSTRAINT of {file} to {variable}
81493>>>>>>>>>>>>>/// @Param  file                        Name or Number of the file.
81493>>>>>>>>>>>>>/// @Param  variable            A SQL expression that constrains the data
81493>>>>>>>>>>>>>///
81493>>>>>>>>>>>>>/// @Example
81493>>>>>>>>>>>>>/// Open Customer
81493>>>>>>>>>>>>>///
81493>>>>>>>>>>>>>/// SET_SQL_CONSTRAINT of 1 to (SFormat('AND "%1"."%2" = ' + "'%3'", "Customer", "Status", "Active"))
81493>>>>>>>>>>>>>///
81493>>>>>>>>>>>>>/// For_All Customer by Index.1 do
81493>>>>>>>>>>>>>///     Showln Customer.FirstName
81493>>>>>>>>>>>>>/// End_For_All
81493>>>>>>>>>>>>>
81493>>>>>>>>>>>>>Procedure MertechInc_SET_SQL_CONSTRAINT Global Integer iFunction String sConstraint
81495>>>>>>>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function iFunction CALLBACK 0 PASSING sConstraint MertechInc_Blank 0 RESULT MertechInc_iRet
81500>>>>>>>>>>>>>End_Procedure
81501>>>>>>>>>>>>>
81501>>>>>>>>>>>>>Procedure MertechInc_SET_SQL_CONSTRAINT_PROGRAMMATIC Global Integer iFunction
81503>>>>>>>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function iFunction CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank 4 RESULT MertechInc_iRet
81508>>>>>>>>>>>>>End_Procedure
81509>>>>>>>>>>>>>
81509>>>>>>>>>>>>>//=============================================================================
81509>>>>>>>>>>>>>/// @Name        GET_SQL_CONSTRAINT
81509>>>>>>>>>>>>>/// @Description This command returns the current SQL constraint for the given
81509>>>>>>>>>>>>>/// table.  If there is no current constraint, then a blank string is returned.
81509>>>>>>>>>>>>>///
81509>>>>>>>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
81509>>>>>>>>>>>>>/// @Status      Public
81509>>>>>>>>>>>>>/// @Drivers     All
81509>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
81509>>>>>>>>>>>>>/// @See         SQL_CONSTRAINT SET_SQL_CONSTRAINT
81509>>>>>>>>>>>>>///
81509>>>>>>>>>>>>>/// @Syntax GET_SQL_CONSTRAINT of {File} to {variable}
81509>>>>>>>>>>>>>/// @Param  File                        Name or number of the file
81509>>>>>>>>>>>>>/// @Param  variable            The string containing the constraining SQL expression
81509>>>>>>>>>>>>>///
81509>>>>>>>>>>>>>/// @Example
81509>>>>>>>>>>>>>/// Open Customer
81509>>>>>>>>>>>>>///
81509>>>>>>>>>>>>>/// String sCon
81509>>>>>>>>>>>>>///
81509>>>>>>>>>>>>>/// SET_SQL_CONSTRAINT of Customer to (SFormat('AND "%1"."%2" = ' + "'%3'", "Customer", "Status", "Active"))
81509>>>>>>>>>>>>>/// GET_SQL_CONSTRAINT of Customer to sCon
81509>>>>>>>>>>>>>///
81509>>>>>>>>>>>>>/// For_All Customer by Index.1 do
81509>>>>>>>>>>>>>///     Showln Customer.FirstName
81509>>>>>>>>>>>>>///     Showln sCon
81509>>>>>>>>>>>>>/// End_For_All
81509>>>>>>>>>>>>>
81509>>>>>>>>>>>>>Function MertechInc_GET_SQL_CONSTRAINT Global Integer iFunction Returns String
81511>>>>>>>>>>>>>    String sConstraint
81511>>>>>>>>>>>>>    Get MertechInc_Pre_Size_String 0 to sConstraint
81512>>>>>>>>>>>>>
81512>>>>>>>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function iFunction CALLBACK 0 PASSING sConstraint MertechInc_Blank 3 RESULT MertechInc_iRet
81517>>>>>>>>>>>>>    Function_Return sConstraint
81518>>>>>>>>>>>>>End_Function
81519>>>>>>>>>>>>>
81519>>>>>>>>>>>>>//=============================================================================
81519>>>>>>>>>>>>>/// @Name        SQL_CONSTRAINT
81519>>>>>>>>>>>>>/// @Description This command is used to toggle on or off the current SQL
81519>>>>>>>>>>>>>/// constraint that is set for a table. To deactivate the current constraint,
81519>>>>>>>>>>>>>/// pass the constant DEACTIVATE to this command. to reactivate the constraint,
81519>>>>>>>>>>>>>/// pass ACTIVATE to this command.
81519>>>>>>>>>>>>>///
81519>>>>>>>>>>>>>/// @Status      Public
81519>>>>>>>>>>>>>/// @Drivers     All
81519>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
81519>>>>>>>>>>>>>/// @See         SET_SQL_CONSTRAINT GET_SQL_CONSTRAINT
81519>>>>>>>>>>>>>///
81519>>>>>>>>>>>>>/// @Syntax SQL_CONSTRAINT of {File} to {Activate|Deactivate}
81519>>>>>>>>>>>>>/// @Param  File                        Name or Number of the file
81519>>>>>>>>>>>>>/// @Param  Activate            Activates the constraint
81519>>>>>>>>>>>>>/// @Param  Deactivate          Deactivates the constraint
81519>>>>>>>>>>>>>///
81519>>>>>>>>>>>>>/// @Example
81519>>>>>>>>>>>>>/// Open Customer
81519>>>>>>>>>>>>>///
81519>>>>>>>>>>>>>/// SET_SQL_CONSTRAINT of Customer to (SFormat('AND "%1"."%2" = ' + "'%3'", "Customer", "FirstName", "Aaron"))
81519>>>>>>>>>>>>>/// SQL_CONSTRAINT of Customer to Deactivate
81519>>>>>>>>>>>>>///
81519>>>>>>>>>>>>>/// For_All Customer by Index.1 do
81519>>>>>>>>>>>>>///     Showln Customer.FirstName
81519>>>>>>>>>>>>>/// End_For_All
81519>>>>>>>>>>>>>
81519>>>>>>>>>>>>>//=============================================================================
81519>>>>>>>>>>>>>/// @Name        CREATE_TD_FILE
81519>>>>>>>>>>>>>/// @Description A .TD file is created when the attribute is set to True.
81519>>>>>>>>>>>>>///
81519>>>>>>>>>>>>>/// @Assumptions
81519>>>>>>>>>>>>>/// @Status      Deprecated
81519>>>>>>>>>>>>>/// @Drivers     All
81519>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
81519>>>>>>>>>>>>>/// @See
81519>>>>>>>>>>>>>///
81519>>>>>>>>>>>>>/// @Syntax CREATE_TD_FILE {variable}
81519>>>>>>>>>>>>>/// @Param  variable            True to create the .TD file, false doesn't create it.
81519>>>>>>>>>>>>>
81519>>>>>>>>>>>>>//=============================================================================
81519>>>>>>>>>>>>>/// @Name        OPEN_INT
81519>>>>>>>>>>>>>/// @Description This command is used to replace the OPEN command in DataFlex.
81519>>>>>>>>>>>>>/// It can be useful when accessing tables that are not in the current filelist.
81519>>>>>>>>>>>>>/// To access these tables, the INT and FD files must be in the directory. From
81519>>>>>>>>>>>>>/// there, all that is needed is to open the table using this command under an
81519>>>>>>>>>>>>>/// alias name. If the command is executed successfully then the table can be
81519>>>>>>>>>>>>>/// queried normally as if it were a standard table. Note that if the desired
81519>>>>>>>>>>>>>/// table is already in the filelist or doesn't have an INT file then this
81519>>>>>>>>>>>>>/// command will act as a normal open command.
81519>>>>>>>>>>>>>///
81519>>>>>>>>>>>>>/// @Assumptions
81519>>>>>>>>>>>>>/// @Status      Public
81519>>>>>>>>>>>>>/// @Drivers     All
81519>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-21 by Aaron Gulack
81519>>>>>>>>>>>>>/// @See
81519>>>>>>>>>>>>>///
81519>>>>>>>>>>>>>/// @Syntax OPEN_INT {variable} as {aliasName}
81519>>>>>>>>>>>>>/// @Param  variable            The name of the int file without the extension.
81519>>>>>>>>>>>>>/// @Param  aliasName           The alias name being used to query this table.
81519>>>>>>>>>>>>>/// @Example
81519>>>>>>>>>>>>>/// OPEN_INT "customer" as Customer
81519>>>>>>>>>>>>>///
81519>>>>>>>>>>>>>/// For_All Customer by Index.1 do
81519>>>>>>>>>>>>>///     Showln Customer.FirstName
81519>>>>>>>>>>>>>/// End_For_All
81519>>>>>>>>>>>>>
81519>>>>>>>>>>>>>//=============================================================================
81519>>>>>>>>>>>>>/// @Name        SET_OPEN_MODE
81519>>>>>>>>>>>>>/// @Description This command is used to enable an option known as "Lazy Open
81519>>>>>>>>>>>>>/// Mode". When turned on the table's metadata i.e. table, columns, index
81519>>>>>>>>>>>>>/// descriptions, is deferred until a field is accessed, even if a OPEN has
81519>>>>>>>>>>>>>/// already been done. This can significantly improve an application's initial
81519>>>>>>>>>>>>>/// performance, especially when a large number of files are opened when the
81519>>>>>>>>>>>>>/// program is launched. By default, tables are set to open normally, but by
81519>>>>>>>>>>>>>/// passing the constant LAZY_MODE to this command, it can be altered to use
81519>>>>>>>>>>>>>/// this mode. Note that when this mode is activated, it effects all tables
81519>>>>>>>>>>>>>/// that are opened. To deactivate this feature, pass the constant "DEFAULT"
81519>>>>>>>>>>>>>/// to this command at any time. This is the preferred method to activate or
81519>>>>>>>>>>>>>/// deactive this feature but it can also be set globally in the .INI file.
81519>>>>>>>>>>>>>///
81519>>>>>>>>>>>>>/// Default Value: DEFAULT (Off)
81519>>>>>>>>>>>>>///
81519>>>>>>>>>>>>>/// @Assumptions
81519>>>>>>>>>>>>>/// @Status      Public
81519>>>>>>>>>>>>>/// @Drivers     All
81519>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-21 by Aaron Gulack
81519>>>>>>>>>>>>>/// @See
81519>>>>>>>>>>>>>///
81519>>>>>>>>>>>>>/// @Syntax SET_OPEN_MODE to {DEFAULT/LAZY_MODE}
81519>>>>>>>>>>>>>/// @Param  DEFAULT                     Used to turn of the lazy mode feature.
81519>>>>>>>>>>>>>/// @Param  LAZY_MODE           Turns on the lazy mode feature
81519>>>>>>>>>>>>>///
81519>>>>>>>>>>>>>/// @Example
81519>>>>>>>>>>>>>/// SET_OPEN_MODE TO LAZY_MODE
81519>>>>>>>>>>>>>/// Open "customer.int" as Customer
81519>>>>>>>>>>>>>/// ...
81519>>>>>>>>>>>>>/// ...
81519>>>>>>>>>>>>>/// Find gt Customer by Index.1
81519>>>>>>>>>>>>>
81519>>>>>>>>>>>>>//=============================================================================
81519>>>>>>>>>>>>>/// @Name        SQL_SET_STMT
81519>>>>>>>>>>>>>/// @Description Use this command to set an SQL statement to be executed on the
81519>>>>>>>>>>>>>/// desired table. The string passed to this command must be a valid SQL
81519>>>>>>>>>>>>>/// expression and must be on a table that has already been opened. Note that
81519>>>>>>>>>>>>>/// when using this command, the SQL_PREPARE_STMT and SQL_EXECUTE_STMT must be
81519>>>>>>>>>>>>>/// used in addition to carry out the expression. The option to pass the file
81519>>>>>>>>>>>>>/// name as an extra parameter is used in cases where the data needs to be
81519>>>>>>>>>>>>>/// fetched directly into the record buffer of the specified file.
81519>>>>>>>>>>>>>///
81519>>>>>>>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
81519>>>>>>>>>>>>>/// @Status      Public
81519>>>>>>>>>>>>>/// @Drivers     All
81519>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-21 by Aaron Gulack
81519>>>>>>>>>>>>>/// @See                 SQL_APPEND_STMT SQL_PREPARE_STMT SQL_EXECUTE_STMT SQL_CANCEL_QUERY_STMT SQL_FETCH_NEXT_ROW SQL_BINDCOLUMNS_STMT
81519>>>>>>>>>>>>>///
81519>>>>>>>>>>>>>/// @Syntax SQL_SET_STMT [of {file}] to {variable}
81519>>>>>>>>>>>>>/// @Param file                         Name or number of the file (optional)
81519>>>>>>>>>>>>>/// @Param variable                     String containing the SQL statement
81519>>>>>>>>>>>>>///
81519>>>>>>>>>>>>>/// @Usage SQL_SET_STMT of Customer to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
81519>>>>>>>>>>>>>/// @Usage SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
81519>>>>>>>>>>>>>///
81519>>>>>>>>>>>>>/// @Example
81519>>>>>>>>>>>>>/// Open Customer
81519>>>>>>>>>>>>>///
81519>>>>>>>>>>>>>/// String sID sFirstName sLastName sDOB
81519>>>>>>>>>>>>>///
81519>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
81519>>>>>>>>>>>>>/// SQL_PREPARE_STMT
81519>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
81519>>>>>>>>>>>>>/// While (Found)
81519>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sFirstName sLastName sDOB
81519>>>>>>>>>>>>>///     Showln sID
81519>>>>>>>>>>>>>///     Showln sFirstName
81519>>>>>>>>>>>>>///     Showln sLastName
81519>>>>>>>>>>>>>///     Showln sDOB
81519>>>>>>>>>>>>>/// Loop
81519>>>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT
81519>>>>>>>>>>>>>
81519>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_STMT Global String sStatment
81521>>>>>>>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function 22 CALLBACK 0 PASSING MertechInc_Blank sStatment 0 RESULT MertechInc_iRet
81526>>>>>>>>>>>>>End_Procedure
81527>>>>>>>>>>>>>
81527>>>>>>>>>>>>>//=============================================================================
81527>>>>>>>>>>>>>/// @Name        SQL_APPEND_STMT
81527>>>>>>>>>>>>>/// @Description This command is used to append a command string to the
81527>>>>>>>>>>>>>/// command buffer initialized by SQL_SET_STMT. SQL_APPEND_STMT was added
81527>>>>>>>>>>>>>/// so that long SQL expressions could be broken into smaller strings and
81527>>>>>>>>>>>>>/// appended to a dynamic command buffer, which is then passed to the server.
81527>>>>>>>>>>>>>/// The SQL_APPEND_STMT will concatenate a string to the command buffer
81527>>>>>>>>>>>>>/// initialized by the SQL_SET_STMT command. SQL_APPEND_STMT can be called as
81527>>>>>>>>>>>>>/// many times as necessary to complete the SQL expression. Subsequently, the
81527>>>>>>>>>>>>>/// SQL_EXECUTE_STMT command executes the completed command.  The option to
81527>>>>>>>>>>>>>/// pass the file name as an extra parameter is used in cases where the data
81527>>>>>>>>>>>>>/// needs to be fetched directly into the record buffer of the specified file.
81527>>>>>>>>>>>>>///
81527>>>>>>>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
81527>>>>>>>>>>>>>/// @Status      Public
81527>>>>>>>>>>>>>/// @Drivers     All
81527>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-22 by Aaron Gulack
81527>>>>>>>>>>>>>/// @See                 SQL_SET_STMT SQL_PREPARE_STMT SQL_EXECUTE_STMT SQL_CANCEL_QUERY_STMT SQL_FETCH_NEXT_ROW SQL_BINDCOLUMNS_STMT
81527>>>>>>>>>>>>>///
81527>>>>>>>>>>>>>/// @Syntax SQL_APPEND_STMT [of {file}] to {variable}
81527>>>>>>>>>>>>>/// @Param file                         The name or number of the file (optional)
81527>>>>>>>>>>>>>/// @Param variable                     The string to be appended to the current SQL expression
81527>>>>>>>>>>>>>///
81527>>>>>>>>>>>>>/// @Usage SQL_APPEND_STMT to " CUSTOMER.PHONE_NUMBER, CUSTOMER.FAX_NUMBER"
81527>>>>>>>>>>>>>/// @Usage SQL_APPEND_STMT of Customer to " CUSTOMER.PHONE_NUMBER, CUSTOMER.FAX_NUMBER"
81527>>>>>>>>>>>>>///
81527>>>>>>>>>>>>>/// @Example
81527>>>>>>>>>>>>>/// Open Customer
81527>>>>>>>>>>>>>///
81527>>>>>>>>>>>>>/// String sID sFirstName sLastName sDOB
81527>>>>>>>>>>>>>///
81527>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
81527>>>>>>>>>>>>>/// SQL_PREPARE_STMT
81527>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
81527>>>>>>>>>>>>>/// While (Found)
81527>>>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW into sID sFirstName sLastName sDOB
81527>>>>>>>>>>>>>///     Showln sID
81527>>>>>>>>>>>>>///     Showln sFirstName
81527>>>>>>>>>>>>>///     Showln sLastName
81527>>>>>>>>>>>>>///     Showln sDOB
81527>>>>>>>>>>>>>/// Loop
81527>>>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT
81527>>>>>>>>>>>>>
81527>>>>>>>>>>>>>Procedure MertechInc_SQL_APPEND_STMT Global String sStatement
81529>>>>>>>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function 22 CALLBACK 0 PASSING MertechInc_Blank sStatement 1 RESULT MertechInc_iRet
81534>>>>>>>>>>>>>End_Procedure
81535>>>>>>>>>>>>>
81535>>>>>>>>>>>>>//=============================================================================
81535>>>>>>>>>>>>>/// @Name        APPEND_UPDATE_COLUMN
81535>>>>>>>>>>>>>/// @Description Append a given string to the existing SQL statement
81535>>>>>>>>>>>>>/// already set.
81535>>>>>>>>>>>>>///
81535>>>>>>>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method
81535>>>>>>>>>>>>>/// @Status      Internal
81535>>>>>>>>>>>>>/// @Drivers     All
81535>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
81535>>>>>>>>>>>>>/// @See
81535>>>>>>>>>>>>>///
81535>>>>>>>>>>>>>/// @Syntax APPEND_UPDCOL_STMT {variable} for {fileName}.{fieldName} {fields...}
81535>>>>>>>>>>>>>/// @Param variable                             SQL expression to be appended
81535>>>>>>>>>>>>>/// @Param fileName                             Name of the file
81535>>>>>>>>>>>>>/// @Param fieldName                    Name of the field
81535>>>>>>>>>>>>>/// @Param fields...                    Any additional fields, use the file.field format
81535>>>>>>>>>>>>>
81535>>>>>>>>>>>>>Procedure MertechInc_APPEND_UPDATE_COLUMN Global String sStatement
81537>>>>>>>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function 22 CALLBACK 0 PASSING MertechInc_Blank sStatement 1 RESULT MertechInc_iRet
81542>>>>>>>>>>>>>End_Procedure
81543>>>>>>>>>>>>>
81543>>>>>>>>>>>>>//=============================================================================
81543>>>>>>>>>>>>>/// @Name        SQL_APPEND_UPDCOL_STMT
81543>>>>>>>>>>>>>/// @Description Used to optimize the update process of columns being loaded
81543>>>>>>>>>>>>>/// with the same value.
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Assumptions
81543>>>>>>>>>>>>>/// @Status      Deprecated
81543>>>>>>>>>>>>>/// @Drivers     All
81543>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
81543>>>>>>>>>>>>>/// @See
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Syntax SQL_APPEND_UPDCOL_STMT [of {file}] Value {variable} for {fileName}.{fieldName} {fields...}
81543>>>>>>>>>>>>>/// @Param file                         The name or number of the file (optional)
81543>>>>>>>>>>>>>/// @Param variable                     The value being uploaded
81543>>>>>>>>>>>>>/// @Param fileName                     The name of the file
81543>>>>>>>>>>>>>/// @Param fieldName            The name of the field
81543>>>>>>>>>>>>>/// @Param fields...            Any additional fields, use the file.field format
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Example
81543>>>>>>>>>>>>>/// Open Customer
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// SQL_SET_STMT    of Customer to "UPDATE CUSTOMER SET"
81543>>>>>>>>>>>>>/// SQL_APPEND_STMT of Customer to " ASC11='x', ASC12='y', ASC13='z'"
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// SQL_APPEND_UPDCOL_STMT of Customer value 0 ;
81543>>>>>>>>>>>>>///     for Customer.ID Customer.Purchases Customer.Credit ;
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// SQL_APPEND_STMT of Customer to " WHERE RECNUM=1"
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// SQL_PREPARE_STMT of Customer
81543>>>>>>>>>>>>>/// SQL_EXECUTE_STMT of Customer
81543>>>>>>>>>>>>>
81543>>>>>>>>>>>>>//=============================================================================
81543>>>>>>>>>>>>>/// @Name        SQL_SET_CURSOR_TYPE
81543>>>>>>>>>>>>>/// @Description Specify the SQL cursor type to be used during the next
81543>>>>>>>>>>>>>/// embedded SQL statement execution.
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Assumptions
81543>>>>>>>>>>>>>/// @Status      Internal
81543>>>>>>>>>>>>>/// @Drivers     SQLFlex
81543>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
81543>>>>>>>>>>>>>/// @See
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Syntax SQL_SET_CURSOR_TYPE to {TYPE_NONE/TYPE_CLIENT/TYPE_SERVER}
81543>>>>>>>>>>>>>/// @Param TYPE_NONE                    the default cursor type should be used
81543>>>>>>>>>>>>>/// @Param TYPE_CLIENT                  a client side cursor should be used
81543>>>>>>>>>>>>>/// @Param TYPE_SERVER                  a server side cursor should be used
81543>>>>>>>>>>>>>
81543>>>>>>>>>>>>>//=============================================================================
81543>>>>>>>>>>>>>/// @Name        CLEAR_INT_CACHE
81543>>>>>>>>>>>>>/// @Description Clears all memory-cached INT info. This is used in the
81543>>>>>>>>>>>>>/// test framework to force a "reload" of int info which the framework
81543>>>>>>>>>>>>>/// modifies for its tests. This is a different cache than the TD files
81543>>>>>>>>>>>>>/// which are a file based cache of the structure for use at file open.
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Assumptions
81543>>>>>>>>>>>>>/// @Status      Internal
81543>>>>>>>>>>>>>/// @Drivers     All
81543>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
81543>>>>>>>>>>>>>/// @See
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Syntax CLEAR_INT_CACHE
81543>>>>>>>>>>>>>
81543>>>>>>>>>>>>>//=============================================================================
81543>>>>>>>>>>>>>/// @Name        CREATE_INVERSE_KEY_FUNCTIONS
81543>>>>>>>>>>>>>/// @Description Create SQL Functions to handle Inverse Key columns.
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Assumptions
81543>>>>>>>>>>>>>/// @Status      Internal
81543>>>>>>>>>>>>>/// @Drivers     All (v10.1 and above)
81543>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
81543>>>>>>>>>>>>>/// @See
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Syntax CREATE_INVERSE_KEY_FUNCTIONS
81543>>>>>>>>>>>>>
81543>>>>>>>>>>>>>//=============================================================================
81543>>>>>>>>>>>>>/// @Name        SQL_PREPARE_STMT
81543>>>>>>>>>>>>>/// @Description Prepares a statement and opens a cursor to be executed by
81543>>>>>>>>>>>>>/// SQL_EXECUTE_STMT. This command tells the server to parse the SQL statement
81543>>>>>>>>>>>>>/// created by the respective SQL_SET_STMT and all subsequent SQL_APPEND_STMT
81543>>>>>>>>>>>>>/// statements and to allocate cursor handles to be used to fetch the data.
81543>>>>>>>>>>>>>/// A cursor can be thought of as a pointer to a record set. The CURSOR_TYPE
81543>>>>>>>>>>>>>/// argument is only supported by SQLFlex and by default SQLFLex is using a
81543>>>>>>>>>>>>>/// TYPE_SERVER cursor type to all embedded SQL. TYPE_CLIENT should be used only
81543>>>>>>>>>>>>>/// for the statements that are querying LOB columns i.e. TEXT, NVARCHAR(MAX),
81543>>>>>>>>>>>>>/// VARCHAR(MAX), IMAGE, VARBINARY(MAX), XML. If the cursor type is
81543>>>>>>>>>>>>>/// TYPE_SERVER and a LOB type column is selected, MS SQL Server will not be
81543>>>>>>>>>>>>>/// able to get into a transaction, either explicitly or implicitly through a
81543>>>>>>>>>>>>>/// REREAD, LOCK, SAVERECORD, etc.
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Assumptions
81543>>>>>>>>>>>>>/// @Status      Public
81543>>>>>>>>>>>>>/// @Drivers     All
81543>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
81543>>>>>>>>>>>>>/// @See                 SQL_SET_STMT SQL_APPEND_STMT SQL_EXECUTE_STMT SQL_CANCEL_QUERY_STMT SQL_FETCH_NEXT_ROW SQL_BINDCOLUMNS_STMT
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Syntax SQL_PREPARE_STMT [of {file}] CURSOR_TYPE {TYPE_NONE/TYPE_CLIENT/TYPE_SERVER}
81543>>>>>>>>>>>>>/// @Param file                         The name or number of the file (optional)
81543>>>>>>>>>>>>>/// @Param CURSOR_TYPE          Used if the cursor type is being set, do not include otherwise
81543>>>>>>>>>>>>>/// @Param TYPE_NONE            Default cursor will be used
81543>>>>>>>>>>>>>/// @Param TYPE_CLIENT          A client side cursor should be used
81543>>>>>>>>>>>>>/// @Param TYPE_SERVER          A server side cursor should be used (Default)
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Usage SQL_PREPARE_STMT
81543>>>>>>>>>>>>>/// @Usage SQL_PREPARE_STMT of Customer
81543>>>>>>>>>>>>>/// @Usage SQL_PREPARE_STMT CURSOR_TYPE TYPE_SERVER
81543>>>>>>>>>>>>>/// @Usage SQL_PREPARE_STMT of Customer CURSOR_TYPE TYPE_CLIENT
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Example
81543>>>>>>>>>>>>>/// Open Customer
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// String sID sFirstName
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
81543>>>>>>>>>>>>>/// SQL_PREPARE_STMT
81543>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
81543>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sFirstName
81543>>>>>>>>>>>>>
81543>>>>>>>>>>>>>//=============================================================================
81543>>>>>>>>>>>>>/// @Name        SQL_BIND_COLUMN
81543>>>>>>>>>>>>>/// @Description Clears all cached INT info. This should be merged with
81543>>>>>>>>>>>>>/// SQL_BINDCOLUMNS_STMT, but has to remain as a separate command for
81543>>>>>>>>>>>>>/// compatibility.
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Assumptions
81543>>>>>>>>>>>>>/// @Status      Internal
81543>>>>>>>>>>>>>/// @Drivers     All
81543>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-26 by Aaron Gulack
81543>>>>>>>>>>>>>/// @See
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Syntax SQL_BIND_COLUMN FileNumber FieldNumber | DF_BIND_ALL_COLUMNS
81543>>>>>>>>>>>>>/// @Param FileNumber                   The number of the file
81543>>>>>>>>>>>>>/// @Param FieldNumber                  The number of the field
81543>>>>>>>>>>>>>
81543>>>>>>>>>>>>>//=============================================================================
81543>>>>>>>>>>>>>/// @Name        SQL_BINDCOLUMNS_STMT
81543>>>>>>>>>>>>>/// @Description This command is used to fetch the returned data of a
81543>>>>>>>>>>>>>/// specified SQL expression into the given field in the record buffer. By
81543>>>>>>>>>>>>>/// passing any number of fields to this command, the fetched record will then
81543>>>>>>>>>>>>>/// be put into the subsequent fields in the record buffer. The order of the
81543>>>>>>>>>>>>>/// fields must be the same as the order of the columns being retrieved from
81543>>>>>>>>>>>>>/// the SQL expression. SQL_FETCH_NEXT_ROW can then be called to take the data
81543>>>>>>>>>>>>>/// retrieved from the server and place it into the corresponding fields in the
81543>>>>>>>>>>>>>/// buffer. Instead of specifying each field, DF_BIND_ALL_COLUMNS can be passed,
81543>>>>>>>>>>>>>/// which will retrieve every column in the table.
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Assumptions
81543>>>>>>>>>>>>>/// @Status      Public
81543>>>>>>>>>>>>>/// @Drivers     All
81543>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-26 by Aaron Gulack
81543>>>>>>>>>>>>>/// @See                 SQL_SET_STMT SQL_APPEND_STMT SQL_PREPARE_STMT SQL_EXECUTE_STMT SQL_CANCEL_QUERY_STMT SQL_FETCH_NEXT_ROW
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Syntax SQL_BINDCOLUMNS_STMT of {file} to {field/DF_BIND_ALL_COLUMNS}
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Param file                 Name or number of the file
81543>>>>>>>>>>>>>/// @Param field                        Name or number of the field (can be multiple)
81543>>>>>>>>>>>>>/// @Param DF_BIND_ALL_COLUMNS  Used instead of the field to retrieve all columns in the file
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Example
81543>>>>>>>>>>>>>/// Open Customer
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
81543>>>>>>>>>>>>>/// SQL_PREPARE_STMT
81543>>>>>>>>>>>>>/// SQL_BINDCOLUMNS_STMT of Customer to DF_BIND_ALL_COLUMNS
81543>>>>>>>>>>>>>/// SQL_EXECUTE_STMT of Customer
81543>>>>>>>>>>>>>/// While (Found)
81543>>>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW of Customer
81543>>>>>>>>>>>>>///     Showln Customer.ID
81543>>>>>>>>>>>>>///     Showln Customer.FirstName
81543>>>>>>>>>>>>>///     Showln Customer.LastName
81543>>>>>>>>>>>>>///     Showln Customer.DOB
81543>>>>>>>>>>>>>/// Loop
81543>>>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT
81543>>>>>>>>>>>>>
81543>>>>>>>>>>>>>//=============================================================================
81543>>>>>>>>>>>>>/// @Name        SQL_EXECUTE_STMT
81543>>>>>>>>>>>>>/// @Description This command is used to execute the SQL expression created
81543>>>>>>>>>>>>>/// by the SQL_SET_STMT and any subsequent SQL_APPEND_STMT commands issued
81543>>>>>>>>>>>>>/// after a SQL_PREPARE_STMT. If the results will be sent to the record
81543>>>>>>>>>>>>>/// buffer directly, then the file must be specified. An optional parameter
81543>>>>>>>>>>>>>/// can also be passed, indicating the maximum number of rows to be sent to
81543>>>>>>>>>>>>>/// the local cache. This is done by adding the constant ROWCOUNT followed
81543>>>>>>>>>>>>>/// by the maximun number.
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Assumptions
81543>>>>>>>>>>>>>/// @Status      Public
81543>>>>>>>>>>>>>/// @Drivers     All
81543>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-26 by Aaron Gulack
81543>>>>>>>>>>>>>/// @See                 SQL_SET_STMT SQL_APPEND_STMT SQL_PREPARE_STMT SQL_CANCEL_QUERY_STMT SQL_FETCH_NEXT_ROW SQL_BINDCOLUMNS_STMT
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Syntax SQL_EXECUTE_STMT [of {file} ROWCOUNT {variable}]
81543>>>>>>>>>>>>>/// @Param file                         Name or number of the file (optional)
81543>>>>>>>>>>>>>/// @Param variable                     Maximum number of rows to send to the local cache (optional)
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Usage SQL_EXECUTE_STMT
81543>>>>>>>>>>>>>/// @Usage SQL_EXECUTE_STMT of Customer
81543>>>>>>>>>>>>>/// @Usage SQL_EXECUTE_STMT of Customer ROWCOUNT 10
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Example
81543>>>>>>>>>>>>>/// Open Customer
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
81543>>>>>>>>>>>>>/// SQL_PREPARE_STMT
81543>>>>>>>>>>>>>/// SQL_BINDCOLUMNS_STMT of Customer to DF_BIND_ALL_COLUMNS
81543>>>>>>>>>>>>>/// SQL_EXECUTE_STMT of Customer
81543>>>>>>>>>>>>>/// While (Found)
81543>>>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW of Customer
81543>>>>>>>>>>>>>///     Showln Customer.ID
81543>>>>>>>>>>>>>///     Showln Customer.FirstName
81543>>>>>>>>>>>>>///     Showln Customer.LastName
81543>>>>>>>>>>>>>///     Showln Customer.DOB
81543>>>>>>>>>>>>>/// Loop
81543>>>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT
81543>>>>>>>>>>>>>
81543>>>>>>>>>>>>>
81543>>>>>>>>>>>>>//This alias may be redundant. Is was only called from MertechInc_SQL_FUNCTION_EXECUTE
81543>>>>>>>>>>>>>//which has been recoded to directly call SQL_EXECUTE_STMT - I.S. 2009-09-19
81543>>>>>>>>>>>>>Procedure MertechInc_SQL_PROCEDURE_EXECUTE Global
81545>>>>>>>>>>>>>    SQL_EXECUTE_STMT
81560>>>>>>>>>>>>>End_Procedure
81561>>>>>>>>>>>>>
81561>>>>>>>>>>>>>//=============================================================================
81561>>>>>>>>>>>>>/// @Name        SQL_START_TRANSACTION_STMT
81561>>>>>>>>>>>>>/// @Description Transactions in SQL are used to maintain atomicity within
81561>>>>>>>>>>>>>/// an process. If one procedure in the transaction fails, then they all
81561>>>>>>>>>>>>>/// will fail. This command is used to start an SQL transaction. Inside of
81561>>>>>>>>>>>>>/// a transaction, there can be any number of SQL statements, none of which
81561>>>>>>>>>>>>>/// will be executed until SQL_COMMIT_STMT is called. Note that transactions
81561>>>>>>>>>>>>>/// are generally only needed when a table is being altered.
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Assumptions
81561>>>>>>>>>>>>>/// @Status      Public
81561>>>>>>>>>>>>>/// @Drivers     All
81561>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-26 by Aaron Gulack
81561>>>>>>>>>>>>>/// @See         SQL_COMMIT_STMT SQL_ROLLBACK_STMT
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Syntax SQL_START_TRANSACTION_STMT
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Example
81561>>>>>>>>>>>>>/// SQL_START_TRANSACTION_STMT
81561>>>>>>>>>>>>>/// SQL_SET_STMT to "UPDATE CUSTOMER SET STATUS = 'Inactive'"
81561>>>>>>>>>>>>>/// SQL_PREPARE_STMT
81561>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
81561>>>>>>>>>>>>>/// SQL_COMMIT_STMT
81561>>>>>>>>>>>>>
81561>>>>>>>>>>>>>//=============================================================================
81561>>>>>>>>>>>>>/// @Name        SQL_COMMIT_STMT
81561>>>>>>>>>>>>>/// @Description Just as the SQL_EXECUTE_STMT is used to execute the SQL
81561>>>>>>>>>>>>>/// statement in the block, this command is used to commit the transaction
81561>>>>>>>>>>>>>/// started by SQL_START_TRANSACTION_STMT. When this command is called, any
81561>>>>>>>>>>>>>/// preceding statements or procedures that are apart of the transaction will
81561>>>>>>>>>>>>>/// be committed. If one or more of these statements fail, then none of them
81561>>>>>>>>>>>>>/// will be successful, thus maintaining atomicity.
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Assumptions
81561>>>>>>>>>>>>>/// @Status      Public
81561>>>>>>>>>>>>>/// @Drivers     All
81561>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-27 by Aaron Gulack
81561>>>>>>>>>>>>>/// @See                 SQL_START_TRANSACTION_STMT SQL_ROLLBACK_STMT
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Syntax SQL_COMMIT_STMT
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Example
81561>>>>>>>>>>>>>/// SQL_START_TRANSACTION_STMT
81561>>>>>>>>>>>>>/// SQL_SET_STMT to "UPDATE CUSTOMER SET STATUS = 'Inactive'"
81561>>>>>>>>>>>>>/// SQL_PREPARE_STMT
81561>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
81561>>>>>>>>>>>>>/// SQL_COMMIT_STMT
81561>>>>>>>>>>>>>
81561>>>>>>>>>>>>>//=============================================================================
81561>>>>>>>>>>>>>/// @Name        SQL_ROLLBACK_STMT
81561>>>>>>>>>>>>>/// @Description Rolls back an SQL transaction, any data changes inside the
81561>>>>>>>>>>>>>/// transaction will not be committed by the server.
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Assumptions
81561>>>>>>>>>>>>>/// @Status      Public
81561>>>>>>>>>>>>>/// @Drivers     All
81561>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-27 by Aaron Gulack
81561>>>>>>>>>>>>>/// @See                 SQL_START_TRANSACTION_STMT SQL_COMMIT_STMT
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Syntax SQL_ROLLBACK_STMT
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Example
81561>>>>>>>>>>>>>/// SQL_START_TRANSACTION_STMT
81561>>>>>>>>>>>>>/// SQL_SET_STMT to "DELETE FROM CUSTOMER WHERE ID = 2145"
81561>>>>>>>>>>>>>/// SQL_PREPARE_STMT
81561>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
81561>>>>>>>>>>>>>/// If (Err) Begin
81561>>>>>>>>>>>>>///             SQL_ERROR_MESSAGE errorString
81561>>>>>>>>>>>>>///     Showln errorString
81561>>>>>>>>>>>>>///     SQL_ROLLBACK_STMT
81561>>>>>>>>>>>>>/// End
81561>>>>>>>>>>>>>/// Else
81561>>>>>>>>>>>>>///     Showln "SQL Statement successful - committing"
81561>>>>>>>>>>>>>///     SQL_COMMIT_STMT
81561>>>>>>>>>>>>>
81561>>>>>>>>>>>>>//=============================================================================
81561>>>>>>>>>>>>>/// @Name        SET_TRANSACTIONS_ALLOWED
81561>>>>>>>>>>>>>/// @Description This command is used to toggle on or off the ability to
81561>>>>>>>>>>>>>/// complete transaction to the server. Passing false to this command will
81561>>>>>>>>>>>>>/// not allow transactions to be made, passing true will allow the transactions.
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Assumptions
81561>>>>>>>>>>>>>/// @Status      Internal
81561>>>>>>>>>>>>>/// @Drivers     All
81561>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-27 by Aaron Gulack
81561>>>>>>>>>>>>>/// @See
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Syntax SET_TRANSACTIONS_ALLOWED of {server} to {variable}
81561>>>>>>>>>>>>>/// @Param server                               The name of the server being used
81561>>>>>>>>>>>>>/// @Param variable                     Boolean to enable or disable transactions
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Example
81561>>>>>>>>>>>>>/// SET_TRANSACTIONS_ALLOWED of "localhost" to True
81561>>>>>>>>>>>>>
81561>>>>>>>>>>>>>//=============================================================================
81561>>>>>>>>>>>>>/// @Name        SQL_FETCH_NEXT_ROW
81561>>>>>>>>>>>>>/// @Description This command is used to fetch the next row returned by the
81561>>>>>>>>>>>>>/// associated SQL statement. The SQL statement is created from the
81561>>>>>>>>>>>>>/// SQL_SET_STMT and executed with the SQL_EXECUTE_STMT. This command can be
81561>>>>>>>>>>>>>/// used in two ways. If the results are to be attached to variables, then no
81561>>>>>>>>>>>>>/// file needs to be specified, just the variables for each column in the row.
81561>>>>>>>>>>>>>/// If the results are to be inserted into the record buffer directly, then the
81561>>>>>>>>>>>>>/// file must be specified. From there, a SQL_BINDCOLUMNS_STMT can be used to
81561>>>>>>>>>>>>>/// bind the fetched row to the specific fields in the file. Note that the
81561>>>>>>>>>>>>>/// columns are fecthed in the order that the SQL statement generates them, so
81561>>>>>>>>>>>>>/// the variables must follow the same order. The two constants, "found" and
81561>>>>>>>>>>>>>/// "finderr" are set depending on whether the next row was found.
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Assumptions
81561>>>>>>>>>>>>>/// @Status      Public
81561>>>>>>>>>>>>>/// @Drivers     All
81561>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-27 by Aaron Gulack
81561>>>>>>>>>>>>>/// @See                 SQL_SET_STMT SQL_APPEND_STMT SQL_PREPARE_STMT SQL_EXECUTE_STMT SQL_CANCEL_QUERY_STMT SQL_BINDCOLUMNS_STMT
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Syntax SQL_FETCH_NEXT_ROW [of {file}] into {variable}
81561>>>>>>>>>>>>>/// @Param  file                                The name or number of the file
81561>>>>>>>>>>>>>/// @Param  variable                    The variable that the next column in the fetched row will be put into (can be multiple)
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Usage SQL_FETCH_NEXT_ROW of Customer
81561>>>>>>>>>>>>>/// @Usage SQL_FETCH_NEXT_ROW into sRecnum sID
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Example
81561>>>>>>>>>>>>>/// String sID sRecnum
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER ID"
81561>>>>>>>>>>>>>/// SQL_APPEND_STMT to " BY NAME DESC"
81561>>>>>>>>>>>>>/// SQL_PREPARE_STMT
81561>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
81561>>>>>>>>>>>>>/// While (found)
81561>>>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW into sRecnum sID
81561>>>>>>>>>>>>>///     If (found) Begin
81561>>>>>>>>>>>>>///             Showln sID
81561>>>>>>>>>>>>>///    End
81561>>>>>>>>>>>>>/// Loop
81561>>>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Example
81561>>>>>>>>>>>>>/// Open Customer
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// SQL_SET_STMT of Customer to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
81561>>>>>>>>>>>>>/// SQL_PREPARE_STMT of Customer
81561>>>>>>>>>>>>>/// SQL_BINDCOLUMNS_STMT of Customer to DF_BIND_ALL_COLUMNS
81561>>>>>>>>>>>>>/// SQL_EXECUTE_STMT of Customer
81561>>>>>>>>>>>>>/// While (Found)
81561>>>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW of Customer
81561>>>>>>>>>>>>>///     Showln Customer.ID
81561>>>>>>>>>>>>>///     Showln Customer.FirstName
81561>>>>>>>>>>>>>///             Showln Customer.LastName
81561>>>>>>>>>>>>>/// Loop
81561>>>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT
81561>>>>>>>>>>>>>
81561>>>>>>>>>>>>>
81561>>>>>>>>>>>>>//=============================================================================
81561>>>>>>>>>>>>>/// @Name        GET_RESULT_SET
81561>>>>>>>>>>>>>/// @Description Fetches the next row in the result set returned by a
81561>>>>>>>>>>>>>/// query or stored procedure.
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Assumptions
81561>>>>>>>>>>>>>/// @Status      Deprecated
81561>>>>>>>>>>>>>/// @Drivers     All
81561>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-27 by Aaron Gulack
81561>>>>>>>>>>>>>/// @See
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Syntax GET_RESULT_SET into {variable}
81561>>>>>>>>>>>>>/// @Param variable                     The variable receiving the result (can be multiple)
81561>>>>>>>>>>>>>
81561>>>>>>>>>>>>>//=============================================================================
81561>>>>>>>>>>>>>/// @Name        SQL_GET_DATA_CHUNK
81561>>>>>>>>>>>>>/// @Description This command is used to get a chunk of data from a column
81561>>>>>>>>>>>>>/// retrieved through an embedded SQL statement. By passing the column number
81561>>>>>>>>>>>>>/// and the offset number, the chunk will be put into the specified variable.
81561>>>>>>>>>>>>>/// To specify how big of a chunk to get, use the SQL_SET_CHUNK_SIZE command.
81561>>>>>>>>>>>>>/// Otherwise the maximum length will be retrieved. An optional variable can
81561>>>>>>>>>>>>>/// also be passed which will store the length of the chunk. Note that unlike
81561>>>>>>>>>>>>>/// LOB_READ, this command works for any column type, not just LOB columns.
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Assumptions
81561>>>>>>>>>>>>>/// @Status      Public
81561>>>>>>>>>>>>>/// @Drivers     SQLFlex
81561>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
81561>>>>>>>>>>>>>/// @See                 SQL_SET_CHUNK_SIZE SQL_GET_CHUNK_SIZE SQL_SET_MAX_DATA_SIZE SQL_GET_MAX_DATA_SIZE
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Syntax SQL_GET_DATA_CHUNK COLUMN {column} OFFSET {offset} to {variable} {length}
81561>>>>>>>>>>>>>/// @Param column                               Column number to get chunk from
81561>>>>>>>>>>>>>/// @Param offset                       Offset to start at for the chunk
81561>>>>>>>>>>>>>/// @Param variable                     Variable to hold the returned chunk
81561>>>>>>>>>>>>>/// @Param length                       Variable to hold the chunk length
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Example
81561>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
81561>>>>>>>>>>>>>/// SQL_PREPARE_STMT
81561>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
81561>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sBio
81561>>>>>>>>>>>>>/// If (Found) Begin
81561>>>>>>>>>>>>>///     SQL_SET_CHUNK_SIZE to 150
81561>>>>>>>>>>>>>///     SQL_GET_DATA_CHUNK COLUMN 6 OFFSET 1 to sChunk iLength
81561>>>>>>>>>>>>>///     Showln sChunk
81561>>>>>>>>>>>>>///     Showln iLength
81561>>>>>>>>>>>>>/// End
81561>>>>>>>>>>>>>
81561>>>>>>>>>>>>>Function MertechInc_SQL_GET_DATA_CHUNK Global Integer iColumn Integer iOffset Returns String
81563>>>>>>>>>>>>>    Integer iChuck_Size
81563>>>>>>>>>>>>>    String sChunk
81563>>>>>>>>>>>>>
81563>>>>>>>>>>>>>    //Get current Chuck size and pre size string
81563>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_CHUNK_SIZE CALLBACK 0 PASSING iChuck_Size MertechInc_Blank 1 RESULT MertechInc_iRet
81568>>>>>>>>>>>>>    Get MertechInc_Pre_Size_String iChuck_Size to sChunk
81569>>>>>>>>>>>>>
81569>>>>>>>>>>>>>    //Get data
81569>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_GET_DATA_CHUNK CALLBACK 0 PASSING iColumn sChunk iOffset RESULT MertechInc_iRet
81574>>>>>>>>>>>>>
81574>>>>>>>>>>>>>    //sArg1 (iColumn) contains the number of bytes returned, so move it to
81574>>>>>>>>>>>>>    //MertechInc_Arg1 to pass the value back
81574>>>>>>>>>>>>>    Move iColumn to MertechInc_sArg1
81575>>>>>>>>>>>>>
81575>>>>>>>>>>>>>    Function_Return sChunk
81576>>>>>>>>>>>>>End_Function
81577>>>>>>>>>>>>>
81577>>>>>>>>>>>>>//=============================================================================
81577>>>>>>>>>>>>>/// @Name        SQL_SET_CHUNK_SIZE
81577>>>>>>>>>>>>>/// @Description This command sets the size of the chunk to retrieve when
81577>>>>>>>>>>>>>/// using SQL_GET_DATA_CHUNK. Whatever number is set here will be the
81577>>>>>>>>>>>>>/// length of the chunk that is retrieved, as long as it does not exceed
81577>>>>>>>>>>>>>/// the maximum chunk size.
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Assumptions
81577>>>>>>>>>>>>>/// @Status      Public
81577>>>>>>>>>>>>>/// @Drivers     SQLFlex
81577>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
81577>>>>>>>>>>>>>/// @See                 SQL_GET_DATA_CHUNK SQL_GET_CHUNK_SIZE SQL_SET_MAX_DATA_SIZE SQL_GET_MAX_DATA_SIZE
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Syntax SQL_SET_CHUNK_SIZE to {variable}
81577>>>>>>>>>>>>>/// @Param variable                     Length of chunk to retrive
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Example
81577>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
81577>>>>>>>>>>>>>/// SQL_PREPARE_STMT
81577>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
81577>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sBio
81577>>>>>>>>>>>>>/// If (Found) Begin
81577>>>>>>>>>>>>>///     SQL_SET_CHUNK_SIZE to 150
81577>>>>>>>>>>>>>///     SQL_GET_DATA_CHUNK COLUMN 6 OFFSET 1 to sChunk iLength
81577>>>>>>>>>>>>>///     Showln sChunk
81577>>>>>>>>>>>>>///     Showln iLength
81577>>>>>>>>>>>>>/// End
81577>>>>>>>>>>>>>
81577>>>>>>>>>>>>>//=============================================================================
81577>>>>>>>>>>>>>/// @Name        SQL_GET_CHUNK_SIZE
81577>>>>>>>>>>>>>/// @Description This command gets the size of the chunk being retrieved
81577>>>>>>>>>>>>>/// from SQL_GET_DATA_CHUNK and puts it into the specified variable.
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Assumptions
81577>>>>>>>>>>>>>/// @Status      Public
81577>>>>>>>>>>>>>/// @Drivers     SQLFlex
81577>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
81577>>>>>>>>>>>>>/// @See                 SQL_SET_CHUNK_SIZE SQL_GET_DATA_CHUNK SQL_SET_MAX_DATA_SIZE SQL_GET_MAX_DATA_SIZE
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Syntax SQL_GET_CHUNK_SIZE to {variable}
81577>>>>>>>>>>>>>/// @Param variable             Variable to hold the chunk size
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Example
81577>>>>>>>>>>>>>/// SQL_GET_CHUNK_SIZE to iLength
81577>>>>>>>>>>>>>
81577>>>>>>>>>>>>>//=============================================================================
81577>>>>>>>>>>>>>/// @Name        SQL_SET_MAX_DATA_SIZE
81577>>>>>>>>>>>>>/// @Description This command sets the maximum size for data chunks
81577>>>>>>>>>>>>>/// retrieved through SQL_GET_DATA_CHUNK. If SQL_SET_CHUNK_SIZE is higher
81577>>>>>>>>>>>>>/// than the maximum size set with this command, then this will override
81577>>>>>>>>>>>>>/// it and the chunk will be no longer than the maximum size set here.
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Assumptions
81577>>>>>>>>>>>>>/// @Status      Public
81577>>>>>>>>>>>>>/// @Drivers     SQLFlex
81577>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
81577>>>>>>>>>>>>>/// @See                 SQL_SET_CHUNK_SIZE SQL_GET_CHUNK_SIZE SQL_GET_DATA_CHUNK SQL_GET_MAX_DATA_SIZE
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Syntax SQL_SET_MAX_DATA_SIZE to {variable}
81577>>>>>>>>>>>>>/// @Param variable                     Max length to allow for chunks
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Example
81577>>>>>>>>>>>>>/// SQL_SET_MAX_DATA_SIZE to 1000
81577>>>>>>>>>>>>>
81577>>>>>>>>>>>>>//=============================================================================
81577>>>>>>>>>>>>>/// @Name        SQL_GET_MAX_DATA_SIZE
81577>>>>>>>>>>>>>/// @Description This command returns the maximum chunk size allowed
81577>>>>>>>>>>>>>/// for SQL_GET_DATA_CHUNK.
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Assumptions
81577>>>>>>>>>>>>>/// @Status      Public
81577>>>>>>>>>>>>>/// @Drivers     SQLFlex
81577>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
81577>>>>>>>>>>>>>/// @See                 SQL_SET_CHUNK_SIZE SQL_GET_CHUNK_SIZE SQL_GET_DATA_CHUNK SQL_SET_MAX_DATA_SIZE
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Syntax SQL_GET_MAX_DATA_SIZE to {variable}
81577>>>>>>>>>>>>>/// @Param variable             Variable to hold the maximum chunk size
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Example
81577>>>>>>>>>>>>>/// SQL_GET_MAX_DATA_SIZE to iLength
81577>>>>>>>>>>>>>
81577>>>>>>>>>>>>>//=============================================================================
81577>>>>>>>>>>>>>/// @Name        SQL_GET_NUM_COLS
81577>>>>>>>>>>>>>/// @Description This command is used to get the number of columns retrieved
81577>>>>>>>>>>>>>/// from an SQL expression result set. Since the column number is based on
81577>>>>>>>>>>>>>/// the result set, this command cannot be used when the results are being
81577>>>>>>>>>>>>>/// bound to the record buffer.  If this command is used with the record
81577>>>>>>>>>>>>>/// buffer or if no columns are found, -1 is returned.
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Assumptions
81577>>>>>>>>>>>>>/// @Status      Public
81577>>>>>>>>>>>>>/// @Drivers     All
81577>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-28 by Aaron Gulack
81577>>>>>>>>>>>>>/// @See                 SQL_PREPARE_STMT SQL_EXECUTE_STMT SQL_SET_STMT
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Syntax SQL_GET_NUM_COLS to {variable}
81577>>>>>>>>>>>>>/// @Param variable                     Variable to hold the number of columns.
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Example
81577>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE FIRSTNAME = 'Aaron'"
81577>>>>>>>>>>>>>/// SQL_PREPARE_STMT
81577>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
81577>>>>>>>>>>>>>/// GET_RESULT_SET_NUM_COLS to iNumCols
81577>>>>>>>>>>>>>/// Showln iNumCols
81577>>>>>>>>>>>>>
81577>>>>>>>>>>>>>
81577>>>>>>>>>>>>>//=============================================================================
81577>>>>>>>>>>>>>/// @Name        GET_RESULT_SET_NUM_COLS
81577>>>>>>>>>>>>>/// @Description Returns the number of columns in the result set.
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Assumptions
81577>>>>>>>>>>>>>/// @Status      Deprecated
81577>>>>>>>>>>>>>/// @Drivers     All
81577>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-28 by Aaron Gulack
81577>>>>>>>>>>>>>/// @See                 SQL_GET_NUM_COLS
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Syntax GET_RESULT_SET_NUM_COLS to {variable}
81577>>>>>>>>>>>>>/// @Param variable                     Variable to hold the number of columns
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Example
81577>>>>>>>>>>>>>/// Integer iNumCols
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE FIRSTNAME = 'Aaron'"
81577>>>>>>>>>>>>>/// SQL_PREPARE_STMT
81577>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
81577>>>>>>>>>>>>>/// GET_RESULT_SET_NUM_COLS to iNumCols
81577>>>>>>>>>>>>>/// Showln iNumCols
81577>>>>>>>>>>>>>
81577>>>>>>>>>>>>>//=============================================================================
81577>>>>>>>>>>>>>/// @Name        SQL_GET_NUM_ROWS
81577>>>>>>>>>>>>>/// @Description This command is used to get the number of rows retrieved
81577>>>>>>>>>>>>>/// from a result set of an SQL expression. It cannot be used when binding
81577>>>>>>>>>>>>>/// the result set to the record buffer.
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// Note: The number of rows may not always be available, depending
81577>>>>>>>>>>>>>/// on server and cursor types.
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Assumptions
81577>>>>>>>>>>>>>/// @Status      Public
81577>>>>>>>>>>>>>/// @Drivers     All
81577>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-30 by Aaron Gulack
81577>>>>>>>>>>>>>/// @See                 SQL_PREPARE_STMT SQL_EXECUTE_STMT
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Syntax SQL_GET_NUM_ROWS to {variable}
81577>>>>>>>>>>>>>/// @Param variable                     Variable to hold the number of rows
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Example
81577>>>>>>>>>>>>>/// Integer iNumRows
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
81577>>>>>>>>>>>>>/// SQL_PREPARE_STMT
81577>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
81577>>>>>>>>>>>>>/// SQL_GET_NUM_ROWS to iNumRows
81577>>>>>>>>>>>>>/// Showln iNumRows
81577>>>>>>>>>>>>>
81577>>>>>>>>>>>>>
81577>>>>>>>>>>>>>//=============================================================================
81577>>>>>>>>>>>>>/// @Name        SQL_GET_COL_NAME
81577>>>>>>>>>>>>>/// @Description This command is used to retrieve the name of a specified
81577>>>>>>>>>>>>>/// column within an SQL result set. An optional second variable can be used
81577>>>>>>>>>>>>>/// to retrieve the size of the specified column. Note that this command
81577>>>>>>>>>>>>>/// cannot be used when the results are being directly binded to the record
81577>>>>>>>>>>>>>/// buffer, it can only be used for the results of an SQL statement.
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Assumptions
81577>>>>>>>>>>>>>/// @Status      Public
81577>>>>>>>>>>>>>/// @Drivers     All
81577>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-30 by Aaron Gulack
81577>>>>>>>>>>>>>/// @See                 SQL_GET_NUM_COLS
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Syntax SQL_GET_COL_NAME {columnNumber} to {variable} [{length}]
81577>>>>>>>>>>>>>/// @Param columnNumber                 The column number being used
81577>>>>>>>>>>>>>/// @Param variable                             String variable for the column name
81577>>>>>>>>>>>>>/// @Param length                       Variable to hold the column length (optional)
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Example
81577>>>>>>>>>>>>>/// Open Customer
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// String sColumnName
81577>>>>>>>>>>>>>/// Integer iLength
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
81577>>>>>>>>>>>>>/// SQL_PREPARE_STMT
81577>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
81577>>>>>>>>>>>>>/// SQL_GET_COL_NAME 1 to sColumnName iLength
81577>>>>>>>>>>>>>/// showln sColumnName
81577>>>>>>>>>>>>>/// showln iLength
81577>>>>>>>>>>>>>
81577>>>>>>>>>>>>>
81577>>>>>>>>>>>>>//=============================================================================
81577>>>>>>>>>>>>>/// @Name        GET_RESULT_SET_COL_NAME
81577>>>>>>>>>>>>>/// @Description Returns the column name being populated from the result set.
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Assumptions
81577>>>>>>>>>>>>>/// @Status      Deprecated
81577>>>>>>>>>>>>>/// @Drivers     All
81577>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-30 by Aaron Gulack
81577>>>>>>>>>>>>>/// @See                 SQL_GET_COL_NAME
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Syntax GET_RESULT_SET_COL_NAME {columnNumber} to {variable} [{length}]
81577>>>>>>>>>>>>>/// @Param columnNumber                 The column number being used
81577>>>>>>>>>>>>>/// @Param variable                             String variable for the column name
81577>>>>>>>>>>>>>/// @Param length                       Variable receiving the column length (optional)
81577>>>>>>>>>>>>>
81577>>>>>>>>>>>>>//=============================================================================
81577>>>>>>>>>>>>>/// @Name        SQL_GET_COL_ATTRIBUTE
81577>>>>>>>>>>>>>/// @Description This command is used to get specific column information from
81577>>>>>>>>>>>>>/// the columns in a result set of an SQL statement. By passing one of the
81577>>>>>>>>>>>>>/// supported attributes below, the command will return the desired information.
81577>>>>>>>>>>>>>/// Note that some attributes only work with specific drivers. See the list
81577>>>>>>>>>>>>>/// below for more information.
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// Supported attributes are:
81577>>>>>>>>>>>>>/// <dl>
81577>>>>>>>>>>>>>/// <dt>SIZE        </dt><dd>The maximum length of the column</dd>
81577>>>>>>>>>>>>>/// <dt>DATA_LENGTH </dt><dd>Length of data currently in the column</dd>
81577>>>>>>>>>>>>>/// <dt>DECIMALS    </dt><dd>If numeric, shows number of decimal places</dd>
81577>>>>>>>>>>>>>/// <dt>LABEL       </dt><dd>Returns the column name in ORAFlex and MySQLFlex</dd>
81577>>>>>>>>>>>>>/// <dt>COLUMN_NAME </dt><dd>Returns the name of the column</dd>
81577>>>>>>>>>>>>>/// <dt>TABLE_NAME  </dt><dd>Returns the name of the table (MySQLFlex only)</dd>
81577>>>>>>>>>>>>>/// <dt>SQLTYPE     </dt><dd>Returns the number representing the SQL data type</dd>
81577>>>>>>>>>>>>>/// <dt>NULLABLE    </dt><dd>Returns true if null is allowed, false otherwise (doesn't work in PostgreSQL)</dd>
81577>>>>>>>>>>>>>/// <dt>DFTYPE      </dt><dd>Dataflex type column is mapped to</dd>
81577>>>>>>>>>>>>>/// </dl>
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Assumptions
81577>>>>>>>>>>>>>/// @Status      Public
81577>>>>>>>>>>>>>/// @Drivers     All
81577>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
81577>>>>>>>>>>>>>/// @See
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Syntax SQL_GET_COL_ATTRIBUTE of {columnNumber} {attribute} to {variable}
81577>>>>>>>>>>>>>/// @Param columnNumber                 The number of the column that is being examined
81577>>>>>>>>>>>>>/// @Param attribute                    The attribute being checked (see list)
81577>>>>>>>>>>>>>/// @Param variable                             Variable to hold the attribute value
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Example
81577>>>>>>>>>>>>>/// String sFirstName sLastName sColumn1Name sColumn2Name
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// Open Customer
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
81577>>>>>>>>>>>>>/// SQL_PREPARE_STMT
81577>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
81577>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sFirstName sLastName
81577>>>>>>>>>>>>>/// If (Found) Begin
81577>>>>>>>>>>>>>///     SQL_GET_COL_ATTRIBUTE of 1 COLUMN_NAME to sColumn1Name
81577>>>>>>>>>>>>>///     SQL_GET_COL_ATTRIBUTE of 2 COLUMN_NAME to sColumn2Name
81577>>>>>>>>>>>>>///     Showln (sColumn1Name + " = " + sFirstName)
81577>>>>>>>>>>>>>///     Showln (sColumn2Name + " = " + sLastName)
81577>>>>>>>>>>>>>/// End
81577>>>>>>>>>>>>>
81577>>>>>>>>>>>>>//=============================================================================
81577>>>>>>>>>>>>>/// @Name        DDO_GET_BIND_RSPARAMETERS
81577>>>>>>>>>>>>>/// @Description Recursively calls DO_GET_BIND_RSPARAMETERS.
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Assumptions
81577>>>>>>>>>>>>>/// @Status      Internal
81577>>>>>>>>>>>>>/// @Drivers     All
81577>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-30 by Aaron Gulack
81577>>>>>>>>>>>>>/// @See
81577>>>>>>>>>>>>>
81577>>>>>>>>>>>>>//=============================================================================
81577>>>>>>>>>>>>>/// @Name        DO_GET_BIND_RSPARAMETERS
81577>>>>>>>>>>>>>/// @Description Gets bound parameters values for result set call.
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Assumptions
81577>>>>>>>>>>>>>/// @Status      Internal
81577>>>>>>>>>>>>>/// @Drivers     All
81577>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-30 by Aaron Gulack
81577>>>>>>>>>>>>>/// @See
81577>>>>>>>>>>>>>
81577>>>>>>>>>>>>>Function MertechInc_DO_GET_BIND_RSPARAMETERS Global Integer bSQLFlex String sArg1 String sArg2 Integer iArg Returns String
81579>>>>>>>>>>>>>    String sReturnValue
81579>>>>>>>>>>>>>    Integer iSize
81579>>>>>>>>>>>>>
81579>>>>>>>>>>>>>    move 0 to iSize
81580>>>>>>>>>>>>>        SQL_GET_COL_ATTRIBUTE of iArg DATA_LENGTH to iSize
81597>>>>>>>>>>>>>>
81597>>>>>>>>>>>>>
81597>>>>>>>>>>>>>    Get MertechInc_Pre_Size_String (iSize+1) to sReturnValue
81598>>>>>>>>>>>>>    Move (|CI$10000 * iArg) To iArg // Shift column number 16 bits to the left
81599>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function 24 CALLBACK 0 PASSING sReturnValue MertechInc_Blank iArg RESULT MertechInc_iRet
81604>>>>>>>>>>>>>
81604>>>>>>>>>>>>>    Function_Return sReturnValue
81605>>>>>>>>>>>>>End_Function
81606>>>>>>>>>>>>>
81606>>>>>>>>>>>>>
81606>>>>>>>>>>>>>//=============================================================================
81606>>>>>>>>>>>>>/// @Name        SQL_NEXT_RESULT_SET
81606>>>>>>>>>>>>>/// @Description This command is used when working with SQL statements that
81606>>>>>>>>>>>>>/// return multiple result sets. In that scenario, calling this command will
81606>>>>>>>>>>>>>/// move to the next result set. That set can now be fetched or binded to
81606>>>>>>>>>>>>>/// columns on a table.
81606>>>>>>>>>>>>>///
81606>>>>>>>>>>>>>/// @See
81606>>>>>>>>>>>>>/// @Status      Public
81606>>>>>>>>>>>>>/// @Drivers     All
81606>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-02 by Aaron Gulack
81606>>>>>>>>>>>>>/// @See
81606>>>>>>>>>>>>>///
81606>>>>>>>>>>>>>/// @Syntax SQL_NEXT_RESULT_SET [of {file}]
81606>>>>>>>>>>>>>/// @Param file                 Name or number of the file (optional)
81606>>>>>>>>>>>>>///
81606>>>>>>>>>>>>>/// @Example
81606>>>>>>>>>>>>>/// SQL_SET_STMT to "SP_HELP CUSTOMER"
81606>>>>>>>>>>>>>/// SQL_PREPARE_STMT
81606>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
81606>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sTable sOwner sTableType dtCreated
81606>>>>>>>>>>>>>/// If (Found) Begin
81606>>>>>>>>>>>>>///     Showln sTable
81606>>>>>>>>>>>>>///     Showln sOwner
81606>>>>>>>>>>>>>///     Showln sTableType
81606>>>>>>>>>>>>>///     Showln dtCreated
81606>>>>>>>>>>>>>/// End
81606>>>>>>>>>>>>>/// SQL_NEXT_RESULT_SET
81606>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sColumnName sColumnType sComputed sLength
81606>>>>>>>>>>>>>/// If (Found) Begin
81606>>>>>>>>>>>>>///     Showln sColumnName
81606>>>>>>>>>>>>>///     Showln sColumnType
81606>>>>>>>>>>>>>///     Showln sComputed
81606>>>>>>>>>>>>>///     Showln sLength
81606>>>>>>>>>>>>>/// End
81606>>>>>>>>>>>>>
81606>>>>>>>>>>>>>//=============================================================================
81606>>>>>>>>>>>>>/// @Name        DDO_PASS_ARGUMENTS
81606>>>>>>>>>>>>>/// @Description Calls DO_PASS_ARGUMENTS until the argument is "BINDING" and
81606>>>>>>>>>>>>>/// then stops.
81606>>>>>>>>>>>>>///
81606>>>>>>>>>>>>>/// @Assumptions
81606>>>>>>>>>>>>>/// @Status      Internal
81606>>>>>>>>>>>>>/// @Drivers     All
81606>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
81606>>>>>>>>>>>>>/// @See
81606>>>>>>>>>>>>>
81606>>>>>>>>>>>>>//=============================================================================
81606>>>>>>>>>>>>>/// @Name        DO_PASS_ARGUMENTS
81606>>>>>>>>>>>>>/// @Description Builds parameter statements for stored procedures and adds
81606>>>>>>>>>>>>>/// them to the current query.
81606>>>>>>>>>>>>>///
81606>>>>>>>>>>>>>/// @Assumptions
81606>>>>>>>>>>>>>/// @Status      internal
81606>>>>>>>>>>>>>/// @Drivers     All
81606>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
81606>>>>>>>>>>>>>/// @See
81606>>>>>>>>>>>>>
81606>>>>>>>>>>>>>//=============================================================================
81606>>>>>>>>>>>>>/// @Name        DDO_BIND_PARAMETERS
81606>>>>>>>>>>>>>/// @Description Recursively calls DO_BIND_PARAMETERS until the keyword
81606>>>>>>>>>>>>>/// "BINDING" is encountered.
81606>>>>>>>>>>>>>///
81606>>>>>>>>>>>>>/// @Assumptions
81606>>>>>>>>>>>>>/// @Status      Internal
81606>>>>>>>>>>>>>/// @Drivers     All
81606>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
81606>>>>>>>>>>>>>/// @See
81606>>>>>>>>>>>>>
81606>>>>>>>>>>>>>//=============================================================================
81606>>>>>>>>>>>>>/// @Name        DO_BIND_PARAMETERS
81606>>>>>>>>>>>>>/// @Description Binds parameters for a stored procedure call.
81606>>>>>>>>>>>>>///
81606>>>>>>>>>>>>>/// @Assumptions
81606>>>>>>>>>>>>>/// @Status      Internal
81606>>>>>>>>>>>>>/// @Drivers     All
81606>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
81606>>>>>>>>>>>>>/// @See
81606>>>>>>>>>>>>>
81606>>>>>>>>>>>>>Procedure MertechInc_DO_BIND_PARAMETERS Global String sValue String sName Integer iLength
81608>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_BIND_PARAMETER CALLBACK 0 PASSING sValue sName iLength RESULT MertechInc_iRet
81613>>>>>>>>>>>>>End_Procedure
81614>>>>>>>>>>>>>
81614>>>>>>>>>>>>>//=============================================================================
81614>>>>>>>>>>>>>/// @Name        DO_BIND_PAR_RET
81614>>>>>>>>>>>>>/// @Description Binds parameters for a stored procedure call.
81614>>>>>>>>>>>>>///
81614>>>>>>>>>>>>>/// @Assumptions
81614>>>>>>>>>>>>>/// @Status      Internal
81614>>>>>>>>>>>>>/// @Drivers     OraFlex
81614>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
81614>>>>>>>>>>>>>/// @See
81614>>>>>>>>>>>>>
81614>>>>>>>>>>>>>//=============================================================================
81614>>>>>>>>>>>>>/// @Name        DDO_GET_BIND_PARAMETERS
81614>>>>>>>>>>>>>/// @Description Recursively calls DO_GET_BIND_PARAMETERS.
81614>>>>>>>>>>>>>///
81614>>>>>>>>>>>>>/// @Assumptions
81614>>>>>>>>>>>>>/// @Status      Internal
81614>>>>>>>>>>>>>/// @Drivers     All
81614>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
81614>>>>>>>>>>>>>/// @See
81614>>>>>>>>>>>>>
81614>>>>>>>>>>>>>//=============================================================================
81614>>>>>>>>>>>>>/// @Name        DO_GET_BIND_PARAMETERS
81614>>>>>>>>>>>>>/// @Description Gets bound parameter values for a stored procedure call.
81614>>>>>>>>>>>>>///
81614>>>>>>>>>>>>>/// @Assumptions
81614>>>>>>>>>>>>>/// @Status      Internal
81614>>>>>>>>>>>>>/// @Drivers     All
81614>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
81614>>>>>>>>>>>>>/// @See
81614>>>>>>>>>>>>>
81614>>>>>>>>>>>>>Function MertechInc_DO_GET_BIND_PARAMETERS Global Integer bSQLFlex String sArg1 String sArg2 Integer iArg Returns String
81616>>>>>>>>>>>>>    String sReturnValue
81616>>>>>>>>>>>>>    Integer iSize
81616>>>>>>>>>>>>>
81616>>>>>>>>>>>>>    if (MertechInc_DriverName = SQLFLEX) ;                move (iArg+1) to iArg
81619>>>>>>>>>>>>>//        SQL_GET_COL_ATTRIBUTE of iArg DATA_LENGTH to iSize
81619>>>>>>>>>>>>>
81619>>>>>>>>>>>>>    Get MertechInc_Pre_Size_String (iSize+1) to sReturnValue
81620>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function 24 CALLBACK 0 PASSING sReturnValue MertechInc_Blank iArg RESULT MertechInc_iRet
81625>>>>>>>>>>>>>
81625>>>>>>>>>>>>>    Function_Return sReturnValue
81626>>>>>>>>>>>>>End_Function
81627>>>>>>>>>>>>>
81627>>>>>>>>>>>>>//=============================================================================
81627>>>>>>>>>>>>>/// @Name        SQL_GET_OUTPUT_VALUE
81627>>>>>>>>>>>>>/// @Description This command is used to get the value of a specific
81627>>>>>>>>>>>>>/// parameter associated with a stored procedure.  Although this
81627>>>>>>>>>>>>>/// command will work with any parameter, it is mostly used with
81627>>>>>>>>>>>>>/// IN/OUT or OUT parameters as their value will more often be important
81627>>>>>>>>>>>>>/// once returned. When multiple values are returned, this command can be
81627>>>>>>>>>>>>>/// more efficient than other options. Note that the specified parameter
81627>>>>>>>>>>>>>/// must first be defined using the SQL_SET_PROCEDURE_PARAMETER command
81627>>>>>>>>>>>>>/// in order to work properly.
81627>>>>>>>>>>>>>///
81627>>>>>>>>>>>>>/// @Assumptions
81627>>>>>>>>>>>>>/// @Status      Deprecated
81627>>>>>>>>>>>>>/// @Drivers     All
81627>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
81627>>>>>>>>>>>>>/// @See                 SQL_GET_PROCEDURE_PARAMETER
81627>>>>>>>>>>>>>///
81627>>>>>>>>>>>>>/// @Syntax SQL_GET_OUTPUT_VALUE {parameter} to {variable}
81627>>>>>>>>>>>>>/// @Param parameter            Number of the parameter
81627>>>>>>>>>>>>>/// @Param variable                     Variable to hold the parameter's value
81627>>>>>>>>>>>>>///
81627>>>>>>>>>>>>>/// @Example
81627>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_NAME "user.getCustomerStatus" NUMPAR 1
81627>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to sCustomerID IN_OUT
81627>>>>>>>>>>>>>/// SQL_PROCEDURE_EXECUTE
81627>>>>>>>>>>>>>/// SQL_GET_OUTPUT_VALUE 1 to sStatus
81627>>>>>>>>>>>>>///
81627>>>>>>>>>>>>>/// Showln sStatus
81627>>>>>>>>>>>>>///
81627>>>>>>>>>>>>>/// @Example
81627>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_NAME "user.getCustomerStatus" NUMPAR 2
81627>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to sCustomerID IN
81627>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 2 to sStatus OUT
81627>>>>>>>>>>>>>/// SQL_PROCEDURE_EXECUTE
81627>>>>>>>>>>>>>/// SQL_GET_OUTPUT_VALUE 2 to sStatus
81627>>>>>>>>>>>>>///
81627>>>>>>>>>>>>>/// Showln sStatus
81627>>>>>>>>>>>>>// OLI:
81627>>>>>>>>>>>>>// This function is identical in operation to SQL_GET_PROCEDURE_PARAMETER, so just do a replace
81627>>>>>>>>>>>>>
81627>>>>>>>>>>>>>//=============================================================================
81627>>>>>>>>>>>>>/// @Name        SQL_FETCH_COLUMN
81627>>>>>>>>>>>>>/// @Description This command is used to retrieve a specified column from a
81627>>>>>>>>>>>>>/// result set of an SQL statement. Note that this command cannot be used to
81627>>>>>>>>>>>>>/// replace SQL_FETCH_NEXT_ROW but is used in addition to it when only one
81627>>>>>>>>>>>>>/// column is needed. For most cases, SQL_FETCH_NEXT_ROW can be used alone
81627>>>>>>>>>>>>>/// to retrieve the columns desired so this should only be used if there is
81627>>>>>>>>>>>>>/// a specific reason to do so.
81627>>>>>>>>>>>>>///
81627>>>>>>>>>>>>>/// @Assumptions
81627>>>>>>>>>>>>>/// @Status      Public
81627>>>>>>>>>>>>>/// @Drivers     All
81627>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
81627>>>>>>>>>>>>>/// @See                 SQL_FETCH_NEXT_ROW
81627>>>>>>>>>>>>>///
81627>>>>>>>>>>>>>/// @Syntax SQL_FETCH_COLUMN {columnNumber} into {variable}
81627>>>>>>>>>>>>>/// @Param columnNumber    Number of the column to fetch
81627>>>>>>>>>>>>>/// @Param variable        Variable to hold the fetched value
81627>>>>>>>>>>>>>///
81627>>>>>>>>>>>>>/// @Example
81627>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
81627>>>>>>>>>>>>>/// SQL_PREPARE_STMT
81627>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
81627>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW
81627>>>>>>>>>>>>>/// SQL_GET_NUM_COLS to iCols
81627>>>>>>>>>>>>>/// For fieldIndex from 1 to iCols
81627>>>>>>>>>>>>>///     SQL_FETCH_COLUMN fieldIndex into sValue
81627>>>>>>>>>>>>>///     Showln sValue
81627>>>>>>>>>>>>>/// Loop
81627>>>>>>>>>>>>>
81627>>>>>>>>>>>>>Function MertechInc_SQL_FETCH_COLUMN Global String sArg1 String sArg2 Integer iArg Returns String
81629>>>>>>>>>>>>>    String sReturnValue
81629>>>>>>>>>>>>>    Integer iSize
81629>>>>>>>>>>>>>
81629>>>>>>>>>>>>>    Move 0 to iSize
81630>>>>>>>>>>>>>        SQL_GET_COL_ATTRIBUTE of iArg DATA_LENGTH to iSize
81647>>>>>>>>>>>>>>
81647>>>>>>>>>>>>>
81647>>>>>>>>>>>>>    Get MertechInc_Pre_Size_String (iSize+1) to sReturnValue
81648>>>>>>>>>>>>>    Move (|CI$10000 * iArg) to iArg // Shift column number 16 bits to the left
81649>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function 24 CALLBACK 0 PASSING sReturnValue MertechInc_Blank iArg RESULT MertechInc_iRet
81654>>>>>>>>>>>>>
81654>>>>>>>>>>>>>    Function_Return sReturnValue
81655>>>>>>>>>>>>>End_Function
81656>>>>>>>>>>>>>
81656>>>>>>>>>>>>>//=============================================================================
81656>>>>>>>>>>>>>/// @Name        SET_SCHEMA_NAME
81656>>>>>>>>>>>>>/// @Description This command is used to set the schema name to be used when
81656>>>>>>>>>>>>>/// opening tables. Note that this command will override the schema name that
81656>>>>>>>>>>>>>/// is set in the INT file.  The default schema for the current user is used
81656>>>>>>>>>>>>>/// when no name is set.
81656>>>>>>>>>>>>>///
81656>>>>>>>>>>>>>/// @Assumptions
81656>>>>>>>>>>>>>/// @Status      Public
81656>>>>>>>>>>>>>/// @Drivers     SQLFlex and ORAFlex
81656>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-24 by Aaron Gulack
81656>>>>>>>>>>>>>/// @See                 GET_SCHEMA_NAME
81656>>>>>>>>>>>>>///
81656>>>>>>>>>>>>>/// @Syntax SET_SCHEMA_NAME to {schema}
81656>>>>>>>>>>>>>/// @Param variable                     Name of the schema
81656>>>>>>>>>>>>>///
81656>>>>>>>>>>>>>/// @Example
81656>>>>>>>>>>>>>/// SET_SCHEMA_NAME to 'CustomerSchema'
81656>>>>>>>>>>>>>/// OPEN "CUSTOMER.INT" as CUSTOMER
81656>>>>>>>>>>>>>/// SET_SCHEMA_NAME to 'SalesSchema'
81656>>>>>>>>>>>>>/// OPEN "SALESP.INT" as SALESP
81656>>>>>>>>>>>>>
81656>>>>>>>>>>>>>//=============================================================================
81656>>>>>>>>>>>>>/// @Name        GET_SCHEMA_NAME
81656>>>>>>>>>>>>>/// @Description This command is used to get the name of the schema being
81656>>>>>>>>>>>>>/// used to open tables.
81656>>>>>>>>>>>>>///
81656>>>>>>>>>>>>>/// @Assumptions
81656>>>>>>>>>>>>>/// @Status      Public
81656>>>>>>>>>>>>>/// @Drivers     SQLFlex and ORAFlex
81656>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-24 by Aaron Gulack
81656>>>>>>>>>>>>>/// @See                 SET_SCHEMA_NAME
81656>>>>>>>>>>>>>///
81656>>>>>>>>>>>>>/// @Syntax GET_SCHEMA_NAME to {variable}
81656>>>>>>>>>>>>>/// @Param variable                     variable to hold the schema name
81656>>>>>>>>>>>>>///
81656>>>>>>>>>>>>>/// @Example
81656>>>>>>>>>>>>>/// GET_SCHEMA_NAME to sName
81656>>>>>>>>>>>>>/// Showln sName
81656>>>>>>>>>>>>>
81656>>>>>>>>>>>>>//=============================================================================
81656>>>>>>>>>>>>>/// @Name        CALL_ORACLE_STORED_PROCEDURE
81656>>>>>>>>>>>>>/// @Description This command is used to call a stored procedure on the SQL
81656>>>>>>>>>>>>>/// backend. To successfully call a procedure with this command, a string
81656>>>>>>>>>>>>>/// must be passed containing a valid procedure name. In addition, if the
81656>>>>>>>>>>>>>/// procedure takes any arguments, they must also be passed using the constant
81656>>>>>>>>>>>>>/// "passing" along with all of the needed arguments. If the procedure has a
81656>>>>>>>>>>>>>/// return value, then SQL_GET_FUNCTION_RETURN or SQL_FETCH_NEXT_ROW can be
81656>>>>>>>>>>>>>/// used to get the value(s). If an error is found then the indicator "Err"
81656>>>>>>>>>>>>>/// is set to true.
81656>>>>>>>>>>>>>///
81656>>>>>>>>>>>>>/// @Assumptions
81656>>>>>>>>>>>>>/// @Status      Deprecated
81656>>>>>>>>>>>>>/// @Drivers     ORAFLex
81656>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-25 by Aaron Gulack
81656>>>>>>>>>>>>>/// @See                 CALL_STORED_PROCEDURE
81656>>>>>>>>>>>>>///
81656>>>>>>>>>>>>>/// @Syntax CALL_ORACLE_STORED_PROCEDURE {procedure} Passing {variable}
81656>>>>>>>>>>>>>/// @Param procedure            Full name of the procedure
81656>>>>>>>>>>>>>/// @Param variable                     Argument being passed to procedure (can be multiple)
81656>>>>>>>>>>>>>///
81656>>>>>>>>>>>>>/// @Example
81656>>>>>>>>>>>>>/// CALL_ORACLE_STORED_PROCEDURE "sys.sp_addmessage" passing 50003 15 "Please enter a valid date"
81656>>>>>>>>>>>>>
81656>>>>>>>>>>>>>//=============================================================================
81656>>>>>>>>>>>>>/// @Name        SQL_SET_PROCEDURE_NAME
81656>>>>>>>>>>>>>/// @Description This command is used to set the procedure to be executed.
81656>>>>>>>>>>>>>/// This is used when the procedure is being split up into multiple lines
81656>>>>>>>>>>>>>/// as shown below. When using this command, SQL_PROCEDURE_EXECUTE must be
81656>>>>>>>>>>>>>/// called after all parameters have been set to successfully execute the
81656>>>>>>>>>>>>>/// procedure. The constant "NUMPAR" is used to indicate how many parameters
81656>>>>>>>>>>>>>/// will be passed.
81656>>>>>>>>>>>>>///
81656>>>>>>>>>>>>>/// @Assumptions The procedure is a valid procedure in the SQL database
81656>>>>>>>>>>>>>/// @Status      Public
81656>>>>>>>>>>>>>/// @Drivers     All
81656>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-25 by Aaron Gulack
81656>>>>>>>>>>>>>/// @See                 SQL_SET_PROCEDURE_PARAMETER SQL_PROCEDURE_EXECUTE
81656>>>>>>>>>>>>>///
81656>>>>>>>>>>>>>/// @Syntax SQL_SET_PROCEDURE_NAME {procedure} NUMPAR {variable}
81656>>>>>>>>>>>>>/// @Param procedure            Full name of the procedure
81656>>>>>>>>>>>>>/// @Param variable                     Number of parameters to be passed
81656>>>>>>>>>>>>>///
81656>>>>>>>>>>>>>/// @Example
81656>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_NAME "sys.sp_addmessage" NUMPAR 3
81656>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to 500004 IN
81656>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 2 to 15 IN
81656>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 3 to "Please enter a valid Date" IN
81656>>>>>>>>>>>>>/// SQL_PROCEDURE_EXECUTE
81656>>>>>>>>>>>>>
81656>>>>>>>>>>>>>
81656>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_ORAPROCEDURE_NAME Global String strProcName Integer iNumpar
81658>>>>>>>>>>>>>    Integer iParam
81658>>>>>>>>>>>>>
81658>>>>>>>>>>>>>    Move 0 to MertechInc_iParamCount       //Redundant, but left in incase called
81659>>>>>>>>>>>>>    INDICATE ERR False              //directly and not via SQL_SET_PROCEDURE_NAME
81660>>>>>>>>>>>>>    Move ORAFlex to MertechInc_DriverName  //
81661>>>>>>>>>>>>>
81661>>>>>>>>>>>>>    SQL_SET_STMT to "BEGIN "
81669>>>>>>>>>>>>>    SQL_APPEND_STMT to strProcName
81677>>>>>>>>>>>>>    SQL_APPEND_STMT to "( "
81685>>>>>>>>>>>>>    For iParam from 1 to iNumpar
81691>>>>>>>>>>>>>>
81691>>>>>>>>>>>>>        DO_PASS_ARGUMENTS iParam
81723>>>>>>>>>>>>>    Loop
81724>>>>>>>>>>>>>>
81724>>>>>>>>>>>>>    SQL_APPEND_STMT to  " ); END;"
81732>>>>>>>>>>>>>    SQL_PREPARE_STMT
81744>>>>>>>>>>>>> End_Procedure
81745>>>>>>>>>>>>>
81745>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_MYPROCEDURE_NAME Global String strProcName Integer iNumpar
81747>>>>>>>>>>>>>    Integer iParam
81747>>>>>>>>>>>>>
81747>>>>>>>>>>>>>    Move 0 to MertechInc_iParamCount           //Redundant, but left in incase called
81748>>>>>>>>>>>>>    INDICATE ERR False                  //directly and not via SQL_SET_PROCEDURE_NAME
81749>>>>>>>>>>>>>    Move MySQLFlex to MertechInc_DriverName    //
81750>>>>>>>>>>>>>
81750>>>>>>>>>>>>>    SQL_SET_STMT to "CALL "
81758>>>>>>>>>>>>>    SQL_APPEND_STMT to strProcName
81766>>>>>>>>>>>>>    SQL_APPEND_STMT to "("
81774>>>>>>>>>>>>>    For iParam from 1 to iNumpar
81780>>>>>>>>>>>>>>
81780>>>>>>>>>>>>>        DO_PASS_ARGUMENTS iParam
81812>>>>>>>>>>>>>    Loop
81813>>>>>>>>>>>>>>
81813>>>>>>>>>>>>>    SQL_APPEND_STMT to ")"
81821>>>>>>>>>>>>>    SQL_PREPARE_STMT
81833>>>>>>>>>>>>>End_Procedure
81834>>>>>>>>>>>>>
81834>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_MSPROCEDURE_NAME Global String strProcName Integer iNumpar
81836>>>>>>>>>>>>>    Integer iParam
81836>>>>>>>>>>>>>    String  sParam
81836>>>>>>>>>>>>>
81836>>>>>>>>>>>>>    Move SQLFlex to MertechInc_DriverName
81837>>>>>>>>>>>>>
81837>>>>>>>>>>>>>    // This calling syntax is referred to as the "ODBC CALL escape sequence".  This syntax is
81837>>>>>>>>>>>>>    // advised over the execute command since CALL allows for the retrieval of the return codes
81837>>>>>>>>>>>>>    // from the call.
81837>>>>>>>>>>>>>    SQL_SET_STMT to "{? = CALL "
81845>>>>>>>>>>>>>    SQL_APPEND_STMT to strProcName
81853>>>>>>>>>>>>>
81853>>>>>>>>>>>>>    // Note that DO_PASS_ARGUMENTS can add the open paren for us, but only if the keyword "PASSING"
81853>>>>>>>>>>>>>    // is passed to it first time through.  This is a bit weird, so we ignore that and just add
81853>>>>>>>>>>>>>    // the open and close parens ourself to make things more clear.
81853>>>>>>>>>>>>>    If (iNumpar > 0) SQL_APPEND_STMT to " ("
81863>>>>>>>>>>>>>
81863>>>>>>>>>>>>>    For iParam from 1 to iNumpar
81869>>>>>>>>>>>>>>
81869>>>>>>>>>>>>>        DO_PASS_ARGUMENTS iParam
81901>>>>>>>>>>>>>    Loop
81902>>>>>>>>>>>>>>
81902>>>>>>>>>>>>>
81902>>>>>>>>>>>>>    If (iNumpar > 0) SQL_APPEND_STMT to ")"
81912>>>>>>>>>>>>>    SQL_APPEND_STMT to  " };"
81920>>>>>>>>>>>>>
81920>>>>>>>>>>>>>    SQL_PREPARE_STMT
81932>>>>>>>>>>>>>
81932>>>>>>>>>>>>>    // This bind parameter is for the "{? = " which is technically the first parameter even though
81932>>>>>>>>>>>>>    // it is the return value.  The driver will bind MertechInc_iWork to it.
81932>>>>>>>>>>>>>    DO_BIND_PARAMETERS MertechInc_iWork
81955>>>>>>>>>>>>>End_Procedure
81956>>>>>>>>>>>>>
81956>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_PGPROCEDURE_NAME Global String strProcName Integer iNumpar
81958>>>>>>>>>>>>>    Integer iParam
81958>>>>>>>>>>>>>    String  sParam
81958>>>>>>>>>>>>>
81958>>>>>>>>>>>>>    Move PgFlex to MertechInc_DriverName
81959>>>>>>>>>>>>>
81959>>>>>>>>>>>>>    // For Postgres, you can call a function just by passing the function name and
81959>>>>>>>>>>>>>    // open/close parens
81959>>>>>>>>>>>>>    SQL_SET_STMT to strProcName
81967>>>>>>>>>>>>>
81967>>>>>>>>>>>>>    // Note that DO_PASS_ARGUMENTS can add the open paren for us, but only if the keyword "PASSING"
81967>>>>>>>>>>>>>    // is passed to it first time through.  This is a bit weird, so we ignore that and just add
81967>>>>>>>>>>>>>    // the open and close parens ourself to make things more clear.
81967>>>>>>>>>>>>>    SQL_APPEND_STMT to "( "
81975>>>>>>>>>>>>>
81975>>>>>>>>>>>>>    For iParam from 1 to iNumpar
81981>>>>>>>>>>>>>>
81981>>>>>>>>>>>>>        DO_PASS_ARGUMENTS iParam
82013>>>>>>>>>>>>>    Loop
82014>>>>>>>>>>>>>>
82014>>>>>>>>>>>>>
82014>>>>>>>>>>>>>    SQL_APPEND_STMT to ")"
82022>>>>>>>>>>>>>
82022>>>>>>>>>>>>>    SQL_PREPARE_STMT
82034>>>>>>>>>>>>>    // Indicate that a stored function will be executed - Query = 0, Procedure = 1, Function = 2
82034>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_EMBEDDED_SQL_TYPE CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank 1 RESULT MertechInc_iRet
82039>>>>>>>>>>>>>End_Procedure
82040>>>>>>>>>>>>>
82040>>>>>>>>>>>>>//=============================================================================
82040>>>>>>>>>>>>>/// @Name        SQL_GET_STMT
82040>>>>>>>>>>>>>/// @Description This command returns the last embedded SQL statement that
82040>>>>>>>>>>>>>/// was executed into a string. Optional parameters can be passed to specify
82040>>>>>>>>>>>>>/// what character to start the string at and also the maximum number of
82040>>>>>>>>>>>>>/// characters to allow for the string.
82040>>>>>>>>>>>>>///
82040>>>>>>>>>>>>>/// @Assumptions
82040>>>>>>>>>>>>>/// @Status      Public
82040>>>>>>>>>>>>>/// @Drivers     All
82040>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-24 by Aaron Gulack
82040>>>>>>>>>>>>>/// @See                 SQL_GET_STATEMENT
82040>>>>>>>>>>>>>///
82040>>>>>>>>>>>>>/// @Syntax SQL_GET_STMT to {variable} [{max} {start}]
82040>>>>>>>>>>>>>/// @Param variable                     SQL statement to be executed
82040>>>>>>>>>>>>>/// @Param max                          Indicates the maximum number of characters to get (optional)
82040>>>>>>>>>>>>>/// @Param start                        Indicates what character to start at for the returned string (optional)
82040>>>>>>>>>>>>>///
82040>>>>>>>>>>>>>/// @Example
82040>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
82040>>>>>>>>>>>>>/// SQL_PREPARE_STMT
82040>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
82040>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sFirstName sLastName
82040>>>>>>>>>>>>>/// If (Found) Begin
82040>>>>>>>>>>>>>///     Showln sFirstName
82040>>>>>>>>>>>>>///     Showln sLastName
82040>>>>>>>>>>>>>/// End
82040>>>>>>>>>>>>>///
82040>>>>>>>>>>>>>/// SQL_GET_STATEMENT to sValue
82040>>>>>>>>>>>>>/// Showln sValue
82040>>>>>>>>>>>>>
82040>>>>>>>>>>>>>
82040>>>>>>>>>>>>>Function MertechInc_SQL_GET_STATEMENT Global Integer iLength Integer iStart Returns String
82042>>>>>>>>>>>>>    String sStatement
82042>>>>>>>>>>>>>
82042>>>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
82044>>>>>>>>>>>>>
82044>>>>>>>>>>>>>    If (MertechInc_FileNumber <> -1) Begin
82046>>>>>>>>>>>>>        Get MertechInc_Pre_Size_String 0 to sStatement
82047>>>>>>>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_GET_SQL_STMT CALLBACK 0 PASSING sStatement iStart iLength RESULT MertechInc_iRet
82052>>>>>>>>>>>>>    End
82052>>>>>>>>>>>>>>
82052>>>>>>>>>>>>>    Function_Return sStatement
82053>>>>>>>>>>>>>End_Function
82054>>>>>>>>>>>>>
82054>>>>>>>>>>>>>//=============================================================================
82054>>>>>>>>>>>>>/// @Name        SQL_SET_FUNCTION_NAME
82054>>>>>>>>>>>>>/// @Description This command is used in the same way as SQL_SET_PROCEDURE_NAME
82054>>>>>>>>>>>>>/// and SQL_SET_STMT to set the name of the function to be executed. When
82054>>>>>>>>>>>>>/// calling SQL functions in this fashion, this command must be used along with
82054>>>>>>>>>>>>>/// SQL_FUNCTION_EXECUTE (to execute the function), SQL_SET_FUNCTION_PARAMETER
82054>>>>>>>>>>>>>/// (to set the needed parameters) and SQL_GET_FUNCTION_RETURN (to get any
82054>>>>>>>>>>>>>/// returned value). The number of parameters must be set using the constant,
82054>>>>>>>>>>>>>/// NUMPAR, followed by the number of parameters. Note that when setting the
82054>>>>>>>>>>>>>/// name of the function, the user can be specified or, if left blank, the
82054>>>>>>>>>>>>>/// current user will be inserted before the function name.
82054>>>>>>>>>>>>>///
82054>>>>>>>>>>>>>/// @Assumptions
82054>>>>>>>>>>>>>/// @Status      Public
82054>>>>>>>>>>>>>/// @Drivers     All
82054>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
82054>>>>>>>>>>>>>/// @See                 SQL_FUNCTION_EXECUTE SQL_SET_FUNCTION_PARAMETER SQL_GET_FUNCTION_RETURN
82054>>>>>>>>>>>>>///
82054>>>>>>>>>>>>>/// @Syntax SQL_SET_FUNCTION_NAME {function} NUMPAR {parameters}
82054>>>>>>>>>>>>>/// @Param function                     Full name of the function
82054>>>>>>>>>>>>>/// @Param parameters           Number of parameters to pass
82054>>>>>>>>>>>>>///
82054>>>>>>>>>>>>>/// @Example
82054>>>>>>>>>>>>>/// SQL_SET_FUNCTION_NAME "getCustomerStatus" NUMPAR 1
82054>>>>>>>>>>>>>/// SQL_SET_FUNCTION_PARAMETER 1 to 'Jones' IN
82054>>>>>>>>>>>>>/// SQL_FUNCTION_EXECUTE
82054>>>>>>>>>>>>>/// SQL_GET_FUNCTION_RETURN to dDOB
82054>>>>>>>>>>>>>/// Showln dDOB
82054>>>>>>>>>>>>>
82054>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_ORAFUNCTION_NAME Global String strProcName Integer iNumpar
82056>>>>>>>>>>>>>    Integer iParam
82056>>>>>>>>>>>>>
82056>>>>>>>>>>>>>    SQL_SET_STMT to "BEGIN "
82064>>>>>>>>>>>>>    SQL_APPEND_STMT to ":PAR_RET := "
82072>>>>>>>>>>>>>    SQL_APPEND_STMT to strProcName
82080>>>>>>>>>>>>>    SQL_APPEND_STMT to "( "
82088>>>>>>>>>>>>>    For iParam from 1 to iNumpar
82094>>>>>>>>>>>>>>
82094>>>>>>>>>>>>>        DO_PASS_ARGUMENTS iParam
82126>>>>>>>>>>>>>    Loop
82127>>>>>>>>>>>>>>
82127>>>>>>>>>>>>>    SQL_APPEND_STMT to  " ); END;"
82135>>>>>>>>>>>>>    SQL_PREPARE_STMT
82147>>>>>>>>>>>>>
82147>>>>>>>>>>>>>    Move IS_OUT to MertechInc_iArg
82148>>>>>>>>>>>>>    Call_Driver 0 ORAFLEX Function CALLDRV_SET_PROC_ATTRIBUTE_TYPE CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank MertechInc_iArg RESULT MertechInc_iRet
82153>>>>>>>>>>>>>
82153>>>>>>>>>>>>>    Increment MertechInc_iParamCount
82154>>>>>>>>>>>>>    Move ":PAR_RET" to MertechInc_sArg2
82155>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_BIND_PARAMETER CALLBACK 0 PASSING MertechInc_Blank MertechInc_sArg2 16384 RESULT MertechInc_iRet
82160>>>>>>>>>>>>>End_Procedure
82161>>>>>>>>>>>>>
82161>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_MYFUNCTION_NAME Global String strProcName Integer iNumpar
82163>>>>>>>>>>>>>    Integer iParam
82163>>>>>>>>>>>>>
82163>>>>>>>>>>>>>    Move MySQLFlex to MertechInc_DriverName
82164>>>>>>>>>>>>>
82164>>>>>>>>>>>>>    SQL_SET_STMT to "SELECT "
82172>>>>>>>>>>>>>    SQL_APPEND_STMT to strProcName
82180>>>>>>>>>>>>>    SQL_APPEND_STMT to "("
82188>>>>>>>>>>>>>    For iParam from 1 to iNumpar
82194>>>>>>>>>>>>>>
82194>>>>>>>>>>>>>        DO_PASS_ARGUMENTS iParam
82226>>>>>>>>>>>>>    Loop
82227>>>>>>>>>>>>>>
82227>>>>>>>>>>>>>    SQL_APPEND_STMT to ")"
82235>>>>>>>>>>>>>    SQL_PREPARE_STMT
82247>>>>>>>>>>>>>End_Procedure
82248>>>>>>>>>>>>>
82248>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_SQLFUNCTION_NAME Global String strProcName Integer iNumpar
82250>>>>>>>>>>>>>    Integer iParam
82250>>>>>>>>>>>>>
82250>>>>>>>>>>>>>    Move SQLFlex to MertechInc_DriverName
82251>>>>>>>>>>>>>
82251>>>>>>>>>>>>>    If (not(strProcName contains ".")) Begin
82253>>>>>>>>>>>>>        String schema
82253>>>>>>>>>>>>>        GET_SCHEMA_NAME to schema
82275>>>>>>>>>>>>>        Move (schema + "." + strProcName) to strProcName
82276>>>>>>>>>>>>>    End
82276>>>>>>>>>>>>>>
82276>>>>>>>>>>>>>
82276>>>>>>>>>>>>>    SQL_SET_STMT    to "SELECT "
82284>>>>>>>>>>>>>    SQL_APPEND_STMT to strProcName
82292>>>>>>>>>>>>>    SQL_APPEND_STMT to "("
82300>>>>>>>>>>>>>End_Procedure
82301>>>>>>>>>>>>>
82301>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_PGFUNCTION_NAME Global String strProcName Integer iNumpar
82303>>>>>>>>>>>>>    Integer iParam
82303>>>>>>>>>>>>>
82303>>>>>>>>>>>>>    Move PgFlex to MertechInc_DriverName
82304>>>>>>>>>>>>>
82304>>>>>>>>>>>>>    SQL_SET_STMT    to "SELECT "
82312>>>>>>>>>>>>>    SQL_APPEND_STMT to strProcName
82320>>>>>>>>>>>>>    SQL_APPEND_STMT to "("
82328>>>>>>>>>>>>>End_Procedure
82329>>>>>>>>>>>>>
82329>>>>>>>>>>>>>//=============================================================================
82329>>>>>>>>>>>>>/// @Name        SQL_SET_PROCEDURE_PARAMETER
82329>>>>>>>>>>>>>/// @Description
82329>>>>>>>>>>>>>/// With this command you can pass one or more parameters to predefined
82329>>>>>>>>>>>>>/// stored procedures on a MySQL or Oracle server. The SQL_SET_PROCEDURE_PARAMETER
82329>>>>>>>>>>>>>/// command enables you to add a parameter to a stored procedure which you are
82329>>>>>>>>>>>>>/// planning to call. You can pass multiple parameters by calling the command
82329>>>>>>>>>>>>>/// for each parameter.
82329>>>>>>>>>>>>>///
82329>>>>>>>>>>>>>/// When passing parameters you'll have to inform the driver which variable
82329>>>>>>>>>>>>>/// you are passing, starting with 1 from left-to-right in the parameter list.
82329>>>>>>>>>>>>>///
82329>>>>>>>>>>>>>/// For each parameter you'll have to indicate if the variable is to be
82329>>>>>>>>>>>>>/// regarded as input, output or both.
82329>>>>>>>>>>>>>///
82329>>>>>>>>>>>>>///@Assumptions
82329>>>>>>>>>>>>>/// @Status      Public
82329>>>>>>>>>>>>>/// @Drivers     All
82329>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-27 by Aaron Gulack
82329>>>>>>>>>>>>>/// @See                 SQL_SET_PROCEDURE_NAME SQL_PROCEDURE_EXECUTE
82329>>>>>>>>>>>>>///
82329>>>>>>>>>>>>>/// @Syntax SQL_SET_PROCEDURE_PARAMETER {number} to {variable} {direction}
82329>>>>>>>>>>>>>/// @Param number                       Index number of the parameter being defined.
82329>>>>>>>>>>>>>/// @Param variable                     Variable holding the parameter to be passed.
82329>>>>>>>>>>>>>/// @Param direction            IN, OUT, IN_OUT, RSET, or leave blank
82329>>>>>>>>>>>>>///
82329>>>>>>>>>>>>>/// @Example
82329>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_NAME "sys.sp_addmessage" NUMPAR 3
82329>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to 500004 IN
82329>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 2 to 15 IN
82329>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 3 to "Please enter a valid Date" IN
82329>>>>>>>>>>>>>/// SQL_PROCEDURE_EXECUTE
82329>>>>>>>>>>>>>
82329>>>>>>>>>>>>>
82329>>>>>>>>>>>>>
82329>>>>>>>>>>>>>//=============================================================================
82329>>>>>>>>>>>>>/// @Name        SQL_GET_PROCEDURE_PARAMETER
82329>>>>>>>>>>>>>/// @Description This command is used to get the value of a specific
82329>>>>>>>>>>>>>/// parameter associated with a stored procedure.  Although this
82329>>>>>>>>>>>>>/// command will work with any parameter, it is mostly be used with
82329>>>>>>>>>>>>>/// IN/OUT or OUT parameters as their value will more often be important
82329>>>>>>>>>>>>>/// once returned. When multiple values are returned, this command can be
82329>>>>>>>>>>>>>/// more efficient than other options. Note that the specified parameter
82329>>>>>>>>>>>>>/// must first be defined using the SQL_SET_PROCEDURE_PARAMETER command
82329>>>>>>>>>>>>>/// in order to work properly.
82329>>>>>>>>>>>>>///
82329>>>>>>>>>>>>>/// @Assumptions
82329>>>>>>>>>>>>>/// @Status      Public
82329>>>>>>>>>>>>>/// @Drivers     All
82329>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82329>>>>>>>>>>>>>/// @See                 SQL_SET_PROCEDURE_NAME SQL_SET_PROCEDURE_PARAMETER SQL_PROCEDURE_EXECUTE
82329>>>>>>>>>>>>>///
82329>>>>>>>>>>>>>/// @Syntax SQL_GET_PROCEDURE_PARAMETER {parameter} to {variable}
82329>>>>>>>>>>>>>/// @Param parameter            Number of paramater to return
82329>>>>>>>>>>>>>/// @Param variable                     Variable to hold the value of the parameter
82329>>>>>>>>>>>>>///
82329>>>>>>>>>>>>>/// @Example
82329>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_NAME "user.getCustomerStatus" NUMPAR 1
82329>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to sCustomerID IN_OUT
82329>>>>>>>>>>>>>/// SQL_PROCEDURE_EXECUTE
82329>>>>>>>>>>>>>/// SQL_GET_PROCEDURE_PARAMETER 1 to sStatus
82329>>>>>>>>>>>>>///
82329>>>>>>>>>>>>>/// Showln sStatus
82329>>>>>>>>>>>>>///
82329>>>>>>>>>>>>>/// @Example
82329>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_NAME "user.getCustomerStatus" NUMPAR 2
82329>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to sCustomerID IN
82329>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 2 to sStatus OUT
82329>>>>>>>>>>>>>/// SQL_PROCEDURE_EXECUTE
82329>>>>>>>>>>>>>/// SQL_GET_PROCEDURE_PARAMETER 2 to sStatus
82329>>>>>>>>>>>>>///
82329>>>>>>>>>>>>>/// Showln sStatus
82329>>>>>>>>>>>>>
82329>>>>>>>>>>>>>
82329>>>>>>>>>>>>>
82329>>>>>>>>>>>>>//=============================================================================
82329>>>>>>>>>>>>>/// @Name        SQL_GET_FUNCTION_RETURN
82329>>>>>>>>>>>>>/// @Description This variable is used to get the value returned from a SQL
82329>>>>>>>>>>>>>/// function call. After the function has been successfully called, this
82329>>>>>>>>>>>>>/// command takes the returned value and inserts it the given variable.
82329>>>>>>>>>>>>>///
82329>>>>>>>>>>>>>/// @Assumptions
82329>>>>>>>>>>>>>/// @Status      Public
82329>>>>>>>>>>>>>/// @Drivers     All
82329>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
82329>>>>>>>>>>>>>/// @See                 SQL_SET_FUNCTION_NAME SQL_SET_FUNCTION_PARAMETER SQL_FUNCTION_EXECUTE
82329>>>>>>>>>>>>>///
82329>>>>>>>>>>>>>/// @Syntax SQL_GET_FUNCTION_RETURN to {variable}
82329>>>>>>>>>>>>>/// @Param variable                     Variable to hold the returned value
82329>>>>>>>>>>>>>///
82329>>>>>>>>>>>>>/// @Example
82329>>>>>>>>>>>>>/// SQL_SET_FUNCTION_NAME "getCustomerStatus" NUMPAR 1
82329>>>>>>>>>>>>>/// SQL_SET_FUNCTION_PARAMETER 1 to 'Jones' IN
82329>>>>>>>>>>>>>/// SQL_FUNCTION_EXECUTE
82329>>>>>>>>>>>>>/// SQL_GET_FUNCTION_RETURN to dDOB
82329>>>>>>>>>>>>>/// Showln dDOB
82329>>>>>>>>>>>>>
82329>>>>>>>>>>>>>//=============================================================================
82329>>>>>>>>>>>>>/// @Name        SQL_FUNCTION_EXECUTE
82329>>>>>>>>>>>>>/// @Description This command is used to execute the function statement
82329>>>>>>>>>>>>>/// that was built by the SQL_SET_FUNCTION_NAME and subsequent
82329>>>>>>>>>>>>>/// SQL_SET_FUNCTION_PARAMETER commands. This works similarly to the
82329>>>>>>>>>>>>>/// SQL_EXECUTE_STMT command. Note that executing the function with this
82329>>>>>>>>>>>>>/// command will not get any returned values but will simply execute the
82329>>>>>>>>>>>>>/// function.
82329>>>>>>>>>>>>>///
82329>>>>>>>>>>>>>/// @Assumptions
82329>>>>>>>>>>>>>/// @Status      Public
82329>>>>>>>>>>>>>/// @Drivers     All
82329>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
82329>>>>>>>>>>>>>/// @See                 SQL_SET_FUNCTION_NAME SQL_SET_FUNCTION_PARAMETER SQL_GET_FUNCTION_RETURN
82329>>>>>>>>>>>>>///
82329>>>>>>>>>>>>>/// @Syntax SQL_FUNCTION_EXECUTE
82329>>>>>>>>>>>>>///
82329>>>>>>>>>>>>>/// @Example
82329>>>>>>>>>>>>>/// SQL_SET_FUNCTION_NAME "getCustomerStatus" NUMPAR 1
82329>>>>>>>>>>>>>/// SQL_SET_FUNCTION_PARAMETER 1 to 'Jones' IN
82329>>>>>>>>>>>>>/// SQL_FUNCTION_EXECUTE
82329>>>>>>>>>>>>>/// SQL_GET_FUNCTION_RETURN to dDOB
82329>>>>>>>>>>>>>/// Showln dDOB
82329>>>>>>>>>>>>>
82329>>>>>>>>>>>>>Procedure MertechInc_SQL_FUNCTION_EXECUTE Global String sDriverName
82331>>>>>>>>>>>>>    Integer iParam
82331>>>>>>>>>>>>>    String  sParam
82331>>>>>>>>>>>>>
82331>>>>>>>>>>>>>    If (sDriverName = SQLFLEX or sDriverName = PgFlex) Begin
82333>>>>>>>>>>>>>       SQL_APPEND_STMT to ')'
82341>>>>>>>>>>>>>       SQL_PREPARE_STMT
82353>>>>>>>>>>>>>    End
82353>>>>>>>>>>>>>>
82353>>>>>>>>>>>>>
82353>>>>>>>>>>>>>    SQL_EXECUTE_STMT
82368>>>>>>>>>>>>>    If (sDriverName <> ORAFLEX) Begin
82370>>>>>>>>>>>>>        SQL_FETCH_NEXT_ROW
82385>>>>>>>>>>>>>>
82385>>>>>>>>>>>>>    End
82385>>>>>>>>>>>>>>
82385>>>>>>>>>>>>>End_Procedure
82386>>>>>>>>>>>>>
82386>>>>>>>>>>>>>//=============================================================================
82386>>>>>>>>>>>>>/// @Name        REEXEC_ORACLE_STORED_PROCEDURE
82386>>>>>>>>>>>>>/// @Description This command is used to re-execute a stored procedure
82386>>>>>>>>>>>>>/// when using Oracle. Although it follows the same format as
82386>>>>>>>>>>>>>/// CALL_STORED_PROCEDURE, it can be useful because it does not need to
82386>>>>>>>>>>>>>/// prepare the procedure again before executing. This can cause speed
82386>>>>>>>>>>>>>/// improvements when calling a stored procedure multiple times.
82386>>>>>>>>>>>>>///
82386>>>>>>>>>>>>>/// @Assumptions A procedure has already been created through CALL_STORED_PROCEDURE
82386>>>>>>>>>>>>>/// @Status      Public
82386>>>>>>>>>>>>>/// @Drivers     ORAFLex
82386>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
82386>>>>>>>>>>>>>/// @See                 CALL_STORED_PROCEDURE
82386>>>>>>>>>>>>>///
82386>>>>>>>>>>>>>/// @Syntax CALL_ORACLE_STORED_PROCEDURE {procedure} Passing {variable}
82386>>>>>>>>>>>>>/// @Param procedure            Full name of the procedure
82386>>>>>>>>>>>>>/// @Param variable                     Parameter to pass (optional and can be multiple)
82386>>>>>>>>>>>>>///
82386>>>>>>>>>>>>>/// @Example
82386>>>>>>>>>>>>>/// CALL_STORED_PROCEDURE "user.getCustomerStatus" Passing sCustomerID sStatus
82386>>>>>>>>>>>>>/// Showln sStatus
82386>>>>>>>>>>>>>///
82386>>>>>>>>>>>>>/// Move (sCustomerID + 1) to sCustomerID
82386>>>>>>>>>>>>>///
82386>>>>>>>>>>>>>/// REEXEC_ORACLE_STORED_PROCEDURE "user.getCustomerStatus" passing sCustomerID sStatus
82386>>>>>>>>>>>>>/// Showln sStatus
82386>>>>>>>>>>>>>
82386>>>>>>>>>>>>>
82386>>>>>>>>>>>>>//=============================================================================
82386>>>>>>>>>>>>>/// @Name        CALL_STORED_FUNCTION
82386>>>>>>>>>>>>>/// @Description This command is used to execute a function stored in the
82386>>>>>>>>>>>>>/// SQL backend. This is an alternative to building a function with the
82386>>>>>>>>>>>>>/// SQL_SET_FUNCTION_NAME, SQL_SET_FUNCTION_PARAMETER and SQL_FUNCTION_EXECUTE
82386>>>>>>>>>>>>>/// commands. This command builds and executes the function by setting the full
82386>>>>>>>>>>>>>/// function name, the parameter(s) to pass and the variable to hold the
82386>>>>>>>>>>>>>/// returned value. Note that this command can only return a single value
82386>>>>>>>>>>>>>/// so SQL_SET_FUNCTION_PARAMETER and SQL_SET_FUNCTION_NAME must be used when
82386>>>>>>>>>>>>>/// dealing with multiple return values.
82386>>>>>>>>>>>>>///
82386>>>>>>>>>>>>>/// Assumptions
82386>>>>>>>>>>>>>/// @Status      Public
82386>>>>>>>>>>>>>/// @Drivers     ORAFLex MySQLFlex PgFlex
82386>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
82386>>>>>>>>>>>>>/// @See
82386>>>>>>>>>>>>>///
82386>>>>>>>>>>>>>/// @Syntax CALL_STORED_FUNCTION {function} Returns {variable} Passing {parameters}
82386>>>>>>>>>>>>>/// @Param function                     Full name of the function
82386>>>>>>>>>>>>>/// @Param variable                     Variable to hold the returned value
82386>>>>>>>>>>>>>/// @Param parameters           Parameter to pass to the function (can be multiple)
82386>>>>>>>>>>>>>///
82386>>>>>>>>>>>>>/// @Example
82386>>>>>>>>>>>>>/// Move 5 to sCustomerID
82386>>>>>>>>>>>>>/// CALL_STORED_FUNCTION "getCustomerStatus" Returns sStatus Passing sCustomerID
82386>>>>>>>>>>>>>/// Showln sStatus
82386>>>>>>>>>>>>>
82386>>>>>>>>>>>>>//=============================================================================
82386>>>>>>>>>>>>>/// @Name        OUTPUT_INT_FILE
82386>>>>>>>>>>>>>/// @Description This command is used to output the int file of an opened
82386>>>>>>>>>>>>>/// table. If the file to be output to does not exist, it will be created
82386>>>>>>>>>>>>>/// upon execution of this command. Note that the INT file can be output
82386>>>>>>>>>>>>>/// into multiple types of files i.e. .doc, .txt, .int.
82386>>>>>>>>>>>>>///
82386>>>>>>>>>>>>>/// @Assumptions
82386>>>>>>>>>>>>>/// @Status      Public
82386>>>>>>>>>>>>>/// @Drivers     All
82386>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
82386>>>>>>>>>>>>>/// @See
82386>>>>>>>>>>>>>///
82386>>>>>>>>>>>>>/// @Syntax OUTPUT_INT_FILE for {FileNumber} to {variable}
82386>>>>>>>>>>>>>/// @Param FileNumber           The file number
82386>>>>>>>>>>>>>/// @Param variable                     Path of the file being output to
82386>>>>>>>>>>>>>///
82386>>>>>>>>>>>>>///@Example
82386>>>>>>>>>>>>>/// OUTPUT_INT_FILE for Customer.File_Number to "C:\Temp\Customer.int"
82386>>>>>>>>>>>>>
82386>>>>>>>>>>>>>//=============================================================================
82386>>>>>>>>>>>>>/// @Name        SQL_ERROR_MESSAGE
82386>>>>>>>>>>>>>/// @Description This command is used to get an error message
82386>>>>>>>>>>>>>/// from a given SQL statement. If the given statement is executed with
82386>>>>>>>>>>>>>/// no errors, the variable specified with this command will be blank.
82386>>>>>>>>>>>>>/// Otherwise the message will be stored in the given variable. Note that
82386>>>>>>>>>>>>>/// unless specified, strings have a size limit of 80 characters, so using
82386>>>>>>>>>>>>>/// a variant can ensure the full message is retrieved.
82386>>>>>>>>>>>>>///
82386>>>>>>>>>>>>>/// @Assumptions
82386>>>>>>>>>>>>>/// @Status      Public
82386>>>>>>>>>>>>>/// @Drivers     All
82386>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
82386>>>>>>>>>>>>>/// @See         SQL_ERROR_MESSAGE2
82386>>>>>>>>>>>>>///
82386>>>>>>>>>>>>>/// @Syntax SQL_ERROR_MESSAGE {variable}
82386>>>>>>>>>>>>>/// @Param variable                     Variable to hold the error message
82386>>>>>>>>>>>>>///
82386>>>>>>>>>>>>>/// @Example
82386>>>>>>>>>>>>>/// SQL_ERROR_MESSAGE sError
82386>>>>>>>>>>>>>
82386>>>>>>>>>>>>>Function MertechInc_SQL_ERROR_MESSAGE Global Returns String
82388>>>>>>>>>>>>>    String sMessage
82388>>>>>>>>>>>>>
82388>>>>>>>>>>>>>    Get MertechInc_Pre_Size_String 0 to sMessage
82389>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_SQL_ERROR_MESSAGE CALLBACK 0 PASSING MertechInc_Blank sMessage 0 RESULT MertechInc_iRet
82394>>>>>>>>>>>>>
82394>>>>>>>>>>>>>    Function_Return sMessage
82395>>>>>>>>>>>>>End_Function
82396>>>>>>>>>>>>>
82396>>>>>>>>>>>>>//=============================================================================
82396>>>>>>>>>>>>>/// @Name        SQL_ERROR_MESSAGE2
82396>>>>>>>>>>>>>/// @Description This command is used to get the last error message used
82396>>>>>>>>>>>>>/// for the specified server. This can be useful once a transaction has
82396>>>>>>>>>>>>>/// already been completed and any error messages need to be retrieved.
82396>>>>>>>>>>>>>///
82396>>>>>>>>>>>>>/// @Assumptions
82396>>>>>>>>>>>>>/// @Status      Public
82396>>>>>>>>>>>>>/// @Drivers     All
82396>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
82396>>>>>>>>>>>>>/// @See         SQL_ERROR_MESSAGE SQL_ERROR_MESSAGE2
82396>>>>>>>>>>>>>///
82396>>>>>>>>>>>>>/// @Syntax SQL_ERROR_MESSAGE2 of {server} to {variable}
82396>>>>>>>>>>>>>/// @Param server                       Name of the server
82396>>>>>>>>>>>>>/// @Param variable                     Variable to hold the error message
82396>>>>>>>>>>>>>///
82396>>>>>>>>>>>>>/// @Example
82396>>>>>>>>>>>>>/// SQL_ERROR_MESSAGE2 of "localhost" to sError
82396>>>>>>>>>>>>>
82396>>>>>>>>>>>>>Function MertechInc_SQL_ERROR_MESSAGE2 Global String sServer Returns String
82398>>>>>>>>>>>>>    String sMessage
82398>>>>>>>>>>>>>
82398>>>>>>>>>>>>>    Get MertechInc_Pre_Size_String 800 to sMessage
82399>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_SQL_ERROR_MESSAGE2 CALLBACK 0 PASSING sServer sMessage 0 RESULT MertechInc_iRet
82404>>>>>>>>>>>>>
82404>>>>>>>>>>>>>    Function_Return sMessage
82405>>>>>>>>>>>>>End_Function
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//=============================================================================
82406>>>>>>>>>>>>>/// @Name        MERTECH_WARNING_MESSAGE
82406>>>>>>>>>>>>>/// @Description When restructuring a table, i.e. Structure_Start, a warning
82406>>>>>>>>>>>>>/// message will appear to confirm the restructure before it is executed.
82406>>>>>>>>>>>>>/// This command is used to disable or enable that warning message. All that
82406>>>>>>>>>>>>>/// is passed is either the constant "Enabled" or "Disabled". By default,
82406>>>>>>>>>>>>>/// this message is enabled.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Assumptions
82406>>>>>>>>>>>>>/// @Status      Public
82406>>>>>>>>>>>>>/// @Drivers     All
82406>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Syntax MERTECH_WARNING_MESSAGE {Enabled|Disabled}
82406>>>>>>>>>>>>>/// @Param Enabled                      Enables the restructure warning
82406>>>>>>>>>>>>>/// @Param Disabled                     Disables the restructure warning
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Example
82406>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
82406>>>>>>>>>>>>>/// MERTECH_WARNING_MESSAGE Disabled
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// Structure_Start hFile
82406>>>>>>>>>>>>>///     Set_Attribute DF_FILE_OEM_TRANSLATION of hFile to True
82406>>>>>>>>>>>>>/// Structure_End hFile
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//=============================================================================
82406>>>>>>>>>>>>>/// @Name        DISABLE_SELECT_COLUMNS_ERRORS
82406>>>>>>>>>>>>>/// @Description When using SELECT_COLUMNS_FIND to limit the number of columns
82406>>>>>>>>>>>>>/// to fetch, the framework might still ask for columns that you do not need.
82406>>>>>>>>>>>>>/// As a result you'll end up getting runtime errors you do not want to see.
82406>>>>>>>>>>>>>/// This command gives you the ability to stop reporting errors for querying
82406>>>>>>>>>>>>>/// for data from columns that are not part of the query.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// DISABLED_SELECT_COLUMNS_ERRORS DISABLED will disable the errors, use
82406>>>>>>>>>>>>>/// ENABLED to turn the error messages back on.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// By default triggering error messages on unknown columns is ENABLED
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Assumptions
82406>>>>>>>>>>>>>/// @Status      Public
82406>>>>>>>>>>>>>/// @Drivers     All
82406>>>>>>>>>>>>>/// @VersionNote Last Revised: 2014-04-28 by Wil van Antwerpen
82406>>>>>>>>>>>>>/// @See         SELECT_COLUMNS_FIND RESET_FETCH_FIELDS
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Example
82406>>>>>>>>>>>>>/// Open Customer
82406>>>>>>>>>>>>>/// RESET_FETCH_FIELDS  CUSTOMER DF_FETCH_FALSE
82406>>>>>>>>>>>>>/// SELECT_COLUMNS_FIND CUSTOMER CUSTOMER_NUMBER NAME
82406>>>>>>>>>>>>>/// DISABLE_SELECT_COLUMNS_ERRORS DISABLED
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// Clear Customer
82406>>>>>>>>>>>>>/// Repeat
82406>>>>>>>>>>>>>///    Find Gt Customer by Index.1
82406>>>>>>>>>>>>>///    If (Found) Showln Customer.Customer_Number '-' Customer.Name
82406>>>>>>>>>>>>>/// Until (Not(Found))
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// RESET_FETCH_FIELDS Customer DF_FETCH_TRUE
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Syntax DISABLE_SELECT_COLUMNS_ERRORS {ENABLED|DISABLED}
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//=============================================================================
82406>>>>>>>>>>>>>/// @Name        SQLFlex_REVISION
82406>>>>>>>>>>>>>/// @Description This command will put the current version (decimals included)
82406>>>>>>>>>>>>>/// of the MSSQL driver associated with the current workspace into the
82406>>>>>>>>>>>>>/// specified variable.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Assumptions
82406>>>>>>>>>>>>>/// @Status      Deprecated
82406>>>>>>>>>>>>>/// @Drivers     SQLFlex
82406>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
82406>>>>>>>>>>>>>/// @See                 GET_DRIVER_REVISION
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Syntax SQLFlex_REVISION {variable}
82406>>>>>>>>>>>>>/// @Param variable                     String variable to hold the returned version
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Example
82406>>>>>>>>>>>>>/// SQLFlex_REVISION sVersion
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//=============================================================================
82406>>>>>>>>>>>>>/// @Name        SQLFlex_MAJOR_REVISION
82406>>>>>>>>>>>>>/// @Description This command will put the major version (no decimals) of
82406>>>>>>>>>>>>>/// the the MSSQL driver associated with the current workspace into the
82406>>>>>>>>>>>>>/// specified variable.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Assumptions
82406>>>>>>>>>>>>>/// @Status      Deprecated
82406>>>>>>>>>>>>>/// @Drivers     SQLFlex
82406>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
82406>>>>>>>>>>>>>/// @See                 GET_DRIVER_MAJOR_REVISION
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Syntax SQLFlex_MAJOR_REVISION {variable}
82406>>>>>>>>>>>>>/// @Param variable                     String variable to hold the returned version
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Example
82406>>>>>>>>>>>>>/// SQLFlex_MAJOR_REVISION sVersion
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//=============================================================================
82406>>>>>>>>>>>>>/// @Name        LOGGED_USERS
82406>>>>>>>>>>>>>/// @Description This command returns the number of native users that are
82406>>>>>>>>>>>>>/// using the driver currently. This number is stored in the variable that
82406>>>>>>>>>>>>>/// is passed with the command.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Assumptions
82406>>>>>>>>>>>>>/// @Status      Public
82406>>>>>>>>>>>>>/// @Drivers     All
82406>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
82406>>>>>>>>>>>>>/// @See                 MAXIMUM_NUMBER_OF_USERS
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Syntax LOGGED_USERS {variable}
82406>>>>>>>>>>>>>/// @Param variable                     Variable to hold the number of users
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Example LOGGED_USERS sUsers
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//=============================================================================
82406>>>>>>>>>>>>>/// @Name        MAXIMUM_NUMBER_OF_USERS
82406>>>>>>>>>>>>>/// @Description This command returns the maximum number of user allowed by
82406>>>>>>>>>>>>>/// the current license.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Assumptions
82406>>>>>>>>>>>>>/// @Status      Public
82406>>>>>>>>>>>>>/// @Drivers     All
82406>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
82406>>>>>>>>>>>>>/// @See                 LOGGED_USERS
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Syntax MAXIMUM_NUMBER_OF_USERS {variable}
82406>>>>>>>>>>>>>/// @Param variable                     Variable to hold the maximum number of users
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Example
82406>>>>>>>>>>>>>/// MAXIMUM_NUMBER_OF_USERS sMax
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//=============================================================================
82406>>>>>>>>>>>>>/// @Name        SET_DATABASE_NAME
82406>>>>>>>>>>>>>/// @Description This command overrides the database set in the INT file
82406>>>>>>>>>>>>>/// under DATABASE_SPACE_NAME. Any opens or finds will use the database
82406>>>>>>>>>>>>>/// specified here. This can be used when the database is not stated in
82406>>>>>>>>>>>>>/// the INT file or if the database needs to be dynamically changed for
82406>>>>>>>>>>>>>/// a certain query. If the database is not specified with this command
82406>>>>>>>>>>>>>/// or in the INT file, then the default database for the server will be
82406>>>>>>>>>>>>>/// used. To set the database to be used for embedded SQL statements,
82406>>>>>>>>>>>>>/// use SQL_USE_DATABASE.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Assumptions
82406>>>>>>>>>>>>>/// @Status      Public
82406>>>>>>>>>>>>>/// @Drivers     SQLFlex, MySQLFlex and PGFlex
82406>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82406>>>>>>>>>>>>>/// @See                 GET_DATABASE_NAME SQL_USE_DATABASE
82406>>>>>>>>>>>>>/// @INTOPT              DATABASE_SPACE_NAME
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Syntax SET_DATABASE_NAME to {database}
82406>>>>>>>>>>>>>/// @Param database                     Name of the database
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Example
82406>>>>>>>>>>>>>/// Login "localhost" "user" "pas123" "sql_drv"
82406>>>>>>>>>>>>>/// SET_DATABASE_NAME to "TestDB"
82406>>>>>>>>>>>>>/// Open Customer
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//=============================================================================
82406>>>>>>>>>>>>>/// @Name        GET_DATABASE_NAME
82406>>>>>>>>>>>>>/// @Description This command is used to get the name of the database
82406>>>>>>>>>>>>>/// currently being used. The name of the database is returned into the
82406>>>>>>>>>>>>>/// specified string. Even though this command works either way, it is
82406>>>>>>>>>>>>>/// typically used when the INT file does not contain the DATABASE_SPACE_NAME.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Assumptions
82406>>>>>>>>>>>>>/// @Status      Public
82406>>>>>>>>>>>>>/// @Drivers     SQLFlex, MySQLFlex and PgFlex
82406>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
82406>>>>>>>>>>>>>/// @See SET_DATABASE_NAME SQL_USE_DATABASE
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Syntax GET_DATABASE_NAME to {variable}
82406>>>>>>>>>>>>>/// @Param variable                     Variable to hold the database name
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Example
82406>>>>>>>>>>>>>/// GET_DATABASE_NAME to sDbName
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//=============================================================================
82406>>>>>>>>>>>>>/// @Name        GET_NAME_SPACE
82406>>>>>>>>>>>>>/// @Description This command returns the name space, or schema, being
82406>>>>>>>>>>>>>/// used with the current application.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Assumptions
82406>>>>>>>>>>>>>/// @Status      Public
82406>>>>>>>>>>>>>/// @Drivers     PgFlex
82406>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
82406>>>>>>>>>>>>>/// @See                 SET_NAME_SPACE
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Syntax GET_NAME_SPACE to {variable}
82406>>>>>>>>>>>>>/// @Param variable                     Variable to hold the returned name space.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Example
82406>>>>>>>>>>>>>/// GET_NAME_SPACE to sNameSpace
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//=============================================================================
82406>>>>>>>>>>>>>/// @Name        SET_NAME_SPACE
82406>>>>>>>>>>>>>/// @Description This command sets the name space, or schema, to be used
82406>>>>>>>>>>>>>/// for the application. In Postgres, schemas are objects where all the
82406>>>>>>>>>>>>>/// tables,views and indexes are stored. Separate schemas are used to
82406>>>>>>>>>>>>>/// specify relational data. Note that this command will override the
82406>>>>>>>>>>>>>/// NAME_SPACE value in the INT file.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Assumptions
82406>>>>>>>>>>>>>/// @Status      Public
82406>>>>>>>>>>>>>/// @Drivers     PgFlex
82406>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-14 By Ian Smith
82406>>>>>>>>>>>>>/// @See                 GET_NAME_SPACE
82406>>>>>>>>>>>>>/// @INTOPT              NAME_SPACE
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Syntax SET_NAME_SPACE to {variable}
82406>>>>>>>>>>>>>/// @Param variable                     Name of the name space
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Example
82406>>>>>>>>>>>>>/// SET_NAME_SPACE to "public"
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//=============================================================================
82406>>>>>>>>>>>>>/// @Name        SQL_USE_DATABASE
82406>>>>>>>>>>>>>/// @Description This command is used to specify which database is used
82406>>>>>>>>>>>>>/// for SQL statements only. Any normal table queries or changes will
82406>>>>>>>>>>>>>/// still use the default database, this only effects SQL statements.
82406>>>>>>>>>>>>>/// If none is specified then the default database is used. This can
82406>>>>>>>>>>>>>/// be useful if a certain SQL statement needs to query data from a
82406>>>>>>>>>>>>>/// database not currently being used. Note that this only works if
82406>>>>>>>>>>>>>/// the table name is not fully qualified in the SQl statement, i.e.
82406>>>>>>>>>>>>>/// "TestDB.Customer".
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Assumptions
82406>>>>>>>>>>>>>/// @Status      Public
82406>>>>>>>>>>>>>/// @Drivers     SQLFlex MySQLFLex PgSQL
82406>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
82406>>>>>>>>>>>>>/// @See                 SET_DATABASE_NAME GET_DATABASE_NAME
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Syntax SQL_USE_DATABASE of {server} to {database}
82406>>>>>>>>>>>>>/// @Param server                       Name of the server (Postgre only)
82406>>>>>>>>>>>>>/// @Param database                     Name of the database
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Example
82406>>>>>>>>>>>>>/// SQL_USE_DATABASE "testDB"
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
82406>>>>>>>>>>>>>/// SQL_PREPARE_STMT
82406>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
82406>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sFirstName sLastName
82406>>>>>>>>>>>>>/// If (Found) Begin
82406>>>>>>>>>>>>>///     Showln sFirstName
82406>>>>>>>>>>>>>///     Showln sLastName
82406>>>>>>>>>>>>>/// End
82406>>>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//=============================================================================
82406>>>>>>>>>>>>>/// @Name        SET_CURRENT_SQL_SERVER
82406>>>>>>>>>>>>>/// @Description This command is used to set the server to be used when
82406>>>>>>>>>>>>>/// opening tables. It will override the SERVER_NAME token in the INT file.
82406>>>>>>>>>>>>>/// If the server is not specified in the INT file or with this command,
82406>>>>>>>>>>>>>/// then the server used during login will be used. This command is only
82406>>>>>>>>>>>>>/// needed when connecting to multiple SQL servers. To set the server to
82406>>>>>>>>>>>>>/// use for embedded SQL statements, use SET_CURRENT_SQL_SERVER_CONNECTION.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Assumptions
82406>>>>>>>>>>>>>/// @Status      Public
82406>>>>>>>>>>>>>/// @Drivers     All
82406>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82406>>>>>>>>>>>>>/// @See                 GET_CURRENT_SQL_SERVER  SET_CURRENT_SQL_SERVER_CONNECTION GET_CURRENT_SQL_SERVER_CONNECTION
82406>>>>>>>>>>>>>/// @INTOPT              SERVER_NAME
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Syntax SET_CURRENT_SQL_SERVER to {server}
82406>>>>>>>>>>>>>/// @Param server                       Name of the server
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Example
82406>>>>>>>>>>>>>/// SET_CURRENT_SQL_SERVER to "localhost"
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//IGS - removed. CURRENT_SERVER is a property of Validation_List_Mixin so this
82406>>>>>>>>>>>>>//               replace conflicts with the property SET message.
82406>>>>>>>>>>>>>//#Replace SET_CURRENT_SERVER SET_CURRENT_SQL_SERVER
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//=============================================================================
82406>>>>>>>>>>>>>/// @Name        GET_CURRENT_SQL_SERVER
82406>>>>>>>>>>>>>/// @Description This command returns the name of the server to be used
82406>>>>>>>>>>>>>/// for opening and querying tables.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Assumptions
82406>>>>>>>>>>>>>/// @Status      Public
82406>>>>>>>>>>>>>/// @Drivers     All
82406>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
82406>>>>>>>>>>>>>/// @See SET_CURRENT_SQL_SERVER SET_CURRENT_SQL_SERVER_CONNECTION GET_CURRENT_SQL_SERVER_CONNECTION
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Syntax GET_CURRENT_SERVER to {variable}
82406>>>>>>>>>>>>>/// @Param variable                     Variable to hold the server name
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Example
82406>>>>>>>>>>>>>/// GET_CURRENT_SQL_SERVER to sServer
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//IGS - removed. CURRENT_SERVER is a property of Validation_List_Mixin so this
82406>>>>>>>>>>>>>//               replace conflicts with the property GET message.
82406>>>>>>>>>>>>>//#Replace GET_CURRENT_SERVER GET_CURRENT_SQL_SERVER
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//=============================================================================
82406>>>>>>>>>>>>>/// @Name        SET_CURRENT_SQL_SERVER_CONNECTION
82406>>>>>>>>>>>>>/// @Description This command is used to specify which server to use for
82406>>>>>>>>>>>>>/// embedded SQL statements. By default, the last logged in server will
82406>>>>>>>>>>>>>/// be used. Note that in addition to setting the server, this command
82406>>>>>>>>>>>>>/// also sets the driver to be used. This command is only needed when
82406>>>>>>>>>>>>>/// connecting to multiple servers. To set the server for opening tables,
82406>>>>>>>>>>>>>/// use SET_CURRENT_SQL_SERVER.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Assumptions
82406>>>>>>>>>>>>>/// @Status      Public
82406>>>>>>>>>>>>>/// @Drivers     All
82406>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82406>>>>>>>>>>>>>/// @See                 GET_CURRENT_SQL_SERVER_CONNECTION GET_CURRENT_SQL_SERVER SET_CURRENT_SQL_SERVER
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Syntax SET_CURRENT_SQL_SERVER_CONNECTION of {constant} to {server}
82406>>>>>>>>>>>>>/// @Param constant                     MYSQLFLEX, ORAFLEX, PGFLEX, or SQLFLEX
82406>>>>>>>>>>>>>/// @Param server               Name of the server
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Example
82406>>>>>>>>>>>>>/// SET_CURRENT_SQL_SERVER_CONNECTION of SQLFLEX to "(localdb)\v11.0"
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//=============================================================================
82406>>>>>>>>>>>>>/// @Name        GET_CURRENT_SQL_SERVER_CONNECTION
82406>>>>>>>>>>>>>/// @Description This command returns the server currently being used for
82406>>>>>>>>>>>>>/// embedded SQL statements.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Assumptions
82406>>>>>>>>>>>>>/// @Status      Public
82406>>>>>>>>>>>>>/// @Drivers     All
82406>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82406>>>>>>>>>>>>>/// @See                 SET_CURRENT_SQL_SERVER_CONNECTION GET_CURRENT_SQL_SERVER SET_CURRENT_SQL_SERVER
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Syntax GET_CURRENT_SQL_SERVER_CONNECTION of {constant} to {variable}
82406>>>>>>>>>>>>>/// @Param constant                     MYSQLFLEX, ORAFLEX, PGFLEX, or SQLFLEX
82406>>>>>>>>>>>>>/// @Param variable             Variable to hold the name of the server
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Example
82406>>>>>>>>>>>>>/// GET_CURRENT_SQL_SERVER_CONNECTION of SQLFLEX to sServer
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//=============================================================================
82406>>>>>>>>>>>>>/// @Name        LOGIN_SQLFLEX
82406>>>>>>>>>>>>>/// @Description This command allows the user to login with a specified
82406>>>>>>>>>>>>>/// hostname. The default hostname that is passed is the path of the
82406>>>>>>>>>>>>>/// executable. Passing a custom hostname can be very useful for tracking
82406>>>>>>>>>>>>>/// a specific user for different situations. For example, if a company
82406>>>>>>>>>>>>>/// is using a terminal server and a whole sales team logs in under the
82406>>>>>>>>>>>>>/// same username and hostname, locating a specific user could otherwise
82406>>>>>>>>>>>>>/// be difficult. With this command, each user can pass a custom hostname,
82406>>>>>>>>>>>>>/// easily distinguishing themselves from other users.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Assumptions
82406>>>>>>>>>>>>>/// @Status      Public
82406>>>>>>>>>>>>>/// @Drivers     SQLFlex
82406>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82406>>>>>>>>>>>>>/// @See
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Syntax LOGIN_SQLFLEX {server} {username} {password} {hostname}
82406>>>>>>>>>>>>>/// @Param server               Server to use for login
82406>>>>>>>>>>>>>/// @Param username     Username to use for login
82406>>>>>>>>>>>>>/// @Param password     Password to use for login
82406>>>>>>>>>>>>>/// @Param hostname     Hostname to use for login
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Example
82406>>>>>>>>>>>>>/// LOGIN_SQLFLEX "localhost" "guestUser" "pas123" "WIN-MM7PQS5CP6C"
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//=============================================================================
82406>>>>>>>>>>>>>/// @Name        SQL_CANCEL_QUERY_STMT
82406>>>>>>>>>>>>>/// @Description This command is used to close any open cursors related to
82406>>>>>>>>>>>>>/// an SQL_EXECUTE_STMT. This should be used once the SQL statement has
82406>>>>>>>>>>>>>/// been executed and all rows have been fetched.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Assumptions
82406>>>>>>>>>>>>>/// @Status      Public
82406>>>>>>>>>>>>>/// @Drivers     All
82406>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-03 by Aaron Gulack
82406>>>>>>>>>>>>>/// @See                 SQL_SET_STMT SQL_EXECUTE_STMT SQL_FETCH_NEXT_ROW SQL_APPEND_STMT SQL_PREPARE_STMT
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Syntax SQL_CANCEL_QUERY_STMT [of {FileName}]
82406>>>>>>>>>>>>>/// @Param FileName             Name of the file (optional)
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Example
82406>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
82406>>>>>>>>>>>>>/// SQL_PREPARE_STMT
82406>>>>>>>>>>>>>/// SQL_BINDCOLUMNS_STMT of Customer to DF_BIND_ALL_COLUMNS
82406>>>>>>>>>>>>>/// SQL_EXECUTE_STMT of Customer
82406>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW of Customer
82406>>>>>>>>>>>>>/// If (Found) Begin
82406>>>>>>>>>>>>>///     Showln Customer.FirstName
82406>>>>>>>>>>>>>///     Showln Customer.LastName
82406>>>>>>>>>>>>>/// End
82406>>>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT of Customer
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//=============================================================================
82406>>>>>>>>>>>>>/// @Name        NATIVE_OPTIMIZATION
82406>>>>>>>>>>>>>/// @Description Allows user to turn off the use of index hints on the native
82406>>>>>>>>>>>>>/// server. Setting this command to DEFAULT will cause the server to use the
82406>>>>>>>>>>>>>/// default settings for hints. Hints are off by default in Microsoft SQL
82406>>>>>>>>>>>>>/// Server but are on in Oracle. Care should be taken with changing the
82406>>>>>>>>>>>>>/// default, and should only be used if the diagnostics tool for your server
82406>>>>>>>>>>>>>/// indicates performance problems with the type of queries that are being
82406>>>>>>>>>>>>>/// generated. Note that this can be turned off or on for the whole server
82406>>>>>>>>>>>>>/// or just for a specific table.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// DEFAULT             - The specified server's default settings
82406>>>>>>>>>>>>>/// USE_INDEXHINT       - All Index hints will be used
82406>>>>>>>>>>>>>/// NO_INDEXHINT        - No index hints will be used
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Assumptions
82406>>>>>>>>>>>>>/// @Status      Public
82406>>>>>>>>>>>>>/// @Drivers     SQLFlex, ORAFlex
82406>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
82406>>>>>>>>>>>>>/// @See
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Syntax NATIVE_OPTIMIZATION of {scopeLevel} {variable} to {constant}
82406>>>>>>>>>>>>>/// @Param scopeLevel           TABLE or SERVER. Indicates the scope of the setting
82406>>>>>>>>>>>>>/// @Param variable                     Either the name of the server or of the table
82406>>>>>>>>>>>>>/// @Param constant                     DEFAULT, USE_INDEXHINT, or NO_INDEXHINT
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Example
82406>>>>>>>>>>>>>/// NATIVE_OPTIMIZATION of SERVER "localhost" to USE_INDEXHINT
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//=============================================================================
82406>>>>>>>>>>>>>/// @Name        SET_ISOLATION_LEVEL
82406>>>>>>>>>>>>>/// @Description This command sets the locking and row versioning behavior
82406>>>>>>>>>>>>>/// for SQL statements. See the options below for information on the various
82406>>>>>>>>>>>>>/// effects they can have on transactions.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// DEFAULT  - The default isolation level for the server (READ_COMMITTED
82406>>>>>>>>>>>>>/// for MSSQL).
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// READ_COMMITTED - This option is used to prevent dirty reads. A dirty
82406>>>>>>>>>>>>>/// read is when one transaction reads data from another transaction that
82406>>>>>>>>>>>>>/// has yet to be committed. If one transaction fails, the other now is
82406>>>>>>>>>>>>>/// dealing with invalid data. By setting the isolation level to
82406>>>>>>>>>>>>>/// READ_COMMITTED, dirty reads will be avoided by not allowing transactions
82406>>>>>>>>>>>>>/// to deal with any other data that has not been committed yet. However,
82406>>>>>>>>>>>>>/// in between statements within the current transaction, data can be changed
82406>>>>>>>>>>>>>/// by other transactions. This can result in phantom data or non-repeatable
82406>>>>>>>>>>>>>/// reads. Note that this can slow down performance speeds but is usually
82406>>>>>>>>>>>>>/// good practice.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// READ_UNCOMMITTED - This option is the least restrictive isolation level.
82406>>>>>>>>>>>>>/// With this option, dirty reads are allowed, thus no exclusive locks are
82406>>>>>>>>>>>>>/// honored and modified data from one uncommitted transaction can be read
82406>>>>>>>>>>>>>/// by other transactions.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// REPEATABLE_READ - This option is similar to the READ_COMMITTED option
82406>>>>>>>>>>>>>/// in that locks all placed on all transactions and uncommitted data from
82406>>>>>>>>>>>>>///     other transactions cannot be read, preventing dirty reads. However, unlike
82406>>>>>>>>>>>>>/// READ_COMMITTED, new rows that are added by other transactions can be read
82406>>>>>>>>>>>>>/// by the current transaction if it is retried, possibly resulting in phantom
82406>>>>>>>>>>>>>/// reads. This option should not be used unless there is a specific reason to
82406>>>>>>>>>>>>>/// do so.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// SERIALIZABLE - This option is the most restrictive isolation level. With
82406>>>>>>>>>>>>>/// this option, no interaction is allowed between transactions until they
82406>>>>>>>>>>>>>/// have been committed. Similar to READ_COMMITTED, no transaction can deal
82406>>>>>>>>>>>>>/// with any uncommitted data. On top of that though, range locks are placed on
82406>>>>>>>>>>>>>/// all rows being modified until the current transaction is complete. Because
82406>>>>>>>>>>>>>/// concurrency is so low with this option, performance speeds can be much lower
82406>>>>>>>>>>>>>/// and so this should only be used when there is a specific reason to do so.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Assumptions
82406>>>>>>>>>>>>>/// @Status      Public
82406>>>>>>>>>>>>>/// @Drivers     All
82406>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
82406>>>>>>>>>>>>>/// @See
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Syntax SET_ISOLATION_LEVEL of {server} to {constant}
82406>>>>>>>>>>>>>/// @Param server                       Name of the server
82406>>>>>>>>>>>>>/// @Param constant                     DEFAULT, READ_COMMITTED, READ_UNCOMMITTED, REPEATABLE_READ, or SERIALIZABLE
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Example
82406>>>>>>>>>>>>>/// LOGIN "localhost" "user" "pass123" "SQL_DRV"
82406>>>>>>>>>>>>>/// SET_ISOLATION_LEVEL of "localhost" to READ_COMMITTED
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//=============================================================================
82406>>>>>>>>>>>>>/// @Name        SET_SESSION_PARAMETER
82406>>>>>>>>>>>>>/// @Description There are two sets of code pages used in windows, ANSI and
82406>>>>>>>>>>>>>/// OEM. ANSI is what is commonly used now, but some data still uses the OEM
82406>>>>>>>>>>>>>/// code pages. When migrating data, this command is used to determine whether
82406>>>>>>>>>>>>>/// the OEM data will be translated to ANSI during the migration. For example,
82406>>>>>>>>>>>>>/// migrating passwords with special characters may call for different code
82406>>>>>>>>>>>>>/// pages. Sending true will convert the OEM data to ANSI, sending false will
82406>>>>>>>>>>>>>/// not. Both OEM_TO_ANSI and OEM_TRANSLATION_STATE do essentially the same
82406>>>>>>>>>>>>>/// thing, however since MSSQL has the functionality built in, OEM_TO_ANSI
82406>>>>>>>>>>>>>/// will use MSSQL's built in translation and thus only works with SQLFlex.
82406>>>>>>>>>>>>>/// OEM_TRANSLATION_STATE is internal and built into the driver so it works
82406>>>>>>>>>>>>>/// for all drivers. Note that if using custom entries with
82406>>>>>>>>>>>>>/// SET_CUSTOM_OEM_TO_ANSI then OEM_TRANSLATION_STATE must be used. Also, if
82406>>>>>>>>>>>>>/// there are already custom entries set then turning OEM_TRANSLATION_STATE
82406>>>>>>>>>>>>>/// on will automatically enable those custom translations.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Assumptions
82406>>>>>>>>>>>>>/// @Status      Public
82406>>>>>>>>>>>>>/// @Drivers     All
82406>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
82406>>>>>>>>>>>>>/// @See                 SET_CUSTOM_OEM_TO_ANSI GET_CUSTOM_OEM_TO_ANSI
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Syntax SET_SESSION_PARAMETER {OEM_TO_ANSI/OEM_TRANSLATION_STATE} to {variable}
82406>>>>>>>>>>>>>/// @Param variable                     Boolean variable enabling or disabling translation
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Example
82406>>>>>>>>>>>>>/// SET_SESSION_PARAMETER OEM_TO_ANSI to True
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>Procedure MertechInc_SET_CUSTOM_OEM_TO_ANSI Global Integer iChar Integer iOem Integer iAnsi
82408>>>>>>>>>>>>>    Move iChar to MertechInc_sArg1
82409>>>>>>>>>>>>>    move (String(iOem) + "," + String(iAnsi)) to MertechInc_sArg2
82410>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_LICENSE_ENVIRONMENT_SET CALLBACK 0 PASSING MertechInc_sArg1 MertechInc_sArg2 CALLDRV_SET_CUSTOM_OEM_TO_ANSI RESULT MertechInc_iRet
82415>>>>>>>>>>>>>    IF MertechInc_iRet EQ -1 INDICATE ERR TRUE
82418>>>>>>>>>>>>>End_Procedure
82419>>>>>>>>>>>>>
82419>>>>>>>>>>>>>//=============================================================================
82419>>>>>>>>>>>>>/// @Name        SET_CUSTOM_OEM_TO_ANSI
82419>>>>>>>>>>>>>/// @Description In very rare situations, a custom OEM to ANSI translation
82419>>>>>>>>>>>>>/// is needed. When that is the case, this command can be used to create
82419>>>>>>>>>>>>>/// those custom entries. This is done by passing the character numbered
82419>>>>>>>>>>>>>/// position, the OEM value and the ANSI value. Note that
82419>>>>>>>>>>>>>/// OEM_TRANSLATION_STATE must be set to true for these custom entries to
82419>>>>>>>>>>>>>/// work.
82419>>>>>>>>>>>>>///
82419>>>>>>>>>>>>>/// @Assumptions
82419>>>>>>>>>>>>>/// @Status      Public
82419>>>>>>>>>>>>>/// @Drivers     All
82419>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
82419>>>>>>>>>>>>>/// @See                 GET_CUSTOM_OEM_TO_ANSI SET_SESSION_PARAMETER
82419>>>>>>>>>>>>>///
82419>>>>>>>>>>>>>/// @Syntax SET_CUSTOM_OEM_TO_ANSI {character} to OEM {value1} ANSI {value2}
82419>>>>>>>>>>>>>/// @Param character            Numbered position (0-255) of the character
82419>>>>>>>>>>>>>/// @Param value1                       Character number for the OEM value
82419>>>>>>>>>>>>>/// @Param value2                       Character number for the ANSI value
82419>>>>>>>>>>>>>
82419>>>>>>>>>>>>>Procedure MertechInc_GET_CUSTOM_OEM_TO_ANSI Global Integer iChar Integer iOem Integer iAnsi
82421>>>>>>>>>>>>>    Move iChar to MertechInc_sArg1
82422>>>>>>>>>>>>>    Move (Repeat(" ", 255)) to MertechInc_sArg2
82423>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_LICENSE_ENVIRONMENT_SET CALLBACK 0 PASSING MertechInc_sArg1 MertechInc_sArg2 CALLDRV_GET_CUSTOM_OEM_TO_ANSI RESULT MertechInc_iRet
82428>>>>>>>>>>>>>    IF MertechInc_iRet EQ -1 INDICATE ERR TRUE
82431>>>>>>>>>>>>>End_Function
82432>>>>>>>>>>>>>
82432>>>>>>>>>>>>>//=============================================================================
82432>>>>>>>>>>>>>/// @Name        GET_CUSTOM_OEM_TO_ANSI
82432>>>>>>>>>>>>>/// @Description This command returns the custom OEM and ANSI values
82432>>>>>>>>>>>>>/// respectively for a given character. If there is no custom translation
82432>>>>>>>>>>>>>/// for the specified character then no error will be raised, but nothing
82432>>>>>>>>>>>>>/// will be returned.
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>/// @Assumptions There exists a custom translation for the specified character
82432>>>>>>>>>>>>>/// @Status      Public
82432>>>>>>>>>>>>>/// @Drivers     All
82432>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
82432>>>>>>>>>>>>>/// @See
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>/// @Syntax SET_CUSTOM_OEM_TO_ANSI {character} to OEM {value1} ANSI {value2}
82432>>>>>>>>>>>>>/// @Param character            Numbered position (0-255) of the character
82432>>>>>>>>>>>>>/// @Param value1                       Variable to hold the OEM value
82432>>>>>>>>>>>>>/// @Param value2                       Variable to hold the ANSI value
82432>>>>>>>>>>>>>
82432>>>>>>>>>>>>>//=============================================================================
82432>>>>>>>>>>>>>/// @Name        SET_AUTOMATIC_NUMERIC_DATATYPE_REMAPPING
82432>>>>>>>>>>>>>/// @Description This command toggles off and on the automatic numeric
82432>>>>>>>>>>>>>/// data type remapping built into SQLFlex. When adding or creating
82432>>>>>>>>>>>>>/// smaller numeric columns during a restructure, SQLFlex will change
82432>>>>>>>>>>>>>/// the type to a more specific data type i.e. smallint or tinyint since
82432>>>>>>>>>>>>>/// they are handled more efficiently by the server. Sending false to this
82432>>>>>>>>>>>>>/// command will force SQl to keep the column as a numeric field, preserving
82432>>>>>>>>>>>>>/// the length and precision. Passing true will leave the remapping up to the
82432>>>>>>>>>>>>>/// driver.
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>/// @Assumptions
82432>>>>>>>>>>>>>/// @Status      Public
82432>>>>>>>>>>>>>/// @Drivers     SQLFlex
82432>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
82432>>>>>>>>>>>>>/// @See
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>/// @Syntax SET_AUTOMATIC_NUMERIC_DATATYPE_REMAPPING to {variable}
82432>>>>>>>>>>>>>/// @Param variable                     Boolean variable enabling or disabling remapping
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>/// @Example
82432>>>>>>>>>>>>>/// Structure_Start hFile
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>///     Create_Field hFile
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>///     SET_AUTOMATIC_NUMERIC_DATATYPE_REMAPPING to False
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>///     Set_Attribute DF_FIELD_NAME   of hFile iColumn to "Transaction_Count"
82432>>>>>>>>>>>>>///     Set_Attribute DF_FIELD_TYPE   of hFile iColumn to DF_BCD
82432>>>>>>>>>>>>>///     Set_Attribute DF_FIELD_LENGTH of hFile iColumn to 1
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>/// Structure_End hFile
82432>>>>>>>>>>>>>
82432>>>>>>>>>>>>>//=============================================================================
82432>>>>>>>>>>>>>/// @Name        SET_FORCE_DATE_FORMAT_INIT
82432>>>>>>>>>>>>>/// @Description At times, a stored procedure, function or trigger may
82432>>>>>>>>>>>>>/// alter the default format for dates. This could cause problems because,
82432>>>>>>>>>>>>>/// for example, if a trigger on a table does this, then every time a save
82432>>>>>>>>>>>>>/// takes place on that table, the format for dates will be changed. By
82432>>>>>>>>>>>>>/// sending true to this command, the date formats will reset to their
82432>>>>>>>>>>>>>/// default format. Note that this is essentially the same thing as running
82432>>>>>>>>>>>>>/// the SQL statement: "ALTER SESSION SET NLS_DATE_FORMAT='MM/DD/YYYY'", so
82432>>>>>>>>>>>>>/// in most situations, that should be used instead of this command.
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>/// @Assumptions
82432>>>>>>>>>>>>>/// @Status      Deprecated
82432>>>>>>>>>>>>>/// @Drivers     ORAFlex
82432>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
82432>>>>>>>>>>>>>/// @See
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>/// @Syntax SET_FORCE_DATE_FORMAT_INIT to {variable}
82432>>>>>>>>>>>>>/// @Param variable             Boolean variable enabling or disabling format reset
82432>>>>>>>>>>>>>
82432>>>>>>>>>>>>>//=============================================================================
82432>>>>>>>>>>>>>/// @Name        SET_STATIC_TABLE_OPTIMIZATION
82432>>>>>>>>>>>>>/// @Description At this time, this command no longer serves any function.
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>/// @Assumptions
82432>>>>>>>>>>>>>/// @Status      Deprecated
82432>>>>>>>>>>>>>/// @Drivers     SQLFlex
82432>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
82432>>>>>>>>>>>>>/// @See
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>/// @Syntax SET_STATIC_TABLE_OPTIMIZATION to {ENABLED/DISABLED}
82432>>>>>>>>>>>>>
82432>>>>>>>>>>>>>//=============================================================================
82432>>>>>>>>>>>>>/// @Name        GET_MAX_OBJECT_NAME_LENGTH
82432>>>>>>>>>>>>>/// @Description This command returns the maximum length allowed for object
82432>>>>>>>>>>>>>/// names in the SQl backend. This includes table names, column names,
82432>>>>>>>>>>>>>/// database names etc. The maximum length in put into the specified variable.
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>/// @Assumptions
82432>>>>>>>>>>>>>/// @Status      Public
82432>>>>>>>>>>>>>/// @Drivers     All
82432>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
82432>>>>>>>>>>>>>/// @See
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>/// @Syntax GET_MAX_OBJECT_NAME_LENGTH to {variable}
82432>>>>>>>>>>>>>/// @Param variable                     Variable to hold the maximum length
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>/// @Example
82432>>>>>>>>>>>>>/// GET_MAX_OBJECT_NAME_LENGTH to iMaxLength
82432>>>>>>>>>>>>>
82432>>>>>>>>>>>>>//=============================================================================
82432>>>>>>>>>>>>>/// @Name        SET_SQL_LOCK_TIMEOUT
82432>>>>>>>>>>>>>/// @Description This command is used to set the number of milliseconds
82432>>>>>>>>>>>>>/// an SQL statement waits for a database lock to be released before timing
82432>>>>>>>>>>>>>/// out. Locks are used with transactions to maintain atomicity. If a lock is
82432>>>>>>>>>>>>>/// not released before the timeout, then the statement will fail and an error
82432>>>>>>>>>>>>>/// will be raised. By default, the timeout is set to -1, indicating that
82432>>>>>>>>>>>>>/// statements will wait indefinitely before timing out.
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>/// @Assumptions
82432>>>>>>>>>>>>>/// @Status      Public
82432>>>>>>>>>>>>>/// @Drivers     SQLFlex
82432>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
82432>>>>>>>>>>>>>/// @See                 GET_SQL_LOCK_TIMEOUT
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>/// @Syntax SET_SQL_LOCAL_TIMEOUT of {server} to {variable}
82432>>>>>>>>>>>>>/// @Param server                       Name of the server
82432>>>>>>>>>>>>>/// @Param variable                     Number of milliseconds to wait until timeout
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>/// @Example
82432>>>>>>>>>>>>>/// SET_SQL_LOCK_TIMEOUT of "localhost" to 6000
82432>>>>>>>>>>>>>
82432>>>>>>>>>>>>>//=============================================================================
82432>>>>>>>>>>>>>/// @Name        GET_SQL_LOCK_TIMEOUT
82432>>>>>>>>>>>>>/// @Description This command returns the number of milliseconds an SQL
82432>>>>>>>>>>>>>/// statement will wait for a database lock to be released. If the lock
82432>>>>>>>>>>>>>/// is not released before the timeout, then the statement will fail and
82432>>>>>>>>>>>>>/// an error will be raised. Note that the default value is -1, indicating
82432>>>>>>>>>>>>>/// that the statement will wait indefinitely.
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>/// @Assumptions
82432>>>>>>>>>>>>>/// @Status      Public
82432>>>>>>>>>>>>>/// @Drivers     SQLFlex
82432>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
82432>>>>>>>>>>>>>/// @See                 SET_SQL_LOCK_TIMEOUT
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>/// @Syntax GET_SQL_LOCAL_TIMEOUT of {server} to {variable}
82432>>>>>>>>>>>>>/// @Param server                       Name of the server
82432>>>>>>>>>>>>>/// @Param variable                     Variable to hold the number of milliseconds
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>/// @Example
82432>>>>>>>>>>>>>/// GET_SQL_LOCK_TIMEOUT of "localhost" to iTimeout
82432>>>>>>>>>>>>>
82432>>>>>>>>>>>>>//=============================================================================
82432>>>>>>>>>>>>>/// @Name        DO_GET_SQLSERVER_PARAMETERS
82432>>>>>>>>>>>>>/// @Description Retrieves stored procedure parameter values.
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>/// @Assumptions
82432>>>>>>>>>>>>>/// @Status      Internal
82432>>>>>>>>>>>>>/// @Drivers     All
82432>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-18 By Ian Smith
82432>>>>>>>>>>>>>/// @See
82432>>>>>>>>>>>>>
82432>>>>>>>>>>>>>Function MertechInc_DO_GET_SQLSERVER_PARAMETERS Global Integer iParameter Returns String
82434>>>>>>>>>>>>>    String sValue
82434>>>>>>>>>>>>>
82434>>>>>>>>>>>>>    Get MertechInc_Pre_Size_String 0 to sValue //Need to check if Call_Driver needs pre sized strings. Until then assume it does
82435>>>>>>>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function 24 CALLBACK 0 PASSING sValue MertechInc_Blank iParameter RESULT MertechInc_iRet
82440>>>>>>>>>>>>>
82440>>>>>>>>>>>>>    Function_Return sValue
82441>>>>>>>>>>>>>End_Function
82442>>>>>>>>>>>>>
82442>>>>>>>>>>>>>//=============================================================================
82442>>>>>>>>>>>>>/// @Name        DO_BIND_SQLSERVER_PARAMETERS
82442>>>>>>>>>>>>>/// @Description Binds parameters for stored procedure call.
82442>>>>>>>>>>>>>///
82442>>>>>>>>>>>>>/// @Assumptions
82442>>>>>>>>>>>>>/// @Status      Internal
82442>>>>>>>>>>>>>/// @Drivers     All
82442>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-18 By Ian Smith
82442>>>>>>>>>>>>>/// @See
82442>>>>>>>>>>>>>
82442>>>>>>>>>>>>>Procedure MertechInc_DO_BIND_SQLSERVER_PARAMETERS Global String sDirection String sParameter Integer iSize
82444>>>>>>>>>>>>>    Call_Driver 0 SQLFLEX Function CALLDRV_BIND_PARAMETER CALLBACK 0 PASSING sDirection sParameter iSize RESULT MertechInc_iRet
82449>>>>>>>>>>>>>End_Procedure
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        DO_CHECK_BINDING
82450>>>>>>>>>>>>>/// @Description Sets MertechInc_bThereIsBinding True if any of the
82450>>>>>>>>>>>>>/// parameters is the keyword BINDING.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Internal
82450>>>>>>>>>>>>>/// @Drivers     All
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-18 By Ian Smith
82450>>>>>>>>>>>>>/// @See
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        DO_FETCH_FIRST_ROW
82450>>>>>>>>>>>>>/// @Description Recursive - drops first parameter until the first parameter
82450>>>>>>>>>>>>>/// is BINDING and then calls SQL_FETCH_NEXT_ROW passing remaining parameters.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Internal
82450>>>>>>>>>>>>>/// @Drivers     SQLFlex
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-18 By Ian Smith
82450>>>>>>>>>>>>>/// @See
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        CALL_STORED_PROCEDURE
82450>>>>>>>>>>>>>/// @Description This command is used to call a stored procedure on the SQL
82450>>>>>>>>>>>>>/// backend. To successfully call a procedure with this command, a string
82450>>>>>>>>>>>>>/// must be passed containing a valid procedure name. In addition, if the
82450>>>>>>>>>>>>>/// procedure takes any arguments, they must also be passed using the constant
82450>>>>>>>>>>>>>/// "passing" along with all of the needed arguments. If the procedure has a
82450>>>>>>>>>>>>>/// return value, then SQL_GET_FUNCTION_RETURN or SQL_FETCH_NEXT_ROW can be
82450>>>>>>>>>>>>>/// used to get the value(s). If an error is found then the indicator "Err"
82450>>>>>>>>>>>>>/// is set to true.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     All
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-25 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax CALL_STORED_PROCEDURE {procedure} Passing {variable}
82450>>>>>>>>>>>>>/// @Param procedure            Full name of the procedure
82450>>>>>>>>>>>>>/// @Param variable                     Argument being passed (can be multiple)
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// CALL_STORED_PROCEDURE "sys.sp_addmessage" passing 50003 15 "Please enter a valid date"
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        CALL_SQLSERVER_PROCEDURE
82450>>>>>>>>>>>>>/// @Description This command is used to call a stored procedure on the SQL
82450>>>>>>>>>>>>>/// backend. To successfully call a procedure with this command, a string
82450>>>>>>>>>>>>>/// must be passed containing a valid procedure name. In addition, if the
82450>>>>>>>>>>>>>/// procedure takes any arguments, they must also be passed using the constant
82450>>>>>>>>>>>>>/// "passing" along with all of the needed arguments. If the procedure has a
82450>>>>>>>>>>>>>/// return value, then SQL_GET_FUNCTION_RETURN, SQL_FETCH_NEXT_ROW or
82450>>>>>>>>>>>>>/// GET_PROCEDURE_RETURN can be used to get the value(s). If an error is found
82450>>>>>>>>>>>>>/// then the indicator "Err" is set to true.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Status      Deprecated
82450>>>>>>>>>>>>>/// @Drivers     SQLFlex
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See                 CALL_STORED_PROCEDURE
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax CALL_SQLSERVER_PROCEDURE {procedure} Passing {variable}
82450>>>>>>>>>>>>>/// @Param procedure            Full name of the procedure
82450>>>>>>>>>>>>>/// @Param variable                     Argument to be passed (can be multiple)
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// CALL_SQLSERVER_PROCEDURE "sys.sp_addmessage" passing 50003 15 "Please enter a valid date"
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        END_CALL_PROCEDURE
82450>>>>>>>>>>>>>/// @Description This command is used to close any open cursors created
82450>>>>>>>>>>>>>/// by the respective stored procedure. Cursors are used in MSSQL to make
82450>>>>>>>>>>>>>/// the results from one procedure temporarily available to other procedures
82450>>>>>>>>>>>>>/// or triggers. To avoid causing unwanted results, it is good practice to
82450>>>>>>>>>>>>>/// use this command once a procedure call is completed.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     SQLFlex
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See                 CALL_STORED_PROCEDURE
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax END_CALL_PROCEDURE
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// CALL_STORED_PROCEDURE "sys.sp_spaceused" Passing "Customer"
82450>>>>>>>>>>>>>/// GET_PROCEDURE_RETURN to sValue
82450>>>>>>>>>>>>>/// END_CALL_PROCEDURE
82450>>>>>>>>>>>>>/// Showln sValue
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        GET_PROCEDURE_RETURN
82450>>>>>>>>>>>>>/// @Description This command is used to get a returned value from a stored
82450>>>>>>>>>>>>>/// procedure using MSSQL. Note that this command can only handle one
82450>>>>>>>>>>>>>/// returned value and must be used after the procedure has already been
82450>>>>>>>>>>>>>/// built and executed.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     SQLFlex
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax GET_PROCEDURE_RETURN to {variable}
82450>>>>>>>>>>>>>/// @Param variable             Variable to hold the returned value
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_NAME "sys.sp_spaceused" NUMPAR 1
82450>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to "Customer" IN
82450>>>>>>>>>>>>>/// SQL_PROCEDURE_EXECUTE
82450>>>>>>>>>>>>>/// GET_PROCEDURE_RETURN to sSpaceUsed
82450>>>>>>>>>>>>>/// Showln sSpaceUsed
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        SET_MIRROR_SERVER
82450>>>>>>>>>>>>>/// @Description This command is used to programmatically set the mirror
82450>>>>>>>>>>>>>/// server for the database. This is to be used along with SQl server
82450>>>>>>>>>>>>>/// failover mirroring. Note that this simply sets the server and database
82450>>>>>>>>>>>>>/// to be used for mirroring. All set up for the servers must already be
82450>>>>>>>>>>>>>/// working properly through SQL Server.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions A compatible version of SQL Server is being used
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     SQLFlex v9.2 and above
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See                 GET_MIRROR_SERVER
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax SET_MIRROR_SERVER to {server} {database}
82450>>>>>>>>>>>>>/// @Param server                       The name of the mirror server
82450>>>>>>>>>>>>>/// @Param database                     The database acting as a mirror
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// SET_MIRROR_SERVER to "(localdb)\v11.0" "MirrorDB"
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        GET_MIRROR_SERVER
82450>>>>>>>>>>>>>/// @Description This command is used to get the name of the server
82450>>>>>>>>>>>>>/// and database being used for failover mirroring. Mirroring must
82450>>>>>>>>>>>>>/// be properly set up in SQL Server for this command to return the
82450>>>>>>>>>>>>>/// correct values.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     SQLFlex v9.2 and above
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See                 SET_MIRROR_SERVER
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax GET_MIRROR_SERVER to {server} {database}
82450>>>>>>>>>>>>>/// @Param server                       Variable to hold the name of the mirrored server
82450>>>>>>>>>>>>>/// @Param database                     Variable to hold the name of the mirrored database
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// GET_MIRROR_SERVER to sServer sDatabase
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        COPY_DATA
82450>>>>>>>>>>>>>/// @Description This command is used to copy data from a DAT file to an
82450>>>>>>>>>>>>>/// SQL table. Both the source and the destination files are opened, the
82450>>>>>>>>>>>>>/// data is copied and then the files are closed. This is usually used
82450>>>>>>>>>>>>>/// along with CREATE_TABLE_FROM_DAT_FILE, which creates the structure
82450>>>>>>>>>>>>>/// and then this command will insert the data. If needed, this command
82450>>>>>>>>>>>>>/// can also work backwards, copying data from an SQL table to a DAT file.
82450>>>>>>>>>>>>>/// This is an alternative to using the Flex2SQL Migration Tool and can
82450>>>>>>>>>>>>>/// improve performance when used in the right situations. Note that in
82450>>>>>>>>>>>>>/// order for this process to work properly the table being copied can not
82450>>>>>>>>>>>>>/// be opened. Because of this, a manual login must take place, using
82450>>>>>>>>>>>>>/// something like LOGIN_SQLFLEX or LOGIN. Since this only copies the data,
82450>>>>>>>>>>>>>/// CREATE_TABLE_FROM_DAT_FILE can be used to create the table structure.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// Because COPY_DATA requires no user interaction, an optional callback
82450>>>>>>>>>>>>>/// function can be passed for tracing purposes. By passing the constant
82450>>>>>>>>>>>>>/// "CALLBACK" followed by the object name, a function can be used to set
82450>>>>>>>>>>>>>/// up messages for tracking and error handling. Below is more information
82450>>>>>>>>>>>>>/// regarding this callback object.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// This function should follow this pattern:
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// Function Callback String sText Integer iStatusID Returns Integer
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// sText - Message corresponding to the current status ID
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// iStatusID - Integer value mapping to the current status constant:
82450>>>>>>>>>>>>>///                     DF_MESSAGE_PROGRESS_TITLE    Sent when SQLFlex starts the
82450>>>>>>>>>>>>>///                                                                              process
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>///             DF_MESSAGE_HEADING_1         Sent when SQLFlex is about to
82450>>>>>>>>>>>>>///                                                                              copy the source data
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>///             DF_MESSAGE_ERROR             Sent when an error occurs
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>///             DF_MESSAGE_PROGRESS_STATUS   Sent each time an additional
82450>>>>>>>>>>>>>///                                                                              10% of the data is copied
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// NOTE: Returning false each time the function is called will continue
82450>>>>>>>>>>>>>/// copying process. Returning true will end it.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// Another optional parameter that can be used is a constrain on the data
82450>>>>>>>>>>>>>/// being copied. This is done by passing the constant "CONSTRAIN" followed
82450>>>>>>>>>>>>>/// by an SQL constrain statement. When passing a constrain but not a callback
82450>>>>>>>>>>>>>/// object, pass 0 for the callback before passsing the constrain.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     All
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See                 CREATE_TABLE_FROM_DAT_FILE CONVERT_DAT_FILE
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax COPY_DATA {from} to {destination} [CALLBACK {function}] [CONSTRAIN {variable}]
82450>>>>>>>>>>>>>/// @Param from                         Table to copy from.
82450>>>>>>>>>>>>>/// @Param destination          Table to copy to.
82450>>>>>>>>>>>>>/// @Param function             Object with callback function (optional)
82450>>>>>>>>>>>>>/// @Param variable                     SQL contraint to use when copying (optional)
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// Object CallBackObj is a Array
82450>>>>>>>>>>>>>///     Function Callback String sText Integer iLogicalID Returns Integer
82450>>>>>>>>>>>>>///         If (iLogicalID = DF_MESSAGE_ERROR) Begin
82450>>>>>>>>>>>>>///             Showln "Error"
82450>>>>>>>>>>>>>///                             Showln sText
82450>>>>>>>>>>>>>///                             Function_Return True
82450>>>>>>>>>>>>>///         End
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>///         Else Showln sText
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>///                     Function_Return False
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>///     End_Function
82450>>>>>>>>>>>>>/// End_Object
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// Login "localhost" "user" "pass123" "sql_drv"
82450>>>>>>>>>>>>>/// CREATE_TABLE_FROM_DAT_FILE Customer.File_Number "Customer"
82450>>>>>>>>>>>>>/// COPY_DATA "Customer" to "sql_drv:Customer" CALLBACK (Callback(Self)) CONSTRAIN "STATUS = 'Active'"
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        ORAFlex_REVISION
82450>>>>>>>>>>>>>/// @Description This command will put the current version (decimals included)
82450>>>>>>>>>>>>>/// of the Oracle driver associated with the current workspace into the specified
82450>>>>>>>>>>>>>/// variable.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Deprecated
82450>>>>>>>>>>>>>/// @Drivers     ORAFlex
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See                 GET_DRIVER_REVISION
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax ORAFlex_REVISION {variable}
82450>>>>>>>>>>>>>/// @Param variable                     String variable to hold the returned version
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// ORAFlex_REVISION sVersion
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        KEEP_FILES_OPEN
82450>>>>>>>>>>>>>/// @Description Keep the files, currently in use, open after the server is
82450>>>>>>>>>>>>>/// logged out. Sometimes an application needs to login to the same server
82450>>>>>>>>>>>>>/// with a different user id. When logging out, however, the drivers
82450>>>>>>>>>>>>>/// automatically close all opened files. The overhead of opening these files
82450>>>>>>>>>>>>>/// should be avoided if the user will work with the same files that were
82450>>>>>>>>>>>>>/// closed. KEEP_FILES_OPEN keeps all files opened after a user logs out
82450>>>>>>>>>>>>>/// from the server.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Status      Deprecated
82450>>>>>>>>>>>>>/// @Drivers     All
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax KEEP_FILES_OPEN of {server}
82450>>>>>>>>>>>>>/// @Param server               Name of the server
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        SET_MAX_OPEN_CURSORS
82450>>>>>>>>>>>>>/// @Description Set the maximum number of cursors you want the driver to use.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// The driver will recycle the least used cursors if this limit is hit.
82450>>>>>>>>>>>>>/// The trade off is between increased resources on the server and
82450>>>>>>>>>>>>>/// re-preparing of cursors.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// For a program that keeps 40+ files opened at the same time, 255 is a good
82450>>>>>>>>>>>>>/// number for the open cursors parameter. For programs that open less than
82450>>>>>>>>>>>>>/// 40 files, any number between 100-255 is sufficient. These numbers can be
82450>>>>>>>>>>>>>/// changed based on available server resources.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// On Oracle this value should not exceed the value of open_cursors in
82450>>>>>>>>>>>>>/// init.ora
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// Note: Only change this setting if you are having performance issues
82450>>>>>>>>>>>>>/// and the server is indicating you are using up too many cursors or too
82450>>>>>>>>>>>>>/// much memory. GET_OPENED_CURSORS can be used to check the number of
82450>>>>>>>>>>>>>/// cursors the server has opened. If this number is hitting the limit,
82450>>>>>>>>>>>>>/// it is worth increasing the number, as long as the server has enough
82450>>>>>>>>>>>>>/// resources.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     All
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See         GET_MAX_OPEN_CURSORS GET_OPENED_CURSORS
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax SET_MAX_OPEN_CURSORS of {server} to {variable}
82450>>>>>>>>>>>>>/// @Param server                       The name of the server
82450>>>>>>>>>>>>>/// @Param variable                     Maximum number of cursors
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        GET_MAX_OPEN_CURSORS
82450>>>>>>>>>>>>>/// @Description This command will return the maximum number of open
82450>>>>>>>>>>>>>/// cursors allowed by the server.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     All
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See         SET_MAX_OPEN_CURSORS GET_OPENED_CURSORS
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax GET_MAX_OPEN_CURSORS of {server} to {variable}
82450>>>>>>>>>>>>>/// @Param server                       Name of the server
82450>>>>>>>>>>>>>/// @Param variable                     Variable to hold the maximum number of open cursors
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        GET_OPENED_CURSORS
82450>>>>>>>>>>>>>/// @Description This command returns the number of cursors currently
82450>>>>>>>>>>>>>/// open on the server.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     All
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See         SET_MAX_OPEN_CURSORS GET_MAX_OPEN_CURSORS
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax GET_MAX_OPEN_CURSORS of {server} to {variable}
82450>>>>>>>>>>>>>/// @Param server                       Name of the server
82450>>>>>>>>>>>>>/// @Param variable                     Variable to hold the number of cursors currently open
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        ACTIVATE_TIME_STAMP
82450>>>>>>>>>>>>>/// @Description This command will specify whether or not to show the time
82450>>>>>>>>>>>>>/// portion of a date field. When set to ON, the time portion will be
82450>>>>>>>>>>>>>/// included, OFF will just show the date. This is the same as changing
82450>>>>>>>>>>>>>/// the date format with "ALTER SESSION SET nls_timestamp_format". Note that
82450>>>>>>>>>>>>>/// this will only take effect if the date is put into a string variable.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Deprecated
82450>>>>>>>>>>>>>/// @Drivers     OraFlex
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax ACTIVATE_TIME_STAMP of {server} to {ON/OFF}
82450>>>>>>>>>>>>>/// @Param server                       Name of the server
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// ACTIVATE_TIME_STAMP of "localhost/orcl.localdomain" to OFF
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// SQL_SET_STMT to 'SELECT * from USER."Customer" '
82450>>>>>>>>>>>>>/// SQL_PREPARE_STMT
82450>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
82450>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sFirstName sLastName sDOB
82450>>>>>>>>>>>>>/// If (Found) Begin
82450>>>>>>>>>>>>>///     Showln sDOB
82450>>>>>>>>>>>>>/// End
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        CALL_ORACLE_STORED_FUNCTION
82450>>>>>>>>>>>>>/// @Description This command is used to execute a function stored in Oracle.
82450>>>>>>>>>>>>>/// This is an alternative to building a function with the SQL_SET_FUNCTION_NAME,
82450>>>>>>>>>>>>>/// SQL_SET_FUNCTION_PARAMETER and SQL_FUNCTION_EXECUTE commands. This command
82450>>>>>>>>>>>>>/// builds and executes the function by setting the full function name, the
82450>>>>>>>>>>>>>/// parameter(s) to pass and the variable to hold the returned value. Note that
82450>>>>>>>>>>>>>/// this command can only return a single value so SQL_SET_FUNCTION_PARAMETER
82450>>>>>>>>>>>>>/// and SQL_SET_FUNCTION_NAME must be used when dealing with multiple return
82450>>>>>>>>>>>>>/// values.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Status      Deprecated
82450>>>>>>>>>>>>>/// @Drivers     ORAFLex
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See                 CALL_STORED_FUNCTION
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax CALL_ORACLE_STORED_FUNCTION {function} Returns {variable} Passing {argument}
82450>>>>>>>>>>>>>/// @Param function                     Full name of the function
82450>>>>>>>>>>>>>/// @Param variable                     Variable to hold the returned value
82450>>>>>>>>>>>>>/// @Param argument                     Argument to pass (can be multiple)
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// CALL_ORACLE_STORED_FUNCTION "user.getCustomerStatus" Returns sStatus passing sCustomerID
82450>>>>>>>>>>>>>/// Showln sStatus
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        CALL_PGSQL_STORED_FUNCTION
82450>>>>>>>>>>>>>/// @Description This command is used to execute a function stored in Oracle.
82450>>>>>>>>>>>>>/// This is an alternative to building a function with the SQL_SET_FUNCTION_NAME,
82450>>>>>>>>>>>>>/// SQL_SET_FUNCTION_PARAMETER and SQL_FUNCTION_EXECUTE commands. This command
82450>>>>>>>>>>>>>/// builds and executes the function by setting the full function name, the
82450>>>>>>>>>>>>>/// parameter(s) to pass and the variable to hold the returned value. Note that
82450>>>>>>>>>>>>>/// this command can only return a single value so SQL_SET_FUNCTION_PARAMETER
82450>>>>>>>>>>>>>/// and SQL_SET_FUNCTION_NAME must be used when dealing with multiple return
82450>>>>>>>>>>>>>/// values.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Status      Deprecated
82450>>>>>>>>>>>>>/// @Drivers     PGFlex
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See                 CALL_STORED_FUNCTION
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax CALL_PGSQL_STORED_FUNCTION {function} Returns {variable} Passing {argument}
82450>>>>>>>>>>>>>/// @Param function                     Full name of the function
82450>>>>>>>>>>>>>/// @Param variable                     Variable to hold the returned value
82450>>>>>>>>>>>>>/// @Param argument                     Argument to pass (can be multiple)
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// CALL_PGSQL_STORED_FUNCTION "user.getCustomerStatus" Returns sStatus passing sCustomerID
82450>>>>>>>>>>>>>/// Showln sStatus
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        MERTECH_LANGUAGE_SUPPORT
82450>>>>>>>>>>>>>/// @Description Sets the support language for the driver.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Internal
82450>>>>>>>>>>>>>/// @Drivers     ORAFLex
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax MERTECH_LANGUAGE_SUPPORT of {server} to {language}
82450>>>>>>>>>>>>>/// @Param server               The name of the server being used
82450>>>>>>>>>>>>>/// @Param language             The language to set support to
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        SQL_SAVE_BUFFER_BEGIN
82450>>>>>>>>>>>>>/// @Description This command is used to initialize a SAVE_BUFFER
82450>>>>>>>>>>>>>/// statement. Doing this will allow a specified set of records to be
82450>>>>>>>>>>>>>/// stored in the buffer before a save takes place. Once the buffer is
82450>>>>>>>>>>>>>/// filled, it will be saved automatically. This set of commands can be
82450>>>>>>>>>>>>>/// used to efficiently save a large number of records. Once the buffer
82450>>>>>>>>>>>>>/// is full, the save occurs automatically and the buffer will be emptied
82450>>>>>>>>>>>>>/// out. It is good practice to use this method inside of a transaction to
82450>>>>>>>>>>>>>/// maintain atomicity. Note that these commands should not be used in
82450>>>>>>>>>>>>>/// conjuction with finds.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     All
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See         SQL_SAVE_BUFFER_END SQL_SAVE_BUFFER
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax SQL_SAVE_BUFFER_BEGIN of {FileName} to {variable}
82450>>>>>>>>>>>>>/// @Param FileName                     Name of the file
82450>>>>>>>>>>>>>/// @Param variable                     Number of records to store in the buffer
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// Open Customer
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// SQL_SAVE_BUFFER_BEGIN of Transactions to 10
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// For i from 0 to 1000
82450>>>>>>>>>>>>>///     Move i to Transactions.ID
82450>>>>>>>>>>>>>///     SQL_SAVE_BUFFER of Transactions
82450>>>>>>>>>>>>>/// Loop
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// SQL_SAVE_BUFFER_END of Customer
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        SQL_SAVE_BUFFER
82450>>>>>>>>>>>>>/// @Description This command is used to send a record to the "Save
82450>>>>>>>>>>>>>/// Record" buffer. It must be used along with SQL_SAVE_BUFFER_BEGIN
82450>>>>>>>>>>>>>/// and SQL_SAVE_BUFFER_END. SQL_SAVE_BUFFER_BEGIN sets the number of
82450>>>>>>>>>>>>>/// records to store in the buffer before a save is done on all the records
82450>>>>>>>>>>>>>/// at once. Each time a record is created, this command should be called
82450>>>>>>>>>>>>>/// to insert it into the buffer. Using this set of commands can be useful
82450>>>>>>>>>>>>>/// to efficiently save a large number of records. Once the buffer is full,
82450>>>>>>>>>>>>>/// the save occurs automatically and the buffer will be emptied out. It is
82450>>>>>>>>>>>>>/// good practice to use this method inside of a transaction to maintain
82450>>>>>>>>>>>>>/// atomicity.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     All
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See                 SQL_SAVE_BUFFER_BEGIN SQL_SAVE_BUFFER_END
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax SQL_SAVE_BUFFER of {FileName}
82450>>>>>>>>>>>>>/// @Param FileName                     Name of the file
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// Open Customer
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// SQL_SAVE_BUFFER_BEGIN of Transactions to 10
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// For i from 0 to 1000
82450>>>>>>>>>>>>>///     Move i to Transactions.ID
82450>>>>>>>>>>>>>///     SQL_SAVE_BUFFER of Transactions
82450>>>>>>>>>>>>>/// Loop
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// SQL_SAVE_BUFFER_END of Customer
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        SQL_SAVE_BUFFER_END
82450>>>>>>>>>>>>>/// @Description This command indicates the end of the extended record
82450>>>>>>>>>>>>>/// buffer and forces a save of any data currently in the buffer.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     All
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See         SQL_SAVE_BUFFER_BEGIN SQL_SAVE_BUFFER
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax SQL_SAVE_BUFFER_END of {FileName}
82450>>>>>>>>>>>>>/// @Param FileName                     Name of the file
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// Open Customer
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// SQL_SAVE_BUFFER_BEGIN of Transactions to 10
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// For i from 0 to 1000
82450>>>>>>>>>>>>>///     Move i to Transactions.ID
82450>>>>>>>>>>>>>///     SQL_SAVE_BUFFER of Transactions
82450>>>>>>>>>>>>>/// Loop
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// SQL_SAVE_BUFFER_END of Customer
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        SQL_SAVE_SET_ATTRIBUTES
82450>>>>>>>>>>>>>/// @Description Unknown - Not in help - Not call by any other macros
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Internal
82450>>>>>>>>>>>>>/// @Drivers     SQLFlex
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-18 By Ian Smith
82450>>>>>>>>>>>>>/// @See
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        ENABLE_TRACE_ON
82450>>>>>>>>>>>>>/// @Description This command enables driver level tracing to the
82450>>>>>>>>>>>>>/// specified file. Enabling trace on an application and using it
82450>>>>>>>>>>>>>/// in conjunction with SQL_TEXT_MESSAGE is a good way to study
82450>>>>>>>>>>>>>/// particular problems you encounter in the driver. SQL_TEXT_MESSAGE
82450>>>>>>>>>>>>>/// allows you to insert sections of your code into the trace file.
82450>>>>>>>>>>>>>/// This command can also set the trace to three different levels,
82450>>>>>>>>>>>>>/// allowing different amounts of information to be logged. Note that
82450>>>>>>>>>>>>>/// trace files can become very large so it is good practice to only
82450>>>>>>>>>>>>>/// turn them on when specifically needed.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     All
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See                 DISABLE_TRACE_ON SQL_TEXT_MESSAGE
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax ENABLE_TRACE_ON to {fileName} Debug_Level [{constant}]
82450>>>>>>>>>>>>>/// @Param fileName                     The path of the file to send the trace to
82450>>>>>>>>>>>>>/// @Param constant             DETAIL_LEVEL1, DETAIL_LEVEL2, DETAIL_LEVEL3 (optional)
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example ENABLE_TRACE_ON TO "C:\Temp\trace_file.txt" Debug_Level DETAIL_LEVEL3
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        DISABLE_TRACE_ON
82450>>>>>>>>>>>>>/// @Description This command disables the current trace taking
82450>>>>>>>>>>>>>/// place on a driver.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     All
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See ENABLE_TRACE_ON SQL_TEXT_MESSAGE
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax DISABLE_TRACE_ON
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        CREATE_TABLE_FROM_DAT_FILE
82450>>>>>>>>>>>>>/// @Description This command is used to create a SQL table from a .DAT
82450>>>>>>>>>>>>>/// file. The table being copied must be not be opened in order for this
82450>>>>>>>>>>>>>/// command to work properly. This is the programmatic equivalent to
82450>>>>>>>>>>>>>/// using the Flex2SQL Migration Tool. Optional restructuring options
82450>>>>>>>>>>>>>/// can be specified here (see below) as well as an alternative table
82450>>>>>>>>>>>>>/// name than the physical name of the .DAT file. Note that this only
82450>>>>>>>>>>>>>/// creates the  table structure, no data will be copied here. To copy
82450>>>>>>>>>>>>>/// the data, use COPY_DATA after the table has been created.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// DF_STRUCTEND_OPT_FORCE_INVK         - Deprecated
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// DF_STRUCTEND_OPT_OLD_INVK_NAME      - Deprecated
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// DF_STRUCTEND_OPT_FORCE_NOT_NULL - forces all fields to be created as NOT NULL.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     All
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See                 COPY_DATA CONVERT_DAT_FILE
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax CREATE_TABLE_FROM_DAT_FILE {FileNumber} [{options} {table}]
82450>>>>>>>>>>>>>/// @Param FileNumber           Number of the file
82450>>>>>>>>>>>>>/// @Param options                      DF_STRUCTEND_OPT_FORCE_INVK
82450>>>>>>>>>>>>>///                                                     DF_STRUCTEND_OPT_OLD_INVK_NAME
82450>>>>>>>>>>>>>///                                                     DF_STRUCTEND_OPT_FORCE_NOT_NULL (optional)
82450>>>>>>>>>>>>>/// @Param table            name of table to use instead of physical name (optional)
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// Login "localhost" "user" "pass123" "sql_drv"
82450>>>>>>>>>>>>>/// CREATE_TABLE_FROM_DAT_FILE Customer.File_Number "Customer"
82450>>>>>>>>>>>>>/// COPY_DATA "Customer" to "sql_drv:Customer" CALLBACK (Callback(Self)) CONSTRAIN "STATUS = 'Active'"
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        CONVERT_DAT_FILE
82450>>>>>>>>>>>>>/// @Description This command is the programmatic equivalent to the
82450>>>>>>>>>>>>>/// Flex2SQL Migration Tool. With this command, a SQL table can be
82450>>>>>>>>>>>>>/// created from a .DAT table. This combines the COPY_DATA and
82450>>>>>>>>>>>>>/// CREATE_TABLE_FROM_DAT_FILE, creating the table structure and
82450>>>>>>>>>>>>>/// copying all the data into the new table with one command. The
82450>>>>>>>>>>>>>/// table being converted cannot be opened and so a manual login is
82450>>>>>>>>>>>>>/// needed. Note that to specify the database to copy the table to,
82450>>>>>>>>>>>>>/// use SET_DATABASE_NAME. Below is a list of the optional restructure
82450>>>>>>>>>>>>>/// options to use when creating the table.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// DF_STRUCTEND_OPT_FORCE_INVK         - Deprecated
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// DF_STRUCTEND_OPT_OLD_INVK_NAME      - Deprecated
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// DF_STRUCTEND_OPT_FORCE_NOT_NULL - forces all fields to be created as NOT NULL.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     All
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See                 CREATE_TABLE_FROM_DAT_FILE COPY_DATA
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax CONVERT_DAT_FILE {FileNumber} [{options} {table}]
82450>>>>>>>>>>>>>/// @Param FileNumber           Number of the file
82450>>>>>>>>>>>>>/// @Param options                      DF_STRUCTEND_OPT_FORCE_INVK
82450>>>>>>>>>>>>>///                                                     DF_STRUCTEND_OPT_OLD_INVK_NAME
82450>>>>>>>>>>>>>///                                                     DF_STRUCTEND_OPT_FORCE_NOT_NULL (optional)
82450>>>>>>>>>>>>>/// @Param table            Name of table to use instead of physical name (optional)
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// Login "localhost" "user" "pass123" "sql_drv"
82450>>>>>>>>>>>>>/// CONVERT_DAT_FILE Customer.File_Number DF_STRUCTEND_OPT_FORCE_NOT_NULL "Customer"
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        SET_DEFAULT_FILE_CASING
82450>>>>>>>>>>>>>/// @Description This command is used to set the file casing standard when
82450>>>>>>>>>>>>>/// creating or restructuring tables. By default, all table and column names
82450>>>>>>>>>>>>>/// are created using the specified casing. Passing FILE_CASING_UPPER or
82450>>>>>>>>>>>>>/// FILE_CASING_LOWER will allow the names to be saved in uppercase or
82450>>>>>>>>>>>>>/// lowercase respectively. This can be useful for backwards compatibility
82450>>>>>>>>>>>>>/// where casing was important. Note that the casing standard for a file can
82450>>>>>>>>>>>>>/// also be changed through mertech.ini. Below is a description of the constants
82450>>>>>>>>>>>>>/// that can be passed to this command.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// FILE_CASING_UPPER : All created or edited object names will be converted to uppercase.
82450>>>>>>>>>>>>>/// FILE_CASING_LOWER : All created or edited object names will be converted to lowercase.
82450>>>>>>>>>>>>>/// FILE_CASING_KEEP (default) : All created or edited object names will maintain their inputed casing.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     All
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See                 GET_DEFAULT_FILE_CASING
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax SET_DEFAULT_FILE_CASING to {constant}
82450>>>>>>>>>>>>>/// @Param constant                     FILE_CASING_UPPER, FILE_CASING_LOWER, FILE_CASING_KEEP
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// SET_DEFAULT_FILE_CASING to FILE_CASING_UPPER
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        GET_DEFAULT_FILE_CASING
82450>>>>>>>>>>>>>/// @Description This command returns the file casing standard used
82450>>>>>>>>>>>>>/// when creating or restructuring tables. Note that an integer is returned,
82450>>>>>>>>>>>>>/// mapping to a casing method. Below are the meanings of the possible
82450>>>>>>>>>>>>>/// returned integers.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// 0 - FILE_CASING_UPPER : All created or edited object names will be converted to uppercase.
82450>>>>>>>>>>>>>/// 1 - FILE_CASING_LOWER : All created or edited object names will be converted to lowercase.
82450>>>>>>>>>>>>>/// 2 - FILE_CASING_KEEP : All created or edited object names will maintain their inputed casing.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     All
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See                 SET_DEFAULT_FILE_CASING
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax GET_DEFAULT_FILE_CASING to {variable}
82450>>>>>>>>>>>>>/// @Param variable                     Variable to hold the returned casing
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// GET_DEFAULT_FILE_CASING TO iCasing
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        SET_DEFAULT_TABLESPACE
82450>>>>>>>>>>>>>/// @Description This command sets the default table space to use when
82450>>>>>>>>>>>>>/// creating tables through Dataflex. A tablespace is a container of
82450>>>>>>>>>>>>>/// segments (objects that have an allotted amount of space), i.e. tables
82450>>>>>>>>>>>>>/// and indexes.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     ORAFlex, PgFlex
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See                 GET_DEFAULT_TABLESPACE SET_DEFAULT_INDEX_TABLESPACE GET_DEFAULT_INDEX_TABLESPACE
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax SET_DEFAULT_TABLESPACE to {variable}
82450>>>>>>>>>>>>>/// @Param variable                     Name of the default table space
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// SET_DEFAULT_TABLESPACE to "Users"
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        GET_DEFAULT_TABLESPACE
82450>>>>>>>>>>>>>/// @Description This command returns the default table space name for
82450>>>>>>>>>>>>>/// the current database.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     ORAFlex, PgFlex
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See                 SET_DEFAULT_TABLESPACE SET_DEFAULT_INDEX_TABLESPACE GET_DEFAULT_INDEX_TABLESPACE
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax GET_DEFAULT_TABLESPACE to {variable}
82450>>>>>>>>>>>>>/// @Param variable                     Variable to hold the default table space name.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// GET_DEFAULT_TABLESPACE to sTableSpace
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        SET_DEFAULT_INDEX_TABLESPACE
82450>>>>>>>>>>>>>/// @Description This command sets the default table space for indexes
82450>>>>>>>>>>>>>/// when creating tables through the DataFlex API. A tablespace is a
82450>>>>>>>>>>>>>/// container of segments (objects that have an allotted amount of space),
82450>>>>>>>>>>>>>/// i.e. tables and indexes.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     ORAFlex, PgFlex
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09-2013 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See                 SET_DEFAULT_TABLESPACE GET_DEFAULT_TABLESPACE GET_DEFAULT_INDEX_TABLESPACE
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax SET_DEFAULT_INDEX_TABLESPACE to {variable}
82450>>>>>>>>>>>>>/// @Param variable                     Variable to hold the default index table space name.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// SET_DEFAULT_INDEX_TABLESPACE to "Users"
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        GET_DEFAULT_INDEX_TABLESPACE
82450>>>>>>>>>>>>>/// @Description This command returns the default table space name for
82450>>>>>>>>>>>>>/// indexes in the current database.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     ORAFlex, PgFlex
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See                 SET_DEFAULT_TABLESPACE GET_DEFAULT_TABLESPACE SET_DEFAULT_INDEX_TABLESPACE
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax GET_DEFAULT_INDEX_TABLESPACE to {variable}
82450>>>>>>>>>>>>>/// @Param variable                     Variable to hold the default index table space name.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// GET_DEFAULT_INDEX_TABLESPACE to sTableSpace
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        ENABLE_SCRIPTING
82450>>>>>>>>>>>>>/// @Description Scripting is used for testing and preparation. This
82450>>>>>>>>>>>>>/// command allows structural changes to be compiled and tested without
82450>>>>>>>>>>>>>/// actually making any of the changes. Any table restructuring done
82450>>>>>>>>>>>>>/// between this command and DISABLE_SCRIPTING will not actually be
82450>>>>>>>>>>>>>/// committed but will instead create a mock INT file. The script and
82450>>>>>>>>>>>>>/// INT file can then be retrieved and examined for testing purposes.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     All
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See                 DISABLE_SCRIPTING GET_SQL_SCRIPT_CHUNK GET_INT_CHUNK
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax ENABLE_SCRIPTING
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// ENABLE_SCRIPTING
82450>>>>>>>>>>>>>///     //Table restructuring would go here
82450>>>>>>>>>>>>>/// DISABLE_SCRIPTING
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// GET_SQL_SCRIPT_CHUNK OFFSET 0 to sChunk sLength
82450>>>>>>>>>>>>>/// Showln sChunk
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        DISABLE_SCRIPTING
82450>>>>>>>>>>>>>/// @Description This command ends any scripting started by ENABLE_SCRIPTING.
82450>>>>>>>>>>>>>/// The mock INT file and script can then be retrieved and examined.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     All
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2010-12-13 By Marcelo Nachbar
82450>>>>>>>>>>>>>/// @See                 ENABLE_SCRIPTING  GET_SQL_SCRIPT_CHUNK GET_INT_CHUNK
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax DISABLE_SCRIPTING
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// ENABLE_SCRIPTING
82450>>>>>>>>>>>>>///     //Table restructuring would go here
82450>>>>>>>>>>>>>/// DISABLE_SCRIPTING
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// GET_SQL_SCRIPT_CHUNK OFFSET 0 to sChunk sLength
82450>>>>>>>>>>>>>/// Showln sChunk
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>Function MertechInc_GET_RESTRUCTURE_SCRIPT Global Integer iLong Integer iOffset Returns String
82452>>>>>>>>>>>>>    Integer iChuck_Size
82452>>>>>>>>>>>>>    String sChunk
82452>>>>>>>>>>>>>
82452>>>>>>>>>>>>>    //Get current Chuck size and pre size string
82452>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_CHUNK_SIZE CALLBACK 0 PASSING iChuck_Size MertechInc_Blank 1 RESULT MertechInc_iRet
82457>>>>>>>>>>>>>    Get MertechInc_Pre_Size_String iChuck_Size to sChunk
82458>>>>>>>>>>>>>
82458>>>>>>>>>>>>>    //Get data
82458>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_RESTRUCTURE_SCRIPT CALLBACK 0 PASSING sChunk iOffset iLong RESULT MertechInc_iRet
82463>>>>>>>>>>>>>
82463>>>>>>>>>>>>>    // Replace insert a CR before any LF character
82463>>>>>>>>>>>>>    Move (Replaces(Character(10), sChunk, Character(13)+Character(10))) to sChunk
82464>>>>>>>>>>>>>
82464>>>>>>>>>>>>>    Function_Return sChunk
82465>>>>>>>>>>>>>End_Function
82466>>>>>>>>>>>>>
82466>>>>>>>>>>>>>
82466>>>>>>>>>>>>>//=============================================================================
82466>>>>>>>>>>>>>/// @Name        GET_SQL_SCRIPT_CHUNK
82466>>>>>>>>>>>>>/// @Description This command returns a chunk of the script generated
82466>>>>>>>>>>>>>/// from the restructuring done inside of ENABLE_SCRIPTING and
82466>>>>>>>>>>>>>/// DISABLE_SCRIPTING. Since some scripts can be very large, the script
82466>>>>>>>>>>>>>/// can be looped through, grabbing chunks at a time.
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// @Assumptions
82466>>>>>>>>>>>>>/// @Status      Public
82466>>>>>>>>>>>>>/// @Drivers     All
82466>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82466>>>>>>>>>>>>>/// @See                 ENABLE_SCRIPTING DISABLE_SCRIPTING GET_INT_CHUNK
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// @Syntax GET_SQL_SCRIPT_CHUNK OFFSET {offset} to {variable} [{length}]
82466>>>>>>>>>>>>>/// @Param offset                       Specifies the offset to start at for the chunk
82466>>>>>>>>>>>>>/// @Param variable                     Variable to hold the chunk
82466>>>>>>>>>>>>>/// @Param length                       Length of chunk returned (optional)
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// @Example
82466>>>>>>>>>>>>>/// ENABLE_SCRIPTING
82466>>>>>>>>>>>>>///     //Table restructuring would go here
82466>>>>>>>>>>>>>/// DISABLE_SCRIPTING
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// GET_SQL_SCRIPT_CHUNK OFFSET 0 to sChunk sLength
82466>>>>>>>>>>>>>/// Showln sChunk
82466>>>>>>>>>>>>>
82466>>>>>>>>>>>>>//=============================================================================
82466>>>>>>>>>>>>>/// @Name        GET_INT_CHUNK
82466>>>>>>>>>>>>>/// @Description This command returns a chunk of the INT file generated
82466>>>>>>>>>>>>>/// from the restructuring done inside of ENABLE_SCRIPTING and
82466>>>>>>>>>>>>>/// DISABLE_SCRIPTING. Since some INT files can be very large, the file
82466>>>>>>>>>>>>>/// can be looped through, grabbing chunks at a time.
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// @Assumptions
82466>>>>>>>>>>>>>/// @Status      Public
82466>>>>>>>>>>>>>/// @Drivers     All
82466>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82466>>>>>>>>>>>>>/// @See                 ENABLE_SCRIPTING DISABLE_SCRIPTING GET_SQL_SCRIPT_CHUNK
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// @Syntax GET_INT_CHUNK OFFSET {offset} to {variable} [{length}]
82466>>>>>>>>>>>>>/// @Param offset                       Specifies the offset to start at for the chunk
82466>>>>>>>>>>>>>/// @Param variable                     Variable to hold the chunk
82466>>>>>>>>>>>>>/// @Param length                       Length of chunk returned (optional)
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// @Example
82466>>>>>>>>>>>>>/// ENABLE_SCRIPTING
82466>>>>>>>>>>>>>///     //Table restructuring would go here
82466>>>>>>>>>>>>>/// DISABLE_SCRIPTING
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// GET_INT_CHUNK OFFSET 0 to sChunk sLength
82466>>>>>>>>>>>>>/// Showln sChunk
82466>>>>>>>>>>>>>
82466>>>>>>>>>>>>>//=============================================================================
82466>>>>>>>>>>>>>/// @Name        REPORT_STMT
82466>>>>>>>>>>>>>/// @Description This command is an alternative to DataFlex's "Report"
82466>>>>>>>>>>>>>/// command. This allows embedded SQL to be used to fetch data instead of
82466>>>>>>>>>>>>>/// standard table queries.. All of the finds, for example, normally found
82466>>>>>>>>>>>>>/// in "Report" are replaced by SQL_FETCH_NEXT_ROW.
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// @Assumptions
82466>>>>>>>>>>>>>/// @Status      Public
82466>>>>>>>>>>>>>/// @Drivers     n/a
82466>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82466>>>>>>>>>>>>>/// @See
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// @Syntax See DataFlex / Visual DataFlex documentation
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// @Example
82466>>>>>>>>>>>>>/// /Header
82466>>>>>>>>>>>>>/// __/__/____                                                        Page ___.
82466>>>>>>>>>>>>>///                 MERTECH DATA SYSTEMS, INC. - NOT FOR RESALE
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// ID   NAME
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// /Body
82466>>>>>>>>>>>>>/// ____ _________________________
82466>>>>>>>>>>>>>/// /Total
82466>>>>>>>>>>>>>/// Records printed = _______.
82466>>>>>>>>>>>>>/// /*
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// OPEN SALESP
82466>>>>>>>>>>>>>/// direct_output "con:"
82466>>>>>>>>>>>>>/// // Write the complete SELECT statement to retrieve the expected records from your REPORT
82466>>>>>>>>>>>>>/// // Must include the expression to qualify the required records and specify the order by as well
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// sql_set_stmt of salesp to "select recnum, id, name from SALESP where recnum > 5 order by id"
82466>>>>>>>>>>>>>/// sql_prepare_stmt of salesp
82466>>>>>>>>>>>>>/// sql_bindcolumns_stmt of salesp to salesp.recnum salesp.id salesp.name
82466>>>>>>>>>>>>>/// sql_execute_stmt of salesp
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// Report_stmt SALESP By Index.1
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// Section Header
82466>>>>>>>>>>>>>///     Sysdate Header.1
82466>>>>>>>>>>>>>///     Move PageCount to Header.2
82466>>>>>>>>>>>>>///     output header
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// Section Body
82466>>>>>>>>>>>>>///     Print Salesp.id   to Body.1
82466>>>>>>>>>>>>>///     Print Salesp.name to Body.2
82466>>>>>>>>>>>>>///     output body
82466>>>>>>>>>>>>>/// Section Total
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// Return
82466>>>>>>>>>>>>>/// ReportEnd
82466>>>>>>>>>>>>>
82466>>>>>>>>>>>>>//=============================================================================
82466>>>>>>>>>>>>>/// @Name        GET_SERVER_CFG
82466>>>>>>>>>>>>>/// @Description This command, when passed a valid server name, returns
82466>>>>>>>>>>>>>/// the a value for the specified attribute. See the list below for an
82466>>>>>>>>>>>>>/// explanation of each attribute.
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// SERVER_REVISION    Returns the major version, to the left of the decimal, of the server
82466>>>>>>>>>>>>>/// SUPPORT_DESC       Returns 1 if Server supports descending index segments
82466>>>>>>>>>>>>>/// SUPPORT_CASE       Returns 1 if Server supports case insensitive index segments
82466>>>>>>>>>>>>>/// SERVER_VERSION     Returns the full version of the server
82466>>>>>>>>>>>>>/// SERVER_ENCODING    Returns the Server Encoding
82466>>>>>>>>>>>>>/// CONNECTION_ACTIVE  Returns 1 if the connection to the server is active
82466>>>>>>>>>>>>>/// CITEXT_SUPPORT     Returns 1 if Server supports citext, a PostgreSQL data type
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// @Assumptions
82466>>>>>>>>>>>>>/// @Status      Internal
82466>>>>>>>>>>>>>/// @Drivers     All
82466>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82466>>>>>>>>>>>>>/// @See
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// @Syntax GET_SERVER_CFG {constant} of {server} to {variable}
82466>>>>>>>>>>>>>/// @Param constant                     SERVER_REVISION,SERVER_MIN_REVISION,SUPPORT_DESC,SUPPORT_CASE,SERVER_VERSION,SERVER_ENCODING,CONNECTION_ACTIVE
82466>>>>>>>>>>>>>/// @Param server                       Name of the server being checked
82466>>>>>>>>>>>>>/// @Param variable                     Variable to hold the returned value
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// @Example
82466>>>>>>>>>>>>>/// GET_SERVER_CFG SERVER_VERSION of "localhost" to sVersion
82466>>>>>>>>>>>>>
82466>>>>>>>>>>>>>Function MertechInc_GET_SERVER_CFG Global String sServer Integer iAttribute Returns String
82468>>>>>>>>>>>>>    String sReturnValue
82468>>>>>>>>>>>>>
82468>>>>>>>>>>>>>    Get MertechInc_Pre_Size_String 512 to sReturnValue
82469>>>>>>>>>>>>>
82469>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_GET_SERVER_CFG CALLBACK 0 PASSING sServer sReturnValue iAttribute RESULT MertechInc_iRet
82474>>>>>>>>>>>>>
82474>>>>>>>>>>>>>    //If iAttribute = SERVER_VERSION or SERVER_ENCODING then return sReturnValue
82474>>>>>>>>>>>>>    //else we need to return MertechInc_iRet
82474>>>>>>>>>>>>>    If ((iAttribute = 4) or (iAttribute = 5)) Function_Return sReturnValue
82477>>>>>>>>>>>>>    Else                                      Function_Return MertechInc_iRet
82479>>>>>>>>>>>>>End_Function
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        GET_CONNECTION_STATUS
82480>>>>>>>>>>>>>/// @Description Retrieve the connection status for the specified server.
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Assumptions
82480>>>>>>>>>>>>>/// @Status      Internal
82480>>>>>>>>>>>>>/// @Drivers     All
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-25 By Ian Smith
82480>>>>>>>>>>>>>/// @See
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax GET_CONNECTION_STATUS of <serverName> [<databaseName>] to <variable>
82480>>>>>>>>>>>>>/// @Param serverName    Server Name
82480>>>>>>>>>>>>>/// @Param databaseName  Database Name
82480>>>>>>>>>>>>>/// @Param variable      DFTRUE means connection is active
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        GET_CLIENT_CFG
82480>>>>>>>>>>>>>/// @Description Returns the client character encoding (or encoding ID) information.
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Assumptions
82480>>>>>>>>>>>>>/// @Status      Internal
82480>>>>>>>>>>>>>/// @Drivers     MySQLFlex and PgFlex
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-25 By Ian Smith
82480>>>>>>>>>>>>>/// @See
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax GET_CLIENT_CFG [ENCODING | ENCODING_ID] of <Server> [<MySQL_Database>] to <Var>
82480>>>>>>>>>>>>>/// @Param Server           Server name to get encoding of
82480>>>>>>>>>>>>>/// @Param MySQL_Database   Database if   is the File Name
82480>>>>>>>>>>>>>/// @Param Var              Variable to hold returned value
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        SET_CLIENT_CFG
82480>>>>>>>>>>>>>/// @Description Returns the client character encoding (or encoding ID) information.
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Assumptions
82480>>>>>>>>>>>>>/// @Status      Internal
82480>>>>>>>>>>>>>/// @Drivers     MySQLFlex and PgFlex
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-25 By Ian Smith
82480>>>>>>>>>>>>>/// @See
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax SET_CLIENT_CFG [ENCODING | UNIQUE_CHECKS] of <Server> [<MySQL_Database>] to <Value>
82480>>>>>>>>>>>>>/// @Param Server           Server name to get encoding of
82480>>>>>>>>>>>>>/// @Param MySQL_Database   Database if   is the File Name
82480>>>>>>>>>>>>>/// @Param Value            Value to set
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Comment ENCODING - Set the Client Encoding
82480>>>>>>>>>>>>>/// @Comment UNIQUE_CHECKS {DFTRUE/DFFALSE} - enable/disable uniqueness checks for secondary indexes in InnoDB tables
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        CALL_DB2_PROCEDURE
82480>>>>>>>>>>>>>/// @Description Executes a DB2 Server stored procedure.
82480>>>>>>>>>>>>>/// @Status      Public
82480>>>>>>>>>>>>>/// @Drivers     DB2Flex
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-19 By Ian Smith
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax CALL_DB2_PROCEDURE <OWNER> <STORED_PROC> {PASSING <ARG1> {. <ARGn>}}
82480>>>>>>>>>>>>>/// @Param Owner        Name of the Procedure's Owner.
82480>>>>>>>>>>>>>/// @Param Stored_Proc  Full name of the stored procedure being called.
82480>>>>>>>>>>>>>/// @Param Arg1..Argn   Arguments passed to the procedure.
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        GET_RESULTS
82480>>>>>>>>>>>>>/// @Description Returns the initial result set.
82480>>>>>>>>>>>>>/// @Status      Public
82480>>>>>>>>>>>>>/// @Drivers     DB2Flex
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-19 By Ian Smith
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax GET_RESULTS
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        GET_MORE_RESULTS
82480>>>>>>>>>>>>>/// @Description Returns remaining values not retrieved with GET_RESULT.
82480>>>>>>>>>>>>>/// @Status      Public
82480>>>>>>>>>>>>>/// @Drivers     DB2Flex
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-19 By Ian Smith
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax GET_MORE_RESULTS
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        GET_CURRENT_USER_NAME
82480>>>>>>>>>>>>>/// @Description This command is used to get the name of the user currently
82480>>>>>>>>>>>>>/// logged into the server.
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Assumptions
82480>>>>>>>>>>>>>/// @Status      Public
82480>>>>>>>>>>>>>/// @Drivers     All
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
82480>>>>>>>>>>>>>/// @See                 GET_CURRENT_USER_PASSWORD
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax GET_CURRENT_USER_NAME of {server} to {variable}
82480>>>>>>>>>>>>>/// @Param server               The name of the server the user is in
82480>>>>>>>>>>>>>/// @Param variable             Variable to hold the username
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Example
82480>>>>>>>>>>>>>/// GET_CURRENT_USER_NAME of "localhost" to sUserName
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        GET_CURRENT_USER_PASSWORD
82480>>>>>>>>>>>>>/// @Description This command is used to get the password associated with
82480>>>>>>>>>>>>>/// the user currently logged into the server.
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Assumptions
82480>>>>>>>>>>>>>/// @Status      Public
82480>>>>>>>>>>>>>/// @Drivers     All
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
82480>>>>>>>>>>>>>/// @See                 GET_CURRENT_USER_NAME
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax GET_CURRENT_USER_PASSWORD of {server} to {variable}
82480>>>>>>>>>>>>>/// @Param server               The name of the server the user is in
82480>>>>>>>>>>>>>/// @Param variable             Variable to hold the password
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Example
82480>>>>>>>>>>>>>/// GET_CURRENT_USER_PASSWORD of "localhost" to sPassword
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        CREATE_DB2_DATABASE
82480>>>>>>>>>>>>>/// @Description Creates a DB2 database with the same DataFlex collating sequence.
82480>>>>>>>>>>>>>/// @Status      Public
82480>>>>>>>>>>>>>/// @Drivers     All
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-12 By Ian Smith
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax CREATE_DB2_DATABASE <DB Name> <DB Alias> <Code Set> <Territory> [<Path> <Node Name> <User ID><Password>]
82480>>>>>>>>>>>>>/// @Param DB Name     Name of the database being created
82480>>>>>>>>>>>>>/// @Param DB Alias    Alias Name applied to the database being created
82480>>>>>>>>>>>>>/// @Param Code Set    Code Set used by the database being created
82480>>>>>>>>>>>>>/// @Param Territory   Territory associated to the database being created
82480>>>>>>>>>>>>>/// @Param Path        Location of the database                                    - Optional
82480>>>>>>>>>>>>>/// @Param Node Name   Name of the machine (node) where the database is to reside  - Optional
82480>>>>>>>>>>>>>/// @Param User ID     User ID owning the database                                 - Optional
82480>>>>>>>>>>>>>/// @Param Password    Password of the User owning the database                    - Optional
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        SQL_OPEN_CURSOR_STMT
82480>>>>>>>>>>>>>/// @Description This command is used to create a new SQl Cursor. Once
82480>>>>>>>>>>>>>/// created, SQL_SET_CURRENT_CURSOR_STMT can be called to specify which
82480>>>>>>>>>>>>>/// cursor is to be used for a given SQL statement. Creating multiple
82480>>>>>>>>>>>>>/// cursors using this command allows multiple SQL statements to be
82480>>>>>>>>>>>>>/// opened at once. Optionally a different server can be specified for each
82480>>>>>>>>>>>>>/// cursor by passing the server name to this command as well. If no
82480>>>>>>>>>>>>>/// server is specified, the current server will be used. Note that it
82480>>>>>>>>>>>>>/// is important to close all cursors at the end using SQL_CLOSE_CURSOR_STMT.
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Assumptions
82480>>>>>>>>>>>>>/// @Status      Public
82480>>>>>>>>>>>>>/// @Drivers     All
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
82480>>>>>>>>>>>>>/// @See                 SQL_CLOSE_CURSOR_STMT SQL_SET_CURRENT_CURSOR_STMT SQL_GET_CURRENT_CURSOR_STMT
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax SQL_OPEN_CURSOR_STMT [of {server}] to {variable}
82480>>>>>>>>>>>>>/// @Param server                       Name of the server (optional)
82480>>>>>>>>>>>>>/// @Param variable                     Variable to hold the returned cursor handle
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Example
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// Integer iCursor1 iCursor2 iCustomer
82480>>>>>>>>>>>>>/// String  sName
82480>>>>>>>>>>>>>/// Number  nOrderTotal
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// SQL_OPEN_CURSOR_STMT to iCursor1
82480>>>>>>>>>>>>>/// SQL_SET_STMT         to "SELECT CUSTOMER_NUMBER,NAME FROM CUSTOMER "
82480>>>>>>>>>>>>>/// SQL_APPEND_STMT      to "ORDER BY NAME "
82480>>>>>>>>>>>>>/// SQL_PREPARE_STMT
82480>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
82480>>>>>>>>>>>>>/// Repeat
82480>>>>>>>>>>>>>///     SQL_SET_CURRENT_CURSOR_STMT TO iCursor1
82480>>>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW INTO iCustomer sName
82480>>>>>>>>>>>>>///     If (Found) Begin
82480>>>>>>>>>>>>>///        SQL_OPEN_CURSOR_STMT to iCursor2
82480>>>>>>>>>>>>>///        SQL_SET_STMT         to "SELECT SUM(ORDER_TOTAL) FROM ORDERHEA "
82480>>>>>>>>>>>>>///        SQL_APPEND_STMT      to ("WHERE CUSTOMER_NUMBER = " + Trim(iCustomer))
82480>>>>>>>>>>>>>///        SQL_PREPARE_STMT
82480>>>>>>>>>>>>>///        SQL_EXECUTE_STMT
82480>>>>>>>>>>>>>///        SQL_FETCH_NEXT_ROW INTO nOrderTotal
82480>>>>>>>>>>>>>///        If (Found and nOrderTotal > 0) Begin
82480>>>>>>>>>>>>>///            Showln "Customer : " iCustomer "-" sName " - Total: " nOrderTotal
82480>>>>>>>>>>>>>///        End
82480>>>>>>>>>>>>>///        SQL_CLOSE_CURSOR_STMT to Cursor2
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>///        Indicate Found True
82480>>>>>>>>>>>>>///     End
82480>>>>>>>>>>>>>/// Until (Not(Found))
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// SQL_CLOSE_CURSOR_STMT to Cursor1
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        SQL_CLOSE_CURSOR_STMT
82480>>>>>>>>>>>>>/// @Description This command closes the specified cursor that was created
82480>>>>>>>>>>>>>/// from SQL_OPEN_CURSOR_STMT. It is good practice to close all cursors
82480>>>>>>>>>>>>>/// once the statements associated with them are complete.
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Assumptions
82480>>>>>>>>>>>>>/// @Status      Public
82480>>>>>>>>>>>>>/// @Drivers     All
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
82480>>>>>>>>>>>>>/// @See                 SQL_OPEN_CURSOR_STMT SQL_SET_CURRENT_CURSOR_STMT SQL_GET_CURRENT_CURSOR_STMT
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax SQL_CLOSE_CURSOR_STMT [of {server}] to {variable}
82480>>>>>>>>>>>>>/// @Param server                       Name of the server (optional)
82480>>>>>>>>>>>>>/// @Param variable                     Cursor handle to close
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Example
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// SQL_OPEN_CURSOR_STMT to hCursor1
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
82480>>>>>>>>>>>>>/// SQL_PREPARE_STMT
82480>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// SQL_OPEN_CURSOR_STMT to hCursor2
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Inactive' "
82480>>>>>>>>>>>>>/// SQL_PREPARE_STMT
82480>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// Repeat
82480>>>>>>>>>>>>>///     SQL_SET_CURRENT_CURSOR_STMT to hCursor1
82480>>>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW INTO  sID sFirstName sLastName
82480>>>>>>>>>>>>>///     If (Found) Begin
82480>>>>>>>>>>>>>///        Showln "Active : " sID "- " sFirstName sLastName
82480>>>>>>>>>>>>>///     End
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>///     SQL_SET_CURRENT_CURSOR_STMT to hCursor2
82480>>>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW into sId sFirstName sLastName
82480>>>>>>>>>>>>>///     If (Found) Begin
82480>>>>>>>>>>>>>///         Showln "Inactive : " sID "- " sFirstName sLastName
82480>>>>>>>>>>>>>///     End
82480>>>>>>>>>>>>>/// Until (FindErr)
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// SQL_CLOSE_CURSOR_STMT to hCursor1
82480>>>>>>>>>>>>>/// SQL_CLOSE_CURSOR_STMT to hCursor2
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        SQL_SET_CURRENT_CURSOR_STMT
82480>>>>>>>>>>>>>/// @Description This command is used to open a cursor to be used for an
82480>>>>>>>>>>>>>/// SQl statement. The cursor must be created using the SQL_OPEN_CURSOR_STMT,
82480>>>>>>>>>>>>>/// but once it has been created, this command can easily switch between
82480>>>>>>>>>>>>>/// cursors as desired. Optionally a different server can be specified for each
82480>>>>>>>>>>>>>/// cursor by passing the server name to this command as well. If no
82480>>>>>>>>>>>>>/// server is specified, the current server will be used. Note that it
82480>>>>>>>>>>>>>/// is important to close all cursors at the end using SQL_CLOSE_CURSOR_STMT.
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Assumptions
82480>>>>>>>>>>>>>/// @Status      Public
82480>>>>>>>>>>>>>/// @Drivers     All
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
82480>>>>>>>>>>>>>/// @See                 SQL_OPEN_CURSOR_STMT SQL_CLOSE_CURSOR_STMT SQL_GET_CURRENT_CURSOR_STMT
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax SQL_SET_CURRENT_CURSOR_STMT [of {server}] to {variable}
82480>>>>>>>>>>>>>/// @Param server                       Name of the server (optional)
82480>>>>>>>>>>>>>/// @Param variable                     Cursor handle to use
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Example
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// SQL_OPEN_CURSOR_STMT to hCursor1
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
82480>>>>>>>>>>>>>/// SQL_PREPARE_STMT
82480>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// SQL_OPEN_CURSOR_STMT to hCursor2
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Inactive' "
82480>>>>>>>>>>>>>/// SQL_PREPARE_STMT
82480>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// Repeat
82480>>>>>>>>>>>>>///     SQL_SET_CURRENT_CURSOR_STMT to hCursor1
82480>>>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW INTO  sID sFirstName sLastName
82480>>>>>>>>>>>>>///     If (Found) Begin
82480>>>>>>>>>>>>>///        Showln "Active : " sID "- " sFirstName sLastName
82480>>>>>>>>>>>>>///     End
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>///     SQL_SET_CURRENT_CURSOR_STMT to hCursor2
82480>>>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW into sId sFirstName sLastName
82480>>>>>>>>>>>>>///     If (Found) Begin
82480>>>>>>>>>>>>>///         Showln "Inactive : " sID "- " sFirstName sLastName
82480>>>>>>>>>>>>>///     End
82480>>>>>>>>>>>>>/// Until (FindErr)
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// SQL_CLOSE_CURSOR_STMT to hCursor1
82480>>>>>>>>>>>>>/// SQL_CLOSE_CURSOR_STMT to hCursor2
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        SQL_GET_CURRENT_CURSOR_STMT
82480>>>>>>>>>>>>>/// @Description This command returns the current active cursor being
82480>>>>>>>>>>>>>/// used. The cursor is returned to the specified variable.
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Assumptions
82480>>>>>>>>>>>>>/// @Status      Public
82480>>>>>>>>>>>>>/// @Drivers     All
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
82480>>>>>>>>>>>>>/// @See SQL_OPEN_CURSOR_STMT SQL_CLOSE_CURSOR_STMT SQL_SET_CURRENT_CURSOR_STMT
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax SQL_GET_CURRENT_CURSOR_STMT [of {server}] to {variable}
82480>>>>>>>>>>>>>/// @Param server                       Name of the server (optional)
82480>>>>>>>>>>>>>/// @Param variable         Variable to hold the current cursor handle
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Example
82480>>>>>>>>>>>>>/// SQL_GET_CURRENT_CURSOR_STMT to hCursor
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        SQL_SET_MAX_CURSORS_STMT
82480>>>>>>>>>>>>>/// @Description Sets the maximum number of simultaneous cursors allowed.
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Assumptions
82480>>>>>>>>>>>>>/// @Status      Deprecated
82480>>>>>>>>>>>>>/// @Drivers     All
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
82480>>>>>>>>>>>>>/// @See
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax SQL_SET_MAX_CURSORS_STMT [of {server}] to {variable}
82480>>>>>>>>>>>>>/// @Param server                       Name of the server (optional)
82480>>>>>>>>>>>>>/// @Param variable                     Maximum number of cursors allowed
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Example
82480>>>>>>>>>>>>>/// SQL_SET_MAX_CURSORS_STMT to 50
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        SQL_GET_MAX_CURSORS_STMT
82480>>>>>>>>>>>>>/// @Description Retrieves the maximum number of cursors allowed.
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Assumptions
82480>>>>>>>>>>>>>/// @Status      Deprecated
82480>>>>>>>>>>>>>/// @Drivers     All
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
82480>>>>>>>>>>>>>/// @See
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax SQL_GET_MAX_CURSORS_STMT [of {server}] to {variable}
82480>>>>>>>>>>>>>/// @Param server                       Name of the server (optional)
82480>>>>>>>>>>>>>/// @Param variable                     Maximum number of cursors allowed
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Example
82480>>>>>>>>>>>>>/// SQL_GET_MAX_CURSORS_STMT to iCursors
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        SQL_SET_LOCAL_TD_PATH
82480>>>>>>>>>>>>>/// @Description Sets the directory where the driver will find the LOCAL TD files.
82480>>>>>>>>>>>>>/// @Status      Deprecated
82480>>>>>>>>>>>>>/// @Drivers     All
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-19 By Ian Smith
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax SQL_SET_LOCAL_TD_PATH TO <DirectoryPath|Variable>
82480>>>>>>>>>>>>>/// @Param DirectoryPath   Directory path were the TD files are to be located.
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        SQL_GET_LOCAL_TD_PATH
82480>>>>>>>>>>>>>/// @Description Gets the directory where the driver is looking for the LOCAL TD files.
82480>>>>>>>>>>>>>/// @Status      Deprecated
82480>>>>>>>>>>>>>/// @Drivers     All
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-19 By Ian Smith
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax SQL_SET_LOCAL_TD_PATH TO <DirectoryPath|Variable>
82480>>>>>>>>>>>>>/// @Param DirectoryPath   Directory path were the driver is looking
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        GET_DRIVER_REVISION
82480>>>>>>>>>>>>>/// @Description This command will put the current version (decimals included)
82480>>>>>>>>>>>>>/// of the driver associated with the current workspace into the specified
82480>>>>>>>>>>>>>/// variable.
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Assumptions
82480>>>>>>>>>>>>>/// @Status      Public
82480>>>>>>>>>>>>>/// @Drivers     All
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
82480>>>>>>>>>>>>>/// @See                 GET_DRIVER_MAJOR_REVISION
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax GET_DRIVER_REVISION to {variable}
82480>>>>>>>>>>>>>/// @Param variable                     String variable to hold the returned version
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Example
82480>>>>>>>>>>>>>/// GET_DRIVER_REVISION to sVersion
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        GET_DRIVER_MAJOR_REVISION
82480>>>>>>>>>>>>>/// @Description This command will put the current version (no decimals)
82480>>>>>>>>>>>>>/// of the driver associated with the current workspace into the specified
82480>>>>>>>>>>>>>/// variable.
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Assumptions
82480>>>>>>>>>>>>>/// @Status      Public
82480>>>>>>>>>>>>>/// @Drivers     All
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
82480>>>>>>>>>>>>>/// @See                 GET_DRIVER_REVISION
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax GET_DRIVER_MAJOR_REVISION to {variable}
82480>>>>>>>>>>>>>/// @Param variable                     String variable to hold the returned version
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Example
82480>>>>>>>>>>>>>/// GET_DRIVER_MAJOR_REVISION to sVersion
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        GET_DRIVER_LICENSE_EXPIRATION_TIME
82480>>>>>>>>>>>>>/// @Description This command is used to find out how long until a
82480>>>>>>>>>>>>>/// specific temporary license for a driver expires. If 0 is returned,
82480>>>>>>>>>>>>>/// then the license is not a temporary license. If -1 is returned, then
82480>>>>>>>>>>>>>/// the license has already expired. Otherwise, the number returned
82480>>>>>>>>>>>>>/// is the number of days until the license will expire.
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Assumptions
82480>>>>>>>>>>>>>/// @Status      Public
82480>>>>>>>>>>>>>/// @Drivers     All
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 Aaron Gulack
82480>>>>>>>>>>>>>/// @See                 GET_DRIVER_LICENSE_PATH SET_DRIVER_LICENSE_EXPIRATION_WARNING
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax GET_DRIVER_LICENSE_EXPIRATION_TIME to {variable}
82480>>>>>>>>>>>>>/// @Param variable                     Variable to hold the days until expiration
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Example
82480>>>>>>>>>>>>>/// GET_DRIVER_LICENSE_EXPIRATION_TIME to iExpire
82480>>>>>>>>>>>>>/// Showln iExpire
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        SET_DRIVER_LICENSE_EXPIRATION_WARNING
82480>>>>>>>>>>>>>/// @Description This command is used to set a custom warning message to
82480>>>>>>>>>>>>>/// be displayed when a temporary license for a driver is close to expiring.
82480>>>>>>>>>>>>>/// Note that since the license evaluation is done during Login and before
82480>>>>>>>>>>>>>/// any open calls, this command should be called before either of those.
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Assumptions
82480>>>>>>>>>>>>>/// @Status      Public
82480>>>>>>>>>>>>>/// @Drivers     All
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82480>>>>>>>>>>>>>/// @See                 GET_DRIVER_LICENSE_PATH GET_DRIVER_LICENSE_EXPIRATION_TIME
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax SET_DRIVER_LICENSE_EXPIRATION_WARNING to {variable}
82480>>>>>>>>>>>>>/// @Param variable                     New warning message for expiring license
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Example
82480>>>>>>>>>>>>>/// SET_DRIVER_LICENSE_EXPIRATION_WARNING to "Your license is about to expire."
82480>>>>>>>>>>>>>/// Login "localhost" "" "" "sql_drv"
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        GET_DRIVER_LICENSE_PATH
82480>>>>>>>>>>>>>/// @Description This command will return the current path of the license
82480>>>>>>>>>>>>>/// associated with the driver.
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Assumptions
82480>>>>>>>>>>>>>/// @Status      Internal
82480>>>>>>>>>>>>>/// @Drivers     All
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
82480>>>>>>>>>>>>>/// @See                 SET_DRIVER_LICENSE_EXPIRATION_WARNING GET_DRIVER_LICENSE_EXPIRATION_TIME
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax GET_DRIVER_LICENSE_PATH to {variable}
82480>>>>>>>>>>>>>/// @Param variable                     Variable to hold the path of the license
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>Function MertechInc_GET_DRIVER_LICENSE_PATH Global Returns String
82482>>>>>>>>>>>>>    String sReturnValue
82482>>>>>>>>>>>>>
82482>>>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
82484>>>>>>>>>>>>>    If (MertechInc_FileNumber <> -1) Begin
82486>>>>>>>>>>>>>        Get MertechInc_Pre_Size_String 4096 to sReturnValue
82487>>>>>>>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_LICENSE_ENVIRONMENT_SET CALLBACK 0 PASSING sReturnValue MertechInc_Blank CALLDRV_LICENSE_PATH RESULT MertechInc_iRet
82492>>>>>>>>>>>>>        If MertechInc_iRet EQ -1 INDICATE ERR True
82495>>>>>>>>>>>>>    End
82495>>>>>>>>>>>>>>
82495>>>>>>>>>>>>>
82495>>>>>>>>>>>>>    Function_Return sReturnValue
82496>>>>>>>>>>>>>End_Function
82497>>>>>>>>>>>>>
82497>>>>>>>>>>>>>//=============================================================================
82497>>>>>>>>>>>>>/// @Name        SET_DATABASE_PORT
82497>>>>>>>>>>>>>/// @Description This command is used to dynamically change the port
82497>>>>>>>>>>>>>/// number to use for all TCP/IP connections to the server. Note that
82497>>>>>>>>>>>>>/// the port is used for the current session only.
82497>>>>>>>>>>>>>///
82497>>>>>>>>>>>>>/// @Assumptions The port is valid and available
82497>>>>>>>>>>>>>/// @Status      Public
82497>>>>>>>>>>>>>/// @Drivers     MySQLFlex PgFlex
82497>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
82497>>>>>>>>>>>>>/// @See                 GET_DATABASE_PORT
82497>>>>>>>>>>>>>///
82497>>>>>>>>>>>>>/// @Syntax SET_DATABASE_PORT of {constant} to {variable}
82497>>>>>>>>>>>>>/// @Param constant                     MYSQL or PGSQL
82497>>>>>>>>>>>>>/// @Param variable                     Port number to use to connect to server
82497>>>>>>>>>>>>>///
82497>>>>>>>>>>>>>/// @Example
82497>>>>>>>>>>>>>/// GET_DATABASE_PORT of MYSQL to 1433
82497>>>>>>>>>>>>>
82497>>>>>>>>>>>>>//=============================================================================
82497>>>>>>>>>>>>>/// @Name        GET_DATABASE_PORT
82497>>>>>>>>>>>>>/// @Description This command returns the TCP/IP port used to connect
82497>>>>>>>>>>>>>/// to the server.
82497>>>>>>>>>>>>>///
82497>>>>>>>>>>>>>/// @Assumptions
82497>>>>>>>>>>>>>/// @Status      Public
82497>>>>>>>>>>>>>/// @Drivers     MySQLFlex PgFlex
82497>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82497>>>>>>>>>>>>>/// @See                 SET_DATABASE_PORT
82497>>>>>>>>>>>>>///
82497>>>>>>>>>>>>>/// @Syntax GET_DATABASE_PORT of {MYSQL/PGSQL} to {variable}
82497>>>>>>>>>>>>>/// @Param variable                     Variable to hold the TCP/IP port number
82497>>>>>>>>>>>>>///
82497>>>>>>>>>>>>>/// @Example
82497>>>>>>>>>>>>>/// GET_DATABASE_PORT of MYSQL to iPort
82497>>>>>>>>>>>>>
82497>>>>>>>>>>>>>//=============================================================================
82497>>>>>>>>>>>>>/// @Name        GET_SERIAL_NUMBER
82497>>>>>>>>>>>>>/// @Description This command returns the serial number associated with
82497>>>>>>>>>>>>>/// the current driver's license.
82497>>>>>>>>>>>>>///
82497>>>>>>>>>>>>>/// @Assumptions
82497>>>>>>>>>>>>>/// @Status      Public
82497>>>>>>>>>>>>>/// @Drivers     All
82497>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
82497>>>>>>>>>>>>>/// @See
82497>>>>>>>>>>>>>///
82497>>>>>>>>>>>>>/// @Syntax GET_SERIAL_NUMBER to {variable}
82497>>>>>>>>>>>>>/// @Param variable                     Variable to hold the driver's serial number
82497>>>>>>>>>>>>>///
82497>>>>>>>>>>>>>/// @Example
82497>>>>>>>>>>>>>/// GET_SERIAL_NUMBER to iSerial
82497>>>>>>>>>>>>>
82497>>>>>>>>>>>>>//=============================================================================
82497>>>>>>>>>>>>>/// @Name        SET_DATABASE_SOCKET
82497>>>>>>>>>>>>>/// @Description This command is used to set the socket used to connect
82497>>>>>>>>>>>>>/// to the server when running an application under Linux/Unix.
82497>>>>>>>>>>>>>///
82497>>>>>>>>>>>>>/// @Assumptions
82497>>>>>>>>>>>>>/// @Status      Public
82497>>>>>>>>>>>>>/// @Drivers     MySQLFlex
82497>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82497>>>>>>>>>>>>>/// @See                 GET_DATABASE_SOCKET
82497>>>>>>>>>>>>>///
82497>>>>>>>>>>>>>/// @Syntax SET_DATABASE_SOCKET of MYSQL to {variable}
82497>>>>>>>>>>>>>/// @Param variable                     Full name of the socket
82497>>>>>>>>>>>>>
82497>>>>>>>>>>>>>//=============================================================================
82497>>>>>>>>>>>>>/// @Name        GET_DATABASE_SOCKET
82497>>>>>>>>>>>>>/// @Description This command returns the name of the socket used to
82497>>>>>>>>>>>>>/// connect to the server when running an application under Linux/Unix.
82497>>>>>>>>>>>>>///
82497>>>>>>>>>>>>>/// @Assumptions
82497>>>>>>>>>>>>>/// @Status      Public
82497>>>>>>>>>>>>>/// @Drivers     MySQLFlex
82497>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82497>>>>>>>>>>>>>/// @See                 SET_DATABASE_SOCKET
82497>>>>>>>>>>>>>///
82497>>>>>>>>>>>>>/// @Syntax SET_DATABASE_SOCKET of MYSQL to {variable}
82497>>>>>>>>>>>>>/// @Param variable                     Variable to hold the full socket name
82497>>>>>>>>>>>>>
82497>>>>>>>>>>>>>//=============================================================================
82497>>>>>>>>>>>>>/// @Name        SET_AUTHENTICATION_MODE
82497>>>>>>>>>>>>>/// @Description This command is used to control what mode the user logs
82497>>>>>>>>>>>>>/// in as. When DEFAULT is passed, the user will be logged in with the
82497>>>>>>>>>>>>>/// default privileges given to it. When SYSDBA is passed, the user will
82497>>>>>>>>>>>>>/// be logged in with the roles assigned to the sysdba user, most likely
82497>>>>>>>>>>>>>/// full control over the database.
82497>>>>>>>>>>>>>///
82497>>>>>>>>>>>>>/// @Assumptions
82497>>>>>>>>>>>>>/// @Status      Public
82497>>>>>>>>>>>>>/// @Drivers     OraFlex
82497>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
82497>>>>>>>>>>>>>/// @See
82497>>>>>>>>>>>>>///
82497>>>>>>>>>>>>>/// @Syntax SET_AUTHENTICATION_MODE of Oracle to {SYSDBA/DEFAULT}
82497>>>>>>>>>>>>>///
82497>>>>>>>>>>>>>/// @Example
82497>>>>>>>>>>>>>/// SET_AUTHENTICATION_MODE of Oracle to DEFAULT
82497>>>>>>>>>>>>>
82497>>>>>>>>>>>>>//=============================================================================
82497>>>>>>>>>>>>>/// @Name        SQL_ESCAPE_STRING
82497>>>>>>>>>>>>>/// @Description This command is used to properly escape strings before
82497>>>>>>>>>>>>>/// they are used in embedded SQL statements. This can be extremely
82497>>>>>>>>>>>>>/// important when you do not have full control of the strings being passed
82497>>>>>>>>>>>>>/// to the SQL statement as this will ensure that the strings are properly
82497>>>>>>>>>>>>>/// quoted.
82497>>>>>>>>>>>>>///
82497>>>>>>>>>>>>>/// @Assumptions
82497>>>>>>>>>>>>>/// @Status      Public
82497>>>>>>>>>>>>>/// @Drivers     All
82497>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82497>>>>>>>>>>>>>/// @See
82497>>>>>>>>>>>>>///
82497>>>>>>>>>>>>>/// @Syntax SQL_ESCAPE_STRING of {string} to {variable}
82497>>>>>>>>>>>>>/// @Param string               The string to be escaped.
82497>>>>>>>>>>>>>/// @Param variable     Variable to hold the newly escaped string
82497>>>>>>>>>>>>>///
82497>>>>>>>>>>>>>/// @Example
82497>>>>>>>>>>>>>/// SQL_ESCAPE_STRING of "They said to me, 'hello'." to sEscaped
82497>>>>>>>>>>>>>
82497>>>>>>>>>>>>>Function SQLESCAPESTRING Global String sData Returns String
82499>>>>>>>>>>>>>    String sReturnData
82499>>>>>>>>>>>>>
82499>>>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
82501>>>>>>>>>>>>>
82501>>>>>>>>>>>>>    If (MertechInc_FileNumber <> -1) Begin
82503>>>>>>>>>>>>>        Get MertechInc_Pre_Size_String 0 to sReturnData
82504>>>>>>>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_ESCAPE_STRING CALLBACK 0 PASSING sData sReturnData 0 RESULT MertechInc_iRet
82509>>>>>>>>>>>>>    End
82509>>>>>>>>>>>>>>
82509>>>>>>>>>>>>>
82509>>>>>>>>>>>>>    Function_Return sReturnData
82510>>>>>>>>>>>>>End_Function
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>//=============================================================================
82511>>>>>>>>>>>>>/// @Name        DIRECT_PATH_LOAD
82511>>>>>>>>>>>>>/// @Description
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Assumptions
82511>>>>>>>>>>>>>/// @Status      Internal
82511>>>>>>>>>>>>>/// @Drivers     OraFlex
82511>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-21 By Ian Smith
82511>>>>>>>>>>>>>/// @See
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>//=============================================================================
82511>>>>>>>>>>>>>/// @Name        SQL_INITIALIZE_SEQUENCE
82511>>>>>>>>>>>>>/// @Description This command is used to initialize all auto increment
82511>>>>>>>>>>>>>/// columns, or sequences in Oracle, of the specified table to be the
82511>>>>>>>>>>>>>/// highest number plus one. This is useful when inserting a large amount
82511>>>>>>>>>>>>>/// of records in the table and the sequence is not being updated because
82511>>>>>>>>>>>>>/// the auto incremented column is being manually filled.
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Assumptions
82511>>>>>>>>>>>>>/// @Status      Public
82511>>>>>>>>>>>>>/// @Drivers     OraFlex PgFlex
82511>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82511>>>>>>>>>>>>>/// @See
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// SQL_INITIALIZE_SEQUENCE of {FileNumber}
82511>>>>>>>>>>>>>/// @Param FileNumber                   The file number
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>//=============================================================================
82511>>>>>>>>>>>>>/// @Name        LOB_APPEND
82511>>>>>>>>>>>>>/// @Description This command is used to append data to an existing LOB
82511>>>>>>>>>>>>>/// column in the database. When called, the data corresponding field
82511>>>>>>>>>>>>>/// in the buffer is appended to the respective column in the database.
82511>>>>>>>>>>>>>/// This can be very useful when saving data that exceeds VDF size limits
82511>>>>>>>>>>>>>/// but falls within the limits of the SQL database. Note that this command
82511>>>>>>>>>>>>>/// must write to a file that is active and locked. Also the save is handled
82511>>>>>>>>>>>>>/// within the command so no extra calls are needed to save the changes made.
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
82511>>>>>>>>>>>>>/// @Status      Deprecated
82511>>>>>>>>>>>>>/// @Drivers     All
82511>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82511>>>>>>>>>>>>>/// @See                 SQL_LOB_ADD_CHUNK
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Syntax LOB_APPEND of {FileName} {FieldNumber}
82511>>>>>>>>>>>>>/// @Param FileName                     Name of the file containing the LOB column
82511>>>>>>>>>>>>>/// @Param FieldNumber          Number of the field being appended to
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Example
82511>>>>>>>>>>>>>/// Clear Customer
82511>>>>>>>>>>>>>/// Find Gt Customer By Index.1
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// Direct_Input 'C:\Mertech.xml'
82511>>>>>>>>>>>>>/// Lock
82511>>>>>>>>>>>>>///    Find Eq Customer by Recnum
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>///    Read_Block Customer.Comments 16384
82511>>>>>>>>>>>>>///    SQL_LOB_WRITE of Customer 13 // Customer.Comments
82511>>>>>>>>>>>>>///    Repeat
82511>>>>>>>>>>>>>///        Read_Block Customer.Comments 16384
82511>>>>>>>>>>>>>///        SQL_LOB_APPEND of Customer 13 // Customer.Comments
82511>>>>>>>>>>>>>///    Until (SeqEOF)
82511>>>>>>>>>>>>>/// Unlock
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// Close_Input
82511>>>>>>>>>>>>>/// Find Eq Customer By Recnum
82511>>>>>>>>>>>>>/// SQL_LOB_LENGTH of Customer 13 to iLength
82511>>>>>>>>>>>>>/// Showln 'Length: ' iLength
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>//=============================================================================
82511>>>>>>>>>>>>>/// @Name        LOB_LENGTH
82511>>>>>>>>>>>>>/// @Description This command returns the length of the data in the
82511>>>>>>>>>>>>>/// specified column. This command must be used after a proper FIND to
82511>>>>>>>>>>>>>/// ensure that a valid record is in the buffer. This can be a useful
82511>>>>>>>>>>>>>/// command for checking if uploaded data exceeds size limits.
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
82511>>>>>>>>>>>>>/// @Status      Deprecated
82511>>>>>>>>>>>>>/// @Drivers     All
82511>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82511>>>>>>>>>>>>>/// @See                 SQL_GET_LOB_LENGTH
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Syntax LOB_LENGTH of {FileName} {FieldNumber} to {variable}
82511>>>>>>>>>>>>>/// @Param FileName                     Name of the file
82511>>>>>>>>>>>>>/// @Param FieldNumber          Number of the LOB field
82511>>>>>>>>>>>>>/// @Param variable                     Variable to hold the length
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Example
82511>>>>>>>>>>>>>/// Clear Customer
82511>>>>>>>>>>>>>/// Find Gt Customer By Index.1
82511>>>>>>>>>>>>>/// SQL_LOB_LENGTH of Customer 13 to iLength
82511>>>>>>>>>>>>>/// Showln 'Length: ' iLength
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>//=============================================================================
82511>>>>>>>>>>>>>/// @Name        LOB_READ
82511>>>>>>>>>>>>>/// @Description This command reads a chunk of data from a specified LOB
82511>>>>>>>>>>>>>/// column, moving it into its corresponding field buffer. Because the
82511>>>>>>>>>>>>>/// chunk will be moved into the field buffer, it can only be as large as
82511>>>>>>>>>>>>>/// the buffer allows. To account for this, the constants FIRST or NEXT
82511>>>>>>>>>>>>>/// are passed as well indicating whether to grab the first chunk for
82511>>>>>>>>>>>>>/// the buffer or the next. Each chunk grabbed will be as large as allowed.
82511>>>>>>>>>>>>>/// All these things considered, when reading data larger than the field
82511>>>>>>>>>>>>>/// buffer, it is good practice to perform the read in a loop, adding the
82511>>>>>>>>>>>>>/// length each time. Another optional parameter that can be passed is a
82511>>>>>>>>>>>>>/// variable that will store the length of the chunk. Note that a LOB read
82511>>>>>>>>>>>>>/// must be done after a successful find on the record.
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
82511>>>>>>>>>>>>>/// @Status      Deprecated
82511>>>>>>>>>>>>>/// @Drivers     All
82511>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82511>>>>>>>>>>>>>/// @See                 SQL_GET_LOB SQL_GET_LOB_CHUNK
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Syntax LOB_READ of {FileName} {FieldNumber} {FIRST/NEXT} [{length}]
82511>>>>>>>>>>>>>/// @Param FileName                     Name of the file containing the LOB field
82511>>>>>>>>>>>>>/// @Param FieldNumber          Number of the field being read from
82511>>>>>>>>>>>>>/// @Param FIRST                        Reads the first chunk of data
82511>>>>>>>>>>>>>/// @Param NEXT                         Reads the next chuck of data (if larger than buffer limit)
82511>>>>>>>>>>>>>/// @Param length                       Variable to hold the chunk length (optional)
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Example
82511>>>>>>>>>>>>>/// Direct_Output ('binary:Mertech.pdf')
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// Clear customer
82511>>>>>>>>>>>>>/// Find Gt customer by Index.1
82511>>>>>>>>>>>>>/// SQL_LOB_LENGTH of customer 13 to liLength
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// While (liLength > 0)
82511>>>>>>>>>>>>>///     Write customer.comments
82511>>>>>>>>>>>>>///     SQL_LOB_READ of customer 13 Next liLength
82511>>>>>>>>>>>>>/// Loop
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// Close_Output
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>//=============================================================================
82511>>>>>>>>>>>>>/// @Name        LOB_WRITE
82511>>>>>>>>>>>>>/// @Description This command is used to write data to a LOB column.
82511>>>>>>>>>>>>>/// By passing the file name and field number of the LOB column, this
82511>>>>>>>>>>>>>/// command will take the current value of the respective field in
82511>>>>>>>>>>>>>/// the field buffer, write it to the database and save it. Any data
82511>>>>>>>>>>>>>/// currently in that field will be overridden by the data from the
82511>>>>>>>>>>>>>/// buffer. Note that this command must write to a file that is active
82511>>>>>>>>>>>>>/// and locked. Also this command handles the save so no extra calls
82511>>>>>>>>>>>>>/// are needed to save the changes.
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
82511>>>>>>>>>>>>>/// @Status      Deprecated
82511>>>>>>>>>>>>>/// @Drivers     All
82511>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82511>>>>>>>>>>>>>/// @See                 SQL_SET_LOB SQL_ADD_LOB_CHUNK
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Syntax LOB_WRITE of {FileName} {FieldNumber}
82511>>>>>>>>>>>>>/// @Param FileName                     Name of the file containing the LOB field
82511>>>>>>>>>>>>>/// @Param FieldNumber          Number of the field being written to
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Example
82511>>>>>>>>>>>>>/// Clear Customer
82511>>>>>>>>>>>>>/// Find Gt Customer By Index.1
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// Direct_Input 'C:\Mertech.xml'
82511>>>>>>>>>>>>>/// Lock
82511>>>>>>>>>>>>>///    Find Eq Customer by Recnum
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>///    Read_Block Customer.Comments 16384
82511>>>>>>>>>>>>>///    SQL_LOB_WRITE of Customer 13 // Customer.Comments
82511>>>>>>>>>>>>>///    Repeat
82511>>>>>>>>>>>>>///        Read_Block Customer.Comments 16384
82511>>>>>>>>>>>>>///        SQL_LOB_APPEND of Customer 13 // Customer.Comments
82511>>>>>>>>>>>>>///    Until (SeqEOF)
82511>>>>>>>>>>>>>/// Unlock
82511>>>>>>>>>>>>>/// Close_Input
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// Find Eq Customer By Recnum
82511>>>>>>>>>>>>>/// SQL_LOB_LENGTH of Customer 13 to iLength
82511>>>>>>>>>>>>>/// Showln 'Length: ' iLength
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>//=============================================================================
82511>>>>>>>>>>>>>/// @Name        LOB_LOADFROMFILE
82511>>>>>>>>>>>>>/// @Description This command loads an external file into a specified LOB
82511>>>>>>>>>>>>>/// column. After specifying the file name and field number, the path and
82511>>>>>>>>>>>>>/// file must then be passed respectively. When using Oracle, instead of
82511>>>>>>>>>>>>>/// passing the directory, a directory alias must be passed. This alias
82511>>>>>>>>>>>>>/// can be created using a "CREATE DIRECTORY" statement in SQL. For more
82511>>>>>>>>>>>>>/// information on setting this directory alias, see the Oracle help.
82511>>>>>>>>>>>>>/// For other servers, the file must be a local file available to the
82511>>>>>>>>>>>>>/// application that is calling the command. Note that this command must
82511>>>>>>>>>>>>>/// write to a file that is active and locked. Also this command handles
82511>>>>>>>>>>>>>/// the save so no extra calls are needed to save the changes.
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
82511>>>>>>>>>>>>>/// @Status      Deprecated
82511>>>>>>>>>>>>>/// @Drivers     All
82511>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82511>>>>>>>>>>>>>/// @See                 LOB_APPEND LOB_LENGTH LOB_WRITE LOB_READ LOB_ERASE LOB_TRUNCATE FLUSH_LOB_BUFFER
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Syntax LOB_LOADFROMFILE of {FileName} {FieldNumber} From {path} {file}
82511>>>>>>>>>>>>>/// @Param FileName                     Name of the file containing the LOB column
82511>>>>>>>>>>>>>/// @Param FieldNumber          Number of the LOB column being used
82511>>>>>>>>>>>>>/// @Param path                         The path of the file, excluding the file name
82511>>>>>>>>>>>>>/// @Param file                         The name of the file, including the extension
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Example
82511>>>>>>>>>>>>>/// Clear Customer
82511>>>>>>>>>>>>>/// Find Gt Customer By Index.1
82511>>>>>>>>>>>>>/// Lock
82511>>>>>>>>>>>>>///    Find Eq Customer by Recnum
82511>>>>>>>>>>>>>///    LOB_TRUNCATE OF customel 13 to 0 // Customer.Comments
82511>>>>>>>>>>>>>///    Saverecord Customer
82511>>>>>>>>>>>>>///    // Directory name is case sensitive.
82511>>>>>>>>>>>>>///    // Make sure the name case matches
82511>>>>>>>>>>>>>///    LOB_LOADFROMFILE OF customel 13 FROM "C:\Mertech\FilesToLoad" "Mertech.XML"
82511>>>>>>>>>>>>>/// Unlock
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>//=============================================================================
82511>>>>>>>>>>>>>/// @Name        LOB_ERASE
82511>>>>>>>>>>>>>/// @Description This command is used to erase a portion of data from a
82511>>>>>>>>>>>>>/// LOB column. For text fields, the portion of data to be erased is
82511>>>>>>>>>>>>>/// replaced with white space, and in binary fields, with 0X0. To erase
82511>>>>>>>>>>>>>/// a portion of the data, pass the length to erase as well as the number
82511>>>>>>>>>>>>>/// to offset from. For this command to work properly, it must be done
82511>>>>>>>>>>>>>/// after a valid find. Note that the save is handled inside this command
82511>>>>>>>>>>>>>/// so no extra commands are needed to save the changes.
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
82511>>>>>>>>>>>>>/// @Status      Deprecated
82511>>>>>>>>>>>>>/// @Drivers     All
82511>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82511>>>>>>>>>>>>>/// @See LOB_APPEND LOB_LENGTH LOB_WRITE LOB_READ LOB_LOADFROMFILE LOB_ERASE LOB_TRUNCATE FLUSH_LOB_BUFFER
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Syntax LOB_ERASE OF {FileName} {FieldNumber} {length} {offset}
82511>>>>>>>>>>>>>/// @Param FileName                     Name of the file containing the LOB column
82511>>>>>>>>>>>>>/// @Param FieldNumber          Number of the LOB column being erased
82511>>>>>>>>>>>>>/// @Param Length                       Length of chunk to erase from column
82511>>>>>>>>>>>>>/// @Param offset                       Starting position for erase
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Example
82511>>>>>>>>>>>>>/// Clear customer
82511>>>>>>>>>>>>>/// Find Gt customer by Recnum
82511>>>>>>>>>>>>>/// Lock
82511>>>>>>>>>>>>>/// Find Eq customer by Recnum
82511>>>>>>>>>>>>>/// LOB_LENGTH OF customer 13 to liTotalLength
82511>>>>>>>>>>>>>/// LOB_ERASE  OF customer 13    liTotalLength 1
82511>>>>>>>>>>>>>/// Unlock
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>//=============================================================================
82511>>>>>>>>>>>>>/// @Name        LOB_TRUNCATE
82511>>>>>>>>>>>>>/// @Description This command is used to trim a LOB column down to a
82511>>>>>>>>>>>>>/// specified length. By passing the table name and column number, the
82511>>>>>>>>>>>>>/// value in the column can then be trimmed down the specified length.
82511>>>>>>>>>>>>>/// This can be a useful command for clearing out a column before entering
82511>>>>>>>>>>>>>/// new data into it. Note that this command must write to a file that is active
82511>>>>>>>>>>>>>/// and locked. Also this command handles the save so no extra calls
82511>>>>>>>>>>>>>/// are needed to save the changes. This command can be used to clear out a field before adding new data
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
82511>>>>>>>>>>>>>/// @Status      Deprecated
82511>>>>>>>>>>>>>/// @Drivers     All
82511>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82511>>>>>>>>>>>>>/// @See                 LOB_APPEND LOB_LENGTH LOB_WRITE LOB_READ LOB_LOADFROMFILE LOB_ERASE FLUSH_LOB_BUFFER
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Syntax LOB_TRUNCATE of {FileName} {FieldNumber} to {variable}
82511>>>>>>>>>>>>>/// @Param FileName                     Name of the file
82511>>>>>>>>>>>>>/// @Param FieldNumber          The field number
82511>>>>>>>>>>>>>/// @Param length                       New length to truncate to
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Example
82511>>>>>>>>>>>>>/// Clear Customer
82511>>>>>>>>>>>>>/// Find Gt Customer By Index.1
82511>>>>>>>>>>>>>/// Lock
82511>>>>>>>>>>>>>///    Find Eq Customer by Recnum
82511>>>>>>>>>>>>>///    SQL_LOB_TRUNCATE of Customer 13 to 0 // Customer.Comments
82511>>>>>>>>>>>>>///    Saverecord Customer
82511>>>>>>>>>>>>>/// Unlock
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>//=============================================================================
82511>>>>>>>>>>>>>/// @Name        FLUSH_LOB_BUFFER
82511>>>>>>>>>>>>>/// @Description This command currently serves no function.
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Assumptions
82511>>>>>>>>>>>>>/// @Status      Deprecated
82511>>>>>>>>>>>>>/// @Drivers     MySQLFlex
82511>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
82511>>>>>>>>>>>>>/// @See
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Syntax FLUSH_LOB_BUFFER of {FileName}
82511>>>>>>>>>>>>>/// @Param FileName                     Name of the file
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>//=============================================================================
82511>>>>>>>>>>>>>/// @Name        SQL_ENABLE_RECONNECT
82511>>>>>>>>>>>>>/// @Description Allow MySql Driver to auto reconnect after a time-out.
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// Driver auto-reconnect feature handles the issue where MySQL
82511>>>>>>>>>>>>>/// will kick off a user after inactivity.
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Status      Deprecated
82511>>>>>>>>>>>>>/// @Drivers     MySQL
82511>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-11 By Ian Smith
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Syntax SQL_ENABLE_RECONNECT of <ServerName> to dftrue/dffalse
82511>>>>>>>>>>>>>/// @Param ServerName  Server Name.
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Usage SQL_ENABLE_RECONNECT Of sServerID To dftrue
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>//=============================================================================
82511>>>>>>>>>>>>>/// @Name        CALL_MYSQL_STORED_PROCEDURE
82511>>>>>>>>>>>>>/// @Description This command is used to call a stored procedure on the SQL
82511>>>>>>>>>>>>>/// backend. To successfully call a procedure with this command, a string
82511>>>>>>>>>>>>>/// must be passed containing a valid procedure name. In addition, if the
82511>>>>>>>>>>>>>/// procedure takes any arguments, they must also be passed using the constant
82511>>>>>>>>>>>>>/// "passing" along with all of the needed arguments. If the procedure has a
82511>>>>>>>>>>>>>/// return value, then SQL_GET_FUNCTION_RETURN or SQL_FETCH_NEXT_ROW can be
82511>>>>>>>>>>>>>/// used to get the value(s). If an error is found then the indicator "Err"
82511>>>>>>>>>>>>>/// is set to true.
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Assumptions
82511>>>>>>>>>>>>>/// @Status      Deprecated
82511>>>>>>>>>>>>>/// @Drivers     MySQLFlex
82511>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82511>>>>>>>>>>>>>/// @See                 CALL_STORED_PROCEDURE
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Syntax CALL_MYSQL_STORED_PROCEDURE {procedure} Passing {argument}
82511>>>>>>>>>>>>>/// @Param procedure            Full name of the procedure
82511>>>>>>>>>>>>>/// @Param argument                     Argument to pass (can be multiple)
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Example
82511>>>>>>>>>>>>>/// CALL_MYSQL_STORED_PROCEDURE "getCustomerStatus" passing sCustomerID sStatus
82511>>>>>>>>>>>>>/// SQL_GET_PROCEDURE_PARAMETER 2 to sStatus
82511>>>>>>>>>>>>>/// Showln sStatus
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>//=============================================================================
82511>>>>>>>>>>>>>/// @Name        CALL_MYSQL_STORED_FUNCTION
82511>>>>>>>>>>>>>/// @Description This command is used to execute a function stored in MySQL.
82511>>>>>>>>>>>>>/// This is an alternative to building a function with the SQL_SET_FUNCTION_NAME,
82511>>>>>>>>>>>>>/// SQL_SET_FUNCTION_PARAMETER and SQL_FUNCTION_EXECUTE commands. This command
82511>>>>>>>>>>>>>/// builds and executes the function by setting the full function name, the
82511>>>>>>>>>>>>>/// parameter(s) to pass and the variable to hold the returned value. Note that
82511>>>>>>>>>>>>>/// this command can only return a single value so SQL_SET_FUNCTION_PARAMETER
82511>>>>>>>>>>>>>/// and SQL_SET_FUNCTION_NAME must be used when dealing with multiple return
82511>>>>>>>>>>>>>/// values.
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Status      Deprecated
82511>>>>>>>>>>>>>/// @Drivers     MySQLFlex
82511>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82511>>>>>>>>>>>>>/// @See                 CALL_STORED_FUNCTION
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Syntax CALL_MYSQL_STORED_FUNCTION {function} Returns {variable} Passing {argument}
82511>>>>>>>>>>>>>/// @Param function                     Full name of the function
82511>>>>>>>>>>>>>/// @Param variable                     Variable to hold the returned value
82511>>>>>>>>>>>>>/// @Param argument                     Argument to pass (can be multiple)
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Example
82511>>>>>>>>>>>>>/// CALL_MYSQL_STORED_FUNCTION "getCustomerStatus" Returns sStatus passing sCustomerID
82511>>>>>>>>>>>>>/// Showln sStatus
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>//=============================================================================
82511>>>>>>>>>>>>>/// @Name        DO_SET_ALL_FUNCTION_PARAMETERS
82511>>>>>>>>>>>>>/// @Description Sets the parameters for a MySQL stored function call.
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Assumptions
82511>>>>>>>>>>>>>/// @Status      Internal
82511>>>>>>>>>>>>>/// @Drivers     MySQLFlex
82511>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-21 By Ian Smith
82511>>>>>>>>>>>>>/// @See
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Syntax DO_SET_ALL_FUNCTION_PARAMETERS [sParam1 [sParam2 . sParamn]]
82511>>>>>>>>>>>>>/// @Param sParam1.n    Parameters for the stored function
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>//=============================================================================
82511>>>>>>>>>>>>>/// @Name        GET_NO_AVAILABLE_SQLSERVERS
82511>>>>>>>>>>>>>/// @Description This command is used to get the number of available MSSQL
82511>>>>>>>>>>>>>/// servers detected in the network. When used with GET_SQLSERVER_NAME,
82511>>>>>>>>>>>>>/// all the available server names can be easily retrieved.
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Assumptions SQL Server Browser Service is started and firewall is configured properly
82511>>>>>>>>>>>>>/// @Status      Public
82511>>>>>>>>>>>>>/// @Drivers     SQLFlex
82511>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82511>>>>>>>>>>>>>/// @See                 GET_SQLSERVER_NAME
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Syntax GET_NO_AVAILABLE_SQLSERVERS to {variable}
82511>>>>>>>>>>>>>/// @Param variable                     Variable to hold number of servers
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Example
82511>>>>>>>>>>>>>/// GET_NO_AVAILABLE_SQLSERVERS to iServers
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// While (i <= iServers)
82511>>>>>>>>>>>>>///     GET_SQLSERVER_NAME i to sServer
82511>>>>>>>>>>>>>///     Showln sServer
82511>>>>>>>>>>>>>///     Increment i
82511>>>>>>>>>>>>>/// Loop
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>Function SQL_AVAILABLE_SQL_SERVERS Global Returns Integer
82513>>>>>>>>>>>>>    Call_Driver 0 SQLFLEX Function CALLDRV_ENUMERATE_SERVER CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank CALLDRV_ENUMERATE_SERVER_COUNT RESULT MertechInc_iRet
82518>>>>>>>>>>>>>
82518>>>>>>>>>>>>>    Function_Return MertechInc_iRet
82519>>>>>>>>>>>>>End_Function
82520>>>>>>>>>>>>>
82520>>>>>>>>>>>>>
82520>>>>>>>>>>>>>//=============================================================================
82520>>>>>>>>>>>>>/// @Name        GET_SQLSERVER_NAME
82520>>>>>>>>>>>>>/// @Description This command returns the name of the server based on the
82520>>>>>>>>>>>>>/// specified index number. The number of servers can be retrieved from
82520>>>>>>>>>>>>>/// GET_NO_AVAILABLE_SQLSERVERS and the names can be indexed from that
82520>>>>>>>>>>>>>/// number.
82520>>>>>>>>>>>>>///
82520>>>>>>>>>>>>>/// @Assumptions SQL Server Browser Service is started and firewall is configured properly
82520>>>>>>>>>>>>>/// @Status      Public
82520>>>>>>>>>>>>>/// @Drivers     SQLFlex
82520>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82520>>>>>>>>>>>>>/// @See                 GET_NO_AVAILABLE_SQLSERVERS
82520>>>>>>>>>>>>>///
82520>>>>>>>>>>>>>/// @Syntax SQL_AVAILABLE_SQL_SERVER_NAME {index} to {variable}
82520>>>>>>>>>>>>>/// @Param index                The numbered index name to retrieve
82520>>>>>>>>>>>>>/// @Param variable             Variable to hold the server name
82520>>>>>>>>>>>>>///
82520>>>>>>>>>>>>>/// @Example
82520>>>>>>>>>>>>>/// GET_NO_AVAILABLE_SQLSERVERS to iServers
82520>>>>>>>>>>>>>///
82520>>>>>>>>>>>>>/// While (i <= iServers)
82520>>>>>>>>>>>>>///     GET_SQLSERVER_NAME i to sServer
82520>>>>>>>>>>>>>///     Showln sServer
82520>>>>>>>>>>>>>///     Increment i
82520>>>>>>>>>>>>>/// Loop
82520>>>>>>>>>>>>>
82520>>>>>>>>>>>>>Function SQL_AVAILABLE_SQL_SERVER_NAME Global Integer iIndex Returns String
82522>>>>>>>>>>>>>    String sName
82522>>>>>>>>>>>>>
82522>>>>>>>>>>>>>    Get MertechInc_Pre_Size_String 80 to sName
82523>>>>>>>>>>>>>    Call_Driver 0 SQLFLEX Function CALLDRV_ENUMERATE_SERVER CALLBACK 0 PASSING sName iIndex CALLDRV_ENUMERATE_SERVER_SERVER RESULT MertechInc_iRet
82528>>>>>>>>>>>>>
82528>>>>>>>>>>>>>    Function_Return sName
82529>>>>>>>>>>>>>End_Function
82530>>>>>>>>>>>>>
82530>>>>>>>>>>>>>
82530>>>>>>>>>>>>>//=============================================================================
82530>>>>>>>>>>>>>/// @Name        SET_USE_ROWCOUNT_IN_TRANSACTION
82530>>>>>>>>>>>>>/// @Description Turn on / off Row_Count for specified server.
82530>>>>>>>>>>>>>/// @Status      Deprecated
82530>>>>>>>>>>>>>/// @Drivers     All
82530>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-21 By Ian Smith
82530>>>>>>>>>>>>>///
82530>>>>>>>>>>>>>/// @Syntax SET_USE_ROWCOUNT_IN_TRANSACTION OF <Server> To <State>
82530>>>>>>>>>>>>>/// @Param Server      Name of server to turn On / Off Row_Count
82530>>>>>>>>>>>>>/// @Param State       TRUE = turn on Row_Count  FALSE = turn off Row_Count
82530>>>>>>>>>>>>>///
82530>>>>>>>>>>>>>/// @Comment This SHOULD ALWAYS BE TURNED ON
82530>>>>>>>>>>>>>
82530>>>>>>>>>>>>>Procedure Set SQL_USE_ROWCOUNT_IN_TRANSACTIONS Global String sServer Integer iState
82532>>>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
82534>>>>>>>>>>>>>
82534>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_USE_ROWCOUNT_IN_TRANSACTIONS CALLBACK 0 PASSING sServer iState CALLDRV_VALUE_SET RESULT MertechInc_iRet
82539>>>>>>>>>>>>>    If MertechInc_iRet EQ -1 INDICATE ERR True
82542>>>>>>>>>>>>>End_Procedure
82543>>>>>>>>>>>>>
82543>>>>>>>>>>>>>//IGS - commented out by a.n. Other
82543>>>>>>>>>>>>>//#REPLACE UseRowCountInTransactions SQL_USE_ROWCOUNT_IN_TRANSACTIONS
82543>>>>>>>>>>>>>
82543>>>>>>>>>>>>>//=============================================================================
82543>>>>>>>>>>>>>/// @Name        GET_USE_ROWCOUNT_IN_TRANSACTION
82543>>>>>>>>>>>>>/// @Description Gets the Row_Count setting for specified server.
82543>>>>>>>>>>>>>/// @Status      Deprecated
82543>>>>>>>>>>>>>/// @Drivers     All
82543>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-21 By Ian Smith
82543>>>>>>>>>>>>>///
82543>>>>>>>>>>>>>/// @Syntax GET_USE_ROWCOUNT_IN_TRANSACTION OF <Server> To <State>
82543>>>>>>>>>>>>>/// @Param Server      Name of server to get Row_Count state of
82543>>>>>>>>>>>>>/// @Param State       Variable to hold returned value
82543>>>>>>>>>>>>>
82543>>>>>>>>>>>>>Function SQL_USE_ROWCOUNT_IN_TRANSACTIONS Global String sServer Returns Integer
82545>>>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
82547>>>>>>>>>>>>>
82547>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_USE_ROWCOUNT_IN_TRANSACTIONS CALLBACK 0 PASSING sServer MertechInc_Blank CALLDRV_VALUE_GET RESULT MertechInc_iRet
82552>>>>>>>>>>>>>
82552>>>>>>>>>>>>>    Function_Return MertechInc_iRet
82553>>>>>>>>>>>>>End_Function
82554>>>>>>>>>>>>>
82554>>>>>>>>>>>>>
82554>>>>>>>>>>>>>//=============================================================================
82554>>>>>>>>>>>>>/// @Name        SQL_SET_DATE_FORMAT
82554>>>>>>>>>>>>>/// @Description This command controls the date format of data returned
82554>>>>>>>>>>>>>/// through embedded SQL. If set to DATAFLEX, then the dates will be
82554>>>>>>>>>>>>>/// returned in whatever format is set in DF_DATE_FORMAT. When set to
82554>>>>>>>>>>>>>/// NATIVE, this command will force dates to return dates in the format
82554>>>>>>>>>>>>>/// specified on the SQL server. Note that in order for the variables to
82554>>>>>>>>>>>>>/// be in the right form, they need to be string variables.
82554>>>>>>>>>>>>>///
82554>>>>>>>>>>>>>/// @Assumptions
82554>>>>>>>>>>>>>/// @Status      Public
82554>>>>>>>>>>>>>/// @Drivers     SQLFlex
82554>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82554>>>>>>>>>>>>>/// @See
82554>>>>>>>>>>>>>///
82554>>>>>>>>>>>>>/// @Syntax SQL_SET_DATE_FORMAT to {DATAFLEX/NATIVE}
82554>>>>>>>>>>>>>///
82554>>>>>>>>>>>>>/// @Example
82554>>>>>>>>>>>>>/// SQL_SET_DATE_FORMAT to NATIVE
82554>>>>>>>>>>>>>
82554>>>>>>>>>>>>>Procedure Set SQL_USE_DATAFLEX_DATEFORMAT Global Integer iState
82556>>>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
82558>>>>>>>>>>>>>
82558>>>>>>>>>>>>>    If MertechInc_DriverName eq SQLFlex Begin
82560>>>>>>>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_USE_DFLEX_DATE_FORMAT CALLBACK 0 PASSING iState MertechInc_Blank CALLDRV_VALUE_SET RESULT MertechInc_iRet
82565>>>>>>>>>>>>>        IF MertechInc_iRet EQ -1 INDICATE ERR TRUE
82568>>>>>>>>>>>>>    End
82568>>>>>>>>>>>>>>
82568>>>>>>>>>>>>>End_Procedure
82569>>>>>>>>>>>>>
82569>>>>>>>>>>>>>Function SQL_USE_DATAFLEX_DATEFORMAT Global Returns Integer
82571>>>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
82573>>>>>>>>>>>>>
82573>>>>>>>>>>>>>    If MertechInc_DriverName eq SQLFlex Begin
82575>>>>>>>>>>>>>        CALL_DRIVER 0 MertechInc_DriverName FUNCTION CALLDRV_USE_DFLEX_DATE_FORMAT CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank CALLDRV_VALUE_GET RESULT MertechInc_iRet
82580>>>>>>>>>>>>>    End
82580>>>>>>>>>>>>>>
82580>>>>>>>>>>>>>    Else Move DFFALSE to MertechInc_iRet
82582>>>>>>>>>>>>>
82582>>>>>>>>>>>>>    function_return MertechInc_iRet
82583>>>>>>>>>>>>>End_Function
82584>>>>>>>>>>>>>
82584>>>>>>>>>>>>>
82584>>>>>>>>>>>>>//=============================================================================
82584>>>>>>>>>>>>>/// @Name        SET_FIELDS_NOT_NULL
82584>>>>>>>>>>>>>/// @Description This command is used to specify how to handle blank
82584>>>>>>>>>>>>>/// and zero values on the SQL backend. Since blank or zero values can
82584>>>>>>>>>>>>>/// often be stored as null in the server database, this command allows
82584>>>>>>>>>>>>>/// that to be altered if needed. When set to true, a value will be
82584>>>>>>>>>>>>>/// inserted into blank records to keep them from being null. See the
82584>>>>>>>>>>>>>/// list below for what value will be stored instead of null. If set to
82584>>>>>>>>>>>>>/// false, values will be stored normally in the database. Note that this
82584>>>>>>>>>>>>>/// command effects all data types.
82584>>>>>>>>>>>>>///
82584>>>>>>>>>>>>>/// DF_ASCII and DF_TEXT -              ' ' (one blank space)
82584>>>>>>>>>>>>>///
82584>>>>>>>>>>>>>/// DF_BCD -                                    0 (zero)
82584>>>>>>>>>>>>>///
82584>>>>>>>>>>>>>/// DF_DATe and DF_DATETIME -   00/00/0000 for MYSQL
82584>>>>>>>>>>>>>///                                                             01/01/0001 for Oracle MSSQL, and Postgre
82584>>>>>>>>>>>>>///                                                             01/01/1753 for MSSQL Datetimes
82584>>>>>>>>>>>>>///
82584>>>>>>>>>>>>>/// DF_BINARY -                                 0X0
82584>>>>>>>>>>>>>///
82584>>>>>>>>>>>>>/// @Assumptions
82584>>>>>>>>>>>>>/// @Status      Public
82584>>>>>>>>>>>>>/// @Drivers     All
82584>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
82584>>>>>>>>>>>>>/// @See                 SET_FIELDS_NULL GET_FIELDS_NULL
82584>>>>>>>>>>>>>///
82584>>>>>>>>>>>>>/// @Syntax SET_FIELDS_NOT_NULL to {variable}
82584>>>>>>>>>>>>>/// @Param variable             Boolean variable to indicate how to handle null values
82584>>>>>>>>>>>>>///
82584>>>>>>>>>>>>>
82584>>>>>>>>>>>>>Procedure Set SQL_FORCE_FIELDS_NOT_NULL Global Integer iState
82586>>>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
82588>>>>>>>>>>>>>
82588>>>>>>>>>>>>>    If (MertechInc_FileNumber <> -1) Begin
82590>>>>>>>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_FORCE_FIELDS_NOT_NULL CALLBACK 0 PASSING iState MertechInc_Blank CALLDRV_VALUE_SET RESULT MertechInc_iRet
82595>>>>>>>>>>>>>        If MertechInc_iRet EQ -1 INDICATE ERR True
82598>>>>>>>>>>>>>    End
82598>>>>>>>>>>>>>>
82598>>>>>>>>>>>>>End_Procedure
82599>>>>>>>>>>>>>
82599>>>>>>>>>>>>>
82599>>>>>>>>>>>>>
82599>>>>>>>>>>>>>
82599>>>>>>>>>>>>>Function SQL_FORCE_FIELDS_NOT_NULL Global Returns Integer
82601>>>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
82603>>>>>>>>>>>>>
82603>>>>>>>>>>>>>    If (MertechInc_FileNumber <> -1) Begin
82605>>>>>>>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_FORCE_FIELDS_NOT_NULL CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank CALLDRV_VALUE_GET RESULT MertechInc_iRet
82610>>>>>>>>>>>>>    End
82610>>>>>>>>>>>>>>
82610>>>>>>>>>>>>>    Else Move DFFALSE to MertechInc_iRet
82612>>>>>>>>>>>>>
82612>>>>>>>>>>>>>    Function_Return MertechInc_iRet
82613>>>>>>>>>>>>>End_Function
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>//=============================================================================
82614>>>>>>>>>>>>>/// @Name        SET_FIELDS_NULL
82614>>>>>>>>>>>>>/// @Description This command is used to specify how to store blank or zero
82614>>>>>>>>>>>>>/// values in the database. Since database can sometimes store these value,
82614>>>>>>>>>>>>>/// i.e. '' or 0, as null, using this command can be useful in managing that.
82614>>>>>>>>>>>>>/// When set to true, any value in a column of the given type considered blank
82614>>>>>>>>>>>>>/// or 0 will be stored as null in the database. Setting it to false will cause
82614>>>>>>>>>>>>>/// the server to save as it normally would. Note that this command is used to
82614>>>>>>>>>>>>>/// set specific data types only, it can not effect all types at once. Below is
82614>>>>>>>>>>>>>/// a list of value that would be considered blank/zero values.
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// DF_ASCII and DF_TEXT -              ' ' (one blank space)
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// DF_BCD -                                    0 (zero)
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// DF_DATe and DF_DATETIME -   00/00/0000 for MYSQL
82614>>>>>>>>>>>>>///                                                             01/01/0001 for Oracle MSSQL, and Postgre
82614>>>>>>>>>>>>>///                                                             01/01/1753 for MSSQL Datetimes
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// DF_BINARY -                                 0X0
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Assumptions
82614>>>>>>>>>>>>>/// @Status      Public
82614>>>>>>>>>>>>>/// @Drivers     All
82614>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
82614>>>>>>>>>>>>>/// @See                 GET_FIELDS_NULL SET_FIELDS_NOT_NULL
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Syntax SET_FIELDS_NULL {datatype} to {variable}
82614>>>>>>>>>>>>>/// @Param datatype                     DF_ASCII, DF_BCD, or DF_DATE
82614>>>>>>>>>>>>>/// @Param variable             Boolean to indicate how to handle blank data
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>//=============================================================================
82614>>>>>>>>>>>>>/// @Name        GET_FIELDS_NULL
82614>>>>>>>>>>>>>/// @Description This command will return the value of SET_FIELDS_NULL for
82614>>>>>>>>>>>>>/// the specified data type.
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Assumptions
82614>>>>>>>>>>>>>/// @Status      Public
82614>>>>>>>>>>>>>/// @Drivers     All
82614>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
82614>>>>>>>>>>>>>/// @See                 SET_FIELDS_NULL SET_FIELDS_NOT_NULL
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Syntax GET_FIELDS_NULL {datatype} to {variable}
82614>>>>>>>>>>>>>/// @Param datatype                     DF_ASCII, DF_BCD, or DF_DATE
82614>>>>>>>>>>>>>/// @Param variable             Variable to hold the value of SET_FIELDS_NULL
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>//=============================================================================
82614>>>>>>>>>>>>>/// @Name        STRUCTURE_START_DYNAMIC
82614>>>>>>>>>>>>>/// @Description This command is used when scripting structural changes.
82614>>>>>>>>>>>>>/// It is the same as using ENABLE_SCRIPTING and Structure_Start separately.
82614>>>>>>>>>>>>>/// It allows structural changes to be compiled and tested without
82614>>>>>>>>>>>>>/// actually making any of the changes. Any table restructuring done
82614>>>>>>>>>>>>>/// between this command and STRUCTURE_END_DYNAMIC will not actually be
82614>>>>>>>>>>>>>/// committed but will instead create a mock INT file. The script and
82614>>>>>>>>>>>>>/// INT file can then be retrieved and examined for testing purposes.
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Assumptions
82614>>>>>>>>>>>>>/// @Status      Deprecated
82614>>>>>>>>>>>>>/// @Drivers     All
82614>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82614>>>>>>>>>>>>>/// @See                 ENABLE_SCRIPTING DISABLE_SCRIPTING
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Syntax STRUCTURE_START_DYNAMIC of {FileNumber}
82614>>>>>>>>>>>>>/// @Param FileNumber                   The number of the file
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>//=============================================================================
82614>>>>>>>>>>>>>/// @Name        STRUCTURE_END_DYNAMIC
82614>>>>>>>>>>>>>/// @Description This command ends the scripting started by
82614>>>>>>>>>>>>>/// STRUCTURE_START_DYNAMIC. It is the same as calling Structure_End
82614>>>>>>>>>>>>>/// and DISABLE_SCRIPTING separately.
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Assumptions
82614>>>>>>>>>>>>>/// @Status      Deprecated
82614>>>>>>>>>>>>>/// @Drivers     All
82614>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82614>>>>>>>>>>>>>/// @See                 ENABLE_SCRIPTING DISABLE_SCRIPTING
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Syntax STRUCTURE_START_DYNAMIC of {FileNumber}
82614>>>>>>>>>>>>>/// @Param FileNumber                   The number of the file
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>//=============================================================================
82614>>>>>>>>>>>>>/// @Name        SQLSERVER_ATTACH_DB
82614>>>>>>>>>>>>>/// @Description Attachs an MS SQL mdf to the current server instance. If
82614>>>>>>>>>>>>>/// the passed database is already attached, no error is generated.
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// The SQLSERVER_ATTACH_DB command is intended for use with our new support
82614>>>>>>>>>>>>>/// of Microsoft LocalDB's.  When using LocalDB's a common use case might be
82614>>>>>>>>>>>>>/// to attach to a customer DB, do some work on it, and then detach this DB
82614>>>>>>>>>>>>>/// and attach to a different DB.  This was possible using stored procedures,
82614>>>>>>>>>>>>>/// but the code had some complexities that a developer need not worry about.
82614>>>>>>>>>>>>>/// When you attach a database, you must pass the database name, along with
82614>>>>>>>>>>>>>/// the path to an MDF file which contains the database.  Any associated LDF's
82614>>>>>>>>>>>>>/// (log files) and NDF's (secondary data files) must be in the same folder.
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// If you call SQLSERVER_ATTACH_DB on a database that is already attached,
82614>>>>>>>>>>>>>/// no error will be generated.  After you call SQLSERVER_ATTACH_DB, you
82614>>>>>>>>>>>>>/// should call SET_DATABASE_NAME if you wish to make the attached database
82614>>>>>>>>>>>>>/// the currently selected database.
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// SQLSERVER_ATTACH_DB will work on all supported version of SQL server.
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Assumptions
82614>>>>>>>>>>>>>/// @Status      Public
82614>>>>>>>>>>>>>/// @Drivers     SQLFlex
82614>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 Aaron Gulack
82614>>>>>>>>>>>>>/// @See
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Syntax SQLSERVER_ATTACH_DB {database} on {filePath}
82614>>>>>>>>>>>>>/// @Param database                     Name of the database
82614>>>>>>>>>>>>>/// @Param filePath                     Path of the MDF file
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Example
82614>>>>>>>>>>>>>/// SQLSERVER_ATTACH_DB "MTSample" ON "C:\Mertech\Data\SampleDb.mdf"
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>//=============================================================================
82614>>>>>>>>>>>>>/// @Name        SQLSERVER_DETACH_DB
82614>>>>>>>>>>>>>/// @Description The SQLSERVER_DETACH_DB command is intended for use with our
82614>>>>>>>>>>>>>/// new support of Microsoft LocalDB's.  When using LocalDB's a common use
82614>>>>>>>>>>>>>/// case might be to attach to a customer DB, do some work on it, and then
82614>>>>>>>>>>>>>/// detach this DB and attach to a different DB.  This was possible using
82614>>>>>>>>>>>>>/// stored procedures, but the code had some complexities that a developer
82614>>>>>>>>>>>>>/// need not worry about.  A detach can only be done if the database passed
82614>>>>>>>>>>>>>/// has no open connections.  As part of the detach process, the command
82614>>>>>>>>>>>>>/// closes ALL open files (even those not associated with this database or
82614>>>>>>>>>>>>>/// driver).
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// NOTE: SQLSERVER_DETACH_DB will often fail to execute if you are testing
82614>>>>>>>>>>>>>/// your application from the studio.  This is because the studio itself
82614>>>>>>>>>>>>>/// normally has open connections to the database.  If you test your
82614>>>>>>>>>>>>>/// application outside of the studio and the studio is closed (and any
82614>>>>>>>>>>>>>/// other application or tools that access this database are closed) you
82614>>>>>>>>>>>>>/// can successfully detach the database.
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Assumptions
82614>>>>>>>>>>>>>/// @Status      Public
82614>>>>>>>>>>>>>/// @Drivers     SQLFlex
82614>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82614>>>>>>>>>>>>>/// @See
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Syntax SQLSERVER_DETACH_DB {database}
82614>>>>>>>>>>>>>/// @Param database                     Name of the database
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Example
82614>>>>>>>>>>>>>/// SQLSERVER_DETACH_DB "TestDB"
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>//=============================================================================
82614>>>>>>>>>>>>>/// @Name        SET_FIXED_FILE_RECORDS_USED
82614>>>>>>>>>>>>>/// @Description This command is used to set DF_FILE_RECORDS_USED to a
82614>>>>>>>>>>>>>/// fixed value. This can be useful because doing a SELECT COUNT(*) is
82614>>>>>>>>>>>>>/// a very expensive process to the server. Many applications do counts
82614>>>>>>>>>>>>>/// often and using this command can help cut down the server traffic.
82614>>>>>>>>>>>>>/// Sometimes when counts are used, an exact number is not necessary so
82614>>>>>>>>>>>>>/// a fixed value, updated occasionally can be used. By setting this
82614>>>>>>>>>>>>>/// command to 0 or greater, the value of DF_FILE_RECORDS_USED will be
82614>>>>>>>>>>>>>/// set to that specified value and the internal SELECT COUNT(*) will be
82614>>>>>>>>>>>>>/// suppressed. If this command is set to something less that zero,
82614>>>>>>>>>>>>>/// DF_FILE_RECORDS_USED will be dynamically calculated whenever it is
82614>>>>>>>>>>>>>/// called.
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// The default value for this command is -1
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Assumptions
82614>>>>>>>>>>>>>/// @Status              Public
82614>>>>>>>>>>>>>/// @Drivers     All
82614>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82614>>>>>>>>>>>>>/// @See                 GET_FIXED_FILE_RECORDS_USED SUPPRESS_SELECT_COUNT UNSUPPRESS_SELECT_COUNT
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Syntax SET_FIXED_FILE_RECORDS_USED to {variable}
82614>>>>>>>>>>>>>/// @Param variable                     Fixed value for DF_FILE_RECORDS_USED
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Example
82614>>>>>>>>>>>>>/// SET_FIXED_FILE_RECORDS_USED to 10000
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>//=============================================================================
82614>>>>>>>>>>>>>/// @Name        GET_FIXED_FILE_RECORDS_USED
82614>>>>>>>>>>>>>/// @Description This command returns the value of DF_FILE_RECORDS_USED
82614>>>>>>>>>>>>>/// if it has been set to a fixed value by SET_FIXED_FILE_RECORDS_USED.
82614>>>>>>>>>>>>>/// If anything greater than or equal to 0 is returned then that is the
82614>>>>>>>>>>>>>/// fixed value returned by any SELECT COUNT(*) statements, internal or
82614>>>>>>>>>>>>>/// not. If something less than zero is returned, then DF_FILE_RECORDS_USED
82614>>>>>>>>>>>>>/// returns a dynamic count whenever it is called.
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// By default the value of this is -1
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Assumptions
82614>>>>>>>>>>>>>/// @Status              Public
82614>>>>>>>>>>>>>/// @Drivers     All
82614>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82614>>>>>>>>>>>>>/// @See                 SET_FIXED_FILE_RECORDS_USED SUPPRESS_SELECT_COUNT UNSUPPRESS_SELECT_COUNT
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Syntax GET_FILE_RECORDS_USED to {variable}
82614>>>>>>>>>>>>>/// @Param variable                     Variable to hold the fixed value
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Example
82614>>>>>>>>>>>>>/// GET_FIXED_FILE_RECORDS_USED to iRecords
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>//=============================================================================
82614>>>>>>>>>>>>>/// @Name        SUPPRESS_SELECT_COUNT
82614>>>>>>>>>>>>>/// @Description This command sets the value of DF_FILE_RECORDS_USED to
82614>>>>>>>>>>>>>/// a fixed value of zero. That way anytime a SELECT COUNT(*) is done,
82614>>>>>>>>>>>>>/// zero is returned, cutting down on server traffic. This is the same
82614>>>>>>>>>>>>>/// as setting SET_FIXED_FILE_RECORDS_USED to 0.
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Assumptions
82614>>>>>>>>>>>>>/// @Status      Public
82614>>>>>>>>>>>>>/// @Drivers     All
82614>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82614>>>>>>>>>>>>>/// @See                 UNSUPPRESS_SELECT_COUNT SET_FIXED_FILE_RECORDS_USED GET_FIXED_FILE_RECORDS_USED
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Syntax SUPPRESS_SELECT_COUNT
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>//=============================================================================
82614>>>>>>>>>>>>>/// @Name        UNSUPPRESS_SELECT_COUNT
82614>>>>>>>>>>>>>/// @Description This command resets the value of DF_FILE_RECORDS_USED to
82614>>>>>>>>>>>>>/// -1. That way anytime a SELECT COUNT(*) is done, it returns the actual
82614>>>>>>>>>>>>>/// count of records. This is the same as setting SET_FIXED_FILE_RECORDS_USED
82614>>>>>>>>>>>>>/// to -1.
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Assumptions
82614>>>>>>>>>>>>>/// @Status      Public
82614>>>>>>>>>>>>>/// @Drivers     All
82614>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82614>>>>>>>>>>>>>/// @See                 SUPPRESS_SELECT_COUNT SET_FIXED_FILE_RECORDS_USED GET_FIXED_FILE_RECORDS_USED
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Syntax UNSUPPRESS_SELECT_COUNT
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>// Private:
82614>>>>>>>>>>>>>// Get the filenumber of a file.field parameter
82614>>>>>>>>>>>>>//
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>// Private:
82614>>>>>>>>>>>>>// Get the fieldnumber of a file.field parameter
82614>>>>>>>>>>>>>//
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>//
82614>>>>>>>>>>>>>// Minimum required DataFlex version for new LOB support below is VDF 4
82614>>>>>>>>>>>>>//
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>TYPE tMertechLOB_Args
82614>>>>>>>>>>>>>    FIELD tMertechLOB_Args.cbSize       AS WORD          // always the size of the structure (verification + versioning)
82614>>>>>>>>>>>>>    FIELD tMertechLOB_Args.nField       AS DWORD         // always the field number
82614>>>>>>>>>>>>>    FIELD tMertechLOB_Args.pszData      AS POINTER
82614>>>>>>>>>>>>>    FIELD tMertechLOB_Args.nSize        AS DWORD
82614>>>>>>>>>>>>>    FIELD tMertechLOB_Args.nOffset      AS POINTER
82614>>>>>>>>>>>>>END_TYPE
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>//=============================================================================
82614>>>>>>>>>>>>>/// @Name        SQL_SET_LOB
82614>>>>>>>>>>>>>/// @Description This command replaces whatever is currently in a LOB Field
82614>>>>>>>>>>>>>/// with the data passed. It writes to a client side buffer. It can be used
82614>>>>>>>>>>>>>/// to Write an arbitrary amount of data into a LOB.
82614>>>>>>>>>>>>>/// If passed an empty String, it will remove all the contents of the LOB.
82614>>>>>>>>>>>>>/// If you wish to Set a LOB back to NULL, please use the SQL_SET_LOB_NULL
82614>>>>>>>>>>>>>/// command.
82614>>>>>>>>>>>>>/// NOTE: Unlike the previous call LOB_WRITE, this call does not
82614>>>>>>>>>>>>>/// perform the Save. This must be done separately.
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
82614>>>>>>>>>>>>>/// @Status      Public
82614>>>>>>>>>>>>>/// @Drivers     All
82614>>>>>>>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
82614>>>>>>>>>>>>>/// @See                 SQL_ADD_LOB_CHUNK SQL_GET_LOB SQL_GET_LOB_CHUNK SQL_GET_LOB_LENGTH SQL_LOB_TRUNCATE
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Syntax             SQL_SET_LOB {FileName.FieldName} to {variable}
82614>>>>>>>>>>>>>/// @Param              FileName                The name of the file containing the LOB field
82614>>>>>>>>>>>>>/// @Param              FieldName               The name of the LOB field being set
82614>>>>>>>>>>>>>/// @Param              variable                The variable to use to set the field's value
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Example
82614>>>>>>>>>>>>>/// Set_Argument_Size 262144
82614>>>>>>>>>>>>>/// String sLine
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// Clear Customer
82614>>>>>>>>>>>>>///    Move iID to Customer.ID
82614>>>>>>>>>>>>>/// Find Eq Customer by Index.1
82614>>>>>>>>>>>>>/// If (Found) Begin
82614>>>>>>>>>>>>>///    Direct_Input "C:\bigFile.xml"
82614>>>>>>>>>>>>>///    Reread Customer
82614>>>>>>>>>>>>>///       SQL_SET_LOB Customer.Comments to ""
82614>>>>>>>>>>>>>///       Read_Block sLine 262144
82614>>>>>>>>>>>>>///       SQL_SET_LOB Customer.Comments to sLine
82614>>>>>>>>>>>>>///       While (not(SeqEof))
82614>>>>>>>>>>>>>///          Read_Block sLine 262144
82614>>>>>>>>>>>>>///          SQL_ADD_LOB_CHUNK Customer.Comments to sLine
82614>>>>>>>>>>>>>///       Loop
82614>>>>>>>>>>>>>///    Saverecord Customer
82614>>>>>>>>>>>>>///    Unlock
82614>>>>>>>>>>>>>///    Close_Input
82614>>>>>>>>>>>>>/// End
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_LOB String sDriver Integer iFile Integer iField String sData
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
82616>>>>>>>>>>>>>    String sLOB_Args       // can drop local command if minimum vdf version is 6
82616>>>>>>>>>>>>>
82616>>>>>>>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
82617>>>>>>>>>>>>>    // First move the size of the structure to the Structure
82617>>>>>>>>>>>>>    Put tMertechLOB_Args_size to sLOB_Args at tMertechLOB_Args.cbSize
82618>>>>>>>>>>>>>    Put iField                to sLOB_Args at tMertechLOB_Args.nField
82619>>>>>>>>>>>>>    Put (AddressOf(sData))    to sLOB_Args at tMertechLOB_Args.pszData
82620>>>>>>>>>>>>>    Put (length(sData))       to sLOB_Args at tMertechLOB_Args.nSize
82621>>>>>>>>>>>>>
82621>>>>>>>>>>>>>    Call_Driver iFile sDriver Function CALLDRV_LOB_EX_WRITE CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
82626>>>>>>>>>>>>>End_Procedure // MertechInc_SQL_SET_LOB
82627>>>>>>>>>>>>>
82627>>>>>>>>>>>>>//=============================================================================
82627>>>>>>>>>>>>>/// @Name        SQL_ADD_LOB_CHUNK
82627>>>>>>>>>>>>>/// @Description This command is used to add additional chunks to the buffer
82627>>>>>>>>>>>>>/// before saving the record. After SQL_SET_LOB has been called
82627>>>>>>>>>>>>>/// SQL_ADD_LOB_CHUNK can be called as many times as needed to add additional
82627>>>>>>>>>>>>>/// chunks of data before a save. It can also be called independent of
82627>>>>>>>>>>>>>/// SQL_SET_LOB to append data to an existing LOB column.
82627>>>>>>>>>>>>>/// NOTE: Unlike the previous call LOB_APPEND, this call does not perform
82627>>>>>>>>>>>>>/// the save. This must be done separately.
82627>>>>>>>>>>>>>///
82627>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
82627>>>>>>>>>>>>>/// @Status      Public
82627>>>>>>>>>>>>>/// @Drivers     All
82627>>>>>>>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
82627>>>>>>>>>>>>>/// @See                 SQL_SET_LOB SQL_GET_LOB SQL_GET_LOB_CHUNK SQL_GET_LOB_LENGTH SQL_LOB_TRUNCATE
82627>>>>>>>>>>>>>///
82627>>>>>>>>>>>>>/// @Syntax             SQL_ADD_LOB_CHUNK {FileName.FieldName} to {variable}
82627>>>>>>>>>>>>>/// @Param              FileName                The name of the file containing the LOB field
82627>>>>>>>>>>>>>/// @Param              FieldName               The name of the LOB field being set
82627>>>>>>>>>>>>>/// @Param              variable                The variable to add as the LOB chunk
82627>>>>>>>>>>>>>///
82627>>>>>>>>>>>>>/// @Example
82627>>>>>>>>>>>>>/// Set_Argument_Size 262144
82627>>>>>>>>>>>>>/// String sLine
82627>>>>>>>>>>>>>///
82627>>>>>>>>>>>>>/// Clear Customer
82627>>>>>>>>>>>>>///    Move iID to Customer.ID
82627>>>>>>>>>>>>>/// Find Eq Customer by Index.1
82627>>>>>>>>>>>>>/// If (Found) Begin
82627>>>>>>>>>>>>>///    Direct_Input "C:\bigFile.xml"
82627>>>>>>>>>>>>>///    Reread Customer
82627>>>>>>>>>>>>>///       SQL_SET_LOB Customer.Comments to ""
82627>>>>>>>>>>>>>///       Read_Block sLine 262144
82627>>>>>>>>>>>>>///       SQL_SET_LOB Customer.Comments to sLine
82627>>>>>>>>>>>>>///       While (not(SeqEof))
82627>>>>>>>>>>>>>///          Read_Block sLine 262144
82627>>>>>>>>>>>>>///          SQL_ADD_LOB_CHUNK Customer.Comments to sLine
82627>>>>>>>>>>>>>///       Loop
82627>>>>>>>>>>>>>///    Saverecord Customer
82627>>>>>>>>>>>>>///    Unlock
82627>>>>>>>>>>>>>///    Close_Input
82627>>>>>>>>>>>>>/// End
82627>>>>>>>>>>>>>
82627>>>>>>>>>>>>>Procedure MertechInc_SQL_ADD_LOB_CHUNK String sDriver Integer iFile Integer iField String sData
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
82629>>>>>>>>>>>>>    String sLOB_Args
82629>>>>>>>>>>>>>
82629>>>>>>>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
82630>>>>>>>>>>>>>    // First move the size of the structure to the Structure
82630>>>>>>>>>>>>>    Put tMertechLOB_Args_size to sLOB_Args at tMertechLOB_Args.cbSize
82631>>>>>>>>>>>>>    Put iField                to sLOB_Args at tMertechLOB_Args.nField
82632>>>>>>>>>>>>>    Put (AddressOf(sData))    to sLOB_Args at tMertechLOB_Args.pszData
82633>>>>>>>>>>>>>    Put (length(sData))       to sLOB_Args at tMertechLOB_Args.nSize
82634>>>>>>>>>>>>>
82634>>>>>>>>>>>>>    Call_Driver iFile sDriver Function CALLDRV_LOB_EX_APPEND CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
82639>>>>>>>>>>>>>end_procedure // MertechInc_SQL_ADD_LOB_CHUNK
82640>>>>>>>>>>>>>
82640>>>>>>>>>>>>>//=============================================================================
82640>>>>>>>>>>>>>/// @Name        SQL_GET_LOB
82640>>>>>>>>>>>>>/// @Description This command is used for getting the value of a specified LOB
82640>>>>>>>>>>>>>/// field. Two optional parameters can be passed specifying the offset and
82640>>>>>>>>>>>>>/// length of the chunk to get. Passing these parameters essentially makes this
82640>>>>>>>>>>>>>/// call the same as SQL_GET_LOB_CHUNK.
82640>>>>>>>>>>>>>/// Depending on the situation, the two calls can be interchanged for improved
82640>>>>>>>>>>>>>/// code readability. Excluding these additional parameters will get the whole
82640>>>>>>>>>>>>>/// field value within DataFlex variable size limits.
82640>>>>>>>>>>>>>///
82640>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
82640>>>>>>>>>>>>>/// @Status      Public
82640>>>>>>>>>>>>>/// @Drivers     All
82640>>>>>>>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
82640>>>>>>>>>>>>>/// @See                 SQL_SET_LOB SQL_ADD_LOB_CHUNK SQL_GET_LOB_CHUNK SQL_GET_LOB_LENGTH SQL_LOB_TRUNCATE
82640>>>>>>>>>>>>>///
82640>>>>>>>>>>>>>/// @Syntax     SQL_GET_LOB {FileName.FieldName} TO {variable} [ OFFSET {offset} LENGTH {length} ]
82640>>>>>>>>>>>>>/// @Param              FileName                        The name of the file that contains the specified LOB field
82640>>>>>>>>>>>>>/// @Param              FieldName                       The name of the LOB field
82640>>>>>>>>>>>>>/// @Param              variable                        The variable to hold the LOB value
82640>>>>>>>>>>>>>/// @Param              offset                          Integer amount to offset when getting the LOB value (optional)
82640>>>>>>>>>>>>>/// @Param              length                          Length of value to get from the LOB field (optional)
82640>>>>>>>>>>>>>///
82640>>>>>>>>>>>>>/// @Example
82640>>>>>>>>>>>>>/// Set_Argument_Size 262144
82640>>>>>>>>>>>>>/// String sResult
82640>>>>>>>>>>>>>///
82640>>>>>>>>>>>>>/// Move 262144 to iChunkSize
82640>>>>>>>>>>>>>/// Move 0      to iChunk
82640>>>>>>>>>>>>>///
82640>>>>>>>>>>>>>/// Clear Customer
82640>>>>>>>>>>>>>///    Move iID to Customer.ID
82640>>>>>>>>>>>>>/// Find Eq Customer by Index.1
82640>>>>>>>>>>>>>/// If (Found) Begin
82640>>>>>>>>>>>>>///    Direct_Output ('Binary:' + sDestFileName)
82640>>>>>>>>>>>>>///    SQL_GET_LOB_LENGTH Customer.Comments to iLength
82640>>>>>>>>>>>>>///    While (iChunk*iChunkSize < iLength)
82640>>>>>>>>>>>>>///       SQL_GET_LOB Customer.Comments to sResult OFFSET (iChunk*iChunkSize) LENGTH iChunkSize
82640>>>>>>>>>>>>>///       Write sResult
82640>>>>>>>>>>>>>///       Increment iChunk
82640>>>>>>>>>>>>>///    Loop
82640>>>>>>>>>>>>>///    Close_Output
82640>>>>>>>>>>>>>/// End
82640>>>>>>>>>>>>>
82640>>>>>>>>>>>>>
82640>>>>>>>>>>>>>Function MertechInc_SQL_GET_LOB String sDriver Integer iFile Integer iField Integer iOffset Integer iLength Returns String
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
82642>>>>>>>>>>>>>    String sLOB_Args
82642>>>>>>>>>>>>>    String sData
82642>>>>>>>>>>>>>    DWord  nSize
82642>>>>>>>>>>>>>
82642>>>>>>>>>>>>>    Move "" To sData
82643>>>>>>>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
82644>>>>>>>>>>>>>    // First move the size of the structure to the Structure
82644>>>>>>>>>>>>>    Put tMertechLOB_Args_size to sLOB_Args at tMertechLOB_Args.cbSize
82645>>>>>>>>>>>>>    Put iField                to sLOB_Args at tMertechLOB_Args.nField
82646>>>>>>>>>>>>>
82646>>>>>>>>>>>>>    Call_Driver iFile sDriver Function CALLDRV_LOB_EX_GET_LENGTH CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
82651>>>>>>>>>>>>>
82651>>>>>>>>>>>>>    GetBuff from sLOB_Args at tMertechLOB_Args.nSize to nSize
82652>>>>>>>>>>>>>    If nSize GT 0 Begin
82654>>>>>>>>>>>>>      If (iOffset=0 and iLength=0) Begin
82656>>>>>>>>>>>>>        ZeroString nSize to sData
82657>>>>>>>>>>>>>            //Send Assert (AddressOf(sData) <> 0) ("AddressOf(sData) is NULL") DFTrue
82657>>>>>>>>>>>>>        Put (AddressOf(sData)) to sLOB_Args at tMertechLOB_Args.pszData
82658>>>>>>>>>>>>>      End
82658>>>>>>>>>>>>>>
82658>>>>>>>>>>>>>      Else Begin
82659>>>>>>>>>>>>>        ZeroString iLength to sData
82660>>>>>>>>>>>>>        Put (AddressOf(sData)) to sLOB_Args at tMertechLOB_Args.pszData
82661>>>>>>>>>>>>>        Put iLength            to sLOB_Args at tMertechLOB_Args.nSize
82662>>>>>>>>>>>>>        Put iOffset            to sLOB_Args at tMertechLOB_Args.nOffset
82663>>>>>>>>>>>>>      End
82663>>>>>>>>>>>>>>
82663>>>>>>>>>>>>>      Call_Driver iFile sDriver Function CALLDRV_LOB_EX_READ CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
82668>>>>>>>>>>>>>    End
82668>>>>>>>>>>>>>>
82668>>>>>>>>>>>>>    Else Begin
82669>>>>>>>>>>>>>        Move "" to sData
82670>>>>>>>>>>>>>    End
82670>>>>>>>>>>>>>>
82670>>>>>>>>>>>>>    Function_Return sData
82671>>>>>>>>>>>>>End_Function // MertechInc_SQL_GET_LOB
82672>>>>>>>>>>>>>
82672>>>>>>>>>>>>>//=============================================================================
82672>>>>>>>>>>>>>/// @Name        SQL_GET_LOB_CHUNK
82672>>>>>>>>>>>>>/// @Description This command is used for getting a chunk of data from a specified
82672>>>>>>>>>>>>>/// LOB field. The difference between this command and SQL_GET_LOB is only that
82672>>>>>>>>>>>>>/// the parameters OFFSET and LENGTH are not optional when using this command.
82672>>>>>>>>>>>>>/// You may consider using this command to retrieve small portions of a very
82672>>>>>>>>>>>>>/// large BLOB so as to reduce memory usage.
82672>>>>>>>>>>>>>///
82672>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
82672>>>>>>>>>>>>>/// @Status      Public
82672>>>>>>>>>>>>>/// @Drivers     All
82672>>>>>>>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
82672>>>>>>>>>>>>>/// @See                 SQL_SET_LOB SQL_ADD_LOB_CHUNK SQL_GET_LOB SQL_GET_LOB_LENGTH SQL_LOB_TRUNCATE
82672>>>>>>>>>>>>>///
82672>>>>>>>>>>>>>/// @Syntax     SQL_GET_LOB_CHUNK {FileName.FieldName} TO {variable} OFFSET {offset} LENGTH {length}
82672>>>>>>>>>>>>>/// @Param              FileName                        The name of the file that contains the specified LOB field
82672>>>>>>>>>>>>>/// @Param              FieldName                       The name of the LOB field
82672>>>>>>>>>>>>>/// @Param              variable                        The variable to hold the LOB chunk
82672>>>>>>>>>>>>>/// @Param              offset                          Integer amount to offset when getting the LOB chunk
82672>>>>>>>>>>>>>/// @Param              length                          Length of chunk to get from the LOB field
82672>>>>>>>>>>>>>///
82672>>>>>>>>>>>>>/// @Example
82672>>>>>>>>>>>>>/// Set_Argument_Size 262144
82672>>>>>>>>>>>>>/// String sResult
82672>>>>>>>>>>>>>///
82672>>>>>>>>>>>>>/// Move 262144 to iChunkSize
82672>>>>>>>>>>>>>/// Move 0      to iChunk
82672>>>>>>>>>>>>>///
82672>>>>>>>>>>>>>/// Clear Customer
82672>>>>>>>>>>>>>///    Move iID to Customer.ID
82672>>>>>>>>>>>>>/// Find Eq Customer by Index.1
82672>>>>>>>>>>>>>/// If (Found) Begin
82672>>>>>>>>>>>>>///    SQL_GET_LOB_LENGTH Customer.Comments to iLength
82672>>>>>>>>>>>>>///    While (iChunk*iChunkSize < iLength)
82672>>>>>>>>>>>>>///       SQL_GET_LOB_CHUNK Customer.Comments to sResult OFFSET (iChunk*iChunkSize) LENGTH iChunkSize
82672>>>>>>>>>>>>>///       // Do something with the LOB data
82672>>>>>>>>>>>>>///       Increment iChunk
82672>>>>>>>>>>>>>///    Loop
82672>>>>>>>>>>>>>/// End
82672>>>>>>>>>>>>>
82672>>>>>>>>>>>>>//=============================================================================
82672>>>>>>>>>>>>>/// @Name        SQL_GET_LOB_LENGTH
82672>>>>>>>>>>>>>/// @Description This command is used to get the length of a specified LOB field.
82672>>>>>>>>>>>>>/// It is useful, for example, in determining the number of iterations to
82672>>>>>>>>>>>>>/// perform while reading from a LOB field using chunking.
82672>>>>>>>>>>>>>///
82672>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
82672>>>>>>>>>>>>>/// @Status      Public
82672>>>>>>>>>>>>>/// @Drivers     All
82672>>>>>>>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
82672>>>>>>>>>>>>>/// @See                 SQL_SET_LOB SQL_ADD_LOB_CHUNK SQL_GET_LOB SQL_GET_LOB_CHUNK SQL_LOB_TRUNCATE
82672>>>>>>>>>>>>>///
82672>>>>>>>>>>>>>/// @Syntax             SQL_GET_LOB_LENGTH {FileName.FieldName} to {variable}
82672>>>>>>>>>>>>>/// @Param              FileName                        The name of the file containing the LOB field
82672>>>>>>>>>>>>>/// @Param              FieldName                       The name of the specified LOB field
82672>>>>>>>>>>>>>/// @Param              variable                        The variable to hold the length of the field
82672>>>>>>>>>>>>>///
82672>>>>>>>>>>>>>/// @Example
82672>>>>>>>>>>>>>/// Set_Argument_Size 262144
82672>>>>>>>>>>>>>/// String sResult
82672>>>>>>>>>>>>>///
82672>>>>>>>>>>>>>/// Move 16384 to iChunkSize
82672>>>>>>>>>>>>>/// Move 0     to iChunk
82672>>>>>>>>>>>>>///
82672>>>>>>>>>>>>>/// Clear Customer
82672>>>>>>>>>>>>>///    Move iID to Customer.ID
82672>>>>>>>>>>>>>/// Find Eq Customer by Index.1
82672>>>>>>>>>>>>>/// If (Found) Begin
82672>>>>>>>>>>>>>///    SQL_GET_LOB_LENGTH Customer.Comments to iLength
82672>>>>>>>>>>>>>///    While (iChunk*iChunkSize < iLength)
82672>>>>>>>>>>>>>///       SQL_GET_LOB Customer.Comments to sResult OFFSET (iChunk*iChunkSize) LENGTH iChunkSize
82672>>>>>>>>>>>>>///       // Do something with the LOB data
82672>>>>>>>>>>>>>///       Increment iChunk
82672>>>>>>>>>>>>>///    Loop
82672>>>>>>>>>>>>>/// End
82672>>>>>>>>>>>>>
82672>>>>>>>>>>>>>
82672>>>>>>>>>>>>>Function MertechInc_SQL_GET_LOB_LENGTH String sDriver Integer iFile Integer iField Returns Integer
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
82674>>>>>>>>>>>>>    String sLOB_Args
82674>>>>>>>>>>>>>    DWord  nSize
82674>>>>>>>>>>>>>
82674>>>>>>>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
82675>>>>>>>>>>>>>    // First move the size of the structure to the Structure
82675>>>>>>>>>>>>>    Put tMertechLOB_Args_size to sLOB_Args at tMertechLOB_Args.cbSize
82676>>>>>>>>>>>>>    Put iField                to sLOB_Args at tMertechLOB_Args.nField
82677>>>>>>>>>>>>>
82677>>>>>>>>>>>>>    Call_Driver iFile sDriver Function CALLDRV_LOB_EX_GET_LENGTH CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
82682>>>>>>>>>>>>>
82682>>>>>>>>>>>>>    GetBuff from sLOB_Args at tMertechLOB_Args.nSize to nSize
82683>>>>>>>>>>>>>    Function_Return nSize
82684>>>>>>>>>>>>>End_Function // MertechInc_SQL_GET_LOB_LENGTH
82685>>>>>>>>>>>>>
82685>>>>>>>>>>>>>//=============================================================================
82685>>>>>>>>>>>>>/// @Name        SQL_SET_LOB_NULL
82685>>>>>>>>>>>>>/// @Description This command is used to set a LOB column to null. Often
82685>>>>>>>>>>>>>/// LOB columns should either contain data or be null. A "blank" LOB column
82685>>>>>>>>>>>>>/// often doesn't appear empty in other environments, so settings it back to
82685>>>>>>>>>>>>>/// null is best.
82685>>>>>>>>>>>>>///
82685>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
82685>>>>>>>>>>>>>/// @Status      Public
82685>>>>>>>>>>>>>/// @Drivers     All
82685>>>>>>>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
82685>>>>>>>>>>>>>/// @See                 SQL_SET_LOB SQL_ADD_LOB_CHUNK SQL_GET_LOB SQL_GET_LOB_CHUNK SQL_LOB_TRUNCATE
82685>>>>>>>>>>>>>///
82685>>>>>>>>>>>>>/// @Syntax             SQL_SET_LOB_NULL    {FileName.FieldName}
82685>>>>>>>>>>>>>/// @Param              FileName                        The name of the file containing the LOB field
82685>>>>>>>>>>>>>/// @Param              FieldName                       The name of the specified LOB field
82685>>>>>>>>>>>>>///
82685>>>>>>>>>>>>>/// @Example
82685>>>>>>>>>>>>>////
82685>>>>>>>>>>>>>/// Clear Customer
82685>>>>>>>>>>>>>/// Move iID to Customer.ID
82685>>>>>>>>>>>>>/// Find Eq Customer by Index.1
82685>>>>>>>>>>>>>/// If (Found) Begin
82685>>>>>>>>>>>>>///    Reread Customer
82685>>>>>>>>>>>>>///        SQL_SET_LOB_NULL Customer.Comments
82685>>>>>>>>>>>>>///        Saverecord Customer
82685>>>>>>>>>>>>>///    Unlock
82685>>>>>>>>>>>>>/// End
82685>>>>>>>>>>>>>
82685>>>>>>>>>>>>>
82685>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_LOB_NULL String sDriver Integer iFile Integer iField
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
82687>>>>>>>>>>>>>    String sLOB_Args
82687>>>>>>>>>>>>>
82687>>>>>>>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
82688>>>>>>>>>>>>>    // First move the size of the structure to the Structure
82688>>>>>>>>>>>>>    Put tMertechLOB_Args_size to sLOB_Args at tMertechLOB_Args.cbSize
82689>>>>>>>>>>>>>    Put iField                to sLOB_Args at tMertechLOB_Args.nField
82690>>>>>>>>>>>>>
82690>>>>>>>>>>>>>    Call_Driver iFile sDriver Function CALLDRV_LOB_EX_SET_NULL CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
82695>>>>>>>>>>>>>End_Procedure // MertechInc_SQL_SET_LOB_NULL
82696>>>>>>>>>>>>>
82696>>>>>>>>>>>>>
82696>>>>>>>>>>>>>
82696>>>>>>>>>>>>>//=============================================================================
82696>>>>>>>>>>>>>// End of Mertech.inc
82696>>>>>>>>>>>>>//=============================================================================
82696>>>>>>>>>>>Use cli.pkg
82696>>>>>>>>>>>
#REM -----------------------------------------------
#REM MERTECH DATA SYSTEMS INC. - WWW.MERTECHDATA.COM
#REM MERTECH.INC VERSION 1.0.3 FOR DATAFLEX UPDATE FRAMEWORK
#REM -----------------------------------------------
82696>>>>>>>>>>>
82696>>>>>>>>>>>Struct tCLIHandleMap
82696>>>>>>>>>>>    Integer iHdbc
82696>>>>>>>>>>>    String sDriver
82696>>>>>>>>>>>    String sConnect
82696>>>>>>>>>>>End_Struct
82696>>>>>>>>>>>
82696>>>>>>>>>>>Struct tColumnMap
82696>>>>>>>>>>>    Integer iFileNum
82696>>>>>>>>>>>    Variant[] vResultColumn
82696>>>>>>>>>>>End_Struct
82696>>>>>>>>>>>
82696>>>>>>>>>>>//*** Embedded SQL statement attribute constants
82696>>>>>>>>>>>Define SQLSTMTATTRIB_COLUMNCOUNT    for 1
82696>>>>>>>>>>>Define SQLSTMTATTRIB_ROWCOUNT       for 2
82696>>>>>>>>>>>Define SQLSTMTATTRIB_ROWCOUNT_TYPE  for 3
82696>>>>>>>>>>>Define SQLSTMTATTRIB_NUMMESSAGES    for 4
82696>>>>>>>>>>>
82696>>>>>>>>>>>//*** Embedded SQL column attribute constants
82696>>>>>>>>>>>Define SQLCOLATTRIB_SIZE           for 1
82696>>>>>>>>>>>Define SQLCOLATTRIB_LENGTH         for 1
82696>>>>>>>>>>>Define SQLCOLATTRIB_PRECISION      for 2
82696>>>>>>>>>>>Define SQLCOLATTRIB_LABEL          for 3
82696>>>>>>>>>>>Define SQLCOLATTRIB_BASECOLUMNNAME for 4
82696>>>>>>>>>>>Define SQLCOLATTRIB_BASETABLENAME  for 5
82696>>>>>>>>>>>Define SQLCOLATTRIB_SQLTYPE        for 6
82696>>>>>>>>>>>Define SQLCOLATTRIB_NULLABLE       for 7
82696>>>>>>>>>>>Define SQLCOLATTRIB_DFTYPE         for 8
82696>>>>>>>>>>>
82696>>>>>>>>>>>
82696>>>>>>>>>>>//*** Enforced DAC SQL.PKG Compatibility
82696>>>>>>>>>>>Define SQL_DAC_HIGH_COMPATABILITY for 1
82696>>>>>>>>>>>Define SQL_DAC_NORMAL_COMPATIBILITY  for 0
82696>>>>>>>>>>>
82696>>>>>>>>>>>Global_Variable Integer giSQLCompatibilityMode
82696>>>>>>>>>>>Move SQL_DAC_NORMAL_COMPATIBILITY to giSQLCompatibilityMode
82697>>>>>>>>>>>
82697>>>>>>>>>>>//*** Global object handle for the manager
82697>>>>>>>>>>>Handle _embsqlghoSQLHandleMngr
82697>>>>>>>>>>>Register_Function CompareMaps tCLIHandleMap map1 tCLIHandleMap map2 Returns Integer
82697>>>>>>>>>>>
82697>>>>>>>>>>>Class cSQLStatementDUF is a cObject
82698>>>>>>>>>>>    Procedure Construct_Object
82700>>>>>>>>>>>        Forward Send Construct_Object
82702>>>>>>>>>>>
82702>>>>>>>>>>>        Property Integer phCLIHandle      0
82703>>>>>>>>>>>        Property Integer piLastColumn     0
82704>>>>>>>>>>>        Property Integer piLastArgument   0
82705>>>>>>>>>>>        Property Integer piBindFile       0
82706>>>>>>>>>>>        Property Integer piCursorNum      0
82707>>>>>>>>>>>        Property Boolean pisBeforeFetch   True
82708>>>>>>>>>>>        Property Integer piParameterCount 0
82709>>>>>>>>>>>
82709>>>>>>>>>>>        Property Integer piDataChunkOffset 0
82710>>>>>>>>>>>        Property String psProcName ""
82711>>>>>>>>>>>        Property String psSchemaName ""
82712>>>>>>>>>>>        Property Variant[] pvParams
82713>>>>>>>>>>>        Property tColumnMap ptColumnMap
82714>>>>>>>>>>>    End_Procedure
82715>>>>>>>>>>>
82715>>>>>>>>>>>    Function SQLDateToDFDate String sSQLDate Returns String
82717>>>>>>>>>>>        Integer hoCLIHandler
82717>>>>>>>>>>>        Date dDFDate
82717>>>>>>>>>>>
82717>>>>>>>>>>>        //*** Create a CLI handler object
82717>>>>>>>>>>>        Object oSQLDFCLIHandler is a cCLIHandler
82719>>>>>>>>>>>            Move Current_Object to hoCLIHandler
82720>>>>>>>>>>>        End_Object // oCLIHandler
82721>>>>>>>>>>>
82721>>>>>>>>>>>        //*** Convert the date
82721>>>>>>>>>>>        Get CLISQLDateToDFDate of hoCLIHandler (psDRiverID(Current_Object)) sSQLDate to dDFDate
82722>>>>>>>>>>>
82722>>>>>>>>>>>        //*** Destroy the object
82722>>>>>>>>>>>        Send Destroy_Object to hoCLIHandler
82723>>>>>>>>>>>
82723>>>>>>>>>>>        Function_Return dDFDate
82724>>>>>>>>>>>    End_Function // SQLDateToDFDate
82725>>>>>>>>>>>
82725>>>>>>>>>>>    Function DFDateToSQLDate for cSQLStatementDUF Date dDFDate Returns String
82727>>>>>>>>>>>        Integer hoCLIHandler
82727>>>>>>>>>>>        String sSQLDate
82727>>>>>>>>>>>
82727>>>>>>>>>>>        //*** Create a CLI handler object
82727>>>>>>>>>>>        Object oDFSQLCLIHandler is a cCLIHandler
82729>>>>>>>>>>>            Move Current_Object to hoCLIHandler
82730>>>>>>>>>>>        End_Object // oCLIHandler
82731>>>>>>>>>>>
82731>>>>>>>>>>>        //*** Convert the date
82731>>>>>>>>>>>        Get CLIDFDateToSQLDate of hoCLIHandler (psDRiverID(Current_Object)) dDFDate to sSQLDate
82732>>>>>>>>>>>
82732>>>>>>>>>>>        //*** Destroy the object
82732>>>>>>>>>>>        Send Destroy_Object to hoCLIHandler
82733>>>>>>>>>>>
82733>>>>>>>>>>>        Function_Return sSQLDate
82734>>>>>>>>>>>    End_Function // DFDateToSQLDate
82735>>>>>>>>>>>
82735>>>>>>>>>>>
82735>>>>>>>>>>>    Function IsProcedure String sFunctionName Returns Boolean
82737>>>>>>>>>>>        String sRoutineType
82737>>>>>>>>>>>
82737>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
82751>>>>>>>>>>>>
82751>>>>>>>>>>>
82751>>>>>>>>>>>        Case Begin
82751>>>>>>>>>>>            Case (MertechInc_DriverName = SQLFLEX)
82753>>>>>>>>>>>                sql_set_stmt to (SFormat("select type from master.sys.sysobjects where name = '%1' union all select type from sys.sysobjects where name = '%1'", sFunctionName))
82761>>>>>>>>>>>                sql_prepare_stmt
82773>>>>>>>>>>>                sql_execute_stmt
82788>>>>>>>>>>>
82788>>>>>>>>>>>                sql_fetch_next_row into sRoutineType
82812>>>>>>>>>>>>
82812>>>>>>>>>>>                If (sRoutineType = "P") Begin
82814>>>>>>>>>>>                    Move "PROCEDURE" to sRoutineType
82815>>>>>>>>>>>                End
82815>>>>>>>>>>>>
82815>>>>>>>>>>>                Else Begin
82816>>>>>>>>>>>                    Move "FUNCTION" to sRoutineType
82817>>>>>>>>>>>                End
82817>>>>>>>>>>>>
82817>>>>>>>>>>>                Case Break
82818>>>>>>>>>>>            Case (MertechInc_DriverName = MySQLFlex)
82821>>>>>>>>>>>                sql_set_stmt to (SFormat("select routine_type from information_schema.routines where routine_name = '%1'", sFunctionName))
82829>>>>>>>>>>>                sql_prepare_stmt
82841>>>>>>>>>>>                sql_execute_stmt
82856>>>>>>>>>>>                sql_fetch_next_row into sRoutineType
82880>>>>>>>>>>>>
82880>>>>>>>>>>>
82880>>>>>>>>>>>                Case Break
82881>>>>>>>>>>>            Case (MertechInc_DriverName = ORAFLEX)
82884>>>>>>>>>>>                sql_set_stmt  to (SFormat("SELECT object_type from all_objects where object_name = '%1'", sFunctionName))
82892>>>>>>>>>>>                sql_prepare_stmt
82904>>>>>>>>>>>                sql_execute_stmt
82919>>>>>>>>>>>                sql_fetch_next_row into sRoutineType
82943>>>>>>>>>>>>
82943>>>>>>>>>>>
82943>>>>>>>>>>>                Case Break
82944>>>>>>>>>>>            Case (MertechInc_DriverName = PgFlex)
82947>>>>>>>>>>>                // Postgres doesn't differentiate between procedures and functions, so treat everything as procedures
82947>>>>>>>>>>>                // because that is better tested.
82947>>>>>>>>>>>                Move "PROCEDURE" to sRoutineType
82948>>>>>>>>>>>                Case Break
82949>>>>>>>>>>>        Case End
82949>>>>>>>>>>>
82949>>>>>>>>>>>        Function_Return (sRoutineType = "PROCEDURE")
82950>>>>>>>>>>>    End_Function
82951>>>>>>>>>>>
82951>>>>>>>>>>>    Function ProcParams String sFunctionName Returns Variant[]
82953>>>>>>>>>>>        Variant[] vFuncParams
82954>>>>>>>>>>>        Integer i iParamType
82954>>>>>>>>>>>
82954>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
82968>>>>>>>>>>>>
82968>>>>>>>>>>>
82968>>>>>>>>>>>        Case Begin
82968>>>>>>>>>>>            Case (MertechInc_DriverName = SQLFLEX)
82970>>>>>>>>>>>                sql_set_stmt to (SFormat("sys.sp_procedure_params_managed @procedure_name = '%1'", sFunctionName))
82978>>>>>>>>>>>                sql_prepare_stmt
82990>>>>>>>>>>>                sql_execute_stmt
83005>>>>>>>>>>>
83005>>>>>>>>>>>                Repeat
83005>>>>>>>>>>>>
83005>>>>>>>>>>>                    sql_fetch_next_row
83020>>>>>>>>>>>>
83020>>>>>>>>>>>                    If (Found) Begin
83022>>>>>>>>>>>                        sql_fetch_column 6 into iParamType
83027>>>>>>>>>>>
83027>>>>>>>>>>>                        If (iParamType = 1) Move "IN" to vFuncParams[i]
83030>>>>>>>>>>>                        If (iParamType = 2) Move "INOUT" to vFuncParams[i]
83033>>>>>>>>>>>                        If (iParamType = 3) Move "OUT" to vFuncParams[i]
83036>>>>>>>>>>>                        If (iParamType <> 4) Increment i
83039>>>>>>>>>>>                    End
83039>>>>>>>>>>>>
83039>>>>>>>>>>>                Until (not(Found))
83041>>>>>>>>>>>
83041>>>>>>>>>>>                Function_Return vFuncParams
83042>>>>>>>>>>>
83042>>>>>>>>>>>                Case Break
83043>>>>>>>>>>>            Case (MertechInc_DriverName = MySQLFlex)
83046>>>>>>>>>>>                sql_set_stmt to (SFormat("select parameter_mode from INFORMATION_SCHEMA.PARAMETERS where SPECIFIC_NAME = '%1' order by ordinal_position", sFunctionName))
83054>>>>>>>>>>>                sql_prepare_stmt
83066>>>>>>>>>>>                sql_execute_stmt
83081>>>>>>>>>>>
83081>>>>>>>>>>>                Case Break
83082>>>>>>>>>>>            Case (MertechInc_DriverName = ORAFLEX)
83085>>>>>>>>>>>                sql_set_stmt to    "SELECT all_arguments.in_out as parameter_mode "
83093>>>>>>>>>>>                sql_append_stmt to "FROM all_objects inner join all_arguments on all_objects.object_id = all_arguments.object_id "
83101>>>>>>>>>>>                sql_append_stmt to (SFormat("WHERE all_objects.object_name = '%1' order by all_arguments.position", sFunctionName))
83109>>>>>>>>>>>                sql_prepare_stmt
83121>>>>>>>>>>>                sql_execute_stmt
83136>>>>>>>>>>>
83136>>>>>>>>>>>                Case Break
83137>>>>>>>>>>>            Case (MertechInc_DriverName = PgFlex)
83140>>>>>>>>>>>                sql_set_stmt    to "select information_schema.parameters.parameter_mode "
83148>>>>>>>>>>>                sql_append_stmt to "from information_schema.routines inner join information_schema.parameters "
83156>>>>>>>>>>>                sql_append_stmt to "on information_schema.routines.specific_name=information_schema.parameters.specific_name "
83164>>>>>>>>>>>                sql_append_stmt to (SFormat("where information_schema.routines.routine_name = '%1' ", sFunctionName))
83172>>>>>>>>>>>                sql_append_stmt to "order by information_schema.parameters.ordinal_position"
83180>>>>>>>>>>>                sql_prepare_stmt
83192>>>>>>>>>>>                sql_execute_stmt
83207>>>>>>>>>>>
83207>>>>>>>>>>>                Case Break
83208>>>>>>>>>>>        Case End
83208>>>>>>>>>>>
83208>>>>>>>>>>>        Repeat
83208>>>>>>>>>>>>
83208>>>>>>>>>>>            sql_fetch_next_row into vFuncParams[i]
83232>>>>>>>>>>>>
83232>>>>>>>>>>>            Increment i
83233>>>>>>>>>>>        Until (not(Found))
83235>>>>>>>>>>>
83235>>>>>>>>>>>        Function_Return vFuncParams
83236>>>>>>>>>>>    End_Function
83237>>>>>>>>>>>
83237>>>>>>>>>>>    Procedure Set StoreHandleInfo Handle hConn
83239>>>>>>>>>>>        Set phCLIHandle to hConn
83240>>>>>>>>>>>    End_Procedure
83241>>>>>>>>>>>
83241>>>>>>>>>>>    Procedure FreeHandle
83243>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
83257>>>>>>>>>>>>
83257>>>>>>>>>>>
83257>>>>>>>>>>>                                 Case Begin
83257>>>>>>>>>>>            Case (MertechInc_DriverName = SQLFLEX)
83259>>>>>>>>>>>                                END_CALL_PROCEDURE
83264>>>>>>>>>>>                Case Break
83265>>>>>>>>>>>            Case (MertechInc_DriverName = MySQLFlex)
83268>>>>>>>>>>>                Case Break
83269>>>>>>>>>>>            Case (MertechInc_DriverName = ORAFLEX)
83272>>>>>>>>>>>                Case Break
83273>>>>>>>>>>>            Case (MertechInc_DriverName = PgFlex)
83276>>>>>>>>>>>                Case Break
83277>>>>>>>>>>>        Case End
83277>>>>>>>>>>>
83277>>>>>>>>>>>
83277>>>>>>>>>>>        SQL_CLOSE_CURSOR_STMT to (piCursorNum(Self))
83291>>>>>>>>>>>>
83291>>>>>>>>>>>        Send Destroy_Object
83292>>>>>>>>>>>    End_Procedure // FreeHandle
83293>>>>>>>>>>>
83293>>>>>>>>>>>    Procedure SQLClose
83295>>>>>>>>>>>        Send FreeHandle
83296>>>>>>>>>>>    End_Procedure // SQLClose
83297>>>>>>>>>>>
83297>>>>>>>>>>>    Procedure HandleError Integer ihstmt Integer ihdbc String sDrvrId String sOriginMsg
83299>>>>>>>>>>>        Integer iErrHandle
83299>>>>>>>>>>>        Integer iErrNum
83299>>>>>>>>>>>        String  sLocationInfo
83299>>>>>>>>>>>
83299>>>>>>>>>>>        //*** Get the DataFlex statement identifier
83299>>>>>>>>>>>        Move Current_object to iErrHandle
83300>>>>>>>>>>>
83300>>>>>>>>>>>        //*** Determine error number
83300>>>>>>>>>>>        If (ihstmt = 0) ;            Move CLIERR_SQLINVALID_CLI_STMT_HANDLE to iErrNum
83303>>>>>>>>>>>        Else If (ihdbc = 0) ;            Move CLIERR_SQLINVALID_CLI_CONN_HANDLE to iErrNum
83307>>>>>>>>>>>        Else If (sDrvrId = "") ;            Move CLIERR_SQLINVALID_DRIVER_ID to iErrNum
83311>>>>>>>>>>>        Else ;            Move CLIERR_SQL_ERROR to iErrNum
83313>>>>>>>>>>>
83313>>>>>>>>>>>        //*** Create location information
83313>>>>>>>>>>>        Move "[" to sLocationInfo
83314>>>>>>>>>>>        If (sOriginMsg <> "") Begin
83316>>>>>>>>>>>            Move (Append(sLocationInfo, sOriginMsg)) to sLocationInfo
83317>>>>>>>>>>>            Move (Append(sLocationInfo, ", "))       to sLocationInfo
83318>>>>>>>>>>>        End
83318>>>>>>>>>>>>
83318>>>>>>>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) to sLocationInfo
83319>>>>>>>>>>>        Move (Append(sLocationInfo, iErrHandle))          to sLocationInfo
83320>>>>>>>>>>>        Move (Append(sLocationInfo, "]"))                 to sLocationInfo
83321>>>>>>>>>>>
83321>>>>>>>>>>>        //*** Generate the error
83321>>>>>>>>>>>        Error iErrNum sLocationInfo
83322>>>>>>>>>>>>
83322>>>>>>>>>>>    End_Procedure
83323>>>>>>>>>>>
83323>>>>>>>>>>>    Procedure StmtError Integer iErrNum String sErrText String sOriginMsg
83325>>>>>>>>>>>        Integer iErrHandle
83325>>>>>>>>>>>        String  sLocationInfo
83325>>>>>>>>>>>
83325>>>>>>>>>>>        //*** Get the DataFlex statement identifier
83325>>>>>>>>>>>        Move Current_object to iErrHandle
83326>>>>>>>>>>>
83326>>>>>>>>>>>
83326>>>>>>>>>>>        //*** Create location information
83326>>>>>>>>>>>        Move "[" to sLocationInfo
83327>>>>>>>>>>>        If (sOriginMsg <> "") Begin
83329>>>>>>>>>>>            Move (Append(sLocationInfo, sOriginMsg)) to sLocationInfo
83330>>>>>>>>>>>            Move (Append(sLocationInfo, ", "))       to sLocationInfo
83331>>>>>>>>>>>        End
83331>>>>>>>>>>>>
83331>>>>>>>>>>>        If (sErrtext <> "") Begin
83333>>>>>>>>>>>            Move (Append(sLocationInfo, sErrtext)) to sLocationInfo
83334>>>>>>>>>>>            Move (Append(sLocationInfo, ", "))     to sLocationInfo
83335>>>>>>>>>>>        End
83335>>>>>>>>>>>>
83335>>>>>>>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) to sLocationInfo
83336>>>>>>>>>>>        Move (Append(sLocationInfo, iErrHandle))          to sLocationInfo
83337>>>>>>>>>>>        Move (Append(sLocationInfo, "]"))                 to sLocationInfo
83338>>>>>>>>>>>
83338>>>>>>>>>>>        //*** Generate the error
83338>>>>>>>>>>>        Error iErrNum sLocationInfo
83339>>>>>>>>>>>>
83339>>>>>>>>>>>    End_Procedure
83340>>>>>>>>>>>
83340>>>>>>>>>>>    Procedure SQLIllegalAttribute String sErrText String sOriginMsg
83342>>>>>>>>>>>        Integer bReport
83342>>>>>>>>>>>
83342>>>>>>>>>>>        Get_Attribute DF_REPORT_UNSUPPORTED_ATTRIBUTES to bReport
83345>>>>>>>>>>>        If (bReport) ;            Send StmtError CLIERR_SQLINVALID_ATTRIBUTE sErrtext sOriginMsg
83348>>>>>>>>>>>    End_Procedure // SQLIllegalAttribute
83349>>>>>>>>>>>
83349>>>>>>>>>>>    Function SQLColumnValue Integer iCol Returns String
83351>>>>>>>>>>>        String sResult
83351>>>>>>>>>>>        Integer iCols
83351>>>>>>>>>>>        Integer iOrgDateFmt
83351>>>>>>>>>>>        Integer iOrgDateSep
83351>>>>>>>>>>>        String sType
83351>>>>>>>>>>>
83351>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
83365>>>>>>>>>>>>
83365>>>>>>>>>>>
83365>>>>>>>>>>>        SQL_GET_NUM_COLS to iCols
83375>>>>>>>>>>>>
83375>>>>>>>>>>>        If (iCol <= iCols) Begin
83377>>>>>>>>>>>            //DAC SQL Driver currently uses military format for the SQL getting of dates.
83377>>>>>>>>>>>            If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
83379>>>>>>>>>>>                Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
83382>>>>>>>>>>>                Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
83385>>>>>>>>>>>                Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
83388>>>>>>>>>>>                Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
83391>>>>>>>>>>>            End
83391>>>>>>>>>>>>
83391>>>>>>>>>>>
83391>>>>>>>>>>>            //DAC SQL Driver cannot directly get TEXT fields into a result.
83391>>>>>>>>>>>            If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
83393>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol DFTYPE to sType
83410>>>>>>>>>>>>
83410>>>>>>>>>>>                If (sType=5) Move "" to sResult
83413>>>>>>>>>>>                Else Begin
83414>>>>>>>>>>>                    SQL_FETCH_COLUMN iCol into sResult
83419>>>>>>>>>>>                End
83419>>>>>>>>>>>>
83419>>>>>>>>>>>            End
83419>>>>>>>>>>>>
83419>>>>>>>>>>>            Else Begin
83420>>>>>>>>>>>               SQL_FETCH_COLUMN iCol into sResult
83425>>>>>>>>>>>            End
83425>>>>>>>>>>>>
83425>>>>>>>>>>>
83425>>>>>>>>>>>
83425>>>>>>>>>>>            If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
83427>>>>>>>>>>>                Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
83430>>>>>>>>>>>                Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
83433>>>>>>>>>>>            End
83433>>>>>>>>>>>>
83433>>>>>>>>>>>
83433>>>>>>>>>>>            Function_Return sResult
83434>>>>>>>>>>>        End
83434>>>>>>>>>>>>
83434>>>>>>>>>>>        Else Send HandleError (phCLIHandle(Self)) (phCLIHandle(Parent(Self))) (psDriverID(Self)) "SQLColumnValue"
83436>>>>>>>>>>>    End_Function // SQLColumnValue
83437>>>>>>>>>>>
83437>>>>>>>>>>>    Function SQLNextColumn Returns String
83439>>>>>>>>>>>        Integer iCol
83439>>>>>>>>>>>        String  sResult
83439>>>>>>>>>>>
83439>>>>>>>>>>>        Get piLastColumn to iCol
83440>>>>>>>>>>>        Increment iCol
83441>>>>>>>>>>>        Get SQLColumnValue iCol to sResult
83442>>>>>>>>>>>        Set piLastColumn to iCol
83443>>>>>>>>>>>
83443>>>>>>>>>>>        Function_Return sResult
83444>>>>>>>>>>>    End_Function // SQLNextColumn
83445>>>>>>>>>>>
83445>>>>>>>>>>>    Procedure SQLPrepare String sStatement
83447>>>>>>>>>>>        tColumnMap tColumnMap
83447>>>>>>>>>>>        tColumnMap tColumnMap
83447>>>>>>>>>>>        Set ptColumnMap to tColumnMap
83448>>>>>>>>>>>        Set pisBeforeFetch to True
83449>>>>>>>>>>>
83449>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
83463>>>>>>>>>>>>
83463>>>>>>>>>>>        SQL_SET_STMT to sStatement
83471>>>>>>>>>>>
83471>>>>>>>>>>>        SQL_PREPARE_STMT
83483>>>>>>>>>>>    End_Procedure // SQLPrepare
83484>>>>>>>>>>>
83484>>>>>>>>>>>    Procedure SQLExecute
83486>>>>>>>>>>>        SQL_EXECUTE_STMT
83501>>>>>>>>>>>    End_Procedure
83502>>>>>>>>>>>
83502>>>>>>>>>>>    Procedure SQLExecDirect String sStatement
83504>>>>>>>>>>>        tColumnMap tColumnMap
83504>>>>>>>>>>>        tColumnMap tColumnMap
83504>>>>>>>>>>>        Set ptColumnMap to tColumnMap
83505>>>>>>>>>>>        Set pisBeforeFetch to True
83506>>>>>>>>>>>
83506>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
83520>>>>>>>>>>>>
83520>>>>>>>>>>>
83520>>>>>>>>>>>        SQL_SET_STMT to sStatement
83528>>>>>>>>>>>        SQL_PREPARE_STMT
83540>>>>>>>>>>>        SQL_EXECUTE_STMT
83555>>>>>>>>>>>    End_Procedure
83556>>>>>>>>>>>
83556>>>>>>>>>>>    Function SQLFetch Returns Integer
83558>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
83572>>>>>>>>>>>>
83572>>>>>>>>>>>        Set pisBeforeFetch to False
83573>>>>>>>>>>>
83573>>>>>>>>>>>        SQL_FETCH_NEXT_ROW
83588>>>>>>>>>>>>
83588>>>>>>>>>>>        Function_Return (Found)
83589>>>>>>>>>>>    End_Function
83590>>>>>>>>>>>
83590>>>>>>>>>>>    Procedure SQLBindFile Integer iFileNum
83592>>>>>>>>>>>        tColumnMap tColumnMap
83592>>>>>>>>>>>        tColumnMap tColumnMap
83592>>>>>>>>>>>        String[] sBindFileColumns
83593>>>>>>>>>>>        Integer[] iBufferColumn
83594>>>>>>>>>>>        Integer iColCnt i iDateFormat iResultColumnType iBindFileColumnType
83594>>>>>>>>>>>        String sColumnName
83594>>>>>>>>>>>        Variant vFieldValue
83594>>>>>>>>>>>        Boolean isRecnumTable
83594>>>>>>>>>>>
83594>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
83608>>>>>>>>>>>>
83608>>>>>>>>>>>
83608>>>>>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE of iFileNum to isRecnumTable
83611>>>>>>>>>>>        Get ptColumnMap to tColumnMap
83612>>>>>>>>>>>
83612>>>>>>>>>>>        If (tColumnMap.iFileNum <> iFileNum) Begin
83614>>>>>>>>>>>            Move iFileNum to tColumnMap.iFileNum
83615>>>>>>>>>>>
83615>>>>>>>>>>>            // First we build an array of the column names (in order) from the file buffer to bind to
83615>>>>>>>>>>>            Get_Attribute DF_FILE_NUMBER_FIELDS of iFileNum to iColCnt
83618>>>>>>>>>>>            For i from 0 to iColCnt
83624>>>>>>>>>>>>
83624>>>>>>>>>>>                If (isRecnumTable) Get_Attribute DF_FIELD_NAME of iFileNum i to sColumnName
83629>>>>>>>>>>>                Else Move "" to sColumnName
83631>>>>>>>>>>>
83631>>>>>>>>>>>                Move (Uppercase(sColumnName)) to sBindFileColumns[i]
83632>>>>>>>>>>>            Loop
83633>>>>>>>>>>>>
83633>>>>>>>>>>>
83633>>>>>>>>>>>            // Next we iterate over the columns in the resultset.  Any column names that match we
83633>>>>>>>>>>>            // set its match location into an array that maps each resultset column to its matching
83633>>>>>>>>>>>            // column number in the file buffer.  If there is no match, we set that resultset
83633>>>>>>>>>>>            // column mappped column to -1.
83633>>>>>>>>>>>            //
83633>>>>>>>>>>>            // Since Arrays are zero based and columns are numbered from 1, when we actually map
83633>>>>>>>>>>>            // to set the value, we need to add 1 to array indexer to get the proper resultset
83633>>>>>>>>>>>            // column AND we need to add 1 to the mapped-to column since it was loaded into a zero
83633>>>>>>>>>>>            // based array also.  (Ex: vResultColumn[0] = 2 means column 1 from the resultset maps
83633>>>>>>>>>>>            // to Column 3 of the file buffer)
83633>>>>>>>>>>>
83633>>>>>>>>>>>
83633>>>>>>>>>>>            SQL_GET_NUM_COLS to iColCnt
83643>>>>>>>>>>>>
83643>>>>>>>>>>>            For i from 1 to iColCnt
83649>>>>>>>>>>>>
83649>>>>>>>>>>>                SQL_GET_COL_NAME i to sColumnName
83665>>>>>>>>>>>>
83665>>>>>>>>>>>                // Because SearchArray returns -1 if there isn't a match, we don't need to do
83665>>>>>>>>>>>                // anything to make an "unmapped column" have a value of -1.
83665>>>>>>>>>>>                Move (SearchArray(Uppercase(sColumnName), sBindFileColumns)) to tColumnMap.vResultColumn[i-1]
83666>>>>>>>>>>>
83666>>>>>>>>>>>                // If the types don't match between the columns, then "unmap" the column.  This
83666>>>>>>>>>>>                // should only occur when you're not mapping to the same file as the resultset.
83666>>>>>>>>>>>                // In this case, sql.pkg silently does nothing, so we need to duplicate this instead
83666>>>>>>>>>>>                // of generating an error.  If the mapping is to a string, then any type can be
83666>>>>>>>>>>>                // converted to a string so its okay.
83666>>>>>>>>>>>                If (tColumnMap.vResultColumn[i-1] <> -1) Begin
83668>>>>>>>>>>>                    SQL_GET_COL_ATTRIBUTE of i DFTYPE to iResultColumnType
83685>>>>>>>>>>>>
83685>>>>>>>>>>>                    Get_Attribute DF_FIELD_TYPE of iFileNum (tColumnMap.vResultColumn[i-1]) to iBindFileColumnType
83688>>>>>>>>>>>
83688>>>>>>>>>>>                    // If the conversion is to string (even if the resultset column is something
83688>>>>>>>>>>>                    // else) its ok, so Break out of the If block before we muck things up.
83688>>>>>>>>>>>                    If (iBindFileColumnType = DF_ASCII) Break
83691>>>>>>>>>>>
83691>>>>>>>>>>>                    // Otherwise, break the mapping
83691>>>>>>>>>>>                    If (iResultColumnType <> iBindFileColumnType) Move -1 to tColumnMap.vResultColumn[i-1]
83694>>>>>>>>>>>                End
83694>>>>>>>>>>>>
83694>>>>>>>>>>>            Loop
83695>>>>>>>>>>>>
83695>>>>>>>>>>>
83695>>>>>>>>>>>            Set ptColumnMap to tColumnMap
83696>>>>>>>>>>>        End
83696>>>>>>>>>>>>
83696>>>>>>>>>>>
83696>>>>>>>>>>>        Get SQL_USE_DATAFLEX_DATEFORMAT to iDateFormat
83697>>>>>>>>>>>        Set SQL_USE_DATAFLEX_DATEFORMAT to True
83698>>>>>>>>>>>        Clear iFileNum
83699>>>>>>>>>>>        For i from 0 to (SizeOfArray(tColumnMap.vResultColumn)-1)
83705>>>>>>>>>>>>
83705>>>>>>>>>>>            If (tColumnMap.vResultColumn[i] > -1) Begin
83707>>>>>>>>>>>                SQL_FETCH_COLUMN (i+1) into vFieldValue
83712>>>>>>>>>>>                Set_Field_Value iFileNum (tColumnMap.vResultColumn[i]) to vFieldValue
83715>>>>>>>>>>>            End
83715>>>>>>>>>>>>
83715>>>>>>>>>>>        Loop
83716>>>>>>>>>>>>
83716>>>>>>>>>>>        Set_Attribute DF_FILE_STATUS of iFileNum to DF_FILE_ACTIVE
83719>>>>>>>>>>>        Set SQL_USE_DATAFLEX_DATEFORMAT to iDateFormat
83720>>>>>>>>>>>    End_Procedure
83721>>>>>>>>>>>
83721>>>>>>>>>>>    Function SQLGetData Integer iCol Integer iLen Returns String
83723>>>>>>>>>>>        String data
83723>>>>>>>>>>>        Integer retlen
83723>>>>>>>>>>>
83723>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
83737>>>>>>>>>>>>
83737>>>>>>>>>>>
83737>>>>>>>>>>>        SQL_SET_CHUNK_SIZE to iLen
83754>>>>>>>>>>>>
83754>>>>>>>>>>>        SQL_GET_DATA_CHUNK COLUMN iCol OFFSET (piDataChunkOffset(Self)) to data retlen
83764>>>>>>>>>>>>
83764>>>>>>>>>>>        Set piDataChunkOffset to (piDataChunkOffset(Self)+retlen)
83765>>>>>>>>>>>
83765>>>>>>>>>>>        Function_Return data
83766>>>>>>>>>>>    End_Function
83767>>>>>>>>>>>
83767>>>>>>>>>>>    Function SQLColumnMap String sColname Returns Integer
83769>>>>>>>>>>>        Integer iNumColumns i iIndex
83769>>>>>>>>>>>        String[] cols
83770>>>>>>>>>>>
83770>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
83784>>>>>>>>>>>>
83784>>>>>>>>>>>
83784>>>>>>>>>>>        Get SQLStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT to iNumColumns
83785>>>>>>>>>>>
83785>>>>>>>>>>>        For i from 1 to iNumColumns
83791>>>>>>>>>>>>
83791>>>>>>>>>>>            SQL_GET_COL_NAME i to cols[i-1]
83807>>>>>>>>>>>>
83807>>>>>>>>>>>            Move (trim(Uppercase(cols[i-1]))) to cols[i-1]
83808>>>>>>>>>>>        Loop
83809>>>>>>>>>>>>
83809>>>>>>>>>>>
83809>>>>>>>>>>>        Move (trim(Uppercase(sColname))) to sColname
83810>>>>>>>>>>>        Move (SearchArray(sColname, cols)) to iIndex
83811>>>>>>>>>>>        Function_Return (iIndex+1)  // even if searcharray returns -1 (not found) this expects 0 for not found, so it's ok
83812>>>>>>>>>>>    End_Function
83813>>>>>>>>>>>
83813>>>>>>>>>>>    Function SQLStmtAttribute Integer iAttribId Returns String
83815>>>>>>>>>>>        Integer iCnt
83815>>>>>>>>>>>
83815>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
83829>>>>>>>>>>>>
83829>>>>>>>>>>>
83829>>>>>>>>>>>        Case Begin
83829>>>>>>>>>>>            Case (iAttribId = SQLSTMTATTRIB_COLUMNCOUNT)
83831>>>>>>>>>>>                SQL_GET_NUM_COLS to iCnt
83841>>>>>>>>>>>>
83841>>>>>>>>>>>                Function_Return iCnt
83842>>>>>>>>>>>                Case Break
83843>>>>>>>>>>>            Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT)
83846>>>>>>>>>>>                SQL_GET_NUM_ROWS to iCnt
83856>>>>>>>>>>>>
83856>>>>>>>>>>>
83856>>>>>>>>>>>                //DAC Driver doesn't know the rowcount before the first fetch.
83856>>>>>>>>>>>                If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
83858>>>>>>>>>>>                    If (pisBeforeFetch(Self)) Function_Return -1
83861>>>>>>>>>>>                End
83861>>>>>>>>>>>>
83861>>>>>>>>>>>
83861>>>>>>>>>>>                Function_Return iCnt
83862>>>>>>>>>>>                Case Break
83863>>>>>>>>>>>            Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT_TYPE)
83866>>>>>>>>>>>                // TODO: Need something to indicate the quality of the SQL_GET_NUM_ROWS, or fake till I make it
83866>>>>>>>>>>>                Case Break
83867>>>>>>>>>>>            Case (iAttribId = SQLSTMTATTRIB_NUMMESSAGES)
83870>>>>>>>>>>>                Function_Return -1
83871>>>>>>>>>>>                // TODO: Are the messages returned in SQLGetMessage from the driver, or from the underlying connection?
83871>>>>>>>>>>>                Case Break
83872>>>>>>>>>>>            Case Else
83872>>>>>>>>>>>        Case End
83872>>>>>>>>>>>
83872>>>>>>>>>>>    End_Function
83873>>>>>>>>>>>
83873>>>>>>>>>>>    Function SQLColAttribute Integer iCol Integer iAttribId Returns String
83875>>>>>>>>>>>        String sValue
83875>>>>>>>>>>>        Integer iSQLType
83875>>>>>>>>>>>        Integer iDFType
83875>>>>>>>>>>>
83875>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
83889>>>>>>>>>>>>
83889>>>>>>>>>>>        SQL_GET_COL_ATTRIBUTE of iCol SQLTYPE to iSQLType
83906>>>>>>>>>>>>
83906>>>>>>>>>>>        SQL_GET_COL_ATTRIBUTE of iCol DFTYPE to iDFType
83923>>>>>>>>>>>>
83923>>>>>>>>>>>
83923>>>>>>>>>>>        Case Begin
83923>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_SIZE)
83925>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol SIZE to sValue
83942>>>>>>>>>>>>
83942>>>>>>>>>>>
83942>>>>>>>>>>>                //DAC Driver uses different values.
83942>>>>>>>>>>>                If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
83944>>>>>>>>>>>                    If (iSQLType=12) Move (Integer(sValue-1)) to sValue
83947>>>>>>>>>>>                    If (iDFType=5) Move "0" to sValue
83950>>>>>>>>>>>                    If (iSQLType=40)  Move "10" to sValue
83953>>>>>>>>>>>                End
83953>>>>>>>>>>>>
83953>>>>>>>>>>>
83953>>>>>>>>>>>                Case Break
83954>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_PRECISION)
83957>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol DECIMALS to sValue
83974>>>>>>>>>>>>
83974>>>>>>>>>>>                Case Break
83975>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_LABEL)
83978>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol COLUMN_NAME to sValue
83995>>>>>>>>>>>>
83995>>>>>>>>>>>                Case Break
83996>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_BASECOLUMNNAME)
83999>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol COLUMN_NAME to sValue
84016>>>>>>>>>>>>
84016>>>>>>>>>>>
84016>>>>>>>>>>>                //DAC Driver doesn't use Base Column Name.
84016>>>>>>>>>>>                If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
84018>>>>>>>>>>>                    Move "" to sValue
84019>>>>>>>>>>>                End
84019>>>>>>>>>>>>
84019>>>>>>>>>>>
84019>>>>>>>>>>>                Case Break
84020>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_BASETABLENAME)
84023>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol TABLE_NAME to sValue
84040>>>>>>>>>>>>
84040>>>>>>>>>>>                Case Break
84041>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_SQLTYPE)
84044>>>>>>>>>>>                Move iSQLType to sValue
84045>>>>>>>>>>>
84045>>>>>>>>>>>                //DAC Driver uses different values.
84045>>>>>>>>>>>                If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
84047>>>>>>>>>>>                    If (iSQLType=2) Move "3" to sValue
84050>>>>>>>>>>>                    If (iSQLType=-99) Move "12" to sValue
84053>>>>>>>>>>>                    If (iSQLType=40)  Move "91" to sValue
84056>>>>>>>>>>>                End
84056>>>>>>>>>>>>
84056>>>>>>>>>>>
84056>>>>>>>>>>>                Case Break
84057>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_NULLABLE)
84060>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol NULLABLE to sValue
84077>>>>>>>>>>>>
84077>>>>>>>>>>>                Case Break
84078>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_DFTYPE)
84081>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol DFTYPE to sValue
84098>>>>>>>>>>>>
84098>>>>>>>>>>>
84098>>>>>>>>>>>                //DAC Driver uses different values.
84098>>>>>>>>>>>                If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
84100>>>>>>>>>>>                    If (iDFType = 5) Move "0" to sValue
84103>>>>>>>>>>>                End
84103>>>>>>>>>>>>
84103>>>>>>>>>>>                Case Break
84104>>>>>>>>>>>        Case End
84104>>>>>>>>>>>
84104>>>>>>>>>>>        Function_Return sValue
84105>>>>>>>>>>>    End_Function
84106>>>>>>>>>>>
84106>>>>>>>>>>>    Procedure SQLSetProcedureName String sProcName String sSchemaArg
84108>>>>>>>>>>>        Set psProcName to sProcName
84109>>>>>>>>>>>        If (Num_Arguments >= 2) ;            Set psSchemaName to sSchemaArg
84112>>>>>>>>>>>        Else ;            Set psSchemaName to ""
84114>>>>>>>>>>>    End_Procedure
84115>>>>>>>>>>>
84115>>>>>>>>>>>    Procedure SQLSetNextArgument String sArgument
84117>>>>>>>>>>>        Integer iArgnum
84117>>>>>>>>>>>
84117>>>>>>>>>>>        Get piLastArgument to iArgnum
84118>>>>>>>>>>>        Increment iArgnum
84119>>>>>>>>>>>        Send SQLSetArgument iArgnum sArgument
84120>>>>>>>>>>>        Set piLastArgument to iArgnum
84121>>>>>>>>>>>    End_Procedure // SQLSetNextArgument
84122>>>>>>>>>>>
84122>>>>>>>>>>>    Procedure SQLSetArgument Integer iArgnum String sArgument
84124>>>>>>>>>>>        Variant[] vParams
84125>>>>>>>>>>>
84125>>>>>>>>>>>        Get pvParams to vParams
84126>>>>>>>>>>>        Move sArgument to vParams[iArgnum-1]
84127>>>>>>>>>>>        Set pvParams to vParams
84128>>>>>>>>>>>
84128>>>>>>>>>>>    End_Procedure // SQLSetArgument
84129>>>>>>>>>>>
84129>>>>>>>>>>>    Procedure SQLCall
84131>>>>>>>>>>>        Variant[] vParams
84132>>>>>>>>>>>        Variant[] vParamOpts
84133>>>>>>>>>>>        Integer i
84133>>>>>>>>>>>        Integer iMax
84133>>>>>>>>>>>        Integer iParamsIn
84133>>>>>>>>>>>        String sParameter
84133>>>>>>>>>>>        Boolean bIsProcedure
84133>>>>>>>>>>>
84133>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
84147>>>>>>>>>>>>
84147>>>>>>>>>>>
84147>>>>>>>>>>>        Get pvParams to vParams
84148>>>>>>>>>>>
84148>>>>>>>>>>>        // First, we need to figure out if this is a procedure or a function. Then if
84148>>>>>>>>>>>        // it's a procedure, "analyze" it to figure out which parameters are IN,
84148>>>>>>>>>>>        // OUT, or IN_OUT.  Then we adjust how we call SQL_SET_PROCEDURE_PARAMETER
84148>>>>>>>>>>>        // so that after the call you can retrieve the value.
84148>>>>>>>>>>>
84148>>>>>>>>>>>        Get IsProcedure (psProcName(Self)) to bIsProcedure
84149>>>>>>>>>>>
84149>>>>>>>>>>>        If (bIsProcedure) Begin
84151>>>>>>>>>>>            Get ProcParams (psProcName(Self)) to vParamOpts
84152>>>>>>>>>>>
84152>>>>>>>>>>>            Move (sizeOfArray(vParamOpts)) to iMax
84153>>>>>>>>>>>            Move (SizeOfArray(vParams)) to iParamsIn
84154>>>>>>>>>>>            Set piParameterCount to iMax
84155>>>>>>>>>>>
84155>>>>>>>>>>>            SQL_SET_PROCEDURE_NAME (psProcName(Self)) NUMPAR iMax
84175>>>>>>>>>>>            For i from 1 to iMax
84181>>>>>>>>>>>>
84181>>>>>>>>>>>                If ( (i-1) >= iParamsIn) Move "" to sParameter
84184>>>>>>>>>>>                Else Move vParams[i-1] to sParameter
84186>>>>>>>>>>>
84186>>>>>>>>>>>                Case Begin
84186>>>>>>>>>>>                    Case (vParamOpts[i-1] = "IN")
84188>>>>>>>>>>>                        SQL_SET_PROCEDURE_PARAMETER i to sParameter IN
84229>>>>>>>>>>>>
84229>>>>>>>>>>>                        Case Break
84230>>>>>>>>>>>                    Case (vParamOpts[i-1] = "OUT")
84233>>>>>>>>>>>                        SQL_SET_PROCEDURE_PARAMETER i to sParameter OUT
84274>>>>>>>>>>>>
84274>>>>>>>>>>>                        Case Break
84275>>>>>>>>>>>                    Case (vParamOpts[i-1] = "IN/OUT" or vParamOpts[i-1] = "INOUT")
84278>>>>>>>>>>>                        SQL_SET_PROCEDURE_PARAMETER i to sParameter IN_OUT
84319>>>>>>>>>>>>
84319>>>>>>>>>>>                        Case Break
84320>>>>>>>>>>>                Case End
84320>>>>>>>>>>>            Loop
84321>>>>>>>>>>>>
84321>>>>>>>>>>>
84321>>>>>>>>>>>            SQL_PROCEDURE_EXECUTE
84336>>>>>>>>>>>        End
84336>>>>>>>>>>>>
84336>>>>>>>>>>>        Else Begin
84337>>>>>>>>>>>            SQL_SET_FUNCTION_NAME (psProcName(Self)) NUMPAR (SizeOfArray(vParams))
84361>>>>>>>>>>>            For i from 1 to (SizeOfArray(vParams))
84367>>>>>>>>>>>>
84367>>>>>>>>>>>                SQL_SET_FUNCTION_PARAMETER i to vParams[i-1]
84439>>>>>>>>>>>>
84439>>>>>>>>>>>            Loop
84440>>>>>>>>>>>>
84440>>>>>>>>>>>
84440>>>>>>>>>>>            SQL_FUNCTION_EXECUTE
84441>>>>>>>>>>>        End
84441>>>>>>>>>>>>
84441>>>>>>>>>>>    End_Procedure
84442>>>>>>>>>>>
84442>>>>>>>>>>>    Function SQLGetNextArgument Returns String
84444>>>>>>>>>>>        Integer iArgnum
84444>>>>>>>>>>>        String  sResult
84444>>>>>>>>>>>
84444>>>>>>>>>>>        Get piLastArgument to iArgnum
84445>>>>>>>>>>>        Increment iArgnum
84446>>>>>>>>>>>        Get SQLGetArgument iArgnum to sResult
84447>>>>>>>>>>>        Set piLastArgument to iArgnum
84448>>>>>>>>>>>
84448>>>>>>>>>>>        Function_Return sResult
84449>>>>>>>>>>>    End_Function // SQLGetNextArgument
84450>>>>>>>>>>>
84450>>>>>>>>>>>    Function SQLGetArgument Integer iArgnum Returns String
84452>>>>>>>>>>>        String retval
84452>>>>>>>>>>>
84452>>>>>>>>>>>        If ( (piParameterCount(Self)) < iArgnum) Function_Return ""
84455>>>>>>>>>>>        SQL_GET_PROCEDURE_PARAMETER iArgnum to retval
84479>>>>>>>>>>>>
84479>>>>>>>>>>>
84479>>>>>>>>>>>        Function_Return retval
84480>>>>>>>>>>>    End_Function
84481>>>>>>>>>>>
84481>>>>>>>>>>>    Function SQLReturnValue Returns String
84483>>>>>>>>>>>        String retval
84483>>>>>>>>>>>
84483>>>>>>>>>>>        SQL_GET_FUNCTION_RETURN to retval
84515>>>>>>>>>>>        Function_Return retval
84516>>>>>>>>>>>    End_Function
84517>>>>>>>>>>>
84517>>>>>>>>>>>    Function SQLNextResultSet Returns Integer
84519>>>>>>>>>>>        SQL_NEXT_RESULT_SET
84531>>>>>>>>>>>
84531>>>>>>>>>>>        Function_Return (Found)
84532>>>>>>>>>>>    End_Function
84533>>>>>>>>>>>
84533>>>>>>>>>>>    Function SQLGetMessage Integer iMessageNum Returns String
84535>>>>>>>>>>>        // TODO
84535>>>>>>>>>>>    End_Function
84536>>>>>>>>>>>
84536>>>>>>>>>>>    Procedure SQLFetchActivatesBuffer Integer iFileNum Integer bState
84538>>>>>>>>>>>        // TODO
84538>>>>>>>>>>>    End_Procedure
84539>>>>>>>>>>>
84539>>>>>>>>>>>
84539>>>>>>>>>>>End_Class
84540>>>>>>>>>>>
84540>>>>>>>>>>>Class cSQLConnectionDUF is a cObject
84541>>>>>>>>>>>    Procedure Construct_Object
84543>>>>>>>>>>>        Forward Send Construct_Object
84545>>>>>>>>>>>
84545>>>>>>>>>>>        Property Handle phCLIHandle 0
84546>>>>>>>>>>>        Property String psDriverID MertechInc_DriverName
84547>>>>>>>>>>>        Property Integer piBindFile 0
84548>>>>>>>>>>>        Property String psUsername ""
84549>>>>>>>>>>>        Property String psPassword ""
84550>>>>>>>>>>>
84550>>>>>>>>>>>        Property String psCurrentDatabase ""
84551>>>>>>>>>>>
84551>>>>>>>>>>>        Property tCLIHandleMap ptCLIHandleMap
84552>>>>>>>>>>>    End_Procedure
84553>>>>>>>>>>>
84553>>>>>>>>>>>    Procedure StoreHandleInfo Handle hCLIHandle String sDrvrId Handle iParentHandle
84555>>>>>>>>>>>        Set phCLIHandle      to hCLIHandle
84556>>>>>>>>>>>        Set psDriverID       to sDrvrId
84557>>>>>>>>>>>    End_Procedure // StoreHandleInfo
84558>>>>>>>>>>>
84558>>>>>>>>>>>    Procedure FreeHandle
84560>>>>>>>>>>>        Send Destroy
84561>>>>>>>>>>>    End_Procedure
84562>>>>>>>>>>>
84562>>>>>>>>>>>    Procedure Set SQLDatabase String sDatabase
84564>>>>>>>>>>>        tCLIHandleMap conn
84564>>>>>>>>>>>        tCLIHandleMap conn
84564>>>>>>>>>>>
84564>>>>>>>>>>>        Get ptCLIHandleMap to conn
84565>>>>>>>>>>>        Set psCurrentDatabase to sDatabase
84566>>>>>>>>>>>        SQL_USE_DATABASE of conn.sConnect to sDatabase
84580>>>>>>>>>>>>
84580>>>>>>>>>>>    End_Procedure
84581>>>>>>>>>>>
84581>>>>>>>>>>>    Function SQLConnect String sDriver String sConnect Returns Handle
84583>>>>>>>>>>>        tCLIHandleMap[] maps
84583>>>>>>>>>>>        tCLIHandleMap[] maps
84584>>>>>>>>>>>        tCLIHandleMap conn
84584>>>>>>>>>>>        tCLIHandleMap conn
84584>>>>>>>>>>>
84584>>>>>>>>>>>        Get ptCLIHandleMaps to maps
84585>>>>>>>>>>>        Move sDriver to conn.sDriver
84586>>>>>>>>>>>        Move sConnect to conn.sConnect
84587>>>>>>>>>>>
84587>>>>>>>>>>>        If (SizeOfArray(maps) > 0) Move (maps[(SizeOfArray(maps)-1)].iHdbc+1) to conn.iHdbc
84590>>>>>>>>>>>        Else Move 1 to conn.iHdbc
84592>>>>>>>>>>>
84592>>>>>>>>>>>        Set CurrentConnection to sDriver sConnect
84593>>>>>>>>>>>        If (not(Err)) Begin
84595>>>>>>>>>>>            Move conn to maps[(SizeOfArray(maps))]
84596>>>>>>>>>>>            Set ptCLIHandleMaps to maps
84597>>>>>>>>>>>            Set ptCLIHandleMap to conn
84598>>>>>>>>>>>        End
84598>>>>>>>>>>>>
84598>>>>>>>>>>>
84598>>>>>>>>>>>        Function_Return Self
84599>>>>>>>>>>>    End_Function
84600>>>>>>>>>>>
84600>>>>>>>>>>>    Function SQLFileConnect Integer iFileNum Returns Integer
84602>>>>>>>>>>>        Boolean bIsOpen
84602>>>>>>>>>>>        String sDriver sServer
84602>>>>>>>>>>>        tCLIHandleMap[] maps
84602>>>>>>>>>>>        tCLIHandleMap[] maps
84603>>>>>>>>>>>        tCLIHandleMap conn
84603>>>>>>>>>>>        tCLIHandleMap conn
84603>>>>>>>>>>>
84603>>>>>>>>>>>        Get_Attribute DF_FILE_OPENED of iFileNum to bIsOpen
84606>>>>>>>>>>>        If (bIsOpen) Begin
84608>>>>>>>>>>>            //*** Fill the driver id, assume longest is 255 characters
84608>>>>>>>>>>>            Move (Repeat(' ', 255)) to sDriver
84609>>>>>>>>>>>            Move (Repeat(' ', 255)) to sServer
84610>>>>>>>>>>>            Get_Attribute DF_FILE_DRIVER of iFileNum to sDriver
84613>>>>>>>>>>>            Get_Attribute DF_FILE_SERVER_NAME of iFileNum to sServer
84616>>>>>>>>>>>
84616>>>>>>>>>>>            Indicate Err False
84617>>>>>>>>>>>
84617>>>>>>>>>>>            Get ptCLIHandleMaps to maps
84618>>>>>>>>>>>            Move sDriver to conn.sDriver
84619>>>>>>>>>>>            Move sServer to conn.sConnect
84620>>>>>>>>>>>
84620>>>>>>>>>>>            If (SizeOfArray(maps) > 0) Move (maps[(SizeOfArray(maps)-1)].iHdbc+1) to conn.iHdbc
84623>>>>>>>>>>>            Else Move 1 to conn.iHdbc
84625>>>>>>>>>>>
84625>>>>>>>>>>>            Set CurrentConnection to sDriver sServer
84626>>>>>>>>>>>            If (not(Err)) Begin
84628>>>>>>>>>>>                Move conn to maps[(SizeOfArray(maps))]
84629>>>>>>>>>>>                Set ptCLIHandleMaps to maps
84630>>>>>>>>>>>                Set ptCLIHandleMap to conn
84631>>>>>>>>>>>            End
84631>>>>>>>>>>>>
84631>>>>>>>>>>>
84631>>>>>>>>>>>            Send StoreHandleInfo conn.iHdbc conn.sDriver
84632>>>>>>>>>>>            Set piBindFile to iFileNum
84633>>>>>>>>>>>        End
84633>>>>>>>>>>>>
84633>>>>>>>>>>>        Else Error 4099 "File Not Open"
84635>>>>>>>>>>>
84635>>>>>>>>>>>        //*** Return success status
84635>>>>>>>>>>>        Function_Return (not(Err))
84636>>>>>>>>>>>    End_Function
84637>>>>>>>>>>>
84637>>>>>>>>>>>    Procedure SQLDisconnect
84639>>>>>>>>>>>        tCLIHandleMap map
84639>>>>>>>>>>>        tCLIHandleMap map
84639>>>>>>>>>>>        tCLIHandleMap[] maps
84639>>>>>>>>>>>        tCLIHandleMap[] maps
84640>>>>>>>>>>>        Integer iFound
84640>>>>>>>>>>>
84640>>>>>>>>>>>        Get ptCLIHandleMap to map
84641>>>>>>>>>>>        Get ptCLIHandleMaps to maps
84642>>>>>>>>>>>
84642>>>>>>>>>>>        Move (SearchArray(map, maps, Parent(Self), RefFunc(CompareMaps))) to iFound
84643>>>>>>>>>>>        If (iFound > -1) Begin
84645>>>>>>>>>>>            Send FreeHandle
84646>>>>>>>>>>>        End
84646>>>>>>>>>>>>
84646>>>>>>>>>>>    End_Procedure // SQLDisconnect
84647>>>>>>>>>>>
84647>>>>>>>>>>>    Function CreateHandle Returns Integer
84649>>>>>>>>>>>        Handle hSQL
84649>>>>>>>>>>>        Integer iCursor
84649>>>>>>>>>>>
84649>>>>>>>>>>>        Get Create U_cSQLStatementDUF to hSQL
84650>>>>>>>>>>>
84650>>>>>>>>>>>        Set piBindFile of hSQL to (piBindFile(Current_object))
84651>>>>>>>>>>>
84651>>>>>>>>>>>        SQL_OPEN_CURSOR_STMT to iCursor
84665>>>>>>>>>>>>
84665>>>>>>>>>>>        Set piCursorNum of hSQL to iCursor
84666>>>>>>>>>>>
84666>>>>>>>>>>>        Function_Return hSQL
84667>>>>>>>>>>>    End_Function // CreateHandle
84668>>>>>>>>>>>
84668>>>>>>>>>>>    Function SQLOpen Returns Integer
84670>>>>>>>>>>>        Handle hDFHandle
84670>>>>>>>>>>>
84670>>>>>>>>>>>        Get CreateHandle to hDFHandle
84671>>>>>>>>>>>
84671>>>>>>>>>>>        Send StoreHandleInfo to hDFHandle Self (psDriverID(Self))
84672>>>>>>>>>>>
84672>>>>>>>>>>>        Function_Return hDFHandle
84673>>>>>>>>>>>    End_Function // SQLOpen
84674>>>>>>>>>>>
84674>>>>>>>>>>>
84674>>>>>>>>>>>
84674>>>>>>>>>>>
84674>>>>>>>>>>>    Function DriverIndex String sDriver Returns Integer
84676>>>>>>>>>>>        String sCurrentDriver
84676>>>>>>>>>>>        Integer iDriver
84676>>>>>>>>>>>        Integer iNumDrivers
84676>>>>>>>>>>>
84676>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumDrivers
84679>>>>>>>>>>>        For iDriver from 1 to iNumDrivers
84685>>>>>>>>>>>>
84685>>>>>>>>>>>          Get_Attribute DF_DRIVER_NAME of iDriver to sCurrentDriver
84688>>>>>>>>>>>          If (Uppercase(sDriver) = Uppercase(sCurrentDriver)) ;              Function_Return iDriver
84691>>>>>>>>>>>        Loop
84692>>>>>>>>>>>>
84692>>>>>>>>>>>        Function_Return 0
84693>>>>>>>>>>>    End_Function // DriverIndex
84694>>>>>>>>>>>
84694>>>>>>>>>>>    Function FirstServerForDriverNo Integer iDriver Returns String
84696>>>>>>>>>>>        String sServer
84696>>>>>>>>>>>        Integer iNumServers
84696>>>>>>>>>>>        Integer iServer
84696>>>>>>>>>>>
84696>>>>>>>>>>>        If (iDriver <> 0) Begin
84698>>>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iNumServers
84701>>>>>>>>>>>            If (iNumServers<>0) Begin
84703>>>>>>>>>>>                Move 1 to iServer
84704>>>>>>>>>>>                Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iServer to sServer
84707>>>>>>>>>>>            End
84707>>>>>>>>>>>>
84707>>>>>>>>>>>        End
84707>>>>>>>>>>>>
84707>>>>>>>>>>>
84707>>>>>>>>>>>        Function_Return sServer
84708>>>>>>>>>>>    End_Function
84709>>>>>>>>>>>
84709>>>>>>>>>>>    Procedure Set CurrentConnection String sDriver String sServer
84711>>>>>>>>>>>        Integer iDriver
84711>>>>>>>>>>>        String sUsername
84711>>>>>>>>>>>        String sPassword
84711>>>>>>>>>>>
84711>>>>>>>>>>>        If (sDriver="") Begin
84713>>>>>>>>>>>            DO_GETFILENUMBER_DRIVERNAME 0
84715>>>>>>>>>>>            Move MertechInc_DriverName to sDriver
84716>>>>>>>>>>>        End
84716>>>>>>>>>>>>
84716>>>>>>>>>>>
84716>>>>>>>>>>>        If ("MDSMYSQL|ORA_DRV|MDSPGSQL|SQL_DRV|MDS_DB2" contains Uppercase(Trim(sDriver))) Begin
84718>>>>>>>>>>>            Move (Uppercase(Trim(sDriver))) to MertechInc_DriverName
84719>>>>>>>>>>>
84719>>>>>>>>>>>            If (Trim(sDriver) <> "") Move (Uppercase(Trim(sDriver))) to MertechInc_CurrentDriver
84722>>>>>>>>>>>            Else Move "" to MertechInc_CurrentDriver
84724>>>>>>>>>>>
84724>>>>>>>>>>>            Get psUsername to sUsername
84725>>>>>>>>>>>            Get psPassword to sPassword
84726>>>>>>>>>>>
84726>>>>>>>>>>>            Get DriverIndex MertechInc_CurrentDriver to iDriver
84727>>>>>>>>>>>
84727>>>>>>>>>>>            If (sServer="") Get FirstServerForDriverNo iDriver to sServer
84730>>>>>>>>>>>            If (sUsername="") GET_CURRENT_USER_NAME of sServer to sUsername
84747>>>>>>>>>>>            If (sPassword="") get_current_user_password of sServer to sPassword
84764>>>>>>>>>>>            Move False to Err
84765>>>>>>>>>>>            Send Ignore_Error of Error_Object_Id 25000
84766>>>>>>>>>>>            Login sServer sUsername sPassword sDriver
84768>>>>>>>>>>>            Send Trap_Error of Error_Object_Id 25000
84769>>>>>>>>>>>            If (Err = False) Begin
84771>>>>>>>>>>>                Call_Driver 0 MertechInc_DriverName Function CALLDRV_CURRENT_SQL_SERVER_CONNECTION CALLBACK 0 PASSING sServer MertechInc_Blank 0 RESULT MertechInc_iRet
84776>>>>>>>>>>>            End
84776>>>>>>>>>>>>
84776>>>>>>>>>>>            Else Begin
84777>>>>>>>>>>>                Procedure_Return
84778>>>>>>>>>>>            End
84778>>>>>>>>>>>>
84778>>>>>>>>>>>
84778>>>>>>>>>>>            If MertechInc_iRet EQ -1 INDICATE ERR True
84781>>>>>>>>>>>        End
84781>>>>>>>>>>>>
84781>>>>>>>>>>>        Else Error 4099 "Invalid Driver"
84783>>>>>>>>>>>
84783>>>>>>>>>>>    End_Procedure
84784>>>>>>>>>>>
84784>>>>>>>>>>>End_Class
84785>>>>>>>>>>>
84785>>>>>>>>>>>Class cSQLHandleManagerDUF is a cObject
84786>>>>>>>>>>>
84786>>>>>>>>>>>    Procedure Construct_Object
84788>>>>>>>>>>>        Forward Send Construct_Object
84790>>>>>>>>>>>
84790>>>>>>>>>>>        Property String  psDefaultDriver     ""
84791>>>>>>>>>>>        Property String  psDefaultConnection ""
84792>>>>>>>>>>>        Property tCLIHandleMap[] ptCLIHandleMaps
84793>>>>>>>>>>>    End_Procedure
84794>>>>>>>>>>>
84794>>>>>>>>>>>    Function CompareMaps tCLIHandleMap map1 tCLIHandleMap map2 Returns Integer
84796>>>>>>>>>>>        If ((map1.iHdbc = map2.iHdbc) and (map1.sConnect = map2.sConnect) and (map1.sDriver = map2.sDriver)) Begin
84798>>>>>>>>>>>            Function_Return (EQ)
84799>>>>>>>>>>>        End
84799>>>>>>>>>>>>
84799>>>>>>>>>>>    End_Function
84800>>>>>>>>>>>
84800>>>>>>>>>>>    Function CreateHandle Returns Handle
84802>>>>>>>>>>>        Handle hSQL
84802>>>>>>>>>>>
84802>>>>>>>>>>>        Get Create U_cSQLConnectionDUF to hSQL
84803>>>>>>>>>>>        Function_Return hSQL
84804>>>>>>>>>>>    End_Function
84805>>>>>>>>>>>
84805>>>>>>>>>>>    Procedure SQLSetConnect String sDriver String sConnect
84807>>>>>>>>>>>        Set psDefaultDriver to sDriver
84808>>>>>>>>>>>        Set psDefaultConnection to sConnect
84809>>>>>>>>>>>    End_Procedure
84810>>>>>>>>>>>
84810>>>>>>>>>>>    Function SQLConnect String sDriver String sConnect String sUsername String sPassword Returns Handle
84812>>>>>>>>>>>        Handle hSql
84812>>>>>>>>>>>        Boolean bOK
84812>>>>>>>>>>>
84812>>>>>>>>>>>        Get CreateHandle to hSql
84813>>>>>>>>>>>
84813>>>>>>>>>>>        If (sDriver = "" and sConnect = "") Begin
84815>>>>>>>>>>>            Move (psDefaultDriver(Self)) to sDriver
84816>>>>>>>>>>>            Move (psDefaultConnection(Self)) to sConnect
84817>>>>>>>>>>>        End
84817>>>>>>>>>>>>
84817>>>>>>>>>>>
84817>>>>>>>>>>>        If (num_arguments>2) Begin
84819>>>>>>>>>>>            Set psUsername of hSql to sUsername
84820>>>>>>>>>>>            Set psPassword of hSql to sPassword
84821>>>>>>>>>>>        End
84821>>>>>>>>>>>>
84821>>>>>>>>>>>
84821>>>>>>>>>>>        Get SQLConnect of hSql sDriver sConnect to bOK
84822>>>>>>>>>>>        If (not(bOK)) Begin
84824>>>>>>>>>>>            Send FreeHandle of hSQL
84825>>>>>>>>>>>            Function_Return 0
84826>>>>>>>>>>>        End
84826>>>>>>>>>>>>
84826>>>>>>>>>>>
84826>>>>>>>>>>>        Function_Return hSql
84827>>>>>>>>>>>    End_Function
84828>>>>>>>>>>>
84828>>>>>>>>>>>    Function SQLFileConnect Integer iFileNum Returns Integer
84830>>>>>>>>>>>        Handle hSql
84830>>>>>>>>>>>        Boolean bOK
84830>>>>>>>>>>>
84830>>>>>>>>>>>        //*** Allocate a new handle
84830>>>>>>>>>>>        Get CreateHandle to hSql
84831>>>>>>>>>>>        Get SQLFileConnect of hSql iFileNum to bOK
84832>>>>>>>>>>>
84832>>>>>>>>>>>        //*** If failure, kill the handle and return a 0 handle
84832>>>>>>>>>>>        If (not(bOK)) Begin
84834>>>>>>>>>>>            Send FreeHandle of hSql
84835>>>>>>>>>>>            Function_Return 0
84836>>>>>>>>>>>        End
84836>>>>>>>>>>>>
84836>>>>>>>>>>>
84836>>>>>>>>>>>        Function_Return hSql
84837>>>>>>>>>>>    End_Function // SQLFileConnect
84838>>>>>>>>>>>
84838>>>>>>>>>>>End_Class
84839>>>>>>>>>>>
84839>>>>>>>>>>>
84839>>>>>>>>>>>Function CreateSQLmanager for cDesktop Returns Integer
84841>>>>>>>>>>>    Handle hSqlManager
84841>>>>>>>>>>>
84841>>>>>>>>>>>    Get Create U_cSQLHandleManagerDUF to hSqlManager
84842>>>>>>>>>>>    Function_Return hSqlManager
84843>>>>>>>>>>>End_Function // CreateSQLMngr
84844>>>>>>>>>>>
84844>>>>>>>>>>>
84844>>>>>>>>>>>
84844>>>>>>>>>>>
84844>>>>>>>>>>>
84844>>>>>>>>>>>
84844>>>>>>>>>>>Get CreateSQLManager of Desktop to _embsqlghoSQLHandleMngr
84845>>>>>>>>>>>
84845>>>>>>>>>>>
84845>>>>>>>>>    Use Mertech.inc
84845>>>>>>>>>
84845>>>>>>>>>Use cDbUpdateFunctionLibrary.inc
Including file: cDbUpdateFunctionLibrary.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.inc)
84845>>>>>>>>>>>Use DUFLanguageConstants.inc
84845>>>>>>>>>>>
84845>>>>>>>>>>>Register_Function paSQLQueryMessages Returns String[]
84845>>>>>>>>>>>Register_Procedure Set paSQLQueryMessages String[] aSQLQueryMessages
84845>>>>>>>>>>>
84845>>>>>>>>>>>// Global handle to a cDatabaseUpdateHandler object
84845>>>>>>>>>>>    Global_Variable Handle ghoDbUpdateHandler
84845>>>>>>>>>>>
84845>>>>>>>>>>>    Define CS_DatabaseUpdateFramework for " ***  The Database Update Framework (DUF) ***"
84845>>>>>>>>>>>
84845>>>>>>>>>>>    Define DATAFLEX_ID for "DATAFLEX"
84845>>>>>>>>>>>
84845>>>>>>>>>>>    Define CS_OEM_Txt for "OEM"
84845>>>>>>>>>>>
84845>>>>>>>>>>>    Define CS_ANSI_Txt for "ANSI"
84845>>>>>>>>>>>
84845>>>>>>>>>>>    Define CS_DFCONNID for "DFCONNID"
84845>>>>>>>>>>>
84845>>>>>>>>>>>    Define CS_SERVER for "SERVER"
84845>>>>>>>>>>>
84845>>>>>>>>>>>    Define CS_SERVER_NAME for "SERVER_NAME"
84845>>>>>>>>>>>
84845>>>>>>>>>>>    Define CS_DRIVER_NAME for "DRIVER_NAME"
84845>>>>>>>>>>>
84845>>>>>>>>>>>    Define CS_DATABASE_NAME for "DATABASE_NAME"
84845>>>>>>>>>>>
84845>>>>>>>>>>>    Define CS_SCHEMA_NAME for "SCHEMA_NAME"
84845>>>>>>>>>>>
84845>>>>>>>>>>>    Define CS_TABLE_CHARACTER_FORMAT for "TABLE_CHARACTER_FORMAT"
84845>>>>>>>>>>>
84845>>>>>>>>>>>    Define CS_USE_DUMMY_ZERO_DATE for "USE_DUMMY_ZERO_DATE"
84845>>>>>>>>>>>
84845>>>>>>>>>>>    Define CS_SYSTEM_FILE for "SYSTEM_FILE"
84845>>>>>>>>>>>
84845>>>>>>>>>>>    Define CS_RECNUM_TABLE for "RECNUM_TABLE"
84845>>>>>>>>>>>
84845>>>>>>>>>>>    Define CS_PRIMARY_INDEX for "PRIMARY_INDEX"
84845>>>>>>>>>>>
84845>>>>>>>>>>>    Define CS_INDEX_NUMBER for "INDEX_NUMBER"
84845>>>>>>>>>>>
84845>>>>>>>>>>>    Define CS_INDEX_NAME for "INDEX_NAME"
84845>>>>>>>>>>>
84845>>>>>>>>>>>    Define CS_DUFLowestAllowedDateValue for "01/01/1753"
84845>>>>>>>>>>>    Define CS_DUFLowestSQLDateValue     for "1753-01-01"
84845>>>>>>>>>>>
84845>>>>>>>>>>>
84845>>>>>>>>>>>    Global_Variable Handle ghoDbUpdateFunctionLibrary
84845>>>>>>>>>>>
84845>>>>>>>>>>>Struct tSQLScriptArray
84845>>>>>>>>>>>    Boolean bError
84845>>>>>>>>>>>    Boolean bArgumentSizeChanged
84845>>>>>>>>>>>    Integer iOrgArgumentSize
84845>>>>>>>>>>>    String[] sSQLScriptArray
84845>>>>>>>>>>>End_Struct
84845>>>>>>>>>>>
84845>>>>>>>>>>>Struct tSqlErrorArray
84845>>>>>>>>>>>    String[]  sSqlErrorArray
84845>>>>>>>>>>>    String[]  sSqlStatementArray
84845>>>>>>>>>>>    Integer[] iSqlErrorArray
84845>>>>>>>>>>>End_Struct
84845>>>>>>>>>>>
84845>>>>>>>>>>>Struct tSqlColumnNew
84845>>>>>>>>>>>    String  sBaseColumnName
84845>>>>>>>>>>>    String  sBaseTableName
84845>>>>>>>>>>>    String  sLabel
84845>>>>>>>>>>>    Integer iSqlType
84845>>>>>>>>>>>    Integer iSize
84845>>>>>>>>>>>    Integer iPrecision
84845>>>>>>>>>>>    Integer iDFType
84845>>>>>>>>>>>    Integer iDFNativeType
84845>>>>>>>>>>>End_Struct
84845>>>>>>>>>>>
84845>>>>>>>>>>>Struct tColumnType
84845>>>>>>>>>>>    String  sSQLType
84845>>>>>>>>>>>    Integer iSQLType
84845>>>>>>>>>>>    Boolean bCanEditSize
84845>>>>>>>>>>>    Integer iDefaultSize
84845>>>>>>>>>>>    Integer iMinSize
84845>>>>>>>>>>>    Number  nMaxSize
84845>>>>>>>>>>>    String  sDataFlexType
84845>>>>>>>>>>>    Integer iDataFlexType
84845>>>>>>>>>>>    Boolean bNativeDataType
84845>>>>>>>>>>>    String  sPrecision
84845>>>>>>>>>>>End_Struct
84845>>>>>>>>>>>
84845>>>>>>>>>>>// Used to store/retreive SQL keywords in a struct array.
84845>>>>>>>>>>>// Various SQL back-ends can have slightly different
84845>>>>>>>>>>>// keywords.
84845>>>>>>>>>>>Struct tSQLKeyWords
84845>>>>>>>>>>>    Integer iSQLWord
84845>>>>>>>>>>>    Integer iSQLDbType
84845>>>>>>>>>>>    String  sSQLPhrase // Can be more than one word.
84845>>>>>>>>>>>End_Struct
84845>>>>>>>>>>>
84845>>>>>>>>>>>Struct tSQLRelation
84845>>>>>>>>>>>    Integer iFileNumber
84845>>>>>>>>>>>    Integer iFieldNumber
84845>>>>>>>>>>>    String  sFileName
84845>>>>>>>>>>>    String  sFieldName
84845>>>>>>>>>>>End_Struct
84845>>>>>>>>>>>
84845>>>>>>>>>>>Struct tSQLLoggedInUser
84845>>>>>>>>>>>    String sUser
84845>>>>>>>>>>>    String sProgram
84845>>>>>>>>>>>End_Struct
84845>>>>>>>>>>>
84845>>>>>>>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
84845>>>>>>>>>>>Enumeration_List
84845>>>>>>>>>>>    Define DUF_ERROR_REPORT    // Report Error on screen
84845>>>>>>>>>>>    Define DUF_ERROR_NO_REPORT // Show no Error..
84845>>>>>>>>>>>End_Enumeration_List
84845>>>>>>>>>>>
84845>>>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
84845>>>>>>>>>>>// They can have slightly different SQL keywords.
84845>>>>>>>>>>>// Note: If a new type is added to the list,
84845>>>>>>>>>>>//       the struct array xxx must be adjusted
84845>>>>>>>>>>>//       so that it is filled with all SQL
84845>>>>>>>>>>>//       keywords for that new type.
84845>>>>>>>>>>>Enum_List
84845>>>>>>>>>>>    Define EN_DbTypeMSSQL
84845>>>>>>>>>>>    Define EN_DbTypeMySQL
84845>>>>>>>>>>>    Define EN_DbTypeOracle
84845>>>>>>>>>>>    Define EN_DbTypeDB2
84845>>>>>>>>>>>    Define EN_DbTypePostgre
84845>>>>>>>>>>>    Define EN_DbTypeDataFlex // Embedded database.
84845>>>>>>>>>>>End_Enum_List
84845>>>>>>>>>>>
84845>>>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
84845>>>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
84845>>>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
84845>>>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
84845>>>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
84845>>>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
84845>>>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
84845>>>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
84845>>>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
84845>>>>>>>>>>>
84845>>>>>>>>>>>// We need to re-define the standard constants because several driver constants
84845>>>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
84845>>>>>>>>>>>// e.g. creating a column with embedded SQL (ESQL).
84845>>>>>>>>>>>Enum_List
84845>>>>>>>>>>>    Define DF_ASCII_DUF     for -1500 // All of these are DF_xxx constant values - 1500
84845>>>>>>>>>>>    Define DF_BCD_DUF       for -1499
84845>>>>>>>>>>>    Define DF_DATE_DUF      for -1498
84845>>>>>>>>>>>    Define DF_TEXT_DUF      for -1495
84845>>>>>>>>>>>    Define DF_BINARY_DUF    for -1494
84845>>>>>>>>>>>    Define DF_DATETIME_DUF  for -1493
84845>>>>>>>>>>>End_Enum_List
84845>>>>>>>>>>>
84845>>>>>>>>>>>    Define SQL_TEXT for (DF_TEXT + 1024)
84845>>>>>>>>>>>
84845>>>>>>>>>>>Define SQL_CHARBIT          for (DF_BINARY + 1024)
84845>>>>>>>>>>>Define SQL_LONGVARCHARBIT   for (DF_BINARY + 1025)
84845>>>>>>>>>>>Define SQL_VARCHARBIT       for (DF_BINARY + 1026)
84845>>>>>>>>>>>
84845>>>>>>>>>>>// These are not defined pre DF 18:
84845>>>>>>>>>>>
84845>>>>>>>>>>>Struct tSQLIntTableInfo
84845>>>>>>>>>>>    String sDriverName
84845>>>>>>>>>>>    String sServerName
84845>>>>>>>>>>>    String sDatabaseName
84845>>>>>>>>>>>    String sSchemaName
84845>>>>>>>>>>>    Boolean bRecnumTable
84845>>>>>>>>>>>    Integer iPrimaryIndex
84845>>>>>>>>>>>    Integer iGenerateRecordIdMethod  // RIM_NONE, RIM_IDENTITY_COLUMN,  RIM_DISPENSER_TABLE, RIM_EXTERNAL
84845>>>>>>>>>>>    String sTableCharacterFormat
84845>>>>>>>>>>>    Boolean bUseDummyZeroDate
84845>>>>>>>>>>>    Integer iFileDummyUpdateColumn // Init value to -1 if not exists (value can be in range 1 - number of columns)
84845>>>>>>>>>>>    Integer iFileBlockSize         // Init value to -1 if not exists
84845>>>>>>>>>>>    Integer iFileMaxRowsFetched    // Init value to -1 if not exists
84845>>>>>>>>>>>    Integer iFileGetRidAfterCreate // Init value to -1. But is boolean!
84845>>>>>>>>>>>    Integer iFileJitBinding        // Init value to -1. But is boolean!
84845>>>>>>>>>>>    String sRefindAfterSave        // Yes or No (how to handle?)
84845>>>>>>>>>>>    String sSystemFile             // Yes or No (how to handle?)
84845>>>>>>>>>>>    String sFileIndexTablespace
84845>>>>>>>>>>>    String sFileLongTablespace
84845>>>>>>>>>>>    String sTableTablespace
84845>>>>>>>>>>>End_Struct
84845>>>>>>>>>>>
84845>>>>>>>>>>>Struct tSQLIntColumnInfo
84845>>>>>>>>>>>    Integer iFieldNumber
84845>>>>>>>>>>>    Integer iFieldIndex
84845>>>>>>>>>>>    Integer iFieldRelatedFile
84845>>>>>>>>>>>    Integer iFieldRelatedField
84845>>>>>>>>>>>    Integer iIndexNumber
84845>>>>>>>>>>>    Integer iIndexNumberSegments
84845>>>>>>>>>>>    Integer iIndexSegmentField1
84845>>>>>>>>>>>    Integer iIndexSegmentField2
84845>>>>>>>>>>>    Integer iIndexSegmentFieldn
84845>>>>>>>>>>>    String  sIndexName
84845>>>>>>>>>>>End_Struct
84845>>>>>>>>>>>
84845>>>>>>>>>>>Struct tAPIColumn
84845>>>>>>>>>>>    Integer iFieldNumber
84845>>>>>>>>>>>    String  sFieldName
84845>>>>>>>>>>>    Integer iType
84845>>>>>>>>>>>    String  sType
84845>>>>>>>>>>>    Integer iLength
84845>>>>>>>>>>>    Integer iPrecision
84845>>>>>>>>>>>    Integer iOptions
84845>>>>>>>>>>>    Boolean bIsSQLType
84845>>>>>>>>>>>    Boolean bAllowNULL 
84845>>>>>>>>>>>    String  sDefaultValue
84845>>>>>>>>>>>    Boolean bShouldChange
84845>>>>>>>>>>>    Boolean bCancel
84845>>>>>>>>>>>    Boolean bError
84845>>>>>>>>>>>End_Struct
84845>>>>>>>>>>>
84845>>>>>>>>>>>Struct tAPIColumnCompare
84845>>>>>>>>>>>    Integer iFieldNumber
84845>>>>>>>>>>>    // FROM database:
84845>>>>>>>>>>>    Boolean bExistsFrom
84845>>>>>>>>>>>    String  sFieldNameFrom
84845>>>>>>>>>>>    Integer iTypeFrom
84845>>>>>>>>>>>    String  sTypeFrom
84845>>>>>>>>>>>    Integer iLengthFrom
84845>>>>>>>>>>>    Integer iPrecisionFrom
84845>>>>>>>>>>>    Integer iOptionsFrom
84845>>>>>>>>>>>    Boolean bIsSQLTypeFrom
84845>>>>>>>>>>>    Boolean bAllowNULLFrom
84845>>>>>>>>>>>    String  sDefaultValueFrom
84845>>>>>>>>>>>    Boolean bShouldChangeFrom
84845>>>>>>>>>>>    Boolean bCancelFrom
84845>>>>>>>>>>>    Boolean bErrorFrom 
84845>>>>>>>>>>>    // TO database:
84845>>>>>>>>>>>    Boolean bExistsTo
84845>>>>>>>>>>>    Integer iFieldNumberTo
84845>>>>>>>>>>>    String  sFieldNameTo
84845>>>>>>>>>>>    Integer iTypeTo
84845>>>>>>>>>>>    String  sTypeTo
84845>>>>>>>>>>>    Integer iLengthTo
84845>>>>>>>>>>>    Integer iPrecisionTo
84845>>>>>>>>>>>    Integer iOptionsTo
84845>>>>>>>>>>>    Boolean bIsSQLTypeTo
84845>>>>>>>>>>>    Boolean bAllowNULLTo
84845>>>>>>>>>>>    String  sDefaultValueTo
84845>>>>>>>>>>>    Boolean bShouldChangeTo
84845>>>>>>>>>>>    Boolean bCancelTo
84845>>>>>>>>>>>    Boolean bErrorTo
84845>>>>>>>>>>>End_Struct
84845>>>>>>>>>>>
84845>>>>>>>>>>>Struct tAPIRelation
84845>>>>>>>>>>>    Handle  hTableFrom
84845>>>>>>>>>>>    Integer iColumnFrom
84845>>>>>>>>>>>    Handle  hTableTo
84845>>>>>>>>>>>    Integer iColumnTo
84845>>>>>>>>>>>    String  sLogicalNameFrom
84845>>>>>>>>>>>    String  sLogicalNameTo
84845>>>>>>>>>>>    String  sFieldNameFrom
84845>>>>>>>>>>>    String  sFieldNameTo
84845>>>>>>>>>>>    Boolean bShouldChange
84845>>>>>>>>>>>    Boolean bCancel
84845>>>>>>>>>>>    Boolean bError
84845>>>>>>>>>>>End_Struct
84845>>>>>>>>>>>
84845>>>>>>>>>>>Struct tAPIRelationCompare
84845>>>>>>>>>>>    // Common:
84845>>>>>>>>>>>    Handle  hTableFrom
84845>>>>>>>>>>>    Integer iColumnFrom
84845>>>>>>>>>>>    Handle  hTableTo
84845>>>>>>>>>>>    Integer iColumnTo
84845>>>>>>>>>>>    // FROM database:
84845>>>>>>>>>>>    Boolean bExistsFrom
84845>>>>>>>>>>>    String  sLogicalNameFrom_From
84845>>>>>>>>>>>    String  sLogicalNameTo_From
84845>>>>>>>>>>>    String  sFieldNameFrom_From
84845>>>>>>>>>>>    String  sFieldNameTo_From
84845>>>>>>>>>>>    Boolean bShouldChange_From
84845>>>>>>>>>>>    Boolean bCancel_From
84845>>>>>>>>>>>    Boolean bError_From
84845>>>>>>>>>>>    // TO database:
84845>>>>>>>>>>>    Boolean bExistsTo
84845>>>>>>>>>>>    String  sLogicalNameFrom_To
84845>>>>>>>>>>>    String  sLogicalNameTo_To
84845>>>>>>>>>>>    String  sFieldNameFrom_To
84845>>>>>>>>>>>    String  sFieldNameTo_To
84845>>>>>>>>>>>    Boolean bShouldChange_To
84845>>>>>>>>>>>    Boolean bCancel_To
84845>>>>>>>>>>>    Boolean bError_To
84845>>>>>>>>>>>End_Struct
84845>>>>>>>>>>>
84845>>>>>>>>>>>Struct tAPIIndexSegment
84845>>>>>>>>>>>    Integer iFieldNumber
84845>>>>>>>>>>>    String  sFieldName
84845>>>>>>>>>>>    Boolean bUppercase
84845>>>>>>>>>>>    Boolean bAscending
84845>>>>>>>>>>>    Boolean bShouldChange
84845>>>>>>>>>>>    Boolean bCancel
84845>>>>>>>>>>>    Boolean bError
84845>>>>>>>>>>>End_Struct
84845>>>>>>>>>>>
84845>>>>>>>>>>>Struct tAPIIndex
84845>>>>>>>>>>>    Integer iIndexNumber
84845>>>>>>>>>>>    Integer iPrimaryIndex
84845>>>>>>>>>>>    String  sSQLIndexName
84845>>>>>>>>>>>    Integer iSQLIndexType
84845>>>>>>>>>>>    Boolean bIsSQLClustered
84845>>>>>>>>>>>    Boolean bIsSQLPrimaryKey
84845>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
84845>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
84845>>>>>>>>>>>    Boolean bShouldChange
84845>>>>>>>>>>>    Boolean bCancel
84845>>>>>>>>>>>    Boolean bError
84845>>>>>>>>>>>End_Struct
84845>>>>>>>>>>>
84845>>>>>>>>>>>Struct tAPIIndexCompare
84845>>>>>>>>>>>    // Common:
84845>>>>>>>>>>>    Integer iIndexNumber
84845>>>>>>>>>>>    // FROM database:
84845>>>>>>>>>>>    Boolean bExistsFrom
84845>>>>>>>>>>>    Integer iPrimaryIndexFrom
84845>>>>>>>>>>>    String  sSQLIndexNameFrom
84845>>>>>>>>>>>    Integer iSQLIndexTypeFrom
84845>>>>>>>>>>>    Boolean bIsSQLClusteredFrom
84845>>>>>>>>>>>    Boolean bIsSQLPrimaryKeyFrom
84845>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
84845>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
84845>>>>>>>>>>>    Boolean bShouldChangeFrom
84845>>>>>>>>>>>    Boolean bCancelFrom
84845>>>>>>>>>>>    Boolean bErrorFrom
84845>>>>>>>>>>>    // TO database:
84845>>>>>>>>>>>    Boolean bExistsTo
84845>>>>>>>>>>>    Integer iPrimaryIndexTo
84845>>>>>>>>>>>    String  sSQLIndexNameTo
84845>>>>>>>>>>>    Integer iSQLIndexTypeTo
84845>>>>>>>>>>>    Boolean bIsSQLClusteredTo
84845>>>>>>>>>>>    Boolean bIsSQLPrimaryKeyTo
84845>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
84845>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
84845>>>>>>>>>>>    Boolean bShouldChangeTo
84845>>>>>>>>>>>    Boolean bCancelTo
84845>>>>>>>>>>>    Boolean bErrorTo
84845>>>>>>>>>>>End_Struct
84845>>>>>>>>>>>
84845>>>>>>>>>>>Struct tAPITableNameInfo
84845>>>>>>>>>>>    Integer iTableNumber
84845>>>>>>>>>>>    String  sRootName
84845>>>>>>>>>>>    String  sLogicalName
84845>>>>>>>>>>>    String  sDisplayName
84845>>>>>>>>>>>    String  sDriverID
84845>>>>>>>>>>>    Boolean bIsAlias
84845>>>>>>>>>>>    Boolean bIsSQL  
84845>>>>>>>>>>>    Boolean bIsSystemFile
84845>>>>>>>>>>>    Boolean bShouldChange
84845>>>>>>>>>>>    Boolean bCancel
84845>>>>>>>>>>>    Boolean bError
84845>>>>>>>>>>>End_Struct
84845>>>>>>>>>>>
84845>>>>>>>>>>>Struct tAPITableNameInfoCompare
84845>>>>>>>>>>>    Integer iTableNumber
84845>>>>>>>>>>>    // FROM
84845>>>>>>>>>>>    Boolean bExistsFrom
84845>>>>>>>>>>>    String  sRootNameFrom
84845>>>>>>>>>>>    String  sLogicalNameFrom
84845>>>>>>>>>>>    String  sDisplayNameFrom
84845>>>>>>>>>>>    String  sDriverIDFrom
84845>>>>>>>>>>>    Boolean bIsAliasFrom
84845>>>>>>>>>>>    Boolean bIsSQLFrom
84845>>>>>>>>>>>    Boolean bIsSystemFileFrom
84845>>>>>>>>>>>    // TO database:
84845>>>>>>>>>>>    Boolean bExistsTo
84845>>>>>>>>>>>    String  sRootNameTo
84845>>>>>>>>>>>    String  sLogicalNameTo
84845>>>>>>>>>>>    String  sDisplayNameTo
84845>>>>>>>>>>>    String  sDriverIDTo
84845>>>>>>>>>>>    Boolean bIsAliasTo
84845>>>>>>>>>>>    Boolean bIsSQLTo
84845>>>>>>>>>>>    Boolean bIsSystemFileTo // *** Implement!
84845>>>>>>>>>>>    Boolean bShouldChange
84845>>>>>>>>>>>    Boolean bCancel
84845>>>>>>>>>>>    Boolean bError
84845>>>>>>>>>>>End_Struct
84845>>>>>>>>>>>
84845>>>>>>>>>>>Struct tAPITable
84845>>>>>>>>>>>    Handle hTable
84845>>>>>>>>>>>    Boolean bFromTable
84845>>>>>>>>>>>    Boolean bToTable
84845>>>>>>>>>>>    tAPITableNameInfo ApiTableInfo
84845>>>>>>>>>>>    tAPITableNameInfo ApiTableInfo
84845>>>>>>>>>>>    tAPIColumn[]      aApiColumns
84845>>>>>>>>>>>    tAPIColumn[]      aApiColumns
84845>>>>>>>>>>>    tAPIIndex[]       aApiIndexes
84845>>>>>>>>>>>    tAPIIndex[]       aApiIndexes
84845>>>>>>>>>>>    tAPIRelation[]    aApiRelations
84845>>>>>>>>>>>    tAPIRelation[]    aApiRelations
84845>>>>>>>>>>>    Boolean bShouldChange
84845>>>>>>>>>>>    Boolean bCancel
84845>>>>>>>>>>>    Boolean bError
84845>>>>>>>>>>>End_Struct
84845>>>>>>>>>>>
84845>>>>>>>>>>>Struct tAPITableCompare
84845>>>>>>>>>>>    Handle hTable
84845>>>>>>>>>>>    // FROM database:
84845>>>>>>>>>>>    Boolean bExistsFrom
84845>>>>>>>>>>>    // TO database:
84845>>>>>>>>>>>    Boolean bExistsTo
84845>>>>>>>>>>>    // Both:
84845>>>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
84845>>>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
84845>>>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
84845>>>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
84845>>>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
84845>>>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
84845>>>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
84845>>>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
84845>>>>>>>>>>>    Boolean bShouldChange   // Not implemented yet (!)
84845>>>>>>>>>>>    Boolean bCancel         // User cancel
84845>>>>>>>>>>>    Boolean bError          // Error occured while collecting data
84845>>>>>>>>>>>End_Struct
84845>>>>>>>>>>>
84845>>>>>>>>>>>
84845>>>>>>>>>>>Struct tAPITableBooleans  
84845>>>>>>>>>>>    Boolean bApiTableUpdateAuto
84845>>>>>>>>>>>    Boolean bCompareDate_DateTime
84845>>>>>>>>>>>    Boolean bCompareIndexAscending
84845>>>>>>>>>>>    Boolean bCompareIndexUppercase
84845>>>>>>>>>>>    Boolean bCompareFilelistUppercase
84845>>>>>>>>>>>End_Struct
84845>>>>>>>>>>>
84845>>>>>>>>>>>Define C_tAPIColumn_None for 0
84845>>>>>>>>>>>Define C_tAPIColumn_Identity for 1
84845>>>>>>>>>>>
84845>>>>>>>>>>>// SQL Key-Word Constants:
84845>>>>>>>>>>>// Used by the _SqlFindKeyWord function to return a proper keyword depending on the backend SQL,
84845>>>>>>>>>>>// i.e. one of the EN_DbTypeXXX members from the Enum_list above.
84845>>>>>>>>>>>// E.g. the CI_SQLAlterTable is only defined once, but the _SqlFindKeyWord function can return
84845>>>>>>>>>>>// different wording content depending on the EN_xxx value also passed to the function.
84845>>>>>>>>>>>Enum_List
84845>>>>>>>>>>>    Define CI_SQLAlterDatabase         //for "ALTER DATABASE"          
84845>>>>>>>>>>>    Define CI_SQLSingle_User           //for "SINGLE_USER"
84845>>>>>>>>>>>    Define CI_SQLMulti_User            //for "USER_USER"
84845>>>>>>>>>>>    Define CI_SQLRollback              //for "ROLLBACK"
84845>>>>>>>>>>>    Define CI_SQLIMMEDIATE             //for "IMMEDIATE"
84845>>>>>>>>>>>    Define CI_SQLAlterTable            //for "ALTER TABLE"
84845>>>>>>>>>>>    Define CI_SQLAlterColumn           //for "ALTER COLUMN"
84845>>>>>>>>>>>    Define CI_SQLRenameColumn          //for "RENAME COLUMN"
84845>>>>>>>>>>>    Define CI_SQLColumn                //for "COLUMN"
84845>>>>>>>>>>>    Define CI_SQLSelect                //for "SELECT"
84845>>>>>>>>>>>    Define CI_SQLWhere                 //for "WHERE"
84845>>>>>>>>>>>    Define CI_SQLInfoSchema            //for "INFORMATION_SCHEMA.COLUMNS"
84845>>>>>>>>>>>    Define CI_SQLTable_Name            //for "TABLE_NAME"
84845>>>>>>>>>>>    Define CI_SQLTable                 //for "TABLE"
84845>>>>>>>>>>>    Define CI_SQLSys                   //for "SYS"
84845>>>>>>>>>>>    Define CI_SQLSp_Help               //for "SP_HELP"
84845>>>>>>>>>>>    Define CI_SQLFrom                  //for "FROM"
84845>>>>>>>>>>>    Define CI_SQLAdd                   //for "ADD"
84845>>>>>>>>>>>    Define CI_SQLDropColumn            //for "DROP"
84845>>>>>>>>>>>    Define CI_SQLCreateDatabase        //for "CREATE DATABASE"
84845>>>>>>>>>>>    Define CI_SQLDatabaseCollation     //for "COLLATE"
84845>>>>>>>>>>>    Define CI_SQLCreateTable           //for "CREATE TABLE"
84845>>>>>>>>>>>    Define CI_SQLDropTable             //for "DROP TABLE"
84845>>>>>>>>>>>    Define CI_SQLCreateView            //for "CREATE VIEW"
84845>>>>>>>>>>>    Define CI_SQLRenameTable           //for "RENAME TABLE"
84845>>>>>>>>>>>//    Define CI_SQLSelectFromWhereName   //for "SELECT name from [master].[dbo].[sysdatabases] where name"
84845>>>>>>>>>>>    Define CI_SQLDropView              //for "DROP VIEW"
84845>>>>>>>>>>>    Define CI_SQLSetNoCountOn          //for "SET NOCOUNT ON"
84845>>>>>>>>>>>    Define CI_SQLTo                    //for "TO"
84845>>>>>>>>>>>    Define CI_SQLGO                    //for "GO"
84845>>>>>>>>>>>    Define CI_SQLUse                   //for "USE"
84845>>>>>>>>>>>    Define CI_SQLDBO                   //for "DBO"
84845>>>>>>>>>>>
84845>>>>>>>>>>>    Define CI_SQLName                  //for "NAME"
84845>>>>>>>>>>>    Define CI_SQLMaster                //for "MASTER"
84845>>>>>>>>>>>    Define CI_SQLDatabases             //for "DATABASES"
84845>>>>>>>>>>>    Define CI_SQLSysIndexes            //for "SYS.INDEXES"
84845>>>>>>>>>>>    Define CI_SQLObjectID              //for "OBJECT_ID"
84845>>>>>>>>>>>    Define CI_SQLID                    //for "ID"
84845>>>>>>>>>>>    Define CI_SQLAND                   //for "AND"
84845>>>>>>>>>>>    Define CI_SQLUpdate                //for "UPDATE"
84845>>>>>>>>>>>    Define CI_SQLSet                   //for "SET"
84845>>>>>>>>>>>    Define CI_SQLWith                  //for "WITH"
84845>>>>>>>>>>>    Define CI_SQLNotNull               //for "NOT NULL"
84845>>>>>>>>>>>End_Enum_List
84845>>>>>>>>>>>
84845>>>>>>>
84845>>>>>>>// This needs to be after Mertech drivers are defined.
84845>>>>>>>Use cDbUpdateFunctionLibrary_Mixin.pkg
Including file: cDbUpdateFunctionLibrary_Mixin.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary_Mixin.pkg)
84845>>>>>>>>>// *** Mixin Class For the cDbUpdateFunctionLibrary Class ***
84845>>>>>>>>>//
84845>>>>>>>>>// We need to create a mixin class for the library.
84845>>>>>>>>>// Why? Because we import the library to the cDbUpdateVersion class; that imports
84845>>>>>>>>>// all messages (functions & procedures) but all Properties are "lost", aka not imported by
84845>>>>>>>>>// the Import_Class_Protocol command. So we need a way to create our properties somewhere else...
84845>>>>>>>>>// Note: This class should _not_ have a construct_object defined.
84845>>>>>>>>>//
84845>>>>>>>>>Use VdfBase.pkg
84845>>>>>>>>>Use WinUuid.pkg
Including file: WinUuid.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\WinUuid.pkg)
84845>>>>>>>>>>>External_Function WinAPI_UuidCreate "UuidCreate" Rpcrt4.dll Address Uuid Returns Integer
84846>>>>>>>>>>>External_Function WinAPI_UuidToString  "UuidToStringA" Rpcrt4.dll Address aUuid Address lpUUIDString Returns Integer
84847>>>>>>>>>>>External_Function WinAPI_UuidCreateSequential "UuidCreateSequential" Rpcrt4.dll Address aUuid Returns Integer
84848>>>>>>>>>>>External_Function WinAPI_RpcStringFree "RpcStringFreeA" Rpcrt4.dll Address pStr Returns Integer
84849>>>>>>>>>>>
84849>>>>>>>>>>>// RandomHexUUID:
84849>>>>>>>>>>>
84849>>>>>>>>>>>// Returns a 'random' Universally Unique Identifier string as a 32 digit hex number.
84849>>>>>>>>>>>Function RandomHexUUID Global Returns String
84851>>>>>>>>>>>    Address pUUID pUUIDStr
84851>>>>>>>>>>>    Integer iRetval iOffset iChar
84851>>>>>>>>>>>    String sUUID sKey
84851>>>>>>>>>>>    
84851>>>>>>>>>>>    Move (Alloc(16)) to pUUID
84852>>>>>>>>>>>    
84852>>>>>>>>>>>    Move (WinAPI_UuidCreate (pUUID)) to iRetval
84853>>>>>>>>>>>    
84853>>>>>>>>>>>    If (iRetval = 0) Begin
84855>>>>>>>>>>>        Move 0 to pUUIDStr
84856>>>>>>>>>>>        
84856>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
84857>>>>>>>>>>>        If (iRetval = 0) Begin
84859>>>>>>>>>>>            Move pUUIDStr to sUUID
84860>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
84861>>>>>>>>>>> 
84861>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
84862>>>>>>>>>>>        End
84862>>>>>>>>>>>>
84862>>>>>>>>>>>    End
84862>>>>>>>>>>>>
84862>>>>>>>>>>>    
84862>>>>>>>>>>>    Move (Free(pUUID)) to iRetval 
84863>>>>>>>>>>>    
84863>>>>>>>>>>>    Function_Return sUUID
84864>>>>>>>>>>>End_Function
84865>>>>>>>>>>>
84865>>>>>>>>>>>
84865>>>>>>>>>>>// SeqHexUUID:
84865>>>>>>>>>>>
84865>>>>>>>>>>>// Returns a sequential Universally Unique Identifier string as a 32 digit hex number.
84865>>>>>>>>>>>Function SeqHexUUID Global Returns String    
84867>>>>>>>>>>>    Address pUUID pUUIDStr
84867>>>>>>>>>>>    Integer iRetval iOffset iChar
84867>>>>>>>>>>>    String sUUID sKey
84867>>>>>>>>>>>    
84867>>>>>>>>>>>    Move (Alloc(16)) to pUUID
84868>>>>>>>>>>>    
84868>>>>>>>>>>>    Move (WinAPI_UuidCreateSequential (pUUID)) to iRetval
84869>>>>>>>>>>>    
84869>>>>>>>>>>>    If (iRetval = 0) Begin
84871>>>>>>>>>>>        Move 0 to pUUIDStr
84872>>>>>>>>>>>        
84872>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
84873>>>>>>>>>>>        If (iRetval = 0) Begin
84875>>>>>>>>>>>            Move pUUIDStr to sUUID
84876>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
84877>>>>>>>>>>> 
84877>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
84878>>>>>>>>>>>        End
84878>>>>>>>>>>>>
84878>>>>>>>>>>>    End
84878>>>>>>>>>>>>
84878>>>>>>>>>>>    
84878>>>>>>>>>>>    Move (Free(pUUID)) to iRetval 
84879>>>>>>>>>>>    
84879>>>>>>>>>>>    Function_Return sUUID
84880>>>>>>>>>>>End_Function
84881>>>>>>>>>Use cli.pkg
84881>>>>>>>>>Use sql.pkg
84881>>>>>>>>>Use MSSqldrv.pkg
84881>>>>>>>>>Use db2_drv.pkg
84881>>>>>>>>>Use odbc_drv.pkg
84881>>>>>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (C:\Program Files (x86)\DataFlex 19.0\Pkg\DFBTRDRV.PKG)
84881>>>>>>>>>>>//****************************************************************************
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// $File name  : DFBTRDRV.PKG
84881>>>>>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
84881>>>>>>>>>>>// Notice      : This package contains constants and commands, used to call
84881>>>>>>>>>>>//               specific functions in the DFBTRDRV.
84881>>>>>>>>>>>// $Author(s)  : Eddy Kleinjan
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// $System     : DataFlex Connectivity Kit for Pervasive.SQL
84881>>>>>>>>>>>// Created     : 01-07-97 @ 12:00:00
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// Changed     : 04-04-2001.
84881>>>>>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.145
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// Changed     : June 6, 2001
84881>>>>>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.148
84881>>>>>>>>>>>//
84881>>>>>>>>>>>//               Added DFBTR_DDF_OWNER command.
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// Changed     : June 12, 2001
84881>>>>>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.149
84881>>>>>>>>>>>//
84881>>>>>>>>>>>//               Added DF_FIELD_IS_NULL and DF_FIELD_NULL_ALLOWED attributes
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// Changed     : August 4, 2004
84881>>>>>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 3.0.0.1
84881>>>>>>>>>>>//
84881>>>>>>>>>>>//               Added cDfbtrdrvHandler class.
84881>>>>>>>>>>>//               New functions in this class:
84881>>>>>>>>>>>//                  Function CKRevision Returns String
84881>>>>>>>>>>>//                  Function CkUsesUri Returns Integer
84881>>>>>>>>>>>//                  Function PSQLRequesterVersionInfo Integer iFileNum Returns String
84881>>>>>>>>>>>//                  Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
84881>>>>>>>>>>>//                  Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// Changed     : September 30, 2005
84881>>>>>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 3.0.0.14
84881>>>>>>>>>>>//
84881>>>>>>>>>>>//               Bugfix: Prevent compiler errors when no (df)error.pkg is used
84881>>>>>>>>>>>//****************************************************************************
84881>>>>>>>>>>>Use Ui
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// Driver Indentification
84881>>>>>>>>>>>//
84881>>>>>>>>>>>
84881>>>>>>>>>>>//*** Driver attributes
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// Call_Driver functions ID's
84881>>>>>>>>>>>//
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// DFBTRFN_CONVERT_FILE options
84881>>>>>>>>>>>//
84881>>>>>>>>>>>
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// DFBTRFN_SET_OWNER options
84881>>>>>>>>>>>//
84881>>>>>>>>>>>
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
84881>>>>>>>>>>>//
84881>>>>>>>>>>>
84881>>>>>>>>>>>
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// Command to create all vars which may be needed
84881>>>>>>>>>>>// in other commands.
84881>>>>>>>>>>>//
84881>>>>>>>>>>>
84881>>>>>>>>>>>
84881>>>>>>>>>>>
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// Command to set the owner of a Btrieve file.
84881>>>>>>>>>>>// File must have been opened.
84881>>>>>>>>>>>// Filenumber needs to be passed.
84881>>>>>>>>>>>// To clear set the owner to "".
84881>>>>>>>>>>>// Examples:
84881>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
84881>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
84881>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
84881>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
84881>>>>>>>>>>>// To clear:
84881>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
84881>>>>>>>>>>>//
84881>>>>>>>>>>>
84881>>>>>>>>>>>
84881>>>>>>>>>>>
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// Command to parse DFBTR_SET_OWNVER
84881>>>>>>>>>>>// options.
84881>>>>>>>>>>>//
84881>>>>>>>>>>>
84881>>>>>>>>>>>
84881>>>>>>>>>>>
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// Command to parse for Callback
84881>>>>>>>>>>>//
84881>>>>>>>>>>>
84881>>>>>>>>>>>
84881>>>>>>>>>>>
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// Command to clear the owner of a Btrieve file.
84881>>>>>>>>>>>// File must have been opened.
84881>>>>>>>>>>>// Filenumber needs to be passed.
84881>>>>>>>>>>>// Examples:
84881>>>>>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
84881>>>>>>>>>>>//
84881>>>>>>>>>>>
84881>>>>>>>>>>>
84881>>>>>>>>>>>
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// Command to add a owner name to the internal list of ownernames
84881>>>>>>>>>>>// which will be tries when opening files.
84881>>>>>>>>>>>//
84881>>>>>>>>>>>
84881>>>>>>>>>>>
84881>>>>>>>>>>>
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// Command to remove all owners from the internal list of ownernames
84881>>>>>>>>>>>//
84881>>>>>>>>>>>
84881>>>>>>>>>>>
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// Command to set the owner name to be used when opening the DDF files.
84881>>>>>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
84881>>>>>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
84881>>>>>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
84881>>>>>>>>>>>//
84881>>>>>>>>>>>
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// Command to change the transaction type.
84881>>>>>>>>>>>// Valid types are:
84881>>>>>>>>>>>//     DFBTRTT_NONE
84881>>>>>>>>>>>//     DFBTRTT_EXCLUSIVE
84881>>>>>>>>>>>//     DFBTRTT_CONCURRENT
84881>>>>>>>>>>>//
84881>>>>>>>>>>>//
84881>>>>>>>>>>>
84881>>>>>>>>>>>
84881>>>>>>>>>>>
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// Command to get the current transaction type.
84881>>>>>>>>>>>//
84881>>>>>>>>>>>
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// Command to set explicit_locking
84881>>>>>>>>>>>//
84881>>>>>>>>>>>
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// Command to get explicit locking
84881>>>>>>>>>>>//
84881>>>>>>>>>>>
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
84881>>>>>>>>>>>//
84881>>>>>>>>>>>
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
84881>>>>>>>>>>>//
84881>>>>>>>>>>>
84881>>>>>>>>>>>//*****************************************************************************
84881>>>>>>>>>>>//*** Class  : cDfbtrdrvHandler                                                  ***
84881>>>>>>>>>>>//*** Purpose: An instance of this class can be used as a broker object to  ***
84881>>>>>>>>>>>//***          call several Dfbtrdrv releated methods.                           ***
84881>>>>>>>>>>>//*****************************************************************************
84881>>>>>>>>>>>
84881>>>>>>>>>>>Class cDFBtrDrvHandler Is An Array
84882>>>>>>>>>>>
84882>>>>>>>>>>>    Procedure Construct_Object Integer iImage
84884>>>>>>>>>>>        Forward Send Construct_object iImage
84886>>>>>>>>>>>
84886>>>>>>>>>>>        Property String  psDriverID       Public "DFBTRDRV"
84887>>>>>>>>>>>    End_Procedure // Construct_Object
84888>>>>>>>>>>>
84888>>>>>>>>>>>
84888>>>>>>>>>>>
84888>>>>>>>>>>>    //***
84888>>>>>>>>>>>    //*** Function: CKRevsion
84888>>>>>>>>>>>    //*** Purpose : The revsion of a Dfbtrdrv Connectivity Kit
84888>>>>>>>>>>>    //***
84888>>>>>>>>>>>
84888>>>>>>>>>>>    Function CKRevision Returns String
84890>>>>>>>>>>>        Local String  sDriverID
84890>>>>>>>>>>>        Local String  sRevision
84890>>>>>>>>>>>        Local String  sVoid
84890>>>>>>>>>>>        Local Integer iRetval
84890>>>>>>>>>>>
84890>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
84890>>>>>>>>>>>        // This error would otherwise be raised when we have an older
84890>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
84890>>>>>>>>>>>        Send Ignore_error To Error_object_Id 20491
84891>>>>>>>>>>>        Get psDriverID To sDriverID
84892>>>>>>>>>>>        Move (Repeat(" ", 255)) To sRevision
84893>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
84898>>>>>>>>>>>        Send Trap_Error To Error_object_Id 20491
84899>>>>>>>>>>>        If (Trim(sRevision) = "") Begin
84901>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
84901>>>>>>>>>>>            Move "0.0.0.0" To sRevision
84902>>>>>>>>>>>        End
84902>>>>>>>>>>>>
84902>>>>>>>>>>>        Function_Return sRevision
84903>>>>>>>>>>>    End_Function // CKRevision
84904>>>>>>>>>>>
84904>>>>>>>>>>>    Function CkUsesUri Returns Integer
84906>>>>>>>>>>>        Local String  sDriverID
84906>>>>>>>>>>>        Local String  sVoid1
84906>>>>>>>>>>>        Local String  sVoid2
84906>>>>>>>>>>>        Local Integer iRetval
84906>>>>>>>>>>>
84906>>>>>>>>>>>        Get psDriverID To sDriverID
84907>>>>>>>>>>>
84907>>>>>>>>>>>        Move 0 To iRetval
84908>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
84908>>>>>>>>>>>        // This error would otherwise be raised when we have an older
84908>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
84908>>>>>>>>>>>        Send Ignore_error To Error_object_Id 20491
84909>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
84914>>>>>>>>>>>        Send Trap_Error To Error_object_Id 20491
84915>>>>>>>>>>>
84915>>>>>>>>>>>        Function_Return iRetval
84916>>>>>>>>>>>    End_Function // CKUsesUri
84917>>>>>>>>>>>
84917>>>>>>>>>>>
84917>>>>>>>>>>>
84917>>>>>>>>>>>    //***
84917>>>>>>>>>>>    //*** Function: ExtractPartFromRevsion
84917>>>>>>>>>>>    //*** Purpose : Extarct the Nth part of a a.b.c.d revsion string.
84917>>>>>>>>>>>    //***
84917>>>>>>>>>>>    //*** Returns : The part version number or -1 if there is no such part number.
84917>>>>>>>>>>>    //***
84917>>>>>>>>>>>
84917>>>>>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
84919>>>>>>>>>>>        Local Integer iPartRev
84919>>>>>>>>>>>        Local Integer iCurrentPart
84919>>>>>>>>>>>        Local Integer iSeparatorPos
84919>>>>>>>>>>>
84919>>>>>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
84922>>>>>>>>>>>
84922>>>>>>>>>>>        Move 0 To iCurrentPart
84923>>>>>>>>>>>        Repeat
84923>>>>>>>>>>>>
84923>>>>>>>>>>>            Move (Pos(".", sRevision)) To iSeparatorPos
84924>>>>>>>>>>>            If (iSeparatorPos > 0) Begin
84926>>>>>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) To iPartRev
84927>>>>>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) To sRevision
84928>>>>>>>>>>>                Increment iCurrentPart
84929>>>>>>>>>>>            End
84929>>>>>>>>>>>>
84929>>>>>>>>>>>            Else If (sRevision <> "") Begin
84932>>>>>>>>>>>                Move sRevision To iPartRev
84933>>>>>>>>>>>                Move "" To sRevision
84934>>>>>>>>>>>                Increment iCurrentPart
84935>>>>>>>>>>>            End
84935>>>>>>>>>>>>
84935>>>>>>>>>>>            Else ;                Move -1 To iPartRev
84937>>>>>>>>>>>        Until (iCurrentPart >= iPartNum Or iPartRev = -1)
84939>>>>>>>>>>>
84939>>>>>>>>>>>        Function_Return iPartRev
84940>>>>>>>>>>>    End_Function // EcxtractPartFromRevision
84941>>>>>>>>>>>
84941>>>>>>>>>>>
84941>>>>>>>>>>>
84941>>>>>>>>>>>    //***
84941>>>>>>>>>>>    //*** Function: CKMajorRevision
84941>>>>>>>>>>>    //*** Purpose : Returns the major revision of the CK
84941>>>>>>>>>>>    //***
84941>>>>>>>>>>>
84941>>>>>>>>>>>    Function CKMajorRevision Returns Integer
84943>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
84944>>>>>>>>>>>    End_Function // CKMajorRevision
84945>>>>>>>>>>>
84945>>>>>>>>>>>
84945>>>>>>>>>>>
84945>>>>>>>>>>>    //***
84945>>>>>>>>>>>    //*** Function: CKMinorRevision
84945>>>>>>>>>>>    //*** Purpose : Returns the minor revision of the CK
84945>>>>>>>>>>>    //***
84945>>>>>>>>>>>
84945>>>>>>>>>>>    Function CKMinorRevision Returns Integer
84947>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
84948>>>>>>>>>>>    End_Function // CKMinorRevision
84949>>>>>>>>>>>
84949>>>>>>>>>>>
84949>>>>>>>>>>>
84949>>>>>>>>>>>    //***
84949>>>>>>>>>>>    //*** Function: CKReleaseRevision
84949>>>>>>>>>>>    //*** Purpose : Returns the release revision of the CK
84949>>>>>>>>>>>    //***
84949>>>>>>>>>>>
84949>>>>>>>>>>>    Function CKReleaseRevision Returns Integer
84951>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
84952>>>>>>>>>>>    End_Function // CKReleaseRevision
84953>>>>>>>>>>>
84953>>>>>>>>>>>
84953>>>>>>>>>>>
84953>>>>>>>>>>>    //***
84953>>>>>>>>>>>    //*** Function: CKBuildRevision
84953>>>>>>>>>>>    //*** Purpose : Returns the major revision of the CK
84953>>>>>>>>>>>    //***
84953>>>>>>>>>>>
84953>>>>>>>>>>>    Function CKBuildRevision Returns Integer
84955>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
84956>>>>>>>>>>>    End_Function // CKBuildRevision
84957>>>>>>>>>>>
84957>>>>>>>>>>>
84957>>>>>>>>>>>
84957>>>>>>>>>>>    //***
84957>>>>>>>>>>>    //*** Function: IsMinimalRevision
84957>>>>>>>>>>>    //*** Purpose : Determines if the CK conforms to a passed minimal revsion.
84957>>>>>>>>>>>    //***
84957>>>>>>>>>>>
84957>>>>>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
84959>>>>>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_return (TRUE)
84962>>>>>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
84965>>>>>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_return (TRUE)
84968>>>>>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
84971>>>>>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_return (TRUE)
84974>>>>>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) And iBuild <= CKBuildRevision(Current_object)) ;                    Function_return (TRUE)
84978>>>>>>>>>>>            End
84978>>>>>>>>>>>>
84978>>>>>>>>>>>        End
84978>>>>>>>>>>>>
84978>>>>>>>>>>>
84978>>>>>>>>>>>        Function_Return (FALSE)
84979>>>>>>>>>>>    End_Function // IsMinimalRevision
84980>>>>>>>>>>>
84980>>>>>>>>>>>    //   Functions to query the Pervasive.SQL version:
84980>>>>>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
84980>>>>>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
84980>>>>>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
84980>>>>>>>>>>>    //
84980>>>>>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
84980>>>>>>>>>>>    //   in the following format:
84980>>>>>>>>>>>    //       <version>.<revision>.<type>
84980>>>>>>>>>>>    //   possible values for <type>:
84980>>>>>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
84980>>>>>>>>>>>    //         server using Workgroup authentication mode
84980>>>>>>>>>>>    //       C for client cache engine
84980>>>>>>>>>>>    //       D for DOS workstation
84980>>>>>>>>>>>    //       N for client Requester
84980>>>>>>>>>>>    //       S for NetWare server
84980>>>>>>>>>>>    //       T for 32-bit Windows server engine
84980>>>>>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
84980>>>>>>>>>>>    //
84980>>>>>>>>>>>    //   example:
84980>>>>>>>>>>>    //       8.50.T
84980>>>>>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
84980>>>>>>>>>>>    //   32-bits Windows server.
84980>>>>>>>>>>>    //
84980>>>>>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
84980>>>>>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
84980>>>>>>>>>>>    //
84980>>>>>>>>>>>    //   If the version information is not available or can not be obtained
84980>>>>>>>>>>>    //   the functions will return "0.0.0"
84980>>>>>>>>>>>
84980>>>>>>>>>>>
84980>>>>>>>>>>>    //***
84980>>>>>>>>>>>    //*** Function: PSQLRequesterVersionInfo
84980>>>>>>>>>>>    //*** Purpose : Returns the version information of the
84980>>>>>>>>>>>    //***           Pervasive.SQL Client requester.
84980>>>>>>>>>>>
84980>>>>>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
84982>>>>>>>>>>>
84982>>>>>>>>>>>        Local String  sDriverID
84982>>>>>>>>>>>        Local String  sVersion
84982>>>>>>>>>>>        Local String  sVoid
84982>>>>>>>>>>>        Local Integer iRetval
84982>>>>>>>>>>>
84982>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
84982>>>>>>>>>>>        // This error would otherwise be raised when we have an older
84982>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
84982>>>>>>>>>>>        Send Ignore_error To Error_object_Id 20491
84983>>>>>>>>>>>        Get psDriverID To sDriverID
84984>>>>>>>>>>>        Move (Repeat(" ", 255)) To sVersion
84985>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
84990>>>>>>>>>>>        Send Trap_Error To Error_object_Id 20491
84991>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
84993>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
84993>>>>>>>>>>>            Move "0.0.0" To sVersion
84994>>>>>>>>>>>        End
84994>>>>>>>>>>>>
84994>>>>>>>>>>>        Function_Return sVersion
84995>>>>>>>>>>>    End_Function //  PSQLRequesterVersion
84996>>>>>>>>>>>
84996>>>>>>>>>>>    //***
84996>>>>>>>>>>>    //*** Function: PSQLLocalEngineVersionInfo
84996>>>>>>>>>>>    //*** Purpose : Returns the version information of the
84996>>>>>>>>>>>    //***           Pervasive.SQL Local Engine
84996>>>>>>>>>>>
84996>>>>>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
84998>>>>>>>>>>>
84998>>>>>>>>>>>        Local String  sDriverID
84998>>>>>>>>>>>        Local String  sVersion
84998>>>>>>>>>>>        Local String  sVoid
84998>>>>>>>>>>>        Local Integer iRetval
84998>>>>>>>>>>>
84998>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
84998>>>>>>>>>>>        // This error would otherwise be raised when we have an older
84998>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
84998>>>>>>>>>>>        Send Ignore_error To Error_object_Id 20491
84999>>>>>>>>>>>        Get psDriverID To sDriverID
85000>>>>>>>>>>>        Move (Repeat(" ", 255)) To sVersion
85001>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
85006>>>>>>>>>>>        Send Trap_Error To Error_object_Id 20491
85007>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
85009>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
85009>>>>>>>>>>>            Move "0.0.0" To sVersion
85010>>>>>>>>>>>        End
85010>>>>>>>>>>>>
85010>>>>>>>>>>>        Function_Return sVersion
85011>>>>>>>>>>>    End_Function //  PSQLLocalEngineVersion
85012>>>>>>>>>>>
85012>>>>>>>>>>>    //***
85012>>>>>>>>>>>    //*** Function: PSQLServerEngineVersionInfo
85012>>>>>>>>>>>    //*** Purpose : Returns the version information of the
85012>>>>>>>>>>>    //***           Pervasive.SQL Server Engine
85012>>>>>>>>>>>
85012>>>>>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
85014>>>>>>>>>>>
85014>>>>>>>>>>>        Local String  sDriverID
85014>>>>>>>>>>>        Local String  sVersion
85014>>>>>>>>>>>        Local String  sVoid
85014>>>>>>>>>>>        Local Integer iRetval
85014>>>>>>>>>>>
85014>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
85014>>>>>>>>>>>        // This error would otherwise be raised when we have an older
85014>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
85014>>>>>>>>>>>        Send Ignore_error To Error_object_Id 20491
85015>>>>>>>>>>>        Get psDriverID To sDriverID
85016>>>>>>>>>>>        Move (Repeat(" ", 255)) To sVersion
85017>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
85022>>>>>>>>>>>        Send Trap_Error To Error_object_Id 20491
85023>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
85025>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
85025>>>>>>>>>>>            Move "0.0.0" To sVersion
85026>>>>>>>>>>>        End
85026>>>>>>>>>>>>
85026>>>>>>>>>>>        Function_Return sVersion
85027>>>>>>>>>>>    End_Function //  PSQLServerEngineVersion
85028>>>>>>>>>>>
85028>>>>>>>>>>>End_Class // cDfbtrdrvHandler
85029>>>>>>>>>>>
85029>>>>>>>>>Use cDbUpdateFunctionLibrary.inc
85029>>>>>>>>>Use cSQLConnectionIniFile.inc
85029>>>>>>>>>
85029>>>>>>>>>Class cDbUpdateFunctionLibrary_Mixin is a Mixin
85030>>>>>>>>>    Procedure CreateDbUpdateLibraryProperties
85032>>>>>>>>>        Handle hoSQLManagerMT
85032>>>>>>>>>
85032>>>>>>>>>        Property String Private.psUseDatabase ""
85033>>>>>>>>>
85033>>>>>>>>>//        { Visibility=Private }
85033>>>>>>>>>        // These are used by the Error routine to show the Table# & Field# if something goes wrong:
85033>>>>>>>>>        Property Handle  Private.phCurrentTable 0
85034>>>>>>>>>        Property Integer Private.piCurrentField 0
85035>>>>>>>>>
85035>>>>>>>>>        Property Handle phoCLIHandler      (Create(Self,RefClass(cCLIHandler)))
85036>>>>>>>>>        Property Handle phoSQLManager      (Create(Self,RefClass(cSQLHandleManager)))
85037>>>>>>>>>
85037>>>>>>>>>        Property Handle phoSQLManagerMT
85038>>>>>>>>>            Move (Create(Self,RefClass(cSQLHandleManagerDUF))) to hoSQLManagerMT
85039>>>>>>>>>            Set phoSQLManagerMT to hoSQLManagerMT
85040>>>>>>>>>
85040>>>>>>>>>        Property Handle phoMSSQLHandler    (Create(Self,RefClass(cMSSQLHandler)))
85041>>>>>>>>>        Property Handle phoDB2SQLHandler   (Create(Self,RefClass(cDB2Handler)))
85042>>>>>>>>>        Property Handle phoODBCSQLHandler  (Create(Self,RefClass(cODBCHandler)))
85043>>>>>>>>>        Property Handle phoSQLConnectionHandler 0
85044>>>>>>>>>        Property tSQLKeyWords[] paSQLKeywordArray
85045>>>>>>>>>
85045>>>>>>>>>        Property Boolean pbHandleQueryErrors True
85046>>>>>>>>>
85046>>>>>>>>>        Property tSqlColumnNew[] paQueryColumns
85047>>>>>>>>>        Property String[] paSQLFetchResults
85048>>>>>>>>>
85048>>>>>>>>>        // Error handling     
85048>>>>>>>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT        
85049>>>>>>>>>        Property Boolean pbSqlError False
85050>>>>>>>>>        Property tSqlErrorArray paSqlErrorArray
85051>>>>>>>>>        Property Boolean pbProcessingError False
85052>>>>>>>>>
85052>>>>>>>>>        // Statistics on query
85052>>>>>>>>>        Property TimeSpan ptsTotalQueryTime
85053>>>>>>>>>        Property TimeSpan ptsQueryExec
85054>>>>>>>>>        Property TimeSpan ptsFetchResults
85055>>>>>>>>>        Property Integer piColumns 0
85056>>>>>>>>>        Property Integer piRows 0
85057>>>>>>>>>        Property Integer piRowType 0
85058>>>>>>>>>        Property String[] paQueryMessages
85059>>>>>>>>>        Property String psSQLStatementString
85060>>>>>>>>>
85060>>>>>>>>>        Property Integer[] paTableConvertExceptions
85061>>>>>>>>>
85061>>>>>>>>>        Property Integer[] paTableDateCorrectionExceptions
85062>>>>>>>>>
85062>>>>>>>>>        // Number of SQL statements (chunks) to be executed when executing a really big
85062>>>>>>>>>        // SQL file that has been compiled into the program. It is way faster to divide
85062>>>>>>>>>        // the statements in smaller chunks than to execute them all at the same time.
85062>>>>>>>>>        Property Integer piChunkMax 500
85063>>>>>>>>>
85063>>>>>>>>>        // Fill the paSQLKeywordArray array with values;
85063>>>>>>>>>        Send SetupSQLKeywordArray
85064>>>>>>>>>    End_Procedure
85065>>>>>>>>>
85065>>>>>>>>>    // Custom array find function. It compares both the iSQLWord & iSQLDbType params.
85065>>>>>>>>>    Function CompareFindSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
85067>>>>>>>>>        If (SQLKeywords1.iSQLWord = SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType = SQLKeywords2.iSQLDbType) Begin
85069>>>>>>>>>            Function_Return (EQ)
85070>>>>>>>>>        End
85070>>>>>>>>>>
85070>>>>>>>>>        Function_Return (GT)
85071>>>>>>>>>    End_Function
85072>>>>>>>>>
85072>>>>>>>>>    // Custom array sort function. It compares both the iSQLWord & iSQLDbType params.
85072>>>>>>>>>    Function CompareSortSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
85074>>>>>>>>>        If (SQLKeywords1.iSQLWord   < SQLKeywords2.iSQLWord) ;            Function_Return (LT)
85077>>>>>>>>>        If (SQLKeywords1.iSQLWord   > SQLKeywords2.iSQLWord) ;            Function_Return (GT)
85080>>>>>>>>>        If (SQLKeywords1.iSQLDbType < SQLKeywords2.iSQLDbType) ;            Function_Return (LT)
85083>>>>>>>>>        If (SQLKeywords1.iSQLDbType > SQLKeywords2.iSQLDbType) ;            Function_Return (GT)
85086>>>>>>>>>
85086>>>>>>>>>        Function_Return (EQ)
85087>>>>>>>>>    End_Function
85088>>>>>>>>>
85088>>>>>>>>>    Procedure Add_Element Integer iSQLKeywordConstant Integer iEN_dbType String sSQLKeyword
85090>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
85090>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
85091>>>>>>>>>        Integer iSize
85091>>>>>>>>>
85091>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
85092>>>>>>>>>        Move (SizeOfArray(SQLKeywordArray)) to iSize
85093>>>>>>>>>        Move iSQLKeywordConstant to SQLKeywordArray[iSize].iSQLWord
85094>>>>>>>>>        Move iEN_dbType          to SQLKeywordArray[iSize].iSQLDbType
85095>>>>>>>>>        Move sSQLKeyword         to SQLKeywordArray[iSize].sSQLPhrase
85096>>>>>>>>>
85096>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
85097>>>>>>>>>    End_Procedure
85098>>>>>>>>>
85098>>>>>>>>>    // Creates a struct array with all SQL keywords
85098>>>>>>>>>    // for all EN_xxx SQL back-ends. Various back-ends can
85098>>>>>>>>>    // have slightly different wording.
85098>>>>>>>>>    // If a new EN_dbTypexxx type is added; additions
85098>>>>>>>>>    // needs to be done for every keyword group below.
85098>>>>>>>>>    Procedure SetupSQLKeywordArray
85100>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
85100>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
85102>>>>>>>>>
85102>>>>>>>>>        // This should only be called once; but in case it is
85102>>>>>>>>>        // we delete the array first.
85102>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
85103>>>>>>>>>
85103>>>>>>>>>        // ToDo: *** Not all SQL Key-words has been checked for other backends than MS-SQL ***
85103>>>>>>>>>        //
85103>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMSSQL    "ALTER DATABASE"
85104>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMySQL    "ALTER DATABASE"
85105>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeOracle   "ALTER DATABASE"
85106>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeDB2      "ALTER DATABASE"
85107>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypePostgre  "ALTER DATABASE"  
85108>>>>>>>>>        
85108>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMSSQL    "SINGLE_USER"
85109>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMySQL    "SINGLE_USER"
85110>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeOracle   "SINGLE_USER"
85111>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeDB2      "SINGLE_USER"
85112>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypePostgre  "SINGLE_USER"  
85113>>>>>>>>>        
85113>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMSSQL    "MULTI_USER"
85114>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMySQL    "MULTI_USER"
85115>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeOracle   "MULTI_USER"
85116>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeDB2      "MULTI_USER"
85117>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypePostgre  "MULTI_USER"  
85118>>>>>>>>>        
85118>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMSSQL    "ROLLBACK"
85119>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMySQL    "ROLLBACK"
85120>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeOracle   "ROLLBACK"
85121>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeDB2      "ROLLBACK"
85122>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypePostgre  "ROLLBACK"  
85123>>>>>>>>>        
85123>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMSSQL    "IMMEDIATE"
85124>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMySQL    "IMMEDIATE"
85125>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeOracle   "IMMEDIATE"
85126>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeDB2      "IMMEDIATE"
85127>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypePostgre  "IMMEDIATE"  
85128>>>>>>>>>        
85128>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMSSQL    "ALTER TABLE"
85129>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMySQL    "ALTER TABLE"
85130>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeOracle   "ALTER TABLE"
85131>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeDB2      "ALTER TABLE"
85132>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypePostgre  "ALTER TABLE"
85133>>>>>>>>>
85133>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMSSQL           "ADD"
85134>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMySQL           "ADD"
85135>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeOracle          "ADD"
85136>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeDB2             "ADD"
85137>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypePostgre         "ADD"
85138>>>>>>>>>
85138>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMSSQL        "UPDATE"
85139>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMySQL        "UPDATE"
85140>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeOracle       "UPDATE"
85141>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeDB2          "UPDATE"
85142>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypePostgre      "UPDATE"
85143>>>>>>>>>
85143>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMSSQL       "NOT NULL"
85144>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMySQL       "NOT NULL"
85145>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeOracle      "" // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
85146>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeDB2         "DEFAULT NOT NULL"
85147>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypePostgre     "NOT NULL"
85148>>>>>>>>>
85148>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMSSQL           "SET"
85149>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMySQL           "SET"
85150>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeOracle          "SET"
85151>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeDB2             "SET"
85152>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypePostgre         "SET"
85153>>>>>>>>>
85153>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMSSQL          "WITH"
85154>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMySQL          "WITH"
85155>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeOracle         "WITH"
85156>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeDB2            "WITH"
85157>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypePostgre        "WITH"
85158>>>>>>>>>
85158>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMSSQL    "CREATE DATABASE"
85159>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMySQL    "CREATE DATABASE"
85160>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeOracle   "CREATE DATABASE"
85161>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeDB2      "CREATE DATABASE"
85162>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypePostgre  "CREATE DATABASE"
85163>>>>>>>>>
85163>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMSSQL    "COLLATE"
85164>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMySQL    "COLLATE"
85165>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeOracle   "COLLATE"
85166>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeDB2      "COLLATE"
85167>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypePostgre  "COLLATE"
85168>>>>>>>>>
85168>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMSSQL    "CREATE VIEW"
85169>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMySQL    "CREATE VIEW"
85170>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeOracle   "CREATE VIEW"
85171>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeDB2      "CREATE VIEW"
85172>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypePostgre  "CREATE VIEW"
85173>>>>>>>>>
85173>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMSSQL      "DROP VIEW"
85174>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMySQL      "DROP VIEW"
85175>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeOracle     "DROP VIEW"
85176>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeDB2        "DROP VIEW"
85177>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypePostgre    "DROP VIEW"
85178>>>>>>>>>
85178>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMSSQL   "CREATE TABLE"
85179>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMySQL   "CREATE TABLE"
85180>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeOracle  "CREATE TABLE"
85181>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeDB2     "CREATE TABLE"
85182>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypePostgre "CREATE TABLE"
85183>>>>>>>>>
85183>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMSSQL     "DROP TABLE"
85184>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMySQL     "DROP TABLE"
85185>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeOracle    "DROP TABLE"
85186>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeDB2       "DROP TABLE"
85187>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypePostgre   "DROP TABLE"
85188>>>>>>>>>
85188>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMSSQL   "EXEC sp_rename"
85189>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMySQL   "RENAME TABLE"
85190>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeOracle  "RENAME TABLE"
85191>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeDB2     "RENAME TABLE"
85192>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypePostgre "RENAME TO"
85193>>>>>>>>>
85193>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMSSQL    "DROP COLUMN"
85194>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMySQL    "DROP COLUMN"
85195>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeOracle   "DROP COLUMN"
85196>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeDB2      "DROP COLUMN"
85197>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypePostgre  "DROP COLUMN"
85198>>>>>>>>>
85198>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMSSQL        "COLUMN"
85199>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMySQL        "COLUMN"
85200>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeOracle       "COLUMN"
85201>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeDB2          "COLUMN"
85202>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypePostgre      "COLUMN"
85203>>>>>>>>>
85203>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMSSQL   "ALTER COLUMN"
85204>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMySQL   "MODIFY"
85205>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeOracle  "MODIFY"
85206>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeDB2     "ALTER COLUMN"
85207>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypePostgre "ALTER COLUMN"
85208>>>>>>>>>
85208>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMSSQL   "EXEC sp_RENAME"
85209>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMySQL   "CHANGE"
85210>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeOracle  "RENAME COLUMN"
85211>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeDB2     "RENAME COLUMN"
85212>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypePostgre "RENAME COLUMN"
85213>>>>>>>>>
85213>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMSSQL        "SELECT"
85214>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMySQL        "SELECT"
85215>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeOracle       "SELECT"
85216>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeDB2          "SELECT"
85217>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypePostgre      "SELECT"
85218>>>>>>>>>
85218>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMSSQL         "WHERE"
85219>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMySQL         "WHERE"
85220>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeOracle        "WHERE"
85221>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeDB2           "WHERE"
85222>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypePostgre       "WHERE"
85223>>>>>>>>>
85223>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMSSQL          "FROM"
85224>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMySQL          "FROM"
85225>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeOracle         "FROM"
85226>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeDB2            "FROM"
85227>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypePostgre        "FROM"
85228>>>>>>>>>
85228>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMSSQL    "INFORMATION_SCHEMA.COLUMNS"
85229>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMySQL    "INFORMATION_SCHEMA.COLUMNS"
85230>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeOracle   "INFORMATION_SCHEMA.COLUMNS"
85231>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeDB2      "INFORMATION_SCHEMA.COLUMNS"
85232>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypePostgre  "INFORMATION_SCHEMA.COLUMNS"
85233>>>>>>>>>
85233>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMSSQL    "TABLE_NAME"
85234>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMySQL    "TABLE_NAME"
85235>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeOracle   "TABLE_NAME"
85236>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeDB2      "TABLE_NAME"
85237>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypePostgre  "TABLE_NAME"
85238>>>>>>>>>
85238>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMSSQL         "TABLE"
85239>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMySQL         "TABLE"
85240>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeOracle        "TABLE"
85241>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeDB2           "TABLE"
85242>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypePostgre       "TABLE"
85243>>>>>>>>>
85243>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMSSQL           "SYS"
85244>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMySQL           "SYS"
85245>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeOracle          "SYS"
85246>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeDB2             "SYS"
85247>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypePostgre         "SYS"
85248>>>>>>>>>
85248>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMSSQL       "SP_HELP"
85249>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMySQL       "SP_HELP"
85250>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeOracle      "SP_HELP"
85251>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeDB2         "SP_HELP"
85252>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypePostgre     "SP_HELP"
85253>>>>>>>>>
85253>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMSSQL      "SET NOCOUNT ON"
85254>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMySQL      "SET NOCOUNT ON"
85255>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeOracle     "SET NOCOUNT ON"
85256>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeDB2        "SET NOCOUNT ON"
85257>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypePostgre    "SET NOCOUNT ON"
85258>>>>>>>>>
85258>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMSSQL            "TO"
85259>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMySQL            "TO"
85260>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeOracle           "TO"
85261>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeDB2              "TO"
85262>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypePostgre          "TO"
85263>>>>>>>>>
85263>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMSSQL            "GO"
85264>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMySQL            "GO"
85265>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeOracle           "GO"
85266>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeDB2              "GO"
85267>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypePostgre          "GO"
85268>>>>>>>>>
85268>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMSSQL           "USE"
85269>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMySQL           "USE"
85270>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeOracle          "USE"
85271>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeDB2             "USE"
85272>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypePostgre         "USE"
85273>>>>>>>>>
85273>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMSSQL           "dbo"
85274>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMySQL           "dbo"
85275>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeOracle          "dbo"
85276>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeDB2             "dbo"
85277>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypePostgre         "dbo"
85278>>>>>>>>>
85278>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMSSQL        "MASTER"
85279>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMySQL        "MASTER"
85280>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeOracle       "MASTER"
85281>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeDB2          "MASTER"
85282>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypePostgre      "MASTER"
85283>>>>>>>>>
85283>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMSSQL          "NAME"
85284>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMySQL          "NAME"
85285>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeOracle         "NAME"
85286>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeDB2            "NAME"
85287>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypePostgre        "NAME"
85288>>>>>>>>>
85288>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMSSQL     "DATABASES"
85289>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMySQL     "DATABASES"
85290>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeOracle    "DATABASES"
85291>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeDB2       "DATABASES"
85292>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypePostgre   "DATABASES"
85293>>>>>>>>>
85293>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMSSQL    "SYS.INDEXES"
85294>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMySQL    "SYS.INDEXES"
85295>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeOracle   "SYS.INDEXES"
85296>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeDB2      "SYS.INDEXES"
85297>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypePostgre  "SYS.INDEXES"
85298>>>>>>>>>
85298>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMSSQL      "OBJECT_ID"
85299>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMySQL      "OBJECT_ID"
85300>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeOracle     "OBJECT_ID"
85301>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeDB2        "OBJECT_ID"
85302>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypePostgre    "OBJECT_ID"
85303>>>>>>>>>
85303>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMSSQL            "ID"
85304>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMySQL            "ID"
85305>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeOracle           "ID"
85306>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeDB2              "ID"
85307>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypePostgre          "ID"
85308>>>>>>>>>
85308>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMSSQL           "AND"
85309>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMySQL           "AND"
85310>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeOracle          "AND"
85311>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeDB2             "AND"
85312>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypePostgre         "AND"
85313>>>>>>>>>
85313>>>>>>>>>        // In case we didn't put the above in order (and we don't need to); we sort the struct array.
85313>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
85314>>>>>>>>>        Move (SortArray(SQLKeywordArray, Self, (RefFunc(CompareSortSQLKeyWords)))) to SQLKeywordArraySorted
85315>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArraySorted
85316>>>>>>>>>
85316>>>>>>>>>    End_Procedure
85317>>>>>>>>>
85317>>>>>>>>>End_Class
85318>>>>>>>
85318>>>>>>>
85318>>>>>>>
85318>>>>>>>
85318>>>>>>>
85318>>>>>>>
85318>>>>>>>
85318>>>>>>>// SQLConnection.ini constants:
85318>>>>>>>    Define CS_SQLConnectionIDText       for "DFConnectionId"
85318>>>>>>>Define CS_SQLIniFileName                for "SQLConnections.ini"
85318>>>>>>>Define CS_SQLDF19IniFileName            for "DFConnId.ini"
85318>>>>>>>Define CS_SQLIniConnectionSection       for "SQL Connections" // Obsolete!
85318>>>>>>>Define CS_SQLIniSectionName             for "Connection"
85318>>>>>>>
85318>>>>>>>// DF 19 ini-file settings:
85318>>>>>>>Define CS_SQLIniConnectionIdKeyword     for "Id"
85318>>>>>>>Define CS_SQLIniDriverKeyword           for "Driver"
85318>>>>>>>Define CS_SQLIniConnectionKeyWord       for "Connection"
85318>>>>>>>Define CS_SQLIniUIDKeyword              for "UID"
85318>>>>>>>Define CS_SQLIniPWDKeyword              for "PWD"
85318>>>>>>>Define CS_SQLIniDFPWDKeyword            for "DFPWD"
85318>>>>>>>Define CS_SQLIniServerKeyword           for "SERVER"
85318>>>>>>>Define CS_SQLIniDSNKeyword              for "DSN"
85318>>>>>>>Define CS_SQLIniDatabaseKeyword         for "DATABASE"
85318>>>>>>>Define CS_SQLIniTrustedKeyword          for "Trusted_Connection"
85318>>>>>>>
85318>>>>>>>// Database Update Framework extended settings:
85318>>>>>>>Define CS_SQLIniDbTypeKeyword           for "DbType"
85318>>>>>>>Define CS_SQLIniSchemaKeyword           for "Schema"
85318>>>>>>>Define CS_SQLIniBaseTableSpaceKeyword   for "Base Table Space"
85318>>>>>>>Define CS_SQLIniLongTableSpaceKeyword   for "Long Table Space"
85318>>>>>>>Define CS_SQLIniIndexTableSpaceKeyword  for "Index Table Space"
85318>>>>>>>Define CS_SQLIniSilentLoginKeyword      for "Silent Login"
85318>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"      // For compatability with DF19.
85318>>>>>>>
85318>>>>>>>Define CS_SQLIniConnectionPWD           for "PWD"
85318>>>>>>>Define CS_SQLIniConnectionYes           for "Yes"
85318>>>>>>>Define CS_SQLIniConnectionNo            for "No"
85318>>>>>>>
85318>>>>>>>Struct tSQLConnection
85318>>>>>>>    Boolean bEnabled                // 1. There can only be one active/enabled connection at a time.
85318>>>>>>>    String sConnectionID            // 2. The name of the connection ID.
85318>>>>>>>    Integer iDbType                 // 3. Database type; "MS-SQL Server", "DB2", "Oracle", "MySQL", "PostgreSQL"
85318>>>>>>>    String sDriverID                // 4. Name of the driver. E.g. "MSSQLDRV", "DB2_DRV" or "ODBC_DRV".
85318>>>>>>>    String sServer                  // 5. SQL Server/DSN/ODBC source name. (In DF19 this is the "sString" member of the tConnection struct.)
85318>>>>>>>    String sDatabase                // 6. SQL Database
85318>>>>>>>    String sConnectionString        // 7. Full connection string as is needed by e.g. the login command.
85318>>>>>>>    Boolean bTrusted                // 8. Trusted connection (then is UID & PWD not used)
85318>>>>>>>    String sUserID                  // 9. User ID
85318>>>>>>>    String sPassword                // 10. Password
85318>>>>>>>    String sSchema                  // 11. DB2 (and perhaps ODBC specific)
85318>>>>>>>    String sBaseTableSpace          // 12. DB2 specific
85318>>>>>>>    String sLongTableSpace          // 13. DB2 specific
85318>>>>>>>    String sIndexTableSpace         // 14. DB2 specific
85318>>>>>>>    Boolean bSilentLogin            // 15. True=Silent login. (i.e. don't show Database login dialog if database login to fails). Same as driver "Options" parameter.
85318>>>>>>>    Boolean bError                  // 16. Set to true on error.
85318>>>>>>>    Boolean bDAWConnection          // 17. True if a DFConnId.ini file (from DAW) has been used instead of a DUF SQLConnections.ini file.
85318>>>>>>>//    Boolean bDisabled               // 17. For compatability with DF19 Managed Connections only. Not used by DUF (Database Update Framework).
85318>>>>>>>//    Integer iDriverIndex            // 18. For compatability with DF19 Managed Connections only. Not used by DUF (Database Update Framework).
85318>>>>>>>End_Struct
85318>>>>>Use cDbUpdateDatabaseDriver.pkg
Including file: cDbUpdateDatabaseDriver.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateDatabaseDriver.pkg)
85318>>>>>>>Use cSQLConnectionIniFile.inc
85318>>>>>>>
85318>>>>>>>Class cDbUpdateGenericDatabaseDriver is a cObject
85319>>>>>>>    Procedure Construct_Object
85321>>>>>>>        Forward Send Construct_Object
85323>>>>>>>        Property String psDriverID DATAFLEX_ID
85324>>>>>>>    End_Procedure
85325>>>>>>>
85325>>>>>>>    Function ServerKeyword Returns String
85327>>>>>>>        Function_Return CS_SQLIniDSNKeyword
85328>>>>>>>    End_Function
85329>>>>>>>
85329>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
85331>>>>>>>        String sConnect
85331>>>>>>>
85331>>>>>>>        Move (sConnect * ServerKeyword(Self) + "=" + sServer) to sConnect
85332>>>>>>>        If (sDatabase <> "") Begin
85334>>>>>>>            Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
85335>>>>>>>        End
85335>>>>>>>>
85335>>>>>>>        If (bTrusted = True) Begin
85337>>>>>>>            Move (sConnect * ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
85338>>>>>>>        End
85338>>>>>>>>
85338>>>>>>>        Else Begin
85339>>>>>>>            Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
85340>>>>>>>        End
85340>>>>>>>>
85340>>>>>>>        Function_Return sConnect
85341>>>>>>>    End_Function
85342>>>>>>>
85342>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
85344>>>>>>>        Boolean bLoginSuccessful
85344>>>>>>>        String sDriverID
85344>>>>>>>
85344>>>>>>>        Get psDriverID to sDriverID
85345>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
85347>>>>>>>            Function_Return True
85348>>>>>>>        End
85348>>>>>>>>
85348>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
85349>>>>>>>        If (bTrusted = False) Begin
85351>>>>>>>            Login sServer sUserId sPassword sDriverID
85353>>>>>>>        End
85353>>>>>>>>
85353>>>>>>>        Else Begin
85354>>>>>>>            Login sConnectionString "" "" sDriverID
85356>>>>>>>        End
85356>>>>>>>>
85356>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
85357>>>>>>>        Function_Return bLoginSuccessful
85358>>>>>>>    End_Function
85359>>>>>>>End_Class
85360>>>>>>>
85360>>>>>>>Class cDbUpdateMSSQLDriver is a cDbUpdateGenericDatabaseDriver
85361>>>>>>>    Function ServerKeyword Returns String
85363>>>>>>>        Function_Return CS_SQLIniServerKeyword
85364>>>>>>>    End_Function
85365>>>>>>>End_Class
85366>>>>>>>
85366>>>>>>>Class cDbUpdateODBCDriver is a cDbUpdateGenericDatabaseDriver
85367>>>>>>>End_Class
85368>>>>>>>
85368>>>>>>>Class cDbUpdateDB2Driver is a cDbUpdateGenericDatabaseDriver
85369>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
85371>>>>>>>        Boolean bLoginSuccessful
85371>>>>>>>        String sDriverID
85371>>>>>>>
85371>>>>>>>        Move False to Err
85372>>>>>>>        Get psDriverID to sDriverID
85373>>>>>>>        If (not(Uppercase(sServer) contains "DSN")) Begin
85375>>>>>>>            Move ("DSN=" + sServer) to sServer
85376>>>>>>>        End
85376>>>>>>>>
85376>>>>>>>        Login sServer sUserId sPassword sDriverID
85378>>>>>>>
85378>>>>>>>        Move (not(Err)) to bLoginSuccessful
85379>>>>>>>        Function_Return bLoginSuccessful
85380>>>>>>>    End_Function
85381>>>>>>>End_Class
85382>>>>>>>
85382>>>>>>>Class cDbUpdateDataFlexDriver is a cDbUpdateGenericDatabaseDriver
85383>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
85385>>>>>>>        Function_Return ""
85386>>>>>>>    End_Function
85387>>>>>>>End_Class
85388>>>>>>>
85388>>>>>>>Class cDbUpdateSQLFLEXDriver is a cDbUpdateGenericDatabaseDriver
85389>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
85391>>>>>>>        Boolean bLoginSuccessful
85391>>>>>>>        String sDriverID
85391>>>>>>>
85391>>>>>>>        Get psDriverID to sDriverID
85392>>>>>>>        //For the Mertech driver, using the Err indicator is the sanctioned way
85392>>>>>>>        Move False to Err
85393>>>>>>>        If (bTrusted = False) Begin
85395>>>>>>>            Login sServer sUserId sPassword sDriverID
85397>>>>>>>        End
85397>>>>>>>>
85397>>>>>>>        Else Begin
85398>>>>>>>            Login sServer "" "" sDriverID
85400>>>>>>>        End
85400>>>>>>>>
85400>>>>>>>        Move (not(Err)) to bLoginSuccessful
85401>>>>>>>
85401>>>>>>>        Function_Return bLoginSuccessful
85402>>>>>>>    End_Function
85403>>>>>>>End_Class
85404>>>>>>>
85404>>>>>>>Class cDbUpdateORAFLEXDriver is a cDbUpdateGenericDatabaseDriver
85405>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
85407>>>>>>>        Boolean bLoginSuccessful
85407>>>>>>>        String sDriverID
85407>>>>>>>        Integer iPos
85407>>>>>>>
85407>>>>>>>        Get psDriverID to sDriverID
85408>>>>>>>        Move (Pos("/", sServer)) to iPos
85409>>>>>>>        If (iPos = 0) Begin
85411>>>>>>>            If (sDatabase <> "") Begin
85413>>>>>>>                Move (sServer + "/" + sDatabase) to sServer
85414>>>>>>>            End
85414>>>>>>>>
85414>>>>>>>        End
85414>>>>>>>>
85414>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
85414>>>>>>>        Move False to Err
85415>>>>>>>        // For Oracle I don't believe "Trusted" doesn't exist.
85415>>>>>>>        Login sServer sUserId sPassword sDriverID
85417>>>>>>>
85417>>>>>>>        Move (not(Err)) to bLoginSuccessful
85418>>>>>>>        Function_Return bLoginSuccessful
85419>>>>>>>    End_Function
85420>>>>>>>End_Class
85421>>>>>>>
85421>>>>>>>Class cDbUpdateMDSMySQLDriver is a cDbUpdateGenericDatabaseDriver
85422>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
85424>>>>>>>        Boolean bLoginSuccessful
85424>>>>>>>        String sDriverID
85424>>>>>>>
85424>>>>>>>        Get psDriverID to sDriverID
85425>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
85425>>>>>>>        Move False to Err
85426>>>>>>>        If (bTrusted = False) Begin
85428>>>>>>>            Login sServer sUserId sPassword sDriverID
85430>>>>>>>        End
85430>>>>>>>>
85430>>>>>>>        Else Begin
85431>>>>>>>            Login sServer "" "" sDriverID
85433>>>>>>>        End
85433>>>>>>>>
85433>>>>>>>        Move (not(Err)) to bLoginSuccessful
85434>>>>>>>        Function_Return bLoginSuccessful
85435>>>>>>>    End_Function
85436>>>>>>>End_Class
85437>>>>>>>
85437>>>>>>>Class cDbUpdateMDSPgSQLDriver is a cDbUpdateGenericDatabaseDriver
85438>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
85440>>>>>>>        Boolean bLoginSuccessful
85440>>>>>>>        String sDriverID
85440>>>>>>>
85440>>>>>>>        Get psDriverID to sDriverID
85441>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
85441>>>>>>>        Move False to Err
85442>>>>>>>        If (bTrusted = False) Begin
85444>>>>>>>            Login sServer sUserId sPassword sDriverID
85446>>>>>>>        End
85446>>>>>>>>
85446>>>>>>>        Else Begin
85447>>>>>>>            Login sServer "" "" sDriverID
85449>>>>>>>        End
85449>>>>>>>>
85449>>>>>>>        Move (not(Err)) to bLoginSuccessful
85450>>>>>>>        Function_Return bLoginSuccessful
85451>>>>>>>    End_Function
85452>>>>>>>End_Class
85453>>>>>>>
85453>>>>>>>Class cDbUpdateDatabaseDriver is a cObject
85454>>>>>>>    Procedure Construct_Object
85456>>>>>>>        Forward Send Construct_Object
85458>>>>>>>        Property String psDriverID DATAFLEX_ID
85459>>>>>>>        Property Handle phoDriverSpecificObject
85460>>>>>>>    End_Procedure
85461>>>>>>>
85461>>>>>>>    Function CreateDriver Returns Handle
85463>>>>>>>        String sDriverID
85463>>>>>>>        Handle hoDriver hcDriverClass
85463>>>>>>>
85463>>>>>>>        Get psDriverID to sDriverID
85464>>>>>>>        Case Begin
85464>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
85466>>>>>>>                Move (RefClass(cDbUpdateMSSQLDriver))    to hcDriverClass
85467>>>>>>>                Case Break
85468>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
85471>>>>>>>                Move (RefClass(cDbUpdateODBCDriver))     to hcDriverClass
85472>>>>>>>                Case Break
85473>>>>>>>            Case (sDriverID = DB2_DRV_ID)
85476>>>>>>>                Move (RefClass(cDbUpdateDB2Driver))      to hcDriverClass
85477>>>>>>>                Case Break
85478>>>>>>>            Case (sDriverID = SQLFLEX)
85481>>>>>>>                Move (RefClass(cDbUpdateSQLFLEXDriver))  to hcDriverClass
85482>>>>>>>                Case Break
85483>>>>>>>            Case (sDriverID = ORAFLEX)
85486>>>>>>>                Move (RefClass(cDbUpdateORAFLEXDriver))  to hcDriverClass
85487>>>>>>>                Case Break
85488>>>>>>>            Case (sDriverID = MDSPgSQL)
85491>>>>>>>                Move (RefClass(cDbUpdateMDSPgSQLDriver)) to hcDriverClass
85492>>>>>>>                Case Break
85493>>>>>>>            Case (sDriverID = MDSMySQL)
85496>>>>>>>                Move (RefClass(cDbUpdateMDSMySQLDriver)) to hcDriverClass
85497>>>>>>>                Case Break
85498>>>>>>>            // DATAFLEX_ID = Default driver
85498>>>>>>>            Case Else
85498>>>>>>>                Move (RefClass(cDbUpdateDataFlexDriver)) to hcDriverClass
85499>>>>>>>                Move DATAFLEX_ID to sDriverID
85500>>>>>>>        Case End
85500>>>>>>>
85500>>>>>>>        Get Create hcDriverClass to hoDriver
85501>>>>>>>        Set psDriverID of hoDriver to sDriverID
85502>>>>>>>        Set phoDriverSpecificObject to hoDriver
85503>>>>>>>
85503>>>>>>>        Function_Return hoDriver
85504>>>>>>>    End_Procedure
85505>>>>>>>
85505>>>>>>>    Procedure DestroyDriver
85507>>>>>>>        If (phoDriverSpecificObject(Self)) Begin
85509>>>>>>>            Send Destroy of (phoDriverSpecificObject(Self))
85510>>>>>>>        End
85510>>>>>>>>
85510>>>>>>>    End_Procedure
85511>>>>>>>
85511>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
85513>>>>>>>        String sConnect
85513>>>>>>>        Handle hoDriver
85513>>>>>>>
85513>>>>>>>        Get CreateDriver to hoDriver
85514>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
85515>>>>>>>        Send DestroyDriver
85516>>>>>>>        Function_Return sConnect
85517>>>>>>>    End_Function
85518>>>>>>>
85518>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
85520>>>>>>>        Boolean bLoginSuccessful
85520>>>>>>>        Handle hoDriver
85520>>>>>>>
85520>>>>>>>        Get CreateDriver to hoDriver
85521>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
85522>>>>>>>        Send DestroyDriver
85523>>>>>>>        Function_Return bLoginSuccessful
85524>>>>>>>    End_Function
85525>>>>>>>
85525>>>>>>>End_Class
85526>>>>>
85526>>>>>Class cSQLConnectionIniFile is a cIniFile
85527>>>>>    Procedure Construct_Object
85529>>>>>        Forward Send Construct_Object
85531>>>>>
85531>>>>>        Property String Private_psIniFilePath
85532>>>>>        Property String Private_psIniFileName CS_SQLIniFileName
85533>>>>>        Property String psIniSectionName (CS_SQLIniSectionName + "1")
85534>>>>>
85534>>>>>//        { Visibility=Private }
85534>>>>>        Property Boolean pbDFConnId False
85535>>>>>
85535>>>>>        // We use Base64 coding instead of the cCryptographer class because the
85535>>>>>        // password will get scrambled while writing/reading to/from the ini-file.
85535>>>>>//        { Visibility=Public }
85535>>>>>//        // *** You really want to change this value! ***
85535>>>>>//        Property String psHashString "zx!2139(LI0+?ips7433"
85535>>>>>
85535>>>>>    End_Procedure
85536>>>>>
85536>>>>>    Procedure End_Construct_Object
85538>>>>>        Forward Send End_Construct_Object
85540>>>>>    End_Procedure
85541>>>>>
85541>>>>>    Procedure Set psIniFilePath String sPath
85543>>>>>        String sIniFile
85543>>>>>        Get vFolderFormat sPath to sPath
85544>>>>>        Set private_psIniFilePath to sPath
85545>>>>>        Get psIniFileName to sIniFile
85546>>>>>        Set psFileName to (sPath + sIniFile)
85547>>>>>    End_Procedure
85548>>>>>
85548>>>>>    Function psIniFilePath Returns String
85550>>>>>        Function_Return (private_psIniFilePath(Self))
85551>>>>>    End_Function
85552>>>>>
85552>>>>>    Procedure Set psIniFileName String sFileName
85554>>>>>        String sPath
85554>>>>>        Get psIniFilePath to sPath
85555>>>>>        Set psFileName to (sPath + sFileName)
85556>>>>>        Set private_psIniFileName to sFileName
85557>>>>>    End_Procedure
85558>>>>>
85558>>>>>    Function psIniFileName Returns String
85560>>>>>        Function_Return (private_psIniFileName(Self))
85561>>>>>    End_Function
85562>>>>>
85562>>>>>    // *** Generalized messages to Get & Set values of the ini file.
85562>>>>>    // Sets a value in the program's ini file (write)
85562>>>>>    // Pass a section name, the value name parameter and the value itself to be written.
85562>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
85564>>>>>        String sIniFile sPath
85564>>>>>
85564>>>>>        Get psIniFilePath to sPath
85565>>>>>        Get psIniFileName to sIniFile
85566>>>>>        Move (sPath + sIniFile) to sIniFile
85567>>>>>        Set psFileName to sIniFile
85568>>>>>        Send WriteString sSection sValueName sValue
85569>>>>>    End_Procedure
85570>>>>>
85570>>>>>    // Get a value from program's ini-file (read)
85570>>>>>    // Pass a section name and the name of the value parameter & a default value.
85570>>>>>    // Returns the value
85570>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
85572>>>>>        String sValue sIniFile sPath
85572>>>>>
85572>>>>>        Get psIniFilePath to sPath
85573>>>>>        Get psIniFileName to sIniFile
85574>>>>>        Move (sPath + sIniFile) to sIniFile
85575>>>>>        Set psFileName to sIniFile
85576>>>>>        Get ReadString sSection sValueName sDefaultValue to sValue
85577>>>>>
85577>>>>>        Function_Return sValue
85578>>>>>    End_Function
85579>>>>>
85579>>>>>    // Sort function that first sorts on bEnabled & then on the connection string.
85579>>>>>    Function SortActiveFirst tSQLConnection SQLConnectionRow1 tSQLConnection SQLConnectionRow2 Returns Integer
85581>>>>>        If (SQLConnectionRow1.bEnabled > SQLConnectionRow2.bEnabled) ;            Function_Return (LT)
85584>>>>>        If (SQLConnectionRow1.bEnabled < SQLConnectionRow2.bEnabled) ;            Function_Return (GT)
85587>>>>>
85587>>>>>        If (SQLConnectionRow1.sConnectionID < SQLConnectionRow2.sConnectionID) ;            Function_Return (LT)
85590>>>>>        If (SQLConnectionRow1.sConnectionID > SQLConnectionRow2.sConnectionID) ;            Function_Return (GT)
85593>>>>>
85593>>>>>        If (SQLConnectionRow1.iDbType < SQLConnectionRow2.iDbType) ;            Function_Return (LT)
85596>>>>>        If (SQLConnectionRow1.iDbType > SQLConnectionRow2.iDbType) ;            Function_Return (GT)
85599>>>>>
85599>>>>>        If (SQLConnectionRow1.sServer < SQLConnectionRow2.sServer) ;            Function_Return (LT)
85602>>>>>        If (SQLConnectionRow1.sServer > SQLConnectionRow2.sServer) ;            Function_Return (GT)
85605>>>>>
85605>>>>>        If (SQLConnectionRow1.sDatabase < SQLConnectionRow2.sDatabase) ;            Function_Return (LT)
85608>>>>>        If (SQLConnectionRow1.sDatabase > SQLConnectionRow2.sDatabase) ;            Function_Return (GT)
85611>>>>>
85611>>>>>        If (SQLConnectionRow1.sDriverID < SQLConnectionRow2.sDriverID) ;            Function_Return (LT)
85614>>>>>        If (SQLConnectionRow1.sDriverID > SQLConnectionRow2.sDriverID) ;            Function_Return (GT)
85617>>>>>
85617>>>>>        If (SQLConnectionRow1.sConnectionString < SQLConnectionRow2.sConnectionString) ;            Function_Return (LT)
85620>>>>>        If (SQLConnectionRow1.sConnectionString > SQLConnectionRow2.sConnectionString) ;            Function_Return (GT)
85623>>>>>
85623>>>>>        Function_Return (EQ)
85624>>>>>    End_Function
85625>>>>>
85625>>>>>    Function SQLIniFileNumberOfConnections Returns Integer
85627>>>>>        Handle hoSections
85627>>>>>        Integer iItems
85627>>>>>
85627>>>>>        Send ReadSections hoSections
85628>>>>>        Move (Item_Count(hoSections)) to iItems
85629>>>>>        Function_Return iItems
85630>>>>>    End_Function
85631>>>>>
85631>>>>>    // The normal connection string looks something like this;
85631>>>>>    // "SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
85631>>>>>    // ...but the full connection string looks like this;
85631>>>>>    // "DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
85631>>>>>//    Function SQLIniFileAddConnection String sFullConnectionString Returns Boolean
85631>>>>>//        String sSection
85631>>>>>//        Integer iCount
85631>>>>>//
85631>>>>>//        Move False to Err
85631>>>>>//        Get psIniSectionName to sSection
85631>>>>>//        Get SQLIniFileNumberOfConnections to iCount
85631>>>>>//        Increment iCount
85631>>>>>//        Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to sFullConnectionString
85631>>>>>//
85631>>>>>//        Function_Return (Err = False)
85631>>>>>//    End_Function
85631>>>>>
85631>>>>>    Function SQLIniFileDeleteAllConnections Returns Boolean
85633>>>>>        Integer iCount
85633>>>>>        Boolean bExists
85633>>>>>        String sSection
85633>>>>>
85633>>>>>        Move False to Err
85634>>>>>        Move 1 to iCount
85635>>>>>        Get psIniSectionName to sSection
85636>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
85637>>>>>        While (bExists = True)
85641>>>>>            Send DeleteSection (CS_SQLIniSectionName + String(iCount))
85642>>>>>            Increment iCount
85643>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
85644>>>>>        Loop
85645>>>>>>
85645>>>>>        Function_Return (Err = False)
85646>>>>>    End_Function
85647>>>>>
85647>>>>>    Function SQLIniFileDeleteConnection Integer iItem Returns Boolean
85649>>>>>        Integer iCount
85649>>>>>        String sSection
85649>>>>>        Boolean bExists
85649>>>>>
85649>>>>>        Move False to Err
85650>>>>>        Move 1 to iCount
85651>>>>>        Get psIniSectionName to sSection
85652>>>>>        Get KeyExists sSection CS_SQLIniConnectionIdKeyword to bExists
85653>>>>>        While (bExists = True)
85657>>>>>            If (iCount = iItem) Begin
85659>>>>>                Send DeleteSection sSection
85660>>>>>//                Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to ""
85660>>>>>                Move 9999 to iCount // Just some ridiculously high number to get out of the loop as we're done.
85661>>>>>            End
85661>>>>>>
85661>>>>>            Increment iCount
85662>>>>>            Get KeyExists sSection (CS_SQLIniSectionName + String(iCount)) to bExists
85663>>>>>        Loop
85664>>>>>>
85664>>>>>
85664>>>>>        Function_Return (Err = False)
85665>>>>>    End_Function
85666>>>>>
85666>>>>>    // Returns all connection details for the passed Connection ID as a tSQLConnection
85666>>>>>    // If it fails the returned struct member SQLConnection.bError = True.
85666>>>>>    Function SQLIniFileConnectionID String sConnectionID Returns tSQLConnection
85668>>>>>        tSQLConnection[] SQLConnectionsArray
85668>>>>>        tSQLConnection[] SQLConnectionsArray
85669>>>>>        tSQLConnection   SQLConnection
85669>>>>>        tSQLConnection   SQLConnection
85669>>>>>        Integer iIndex
85669>>>>>
85669>>>>>        Get SQLIniFileConnectionIDIndex sConnectionID to iIndex
85670>>>>>        If (iIndex = -1) Begin
85672>>>>>            Move True to SQLConnection.bError
85673>>>>>            Function_Return SQLConnection
85674>>>>>        End
85674>>>>>>
85674>>>>>
85674>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
85675>>>>>        Move SQLConnectionsArray[iIndex -1] to SQLConnection
85676>>>>>
85676>>>>>        Function_Return SQLConnection
85677>>>>>    End_Function
85678>>>>>
85678>>>>>    // Returns -1 if the passed connection ID was not found, else the item number.
85678>>>>>    Function SQLIniFileConnectionIDIndex String sConnectionID Returns Integer
85680>>>>>        tSQLConnection[] SQLConnectionsArray
85680>>>>>        tSQLConnection[] SQLConnectionsArray
85681>>>>>        Integer iRetval iCount iSize
85681>>>>>        String sValue
85681>>>>>        Boolean bExists
85681>>>>>
85681>>>>>        Move -1 to iRetval
85682>>>>>
85682>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
85683>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
85684>>>>>        Decrement iSize
85685>>>>>        For iCount from 0 to iSize
85691>>>>>>
85691>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
85692>>>>>            Move (Uppercase(sValue) = Uppercase(sConnectionID)) to bExists
85693>>>>>            If (bExists) Begin
85695>>>>>                Move (iCount + 1) to iRetval // The [ConnectionX] keys are one-based (starts at 1) but the loop starts at zero.
85696>>>>>                Move iSize to iCount         // We're done!
85697>>>>>            End
85697>>>>>>
85697>>>>>        Loop
85698>>>>>>
85698>>>>>
85698>>>>>        Function_Return iRetval
85699>>>>>    End_Function
85700>>>>>
85700>>>>>    // Checks if the passed sConnectionID exists more than once in the passed struct array.
85700>>>>>    // Used to check that ConnectionID's are unique.
85700>>>>>    Function IsConnectionIDDuplicate String sConnectionID Returns Boolean
85702>>>>>        Integer iCount iSize iItems
85702>>>>>        String sValue
85702>>>>>        Boolean bExists
85702>>>>>        tSQLConnection[] SQLConnectionsArray
85702>>>>>        tSQLConnection[] SQLConnectionsArray
85703>>>>>
85703>>>>>        Move 0 to iItems
85704>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
85705>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
85706>>>>>        Decrement iSize
85707>>>>>        For iCount from 0 to iSize
85713>>>>>>
85713>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
85714>>>>>            Move (sValue = sConnectionID) to bExists
85715>>>>>            If (bExists) Begin
85717>>>>>                Increment iItems
85718>>>>>            End
85718>>>>>>
85718>>>>>        Loop
85719>>>>>>
85719>>>>>
85719>>>>>        Function_Return (iItems > 1)
85720>>>>>    End_Function
85721>>>>>
85721>>>>>    // To update the SQLConnections.ini file with a new default Connection ID.
85721>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
85723>>>>>        Boolean bOK
85723>>>>>        Integer iSize iCount
85723>>>>>        tSQLConnection[] SQLConnectionsArray
85723>>>>>        tSQLConnection[] SQLConnectionsArray
85724>>>>>        tSQLConnection SQLConnection
85724>>>>>        tSQLConnection SQLConnection
85724>>>>>        String sConnectionString
85724>>>>>
85724>>>>>        Move False to Err
85725>>>>>        Get psConnectionString to sConnectionString
85726>>>>>
85726>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
85727>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
85728>>>>>        Decrement iSize
85729>>>>>        // Set all current connection to inactive.
85729>>>>>        For iCount from 0 to iSize
85735>>>>>>
85735>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
85736>>>>>        Loop
85737>>>>>>
85737>>>>>
85737>>>>>        Get SQLIniFileConnectionID sConnectionID to SQLConnection
85738>>>>>        Move True              to SQLConnection.bEnabled
85739>>>>>        Move sConnectionString to SQLConnection.sConnectionString
85740>>>>>        Move (InsertInArray(SQLConnectionsArray, 0, SQLConnection)) to SQLConnectionsArray
85741>>>>>        Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
85742>>>>>
85742>>>>>        Function_Return (bOK = True)
85743>>>>>    End_Function
85744>>>>>
85744>>>>>    // Used for updating an existing connection with new data.
85744>>>>>    // Returns True if successful.
85744>>>>>    Function SQLIniFileUpdateConnection tSQLConnection SQLConnection Returns Boolean
85746>>>>>        Boolean bOK
85746>>>>>        Integer iItem iSize iCount
85746>>>>>        tSQLConnection[] SQLConnectionsArray
85746>>>>>        tSQLConnection[] SQLConnectionsArray
85747>>>>>
85747>>>>>        Move False to Err
85748>>>>>        Move -1 to iItem
85749>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
85750>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
85751>>>>>        Decrement iSize
85752>>>>>        // Set all current connection to inactive.
85752>>>>>        For iCount from 0 to iSize
85758>>>>>>
85758>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
85759>>>>>            If (SQLConnectionsArray[iCount].sConnectionID = SQLConnection.sConnectionID) Begin
85761>>>>>                Move iCount to iItem
85762>>>>>            End
85762>>>>>>
85762>>>>>        Loop
85763>>>>>>
85763>>>>>
85763>>>>>        If (iItem <> -1) Begin
85765>>>>>            Move True to SQLConnection.bEnabled
85766>>>>>            Move SQLConnection to SQLConnectionsArray[iItem]
85767>>>>>            Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
85768>>>>>        End
85768>>>>>>
85768>>>>>
85768>>>>>        Function_Return (bOK = True)
85769>>>>>    End_Function
85770>>>>>
85770>>>>>    Function SQLIniFileReadConnections Returns tSQLConnection[]
85772>>>>>        tSQLConnection[] SQLConnectionsArray
85772>>>>>        tSQLConnection[] SQLConnectionsArray
85773>>>>>        String sSection sValue
85773>>>>>        Integer iCount
85773>>>>>        Boolean bExists bEnabled
85773>>>>>
85773>>>>>        Get psIniSectionName to sSection
85774>>>>>        Get SectionExists sSection to bExists
85775>>>>>        If (bExists = False) Begin
85777>>>>>            Function_Return SQLConnectionsArray
85778>>>>>        End
85778>>>>>>
85778>>>>>        Get SectionExists CS_SQLIniConnectionSection to bExists
85779>>>>>        If (bExists = True) Begin
85781>>>>>            Error DFERR_PROGRAM "Sorry, the format for the SQLConnections.ini file has been changed and this file has the old format that is no longer valid and thus cannot be read. You need to re-enter your connection(s)."
85782>>>>>>
85782>>>>>        End
85782>>>>>>
85782>>>>>
85782>>>>>        Move 1 to iCount // The section name "[ConnectionXX]" starts with "1"
85783>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
85784>>>>>
85784>>>>>        While (bExists = True)
85788>>>>>            // We always put the enabled/active connection at the top
85788>>>>>            Move (iCount = 1) to bEnabled
85789>>>>>            Move bEnabled to SQLConnectionsArray[iCount].bEnabled
85790>>>>>
85790>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionIdKeyword ""        to SQLConnectionsArray[iCount].sConnectionID
85791>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDriverKeyword       ""        to SQLConnectionsArray[iCount].sDriverID
85792>>>>>
85792>>>>>            // The iDbType might be missing from the ini-file. This is e.g. the case when a DAW Managed Connection "DFConnId.ini" file is read.
85792>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDbTypeKeyword       "99"      to sValue
85793>>>>>            If (sValue = "99") Begin
85795>>>>>                Get SqlUtilDbTypeFromDriver SQLConnectionsArray[iCount].sDriverID to sValue
85796>>>>>            End
85796>>>>>>
85796>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].iDbType
85797>>>>>
85797>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionKeyWord   ""        to SQLConnectionsArray[iCount].sConnectionString
85798>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnectionsArray[iCount].sServer
85799>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
85801>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDSNKeyword +"=")   to SQLConnectionsArray[iCount].sServer
85802>>>>>            End
85802>>>>>>
85802>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnectionsArray[iCount].sDatabase
85803>>>>>
85803>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniTrustedKeyword      ""        to sValue
85804>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bTrusted
85805>>>>>
85805>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniUIDKeyword          ""        to SQLConnectionsArray[iCount].sUserID
85806>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDFPWDKeyword        ""        to sValue
85807>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
85809>>>>>                Get DecryptPassword sValue to sValue
85810>>>>>            End
85810>>>>>>
85810>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].sPassword
85811>>>>>
85811>>>>>            // Here we reconstruct the connection string to be complete with all params;
85811>>>>>            Get ConstructConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                          SQLConnectionsArray[iCount].bTrusted SQLConnectionsArray[iCount].sUserID SQLConnectionsArray[iCount].sPassword ;                                          to SQLConnectionsArray[iCount].sConnectionString
85812>>>>>
85812>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSchemaKeyword          ""     to SQLConnectionsArray[iCount].sSchema
85813>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniBaseTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sBaseTableSpace
85814>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniLongTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sLongTableSpace
85815>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniIndexTableSpaceKeyword ""     to SQLConnectionsArray[iCount].sIndexTableSpace
85816>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSilentLoginKeyword     ""     to SQLConnectionsArray[iCount].bSilentLogin
85817>>>>>//            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDisabledKeyword        ""     to SQLConnectionsArray[iCount].bDisabled
85817>>>>>
85817>>>>>            Increment iCount
85818>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
85819>>>>>        Loop
85820>>>>>>
85820>>>>>
85820>>>>>        // Lastly, we remove the very first array item as it is empty (we started at 1 because that is the first [Connection#])
85820>>>>>        If (SizeOfArray(SQLConnectionsArray) > 0) Begin
85822>>>>>            Move (RemoveFromArray(SQLConnectionsArray, 0)) to SQLConnectionsArray
85823>>>>>        End
85823>>>>>>
85823>>>>>
85823>>>>>        Function_Return SQLConnectionsArray
85824>>>>>    End_Function
85825>>>>>
85825>>>>>    Function SQLIniFileWriteConnections tSQLConnection[] SQLConnectionsArray Returns Boolean
85827>>>>>        Integer iCount iSize
85827>>>>>        Boolean bOK
85827>>>>>        String sConnectionString sSection sValue
85827>>>>>
85827>>>>>        // First we need to _remove_ all current connections in the ini-file, we
85827>>>>>        // do that by setting their values to "".
85827>>>>>        Move 0 to iCount
85828>>>>>        Get SQLIniFileDeleteAllConnections to bOK
85829>>>>>        If (bOK = False) Begin
85831>>>>>            Function_Return False
85832>>>>>        End
85832>>>>>>
85832>>>>>
85832>>>>>        Move False to Err
85833>>>>>        Get psIniSectionName to sSection
85834>>>>>        // Sorting will make sure we have the active connection record as the first connection item in the ini-file.
85834>>>>>        Move (SortArray(SQLConnectionsArray, Self, (RefFunc(SortActiveFirst)))) to SQLConnectionsArray
85835>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
85836>>>>>        Decrement iSize
85837>>>>>
85837>>>>>        For iCount from 0 to iSize
85843>>>>>>
85843>>>>>            // DF 19 compatible settings:
85843>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionIdKeyword   to SQLConnectionsArray[iCount].sConnectionID
85844>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDriverKeyword         to SQLConnectionsArray[iCount].sDriverID
85845>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniUIDKeyword            to SQLConnectionsArray[iCount].sUserID
85846>>>>>
85846>>>>>            Move SQLConnectionsArray[iCount].sPassword to sValue
85847>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
85849>>>>>                Get EncryptPassword sValue to sValue
85850>>>>>            End
85850>>>>>>
85850>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDFPWDKeyword          to sValue
85851>>>>>
85851>>>>>            If (SQLConnectionsArray[iCount].bTrusted = True) Begin
85853>>>>>                Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniTrustedKeyword    to CS_SQLIniConnectionYes
85854>>>>>            End
85854>>>>>>
85854>>>>>
85854>>>>>            Get ConstructShortConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                            to SQLConnectionsArray[iCount].sConnectionString
85855>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionKeyWord     to SQLConnectionsArray[iCount].sConnectionString
85856>>>>>
85856>>>>>            // The Database Update Framework extended settings:
85856>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDbTypeKeyword          to SQLConnectionsArray[iCount].iDbType
85857>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSchemaKeyword          to SQLConnectionsArray[iCount].sSchema
85858>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniBaseTableSpaceKeyword  to SQLConnectionsArray[iCount].sBaseTableSpace
85859>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniLongTableSpaceKeyword  to SQLConnectionsArray[iCount].sLongTableSpace
85860>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniIndexTableSpaceKeyword to SQLConnectionsArray[iCount].sIndexTableSpace
85861>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSilentLoginKeyword     to SQLConnectionsArray[iCount].bSilentLogin
85862>>>>>        Loop
85863>>>>>>
85863>>>>>
85863>>>>>        Function_Return (bOK and Err = False)
85864>>>>>    End_Function
85865>>>>>
85865>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
85865>>>>>    //
85865>>>>>    // SQL utility function that returns a database type (string) constant
85865>>>>>    // corresponding to the passed iDbType.
85865>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
85867>>>>>        String sRetval
85867>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
85869>>>>>            Move CS_dbTypeMSSQL to sRetval
85870>>>>>        End
85870>>>>>>
85870>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
85872>>>>>            Move CS_dbTypeMySQL to sRetval
85873>>>>>        End
85873>>>>>>
85873>>>>>        If (iDbType = EN_dbTypeOracle) Begin
85875>>>>>            Move CS_dbTypeOracle to sRetval
85876>>>>>        End
85876>>>>>>
85876>>>>>        If (iDbType = EN_dbTypeDB2) Begin
85878>>>>>            Move CS_dbTypeDB2 to sRetval
85879>>>>>        End
85879>>>>>>
85879>>>>>        If (iDbType = EN_dbTypePostgre) Begin
85881>>>>>            Move CS_dbTypePostgre to sRetval
85882>>>>>        End
85882>>>>>>
85882>>>>>        Function_Return sRetval
85883>>>>>    End_Function
85884>>>>>
85884>>>>>    // SQL utility function that returns a database type constant (integer)
85884>>>>>    // corresponding to the passed sDbType string constant.
85884>>>>>    Function SqlUtilDbTypeToInteger String sDbType  Returns Integer
85886>>>>>        Integer iRetval
85886>>>>>        If (sDbType = CS_dbTypeMSSQL) Begin
85888>>>>>            Move EN_dbTypeMSSQL to iRetval
85889>>>>>        End
85889>>>>>>
85889>>>>>        If (sDbType = CS_dbTypeMySQL) Begin
85891>>>>>            Move EN_dbTypeMySQL to iRetval
85892>>>>>        End
85892>>>>>>
85892>>>>>        If (sDbType = CS_dbTypeOracle) Begin
85894>>>>>            Move EN_dbTypeOracle to iRetval
85895>>>>>        End
85895>>>>>>
85895>>>>>        If (sDbType = CS_dbTypeDB2) Begin
85897>>>>>            Move EN_dbTypeDB2 to iRetval
85898>>>>>        End
85898>>>>>>
85898>>>>>        If (sDbType = CS_dbTypePostgre) Begin
85900>>>>>            Move EN_dbTypePostgre to iRetval
85901>>>>>        End
85901>>>>>>
85901>>>>>        Function_Return iRetval
85902>>>>>    End_Function
85903>>>>>
85903>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
85903>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
85903>>>>>    // the SQL Connection program's grid.
85903>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
85905>>>>>        String sRetval
85905>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
85907>>>>>            Move "EN_dbTypeMSSQL" to sRetval
85908>>>>>        End
85908>>>>>>
85908>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
85910>>>>>            Move "EN_dbTypeMySQL" to sRetval
85911>>>>>        End
85911>>>>>>
85911>>>>>        If (iDbType = EN_dbTypeOracle) Begin
85913>>>>>            Move "EN_dbTypeOracle" to sRetval
85914>>>>>        End
85914>>>>>>
85914>>>>>        If (iDbType = EN_dbTypeDB2) Begin
85916>>>>>            Move "EN_dbTypeDB2" to sRetval
85917>>>>>        End
85917>>>>>>
85917>>>>>        If (iDbType = EN_dbTypePostgre) Begin
85919>>>>>            Move "EN_dbTypePostgre" to sRetval
85920>>>>>        End
85920>>>>>>
85920>>>>>        Function_Return sRetval
85921>>>>>    End_Function
85922>>>>>
85922>>>>>    // Pass a driver id and the function will return
85922>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
85922>>>>>    // quite work and always returns "MS SQL Server"
85922>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
85924>>>>>        Integer iRetval
85924>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
85926>>>>>            Move EN_dbTypeMSSQL to iRetval
85927>>>>>        End
85927>>>>>>
85927>>>>>        If (sDriverID = SQLFLEX) Begin
85929>>>>>            Move EN_dbTypeMSSQL to iRetval
85930>>>>>        End
85930>>>>>>
85930>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
85932>>>>>            Move EN_dbTypeMSSQL to iRetval
85933>>>>>        End
85933>>>>>>
85933>>>>>        If (sDriverID = MDSMySQL) Begin
85935>>>>>            Move EN_dbTypeMySQL to iRetval
85936>>>>>        End
85936>>>>>>
85936>>>>>        If (sDriverID = ORAFLEX) Begin
85938>>>>>            Move EN_dbTypeOracle to iRetval
85939>>>>>        End
85939>>>>>>
85939>>>>>        If (sDriverID = DB2_DRV_ID) Begin
85941>>>>>            Move EN_dbTypeDB2 to iRetval
85942>>>>>        End
85942>>>>>>
85942>>>>>        If (sDriverID = MDSPgSQL) Begin
85944>>>>>            Move EN_dbTypePostgre to iRetval
85945>>>>>        End
85945>>>>>>
85945>>>>>        Function_Return iRetval
85946>>>>>    End_Function
85947>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
85947>>>>>>
85947>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
85949>>>>>>    Integer iStart iEnd
85949>>>>>>    String sRetval
85949>>>>>>
85949>>>>>>    Move (Trim(sConnect)) to sConnect
85950>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
85951>>>>>>    If (iStart = 0) Begin
85953>>>>>>        Function_Return ""
85954>>>>>>    End
85954>>>>>>>
85954>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
85955>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
85956>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
85958>>>>>>        Move (Pos(",", sRetval))          to iEnd
85959>>>>>>    End
85959>>>>>>>
85959>>>>>>    Else Begin
85960>>>>>>        Move (Pos(";", sRetval))          to iEnd
85961>>>>>>    End
85961>>>>>>>
85961>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
85963>>>>>>        Move (Pos(",", sRetval))          to iEnd
85964>>>>>>        Decrement iEnd
85965>>>>>>    End
85965>>>>>>>
85965>>>>>>    If (iEnd <> 0) Begin
85967>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
85968>>>>>>    End
85968>>>>>>>
85968>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
85969>>>>>>
85969>>>>>>    Function_Return (Trim(sRetval))
85970>>>>>>End_Function
85971>>>>>>
85971>>>>>>
85971>>>>>
85971>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
85973>>>>>        String sConnect
85973>>>>>        Handle hoDriver
85973>>>>>
85973>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
85974>>>>>        Set psDriverID of hoDriver to sDriverID
85975>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
85976>>>>>        Send Destroy   of hoDriver
85977>>>>>
85977>>>>>//        Case Begin
85977>>>>>//            Case (sDriverID = MSSQLDRV_ID)
85977>>>>>//                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
85977>>>>>//                If (sDatabase <> "") Begin
85977>>>>>//                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
85977>>>>>//                End
85977>>>>>//                If (bTrusted = True) Begin
85977>>>>>//                    Move (sConnect * ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
85977>>>>>//                End
85977>>>>>//                Else Begin
85977>>>>>//                    Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
85977>>>>>//                End
85977>>>>>//                Case Break
85977>>>>>//
85977>>>>>//            Case (sDriverID = ODBC_DRV_ID)
85977>>>>>//                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
85977>>>>>//                If (sDatabase <> "") Begin
85977>>>>>//                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
85977>>>>>//                End
85977>>>>>//                If (bTrusted = True) Begin
85977>>>>>//                    Move (sConnect * ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
85977>>>>>//                End
85977>>>>>//                Else Begin
85977>>>>>//                    Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
85977>>>>>//                End
85977>>>>>//                Case Break
85977>>>>>//
85977>>>>>//            Case (sDriverID = DB2_DRV_ID)
85977>>>>>//                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
85977>>>>>////                If (sDatabase <> "") Begin
85977>>>>>////                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
85977>>>>>////                End
85977>>>>>////                If (bTrusted = True) Begin
85977>>>>>////                    Move (sConnect * ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
85977>>>>>////                End
85977>>>>>////                Else Begin
85977>>>>>//                Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
85977>>>>>////                End
85977>>>>>//                Case Break
85977>>>>>//
85977>>>>>//            Case (sDriverID = SQLFLEX)
85977>>>>>//                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
85977>>>>>//                If (sDatabase <> "") Begin
85977>>>>>//                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
85977>>>>>//                End
85977>>>>>//                If (bTrusted = True) Begin
85977>>>>>//                    Move (sConnect * ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
85977>>>>>//                End
85977>>>>>//                Else Begin
85977>>>>>//                    Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
85977>>>>>//                End
85977>>>>>//                Case Break
85977>>>>>//
85977>>>>>//            Case (sDriverID = ORAFLEX)
85977>>>>>//                If (sDatabase <> "" and (not(sServer contains "/"))) Begin
85977>>>>>//                    Move (sServer + "/" + sDatabase)                  to sServer
85977>>>>>//                End
85977>>>>>//                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
85977>>>>>//                Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
85977>>>>>//                Case Break
85977>>>>>//
85977>>>>>//            Case (sDriverID = MDSPgSQL)
85977>>>>>//                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
85977>>>>>//                If (sDatabase <> "") Begin
85977>>>>>//                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
85977>>>>>//                End
85977>>>>>//                Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
85977>>>>>//                Case Break
85977>>>>>//
85977>>>>>//            Case (sDriverID = MDSMySQL)
85977>>>>>//                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
85977>>>>>//                If (sDatabase <> "") Begin
85977>>>>>//                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
85977>>>>>//                End
85977>>>>>//                Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
85977>>>>>//                Case Break
85977>>>>>//
85977>>>>>//            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
85977>>>>>//                Break
85977>>>>>//
85977>>>>>//            Case Else
85977>>>>>//                Move "" to sConnect
85977>>>>>//        Case End
85977>>>>>
85977>>>>>        Function_Return sConnect
85978>>>>>    End_Function
85979>>>>>
85979>>>>>    // Short connection string used when writing to ini-file. This is to be compatible with DF19 DFConnId.ini files that uses this short format.
85979>>>>>    Function ConstructShortConnectionString String sDriverID String sServer String sDatabase Returns String
85981>>>>>        String sConnect
85981>>>>>
85981>>>>>        Case Begin
85981>>>>>            Case (sDriverID = MSSQLDRV_ID or sDriverID = SQLFLEX)
85983>>>>>                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
85984>>>>>                If (sDatabase <> "") Begin
85986>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
85987>>>>>                End
85987>>>>>>
85987>>>>>                Case Break
85988>>>>>
85988>>>>>            Case (sDriverID = ODBC_DRV_ID)
85991>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
85992>>>>>                If (sDatabase <> "") Begin
85994>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
85995>>>>>                End
85995>>>>>>
85995>>>>>                Case Break
85996>>>>>
85996>>>>>            Case (sDriverID = DB2_DRV_ID)
85999>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
86000>>>>>                If (sDatabase <> "") Begin
86002>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
86003>>>>>                End
86003>>>>>>
86003>>>>>                Case Break
86004>>>>>
86004>>>>>            Case (sDriverID = ORAFLEX)
86007>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
86008>>>>>                If (sDatabase <> "") Begin
86010>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
86011>>>>>                End
86011>>>>>>
86011>>>>>                Case Break
86012>>>>>
86012>>>>>            Case (sDriverID = MDSPgSQL)
86015>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
86016>>>>>                If (sDatabase <> "") Begin
86018>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
86019>>>>>                End
86019>>>>>>
86019>>>>>                Case Break
86020>>>>>
86020>>>>>            Case (sDriverID = MDSMySQL)
86023>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
86024>>>>>                If (sDatabase <> "") Begin
86026>>>>>                    Move (sConnect * ";" +CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
86027>>>>>                End
86027>>>>>>
86027>>>>>                Case Break
86028>>>>>
86028>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
86031>>>>>                Break
86032>>>>>
86032>>>>>            Case Else
86032>>>>>                Move "" to sConnect
86033>>>>>        Case End
86033>>>>>
86033>>>>>        Function_Return sConnect
86034>>>>>    End_Function
86035>>>>>
86035>>>>>    // Use Base64
86035>>>>>    Function EncryptPassword String sPassword Returns String
86037>>>>>        String sRetval
86037>>>>>//        Handle hoCryptographer
86037>>>>>//
86037>>>>>//        Get psHashString to sHashString
86037>>>>>//        Get Create (RefClass(cCryptographer)) to hoCryptographer
86037>>>>>//        Set psProvider of hoCryptographer to MS_ENHANCED_PROV
86037>>>>>//        Get Encrypt of hoCryptographer sHashString sPassword to sRetval
86037>>>>>//
86037>>>>>//        Send Destroy of hoCryptographer
86037>>>>>          Get EncodeString of oBase64Functions sPassword to sRetval
86038>>>>>        Function_Return sRetval
86039>>>>>    End_Function
86040>>>>>
86040>>>>>    Function DecryptPassword String sPassword Returns String
86042>>>>>        String sRetval
86042>>>>>//        Handle hoCryptographer
86042>>>>>//
86042>>>>>//        Get psHashString to sHashString
86042>>>>>//        Get Create (RefClass(cCryptographer)) to hoCryptographer
86042>>>>>//        Set psProvider of hoCryptographer to MS_ENHANCED_PROV
86042>>>>>//        Get Decrypt of hoCryptographer sHashString sPassword to sRetval
86042>>>>>//
86042>>>>>//        Send Destroy of hoCryptographer
86042>>>>>          Get DecodeString of oBase64Functions sPassword to sRetval
86043>>>>>
86043>>>>>        Function_Return sRetval
86044>>>>>    End_Function
86045>>>>>
86045>>>>>    // Returns the full path of the Application (no trailing "\")
86045>>>>>    Function ApplicationPath Returns String
86047>>>>>        String sApplicationFileName sPath
86047>>>>>        Integer iNumChars iRetval
86047>>>>>
86047>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
86048>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
86049>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
86050>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
86051>>>>>        Move (CString(sApplicationFileName)) to sPath
86052>>>>>
86052>>>>>        Function_Return sPath
86053>>>>>    End_Function
86054>>>>>
86054>>>>>End_Class
86055>>>Use cDbUpdateDatabaseDriver.pkg
86055>>>
86055>>>// The cConnection class is the new SQL connections class for DF 19.
86055>>>// If an object of the cConnection class hasn't been instantiated we use a "dummy" class in its place.
86055>>>
86055>>>// We're making references to this object handle so we need it defined
86055>>>// here as well as for the cDbUpdateHandler class
86055>>>
86055>>>    Global_Variable Handle ghoSQLConnectionHandler
86055>>>
86055>>>Class cSQLConnectionHandler is a cObject
86056>>>
86056>>>    Procedure Construct_Object
86058>>>        Forward Send Construct_Object
86060>>>        Move Self to ghoSQLConnectionHandler
86061>>>
86061>>>        Property Handle phoSQLConnectionIniFile (Create(Self,RefClass(cSQLConnectionIniFile)))
86062>>>
86062>>>        // These properties are used by the cDbUpdateVersion and cDbUpdateFunctionLibrary classes,
86062>>>        // but put here so they can be set/get in both class objects. Those classes has "relay"
86062>>>        // methods to this class.
86062>>>        Property Boolean pbUseConnectionID True
86063>>>        Property Boolean pbToANSI          True
86064>>>        Property Boolean pbRecnum          True
86065>>>        Property Boolean pbCopyData        True
86066>>>        Property Boolean pbApiTableUpdateAuto    False
86067>>>        Property Boolean pbCompareDate_DateTime  False
86068>>>        Property Boolean pbCompareIndexAscending False
86069>>>        Property Boolean pbCompareIndexUppercase False
86070>>>
86070>>>        // Driver default value settings:
86070>>>        // Note: When the object is created the corresponding values
86070>>>        // from the driver .int files are read.
86070>>>        // Sample: Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of {driverNumber} to {StringVariable}
86070>>>        Property String psDriverDefaultValueASCII    ""
86071>>>        Property String psDriverDefaultValueBinary   ""
86072>>>        Property String psDriverDefaultValueDate     ""
86073>>>        Property String psDriverDefaultValueDateTime ""
86074>>>        Property String psDriverDefaultValueNumeric  ""
86075>>>        Property String psDriverDefaultValueText     ""
86076>>>
86076>>>        // Driver "nullability" settings:
86076>>>        // Note: When the object is created the corresponding values
86076>>>        // from the driver .int files are read.
86076>>>        // Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII of {driverNumber} to {BooleanVariable}
86076>>>        Property Boolean pbDriverDefaultNullableASCII    False
86077>>>        Property Boolean pbDriverDefaultNullableBinary   False
86078>>>        Property Boolean pbDriverDefaultNullableDate     False
86079>>>        Property Boolean pbDriverDefaultNullableDateTime False
86080>>>        Property Boolean pbDriverDefaultNullableNumeric  False
86081>>>        Property Boolean pbDriverDefaultNullableText     False
86082>>>
86082>>>        // *** This is the central point of connection data for the Database Update Framework ***
86082>>>        //     It is private because the get/set version also updates the DAW/Mertech
86082>>>        //     driver interfaces.
86082>>>        //     There are also procedure/function pairs to set/get individual data members
86082>>>        //     of the struct they are all routed throu this struct property.
86082>>>        Property tSQLConnection Private.pSQLConnection
86083>>>
86083>>>    End_Procedure
86084>>>
86084>>>    Procedure End_Construct_Object
86086>>>        Boolean bReadSettings
86086>>>        tSQLConnection SQLConnection
86086>>>        tSQLConnection SQLConnection
86086>>>
86086>>>        Forward Send End_Construct_Object
86088>>>
86088>>>        // Now is the time to read and apply SQL connection settings.
86088>>>        Get SetupSQLConnection True True to SQLConnection
86089>>>        Set Private.pSQLConnection to SQLConnection
86090>>>    End_Procedure
86091>>>
86091>>>    // *** Properties ***
86091>>>    // All connection related "properties" (get/set pairs) are really done by changing the
86091>>>    // private.pSQLConnection struct connection property. These "properties" are
86091>>>    // merely here for conveniance.
86091>>>    //
86091>>>    // The pSQLConnection get/set are here so we have a "central hub"
86091>>>    // where we update data to/from the DAW & Mertech driver interfaces and this framework.
86091>>>    // This struct property contains all the connection data.
86091>>>    //
86091>>>    Procedure Set pSQLConnection tSQLConnection SQLConnection
86093>>>        Boolean bIsDaw bOK
86093>>>
86093>>>        Set Private.pSQLConnection to SQLConnection
86094>>>
86094>>>        // When starting a program we might not have a connection id yet:
86094>>>        If (SQLConnection.sConnectionID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
86096>>>            Procedure_Return
86097>>>        End
86097>>>>
86097>>>
86097>>>        // If a DAW DFConnId.ini file was read instead of the DUF SQLConnections.ini file we should by now
86097>>>        // be logged in already and don't want to do it again.
86097>>>        If (SQLConnection.bDAWConnection = False) Begin
86099>>>            // After we have set the class property we need to tell the DAW/Mertech
86099>>>            // driver interfaces about the change & make a new login.
86099>>>            Get SQLLogin SQLConnection to bOK
86100>>>            If (bOK = False) Begin
86102>>>                Error DFERR_PROGRAM "Login error."
86103>>>>
86103>>>            End
86103>>>>
86103>>>        End
86103>>>>
86103>>>
86103>>>        // Now is the time to setup our driver default values by reading the driver .int file:
86103>>>        Send SetupDriverDefaults SQLConnection.sDriverID
86104>>>
86104>>>    End_Procedure
86105>>>
86105>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
86105>>>    // attempt to load the driver.
86105>>>    // Returns true if the passed driver is SQL based.
86105>>>    Function IsSQLDriver String sDriverID Returns Boolean
86107>>>        Boolean bOK
86107>>>
86107>>>        Get IsDAWSQLDriver sDriverID to bOK
86108>>>        If (bOK = False) Begin
86110>>>            Get IsMertechDriver sDriverID to bOK
86111>>>        End
86111>>>>
86111>>>
86111>>>        Function_Return bOK
86112>>>    End_Function
86113>>>
86113>>>    // Reads the driver .int file and sets class properties of the cDbUpdateFunctionLibrary accordingly.
86113>>>    Procedure SetupDriverDefaults String sDriverID
86115>>>        String sAttributeValue
86115>>>        Integer iDriverID
86115>>>        Boolean bNULL bSQLDriver
86115>>>
86115>>>        Get IsSQLDriver sDriverID to bSQLDriver
86116>>>        If (bSQLDriver = False) Begin
86118>>>            Procedure_Return
86119>>>        End
86119>>>>
86119>>>
86119>>>        Get DriverIndex sDriverID to iDriverID
86120>>>
86120>>>        // Driver default values for various data types:
86120>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_ASCII of iDriverID      to sAttributeValue
86123>>>        Set psDriverDefaultValueASCII                                   to sAttributeValue
86124>>>
86124>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_BINARY of iDriverID     to sAttributeValue
86127>>>        Set psDriverDefaultValueBinary                                  to sAttributeValue
86128>>>
86128>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATE of iDriverID       to sAttributeValue
86131>>>        Set psDriverDefaultValueDate                                    to sAttributeValue
86132>>>
86132>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATETIME of iDriverID   to sAttributeValue
86135>>>        Set psDriverDefaultValueDateTime                                to sAttributeValue
86136>>>
86136>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of iDriverID    to sAttributeValue
86139>>>        Set psDriverDefaultValueNumeric                                 to sAttributeValue
86140>>>
86140>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_TEXT of iDriverID       to sAttributeValue
86143>>>        Set psDriverDefaultValueText                                    to sAttributeValue
86144>>>
86144>>>        // The default setting for the "nullability" of newly created ASCII columns.
86144>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII      of iDriverID to bNULL
86147>>>        Set pbDriverDefaultNullableASCII to bNULL
86148>>>
86148>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_BINARY     of iDriverID to bNULL
86151>>>        Set pbDriverDefaultNullableBinary to bNULL
86152>>>
86152>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATE       of iDriverID to bNULL
86155>>>        Set pbDriverDefaultNullableDate to bNULL
86156>>>
86156>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATETIME   of iDriverID to bNULL
86159>>>        Set pbDriverDefaultNullableDateTime to bNULL
86160>>>
86160>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_NUMERIC    of iDriverID to bNULL
86163>>>        Set pbDriverDefaultNullableNumeric to bNULL
86164>>>
86164>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_TEXT       of iDriverID to bNULL
86167>>>        Set pbDriverDefaultNullableText to bNULL
86168>>>
86168>>>    End_Procedure
86169>>>
86169>>>    Function SQLLogin tSQLConnection SQLConnection Returns Boolean
86171>>>        Boolean bOK bIsDaw bIsMertech bTrusted
86171>>>        String sConnectionString sServer sDatabase sUserId sPassword sDriverID
86171>>>        Handle hoErrorObj hoDriver hoIniFile
86171>>>        Integer iDriverID
86171>>>
86171>>>        Move False to bOK
86172>>>
86172>>>        Get IsDAWSQLDriver SQLConnection.sDriverID to bIsDaw
86173>>>        If (bIsDaw = False) Begin
86175>>>            Get IsMertechDriver SQLConnection.sDriverID to bIsMertech
86176>>>            If (bIsMertech = False) Begin
86178>>>                Function_Return False
86179>>>            End
86179>>>>
86179>>>        End
86179>>>>
86179>>>
86179>>>        Move Error_Object_Id to hoErrorObj
86180>>>        Move Self to Error_Object_Id
86181>>>
86181>>>        Get phoSQLConnectionIniFile to hoIniFile
86182>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
86183>>>        Get DriverIndex SQLConnection.sDriverID to iDriverID
86184>>>        If (iDriverID = 0) Begin
86186>>>            Move hoErrorObj to Error_Object_Id
86187>>>            Function_Return False
86188>>>        End
86188>>>>
86188>>>
86188>>>        // There's a bug in Mertech drivers creating "an Exception error" in the debugger (probably will crash an application too.)
86188>>>        If (bIsMertech = False) Begin
86190>>>            Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to SQLConnection.bSilentLogin
86193>>>        End
86193>>>>
86193>>>
86193>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
86194>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
86195>>>        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
86196>>>        Send Destroy   of hoDriver
86197>>>        Move hoErrorObj to Error_Object_Id
86198>>>
86198>>>        Function_Return bOK
86199>>>    End_Function
86200>>>
86200>>>    Function pSQLConnection Returns tSQLConnection
86202>>>        tSQLConnection SQLConnection
86202>>>        tSQLConnection SQLConnection
86202>>>        Get Private.pSQLConnection to SQLConnection
86203>>>        Function_Return SQLConnection
86204>>>    End_Function
86205>>>
86205>>>    Procedure Set psConnectionID String sValue
86207>>>        tSQLConnection SQLConnection
86207>>>        tSQLConnection SQLConnection
86207>>>
86207>>>        Get Private.pSQLConnection to SQLConnection
86208>>>        If (SQLConnection.sConnectionID = "") Begin
86210>>>            Move sValue to SQLConnection.sConnectionID
86211>>>        End
86211>>>>
86211>>>
86211>>>        // Else we might want to change the current connection ID
86211>>>        Else If (SQLConnection.sConnectionID <> "" and SQLConnection.sConnectionID <> sValue) Begin
86214>>>            Move False to Err
86215>>>            Logout SQLConnection.sDriverID
86216>>>            // This will also make a login to the new server.
86216>>>            Get SQLIniFileConnectionID of (phoSQLConnectionIniFile(Self)) sValue to SQLConnection
86217>>>        End
86217>>>>
86217>>>        Set pSQLConnection to SQLConnection
86218>>>    End_Procedure
86219>>>
86219>>>    Function psConnectionID Returns String
86221>>>        tSQLConnection SQLConnection
86221>>>        tSQLConnection SQLConnection
86221>>>        Get Private.pSQLConnection to SQLConnection
86222>>>        Function_Return SQLConnection.sConnectionID
86223>>>    End_Procedure
86224>>>
86224>>>    // Note: If the psDriverID + other connection properties are to be changed,
86224>>>    //       the psDriverID *must* be the first property that is changed!
86224>>>    //       Otherwise errors might be raised by the driver when e.g. the format
86224>>>    //       for a connection string has the wrong format for that driver.
86224>>>    Procedure Set psDriverID String sValue
86226>>>        tSQLConnection SQLConnection
86226>>>        tSQLConnection SQLConnection
86226>>>        Get pSQLConnection to SQLConnection
86227>>>        Move sValue        to SQLConnection.sDriverID
86228>>>        Set pSQLConnection to SQLConnection
86229>>>        If (sValue <> DATAFLEX_ID) Begin
86231>>>            Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
86232>>>        End
86232>>>>
86232>>>    End_Procedure
86233>>>
86233>>>    Function psDriverID Returns String
86235>>>        tSQLConnection SQLConnection
86235>>>        tSQLConnection SQLConnection
86235>>>        Get Private.pSQLConnection to SQLConnection
86236>>>        If (SQLConnection.sDriverID = "") Begin
86238>>>            Move DATAFLEX_ID to SQLConnection.sDriverID // Default is the DataFlex driver.
86239>>>        End
86239>>>>
86239>>>        Function_Return SQLConnection.sDriverID
86240>>>    End_Function
86241>>>
86241>>>    Procedure Set psConnectionString String sValue
86243>>>        tSQLConnection SQLConnection
86243>>>        tSQLConnection SQLConnection
86243>>>        Get Private.pSQLConnection to SQLConnection
86244>>>        Move sValue        to SQLConnection.sConnectionString
86245>>>        Set pSQLConnection to SQLConnection
86246>>>    End_Procedure
86247>>>
86247>>>    Function psConnectionString Returns String
86249>>>        tSQLConnection SQLConnection
86249>>>        tSQLConnection SQLConnection
86249>>>        Get Private.pSQLConnection to SQLConnection
86250>>>        Function_Return SQLConnection.sConnectionString
86251>>>    End_Function
86252>>>
86252>>>    Procedure Set psServer String sValue
86254>>>        tSQLConnection SQLConnection
86254>>>        tSQLConnection SQLConnection
86254>>>        Get Private.pSQLConnection to SQLConnection
86255>>>        Move sValue        to SQLConnection.sServer
86256>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
86257>>>        Set pSQLConnection to SQLConnection
86258>>>    End_Procedure
86259>>>
86259>>>    Function psServer Returns String
86261>>>        tSQLConnection SQLConnection
86261>>>        tSQLConnection SQLConnection
86261>>>        Get Private.pSQLConnection to SQLConnection
86262>>>        Function_Return SQLConnection.sServer
86263>>>    End_Function
86264>>>
86264>>>    Procedure Set psDatabase String sValue
86266>>>        tSQLConnection SQLConnection
86266>>>        tSQLConnection SQLConnection
86266>>>        Get Private.pSQLConnection to SQLConnection
86267>>>        Move sValue        to SQLConnection.sDatabase
86268>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
86269>>>        Set pSQLConnection to SQLConnection
86270>>>    End_Procedure
86271>>>
86271>>>    Function psDatabase Returns String
86273>>>        tSQLConnection SQLConnection
86273>>>        tSQLConnection SQLConnection
86273>>>        Get Private.pSQLConnection to SQLConnection
86274>>>        Function_Return SQLConnection.sDatabase
86275>>>    End_Function
86276>>>
86276>>>    Procedure Set psUserID String sValue
86278>>>        tSQLConnection SQLConnection
86278>>>        tSQLConnection SQLConnection
86278>>>        Get Private.pSQLConnection to SQLConnection
86279>>>        Move sValue        to SQLConnection.sUserID
86280>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
86281>>>        Set pSQLConnection to SQLConnection
86282>>>    End_Procedure
86283>>>
86283>>>    Function psUserID Returns String
86285>>>        tSQLConnection SQLConnection
86285>>>        tSQLConnection SQLConnection
86285>>>        Get Private.pSQLConnection to SQLConnection
86286>>>        Function_Return SQLConnection.sUserID
86287>>>    End_Function
86288>>>
86288>>>    // This is the uncrypted password
86288>>>    Procedure Set psPassword String sValue
86290>>>        tSQLConnection SQLConnection
86290>>>        tSQLConnection SQLConnection
86290>>>        Get Private.pSQLConnection to SQLConnection
86291>>>        Move sValue        to SQLConnection.sPassword
86292>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
86293>>>        Set pSQLConnection to SQLConnection
86294>>>    End_Procedure
86295>>>
86295>>>    Function psPassword Returns String
86297>>>        tSQLConnection SQLConnection
86297>>>        tSQLConnection SQLConnection
86297>>>        Get Private.pSQLConnection to SQLConnection
86298>>>        Function_Return SQLConnection.sPassword
86299>>>    End_Function
86300>>>
86300>>>    Procedure Set pbTrusted Boolean bValue
86302>>>        tSQLConnection SQLConnection
86302>>>        tSQLConnection SQLConnection
86302>>>        Get Private.pSQLConnection to SQLConnection
86303>>>        Move bValue        to SQLConnection.bTrusted
86304>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
86305>>>        Set pSQLConnection to SQLConnection
86306>>>    End_Procedure
86307>>>
86307>>>    Function pbTrusted Returns Boolean
86309>>>        tSQLConnection SQLConnection
86309>>>        tSQLConnection SQLConnection
86309>>>        Get Private.pSQLConnection to SQLConnection
86310>>>        Function_Return SQLConnection.bTrusted
86311>>>    End_Function
86312>>>
86312>>>    // *** All of these properties are special to the Database Update Framework ***
86312>>>    //     Thus they are not propagated to the DAW/Mertech classes and that is why
86312>>>    //     the Private.pSQLConnection property is set instead of the going throu
86312>>>    //     the central pSQLConnection "hub".
86312>>>    Procedure Set pbSilentLogin Boolean bValue
86314>>>        tSQLConnection SQLConnection
86314>>>        tSQLConnection SQLConnection
86314>>>        Get Private.pSQLConnection to SQLConnection
86315>>>        Move bValue to SQLConnection.bTrusted
86316>>>        Set Private.pSQLConnection to SQLConnection
86317>>>    End_Procedure
86318>>>
86318>>>    Function pbSilentLogin Returns Boolean
86320>>>        tSQLConnection SQLConnection
86320>>>        tSQLConnection SQLConnection
86320>>>        Get Private.pSQLConnection to SQLConnection
86321>>>        Function_Return SQLConnection.bSilentLogin
86322>>>    End_Function
86323>>>
86323>>>    Procedure Set piDbType Integer iValue
86325>>>        tSQLConnection SQLConnection
86325>>>        tSQLConnection SQLConnection
86325>>>        Get Private.pSQLConnection to SQLConnection
86326>>>        Move iValue to SQLConnection.iDbType
86327>>>        Set Private.pSQLConnection to SQLConnection
86328>>>    End_Procedure
86329>>>
86329>>>    Function piDbType Returns Integer
86331>>>        tSQLConnection SQLConnection
86331>>>        tSQLConnection SQLConnection
86331>>>        Get Private.pSQLConnection to SQLConnection
86332>>>        Function_Return SQLConnection.iDbType
86333>>>    End_Function
86334>>>
86334>>>    Procedure Set psBaseTableSpace String sValue
86336>>>        tSQLConnection SQLConnection
86336>>>        tSQLConnection SQLConnection
86336>>>        Get Private.pSQLConnection to SQLConnection
86337>>>        Move sValue to SQLConnection.sBaseTableSpace
86338>>>        Set Private.pSQLConnection to SQLConnection
86339>>>    End_Procedure
86340>>>
86340>>>    Function psBaseTableSpace Returns String
86342>>>        tSQLConnection SQLConnection
86342>>>        tSQLConnection SQLConnection
86342>>>        Get Private.pSQLConnection to SQLConnection
86343>>>        Function_Return SQLConnection.sBaseTableSpace
86344>>>    End_Function
86345>>>
86345>>>    Procedure Set psIndexTableSpace String sValue
86347>>>        tSQLConnection SQLConnection
86347>>>        tSQLConnection SQLConnection
86347>>>        Get Private.pSQLConnection to SQLConnection
86348>>>        Move sValue to SQLConnection.sIndexTableSpace
86349>>>        Set Private.pSQLConnection to SQLConnection
86350>>>    End_Procedure
86351>>>
86351>>>    Function psIndexTableSpace Returns String
86353>>>        tSQLConnection SQLConnection
86353>>>        tSQLConnection SQLConnection
86353>>>        Get Private.pSQLConnection to SQLConnection
86354>>>        Function_Return SQLConnection.sIndexTableSpace
86355>>>    End_Function
86356>>>
86356>>>    Procedure Set psLongTableSpace String sValue
86358>>>        tSQLConnection SQLConnection
86358>>>        tSQLConnection SQLConnection
86358>>>        Get Private.pSQLConnection to SQLConnection
86359>>>        Move sValue to SQLConnection.sLongTableSpace
86360>>>        Set Private.pSQLConnection to SQLConnection
86361>>>    End_Procedure
86362>>>
86362>>>    Function psLongTableSpace Returns String
86364>>>        tSQLConnection SQLConnection
86364>>>        tSQLConnection SQLConnection
86364>>>        Get Private.pSQLConnection to SQLConnection
86365>>>        Function_Return SQLConnection.sLongTableSpace
86366>>>    End_Function
86367>>>
86367>>>    Procedure Set psSchema String sValue
86369>>>        tSQLConnection SQLConnection
86369>>>        tSQLConnection SQLConnection
86369>>>        Get Private.pSQLConnection to SQLConnection
86370>>>        Move sValue to SQLConnection.sSchema
86371>>>        Set Private.pSQLConnection to SQLConnection
86372>>>    End_Procedure
86373>>>
86373>>>    Function psSchema Returns String
86375>>>        tSQLConnection SQLConnection
86375>>>        tSQLConnection SQLConnection
86375>>>        Get Private.pSQLConnection to SQLConnection
86376>>>        Function_Return SQLConnection.sSchema
86377>>>    End_Function
86378>>>
86378>>>    Procedure Set pbEnabled Boolean bValue
86380>>>        tSQLConnection SQLConnection
86380>>>        tSQLConnection SQLConnection
86380>>>        Get Private.pSQLConnection to SQLConnection
86381>>>        Move bValue to SQLConnection.bEnabled
86382>>>        Set Private.pSQLConnection to SQLConnection
86383>>>    End_Procedure
86384>>>
86384>>>    Function pbEnabled Returns Boolean
86386>>>        tSQLConnection SQLConnection
86386>>>        tSQLConnection SQLConnection
86386>>>        Get Private.pSQLConnection to SQLConnection
86387>>>        Function_Return SQLConnection.bEnabled
86388>>>    End_Function
86389>>>
86389>>>
86389>>>    // ************************************
86389>>>    Function SetupSQLConnection Boolean bReadDFConnSettings Boolean bReadSQLConnections Returns tSQLConnection
86391>>>        tSQLConnection SQLConnection
86391>>>        tSQLConnection SQLConnection
86391>>>
86391>>>        // If this object was created by the cDbUpdateHandler class we will
86391>>>        // deferr reading SQL connection values until later.
86391>>>        If (bReadDFConnSettings = True) Begin
86393>>>            // This is the new SQL login logic for DF 19 and up; "Managed Connections"
86393>>>            If (ghoConnection > 0) Begin
86395>>>                Get ReadcConnections to SQLConnection
86396>>>            End
86396>>>>
86396>>>
86396>>>            // In addition to the above; there might be other values set even if a cConnection
86396>>>            // object is used.
86396>>>            If (bReadSQLConnections = True) Begin
86398>>>                Get ReadSQLConnectionsIniSettings to SQLConnection
86399>>>            End
86399>>>>
86399>>>        End
86399>>>>
86399>>>
86399>>>        Function_Return SQLConnection
86400>>>    End_Function
86401>>>
86401>>>    // This is for the new cConnection class used by DF 19 and up (only).
86401>>>    Function ReadcConnections Returns tSQLConnection
86403>>>        tConnection Connection
86403>>>        tConnection Connection
86403>>>        tSQLConnection SQLConnection SQLConnectionEmpty
86403>>>        tSQLConnection SQLConnection SQLConnectionEmpty
86403>>>        Integer iRetval iDbType
86403>>>        Boolean bOK bEnabled bConnected
86403>>>        String sConnectionID sSchema
86403>>>
86403>>>            tConnection[] Connections
86403>>>            tConnection[] Connections
86404>>>            // - If the DF 19 cConnection class has been used in the cApplication object
86404>>>            // - and there are multiple connection id's defined for the same driver. This is
86404>>>            //   because otherwise we can't possibly know which connection id to use... So
86404>>>            //   we then generate an error and abort the program...
86404>>>            Get IsSinglecConnection (&sConnectionID) to bOK
86405>>>            If (bOK = False) Begin
86407>>>                Error DFERR_PROGRAM ("Programming error. The psConnectionID must be set in the cDbUpdateVersion object when a cConnect object is used in the cApplication object, and there are multiple connections defined. Program will now exit!")
86408>>>>
86408>>>                Abort
86409>>>>
86409>>>            End
86409>>>>
86409>>>            If (sConnectionID = "") Begin
86411>>>                Get ConnectionIDs of ghoConnection to Connections
86412>>>                If (SizeOfArray(Connections) > 0) Begin
86414>>>                    Move Connections[0].sId to sConnectionID
86415>>>                End
86415>>>>
86415>>>            End
86415>>>>
86415>>>
86415>>>            Move 0 to iRetval
86416>>>            // DAW DF19 connection info:
86416>>>            // We first check that the connection is OK:
86416>>>            Get ConnectionIdIndex of ghoConnection sConnectionID to iRetval
86417>>>            // It might happen that no connection has been setup although the object exists, in case we do nothing.
86417>>>            If (iRetval = -1) Begin
86419>>>                Function_Return SQLConnectionEmpty
86420>>>            End
86420>>>>
86420>>>
86420>>>            If (sConnectionID <> "") Begin
86422>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
86423>>>            End
86423>>>>
86423>>>            If (Connection.sId = "") Begin
86425>>>                Move True to SQLConnectionEmpty.bError
86426>>>                Function_Return SQLConnectionEmpty
86427>>>            End
86427>>>>
86427>>>
86427>>>            // DUF connection info struct property:
86427>>>            Get Private.pSQLConnection                       to SQLConnection
86428>>>
86428>>>            Move Connection.sId to sConnectionID
86429>>>            Get IsConnectionIdLoggedIn of ghoConnection sConnectionID to bConnected
86430>>>
86430>>>            If (bConnected = False) Begin
86432>>>                Get LoginConnectionId of ghoConnection sConnectionID to iRetval
86433>>>                If (iRetval <> 0) Begin
86435>>>                    Send UserError CS_DUF_CannotLoginToServer
86436>>>                    Send Exit_Application
86437>>>                End
86437>>>>
86437>>>                Move True                                   to SQLConnection.bDAWConnection
86438>>>                // We need to get the DAW connection info again as it might have
86438>>>                // been changed in the DAW db login dialog.
86438>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
86439>>>            End
86439>>>>
86439>>>
86439>>>            Move True                                        to SQLConnection.bEnabled
86440>>>            Move Connection.bTrustedConnection               to SQLConnection.bTrusted
86441>>>
86441>>>            // Not used in DUF:
86441>>>            // Move Connection.iDriverIndex                    to SQLConnection.iDriverIndex
86441>>>
86441>>>            Move (If(Connection.iOptions = 0, False, True))  to SQLConnection.bSilentLogin
86442>>>            Move Connection.sConnectionString                to SQLConnection.sConnectionString
86443>>>            Move Connection.sDriver                          to SQLConnection.sDriverID
86444>>>            Move Connection.sId                              to SQLConnection.sConnectionID
86445>>>            Move Connection.sUID                             to SQLConnection.sUserID
86446>>>            Move Connection.sPWD                             to SQLConnection.sPassword
86447>>>
86447>>>            // Not used in DUF:
86447>>>            // Move Connection.sSection to SQLConnection.xxx
86447>>>
86447>>>            // The rest of the properties of the SQLConnection struct should have been
86447>>>            // setup in the cDbUpdateHandler object, and we should be able to reach them through delegation:
86447>>>            If (Connection.sDriver <> ODBC_DRV_ID) Begin
86449>>>                Get ParseKeyWord Connection.sString CS_SQLIniServerKeyword to SQLConnection.sServer
86450>>>            End
86450>>>>
86450>>>            If (Connection.sDriver = ODBC_DRV_ID) Begin
86452>>>                Get ParseKeyWord Connection.sString CS_SQLIniDSNKeyword    to SQLConnection.sServer
86453>>>            End
86453>>>>
86453>>>            Get ParseKeyWord Connection.sString CS_SQLIniDatabaseKeyword   to SQLConnection.sDatabase
86454>>>
86454>>>            // The DbType is a bit special. If the piDbType has _not_ been setup in object code we try to derave
86454>>>            // the value from the driver id:
86454>>>            Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(Self)) Connection.sDriver to SQLConnection.iDbType
86455>>>            // ...but in case it has been explicitly set in the object we use that value.
86455>>>            Get piDbType                                     to iDbType
86456>>>            If (iDbType <> SQLConnection.iDbType) Begin
86458>>>                Move iDbType to SQLConnection.iDbType
86459>>>            End
86459>>>>
86459>>>            Get psBaseTableSpace                             to SQLConnection.sBaseTableSpace
86460>>>            Get psLongTableSpace                             to SQLConnection.sLongTableSpace
86461>>>            Get psIndexTableSpace                            to SQLConnection.sIndexTableSpace
86462>>>            Get psSchema                                     to SQLConnection.sSchema
86463>>>
86463>>>            // We finally set the struct property to the newly fetched values.
86463>>>            Set pSQLConnection to SQLConnection
86464>>>
86464>>>        Function_Return SQLConnection
86465>>>    End_Function
86466>>>
86466>>>    // Returns True if the psConnectionID has been set in the cDbUpateHandler object,
86466>>>    // or the DAW cConnect array of registered connection only contains one active/enabled
86466>>>    // connection id for a particular driver.
86466>>>    // So either the psConnectionID or the psDriverID can have been set in the cDbUpdateHandler
86466>>>    // object. We can then match a connection id from the DAW cConnect class array.
86466>>>    // Returns False if there are multiple connections that are enabled or the psConnectionID has
86466>>>    // been set in the cDbUpdateHandler object but it cannot be found amongst the registered
86466>>>    // connections of the DAW cConnect class.
86466>>>    Function IsSinglecConnection String ByRef sConnectionID Returns Boolean
86468>>>        tConnection[] ConnIdArray
86468>>>        tConnection[] ConnIdArray
86469>>>        Integer iCount iSize iConnectionIDCounter
86469>>>        Boolean bEnabled bFound
86469>>>        String sConnectionID2 sDriverID sDriverConn
86469>>>
86469>>>        Move False to bFound
86470>>>        If (ghoConnection > 0) Begin
86472>>>
86472>>>            // The property of the cDbUpdateHandler container object
86472>>>            Get psDriverID to sDriverID
86473>>>
86473>>>            Move 0 to iConnectionIDCounter
86474>>>            // This is the the DAW cConnect array with all registered connection id's.
86474>>>                Get ConnectionIDs of ghoConnection to ConnIdArray
86475>>>            Move (SizeOfArray(ConnIdArray)) to iSize
86476>>>            Decrement iSize
86477>>>            For iCount from 0 to iSize
86483>>>>
86483>>>                Move ConnIdArray[iCount].sDriver to sDriverConn
86484>>>                Move ConnIdArray[iCount].sId to sConnectionID2
86485>>>                Move (ConnIdArray[iCount].bDisabled = False) to bEnabled
86486>>>                // If no psConnectionID specified in the cDbUpdateHandler, we check if there is a driver
86486>>>                // connection in the DAW cConnect object _and_ that there is only one!
86486>>>                If (sConnectionID = "") Begin
86488>>>                    Move (sDriverID = sDriverConn and bEnabled = True) to bFound
86489>>>                End
86489>>>>
86489>>>                Else Begin
86490>>>                    If (Uppercase(sConnectionID) = Uppercase(sConnectionID2)) Begin
86492>>>                        Move iSize to iCount // Then we've found what we were looking for and we're out of here...
86493>>>                    End
86493>>>>
86493>>>                End
86493>>>>
86493>>>
86493>>>                If (bFound = True) Begin
86495>>>                    Increment iConnectionIDCounter
86496>>>                End
86496>>>>
86496>>>            Loop
86497>>>>
86497>>>            Move (iConnectionIDCounter <= 1 and sDriverConn <> "" and sConnectionID2 <> "") to bFound
86498>>>            If (bFound = True) Begin
86500>>>                Move sConnectionID2 to sConnectionID
86501>>>            End
86501>>>>
86501>>>        End
86501>>>>
86501>>>
86501>>>        // Special case; a cConnection object has been setup in the cApplication,
86501>>>        // but no DFConn.ini record has been created.
86501>>>        If (iSize = -1) Begin
86503>>>            Move True to bFound
86504>>>        End
86504>>>>
86504>>>
86504>>>        Function_Return bFound
86505>>>    End_Function
86506>>>
86506>>>    // Send on object creation to read the default connection string settings, and
86506>>>    // create a connection to the server.
86506>>>    Function ReadSQLConnectionsIniSettings Returns tSQLConnection
86508>>>        String sPath sFileName sPassword
86508>>>        Boolean bExists
86508>>>        tSQLConnection[] SQLConnectionArray
86508>>>        tSQLConnection[] SQLConnectionArray
86509>>>        tSQLConnection SQLConnection SQLConnectionEmpty
86509>>>        tSQLConnection SQLConnection SQLConnectionEmpty
86509>>>        Handle hoIniFile
86509>>>        Integer iSize iCount
86509>>>
86509>>>        Get psIniFilePath to sPath
86510>>>        Get phoSQLConnectionIniFile to hoIniFile
86511>>>        If (sPath = "") Begin
86513>>>            Get ApplicationPath of hoIniFile to sPath
86514>>>            Set psIniFilePath   of hoIniFile to sPath
86515>>>        End
86515>>>>
86515>>>        Get vFolderFormat sPath to sPath
86516>>>        Get psIniFileName to sFileName
86517>>>        Get vFilePathExists (sPath + sFileName) to bExists
86518>>>
86518>>>        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
86519>>>        Move (SizeOfArray(SQLConnectionArray)) to iSize
86520>>>        If (iSize = 0) Begin
86522>>>            // This may have been set by the "ReadcConnections" function,
86522>>>            // if a cConnection object has been setup for DataFlex 19 or later
86522>>>            // in the cApplication object.
86522>>>            Get pSQLConnection to SQLConnection
86523>>>            If (SQLConnection.sConnectionID = "") Begin
86525>>>                Function_Return SQLConnectionEmpty
86526>>>            End
86526>>>>
86526>>>            Move SQLConnection to SQLConnectionArray[0]
86527>>>        End
86527>>>>
86527>>>
86527>>>        // The first connection should be the one that is active, but just in case...
86527>>>        Decrement iSize
86528>>>        For iCount from 0 to iSize
86534>>>>
86534>>>            Move SQLConnectionArray[iCount] to SQLConnection
86535>>>            If (SQLConnection.bEnabled = True) Begin
86537>>>                Move iSize to iCount // We've found the enabled item, so we're out of here.
86538>>>            End
86538>>>>
86538>>>        Loop
86539>>>>
86539>>>
86539>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID ;             SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted ;             SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bSilentLogin
86540>>>
86540>>>        Set pSQLConnection to SQLConnection
86541>>>        Send AutoSetConnectionID
86542>>>
86542>>>        Function_Return SQLConnection
86543>>>    End_Function
86544>>>
86544>>>    Procedure Set psIniFilePath String sPath
86546>>>        Set psIniFilePath of (phoSQLConnectionIniFile(Self)) to sPath
86547>>>    End_Procedure
86548>>>
86548>>>    Function psIniFilePath Returns String
86550>>>        String sRetval
86550>>>        Get psIniFilePath of (phoSQLConnectionIniFile(Self)) to sRetval
86551>>>        Function_Return sRetval
86552>>>    End_Function
86553>>>
86553>>>    Procedure Set psIniFileName String sFileName
86555>>>        Set psIniFileName of (phoSQLConnectionIniFile(Self)) to sFileName
86556>>>    End_Procedure
86557>>>
86557>>>    Function psIniFileName Returns String
86559>>>        String sRetval
86559>>>        Get psIniFileName of (phoSQLConnectionIniFile(Self)) to sRetval
86560>>>        Function_Return sRetval
86561>>>    End_Function
86562>>>
86562>>>    // We use Base64 coding instead of the cCryptographer class because the
86562>>>    // password will get scrambled while writing/reading to/from the ini-file.
86562>>>//    { MethodType=Property Category="Behavior" InitialValue="zx!2139(LI0+?ips7433"}
86562>>>//    Procedure Set psHashString String sHashString
86562>>>//        Set psHashString of (phoSQLConnectionIniFile(Self)) to sHashString
86562>>>//    End_Procedure
86562>>>//
86562>>>//    Function psHashString Returns String
86562>>>//        String sRetval
86562>>>//        Get psHashString of (phoSQLConnectionIniFile(Self)) to sRetval
86562>>>//        Function_Return sRetval
86562>>>//    End_Function
86562>>>
86562>>>    Procedure Set psIniSectionName String sSection
86564>>>        Set psIniSectionName of (phoSQLConnectionIniFile(Self)) to sSection
86565>>>    End_Procedure
86566>>>
86566>>>    Function psIniSectionName Returns String
86568>>>        String sRetval
86568>>>        Get psIniSectionName of (phoSQLConnectionIniFile(Self)) to sRetval
86569>>>        Function_Return sRetval
86570>>>    End_Function
86571>>>
86571>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
86573>>>        Handle ho
86573>>>        Get phoSQLConnectionIniFile to ho
86574>>>        Set IniFileValue of ho to sSection sValueName sValue
86575>>>    End_Procedure
86576>>>
86576>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
86578>>>        Handle ho
86578>>>        String sRetval
86578>>>        Get phoSQLConnectionIniFile to ho
86579>>>        Get IniFileValue of ho sSection sValueName sDefaultValue to sRetval
86580>>>        Function_Return sRetval
86581>>>    End_Function
86582>>>
86582>>>    Function SectionExists String sSection Returns Boolean
86584>>>        Handle ho
86584>>>        Boolean bRetval
86584>>>        Get phoSQLConnectionIniFile to ho
86585>>>        Get SectionExists of ho sSection to bRetval
86586>>>        Function_Return bRetval
86587>>>    End_Function
86588>>>
86588>>>    Function KeyExists String sSection String sKey Returns Boolean
86590>>>        Handle ho
86590>>>        Boolean bRetval
86590>>>        Get phoSQLConnectionIniFile to ho
86591>>>        Get KeyExists of ho sSection sKey to bRetval
86592>>>        Function_Return bRetval
86593>>>    End_Function
86594>>>
86594>>>    Function EncryptPassword String sPassword Returns String
86596>>>        Handle ho
86596>>>        String sRetval
86596>>>        Get phoSQLConnectionIniFile to ho
86597>>>        Get EncryptPassword of ho sPassword to sRetval
86598>>>        Function_Return sRetval
86599>>>    End_Function
86600>>>
86600>>>    Function DecryptPassword String sPassword Returns String
86602>>>        Handle ho
86602>>>        String sRetval
86602>>>        Get phoSQLConnectionIniFile to ho
86603>>>        Get DecryptPassword of ho sPassword to sRetval
86604>>>        Function_Return sRetval
86605>>>    End_Function
86606>>>
86606>>>    // *** Main Connection Message ***
86606>>>    // It will create a Connection ID for the passed driver.
86606>>>    // It will also set the psDriverID & psConnectionID of this class.
86606>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent
86608>>>        Handle hoDriver
86608>>>        String sConnectionString sError
86608>>>        Boolean bLoginSuccessful
86608>>>
86608>>>        Get ConstructConnectionString sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnectionString
86609>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
86610>>>        Set psDriverID of hoDriver to sDriverID
86611>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
86612>>>        If (bLoginSuccessful = False) Begin
86614>>>            Error DFERR_PROGRAM (CS_DUF_CannotLoginToServer * CS_DUF_ErrorText * String(sError) + "\nConnectionID = " * sConnectionID + "\nConnection String = " * sConnectionString)
86615>>>>
86615>>>            Send Exit_Application
86616>>>        End
86616>>>>
86616>>>        Send Destroy of hoDriver
86617>>>
86617>>>    End_Procedure
86618>>>
86618>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
86620>>>        Integer iRetval
86620>>>        Handle hoCLI
86620>>>        String sDriverID
86620>>>
86620>>>        Get psDriverID to sDriverID
86621>>>        Get Create (Refclass(cCLIHandler)) to hoCLI
86622>>>        If (hoCLI <> 0) Begin
86624>>>            Set psDriverID of hoCLI to sDriverID
86625>>>            Get RedirectConnection of hoCLI sOldConnection sNewConnection to iRetval
86626>>>            Send Destroy of hoCLI
86627>>>        End
86627>>>>
86627>>>
86627>>>        Function_Return iRetval
86628>>>    End_Function
86629>>>
86629>>>    Procedure CreateConnParamsFromConnectionString String sDriverID String sConnectionString
86631>>>        String sServer sDatabase sUserID sPassword
86631>>>        tSQLConnection SQLConnection
86631>>>        tSQLConnection SQLConnection
86631>>>
86631>>>        Set psDriverID to sDriverID
86632>>>        Get DeComposeConnectionString sDriverID sConnectionString to SQLConnection
86633>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID SQLConnection.sServer;                                 SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted
86634>>>    End_Procedure
86635>>>
86635>>>    // This is needed when e.g. the connection id we have specified in the program code
86635>>>    // also exists in e.g. the MSSQLDRV.ini file (can either be local in the Data folder
86635>>>    // or the one in the DataFlex Bin folder.)
86635>>>    // We then need to delete the current one before creating a new one.
86635>>>    // This is because the parameters may differ between the program code and the
86635>>>    // MSSQLDRV.ini file in a deployed environment. Also DataFlex will generate an error
86635>>>    // when one tries to create a Connection ID that already exists.
86635>>>    Procedure RemoveExistingConnectionID String sDriverID String sConnectionID
86637>>>        Integer iResult iDriver iNumConn iConn
86637>>>        Handle hoCLI
86637>>>        String sID
86637>>>
86637>>>        If (sDriverID = "" or sConnectionID = "") Begin
86639>>>            Procedure_Return
86640>>>        End
86640>>>>
86640>>>
86640>>>        Move 0 to iResult
86641>>>        Get Create U_cCLIHandler to hoCLI
86642>>>        If (hoCLI <> 0) Begin
86644>>>            Set psDriverID of hoCLI to sDriverID
86645>>>            Get DriverIndex sDriverID to iDriver
86646>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
86649>>>            Decrement iNumConn
86650>>>            For iConn from 0 to iNumConn
86656>>>>
86656>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
86659>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
86661>>>                    Get DeleteConnectionID of hoCLI sConnectionID -1 to iResult
86662>>>                End
86662>>>>
86662>>>            Loop
86663>>>>
86663>>>            Send Destroy of hoCLI
86664>>>        End
86664>>>>
86664>>>
86664>>>    End_Procedure
86665>>>
86665>>>    Function ExistingConnectionSettings String sDriverID String sConnectionID Returns tSQLConnection
86667>>>        Integer iResult iDriver iNumConn iConn
86667>>>        Handle hoCLI
86667>>>        String sID sConnectionString sVal sDatabase
86667>>>        tSQLConnection SQLConnection
86667>>>        tSQLConnection SQLConnection
86667>>>        Boolean bTrusted
86667>>>
86667>>>        Move 0 to iResult
86668>>>        Get Create U_cCLIHandler to hoCLI
86669>>>        If (hoCLI <> 0) Begin
86671>>>            Set psDriverID of hoCLI to sDriverID
86672>>>            Get DriverIndex sDriverID to iDriver
86673>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
86676>>>            Decrement iNumConn
86677>>>            For iConn from 0 to iNumConn
86683>>>>
86683>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
86686>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
86688>>>                    Move sDriverID                                                      to SQLConnection.sDriverID      // For completeness only...
86689>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn              to SQLConnection.sConnectionID  // For completeness only...
86692>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iConn       to sConnectionString
86695>>>                    Move sConnectionString                                              to SQLConnection.sConnectionString
86696>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_OPTIONS of iDriver iConn      to SQLConnection.bSilentLogin
86699>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnection.sServer
86700>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnection.sDatabase
86701>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to SQLConnection.sUserID
86702>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to SQLConnection.sPassword
86703>>>
86703>>>                    Case Begin
86703>>>                        Case (sDriverID = MSSQLDRV_ID)
86705>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=") to sVal
86706>>>                            Move (If(Uppercase(sVal) = Uppercase(CS_SQLIniConnectionYes), True, False)) to bTrusted
86707>>>                            Move bTrusted                                               to SQLConnection.bTrusted
86708>>>                            Case Break
86709>>>                        Case (sDriverID = DB2_DRV_ID)
86712>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
86713>>>                            Case Break
86714>>>                        Case (sDriverID = ODBC_DRV_ID)
86717>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
86718>>>                            Case Break
86719>>>                        Case (sDriverID = SQLFLEX)
86722>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
86723>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
86724>>>                            If (SQLConnection.bTrusted = True) Begin
86726>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
86727>>>                            End
86727>>>>
86727>>>                            Else Begin
86728>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
86729>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
86730>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
86731>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
86732>>>                            End
86732>>>>
86732>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
86733>>>                            Case Break
86734>>>                        Case (sDriverID = MDSMySQL)
86737>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
86738>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
86739>>>                            If (SQLConnection.bTrusted = True) Begin
86741>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
86742>>>                            End
86742>>>>
86742>>>                            Else Begin
86743>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
86744>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
86745>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
86746>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
86747>>>                            End
86747>>>>
86747>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
86748>>>                            Case Break
86749>>>                        Case (sDriverID = MDSPgSQL)
86752>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
86753>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
86754>>>                            If (SQLConnection.bTrusted = True) Begin
86756>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
86757>>>                            End
86757>>>>
86757>>>                            Else Begin
86758>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
86759>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
86760>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
86761>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
86762>>>                            End
86762>>>>
86762>>>                            Move sConnectionString                                                to SQLConnection.sConnectionString
86763>>>                            Case Break
86764>>>
86764>>>                        Case (sDriverID = ORAFLEX)
86767>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to SQLConnection.sServer
86768>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)         to sConnectionString
86769>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
86770>>>                            If (sDatabase <> "" and (not(SQLConnection.sServer contains "/"))) Begin
86772>>>                                Move (SQLConnection.sServer + "/" + sDatabase)                  to SQLConnection.sServer
86773>>>                            End
86773>>>>
86773>>>                            If (SQLConnection.bTrusted = True) Begin
86775>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
86776>>>                            End
86776>>>>
86776>>>                            Else Begin
86777>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
86778>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
86779>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
86780>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
86781>>>                            End
86781>>>>
86781>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
86782>>>                            Case Break
86783>>>                        Case Else
86783>>>                            Error ("Wrong driver ID passed:" * sDriverID)
86784>>>>
86784>>>                            Case Break
86785>>>                    Case End
86785>>>                End
86785>>>>
86785>>>            Loop
86786>>>>
86786>>>            Send Destroy of hoCLI
86787>>>        End
86787>>>>
86787>>>
86787>>>        Function_Return SQLConnection
86788>>>    End_Function
86789>>>
86789>>>    Function DriverIndex String sDriverID Returns Integer
86791>>>        String  sCurrentDriver
86791>>>        Integer iNumberOfDrivers iDriver iCount
86791>>>
86791>>>        Move 0 to iDriver
86792>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
86795>>>        For iCount from 1 to iNumberOfDrivers
86801>>>>
86801>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
86804>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
86806>>>                Function_Return iCount
86807>>>            End
86807>>>>
86807>>>        Loop
86808>>>>
86808>>>
86808>>>        // If driver not previously loaded; attempt to do so now.
86808>>>        If (iDriver = 0) Begin
86810>>>            Move 0 to LastErr
86811>>>            Load_Driver sDriverID
86812>>>            // If driver could not be loaded.
86812>>>            If (LastErr = 4255) Begin
86814>>>                Move 0 to iCount
86815>>>            End
86815>>>>
86815>>>            Function_Return iCount
86816>>>        End
86816>>>>
86816>>>        Function_Return 0
86817>>>    End_Function
86818>>>
86818>>>    // This will update connection settings of the cCLIHandler object with that passed struct values.
86818>>>    Procedure UpdateConnectionString tSQLConnection SQLConnection
86820>>>        String sDriverID sConnectionID sServer sDatabase sUserID sPassword
86820>>>        Boolean bTrusted bSilent
86820>>>
86820>>>        Move SQLConnection.sDriverID     to sDriverID
86821>>>        Move SQLConnection.sConnectionID to sConnectionID
86822>>>        Move SQLConnection.sServer       to sServer
86823>>>        Move SQLConnection.sDatabase     to sDatabase
86824>>>        Move SQLConnection.bTrusted      to bTrusted
86825>>>        Move SQLConnection.sUserID       to sUserID
86826>>>        Move SQLConnection.sPassword     to sPassword
86827>>>        Move SQLConnection.bSilentLogin  to bSilent
86828>>>
86828>>>        Send CreateSQLConnection sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent
86829>>>        // Note that this message will first delete the current ConnectionID if it exists; which is needed by the cCLIHandler logic.
86829>>>        Send AutoSetConnectionID
86830>>>    End_Procedure
86831>>>
86831>>>    // Called when the object is constructed.
86831>>>    // It will check the psDriverID for a ConnectionID and save it
86831>>>    // as psConnectionID property. It is later used whenever a login to
86831>>>    // the database is needed.
86831>>>    Procedure AutoSetConnectionID
86833>>>        String sConnectionID sDriverID sConnectionString
86833>>>        Integer iDriver iRetval
86833>>>        Handle hoCLI
86833>>>        Boolean bOK bSilent bMertechDriver
86833>>>
86833>>>        Get pbSilentLogin      to bSilent
86834>>>        Get psConnectionID     to sConnectionID
86835>>>        Get psConnectionString to sConnectionString
86836>>>        // Get the driver Connection ID string & set the psConnectionString property.
86836>>>        Get psDriverID to sDriverID
86837>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
86838>>>        If (bOK = False) Begin
86840>>>            Procedure_Return
86841>>>        End
86841>>>>
86841>>>
86841>>>        // Mertech drivers can't use connection ID's.
86841>>>        Get IsMertechDriver sDriverID to bMertechDriver
86842>>>        If (bMertechDriver = True) Begin
86844>>>            // This ensures that the correct Server & Database attributes are set both for
86844>>>            // embedded SQL calls and "normal" database commands like e.g. "Open".
86844>>>            Get _MertechSQLManagerHandle to hoCLI
86845>>>            Procedure_Return
86846>>>        End
86846>>>>
86846>>>
86846>>>        Get DriverIndex sDriverID          to iDriver
86847>>>        // If driver not loaded; load it.
86847>>>        If (iDriver = 0) Begin
86849>>>            Load_Driver sDriverID
86850>>>            Get DriverIndex sDriverID      to iDriver
86851>>>        End
86851>>>>
86851>>>        // This shouldn't be possible; unless the driver.dll file is missing or something...
86851>>>        If (iDriver = 0) Begin
86853>>>            Error DFERR_PROGRAM ("The database driver could not be loaded! Connection to database failed." * sDriverID)
86854>>>>
86854>>>            Procedure_Return
86855>>>        End
86855>>>>
86855>>>
86855>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
86856>>>        Set psDriverID of hoCLI            to sDriverID
86857>>>        // Delete the connection first; in case it exists
86857>>>        Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
86858>>>        Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to iRetval
86859>>>
86859>>>        Send Destroy of hoCLI
86860>>>    End_Procedure
86861>>>
86861>>>    // Returns the handle of the Mertech SQL handler.
86861>>>    // It also ensures that the correct Server & Database attributes are set both for
86861>>>    // embedded SQL calls and "normal" database commands like e.g. "Open".
86861>>>    // Note: This does _not_ return a proper CLI handler handle as it is not in this class.
86861>>>    //       So the return value is of no use! But we don't need the handle for this class.
86861>>>    Function _MertechSQLManagerHandle Returns Handle
86863>>>        Handle hoSQLHandler
86863>>>        String sDriverID sServer sDatabase
86863>>>
86863>>>        Move 0 to hoSQLHandler
86864>>>        Get psDriverID to sDriverID
86865>>>        Get psServer   to sServer
86866>>>        Get psDatabase to sDatabase
86867>>>        // This command is used to set the server to be used when opening tables
86867>>>        SET_CURRENT_SQL_SERVER to sServer
86886>>>>
86886>>>        // This command is used to specify which server to use for embedded SQL statements,
86886>>>        // but it has been constructed rather studidly as only constants and not variables
86886>>>        // are allowed...
86886>>>        If (sDriverID = MDSPgSQL) Begin
86888>>>            SET_CURRENT_SQL_SERVER_CONNECTION of MDSPgSQL to sServer
86904>>>        End
86904>>>>
86904>>>        If (sDriverID = MDSMySQL) Begin
86906>>>            SET_CURRENT_SQL_SERVER_CONNECTION of MDSMySQL to sServer
86922>>>        End
86922>>>>
86922>>>        If (sDriverID = ORAFLEX) Begin
86924>>>            SET_CURRENT_SQL_SERVER_CONNECTION of ORAFLEX to sServer
86940>>>        End
86940>>>>
86940>>>        If (sDriverID = SQLFLEX) Begin
86942>>>            SET_CURRENT_SQL_SERVER_CONNECTION of SQLFLEX to sServer
86958>>>        End
86958>>>>
86958>>>
86958>>>        // This command is used to specify which database is used for embedded SQL statements.
86958>>>        SQL_USE_DATABASE sDatabase
86972>>>>
86972>>>        SET_DATABASE_NAME to sDatabase
86986>>>>
86986>>>
86986>>>        // Can't have this here because the property is defined for the cDbUpdateFunctionLibrary class,
86986>>>        // which object may or may not have been created at this point. So don't use the return
86986>>>        // value for this function!
86986>>>        //Get phoSQLManagerMT to hoSQLHandler
86986>>>
86986>>>        Function_Return hoSQLHandler
86987>>>    End_Function
86988>>>
86988>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
86990>>>        Boolean bOK bMertechDriver
86990>>>
86990>>>        Get IsDAWSQLDriver sDriverID to bOK
86991>>>
86991>>>        If (bOK = False) Begin
86993>>>            Get IsMertechDriver sDriverID to bOK
86994>>>        End
86994>>>>
86994>>>
86994>>>        If (bOK = False) Begin
86996>>>            Get IsMertechDriver sDriverID to bMertechDriver
86997>>>            If (bMertechDriver = True) Begin
86999>>>                Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID, ODBC_DRV_ID, SQLFLEX, ORAFLEX, MDSPgSQL or MDSMYSQL"
87000>>>>
87000>>>            End
87000>>>>
87000>>>            Else Begin
87001>>>                Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID or ODBC_DRV_ID"
87002>>>>
87002>>>            End
87002>>>>
87002>>>            Function_Return False
87003>>>        End
87003>>>>
87003>>>
87003>>>        Function_Return True
87004>>>    End_Function
87005>>>
87005>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
87007>>>        Boolean bOK
87007>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
87008>>>        Function_Return bOK
87009>>>    End_Function
87010>>>
87010>>>    Function IsMertechDriver String sDriverID Returns Boolean
87012>>>        Boolean bOK
87012>>>        Move False to bOK
87013>>>            Move (sDriverID = SQLFLEX or sDriverID = ORAFLEX or sDriverID = MDSPgSQL or sDriverID = MDSMYSQL) to bOK
87014>>>        Function_Return bOK
87015>>>    End_Function
87016>>>
87016>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
87018>>>        Handle hoIniFile
87018>>>        String sConnect
87018>>>
87018>>>        Get phoSQLConnectionIniFile to hoIniFile
87019>>>        Get ConstructConnectionString of hoIniFile sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnect
87020>>>
87020>>>        Function_Return sConnect
87021>>>    End_Function
87022>>>
87022>>>    // Sample sConnString: "SERVER=(local)\SQLEXPRESS;UID=dbuser;PWD=secret;DATABASE=OrderEntry;, 0"
87022>>>    // Pass a complete driver connection string
87022>>>    // Returns the following as a struct:
87022>>>    //   sServer, sDatabase, sUser, sPassword & True if Trusted_Connection is used.
87022>>>    // Finally also returns a boolean TRUE if trusted_connection=yes, else false is returned.
87022>>>    //
87022>>>    Function DeComposeConnectionString String sDriverID String sConnectionString Returns tSQLConnection
87024>>>        tSQLConnection SQLConnection
87024>>>        tSQLConnection SQLConnection
87024>>>        String sValue sConnectionID sServer sDatabase sUserID sPassword
87024>>>        Boolean bTrusted bSilent bOK
87024>>>        Integer iPos
87024>>>
87024>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
87025>>>        If (bOK = False) Begin
87027>>>            Function_Return SQLConnection
87028>>>        End
87028>>>>
87028>>>
87028>>>        Move False to bTrusted
87029>>>        Move False to bSilent
87030>>>
87030>>>        Case Begin
87030>>>            Case (sDriverID = MSSQLDRV_ID)
87032>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
87033>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
87034>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
87035>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
87036>>>                If (bTrusted = False) Begin
87038>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
87039>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
87040>>>                End
87040>>>>
87040>>>                Case Break
87041>>>
87041>>>            Case (sDriverID = ODBC_DRV_ID)
87044>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
87045>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
87046>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
87047>>>                If (bTrusted = False) Begin
87049>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
87050>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
87051>>>                End
87051>>>>
87051>>>                Case Break
87052>>>
87052>>>            Case (sDriverID = DB2_DRV_ID)
87055>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
87056>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
87057>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
87058>>>                Case Break
87059>>>
87059>>>            Case (sDriverID = SQLFLEX)
87062>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
87063>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
87064>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
87065>>>                If (bTrusted = False) Begin
87067>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
87068>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
87069>>>                End
87069>>>>
87069>>>                Case Break
87070>>>
87070>>>            Case (sDriverID = ORAFLEX)
87073>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
87074>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
87075>>>                If (sDatabase <> "" and (not(sServer contains "/"))) Begin
87077>>>                    Move (sServer + "/" + sDatabase)                                to sServer
87078>>>                End
87078>>>>
87078>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
87079>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
87080>>>                Case Break
87081>>>
87081>>>            Case (sDriverID = MDSPgSQL)
87084>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
87085>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
87086>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
87087>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
87088>>>                Case Break
87089>>>
87089>>>            Case (sDriverID = MDSMySQL)
87092>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
87093>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
87094>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
87095>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
87096>>>                Case Break
87097>>>
87097>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
87100>>>                Break
87101>>>        Case End
87101>>>
87101>>>        Get ParseKeyWord sConnectionString (Uppercase(CS_SQLConnectionIDText))  to sConnectionID
87102>>>
87102>>>        // bSilent?
87102>>>        Move (Pos(",0", sConnectionString))                                     to iPos
87103>>>        If (iPos = 0) Begin
87105>>>            Move (Pos(",1", sConnectionString))                                 to iPos
87106>>>        End
87106>>>>
87106>>>        If (iPos = 0) Begin
87108>>>            Move "0"                                                            to sValue
87109>>>        End
87109>>>>
87109>>>        Else Begin
87110>>>            Move (Mid(sConnectionString, 1, (iPos +1)))                         to sValue
87111>>>        End
87111>>>>
87111>>>        Move (If(sValue = 1, True, False))                                      to bSilent
87112>>>
87112>>>        Move (Trim(sDriverID))                                                  to SQLConnection.sDriverID
87113>>>        Move (Trim(sConnectionID))                                              to SQLConnection.sConnectionID
87114>>>        Move (Trim(sConnectionString))                                          to SQLConnection.sConnectionString
87115>>>        Move (Trim(sServer))                                                    to SQLConnection.sServer
87116>>>        Move (Trim(sDatabase))                                                  to SQLConnection.sDatabase
87117>>>        Move bTrusted                                                           to SQLConnection.bTrusted
87118>>>        Move (Trim(sUserID))                                                    to SQLConnection.sUserID
87119>>>        Move (Trim(sPassword))                                                  to SQLConnection.sPassword
87120>>>        Move bSilent                                                            to SQLConnection.bSilentLogin
87121>>>
87121>>>        Function_Return SQLConnection
87122>>>    End_Function
87123>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
87123>>>>
87123>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
87125>>>>    Integer iStart iEnd
87125>>>>    String sRetval
87125>>>>
87125>>>>    Move (Trim(sConnect)) to sConnect
87126>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
87127>>>>    If (iStart = 0) Begin
87129>>>>        Function_Return ""
87130>>>>    End
87130>>>>>
87130>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
87131>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
87132>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
87134>>>>        Move (Pos(",", sRetval))          to iEnd
87135>>>>    End
87135>>>>>
87135>>>>    Else Begin
87136>>>>        Move (Pos(";", sRetval))          to iEnd
87137>>>>    End
87137>>>>>
87137>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
87139>>>>        Move (Pos(",", sRetval))          to iEnd
87140>>>>        Decrement iEnd
87141>>>>    End
87141>>>>>
87141>>>>    If (iEnd <> 0) Begin
87143>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
87144>>>>    End
87144>>>>>
87144>>>>    Move (Replace("=", sRetval, ""))      to sRetval
87145>>>>
87145>>>>    Function_Return (Trim(sRetval))
87146>>>>End_Function
87147>>>>
87147>>>>
87147>>>
87147>>>    // To update the SQLSettings.ini file with updated connection data (SQLConnection struct data).
87147>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
87149>>>        Handle ho
87149>>>        Integer iIndex
87149>>>        Boolean bRetval bOK
87149>>>        tSQLConnection SQLConnection
87149>>>        tSQLConnection SQLConnection
87149>>>
87149>>>        Get pSQLConnection to SQLConnection
87150>>>        Get phoSQLConnectionIniFile to ho
87151>>>        Get SQLIniFileConnectionIDIndex of ho sConnectionID to iIndex
87152>>>        If (iIndex = -1) Begin
87154>>>            Function_Return False
87155>>>        End
87155>>>>
87155>>>
87155>>>        Get SQLIniFileUpdateConnection of ho SQLConnection to bRetval
87156>>>        Send UpdateConnectionString of ghoSQLConnectionHandler SQLConnection
87157>>>        If (ghoConnection > 0) Begin
87159>>>            Get ConnectionIdIndex of ghoConnection SQLConnection.sConnectionID to iIndex
87160>>>            If (iIndex <> -1) Begin
87162>>>                Get RedirectConnectionId of ghoConnection SQLConnection.sConnectionID (SQLConnection.sServer + ";" + CS_SQLIniDatabaseKeyword + "=" + SQLConnection.sDatabase) SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted True to bOK
87163>>>            End
87163>>>>
87163>>>        End
87163>>>>
87163>>>
87163>>>        Function_Return bRetval
87164>>>    End_Function
87165>>>
87165>>>End_Class
87166>Object oSQLConnectionHandler is a cSQLConnectionHandler
87168>    // If a file was passed on the command line - which can be done from the Studio -
87168>    // we change the ini-file path here. (The name is always the same)
87168>    Procedure End_Construct_Object
87171>        String sPath
87171>        Boolean bExists
87171>        Get psCommandLineIniFilePath of ghoApplication to sPath
87172>        If (sPath <> "") Begin
87174>            Set psIniFilePath to sPath
87175>        End
87175>        Else Begin
87176>            Get psProgramPath of (phoWorkspace(ghoApplication)) to sPath
87177>            Set psIniFilePath to sPath
87178>            Get vFolderFormat sPath to sPath
87179>            Get vFilePathExists (sPath + CS_SQLIniFileName) to bExists
87180>            Set pbIniFileExists of ghoApplication to bExists
87181>        End
87181>        Forward Send End_Construct_Object
87183>    End_Procedure
87184>End_Object
87185>
87185>Use cDbUpdateFunctionLibrary.pkg
Including file: cDbUpdateFunctionLibrary.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.pkg)
87185>>>//****************************************************************************
87185>>>// $Module type: Class
87185>>>// $Module name: cDbUpdateFunctionLibrary
87185>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
87185>>>// Web-site    : http://www.rdctools.com
87185>>>// Created     : 2014-09-05 @ 09:50 (Military date format: YY-MM-DD)
87185>>>//
87185>>>// Description : The class consists of a function library for database manipulations, aka make changes to a database.
87185>>>//               It has top level functions that uses the DataFlex db API, _but_ also specialized
87185>>>//               functions to make db changes to Sql databases with the DAW & Mertech drivers,
87185>>>//               with the help of Sql-scripts.
87185>>>//
87185>>>// $Rev History:
87185>>>//    2014-09-05  Module header created
87185>>>//
87185>>>//****************************************************************************
87185>>>Use cApplication.pkg
87185>>>Use seq_chnl.pkg
87185>>>Use GlobalFunctionsProcedures.pkg
87185>>>Use Datadict.pkg                        // Declaration of DF_FILE_SQL_TABLE_NAME
87185>>>Use DUFStatusPanel.pkg
Including file: DUFStatusPanel.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\DUFStatusPanel.pkg)
87185>>>>>// StatPnl.pkg - creates the standard status_panel object.
87185>>>>>//
87185>>>>>//
87185>>>>>// This is the default Status Panel object used by any of the Visual DataFlex classes that
87185>>>>>// invoke the standard status panel. The standard has always been that the package name
87185>>>>>// is StatPnl.pkg and the name of the object is Status_Panel. As of 12.0, there are major
87185>>>>>// changes in the way the status panel operates The Sentinel based external status panel used in
87185>>>>>// prior revisions has been replace with status panel that is part of the application.
87185>>>>>// This should work much better and faster than the old sentinel based solution.
87185>>>>>// While the way this operates has changed, the interface has not and therefore this should work
87185>>>>>// with most applications.
87185>>>>>//
87185>>>>>// As of 12.0, we have added a global handle that contains the object ID of this status panel.
87185>>>>>// This variable ghoStatusPanel can be used in place of the object name Status_Panel. This provides
87185>>>>>// a cleaner more robust interface.
87185>>>>>//
87185>>>>>//
87185>>>>>// Compatibility Note:
87185>>>>>//
87185>>>>>// When used in the standard way, this change will require no changes. A developer will only need to
87185>>>>>// change their code if they've modified the sentinel program, which was a difficult thing to do.
87185>>>>>//
87185>>>>>// If for some reason you application will not work using this as a replacement for the old status
87185>>>>>// panel, you've probably done something special with the old status-panel. If you don't want to
87185>>>>>// figure out how to use the new one and you want to continue using the old one you are going to need
87185>>>>>// to add some code to include the old status panel in your application. Add the following to your project (your src).
87185>>>>>//
87185>>>>>// Use StatPnl.pkg    // Make sure you load the new status panel object first. this is not optional!
87185>>>>>// Use OldStatPnl.pkg // load the old status panel. Status_Panel is now this old object
87185>>>>>//
87185>>>>>// If you do this, you will lose access to the new status-panel via Status_Panel. However, you
87185>>>>>// can still access the new object via the ghoStatusPanel handle.
87185>>>>>//
87185>>>>>//
87185>>>>>// Creating your own Status Panel objects
87185>>>>>//
87185>>>>>// If a developer wishes to create a custom panel, they should use this package as their template.
87185>>>>>// This panel can be visually modeled and changed any way you wish. Just save your new custom panel
87185>>>>>// with a different file and object name and direct your status panel request to the new object.
87185>>>>>//
87185>>>>>// If the new panel changes the interface and updates objects that are not currently defined, you
87185>>>>>// want to make sure you send the message ProcessEvents after you've updated the object. This allows
87185>>>>>// the object to paint when inside of a tight loop. For example, if you wanted to add a progress
87185>>>>>// bar (cProgressBar) you would want to Send ProcessEvents after you update the progress bar.
87185>>>>>// e.g.
87185>>>>>//       Procedure UpdateStatusBar
87185>>>>>//           Send DoAdvance of oProgressBar
87185>>>>>//           Send ProcessEvents
87185>>>>>//       End_Procedure
87185>>>>>//
87185>>>>>// of course, if you use the standard interfaces in status bar and your forward send these
87185>>>>>// messages this will be done for you.
87185>>>>>//
87185>>>>>// the standard Interface for status panels are:
87185>>>>>//
87185>>>>>// Send Initialize_StatusPanel - initializes values for caption, title & message
87185>>>>>// Send Start_StatusPanel      - start the status panel
87185>>>>>// Send Stop_StatusPanel       - stop the status panel
87185>>>>>// Send Update_StatusPanel     - update the status panel's action area
87185>>>>>// Get  Check_StatusPanel      - check for cancel (if cancel or pbCancel is set, close the panel)
87185>>>>>//
87185>>>>>// Get/Set Caption_Text - updates the caption bar
87185>>>>>// Get/Set Title_Text   - updates the title area
87185>>>>>// Get/Set Message_Text - updates the Message area
87185>>>>>// Get/Set Action_Text  - updates the action area
87185>>>>>// Get/Set Button_Text  - updates the button area
87185>>>>>//
87185>>>>>// Get/Set Allow_cancel_state - determines if panel can be canceled
87185>>>>>// Send EnableCancelButton - code you should provide to enable/disable cancel button
87185>>>>>//
87185>>>>>// ghoStatusPanel - global handle that points to the standard status panel.
87185>>>>>Use cProcessStatusPanel.pkg
87185>>>>>Use cCJSkinFramework.pkg
87185>>>>>Use cProgressBar.pkg
Including file: cProgressBar.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cProgressBar.pkg)
87185>>>>>>>Use Windows.pkg
87185>>>>>>>Use cWinControl.pkg
87185>>>>>>>Use CommCtrl.pkg
87185>>>>>>>
87185>>>>>>>Type tPbRange
87185>>>>>>>    Field tPbRange.iLow  as DWord
87185>>>>>>>    Field tPbRange.iHigh as DWord
87185>>>>>>>End_Type
87185>>>>>>>
87185>>>>>>>//{ OverrideProperty=pbEnabled DesignTime=False }
87185>>>>>>>Class cProgressBar is a cWinControl
87186>>>>>>>
87186>>>>>>>    Procedure Construct_Object
87188>>>>>>>        Forward Send Construct_Object
87190>>>>>>>        Property Integer private_piMinimum
87191>>>>>>>        Property Integer private_piMaximum   100
87192>>>>>>>        Property Integer private_piAdvanceBy 10
87193>>>>>>>        Property Integer private_piPosition
87194>>>>>>>        Property Integer private_pbVertical  False
87195>>>>>>>        Property Integer private_pbSmooth    False
87196>>>>>>>        Property Integer private_piBackColor clDefault
87197>>>>>>>        Property Integer private_piBarColor  clDefault
87198>>>>>>>
87198>>>>>>>        Send Define_ToolTip_Support_Mixin
87199>>>>>>>
87199>>>>>>>        Set External_Class_Name 'cVdfProgressBar' To 'msctls_progress32'
87200>>>>>>>        Set Focus_Mode to NonFocusable
87201>>>>>>>        Set Skip_State to True
87202>>>>>>>        Set pbUseFormWindowHandle to False     // Must come after Define_ToolTip_Support_Mixin
87203>>>>>>>    End_Procedure
87204>>>>>>>
87204>>>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
87205>>>>>>>
87205>>>>>>>    Procedure Set piMinimum Integer iMin
87207>>>>>>>        Integer iMax
87207>>>>>>>
87207>>>>>>>        Set private_piMinimum to iMin
87208>>>>>>>        Get private_piMaximum To iMax
87209>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
87210>>>>>>>    End_Procedure
87211>>>>>>>    Function piMinimum Returns Integer
87213>>>>>>>        If (Window_Handle(self)) Function_Return (WindowsMessage(PBM_GETRANGE, 1, 0))
87216>>>>>>>        Else Function_Return (private_piMinimum(self))
87218>>>>>>>    End_Function
87219>>>>>>>
87219>>>>>>>    Procedure Set piMaximum Integer iMax
87221>>>>>>>        Integer iMin
87221>>>>>>>
87221>>>>>>>        Set private_piMaximum to iMax
87222>>>>>>>        Get private_piMinimum To iMin
87223>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
87224>>>>>>>    End_Procedure
87225>>>>>>>    Function piMaximum Returns Integer
87227>>>>>>>        If (Window_Handle(self)) Function_Return (WindowsMessage(PBM_GETRANGE, 0, 0))
87230>>>>>>>        Else Function_Return (private_piMaximum(self))
87232>>>>>>>    End_Function
87233>>>>>>>
87233>>>>>>>    Procedure Set piAdvanceBy Integer iAdvanceBy
87235>>>>>>>        Set private_piAdvanceBy To iAdvanceBy
87236>>>>>>>        Send Windows_Message PBM_SETSTEP iAdvanceBy 0
87237>>>>>>>    End_Procedure
87238>>>>>>>    Function piAdvanceBy Returns Integer
87240>>>>>>>        Function_Return (private_piAdvanceBy(self))
87241>>>>>>>    End_Function
87242>>>>>>>
87242>>>>>>>    Procedure Set piPosition Integer iPos
87244>>>>>>>        Set private_piPosition To iPos
87245>>>>>>>        Send Windows_Message PBM_SETPOS iPos 0
87246>>>>>>>    End_Procedure
87247>>>>>>>
87247>>>>>>>    Function piPosition Returns Integer
87249>>>>>>>        If (Window_Handle(self)) Function_Return (WindowsMessage(PBM_GETPOS, 0, 0))
87252>>>>>>>        Else Function_Return (private_piPosition(self))
87254>>>>>>>    End_Function
87255>>>>>>>
87255>>>>>>>    Procedure Set pbVertical Boolean bVertical
87257>>>>>>>        If (private_pbVertical(self) <> bVertical) Begin
87259>>>>>>>            Set private_pbVertical To bVertical
87260>>>>>>>           Send DoRecreateWindow
87261>>>>>>>        End
87261>>>>>>>>
87261>>>>>>>    End_Procedure
87262>>>>>>>
87262>>>>>>>    Function pbVertical Returns Boolean
87264>>>>>>>        Function_Return (private_pbVertical(self))
87265>>>>>>>    End_Function
87266>>>>>>>
87266>>>>>>>    Procedure Set pbSmooth Boolean bSmooth
87268>>>>>>>        If (private_pbSmooth(self) <> bSmooth) Begin
87270>>>>>>>           Set private_pbSmooth To bSmooth
87271>>>>>>>           Send DoRecreateWindow
87272>>>>>>>        End
87272>>>>>>>>
87272>>>>>>>    End_Procedure
87273>>>>>>>    Function pbSmooth Returns Boolean
87275>>>>>>>        Function_Return (private_pbSmooth(self))
87276>>>>>>>    End_Function
87277>>>>>>>
87277>>>>>>>    Procedure Set piBackColor Integer rgbColor
87279>>>>>>>        Set private_piBackColor To rgbColor
87280>>>>>>>        Send Windows_Message PBM_SETBKCOLOR 0 rgbColor
87281>>>>>>>    End_Procedure
87282>>>>>>>    Function piBackColor Returns Integer
87284>>>>>>>        Function_Return (private_piBackColor(self))
87285>>>>>>>    End_Function
87286>>>>>>>
87286>>>>>>>    Procedure Set piBarColor Integer rgbColor
87288>>>>>>>        Set private_piBarColor To rgbColor
87289>>>>>>>        Send Windows_Message PBM_SETBARCOLOR 0 rgbColor
87290>>>>>>>    End_Procedure
87291>>>>>>>    Function piBarColor Returns Integer
87293>>>>>>>        Function_Return (private_piBarColor(self))
87294>>>>>>>    End_Function
87295>>>>>>>
87295>>>>>>>    Procedure DoAdvance
87297>>>>>>>        Send Windows_Message PBM_STEPIT 0 0
87298>>>>>>>    End_procedure
87299>>>>>>>
87299>>>>>>>    Procedure DoAdvanceBy  Integer iAdvanceBy
87301>>>>>>>        Send Windows_Message PBM_DELTAPOS iAdvanceBy 0
87302>>>>>>>    End_procedure
87303>>>>>>>
87303>>>>>>>    Procedure private_DoInitWindow
87305>>>>>>>        Set piBarColor  To (private_piBarColor(self))
87306>>>>>>>        Set piBackColor To (private_piBackColor(self))
87307>>>>>>>        Set piAdvanceBy To (private_piAdvanceBy(self))
87308>>>>>>>        Set piMinimum   To (private_piMinimum(self))
87309>>>>>>>        Set piMaximum   To (private_piMaximum(self))
87310>>>>>>>        Set piPosition  To (private_piPosition(self))
87311>>>>>>>    End_Procedure
87312>>>>>>>
87312>>>>>>>    Procedure Page_Object Integer iState
87314>>>>>>>        Handle hWnd
87314>>>>>>>
87314>>>>>>>        Get Window_Handle To hWnd
87315>>>>>>>        If (hWnd=0 and iState) Begin
87317>>>>>>>            Set Window_Style To PBS_VERTICAL (private_pbVertical(self))
87318>>>>>>>            Set Window_Style To PBS_SMOOTH   (private_pbSmooth(self))
87319>>>>>>>            Forward Send Page_Object True
87321>>>>>>>        End
87321>>>>>>>>
87321>>>>>>>        Else Forward Send Page_Object iState
87324>>>>>>>     
87324>>>>>>>        // Handle tooltip support....
87324>>>>>>>        If (iState = 0) Begin
87326>>>>>>>            Send RequestDeleteToolTip
87327>>>>>>>        End 
87327>>>>>>>>
87327>>>>>>>        Else Begin
87328>>>>>>>            Send RequestAddToolTip
87329>>>>>>>        End
87329>>>>>>>>
87329>>>>>>>    End_Procedure
87330>>>>>>>
87330>>>>>>>    Procedure Page Integer iState
87332>>>>>>>        Forward Send Page iState
87334>>>>>>>        If (iState =1) Send private_DoInitWindow
87337>>>>>>>    End_Procedure
87338>>>>>>>
87338>>>>>>>    // Called by Page_Object. Handles tooltip creation. We use a dedicated
87338>>>>>>>    // method to perform AddToolTip because it is often the case that Page_Object
87338>>>>>>>    // is implemented in a mixin class.
87338>>>>>>>    Procedure RequestAddToolTip
87340>>>>>>>        Send AddToolTip
87341>>>>>>>    End_Procedure  // RequestAddToolTip
87342>>>>>>>
87342>>>>>>>
87342>>>>>>>    // Called by Page_Object. Handles tooltip removal. 
87342>>>>>>>    Procedure RequestDeleteToolTip
87344>>>>>>>        Send DeleteToolTip
87345>>>>>>>    End_Procedure // RequestDeleteToolTip
87346>>>>>>>End_Class
87347>>>>>Use Windows.pkg
87347>>>>>
87347>>>>>
87347>>>>>    Global_Variable Handle ghoProgressBar // will contain the ID of the embedded progress bar.
87347>>>>>
87347>>>>>    Global_Variable Handle ghoProgressBarOverall // will contain the ID of the embedded progress bar with overall results
87347>>>>>
87347>>>>>Object Status_Panel is a cProcessStatusPanel
87349>>>>>    Set Size to 148 222
87350>>>>>    Set Border_Style to Border_Dialog
87351>>>>>//    Set Sysmenu_Icon to False
87351>>>>>//    Set Icon to "DbUpdateFrameworkdf19.ico" 
87351>>>>>    Set Icon to "Default.ico"
87352>>>>>    Move Self to ghoStatusPanel // this can be used throughout the applicaton to access this object
87353>>>>>
87353>>>>>    Property Boolean Cancel_Button_Visible_State True
87355>>>>>
87355>>>>>    Procedure Activate
87358>>>>>        Integer iSizeBefore
87358>>>>>        Get GuiSize to iSizeBefore
87359>>>>>        Forward Send Activate
87361>>>>>        Set GuiSize to (Hi(iSizeBefore)) (Low(iSizeBefore))
87362>>>>>    End_Procedure
87363>>>>>
87363>>>>>    Procedure End_Construct_Object
87366>>>>>        Forward Send End_Construct_Object
87368>>>>>        Set Label of oTitleTxt      to ""
87369>>>>>        Set Label of oTableNameTxt  to ""
87370>>>>>        Set Label of oMessageTxt    to ""
87371>>>>>        Set Label of oActionTxt     to ""
87372>>>>>    End_Procedure
87373>>>>>
87373>>>>>    Object oTitleTxt is a TextBox
87375>>>>>        Set Location to 5 21
87376>>>>>        Set Size to 8 179
87377>>>>>        Set Auto_Size_State to False
87378>>>>>        Set Justification_Mode  to jMode_Center
87379>>>>>        Set Label to "This is the Title Text"
87380>>>>>    End_Object
87381>>>>>
87381>>>>>    Object oTableNameTxt is a TextBox
87383>>>>>        Set Size to 19 204
87384>>>>>        Set Location to 18 9
87385>>>>>        Set Auto_Size_State to False
87386>>>>>        Set Justification_Mode to JMode_Left
87387>>>>>        Set Label to "This is the TableName Text"
87388>>>>>    End_Object
87389>>>>>
87389>>>>>    Object oMessageTxt is a TextBox
87391>>>>>        Set Location to 39 9
87392>>>>>        Set Size to 19 204
87393>>>>>        Set Auto_Size_State to False
87394>>>>>        Set Justification_Mode to JMode_Left
87395>>>>>        Set Label to "This is the Message text"
87396>>>>>    End_Object
87397>>>>>
87397>>>>>    Object oActionTxt is a TextBox
87399>>>>>        Set Size to 16 204
87400>>>>>        Set Location to 60 9
87401>>>>>        Set Auto_Size_State to False
87402>>>>>        Set Justification_Mode to JMode_Left
87403>>>>>        Set Label to "This is the Action Text"
87404>>>>>    End_Object
87405>>>>>
87405>>>>>    Object oStopButton is a Button
87407>>>>>        Set Location to 120 82
87408>>>>>        Set Label to C_$Cancel
87409>>>>>
87409>>>>>        Procedure OnClick
87412>>>>>            Send Close_panel
87413>>>>>        End_Procedure
87414>>>>>
87414>>>>>    End_Object
87415>>>>>
87415>>>>>    Object oPercentage_tb is a TextBox
87417>>>>>        Set Location to 74 196
87418>>>>>        Set Size to 10 25
87419>>>>>//        Set Label to "% Done"
87419>>>>>    End_Object
87420>>>>>
87420>>>>>    Object oCopyRight is a TextBox
87422>>>>>        Set Location to 137 21
87423>>>>>        Set Size to 9 197
87424>>>>>        Set FontPointHeight to 8
87425>>>>>        Set Auto_Size_State to False
87426>>>>>        Set Justification_Mode  to jMode_Center
87427>>>>>        Set Label to "Copyright 2001-2018 RDC Tools International"
87428>>>>>    End_Object
87429>>>>>
87429>>>>>    Object oProgressBar is a cProgressBar
87431>>>>>        Set Size to 10 179
87432>>>>>        Set Location to 83 22
87433>>>>>        Set pbVisible to True // default
87434>>>>>        Move Self to ghoProgressBar // this can be used throughout your application to access the progress bar
87435>>>>>    End_Object
87436>>>>>
87436>>>>>    Procedure Set Progress_Bar_Visible_State Boolean bVisible
87439>>>>>        Set pbVisible of ghoProgressBar to bVisible
87440>>>>>    End_Procedure
87441>>>>>
87441>>>>>    Function Progress_Bar_Visible_State Returns Boolean
87444>>>>>        Boolean bVisible
87444>>>>>        Get pbVisible of ghoProgressBar to bVisible
87445>>>>>        Function_Return (bVisible)
87446>>>>>    End_Function
87447>>>>>
87447>>>>>    Object oProgressBarOverall is a cProgressBar
87449>>>>>        Set Size to 10 179
87450>>>>>        Set Location to 104 22
87451>>>>>        Set pbVisible to True // default
87452>>>>>        Move Self to ghoProgressBarOverall // this can be used throughout your application to access the progress bar
87453>>>>>    End_Object
87454>>>>>
87454>>>>>    Object oOverallProgress_tb is a TextBox
87456>>>>>        Set Size to 10 65
87457>>>>>        Set Location to 95 24
87458>>>>>        Set Label to "Overall Progress"
87459>>>>>    End_Object
87460>>>>>
87460>>>>>    Procedure Set Progress_Bar_Overall_Visible_State Boolean bVisible
87463>>>>>        Set pbVisible of ghoProgressBarOverall to bVisible
87464>>>>>    End_Procedure
87465>>>>>
87465>>>>>    Function Progress_Bar_Overall_Visible_State Returns Boolean
87468>>>>>        Boolean bVisible
87468>>>>>        Get pbVisible of ghoProgressBarOverall to bVisible
87469>>>>>        Function_Return (bVisible)
87470>>>>>    End_Function
87471>>>>>
87471>>>>>    // These messages bind the standard cProcessStatusPanel interface to the actual
87471>>>>>    // objects defined within this instance of the status panel.
87471>>>>>
87471>>>>>    // note: all of the messages that change text should be forwarded
87471>>>>>    // as the forwarded messages allows the panel to paint when in a tight loop
87471>>>>>
87471>>>>>    Procedure Set Message_Text String sText
87474>>>>>        Set Label of oMessageTxt to sText
87475>>>>>        Forward Set Message_Text to sText
87477>>>>>    End_Procedure
87478>>>>>
87478>>>>>    Function Message_Text Returns String
87481>>>>>        Function_Return (Label(oMessageTxt))
87482>>>>>    End_Function
87483>>>>>
87483>>>>>    Procedure Set Action_Text String sText
87486>>>>>        Set Label of oActionTxt to sText
87487>>>>>        Forward Set Action_Text to sText
87489>>>>>    End_Procedure
87490>>>>>
87490>>>>>    Function Action_Text Returns String
87493>>>>>        Function_Return (Label(oActionTxt))
87494>>>>>    End_Function
87495>>>>>
87495>>>>>    Procedure Set Button_Text String sText
87498>>>>>        Set Label of oStopButton to sText
87499>>>>>        Forward Set Button_Text to sText
87501>>>>>    End_Procedure
87502>>>>>
87502>>>>>    Function Button_Text Returns String
87505>>>>>        Function_Return (Label(oStopButton))
87506>>>>>    End_Function
87507>>>>>
87507>>>>>    Procedure Set Title_Text String sText
87510>>>>>        Set Label of oTitleTxt to sText
87511>>>>>        Forward Set Title_Text to sText
87513>>>>>    End_Procedure
87514>>>>>
87514>>>>>    Function Title_Text Returns String
87517>>>>>        Function_Return (Label(oTitleTxt))
87518>>>>>    End_Function
87519>>>>>
87519>>>>>    Procedure Set TableName_Text String sText
87522>>>>>        Set Label of oTableNameTxt to sText
87523>>>>>    End_Procedure
87524>>>>>
87524>>>>>    Function TableName_Text Returns String
87527>>>>>        Function_Return (Label(oTableNameTxt))
87528>>>>>    End_Function
87529>>>>>
87529>>>>>    Procedure Set License_Text String sText
87532>>>>>//        Set Label of oLicense_txt to sText
87532>>>>>    End_Procedure
87533>>>>>
87533>>>>>    // gets called when status panel is activated passing whether a button
87533>>>>>    // should appear
87533>>>>>    Procedure EnableCancelButton Boolean bEnable
87536>>>>>        Boolean bVisible
87536>>>>>        Get Cancel_Button_Visible_State to bVisible
87537>>>>>        If (bEnable = False) Begin
87539>>>>>            Set Visible_State of oStopButton to bVisible
87540>>>>>        End
87540>>>>>>
87540>>>>>        Set Enabled_State of oStopButton to bEnable
87541>>>>>    End_Procedure
87542>>>>>
87542>>>>>    Procedure Reset_StatusPanel
87545>>>>>        Set Allow_Cancel_State of ghoStatusPanel to True
87546>>>>>        Set Cancel_Button_Visible_State of ghoStatusPanel to True
87547>>>>>        Set Progress_Bar_Visible_State  of ghoStatusPanel to True
87548>>>>>        Set Progress_Bar_Overall_Visible_State of ghoProgressBarOverall to False
87549>>>>>    End_Procedure
87550>>>>>
87550>>>>>//    Object oProgressBar is a cProgressBar
87550>>>>>//        Move Self to ghoProgressBar
87550>>>>>//        Set Location to 1 25
87550>>>>>//        Set Size to 9 173
87550>>>>>//        Set piMinimum        to 0
87550>>>>>//        Set piMaximum        to 2000
87550>>>>>//        Set piAdvanceBy      to 100
87550>>>>>//        Set pbSmooth to True
87550>>>>>//
87550>>>>>//        // For some weird reason the application skin makes the coloring of the progressbar
87550>>>>>//        // to malfunction. By telling the CodeJock SkinFramework to skip this object, the
87550>>>>>//        // color will show correctly.
87550>>>>>//        Procedure Page Integer iPageObject
87550>>>>>//            Handle hWin
87550>>>>>//            Forward Send Page iPageObject
87550>>>>>//            If (ghoSkinFramework <> 0) Begin
87550>>>>>//                Get Window_Handle to hWin
87550>>>>>//                Send ComRemoveWindow of ghoSkinFramework hWin
87550>>>>>//            End
87550>>>>>//        End_Procedure
87550>>>>>//    End_Object
87550>>>>>
87550>>>>>End_Object
87551>>>>>
87551>>>Use cDbUpdateFunctionLibrary.inc        // Various constant definitions, structs etc.
87551>>>Use cDbUpdateFunctionLibrary_Mixin.pkg  // Properties used by the cDbUpdateFunctionLibrary class.
87551>>>Use cSQLConnectionHandler.pkg
87551>>>Use vWin32fh.pkg
87551>>>
87551>>>//
87551>>>Class cDbUpdateFunctionLibrary is a cObject
87552>>>    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
Including file: ParseKeyWord.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
87553>>>>
87553>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
87555>>>>    Integer iStart iEnd
87555>>>>    String sRetval
87555>>>>
87555>>>>    Move (Trim(sConnect)) to sConnect
87556>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
87557>>>>    If (iStart = 0) Begin
87559>>>>        Function_Return ""
87560>>>>    End
87560>>>>>
87560>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
87561>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
87562>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
87564>>>>        Move (Pos(",", sRetval))          to iEnd
87565>>>>    End
87565>>>>>
87565>>>>    Else Begin
87566>>>>        Move (Pos(";", sRetval))          to iEnd
87567>>>>    End
87567>>>>>
87567>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
87569>>>>        Move (Pos(",", sRetval))          to iEnd
87570>>>>        Decrement iEnd
87571>>>>    End
87571>>>>>
87571>>>>    If (iEnd <> 0) Begin
87573>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
87574>>>>    End
87574>>>>>
87574>>>>    Move (Replace("=", sRetval, ""))      to sRetval
87575>>>>
87575>>>>    Function_Return (Trim(sRetval))
87576>>>>End_Function
87577>>>>
87577>>>>
87577>>>
87577>>>    Procedure Construct_Object
87579>>>        Handle ho
87579>>>        Forward Send Construct_Object
87581>>>
87581>>>        Move Self to ghoDbUpdateFunctionLibrary
87582>>>
87582>>>        Send CreateDbUpdateLibraryProperties
87583>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
87583>>>        // we will create one as it is used for all ConnectionID, ConnectionString
87583>>>        // etc settings.
87583>>>        If (ghoSQLConnectionHandler = 0) Begin
87585>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
87586>>>            Set phoSQLConnectionHandler to ho
87587>>>        End
87587>>>>
87587>>>
87587>>>    End_Procedure
87588>>>
87588>>>    Procedure End_Construct_Object
87590>>>        Forward Send End_Construct_Object
87592>>>    End_Procedure
87593>>>
87593>>>    // *** SQL Messages for making changes to the SQL back-end ***
87593>>>    //
87593>>>    // * Dummy function for the Studio's Code Explorer *
87593>>>    Function SQL_DATABASE_FUNCTIONS Returns Boolean
87595>>>        Function_Return False
87596>>>    End_Function
87597>>>
87597>>>    // Function for creating a new *Database*.
87597>>>    // Note: This is for creating SQL DATABASES - not tables!
87597>>>    // Returns True if successful.
87597>>>    // ToDo: Only works for MS-SQL...
87597>>>    Function SqlDatabaseCreate String sDriverID String sDatabase Boolean bUpdateConnectionString Boolean bPermanantly Returns Boolean
87599>>>        String sSQL sSQL1 sConnectionID sConnectionString 
87599>>>        String sCreateDatabaseKeyWord sSelectFromWhereName sCollation sCollateKeyWord
87599>>>        Handle hConnection hStmt hoSQLManager
87599>>>        Integer iFetchResult iDbType
87599>>>        Boolean bOK bMertechDriver
87599>>>
87599>>>        Get piDbType to iDbType
87600>>>        If (iDbType <> EN_DbTypeMSSQL) Begin
87602>>>            Error DFERR_PROGRAM "Sorry, the SqlDatabaseCreate function is currently only supported for MS-SQL"
87603>>>>
87603>>>            Function_Return False
87604>>>        End
87604>>>>
87604>>>
87604>>>        Get IsMertechDriver sDriverID to bMertechDriver
87605>>>        If (bMertechDriver = False) Begin
87607>>>            Get phoSQLManager to hoSQLManager
87608>>>        End
87608>>>>
87608>>>        Else Begin
87609>>>            Get _MertechSQLManagerHandle to hoSQLManager
87610>>>        End
87610>>>>
87610>>>        
87610>>>        Get psConnectionID     to sConnectionID
87611>>>        Get psConnectionString to sConnectionString
87612>>>        Move 0 to LastErr
87613>>>
87613>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
87614>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
87615>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
87616>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
87618>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
87619>>>>
87619>>>            Function_Return False
87620>>>        End
87620>>>>
87620>>>
87620>>>        Get SqlOpen of hConnection to hStmt
87621>>>
87621>>>        If (hStmt = 0) Begin
87623>>>            Send SqlDisconnect of hoSQLManager
87624>>>            Error DFERR_PROGRAM CS_SQLConnectError
87625>>>>
87625>>>            Function_Return False
87626>>>        End
87626>>>>
87626>>>
87626>>>        Get _SqlFindKeyWord CI_SQLCreateDatabase to sCreateDatabaseKeyWord
87627>>>        Get _SqlSelectFromWhereName to sSelectFromWhereName
87628>>>        Move (sSelectFromWhereName + "='" + sDatabase + "'") to sSQL 
87629>>>        
87629>>>        // Check if database exists
87629>>>        Send SqlExecDirect of hStmt sSQL
87630>>>        Get SqlFetch of hStmt to iFetchResult
87631>>>        Send SqlClose of hStmt
87632>>>        Send SqlDisconnect of hConnection
87633>>>
87633>>>        // If database already exists we're out of here!
87633>>>        // Note that we return True as this is not an error.
87633>>>        If (iFetchResult > 0) Begin
87635>>>            Function_Return True
87636>>>        End
87636>>>>
87636>>>
87636>>>        // Database doesn't exist, create it.
87636>>>        If (iFetchResult = 0) Begin
87638>>>            Move (sCreateDatabaseKeyWord + " [" + sDatabase + "]") to sSQL1
87639>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
87640>>>
87640>>>            Get psCollation to sCollation
87641>>>            If (sCollation <> "") Begin
87643>>>                Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
87644>>>                Move (sSQL1 * String(sCollateKeyWord) * String(sCollation)) to sSQL1
87645>>>            End
87645>>>>
87645>>>
87645>>>            Send SqlUtilExecuteQuery sSQL1 sDriverID
87646>>>
87646>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
87647>>>            If (LastErr = CLIERR_GENERAL_ERROR) Begin
87649>>>               Function_Return False
87650>>>            End
87650>>>>
87650>>>
87650>>>            // We need to wait a short time for Sql to finish, especially Windows to write the new file to disk.
87650>>>            Sleep 1
87651>>>            Send SqlUtilExecuteQuery sSQL sDriverID
87652>>>        End
87652>>>>
87652>>>
87652>>>        // If used in e.g. the cDbUpdteHandler we want to change the login database name to
87652>>>        // the one we just created.
87652>>>        If (bUpdateConnectionString = True) Begin
87654>>>            Set psDatabase to sDatabase
87655>>>            //...and perhaps also the SQLConnections.ini file setting.
87655>>>            If (bPermanantly = True) Begin
87657>>>                If (ghoSQLConnectionHandler <> 0) Begin
87659>>>                    Get SQLIniFileSetDefaultConnection of ghoSQLConnectionHandler sConnectionID to bOK
87660>>>                End
87660>>>>
87660>>>            End
87660>>>>
87660>>>        End
87660>>>>
87660>>>
87660>>>        Function_Return (Err = False)
87661>>>    End_Function
87662>>>
87662>>>    // Backs up an SQL database to a folder of choice. If no path is passed the SQL default backup folder
87662>>>    // will be used.
87662>>>    Function SqlDatabaseBackupToDisk String sDatabase String sBackupName String sPath Boolean bShowProg Returns Boolean
87664>>>        Boolean bOK bExists bShowProgress
87664>>>        String sStatement sDriverID
87664>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
87664>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
87664>>>        Integer iDbType
87664>>>
87664>>>        If (sDatabase = "") Begin
87666>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
87667>>>>
87667>>>            Function_Return False
87668>>>        End
87668>>>>
87668>>>        If (sBackupName = "") Begin
87670>>>            Error DFERR_PROGRAM "The database backup name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
87671>>>>
87671>>>            Function_Return False
87672>>>        End
87672>>>>
87672>>>
87672>>>        // Create backup-folder if it doesn't exist
87672>>>        Get vFolderExists sPath to bExists
87673>>>        If (bExists = False) Begin
87675>>>            Get vCreateDirectory sPath to bOK
87676>>>            If (bOK = False) Begin
87678>>>                Error DFERR_PROGRAM ("Could not create database backup folder:" * sPath)
87679>>>>
87679>>>                Function_Return False
87680>>>            End
87680>>>>
87680>>>        End
87680>>>>
87680>>>        // Make sure the path ends with a back-slash
87680>>>        If (sPath <> "") Begin
87682>>>            Get vFolderFormat sPath to sPath
87683>>>        End
87683>>>>
87683>>>
87683>>>        Get psDriverID to sDriverID
87684>>>        Get piDbType   to iDbType
87685>>>        If (num_arguments > 3) Begin
87687>>>            Move bShowProg to bShowProgress
87688>>>        End
87688>>>>
87688>>>
87688>>>        Case Begin
87688>>>            Case (iDbType = EN_DbTypeMSSQL)
87690>>>                SQLIncludeScriptFile ..\Scripts\BackupMSSQLDatabase.sql as BackupMSSQLDatabase.sql
87690>>>                SQLIncludeScriptFile ..\Scripts\GetPercentageBackupCompletionMSSQL.sql as GetPercentageBackupCompletionMSSQL.sql
87690>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "BackupMSSQLDatabase.sql" sDriverID False to SQLScriptArray
87691>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "GetPercentageBackupCompletionMSSQL.sql" sDriverID False to SQLScriptArrayPercentReady
87692>>>
87692>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
87693>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase))   to sStatement
87694>>>                Move (Replaces("BACKUP_PATH_XXX",   sStatement, sPath))       to sStatement
87695>>>                Move (Replaces("BACKUP_NAME_XXX",   sStatement, sBackupName)) to sStatement
87696>>>                Move sStatement to SQLScriptArray.sSQLScriptArray[0]
87697>>>                Get SqlUtilExecuteEmbeddedScript of ghoDbUpdateFunctionLibrary SQLScriptArray sDriverID False "" bShowProgress to bOK
87698>>>                Case Break
87699>>>            Case Else
87699>>>                Send Info_Box ("The SqlUtilBackupDatabaseToDisk function is currently not implemented for the driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and add a little ESQL code snippet to make it work for that driver! Thanks for helping out.")
87700>>>        Case End
87700>>>
87700>>>        Function_Return bOK
87701>>>    End_Function
87702>>>
87702>>>    Function SqlDatabaseCollationQuery String sDatabase Returns String
87704>>>        Boolean bOK bExists 
87704>>>        String sStatement sDriverID sRetval sPrevious
87704>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
87704>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
87704>>>        Integer iDbType iRows iFetchResult iColumn
87704>>>        Handle hoSQLHandler hoSQLConnect hstmt 
87704>>>        tSQLConnection SQLConnection
87704>>>        tSQLConnection SQLConnection
87704>>>
87704>>>        If (sDatabase = "") Begin
87706>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilDatabaseCollation' function"
87707>>>>
87707>>>            Function_Return False
87708>>>        End
87708>>>>
87708>>>        
87708>>>        Move "" to sRetval
87709>>>        Get psDriverID to sDriverID
87710>>>        Get piDbType   to iDbType
87711>>>
87711>>>        Case Begin
87711>>>            Case (iDbType = EN_DbTypeMSSQL)
87713>>>                SQLIncludeScriptFile ..\Scripts\QueryMSSQLCollation.sql as QueryMSSQLCollation.sql
87713>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "QueryMSSQLCollation.sql" sDriverID False to SQLScriptArray
87714>>>
87714>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
87715>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase)) to sStatement
87716>>>                Get phoSQLManager to hoSQLHandler
87717>>>        
87717>>>                If (hoSQLHandler <> 0) Begin
87719>>>                    Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
87720>>>                    Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
87721>>>        
87721>>>                    If (hoSQLConnect <> 0) Begin
87723>>>                        Get SQLOpen of hoSQLConnect to hstmt
87724>>>                        If (hstmt <> 0) Begin
87726>>>                            Send SqlExecDirect of hstmt sStatement
87727>>>                            Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
87728>>>                            Get SQLFetch of hstmt to iFetchResult
87729>>>                            If (iFetchResult <> 0) Begin
87731>>>                                Get SQLColumnValue of hstmt 2 to sRetval // Column 1 = Database Name, 2 = Collation Name.
87732>>>                            End
87732>>>>
87732>>>                            Send SQLClose of hstmt
87733>>>                        End
87733>>>>
87733>>>                        Send SQLDisconnect of hoSQLConnect
87734>>>                    End
87734>>>>
87734>>>                End
87734>>>>
87734>>>                Case Break
87735>>>            Case Else
87735>>>                Send Info_Box ("The SqlDatabaseCollationQuery function is currently not implemented for the driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and add a little ESQL code snippet to make it work for that driver! Thanks for helping out.")
87736>>>        Case End
87736>>>
87736>>>        Function_Return sRetval
87737>>>    End_Function
87738>>>
87738>>>    Function SqlDatabaseCollationChange String sDatabase String sSQLCollation Returns Boolean
87740>>>        Boolean bOK bExists bMertechDriver
87740>>>        String sDriverID sSQL sSQL1 sConnectionID sConnectionString sSet sWith
87740>>>        String sAlterDatabaseKeyWord sCollateKeyWord sSQLCollationCheck sSingle_User sMulti_User sRollback sImmediate
87740>>>        Handle hConnection hStmt hoSQLManager
87740>>>        Integer iFetchResult iDbType
87740>>>
87740>>>        If (sDatabase = "") Begin
87742>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
87743>>>>
87743>>>            Function_Return False
87744>>>        End
87744>>>>
87744>>>        
87744>>>        If (sSQLCollation = "") Begin
87746>>>            Error DFERR_PROGRAM "The SQL Collation name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
87747>>>>
87747>>>            Function_Return False
87748>>>        End
87748>>>>
87748>>>        
87748>>>        Get psDriverID to sDriverID
87749>>>        Get piDbType   to iDbType
87750>>>
87750>>>        Get IsMertechDriver sDriverID to bMertechDriver
87751>>>        If (bMertechDriver = False) Begin
87753>>>            Get phoSQLManager to hoSQLManager
87754>>>        End
87754>>>>
87754>>>        Else Begin
87755>>>            Get _MertechSQLManagerHandle to hoSQLManager
87756>>>        End
87756>>>>
87756>>>        
87756>>>        Get psConnectionID     to sConnectionID
87757>>>        Get psConnectionString to sConnectionString
87758>>>        Move 0 to LastErr
87759>>>
87759>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
87760>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
87761>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
87762>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
87764>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
87765>>>>
87765>>>            Function_Return False
87766>>>        End
87766>>>>
87766>>>
87766>>>        Get SqlOpen of hConnection to hStmt
87767>>>
87767>>>        If (hStmt = 0) Begin
87769>>>            Send SqlDisconnect of hoSQLManager
87770>>>            Error DFERR_PROGRAM CS_SQLConnectError
87771>>>>
87771>>>            Function_Return False
87772>>>        End
87772>>>>
87772>>>        
87772>>>        // Check if collation already exists   
87772>>>        Get SqlDatabaseCollationQuery sDatabase to sSQLCollationCheck
87773>>>        // If the current collate is the same as the new; do nothing.
87773>>>        If (sSQLCollation = sSQLCollationCheck) Begin
87775>>>            Function_Return True
87776>>>        End
87776>>>>
87776>>>            
87776>>>        Get _SqlFindKeyWord CI_SQLSet               to sSet
87777>>>        Get _SqlFindKeyWord CI_SQLWith              to sWith
87778>>>        Get _SqlFindKeyWord CI_SQLSingle_User       to sSingle_User
87779>>>        Get _SqlFindKeyWord CI_SQLMulti_User        to sMulti_User
87780>>>        Get _SqlFindKeyWord CI_SQLRollback          to sRollback
87781>>>        Get _SqlFindKeyWord CI_SQLIMMEDIATE         to sImmediate
87782>>>        Get _SqlFindKeyWord CI_SQLAlterDatabase     to sAlterDatabaseKeyWord
87783>>>        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
87784>>>        
87784>>>        // MS-SQL Syntax:
87784>>>        // ALTER DATABASE [database] SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
87784>>>        // ALTER DATABASE [database] COLLATE SQL_1xCompat_CP850_CI_AS;
87784>>>        // ALTER DATABASE [database] SET MULTI_USER;
87784>>>        Move (              sAlterDatabaseKeyWord  * String(sDatabase) * String(sSet) * String(sSingle_User) * String(sWith) * String(sRollback) * String(sImmediate)) to sSQL
87785>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
87786>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sSet) * String(sMulti_User)) to sSQL
87787>>>//        Move (sAlterDatabaseKeyWord * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL 
87787>>>        
87787>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
87788>>>        Send SqlUtilExecuteQuery sSQL sDriverID False
87789>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
87790>>>        If (LastErr = CLIERR_GENERAL_ERROR) Begin
87792>>>           Function_Return False
87793>>>        End
87793>>>>
87793>>>
87793>>>        Function_Return (Err = False)
87794>>>    End_Function
87795>>>
87795>>>    // * Dummy function for the Studio's Code Explorer *
87795>>>    Function SQL_TABLE_FUNCTIONS Returns Boolean
87797>>>        Function_Return False
87798>>>    End_Function
87799>>>    // Converts from SQL to Embedded (DataFlex .dat files).
87799>>>    // To convert from SQL -> SQL (e.g. from Oracle - > MS SQL)
87799>>>    //   first use SQLTableConvertToEmbedded in one cDbUpdateVersion object,
87799>>>    //   and then use the ApiTableConvertToSQL method in a second cDbUpdateVersion object.
87799>>>    // Note: To convert an embedded table to SQL use ApiTableConvertToSQL.
87799>>>    Function SqlTableConvertToEmbedded Handle hTable Boolean bCpyDat Returns Boolean
87801>>>        Handle hToTable
87801>>>        Boolean bOK bExists bOpened bMertechDriver bCopyData
87801>>>        String sDriverID sPhysicalName sRootName sDisplayName
87801>>>        tSQLConnection SQLConnection
87801>>>        tSQLConnection SQLConnection
87801>>>        Integer iPos iMaxRecords
87801>>>
87801>>>        Get psDriverID to sDriverID
87802>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
87803>>>        If (bExists = False) Begin
87805>>>            Function_Return False
87806>>>        End
87806>>>>
87806>>>
87806>>>        If (num_arguments > 1) Begin
87808>>>            Move bCpyDat to bCopyData
87809>>>        End
87809>>>>
87809>>>        Else Begin
87810>>>            Move False to bCopyData
87811>>>        End
87811>>>>
87811>>>
87811>>>        Open hTable
87813>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
87816>>>        If (bOpened = False) Begin
87818>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
87819>>>>
87819>>>            Function_Return False
87820>>>        End
87820>>>>
87820>>>        Move 0 to hToTable
87821>>>
87821>>>        Move 16711679 to iMaxRecords
87822>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
87825>>>        Move (Pos(".", sDisplayName)) to iPos
87826>>>        If (iPos > 0) Begin
87828>>>            Move (Mid(sDisplayName, 200, (iPos +1))) to sDisplayName
87829>>>        End
87829>>>>
87829>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
87832>>>        Get _TableNameOnly sRootName                 to sRootName
87833>>>        Move (sRootName + ".dat")                    to sPhysicalName
87834>>>
87834>>>        If (ghoProgressBar <> 0) Begin
87836>>>            Send DoAdvance of ghoProgressBar
87837>>>            Set TableName_Text of ghoStatusPanel to ("Converting to Embedded - Table:" * String(sRootName) * "Number:" * String(hTable))
87838>>>        End
87838>>>>
87838>>>
87838>>>        Move False to Err
87839>>>
87839>>>        Structure_Start hToTable DATAFLEX_ID
87840>>>            Structure_Copy hTable to hToTable
87841>>>
87841>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
87844>>>            Set_Attribute DF_FILE_REUSE_DELETED of hToTable to DF_FILE_DELETED_REUSE
87847>>>            Set_Attribute DF_FILE_MULTIUSER     of hToTable to DF_FILE_USER_MULTI
87850>>>            Set_Attribute DF_FILE_TRANSACTION   of hToTable to DF_FILE_TRANSACTION_CLIENT_ATOMIC
87853>>>            Set_Attribute DF_FILE_MAX_RECORDS   of hToTable to iMaxRecords
87856>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87857>>>
87857>>>        Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87859>>>
87859>>>        Set Action_Text of ghoStatusPanel to ""
87860>>>        Move (not(Err)) to bOK
87861>>>        If (bOK = True and bCopyData = True) Begin
87863>>>            Get ApiTableCopyData hTable sPhysicalName sRootName DATAFLEX_ID to bOK
87864>>>        End
87864>>>>
87864>>>
87864>>>        Get IsMertechDriver sDriverID to bMertechDriver
87865>>>        If (bMertechDriver = True) Begin
87867>>>            Open hTable
87869>>>        End
87869>>>>
87869>>>
87869>>>        // This must be after copying data...
87869>>>        If (Err = False) Begin
87871>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
87874>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
87877>>>        End
87877>>>>
87877>>>        Move (not(Err)) to bOK
87878>>>
87878>>>        Function_Return (bOK = True)
87879>>>    End_Function
87880>>>
87880>>>    // Creates an SQL Table at the SQL end by its filelist number;
87880>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
87880>>>    Function SqlTableCreate Integer hTable Returns Boolean
87882>>>        String sTableName sSQLString sPath sCreateTable sDriverID
87882>>>        Integer iDbType
87882>>>        Boolean bExists
87882>>>
87882>>>        Get psDriverID to sDriverID
87883>>>        Get UtilTableHandleToString hTable to sTableName
87884>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
87885>>>        If (bExists = True) Begin
87887>>>            Function_Return False
87888>>>        End
87888>>>>
87888>>>
87888>>>        Get psDataPathFirstPart to sPath
87889>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
87890>>>
87890>>>        Get piDbType to iDbType
87891>>>        Get _SqlProperTableName sTableName to sTableName
87892>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
87893>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
87894>>>
87894>>>        Move False to Err
87895>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
87896>>>
87896>>>        Function_Return (Err = False)
87897>>>    End_Function
87898>>>
87898>>>    // Same as SqlTableCreate but creates an SQL Table at the SQL end by a table name;
87898>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
87898>>>    Function SqlTableCreateByTableName String sTableName  Returns Boolean
87900>>>        String sSQLString sPath sCreateTable sDriverID
87900>>>        Integer iDbType
87900>>>        Boolean bExists
87900>>>
87900>>>        Get psDriverID to sDriverID
87901>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
87902>>>        If (bExists = True) Begin
87904>>>            Function_Return False
87905>>>        End
87905>>>>
87905>>>
87905>>>        Get psDataPathFirstPart to sPath
87906>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
87907>>>        If (bExists = True) Begin
87909>>>            // ToDo: What should we do if an .int file already exists?
87909>>>        End
87909>>>>
87909>>>
87909>>>        Get piDbType to iDbType
87910>>>        Get _SqlProperTableName sTableName to sTableName
87911>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
87912>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
87913>>>
87913>>>        Move False to Err
87914>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
87915>>>
87915>>>        Function_Return (Err = False)
87916>>>    End_Function
87917>>>
87917>>>    // First deletes the data cache file and then drops the passed SQL table.
87917>>>    // Note: The table needs to exist in filelist.cfg, and it must be possible to open it,
87917>>>    //       else try using the SqlTableRemoveByTableName message.
87917>>>    Function SqlTableRemove Integer hTable Returns Boolean
87919>>>        String sSQLString sPath sDropTable sTableName sDriverID
87919>>>        Integer iRetval iDbType
87919>>>        Boolean bExists bMertechDriver bOK
87919>>>
87919>>>        Get psDriverID to sDriverID
87920>>>        Get IsMertechDriver sDriverID to bMertechDriver
87921>>>        Get UtilTableHandleToString hTable to sTableName
87922>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
87923>>>        If (bExists = False) Begin
87925>>>            Function_Return False
87926>>>        End
87926>>>>
87926>>>
87926>>>        Get psDataPathFirstPart to sPath
87927>>>        Get UtilDeleteCacheFile sTableName to iRetval
87928>>>
87928>>>        Get piDbType to iDbType
87929>>>        Get _SqlProperTableName sTableName to sTableName
87930>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
87931>>>        Move (sDropTable * String(sTableName)) to sSQLString
87932>>>
87932>>>        Move False to Err
87933>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
87934>>>
87934>>>        // We also need to remove the cache-file since the table has been changed
87934>>>        Get UtilDeleteCacheFile sTableName to bOK
87935>>>
87935>>>        Function_Return (Err = False)
87936>>>    End_Function
87937>>>
87937>>>    // First deletes the data cache file and then drops the passed data table.
87937>>>    Function SqlTableRemoveByTableName String sTableName Returns Boolean
87939>>>        String sSQLString sPath sDropTable sVal sSchema sDriverID
87939>>>        Integer iRetval iDbType
87939>>>        Boolean bMertechDriver bOK
87939>>>
87939>>>        Get psDriverID to sDriverID
87940>>>        Get IsMertechDriver sDriverID to bMertechDriver
87941>>>        Get psDataPathFirstPart to sPath
87942>>>        Get UtilDeleteCacheFile sTableName to iRetval
87943>>>
87943>>>        Get piDbType to iDbType
87944>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
87945>>>        Get psSchema to sSchema
87946>>>        If (sSchema = "") Begin
87948>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
87949>>>        End
87949>>>>
87949>>>        Move (Uppercase(sTableName)) to sVal
87950>>>        If (not(sVal contains (sSchema + "."))) Begin
87952>>>            Move (Lowercase(sSchema) + "." + sTableName) to sTableName
87953>>>        End
87953>>>>
87953>>>        Move (sDropTable * String(sTableName)) to sSQLString
87954>>>
87954>>>        Move False to Err
87955>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
87956>>>
87956>>>        // We also need to remove the cache-file since the table has been changed
87956>>>        Get UtilDeleteCacheFile sTableName to bOK
87957>>>
87957>>>        Function_Return (Err = False)
87958>>>    End_Function
87959>>>
87959>>>    // *** Sql View Messages ***
87959>>>
87959>>>    // First deletes the data cache file and then drops the passed Sql data view.
87959>>>    Function SqlViewRemove String sDataView Returns Boolean
87961>>>        String sDriverID sSQLString sDropViewKeyWord
87961>>>        Integer iRetval
87961>>>        Boolean bMertechDriver bOK
87961>>>
87961>>>        Get psDriverID to sDriverID
87962>>>        Get IsMertechDriver sDriverID to bMertechDriver
87963>>>        Get UtilDeleteCacheFile sDataView to iRetval
87964>>>
87964>>>        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
87965>>>        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
87966>>>        Set psSQLStatementString to sSQLString
87967>>>
87967>>>        // As we don't check if the view exist or not, it might happen
87967>>>        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
87967>>>        Move False to Err
87968>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87969>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
87970>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87971>>>        Move 0 to LastErr
87972>>>
87972>>>        // We also need to remove the cache-file since the table has been changed
87972>>>        Get UtilDeleteCacheFile sDataView to bOK
87973>>>
87973>>>        Function_Return (Err = False)
87974>>>    End_Function
87975>>>
87975>>>    Function SqlTableRename Handle hTable String sCurrentTableName String sNewtTableName Returns Boolean
87977>>>        Boolean bOK
87977>>>        Integer iDbType
87977>>>        String sDriverID sAlterTable sRenameTable sSQLTo sSQLString
87977>>>
87977>>>        Get psDriverID to sDriverID
87978>>>        Get piDbType   to iDbType
87979>>>
87979>>>        Case Begin
87979>>>            Case (iDbType = EN_DbTypeDB2)
87981>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
87982>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
87983>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * sNewtTableName) to sSQLString
87984>>>            Break
87985>>>
87985>>>            Case (iDbType = EN_DbTypeMSSQL)
87988>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
87989>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
87990>>>                Move (sRenameTable * "'" - sCurrentTableName - "', '" - sNewtTableName - "'") to sSQLString
87991>>>            Break
87992>>>
87992>>>            Case (iDbType = EN_DbTypeOracle)
87995>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
87996>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
87997>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * sNewtTableName) to sSQLString
87998>>>            Break
87999>>>
87999>>>            Case (iDbType = EN_DbTypePostgre)
88002>>>                Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
88003>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
88004>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
88005>>>                Move (sAlterTable * sCurrentTableName * sRenameTable * sSQLTo * sNewtTableName) to sSQLString
88006>>>            Break
88007>>>
88007>>>            Case (iDbType = EN_DbTypeMySQL)
88010>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
88011>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
88012>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * sNewtTableName) to sSQLString
88013>>>            Break
88014>>>        Case End
88014>>>
88014>>>        Move False to Err
88015>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
88016>>>        Move (Err = False) to bOK
88017>>>
88017>>>        Function_Return bOK
88018>>>    End_Function
88019>>>
88019>>>    // * Dummy function for the Studio's Code Explorer *
88019>>>    Function SQL_COLUMN_FUNCTIONS Returns Boolean
88021>>>        Function_Return False
88022>>>    End_Function
88023>>>
88023>>>    // Sample: Get SqlColumnAdd MyTable.File_Number "NewColumnName" True "InitValue" DF_ASCII_DUF 35
88023>>>    Function SqlColumnAdd Integer hTable String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
88025>>>        Integer iLength iDecimals
88025>>>        String sColumnValue
88025>>>        String sTableName sDriverID
88025>>>        Boolean bOK bInitializeValue
88025>>>
88025>>>        Get psDriverID to sDriverID
88026>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
88027>>>        If (bOK = False) Begin
88029>>>            Function_Return False
88030>>>        End
88030>>>>
88030>>>
88030>>>        Get UtilTableHandleToString hTable to sTableName
88031>>>        If (sTableName = "") Begin
88033>>>            Function_Return False
88034>>>        End
88034>>>>
88034>>>
88034>>>        If (num_arguments > 3) Begin
88036>>>            Move iLen     to iLength
88037>>>            Move iDec     to iDecimals
88038>>>            Move bInitVal to bInitializeValue
88039>>>            Move sColVal  to sColumnValue
88040>>>        End
88040>>>>
88040>>>
88040>>>        Get SqlColumnAddByTableName sTableName sColumnName iDataType iLen iDecimals bInitializeValue sColumnValue to bOK
88041>>>
88041>>>        Function_Return (bOK = True)
88042>>>    End_Function
88043>>>
88043>>>    // Sample: Get SqlColumnAddByTableName "MyTable" "NewColumnName" DF_ASCII_DUF 35 0 True "InitValue"
88043>>>    Function SqlColumnAddByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
88045>>>        Integer iDbType iLength iDecimals iDriver
88045>>>        String sStmt sAlterTable sAddColumn sVal sDataType sLengthAndDecimals sColumnValue
88045>>>        String sDriverID sNotNull
88045>>>        Boolean bOK bInitializeValue bRetval bFixed bDriverIgnoreErrorState
88045>>>        Handle hTable
88045>>>
88045>>>        Get psDriverID to sDriverID
88046>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
88047>>>        If (bOK = False) Begin
88049>>>            Function_Return False
88050>>>        End
88050>>>>
88050>>>
88050>>>        Get UtilTableNameToHandle sTableName to hTable
88051>>>        If (hTable = 0) Begin
88053>>>            Get NextFreeFilelistSlot to hTable
88054>>>        End
88054>>>>
88054>>>
88054>>>        Get piDbType to iDbType
88055>>>        // If a field/column already exists; we just ignore the request to not add unneccesary errors to the log.
88055>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
88056>>>        If (Uppercase(sVal) = Uppercase(sColumnName)) Begin
88058>>>            Function_Return False
88059>>>        End
88059>>>>
88059>>>
88059>>>        Get DriverIndex sDriverID to iDriver
88060>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
88063>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
88066>>>
88066>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
88067>>>        If (num_arguments > 3) Begin
88069>>>            Move iLen     to iLength
88070>>>            Move iDec     to iDecimals
88071>>>            Move bInitVal to bInitializeValue
88072>>>            Move sColVal  to sColumnValue
88073>>>        End
88073>>>>
88073>>>
88073>>>        Get _SqlProperTableName sTableName   to sTableName
88074>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
88075>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
88076>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
88077>>>
88077>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
88078>>>        If (bFixed = False) Begin
88080>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
88081>>>        End
88081>>>>
88081>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
88082>>>
88082>>>        Move False to Err
88083>>>        Send SqlUtilExecuteQuery sStmt sDriverID
88084>>>
88084>>>        If (bInitializeValue = True and Err = False) Begin
88086>>>            Get SQLColumnUpdateValue hTable sColumnName sColumnValue to bRetval
88087>>>        End
88087>>>>
88087>>>
88087>>>        If (Err = False) Begin
88089>>>            Get SqlUtilAdjustAuxFiles hTable sTableName sColumnName to bOK
88090>>>        End
88090>>>>
88090>>>
88090>>>        Move (not(Err)) to bRetval
88091>>>
88091>>>        // We also need to remove the cache-file since the table has been changed
88091>>>        Get UtilDeleteCacheFile sTableName to bOK
88092>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
88095>>>
88095>>>        Function_Return bRetval
88096>>>    End_Function
88097>>>
88097>>>    // To update all current rows for a table column with a common value.
88097>>>    Function SqlColumnUpdateValue Handle hTable String sColumnName String sColumnValue Returns Boolean
88099>>>        String sDriverID sTableName sUpdate sSet sNoCountOn sStmt
88099>>>        Boolean bRetval bSQLDriver
88099>>>        Integer iCurrErr
88099>>>
88099>>>        Move False to bRetval
88100>>>        Get psDriverID to sDriverID
88101>>>        Get IsSQLDriver sDriverID to bSQLDriver
88102>>>        If (bSQLDriver = False) Begin
88104>>>            Function_Return bRetval
88105>>>        End
88105>>>>
88105>>>        Get UtilTableHandleToString hTable to sTableName
88106>>>
88106>>>        Move Err to iCurrErr
88107>>>        Move False to Err
88108>>>        Get _SqlFindKeyWord CI_SQLUpdate       to sUpdate
88109>>>        Get _SqlFindKeyWord CI_SQLSet          to sSet
88110>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountOn
88111>>>        Move (sNoCountOn * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
88112>>>        Send SqlUtilExecuteQuery sStmt sDriverID
88113>>>        Move (Err = False) to bRetval
88114>>>        Move iCurrErr to Err
88115>>>
88115>>>        Function_Return bRetval
88116>>>    End_Function
88117>>>
88117>>>    // The fourth & fifth arguments are optional, depending on the iDataType
88117>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
88117>>>    Function SqlColumnChange Handle hTable String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
88119>>>        String sDriverID sTableName
88119>>>        Boolean bOK
88119>>>
88119>>>        Get psDriverID to sDriverID
88120>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
88121>>>        If (bOK = False) Begin
88123>>>            Function_Return False
88124>>>        End
88124>>>>
88124>>>
88124>>>        Get UtilTableHandleToString hTable to sTableName
88125>>>        Get SqlColumnChangeByTableName sTableName sColumnName iDataType iLen iDec to bOK
88126>>>
88126>>>        Function_Return (Err = False)
88127>>>    End_Function
88128>>>
88128>>>    // Same as SqlColumnChange but instead of passing a filelist number; pass the table name as a string.
88128>>>    // The fourth & fifth arguments are optional, depending on the iDataType
88128>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
88128>>>    Function SqlColumnChangeByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
88130>>>        Integer iDbType iLength iDecimals
88130>>>        String sDriverID sStmt sAlterTable sAlterColumn sDataType sLengthAndDecimals sNotNull
88130>>>        Boolean bExists bOK bFixed
88130>>>        Handle hTable
88130>>>
88130>>>        Get psDriverID to sDriverID
88131>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
88132>>>        If (bOK = False) Begin
88134>>>            Function_Return False
88135>>>        End
88135>>>>
88135>>>
88135>>>        Get UtilTableNameToHandle sTableName to hTable
88136>>>        If (hTable = 0) Begin
88138>>>            Get NextFreeFilelistSlot to hTable
88139>>>        End
88139>>>>
88139>>>        Get SQLUtilColumnExists sTableName sColumnName to bExists
88140>>>        If (bExists = True) Begin
88142>>>            Function_Return False
88143>>>        End
88143>>>>
88143>>>
88143>>>        If (num_arguments > 3) Begin
88145>>>            Move iLen to iLength
88146>>>        End
88146>>>>
88146>>>        If (num_arguments > 4) Begin
88148>>>            Move iDec to iDecimals
88149>>>        End
88149>>>>
88149>>>
88149>>>        Get piDbType to iDbType
88150>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
88151>>>
88151>>>        Move False to Err
88152>>>        Get _SqlProperTableName sTableName    to sTableName
88153>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
88154>>>        Get _SqlFindKeyWord CI_SQLAlterColumn to sAlterColumn
88155>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
88156>>>
88156>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
88157>>>        If (bFixed = False) Begin
88159>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
88160>>>        End
88160>>>>
88160>>>
88160>>>        Move (sAlterTable * sTableName * sAlterColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
88161>>>        Send SqlUtilExecuteQuery sStmt sDriverID
88162>>>
88162>>>        // We also need to remove the cache-file since the table has been changed
88162>>>        Get UtilDeleteCacheFile sTableName to bOK
88163>>>
88163>>>        Function_Return (Err = False)
88164>>>    End_Function
88165>>>
88165>>>    Function SqlColumnDefaultValue Handle hTable Integer iColumn String sValue Returns Boolean
88167>>>        Boolean bOK bErr bIsSQLDriver
88167>>>        String sDriverID  
88167>>>        Integer iDataType
88167>>>
88167>>>        Get psDriverID to sDriverID
88168>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
88169>>>        If (bIsSQLDriver = False) Begin
88171>>>            Function_Return False
88172>>>        End
88172>>>>
88172>>>
88172>>>        Move Err to bErr
88173>>>        Move False to bErr
88174>>>
88174>>>        // There seems to be a problem with the ODBC_DRV driver that sometimes
88174>>>        // inserts randomly character(10) and spaces, so we correct from that here:
88174>>>        Move (Replaces(Character(10), Trim(sValue), "")) to sValue
88175>>>        Get_Attribute DF_FIELD_TYPE of hTable iColumn to iDataType 
88178>>>        If (iDataType = DF_BCD and Left(sValue, 1 <> "[")) Begin
88180>>>            Move ("[" + String(sValue) + "]") to sValue
88181>>>        End
88181>>>>
88181>>>        
88181>>>        Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sValue
88184>>>        Move (not(Err)) to bOK
88185>>>        Move bErr to Err
88186>>>
88186>>>        Function_Return bOK
88187>>>    End_Function
88188>>>
88188>>>    Function SqlColumnNullable Handle hTable Integer iColumn Boolean bNullable Returns Boolean
88190>>>        Boolean bOK bErr bCurrentState bOpen bIsSQLDriver
88190>>>        String sDriverID
88190>>>
88190>>>        Get psDriverID to sDriverID
88191>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
88192>>>        If (bIsSQLDriver = False) Begin
88194>>>            Function_Return False
88195>>>        End
88195>>>>
88195>>>
88195>>>        Move Err to bErr
88196>>>        Move False to bErr
88197>>>        Get_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bCurrentState
88200>>>        If (bNullable = bCurrentState) Begin
88202>>>            Function_Return True
88203>>>        End
88203>>>>
88203>>>
88203>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
88206>>>        If (bOpen = False) Begin
88208>>>            Get AutoConnectionIDLogin to bOK
88209>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
88210>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
88211>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88212>>>            Open hTable
88214>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
88215>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
88216>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88217>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
88220>>>        End
88220>>>>
88220>>>        If (bOpen = True) Begin
88222>>>            Structure_Start hTable sDriverID
88223>>>                Set_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bNullable
88226>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
88227>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88229>>>            Set Action_Text of ghoStatusPanel to ""
88230>>>        End
88230>>>>
88230>>>
88230>>>        Move (not(Err)) to bOK
88231>>>        Move bErr to Err
88232>>>
88232>>>        Function_Return bOK
88233>>>    End_Function
88234>>>
88234>>>    // Drop column by its table handle
88234>>>    Function SqlColumnRemove Handle hTable String sColumnName Returns Boolean
88236>>>        String sDriverID sTableName
88236>>>        Boolean bOK
88236>>>
88236>>>        Get psDriverID to sDriverID
88237>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
88238>>>        If (bOK = False) Begin
88240>>>            Function_Return False
88241>>>        End
88241>>>>
88241>>>
88241>>>        Get UtilTableHandleToString hTable to sTableName
88242>>>        If (sTableName = "") Begin
88244>>>            Function_Return False
88245>>>        End
88245>>>>
88245>>>
88245>>>        Get SqlColumnRemoveByTableName sTableName sColumnName to bOK
88246>>>
88246>>>        Function_Return (bOK = True)
88247>>>    End_Function
88248>>>
88248>>>    // Drop column by its table name as a string.
88248>>>    Function SqlColumnRemoveByTableName String sTableName String sColumnName Returns Boolean
88250>>>        Integer iDbType iDriver
88250>>>        String sDriverID sStmt sAlterTable sDropColumn
88250>>>        Boolean bExists bOK bRetval bDriverIgnoreErrorState
88250>>>        Handle hTable
88250>>>
88250>>>        Get psDriverID to sDriverID
88251>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
88252>>>        If (bOK = False) Begin
88254>>>            Function_Return False
88255>>>        End
88255>>>>
88255>>>
88255>>>        Get DriverIndex sDriverID to iDriver
88256>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
88259>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
88262>>>
88262>>>        Get UtilTableNameToHandle sTableName to hTable
88263>>>        If (hTable <> 0) Begin
88265>>>            Get SQLUtilColumnExists sTableName sColumnName to bExists
88266>>>            If (bExists = False) Begin
88268>>>                Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
88271>>>                Function_Return False
88272>>>            End
88272>>>>
88272>>>        End
88272>>>>
88272>>>
88272>>>        Get piDbType to iDbType
88273>>>        If (iDbType = EN_DbTypeMSSQL) Begin
88275>>>            Get _SqlUtilRemoveTableColumnMSSQL sTableName sColumnName to bOK
88276>>>            Get UtilDeleteCacheFile sTableName to bOK
88277>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
88280>>>            Function_Return bOK
88281>>>        End
88281>>>>
88281>>>
88281>>>        Move False to Err
88282>>>        Get _SqlProperTableName sTableName    to sTableName
88283>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
88284>>>        Get _SqlFindKeyWord CI_SQLDropColumn  to sDropColumn
88285>>>
88285>>>        Move (sAlterTable * sTableName * sDropColumn * sColumnName) to sStmt
88286>>>        Send SqlUtilExecuteQuery sStmt sDriverID
88287>>>        Move (not(Err)) to bRetval
88288>>>
88288>>>        // We also need to remove the cache-file since the table has been changed
88288>>>        Get UtilDeleteCacheFile sTableName to bOK
88289>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
88292>>>
88292>>>        Function_Return bRetval
88293>>>    End_Function
88294>>>
88294>>>    // Rename a field/column by table handle (filelist number)
88294>>>    Function SqlColumnRename Integer hTable String sColumnName String sNewColumnName Returns Boolean
88296>>>        String sDriverID sTableName
88296>>>        Boolean bOK
88296>>>
88296>>>        Get psDriverID to sDriverID
88297>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
88298>>>        If (bOK = False) Begin
88300>>>            Function_Return False
88301>>>        End
88301>>>>
88301>>>
88301>>>        Get UtilTableHandleToString hTable to sTableName
88302>>>        Get SqlColumnRenameByTableName sTableName sColumnName sNewColumnName to bOK
88303>>>
88303>>>        Function_Return (Err = False)
88304>>>    End_Function
88305>>>
88305>>>    // Rename a field/column by table name.
88305>>>    Function SqlColumnRenameByTableName String sTableName String sColumnName String sNewColumnName Returns Boolean
88307>>>        Integer iDbType iDataType
88307>>>        String sDriverID sStmt sAlterTable sRenameColumn sVal sColumnKeyWord sOrgTableName sDatabase sDataType
88307>>>        Boolean bOK bRetval
88307>>>        Handle hTable
88307>>>
88307>>>        Move sTableName to sOrgTableName
88308>>>        Get psDriverID to sDriverID
88309>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
88310>>>        If (bOK = False) Begin
88312>>>            Function_Return False
88313>>>        End
88313>>>>
88313>>>
88313>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
88314>>>        If (sVal = "") Begin
88316>>>            Function_Return False
88317>>>        End
88317>>>>
88317>>>
88317>>>        Get piDbType to iDbType
88318>>>        Get _SqlFindKeyWord CI_SQLColumn       to sColumnKeyWord
88319>>>        Get _SqlProperTableName sTableName     to sTableName
88320>>>        Get _SqlFindKeyWord CI_SQLAlterTable   to sAlterTable
88321>>>        Get _SqlFindKeyWord CI_SQLRenameColumn to sRenameColumn
88322>>>
88322>>>        Case Begin
88322>>>            Case (iDbType = EN_dbTypeMSSQL)
88324>>>                Move (sRenameColumn * "'" + sTableName + "." + sColumnName + "'," * "'" + sNewColumnName + "'," * "'" + sColumnKeyWord + "'") to sStmt
88325>>>                Case Break
88326>>>            // Alter table "SYS"."Customer" rename column "Comments" to "NewColumnName"
88326>>>            Case (iDbType = EN_dbTypeOracle)
88329>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
88330>>>                Case Break
88331>>>            // ALTER TABLE Schema.TableName RENAME COLUMN "deptnumb" TO "deptnum"
88331>>>            Case (iDbType = EN_dbTypeDB2)
88334>>>                Move (sAlterTable *  sTableName * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
88335>>>                Case Break
88336>>>            // ALTER TABLE "Customer" RENAME COLUMN "Comments" TO "NewColumnName"
88336>>>            Case (iDbType = EN_dbTypePostgre)
88339>>>                Move sOrgTableName to sTableName
88340>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
88341>>>                Case Break
88342>>>            Case (iDbType = EN_dbTypeMySQL)
88345>>>                // ALTER TABLE orderentry.customer CHANGE Comments NewColumnName text // Note: The last token is the column type!
88345>>>                Move sOrgTableName to sTableName
88346>>>                Get psDatabase to sDatabase
88347>>>                Get UtilTableNameToHandle sTableName to hTable
88348>>>                If (hTable = 0) Begin
88350>>>                    Get UtilTableOpen hTable sTableName DF_SHARE to bOK
88351>>>                    If (bOK = False) Begin
88353>>>                        Function_Return False
88354>>>                    End
88354>>>>
88354>>>                    Get NextFreeFilelistSlot to hTable
88355>>>                End
88355>>>>
88355>>>                Else Begin
88356>>>                    Open hTable
88358>>>                End
88358>>>>
88358>>>                Get SQLColumnType sDriverID hTable sTableName sColumnName to iDataType
88359>>>                Get UtilColumnTypeToString sDriverID iDbType iDataType    to sDataType
88360>>>                Move (sAlterTable * sDatabase + "." + sTableName * sRenameColumn * sColumnName * sNewColumnName * sDataType) to sStmt
88361>>>                Case Break
88362>>>            Case Else
88362>>>                Move (sAlterTable * "'" + sTableName + "'" * sRenameColumn * "'" + sTableName + "." + sColumnName + "'" * "TO" * "'" + sNewColumnName + "'") to sStmt
88363>>>        Case End
88363>>>
88363>>>        Move False to Err
88364>>>        Send SqlUtilExecuteQuery sStmt sDriverID
88365>>>        Move (Err = False) to bRetval
88366>>>        // We also need to remove the cache-file since the table has been changed
88366>>>        Get UtilDeleteCacheFile sTableName to bOK
88367>>>
88367>>>        Function_Return bRetval
88368>>>    End_Function
88369>>>
88369>>>    Function SqlColumnType String sDriverID Handle hTable String sTableName String sColumnName Returns Integer
88371>>>        Handle hoSQLHandler hSQLConnect hStmt
88371>>>        Boolean bMertechDriver
88371>>>        Integer iNumCols iCount iDataType
88371>>>        String sValue
88371>>>
88371>>>        Get IsMertechDriver sDriverID to bMertechDriver
88372>>>        If (bMertechDriver = False) Begin
88374>>>            Get phoSQLManager to hoSQLHandler
88375>>>        End
88375>>>>
88375>>>        Else Begin
88376>>>            Get _MertechSQLManagerHandle to hoSQLHandler
88377>>>        End
88377>>>>
88377>>>
88377>>>        Get SQLFileConnect of hoSQLHandler hTable to hSQLConnect
88378>>>        If (hSQLConnect <> 0) Begin
88380>>>            Get SQLOpen of hSQLConnect to hStmt
88381>>>            If (hStmt <> 0) Begin
88383>>>                Send SQLExecDirect of hStmt ("select * from" * sTableName)
88384>>>
88384>>>                Get SQLStmtAttribute of hStmt SQLSTMTATTRIB_COLUMNCOUNT to iNumCols
88385>>>                For iCount from 1 to iNumCols
88391>>>>
88391>>>                    Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_LABEL to sValue
88392>>>                    If (Lowercase(sValue) = Lowercase(sColumnName)) Begin
88394>>>                        Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_SQLTYPE to iDataType
88395>>>                        Move iNumCols to iCount // We're out of here
88396>>>                    End
88396>>>>
88396>>>                Loop
88397>>>>
88397>>>
88397>>>                Send SQLClose of hStmt
88398>>>            End
88398>>>>
88398>>>            Send SQLDisconnect of hSQLConnect
88399>>>        End
88399>>>>
88399>>>
88399>>>        Function_Return iDataType
88400>>>    End_Function
88401>>>
88401>>>    // * Dummy function for the Studio's Code Explorer *
88401>>>    Function SQL_EXECUTE_FUNCTIONS Returns Boolean
88403>>>        Function_Return False
88404>>>    End_Function
88405>>>
88405>>>    Procedure SqlUtilExecuteQuery String sStmt String sDriverID Boolean bShowProgr
88407>>>        String sConnectionString sMessage
88407>>>        Handle hoSqlHandler hoSQLConnect hoStmt hoError
88407>>>        Integer i iMsgs iFetchResult iRowType iRows iErr iMessage iLastErr
88407>>>        String[] sMsg aSQLQueryMessages aSQLFetchResults
88410>>>        DateTime dtQueryExecStart dtQueryExecEnd dtFetchStart dtFetchEnd
88410>>>        TimeSpan tsQuery tsFetch
88410>>>        tSqlErrorArray aSqlErrorArray
88410>>>        tSqlErrorArray aSqlErrorArray
88410>>>        Boolean bOK bMertechDriver bShowProgress
88410>>>        tSQLConnection SQLConnection
88410>>>        tSQLConnection SQLConnection
88410>>>
88410>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
88411>>>        If (bOK = False) Begin
88413>>>            Procedure_Return
88414>>>        End
88414>>>>
88414>>>
88414>>>        If (num_arguments > 2) Begin
88416>>>            Move bShowProgr to bShowProgress
88417>>>        End
88417>>>>
88417>>>
88417>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
88418>>>
88418>>>        Get IsMertechDriver sDriverID to bMertechDriver
88419>>>        If (bMertechDriver = True) Begin
88421>>>            Get _MertechSQLConnect sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
88422>>>        End
88422>>>>
88422>>>        If (bMertechDriver = False) Begin
88424>>>            Get phoSQLManager to hoSqlHandler
88425>>>            Send SqlSetConnect of hoSqlHandler sDriverID SQLConnection.sConnectionString
88426>>>            Get SqlConnect     of hoSqlHandler "" "" to hoSQLConnect
88427>>>        End
88427>>>>
88427>>>
88427>>>        If (hoSQLConnect <> 0) Begin
88429>>>            Get SqlOpen of hoSQLConnect to hoStmt
88430>>>            If (hoStmt <> 0) Begin
88432>>>                // record starting date/time stamp
88432>>>                Move (CurrentDateTime()) to dtQueryExecStart
88433>>>                // turn on error handling if enabled
88433>>>                If (pbHandleQueryErrors(Self)) Begin
88435>>>                    Set pbSqlError to False
88436>>>                    Set paSqlErrorArray to aSqlErrorArray
88437>>>                    Move Error_Object_Id to hoError 
88438>>>                    If (ghoDbUpdateHandler <> 0) Begin
88440>>>                        Move ghoDbUpdateHandler to Error_Object_Id
88441>>>                    End                                           
88441>>>>
88441>>>                    Else Begin
88442>>>                        Move Self to Error_Object_Id
88443>>>                    End
88443>>>>
88443>>>                End
88443>>>>
88443>>>
88443>>>                // Before we execute the statement; save it so we can display the faulty statement in the error log.
88443>>>                Set psSQLStatementString to sStmt 
88444>>>                Send Cursor_Wait of Cursor_Control
88445>>>                Send SqlExecDirect of hoStmt sStmt
88446>>>                Send Cursor_Ready of Cursor_Control
88447>>>
88447>>>                If (pbHandleQueryErrors(Self)) Begin
88449>>>                    Move hoError to Error_Object_Id
88450>>>                End
88450>>>>
88450>>>
88450>>>                Move 0 to iMsgs
88451>>>                // ToDo: There seems to be some issues with this code and Mertech drivers that makes
88451>>>                // the debugger crash in some cases like an error in the ESQL statement; so we exclude it for now.
88451>>>                If (bMertechDriver = False) Begin
88453>>>                    Move Err to iErr
88454>>>                    Move LastErr to iLastErr
88455>>>                    Get SqlStmtAttribute of hoStmt SQLSTMTATTRIB_NUMMESSAGES   to iMsgs
88456>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT      to iRows
88457>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
88458>>>                    Send _SqlColumnInfo hoStmt
88459>>>                    Send Ignore_Error of Error_Object_Id 12289
88460>>>                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88461>>>                    Repeat
88461>>>>
88461>>>                        Get SqlFetch of hoStmt to iFetchResult
88462>>>                        If (iFetchResult <> 0) Begin
88464>>>                            Get SQLColumnValue of hoStmt 1 to aSQLFetchResults[SizeOfArray(aSQLFetchResults)]
88465>>>                        End
88465>>>>
88465>>>                    Until (iFetchResult = 0)
88467>>>                    Send Trap_Error of Error_Object_Id 12289
88468>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
88469>>>                    Move iErr to Err
88470>>>                    Move iLastErr to LastErr
88471>>>                    Set paSQLFetchResults to aSQLFetchResults
88472>>>                End
88472>>>>
88472>>>
88472>>>                Set piRows    to iRows
88473>>>                Set piRowType to iRowType
88474>>>                Move (CurrentDateTime()) to dtQueryExecEnd
88475>>>                Move (CurrentDateTime()) to dtFetchStart
88476>>>
88476>>>                If (iMsgs <> 0) Begin
88478>>>                    If (ghoDbUpdateHandler > 0) Begin
88480>>>                        Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
88481>>>                    End
88481>>>>
88481>>>                    For i from 1 to iMsgs
88487>>>>
88487>>>                        Get SqlGetMessage of hoStmt i to sMessage
88488>>>                        Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
88489>>>                        If (bShowProgress = True) Begin
88491>>>                            If (Active_State(ghoStatusPanel)) Begin
88493>>>                                Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
88494>>>                            End
88494>>>>
88494>>>                            Else Begin
88495>>>                                Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
88497>>>                            End
88497>>>>
88497>>>                        End
88497>>>>
88497>>>                        Move sMessage to sMsg[SizeOfArray(sMsg)]
88498>>>                        Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
88499>>>                    Loop
88500>>>>
88500>>>                    If (ghoDbUpdateHandler > 0) Begin
88502>>>                        Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
88503>>>                    End
88503>>>>
88503>>>                    Set paQueryMessages to sMsg
88504>>>                End 
88504>>>>
88504>>>                Else Begin
88505>>>                    If (bShowProgress = True) Begin
88507>>>                        Get paSqlErrorArray to aSqlErrorArray
88508>>>                        If (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) Begin
88510>>>                            Move (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) to iMsgs
88511>>>                            Decrement iMsgs
88512>>>                            For i from 0 to iMsgs
88518>>>>
88518>>>                                Showln "Embedded SQL Statement: " aSqlErrorArray.sSqlStatementArray[i]
88521>>>                                Showln "SQL Error Message     : " aSqlErrorArray.sSqlErrorArray[i]
88524>>>                            Loop
88525>>>>
88525>>>                        End
88525>>>>
88525>>>                    End
88525>>>>
88525>>>                End
88525>>>>
88525>>>                Move (CurrentDateTime()) to dtFetchEnd
88526>>>            End
88526>>>>
88526>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
88527>>>            Move (dtFetchStart - dtFetchEnd) to tsFetch
88528>>>            Set ptsQueryExec to tsQuery
88529>>>            Set ptsFetchResults to tsFetch
88530>>>            Send SqlClose of hoStmt
88531>>>        End
88531>>>>
88531>>>
88531>>>        Send SqlDisconnect of hoSQLConnect
88532>>>    End_Procedure
88533>>>
88533>>>    // *** Main message for executing an SQL script that has been compiled into the program as a resource ***
88533>>>    // Use the SQLIncludeScriptFile command to include an SQL script into the program.
88533>>>    // Returns False if no error occured.
88533>>>    Function SqlUtilExecuteResource String sMemFileName String sDriverID Boolean bCreateScriptFile Boolean bShowProgr Returns Boolean
88535>>>        Boolean bOK bShowProgress
88535>>>        tSQLScriptArray SQLScriptArray
88535>>>        tSQLScriptArray SQLScriptArray
88535>>>        DateTime dtTotalQueryStart dtTotalQueryEnd
88535>>>        TimeSpan tsTotalTime
88535>>>
88535>>>        Move (CurrentDateTime()) to dtTotalQueryStart
88536>>>        Get SqlUtilReadResource sMemFileName to SQLScriptArray
88537>>>        If (SQLScriptArray.bError = True) Begin
88539>>>            Function_Return False
88540>>>        End
88540>>>>
88540>>>
88540>>>        If (num_arguments > 3) Begin
88542>>>            Move bShowProgr to bShowProgress
88543>>>        End
88543>>>>
88543>>>
88543>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88544>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID bCreateScriptFile sMemFileName bShowProgress to bOK
88545>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88546>>>
88546>>>        If (SQLScriptArray.bArgumentSizeChanged = True) Begin
88548>>>            Set_Argument_Size SQLScriptArray.iOrgArgumentSize
88549>>>>
88549>>>        End
88549>>>>
88549>>>
88549>>>        Move (CurrentDateTime()) to dtTotalQueryEnd
88550>>>        Move (dtTotalQueryEnd - dtTotalQueryStart) to tsTotalTime
88551>>>        Set ptsTotalQueryTime to tsTotalTime
88552>>>
88552>>>        Function_Return bOK
88553>>>    End_Procedure
88554>>>
88554>>>    // Reads a SQL script file that has been compiled into the .exe program as a resource.
88554>>>    // Pass: The memory resource reference and a boolean True if you want to create the file on disk (in the Home folder).
88554>>>    // Returns: A tSQLScriptArray Struct with the Sql script as an uChar Array will be returned along with the a bError boolean.
88554>>>    Function SqlUtilReadResource String sMemFileName Returns tSQLScriptArray
88556>>>        Integer iChannel iArgumentSize iCount
88556>>>        Number nByteCount
88556>>>        String sSQLScript
88556>>>        tSQLScriptArray SqlScriptArray
88556>>>        tSQLScriptArray SqlScriptArray
88556>>>        UChar[] uCharData
88557>>>
88557>>>        Move False to Err
88558>>>        Get Seq_New_Channel to iChannel
88559>>>        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
88561>>>            Error DFERR_PROGRAM 'No channel available...'
88562>>>>
88562>>>            Move True to SqlScriptArray.bError
88563>>>            Function_Return SqlScriptArray
88564>>>        End
88564>>>>
88564>>>
88564>>>        // First decide the size of the script
88564>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
88566>>>        Read_Block channel iChannel uCharData -1 // -1 means that all data should be read.
88568>>>        Close_Input channel iChannel
88570>>>
88570>>>        Move (SizeOfArray(uCharData)) to nByteCount
88571>>>        If (nByteCount  < 1) Begin
88573>>>            Send Seq_Release_Channel iChannel
88574>>>            Move True to SqlScriptArray.bError
88575>>>            Function_Return SqlScriptArray
88576>>>        End
88576>>>>
88576>>>
88576>>>        // If necessary change the string argument_size
88576>>>        Get_Argument_Size to iArgumentSize
88577>>>        If (nByteCount >= iArgumentSize) Begin
88579>>>            Move (nByteCount + 2048) to nByteCount
88580>>>            Set_Argument_Size nByteCount // Set new argument size just a bit higher than "needed" for overhead margin.
88581>>>>
88581>>>            Move True          to SqlScriptArray.bArgumentSizeChanged
88582>>>            Move iArgumentSize to SqlScriptArray.iOrgArgumentSize
88583>>>        End
88583>>>>
88583>>>        Else Begin
88584>>>            Move False to SqlScriptArray.bArgumentSizeChanged
88585>>>        End
88585>>>>
88585>>>
88585>>>        // Read the script file from memory line-by-line
88585>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
88587>>>            Move 0 to iCount
88588>>>            Repeat
88588>>>>
88588>>>                Readln channel iChannel sSQLScript
88590>>>                Move sSQLScript to SqlScriptArray.sSQLScriptArray[iCount]
88591>>>                Increment iCount
88592>>>            Until (SeqEof = True)
88594>>>        Close_Input channel iChannel
88596>>>        Send Seq_Release_Channel iChannel
88597>>>
88597>>>        // Finally "sanitize" the script by removing all comments.
88597>>>        Get _SqlUtilSanitizeScript SqlScriptArray to SqlScriptArray
88598>>>
88598>>>        Function_Return SqlScriptArray
88599>>>    End_Function
88600>>>
88600>>>    Function SqlUtilExecuteEmbeddedScript tSQLScriptArray SQLScriptArray String sDriverID Boolean bCreateScriptFile String sMemFileName Boolean bShowProgr Returns Boolean
88602>>>        String sSQLVal sStmt sCR sGOKeyWord sNoCountKeyWord sMessage sExportFile
88602>>>        Handle hoSql hoSQLConnect hoStmt hoError
88602>>>        Integer i iMsgs iRows iRowType iCount iChunkCounter iChunkMax iOut iNextSet iMessage
88602>>>        String[] sMsg aSQLQueryMessages
88604>>>        DateTime dtQueryExecStart dtQueryExecEnd
88604>>>        TimeSpan tsQuery
88604>>>        tSqlErrorArray aSqlErrorArray
88604>>>        tSqlErrorArray aSqlErrorArray
88604>>>        tSQLConnection SQLConnection
88604>>>        tSQLConnection SQLConnection
88604>>>        Boolean bMertechDriver bShowProgress
88604>>>
88604>>>        If (num_arguments > 4) Begin
88606>>>            Move bShowProgr to bShowProgress
88607>>>        End
88607>>>>
88607>>>        Get IsMertechDriver sDriverID to bMertechDriver
88608>>>        If (bMertechDriver = False) Begin
88610>>>            Get phoSQLManager to hoSql
88611>>>        End
88611>>>>
88611>>>        Else Begin
88612>>>            Get _MertechSQLManagerHandle to hoSql
88613>>>        End
88613>>>>
88613>>>
88613>>>        Get _SqlFindKeyWord CI_SQLGO to sGOKeyWord
88614>>>        // There seems to be a problem to pass strings when their value gets really big, aka
88614>>>        // above the argument_size level. It isn't clear when these problems starts but sooner
88614>>>        // or later SqlExecDirect stops working correctly with no error messages!
88614>>>        // To guard from this we set a max number of lines (iChunkMax) that can be processed
88614>>>        // at a time. Testing with the Create Chinook Database script; 500 seems like a number that works fine.
88614>>>        // A bonus of this is that it turns out that it is actually faster to run in chunks!
88614>>>        Get piChunkMax to iChunkMax
88615>>>        Move 0 to iChunkCounter
88616>>>        Move "" to sStmt
88617>>>
88617>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
88618>>>        Move (Character(13) + Character(10)) to sCR
88619>>>
88619>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
88620>>>
88620>>>        If (bMertechDriver = True) Begin
88622>>>            Get _MertechSQLConnect sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
88623>>>        End
88623>>>>
88623>>>        If (bMertechDriver = False) Begin
88625>>>            Get phoSQLManager  to hoSQL
88626>>>            Send SqlSetConnect of hoSQL sDriverID SQLConnection.sConnectionString
88627>>>            Get SqlConnect     of hoSQL "" "" to hoSQLConnect
88628>>>        End
88628>>>>
88628>>>
88628>>>        If (hoSQLConnect <> 0) Begin
88630>>>            Move False to Err
88631>>>            Get SqlOpen of hoSQLConnect to hoStmt
88632>>>            If (hoStmt <> 0) Begin
88634>>>
88634>>>                // If the embedded resource should be written as a script file to disk:
88634>>>                If (bCreateScriptFile = True) Begin
88636>>>                    Get psHome of (phoWorkspace(ghoApplication)) to sExportFile
88637>>>                    Get vFolderFormat sExportFile to sExportFile
88638>>>                    Move (sExportFile + sMemFileName) to sExportFile
88639>>>                    Get Seq_New_Channel to iOut
88640>>>                    If (iOut <> DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
88642>>>                        Direct_Output channel iOut sExportFile
88644>>>                    End
88644>>>>
88644>>>                End
88644>>>>
88644>>>
88644>>>                // Record starting date/time stamp
88644>>>                Move (CurrentDateTime()) to dtQueryExecStart
88645>>>                // Turn on error handling if enabled
88645>>>                If (pbHandleQueryErrors(Self)) Begin
88647>>>                    Set pbSqlError to False
88648>>>                    Set paSqlErrorArray to aSqlErrorArray
88649>>>                    Move Error_Object_Id to hoError
88650>>>                    Move Self to Error_Object_Id
88651>>>                End
88651>>>>
88651>>>
88651>>>                Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iRows
88652>>>                Decrement iRows
88653>>>                Move (sNoCountKeyWord + sCR) to sStmt
88654>>>
88654>>>                For iCount from 0 to iRows
88660>>>>
88660>>>                    Move (SQLScriptArray.sSQLScriptArray[iCount]) to sSQLVal
88661>>>
88661>>>                    If (Uppercase(sSQLVal) <> sGOKeyWord) Begin
88663>>>                        If (sSQLVal <> "") Begin
88665>>>                            Move (sSQLVal + sCR) to sSQLVal
88666>>>                        End
88666>>>>
88666>>>                        Move (Append(sStmt, (sSQLVal))) to sStmt
88667>>>                    End
88667>>>>
88667>>>
88667>>>                    // - Each time we encounter a "GO" statement we execute it,
88667>>>                    // or if at the very end of the script.
88667>>>                    If (Uppercase(sSQLVal) = sGOKeyWord or iChunkCounter >= iChunkMax or iCount = iRows) Begin
88669>>>
88669>>>                        // - It turns out it can be at least 10 times faster to execute SQL statements in chunks,
88669>>>                        // instead of all in one go.
88669>>>                        Send SqlExecDirect of hoStmt sStmt
88670>>>
88670>>>                        If (bCreateScriptFile = True) Begin
88672>>>                            Write channel iOut sStmt
88674>>>                        End
88674>>>>
88674>>>                        Move "" to sStmt
88675>>>                        Move 0 to iChunkCounter
88676>>>                    End
88676>>>>
88676>>>                    Increment iChunkCounter
88677>>>                Loop
88678>>>>
88678>>>
88678>>>                Repeat
88678>>>>
88678>>>                    If (pbHandleQueryErrors(Self)) Begin
88680>>>                        Move hoError to Error_Object_Id
88681>>>                    End
88681>>>>
88681>>>                    Move (CurrentDateTime()) to dtQueryExecEnd
88682>>>
88682>>>                    Send _SqlColumnInfo hoStmt
88683>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT to iRows
88684>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
88685>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_NUMMESSAGES to iMsgs
88686>>>                    Set piRows    to iRows
88687>>>                    Set piRowType to iRowType
88688>>>
88688>>>                    If (iMsgs <> 0) Begin
88690>>>                        If (ghoDbUpdateHandler > 0) Begin
88692>>>                            Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
88693>>>                        End
88693>>>>
88693>>>                        For i from 1 to iMsgs
88699>>>>
88699>>>                            Get SqlGetMessage of hoStmt i to sMessage
88700>>>                            Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
88701>>>                            If (bShowProgress = True) Begin
88703>>>                                If (Active_State(ghoStatusPanel)) Begin
88705>>>                                    Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
88706>>>                                End
88706>>>>
88706>>>                                Else Begin
88707>>>                                    Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
88709>>>                                End
88709>>>>
88709>>>                            End
88709>>>>
88709>>>                            Move sMessage to sMsg[SizeOfArray(sMsg)]
88710>>>                            Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
88711>>>                        Loop
88712>>>>
88712>>>
88712>>>
88712>>>                        If (ghoDbUpdateHandler > 0) Begin
88714>>>                            Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
88715>>>                        End
88715>>>>
88715>>>                        Set paQueryMessages to sMsg
88716>>>                    End
88716>>>>
88716>>>
88716>>>                    Get SQLNextResultSet of hoStmt to iNextSet
88717>>>                Until (iNextSet = 0)
88719>>>
88719>>>                Move (CurrentDateTime()) to dtQueryExecEnd
88720>>>            End
88720>>>>
88720>>>
88720>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
88721>>>            Set ptsQueryExec to tsQuery
88722>>>            Send SqlClose of hoStmt
88723>>>
88723>>>            If (bCreateScriptFile = True) Begin
88725>>>                Close_Output channel iOut
88727>>>                Send Seq_Release_Channel iOut
88728>>>            End
88728>>>>
88728>>>        End
88728>>>>
88728>>>        Send SqlDisconnect of hoSQLConnect
88729>>>
88729>>>        Function_Return (hoSQLConnect <> 0 and Err = False)
88730>>>    End_Function
88731>>>
88731>>>    // * Dummy function for the Studio's Code Explorer *
88731>>>    Function SQL_UTILITY_FUNCTIONS Returns Boolean
88733>>>        Function_Return False
88734>>>    End_Function
88735>>>
88735>>>    // Does three things with auxilirary files;
88735>>>    // 1) Deletes the cache file in the first Data folder of the psDataPath property as the table at the SQL end has been changed.
88735>>>    // 2) Adds the sColumnName to the TableName.tag file in the first Data folder of the psDataPath property
88735>>>    // 3) Creates a new TableName.fd file if the DdSrc folder is available (if this is a development environment)
88735>>>    Function SqlUtilAdjustAuxFiles Handle hTable String sTableName String sColumnName Returns Boolean
88737>>>        String sDataPath sDDSrcPath sDriverID
88737>>>        Boolean bOK bExists bMertechDriver
88737>>>        Integer iCount iCh iPos
88737>>>
88737>>>        // If table name equals e.g. "dbo.MyTable" we need to remove the prefix.
88737>>>        If (sTableName contains ".") Begin
88739>>>            Move (Pos(".", sTableName)) to iPos
88740>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
88741>>>        End
88741>>>>
88741>>>
88741>>>        Get psDriverID to sDriverID
88742>>>        Get psDataPathFirstPart to sDataPath
88743>>>        Get vFolderExists sDataPath to bOK
88744>>>        If (bOK = False) Begin
88746>>>            Error DFERR_PROGRAM "Function SqlUtilAdjustAuxFiles; psDataPath not found!"
88747>>>>
88747>>>            Function_Return False
88748>>>        End
88748>>>>
88748>>>
88748>>>        Get IsMertechDriver sDriverID to bMertechDriver
88749>>>        // First delete the cache file:
88749>>>        Get UtilDeleteCacheFile sTableName to bOK
88750>>>
88750>>>        Get Seq_New_Channel to iCh
88751>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
88753>>>            Function_Return False
88754>>>        End
88754>>>>
88754>>>
88754>>>        Get vFilePathExists (sDataPath + sTableName + ".tag") to bExists
88755>>>        If (bExists = False) Begin
88757>>>            Function_Return False
88758>>>        End
88758>>>>
88758>>>
88758>>>        // Add the new column name to the .tag file:
88758>>>        Append_Output channel iCh (sDataPath + sTableName + ".tag")
88760>>>            Writeln channel iCh sColumnName
88763>>>        Close_Output
88764>>>
88764>>>        // If in development environment; output new .fd file:
88764>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
88765>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
88766>>>        If (iCount > 1) Begin
88768>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
88769>>>        End
88769>>>>
88769>>>        Get vFolderExists sDDSrcPath to bExists
88770>>>        If (bExists = True) Begin
88772>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
88773>>>            Move False to Err
88774>>>            Get AutoConnectionIDLogin to bOK
88775>>>            If (hTable <> 0) Begin
88777>>>                Open hTable
88779>>>            End
88779>>>>
88779>>>            Else Begin
88780>>>                Get UtilTableOpen hTable sTableName DF_SHARE to bOK
88781>>>            End
88781>>>>
88781>>>
88781>>>            Get_Attribute DF_FILE_OPENED of hTable to bOK
88784>>>            If (bOK = True) Begin
88786>>>                Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
88788>>>            End
88788>>>>
88788>>>            If (Err = True) Begin
88790>>>                Move False to bOK
88791>>>            End
88791>>>>
88791>>>        End
88791>>>>
88791>>>
88791>>>        Function_Return (bOK = True)
88792>>>    End_Function
88793>>>
88793>>>    // Message for changing .int files to use connection ID's
88793>>>    //
88793>>>    // Changes all ".int" files for the passed sDataPath to use a sConnectionID,
88793>>>    // OR changes an existing connection id to a new id.
88793>>>    // Pass the full path to the data folder and the name of the connection id (string value).
88793>>>    // Pass a True for the bShowResult parameter to show work in progress (showln's).
88793>>>    Procedure SqlUtilChangeIntFilesToConnectionIDs String sDataPath String sConnectionID Boolean bShowResult
88795>>>        String sFileName sDriverID sDriverFile sConnectionString
88795>>>        String[] sFilesData
88796>>>        Boolean bOK bCancel
88796>>>        Integer iSize iCount
88796>>>
88796>>>        Get SqlUtilEnumerateIntFiles sDataPath to sFilesData
88797>>>        Move (SizeOfArray(sFilesData))    to iSize
88798>>>        If (iSize = 0) Begin
88800>>>            If (ghoStatusPanel <> 0) Begin
88802>>>                If (Active_State(ghoStatusPanel)) Begin
88804>>>                    Send Stop_StatusPanel of ghoStatusPanel
88805>>>                End
88805>>>>
88805>>>            End
88805>>>>
88805>>>            Send Info_Box "No .int files found! Nothing was changed."
88806>>>            Procedure_Return
88807>>>        End
88807>>>>
88807>>>
88807>>>        Move (Trim(sConnectionID)) to sConnectionID
88808>>>        Get vFolderFormat sDataPath to sDataPath
88809>>>        Decrement iSize
88810>>>        For iCount from 0 to iSize
88816>>>>
88816>>>            Move sFilesData[iCount] to sFileName
88817>>>            // This makes sure that we also can change an existing connection id to something new:
88817>>>            Get UtilChangeSourceCodeLine (sDataPath + sFileName) CS_SERVER_NAME (CS_SERVER_NAME * CS_DFCONNID + "=" + sConnectionID) bShowResult to bOK
88818>>>            If (ghoStatusPanel <> 0) Begin
88820>>>                If (Active_State(ghoStatusPanel)) Begin
88822>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
88823>>>                    If (bCancel = True) Begin
88825>>>                        Send Deactivate of ghoStatusPanel
88826>>>                        Procedure_Return
88827>>>                    End
88827>>>>
88827>>>                End
88827>>>>
88827>>>            End
88827>>>>
88827>>>        Loop
88828>>>>
88828>>>
88828>>>        Get psDriverID to sDriverID
88829>>>
88829>>>         // Finally also change the driver file e.g. MSSQLDRV.int file in the Data folder in case it has a "DFconnectionID xxxxID,SERVER..."
88829>>>        Move "" to sFileName
88830>>>        If (sDriverID = MSSQLDRV_ID) Begin
88832>>>            Move "MSSQLDrv.int" to sFileName
88833>>>        End
88833>>>>
88833>>>        If (sDriverID = DB2_DRV_ID) Begin
88835>>>            Move "DB2_Drv.int" to sFileName
88836>>>        End
88836>>>>
88836>>>        If (sDriverID = ODBC_DRV_ID) Begin
88838>>>            Move "ODBC_Drv.int" to sFileName
88839>>>        End
88839>>>>
88839>>>        If (sFileName <> "") Begin
88841>>>            Move "" to sDriverFile
88842>>>            Get_File_Path sFileName to sDriverFile
88843>>>            If (sDriverFile <> "") Begin
88845>>>                Get psConnectionString to sConnectionString
88846>>>                Get UtilChangeSourceCodeLine sDriverFile CS_SQLConnectionIDText (CS_SQLConnectionIDText * String(sConnectionID) + "," * String(sConnectionString) * String(",0")) bShowResult to bOK
88847>>>            End
88847>>>>
88847>>>        End
88847>>>>
88847>>>    End_Procedure
88848>>>
88848>>>    // Checks if the database exists in SQL. Returns = True if it does.
88848>>>    Function SqlUtilCheckIfDatabaseExists String sDatabase Returns Boolean
88850>>>        String[] sDatabaseArray
88851>>>        String sVal sServer sDriverID
88851>>>        Integer iCount iSize iPos
88851>>>        Boolean bExists
88851>>>        tSQLConnection SQLConnection
88851>>>        tSQLConnection SQLConnection
88851>>>
88851>>>        Move False to bExists
88852>>>        Get psDriverID to sDriverID
88853>>>        // DB2 doesn't need to have a "Database" name, so we always return True.
88853>>>        If (sDriverID = DB2_DRV_ID) Begin
88855>>>            Function_Return bExists
88856>>>        End
88856>>>>
88856>>>
88856>>>        Get SqlUtilEnumerateDatabases sDriverID to sDatabaseArray
88857>>>        If (SizeOfArray(sDatabaseArray) = 0) Begin
88859>>>            Function_Return False
88860>>>        End
88860>>>>
88860>>>
88860>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
88861>>>        Get ParseKeyWord SQLConnection.sConnectionString (CS_SQLIniDSNKeyword + "=") to sServer
88862>>>        If (sServer contains "/") Begin
88864>>>            Move (Pos("/", sServer)) to iPos
88865>>>            Move (Mid(sServer, 999, (iPos +1)))                        to sDatabase
88866>>>        End
88866>>>>
88866>>>
88866>>>        Move (SizeOfArray(sDatabaseArray)) to iSize
88867>>>        Decrement iSize
88868>>>        For iCount from 0 to iSize
88874>>>>
88874>>>            Move sDatabaseArray[iCount] to sVal
88875>>>            If (Uppercase(sVal) = Uppercase(sDatabase)) Begin
88877>>>                Move True to bExists
88878>>>            End
88878>>>>
88878>>>        Loop
88879>>>>
88879>>>
88879>>>        Function_Return bExists
88880>>>    End_Function
88881>>>
88881>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
88881>>>    Function SqlUtilCheckIfTableHandleExists Handle hTable String sDriverID Returns Boolean
88883>>>        String sTableName sVal
88883>>>        Boolean bExists
88883>>>        String[] sTablesArray
88884>>>        Integer iSize iCount
88884>>>
88884>>>        Move False to bExists
88885>>>        Get UtilTableHandleToString hTable to sTableName
88886>>>        Get SqlUtilEnumerateTables sDriverID to sTablesArray
88887>>>        Move (SizeOfArray(sTablesArray)) to iSize
88888>>>        Decrement iSize
88889>>>        For iCount from 0 to iSize
88895>>>>
88895>>>            Move sTablesArray[iCount] to sVal
88896>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
88898>>>                Move True to bExists
88899>>>                Move iSize to iCount // We're done!
88900>>>            End
88900>>>>
88900>>>        Loop
88901>>>>
88901>>>
88901>>>        Function_Return bExists
88902>>>    End_Function
88903>>>
88903>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
88903>>>    Function SqlUtilCheckIfTableNameExists String sTableName String sDriverID Returns Boolean
88905>>>        String sVal
88905>>>        Boolean bExists
88905>>>        String[] sTablesArray
88906>>>        Integer iSize iCount
88906>>>
88906>>>        Move False to bExists
88907>>>        Get SqlUtilEnumerateTables sDriverID to sTablesArray
88908>>>        Move (SizeOfArray(sTablesArray)) to iSize
88909>>>        Decrement iSize
88910>>>        For iCount from 0 to iSize
88916>>>>
88916>>>            Move sTablesArray[iCount] to sVal
88917>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
88919>>>                Move True to bExists
88920>>>                Move iSize to iCount // We're done!
88921>>>            End
88921>>>>
88921>>>        Loop
88922>>>>
88922>>>
88922>>>        Function_Return bExists
88923>>>    End_Function
88924>>>
88924>>>    // ToDo: This index name function needs to be finished...
88924>>>    Function SqlUtilCheckIfIndexNameExists Handle hTable String sIndexName Returns Boolean
88926>>>        String sSchema sTableName sDriverID
88926>>>        Boolean bExists
88926>>>
88926>>>        Get psDriverID to sDriverID
88927>>>        Get psSchema to sSchema
88928>>>        Get UtilTableHandleToString hTable to sTableName
88929>>>
88929>>>        Function_Return bExists
88930>>>    End_Function
88931>>>
88931>>>    // Checks if a column/field name exists in a SQL table definition
88931>>>    // Returns True if it does
88931>>>    // Sample:
88931>>>    //   Get SQLUtilColumnExists "MySQLTable" "MyColumnName" to bExists
88931>>>    Function SqlUtilColumnExists String sTableName String sFieldName Returns Boolean
88933>>>        Integer iNumColumns iColumn
88933>>>        String sColumn sDriverID
88933>>>        String[] sColumnsArray
88934>>>        Boolean bExists bOK
88934>>>
88934>>>        Move False to bExists
88935>>>        Get AutoConnectionIDLogin to bOK
88936>>>        Get psDriverID to sDriverID
88937>>>
88937>>>        Get SqlUtilEnumerateColumns sDriverID sTableName to sColumnsArray
88938>>>        Move (SizeOfArray(sColumnsArray)) to iNumColumns
88939>>>        Decrement iNumColumns
88940>>>        For iColumn from 0 to iNumColumns
88946>>>>
88946>>>            Move sColumnsArray[iColumn] to sColumn
88947>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
88949>>>                Move True to bExists
88950>>>                Move iNumColumns to iColumn // We're out of here
88951>>>            End
88951>>>>
88951>>>        Loop
88952>>>>
88952>>>
88952>>>        Function_Return bExists
88953>>>    End_Function
88954>>>
88954>>>    Function SqlUtilConvertColumnTypesToSQL2008 Handle hTable Returns Boolean
88956>>>        Integer iNumColumns iColumn iDFType iNativeType
88956>>>        Boolean bOpened bOK
88956>>>        String sColumnName sNativeTypeName
88956>>>
88956>>>        Get AutoConnectionIDLogin to bOK
88957>>>        Get OpenTableExclusive hTable to bOK
88958>>>        If (bOK = False) Begin
88960>>>            Function_Return False
88961>>>        End
88961>>>>
88961>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
88964>>>        If (bOpened = False) Begin
88966>>>            Error DFERR_PROGRAM ("Function SQLUtilConvertColumnTypesToSQL2008; Could not open table" * String(hTable))
88967>>>>
88967>>>            Function_Return False
88968>>>        End
88968>>>>
88968>>>
88968>>>        Move False to Err
88969>>>
88969>>>        Structure_Start hTable
88970>>>            Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
88973>>>
88973>>>            For iColumn from 1 to iNumColumns
88979>>>>
88979>>>                Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iDfType
88982>>>                Get_Attribute DF_FIELD_NAME             of hTable iColumn to sColumnName
88985>>>                Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iNativeType
88988>>>                Get_Attribute DF_FIELD_NATIVE_TYPE_Name of hTable iColumn to sNativeTypeName
88991>>>
88991>>>                Case Begin
88991>>>                    Case (iDFType = DF_DATE)
88993>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
88995>>>                            // Convert datetime to date
88995>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_DATE
88998>>>                        End
88998>>>>
88998>>>                        Case Break
88999>>>                    Case (iDFType = DF_DATETIME)
89002>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
89004>>>                            // Convert datetime to datetime2
89004>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_TIMESTAMP2
89007>>>                        End
89007>>>>
89007>>>                        Case Break
89008>>>                    Case (iDFType = DF_ASCII)
89011>>>                        If (iNativeType = SQL_CHAR) Begin
89013>>>                            // Convert char to varchar
89013>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
89016>>>                        End
89016>>>>
89016>>>                        Case Break
89017>>>                    Case (iDFType = DF_TEXT)
89020>>>                        If (iNativeType = SQL_LONGVARCHAR) Begin
89022>>>                            // Convert text to varchar(max)
89022>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
89025>>>                        End
89025>>>>
89025>>>                        Case Break
89026>>>                    Case (iDFType = DF_BINARY)
89029>>>                        If (iNativeType = SQL_LONGVARBINARY) Begin
89031>>>                            // Convert image to varbinary(max)
89031>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARBINARY
89034>>>                        End
89034>>>>
89034>>>                        Case Break
89035>>>                Case End
89035>>>            Loop
89036>>>>
89036>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89037>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89039>>>
89039>>>        Set Action_Text of ghoStatusPanel to ""
89040>>>        Function_Return (Err = False)
89041>>>    End_Function
89042>>>
89042>>>
89042>>>    // Will create an SQL table with the passed sTableName & sColumnName as Numeric 4.2 to keep
89042>>>    // the DbUpdateVersion database revision in.
89042>>>    // Also pass the file number of the current (embedded?) table number used in development.
89042>>>    // It will first create the SQL Table & column, then create the .int file and change Filelist.cfg
89042>>>    Function SqlUtilCreateDbVersionTable Handle hTable String sColumnName String sDriverID Returns Boolean
89044>>>        Boolean bOK bOpened
89044>>>        String sTableName sDataType sAlterTable sAddColumn sLengthAndDecimals sStmt
89044>>>
89044>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
89047>>>        Get _TableNameOnly sTableName to sTableName
89048>>>        If (sTableName = "") Begin
89050>>>            Function_Return False
89051>>>        End
89051>>>>
89051>>>
89051>>>        // This just creates the table and a "dummy" column.
89051>>>        Get SqlTableCreate hTable sDriverID to bOK
89052>>>        If (bOK = False) Begin
89054>>>            Function_Return False
89055>>>        End
89055>>>>
89055>>>
89055>>>        Close hTable
89056>>>        Move False to Err
89057>>>
89057>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
89058>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
89059>>>        Move "Decimal" to sDataType
89060>>>        Get _SqlFormatLengthAndDecimalAsString 4 2 to sLengthAndDecimals
89061>>>
89061>>>        // Adds the "sColumnName" passed to the function
89061>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals) to sStmt
89062>>>        Send SqlUtilExecuteQuery sStmt sDriverID
89063>>>
89063>>>        // Now we can delete the dummy column:
89063>>>        Get SqlColumnRemoveByTableName sTableName "Dummy" to bOK
89064>>>
89064>>>        // Finally, we attach to the newly created table.
89064>>>        If (Err = False) Begin
89066>>>            Get ApiTableAttachToSQL hTable True to bOK
89067>>>        End
89067>>>>
89067>>>        Open hTable
89069>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
89072>>>
89072>>>        Function_Return (Err = False and bOK = True and bOpened = True)
89073>>>    End_Function
89074>>>
89074>>>    // The table must already exist in the filelist for this function to work.
89074>>>    // It creates a rudimentary .int file in the first Data folder of the psDataPath property.
89074>>>    Function SqlUtilCreateIntFile Handle hTable String sDriverID String sConnectionID Boolean bAnsi Boolean bSysFile Returns Boolean
89076>>>        Boolean bOK bExists bUseConnectionID bMertech
89076>>>        String sDataPath sRootName sLogicalName sPhysicalFileName sConnectionString sDatabaseName sSchemaName sANSI_OEM
89076>>>        String[] sIndexArray
89077>>>        Integer iCount iCh iSize
89077>>>
89077>>>        Move (Trim(sConnectionID) <> "") to bUseConnectionID
89078>>>        Get psConnectionString to sConnectionString
89079>>>
89079>>>        Move CS_ANSI_Txt to sANSI_OEM
89080>>>        If (bANSI = False) Begin
89082>>>            Move CS_OEM_Txt to sANSI_OEM
89083>>>        End
89083>>>>
89083>>>
89083>>>        Get psDataPathFirstPart to sDataPath
89084>>>        Get vFolderExists sDataPath to bOK
89085>>>        If (bOK = False) Begin
89087>>>            Error DFERR_PROGRAM "Function SqlUtilCreateIntFile; psDataPath not found!"
89088>>>>
89088>>>            Function_Return False
89089>>>        End
89089>>>>
89089>>>        Get vFolderFormat sDataPath to sDataPath
89090>>>
89090>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
89093>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
89096>>>        Get _TableNameOnly sRootName to sDatabaseName
89097>>>        Move sLogicalName  to sPhysicalFileName
89098>>>        Move (sPhysicalFileName + ".int") to sPhysicalFileName
89099>>>
89099>>>        Get IsMertechDriver sDriverID to bMertech
89100>>>        If (bMertech = True) Begin
89102>>>            // This should not be called here. Instead it is called by the SqlUtilUpdateIntFile!
89102>>>            // Else it will create an error in the error log (although it won't do anything...)
89102>>>            // Get _MertechSqlUtilCreateIntFile hTable sDataPath sPhysicalFileName to bOK
89102>>>            Function_Return (bOK = True)
89103>>>        End
89103>>>>
89103>>>
89103>>>        Get psSchema hTable to sSchemaName
89104>>>        If (sSchemaName = "") Begin
89106>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchemaName
89107>>>        End
89107>>>>
89107>>>
89107>>>        // If the .int file already exists; we rename it to "FileName" + ".bak"
89107>>>        Get vFilePathExists (sDataPath + sPhysicalFileName) to bExists
89108>>>        If (bExists = True) Begin
89110>>>            Get vRenameFile (sDataPath + sPhysicalFileName) (sDataPath + sPhysicalFileName + ".bak") to bOK
89111>>>        End
89111>>>>
89111>>>
89111>>>        Get UtilDeleteCacheFile sRootName to bOK
89112>>>        Get SqlUtilEnumerateIndexes sRootName sDriverID to sIndexArray
89113>>>
89113>>>        Get Seq_Open_Output_Channel (sDataPath + sPhysicalFileName) to iCh
89114>>>            Writeln channel iCh CS_DRIVER_NAME     " " sDriverID
89119>>>            If (bUseConnectionID = True) Begin
89121>>>                Writeln channel iCh CS_SERVER_NAME " " CS_DFCONNID "=" sConnectionID
89128>>>            End
89128>>>>
89128>>>            Else Begin
89129>>>                Writeln channel iCh CS_SERVER_NAME " " CS_SERVER "=" sConnectionString
89136>>>            End
89136>>>>
89136>>>            Writeln channel iCh CS_DATABASE_NAME          " " sDatabaseName
89141>>>            Writeln channel iCh CS_SCHEMA_NAME            " " (Lowercase(sSchemaName))
89146>>>            // There seems to be a new order how these are set from DF19.
89146>>>            If (bSysFile = True) Begin
89148>>>                Writeln channel iCh CS_RECNUM_TABLE       " " "NO"
89153>>>            End
89153>>>>
89153>>>            Writeln channel iCh CS_TABLE_CHARACTER_FORMAT " " sANSI_OEM
89158>>>            Writeln channel iCh CS_USE_DUMMY_ZERO_DATE    " " "YES" // ToDo: We maybe need to paramerize this setting?
89163>>>            If (bSysFile = True) Begin
89165>>>                Writeln channel iCh CS_SYSTEM_FILE        " " "YES"
89170>>>            End
89170>>>>
89170>>>
89170>>>            If (bSysFile = False) Begin
89172>>>                Move (SizeOfArray(sIndexArray)) to iSize
89173>>>                Move (SortArray(sIndexArray)) to sIndexArray
89174>>>                If (iSize > 0) Begin
89176>>>                    Writeln channel iCh (CS_PRIMARY_INDEX * String("0"))
89179>>>                    Writeln channel iCh // Just an empty line
89181>>>                End
89181>>>>
89181>>>                Decrement iSize
89182>>>                For iCount from 0 to iSize
89188>>>>
89188>>>                    Writeln channel iCh (CS_INDEX_NUMBER * String(iCount))
89191>>>                    Writeln channel iCh (CS_INDEX_NAME   * String(sIndexArray[iCount]))
89194>>>                    Writeln channel iCh
89196>>>                Loop
89197>>>>
89197>>>            End
89197>>>>
89197>>>        Send Seq_Close_Channel iCh
89198>>>
89198>>>        // Wait a sec for Windows to finish writing the file:
89198>>>        Sleep 1
89199>>>
89199>>>        Function_Return (bOK = True)
89200>>>    End_Function
89201>>>
89201>>>    // Returns a handle to the SQL server associated with the passed driver ID.
89201>>>    // Pass e.g. the psServer property to determine the current connection server.
89201>>>    // Returns a handle to the database connection, or a zero (0) if it fails.
89201>>>    // This handle can be used to obtain attributes about the server, such as default
89201>>>    // column types.
89201>>>    Function SqlUtilDatabaseHandle String sDriverID String sServer Returns Handle
89203>>>        Handle hDatabase
89203>>>        Integer iDriver iServers iCount
89203>>>        String sValue
89203>>>
89203>>>        If (sServer = "") Begin
89205>>>            Function_Return 0
89206>>>        End
89206>>>>
89206>>>
89206>>>        Get DriverIndex sDriverID to iDriver
89207>>>        If (iDriver = 0) Begin
89209>>>            Function_Return 0
89210>>>        End
89210>>>>
89210>>>
89210>>>        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iServers
89213>>>        For iCount from 1 to iServers
89219>>>>
89219>>>            Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
89222>>>            If (Uppercase(sValue) contains Uppercase(sServer)) Begin
89224>>>                Get_Attribute DF_DATABASE_ID of iDriver iCount to hDatabase
89227>>>            End
89227>>>>
89227>>>        Loop
89228>>>>
89228>>>
89228>>>        Function_Return hDatabase
89229>>>    End_Function
89230>>>
89230>>>//    Function UtilIsFilelistEntryDriverBased Integer hTable String sDriverID Returns Boolean
89230>>>//        String sRootName
89230>>>//        Boolean bOK
89230>>>//
89230>>>//        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
89230>>>//        Move (sRootName contains sDriverID) to bOK
89230>>>//
89230>>>//        Function_Return bOK
89230>>>//    End_Function
89230>>>
89230>>>//    Function UtilFilelistAddDriverInfo Integer hTable Returns Boolean
89230>>>//        String sDriverID sRootName sDisplayName sSchema sVal
89230>>>//        Integer iDbType
89230>>>//        Boolean bOK
89230>>>//
89230>>>//        Get UtilIsFilelistEntryDriverBased to bOK
89230>>>//        If (bOK = True) Begin
89230>>>//            Function_Return False
89230>>>//        End
89230>>>//
89230>>>//        Get psDriverID to sDriverID
89230>>>//        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
89230>>>//        Move (sDriverID + ":" + sRootName)           to sRootName
89230>>>//        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
89230>>>//
89230>>>//        Get psDriverID to sDriverID
89230>>>//        Get piDbType   to iDbType
89230>>>//        Get psSchema   to sSchema
89230>>>//        If (sSchema = "") Begin
89230>>>//            Get _SqlFindKeyWord CI_SQLDBO to sSchema
89230>>>//        End
89230>>>//
89230>>>//        Move (Uppercase(sDisplayName)) to sVal
89230>>>//        If (not(sVal contains (sSchema + "."))) Begin
89230>>>//            If (iDbType = EN_dbTypeDB2) Begin
89230>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
89230>>>//            End
89230>>>//            Else Begin
89230>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
89230>>>//            End
89230>>>//        End
89230>>>//
89230>>>//        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
89230>>>//        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
89230>>>//
89230>>>//        Function_Return True
89230>>>//    End_Function
89230>>>
89230>>>    // Removes all driver identifications (e.g. "MSSQLDRV;MyTable" or "MyTable.MSSQLDRV"
89230>>>    // from the passed filelist.
89230>>>    // Returns the number of tables affected.
89230>>>    Function SqlUtilFilelistRemoveDriverInfo String sFilelist Returns Integer
89232>>>        String sCurrentFileList sRootName sDisplayName sLogicalName sVal
89232>>>        Integer iRetval
89232>>>        Handle hTable
89232>>>
89232>>>        // We first save the current filelist as the passed filelist name
89232>>>        // may come from another workspace, to restore it when we're ready.
89232>>>        Get_Attribute DF_FILELIST_NAME to sCurrentFileList
89235>>>        Set_Attribute DF_FILELIST_NAME to sFilelist
89238>>>        Move 0 to hTable
89239>>>        Move 0 to iRetval
89240>>>
89240>>>        Repeat
89240>>>>
89240>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89243>>>            If (hTable <> 0) Begin
89245>>>                Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
89248>>>                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
89251>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
89254>>>                Move (Uppercase(sRootName)) to sVal
89255>>>                If (sVal contains MSSQLDRV_ID or sVal contains DB2_DRV_ID or sVal contains ODBC_DRV_ID) Begin
89257>>>                    // Prefixes:
89257>>>                    Move (Replace((MSSQLDRV_ID + ":"), sRootName, "")) to sRootName
89258>>>                    Move (Replace((DB2_DRV_ID  + ":"), sRootName, "")) to sRootName
89259>>>                    Move (Replace((ODBC_DRV_ID + ":"), sRootName, "")) to sRootName
89260>>>                    // Suffixes:
89260>>>                    Move (Replace(("." + MSSQLDRV_ID), sRootName, "")) to sRootName
89261>>>                    Move (Replace(("." + DB2_DRV_ID),  sRootName, "")) to sRootName
89262>>>                    Move (Replace(("." + ODBC_DRV_ID), sRootName, "")) to sRootName
89263>>>
89263>>>                    // Change Filelist entry:
89263>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable          to sRootName
89266>>>
89266>>>                    Move (Lowercase(sDisplayName)) to sVal
89267>>>                    If (sVal contains "dbo.") Begin
89269>>>                        Move (Replace("dbo.", sDisplayName, ""))       to sDisplayName
89270>>>
89270>>>                        // Change Filelist entry:
89270>>>                        Set_Attribute DF_FILE_DISPLAY_NAME of hTable   to sDisplayName
89273>>>                    End
89273>>>>
89273>>>                    Increment iRetval
89274>>>                End
89274>>>>
89274>>>            End
89274>>>>
89274>>>        Until (hTable = 0)
89276>>>
89276>>>        Set_Attribute DF_FILELIST_NAME to sCurrentFileList
89279>>>
89279>>>        Function_Return iRetval
89280>>>    End_Function
89281>>>
89281>>>    // To open all Sql based tables in Filelist.cfg
89281>>>    Procedure SqlUtilOpenAllTables
89283>>>        Handle hTable
89283>>>        String sRoot sDriverID
89283>>>        Boolean bOK
89283>>>
89283>>>        Move 0 to hTable
89284>>>        Move "" to sDriverID
89285>>>        Get AutoConnectionIDLogin to bOK
89286>>>
89286>>>        Repeat
89286>>>>
89286>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89289>>>            If (hTable > 0) Begin
89291>>>                Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89294>>>                If (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) Begin
89296>>>                    Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
89299>>>                    If (Uppercase(sRoot) contains ".INT" or Uppercase(sRoot) contains MSSQLDRV_ID or Uppercase(sRoot) contains DB2_DRV_ID or Uppercase(sRoot) contains ODBC_DRV_ID) Begin
89301>>>                        Open hTable
89303>>>                    End
89303>>>>
89303>>>                End
89303>>>>
89303>>>            End
89303>>>>
89303>>>
89303>>>        Until (hTable = 0)
89305>>>    End_Procedure
89306>>>
89306>>>//    Function SqlUtilSchemaName Handle hTable Returns String
89306>>>//        String sRetval sDriverID
89306>>>//        String sTableName
89306>>>//        Integer iDbType iIndex
89306>>>//        Boolean bOK
89306>>>//
89306>>>//        Get psDriverID to sDriverID
89306>>>//        Get _SqlCheckCurrentDriver sDriverID to bOK
89306>>>//        If (hTable = 0 or bOK = False) Begin
89306>>>//            Function_Return ""
89306>>>//        End
89306>>>//
89306>>>//        Move False to Err
89306>>>//        Get UtilTableHandleToString hTable to sTableName
89306>>>//        Get piDbType to iDbType
89306>>>//        Get _SqlUtilEnumerateTableIndex sTableName sDriverID to iIndex
89306>>>//        If (iIndex = -1) Begin
89306>>>//            Function_Return ""
89306>>>//        End
89306>>>//
89306>>>//        Function_Return sRetval
89306>>>//    End_Function
89306>>>
89306>>>    // Checks if the passed Table;
89306>>>    // 1) Already has a Filelist entry that points to SQL and
89306>>>    // 2) It has an .int file.
89306>>>    // If both is True it should already be connected to SQL
89306>>>    Function SqlUtilTableIsAttached String sDriverID Handle hTable Returns Boolean
89308>>>        Boolean bExists bRootName
89308>>>        String sRootName sDataPath
89308>>>
89308>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
89311>>>        Move (sRootName contains sDriverID) to bRootName
89312>>>
89312>>>        Get psDataPathFirstPart to sDataPath
89313>>>        Get vFolderExists sDataPath to bExists
89314>>>        If (bExists = False) Begin
89316>>>            // If the path doesn't exist it cannot have an .int file and we're done, although it shouldn't happen.
89316>>>            Function_Return False
89317>>>        End
89317>>>>
89317>>>
89317>>>        Get vFolderFormat sDataPath to sDataPath
89318>>>        Get _TableNameOnly sRootName to sRootName
89319>>>        Get vFilePathExists (sDataPath + sRootName + ".int") to bExists
89320>>>
89320>>>        Function_Return (bRootName = True and bExists = True)
89321>>>    End_Function
89322>>>
89322>>>    Function SqlUtilTableIsViewType String sDriverID Handle hTable Returns Boolean
89324>>>        Boolean bViewTableType bOpen bOK
89324>>>        Integer iTableCount iNumTables
89324>>>        String sTableName sOwner sTableType sEnumTableName sEnumSchemaName
89324>>>        Handle hoCliHandler
89324>>>        tSQLConnection SQLConnection
89324>>>        tSQLConnection SQLConnection
89324>>>
89324>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
89327>>>        If (bOpen = False) Begin
89329>>>            Get AutoConnectionIDLogin to bOK
89330>>>            Open hTable
89332>>>        End
89332>>>>
89332>>>
89332>>>        Get pSQLConnection to SQLConnection
89333>>>        Get phoCLIHandler to hoCliHandler
89334>>>        Set psDriverID of hoCliHandler to sDriverID
89335>>>
89335>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
89338>>>        Get _TableNameOnly sTableName to sTableName
89339>>>        Get_Attribute DF_FILE_OWNER     of hTable to sOwner
89342>>>        Get EnumerateTables of hoCliHandler SQLConnection.sConnectionString to iNumTables
89343>>>
89343>>>        For iTableCount from 1 to iNumTables
89349>>>>
89349>>>            Get TableName  of hoCliHandler iTableCount to sEnumTableName
89350>>>            Get SchemaName of hoCliHandler iTableCount to sEnumSchemaName
89351>>>            If ((Uppercase(sEnumTableName)  = Uppercase(sTableName)) and (Uppercase(sEnumSchemaName) = Uppercase(sOwner))) Begin
89353>>>                Get TableType of hoCliHandler iTableCount to sTableType
89354>>>                Move iNumTables to iTableCount // We're done.
89355>>>            End
89355>>>>
89355>>>        Loop
89356>>>>
89356>>>
89356>>>        Move (sTableType = "VIEW") to bViewTableType
89357>>>        If (bOpen = False) Begin
89359>>>            Close hTable
89360>>>        End
89360>>>>
89360>>>
89360>>>        Function_Return bViewTableType
89361>>>    End_Function
89362>>>
89362>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
89362>>>    //
89362>>>    // SQL utility function that returns a database type (string) constant
89362>>>    // corresponding to the passed iDbType.
89362>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
89364>>>        String sRetval
89364>>>        Get SqlUtilDbTypeToString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
89365>>>        Function_Return sRetval
89366>>>    End_Function
89367>>>
89367>>>    // SQL utility function that returns a database type constant (integer)
89367>>>    // corresponding to the passed sDbType string constant.
89367>>>    Function SqlUtilDbTypeToInteger String sDbType Returns Integer
89369>>>        Integer iRetval
89369>>>        Get SqlUtilDbTypeToInteger of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDbType to iRetval
89370>>>        Function_Return iRetval
89371>>>    End_Function
89372>>>
89372>>>    // Pass an integer DbType and function returns the database type integer as a string value.
89372>>>    // Used e.g. when reading a connection ini-file to display the database type in
89372>>>    // the SQL Connection program's grid.
89372>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
89374>>>        String sRetval
89374>>>        Get SqlUtilDbTypeIntegerToStringConstant of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
89375>>>        Function_Return sRetval
89376>>>    End_Function
89377>>>
89377>>>    // Pass a driver name as a string and the function will return
89377>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
89377>>>    // quite work and always returns "MS SQL Server"
89377>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
89379>>>        Integer iRetval
89379>>>        Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverID to iRetval
89380>>>        Function_Return iRetval
89381>>>    End_Function
89382>>>
89382>>>    // Returns a temp table name that consists of the RootName, an underscore and as much of a GUID
89382>>>    // that "fits" in the max allowed length for table names.
89382>>>    // Max number of characters allowed for table names;
89382>>>    // IBM DB2      = 128
89382>>>    // MS-SQL       = 128
89382>>>    // Oracle       = 128 (Version 12.2 and later. 30 characters for earlier versions)
89382>>>    // MySQL        = 64
89382>>>    // PostgreSQL   = 64
89382>>>    Function SqlUtilGUIDTempTableName String sRootName Returns String
89384>>>        String sGUIDName
89384>>>        Integer iDbType iLength
89384>>>
89384>>>        Get piDbType to iDbType
89385>>>        Move (RandomHexUUID()) to sGUIDName
89386>>>        Move (sRootName + "_" + sGUIDName) to sGUIDName
89387>>>        Move (Length(sGUIDName)) to iLength
89388>>>
89388>>>        Case Begin
89388>>>            Case (iDbType = EN_DbTypeDB2)
89390>>>            If (iLength > 128) Begin
89392>>>                Move (Left(sGUIDName, 128)) to sGUIDName
89393>>>            End
89393>>>>
89393>>>            Case Break
89394>>>
89394>>>            Case (iDbType = EN_DbTypeMSSQL)
89397>>>            If (iLength > 128) Begin
89399>>>                Move (Left(sGUIDName, 128)) to sGUIDName
89400>>>            End
89400>>>>
89400>>>            Case Break
89401>>>
89401>>>            Case (iDbType = EN_DbTypeOracle) // Note: We assume an Oracle version of 12.2 or later.
89404>>>            If (iLength > 128) Begin
89406>>>                Move (Left(sGUIDName, 128)) to sGUIDName
89407>>>            End
89407>>>>
89407>>>            Case Break
89408>>>
89408>>>            Case (iDbType = EN_DbTypeMySQL)
89411>>>            If (iLength > 64) Begin
89413>>>                Move (Left(sGUIDName, 64)) to sGUIDName
89414>>>            End
89414>>>>
89414>>>            Case Break
89415>>>
89415>>>            Case (iDbType = EN_DbTypePostgre)
89418>>>            If (iLength > 64) Begin
89420>>>                Move (Left(sGUIDName, 64)) to sGUIDName
89421>>>            End
89421>>>>
89421>>>        Case End
89421>>>
89421>>>        Function_Return sGUIDName
89422>>>    End_Function
89423>>>
89423>>>    // Reads a resource that has been embedded by the compiler and writes it to disk.
89423>>>    // Pass the memory resource file reference and the filename to be created,
89423>>>    // including full path.
89423>>>    Procedure SqlUtilCreateFileFromMemory String sMemFileName String sFileName
89425>>>        String sText
89425>>>        Integer iCh iSize iArgSize
89425>>>
89425>>>        Move ("Resource:" + sMemFileName) to sMemFileName
89426>>>        Get Seq_Open_Input_Channel sMemFileName to iCh
89427>>>            Get_Channel_Size iCh to iSize
89428>>>            Get_Argument_Size to iArgSize
89429>>>            If (iSize > iArgSize) Begin
89431>>>                Set_Argument_Size iSize
89432>>>>
89432>>>            End
89432>>>>
89432>>>            Read_Block channel iCh sText iSize
89434>>>        Send Seq_Close_Channel iCh
89435>>>
89435>>>        Get Seq_Open_Output_Channel sFileName to iCh
89436>>>            Write channel iCh sText
89438>>>        Send Seq_Close_Channel iCh
89439>>>
89439>>>        If (iSize <> iArgSize) Begin
89441>>>            Set_Argument_Size iArgSize
89442>>>>
89442>>>        End
89442>>>>
89442>>>
89442>>>        // Wait for file to be written to disk.
89442>>>        Sleep 2
89443>>>    End_Procedure
89444>>>
89444>>>    Function SqlUtilDefaultNullValue String sDriverID Integer iDbType Integer iDataType Returns String
89446>>>        String sNotNull sRetval sDefaultValue
89446>>>        Boolean bOK
89446>>>
89446>>>        Get IsSQLDriver sDriverID to bOK
89447>>>        If (bOK = False) Begin
89449>>>            Function_Return ""
89450>>>        End
89450>>>>
89450>>>
89450>>>        Get UtilDataTypeDefaultValue sDriverID iDbType iDataType to sDefaultValue
89451>>>        Get _SqlFindKeyWord CI_SQLNotNull to sNotNull
89452>>>
89452>>>        Case Begin
89452>>>            Case (iDbType = EN_dbTypeMSSQL)
89454>>>                Move ("DEFAULT" * String(sDefaultValue) * String(sNotNull)) to sRetval
89455>>>                Case Break
89456>>>            Case (iDbType = EN_dbTypeMySQL)
89459>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
89460>>>                Case Break
89461>>>            Case (iDbType = EN_dbTypePostgre)
89464>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
89465>>>                Case Break
89466>>>            Case (iDbType = EN_dbTypeDB2)
89469>>>                Move (String(sNotNull))                                     to sRetval
89470>>>                Case Break
89471>>>
89471>>>            // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
89471>>>            // ToDo: We need to look deeper into how Oracle handles NULL
89471>>>            Case (iDbType = EN_dbTypeOracle)
89474>>>                Move  ""                                                    to sRetval
89475>>>                Case Break
89476>>>
89476>>>            Case Else
89476>>>                Move  ""                                                    to sRetval
89477>>>        Case End
89477>>>
89477>>>        Function_Return sRetval
89478>>>    End_Function
89479>>>
89479>>>    Function SqlUtilUpdateIntFile Integer hTable Returns Boolean
89481>>>        String sOrgFormat sNewFormat sRootName sDatabaseName sPhysicalFileName sDriverID sDataPath
89481>>>        Boolean bOpened bOK bMertech
89481>>>
89481>>>        // For some reason this .int file update screws up of CodeMast & CodeType .int files
89481>>>        // which makes the program unable to run because they can't be opened.
89481>>>        // ToDo: This needs further investigation but for now we just skip CodeMast & CodeType .int files update...
89481>>>        // Also note that there is another helper function "UtilTableCreateCodeMastCodeTypeIntFiles" to create
89481>>>        // proper .int files for the two tables.
89481>>>        If (Uppercase(sDatabaseName) = "CODETYPE" or Uppercase(sDatabaseName) = "CODEMAST") Begin
89483>>>            Function_Return True
89484>>>        End
89484>>>>
89484>>>
89484>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
89487>>>        Get _TableNameOnly sRootName to sDatabaseName
89488>>>        Move CS_OEM_Txt  to sOrgFormat
89489>>>        Move CS_ANSI_Txt to sNewFormat
89490>>>        Get AutoConnectionIDLogin to bOK
89491>>>
89491>>>        // It seems this can be called to quickly; causing a 13001 error "Cannot open cache file for write"
89491>>>        Sleep 2
89492>>>        Get OpenTableExclusive hTable to bOpened
89493>>>        If (bOpened = False) Begin
89495>>>            Function_Return False
89496>>>        End
89496>>>>
89496>>>
89496>>>        Get psDriverID to sDriverID
89497>>>        Get IsMertechDriver sDriverID to bMertech
89498>>>        If (bMertech = True) Begin
89500>>>            Get psDataPathFirstPart to sDataPath
89501>>>            Get vFolderExists sDataPath to bOK
89502>>>            If (bOK = False) Begin
89504>>>                Error DFERR_PROGRAM "Function SqlUtilUpdateIntFile; psDataPath not found!"
89505>>>>
89505>>>                Function_Return False
89506>>>            End
89506>>>>
89506>>>            Get vFolderFormat sDataPath to sDataPath
89507>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
89510>>>            Get _TableNameOnly sRootName to sDatabaseName
89511>>>            Move sDatabaseName to sPhysicalFileName
89512>>>            Move (sPhysicalFileName + ".int") to sPhysicalFileName
89513>>>            Get _MertechSqlUtilCreateIntFile hTable sDataPath sPhysicalFileName to bOK
89514>>>            Function_Return (bOK = True)
89515>>>        End
89515>>>>
89515>>>
89515>>>        Move False to Err
89516>>>        Get_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
89519>>>        Move (Uppercase(sOrgFormat)) to sOrgFormat
89520>>>        // Lets swap the OEM/ANSI format, just to make a change in Structure_Start below (and back),
89520>>>        // to "touch" the table so the driver feels there has been a change and updates the .int file.
89520>>>        Move (If(sOrgFormat = CS_OEM_Txt, CS_ANSI_Txt, CS_OEM_Txt)) to sNewFormat
89521>>>
89521>>>        If (hTable > 0) Begin
89523>>>            Structure_Start hTable
89524>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
89527>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
89530>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89532>>>        End
89532>>>>
89532>>>        Else Begin
89533>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
89536>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
89539>>>        End
89539>>>>
89539>>>        Function_Return (Err = False)
89540>>>    End_Function
89541>>>
89541>>>    Function SqlProcedureArrayMertech String sStmt String sArgument Returns String[]
89543>>>        String[] sReturnArray
89544>>>        String sValue sUserID sPassword
89544>>>        Handle hoSQLHandler hoSQLConnect hStmt
89544>>>        Integer iFetchResult iRetval
89544>>>        tSQLConnection SQLConnection
89544>>>        tSQLConnection SQLConnection
89544>>>
89544>>>        Get _MertechSQLManagerHandle to hoSQLHandler
89545>>>        If (hoSQLHandler <> 0) Begin
89547>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
89548>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
89549>>>            If (hoSQLConnect <> 0) Begin
89551>>>                Get SQLOpen of hoSQLConnect to hStmt
89552>>>                If (hStmt <> 0) Begin
89554>>>                    Send SQLSetProcedureName of hStmt sStmt
89555>>>                    If (sArgument <> "") Begin
89557>>>                        Send SqlSetArgument  of hStmt 1 sArgument
89558>>>                    End
89558>>>>
89558>>>                    Send SQLCall of hStmt
89559>>>
89559>>>                    Get SqlReturnValue       of hStmt to iRetval
89560>>>                    If (iRetval = 0) Begin
89562>>>                        Repeat
89562>>>>
89562>>>                            Get SQLFetch of hStmt to iFetchResult
89563>>>                            If (iFetchResult <> 0) Begin
89565>>>                                Get SQLColumnValue of hStmt 1 to sValue
89566>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
89567>>>                            End
89567>>>>
89567>>>                        Until (iFetchResult = 0)
89569>>>                        Send SQLClose of hStmt
89570>>>                    End
89570>>>>
89570>>>                End
89570>>>>
89570>>>                Send SQLDisconnect of hoSQLConnect
89571>>>            End
89571>>>>
89571>>>        End
89571>>>>
89571>>>
89571>>>        Function_Return sReturnArray
89572>>>    End_Function
89573>>>
89573>>>    // * Dummy function for the Studio's Code Explorer *
89573>>>    Function SQL_ENUMERATION_FUNCTIONS Returns Boolean
89575>>>        Function_Return False
89576>>>    End_Function
89577>>>
89577>>>    // Enumerate SQL Servers.
89577>>>    // Pass a driver id. Returns a string array.
89577>>>    // The iDataSourceType (iDatSrcType) parameter is optional and is for the ODBC driver only.
89577>>>    // Note: Returns servers for MSSQLDRV; else data-sources on the machine.
89577>>>    Function SqlUtilEnumerateServers String sDriverID Integer iDatSrcType Returns String[]
89579>>>        String[] sReturnArray
89580>>>        Handle hoSQLHandler
89580>>>        String sServer
89580>>>        Integer iCount iNumItems iDataSourceType
89580>>>
89580>>>        If (num_arguments > 1) Begin
89582>>>            Move iDatSrcType to iDataSourceType
89583>>>        End
89583>>>>
89583>>>
89583>>>        Case Begin
89583>>>            Case (sDriverID = MSSQLDRV_ID)
89585>>>                Get phoMSSQLHandler to hoSQLHandler
89586>>>                // Not sure why, but this doesn't seem to work with the updated DAW MSSQLDRV driver.
89586>>>//                #IFNDEF get_ComparetConnectionById
89586>>>//                    Get EnumerateServers of hoSQLHandler to iNumItems
89586>>>//                #ELSE
89586>>>//                    Get EnumerateServersLocal of hoSQLHandler to iNumItems
89586>>>//                    If (iNumItems = 0) Begin
89586>>>                        Get EnumerateServers of hoSQLHandler to iNumItems
89587>>>//                    End
89587>>>//                #ENDIF
89587>>>                For iCount from 0 to (iNumItems - 1)
89593>>>>
89593>>>                    Get String_Value of hoSQLHandler item iCount to sServer
89594>>>                    Move (Trim(sServer)) to sReturnArray[iCount]
89595>>>                Loop
89596>>>>
89596>>>                Case Break
89597>>>
89597>>>            Case (sDriverID = DB2_DRV_ID)
89600>>>                Get phoDB2SQLHandler to hoSQLHandler
89601>>>                Send SeedDataSources of hoSQLHandler
89602>>>                Move 0 to iCount
89603>>>                Repeat
89603>>>>
89603>>>                    Get DataSources of hoSQLHandler to sServer
89604>>>                    If (sServer <> "") Begin
89606>>>                        Move (Replace(",", sServer, "")) to sServer
89607>>>                        Move sServer to sReturnArray[iCount]
89608>>>                    End
89608>>>>
89608>>>                    Increment iCount
89609>>>                Until (sServer = "")
89611>>>                Case Break
89612>>>
89612>>>            Case (sDriverID = ODBC_DRV_ID)
89615>>>                Get phoODBCSQLHandler to hoSQLHandler
89616>>>                Set DataSourceType of hoSQLHandler to iDataSourceType
89617>>>                Move 0 to iCount
89618>>>                Repeat
89618>>>>
89618>>>                    Get DataSources of hoSQLHandler to sServer
89619>>>                    If (sServer <> "") Begin
89621>>>                        Move (Replace(",", sServer, ", ")) to sServer
89622>>>                        Move sServer to sReturnArray[iCount]
89623>>>                    End
89623>>>>
89623>>>                    Increment iCount
89624>>>                Until (sServer = "")
89626>>>                Case Break
89627>>>
89627>>>            Case (sDriverID = SQLFLEX)
89630>>>                Get _MertechEnumerateSQLFlexServers to sReturnArray
89631>>>                Case Break
89632>>>
89632>>>            Case (sDriverID = ORAFLEX)
89635>>>                Get _MertechEnumerateORAFLEXServers to sReturnArray
89636>>>                Case Break
89637>>>
89637>>>            // There appearantly is no way to enumerate servers for this backend.
89637>>>            Case (sDriverID = MDSPgSQL)
89640>>>                Move "localhost" to sReturnArray[0]
89641>>>                Case Break
89642>>>
89642>>>            // There appearantly is no way to enumerate servers for this backend.
89642>>>            Case (sDriverID = MDSMySQL)
89645>>>                Move "localhost" to sReturnArray[0]
89646>>>                Case Break
89647>>>
89647>>>            Case Else
89647>>>                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateServers function"
89648>>>>
89648>>>        Case End
89648>>>
89648>>>        Function_Return sReturnArray
89649>>>    End_Function
89650>>>
89650>>>    // Returns all databases as a string array for the passed driver id.
89650>>>    Function SqlUtilEnumerateDatabases String sDriverID Returns String[]
89652>>>        String[] sReturnArray
89653>>>        Boolean bOK
89653>>>
89653>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
89654>>>        If (bOK = False) Begin
89656>>>            Function_Return sReturnArray
89657>>>        End
89657>>>>
89657>>>
89657>>>        Case Begin
89657>>>            Case (sDriverID = MSSQLDRV_ID)
89659>>>                Get _SqlDatabasesArrayMSSQL to sReturnArray
89660>>>                Case Break
89661>>>            Case (sDriverID = DB2_DRV_ID)
89664>>>                Get _SqlDatabasesArrayDB2 to sReturnArray
89665>>>                Case Break
89666>>>
89666>>>            // Enumeration of ODBC databases should be irrelevant as the database
89666>>>            // should have been specified when the ODBC source was setup with the ODBC manager.
89666>>>            Case (sDriverID = ODBC_DRV_ID)
89669>>>                Case Break
89670>>>
89670>>>            Case (sDriverID = SQLFLEX)
89673>>>                Get SqlProcedureArrayMertech "sp_databases" "" to sReturnArray
89674>>>                Case Break
89675>>>
89675>>>            Case (sDriverID = MDSPgSQL)
89678>>>                Get SqlEnumerateEsqlMertech "SELECT datname FROM pg_database" to sReturnArray
89679>>>                Case Break
89680>>>
89680>>>            Case (sDriverID = MDSMySQL)
89683>>>                Get SqlEnumerateEsqlMertech "show databases" to sReturnArray
89684>>>                Case Break
89685>>>
89685>>>            Case (sDriverID = ORAFLEX)
89688>>>                Get SqlEnumerateEsqlMertech "SELECT NAME FROM v$database" to sReturnArray
89689>>>                Case Break
89690>>>
89690>>>            Case Else
89690>>>                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateDatabases function"
89691>>>>
89691>>>        Case End
89691>>>
89691>>>        Function_Return sReturnArray
89692>>>    End_Function
89693>>>
89693>>>    // Returns all table spaces as a string array for the passed driver id.
89693>>>    Function SqlUtilEnumerateTableSpaces String sDriverID Returns String[]
89695>>>        String[] sReturnArray
89696>>>        Boolean bOK
89696>>>
89696>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
89697>>>        If (bOK = False) Begin
89699>>>            Function_Return sReturnArray
89700>>>        End
89700>>>>
89700>>>
89700>>>        Case Begin
89700>>>            Case (sDriverID = DB2_DRV_ID)
89702>>>                Get SqlEnumerateEsqlDAW "select tablespace_name from dba_tablespaces" 1 to sReturnArray
89703>>>                Case Break
89704>>>
89704>>>            Case (sDriverID = MDSPgSQL)
89707>>>                Get SqlEnumerateEsqlMertech "SELECT spcname FROM pg_tablespace" 1 to sReturnArray
89708>>>                Case Break
89709>>>
89709>>>            Case (sDriverID = ORAFLEX)
89712>>>                Get SqlEnumerateEsqlMertech "SELECT TABLESPACE_NAME FROM USER_TABLESPACES" 1 to sReturnArray
89713>>>                Case Break
89714>>>
89714>>>            Case Else
89714>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateTableSpaces function."
89715>>>>
89715>>>                Case Break
89716>>>        Case End
89716>>>
89716>>>        Function_Return sReturnArray
89717>>>    End_Function
89718>>>
89718>>>    // Returns all schemas as a string array for the passed driver id.
89718>>>    Function SqlUtilEnumerateSchemas String sDriverID Returns String[]
89720>>>        String[] sReturnArray
89721>>>        Boolean bOK
89721>>>
89721>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
89722>>>        If (bOK = False) Begin
89724>>>            Function_Return sReturnArray
89725>>>        End
89725>>>>
89725>>>
89725>>>        Case Begin
89725>>>            Case (sDriverID = DB2_DRV_ID)
89727>>>                Get SqlEnumerateEsqlDAW "select schemaname from syscat.schemata" 1 to sReturnArray
89728>>>                Case Break
89729>>>
89729>>>            Case (sDriverID = MDSPgSQL)
89732>>>                Get SqlEnumerateEsqlMertech "select schema_name from information_schema.schemata" 1 to sReturnArray
89733>>>                Case Break
89734>>>
89734>>>            Case (sDriverID = ORAFLEX)
89737>>>                Get SqlEnumerateEsqlMertech "SELECT username from dba_users WHERE default_tablespace not in ('SYSTEM','SYSAUX')" 1 to sReturnArray
89738>>>                Case Break
89739>>>
89739>>>            Case Else
89739>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateSchemas function."
89740>>>>
89740>>>                Case Break
89741>>>        Case End
89741>>>
89741>>>        Function_Return sReturnArray
89742>>>    End_Function
89743>>>
89743>>>    // Returns a string array with all tables for the current database.
89743>>>    Function SqlUtilEnumerateTables String sDriverID Returns String[]
89745>>>        String[] sReturnArray sArray
89747>>>        String sDatabase sConnectionString sSelect sSchema
89747>>>        Integer iSize iCount
89747>>>        Boolean bOK
89747>>>
89747>>>        If (sDriverID = DATAFLEX_ID) Begin
89749>>>            Function_Return sArray
89750>>>        End
89750>>>>
89750>>>
89750>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
89751>>>        If (bOK = False) Begin
89753>>>            Function_Return sReturnArray
89754>>>        End
89754>>>>
89754>>>
89754>>>        Get psConnectionString to sConnectionString
89755>>>        Get psDatabase to sDatabase
89756>>>        Get psSchema   to sSchema
89757>>>
89757>>>        Case Begin
89757>>>            Case (sDriverID = MSSQLDRV_ID)
89759>>>                Get _SqlTableArrayDAW to sReturnArray
89760>>>                Case Break
89761>>>
89761>>>            Case (sDriverID = DB2_DRV_ID)
89764>>>                Get _SqlTableArrayDAW to sReturnArray
89765>>>                Case Break
89766>>>
89766>>>            Case (sDriverID = ODBC_DRV_ID)
89769>>>                Get _SqlTableArrayDAW to sReturnArray
89770>>>                Case Break
89771>>>
89771>>>            Case (sDriverID = SQLFLEX)
89774>>>                Move ("SELECT TABLE_NAME FROM" * sDatabase + ".INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE != 'VIEW'") to sSelect
89775>>>                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
89776>>>                Case Break
89777>>>
89777>>>            Case (sDriverID = MDSMySQL)
89780>>>                Move ("SELECT TABLE_NAME from INFORMATION_SCHEMA.TABLES where TABLE_SCHEMA = '" + sDatabase + "' and TABLE_TYPE = 'BASE TABLE' order by TABLE_NAME") to sSelect
89781>>>                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
89782>>>                Case Break
89783>>>
89783>>>            Case (sDriverID = MDSPgSQL)
89786>>>                Move "select tablename, schemaname from pg_catalog.pg_tables order by tablename"  to sSelect
89787>>>                Get SqlEnumerateEsqlMertech sSelect "" to sReturnArray
89788>>>                Case Break
89789>>>
89789>>>            Case (sDriverID = ORAFLEX)
89792>>>                Move "SELECT table_name from user_tables" to sSelect
89793>>>                Get SqlEnumerateEsqlMertech sSelect to sArray
89794>>>                Move (SizeOfArray(sArray)) to iSize
89795>>>                Decrement iSize
89796>>>                For iCount from 0 to iSize
89802>>>>
89802>>>                    If (not(sArray[iCount] contains "$")) Begin
89804>>>                        Move sArray[iCount] to sReturnArray[SizeOfArray(sReturnArray)]
89805>>>                    End
89805>>>>
89805>>>                Loop
89806>>>>
89806>>>                Case Break
89807>>>
89807>>>            Case Else
89807>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateTables function."
89808>>>>
89808>>>                Case Break
89809>>>        Case End
89809>>>
89809>>>        Function_Return sReturnArray
89810>>>    End_Function
89811>>>
89811>>>    // Returns a string array with all table columns/fields for the passed table handle and driver id.
89811>>>    Function SqlUtilEnumerateColumns String sDriverID String sTableName Returns String[]
89813>>>        String[] sReturnArray
89814>>>        String sConnectionString sSelect sSchema
89814>>>        Boolean bOK
89814>>>
89814>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
89815>>>        If (bOK = False) Begin
89817>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
89818>>>>
89818>>>            Function_Return sReturnArray
89819>>>        End
89819>>>>
89819>>>
89819>>>        Get psConnectionString to sConnectionString
89820>>>        Get psSchema to sSchema
89821>>>
89821>>>        Case Begin
89821>>>            Case (sDriverID = MSSQLDRV_ID)
89823>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
89824>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
89825>>>                Case Break
89826>>>
89826>>>            Case (sDriverID = DB2_DRV_ID)
89829>>>                Move ("SELECT colname from syscat.columns WHERE tabschema = '" + sSchema + "'" * "AND tabname = '" + sTableName + "'") to sSelect
89830>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
89831>>>                Case Break
89832>>>
89832>>>            Case (sDriverID = SQLFLEX)
89835>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
89836>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
89837>>>                Case Break
89838>>>
89838>>>            Case (sDriverID = MDSMySQL)
89841>>>                Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
89842>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
89843>>>                Case Break
89844>>>
89844>>>            Case (sDriverID = MDSPgSQL)
89847>>>                Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
89848>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
89849>>>                Case Break
89850>>>
89850>>>            Case (sDriverID = ORAFLEX)
89853>>>                Move ("SELECT column_name from user_tab_cols WHERE table_name = '" + sTableName + "'") to sSelect
89854>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
89855>>>                Case Break
89856>>>
89856>>>            Case Else
89856>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateColumns function."
89857>>>>
89857>>>                Case Break
89858>>>        Case End
89858>>>
89858>>>        Function_Return sReturnArray
89859>>>    End_Function
89860>>>
89860>>>
89860>>>    // Returns a string array with all table indexes for the passed table handle and driver id.
89860>>>    Function SqlUtilEnumerateIndexes String sTableName String sDriverID Returns String[]
89862>>>        String[] sReturnArray sReturnArray2
89864>>>        String sConnectionString sSelect sSchema
89864>>>        Boolean bOK
89864>>>        Integer iCount iSize
89864>>>
89864>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
89865>>>        If (bOK = False) Begin
89867>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
89868>>>>
89868>>>            Function_Return sReturnArray
89869>>>        End
89869>>>>
89869>>>
89869>>>        Get psConnectionString to sConnectionString
89870>>>        Get psSchema to sSchema
89871>>>
89871>>>        Case Begin
89871>>>            Case (sDriverID = MSSQLDRV_ID)
89873>>>                Move ("select * from sys.indexes where object_id = (select object_id from sys.objects where name = '" + sTableName + "')") to sSelect
89874>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
89875>>>                Case Break
89876>>>
89876>>>            Case (sDriverID = DB2_DRV_ID)
89879>>>                Error "Not implemented yet! The select statement has not been finalized."
89880>>>>
89880>>>//                Move () to sSelect
89880>>>//                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
89880>>>                Case Break
89881>>>
89881>>>            Case (sDriverID = SQLFLEX)
89884>>>                Error "Not implemented yet! The select statement has not been finalized."
89885>>>>
89885>>>//                Move () to sSelect
89885>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
89885>>>                Case Break
89886>>>
89886>>>            Case (sDriverID = MDSMySQL)
89889>>>                Error "Not implemented yet! The select statement has not been finalized."
89890>>>>
89890>>>//                Move () to sSelect
89890>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
89890>>>                Case Break
89891>>>
89891>>>            Case (sDriverID = MDSPgSQL)
89894>>>                Error "Not implemented yet! The select statement has not been finalized."
89895>>>>
89895>>>//                Move () to sSelect
89895>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
89895>>>                Case Break
89896>>>
89896>>>            Case (sDriverID = ORAFLEX)
89899>>>                Error "Not implemented yet! The select statement has not been finalized."
89900>>>>
89900>>>//                Move () to sSelect
89900>>>//                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
89900>>>                Case Break
89901>>>
89901>>>            Case Else
89901>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateIndexes function."
89902>>>>
89902>>>                Case Break
89903>>>        Case End
89903>>>
89903>>>        Move (SizeOfArray(sReturnArray)) to iSize
89904>>>        Decrement iSize
89905>>>        For iCount from 0 to iSize
89911>>>>
89911>>>            If (Trim(sReturnArray[iCount]) <> "") Begin
89913>>>                Move sReturnArray[iCount] to sReturnArray2[SizeOfArray(sReturnArray2)]
89914>>>            End
89914>>>>
89914>>>        Loop
89915>>>>
89915>>>
89915>>>        Function_Return sReturnArray2
89916>>>    End_Function
89917>>>
89917>>>    // Returns a string array with all table names the passed table handle has relation ships with.
89917>>>    // The format of the array is "TableName.FieldName"
89917>>>    Function SqlUtilEnumerateRelations String sTableName String sDriverID Returns tSQLRelation[]
89919>>>        String[] sFileNameArray sFieldNameArray
89921>>>        tSQLRelation[] sRelationsArray
89921>>>        tSQLRelation[] sRelationsArray
89922>>>        String sConnectionString sSelect sSchema sFileName sFieldName
89922>>>        Boolean bOK
89922>>>        Integer iCount iSize iLength
89922>>>
89922>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
89923>>>        If (bOK = False) Begin
89925>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
89926>>>>
89926>>>            Function_Return sRelationsArray
89927>>>        End
89927>>>>
89927>>>
89927>>>        Get psConnectionString to sConnectionString
89928>>>        Get psSchema to sSchema
89929>>>
89929>>>        Case Begin
89929>>>            Case (sDriverID = MSSQLDRV_ID)
89931>>>                Move ("SELECT object_name(parent_object_id), object_name(referenced_object_id), name from sys.foreign_keys WHERE parent_object_id = object_id( '" + sTableName + "')") to sSelect
89932>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sFileNameArray
89933>>>                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
89934>>>                Case Break
89935>>>
89935>>>            Case (sDriverID = DB2_DRV_ID)
89938>>>                Error "Not implemented yet! The select statement has not been finalized."
89939>>>>
89939>>>//                Move () to sSelect
89939>>>//                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
89939>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
89939>>>                Case Break
89940>>>
89940>>>            Case (sDriverID = SQLFLEX)
89943>>>                Error "Not implemented yet! The select statement has not been finalized."
89944>>>>
89944>>>//                Move () to sSelect
89944>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
89944>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
89944>>>                Case Break
89945>>>
89945>>>            Case (sDriverID = MDSMySQL)
89948>>>                Error "Not implemented yet! The select statement has not been finalized."
89949>>>>
89949>>>//                Move () to sSelect
89949>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
89949>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
89949>>>                Case Break
89950>>>
89950>>>            Case (sDriverID = MDSPgSQL)
89953>>>                Error "Not implemented yet! The select statement has not been finalized."
89954>>>>
89954>>>//                Move () to sSelect
89954>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
89954>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
89954>>>                Case Break
89955>>>
89955>>>            Case (sDriverID = ORAFLEX)
89958>>>                Error "Not implemented yet! The select statement has not been finalized."
89959>>>>
89959>>>//                Move () to sSelect
89959>>>//                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
89959>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
89959>>>                Case Break
89960>>>
89960>>>            Case Else
89960>>>                Error DFERR_PROGRAM "Unsupported driver passed to the SqlUtilEnumerateRelations function."
89961>>>>
89961>>>                Case Break
89962>>>        Case End
89962>>>
89962>>>        Move (Length(sTableName)) to iLength
89963>>>        Move (iLength + 4)        to iLength // The related to field key has the format "FK_TableName + FieldName"
89964>>>        Move (SizeOfArray(sFileNameArray)) to iSize
89965>>>        Decrement iSize
89966>>>        For iCount from 0 to iSize
89972>>>>
89972>>>            If (Trim(sFileNameArray[iCount]) <> "") Begin
89974>>>                Move sFileNameArray[iCount]         to sFileName
89975>>>                Move sFieldNameArray[iCount]        to sFieldName
89976>>>                Move (Mid(sFieldName, 99, iLength)) to sFieldName
89977>>>                Move sFileName  to sRelationsArray[iCount].sFileName
89978>>>                Move sFieldName to sRelationsArray[iCount].sFieldName
89979>>>            End
89979>>>>
89979>>>        Loop
89980>>>>
89980>>>
89980>>>        Function_Return sRelationsArray
89981>>>    End_Function
89982>>>
89982>>>    Function SqlUtilEnumerateLoggedInUsers String sDriverID String sDatabase Returns tSQLLoggedInUser[]
89984>>>        tSQLLoggedInUser[] SQLLoggedInUser
89984>>>        tSQLLoggedInUser[] SQLLoggedInUser
89985>>>        String[] sUsers sPrograms
89987>>>        String sSelect
89987>>>        Integer iSize iCount
89987>>>
89987>>>        Case Begin
89987>>>            Case (sDriverID = MSSQLDRV_ID)
89989>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
89990>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sUsers
89991>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sPrograms
89992>>>                Case Break
89993>>>            Case (sDriverID = SQLFLEX)
89996>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
89997>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sUsers
89998>>>                Get SqlEnumerateEsqlMertech sSelect 2 to sPrograms
89999>>>                Case Break
90000>>>            Case Else
90000>>>                Error DFERR_PROGRAM ("Not implemented yet for this driver (" + sDriverID + ")")
90001>>>>
90001>>>        Case End
90001>>>
90001>>>        Move (SizeOfArray(sUsers)) to iSize
90002>>>        Decrement iSize
90003>>>        For iCount from 0 to iSize
90009>>>>
90009>>>            Move sUsers[iCount]    to SQLLoggedInUser[iCount].sUser
90010>>>            Move sPrograms[iCount] to SQLLoggedInUser[iCount].sProgram
90011>>>        Loop
90012>>>>
90012>>>
90012>>>        Function_Return SQLLoggedInUser
90013>>>    End_Function
90014>>>
90014>>>    // Returns an array with all ".int" files for the passed sDataPath, _except_ for the driver .int files;
90014>>>    // "MSSQLDRV.int", "DB2_DRV.int" & "ODBC_DRV.int".
90014>>>    Function SqlUtilEnumerateIntFiles String sDataPath Returns String[]
90016>>>        String[] sFilesData
90017>>>        Boolean bExists
90017>>>        Integer iCh
90017>>>        String sFileName sExt
90017>>>
90017>>>        Get vFolderExists sDataPath to bExists
90018>>>        If (bExists = True) Begin
90020>>>            Move (ToANSI(Trim(sDataPath))) to sDataPath
90021>>>            Move ("dir:" + sDataPath)      to sDataPath
90022>>>            Get Seq_New_Channel to iCh  // get free channel for input
90023>>>            Direct_Input channel iCh sDataPath
90025>>>                Repeat
90025>>>>
90025>>>                    Readln channel iCh sFileName
90027>>>                    Get ParseFileExtension sFileName to sExt
90028>>>                    If (Uppercase(sExt) = "INT") Begin
90030>>>                        If (not(Uppercase(sFileName) contains "MSSQLDRV" and Uppercase(sFileName) contains "DB2_DRV" and Uppercase(sFileName) contains "ODBC_DRV")) Begin
90032>>>                            Move sFileName to sFilesData[SizeOfArray(sFilesData)]
90033>>>                        End
90033>>>>
90033>>>                    End
90033>>>>
90033>>>                Until (SeqEof = True)
90035>>>            Close_Input channel iCh
90037>>>        End
90037>>>>
90037>>>        Function_Return sFilesData
90038>>>    End_Function
90039>>>
90039>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
90039>>>    // for DAW drivers.
90039>>>    // Returns: A string array.
90039>>>    Function SqlEnumerateEsqlDAW String sStmt Integer iColumn Returns String[]
90041>>>        String[] sReturnArray
90042>>>        String sValue sPrevious
90042>>>        Handle hoSQLHandler hoSQLConnect hstmt
90042>>>        Integer iFetchResult iRows
90042>>>        tSQLConnection SQLConnection
90042>>>        tSQLConnection SQLConnection
90042>>>
90042>>>        Get phoSQLManager to hoSQLHandler
90043>>>
90043>>>        If (hoSQLHandler <> 0) Begin
90045>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
90046>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
90047>>>
90047>>>            If (hoSQLConnect <> 0) Begin
90049>>>                Get SQLOpen of hoSQLConnect to hstmt
90050>>>                If (hstmt <> 0) Begin
90052>>>                    Send SqlExecDirect of hstmt sStmt
90053>>>                    Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
90054>>>                    Repeat
90054>>>>
90054>>>                        Get SQLFetch of hstmt to iFetchResult
90055>>>                        If (iFetchResult <> 0) Begin
90057>>>                            Get SQLColumnValue of hstmt iColumn to sValue
90058>>>                            If (sValue <> sPrevious) Begin
90060>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
90061>>>                            End
90061>>>>
90061>>>                            Move sValue to sPrevious
90062>>>                        End
90062>>>>
90062>>>                    Until (iFetchResult = 0)
90064>>>                    Send SQLClose of hstmt
90065>>>                End
90065>>>>
90065>>>                Send SQLDisconnect of hoSQLConnect
90066>>>            End
90066>>>>
90066>>>        End
90066>>>>
90066>>>
90066>>>        Function_Return sReturnArray
90067>>>    End_Function
90068>>>
90068>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
90068>>>    // for Mertech drivers.
90068>>>    // Returns: A string array.
90068>>>    Function SqlEnumerateEsqlMertech String sStmt Returns String[]
90070>>>        String[] sReturnArray
90071>>>        String sValue sUserID sPassword
90071>>>        Handle hoSQLHandler hoSQLConnect hStmt
90071>>>        Integer iFetchResult iRows
90071>>>        tSQLConnection SQLConnection
90071>>>        tSQLConnection SQLConnection
90071>>>
90071>>>        Get _MertechSQLManagerHandle to hoSQLHandler
90072>>>
90072>>>        If (hoSQLHandler <> 0) Begin
90074>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
90075>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
90076>>>
90076>>>            If (hoSQLConnect <> 0) Begin
90078>>>                Get SQLOpen of hoSQLConnect to hStmt
90079>>>                If (hStmt <> 0) Begin
90081>>>                    Send SqlExecDirect of hStmt sStmt
90082>>>                    Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_ROWCOUNT to iRows
90083>>>                    Repeat
90083>>>>
90083>>>                        Get SQLFetch of hStmt to iFetchResult
90084>>>                        If (iFetchResult <> 0) Begin
90086>>>                            Get SQLColumnValue of hStmt 1 to sValue
90087>>>                            Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
90088>>>                        End
90088>>>>
90088>>>                    Until (iFetchResult = 0)
90090>>>                    Send SQLClose of hStmt
90091>>>                End
90091>>>>
90091>>>                Send SQLDisconnect of hoSQLConnect
90092>>>            End
90092>>>>
90092>>>        End
90092>>>>
90092>>>
90092>>>        Function_Return sReturnArray
90093>>>    End_Function
90094>>>
90094>>>    // * Dummy function for the Studio's Code Explorer *
90094>>>    Function PRIVATE_SQL_SUB_FUNCTIONS Returns Boolean
90096>>>        Function_Return False
90097>>>    End_Function
90098>>>
90098>>>    // Returns the index for the passed sTableName
90098>>>    // Returns >= 0 if successful. It is e.g. needed to get the SchemaName for a table.
90098>>>    Function _SqlUtilEnumerateTableIndex String sTableName String sDriverID Returns Integer
90100>>>        Integer iIndex iSize iCount
90100>>>        String[] sTablesArray
90101>>>        String sVal sConnectionString
90101>>>
90101>>>        Move -1 to iIndex
90102>>>        Get psConnectionString to sConnectionString
90103>>>        Get SqlUtilEnumerateTables sDriverID to sTablesArray
90104>>>        Move (SizeOfArray(sTablesArray)) to iSize
90105>>>        Decrement iSize
90106>>>        For iCount from 0 to iSize
90112>>>>
90112>>>            Move sTablesArray[iCount] to sVal
90113>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
90115>>>                Move iCount to iIndex // We found it!
90116>>>                Move iSize to iCount  // End the loop
90117>>>            End
90117>>>>
90117>>>        Loop
90118>>>>
90118>>>
90118>>>        Function_Return iIndex
90119>>>    End_Function
90120>>>
90120>>>    // Helper function that builds a string like;
90120>>>    // "SELECT name from [Master].[sys].[databases] where name"
90120>>>    Function _SqlSelectFromWhereName Returns String
90122>>>        String sRetval sSelect sName sFrom sMaster sSys sDatabases sWhere sDBO
90122>>>
90122>>>        Get _SqlFindKeyWord CI_SQLSelect       to sSelect
90123>>>        Get _SqlFindKeyWord CI_SQLName         to sName
90124>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBO
90125>>>        Get _SqlFindKeyWord CI_SQLFrom         to sFrom
90126>>>        Get _SqlFindKeyWord CI_SQLMaster       to sMaster
90127>>>        Get _SqlFindKeyWord CI_SQLSys          to sSys
90128>>>        Get _SqlFindKeyWord CI_SQLDatabases    to sDatabases
90129>>>        Get _SqlFindKeyWord CI_SQLWhere        to sWhere
90130>>>        Move (sSelect * sName * sFrom * "[" + sMaster + "].[" + sDBO + "].[" + sSys + sDatabases + "]" * sWhere * sName) to sRetval
90131>>>        Function_Return sRetval
90132>>>    End_Function
90133>>>
90133>>>    // Helper function to create a SQL statement like;
90133>>>    // "SELECT * FROM SYS.INDEXES WHERE NAME = MyIndexName AND OBJECT_ID = OBJECT_ID([MySchmaName].[MyTableName])"
90133>>>    // Used for checking if an index exists.
90133>>>    Function _SqlQueryIfIndexExists String sSchemaName String sTableName String sIndexName Returns String
90135>>>        String sRetval sSelect sFrom sSysIndexes sWhere sObjectID sAnd sName
90135>>>
90135>>>        Get _SqlFindKeyWord CI_SQLSelect to sSelect
90136>>>        Get _SqlFindKeyWord CI_SQLFrom to sFrom
90137>>>        Get _SqlFindKeyWord CI_SQLSysIndexes to sSysIndexes
90138>>>        Get _SqlFindKeyWord CI_SQLWhere to sWhere
90139>>>        Get _SqlFindKeyWord CI_SQLObjectID to sObjectID
90140>>>        Get _SqlFindKeyWord CI_SQLAND to sAnd
90141>>>        Get _SqlFindKeyWord CI_SQLName to sName
90142>>>
90142>>>        Move (sSelect * String("*") * sFrom * sSysIndexes * sWhere * sName * "=" * sIndexName * sAnd * sObjectID * "=([" + sSchemaName + "].[" + sTableName + "])") to sRetval
90143>>>
90143>>>        Function_Return sRetval
90144>>>    End_Function
90145>>>
90145>>>    // Formats a columns iLenght & iDecimal parameters as SQL expects them in a string.
90145>>>    // E.g. (4,2), where 4 is the iLength and 2 the iDecimals param.
90145>>>    Function _SqlFormatLengthAndDecimalAsString Integer iLength Integer iDecimals Returns String
90147>>>        String sRetval
90147>>>        If (iLength <> 0) Begin
90149>>>            Move ("(" + String(iLength)) to sRetval
90150>>>            If (iDecimals <> 0) Begin
90152>>>                Move (sRetval + "," + String(iDecimals)) to sRetval
90153>>>            End
90153>>>>
90153>>>            Move (sRetval + ")") to sRetval
90154>>>        End
90154>>>>
90154>>>        Function_Return sRetval
90155>>>    End_Function
90156>>>
90156>>>    Procedure _SqlColumnInfo Handle hoStmt
90158>>>        Integer i iCols iItem
90158>>>        tSqlColumnNew[] aQueryColumns
90158>>>        tSqlColumnNew[] aQueryColumns
90159>>>
90159>>>        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
90160>>>        For i from 1 to iCols
90166>>>>
90166>>>            Move (SizeOfArray(aQueryColumns)) to iItem
90167>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASECOLUMNNAME to aQueryColumns[iItem].sBaseColumnName
90168>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASETABLENAME  to aQueryColumns[iItem].sBaseTableName
90169>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_LABEL          to aQueryColumns[iItem].sLabel
90170>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SQLTYPE        to aQueryColumns[iItem].iSqlType
90171>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_DFTYPE         to aQueryColumns[iItem].iDFType
90172>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SIZE           to aQueryColumns[iItem].iSize
90173>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_PRECISION      to aQueryColumns[iItem].iPrecision
90174>>>        Loop
90175>>>>
90175>>>        Set piColumns to iCols
90176>>>        Set paQueryColumns to aQueryColumns
90177>>>    End_Procedure
90178>>>
90178>>>    // Checks that the passed sDriverID is defined.
90178>>>    // Also checks if the driver has been loaded; else it gets loaded.
90178>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
90180>>>        Boolean bOK
90180>>>        Integer iDriver
90180>>>
90180>>>        If (sDriverID = DATAFLEX_ID) Begin
90182>>>            Function_Return False
90183>>>        End
90183>>>>
90183>>>
90183>>>        Get IsDAWSQLDriver sDriverID to bOK
90184>>>
90184>>>        If (bOK = False) Begin
90186>>>            Get IsMertechDriver sDriverID to bOK
90187>>>        End
90187>>>>
90187>>>
90187>>>        If (bOK = False) Begin
90189>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV, DB2_DRV, ODBC_DRV, SQLFLEX, ORAFLEX, MDSPgSQL or MDSMySQL"
90190>>>>
90190>>>            Function_Return False
90191>>>        End
90191>>>>
90191>>>
90191>>>        Get DriverIndex sDriverID to iDriver
90192>>>        If (iDriver = 0) Begin
90194>>>            Load_Driver sDriverID
90195>>>        End
90195>>>>
90195>>>
90195>>>        Function_Return True
90196>>>    End_Function
90197>>>
90197>>>    // Checks that the length parameter has been passed correctly.
90197>>>    // This is only of concern for certain SQL data types.
90197>>>    Function _SqlCheckLengthParamForDataType Integer iDataType Integer iLen Returns Boolean
90199>>>        Integer iLength
90199>>>        Boolean bOK bCheckTypeLength
90199>>>
90199>>>        If (num_arguments > 1) Begin
90201>>>            Move iLen to iLength
90202>>>        End
90202>>>>
90202>>>        Move (iDataType = SQL_DECIMAL   or iDataType = SQL_NUMERIC or iDataType = SQL_FLOAT   or iDataType = SQL_INTEGER or;              iDataType = SQL_VARBINARY or iDataType = SQL_BINARY  or iDataType = SQL_VARCHAR or iDataType = SQL_CHAR or;              iDataType = SQL_BIGINT    or iDataType = SQL_REAL) to bCheckTypeLength
90203>>>
90203>>>        If (bCheckTypeLength = True) Begin
90205>>>            Move (iLength > 0) to bOK
90206>>>        End
90206>>>>
90206>>>
90206>>>        Function_Return (bOK = True)
90207>>>    End_Function
90208>>>
90208>>>    Function _SqlProperTableName String sTableName Returns String
90210>>>        String sVal sSchema sDriverID
90210>>>        Integer iDbType
90210>>>
90210>>>        If (Trim(sTableName) = "") Begin
90212>>>            Function_Return ""
90213>>>        End
90213>>>>
90213>>>
90213>>>        Get psDriverID to sDriverID
90214>>>        Get piDbType   to iDbType
90215>>>        If (iDbType = EN_dbTypeOracle) Begin
90217>>>            Get psUserID to sSchema
90218>>>            // Not sure about this uppercasing but it seems like Oracle wants that?
90218>>>            Move (Uppercase(sSchema)) to sSchema
90219>>>            Move ('"' + sSchema + '"."' + sTableName + '"') to sTableName
90220>>>            Function_Return sTableName
90221>>>        End
90221>>>>
90221>>>        If (iDbType = EN_DbTypeMySQL) Begin
90223>>>            Get psDatabase to sVal
90224>>>            Move (sVal + "." + sTableName) to sTableName
90225>>>            Function_Return sTableName
90226>>>        End
90226>>>>
90226>>>        If (iDbType = EN_DbTypePostgre) Begin
90228>>>            Move ('"' + sTableName + '"') to sTableName
90229>>>            Function_Return sTableName
90230>>>        End
90230>>>>
90230>>>
90230>>>        Get psSchema to sSchema
90231>>>        If (sSchema = "") Begin
90233>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
90234>>>        End
90234>>>>
90234>>>
90234>>>        Move (Uppercase(sTableName)) to sVal
90235>>>        If (not(sVal contains (sSchema + "."))) Begin
90237>>>            If (iDbType = EN_dbTypeDB2) Begin
90239>>>                Move (Lowercase(sSchema) + "." + sTableName) to sTableName
90240>>>            End
90240>>>>
90240>>>            Else Begin
90241>>>                Move (sSchema + "." + sTableName) to sTableName
90242>>>            End
90242>>>>
90242>>>        End
90242>>>>
90242>>>
90242>>>        Function_Return sTableName
90243>>>    End_Function
90244>>>
90244>>>    // SQL column names can be case-sensitive. This function is used to check that
90244>>>    // the passed sFieldName has the correct spelling.
90244>>>    // Used with Embedded SQL statement calls.
90244>>>    // If the spelling or fieldname doesn't exist, the return value is "" (blank).
90244>>>    Function _SqlFindColumnName String sTableName String sColumnName Returns String
90246>>>        String sRetval sValue sDriverID
90246>>>        String[] sColumnNamesArray
90247>>>        Integer iCount iColumns
90247>>>
90247>>>        Move "" to sRetval
90248>>>        Get psDriverID to sDriverID
90249>>>        Get SqlUtilEnumerateColumns sDriverID sTableName to sColumnNamesArray
90250>>>        Move (SizeOfArray(sColumnNamesArray)) to iColumns
90251>>>        Decrement iColumns
90252>>>
90252>>>        For iCount from 0 to iColumns
90258>>>>
90258>>>            Move sColumnNamesArray[iCount] to sValue
90259>>>            If (Uppercase(sColumnName) = Uppercase(sValue)) Begin
90261>>>                Move sValue to sRetval
90262>>>                Move iColumns to iCount // We're done.
90263>>>            End
90263>>>>
90263>>>        Loop
90264>>>>
90264>>>
90264>>>        Function_Return sRetval
90265>>>    End_Function
90266>>>
90266>>>    Function _SqlDatabasesArrayMSSQL Returns String[]
90268>>>        String[] sReturnArray
90269>>>        Handle hoSQLHandler
90269>>>        Integer iCount iSize iItem
90269>>>        String sServer sUser sPassword
90269>>>        tSQLConnection SQLConnection
90269>>>        tSQLConnection SQLConnection
90269>>>
90269>>>        Get phoMSSQLHandler to hoSQLHandler
90270>>>        Send Delete_Data    of hoSQLHandler
90271>>>        Get pSQLConnection  of ghoSQLConnectionHandler to SQLConnection
90272>>>
90272>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
90273>>>        Get EnumerateDatabases of hoSQLHandler SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to iSize
90274>>>        Decrement iSize
90275>>>
90275>>>        For iCount from 0 to iSize
90281>>>>
90281>>>            Get String_Value of hoSQLHandler item iCount to sServer
90282>>>            Move (Trim(sServer)) to sReturnArray[iItem]
90283>>>            Increment iItem
90284>>>        Loop
90285>>>>
90285>>>
90285>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
90286>>>
90286>>>        Function_Return sReturnArray
90287>>>    End_Function
90288>>>
90288>>>    Function _SqlTableArrayDAW Returns String[]
90290>>>        String[] sReturnArray
90291>>>        String sTable sTableType sSchema sDefSchema sComment sTableKeyWord sSysKeyWord
90291>>>        Handle hoSQLHandler
90291>>>        Integer iCount iSize iItem
90291>>>        Boolean bOK
90291>>>        tSQLConnection SQLConnection
90291>>>        tSQLConnection SQLConnection
90291>>>
90291>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
90292>>>        If (SQLConnection.sConnectionString = "") Begin
90294>>>            Function_Return sReturnArray
90295>>>        End
90295>>>>
90295>>>
90295>>>        Move SQLConnection.sSchema      to sDefSchema
90296>>>        Move (Uppercase(sDefSchema))    to sDefSchema
90297>>>        Get _SqlFindKeyWord CI_SQLTable to sTableKeyWord
90298>>>        Get _SqlFindKeyWord CI_SQLSys   to sSysKeyWord
90299>>>
90299>>>        Get phoCLIHandler to hoSQLHandler
90300>>>        Set psDriverID    of hoSQLHandler to SQLConnection.sDriverID
90301>>>        Send Delete_Data  of hoSQLHandler
90302>>>
90302>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
90303>>>        Get EnumerateTables of hoSQLHandler SQLConnection.sConnectionString to iSize
90304>>>        Move False to Err
90305>>>        Decrement iSize
90306>>>
90306>>>        For iCount from 0 to iSize
90312>>>>
90312>>>            Get TableName    of hoSQLHandler iCount to sTable
90313>>>            Get TableType    of hoSQLHandler iCount to sTableType
90314>>>            Get SchemaName   of hoSQLHandler iCount to sSchema
90315>>>            Get TableComment of hoSQLHandler iCount to sComment
90316>>>            Move (Trim(sTable)) to sTable
90317>>>            If (SQLConnection.sDriverID = DB2_DRV_ID) Begin
90319>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) = sDefSchema) to bOK
90320>>>            End
90320>>>>
90320>>>            Else Begin
90321>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) <> sSysKeyWord and Uppercase(sSchema) <> "SYSTOOLS") to bOK
90322>>>            End
90322>>>>
90322>>>            If (bOK = True) Begin
90324>>>                Move sTable to sReturnArray[iItem]
90325>>>                Increment iItem
90326>>>            End
90326>>>>
90326>>>        Loop
90327>>>>
90327>>>
90327>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
90328>>>
90328>>>        Function_Return sReturnArray
90329>>>    End_Function
90330>>>
90330>>>    Function _SqlProcedureArrayDAW String sStmt String sArgument Returns String[]
90332>>>        String[] sReturnArray
90333>>>        String sValue
90333>>>        Handle hoSQLHandler hoSQLConnect hStmt
90333>>>        Integer iRetval iCols iFetchResult
90333>>>        tSQLConnection SQLConnection
90333>>>        tSQLConnection SQLConnection
90333>>>
90333>>>        Get phoSQLManager to hoSQLHandler
90334>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
90335>>>        Get SqlConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
90336>>>
90336>>>        If (hoSQLConnect <> 0) Begin
90338>>>            Get SqlOpen of hoSQLConnect to hStmt
90339>>>            If (hStmt <> 0) Begin
90341>>>                Send SqlSetProcedurename of hStmt sStmt
90342>>>                If (sArgument <> "") Begin
90344>>>                    Send SqlSetArgument  of hStmt 1 sArgument
90345>>>                End
90345>>>>
90345>>>
90345>>>                Send SqlCall             of hStmt
90346>>>                Get SqlReturnValue       of hStmt to iRetval
90347>>>                If (iRetval = 0) Begin
90349>>>                    Repeat
90349>>>>
90349>>>                        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
90350>>>                        If (iCols > 0) Begin
90352>>>                            Repeat
90352>>>>
90352>>>                                Get SqlFetch of hStmt to iFetchResult
90353>>>                                If (iFetchResult <> 0) Begin
90355>>>                                    Get SqlColumnValue of hStmt 1 to sValue
90356>>>                                    Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)]
90357>>>                                End
90357>>>>
90357>>>                            Until (iFetchResult = 0)
90359>>>                        End
90359>>>>
90359>>>                        Get SqlNextResultSet of hStmt to iRetval
90360>>>                    Until (iRetval = 0)
90362>>>                    Send SqlClose of hStmt
90363>>>                End
90363>>>>
90363>>>            End
90363>>>>
90363>>>            Send SqlDisconnect of hoSQLConnect
90364>>>        End
90364>>>>
90364>>>        Function_Return sReturnArray
90365>>>    End_Function
90366>>>
90366>>>    Function _SqlDatabasesArrayDB2 Returns String[]
90368>>>        String[] sReturnArray
90369>>>        String sDataSource
90369>>>        Handle hoSQLHandler
90369>>>        Integer iItem
90369>>>
90369>>>        Get phoDB2SQLHandler to hoSQLHandler
90370>>>        Send SeedDataSources of hoSQLHandler
90371>>>
90371>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
90372>>>
90372>>>        Repeat
90372>>>>
90372>>>            Get DataSources of hoSQLHandler to sDataSource
90373>>>            Move (Replaces(",", sDataSource, "")) to sDataSource
90374>>>            Move (Trim(sDataSource)) to sReturnArray[iItem]
90375>>>            Increment iItem
90376>>>        Until (sDataSource = "")
90378>>>
90378>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
90379>>>
90379>>>        Function_Return sReturnArray
90380>>>    End_Function
90381>>>
90381>>>    Function _SqlDatabasesArrayODBC Returns String[]
90383>>>        String[] sReturnArray
90384>>>        String sDataSource
90384>>>        Handle hoSQLHandler
90384>>>        Integer iItem
90384>>>
90384>>>        Get phoODBCSQLHandler to hoSQLHandler
90385>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
90386>>>
90386>>>        Send SeedDataSources of hoSQLHandler
90387>>>
90387>>>        Repeat
90387>>>>
90387>>>            Get DataSources of hoSQLHandler to sDataSource
90388>>>            If (Trim(sDataSource) <> "" and not(sDataSource contains "*.")) Begin
90390>>>                Move (Trim(sDataSource)) to sReturnArray[iItem]
90391>>>                Increment iItem
90392>>>            End
90392>>>>
90392>>>        Until (sDataSource = "")
90394>>>
90394>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
90395>>>
90395>>>        Function_Return sReturnArray
90396>>>    End_Function
90397>>>
90397>>>    // We might have a split Sql script where the info about which database to use is
90397>>>    // put on top of the Sql script, we then need to save it to be able to retrieve it later and
90397>>>    // insert it for scriplets to come after the first one.
90397>>>    Function _SqlFormatStatement String sStmt Returns String
90399>>>        String sUseDatabase sTmp sUseKeyWord sCreateViewKeyWord sDBOKeyWord sNoCountKeyWord sDriverID
90399>>>        Integer iStart iEnd iDbType
90399>>>        Boolean bOK
90399>>>
90399>>>        Get piDbType to iDbType
90400>>>        Get psDriverID to sDriverID
90401>>>        Get _SqlFindKeyWord CI_SQLUse          to sUseKeyWord
90402>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
90403>>>        Get _SqlFindKeyWord CI_SQLCreateView   to sCreateViewKeyWord
90404>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBOKeyWord
90405>>>        Move (Replaces(" ", sStmt, "")) to sTmp
90406>>>        If (Uppercase(sTmp) contains (sUseKeyWord +"[")) Begin
90408>>>            Move (Pos("[", (Uppercase(sTmp)))) to iStart
90409>>>            Move (Pos("]", sTmp)) to iEnd
90410>>>            Move (Mid(sTmp, (iEnd -iStart +1), iStart)) to sUseDatabase
90411>>>            Move (sUseKeyWord * sUseDatabase + " ") to sUseDatabase
90412>>>            Set Private.psUseDatabase to sUseDatabase
90413>>>        End
90413>>>>
90413>>>        Else Begin
90414>>>            Move (Uppercase(sStmt)) to sTmp
90415>>>
90415>>>            // A "Create View" statement _must_ be the very first words in a Sql statement.
90415>>>            If (not(sTmp contains sCreateViewKeyWord)) Begin
90417>>>                Get Private.psUseDatabase to sUseDatabase
90418>>>                Move (Insert(sUseDatabase, sStmt, 1)) to sStmt
90419>>>            End
90419>>>>
90419>>>
90419>>>            // This is a bit special to place here but was done so because it was easier that way.
90419>>>            // We will get an error when trying to create a view if it already exists.
90419>>>            // So to avoid such errors; we first remove it & then recreate it.
90419>>>            Else If (sTmp contains sCreateViewKeyWord) Begin
90422>>>                // Make sure we only have one space between statements/words.
90422>>>                Move (Replaces("  ", sTmp, " ")) to sTmp
90423>>>                Move (Replace(sCreateViewKeyWord, sTmp, "")) to sTmp
90424>>>                Move (Trim(sTmp)) to sTmp
90425>>>                Move (Pos(" ", sTmp)) to iEnd
90426>>>                Move (Left(sTmp, iEnd)) to sTmp
90427>>>                If ((not(sTmp contains ("[" + sDBOKeyWord + "]."))) and (not(sTmp contains (sDBOKeyWord + ".")))) Begin
90429>>>                    Move (sDBOKeyWord + "." + Trim(sTmp)) to sTmp
90430>>>                End
90430>>>>
90430>>>                Move (Trim(sTmp)) to sTmp
90431>>>                // Remove data view as it already exists!
90431>>>                Get SqlViewRemove sDriverID sTmp to bOK
90432>>>            End
90432>>>>
90432>>>        End
90432>>>>
90432>>>
90432>>>        Function_Return sStmt
90433>>>    End_Function
90434>>>
90434>>>    // Returns the proper Sql language key word(s) for the passed SQL key-word constant
90434>>>    Function _SqlFindKeyWord Integer iSQLKeywordConstant Returns String
90436>>>        String sRetval
90436>>>        Integer iDbType iIndex
90436>>>        tSQLKeyWords[] SQLKeywordArray
90436>>>        tSQLKeyWords[] SQLKeywordArray
90437>>>        tSQLKeyWords   SQLKeyWords
90437>>>        tSQLKeyWords   SQLKeyWords
90437>>>
90437>>>        // Sql back-end type. E.g. MS-SQL, MySQL, Oracle, DB2...
90437>>>        Get piDbType to iDbType
90438>>>        Move iDbType             to SQLKeyWords.iSQLDbType
90439>>>        Move iSQLKeywordConstant to SQLKeyWords.iSQLWord
90440>>>
90440>>>        Get paSQLKeywordArray to SQLKeywordArray
90441>>>        Move (SearchArray(SQLKeyWords, SQLKeywordArray, Self, RefFunc(CompareFindSQLKeyWords))) to iIndex
90442>>>        Move SQLKeywordArray[iIndex].sSQLPhrase to sRetval
90443>>>
90443>>>        Function_Return sRetval
90444>>>    End_Function
90445>>>
90445>>>    // Function will "clean/sanitize" the script by removing all comments and blank lines.
90445>>>    Function _SqlUtilSanitizeScript tSQLScriptArray SqlScriptArray Returns tSQLScriptArray[]
90447>>>        String[] sSQLScriptArray
90448>>>        String sText sLine sTmp sCommentStart sCommentEnd sDashComment
90448>>>        Integer iSize iCount
90448>>>        Boolean bCommentStart bCommentEnd bDashComment
90448>>>
90448>>>        Move False to bCommentStart
90449>>>        Move False to bCommentEnd
90450>>>        Move False to bDashComment
90451>>>        Move "/*"  to sCommentStart   // These are the standard comment start & stop tokens...
90452>>>        Move "*/"  to sCommentEnd
90453>>>        Move "--"  to sDashComment    // ...but a comment can also start with two dashes "--".
90454>>>
90454>>>        Move (SizeOfArray(SqlScriptArray.sSQLScriptArray)) to iSize
90455>>>        Decrement iSize
90456>>>        Move "" to sText
90457>>>
90457>>>        For iCount from 0 to iSize
90463>>>>
90463>>>            Move SqlScriptArray.sSQLScriptArray[iCount] to sLine
90464>>>            Move (Trim(sLine)) to sTmp
90465>>>            If (sTmp <> "") Begin
90467>>>                Move (Left(sTmp, 2) = sDashComment) to bDashComment
90468>>>                If (bCommentStart = False) Begin
90470>>>                    Move (Left(sTmp, 2) = sCommentStart) to bCommentStart
90471>>>                    If (bCommentStart = False) Begin
90473>>>                    End
90473>>>>
90473>>>                End
90473>>>>
90473>>>                Move (sTmp contains sCommentEnd) to bCommentEnd
90474>>>                If (bCommentEnd = True) Begin
90476>>>                    Move False to bCommentStart
90477>>>                End
90477>>>>
90477>>>                If (bDashComment = False and bCommentStart = False and bCommentEnd = False) Begin
90479>>>                    Move sLine to sSQLScriptArray[SizeOfArray(sSQLScriptArray)]
90480>>>                End
90480>>>>
90480>>>            End
90480>>>>
90480>>>        Loop
90481>>>>
90481>>>
90481>>>        // Update the retval struct array:
90481>>>        Move sSQLScriptArray to SqlScriptArray.sSQLScriptArray
90482>>>        Function_Return SqlScriptArray
90483>>>    End_Function
90484>>>
90484>>>
90484>>>    // *** Database API Functions: ***
90484>>>    // Instead of using Sql Scripts (ESQL), we can opt to use the DataFlex Database API's to
90484>>>    // make changes/updates to the database.
90484>>>
90484>>>    // * Dummy function for the Studio's Code Explorer *
90484>>>    Function API_TABLE_FUNCTIONS Returns Boolean
90486>>>        Function_Return False
90487>>>    End_Function
90488>>>
90488>>>    // This might not do what you think - Here's what it does:
90488>>>    // It checks that the passed hTable TableName in filelist.cfg is exactly the same as at the SQL back-end.
90488>>>    // If that is True; it creates an .int file for it and changes Filelist.cfg to point
90488>>>    // to the SQL table.
90488>>>    // Typical usage for this function is when an entry exists in the Filelist for a table and the table
90488>>>    // already exists in SQL.
90488>>>    // This is a bit fiddly as the DF_FILE_PHYSICAL_NAME attribute can only be set inside a
90488>>>    // Structure_Start ... Structure_End operation when creating a NEW table. Thus it cannot be set when
90488>>>    // restructuring an existing table.
90488>>>    Function ApiTableAttachToSql Handle hTable Boolean bUseConnID Returns Boolean
90490>>>        Boolean bExists bOpened bOK bSystemFile bMertechDriver bUseConnectionID bIsAlias
90490>>>        String sDriverID sConnectionID sConnectionString sDisplayName sRootName sLogicalName sPhysicalName sSchema
90490>>>        Handle hToTable
90490>>>        Integer iPos
90490>>>
90490>>>        Move True to bUseConnectionID
90491>>>        If (num_arguments > 1) Begin
90493>>>            Move bUseConnID to bUseConnectionID
90494>>>        End
90494>>>>
90494>>>
90494>>>        Get psDriverID to sDriverID
90495>>>        // If the table doesn't exist on the SQL back-end we do nothing.
90495>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
90496>>>        If (bExists = False) Begin
90498>>>            Function_Return False
90499>>>        End
90499>>>>
90499>>>
90499>>>        Get UtilTableIsAlias hTable to bIsAlias
90500>>>
90500>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
90501>>>        If (bOK = False) Begin
90503>>>            Function_Return False
90504>>>        End
90504>>>>
90504>>>
90504>>>        // Then we need to check that the function hasn't been called before; which in case
90504>>>        // we do nothing
90504>>>        Get SQLUtilTableIsAttached sDriverID hTable to bExists
90505>>>        If (bExists = True) Begin
90507>>>            Function_Return False
90508>>>        End
90508>>>>
90508>>>
90508>>>        Get psConnectionID     to sConnectionID
90509>>>        Get psConnectionString to sConnectionString
90510>>>        If (sConnectionID = "" or sConnectionString = "") Begin
90512>>>            Error DFERR_PROGRAM ("An SQL connection has NOT been setup correctly. Could not attach table:" * String(hTable) * "to SQL")
90513>>>>
90513>>>            Function_Return False
90514>>>        End
90514>>>>
90514>>>
90514>>>        Set Private.phCurrentTable to hTable
90515>>>        Get psSchema to sSchema
90516>>>        If (sSchema = "") Begin
90518>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
90519>>>        End
90519>>>>
90519>>>
90519>>>        Get IsMertechDriver sDriverID to bMertechDriver
90520>>>
90520>>>        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
90520>>>        // was a programmer's error and we adjust for it here.
90520>>>        If (bMertechDriver = True) Begin
90522>>>            Move False to bUseConnectionID
90523>>>        End
90523>>>>
90523>>>
90523>>>        // If we should use a connection id we need to check it exists;
90523>>>        // else we create it before attempting creating the table
90523>>>        If (bUseConnectionID = True) Begin
90525>>>            Get AutoConnectionIDLogin to bOK
90526>>>            If (bOk = False) Begin
90528>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
90529>>>>
90529>>>                Function_Return False
90530>>>            End
90530>>>>
90530>>>        End
90530>>>>
90530>>>
90530>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
90533>>>        Get _TableNameOnly sRootName to sRootName
90534>>>        If (sRootName = "") Begin
90536>>>            Function_Return False
90537>>>        End
90537>>>>
90537>>>        Move (sRootName + ".int")                    to sPhysicalName
90538>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
90541>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
90544>>>
90544>>>        // We don't want to change the display name if it starts with an ampersand ("@"),
90544>>>        // because then the table should not be visible to users.
90544>>>        Move (Pos("@", sDisplayName)) to iPos
90545>>>        If (iPos <> 1) Begin
90547>>>            If (sDisplayName contains ".") Begin
90549>>>                Move (Pos(".", sDisplayName)) to iPos
90550>>>                Move (Mid(sDisplayName, 200 ,(iPos + 1))) to sDisplayName
90551>>>                Move (sSchema + "." + sDisplayName)       to sDisplayName
90552>>>            End
90552>>>>
90552>>>            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
90554>>>                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
90555>>>            End
90555>>>>
90555>>>        End
90555>>>>
90555>>>
90555>>>        If (bIsAlias = False) Begin
90557>>>            Get OpenTableExclusive hTable to bOpened
90558>>>            If (bOpened = False) Begin
90560>>>                Error DFERR_PROGRAM ("Function ApiTableAttachToSQL - Could not open table number:" * String(hTable) * sLogicalName)
90561>>>>
90561>>>                Function_Return False
90562>>>            End
90562>>>>
90562>>>        End
90562>>>>
90562>>>
90562>>>        If (ghoProgressBar <> 0) Begin
90564>>>            Send DoAdvance of ghoProgressBar
90565>>>            Set TableName_Text of ghoStatusPanel to ("Attaching to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable) * "to SQL")
90566>>>        End
90566>>>>
90566>>>        // Note: The hToTable will get changed by the Structure_xxx command...
90566>>>        Move hTable to hToTable
90567>>>        Move False to Err
90568>>>
90568>>>        // We now create a stub .int file and after Structure_end and also change the Filelist.cfg,
90568>>>        // then we do a pseudo .int file change with the "SqlUtilUpdateIntFile" function. After that we have
90568>>>        // a proper and updated .int file.
90568>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemFile
90571>>>        Get SqlUtilCreateIntFile hTable sDriverID sConnectionID True bSystemFile to bOK
90572>>>
90572>>>        If (bIsAlias = False) Begin
90574>>>            Structure_Start hToTable sDriverID
90575>>>                Set Private.phCurrentTable to hTable
90576>>>                If (bUseConnectionID = True) Begin
90578>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to (CS_DFCONNID + "=" + sConnectionID)
90581>>>                End
90581>>>>
90581>>>                Else Begin
90582>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to sConnectionString
90585>>>                End
90585>>>>
90585>>>                Set_Attribute DF_FILE_OWNER         of hToTable to (Lowercase(sSchema))
90588>>>                // For unknown reason the above sometimes triggers an error and it doesn't help to try to trap the error; so we cheat...
90588>>>                Move False to Err
90589>>>                Move 0 to LastErr
90590>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
90591>>>            Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
90593>>>            Set Action_Text of ghoStatusPanel to ""
90594>>>        End
90594>>>>
90594>>>
90594>>>        Move (not(Err)) to bOK
90595>>>        If (bOK = True) Begin
90597>>>            // The attributes set above will always trigger an error
90597>>>            // We also adjust the Filelist entries
90597>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to (sDriverID + ":" + sRootName)
90600>>>            Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
90603>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
90606>>>
90606>>>            // This updates the .int file to make it up-to-date with the SQL back-end.
90606>>>            Get SqlUtilUpdateIntFile hTable to bOK
90607>>>        End
90607>>>>
90607>>>
90607>>>        Function_Return (bOK = True)
90608>>>    End_Function
90609>>>
90609>>>    // Sample usage:
90609>>>    //    Get ApiTableChangeAttribute SysInfo.File_Number DF_FILE_IS_SYSTEM_FILE True to bOK
90609>>>    //    Get ApiTableChangeAttribute OrderHea.File_Number DF_FILE_REUSE_DELETED DF_FILE_DELETED_NOREUSE to bOK
90609>>>    Function ApiTableChangeAttribute Handle hTable Integer iAttribute Integer iValue Returns Boolean
90611>>>        Boolean bOK bIsSQLTable
90611>>>
90611>>>        Get AutoConnectionIDLogin to bOK
90612>>>        Move False to Err
90613>>>        Get OpenTableExclusive hTable to bOK
90614>>>        If (bOK = False) Begin
90616>>>            Function_Return False
90617>>>        End 
90617>>>>
90617>>>        
90617>>>        // ToDo: Add to all table change functions!
90617>>>            Get UtilTableIsSQL hTable to bIsSQLTable
90618>>>            If (bIsSQLTable = True) Begin
90620>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
90623>>>            End
90623>>>>
90623>>>        
90623>>>        Set Private.phCurrentTable to hTable
90624>>>        Structure_Start hTable
90625>>>            Set_Attribute iAttribute of hTable to iValue
90628>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
90629>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
90631>>>
90631>>>        Set Action_Text of ghoStatusPanel to ""
90632>>>        Function_Return (Err = False)
90633>>>    End_Function
90634>>>
90634>>>    // To use a filelist slot for the passed FileName, TableName & DisplayName,
90634>>>    // or to change the filelist slot names.
90634>>>    Function ApiTableChangeFileListSlot String sRootName String sLogicalName String sDisplayName Handle hTable String sDriverID Returns Boolean
90636>>>        Boolean bExists
90636>>>
90636>>>        Move False to Err
90637>>>        Get UtilTableNumberIsInUse hTable to bExists
90638>>>        If (bExists = False) Begin
90640>>>            Function_Return False
90641>>>        End
90641>>>>
90641>>>
90641>>>        If (ghoProgressBar <> 0) Begin
90643>>>            Send DoAdvance of ghoProgressBar
90644>>>            Set TableName_Text of ghoStatusPanel to ("Changing Filelist slot for Table:" * String(sLogicalName) * "Number:" * String(hTable))
90645>>>        End
90645>>>>
90645>>>        // If all strings are empty it means that we should remove this entry from filelist.
90645>>>        If (sRootName = "" and sLogicalName = "" and sDisplayName = "") Begin
90647>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
90650>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
90653>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
90656>>>            Function_Return (Err = False) // And we're done.
90657>>>        End
90657>>>>
90657>>>
90657>>>        If (sDriverID <> DATAFLEX_ID) Begin
90659>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
90662>>>        End
90662>>>>
90662>>>        Else Begin
90663>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
90666>>>        End
90666>>>>
90666>>>
90666>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
90669>>>
90669>>>        If (sDriverID <> DATAFLEX_ID and not(Uppercase(sDisplayName) contains "DBO.")) Begin
90671>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ("dbo." + sDisplayName)
90674>>>        End
90674>>>>
90674>>>        Else Begin
90675>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
90678>>>        End
90678>>>>
90678>>>
90678>>>        Function_Return (Err = False)
90679>>>    End_Function
90680>>>
90680>>>    Function ApiTableChangeRecordLength Handle hTable Integer iRecordLength Returns Boolean
90682>>>        Boolean bOK
90682>>>
90682>>>        Get AutoConnectionIDLogin to bOK
90683>>>        Move False to Err
90684>>>        Get OpenTableExclusive hTable to bOK
90685>>>        If (bOK = False) Begin
90687>>>            Function_Return False
90688>>>        End
90688>>>>
90688>>>
90688>>>        Set Private.phCurrentTable to hTable
90689>>>        Structure_Start hTable
90690>>>            Set_Attribute DF_FILE_RECORD_LENGTH of hTable to iRecordLength
90693>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
90694>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
90696>>>
90696>>>        Set Action_Text of ghoStatusPanel to ""
90697>>>        Function_Return (Err = False)
90698>>>    End_Function
90699>>>
90699>>>    Function ApiTableChangeRelation Handle hTable Handle hToTable Integer iFromField Integer iToField Returns Boolean
90701>>>        Boolean bOK
90701>>>
90701>>>        Move False to Err
90702>>>        Get AutoConnectionIDLogin to bOK
90703>>>        Open hToTable
90705>>>        Get OpenTableExclusive hTable to bOK
90706>>>        If (bOK = False) Begin
90708>>>            Function_Return False
90709>>>        End
90709>>>>
90709>>>
90709>>>        Set Private.phCurrentTable to hTable
90710>>>        Structure_Start hTable
90711>>>            Set_Attribute DF_FIELD_RELATED_FILE  of hTable iFromField to hToTable
90714>>>            Set_Attribute DF_FIELD_RELATED_FIELD of hTable iFromField to iToField
90717>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
90718>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
90720>>>
90720>>>        Set Action_Text of ghoStatusPanel to ""
90721>>>        Function_Return (Err = False)
90722>>>    End_Function
90723>>>
90723>>>    Procedure ApiTableConvertAllAddException Integer hTable
90725>>>        Integer[] aTableConvertExceptions
90726>>>        Get paTableConvertExceptions to aTableConvertExceptions
90727>>>        Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
90728>>>        Set paTableConvertExceptions to aTableConvertExceptions
90729>>>    End_Procedure
90730>>>
90730>>>    Procedure ApiTableDateCorrectionAddException Integer hTable
90732>>>        Integer[] aTableDateCorrectionExceptions
90733>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
90734>>>        Move hTable to aTableDateCorrectionExceptions[SizeOfArray(aTableDateCorrectionExceptions)]
90735>>>        Set paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
90736>>>    End_Procedure
90737>>>
90737>>>    Procedure ApiTableConvertALLToSql
90739>>>        Integer[] iTablesArray
90740>>>        Integer iSize iCount
90740>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
90740>>>        String sDriverID
90740>>>
90740>>>        Get psDriverID to sDriverID
90741>>>        Get pbUseConnectionID to bUseConnectionID
90742>>>        Get pbToANSI          to bToANSI
90743>>>        Get pbRecnum          to bRecnum
90744>>>        Get pbCopyData        to bCopyData
90745>>>        If (ghoDbUpdateHandler > 0) Begin
90747>>>            Get pbContinueOnError to bContinueOnError
90748>>>        End
90748>>>>
90748>>>
90748>>>        Get _AllTablesToConvert to iTablesArray
90749>>>        Move (SizeOfArray(iTablesArray)) to iSize
90750>>>        Set pbVisible   of ghoProgressBarOverall to True
90751>>>        Set piPosition  of ghoProgressBarOverall to 0
90752>>>        Set piAdvanceBy of ghoProgressBarOverall to 1
90753>>>        Set piMaximum   of ghoProgressBarOverall to iSize
90754>>>
90754>>>        Decrement iSize
90755>>>        For iCount from 0 to iSize
90761>>>>
90761>>>            Set piPosition of ghoProgressBarOverall to iCount
90762>>>            Get ApiTableConvertToSQL_Ex iTablesArray[iCount] sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
90763>>>            // Probably the right logic here is to just continue trying to convert every table even
90763>>>            // if there was an error converting one table...
90763>>>            //If (bContinueOnError = False and bOK = False) Break
90763>>>        Loop
90764>>>>
90764>>>
90764>>>    End_Procedure
90765>>>
90765>>>    Procedure ApiTableAttachALLToSql
90767>>>        Integer[] iTablesArray
90768>>>        Integer iSize iCount
90768>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
90768>>>        String sDriverID
90768>>>
90768>>>        Get psDriverID to sDriverID
90769>>>        Get pbUseConnectionID to bUseConnectionID
90770>>>        Get pbToANSI          to bToANSI
90771>>>        Get pbRecnum          to bRecnum
90772>>>        Get pbCopyData        to bCopyData
90773>>>        If (ghoDbUpdateHandler > 0) Begin
90775>>>            Get pbContinueOnError to bContinueOnError
90776>>>        End
90776>>>>
90776>>>
90776>>>        Get _AllTablesToConvert to iTablesArray
90777>>>        Move (SizeOfArray(iTablesArray)) to iSize
90778>>>        Decrement iSize
90779>>>        For iCount from 0 to iSize
90785>>>>
90785>>>            Get ApiTableAttachToSQL iTablesArray[iCount] bUseConnectionID to bOK
90786>>>        Loop
90787>>>>
90787>>>
90787>>>    End_Procedure      
90788>>>    
90788>>>    // Subfunction to the ApiTableUpdate function (et al)
90788>>>    Function _UtilTableCheckChangeFilelistNames tAPITableNameInfo APITableNameInfoFrom Boolean bIsSQLTableTo Returns Boolean
90790>>>        Handle hTable 
90790>>>        String sRootNameTo sLogicalNameTo sDisplayNameTo sConnectionID
90790>>>        Boolean bIsSQLTableFrom bTableExists bSameTableNames bANSI bOK
90790>>>        
90790>>>        Get ApiTableFilelistNamesCompare True APITableNameInfoFrom to bSameTableNames
90791>>>        If (bSameTableNames = True) Begin
90793>>>            Function_Return True
90794>>>        End 
90794>>>>
90794>>>        
90794>>>        Move True to bOK
90795>>>        Move APITableNameInfoFrom.iTableNumber  to hTable  
90796>>>        Set Private.phCurrentTable              to hTable
90797>>>        Set_Attribute DF_FILE_ROOT_NAME         of hTable to APITableNameInfoFrom.sRootName
90800>>>        Set_Attribute DF_FILE_LOGICAL_NAME      of hTable to APITableNameInfoFrom.sLogicalName
90803>>>        Set_Attribute DF_FILE_DISPLAY_NAME      of hTable to APITableNameInfoFrom.sDisplayName
90806>>>        
90806>>>        If (APITableNameInfoFrom.bIsSQL = True) Begin
90808>>>            Get psConnectionID to sConnectionID
90809>>>            Get UtilTableExists hTable to bTableExists
90810>>>            If (bTableExists = True) Begin  
90812>>>                Get SqlUtilUpdateIntFile hTable to bOK
90813>>>            End
90813>>>>
90813>>>            Else Begin
90814>>>                Get pbToANSI to bANSI 
90815>>>                Get SqlUtilCreateIntFile hTable APITableNameInfoFrom.sDriverID sConnectionID bANSI False to bOK
90816>>>            End
90816>>>>
90816>>>        End
90816>>>>
90816>>>
90816>>>        Function_Return bOK
90817>>>    End_Function
90818>>>
90818>>>    Function ApiTableConvertToSql_Ex Handle hTable String sDriverID Boolean bUseConnectionID Boolean bToAnsi Boolean bRecnum Boolean bCopyData Returns Boolean
90820>>>        Handle hToTable hoLogFile
90820>>>        Boolean bOK bExists bOpened bMertechDriver bDAWDriver bContinueOnError bIsAlias
90820>>>        String sPhysicalName sRootName sLogicalName sDisplayName sConnectionID sConnectionString
90820>>>        String sANSI_OEM sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace sDatabase sGUIDName sWarning
90820>>>        tSQLConnection SQLConnection
90820>>>        tSQLConnection SQLConnection
90820>>>        
90820>>>        Get UtilTableIsAlias hTable to bIsAlias
90821>>>        // If this is an Alias file there is nothing to convert to SQL.
90821>>>        // Instead we change the Filelist.cfg by adding the driver id to the rootname and create an .int file
90821>>>        If (bIsAlias = True) Begin
90823>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
90826>>>            If (sDriverID <> DATAFLEX_ID and not(sRootName contains ":")) Begin
90828>>>                Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
90831>>>                Get psConnectionID to sConnectionID
90832>>>                Get SqlUtilCreateIntFile hTable sDriverID sConnectionID True False to bOK
90833>>>            End
90833>>>>
90833>>>            Function_Return True
90834>>>        End
90834>>>>
90834>>>
90834>>>        Set Private.phCurrentTable to hTable
90835>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
90838>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
90841>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
90844>>>
90844>>>        If (ghoProgressBar <> 0) Begin
90846>>>            Send DoAdvance of ghoProgressBar
90847>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(sLogicalName))
90848>>>        End
90848>>>>
90848>>>
90848>>>        // Marco Kuipers suggestion;
90848>>>        // If Filelist.cfg points to an embedded .dat table and the table already exists as
90848>>>        // an SQL table; rename the SQL table by adding a GUID at the end, then convert the
90848>>>        // table again.
90848>>>        Get UtilTableIsSQL hTable to bOK
90849>>>        If (bOK = False) Begin
90851>>>            Get SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
90852>>>            If (bExists = True) Begin
90854>>>                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
90855>>>                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
90856>>>                Get phoLogFile to hoLogFile
90857>>>                If (hoLogFile <> 0) Begin
90859>>>                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The existing SQL table was renamed to:" * String(sGUIDName) * "and then converted again.") to sWarning
90860>>>                    Send LogError sWarning False
90861>>>                End
90861>>>>
90861>>>                Else Begin
90862>>>                    Error DFERR_PROGRAM sWarning
90863>>>>
90863>>>                End
90863>>>>
90863>>>            End
90863>>>>
90863>>>        End
90863>>>>
90863>>>
90863>>>        // Does the rootname contain a driver?
90863>>>        If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
90865>>>            // Does the table already exist as an SQL table?
90865>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
90866>>>            // It can happen that the table is missing from Filelist.cfg but still
90866>>>            // exist on the SQL side, in case we want to search for the table by its name.
90866>>>            If (bExists = False) Begin
90868>>>                Get SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
90869>>>            End
90869>>>>
90869>>>            If (bExists = True) Begin
90871>>>                Set TableName_Text of ghoStatusPanel to ""
90872>>>                Function_Return False
90873>>>            End
90873>>>>
90873>>>        End
90873>>>>
90873>>>        Move (If(bToAnsi = True, CS_ANSI_Txt, CS_OEM_Txt)) to sANSI_OEM
90874>>>
90874>>>        Get IsDAWSQLDriver sDriverID to bDAWDriver
90875>>>        // Mertech drivers don't use Connection ID's; so if bUseConnectionID was
90875>>>        // passed as True, we adjust for that here.
90875>>>        Get IsMertechDriver sDriverID to bMertechDriver
90876>>>        If (bMertechDriver = True and bUseConnectionID = True) Begin
90878>>>            Move False to bUseConnectionID
90879>>>        End
90879>>>>
90879>>>
90879>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
90880>>>        Move SQLConnection.sSchema           to sSchema
90881>>>        If (sSchema = "") Begin
90883>>>            Get _SqlFindKeyWord CI_SQLDBO    to sSchema
90884>>>            Move (Lowercase(sSchema))        to sSchema
90885>>>        End
90885>>>>
90885>>>
90885>>>        If (sDriverID = ORAFLEX) Begin
90887>>>            Move SQLConnection.sUserID       to sSchema
90888>>>        End
90888>>>>
90888>>>
90888>>>        Move SQLConnection.sDatabase         to sDatabase
90889>>>        Move SQLConnection.sConnectionID     to sConnectionID
90890>>>        Move SQLConnection.sConnectionString to sConnectionString
90891>>>        If (sConnectionID = "" or sConnectionString = "") Begin
90893>>>            Error DFERR_PROGRAM ("The SQL connection info has NOT been setup. Could not convert table:" * String(hTable) * "to SQL")
90894>>>>
90894>>>            Function_Return False
90895>>>        End
90895>>>>
90895>>>
90895>>>        Get AutoConnectionIDLogin to bOK
90896>>>        Open hTable
90898>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
90901>>>        If (bOpened = False) Begin
90903>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
90904>>>>
90904>>>            Function_Return False
90905>>>        End
90905>>>>
90905>>>
90905>>>        If (ghoProgressBar <> 0) Begin
90907>>>            Send DoAdvance of ghoProgressBar
90908>>>            Set TableName_Text of ghoStatusPanel to ("Converting to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable))
90909>>>        End
90909>>>>
90909>>>
90909>>>        Move 0 to hToTable
90910>>>        Get _TableNameOnly sRootName                 to sRootName
90911>>>        Move (sRootName + ".int")                    to sPhysicalName
90912>>>
90912>>>        Case Begin
90912>>>            Case (sDriverID = MSSQLDRV_ID)
90914>>>                Case Break
90915>>>            Case (sDriverID = ODBC_DRV_ID)
90918>>>                Case Break
90919>>>            Case (sDriverID = DB2_DRV_ID)
90922>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
90923>>>                Move SQLConnection.sLongTableSpace  to sLongTableSpace
90924>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
90925>>>                Case Break
90926>>>            Case (sDriverID = ORAFLEX)
90929>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
90930>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
90931>>>                Case Break
90932>>>            Case (sDriverID = MDSMySQL)
90935>>>                Case Break
90936>>>            Case (sDriverID = MDSPgSQL)
90939>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
90940>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
90941>>>                Case Break
90942>>>            Case (sDriverID = DATAFLEX_ID)
90945>>>                Case Break
90946>>>            Case Else
90946>>>                Error DFERR_PROGRAM "Wrong database driver passed to the 'ApiTableConvertToSQL_Ex' function."
90947>>>>
90947>>>                Case Break
90948>>>        Case End
90948>>>
90948>>>        Move False to Err
90949>>>
90949>>>        If (bIsAlias = False) Begin
90951>>>
90951>>>            If (bMertechDriver = True) Begin
90953>>>                // Note: This function also sets the Err flag.
90953>>>                Get _MertechApiTableConvertToSQL hTable sRootName sDatabase sDriverID sBaseTableSpace sIndexTableSpace bCopyData to bOK
90954>>>            End
90954>>>>
90954>>>
90954>>>            If (bMertechDriver = False) Begin
90956>>>                Structure_Start hToTable sDriverID
90957>>>                    Structure_Copy hTable to hToTable
90958>>>
90958>>>                    Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
90961>>>
90961>>>                    If (sDriverID <> DATAFLEX_ID) Begin
90963>>>                        If (bUseConnectionID = True) Begin
90965>>>                            Set_Attribute DF_FILE_LOGIN     of hToTable to (CS_DFCONNID + "=" + sConnectionID)
90968>>>                        End
90968>>>>
90968>>>                        Else Begin
90969>>>                            Set_Attribute DF_FILE_LOGIN     of hToTable to sConnectionString
90972>>>                        End
90972>>>>
90972>>>
90972>>>                        Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT   of hToTable to sANSI_OEM
90975>>>                        Set_Attribute DF_FILE_RECNUM_TABLE             of hToTable to bRecnum
90978>>>
90978>>>                        If (sSchema <> "") Begin
90980>>>                            Set_Attribute DF_FILE_OWNER                of hToTable to sSchema
90983>>>                        End
90983>>>>
90983>>>
90983>>>                        If (sDriverID = DB2_DRV_ID) Begin
90985>>>                            If (sLongTableSpace <> "") Begin
90987>>>                                Set_Attribute DF_FILE_LONG_TABLESPACE  of hToTable to sLongTableSpace
90990>>>                            End
90990>>>>
90990>>>                            If (sBaseTableSpace <> "") Begin
90992>>>                                Set_Attribute DF_FILE_TABLE_TABLESPACE of hToTable to sBaseTableSpace
90995>>>                            End
90995>>>>
90995>>>                            If (sIndexTableSpace <> "") Begin
90997>>>                                Set_Attribute DF_FILE_INDEX_TABLESPACE of hToTable to sIndexTableSpace
91000>>>                            End
91000>>>>
91000>>>                        End
91000>>>>
91000>>>                    End
91000>>>>
91000>>>
91000>>>                    Set Action_Text of ghoStatusPanel to "Restructures table..."
91001>>>                Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
91003>>>                Set Action_Text of ghoStatusPanel to ""
91004>>>            End
91004>>>>
91004>>>
91004>>>            Move (not(Err)) to bOK
91005>>>            If (bOK = True and bCopyData = True and bMertechDriver = False) Begin
91007>>>                If (bIsAlias = False) Begin
91009>>>                    Get ApiTableCopyData hTable sPhysicalName sRootName sDriverID to bOK
91010>>>                    If (ghoDbUpdateHandler > 0) Begin
91012>>>                        Get pbContinueOnError to bContinueOnError
91013>>>                    End
91013>>>>
91013>>>                    // If the data copy failed we will keep the newly created SQL table but
91013>>>                    // rename it by adding a GUID at the end of the table name
91013>>>                    // - or as much as "fit" because different SQL back-ends have
91013>>>                    // different rules how long a table name can be.
91013>>>                    // The new table will probably contain data but something went
91013>>>                    // wrong while converting the data from embedded to SQL.
91013>>>                    If (bOK = False and bContinueOnError = False) Begin
91015>>>                        Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
91016>>>                        Get SqlTableRename hTable sLogicalName sGUIDName to bOK
91017>>>                        Error DFERR_PROGRAM ("Copying of data failed. The SQL table:" * sLogicalName * "was renamed to:" * String(sGUIDName))
91018>>>>
91018>>>                    End
91018>>>>
91018>>>                End
91018>>>>
91018>>>            End
91018>>>>
91018>>>        End
91018>>>>
91018>>>
91018>>>        If (bMertechDriver = True) Begin
91020>>>            Open hTable
91022>>>        End
91022>>>>
91022>>>
91022>>>        // This must be after copying data...
91022>>>        If (Err = False) Begin
91024>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
91027>>>            // We also adjust the display name by prefixing it by the schema name;
91027>>>            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
91029>>>                // The max length for the display_name is 31 characters...
91029>>>                If (Length(sSchema + "." + sDisplayName) < 31) Begin
91031>>>                    Set_Attribute DF_FILE_DISPLAY_NAME of hTable to (Lowercase(sSchema) + "." + sDisplayName)
91034>>>                End
91034>>>>
91034>>>            End
91034>>>>
91034>>>        End
91034>>>>
91034>>>
91034>>>        Close hTable
91035>>>        Move (not(Err)) to bOK
91036>>>        Function_Return (bOK = True)
91037>>>    End_Function
91038>>>
91038>>>    // Calls a driver function directly to copy data from one table to another (table structures needs to be the same).
91038>>>    // It will first drop all indicies, copy the data and then recreate indicies.
91038>>>    // An error log file with the sRootname + ".err" will be created in the Data folder.
91038>>>    Function ApiTableCopyData Integer hFromTable String sPhysicalName String sRootName String sDriverID Returns Boolean
91040>>>        Boolean bOpened bOK
91040>>>        Integer hToTable iIndex iRetval iVoid iOrgFreq
91040>>>        String sErrorFile sEmpty sPath
91040>>>
91040>>>        Get_Attribute DF_FILE_NEXT_EMPTY of 0 to hToTable
91043>>>        Get AutoConnectionIDLogin to bOK
91044>>>        If (sDriverID = DATAFLEX_ID) Begin
91046>>>            Send IncreaseSortBufferSize
91047>>>//            Send SetAllIndexesToBatch hToTable
91047>>>        End
91047>>>>
91047>>>
91047>>>        Move False to Err
91048>>>        Open sPhysicalName as hToTable
91050>>>        Get_Attribute DF_FILE_OPENED of hToTable to bOpened
91053>>>        If (bOpened = False) Begin
91055>>>            Function_Return False
91056>>>        End
91056>>>>
91056>>>
91056>>>        If (ghoStatusPanel <> 0) Begin
91058>>>            Set TableName_Text of ghoStatusPanel to ("Copying Data for Table:" * sRootName * "Number:" * String(hFromTable))
91059>>>            Set piMinimum of ghoProgressBar to 0 
91060>>>            Set piMaximum of ghoProgressBar to 100 // 100%
91061>>>        End
91061>>>>
91061>>>
91061>>>        Move "" to sEmpty
91062>>>        Move False to Err
91063>>>        Move True to bOK
91064>>>        Set Private.phCurrentTable to hToTable
91065>>>
91065>>>        // No need to get the record identifier
91065>>>        Set_Attribute DF_FILE_GET_RID_AFTER_CREATE of hToTable to False        
91068>>>        Get_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
91071>>>        If (sDriverID <> DATAFLEX_ID) Begin
91073>>>            // Remove all indices to speed up copying of data:
91073>>>            Call_Driver hToTable sDriverID Function CLI_DROPINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
91078>>>            If (iRetval <> 0) Begin
91080>>>                Error DFERR_PROGRAM ("Failed dropping indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
91081>>>>
91081>>>                Function_Return False
91082>>>            End
91082>>>>
91082>>>        End
91082>>>>
91082>>>
91082>>>        Move (sRootName + ".err") to sErrorFile
91083>>>        Move 0 to iIndex
91084>>>        Move False to Err
91085>>>        
91085>>>        If (sDriverID = MSSQLDRV_ID) Begin
91087>>>            Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to 10
91090>>>            Call_Driver hToTable sDriverID Function CLI_BCP CallBack ghoDbUpdateHandler Passing iIndex sEmpty hFromTable Result iRetval
91095>>>            If (iRetval <> 0) Begin
91097>>>                Error DFERR_PROGRAM ("Failed copying data for table Number:" * String(hToTable) * "Name:" * String(sRootName))
91098>>>>
91098>>>                Function_Return False
91099>>>            End
91099>>>>
91099>>>        End 
91099>>>>
91099>>>        Else Begin
91100>>>            Copy_Records hFromTable to hToTable using 0 Callback ghoDbUpdateHandler
91103>>>        End
91103>>>>
91103>>>
91103>>>        If (Err = False) Begin
91105>>>            Get psHome of (phoWorkspace(ghoApplication)) to sPath
91106>>>            Get vDeleteFile (sPath + sErrorFile) to iRetval
91107>>>        End
91107>>>>
91107>>>
91107>>>        If (sDriverID <> DATAFLEX_ID) Begin
91109>>>            // Recreate indices:
91109>>>            Call_Driver hToTable sDriverID Function CLI_CREATEINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
91114>>>            If (iRetval <> 0) Begin
91116>>>                Error DFERR_PROGRAM ("Failed creating indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
91117>>>>
91117>>>                Function_Return False
91118>>>            End
91118>>>>
91118>>>        End
91118>>>>
91118>>>
91118>>>        Close hToTable
91119>>>        Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
91122>>>
91122>>>        If (bOK = True) Begin
91124>>>            Move (not(Err)) to bOK
91125>>>        End
91125>>>>
91125>>>
91125>>>        If (ghoStatusPanel <> 0) Begin
91127>>>            Set TableName_Text of ghoStatusPanel to ""
91128>>>            Set Message_Text   of ghoStatusPanel to ""
91129>>>            Set Action_Text    of ghoStatusPanel to ""
91130>>>        End
91130>>>>
91130>>>
91130>>>        Function_Return (bOK = True)
91131>>>    End_Function
91132>>>
91132>>>    // The bANSI parameter's default value = True, meaning a table in ANSI format will be created.
91132>>>    // i.e. DF_FILE_TABLE_CHARACTER_FORMAT {"OEM"|"ANSI"}
91132>>>    Function ApiTableCreate Handle hTable String sRootName String sDisplayName String sLogicalName Boolean bUseConnectionID Boolean bANSI Boolean bRecnum tAPIColumn[] aColumnIn Returns Boolean
91134>>>        Handle hFile
91134>>>        String sConnectionID sPhysicalFile sANSI_OEM sVal sSchema sOriginalDriverID sDriverID sTableName
91134>>>        Integer iColumn iIdentityType iDataType iDbType iCount iSize
91134>>>        Boolean bOk bExists bSqlDriver bMertechDriver bDeleteDummy bExistsInFilelist bSysFile
91134>>>        tSQLConnection SQLConnection
91134>>>        tSQLConnection SQLConnection
91134>>>        tAPIColumn[] aColumns
91134>>>        tAPIColumn[] aColumns
91135>>>        tColumnType ColumnType
91135>>>        tColumnType ColumnType
91135>>>
91135>>>        // First check if the passed filenumber already exists; in case we do nothing
91135>>>        Get UtilTableExists hTable to bOk
91136>>>        If (bOk = True) Begin
91138>>>            Function_Return False
91139>>>        End
91139>>>>
91139>>>
91139>>>        Set Private.phCurrentTable to hTable
91140>>>        Move sLogicalName to sTableName
91141>>>        If (ghoProgressBar <> 0) Begin
91143>>>            Send DoAdvance of ghoProgressBar
91144>>>            Set TableName_Text of ghoStatusPanel to ("Creating Table:" * String(sTableName) * "Number:" * String(hTable) * String(sLogicalName))
91145>>>        End
91145>>>>
91145>>>
91145>>>        Get UtilTableLogicalNameIsInUse sTableName to bExistsInFilelist
91146>>>        Get psDriverID to sDriverID
91147>>>        Get IsSQLDriver sDriverID to bSqlDriver
91148>>>        Get piDbType to iDbType
91149>>>
91149>>>        // If no columns passed in, we need to create a "dummy" column
91149>>>        Move False to bDeleteDummy
91150>>>        If (Num_Arguments = 8) Begin
91152>>>            Move aColumnIn to aColumns
91153>>>        End
91153>>>>
91153>>>        If ((SizeOfArray(aColumns)) = 0) Begin
91155>>>            Get UtilDFDataTypeToSqlTypeMapping sDriverID iDbType DF_BCD to ColumnType
91156>>>            Move ColumnType.iSQLType to iDataType
91157>>>            If (bRecnum = False) Begin
91159>>>                Move C_tAPIColumn_Identity to iIdentityType
91160>>>            End
91160>>>>
91160>>>            Else Begin
91161>>>                Move C_tAPIColumn_None     to iIdentityType
91162>>>            End
91162>>>>
91162>>>            Get _AppendAPIColumn aColumns "temp" iDataType 10 0 iIdentityType to aColumns
91163>>>            Move True to bDeleteDummy
91164>>>        End
91164>>>>
91164>>>
91164>>>        // If columns have been passed as an array we need to check if an identity column
91164>>>        // has been specified (aColumns[iCounter].iOptions = C_tAPIColumn_Identity), and
91164>>>        // if so auto-set the bRecnum to FALSE. This is because else there would be
91164>>>        // two identity columns and SQL doesn't like that and throws an error.
91164>>>        If (bRecnum = True and (SizeOfArray(aColumns)) <> 0) Begin
91166>>>            Move (SizeOfArray(aColumns)) to iSize
91167>>>            Decrement iSize
91168>>>            for iCount from 0 to iSize
91174>>>>
91174>>>                If (aColumns[iCount].iOptions = C_tAPIColumn_Identity) Begin
91176>>>                    Move False to bRecnum
91177>>>                    Move iSize to iCount
91178>>>                End
91178>>>>
91178>>>            Loop
91179>>>>
91179>>>        End
91179>>>>
91179>>>
91179>>>        // If this is a SQL based driver we also check if the table exists
91179>>>        // in the SQL back end; in case we do nothing.
91179>>>        If (bSqlDriver = True) Begin
91181>>>            // Get all connection properties
91181>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
91182>>>            Move SQLConnection.sSchema to sSchema
91183>>>            If (sSchema = "") Begin
91185>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
91186>>>            End
91186>>>>
91186>>>
91186>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
91187>>>            // It can happen that the table is missing from Filelist.cfg but still
91187>>>            // exist on the SQL side, in case we want to search for the table by its name.
91187>>>            If (bExists = False) Begin
91189>>>                Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
91190>>>            End
91190>>>>
91190>>>            // If the table exists on the SQL back-end but not in Filelist.cfg,
91190>>>            // we will just add it to Filelist.cfg
91190>>>            If (bExists = True) Begin
91192>>>                If (bExistsInFilelist = False) Begin
91194>>>                    If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
91196>>>                        Move (sDriverID + ":" + sRootName) to sRootName
91197>>>                    End
91197>>>>
91197>>>                    Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
91200>>>                    Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
91203>>>                    Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
91206>>>                    Move False to bSysFile
91207>>>                    Get SqlUtilCreateIntFile hTable sDriverID SQLConnection.sConnectionID bANSI bSysFile to bOK
91208>>>                End
91208>>>>
91208>>>                Function_Return False
91209>>>            End
91209>>>>
91209>>>        End
91209>>>>
91209>>>
91209>>>        Move CS_ANSI_Txt to sANSI_OEM
91210>>>        If (num_arguments > 6) Begin
91212>>>            If (bANSI = False) Begin
91214>>>                Move CS_OEM_Txt to sANSI_OEM
91215>>>            End
91215>>>>
91215>>>        End
91215>>>>
91215>>>
91215>>>        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
91215>>>        // is a programmer's error and we auto-correct for it here.
91215>>>        // This is also a bit messy. If a Mertech driver is used and we want to create a new table,
91215>>>        // we first need to create it as embedded (DataFlex) and then convert it to SQL (!)
91215>>>        // So we set the driver ID temporarily to "DataFlex" to get the table created as embedded and later
91215>>>        // set it back and use a Mertech function to convert it to SQL.
91215>>>        Get IsMertechDriver sDriverID to bMertechDriver
91216>>>        If (bMertechDriver = True) Begin
91218>>>            If (bUseConnectionID = True) Begin
91220>>>                Move False to bUseConnectionID
91221>>>            End
91221>>>>
91221>>>            Move sDriverID to sOriginalDriverID
91222>>>            Move DATAFLEX_ID to sDriverID
91223>>>        End
91223>>>>
91223>>>
91223>>>        Move False to Err
91224>>>        If (sDriverID = DATAFLEX_ID) Begin
91226>>>            Move sRootName to sPhysicalFile
91227>>>        End
91227>>>>
91227>>>
91227>>>        If (sDriverID <> DATAFLEX_ID) Begin
91229>>>            Move SQLConnection.sConnectionID to sConnectionID
91230>>>
91230>>>            // If DAW driver and we should use a connection id we need to
91230>>>            // check if the connection ID exists; else we create it before attempting creating the table
91230>>>            If (bMertechDriver = False and bUseConnectionID = True) Begin
91232>>>                Get IsConnectionID sConnectionID sDriverID to bExists
91233>>>                If (bExists = False) Begin
91235>>>                    Get UtilCreateConnectionID sConnectionID to bOk
91236>>>                    If (bOk = False) Begin
91238>>>                        Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
91239>>>>
91239>>>                        Function_Return False
91240>>>                    End
91240>>>>
91240>>>                End
91240>>>>
91240>>>            End
91240>>>>
91240>>>
91240>>>            If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
91242>>>                Move (sTableName + ".int") to sPhysicalFile
91243>>>            End
91243>>>>
91243>>>            Else Begin
91244>>>                Move (sRootName + ".int") to sPhysicalFile
91245>>>            End
91245>>>>
91245>>>            Move (Uppercase(sDisplayName)) to sVal
91246>>>            If (not(sVal contains (sSchema + "."))) Begin
91248>>>                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
91249>>>            End
91249>>>>
91249>>>        End
91249>>>>
91249>>>        Move False to Err
91250>>>        Move 0 to hFile
91251>>>
91251>>>        Structure_Start hFile sDriverID
91252>>>            If (sDriverID <> DATAFLEX_ID) Begin
91254>>>                If (bUseConnectionID = True) Begin
91256>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to (CS_DFCONNID + "=" + sConnectionID)
91259>>>                End
91259>>>>
91259>>>                Else Begin
91260>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to SQLConnection.sConnectionString
91263>>>                End
91263>>>>
91263>>>                Set_Attribute DF_FILE_TABLE_NAME               of hFile to sTableName
91266>>>                Set_Attribute DF_FILE_USE_DUMMY_ZERO_DATE      of hFile to True
91269>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT   of hFile to sANSI_OEM
91272>>>                Set_Attribute DF_FILE_RECNUM_TABLE             of hFile to bRecnum
91275>>>
91275>>>                If (sSchema <> "") Begin
91277>>>                    Set_Attribute DF_FILE_OWNER                of hFile to sSchema
91280>>>                End
91280>>>>
91280>>>
91280>>>                If (sDriverID = DB2_DRV_ID) Begin
91282>>>                    If (SQLConnection.sLongTableSpace <> "") Begin
91284>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hFile to SQLConnection.sLongTableSpace
91287>>>                    End
91287>>>>
91287>>>                End
91287>>>>
91287>>>                If (sDriverID = DB2_DRV_ID or sDriverID = ORAFLEX or sDriverID = MDSPgSQL) Begin
91289>>>                    If (SQLConnection.sBaseTableSpace <> "") Begin
91291>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hFile to SQLConnection.sBaseTableSpace
91294>>>                    End
91294>>>>
91294>>>                    If (SQLConnection.sIndexTableSpace <> "") Begin
91296>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hFile to SQLConnection.sIndexTableSpace
91299>>>                    End
91299>>>>
91299>>>                End
91299>>>>
91299>>>            End
91299>>>>
91299>>>
91299>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hFile to sPhysicalFile
91302>>>            Get ApiColumnsAddToTable hFile aColumns True to bOk
91303>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
91304>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
91306>>>        Set Action_Text of ghoStatusPanel to ""
91307>>>
91307>>>        // If Mertech driver we convert the newly created embedded table (DataFlex) to SQL
91307>>>        If (bMertechDriver = True) Begin
91309>>>            Move sOriginalDriverID to sDriverID
91310>>>            If (not(sVal contains (sSchema + "."))) Begin
91312>>>                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
91313>>>            End
91313>>>>
91313>>>            // Note: This function also sets the Err flag.
91313>>>            Get _MertechApiTableConvertToSQL hTable sRootName SQLConnection.sDatabase sDriverID SQLConnection.sBaseTableSpace SQLConnection.sIndexTableSpace False to bOK
91314>>>        End
91314>>>>
91314>>>
91314>>>        Move (not(Err)) to bOK
91315>>>        If (bOk = True) Begin
91317>>>            If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
91319>>>                Move (sDriverID + ":" + sRootName) to sRootName
91320>>>            End
91320>>>>
91320>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
91323>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
91326>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
91329>>>
91329>>>            // Lastly we remove the temporary column we created above, if all went well.
91329>>>            If (bDeleteDummy) Begin
91331>>>                Get ApiColumnRemove hTable "temp" to bOk
91332>>>            End
91332>>>>
91332>>>        End
91332>>>>
91332>>>
91332>>>        Close hTable
91333>>>        Function_Return (bOK = True)
91334>>>    End_Function
91335>>>
91335>>>    Function ApiTableCreateAlias String sFileName String sDisplayName String sAliasName Integer iFilelistSlot Returns Boolean
91337>>>        Move False to Err
91338>>>        Set_Attribute DF_FILE_ROOT_NAME     of iFilelistSlot to sFileName
91341>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of iFilelistSlot to sDisplayName
91344>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of iFilelistSlot to sAliasName
91347>>>
91347>>>        Function_Return (Err = False)
91348>>>    End_Function
91349>>>
91349>>>    // ToDo: Needs to be revised
91349>>>    Procedure ApiTableCreateFromDEF String sPath String sFileName String sTableName String sDisplayName Integer iFilelistSlot
91351>>>        Handle hTable
91351>>>        String sDEFName sDataPath
91351>>>        Boolean bExists
91351>>>
91351>>>        // Do nothing if MSSQL Driver.
91351>>>//        Get IsMSSQLDriver to bExists
91351>>>//        If (bExists = True) Begin
91351>>>//            Procedure_Return
91351>>>//        End
91351>>>
91351>>>        Get psDataPathFirstPart to sDataPath
91352>>>        Get vFilePathExists (sDataPath + sFileName + ".dat") to bExists
91353>>>        If (bExists = True) Begin
91355>>>            // We also needs to check if it is an Alias file, in case the sFileName.dat exists, but it may
91355>>>            // still be missing from the filelist and needs to be added.
91355>>>            Get UtilTableNumberIsInUse iFilelistSlot to bExists
91356>>>            If (bExists = True) Begin
91358>>>                Procedure_Return
91359>>>            End
91359>>>>
91359>>>            // Do _not_ use the DEF file if an alias, it will overwrite the base table data.
91359>>>            Else Begin
91360>>>                Set_Attribute DF_FILE_ROOT_NAME    of iFilelistSlot to sFileName
91363>>>                Set_Attribute DF_FILE_LOGICAL_NAME of iFilelistSlot to sTableName
91366>>>                Set_Attribute DF_FILE_DISPLAY_NAME of iFilelistSlot to sDisplayName
91369>>>                Procedure_Return
91370>>>            End
91370>>>>
91370>>>        End
91370>>>>
91370>>>
91370>>>        Move (sPath + sFileName + ".def") to sDEFName
91371>>>        Move 0 to hTable
91372>>>        Move False to Err
91373>>>
91373>>>        Structure_Start hTable DATAFLEX_ID
91374>>>            Load_Def sDEFName Onto hTable
91375>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hTable to sFileName
91378>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
91379>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
91381>>>        Set Action_Text of ghoStatusPanel to ""
91382>>>
91382>>>        Move iFilelistSlot to hTable
91383>>>        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sFileName
91386>>>        Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
91389>>>        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
91392>>>
91392>>>    End_Procedure
91393>>>
91393>>>    Function ApiTableMoveToFileSlot Integer iFromFileSlot Integer iToFileSlot String sDriverID Returns Boolean
91395>>>        Boolean bTmp bErr bOK
91395>>>        String sTableName sDisplayName sFileName
91395>>>
91395>>>        // We preserve the value of the Err flag, by saving its current state and resetting it before end of function.
91395>>>        Move Err to bTmp
91396>>>        Move False to Err
91397>>>
91397>>>        Get AutoConnectionIDLogin to bOK
91398>>>        // First get the info for the current filelist slot:
91398>>>        Open iFromFileSlot
91400>>>        Get_Attribute DF_FILE_OPENED of iFromFileSlot to bOK
91403>>>        If (bOK = True) Begin
91405>>>            Get_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to sFileName
91408>>>            Get_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to sTableName
91411>>>            Get_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to sDisplayName
91414>>>
91414>>>            //...then move it.
91414>>>            Set_Attribute DF_FILE_ROOT_NAME    of iToFileSlot to sFileName
91417>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iToFileSlot to sTableName
91420>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iToFileSlot to sDisplayName
91423>>>
91423>>>            //...and finally remove the old filelist values.
91423>>>            Set_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to ""
91426>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to ""
91429>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to ""
91432>>>        End
91432>>>>
91432>>>        Close iFromFileSlot
91433>>>
91433>>>        Move Err to bErr
91434>>>        Move bTmp to Err
91435>>>        Function_Return (bErr = False)
91436>>>    End_Function
91437>>>
91437>>>    Function ApiTableRelate Handle hTableFrom Handle hTableTo Integer iColumnFrom Integer iColumnTo Returns Boolean
91439>>>        Handle hTable
91439>>>        Boolean bOK
91439>>>        String sDriverID
91439>>>
91439>>>        Get AutoConnectionIDLogin to bOK
91440>>>        Move False to Err
91441>>>        Open hTableFrom Mode DF_EXCLUSIVE
91443>>>        If (hTableTo > 0) Begin
91445>>>            Open hTableTo
91447>>>        End
91447>>>>
91447>>>        Move hTableFrom to hTable
91448>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
91451>>>        Set Private.phCurrentTable to hTable
91452>>>
91452>>>        Structure_Start hTable sDriverID            
91453>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumnFrom to hTableTo
91456>>>            If (iColumnTo <> 0) Begin
91458>>>                Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumnFrom to iColumnTo
91461>>>            End
91461>>>>
91461>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
91462>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
91464>>>        Set Action_Text of ghoStatusPanel to ""
91465>>>
91465>>>        If (hTableTo > 0) Begin
91467>>>            Close hTableTo
91468>>>        End
91468>>>>
91468>>>
91468>>>        Function_Return (Err = False)
91469>>>    End_Function
91470>>>
91470>>>    // Removes the passed table name completely from disk, filelist (& Sql Server if an Sql-driver)
91470>>>    Function ApiTableRemove Handle hTable Returns Boolean
91472>>>        String sTableName sDriverID
91472>>>        Boolean bOk
91472>>>        String sDataPath
91472>>>
91472>>>        Get AutoConnectionIDLogin to bOK
91473>>>        Move False to Err
91474>>>        Get psDriverID to sDriverID
91475>>>        Get UtilTableHandleToString hTable sDriverID to sTableName
91476>>>        If (sTableName = "") Begin
91478>>>            Function_Return False
91479>>>        End
91479>>>>
91479>>>
91479>>>        Set Private.phCurrentTable to hTable
91480>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
91481>>>        Delete_db sTableName
91482>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
91483>>>
91483>>>        If (sDriverID <> DATAFLEX_ID) Begin
91485>>>            Get SqlTableRemoveByTableName sDriverID sTableName to bOk
91486>>>            Get psDataPathFirstPart to sDataPath
91487>>>            Get vDeleteFile (sDataPath + sTableName + ".int") to bOk
91488>>>        End
91488>>>>
91488>>>        // Also remove table from filelist.cfg in case the physical file didn't exist.
91488>>>        If (hTable <> 0) Begin
91490>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
91493>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
91496>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
91499>>>        End
91499>>>>
91499>>>
91499>>>        Close hTable
91500>>>        Function_Return (hTable <> 0)
91501>>>    End_Function
91502>>>
91502>>>    Function ApiTableRemoveRelation Handle hTableTo Integer iColumn Returns Boolean
91504>>>        Handle hTable
91504>>>        Boolean bOK
91504>>>
91504>>>        Get AutoConnectionIDLogin to bOK
91505>>>        Move False to Err
91506>>>        Open hTableTo Mode DF_EXCLUSIVE
91508>>>        Move hTableTo to hTable
91509>>>
91509>>>        Structure_Start hTable
91510>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to 0
91513>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
91514>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
91516>>>        Set Action_Text of ghoStatusPanel to ""
91517>>>
91517>>>        Close hTableTo
91518>>>        Function_Return (Err = False)
91519>>>    End_Function
91520>>>
91520>>>    Function ApiTableRename Integer hTable String sRootName String sDisplayName String sLogicalName Returns Boolean
91522>>>        String sPhysicalName sRootNameTo sLogicalNameTo sDataPath sDriverID sSchema sPhysicalNameTo
91522>>>        Boolean bOK bExists bOpened     
91522>>>        tAPITableNameInfo APITableNameInfo
91522>>>        tAPITableNameInfo APITableNameInfo
91522>>>        
91522>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
91525>>>        If (bOpened = False) Begin
91527>>>            Get OpenTableExclusive hTable to bOpened
91528>>>            If (bOpened = False) Begin
91530>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
91531>>>                Function_Return False
91532>>>            End
91532>>>>
91532>>>        End
91532>>>>
91532>>>
91532>>>        Set Private.phCurrentTable to hTable
91533>>>        Move hTable         to APITableNameInfo.iTableNumber
91534>>>        Move sRootName      to APITableNameInfo.sRootName
91535>>>        Move sLogicalName   to APITableNameInfo.sLogicalName
91536>>>        Move sDisplayName   to APITableNameInfo.sDisplayName
91537>>>        Get ApiTableFilelistNamesCompare True APITableNameInfo to bExists
91538>>>        If (bExists = True) Begin
91540>>>            Function_Return True
91541>>>        End
91541>>>>
91541>>>        
91541>>>        Set Private.phCurrentTable to hTable
91542>>>        Move False to Err  
91543>>>        Get psDataPathFirstPart to sDataPath
91544>>>        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName
91547>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
91550>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
91553>>>
91553>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
91556>>>        Close hTable
91557>>>        If (sDriverID = DATAFLEX_ID) Begin
91559>>>            Get vFilePathExists (sDataPath + sRootNameTo + ".dat") to bExists
91560>>>            If (bExists = True) Begin
91562>>>                If (Uppercase(sRootName) <> Uppercase(sRootNameTo)) Begin
91564>>>                    Copy_db (sDataPath + sRootNameTo) to (sDataPath + sRootName)
91567>>>                    // We need a short break here before attempting to delete the physical old files or Windows
91567>>>                    // might report "File in use..." and the deletion will fail.
91567>>>                    Sleep 2
91568>>>                    Get vDeleteFile (sDataPath + sRootNameTo + ".*") to bOK
91569>>>                End
91569>>>>
91569>>>            End
91569>>>>
91569>>>        End
91569>>>>
91569>>>
91569>>>        If (sDriverID <> DATAFLEX_ID) Begin           
91571>>>            If (not(sPhysicalName contains ".")) Begin
91573>>>                Move (sPhysicalName + String(".int")) to sPhysicalName
91574>>>            End
91574>>>>
91574>>>            
91574>>>            // Change the table name in the .int file to the new table new:
91574>>>            Get UtilChangeSourceCodeLine (sDataPath + sPhysicalName) (CS_DATABASE_NAME * String(sLogicalNameTo)) (CS_DATABASE_NAME * String(sLogicalName)) False to bOK
91575>>>            If (bOK = False) Begin
91577>>>                Function_Return False
91578>>>            End
91578>>>>
91578>>>            
91578>>>            // Change table name at the SQL side:
91578>>>            Get psSchema to sSchema
91579>>>            Get SqlTableRename hTable sLogicalNameTo sLogicalName to bOK 
91580>>>            
91580>>>            Get _TableNameOnly sRootName to sPhysicalNameTo
91581>>>            // Remove cache file and Rename the physical file names:
91581>>>            Get vDeleteFile (sDataPath + sPhysicalNameTo + ".cch")                                  to bOK 
91582>>>            Get vRenameFile (sDataPath + sPhysicalName)            (sDataPath + sRootName + ".int") to bOK
91583>>>            Get vRenameFile (sDataPath + sPhysicalNameTo + ".tag") (sDataPath + sRootName + ".tag") to bOK
91584>>>            Move (sDriverID + ":" + sRootName) to sRootName         
91585>>>            If (not(sDisplayName contains ".")) Begin
91587>>>                Move (sSchema + "." + sDisplayName) to sDisplayName
91588>>>            End
91588>>>>
91588>>>        End
91588>>>>
91588>>>
91588>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
91591>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
91594>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
91597>>>
91597>>>        Function_Return (Err = False)
91598>>>    End_Function
91599>>>
91599>>>    Function ApiTableRenameAlias Integer hTable String sDisplayName String sLogicalName Returns Boolean
91601>>>        Move False to Err
91602>>>        Set Private.phCurrentTable to hTable
91603>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
91606>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
91609>>>
91609>>>        Function_Return (Err = False)
91610>>>    End_Function
91611>>>
91611>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
91611>>>    // Note that it first removes any driver prefixes in the rootname.
91611>>>    Function ApiTableFilelistNamesCompare Boolean bCompareFilelistUppercase tAPITableNameInfo APITableInfo Returns Boolean
91613>>>        String sRootNameFrom sRootNameTo sDisplayNameTo sLogicalNameTo
91613>>>        Handle hTable
91613>>>        Boolean bIsSame
91613>>>
91613>>>        Move APITableInfo.iTableNumber      to hTable
91614>>>        Get _TableNameOnly APITableInfo.sRootName     to sRootNameFrom
91615>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
91618>>>        Get _TableNoPrefix sRootNameTo                to sRootNameTo
91619>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
91622>>>        Get_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayNameTo
91625>>>        Get _TableNoPrefix sDisplayNameTo             to sDisplayNameTo
91626>>>
91626>>>        If (bCompareFilelistUppercase = True) Begin
91628>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(APITableInfo.sLogicalName) = Uppercase(sLogicalNameTo) and ;                  Uppercase(APITableInfo.sDisplayName) = Uppercase(sDisplayNameTo)) to bIsSame
91629>>>        End
91629>>>>
91629>>>        Else Begin
91630>>>            Move (sRootNameFrom = sRootNameTo and APITableInfo.sLogicalName = sLogicalNameTo and APITableInfo.sDisplayName = sDisplayNameTo) to bIsSame
91631>>>        End
91631>>>>
91631>>>
91631>>>        Function_Return bIsSame
91632>>>    End_Function
91633>>>    
91633>>>    // Note: This table update function does _not_ convert an embedded table to SQL. Use function ApiTableConvertToSQL first for that.
91633>>>    Function ApiTableUpdate tAPITableNameInfo APITableNameInfoFrom tAPIColumn[] aColumnsFrom tAPIIndex[] aIndexesFrom tAPIRelation[] aRelationsFrom Returns Boolean
91635>>>        Handle hFile hTable
91635>>>        String sTableName sLogicalName sDisplayName
91635>>>        String sConnectionID sVal sSchema sOriginalDriverID sDriverIDFrom sDriverIDTo sRootName
91635>>>        Integer iColumn iDbType
91635>>>        Boolean bOk bExists bMertechDriver bExistsInFilelist bOpened bApiTableUpdateAuto
91635>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase bTableExists
91635>>>        Boolean bIsSame bSameTableNames bFilelistError bIsAliasFrom bIsAliasTo bIsSQLTableFrom bIsSQLTableTo
91635>>>        tSQLConnection SQLConnection
91635>>>        tSQLConnection SQLConnection
91635>>>        tAPITable      APITableFrom APITableTo
91635>>>        tAPITable      APITableFrom APITableTo
91635>>>        tColumnType    ColumnType
91635>>>        tColumnType    ColumnType
91635>>>        tAPIColumnCompare[]   aAPIColumnCompare
91635>>>        tAPIColumnCompare[]   aAPIColumnCompare
91636>>>        tAPIIndexCompare[]    aAPIIndexCompare
91636>>>        tAPIIndexCompare[]    aAPIIndexCompare
91637>>>        tAPIRelationCompare[] aAPIRelationCompare
91637>>>        tAPIRelationCompare[] aAPIRelationCompare
91638>>>
91638>>>        // We don't allow update of the framework's DbVersion table.
91638>>>        If (Lowercase(sTableName) = "dbversion") Begin
91640>>>            Function_Return False
91641>>>        End
91641>>>>
91641>>>        
91641>>>        Move APITableNameInfoFrom.sDriverID     to sDriverIDFrom
91642>>>        Get piDbType                            to iDbType
91643>>>        Get pbRecnum                            to bRecnum
91644>>>        Get pbToANSI                            to bToANSI
91645>>>        Get pbCopyData                          to bCopyData
91646>>>        Get pbApiTableUpdateAuto                to bApiTableUpdateAuto
91647>>>        Get pbCompareDate_DateTime              to bCompareDate_DateTime
91648>>>        Get pbCompareIndexAscending             to bCompareIndexAscending
91649>>>        Get pbCompareIndexUppercase             to bCompareIndexUppercase   
91650>>>        Get IsMertechDriver sDriverIDFrom       to bMertechDriver
91651>>>        Get pbUseConnectionID                   to bUseConnectionID
91652>>>        If (bMertechDriver = True and bUseConnectionID = True) Begin
91654>>>            Move False                          to bUseConnectionID
91655>>>        End
91655>>>>
91655>>>
91655>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
91656>>>        Set Private.phCurrentTable              to hTable
91657>>>        Get UtilTableExists  hTable             to bTableExists     
91658>>>        
91658>>>        If (ghoProgressBar <> 0) Begin
91660>>>            Send DoAdvance of ghoProgressBar
91661>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
91662>>>        End
91662>>>>
91662>>>
91662>>>        Move APITableNameInfoFrom.bIsAlias      to bIsAliasFrom
91663>>>        Move APITableNameInfoFrom.bIsSQL        to bIsSQLTableFrom
91664>>>        Get UtilDriverFromTableNumber hTable    to sDriverIDTo
91665>>>        Get UtilTableIsSQL   hTable             to bIsSQLTableTo
91666>>>        Move True                               to APITableFrom.bFromTable
91667>>>        Move hTable                             to APITableFrom.hTable
91668>>>        Move APITableNameInfoFrom               to APITableFrom.ApiTableInfo
91669>>>        Move aColumnsFrom                       to APITableFrom.aApiColumns
91670>>>        Move aIndexesFrom                       to APITableFrom.aApiIndexes
91671>>>        Move aRelationsFrom                     to APITableFrom.aApiRelations
91672>>>        
91672>>>        If (bTableExists = True) Begin
91674>>>            Get OpenTableExclusive hTable to bOpened
91675>>>            If (bOpened = False) Begin
91677>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
91678>>>                Function_Return False
91679>>>            End
91679>>>>
91679>>>            Get UtilTableStructFill hTable False                                                        to APITableTo
91680>>>            Get UtilColumnCombineFromAndToArrays APITableFrom.aApiColumns     APITableTo.aApiColumns    to aAPIColumnCompare
91681>>>            Get UtilIndexCombineFromAndToArrays  APITableFrom.aApiIndexes     APITableTo.aApiIndexes    to aAPIIndexCompare
91682>>>            Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations  to aAPIRelationCompare
91683>>>        End
91683>>>>
91683>>>        
91683>>>        Move False to Err
91684>>>        Case Begin
91684>>>            // Alias table:
91684>>>            Case (bIsAliasFrom = True)
91686>>>                Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
91687>>>                Case Break
91688>>>            
91688>>>            // New Table:
91688>>>            Case (bTableExists = False)
91691>>>                Get ApiTableCreate      hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName bUseConnectionID bToANSI bRecnum aColumnsFrom to bOk
91692>>>                Get UtilIndexesUpdate   hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
91693>>>                Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
91694>>>                Case Break
91695>>>    
91695>>>            // Update table:    
91695>>>            Case (bTableExists = True)
91698>>>                Get UtilTableCompare APITableFrom APITableTo False (&bFilelistError) to bIsSame
91699>>>                If (bIsSame = True) Begin
91701>>>                    Case Break
91702>>>                End
91702>>>>
91702>>>                If (bFilelistError = True) Begin
91704>>>                    Get ApiTableRename hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName to bOk
91705>>>                    If (bOk = False) Begin
91707>>>                        Case Break
91708>>>                    End
91708>>>>
91708>>>                End
91708>>>>
91708>>>
91708>>>                If (ghoProgressBar <> 0) Begin
91710>>>                    Send DoAdvance of ghoProgressBar
91711>>>                    Set TableName_Text of ghoStatusPanel to ("Updating Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
91712>>>                End
91712>>>>
91712>>>        
91712>>>                // Columns:            
91712>>>                Move True to bOk
91713>>>                Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
91714>>>                If (bIsSame = False) Begin
91716>>>                    Get ApiColumnsUpdate sDriverIDFrom hTable bIsSQLTableFrom APITableFrom.aApiColumns APITableTo.aApiColumns bCompareDate_DateTime to bOk
91717>>>                End
91717>>>>
91717>>>                If (bOk = False) Begin
91719>>>                    Case Break
91720>>>                End
91720>>>>
91720>>>
91720>>>                // Indexes:
91720>>>                Get UtilIndexesCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
91721>>>                If (bIsSame = False) Begin
91723>>>                    Get UtilIndexesUpdate hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
91724>>>                End
91724>>>>
91724>>>                
91724>>>                // Relations:
91724>>>                Get UtilRelationsCompare hTable aAPIRelationCompare to bIsSame
91725>>>                If (bIsSame = False) Begin
91727>>>                    Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
91728>>>                    If (bOk = False) Begin
91730>>>                        Case Break
91731>>>                    End
91731>>>>
91731>>>                End                                                               
91731>>>>
91731>>>                
91731>>>                // Filelist Names:
91731>>>                Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
91732>>>                Case Break
91733>>>
91733>>>            Case Else
91733>>>                Error DFERR_PROGRAM "Unknown Case structure exit in Function ApiTableUpdate"
91734>>>>
91734>>>                Move False to bOk
91735>>>        Case End                     
91735>>>
91735>>>        Close hTable
91736>>>        Set TableName_Text of ghoStatusPanel to ""
91737>>>
91737>>>        Function_Return (bOK = True)
91738>>>    End_Function
91739>>>    
91739>>>    // Replaces all date values with CS_DUFLowestAllowedDateValue for all tables in Filelist.cfg,
91739>>>    // _except_ those tables that has been excluded with the "ApiTableDateCorrectionAddException" message.
91739>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.               
91739>>>    // This is for prepairing embedded tables (*.dat) before an SQL conversion.
91739>>>    //
91739>>>    // The root of the problem is the following:
91739>>>    // The data type Date in SQL has a range of accepted values from 01-01-0001 through 12-31-9999
91739>>>    // while the data type DateTime has a range of accepted values from 01-01-1753 through 12-31-9999
91739>>>    // So if you happen to have a Date from before 1753, or an empty / NULL value - this will be outside 
91739>>>    // the range that DateTime can handle and if you then try to change a Date column to a DateTime,
91739>>>    // an SQL error will be thrown;
91739>>>    // "The conversion of a date data type to a datetime data type resulted in an out-of-range value".
91739>>>    Function ApiTableFixAllDateBogusValues Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
91741>>>        Boolean bOK bIsAlias bIsSQL
91741>>>        Integer iCount iSize iDateSize iItems
91741>>>        Handle hTable                        
91741>>>        String sLogicalName
91741>>>        Integer[] aTablesToCheck aDateFields
91743>>>        
91743>>>        Get _AllTablesDateCorrections to aTablesToCheck
91744>>>        Move (SizeOfArray(aTablesToCheck)) to iSize
91745>>>        Set pbVisible    of ghoProgressBarOverall to True
91746>>>        Set piPosition   of ghoProgressBarOverall to 0
91747>>>        Set piMaximum    of ghoProgressBarOverall to iSize
91748>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
91749>>>
91749>>>        Move True to bOK
91750>>>        Decrement iSize
91751>>>        for iCount from 0 to iSize
91757>>>>
91757>>>            Move aTablesToCheck[iCount] to hTable 
91758>>>            Set piPosition of ghoProgressBarOverall to iCount
91759>>>            Get UtilTableIsAlias hTable to bIsAlias
91760>>>            Get UtilTableIsSql   hTable to bIsSQL
91761>>>            
91761>>>            Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
91764>>>            Set TableName_Text of ghoStatusPanel to ("Processing Table Number:" * String(hTable) * "Name:" * String(sLogicalName))
91765>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
91766>>>
91766>>>            If (bIsAlias = False and bIsSQL = False) Begin
91768>>>                Get UtilCheckForDateFields hTable to aDateFields
91769>>>                Move (SizeOfArray(aDateFields)) to iDateSize
91770>>>                If (iDateSize > 0) Begin
91772>>>                    Get UtilTableCorrectBogusDateValues hTable aDateFields bFixZeroDates bResetIndexesToOnLine to bOK
91773>>>                    Close hTable                                     
91774>>>                End
91774>>>>
91774>>>            End  
91774>>>>
91774>>>        Loop
91775>>>>
91775>>>        
91775>>>        Close DF_ALL
91776>>>        Function_Return bOK
91777>>>    End_Function
91778>>>    
91778>>>    // Returns all fields of type Date or DateTime in an integer array with the field numbers.
91778>>>    Function UtilCheckForDateFields Handle hTable Returns Integer[]
91780>>>        Integer[] aDateFields aDateFieldsEmpty
91782>>>        Integer iField iSize iCount iType
91782>>>        Boolean bOpen
91782>>>        
91782>>>        Open hTable
91784>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
91787>>>        If (bOpen = False) Begin  
91789>>>            Error ("Table could not be opened." * String(hTable))
91790>>>>
91790>>>            Function_Return aDateFieldsEmpty
91791>>>        End                                 
91791>>>>
91791>>>        
91791>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iSize
91794>>>        for iCount from 1 to iSize
91800>>>>
91800>>>            Get_Attribute DF_FIELD_TYPE of hTable iCount to iType
91803>>>            If (iType = DF_DATE or iType = DF_DATETIME) Begin
91805>>>                Move iCount to aDateFields[SizeOfArray(aDateFields)]
91806>>>            End
91806>>>>
91806>>>        Loop
91807>>>>
91807>>>        
91807>>>        Function_Return aDateFields
91808>>>    End_Function         
91809>>>        
91809>>>    // Loops through all records for the passed hTable, and checks that all Date values
91809>>>    // for the passed aDateFields array are OK. Else the Data value is set to CS_DUFLowestAllowedDateValue
91809>>>    // and the record is saved  
91809>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed. 
91809>>>    // Note: It first sets all indexes to BATCH and reset them at the end.
91809>>>    Function UtilTableCorrectBogusDateValues Handle hTable Integer[] aDateFields Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
91811>>>        Integer iSize iCount iField iRecord iRetval iTotalRecords iDateFormat
91811>>>        String sValue    
91811>>>        Boolean bCancel bFound bOK bChange bOpened bSaveChanges
91811>>>        Date dDate dDateMin 
91811>>>        Integer[] iaChangeField
91812>>>        
91812>>>        // The CS_DUFLowestAllowedDateValue is defined as "01/01/1753", so we first set the 
91812>>>        // date format to "USA" = "MM/DD/YYYY"
91812>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
91815>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_USA
91818>>>        
91818>>>        Send SetAllIndexesToBatch hTable True
91819>>>        Open hTable                               
91821>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
91824>>>        If (bOpened = False) Begin
91826>>>            Function_Return False
91827>>>        End                      
91827>>>>
91827>>>        
91827>>>        Set Private.phCurrentTable to hTable
91828>>>        Move 0 to iRecord
91829>>>        Move (SizeOfArray(aDateFields)) to iSize
91830>>>        Decrement iSize
91831>>>        
91831>>>        Get_Attribute DF_FILE_RECORDS_USED of hTable to iTotalRecords
91834>>>        Set piPosition   of ghoProgressBar to 0
91835>>>        Set piAdvanceBy  of ghoProgressBar to 100
91836>>>        Set piMaximum    of ghoProgressBar to iTotalRecords
91837>>>        Move CS_DUFLowestAllowedDateValue  to dDateMin
91838>>>        Move False to Err
91839>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91840>>>        
91840>>>        Clear hTable     
91841>>>        Repeat
91841>>>>
91841>>>            Vfind hTable 0 GT
91843>>>            Move Found to bFound
91844>>>            If (bFound = True) Begin    
91846>>>                Move False to bSaveChanges   
91847>>>                Move (ResizeArray(iaChangeField, 0)) to iaChangeField 
91848>>>                Move (SizeOfArray(aDateFields)) to iSize
91849>>>                Decrement iSize
91850>>>                for iCount from 0 to iSize   
91856>>>>
91856>>>                    Move aDateFields[iCount] to iField
91857>>>                    Get_Field_Value hTable iField to dDate
91860>>>                    If (bFixZeroDates = True) Begin
91862>>>                        Move (dDate = 0 or dDate < dDateMin) to bChange
91863>>>                    End 
91863>>>>
91863>>>                    Else Begin
91864>>>                        Move (dDate <> 0 and dDate < dDateMin) to bChange
91865>>>                    End
91865>>>>
91865>>>                    If (bChange = True) Begin      
91867>>>                        Move iField to iaChangeField[SizeOfArray(iaChangeField)]            
91868>>>                    End
91868>>>>
91868>>>                Loop       
91869>>>>
91869>>>                
91869>>>                // Only change Date fields that needs to be changed.
91869>>>                If (SizeOfArray(iaChangeField)) Begin
91871>>>                    Reread hTable 
91875>>>                        Move (SizeOfArray(iaChangeField)) to iSize
91876>>>                        Decrement iSize      
91877>>>                        for iCount from 0 to iSize
91883>>>>
91883>>>                            Move iaChangeField[iCount] to iField
91884>>>                            Set Private.piCurrentField to iField
91885>>>                            Set_Field_Value hTable iField to dDateMin  
91888>>>                        Loop
91889>>>>
91889>>>                        Move False to Err
91890>>>                        SaveRecord hTable
91891>>>                    Unlock
91892>>>>
91892>>>                End
91892>>>>
91892>>>                
91892>>>                Increment iRecord
91893>>>                // Increment the StatusPanel counter and check the
91893>>>                // cancel status every 100 records rather than every
91893>>>                // record, it's way faster.
91893>>>                If (Mod(iRecord, 100) = 0) Begin
91895>>>                    Send DoAdvance of ghoProgressBar
91896>>>                    Set Action_Text of ghoStatusPanel to ("Record:" * String(iRecord))
91897>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
91898>>>                End 
91898>>>>
91898>>>            End
91898>>>>
91898>>>        Until (bFound = False)
91900>>>                
91900>>>        Set_Attribute DF_DATE_FORMAT to iDateFormat   
91903>>>        If (bResetIndexesToOnLine = True) Begin
91905>>>            Send SetAllIndexesToBatch hTable False
91906>>>        End
91906>>>>
91906>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91907>>>        
91907>>>        Function_Return (Err = False)
91908>>>    End_Function 
91909>>>        
91909>>>
91909>>>    // * Dummy function for the Studio's Code Explorer *
91909>>>    Function API_COLUMN_FUNCTIONS Returns Boolean
91911>>>        Function_Return False
91912>>>    End_Function
91913>>>
91913>>>    // Adds a column name to the passed table number.
91913>>>    Function ApiColumnAdd Handle hTable String sFieldName Integer iType Integer iLength Integer iPrec Boolean bInitVal String sColVal Returns Boolean
91915>>>        Integer iColumn iCount iFile iPrecision
91915>>>        Boolean bExists bOK bInitializeValue bRetval
91915>>>        String sDdSrcPath sTableName sColumnValue
91915>>>
91915>>>        Get UtilColumnExists hTable sFieldName to bExists
91916>>>        Move False to Err
91917>>>        If (bExists = True) Begin
91919>>>            Function_Return False
91920>>>        End
91920>>>>
91920>>>        If (num_arguments > 4) Begin
91922>>>            Move iPrec to iPrecision
91923>>>        End
91923>>>>
91923>>>        If (num_arguments > 6) Begin
91925>>>            Move bInitVal to bInitializeValue
91926>>>            Move sColVal  to sColumnValue
91927>>>        End
91927>>>>
91927>>>        If (iType < -1490) Begin
91929>>>            Move (iType + 1500) to iType
91930>>>        End
91930>>>>
91930>>>
91930>>>        Get AutoConnectionIDLogin to bOK
91931>>>        Move False to Err
91932>>>        // Structure_start will change the value of hTable...
91932>>>        Move hTable to iFile
91933>>>        Open iFile Mode DF_EXCLUSIVE
91935>>>
91935>>>        Set Private.phCurrentTable to hTable
91936>>>        Structure_Start iFile
91937>>>            Move 0 to iColumn
91938>>>            Set Private.piCurrentField to iColumn
91939>>>            Create_Field hTable At iColumn
91940>>>            Set_Attribute DF_FIELD_NAME      of iFile iColumn to sFieldName
91943>>>            Set_Attribute DF_FIELD_TYPE      of iFile iColumn to iType
91946>>>            Set_Attribute DF_FIELD_LENGTH    of iFile iColumn to (iLength + iPrecision)
91949>>>            Set_Attribute DF_FIELD_PRECISION of iFile iColumn to iPrecision
91952>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
91953>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
91955>>>        Set Action_Text of ghoStatusPanel to ""
91956>>>
91956>>>        // If in development environment; create .fd file:
91956>>>        Open hTable
91958>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
91959>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
91960>>>        If (iCount > 1) Begin
91962>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
91963>>>        End
91963>>>>
91963>>>        Get vFolderExists sDDSrcPath to bExists
91964>>>        If (bExists = True) Begin
91966>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
91967>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
91970>>>            Get _TableNameOnly sTableName to sTableName
91971>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
91973>>>        End
91973>>>>
91973>>>
91973>>>        // Check for a default value
91973>>>        If (bInitializeValue = True and sColumnValue <> "" and Err = False) Begin
91975>>>            Get ApiColumnUpdateValue hTable sFieldName sColumnValue to bRetval
91976>>>        End
91976>>>>
91976>>>        Close hTable
91977>>>
91977>>>        Function_Return (Err = False)
91978>>>    End_Function
91979>>>
91979>>>    // Adds a column name to the passed table number.
91979>>>    Function ApiColumnInsert Handle hTable Integer iColumn String sFieldName Integer iType Integer iLength Integer iPrec Boolean bIsSQLType Returns Boolean
91981>>>        Integer iCount iFile iPrecision iNumberOfFields
91981>>>        Boolean bExists bOK bInitializeValue bRetval bIsDateType
91981>>>        String sDdSrcPath sTableName sColumnValue
91981>>>
91981>>>        Get UtilColumnExists hTable sFieldName to bExists
91982>>>        Move False to Err
91983>>>        If (bExists = True) Begin
91985>>>            Function_Return False
91986>>>        End
91986>>>>
91986>>>        If (num_arguments > 4) Begin
91988>>>            Move iPrec to iPrecision
91989>>>        End
91989>>>>
91989>>>        If (iType < -1490) Begin
91991>>>            Move (iType + 1500) to iType
91992>>>        End
91992>>>>
91992>>>
91992>>>        Get AutoConnectionIDLogin to bOK
91993>>>        Move False to Err
91994>>>        // Structure_start will change the value of hTable...
91994>>>        Move hTable to iFile
91995>>>        Get OpenTableExclusive iFile to bOK
91996>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iNumberOfFields
91999>>>        
91999>>>        // If the passed column number is higher than the current number of fields
91999>>>        // in the table, this means we should _not_ insert a field but rather add
91999>>>        // a new field to the end:
91999>>>        If (iColumn > iNumberOfFields) Begin
92001>>>            Move 0 to iColumn
92002>>>        End
92002>>>>
92002>>>
92002>>>        Set Private.phCurrentTable to hTable
92003>>>        Set Private.piCurrentField to iColumn
92004>>>
92004>>>        Structure_Start iFile
92005>>>            Create_Field iFile At iColumn
92006>>>            Set_Attribute DF_FIELD_NAME            of iFile iColumn to sFieldName
92009>>>            If (bIsSQLType = False) Begin
92011>>>                Set_Attribute DF_FIELD_TYPE        of iFile iColumn to iType
92014>>>            End 
92014>>>>
92014>>>            Else Begin
92015>>>                Set_Attribute DF_FIELD_NATIVE_TYPE of iFile iColumn to iType
92018>>>            End
92018>>>>
92018>>>            Get UtilColumnIsDateType iType False to bIsDateType
92019>>>            If (bIsDateType = False) Begin
92021>>>                Set_Attribute DF_FIELD_LENGTH       of iFile iColumn to (iLength + iPrecision)
92024>>>                Set_Attribute DF_FIELD_PRECISION    of iFile iColumn to iPrecision
92027>>>            End
92027>>>>
92027>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
92028>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
92030>>>
92030>>>        Set Action_Text of ghoStatusPanel to ""
92031>>>        // If in development environment; create .fd file:
92031>>>        Open hTable
92033>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
92034>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
92035>>>        If (iCount > 1) Begin
92037>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
92038>>>        End
92038>>>>
92038>>>        Get vFolderExists sDDSrcPath to bExists
92039>>>        If (bExists = True) Begin
92041>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
92042>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
92045>>>            Get _TableNameOnly sTableName to sTableName
92046>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
92048>>>        End
92048>>>>
92048>>>
92048>>>        // Check for a default value
92048>>>        Close hTable
92049>>>
92049>>>        Function_Return (Err = False)
92050>>>    End_Function
92051>>>
92051>>>//    Function ApiColumnAddMultiple Handle hTable tAPIColumn[] aColumns Returns Boolean
92051>>>//        Integer iColumn iCount iFile
92051>>>//        Boolean bExists bOK
92051>>>//        String sDdSrcPath sTableName
92051>>>//
92051>>>//        Get AutoConnectionIDLogin to bOK
92051>>>//        Move False to Err
92051>>>//
92051>>>//        // Structure_start will change the value of hTable...
92051>>>//        Move hTable to iFile
92051>>>//        Open iFile Mode DF_EXCLUSIVE
92051>>>//
92051>>>//        Structure_Start iFile
92051>>>//            Send ApiColumnsAddToTable iFile aColumns False
92051>>>//        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
92051>>>//
92051>>>//        // If in development environment; create .fd file:
92051>>>//        Open hTable
92051>>>//        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
92051>>>//        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
92051>>>//        If (iCount > 1) Begin
92051>>>//            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
92051>>>//        End
92051>>>//        Get vFolderExists sDDSrcPath to bExists
92051>>>//        If (bExists = True) Begin
92051>>>//            Get vFolderFormat sDDSrcPath to sDDSrcPath
92051>>>//            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
92051>>>//            Get _TableNameOnly sTableName to sTableName
92051>>>//            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
92051>>>//        End
92051>>>//        Close hTable
92051>>>//
92051>>>//        Function_Return (Err = False)
92051>>>//    End_Function
92051>>>
92051>>>    // To update all records for a table column with a fixed value.
92051>>>    Function ApiColumnUpdateValue Handle hTable String sFieldName String sColumnValue Returns Boolean
92053>>>        Integer iRecs iCurrErr iField iRecord
92053>>>        Boolean bRetval bOpen
92053>>>
92053>>>        Move 0 to iRecs
92054>>>        Move False to bRetval
92055>>>        Move Err to iCurrErr
92056>>>        Move False to Err
92057>>>
92057>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
92060>>>        If (bOpen = False) Begin
92062>>>            Open hTable
92064>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
92067>>>            If (bOpen = False) Begin
92069>>>                Function_Return bRetval
92070>>>            End
92070>>>>
92070>>>        End
92070>>>>
92070>>>
92070>>>        Field_Map hTable sFieldName to iField
92072>>>        If (iField <> 0) Begin
92074>>>            Set Private.phCurrentTable to hTable
92075>>>            Set Private.piCurrentField to iField
92076>>>            Clear hTable
92077>>>            Repeat
92077>>>>
92077>>>                Vfind hTable 0 GT
92079>>>                If (Found) Begin
92081>>>                    If (ghoStatusPanel <> 0) Begin
92083>>>                        Get_Field_Value hTable 0 to iRecord
92086>>>                        Send Update_StatusPanel of ghoStatusPanel (CS_UpdateVersion * String(iRecord))
92087>>>                    End
92087>>>>
92087>>>                    Reread hTable
92091>>>                        Set_Field_Value hTable iField to sColumnValue
92094>>>                        SaveRecord hTable
92095>>>                    Unlock
92096>>>>
92096>>>                End
92096>>>>
92096>>>           Until (not(Found))
92098>>>        End
92098>>>>
92098>>>
92098>>>        Move (Err = False) to bRetval
92099>>>        Move iCurrErr to Err
92100>>>
92100>>>        Function_Return bRetval
92101>>>    End_Function
92102>>>    
92102>>>    // Note: This can only be used from within a Structure_Start/End construct.
92102>>>    Function ApiColumnsAddToTable Handle hTable tAPIColumn[] aColumns Boolean bCreating Returns Boolean
92104>>>        Integer iCount iSize iColumn iType iDataFlexType iIndex iDbType
92104>>>        Boolean bFieldExists bNativeType bIsSQLDriver bIsDAWSqlDriver bIsSqlTable bRecnumTable bIsOpen bIsDateType
92104>>>        String sFieldName sDriverID sTableName sDefaultValue
92104>>>
92104>>>//        Set Private.phCurrentTable to hTable
92104>>>        Get psDriverID to sDriverID
92105>>>        Get piDbType to iDbType
92106>>>        Get UtilTableHandleToString hTable to sTableName
92107>>>        Get IsSQLDriver    sDriverID to bIsSQLDriver
92108>>>        Get IsDAWSQLDriver sDriverID to bIsDAWSqlDriver
92109>>>        Get UtilTableIsSQL hTable to bIsSqlTable
92110>>>        If (bIsSqlTable = False and bCreating = True and bIsSQLDriver = True) Begin
92112>>>            Move True to bIsSqlTable
92113>>>        End
92113>>>>
92113>>>        Move False to bIsOpen
92114>>>        If (hTable > 0) Begin
92116>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
92119>>>        End
92119>>>>
92119>>>        If (bIsOpen = True) Begin
92121>>>            Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
92124>>>        End
92124>>>>
92124>>>        Else Begin        
92125>>>            Get pbRecnum to bRecnumTable
92126>>>        End
92126>>>>
92126>>>        
92126>>>        Move False to Err
92127>>>        Move (SizeOfArray(aColumns)) to iSize
92128>>>        Decrement iSize
92129>>>        for iCount from 0 to iSize
92135>>>>
92135>>>            Move aColumns[iCount].sFieldName to sFieldName
92136>>>            If (hTable > 0) Begin
92138>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92139>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
92140>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn to sFieldName
92143>>>                Move (Trim(sFieldName) <> "") to bFieldExists
92144>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
92145>>>                Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
92146>>>            End
92146>>>>
92146>>>            Else Begin
92147>>>                Move False to bFieldExists
92148>>>            End
92148>>>>
92148>>>
92148>>>            If (bFieldExists = False) Begin
92150>>>                Move 0 to iColumn
92151>>>                Create_Field hTable At iColumn
92152>>>            End
92152>>>>
92152>>>            Else Begin
92153>>>                Move iCount to iColumn
92154>>>            End
92154>>>>
92154>>>
92154>>>            Set Private.piCurrentField to iColumn
92155>>>
92155>>>            Move                                        iColumn to aColumns[iCount].iFieldNumber
92156>>>            Set_Attribute DF_FIELD_NAME       of hTable iColumn to aColumns[iCount].sFieldName
92159>>>
92159>>>            Move aColumns[iCount].iType to iType
92160>>>            Move (not(iType < -1490)) to bNativeType
92161>>>            If (iType < -1490) Begin
92163>>>                Move (iType + 1500) to iType
92164>>>            End
92164>>>>
92164>>>
92164>>>            If (bIsSqlTable = True) Begin
92166>>>                If (aColumns[iCount].bIsSQLType = True) Begin
92168>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iDataFlexType
92169>>>                    Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iDataFlexType
92172>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iType  
92175>>>                    Set_Attribute DF_FIELD_NULL_ALLOWED  of hTable iColumn to aColumns[iCount].bAllowNULL
92178>>>                    
92178>>>                    Move aColumns[iCount].sDefaultValue                    to sDefaultValue
92179>>>                    If (iDataFlexType = DF_BCD and Left(sDefaultValue, 1 <> "[")) Begin
92181>>>                        Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
92182>>>                    End
92182>>>>
92182>>>                    Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sDefaultValue 
92185>>>                
92185>>>                End
92185>>>>
92185>>>                Else Begin
92186>>>                    Set_Attribute DF_FIELD_TYPE        of hTable iColumn to iType
92189>>>                End
92189>>>>
92189>>>            End
92189>>>>
92189>>>            Else Begin
92190>>>                If (bCreating = False) Begin
92192>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iType
92193>>>                End
92193>>>>
92193>>>                Set_Attribute DF_FIELD_TYPE of hTable iColumn to iType
92196>>>            End
92196>>>>
92196>>>            
92196>>>            Get UtilColumnIsDateType iType bIsSqlTable to bIsDateType
92197>>>            If (bIsDateType = False) Begin
92199>>>                Set_Attribute DF_FIELD_LENGTH     of hTable iColumn to aColumns[iCount].iLength
92202>>>                Set_Attribute DF_FIELD_PRECISION  of hTable iColumn to aColumns[iCount].iPrecision
92205>>>            End
92205>>>>
92205>>>
92205>>>            If (aColumns[iCount].iOptions iand C_tAPIColumn_Identity) Begin
92207>>>                Move 0 to iIndex
92208>>>                Create_Index hTable at iIndex
92209>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to 1
92212>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD   of hTable iIndex 1 to iColumn
92215>>>                Set_Attribute DF_FILE_PRIMARY_INDEX    of hTable iIndex to 1
92218>>>
92218>>>                // If we have an identity table - we must create a primary_key table.
92218>>>                If (bIsSqlTable = True) Begin
92220>>>                    Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to True
92223>>>                    Set_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to True
92226>>>                End
92226>>>>
92226>>>            End
92226>>>>
92226>>>        Loop             
92227>>>>
92227>>>        
92227>>>        Function_Return (Err = False)
92228>>>    End_Function
92229>>>
92229>>>    // Changes a field type, length and precision for the passed table number and field name
92229>>>    Function ApiColumnChange Handle hTable String sFieldNameFrom Integer iTypeFrom Integer iLengthFrom Integer iPrec Returns Boolean
92231>>>        Integer iColumn iPrecFrom iTypeTo iLengthTo iPrecTo
92231>>>        Boolean bOK bIsSqlTable
92231>>>        String sFieldNameTo
92231>>>
92231>>>        If (num_arguments > 4) Begin
92233>>>            Move iPrec to iPrecFrom
92234>>>        End
92234>>>>
92234>>>        If (iTypeFrom < -1490) Begin
92236>>>            Move (iTypeFrom + 1500) to iTypeFrom
92237>>>        End
92237>>>>
92237>>>
92237>>>        Get AutoConnectionIDLogin to bOK
92238>>>        Move False to Err
92239>>>        Get OpenTableExclusive hTable to bOK
92240>>>        If (bOK = False) Begin
92242>>>            Function_Return False
92243>>>        End
92243>>>>
92243>>>
92243>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92244>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
92245>>>        Field_Map hTable sFieldNameFrom to iColumn
92247>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
92248>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
92249>>>        If (Err = True) Begin
92251>>>            Function_Return False
92252>>>        End
92252>>>>
92252>>>
92252>>>        Get_Attribute DF_FIELD_NAME                  of hTable iColumn to sFieldNameTo
92255>>>        Get UtilTableIsSQL hTable to bIsSqlTable
92256>>>        If (bIsSqlTable = False) Begin
92258>>>            Get_Attribute DF_FIELD_TYPE              of hTable iColumn to iTypeTo
92261>>>        End
92261>>>>
92261>>>        Else Begin
92262>>>            Get_Attribute DF_FIELD_NATIVE_TYPE       of hTable iColumn to iTypeTo
92265>>>        End
92265>>>>
92265>>>        // Let the driver decide the other values;
92265>>>        Get_Attribute DF_FIELD_LENGTH                of hTable iColumn to iLengthTo
92268>>>        Get_Attribute DF_FIELD_PRECISION             of hTable iColumn to iPrecTo
92271>>>
92271>>>        If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo) Begin
92273>>>            Function_Return False
92274>>>        End
92274>>>>
92274>>>
92274>>>        Set Private.phCurrentTable to hTable
92275>>>        Set Private.piCurrentField to iColumn
92276>>>
92276>>>        Structure_Start hTable
92277>>>            Set_Attribute DF_FIELD_NAME              of hTable iColumn to sFieldNameFrom
92280>>>            If (bIsSqlTable = False) Begin
92282>>>                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
92285>>>            End
92285>>>>
92285>>>            Else Begin
92286>>>                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
92289>>>                Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iTypeFrom
92292>>>            End
92292>>>>
92292>>>            Set_Attribute DF_FIELD_LENGTH            of hTable iColumn to iLengthFrom
92295>>>            Set_Attribute DF_FIELD_PRECISION         of hTable iColumn to iPrecFrom
92298>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
92299>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
92301>>>
92301>>>        Set Action_Text of ghoStatusPanel to ""
92302>>>        Function_Return (Err = False)
92303>>>    End_Function
92304>>>
92304>>>    // Changes a field type, length and precision for the passed table number and field name
92304>>>    Function ApiColumnChangeByColumnNumber String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo String sFieldNameFrom Integer iColumn Integer iTypeFrom Integer iLengthFrom Integer iPrec Integer iOpt Returns Boolean
92306>>>        Integer iPrecFrom iTypeTo iLengthTo iPrecTo iDbType iOptionFrom iOptionTo iDataFlexType iIndex
92306>>>        Boolean bOK bCompareDate_DateTime bSkip bRecnumTable bIsSameDataType
92306>>>        String sFieldNameTo sDriverIDTo
92306>>>        tColumnType ColumnType
92306>>>        tColumnType ColumnType
92306>>>        
92306>>>        Get pbCompareDate_DateTime to bCompareDate_DateTime
92307>>>        Get piDbType to iDbType
92308>>>        If (num_arguments > 4) Begin
92310>>>            Move iPrec to iPrecFrom
92311>>>            Move iOpt  to iOptionFrom
92312>>>        End
92312>>>>
92312>>>        If (iTypeFrom < -1490) Begin
92314>>>            Move (iTypeFrom + 1500) to iTypeFrom
92315>>>        End
92315>>>>
92315>>>
92315>>>        Get AutoConnectionIDLogin to bOK
92316>>>        Move False to Err   
92317>>>        Close hTable
92318>>>        Get OpenTableExclusive hTable to bOK
92319>>>        If (bOK = False) Begin
92321>>>            Function_Return False
92322>>>        End 
92322>>>>
92322>>>
92322>>>        Get_Attribute DF_FILE_DRIVER                of hTable         to sDriverIDTo
92325>>>        Get_Attribute DF_FILE_RECNUM_TABLE          of hTable         to bRecnumTable
92328>>>        Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iTypeTo iLengthTo to iDataFlexType
92329>>>        Get_Attribute DF_FIELD_NAME                 of hTable iColumn to sFieldNameTo 
92332>>>
92332>>>        If (bIsSQLTableTo = True) Begin
92334>>>            Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iTypeTo
92337>>>        End
92337>>>>
92337>>>        Else Begin
92338>>>            Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iTypeTo
92341>>>        End
92341>>>>
92341>>>
92341>>>        Get_Attribute DF_FIELD_LENGTH               of hTable iColumn to iLengthTo
92344>>>        Get_Attribute DF_FIELD_PRECISION            of hTable iColumn to iPrecTo
92347>>>            Get_Attribute DF_FIELD_IS_IDENTITY      of hTable iColumn to iOptionTo 
92350>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
92350>>>        // data types between Embedded and SQL, else we can't compare the data types.
92350>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
92352>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeFrom
92353>>>        End
92353>>>>
92353>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
92356>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeTo
92357>>>        End
92357>>>>
92357>>>        Move (iTypeFrom = iTypeTo) to bIsSameDataType
92358>>>
92358>>>        If (bCompareDate_DateTime = False) Begin
92360>>>            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkip
92361>>>            If (bSkip = True) Begin
92363>>>                If (sFieldNameFrom = sFieldNameTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
92365>>>                    Function_Return True
92366>>>                End
92366>>>>
92366>>>            End
92366>>>>
92366>>>        End
92366>>>>
92366>>>        Else If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
92369>>>            Function_Return True
92370>>>        End
92370>>>>
92370>>>
92370>>>        Set Private.phCurrentTable to hTable
92371>>>        Set Private.piCurrentField to iColumn
92372>>>       
92372>>>        Structure_Start hTable                                               
92373>>>            If (sFieldNameFrom <> sFieldNameTo) Begin
92375>>>                Set_Attribute DF_FIELD_NAME             of hTable iColumn to sFieldNameFrom
92378>>>            End
92378>>>>
92378>>>            
92378>>>            If (bIsSameDataType = False) Begin
92380>>>                Set_Attribute DF_FIELD_TYPE             of hTable iColumn to iDataFlexType
92383>>>                If (bIsSQLTableTo = True) Begin
92385>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE  of hTable iColumn to iTypeFrom
92388>>>                End
92388>>>>
92388>>>            End                                         
92388>>>>
92388>>>            
92388>>>            If (iLengthFrom <> iLengthTo) Begin
92390>>>                Set_Attribute DF_FIELD_LENGTH           of hTable iColumn to iLengthFrom
92393>>>            End
92393>>>>
92393>>>            If (iPrecFrom <> iPrecTo) Begin
92395>>>                Set_Attribute DF_FIELD_PRECISION        of hTable iColumn to iPrecFrom
92398>>>            End
92398>>>>
92398>>>
92398>>>            If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
92400>>>                // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
92400>>>                If (bRecnumTable = True) Begin
92402>>>                    Set_Attribute DF_FILE_RECNUM_TABLE  of hTable to False
92405>>>                End
92405>>>>
92405>>>
92405>>>                // We might need to create an index here.
92405>>>                // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
92405>>>                // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
92405>>>                // index update checking logic.
92405>>>                Get_Attribute DF_FIELD_INDEX               of hTable iColumn to iIndex
92408>>>                If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
92410>>>                    Create_Index hTable At iIndex
92411>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex   to 1
92414>>>                End
92414>>>>
92414>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD       of hTable iIndex 1 to iColumn
92417>>>                Set_Attribute DF_FILE_PRIMARY_INDEX        of hTable          to iIndex
92420>>>                    Set_Attribute DF_FIELD_IS_IDENTITY     of hTable iColumn  to True
92423>>>                If (bIsSQLTableTo = True) Begin
92425>>>                    Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex   to True
92428>>>                End
92428>>>>
92428>>>            End
92428>>>>
92428>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
92429>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
92431>>>
92431>>>        Set Action_Text of ghoStatusPanel to ""
92432>>>        Function_Return (Err = False)
92433>>>    End_Function
92434>>>
92434>>>    Function ApiColumnChangeMainIndex Handle hTable Integer iIndex Integer iColumn Returns Boolean
92436>>>        Boolean bOK
92436>>>
92436>>>        Get AutoConnectionIDLogin to bOK
92437>>>        Move False to Err
92438>>>        Get OpenTableExclusive hTable to bOK
92439>>>        If (bOK = False) Begin
92441>>>            Function_Return False
92442>>>        End
92442>>>>
92442>>>
92442>>>        Structure_Start hTable
92443>>>            Set_Attribute DF_FIELD_INDEX of hTable iColumn to iIndex
92446>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
92447>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
92449>>>
92449>>>        Set Action_Text of ghoStatusPanel to ""
92450>>>        Function_Return (Err = False)
92451>>>    End_Function
92452>>>
92452>>>    // To move an existing field to another position in a table.
92452>>>    Function ApiColumnMove Handle hTable Integer iOld Integer iNew Boolean bIsSQLType Returns Boolean
92454>>>        String sColumn sDriverID
92454>>>        Integer iType iSQLType iLength iPrecision iDbType
92454>>>        Boolean bOK bIsDate
92454>>>        
92454>>>        Close hTable
92455>>>        Get AutoConnectionIDLogin to bOK
92456>>>        Get OpenTableExclusive hTable to bOK
92457>>>        If (bOK = False) Begin
92459>>>            Function_Return False
92460>>>        End
92460>>>>
92460>>>        
92460>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
92463>>>        If (sDriverID = DFBTRDRV_ID) Begin
92465>>>            Error DFERR_PROGRAM "Function 'ColumnMove' is not supported for the Pervasive database."
92466>>>>
92466>>>            Function_Return False
92467>>>        End
92467>>>>
92467>>>        
92467>>>        Get_Attribute DF_FIELD_NAME of hTable iOld to sColumn
92470>>>        Get_Attribute DF_FIELD_TYPE of hTable iOld to iType
92473>>>
92473>>>        Set Private.phCurrentTable to hTable
92474>>>        Set Private.piCurrentField to iOld
92475>>>
92475>>>        Get UtilColumnIsDateType iType bIsSQLType to bIsDate
92476>>>        If (bIsDate = False) Begin
92478>>>            Get_Attribute DF_FIELD_LENGTH    of hTable iOld to iLength
92481>>>            Get_Attribute DF_FIELD_PRECISION of hTable iOld to iPrecision
92484>>>        End  
92484>>>>
92484>>>        Else Begin
92485>>>            Move 6 to iLength 
92486>>>            Move 0 to iPrecision
92487>>>        End
92487>>>>
92487>>>
92487>>>        Move False to Err
92488>>>
92488>>>        Structure_Start hTable
92489>>>            Delete_Field hTable iOld
92490>>>            Create_Field hTable At iNew
92491>>>            Set_Attribute DF_FIELD_NAME of hTable iNew to sColumn 
92494>>>            
92494>>>            If (bIsSQLType = False) Begin
92496>>>                Set_Attribute DF_FIELD_TYPE        of hTable iNew to iType
92499>>>            End 
92499>>>>
92499>>>            Else Begin
92500>>>                Set_Attribute DF_FIELD_TYPE        of hTable iNew to iType
92503>>>//                Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iNew to iSQLType  
92503>>>            End
92503>>>>
92503>>>            
92503>>>            If (bIsDate = False) Begin
92505>>>                Set_Attribute DF_FIELD_LENGTH    of hTable iNew to iLength
92508>>>                Set_Attribute DF_FIELD_PRECISION of hTable iNew to iPrecision
92511>>>            End
92511>>>>
92511>>>
92511>>>            Set_Attribute DF_FIELD_OLD_NUMBER of hTable iNew to iOld
92514>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
92515>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
92517>>>
92517>>>        Set Action_Text of ghoStatusPanel to ""
92518>>>        Function_Return (Err = False)
92519>>>    End_Function
92520>>>
92520>>>    // Deletes a column name for the passed table number (and column number).
92520>>>    Function ApiColumnRemove Handle hTable String sFieldName Returns Boolean
92522>>>        Integer iColumn
92522>>>        Boolean bOK
92522>>>
92522>>>        Get AutoConnectionIDLogin to bOK
92523>>>        Move False to Err
92524>>>        Close hTable
92525>>>        Get OpenTableExclusive hTable to bOK
92526>>>        If (bOK = False) Begin
92528>>>            Function_Return False
92529>>>        End
92529>>>>
92529>>>
92529>>>        If (not(Err)) Begin 
92531>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92532>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
92533>>>            Field_Map hTable sFieldName to iColumn
92535>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
92536>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
92537>>>            If (Err = True) Begin
92539>>>                Function_Return False
92540>>>            End
92540>>>>
92540>>>            Move False to Err
92541>>>
92541>>>            Set Private.phCurrentTable to hTable
92542>>>            Set Private.piCurrentField to iColumn
92543>>>        
92543>>>            Structure_Start hTable
92544>>>                Delete_Field hTable iColumn
92545>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
92546>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
92548>>>            Set Action_Text of ghoStatusPanel to ""
92549>>>        End
92549>>>>
92549>>>        Else Begin
92550>>>            Error DFERR_PROGRAM ("The table number:" * String(hTable) * "could not be opened exclusiv. This indicates the table is in use!")
92551>>>>
92551>>>        End
92551>>>>
92551>>>
92551>>>        Function_Return (Err = False)
92552>>>    End_Function
92553>>>
92553>>>    // Renames a field for the passed table number & old field name & new field name
92553>>>    // Returns True if no errors occured.
92553>>>    // Sample usage:
92553>>>    //   Get ColumnRename Quote.File_Number "ID#" "ID" to bOK
92553>>>    Function ApiColumnRename Integer hTable String sOldFieldName String sNewFieldName Returns Boolean
92555>>>        Integer iField
92555>>>        Boolean bOK bExists bIsOpen
92555>>>
92555>>>        Get UtilColumnExists hTable sNewFieldName to bExists
92556>>>        If (bExists = True) Begin
92558>>>            Function_Return False
92559>>>        End
92559>>>>
92559>>>        
92559>>>        // Note: The Field_Map command does _not_ work if the table has been
92559>>>        //       opened exclusively, so we first open it in normal mode.
92559>>>        Close hTable
92560>>>        Open hTable                
92562>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
92565>>>        If (bIsOpen = False) Begin
92567>>>            Function_Return False
92568>>>        End
92568>>>>
92568>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92569>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
92570>>>        Field_Map hTable sOldFieldName to iField   
92572>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
92573>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
92574>>>        
92574>>>        Get AutoConnectionIDLogin to bOK
92575>>>        Get OpenTableExclusive hTable to bOK
92576>>>        If (bOK = False) Begin
92578>>>            Function_Return False
92579>>>        End
92579>>>>
92579>>>
92579>>>        Move False to Err
92580>>>        Send Ignore_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
92581>>>        Set Private.phCurrentTable to hTable
92582>>>        Set Private.piCurrentField to iField
92583>>>
92583>>>        If (iField > 0) Begin
92585>>>            Structure_Start hTable
92586>>>                Set_Attribute DF_FIELD_NAME of hTable iField to sNewFieldName
92589>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
92590>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
92592>>>        End
92592>>>>
92592>>>        Else Begin
92593>>>            Move 0 to LastErr
92594>>>            Move False to Err
92595>>>        End
92595>>>>
92595>>>
92595>>>        Set Action_Text of ghoStatusPanel to ""
92596>>>        Send Trap_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
92597>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
92598>>>
92598>>>        Function_Return (Err = False)
92599>>>    End_Function  
92600>>>    
92600>>>    Function UtilColumnsCheckForInserts Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[] 
92602>>>        tAPIColumnCompare[] aAPIColumnsToInsert
92602>>>        tAPIColumnCompare[] aAPIColumnsToInsert
92603>>>        Integer iSize iCount iItem iFieldTo iNumberOfFieldsTo
92603>>>        Boolean bRenameField bExists
92603>>>        
92603>>>        Open hTable
92605>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92606>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
92607>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize       
92608>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumberOfFieldsTo  
92611>>>        Move (iSize min iNumberOfFieldsTo) to iSize
92612>>>        Decrement iSize
92613>>>        for iCount from 0 to iSize    
92619>>>>
92619>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
92621>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92622>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
92623>>>
92623>>>                Field_Map hTable aAPIColumnCompare[iCount].sFieldNameFrom to iFieldTo
92625>>>                If (iFieldTo = 0) Begin 
92627>>>                    Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount] to bRenameField
92628>>>                    Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to bExists
92629>>>                    If (bRenameField = False and bExists = False) Begin
92631>>>                        Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToInsert[iItem].iFieldNumber 
92632>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToInsert[iItem].sFieldNameFrom
92633>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to aAPIColumnsToInsert[iItem].iTypeFrom 
92634>>>                        Move aAPIColumnCompare[iCount].sTypeFrom        to aAPIColumnsToInsert[iItem].sTypeFrom
92635>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to aAPIColumnsToInsert[iItem].iLengthFrom
92636>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to aAPIColumnsToInsert[iItem].iPrecisionFrom
92637>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeFrom   to aAPIColumnsToInsert[iItem].bIsSQLTypeFrom
92638>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeTo     to aAPIColumnsToInsert[iItem].bIsSQLTypeTo
92639>>>                        Move True                                       to aAPIColumnsToInsert[iItem].bExistsFrom
92640>>>                        Move False                                      to aAPIColumnsToInsert[iItem].bExistsTo
92641>>>                        Increment iItem
92642>>>                    End
92642>>>>
92642>>>                End
92642>>>>
92642>>>            End
92642>>>>
92642>>>        Loop
92643>>>>
92643>>>        
92643>>>        Move False to Err
92644>>>        Move 0 to LastErr
92645>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
92646>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
92647>>>        Function_Return aAPIColumnsToInsert
92648>>>    End_Function   
92649>>>    
92649>>>    Function UtilColumnsInsert Handle hTable tAPIColumnCompare[] aAPIColumnsToInsert Returns Boolean
92651>>>        Integer iSize iCount
92651>>>        Boolean bOK                             
92651>>>        tAPIColumn[] aColumnsTo 
92651>>>        tAPIColumn[] aColumnsTo 
92652>>>        tAPIColumnCompare[] aAPIColumnCompare
92652>>>        tAPIColumnCompare[] aAPIColumnCompare
92653>>>
92653>>>        Move (SizeOfArray(aAPIColumnsToInsert)) to iSize
92654>>>        If (iSize = 0) Begin
92656>>>            Function_Return True
92657>>>        End                     
92657>>>>
92657>>>        
92657>>>        Move False to Err
92658>>>        Decrement iSize
92659>>>        for iCount from 0 to iSize
92665>>>>
92665>>>            Get ApiColumnInsert hTable aAPIColumnsToInsert[iCount].iFieldNumber aAPIColumnsToInsert[iCount].sFieldNameFrom aAPIColumnsToInsert[iCount].iTypeFrom aAPIColumnsToInsert[iCount].iLengthFrom aAPIColumnsToInsert[iCount].iPrecisionFrom aAPIColumnsToInsert[iCount].bIsSQLTypeFrom to bOK
92666>>>        Loop
92667>>>>
92667>>>        
92667>>>        Function_Return bOK
92668>>>    End_Function
92669>>>    
92669>>>    // Returns a struct array with fields that has the same names but different field numbers.
92669>>>    Function UtilColumnsCheckForMoves Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[] 
92671>>>        tAPIColumnCompare[] aAPIColumnsToMove
92671>>>        tAPIColumnCompare[] aAPIColumnsToMove
92672>>>        Integer iSize iCount iItem iFieldTo
92672>>>        
92672>>>        Open hTable
92674>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92675>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
92676>>>
92676>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize       
92677>>>        Decrement iSize
92678>>>        for iCount from 0 to iSize    
92684>>>>
92684>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
92686>>>                Field_Map hTable aAPIColumnCompare[iCount].sFieldNameFrom to iFieldTo
92688>>>                If (iFieldTo > 0) Begin
92690>>>                    Move aAPIColumnCompare[iCount].iFieldNumber to aAPIColumnsToMove[iItem].iFieldNumber 
92691>>>                    Move iFieldTo                               to aAPIColumnsToMove[iItem].iFieldNumberTo 
92692>>>                    Increment iItem
92693>>>                End
92693>>>>
92693>>>            End
92693>>>>
92693>>>        Loop
92694>>>>
92694>>>        
92694>>>        Move False to Err
92695>>>        Move 0 to LastErr
92696>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
92697>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
92698>>>        Function_Return aAPIColumnsToMove
92699>>>    End_Function   
92700>>>    
92700>>>    Function UtilColumnsMove Handle hTable tAPIColumnCompare[] aAPIColumnsToMove Returns Boolean
92702>>>        Integer iSize iCount
92702>>>        Boolean bOK                             
92702>>>        tAPIColumn[] aColumnsTo 
92702>>>        tAPIColumn[] aColumnsTo 
92703>>>        tAPIColumnCompare[] aAPIColumnCompare
92703>>>        tAPIColumnCompare[] aAPIColumnCompare
92704>>>
92704>>>        Move (SizeOfArray(aAPIColumnsToMove)) to iSize
92705>>>        If (iSize = 0) Begin
92707>>>            Function_Return True
92708>>>        End                     
92708>>>>
92708>>>        
92708>>>        Move False to Err
92709>>>        Decrement iSize
92710>>>        for iCount from 0 to iSize
92716>>>>
92716>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92717>>>            If (aAPIColumnsToMove[iCount].bExistsFrom = True and aAPIColumnsToMove[iCount].bExistsTo = True) Begin
92719>>>                Get ApiColumnMove hTable aAPIColumnsToMove[iCount].iFieldNumberTo aAPIColumnsToMove[iCount].iFieldNumber aAPIColumnsToMove[iCount].bIsSQLTypeFrom to bOK
92720>>>            End
92720>>>>
92720>>>        Loop
92721>>>>
92721>>>        
92721>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
92722>>>        Function_Return bOK
92723>>>    End_Function
92724>>>
92724>>>    // Checks if the "FROM" and "TO" database field is the same _except_ for the field name.
92724>>>    // We then assume this field should be renamed.
92724>>>//    Function UtilColumCheckRename Handle hTable tAPIColumnCompare aAPIColumnCompare Returns Boolean
92724>>>//        Boolean bDifferentFieldNames bShouldBeRenamed        
92724>>>//        
92724>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92724>>>//        Move (Uppercase(aAPIColumnCompare.sFieldNameFrom) <> Uppercase(aAPIColumnCompare.sFieldNameTo)) to bDifferentFieldNames
92724>>>//        
92724>>>//        If (bDifferentFieldNames = True) Begin
92724>>>//            Move (aAPIColumnCompare.iFieldNumber = aAPIColumnCompare.iFieldNumberTo) to bShouldBeRenamed
92724>>>//            If (bShouldBeRenamed = False) Begin
92724>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
92724>>>//                Function_Return False
92724>>>//            End
92724>>>//        
92724>>>//            Move (aAPIColumnCompare.iTypeFrom = aAPIColumnCompare.iTypeTo) to bShouldBeRenamed
92724>>>//            If (bShouldBeRenamed = False) Begin
92724>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
92724>>>//                Function_Return False
92724>>>//            End
92724>>>//        
92724>>>//            Move (aAPIColumnCompare.iLengthFrom = aAPIColumnCompare.iLengthTo) to bShouldBeRenamed
92724>>>//            If (bShouldBeRenamed = False) Begin
92724>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
92724>>>//                Function_Return False
92724>>>//            End
92724>>>//        
92724>>>//            Move (aAPIColumnCompare.iPrecisionFrom = aAPIColumnCompare.iPrecisionTo) to bShouldBeRenamed
92724>>>//            If (bShouldBeRenamed = False) Begin
92724>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
92724>>>//                Function_Return False
92724>>>//            End
92724>>>//        End
92724>>>//    
92724>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
92724>>>//        Function_Return True
92724>>>//    End_Function                   
92724>>>    
92724>>>    // Takes a tAPIColumnCompare struct as parameter and returns True if;
92724>>>    // - Field Numbers, Data Types, Lengths and Precisions are all equal.
92724>>>    // - The "FROM" field name is <> "TO" field name
92724>>>    // - The "FROM" field name also exists in the "TO" table; or the "TO" is part
92724>>>    //   of the "FROM" field name. E.g. "FROM" = LATEST_REPL_COST_DATE, "TO" = Latest_Repl_Cos would results in a TRUE.
92724>>>    Function UtilColumnShouldBeRenamed tAPIColumnCompare aAPIColumnCompare Returns Boolean
92726>>>        Boolean bExists bShouldRename
92726>>>        String sFieldNameFrom sFieldNameTo
92726>>>        
92726>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameFrom)) to sFieldNameFrom
92727>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameTo))   to sFieldNameTo  
92728>>>        If (sFieldNameFrom = sFieldNameTo) Begin
92730>>>            Function_Return False
92731>>>        End
92731>>>>
92731>>>        
92731>>>        Move (aAPIColumnCompare.bExistsFrom    = aAPIColumnCompare.bExistsTo      and ;              aAPIColumnCompare.iFieldNumber   = aAPIColumnCompare.iFieldNumberTo and ;              aAPIColumnCompare.iTypeFrom      = aAPIColumnCompare.iTypeTo        and ;              aAPIColumnCompare.iLengthFrom    = aAPIColumnCompare.iLengthTo      and ;              aAPIColumnCompare.iPrecisionFrom = aAPIColumnCompare.iPrecisionTo   and ;              aAPIColumnCompare.iOptionsFrom   = aAPIColumnCompare.iOptionsTo) to bShouldRename
92732>>>        If (bShouldRename = False) Begin
92734>>>            Function_Return False
92735>>>        End                      
92735>>>>
92735>>>        
92735>>>        If (sFieldNameFrom contains sFieldNameTo) Begin
92737>>>            Function_Return True
92738>>>        End
92738>>>>
92738>>>        
92738>>>        Function_Return bShouldRename
92739>>>    End_Function
92740>>>    
92740>>>    Function UtilColumnExistsWithOtherNumber tAPIColumnCompare[] aAPIColumnCompare Integer iColumn Returns Boolean
92742>>>        Boolean bExists
92742>>>        Integer iCount iSize
92742>>>        String sFieldNameFrom
92742>>>        
92742>>>        Move (Uppercase(aAPIColumnCompare[iColumn].sFieldNameFrom)) to sFieldNameFrom
92743>>>        
92743>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
92744>>>        Decrement iSize
92745>>>        for iCount from 0 to iSize
92751>>>>
92751>>>            // We're only interested in fields other than the passed field/column number:
92751>>>            If ((iCount +1) <> iColumn) Begin
92753>>>                If (Uppercase(aAPIColumnCompare[iCount].sFieldNameTo) = sFieldNameFrom) Begin
92755>>>                    Move True to bExists 
92756>>>                End  
92756>>>>
92756>>>                Else If (sFieldNameFrom contains Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
92759>>>                    Move True to bExists 
92760>>>                End
92760>>>>
92760>>>            End
92760>>>>
92760>>>        Loop
92761>>>>
92761>>>        
92761>>>        Function_Return bExists 
92762>>>    End_Function
92763>>>    
92763>>>    Function UtilColumnsCheckForRenames Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[] 
92765>>>        tAPIColumnCompare[] aAPIColumnsToRename
92765>>>        tAPIColumnCompare[] aAPIColumnsToRename
92766>>>        Integer iSize iCount iItem iFieldTo iNumberOfFieldsTo
92766>>>        Boolean bRenameField
92766>>>        
92766>>>        Open hTable
92768>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumberOfFieldsTo
92771>>>        Move 0 to iItem
92772>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize                    
92773>>>        Move (iSize min iNumberOfFieldsTo)    to iSize
92774>>>        Decrement iSize
92775>>>        for iCount from 0 to iSize    
92781>>>>
92781>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
92783>>>                Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount] to bRenameField
92784>>>                If (bRenameField = True) Begin
92786>>>                    Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToRename[iItem].iFieldNumber 
92787>>>                    Move iFieldTo                                   to aAPIColumnsToRename[iItem].iFieldNumberTo 
92788>>>                    Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToRename[iItem].sFieldNameFrom
92789>>>                    Move aAPIColumnCompare[iCount].sFieldNameTo     to aAPIColumnsToRename[iItem].sFieldNameTo
92790>>>                    Increment iItem
92791>>>                End
92791>>>>
92791>>>            End
92791>>>>
92791>>>        Loop
92792>>>>
92792>>>        
92792>>>        Move False to Err
92793>>>        Move 0 to LastErr
92794>>>        Function_Return aAPIColumnsToRename
92795>>>    End_Function   
92796>>>    
92796>>>    Function UtilColumnsRename Handle hTable tAPIColumnCompare[] aAPIColumnsToRename Returns Boolean
92798>>>        Integer iSize iCount
92798>>>        Boolean bOK                             
92798>>>        tAPIColumn[] aColumnsTo 
92798>>>        tAPIColumn[] aColumnsTo 
92799>>>        tAPIColumnCompare[] aAPIColumnCompare
92799>>>        tAPIColumnCompare[] aAPIColumnCompare
92800>>>
92800>>>        Move (SizeOfArray(aAPIColumnsToRename)) to iSize
92801>>>        If (iSize = 0) Begin
92803>>>            Function_Return True
92804>>>        End                     
92804>>>>
92804>>>        
92804>>>        Move False to Err
92805>>>        Decrement iSize
92806>>>        For iCount from 0 to iSize
92812>>>>
92812>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92813>>>            Get ApiColumnRename hTable aAPIColumnsToRename[iCount].sFieldNameTo aAPIColumnsToRename[iCount].sFieldNameFrom to bOK 
92814>>>        Loop
92815>>>>
92815>>>        
92815>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
92816>>>        Function_Return bOK
92817>>>    End_Function
92818>>>
92818>>>    Function UtilColumnIsDateType Integer iType Boolean bIsSQLTableTo Returns Boolean
92820>>>        Boolean bDateType
92820>>>        
92820>>>        If (bIsSQLTableTo = True) Begin
92822>>>            Move (iType = SQL_TYPE_DATE or iType = SQL_TYPE_TIMESTAMP or iType = SQL_TYPE_TIMESTAMP2) to bDateType
92823>>>        End 
92823>>>>
92823>>>        Else Begin
92824>>>            Move (iType = DF_DATE or iType = DF_DATETIME) to bDateType
92825>>>        End
92825>>>>
92825>>>    
92825>>>        Function_Return bDateType
92826>>>    End_Function
92827>>>    
92827>>>    Function ApiColumnsUpdate String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo Boolean bCompareDate_DateTime Returns Boolean
92829>>>        Integer iCount iSize iColumn iTypeFrom iTypeTo iDataFlexType iIndex iLengthFrom iLengthTo iPrecisionFrom iPrecisionTo iOptionFrom iOptionTo iDbType
92829>>>        Handle hFile
92829>>>        Boolean bFieldExistsFrom bFieldExistsTo bShouldMove bIsSQLDriver bIsSame bOK bSkip
92829>>>        Boolean bRecnum bIsSQLTableTo bOpened bRecnumTable bIsOpen bSkipTypeChange bIsDateType
92829>>>        String sFieldNameFrom sFieldNameTo sDriverIDTo sDefaultValue
92829>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns
92829>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns
92833>>>        tColumnType ColumnType
92833>>>        tColumnType ColumnType
92833>>>
92833>>>        Move False to Err
92834>>>        Close hTable
92835>>>        Get OpenTableExclusive hTable to bIsOpen
92836>>>        If (bIsOpen = False) Begin
92838>>>            Error DFERR_PROGRAM ("Function 'ApiColumnsUpdate'. Can't open table number:" * String(hTable))
92839>>>>
92839>>>            Function_Return False
92840>>>        End
92840>>>>
92840>>>
92840>>>        Get piDbType to iDbType
92841>>>        Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
92844>>>        Get IsSQLDriver sDriverIDFrom to bIsSQLDriver
92845>>>        Get UtilTableIsSQL hTable     to bIsSQLTableTo
92846>>>        If (bIsSQLTableTo = False) Begin
92848>>>            Move DATAFLEX_ID to sDriverIDTo
92849>>>        End
92849>>>>
92849>>>        Else Begin          
92850>>>            Get_Attribute DF_FILE_DRIVER of hTable to sDriverIDTo
92853>>>        End
92853>>>>
92853>>>        
92853>>>        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
92854>>>        
92854>>>        // Before we start to change the table we need to do three things;
92854>>>        // 1) Insert any new fields
92854>>>        Get UtilColumnsCheckForInserts hTable aAPIColumnCompare to aApiInsertColumns
92855>>>        If (SizeOfArray(aApiInsertColumns)) Begin
92857>>>            Get UtilColumnsInsert hTable aApiInsertColumns to bOK
92858>>>            If (bOK = False) Begin
92860>>>                Function_Return False
92861>>>            End                  
92861>>>>
92861>>>            // Update info with changes made.
92861>>>            Get UtilColumnsStructFill hTable to aColumnsTo
92862>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
92863>>>        End
92863>>>>
92863>>>        
92863>>>        // 2) Rename fields
92863>>>        Get UtilColumnsCheckForRenames hTable aAPIColumnCompare to aAPIRenameColumns
92864>>>        If (SizeOfArray(aAPIRenameColumns)) Begin
92866>>>            Get UtilColumnsRename hTable aAPIRenameColumns to bOK
92867>>>            If (bOK = False) Begin
92869>>>                Function_Return False
92870>>>            End
92870>>>>
92870>>>            Get UtilColumnsStructFill hTable to aColumnsTo
92871>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
92872>>>        End
92872>>>>
92872>>>
92872>>>        // 3) Move fields with same names
92872>>>        Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIMoveColumns
92873>>>        If (SizeOfArray(aAPIMoveColumns)) Begin
92875>>>            Get UtilColumnsMove hTable aAPIMoveColumns to bOK
92876>>>            If (bOK = False) Begin
92878>>>                Function_Return False
92879>>>            End
92879>>>>
92879>>>            Get UtilColumnsStructFill hTable to aColumnsTo
92880>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
92881>>>        End
92881>>>>
92881>>>        
92881>>>        // If any of the fields were changed by "Insert", "Rename" or "Move", we need to compare the fields again: 
92881>>>        If (SizeOfArray(aApiInsertColumns) or SizeOfArray(aAPIRenameColumns) or SizeOfArray(aAPIMoveColumns)) Begin
92883>>>            Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
92884>>>            If (bIsSame = True) Begin
92886>>>                Function_Return True
92887>>>            End
92887>>>>
92887>>>        End
92887>>>>
92887>>>        
92887>>>        // We can now continue to make standard field changes:
92887>>>        Get OpenTableExclusive hTable to bIsOpen
92888>>>        Set Private.phCurrentTable to hTable
92889>>>        Move hTable to hFile
92890>>>        Structure_Start hFile sDriverIDTo
92891>>>
92891>>>            Move (SizeOfArray(aAPIColumnCompare)) to iSize
92892>>>            Decrement iSize
92893>>>            For iCount from 0 to iSize
92899>>>>
92899>>>                Send DoAdvance of ghoProgressBar
92900>>>                                
92900>>>                Move aAPIColumnCompare[iCount].bExistsFrom          to bFieldExistsFrom
92901>>>                If (bFieldExistsFrom = True) Begin
92903>>>                    Move aAPIColumnCompare[iCount].bExistsTo        to bFieldExistsTo
92904>>>                    Move aAPIColumnCompare[iCount].sFieldNameFrom   to sFieldNameFrom
92905>>>                    Move aAPIColumnCompare[iCount].iFieldNumber     to iColumn              
92906>>>                    Set Private.piCurrentField                      to iColumn
92907>>>                    Move aAPIColumnCompare[iCount].iLengthFrom      to iLengthFrom                                   
92908>>>                    Move aAPIColumnCompare[iCount].iPrecisionFrom   to iPrecisionFrom
92909>>>                    Move aAPIColumnCompare[iCount].iOptionsFrom     to iOptionFrom
92910>>>                    
92910>>>                    Move aAPIColumnCompare[iCount].iTypeFrom        to iTypeFrom
92911>>>//                    Get UtilDFDataTypeToSqlTypeMapping sDriverIDFrom iDbType iTypeFrom to ColumnType
92911>>>//                    Move ColumnType.iDataFlexType                   to iDataFlexType
92911>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iDataFlexType
92912>>>                    If (iTypeFrom < -1490) Begin
92914>>>                        Move (iTypeFrom + 1500)                     to iTypeFrom
92915>>>                    End
92915>>>>
92915>>>    
92915>>>                    // If one of the two tables are SQL and the other Embedded we need to "translate"
92915>>>                    // data types between Embedded and SQL, else we can't compare the data types.
92915>>>                    If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
92917>>>                        Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeFrom
92918>>>                    End
92918>>>>
92918>>>                    Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
92921>>>                        Get UtilSqlColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeTo
92922>>>                    End
92922>>>>
92922>>>                    
92922>>>                    Move aAPIColumnCompare[iCount].sFieldNameTo to sFieldNameTo
92923>>>                    Move aAPIColumnCompare[iCount].iLengthTo    to iLengthTo
92924>>>                    Move aAPIColumnCompare[iCount].iPrecisionTo to iPrecisionTo
92925>>>                    Move aAPIColumnCompare[iCount].iOptionsTo   to iOptionTo
92926>>>                    Move aAPIColumnCompare[iCount].iTypeTo      to iTypeTo
92927>>>                    
92927>>>                    Move False to bSkipTypeChange
92928>>>                    If (bCompareDate_DateTime = False) Begin
92930>>>                        Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkipTypeChange
92931>>>                    End
92931>>>>
92931>>>                    
92931>>>                    If (bFieldExistsTo = False) Begin 
92933>>>                        Move 0 to iColumn
92934>>>                        Create_Field hFile At iColumn
92935>>>                        Set Private.piCurrentField to iColumn
92936>>>                    End
92936>>>>
92936>>>                    
92936>>>                    If (sFieldNameFrom <> sFieldNameTo) Begin
92938>>>                        Set_Attribute DF_FIELD_NAME of hFile iColumn to sFieldNameFrom
92941>>>                    End                   
92941>>>>
92941>>>                    
92941>>>                    If (bIsSQLTableFrom = True and aAPIColumnCompare[iCount].iOptionsFrom <> C_tAPIColumn_Identity) Begin
92943>>>                        Set_Attribute DF_FIELD_NULL_ALLOWED  of hFile iColumn to aAPIColumnCompare[iCount].bAllowNULLFrom
92946>>>                        Move aAPIColumnCompare[iCount].sDefaultValueFrom to sDefaultValue
92947>>>                        If (iDataFlexType = DF_BCD and Left(sDefaultValue, 1 <> "[")) Begin
92949>>>                            Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
92950>>>                        End
92950>>>>
92950>>>                        Set_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefaultValue
92953>>>                    End
92953>>>>
92953>>>                    
92953>>>                    If (bSkipTypeChange = False) Begin
92955>>>                        If (iTypeFrom <> iTypeTo) Begin 
92957>>>                            If (bIsSQLTableTo = True) Begin
92959>>>                                Set_Attribute DF_FIELD_NATIVE_TYPE   of hFile iColumn to iTypeFrom
92962>>>                            End
92962>>>>
92962>>>                            Else Begin
92963>>>                                Set_Attribute DF_FIELD_TYPE          of hFile iColumn to iDataFlexType
92966>>>                            End
92966>>>>
92966>>>                        End
92966>>>>
92966>>>                    End
92966>>>>
92966>>>                    
92966>>>                    Get UtilColumnIsDateType iTypeFrom bIsSQLTableTo to bIsDateType   
92967>>>                    // We can't set the length or precision for Date type columns (they are fixed).
92967>>>                    If (bIsDateType = False) Begin
92969>>>                        If (iLengthFrom <> iLengthTo) Begin
92971>>>                            Set_Attribute DF_FIELD_LENGTH of hFile iColumn to iLengthFrom
92974>>>                        End
92974>>>>
92974>>>                        If (iPrecisionFrom <> iPrecisionTo) Begin
92976>>>                            Set_Attribute DF_FIELD_PRECISION of hFile iColumn to iPrecisionFrom
92979>>>                        End
92979>>>>
92979>>>                    End
92979>>>>
92979>>>    
92979>>>                    If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
92981>>>                        // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
92981>>>                        If (bRecnumTable = True) Begin
92983>>>                            Set_Attribute DF_FILE_RECNUM_TABLE of hTable to False
92986>>>                        End
92986>>>>
92986>>>    
92986>>>                        // We might need to create an index here.
92986>>>                        // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
92986>>>                        // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
92986>>>                        // index update checking logic.
92986>>>                        Get_Attribute DF_FIELD_INDEX           of hFile iColumn to iIndex
92989>>>                        If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
92991>>>                            Create_Index hFile at iIndex
92992>>>                            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hFile iIndex to 1
92995>>>                        End
92995>>>>
92995>>>
92995>>>                        Set_Attribute DF_INDEX_SEGMENT_FIELD   of hFile iIndex 1 to iColumn
92998>>>                        Set_Attribute DF_FILE_PRIMARY_INDEX    of hFile          to iIndex
93001>>>                            // Note: The order of these two are crucial!
93001>>>                            Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hFile iIndex to True
93004>>>                            Set_Attribute DF_FIELD_IS_IDENTITY of hFile iColumn    to True
93007>>>                    End
93007>>>>
93007>>>                End
93007>>>>
93007>>>            Loop 
93008>>>>
93008>>>        
93008>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
93009>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
93011>>>
93011>>>        Set Action_Text of ghoStatusPanel to ""
93012>>>        Function_Return (Err = False)
93013>>>    End_Function
93014>>>
93014>>>    // * Dummy function for the Studio's Code Explorer *
93014>>>    Function API_INDEX_FUNCTIONS Returns Boolean
93016>>>        Function_Return False
93017>>>    End_Function
93018>>>
93018>>>    // Get ApiIndexCreate Customers.File_Number 1 2 0 1 -1 -1 -1 -1 -1 -1 -1 -1 to bOK
93018>>>    // Note: the "-1" can be left out as this function is overloaded to make it easier to call.
93018>>>    // Note: This doesn't set Descending attributes - Use function IndexChangeDirection to do that.
93018>>>    Function ApiIndexCreate Handle hTable Integer iIndex Integer iSegments Integer iSgmnt1 Integer iSgmnt2 Integer iSgmnt3 Integer iSgmnt4 Integer iSgmnt5 Integer iSgmnt6 Integer iSgmnt7 Integer iSgmnt8 Integer iSgmnt9 Integer iSgmnt10 Returns Boolean
93020>>>        Integer iTableNo iSegment1 iSegment2 iSegment3 iSegment4 iSegment5 iSegment6 iSegment7 iSegment8 iSegment9 iSegment10
93020>>>        String sDriverID
93020>>>        Boolean bOK
93020>>>
93020>>>        Get AutoConnectionIDLogin to bOK
93021>>>        Move -1 to iSegment1
93022>>>        Move -1 to iSegment2
93023>>>        Move -1 to iSegment3
93024>>>        Move -1 to iSegment4
93025>>>        Move -1 to iSegment5
93026>>>        Move -1 to iSegment6
93027>>>        Move -1 to iSegment7
93028>>>        Move -1 to iSegment8
93029>>>        Move -1 to iSegment9
93030>>>        Move -1 to iSegment10
93031>>>
93031>>>        If (num_arguments > 3) Begin
93033>>>            Move iSgmnt1 to iSegment1
93034>>>        End
93034>>>>
93034>>>        If (num_arguments > 4) Begin
93036>>>            Move iSgmnt2 to iSegment2
93037>>>        End
93037>>>>
93037>>>        If (num_arguments > 5) Begin
93039>>>            Move iSgmnt3 to iSegment3
93040>>>        End
93040>>>>
93040>>>        If (num_arguments > 6) Begin
93042>>>            Move iSgmnt4 to iSegment4
93043>>>        End
93043>>>>
93043>>>        If (num_arguments > 7) Begin
93045>>>            Move iSgmnt5 to iSegment5
93046>>>        End
93046>>>>
93046>>>        If (num_arguments > 8) Begin
93048>>>            Move iSgmnt6 to iSegment6
93049>>>        End
93049>>>>
93049>>>        If (num_arguments > 9) Begin
93051>>>            Move iSgmnt7 to iSegment7
93052>>>        End
93052>>>>
93052>>>        If (num_arguments > 10) Begin
93054>>>            Move iSgmnt8 to iSegment8
93055>>>        End
93055>>>>
93055>>>        If (num_arguments > 11) Begin
93057>>>            Move iSgmnt9 to iSegment9
93058>>>        End
93058>>>>
93058>>>        If (num_arguments > 12) Begin
93060>>>            Move iSgmnt10 to iSegment10
93061>>>        End
93061>>>>
93061>>>
93061>>>        Move False to Err
93062>>>        Move hTable to iTableNo
93063>>>        Get OpenTableExclusive hTable to bOK
93064>>>        If (bOK = False) Begin
93066>>>            Function_Return False
93067>>>        End
93067>>>>
93067>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
93070>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
93071>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
93072>>>        Send Ignore_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
93073>>>
93073>>>        // We start by deleting the index
93073>>>        Structure_Start hTable sDriverID
93074>>>            Delete_Index iTableNo iIndex
93075>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
93076>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
93078>>>
93078>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
93079>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
93080>>>        Send Trap_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
93081>>>        Set Action_Text of ghoStatusPanel to ""
93082>>>        Move False to Err 
93083>>>        Move 0 to LastErr
93084>>>        Move iTableNo to hTable
93085>>>        Get OpenTableExclusive hTable to bOK
93086>>>        If (bOK = False) Begin
93088>>>            Function_Return False
93089>>>        End
93089>>>>
93089>>>
93089>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
93090>>>        Structure_Start hTable sDriverID
93091>>>            Create_Index hTable At iIndex
93092>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iSegments
93095>>>
93095>>>            If (iSgmnt1 <> -1) Begin
93097>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 1 to iSegment1
93100>>>            End
93100>>>>
93100>>>            If (iSegment2 <> -1) Begin
93102>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 2 to iSegment2
93105>>>            End
93105>>>>
93105>>>            If (iSegment3 <> -1) Begin
93107>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 3 to iSegment3
93110>>>            End
93110>>>>
93110>>>            If (iSegment4 <> -1) Begin
93112>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 4 to iSegment4
93115>>>            End
93115>>>>
93115>>>            If (iSegment5 <> -1) Begin
93117>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 5 to iSegment5
93120>>>            End
93120>>>>
93120>>>            If (iSegment6 <> -1) Begin
93122>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 6 to iSegment6
93125>>>            End
93125>>>>
93125>>>            If (iSegment7 <> -1) Begin
93127>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 7 to iSegment7
93130>>>            End
93130>>>>
93130>>>            If (iSegment8 <> -1) Begin
93132>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 8 to iSegment8
93135>>>            End
93135>>>>
93135>>>            If (iSegment9 <> -1) Begin
93137>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 9 to iSegment9
93140>>>            End
93140>>>>
93140>>>            If (iSegment10 <> -1) Begin
93142>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 10 to iSegment10
93145>>>            End
93145>>>>
93145>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
93146>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
93148>>>
93148>>>        Set Action_Text of ghoStatusPanel to ""
93149>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
93150>>>
93150>>>        Function_Return (Err = False)
93151>>>    End_Function
93152>>>
93152>>>    Function APIIndexCreateByFieldNames Handle hTable tAPIIndex APIIndex tAPIIndex[] APIIndexTo tAPIIndexSegment[] aIndexSegments Returns Boolean
93154>>>        String[] aFields
93155>>>        Integer iCount iSegmentsFrom iFieldFrom iFieldTo iSegmentsTo iSQLIndexType iLastIndex iTableNo iSQLIndexTo
93155>>>        String sDriverID sSQLIndexName sTableName
93155>>>        Boolean bOK bIsSQLTable bIsOpen bIsSQLPrimaryKey bIsSQLClustered bIsSQLTemporaryIndex bExists
93155>>>
93155>>>        Move (SizeOfArray(aIndexSegments)) to iSegmentsFrom
93156>>>        If (iSegmentsFrom = 0) Begin
93158>>>            Function_Return False
93159>>>        End
93159>>>>
93159>>>
93159>>>        Get AutoConnectionIDLogin to bOK
93160>>>        Move False to Err
93161>>>        Get OpenTableExclusive hTable to bIsOpen
93162>>>        If (bIsOpen = False) Begin
93164>>>            Function_Return False
93165>>>        End
93165>>>>
93165>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
93168>>>        Get UtilTableIsSql hTable to bIsSQLTable   
93169>>>        
93169>>>        Move 0     to iSegmentsTo    
93170>>>        Move 0     to iSQLIndexType 
93171>>>        Move ""    to sSQLIndexName
93172>>>        Move False to bIsSQLTemporaryIndex 
93173>>>        Move False to bIsSQLPrimaryKey
93174>>>        Move False to bIsSQLClustered
93175>>>        
93175>>>//        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable                               to iLastIndex
93175>>>//        If (APIIndex.iIndexNumber <= iLastIndex) Begin
93175>>>//            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber      to iSegmentsTo
93175>>>//            If (bIsSQLTable = True) Begin
93175>>>//                Get_Attribute DF_INDEX_NAME of hTable APIIndex.iIndexNumber             to sSQLIndexName
93175>>>//                #IF (Required_RT_Version > 17)                                    
93175>>>//                Get_Attribute DF_INDEX_SQL_TYPE of hTable APIIndex.iIndexNumber         to iSQLIndexType
93175>>>//                Move (iSQLIndexType = DF_INDEX_TEMPORARY)                               to bIsSQLTemporaryIndex
93175>>>//                Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber  to bIsSQLPrimaryKey
93175>>>//                Get_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber  to bIsSQLClustered
93175>>>//                #ENDIF
93175>>>//            End
93175>>>//        End
93175>>>        
93175>>>        Move hTable to iTableNo 
93176>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber to bExists
93179>>>        If (bExists = True) Begin
93181>>>            Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber to bIsSQLPrimaryKey
93184>>>            If (bIsSQLPrimaryKey = False) Begin
93186>>>                // We start by deleting the index, if it exists
93186>>>                Structure_Start iTableNo sDriverID
93187>>>                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
93188>>>                    Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
93189>>>                    Delete_Index iTableNo APIIndex.iIndexNumber
93190>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
93191>>>                    Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
93192>>>                    Set Action_Text of ghoStatusPanel to "Restructures table..."
93193>>>                Structure_End iTableNo DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
93195>>>                Set Action_Text of ghoStatusPanel to ""
93196>>>                
93196>>>                Get OpenTableExclusive hTable to bOK
93197>>>                If (bOK = False) Begin
93199>>>                    Function_Return False
93200>>>                End
93200>>>>
93200>>>            End
93200>>>>
93200>>>        End
93200>>>>
93200>>>        
93200>>>        Move hTable to iTableNo
93201>>>        Move False to Err
93202>>>        Move 0 to LastErr 
93203>>>
93203>>>        // Note: If the SQL index type = DF_INDEX_TEMPORARY, we _must_ set the DF_INDEX_SQL_TYPE 
93203>>>        //       _outside_ the Structure_Start/End construct.
93203>>>//        Move False to bIsSQLTemporaryIndex
93203>>>//        #IF (Required_RT_Version > 17)                                    
93203>>>//            If (bIsSQLTemporaryIndex = True and APIIndex.iIndexNumber <= iLastIndex) Begin
93203>>>//                If (APIIndex.iSQLIndexType <> iSQLIndexType) Begin
93203>>>//                    Set_Attribute DF_INDEX_SQL_TYPE of hTable APIIndex.iIndexNumber to APIIndex.iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
93203>>>//                End
93203>>>//            End
93203>>>//        #ENDIF
93203>>>        
93203>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
93204>>>        Structure_Start hTable sDriverID
93205>>>            If (bIsSQLPrimaryKey = False) Begin
93207>>>                Create_Index hTable At APIIndex.iIndexNumber
93208>>>            End
93208>>>>
93208>>>
93208>>>//            If (bIsSQLTable = True) Begin                                                         
93208>>>//                // In case the SQL Index name already exists for another index number; we temporarily rename that index name;
93208>>>//                Get UtilIndexSQLIndexNameExists iTableNo APIIndex.iIndexNumber APIIndex.sSQLIndexName APIIndexTo to iSQLIndexTo
93208>>>//                If (iSQLIndexTo > 0) Begin   
93208>>>//                    Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
93208>>>//                    Set_Attribute DF_INDEX_NAME of hTable iSQLIndexTo to (sTableName + String("001") + String(iSQLIndexTo))
93208>>>//                End
93208>>>//                Set_Attribute DF_INDEX_NAME of hTable APIIndex.iIndexNumber to APIIndex.sSQLIndexName
93208>>>//            End
93208>>>            
93208>>>            If (bIsSQLTable = True) Begin // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
93210>>>                Set_Attribute DF_INDEX_SQL_TYPE        of hTable APIIndex.iIndexNumber to APIIndex.iSQLIndexType 
93213>>>                Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLPrimaryKey
93216>>>                Set_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLClustered
93219>>>            End
93219>>>>
93219>>>                
93219>>>                If (iSegmentsFrom <> iSegmentsTo) Begin
93221>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber to iSegmentsFrom
93224>>>            End
93224>>>>
93224>>>            
93224>>>            for iCount from 0 to (iSegmentsFrom -1)
93230>>>>
93230>>>                Move aIndexSegments[iCount].iFieldNumber to iFieldFrom   
93231>>>                If (iFieldFrom <> -1 ) Begin
93233>>>                        Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable APIIndex.iIndexNumber (iCount +1) to iFieldFrom
93236>>>                End
93236>>>>
93236>>>            Loop                         
93237>>>>
93237>>>                
93237>>>            // If more segments existed; remove them
93237>>>//            If (iSegmentsTo > iSegmentsFrom) Begin
93237>>>//                for iCount from iSegmentsFrom to iSegmentsTo
93237>>>//                          Get ApiIndexDeleteSegment hTable APIIndex.iIndexNumber iCount to bOK
93237>>>//                Loop
93237>>>//                  Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber to iSegmentsFrom
93237>>>//            End
93237>>>                
93237>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
93238>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
93240>>>
93240>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
93241>>>        Set Action_Text of ghoStatusPanel to ""
93242>>>        
93242>>>        Function_Return (Err = False)
93243>>>    End_Function 
93244>>>    
93244>>>    // Checks if an SQL Index name for the "FROM" database already exists in the TO database,
93244>>>    // but with another Index number. We can then not rename the SQL index name for the TO database table.
93244>>>    Function UtilIndexSQLIndexNameExists Handle hTable Integer iIndexNumberFrom String sSQLIndexNameFrom tAPIIndex[] APIIndexTo Returns Integer
93246>>>        Integer iSize iCount iIndexNumberTo
93246>>>        String sSQLIndexNameTo
93246>>>        Integer iRetVal
93246>>>        
93246>>>        Move 0 to iRetVal     
93247>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndexNumberFrom to iRetVal
93250>>>        If (iRetVal = 0) Begin
93252>>>            Function_Return 0
93253>>>        End
93253>>>>
93253>>>        Move (SizeOfArray(APIIndexTo)) to iSize
93254>>>        Decrement iSize
93255>>>        for iCount from 0 to iSize
93261>>>>
93261>>>            If (Uppercase(sSQLIndexNameFrom) = Uppercase(APIIndexTo[iCount].sSQLIndexName)) Begin
93263>>>                If (iIndexNumberFrom <> APIIndexTo[iCount].iIndexNumber) Begin
93265>>>                    Move APIIndexTo[iCount].iIndexNumber to iRetVal
93266>>>                End
93266>>>>
93266>>>            End
93266>>>>
93266>>>        Loop
93267>>>>
93267>>>        
93267>>>        Function_Return iRetVal
93268>>>    End_Function   
93269>>>    
93269>>>    Function ApiIndexDeleteSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
93271>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
93271>>>    
93271>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
93274>>>        If (iSegment = iNumSegments) Begin
93276>>>//            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
93276>>>        End
93276>>>>
93276>>>    
93276>>>        Else If (iSegment > 0 and iSegment < iNumSegments) Begin
93279>>>            for iCurSegment from iSegment to (iNumSegments - 1)
93285>>>>
93285>>>                //*** Move index segment attributes
93285>>>                Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
93288>>>                Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
93291>>>                Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
93294>>>    
93294>>>                Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment to iSegmentCase
93297>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment to iSegmentDirection
93300>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment to iSegmentColumn
93303>>>            Loop
93304>>>>
93304>>>    
93304>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
93307>>>        End
93307>>>>
93307>>>    
93307>>>    End_Procedure
93308>>>
93308>>>    Function APIIndexRemoveAllIndexes Handle hTable tAPIIndex[] APIIndex Returns Boolean
93310>>>        String[] aFields
93311>>>        Integer iCount iSize iIndex 
93311>>>        String sDriverID
93311>>>        Boolean bOK bIsSQLTable bIsOpen bIsSQLPrimaryKey
93311>>>
93311>>>        Move (SizeOfArray(APIIndex)) to iSize
93312>>>        If (iSize = 0) Begin
93314>>>            Function_Return True
93315>>>        End
93315>>>>
93315>>>
93315>>>        Get AutoConnectionIDLogin to bOK
93316>>>        Move False to Err
93317>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
93320>>>        If (bIsOpen = False) Begin
93322>>>            Get OpenTableExclusive hTable to bIsOpen
93323>>>            If (bIsOpen = False) Begin
93325>>>                Function_Return False
93326>>>            End
93326>>>>
93326>>>        End    
93326>>>>
93326>>>        
93326>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
93329>>>        Get UtilTableIsSql hTable to bIsSQLTable
93330>>>
93330>>>        Move False to Err
93331>>>        Move 0 to LastErr             
93332>>>        Decrement iSize
93333>>>
93333>>>        Structure_Start hTable sDriverID
93334>>>            for iCount from 0 to iSize
93340>>>>
93340>>>//                Move False to bIsSQLPrimaryKey
93340>>>//                #IF ((Required_RT_Version * 10 + Required_RT_Revision) > 180)   // DF 18.1 and up
93340>>>//                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
93340>>>//                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex[iCount].iIndexNumber to bIsSQLPrimaryKey
93340>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
93340>>>//                #ENDIF
93340>>>                // We can't delete if this is a primary key index:
93340>>>//                If (bIsSQLPrimaryKey = False) Begin
93340>>>                    Move APIIndex[iCount].iIndexNumber to iIndex
93341>>>                    Delete_Index hTable iIndex
93342>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
93342>>>//                End
93342>>>            Loop
93343>>>>
93343>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
93344>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
93346>>>//        Move False to Err
93346>>>        Move 0 to LastErr
93347>>>
93347>>>        Set Action_Text of ghoStatusPanel to ""
93348>>>        Function_Return (Err = False)
93349>>>    End_Function
93350>>>
93350>>>    Function ApiIndexChangeDirection Handle hTable Integer iIndex Integer iSegment Integer iDirection Returns Boolean
93352>>>        Boolean bOK
93352>>>
93352>>>        Get AutoConnectionIDLogin to bOK
93353>>>        Move False to Err
93354>>>        Get OpenTableExclusive hTable to bOK
93355>>>        If (bOK = False) Begin
93357>>>            Function_Return False
93358>>>        End
93358>>>>
93358>>>        Structure_Start hTable
93359>>>            Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to iDirection
93362>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
93363>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
93365>>>
93365>>>        Set Action_Text of ghoStatusPanel to ""
93366>>>        Function_Return (Err = False)
93367>>>    End_Function
93368>>>
93368>>>    Function ApiIndexChangeUppercase Handle hTable Integer iIndex Integer iSegment Boolean bUppercase Returns Boolean
93370>>>        Integer iCase
93370>>>        Boolean bOK
93370>>>
93370>>>        If (bUppercase = True) Begin
93372>>>            Move DF_CASE_IGNORED to iCase
93373>>>        End
93373>>>>
93373>>>        Else Begin
93374>>>            Move DF_CASE_USED to iCase
93375>>>        End
93375>>>>
93375>>>
93375>>>        Get AutoConnectionIDLogin to bOK
93376>>>        Move False to Err
93377>>>        Get OpenTableExclusive hTable to bOK
93378>>>        If (bOK = False) Begin
93380>>>            Function_Return False
93381>>>        End
93381>>>>
93381>>>        Structure_Start hTable
93382>>>            Set_Attribute DF_INDEX_SEGMENT_CASE of hTable iIndex iSegment to iCase
93385>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
93386>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
93388>>>
93388>>>        Set Action_Text of ghoStatusPanel to ""
93389>>>        Function_Return (Err = False)
93390>>>    End_Function
93391>>>
93391>>>    // To delete an index
93391>>>    Function ApiIndexRemove Handle hTable Integer iIndex Returns Boolean
93393>>>        Integer iTableNo iNumSegments
93393>>>        String sDriverID
93393>>>        Boolean bOK
93393>>>
93393>>>        Get AutoConnectionIDLogin to bOK
93394>>>        Move False to Err
93395>>>        Move hTable to iTableNo
93396>>>        Get OpenTableExclusive hTable to bOK
93397>>>        If (bOK = False) Begin
93399>>>            Function_Return False
93400>>>        End
93400>>>>
93400>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
93403>>>
93403>>>        // Check to see if the index exists or not...
93403>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
93406>>>        If (iNumSegments = 0) Begin
93408>>>            Function_Return False
93409>>>        End
93409>>>>
93409>>>
93409>>>        Structure_Start hTable sDriverID
93410>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
93411>>>            Delete_Index iTableNo iIndex
93412>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
93413>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
93414>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
93416>>>
93416>>>        Set Action_Text of ghoStatusPanel to ""
93417>>>        Function_Return (Err = False)
93418>>>    End_Function
93419>>>
93419>>>    // Delete an Index Segment
93419>>>    Function ApiIndexRemoveSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
93421>>>        Boolean bOK bSQLDriver bIndexTemporary
93421>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
93421>>>        Integer iIndexType
93421>>>        String sDriverID
93421>>>
93421>>>        Get AutoConnectionIDLogin to bOK
93422>>>        Move False to Err
93423>>>
93423>>>        Get OpenTableExclusive hTable to bOK
93424>>>        If (bOK = False) Begin
93426>>>            Function_Return False
93427>>>        End
93427>>>>
93427>>>
93427>>>        // Check to see if the index exists or not...
93427>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
93430>>>        If (iNumSegments = 0) Begin
93432>>>            Function_Return False
93433>>>        End
93433>>>>
93433>>>
93433>>>        Move False to bIndexTemporary
93434>>>        Get psDriverID to sDriverID
93435>>>        Get IsSQLDriver sDriverID to bSQLDriver
93436>>>        If (bSQLDriver) Begin
93438>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
93441>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
93444>>>                Move True to bIndexTemporary
93445>>>        End
93445>>>>
93445>>>
93445>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
93445>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
93447>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
93450>>>            If (iSegment = iNumSegments) Begin
93452>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
93455>>>            End
93455>>>>
93455>>>            Else If (iSegment > 0 and iSegment < iNumSegments) Begin
93458>>>                For iCurSegment from iSegment to (iNumSegments - 1)
93464>>>>
93464>>>                    //*** Move index segment attributes
93464>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
93467>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
93470>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
93473>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
93476>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
93479>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
93482>>>                Loop
93483>>>>
93483>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
93486>>>            End
93486>>>>
93486>>>        End
93486>>>>
93486>>>
93486>>>        Else Begin
93487>>>           Structure_Start hTable
93488>>>               Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
93491>>>               If (iSegment = iNumSegments) Begin
93493>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
93496>>>               End
93496>>>>
93496>>>               Else If (iSegment > 0 and iSegment < iNumSegments) Begin
93499>>>                   for iCurSegment from iSegment to (iNumSegments - 1)
93505>>>>
93505>>>                       //*** Move index segment attributes
93505>>>                       Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
93508>>>                       Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
93511>>>                       Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
93514>>>                       Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
93517>>>                       Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
93520>>>                       Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
93523>>>                   Loop
93524>>>>
93524>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
93527>>>               End
93527>>>>
93527>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
93528>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
93530>>>            Set Action_Text of ghoStatusPanel to ""
93531>>>        End
93531>>>>
93531>>>
93531>>>        Function_Return (Err = False)
93532>>>    End_Function
93533>>>
93533>>>    // Add/Insert an Index Segment
93533>>>    Function ApiIndexInsertSegment Handle hTable Integer iIndex Integer iSegment Integer iSegmentColumn Integer iSegmentCase Integer iSegmentDirection Returns Boolean
93535>>>        Boolean bOK bSQLDriver bIndexTemporary
93535>>>        Integer iNumSegments iCurSegment iCurSegmentColumn iCurSegmentCase iCurSegmentDirection
93535>>>        Integer iIndexType
93535>>>        String sDriverId
93535>>>
93535>>>        Get AutoConnectionIDLogin to bOK
93536>>>        Move False to Err
93537>>>
93537>>>        Get OpenTableExclusive hTable to bOK
93538>>>        If (bOK = False) Begin
93540>>>            Function_Return False
93541>>>        End
93541>>>>
93541>>>
93541>>>        Move False to bIndexTemporary
93542>>>        // Check to see if the index exists or not...
93542>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
93545>>>        If (iNumSegments = 0) Begin
93547>>>            Function_Return False
93548>>>        End
93548>>>>
93548>>>
93548>>>        Get psDriverID to sDriverID
93549>>>        Get IsSQLDriver sDriverID to bSQLDriver
93550>>>        If (bSQLDriver) Begin
93552>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
93555>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
93558>>>                Move True to bIndexTemporary
93559>>>        End
93559>>>>
93559>>>
93559>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
93559>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
93561>>>           Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
93564>>>
93564>>>           If (iSegment > iNumSegments) Begin
93566>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
93569>>>               Move (iNumSegments + 1) to iCurSegment
93570>>>           End
93570>>>>
93570>>>           Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
93573>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
93576>>>               Move iNumSegments to iCurSegment
93577>>>
93577>>>               While (iCurSegment > iSegment)
93581>>>                   //*** Move index segment attributes
93581>>>                   Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iCurSegmentCase
93584>>>                   Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iCurSegmentDirection
93587>>>                   Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
93590>>>                   Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iCurSegmentCase
93593>>>                   Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iCurSegmentDirection
93596>>>                   Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iCurSegmentColumn
93599>>>                   Decrement iCurSegment
93600>>>               End
93601>>>>
93601>>>
93601>>>               //*** Now set new segment attributes
93601>>>               Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
93604>>>               Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
93607>>>               Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
93610>>>           End
93610>>>>
93610>>>        End
93610>>>>
93610>>>
93610>>>        Else Begin
93611>>>           Structure_Start hTable
93612>>>              Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
93615>>>
93615>>>              If (iSegment > iNumSegments) Begin
93617>>>                  Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
93620>>>                  Move (iNumSegments + 1) to iCurSegment
93621>>>              End
93621>>>>
93621>>>              Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
93624>>>                  Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
93627>>>                  Move iNumSegments to iCurSegment
93628>>>
93628>>>                  While (iCurSegment > iSegment)
93632>>>                      //*** Move index segment attributes
93632>>>                      Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iSegmentCase
93635>>>                      Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iSegmentDirection
93638>>>                      Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
93641>>>                      Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
93644>>>                      Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
93647>>>                      Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
93650>>>                      Decrement iCurSegment
93651>>>                  End
93652>>>>
93652>>>
93652>>>                  //*** Now set new segment attributes
93652>>>                  Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
93655>>>                  Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
93658>>>                  Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
93661>>>              End
93661>>>>
93661>>>              Set Action_Text of ghoStatusPanel to "Restructures table..."
93662>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
93664>>>            Set Action_Text of ghoStatusPanel to ""
93665>>>        End
93665>>>>
93665>>>
93665>>>        Function_Return (Err = False)
93666>>>    End_Function
93667>>>
93667>>>    Function API_TABLE_UTILITY_FUNCTIONS Returns Boolean
93669>>>        Function_Return False
93670>>>    End_Function
93671>>>
93671>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
93671>>>    // Note that it first removes any driver prefixes in the rootname.
93671>>>    Function UtilTableInfoCompare Boolean bCompareFilelistUppercase tAPITableNameInfoCompare APITableInfoCompare Returns Boolean
93673>>>        Boolean bIsSame
93673>>>        String sRootNameFrom sRootNameTo sLogicalNameFrom sLogicalNameTo sDisplayNameFrom sDisplayNameTo
93673>>>
93673>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameFrom    to sRootNameFrom
93674>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameTo      to sRootNameTo
93675>>>        Move APITableInfoCompare.sLogicalNameFrom               to sLogicalNameFrom
93676>>>        Move APITableInfoCompare.sLogicalNameTo                 to sLogicalNameTo
93677>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameFrom to sDisplayNameFrom
93678>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameTo   to sDisplayNameTo
93679>>>
93679>>>        If (bCompareFilelistUppercase = True) Begin
93681>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(sLogicalNameFrom) = Uppercase(sLogicalNameTo)) to bIsSame
93682>>>        End
93682>>>>
93682>>>        Else Begin
93683>>>            Move (sRootNameFrom = sRootNameTo and sLogicalNameFrom = sLogicalNameTo and sDisplayNameFrom = sDisplayNameTo) to bIsSame
93684>>>        End  
93684>>>>
93684>>>        If (bIsSame = False) Begin
93686>>>            Function_Return False
93687>>>        End 
93687>>>>
93687>>>
93687>>>        Move (APITableInfoCompare.bIsAliasFrom = APITableInfoCompare.bIsAliasTo) to bIsSame
93688>>>        If (bIsSame = False) Begin
93690>>>            Function_Return False
93691>>>        End 
93691>>>>
93691>>>
93691>>>        Move (APITableInfoCompare.bIsSQLFrom = APITableInfoCompare.bIsSQLTo) to bIsSame
93692>>>        If (bIsSame = False) Begin
93694>>>            Function_Return False
93695>>>        End 
93695>>>>
93695>>>
93695>>>        Move (APITableInfoCompare.bIsSystemFileFrom = APITableInfoCompare.bIsSystemFileTo) to bIsSame
93696>>>        If (bIsSame = False) Begin
93698>>>            Function_Return False
93699>>>        End 
93699>>>>
93699>>>
93699>>>        Function_Return bIsSame
93700>>>    End_Function
93701>>>
93701>>>    Function UtilTableCompare tAPITable APITableFrom tAPITable APITableTo Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
93703>>>        Handle hTableFrom hTableTo
93703>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
93703>>>        Boolean bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase
93703>>>        String sRootName sDriverIDFrom sDriverIDTo
93703>>>        tAPIColumnCompare[]   aAPIColumnCompare
93703>>>        tAPIColumnCompare[]   aAPIColumnCompare
93704>>>        tAPIIndexCompare[]    aAPIIndexCompare
93704>>>        tAPIIndexCompare[]    aAPIIndexCompare
93705>>>        tAPIRelationCompare[] aAPIRelationCompare
93705>>>        tAPIRelationCompare[] aAPIRelationCompare
93706>>>
93706>>>        Move (IsSameStruct(APITableFrom, APITableTo)) to bIsSame
93707>>>        If (bIsSame = True) Begin
93709>>>            Function_Return True
93710>>>        End
93710>>>>
93710>>>
93710>>>        Move False to bFilelistError
93711>>>        Move True to bIsSame
93712>>>        Get pbCompareDate_DateTime  to bCompareDate_DateTime
93713>>>        Get pbCompareIndexAscending to bCompareIndexAscending
93714>>>        Get pbCompareIndexUppercase to bCompareIndexUppercase
93715>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
93716>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
93717>>>
93717>>>        Move APITableFrom.ApiTableInfo.sRootName to sRootName
93718>>>        Get _TableNameOnly sRootName             to sRootName
93719>>>        Move sRootName to APITableTo.ApiTableInfo.sRootName
93720>>>
93720>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg is the same).
93720>>>        // bCodeGenerateMode = True = Code Generation mode.
93720>>>        If (bCodeGenerateMode = True) Begin
93722>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
93722>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
93724>>>                Function_Return False
93725>>>            End
93725>>>>
93725>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
93726>>>            If (bIsSame = False) Begin
93728>>>                Send UserError ("Yikes! There is a serious problem with the Filelist.cfg slot number:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * ".\nThis needs to be fixed before you can generate code for this table number.")
93729>>>                Move True to bFilelistError
93730>>>                Function_Return False
93731>>>            End
93731>>>>
93731>>>        End
93731>>>>
93731>>>
93731>>>        If (bCodeGenerateMode = False) Begin
93733>>>            // Then we want to create this table
93733>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
93735>>>                Function_Return False
93736>>>            End
93736>>>>
93736>>>
93736>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
93737>>>            If (bIsSame = False) Begin
93739>>>                Error DFERR_PROGRAM ("'UtilTableCompare function' problem in Filelist.cfg! Table No:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * "No changes was made for this entry.")
93740>>>>
93740>>>                Move True to bFilelistError
93741>>>                Function_Return False
93742>>>            End
93742>>>>
93742>>>        End
93742>>>>
93742>>>
93742>>>        // Check columns:
93742>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
93743>>>        Move APITableFrom.ApiTableInfo.bIsSQL       to bIsSQLFrom
93744>>>        Move APITableFrom.ApiTableInfo.sDriverID    to sDriverIDFrom
93745>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
93746>>>        Move APITableTo.ApiTableInfo.bIsSQL         to bIsSQLTo
93747>>>        Move APITableTo.ApiTableInfo.sDriverID      to sDriverIDTo
93748>>>        Get UtilColumnsStructFill hTableTo          to APITableTo.aApiColumns
93749>>>        Get UtilColumnCombineFromAndToArrays APITableFrom.aApiColumns APITableTo.aApiColumns to aAPIColumnCompare
93750>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
93751>>>        If (bIsSame = False) Begin
93753>>>            Function_Return False
93754>>>        End
93754>>>>
93754>>>
93754>>>        // ...then check indexes:
93754>>>        Get UtilIndexesStructFill hTableFrom to APITableTo.aApiIndexes
93755>>>        Get UtilIndexCombineFromAndToArrays APITableFrom.aApiIndexes APITableTo.aApiIndexes to aAPIIndexCompare
93756>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
93757>>>        If (bIsSame = False) Begin
93759>>>            Function_Return False
93760>>>        End
93760>>>>
93760>>>
93760>>>        // ...and finally relationships:
93760>>>        Get UtilRelationsStructFill hTableFrom to APITableTo.aApiRelations
93761>>>        Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations to aAPIRelationCompare
93762>>>        Move (IsSameArray(APITableFrom.aApiRelations, APITableTo.aApiRelations)) to bIsSame
93763>>>        Get UtilRelationsCompare hTableFrom aAPIRelationCompare to bIsSame
93764>>>
93764>>>        Function_Return (bIsSame = True)
93765>>>    End_Function
93766>>>
93766>>>    // Similar to UtilTableCompare, but takes a tAPITableCompare struct array and a tAPITableBooleans struct as params.
93766>>>    Function UtilTableCompare_Ex tAPITableCompare APITableCompare tAPITableBooleans CompareTableBooleans Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
93768>>>        Handle hTable
93768>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
93768>>>        String sRootName sDriverIDFrom sDriverIDTo
93768>>>
93768>>>        If (APITableCompare.APITableNameInfoCompare.bExistsFrom = False and APITableCompare.APITableNameInfoCompare.bExistsTo = False) Begin
93770>>>            Move True to bFilelistError
93771>>>            Function_Return False
93772>>>        End
93772>>>>
93772>>>
93772>>>        Move APITableCompare.hTable to hTable
93773>>>        Move True  to bIsSame
93774>>>        Move False to bFilelistError
93775>>>
93775>>>        If (APITableCompare.bExistsFrom = True) Begin
93777>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameFrom to sRootName
93778>>>        End
93778>>>>
93778>>>        Else Begin
93779>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameTo   to sRootName
93780>>>        End
93780>>>>
93780>>>        Get _TableNameOnly sRootName                                   to sRootName
93781>>>
93781>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDFrom     to sDriverIDFrom
93782>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDTo       to sDriverIDTo
93783>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLFrom        to bIsSQLFrom
93784>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLTo          to bIsSQLTo
93785>>>
93785>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg are the same).
93785>>>        // bCodeGenerateMode = True = Code Generation mode.
93785>>>        If (bCodeGenerateMode = True) Begin
93787>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
93787>>>            If (APITableCompare.bExistsTo = False) Begin
93789>>>                Function_Return False
93790>>>            End
93790>>>>
93790>>>            Move (Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) = Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameTo)) to bIsSame
93791>>>            If (bIsSame = False) Begin
93793>>>                Send UserError ("Yikes! There is a problem with the Filelist.cfg slot number:" * String(hTable) + ;                    ".\nThe FROM table logical name is:" * String(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) * "\nwhile the TO table logical name is:" * ;                    String(APITableCompare.APITableNameInfoCompare.sLogicalNameTo) * ".\nThis needs to be fixed before you can generate code for this table number.")
93794>>>                Move True to bFilelistError
93795>>>                Function_Return False
93796>>>            End
93796>>>>
93796>>>        End
93796>>>>
93796>>>
93796>>>        If (bCodeGenerateMode = False) Begin
93798>>>            If (APITableCompare.bExistsTo = False) Begin
93800>>>                // Then we might want to create this table
93800>>>                Function_Return False
93801>>>            End
93801>>>>
93801>>>
93801>>>            Move (APITableCompare.APITableNameInfoCompare.bIsAliasFrom = APITableCompare.APITableNameInfoCompare.bIsAliasTo) to bIsSame
93802>>>            If (bIsSame = False) Begin
93804>>>                Function_Return False
93805>>>            End 
93805>>>>
93805>>>    
93805>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSQLFrom = APITableCompare.APITableNameInfoCompare.bIsSQLTo) to bIsSame
93806>>>            If (bIsSame = False) Begin
93808>>>                Function_Return False
93809>>>            End 
93809>>>>
93809>>>    
93809>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSystemFileFrom = APITableCompare.APITableNameInfoCompare.bIsSystemFileTo) to bIsSame
93810>>>            If (bIsSame = False) Begin
93812>>>                Function_Return False
93813>>>            End 
93813>>>>
93813>>>
93813>>>            // Check table names et al.
93813>>>            Get UtilTableInfoCompare CompareTableBooleans.bCompareFilelistUppercase APITableCompare.APITableNameInfoCompare to bIsSame
93814>>>            If (bIsSame = False) Begin
93816>>>                Function_Return False
93817>>>            End
93817>>>>
93817>>>        End
93817>>>>
93817>>>
93817>>>        // Check Columns:
93817>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo APITableCompare.aAPIColumnsCompare CompareTableBooleans.bCompareDate_DateTime to bIsSame
93818>>>        If (bIsSame = False) Begin
93820>>>            Function_Return False
93821>>>        End
93821>>>>
93821>>>
93821>>>        // ...then check Indexes:
93821>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo APITableCompare.aAPIIndexesCompare CompareTableBooleans.bCompareIndexUppercase CompareTableBooleans.bCompareIndexAscending to bIsSame
93822>>>        If (bIsSame = False) Begin
93824>>>            Function_Return False
93825>>>        End
93825>>>>
93825>>>
93825>>>        // ...and finally Relationships:
93825>>>        Get UtilRelationsCompare hTable APITableCompare.aAPIRelationsCompare to bIsSame
93826>>>
93826>>>        Function_Return (bIsSame = True)
93827>>>    End_Function
93828>>>
93828>>>    // To fill a complete Table array structure (tAPITable[]) with data.
93828>>>    // The data + filelist.cfg path, login et al must have been setup properly first.
93828>>>    // Pass a True as first parameter if the ghoStatusPanel is active and progress info should be shown.
93828>>>    // Pass a second True if this is a comparison and the text should either reflect "FROM" or "TO" database.
93828>>>    Function UtilTablesStructArrayFill Boolean bStatusPanel Boolean bCompareUtil Boolean bFromTables Returns tAPITable[]
93830>>>        tAPITableNameInfo ApiTableNameInfo
93830>>>        tAPITableNameInfo ApiTableNameInfo
93830>>>        tAPITable[]     aApiTables aApiTablesEmpty
93830>>>        tAPITable[]     aApiTables aApiTablesEmpty
93832>>>        tAPIColumn[]    aApiColumns
93832>>>        tAPIColumn[]    aApiColumns
93833>>>        tAPIIndex[]     aApiIndexes
93833>>>        tAPIIndex[]     aApiIndexes
93834>>>        tAPIRelation[]  aApiRelations
93834>>>        tAPIRelation[]  aApiRelations
93835>>>        Handle hTable
93835>>>        Integer iCount iPos
93835>>>        Boolean bIsAlias bUserCancel bIsSQL bIsOpen
93835>>>        String sLogicalName sMessageText
93835>>>
93835>>>        Move 0 to hTable
93836>>>        If (bFromTables = True) Begin
93838>>>            Move "Reading 'FROM' Table Structure:" to sMessageText
93839>>>            If (bCompareUtil = True) Begin
93841>>>                Move (sMessageText * "(1 of 3)") to sMessageText
93842>>>            End
93842>>>>
93842>>>        End
93842>>>>
93842>>>        Else Begin
93843>>>            Move "Reading 'TO' Table Structure:" to sMessageText
93844>>>            If (bCompareUtil = True) Begin
93846>>>                Move (sMessageText * "(2 of 3)") to sMessageText
93847>>>            End
93847>>>>
93847>>>        End
93847>>>>
93847>>>        Set Message_Text of ghoStatusPanel to sMessageText
93848>>>
93848>>>        Get UtilFilelistNoOfTables to iCount
93849>>>        Set piMaximum of ghoProgressBar to iCount
93850>>>        Move 0 to iCount
93851>>>
93851>>>        Repeat
93851>>>>
93851>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
93854>>>            If (hTable > 0 and hTable <> 50) Begin
93856>>>            
93856>>>                Open hTable
93858>>>                Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
93861>>>                If (bIsOpen = False) Begin
93863>>>                    Move True to aApiTablesEmpty[0].bError
93864>>>                    Move hTable to aApiTablesEmpty[0].ApiTableInfo.iTableNumber
93865>>>                    Function_Return aApiTablesEmpty
93866>>>                End
93866>>>>
93866>>>
93866>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName 
93869>>>                Set piPosition of ghoProgressBar to iCount
93870>>>                Send DoAdvance of ghoProgressBarOverall
93871>>>                Set Action_Text of ghoStatusPanel to ("Number:" * String(hTable) * String(sLogicalName))
93872>>>
93872>>>                Get UtilTableStructFill hTable bFromTables to aApiTables[iCount]
93873>>>//                // Table Name Info
93873>>>//                Get UtilTableNameInfoStructFill hTable to ApiTableNameInfo
93873>>>//                
93873>>>//                // Fill columns
93873>>>//                Get UtilColumnsStructFill hTable to aApiColumns
93873>>>//                If (aApiColumns[0].bCancel = True) Begin
93873>>>//                    Move True to aApiTablesEmpty[0].bError
93873>>>//                    Move hTable to aApiTablesEmpty[0].ApiTableInfo.iTableNumber
93873>>>//                    Function_Return aApiTablesEmpty
93873>>>//                End
93873>>>//
93873>>>//                // Fill indexes
93873>>>//                Get UtilIndexesStructFill hTable to aApiIndexes
93873>>>//                If (aApiIndexes[0].bCancel = True) Begin
93873>>>//                    Move True to aApiTablesEmpty[0].bError
93873>>>//                    Move hTable to aApiTablesEmpty[0].ApiTableInfo.iTableNumber
93873>>>//                    Function_Return aApiTablesEmpty
93873>>>//                End
93873>>>//
93873>>>//                // Fill relationships
93873>>>//                Get UtilRelationsStructFill hTable to aApiRelations
93873>>>//                If (aApiRelations[0].bCancel = True) Begin
93873>>>//                    Move True to aApiTablesEmpty[0].bError
93873>>>//                    Move hTable to aApiTablesEmpty[0].ApiTableInfo.iTableNumber
93873>>>//                    Function_Return aApiTablesEmpty
93873>>>//                End
93873>>>
93873>>>                Close hTable DF_PERMANENT
93875>>>
93875>>>//                Move hTable             to aApiTables[iCount].hTable
93875>>>//                Move bFromTables        to aApiTables[iCount].bFromTable
93875>>>//                Move (not(bFromTables)) to aApiTables[iCount].bToTable   
93875>>>//                Move ApiTableNameInfo   to aApiTables[iCount].ApiTableInfo
93875>>>//                Move aApiColumns        to aApiTables[iCount].aApiColumns
93875>>>//                Move aApiIndexes        to aApiTables[iCount].aApiIndexes
93875>>>//                Move aApiRelations      to aApiTables[iCount].aApiRelations
93875>>>                Increment iCount
93876>>>            End
93876>>>>
93876>>>
93876>>>            If (bStatusPanel = True) Begin
93878>>>                Get Check_StatusPanel of ghoStatusPanel to bUserCancel
93879>>>                If (bUserCancel = True) Begin
93881>>>                    Move True to aApiTablesEmpty[0].bCancel
93882>>>                    Function_Return aApiTablesEmpty
93883>>>                End
93883>>>>
93883>>>            End
93883>>>>
93883>>>
93883>>>        Until (hTable = 0)
93885>>>
93885>>>        Function_Return aApiTables
93886>>>    End_Function
93887>>>    
93887>>>    // Returns a 'single' table APITable struct.
93887>>>    Function UtilTableStructFill Handle hTable Boolean bFromTables Returns tAPITable
93889>>>        tAPITableNameInfo ApiTableNameInfo
93889>>>        tAPITableNameInfo ApiTableNameInfo
93889>>>        tAPITable         ApiTable ApiTableEmpty
93889>>>        tAPITable         ApiTable ApiTableEmpty
93889>>>        tAPIColumn[]     aApiColumns
93889>>>        tAPIColumn[]     aApiColumns
93890>>>        tAPIIndex[]      aApiIndexes
93890>>>        tAPIIndex[]      aApiIndexes
93891>>>        tAPIRelation[]   aApiRelations
93891>>>        tAPIRelation[]   aApiRelations
93892>>>        Integer iCount iPos
93892>>>        Boolean bIsAlias bUserCancel bIsSQL bIsOpen
93892>>>        String sLogicalName sRootName sDisplayName sTableName sDriverID sMessageText
93892>>>
93892>>>        Open hTable
93894>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
93897>>>        If (bIsOpen = False) Begin
93899>>>            Move True to ApiTableEmpty.bError
93900>>>            Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
93901>>>            Function_Return ApiTableEmpty
93902>>>        End
93902>>>>
93902>>>        
93902>>>        // Fill Table Name Info
93902>>>        Get UtilTableNameInfoStructFill hTable to ApiTableNameInfo
93903>>>                
93903>>>        // Fill columns
93903>>>        Get UtilColumnsStructFill hTable to aApiColumns
93904>>>        If (SizeOfArray(aApiColumns)) Begin
93906>>>            If (aApiColumns[0].bCancel = True) Begin
93908>>>                Move True to ApiTableEmpty.bError
93909>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
93910>>>                Function_Return ApiTableEmpty
93911>>>            End
93911>>>>
93911>>>        End
93911>>>>
93911>>>        
93911>>>        // Fill indexes
93911>>>        Get UtilIndexesStructFill hTable to aApiIndexes
93912>>>        If (SizeOfArray(aApiIndexes)) Begin
93914>>>            If (aApiIndexes[0].bCancel = True) Begin
93916>>>                Move True to ApiTableEmpty.bError
93917>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
93918>>>                Function_Return ApiTableEmpty
93919>>>            End
93919>>>>
93919>>>        End
93919>>>>
93919>>>        
93919>>>
93919>>>        // Fill relationships
93919>>>        Get UtilRelationsStructFill hTable to aApiRelations
93920>>>        If (SizeOfArray(aApiRelations)) Begin
93922>>>            If (aApiRelations[0].bCancel = True) Begin
93924>>>                Move True to ApiTableEmpty.bError
93925>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
93926>>>                Function_Return ApiTableEmpty
93927>>>            End
93927>>>>
93927>>>        End
93927>>>>
93927>>>        
93927>>>        Move hTable             to ApiTable.hTable
93928>>>        Move bFromTables        to ApiTable.bFromTable
93929>>>        Move (not(bFromTables)) to ApiTable.bToTable   
93930>>>
93930>>>        Move ApiTableNameInfo   to ApiTable.ApiTableInfo
93931>>>        Move aApiColumns        to ApiTable.aApiColumns
93932>>>        Move aApiIndexes        to ApiTable.aApiIndexes
93933>>>        Move aApiRelations      to ApiTable.aApiRelations
93934>>>
93934>>>        Function_Return ApiTable
93935>>>    End_Function
93936>>>
93936>>>
93936>>>    Function UtilTableNameInfoStructFill Handle hTable Returns tAPITableNameInfo
93938>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty                                      
93938>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty                                      
93938>>>        Boolean bIsOpen
93938>>>        
93938>>>        Open hTable
93940>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
93943>>>        If (bIsOpen = False) Begin
93945>>>            Move True   to APITableNameInfoEmpty.bError
93946>>>            Move hTable to APITableNameInfoEmpty.iTableNumber
93947>>>            Function_Return APITableNameInfoEmpty
93948>>>        End
93948>>>>
93948>>>
93948>>>        Move hTable                                  to APITableNameInfo.iTableNumber
93949>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to APITableNameInfo.sRootName
93952>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to APITableNameInfo.sLogicalName
93955>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to APITableNameInfo.sDisplayName
93958>>>        Get_Attribute DF_FILE_DRIVER       of hTable to APITableNameInfo.sDriverID
93961>>>        
93961>>>        Get UtilTableIsAlias                  hTable to APITableNameInfo.bIsAlias
93962>>>        Get UtilTableIsSQL                    hTable to APITableNameInfo.bIsSQL
93963>>>
93963>>>        Close hTable
93964>>>
93964>>>        Function_Return APITableNameInfo
93965>>>    End_Function 
93966>>>    
93966>>>    Function UtilFindTableArrayItem tAPITable[] ByRef aTableStructure String sLogicalTableName Returns Integer
93968>>>        Integer iSize iCount iTable iItem
93968>>>        tAPITableNameInfo ApiTableNameInfo
93968>>>        tAPITableNameInfo ApiTableNameInfo
93968>>>
93968>>>        Move -1 to iItem
93969>>>        Move (SizeOfArray(aTableStructure)) to iSize
93970>>>        Decrement iSize
93971>>>        for iCount from 0 to iSize
93977>>>>
93977>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
93978>>>            If (Uppercase(ApiTableNameInfo.sLogicalName) = Uppercase(sLogicalTableName)) Begin
93980>>>                Move iCount to iItem
93981>>>                Move iSize  to iCount // We're done.
93982>>>            End
93982>>>>
93982>>>        Loop
93983>>>>
93983>>>
93983>>>        Function_Return iItem
93984>>>    End_Function
93985>>>
93985>>>    Function UtilTableArrayCompare tAPITable APITableFrom tAPITable APITableTo Returns Integer
93987>>>        If (APITableFrom.hTable  > APITableTo.hTable) ;            Function_Return (GT)
93990>>>        If (APITableFrom.hTable  < APITableTo.hTable) ;            Function_Return (LT)
93993>>>
93993>>>        If (APITableFrom.bFromTable = True)  ;            Function_Return (LT)
93996>>>        If (APITableFrom.bFromTable = False) ;            Function_Return (GT)
93999>>>
93999>>>        Function_Return (EQ)
94000>>>    End_Function
94001>>>
94001>>>    Function UtilTableCombineFromAndToArrays tAPITable[] aAPITableFrom tAPITable[] aAPITableTo Returns tAPITableCompare[]
94003>>>        Integer iCount iSize iSizeFrom iSizeTo iItemFrom iItemTo iItem
94003>>>        Handle hTable
94003>>>        tAPITable[] aAPITableFromAndTo aAPITableEmpty
94003>>>        tAPITable[] aAPITableFromAndTo aAPITableEmpty
94005>>>        tAPITable   APITableFrom APITableTo
94005>>>        tAPITable   APITableFrom APITableTo
94005>>>        tAPITableNameInfoCompare APITableNameInfoCompare
94005>>>        tAPITableNameInfoCompare APITableNameInfoCompare
94005>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
94005>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
94006>>>        tAPIColumnCompare[]   aAPIColumnCompare
94006>>>        tAPIColumnCompare[]   aAPIColumnCompare
94007>>>        tAPIIndexCompare[]    aAPIIndexCompare
94007>>>        tAPIIndexCompare[]    aAPIIndexCompare
94008>>>        tAPIRelationCompare[] aAPIRelationCompare
94008>>>        tAPIRelationCompare[] aAPIRelationCompare
94009>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
94009>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
94009>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
94009>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
94012>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
94012>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
94015>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
94015>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
94018>>>
94018>>>        Move (SizeOfArray(aAPITableFrom)) to iSizeFrom
94019>>>        Move (SizeOfArray(aAPITableTo))   to iSizeTo
94020>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
94022>>>            Function_Return aAPITableCompare
94023>>>        End
94023>>>>
94023>>>
94023>>>        Move (AppendArray(aAPITableFrom, aAPITableTo)) to aAPITableFromAndTo
94024>>>        Move (SortArray(aAPITableFromAndTo, Self, RefFunc(UtilTableArrayCompare))) to aAPITableFromAndTo
94025>>>
94025>>>        Move 0 to iItem
94026>>>        Move (SizeOfArray(aAPITableFromAndTo)) to iSize
94027>>>        Decrement iSize
94028>>>        for iCount from 0 to iSize
94034>>>>
94034>>>
94034>>>            Move iCount to iItemFrom
94035>>>            Move iCount to iItemTo
94036>>>            Move aAPITableEmpty to APITableFrom
94037>>>            Move aAPITableEmpty to APITableTo
94038>>>
94038>>>            If (aAPITableFromAndTo[iCount].bFromTable = True) Begin
94040>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
94041>>>            End
94041>>>>
94041>>>            If (aAPITableFromAndTo[iCount].bToTable = True) Begin
94043>>>                Move aAPITableFromAndTo[iCount]     to APITableTo
94044>>>            End
94044>>>>
94044>>>            If (aAPITableFromAndTo[iCount].hTable = aAPITableFromAndTo[iCount + 1].hTable) Begin
94046>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
94047>>>                Move (iCount + 1) to iItemTo
94048>>>                Move aAPITableFromAndTo[iItemTo]    to APITableTo
94049>>>            End
94049>>>>
94049>>>
94049>>>            Move APITableFrom.ApiTableInfo  to ApiTableInfoFrom
94050>>>            Move APITableFrom.aApiColumns   to aApiColumnsFrom
94051>>>            Move APITableFrom.aApiIndexes   to aApiIndexFrom
94052>>>            Move APITableFrom.aApiRelations to aApiRelationFrom
94053>>>
94053>>>            Move APITableTo.ApiTableInfo    to ApiTableInfoTo
94054>>>            Move APITableTo.aApiColumns     to aApiColumnsTo
94055>>>            Move APITableTo.aApiIndexes     to aApiIndexTo
94056>>>            Move APITableTo.aApiRelations   to aApiRelationTo
94057>>>
94057>>>            Move aAPITableFromAndTo[iCount].hTable to hTable
94058>>>
94058>>>            If (hTable > 0) Begin
94060>>>
94060>>>                // Table info:
94060>>>                Get UtilTableINFOCombineFromAndToArrays ApiTableInfoFrom ApiTableInfoTo to APITableNameInfoCompare
94061>>>                Move APITableNameInfoCompare.iTableNumber                               to aAPITableCompare[iItem].hTable
94062>>>                Move APITableNameInfoCompare.bExistsFrom                                to aAPITableCompare[iItem].bExistsFrom
94063>>>                Move APITableNameInfoCompare.bExistsTo                                  to aAPITableCompare[iItem].bExistsTo
94064>>>                Move APITableNameInfoCompare                                            to aAPITableCompare[iItem].APITableNameInfoCompare
94065>>>
94065>>>                // Column info:
94065>>>                Get UtilColumnCombineFromAndToArrays aApiColumnsFrom aApiColumnsTo      to aAPIColumnCompare
94066>>>                Move aAPIColumnCompare                                                  to aAPITableCompare[iItem].aAPIColumnsCompare
94067>>>
94067>>>                // Index info:
94067>>>                Get UtilIndexCombineFromAndToArrays aApiIndexFrom aApiIndexTo           to aAPIIndexCompare
94068>>>                Move aAPIIndexCompare                                                   to aAPITableCompare[iItem].aAPIIndexesCompare
94069>>>
94069>>>                // Relation info:
94069>>>                Get UtilRelationCombineFromAndToArrays aApiRelationFrom aApiRelationTo  to aAPIRelationCompare
94070>>>                Move aAPIRelationCompare                                                to aAPITableCompare[iItem].aAPIRelationsCompare
94071>>>
94071>>>                Move False                                                              to aAPITableCompare[iItem].bShouldChange
94072>>>                Move False                                                              to aAPITableCompare[iItem].bCancel
94073>>>                Move False                                                              to aAPITableCompare[iItem].bError
94074>>>                If (iItemTo > iItemFrom) Begin
94076>>>                    Increment iCount
94077>>>                End
94077>>>>
94077>>>                Increment iItem
94078>>>            End
94078>>>>
94078>>>
94078>>>        Loop
94079>>>>
94079>>>
94079>>>        Function_Return aAPITableCompare
94080>>>    End_Function
94081>>>
94081>>>    Function UtilTableInfoCombineFromAndToArrays tAPITableNameInfo APITableNameInfoFrom tAPITableNameInfo APITableNameInfoTo Returns tAPITableNameInfoCompare
94083>>>        tAPITableNameInfoCompare APITableNameInfoCompare
94083>>>        tAPITableNameInfoCompare APITableNameInfoCompare
94083>>>
94083>>>        // FROM database info:
94083>>>        If (APITableNameInfoFrom.iTableNumber > 0) Begin
94085>>>            Move APITableNameInfoFrom.iTableNumber  to APITableNameInfoCompare.iTableNumber
94086>>>            Move APITableNameInfoFrom.sRootName     to APITableNameInfoCompare.sRootNameFrom
94087>>>            Move APITableNameInfoFrom.sLogicalName  to APITableNameInfoCompare.sLogicalNameFrom
94088>>>            Move APITableNameInfoFrom.sDisplayName  to APITableNameInfoCompare.sDisplayNameFrom
94089>>>            Move APITableNameInfoFrom.sDriverID     to APITableNameInfoCompare.sDriverIDFrom
94090>>>            Move APITableNameInfoFrom.bIsAlias      to APITableNameInfoCompare.bIsAliasFrom
94091>>>            Move APITableNameInfoFrom.bIsSQL        to APITableNameInfoCompare.bIsSQLFrom
94092>>>            Move True                               to APITableNameInfoCompare.bExistsFrom
94093>>>        End
94093>>>>
94093>>>
94093>>>        // TO database info:
94093>>>        If (APITableNameInfoTo.iTableNumber > 0) Begin
94095>>>            Move APITableNameInfoTo.iTableNumber    to APITableNameInfoCompare.iTableNumber
94096>>>            Move APITableNameInfoTo.sRootName       to APITableNameInfoCompare.sRootNameTo
94097>>>            Move APITableNameInfoTo.sLogicalName    to APITableNameInfoCompare.sLogicalNameTo
94098>>>            Move APITableNameInfoTo.sDisplayName    to APITableNameInfoCompare.sDisplayNameTo
94099>>>            Move APITableNameInfoTo.sDriverID       to APITableNameInfoCompare.sDriverIDTo
94100>>>            Move APITableNameInfoTo.bIsAlias        to APITableNameInfoCompare.bIsAliasTo
94101>>>            Move APITableNameInfoTo.bIsSQL          to APITableNameInfoCompare.bIsSQLTo
94102>>>            Move True                               to APITableNameInfoCompare.bExistsTo
94103>>>        End
94103>>>>
94103>>>
94103>>>        Function_Return APITableNameInfoCompare
94104>>>    End_Function
94105>>>
94105>>>    // Note:
94105>>>    // The DF_FILE_TABLE_NAME attribute holds the name of the table at the back end. Depending on the back end, table
94105>>>    // names may be case sensitive, contain spaces or other special characters. This attribute is used to determine a table's
94105>>>    // back end name when using Embedded SQL. Since Embedded SQL works on the back end directly, the back end's name must be used.
94105>>>    // In most cases the back end name will be the same as the table name used in DataFlex.
94105>>>    // To do the opposite; To get the file handle from a table name string use the UtilTableNameToHandle function.
94105>>>    Function UtilTableHandleToString Handle hTable Returns String
94107>>>        String sTableName
94107>>>        Boolean bOpen bExists bOK
94107>>>
94107>>>        Get UtilTableNumberIsInUse hTable to bExists
94108>>>        If (bExists = False) Begin
94110>>>            Function_Return ""
94111>>>        End
94111>>>>
94111>>>
94111>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
94112>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
94115>>>        If (bOpen = False) Begin
94117>>>            Get AutoConnectionIDLogin to bOK
94118>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
94119>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
94120>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
94121>>>            Open hTable
94123>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
94124>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
94125>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
94126>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
94129>>>        End
94129>>>>
94129>>>        If (bOpen = True) Begin
94131>>>            Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
94132>>>            Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName
94135>>>            // If blank it is an embedded table:
94135>>>            If (sTableName = "") Begin
94137>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
94140>>>                Move 0 to LastErr
94141>>>                Move False to Err
94142>>>            End
94142>>>>
94142>>>            Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
94143>>>        End
94143>>>>
94143>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
94144>>>
94144>>>        Function_Return sTableName
94145>>>    End_Function
94146>>>
94146>>>    // Returns the filenumber for the passed Table name from Filelist.cfg.
94146>>>    // Returns 0 if unsuccessful.
94146>>>    // To do the opposite; To get the string value from a table handle string use the UtilTableHandleToString function.
94146>>>    Function UtilTableNameToHandle String sTableName Returns Integer
94148>>>        String sValue sPrefixTableName sDriverID
94148>>>        Handle hTable hRetval
94148>>>
94148>>>        Get psDriverID to sDriverID
94149>>>        If (sDriverID <> DATAFLEX_ID and not(sTableName contains ":")) Begin
94151>>>            Move (sDriverID + ":" + sTableName) to sPrefixTableName
94152>>>        End
94152>>>>
94152>>>        Move 0 to hTable
94153>>>        Move 0 to hRetval
94154>>>        Repeat
94154>>>>
94154>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
94157>>>            If (hTable <> 0) Begin
94159>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sValue
94162>>>                If (Uppercase(sValue) = Uppercase(sTableName) or Uppercase(sValue) = Uppercase(sPrefixTableName)) Begin
94164>>>                    Move hTable to hRetval
94165>>>                    Move 0 to hTable
94166>>>                End
94166>>>>
94166>>>            End
94166>>>>
94166>>>        Until (hTable = 0)
94168>>>
94168>>>        Function_Return hRetval
94169>>>    End_Function
94170>>>
94170>>>    // * Dummy function for the Studio's Code Explorer *
94170>>>    Function API_COLUMN_UTILITY_FUNCTIONS Returns Boolean
94172>>>        Function_Return False
94173>>>    End_Function
94174>>>
94174>>>    // Compare multiple columns. (For 'FROM' & 'TO' tables)
94174>>>    Function UtilColumnsCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare[] aAPIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
94176>>>        Boolean bIsSame
94176>>>        Integer iCount iSize iColumn
94176>>>
94176>>>        Move True to bIsSame
94177>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
94178>>>        Set piMaximum of ghoProgressBar  to iSize
94179>>>
94179>>>        Decrement iSize
94180>>>        for iCount from 0 to iSize
94186>>>>
94186>>>            Set piPosition of ghoProgressBar to iCount
94187>>>            Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare[iCount] bCompareDate_DataTime to bIsSame
94188>>>            If (bIsSame = False) Begin
94190>>>                Function_Return False
94191>>>            End
94191>>>>
94191>>>        Loop
94192>>>>
94192>>>
94192>>>        Function_Return (bIsSame = True)
94193>>>    End_Function
94194>>>
94194>>>    // Compares a single column (For 'FROM' & 'TO' tables)
94194>>>    Function UtilColumnCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare APIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
94196>>>        Integer iFromType iToType iDbType
94196>>>        tColumnType ColumnType 
94196>>>        tColumnType ColumnType 
94196>>>        Boolean bIsDateTypeFrom bIsDateTypeTo
94196>>>        
94196>>>        If (APIColumnCompare.bCancelFrom = True or APIColumnCompare.bCancelTo = True) Begin
94198>>>            Function_Return False
94199>>>        End
94199>>>>
94199>>>        If (APIColumnCompare.bExistsFrom = False or APIColumnCompare.bExistsTo = False) Begin
94201>>>            Function_Return False
94202>>>        End
94202>>>>
94202>>>        If (Uppercase(APIColumnCompare.sFieldNameFrom) <> Uppercase(APIColumnCompare.sFieldNameTo)) Begin
94204>>>            Function_Return False
94205>>>        End  
94205>>>>
94205>>>        If (APIColumnCompare.bAllowNULLFrom <> APIColumnCompare.bAllowNULLTo) Begin
94207>>>            Function_Return False
94208>>>        End                      
94208>>>>
94208>>>        If (APIColumnCompare.sDefaultValueFrom <> APIColumnCompare.sDefaultValueTo) Begin
94210>>>            Function_Return False
94211>>>        End                      
94211>>>>
94211>>>
94211>>>        Get piDbType                       to iDbType
94212>>>        Move APIColumnCompare.iTypeFrom    to iFromType
94213>>>        Move APIColumnCompare.iTypeTo      to iToType 
94214>>>
94214>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
94214>>>        // data types between Embedded and SQL.
94214>>>        If (bIsSQLFrom = True and bIsSQLTo = False) Begin
94216>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iFromType APIColumnCompare.iLengthFrom to iFromType
94217>>>        End
94217>>>>
94217>>>        If (bIsSQLFrom = False and bIsSQLTo = True) Begin
94219>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iToType APIColumnCompare.iLengthTo to iToType
94220>>>        End
94220>>>>
94220>>>
94220>>>        Get UtilColumnIsDateType iFromType bIsSQLFrom to bIsDateTypeFrom
94221>>>        Get UtilColumnIsDateType iToType   bIsSQLTo   to bIsDateTypeTo
94222>>>
94222>>>        // Make Date and DateTime comparison?
94222>>>        If (bCompareDate_DataTime = True) Begin
94224>>>            If (iFromType <> iToType) Begin
94226>>>                Function_Return False
94227>>>            End
94227>>>>
94227>>>        End
94227>>>>
94227>>>
94227>>>        // This is when not checking for Date/DateTime differences but all other other field types...
94227>>>        If (bCompareDate_DataTime = False and bIsDateTypeFrom = False) Begin
94229>>>            If (iFromType <> iToType) Begin
94231>>>                Function_Return False
94232>>>            End
94232>>>>
94232>>>        End
94232>>>>
94232>>>
94232>>>        // Only if the field is not a Date type (any of them) we compare length & precision.
94232>>>        If (bIsDateTypeFrom = False) Begin
94234>>>            If (APIColumnCompare.iLengthFrom <> APIColumnCompare.iLengthTo) Begin
94236>>>                Function_Return False
94237>>>            End
94237>>>>
94237>>>            If (APIColumnCompare.iPrecisionFrom <> APIColumnCompare.iPrecisionTo) Begin
94239>>>                Function_Return False
94240>>>            End
94240>>>>
94240>>>        End
94240>>>>
94240>>>
94240>>>        If (APIColumnCompare.iOptionsFrom <> APIColumnCompare.iOptionsTo) Begin
94242>>>            Function_Return False
94243>>>        End
94243>>>>
94243>>>
94243>>>        Function_Return True
94244>>>    End_Function
94245>>>
94245>>>    Function UtilColumnsStructFill Handle hTable Returns tAPIColumn[]
94247>>>        Integer iNumColumns iColumn iCount iOptions iDbType iType iLength iPrecision iCheckFieldNumber
94247>>>        Boolean bIdentityKey bDawSqlDriver bSqlDriver bIsOpen bExists bIsSqlTable bUserCancel bState
94247>>>        tAPIColumn[] APIColumns APIColumnsEmpty
94247>>>        tAPIColumn[] APIColumns APIColumnsEmpty
94249>>>        String sDriverID sFieldName sRootName sLogicalName sValue
94249>>>
94249>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
94250>>>        Get piDbType to iDbType
94251>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
94254>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
94257>>>
94257>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
94260>>>        If (bIsOpen = False) Begin
94262>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
94263>>>            Open hTable
94265>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
94266>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
94269>>>            If (bIsOpen = False) Begin
94271>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
94272>>>                Move True to APIColumnsEmpty[0].bError
94273>>>                Function_Return APIColumnsEmpty
94274>>>            End
94274>>>>
94274>>>        End
94274>>>>
94274>>>
94274>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
94277>>>        Get IsSQLDriver    sDriverID to bSqlDriver
94278>>>        Get IsDAWSQLDriver sDriverID to bDawSqlDriver
94279>>>
94279>>>        Get UtilTableIsSQLByRootName sRootName to bIsSqlTable
94280>>>        If (bIsSqlTable = True) Begin
94282>>>            Get UtilTableExists hTable to bExists
94283>>>            If (bExists = False) Begin
94285>>>                Move True to APIColumnsEmpty[0].bError
94286>>>                Function_Return APIColumnsEmpty
94287>>>            End
94287>>>>
94287>>>        End
94287>>>>
94287>>>
94287>>>        Move 0 to iCount
94288>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
94291>>>        Set piMaximum of ghoProgressBar to iNumColumns
94292>>>
94292>>>        for iColumn from 1 to iNumColumns
94298>>>>
94298>>>            Move 0 to iOptions
94299>>>            Move False to bIdentityKey
94300>>>            Move False to Err
94301>>>            Move 0     to LastErr
94302>>>            Move bIsSqlTable to APIColumns[iCount].bIsSQLType
94303>>>            Set piPosition of ghoProgressBar to iColumn
94304>>>            If (bDawSqlDriver = True) Begin
94306>>>                Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
94307>>>                If (bIsSqlTable = True) Begin
94309>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iType
94312>>>                    Move iType                                                to APIColumns[iCount].iType
94313>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE_NAME of hTable iColumn to APIColumns[iCount].sType
94316>>>                    Get_Attribute DF_FIELD_NULL_ALLOWED     of hTable iColumn to APIColumns[iCount].bAllowNULL
94319>>>                    Get_Attribute DF_FIELD_DEFAULT_VALUE    of hTable iColumn to APIColumns[iCount].sDefaultValue 
94322>>>                End
94322>>>>
94322>>>                Else Begin
94323>>>                    Get_Attribute DF_FIELD_TYPE             of hTable iColumn to APIColumns[iCount].iType
94326>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
94327>>>                End
94327>>>>
94327>>>
94327>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
94327>>>                Get_Attribute DF_Field_Number of hTable iColumn to iCheckFieldNumber
94330>>>                Move (iCheckFieldNumber >= 0) to bExists
94331>>>                If (bExists = False) Begin
94333>>>                    Move 0 to APIColumns[iCount].iType
94334>>>                End
94334>>>>
94334>>>                If (bExists = True) Begin
94336>>>                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
94339>>>                End
94339>>>>
94339>>>                Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
94340>>>                If (bIdentityKey = True) Begin
94342>>>                    Move C_tAPIColumn_Identity to APIColumns[iCount].iOptions
94343>>>                End
94343>>>>
94343>>>            End
94343>>>>
94343>>>            Else Begin
94344>>>                Move False to Err
94345>>>                Move 0     to LastErr
94346>>>                If (bIsSqlTable = True) Begin
94348>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to APIColumns[iCount].iType
94351>>>                End
94351>>>>
94351>>>                Else Begin
94352>>>                    Get_Attribute DF_FIELD_TYPE        of hTable iColumn to APIColumns[iCount].iType
94355>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
94356>>>                End
94356>>>>
94356>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
94356>>>                Move (LastErr <> DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) to bExists
94357>>>                If (bExists = False) Begin
94359>>>                    Move 0 to APIColumns[iCount].iType
94360>>>                End
94360>>>>
94360>>>            End
94360>>>>
94360>>>
94360>>>            If (bExists = True) Begin
94362>>>                Move iColumn to APIColumns[iCount].iFieldNumber
94363>>>                Get_Attribute DF_FIELD_NAME        of hTable iColumn to APIColumns[iCount].sFieldName
94366>>>                // ToDo: Can't use native_size as it can get way to big and causes "out of memory" problems.
94366>>>//                If (bIsSqlTable = True) Begin
94366>>>//                    Get_Attribute DF_FIELD_NATIVE_SIZE of hTable iColumn to APIColumns[iCount].iLength
94366>>>//                    Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
94366>>>//                End
94366>>>                Get_Attribute DF_FIELD_LENGTH      of hTable iColumn to APIColumns[iCount].iLength
94369>>>                Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
94372>>>
94372>>>                // If the length was zero we might have an Overlap(!) field.
94372>>>                // We then need check the DF_FIELD_TYPE if it really is and reset data for this array item.
94372>>>                If (APIColumns[iCount].iLength = 0) Begin
94374>>>                    Get_Attribute DF_FIELD_TYPE    of hTable iColumn to iType
94377>>>                    If (iType = DF_OVERLAP) Begin
94379>>>                        Move 0 to APIColumns[iCount].iFieldNumber
94380>>>                        Move 0 to APIColumns[iCount].iLength
94381>>>                        Move 0 to APIColumns[iCount].iOptions
94382>>>                        Move 0 to APIColumns[iCount].iPrecision
94383>>>                        Move DF_OVERLAP to APIColumns[iCount].iType
94384>>>                        Move "" to APIColumns[iCount].sFieldName
94385>>>                        Decrement iCount
94386>>>                    End
94386>>>>
94386>>>                End
94386>>>>
94386>>>            End
94386>>>>
94386>>>            Get Check_StatusPanel of ghoStatusPanel to bUserCancel
94387>>>            If (bUserCancel = True) Begin
94389>>>                Move True to APIColumnsEmpty[0].bCancel
94390>>>                Function_Return APIColumnsEmpty
94391>>>            End
94391>>>>
94391>>>            Increment iCount
94392>>>        Loop
94393>>>>
94393>>>
94393>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
94394>>>        Function_Return APIColumns
94395>>>    End_Function
94396>>>
94396>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
94396>>>    // The combined data will be sorted on the first struct member: iIndexNumber
94396>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
94396>>>    // have "holes" in the series of index numbers.
94396>>>    Function UtilColumnCombineFromAndToArrays tAPIColumn[] APIColumnFrom tAPIColumn[] APIColumnTo Returns tAPIIndexCompare[]
94398>>>        tAPIColumnCompare[] aAPIColumnCompare
94398>>>        tAPIColumnCompare[] aAPIColumnCompare
94399>>>        tAPIColumnCompare   APIColumnCompare
94399>>>        tAPIColumnCompare   APIColumnCompare
94399>>>        Integer iSizeFrom iSizeTo iSize iCount iItem iColumnFrom iColumnTo
94399>>>
94399>>>        Move (SizeOfArray(APIColumnFrom)) to iSizeFrom
94400>>>        Decrement iSizeFrom
94401>>>        for iCount from 0 to iSizeFrom
94407>>>>
94407>>>            Move APIColumnFrom[iCount].iFieldNumber     to aAPIColumnCompare[iCount].iFieldNumber
94408>>>            Move APIColumnFrom[iCount].sFieldName       to aAPIColumnCompare[iCount].sFieldNameFrom
94409>>>            Move APIColumnFrom[iCount].iType            to aAPIColumnCompare[iCount].iTypeFrom
94410>>>            Move APIColumnFrom[iCount].sType            to aAPIColumnCompare[iCount].sTypeFrom
94411>>>            Move APIColumnFrom[iCount].iLength          to aAPIColumnCompare[iCount].iLengthFrom
94412>>>            Move APIColumnFrom[iCount].iPrecision       to aAPIColumnCompare[iCount].iPrecisionFrom
94413>>>            Move APIColumnFrom[iCount].iOptions         to aAPIColumnCompare[iCount].iOptionsFrom
94414>>>            Move APIColumnFrom[iCount].bIsSQLType       to aAPIColumnCompare[iCount].bIsSQLTypeFrom  
94415>>>            Move APIColumnFrom[iCount].bAllowNULL       to aAPIColumnCompare[iCount].bAllowNULLFrom
94416>>>            Move APIColumnFrom[iCount].sDefaultValue    to aAPIColumnCompare[iCount].sDefaultValueFrom
94417>>>            Move APIColumnFrom[iCount].bShouldChange    to aAPIColumnCompare[iCount].bShouldChangeFrom
94418>>>            Move APIColumnFrom[iCount].bCancel          to aAPIColumnCompare[iCount].bCancelFrom
94419>>>            Move APIColumnFrom[iCount].bError           to aAPIColumnCompare[iCount].bErrorFrom
94420>>>            Move True                                   to aAPIColumnCompare[iCount].bExistsFrom
94421>>>        Loop
94422>>>>
94422>>>
94422>>>        Move (SizeOfArray(APIColumnTo)) to iSizeTo
94423>>>        Decrement iSizeTo
94424>>>        for iCount from 0 to iSizeTo
94430>>>>
94430>>>            Move APIColumnTo[iCount].iFieldNumber       to APIColumnCompare.iFieldNumber
94431>>>            // Search if the field number already exists in the array; else add it.
94431>>>            Move (SearchArray(APIColumnCompare, aAPIColumnCompare)) to iItem
94432>>>            If (iItem = -1) Begin
94434>>>                Move (SizeOfArray(aAPIColumnCompare))   to iItem
94435>>>            End
94435>>>>
94435>>>
94435>>>            Move APIColumnCompare.iFieldNumber          to aAPIColumnCompare[iItem].iFieldNumber
94436>>>            Move APIColumnTo[iCount].iFieldNumber       to aAPIColumnCompare[iItem].iFieldNumberTo
94437>>>            Move APIColumnTo[iCount].sFieldName         to aAPIColumnCompare[iItem].sFieldNameTo
94438>>>            Move APIColumnTo[iCount].iType              to aAPIColumnCompare[iItem].iTypeTo
94439>>>            Move APIColumnTo[iCount].sType              to aAPIColumnCompare[iItem].sTypeTo
94440>>>            Move APIColumnTo[iCount].iLength            to aAPIColumnCompare[iItem].iLengthTo
94441>>>            Move APIColumnTo[iCount].iPrecision         to aAPIColumnCompare[iItem].iPrecisionTo
94442>>>            Move APIColumnTo[iCount].iOptions           to aAPIColumnCompare[iItem].iOptionsTo
94443>>>            Move APIColumnTo[iCount].bIsSQLType         to aAPIColumnCompare[iItem].bIsSQLTypeTo
94444>>>            Move APIColumnTo[iCount].bAllowNULL         to aAPIColumnCompare[iItem].bAllowNULLTo
94445>>>            Move APIColumnTo[iCount].sDefaultValue      to aAPIColumnCompare[iItem].sDefaultValueTo
94446>>>            Move APIColumnTo[iCount].bShouldChange      to aAPIColumnCompare[iItem].bShouldChangeTo
94447>>>            Move APIColumnTo[iCount].bCancel            to aAPIColumnCompare[iItem].bCancelTo
94448>>>            Move APIColumnTo[iCount].bError             to aAPIColumnCompare[iItem].bErrorTo
94449>>>            Move True                                   to aAPIColumnCompare[iItem].bExistsTo
94450>>>        Loop
94451>>>>
94451>>>
94451>>>        Move (SortArray(aAPIColumnCompare)) to aAPIColumnCompare
94452>>>
94452>>>        Function_Return aAPIColumnCompare
94453>>>    End_Function
94454>>>
94454>>>    // Checks if a field name exists in a table definition
94454>>>    // Returns True if it does
94454>>>    // Sample:
94454>>>    //   Get UtilColumnExists MyTable.File_Number "MyColumnName" to iExists
94454>>>    Function UtilColumnExists Handle hTable String sFieldName Returns Boolean
94456>>>        Integer iNumColumns iColumn
94456>>>        String sColumn
94456>>>        Boolean bExists bOK bOpen
94456>>>
94456>>>        Get AutoConnectionIDLogin to bOK
94457>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
94458>>>        Open hTable
94460>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
94461>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
94464>>>        If (bOpen = False) Begin
94466>>>            Function_Return False
94467>>>        End
94467>>>>
94467>>>
94467>>>        Move False to bExists
94468>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
94471>>>        for iColumn from 1 to iNumColumns
94477>>>>
94477>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
94480>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
94482>>>                Move iNumColumns to iColumn
94483>>>                Move True to bExists
94484>>>            End
94484>>>>
94484>>>        Loop
94485>>>>
94485>>>        Close hTable
94486>>>
94486>>>        Function_Return bExists
94487>>>    End_Function
94488>>>
94488>>>    // Returns the field/column number for the passed FieldName as an integer.
94488>>>    Function UtilColumnNameToColumnNumber Handle hTable String sFieldName Returns Integer
94490>>>        Integer iNumColumns iColumn iRetval
94490>>>        String sColumn
94490>>>        Boolean bOK bOpen
94490>>>
94490>>>        Get AutoConnectionIDLogin to bOK
94491>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
94492>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
94493>>>        Open hTable
94495>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
94496>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
94499>>>        If (bOpen = False) Begin
94501>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
94502>>>            Function_Return False
94503>>>        End
94503>>>>
94503>>>
94503>>>        Move 0 to iColumn
94504>>>        Move 0 to iRetval
94505>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
94508>>>        for iColumn from 1 to iNumColumns
94514>>>>
94514>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
94517>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
94519>>>                Move iColumn to iRetval
94520>>>                Move iNumColumns to iColumn
94521>>>            End
94521>>>>
94521>>>        Loop
94522>>>>
94522>>>        Close hTable
94523>>>
94523>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
94524>>>        Function_Return iRetval
94525>>>    End_Function
94526>>>
94526>>>    // To convert between a data type string name and its integer constant declaration. E.g."VarChar" -> SQL_VarChar
94526>>>    // The reciprocal function is UtilColumnTypeToInteger.
94526>>>    Function UtilColumnTypeToInteger String sDriverID Integer iDbType String sDataType Returns Integer
94528>>>        tColumnType RetvalType
94528>>>        tColumnType RetvalType
94528>>>
94528>>>        Get _UtilColumnType sDriverID iDbType 0 sDataType False to RetvalType
94529>>>        Function_Return RetvalType.iSQLType
94530>>>    End_Function
94531>>>
94531>>>    // To convert between an integer data type constant and its string value. E.g. SQL_VarChar -> "VarChar".
94531>>>    // The reciprocal function is UtilColumnTypeToString.
94531>>>    Function UtilColumnTypeToString String sDriverID Integer iDbType Integer iDataType Returns String
94533>>>        tColumnType RetvalType
94533>>>        tColumnType RetvalType
94533>>>
94533>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
94534>>>        Function_Return RetvalType.sSQLType
94535>>>    End_Function
94536>>>
94536>>>    Function UtilColumnTypePrecision String sDriverID Integer iDbType Integer iDataType Returns String
94538>>>        tColumnType RetvalType
94538>>>        tColumnType RetvalType
94538>>>
94538>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
94539>>>        Function_Return RetvalType.sPrecision
94540>>>    End_Function
94541>>>
94541>>>    Function UtilColumnTypeFixed String sDriverID Integer iDbType Integer iDataType Returns Boolean
94543>>>        tColumnType RetvalType
94543>>>        tColumnType RetvalType
94543>>>
94543>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
94544>>>        Function_Return RetvalType.bCanEditSize
94545>>>    End_Function
94546>>>
94546>>>    Function UtilColumnTypePrecisionSize String sDriverID Integer iDbType Integer iDataType Returns Integer
94548>>>        tColumnType RetvalType
94548>>>        tColumnType RetvalType
94548>>>        String sValue
94548>>>        Integer iRetval iPos
94548>>>
94548>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
94549>>>        Move RetvalType.sPrecision to sValue
94550>>>        Move (Pos(".", sValue)) to iPos
94551>>>        If (iPos <> 0) Begin
94553>>>            Move (Left(sValue, (iPos -1))) to iRetval
94554>>>        End
94554>>>>
94554>>>        Else Begin
94555>>>            Move sValue to iRetval
94556>>>        End
94556>>>>
94556>>>        Function_Return iRetval
94557>>>    End_Function
94558>>>
94558>>>    Function UtilColumnTypePrecisionDec String sDriverID Integer iDbType Integer iDataType Returns Integer
94560>>>        tColumnType RetvalType
94560>>>        tColumnType RetvalType
94560>>>        String sValue
94560>>>        Integer iRetval iPos
94560>>>
94560>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
94561>>>        Move RetvalType.sPrecision to sValue
94562>>>        Move (Pos(".", sValue)) to iPos
94563>>>        If (iPos = 0) Begin
94565>>>            Function_Return 0
94566>>>        End
94566>>>>
94566>>>        Move (Mid(sValue, 99, (iPos + 1))) to iRetval
94567>>>
94567>>>        Function_Return iRetval
94568>>>    End_Function
94569>>>
94569>>>    // * Dummy function for the Studio's Code Explorer *
94569>>>    Function API_INDEX_UTILITY_FUNCTIONS Returns Boolean
94571>>>        Function_Return False
94572>>>    End_Function
94573>>>
94573>>>    // Compares multiple indexes for a 'FROM' and a 'TO' table.
94573>>>    Function UtilIndexesCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare[] aAPIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
94575>>>        Boolean bIsSame
94575>>>        Integer iCount iSize
94575>>>
94575>>>        Move True to bIsSame
94576>>>        Move (SizeOfArray(aAPIIndexCompare)) to iSize
94577>>>        Decrement iSize
94578>>>        For iCount from 0 to iSize
94584>>>>
94584>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
94585>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
94586>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
94587>>>            If (bIsSame = False) Begin
94589>>>                Function_Return False
94590>>>            End
94590>>>>
94590>>>        Loop
94591>>>>
94591>>>
94591>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
94592>>>        Function_Return bIsSame
94593>>>    End_Function
94594>>>
94594>>>    // Compares a single index for a 'FROM' and a 'TO' table.
94594>>>    // ToDo: ReDo; remove table handles! And add bIsSQLtablefrom/to
94594>>>    Function UtilIndexCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare APIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
94596>>>        Boolean bIsSame
94596>>>        Integer iSegment
94596>>>
94596>>>        Move (APIIndexCompare.bExistsFrom = APIIndexCompare.bExistsTo) to bIsSame
94597>>>        If (bIsSame = False) Begin
94599>>>            Function_Return False
94600>>>        End
94600>>>>
94600>>>        Move (APIIndexCompare.iPrimaryIndexFrom = APIIndexCompare.iPrimaryIndexTo) to bIsSame
94601>>>        If (bIsSame = False) Begin
94603>>>            Function_Return False
94604>>>        End
94604>>>>
94604>>>
94604>>>        If (bIsSqlTableFrom = True and bIsSqlTableTo = True) Begin
94606>>>            // * We should probably not compare SQL index names?
94606>>>            // Move (Uppercase(aIndexFrom.sSQLIndexName) = Uppercase(aIndexTo.sSQLIndexName)) to bIsSame
94606>>>            // If (bIsSame = False) Begin   DF_INDEX_SERVER_ONLY
94606>>>            //     Function_Return False
94606>>>            // End
94606>>>            Move (APIIndexCompare.bIsSQLPrimaryKeyFrom = APIIndexCompare.bIsSQLPrimaryKeyTo) to bIsSame
94607>>>            If (bIsSame = False) Begin
94609>>>                Function_Return False
94610>>>            End
94610>>>>
94610>>>            Move (APIIndexCompare.bIsSQLClusteredFrom = APIIndexCompare.bIsSQLClusteredTo) to bIsSame
94611>>>            If (bIsSame = False) Begin
94613>>>                Function_Return False
94614>>>            End
94614>>>>
94614>>>            Move (APIIndexCompare.iSQLIndexTypeFrom = APIIndexCompare.iSQLIndexTypeTo) to bIsSame
94615>>>            If (bIsSame = False) Begin
94617>>>                Function_Return False
94618>>>            End
94618>>>>
94618>>>        End
94618>>>>
94618>>>
94618>>>        Get UtilIndexSegmentsCompare APIIndexCompare.IndexSegmentArrayFrom APIIndexCompare.IndexSegmentArrayTo bCompareIndexUppercase bCompareIndexAscending to iSegment
94619>>>        Move (iSegment = -1) to bIsSame
94620>>>
94620>>>        Function_Return (bIsSame = True)
94621>>>    End_Function
94622>>>
94622>>>    // Compares each segment for the passed index.
94622>>>    // Returns -1 if same; else returns the index segment that differs.
94622>>>    Function UtilIndexSegmentsCompare tAPIIndexSegment[] aIndexSegmentFrom tAPIIndexSegment[] aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
94624>>>        Integer iNumSegmentsFrom iNumSegmentsTo iNumSegments iSegment
94624>>>        Boolean bIsSame
94624>>>
94624>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
94625>>>        Move (SizeOfArray(aIndexSegmentFrom))      to iNumSegmentsFrom
94626>>>        Move (SizeOfArray(aIndexSegmentTo))        to iNumSegmentsTo
94627>>>        Move (iNumSegmentsFrom max iNumSegmentsTo) to iNumSegments
94628>>>
94628>>>        Decrement iNumSegments
94629>>>        for iSegment from 0 to iNumSegments
94635>>>>
94635>>>            Move False to bIsSame
94636>>>            If (iSegment <= iNumSegmentsFrom and iSegment <= iNumSegmentsTo) Begin
94638>>>                Get UtilIndexSegmentCompare aIndexSegmentFrom[iSegment] aIndexSegmentTo[iSegment] bCompareIndexUppercase bCompareIndexAscending to bIsSame
94639>>>            End
94639>>>>
94639>>>            If (bIsSame = False) Begin
94641>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
94642>>>                Function_Return iSegment
94643>>>            End
94643>>>>
94643>>>        Loop
94644>>>>
94644>>>
94644>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
94645>>>        Function_Return -1 // This means bIsSame = True
94646>>>    End_Function
94647>>>
94647>>>    Function UtilIndexSegmentCompare tAPIIndexSegment aIndexSegmentFrom tAPIIndexSegment aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
94649>>>        Boolean bIsSame
94649>>>
94649>>>        Move (aIndexSegmentFrom.iFieldNumber = aIndexSegmentTo.iFieldNumber) to bIsSame
94650>>>        If (bIsSame = False) Begin
94652>>>            Function_Return False
94653>>>        End
94653>>>>
94653>>>        If (bCompareIndexUppercase = True) Begin
94655>>>            Move (aIndexSegmentFrom.bUppercase = aIndexSegmentTo.bUppercase) to bIsSame
94656>>>            If (bIsSame = False) Begin
94658>>>                Function_Return False
94659>>>            End
94659>>>>
94659>>>        End
94659>>>>
94659>>>        If (bCompareIndexAscending = True) Begin
94661>>>            Move (aIndexSegmentFrom.bAscending = aIndexSegmentTo.bAscending) to bIsSame
94662>>>            If (bIsSame = False) Begin
94664>>>                Function_Return False
94665>>>            End
94665>>>>
94665>>>        End
94665>>>>
94665>>>
94665>>>        Function_Return True
94666>>>    End_Function
94667>>>
94667>>>    Function UtilIndexesUpdate Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndex[] aIndexesFrom tAPIIndex[] aIndexesTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
94669>>>        Boolean bIsSame bOK bExists
94669>>>        Integer iSize iSizeFrom iSizeTo iCount iIndexSegment               
94669>>>        tAPIIndexCompare[] aAPIIndexCompare
94669>>>        tAPIIndexCompare[] aAPIIndexCompare
94670>>>
94670>>>        Move (SizeOfArray(aIndexesFrom)) to iSize
94671>>>        If (iSize = 0) Begin
94673>>>            Function_Return True
94674>>>        End                     
94674>>>>
94674>>>        Move (SizeOfArray(aIndexesTo)) to iSizeTo  
94675>>>        Get UtilTableIsSql hTable to bIsSQLTableTo
94676>>>        Get UtilIndexCombineFromAndToArrays aIndexesFrom aIndexesTo to aAPIIndexCompare
94677>>>        
94677>>>        for iCount from 0 to (iSize - 1) 
94683>>>>
94683>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
94684>>>            If (bIsSame = False) Begin
94686>>>                Get APIIndexCreateByFieldNames hTable aIndexesFrom[iCount] aIndexesTo aIndexesFrom[iCount].IndexSegmentArray to bOK
94687>>>            End
94687>>>>
94687>>>        Loop  
94688>>>>
94688>>>        
94688>>>        // We probably should delete other indexes if they exists.
94688>>>        for iCount from (iSize +1) to iSizeTo
94694>>>>
94694>>>            Get ApiIndexRemove hTable iCount to bOK
94695>>>        Loop
94696>>>>
94696>>>
94696>>>        Function_Return bOK
94697>>>    End_Function
94698>>>
94698>>>//    Function UtilIsSameColumnDefinitions Handle hTable tAPIColumn[] aColumns Returns Boolean
94698>>>//        Boolean bEqual bIdentityKey bSqlDriver bDawSqlDriver bIsOpen
94698>>>//        Integer iCount iColumn iSize iOptions iLength iPrecision iType
94698>>>//        String sFieldName sDriverID
94698>>>//
94698>>>//        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
94698>>>//        If (bIsOpen = False) Begin
94698>>>//            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
94698>>>//            Open hTable
94698>>>//            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
94698>>>//            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
94698>>>//            If (bIsOpen = False) Begin
94698>>>//                Function_Return False
94698>>>//            End
94698>>>//        End
94698>>>//
94698>>>//        Move True to bEqual
94698>>>//        Get psDriverID to sDriverID
94698>>>//        Get IsSQLDriver    sDriverID to bSqlDriver
94698>>>//        Get IsDAWSQLDriver sDriverID to bDawSqlDriver
94698>>>//        Move (SizeOfArray(aColumns)) to iSize
94698>>>//        Decrement iSize
94698>>>//
94698>>>//        For iCount from 0 to iSize
94698>>>//            Move 0 to iOptions
94698>>>//            Move False to bIdentityKey
94698>>>//            Move aColumns[iCount].sFieldName to sFieldName
94698>>>//
94698>>>//            // We need to use the column name - not the column integer as
94698>>>//            // the order does not need to be the same, and the logic should still work.
94698>>>//            Get UtilColumnNameToColumnNumber hTable sFieldName to iColumn
94698>>>//            If (iColumn > 0) Begin
94698>>>//                If (bDawSqlDriver = True) Begin
94698>>>//                    Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
94698>>>//                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iType
94698>>>//                    If (iType <> aColumns[iCount].iSQLType) Begin
94698>>>//                        Move False to bEqual
94698>>>//                    End
94698>>>//                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
94698>>>//                    If (bIdentityKey = True) Begin
94698>>>//                        Move C_tAPIColumn_Identity to iOptions
94698>>>//                    End
94698>>>//                    If (iOptions <> aColumns[iCount].iOptions) Begin
94698>>>//                        Move False to bEqual
94698>>>//                    End
94698>>>//                    Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
94698>>>//                End
94698>>>//                Else Begin
94698>>>//                    Get_Attribute DF_FIELD_TYPE     of hTable iColumn to iType
94698>>>//                    If (iType <> aColumns[iCount].iSQLType) Begin
94698>>>//                        Move False to bEqual
94698>>>//                    End
94698>>>//                End
94698>>>//                Get_Attribute DF_FIELD_LENGTH       of hTable iColumn to iLength
94698>>>//                If (iLength <> aColumns[iCount].iLength) Begin
94698>>>//                    Move False to bEqual
94698>>>//                End
94698>>>//                Get_Attribute DF_FIELD_PRECISION    of hTable iColumn to iPrecision
94698>>>//                If (iPrecision <> aColumns[iCount].iPrecision) Begin
94698>>>//                    Move False to bEqual
94698>>>//                End
94698>>>//                If (bEqual = False) Begin
94698>>>//                    Function_Return False
94698>>>//                End
94698>>>//            End
94698>>>//
94698>>>//            Else Begin
94698>>>//                Function_Return False
94698>>>//            End
94698>>>//        Loop
94698>>>//
94698>>>//        Function_Return bEqual
94698>>>//    End_Function
94698>>>
94698>>>    Function UtilIndexesStructFill Handle hTable Returns tAPIIndex[]
94700>>>        tAPIIndex[] APIIndexes
94700>>>        tAPIIndex[] APIIndexes
94701>>>        Integer iCount iIndex iIndexes iSegment iSegmentCount iNumSegments iColumn
94701>>>        String sDriverID
94701>>>        Boolean bDAWSQLDriver bIsOpen bIsSQLTable bIsSQLPrimaryKey
94701>>>
94701>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
94702>>>        Get psDriverID to sDriverID
94703>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
94704>>>        Get UtilTableIsSQL hTable to bIsSQLTable
94705>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
94708>>>        If (bIsOpen = False) Begin
94710>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
94711>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
94712>>>            Open hTable
94714>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
94715>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
94716>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
94719>>>            If (bIsOpen = False) Begin
94721>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
94722>>>                Move True to APIIndexes[0].bError
94723>>>                Function_Return APIIndexes
94724>>>            End
94724>>>>
94724>>>        End
94724>>>>
94724>>>
94724>>>        Move 0 to iCount
94725>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iIndexes
94728>>>        for iIndex from 1 to iIndexes
94734>>>>
94734>>>            // This is a test that the index exists as there might be "holes" aka the index
94734>>>            // numbers doesn't not need to be consequitive:
94734>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
94737>>>            If (iNumSegments > 0) Begin
94739>>>
94739>>>                Move iIndex                                                     to APIIndexes[iCount].iIndexNumber
94740>>>                Get_Attribute DF_FILE_PRIMARY_INDEX of hTable                   to APIIndexes[iCount].iPrimaryIndex
94743>>>                If (bIsSQLTable = True) Begin
94745>>>                    Get_Attribute DF_INDEX_NAME         of hTable iIndex        to APIIndexes[iCount].sSQLIndexName
94748>>>                        Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to APIIndexes[iCount].bIsSQLPrimaryKey
94751>>>                        Get_Attribute DF_INDEX_CLUSTERED of hTable iIndex       to APIIndexes[iCount].bIsSQLClustered
94754>>>                        Get_Attribute DF_INDEX_SQL_TYPE of hTable iIndex        to APIIndexes[iCount].iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
94757>>>                End
94757>>>>
94757>>>
94757>>>                Move 0 to iSegmentCount
94758>>>                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
94761>>>                For iSegment from 1 to iNumSegments
94767>>>>
94767>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iSegment to iColumn
94770>>>                    Move iColumn                                                       to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].iFieldNumber
94771>>>                    Get_Attribute DF_FIELD_NAME              of hTable iColumn         to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].sFieldName
94774>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bUppercase
94777>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bAscending
94780>>>                    Increment iSegmentCount
94781>>>                Loop
94782>>>>
94782>>>                Increment iCount
94783>>>            End
94783>>>>
94783>>>        Loop
94784>>>>
94784>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
94785>>>
94785>>>        Function_Return APIIndexes
94786>>>    End_Function
94787>>>
94787>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
94787>>>    // The combined data will be sorted on the first struct member: iIndexNumber
94787>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
94787>>>    // have "holes" in the series of index numbers.
94787>>>    Function UtilIndexCombineFromAndToArrays tAPIIndex[] APIIndexFrom tAPIIndex[] APIIndexTo Returns tAPIIndexCompare[]
94789>>>        tAPIIndexCompare[] aAPIIndexCompare
94789>>>        tAPIIndexCompare[] aAPIIndexCompare
94790>>>        tAPIIndexCompare   APIIndexCompare
94790>>>        tAPIIndexCompare   APIIndexCompare
94790>>>        Integer iSizeFrom iSizeTo iSize iCount iItem iIndexFrom iIndexTo
94790>>>
94790>>>        Move (SizeOfArray(APIIndexFrom)) to iSizeFrom
94791>>>        Move (SizeOfArray(APIIndexTo)) to iSizeTo
94792>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
94794>>>            Function_Return aAPIIndexCompare
94795>>>        End
94795>>>>
94795>>>
94795>>>        Decrement iSizeFrom
94796>>>        for iCount from 0 to iSizeFrom
94802>>>>
94802>>>            Move APIIndexFrom[iCount].iIndexNumber      to aAPIIndexCompare[iCount].iIndexNumber
94803>>>            Move APIIndexFrom[iCount].iPrimaryIndex     to aAPIIndexCompare[iCount].iPrimaryIndexFrom
94804>>>            Move APIIndexFrom[iCount].sSQLIndexName     to aAPIIndexCompare[iCount].sSQLIndexNameFrom
94805>>>            Move APIIndexFrom[iCount].iSQLIndexType     to aAPIIndexCompare[iCount].iSQLIndexTypeFrom
94806>>>            Move APIIndexFrom[iCount].bIsSQLClustered   to aAPIIndexCompare[iCount].bIsSQLClusteredFrom
94807>>>            Move APIIndexFrom[iCount].bIsSQLPrimaryKey  to aAPIIndexCompare[iCount].bIsSQLPrimaryKeyFrom
94808>>>            Move APIIndexFrom[iCount].IndexSegmentArray to aAPIIndexCompare[iCount].IndexSegmentArrayFrom
94809>>>            Move APIIndexFrom[iCount].bShouldChange     to aAPIIndexCompare[iCount].bShouldChangeFrom
94810>>>            Move APIIndexFrom[iCount].bCancel           to aAPIIndexCompare[iCount].bCancelFrom
94811>>>            Move APIIndexFrom[iCount].bError            to aAPIIndexCompare[iCount].bErrorFrom
94812>>>            Move True                                   to aAPIIndexCompare[iCount].bExistsFrom
94813>>>        Loop
94814>>>>
94814>>>
94814>>>        Decrement iSizeTo
94815>>>        for iCount from 0 to iSizeTo
94821>>>>
94821>>>            Move APIIndexTo[iCount].iIndexNumber        to APIIndexCompare.iIndexNumber
94822>>>            // Search if the Index number already exists in the array; else add it.
94822>>>            Move (SearchArray(APIIndexCompare, aAPIIndexCompare)) to iItem
94823>>>            If (iItem = -1) Begin
94825>>>                Move (SizeOfArray(aAPIIndexCompare))    to iItem
94826>>>            End
94826>>>>
94826>>>
94826>>>            Move APIIndexCompare.iIndexNumber           to aAPIIndexCompare[iItem].iIndexNumber
94827>>>            Move APIIndexTo[iCount].iPrimaryIndex       to aAPIIndexCompare[iItem].iPrimaryIndexTo
94828>>>            Move APIIndexTo[iCount].sSQLIndexName       to aAPIIndexCompare[iItem].sSQLIndexNameTo
94829>>>            Move APIIndexTo[iCount].iSQLIndexType       to aAPIIndexCompare[iItem].iSQLIndexTypeTo
94830>>>            Move APIIndexTo[iCount].bIsSQLClustered     to aAPIIndexCompare[iItem].bIsSQLClusteredTo
94831>>>            Move APIIndexTo[iCount].bIsSQLPrimaryKey    to aAPIIndexCompare[iItem].bIsSQLPrimaryKeyTo
94832>>>            Move APIIndexTo[iCount].IndexSegmentArray   to aAPIIndexCompare[iItem].IndexSegmentArrayTo
94833>>>            Move APIIndexTo[iCount].bShouldChange       to aAPIIndexCompare[iItem].bShouldChangeTo
94834>>>            Move APIIndexTo[iCount].bCancel             to aAPIIndexCompare[iItem].bCancelTo
94835>>>            Move APIIndexTo[iCount].bError              to aAPIIndexCompare[iItem].bErrorTo
94836>>>            Move True                                   to aAPIIndexCompare[iItem].bExistsTo
94837>>>        Loop
94838>>>>
94838>>>
94838>>>        Move (SortArray(aAPIIndexCompare)) to aAPIIndexCompare
94839>>>
94839>>>        Function_Return aAPIIndexCompare
94840>>>    End_Function
94841>>>
94841>>>    // This is the same as the UtilIndexCompare function but it takes tAPIIndex structs as params.
94841>>>    Function UtilIndexTypeNumberCompare Handle hTable tAPIIndex aIndexFrom tAPIIndex aIndexTo Returns Boolean
94843>>>        Boolean bIsSame bDAWSQLDriver bIsSqlTable
94843>>>        String sDriverID
94843>>>        Integer iSegment
94843>>>        
94843>>>        Get psDriverID to sDriverID
94844>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
94845>>>        Get IsSQLDriver sDriverID to bIsSqlTable
94846>>>        If (bIsSqlTable = True) Begin
94848>>>            Get UtilTableIsSQL hTable to bIsSqlTable
94849>>>        End
94849>>>>
94849>>>
94849>>>        Move (aIndexFrom.iIndexNumber = aIndexTo.iIndexNumber) to bIsSame
94850>>>        If (bIsSame = False) Begin
94852>>>            Function_Return False
94853>>>        End
94853>>>>
94853>>>
94853>>>        If (bDAWSQLDriver = True and bIsSqlTable = True) Begin
94855>>>            // Don't think we should do this. Or should we?
94855>>>            // Move (aIndexesFrom[iCount].sSQLIndexName = aIndexesTo[iCount].sSQLIndexName) to bIsSame
94855>>>
94855>>>            Move (aIndexFrom.iSQLIndexType = aIndexTo.iSQLIndexType) to bIsSame
94856>>>            If (bIsSame = False) Begin
94858>>>                Function_Return False
94859>>>            End    
94859>>>>
94859>>>            Move (aIndexFrom.iPrimaryIndex = aIndexTo.iPrimaryIndex) to bIsSame
94860>>>            If (bIsSame = False) Begin
94862>>>                Function_Return False
94863>>>            End
94863>>>>
94863>>>            Move (aIndexFrom.bIsSQLPrimaryKey = aIndexTo.bIsSQLPrimaryKey) to bIsSame
94864>>>            If (bIsSame = False) Begin
94866>>>                Function_Return False
94867>>>            End                      
94867>>>>
94867>>>            Move (aIndexFrom.bIsSQLClustered = aIndexTo.bIsSQLClustered) to bIsSame
94868>>>            If (bIsSame = False) Begin
94870>>>                Function_Return False
94871>>>            End                      
94871>>>>
94871>>>        End
94871>>>>
94871>>>        
94871>>>        Function_Return bIsSame
94872>>>    End_Function
94873>>>
94873>>>    // DF_INDEX_SQL_TYPE values
94873>>>    // Pass one of the DF_INDEX_XXX integer constants and the function
94873>>>    // returns a string with the name.
94873>>>    Function UtilIndexTypeToString Integer iIndexType Returns String
94875>>>        String sRetval
94875>>>        Case Begin
94875>>>            Case (iIndexType = DF_INDEX_CLIENT)
94877>>>                Move "DF_INDEX_CLIENT" to sRetval
94878>>>                Case Break
94879>>>            Case (iIndexType = DF_INDEX_SERVER)
94882>>>                Move "DF_INDEX_SERVER" to sRetval
94883>>>                Case Break
94884>>>            Case (iIndexType = DF_INDEX_SERVER_ONLY)
94887>>>                Move "DF_INDEX_SERVER_ONLY" to sRetval
94888>>>                Case Break
94889>>>            Case (iIndexType = DF_INDEX_TEMPORARY)
94892>>>                Move "DF_INDEX_TEMPORARY" to sRetval
94893>>>                Case Break
94894>>>            Case Else
94894>>>                Move "UNKNOWN INDEX TYPE" to sRetval
94895>>>        Case End
94895>>>        Function_Return sRetval
94896>>>    End_Function
94897>>>
94897>>>    // * Dummy function for the Studio's Code Explorer *
94897>>>    Function API_RELATION_UTILITY_FUNCTIONS Returns Boolean
94899>>>        Function_Return False
94900>>>    End_Function
94901>>>
94901>>>    // Compares multiple relationships for a 'FROM' and a 'TO' databases
94901>>>    Function UtilRelationsCompare Handle hTable tAPIRelationCompare[] aAPIRelationCompare Returns Boolean
94903>>>        Boolean bIsSame
94903>>>        Integer iSize iCount
94903>>>
94903>>>        Move True to bIsSame
94904>>>        Move (SizeOfArray(aAPIRelationCompare)) to iSize
94905>>>        Decrement iSize
94906>>>        For iCount from 0 to iSize
94912>>>>
94912>>>            Get UtilRelationCompare hTable aAPIRelationCompare[iCount] to bIsSame
94913>>>            If (bIsSame = False) Begin
94915>>>                Function_Return False
94916>>>            End
94916>>>>
94916>>>        Loop
94917>>>>
94917>>>
94917>>>        Function_Return bIsSame
94918>>>    End_Function
94919>>>
94919>>>    // Compares a single relationship for a 'FROM' and a 'TO' table
94919>>>    Function UtilRelationCompare Handle hTable tAPIRelationCompare APIRelationCompare Returns Boolean
94921>>>        Boolean bIsSame
94921>>>
94921>>>        Move True to bIsSame
94922>>>        If (APIRelationCompare.bExistsFrom <> APIRelationCompare.bExistsTo) Begin
94924>>>            Function_Return False
94925>>>        End
94925>>>>
94925>>>        If (APIRelationCompare.hTableFrom = 0 or APIRelationCompare.hTableTo = 0) Begin
94927>>>            Function_Return False
94928>>>        End
94928>>>>
94928>>>
94928>>>        // We could also compare field names, but I don't think that is necessary...
94928>>>
94928>>>        Function_Return bIsSame
94929>>>    End_Function
94930>>>
94930>>>    // This message is different from ApiTableCreate in that it will not do a function_return if the table
94930>>>    // already exists. 
94930>>>    Function UtilRelationsUpdate Handle hTable tAPIRelation[] aRelationsFrom tAPIRelation[] aRelationsTo Returns Boolean
94932>>>        Boolean bIsSame bOK
94932>>>        Integer iSizeTo iSize iCount iColumn
94932>>>        String sDriverID
94932>>>        
94932>>>        Move True to bOK                                                                                
94933>>>        Move (SizeOfArray(aRelationsTo))   to iSizeTo
94934>>>        If (iSizeTo > 0) Begin
94936>>>            Get AutoConnectionIDLogin to bOK
94937>>>            Move False to Err
94938>>>            Open hTable Mode DF_EXCLUSIVE
94940>>>            Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
94943>>>            Decrement iSizeTo
94944>>>
94944>>>            // We should probably not make any comparison between "FROM" and "TO" database; instead just create all "FROM" relations
94944>>>            // for the "TO" database. But start by deleting all current "TO" relations:
94944>>>            Structure_Start hTable sDriverID            
94945>>>                for iCount from 0 to iSizeTo                                                
94951>>>>
94951>>>                    Move aRelationsTo[iCount].iColumnFrom to iColumn
94952>>>                    Set_Attribute DF_FIELD_RELATED_FILE  of hTable iColumn to 0
94955>>>                    Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn to 0
94958>>>                End
94959>>>>
94959>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
94960>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
94962>>>            Set Action_Text of ghoStatusPanel to ""
94963>>>        End
94963>>>>
94963>>>
94963>>>        Move (SizeOfArray(aRelationsFrom)) to iSize
94964>>>        Decrement iSize
94965>>>        for iCount from 0 to iSize
94971>>>>
94971>>>            Get ApiTableRelate aRelationsFrom[iCount].hTableFrom aRelationsFrom[iCount].hTableTo aRelationsFrom[iCount].iColumnFrom aRelationsFrom[iCount].iColumnTo aRelationsTo to bOK
94972>>>        Loop
94973>>>>
94973>>>
94973>>>        Function_Return bOK
94974>>>    End_Function
94975>>>
94975>>>    Function UtilRelationsStructFill Handle hTable Returns tAPIRelation[]
94977>>>        tAPIRelation[] APIRelations
94977>>>        tAPIRelation[] APIRelations
94978>>>        Integer iColumn iColumnTo iNumColumns iCount
94978>>>        Handle hParent
94978>>>        Boolean bIsOpen
94978>>>
94978>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
94979>>>        Move 0 to iCount
94980>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
94983>>>        If (bIsOpen = False) Begin
94985>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
94986>>>            Open hTable
94988>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
94989>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
94992>>>            If (bIsOpen = False) Begin
94994>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
94995>>>                Move True to APIRelations[0].bError
94996>>>                Function_Return APIRelations
94997>>>            End
94997>>>>
94997>>>        End
94997>>>>
94997>>>
94997>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
95000>>>        For iColumn from 1 to iNumColumns
95006>>>>
95006>>>            Get_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to hParent
95009>>>            If (hParent <> 0) Begin
95011>>>                Open hParent
95013>>>                Move hTable                                             to APIRelations[iCount].hTableFrom
95014>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable            to APIRelations[iCount].sLogicalNameFrom
95017>>>                Move iColumn                                            to APIRelations[iCount].iColumnFrom
95018>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn           to APIRelations[iCount].sFieldNameFrom
95021>>>
95021>>>                Move hParent                                            to APIRelations[iCount].hTableTo
95022>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hParent           to APIRelations[iCount].sLogicalNameTo
95025>>>                Get_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn  to iColumnTo
95028>>>                Move iColumnTo                                          to APIRelations[iCount].iColumnTo
95029>>>                Get_Attribute DF_FIELD_NAME of hParent iColumnTo        to APIRelations[iCount].sFieldNameTo
95032>>>                Move False                                              to APIRelations[iCount].bShouldChange
95033>>>                Move False                                              to APIRelations[iCount].bCancel
95034>>>                Move False                                              to APIRelations[iCount].bError
95035>>>                Close hParent
95036>>>                Increment iCount
95037>>>            End
95037>>>>
95037>>>        Loop
95038>>>>
95038>>>
95038>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
95039>>>        Function_Return APIRelations
95040>>>    End_Function
95041>>>
95041>>>    Function UtilRelationArrayCompare tAPIRelation RelationCurrent tAPIRelation RelationNew Returns Integer
95043>>>        If (RelationCurrent.hTableFrom  = RelationNew.hTableFrom and ;            RelationCurrent.iColumnFrom = RelationNew.iColumnFrom and ;            RelationCurrent.hTableTo    = RelationNew.hTableTo and ;            RelationCurrent.iColumnTo   = RelationNew.iColumnTo) Begin
95045>>>            Function_Return (EQ)
95046>>>        End
95046>>>>
95046>>>
95046>>>        Function_Return (GT)
95047>>>    End_Function
95048>>>
95048>>>    Function SearchRelationCompare tAPIRelationCompare RelationCompareCurrent tAPIRelationCompare RelationCompareNew Returns Integer
95050>>>        If (RelationCompareCurrent.hTableFrom  = RelationCompareNew.hTableFrom and ;            RelationCompareCurrent.iColumnFrom = RelationCompareNew.iColumnFrom and ;            RelationCompareCurrent.hTableTo    = RelationCompareNew.hTableTo and ;            RelationCompareCurrent.iColumnTo   = RelationCompareNew.iColumnTo) ;            Function_Return (EQ)
95053>>>
95053>>>        Function_Return (GT)
95054>>>    End_Function
95055>>>
95055>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
95055>>>    // The combined data will be sorted on the first 4 struct members: hTableFrom, iColumnFrom, hTableTo and iColumnTo
95055>>>    Function UtilRelationCombineFromAndToArrays tAPIRelation[] aAPIRelationFrom tAPIRelation[] aAPIRelationTo Returns tAPIIndexCompare[]
95057>>>        tAPIRelation[] aAPIRelationFromAndTo
95057>>>        tAPIRelation[] aAPIRelationFromAndTo
95058>>>        tAPIRelationCompare[] aAPIRelationCompare
95058>>>        tAPIRelationCompare[] aAPIRelationCompare
95059>>>        tAPIRelationCompare   APIRelationCompare
95059>>>        tAPIRelationCompare   APIRelationCompare
95059>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
95059>>>
95059>>>        Move (SizeOfArray(aAPIRelationFrom)) to iSizeFrom
95060>>>        Move (SizeOfArray(aAPIRelationTo))   to iSizeTo
95061>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
95063>>>            Function_Return aAPIRelationCompare
95064>>>        End
95064>>>>
95064>>>
95064>>>        Move (AppendArray(aAPIRelationFrom, aAPIRelationTo)) to aAPIRelationFromAndTo
95065>>>        Move (SortArray(aAPIRelationFromAndTo, Self, RefFunc(UtilRelationArrayCompare))) to aAPIRelationFromAndTo
95066>>>
95066>>>        Decrement iSizeFrom
95067>>>        for iCount from 0 to iSizeFrom
95073>>>>
95073>>>            Move aAPIRelationFrom[iCount].hTableFrom        to aAPIRelationCompare[iCount].hTableFrom
95074>>>            Move aAPIRelationFrom[iCount].iColumnFrom       to aAPIRelationCompare[iCount].iColumnFrom
95075>>>            Move aAPIRelationFrom[iCount].hTableTo          to aAPIRelationCompare[iCount].hTableTo
95076>>>            Move aAPIRelationFrom[iCount].iColumnTo         to aAPIRelationCompare[iCount].iColumnTo
95077>>>            Move aAPIRelationFrom[iCount].sLogicalNameFrom  to aAPIRelationCompare[iCount].sLogicalNameFrom_From
95078>>>            Move aAPIRelationFrom[iCount].sLogicalNameTo    to aAPIRelationCompare[iCount].sLogicalNameTo_From
95079>>>            Move aAPIRelationFrom[iCount].sFieldNameFrom    to aAPIRelationCompare[iCount].sFieldNameFrom_From
95080>>>            Move aAPIRelationFrom[iCount].sFieldNameTo      to aAPIRelationCompare[iCount].sFieldNameTo_From
95081>>>            Move aAPIRelationFrom[iCount].bShouldChange     to aAPIRelationCompare[iCount].bShouldChange_From
95082>>>            Move aAPIRelationFrom[iCount].bCancel           to aAPIRelationCompare[iCount].bCancel_From
95083>>>            Move aAPIRelationFrom[iCount].bError            to aAPIRelationCompare[iCount].bError_From
95084>>>            Move True                                       to aAPIRelationCompare[iCount].bExistsFrom
95085>>>        Loop
95086>>>>
95086>>>
95086>>>        Decrement iSizeTo
95087>>>        for iCount from 0 to iSizeTo
95093>>>>
95093>>>            Move aAPIRelationTo[iCount].hTableFrom          to APIRelationCompare.hTableFrom
95094>>>            Move aAPIRelationTo[iCount].iColumnFrom         to APIRelationCompare.iColumnFrom
95095>>>            Move aAPIRelationTo[iCount].hTableTo            to APIRelationCompare.hTableTo
95096>>>            Move aAPIRelationTo[iCount].iColumnTo           to APIRelationCompare.iColumnTo
95097>>>
95097>>>            // Search if the relation already exists in the array; else add it.
95097>>>            Move (SearchArray(APIRelationCompare, aAPIRelationCompare, Self, RefFunc(SearchRelationCompare))) to iItem
95098>>>            If (iItem = -1) Begin
95100>>>                Move (SizeOfArray(aAPIRelationCompare))     to iItem
95101>>>            End
95101>>>>
95101>>>
95101>>>            Move APIRelationCompare.hTableFrom              to aAPIRelationCompare[iItem].hTableFrom
95102>>>            Move APIRelationCompare.iColumnFrom             to aAPIRelationCompare[iItem].iColumnFrom
95103>>>            Move APIRelationCompare.hTableTo                to aAPIRelationCompare[iItem].hTableTo
95104>>>            Move APIRelationCompare.iColumnTo               to aAPIRelationCompare[iItem].iColumnTo
95105>>>            Move aAPIRelationTo[iCount].sLogicalNameFrom    to aAPIRelationCompare[iItem].sLogicalNameFrom_To
95106>>>            Move aAPIRelationTo[iCount].sLogicalNameTo      to aAPIRelationCompare[iItem].sLogicalNameTo_To
95107>>>            Move aAPIRelationTo[iCount].sFieldNameFrom      to aAPIRelationCompare[iItem].sFieldNameFrom_To
95108>>>            Move aAPIRelationTo[iCount].sFieldNameTo        to aAPIRelationCompare[iItem].sFieldNameTo_To
95109>>>            Move aAPIRelationTo[iCount].bShouldChange       to aAPIRelationCompare[iItem].bShouldChange_To
95110>>>            Move aAPIRelationTo[iCount].bCancel             to aAPIRelationCompare[iItem].bCancel_To
95111>>>            Move aAPIRelationTo[iCount].bError              to aAPIRelationCompare[iItem].bError_To
95112>>>            Move True                                       to aAPIRelationCompare[iItem].bExistsTo
95113>>>        Loop
95114>>>>
95114>>>
95114>>>        Move (SortArray(aAPIRelationCompare, Self, RefFunc(SearchRelationCompare))) to aAPIRelationCompare
95115>>>
95115>>>        Function_Return aAPIRelationCompare
95116>>>    End_Function
95117>>>
95117>>>    // * Dummy function for the Studio's Code Explorer *
95117>>>    Function CODEMAST_UTILITY_FUNCTIONS Returns Boolean
95119>>>        Function_Return False
95120>>>    End_Function
95121>>>
95121>>>    // To add a value to the CodeMast & CodeType tables. Pass; a) bCodeType if it is CodeType that should be updated.
95121>>>    // Else it is CodeMast. b) sTypeValue; either to be added If bCodeType = True, or it will be used to find the correct
95121>>>    // CodeType record. c) sValue1 and d) sValue2 is the CodeType Description & Comment, or CodeMast Type and Code values.
95121>>>    Function UtilCodeMasterAddValue Boolean bCodeType String sTypeValue String sValue2 String sValue3 Returns Boolean
95123>>>        Boolean bFound
95123>>>
95123>>>        Move False to Err
95124>>>        Open CodeMast
95126>>>        Open CodeType
95128>>>
95128>>>        If (bCodeType = True) Begin
95130>>>            Clear CodeType
95131>>>            Move sTypeValue to CODETYPE.Type
95132>>>            Find eq CODETYPE.Type
95133>>>>
95133>>>            Move (Found = True) to bFound
95134>>>            If (bFound = True) Begin
95136>>>                Reread CodeType
95140>>>            End
95140>>>>
95140>>>            If (bFound = False) Begin
95142>>>                Clear CodeType
95143>>>            End
95143>>>>
95143>>>                Move sTypeValue to CODETYPE.Type
95144>>>                Move sValue2    to CODETYPE.Description
95145>>>                Move sValue3    to CODETYPE.Comment
95146>>>                SaveRecord CODETYPE
95147>>>            If (bFound = True) Begin
95149>>>                Unlock
95150>>>>
95150>>>            End
95150>>>>
95150>>>        End
95150>>>>
95150>>>
95150>>>        If (bCodeType = False) Begin
95152>>>            Clear CODEMAST
95153>>>            Move sTypeValue to CODEMAST.Type
95154>>>            Move sValue2    to CODEMAST.Code
95155>>>            Find eq CODEMAST.Code
95156>>>>
95156>>>            Move (Found = True) to bFound
95157>>>            If (bFound = True) Begin
95159>>>                Reread CODEMAST
95163>>>            End
95163>>>>
95163>>>            If (bFound = False) Begin
95165>>>                Clear CODEMAST
95166>>>            End
95166>>>>
95166>>>                Move sTypeValue to CODEMAST.Type
95167>>>                Move sValue2    to CODEMAST.Code
95168>>>                Move sValue3    to CODEMAST.Description
95169>>>                SaveRecord CODEMAST
95170>>>            If (bFound = True) Begin
95172>>>            Unlock
95173>>>>
95173>>>            End
95173>>>>
95173>>>        End
95173>>>>
95173>>>
95173>>>        Close CodeMast
95174>>>        Close CodeType
95175>>>
95175>>>        Function_Return (Err = False)
95176>>>    End_Function
95177>>>
95177>>>    // Changes values in CodeType & CodeMast - From type value To type value. It first changes the type value in
95177>>>    // CodeType and then spins through all CodeMast records to change all related records.
95177>>>    Function UtilCodeMasterChangeValue String sFromValue String sToValue Returns Boolean
95179>>>        Boolean bFound
95179>>>
95179>>>        Move False to Err
95180>>>        Open CodeMast
95182>>>        Open CodeType
95184>>>
95184>>>        Clear CodeType
95185>>>        Move sFromValue to CODETYPE.Type
95186>>>        Find eq CODETYPE.Type
95187>>>>
95187>>>        If (Found = True) Begin
95189>>>            Reread CODETYPE
95193>>>                Move sToValue to CODETYPE.Type
95194>>>                SaveRecord CODETYPE
95195>>>            Unlock
95196>>>>
95196>>>        End
95196>>>>
95196>>>
95196>>>        Clear CODEMAST
95197>>>        Find gt CODEMAST by Recnum
95198>>>>
95198>>>        While (Found = True)
95202>>>            Move (Trim(Uppercase(CODEMAST.Type) = Trim(Uppercase(sFromValue)))) to bFound
95203>>>            If (bFound = True) Begin
95205>>>                Reread CODEMAST
95209>>>                    Move sToValue to CODEMAST.Type
95210>>>                    SaveRecord CODEMAST
95211>>>                Unlock
95212>>>>
95212>>>            End
95212>>>>
95212>>>            Find gt CODEMAST by Recnum
95213>>>>
95213>>>        Loop
95214>>>>
95214>>>
95214>>>        Close CodeMast
95215>>>        Close CodeType
95216>>>
95216>>>        Function_Return (Err = False)
95217>>>    End_Function
95218>>>
95218>>>    // Removes a value from CodeMast. Pass the sTypeValue and the sValue2 to remove.
95218>>>    Function UtilCodeMasterRemoveValue String sTypeValue String sValue2 Returns Boolean
95220>>>        Boolean bFound
95220>>>
95220>>>        Move False to Err
95221>>>        Open CodeMast
95223>>>
95223>>>        Clear CODEMAST
95224>>>        Move sTypeValue to CODEMAST.Type
95225>>>        Move sValue2    to CODEMAST.Code
95226>>>        Find eq CODEMAST.Code
95227>>>>
95227>>>        Move (Found = True) to bFound
95228>>>        If (bFound = True) Begin
95230>>>            Delete CODEMAST
95231>>>        End
95231>>>>
95231>>>
95231>>>        Close CodeMast
95232>>>
95232>>>        Function_Return (Err = False)
95233>>>    End_Function
95234>>>
95234>>>    Function UtilTableCreateCodeMastCodeTypeIntFiles String sDataPath Returns Boolean
95236>>>        Boolean bRecnum bToAnsi
95236>>>        Integer iCh
95236>>>        String sFileName sDriverID sConnectionID sSchemaName sANSI_OEM
95236>>>
95236>>>        If (Trim(sDataPath) = "") Begin
95238>>>            Function_Return False
95239>>>        End
95239>>>>
95239>>>
95239>>>        Move False to Err
95240>>>        Get psDriverID     to sDriverID
95241>>>        Get psConnectionID to sConnectionID
95242>>>        Get psSchema       to sSchemaName
95243>>>        Get True           to bRecnum
95244>>>        Get pbToANSI       to bToAnsi
95245>>>        Move CS_ANSI_Txt to sANSI_OEM
95246>>>        If (bToAnsi = False) Begin
95248>>>            Move CS_OEM_Txt to sANSI_OEM
95249>>>        End
95249>>>>
95249>>>
95249>>>        Get vFolderFormat sDataPath to sDataPath
95250>>>        Move "CodeMast.int"         to sFileName
95251>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
95252>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
95255>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
95258>>>            Writeln channel iCh ("DATABASE_NAME CODEMAST")
95261>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
95264>>>            Writeln channel iCh ("")
95267>>>            Writeln channel iCh ("RECNUM_TABLE YES")
95270>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
95273>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
95276>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
95279>>>            Writeln channel iCh ("")
95282>>>            Writeln channel iCh ("INDEX_NUMBER 1")
95285>>>            Writeln channel iCh ("INDEX_NAME CODEMAST001_PK")
95288>>>            Writeln channel iCh ("")
95291>>>        Send Seq_Close_Channel iCh
95292>>>
95292>>>        Get vFolderFormat sDataPath to sDataPath
95293>>>        Move "CodeType.int"         to sFileName
95294>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
95295>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
95298>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
95301>>>            Writeln channel iCh ("DATABASE_NAME CODETYPE")
95304>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
95307>>>            Writeln channel iCh ("")
95310>>>            Writeln channel iCh ("RECNUM_TABLE YES")
95313>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
95316>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
95319>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
95322>>>            Writeln channel iCh ("")
95325>>>            Writeln channel iCh ("INDEX_NUMBER 0")
95328>>>            Writeln channel iCh ("INDEX_NAME CODETYPE000")
95331>>>            Writeln channel iCh ("")
95334>>>            Writeln channel iCh ("INDEX_NUMBER 1")
95337>>>            Writeln channel iCh ("INDEX_NAME CODETYPE001_PK")
95340>>>            Writeln channel iCh ("")
95343>>>        Send Seq_Close_Channel iCh
95344>>>
95344>>>        Function_Return (Err = False)
95345>>>    End_Function
95346>>>
95346>>>    // * Dummy function for the Studio's Code Explorer *
95346>>>    Function OTHER_UTILITY_FUNCTIONS Returns Boolean
95348>>>        Function_Return False
95349>>>    End_Function
95350>>>
95350>>>    // Check if the file exists in the Data folder,
95350>>>    // else creates it from memory as it has been compiled into the program as a resource:
95350>>>    Function UtilCheckCreateIfFileExists String sFileName String sResourceName Boolean bDataFile Returns Boolean
95352>>>        String sPath sDataPath
95352>>>        Boolean bExists
95352>>>
95352>>>        Get psDataPathFirstPart to sPath
95353>>>        Move (sPath + sFileName) to sFileName
95354>>>        Get vFilePathExists sFileName to bExists
95355>>>
95355>>>        If (bExists = False) Begin
95357>>>            // Read from memory & create file on disk.
95357>>>            Send SqlUtilCreateFileFromMemory sResourceName sFileName
95358>>>            Get vFilePathExists sFileName to bExists
95359>>>        End
95359>>>>
95359>>>        Function_Return bExists
95360>>>    End_Function
95361>>>
95361>>>    Function UtilSqlColumnTypeToDataFlexType String sDriverID Integer iDbType Integer iDataType Integer iLength Returns Integer
95363>>>        tColumnType RetvalType
95363>>>        tColumnType RetvalType
95363>>>        Integer iRetval
95363>>>
95363>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
95364>>>        Move RetvalType.iDataFlexType to iRetval
95365>>>        If (RetvalType.iDataFlexType = DF_TEXT) Begin
95367>>>            If (iLength <= 255) Begin
95369>>>                Move DF_ASCII to iRetval
95370>>>            End
95370>>>>
95370>>>        End
95370>>>>
95370>>>        Function_Return iRetval
95371>>>    End_Function       
95372>>>    
95372>>>    Function UtilDataFlexDataTypeToString Integer iDataType Returns String
95374>>>        String sRetval 
95374>>>
95374>>>        Case Begin
95374>>>            Case (iDataType = DF_ASCII)
95376>>>                Move "DF_ASCII" to sRetval
95377>>>                Case Break
95378>>>            Case (iDataType = DF_BCD)
95381>>>                Move "DF_BCD" to sRetval
95382>>>                Case Break
95383>>>            Case (iDataType = DF_BINARY)
95386>>>                Move "DF_BINARY" to sRetval
95387>>>                Case Break
95388>>>            Case (iDataType = DF_DATE)
95391>>>                Move "DF_DATE" to sRetval
95392>>>                Case Break
95393>>>            Case (iDataType = DF_DATETIME)
95396>>>                Move "DF_DATETIME" to sRetval
95397>>>                Case Break
95398>>>            Case (iDataType = DF_TEXT)
95401>>>                Move "DF_TEXT" to sRetval
95402>>>                Case Break
95403>>>            Case Else
95403>>>                Move "" to sRetval
95404>>>        Case End
95404>>>
95404>>>        Function_Return sRetval
95405>>>    End_Function
95406>>>
95406>>>    // The default value used for a datatype as specified in the driver int file.
95406>>>    Function UtilDataTypeDefaultValue String sDriverID Integer iDbType Integer iDataType Returns String
95408>>>        String sRetval sServer
95408>>>        tColumnType RetvalType
95408>>>        tColumnType RetvalType
95408>>>        Integer iDriver iDataFlexType
95408>>>        Handle hDatabase
95408>>>
95408>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
95409>>>        Move RetvalType.iDataFlexType to iDataFlexType
95410>>>        Get DriverIndex sDriverID to iDriver
95411>>>        Get psServer to sServer
95412>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
95413>>>        If (hDatabase = 0) Begin
95415>>>            Function_Return ""
95416>>>        End
95416>>>>
95416>>>
95416>>>        Case Begin
95416>>>            Case (iDataFlexType = DF_ASCII)
95418>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_ASCII     of iDriver hDatabase to sRetval
95421>>>                Case Break
95422>>>            Case (iDataFlexType = DF_BCD)
95425>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_NUMERIC   of iDriver hDatabase to sRetval
95428>>>                Case Break
95429>>>            Case (iDataFlexType = DF_BINARY)
95432>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_BINARY    of iDriver hDatabase to sRetval
95435>>>                Case Break
95436>>>            Case (iDataFlexType = DF_DATE)
95439>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE      of iDriver hDatabase to sRetval
95442>>>                Case Break
95443>>>            Case (iDataFlexType = DF_DATETIME)
95446>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME  of iDriver hDatabase to sRetval
95449>>>                Case Break
95450>>>            Case (iDataFlexType = DF_TEXT)
95453>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_TEXT      of iDriver hDatabase to sRetval
95456>>>                Case Break
95457>>>            Case Else
95457>>>                Move "" to sRetval
95458>>>        Case End
95458>>>
95458>>>        Function_Return sRetval
95459>>>    End_Function
95460>>>
95460>>>    Procedure Set Df_Database_Default_Default_Date_DUF String sDateValue
95462>>>        String sDriverID sServer
95462>>>        tColumnType RetvalType
95462>>>        tColumnType RetvalType
95462>>>        Integer iDbType iDriver
95462>>>        Handle hDatabase
95462>>>
95462>>>        Get psDriverID to sDriverID
95463>>>        Get piDbType   to iDbType
95464>>>        Get DriverIndex sDriverID to iDriver
95465>>>        Get psServer to sServer
95466>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
95467>>>        If (hDatabase = 0) Begin
95469>>>            Error DFERR_PROGRAM "Could not change the Default Date Value. Could not get a handle to the database."
95470>>>>
95470>>>            Procedure_Return
95471>>>        End
95471>>>>
95471>>>
95471>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE of iDriver hDatabase to sDateValue
95474>>>
95474>>>    End_Procedure
95475>>>
95475>>>    Procedure Set Df_Database_Default_Default_Datetime_DUF String sDateValue
95477>>>        String sDriverID sServer
95477>>>        tColumnType RetvalType
95477>>>        tColumnType RetvalType
95477>>>        Integer iDbType iDriver
95477>>>        Handle hDatabase
95477>>>
95477>>>        Get psDriverID to sDriverID
95478>>>        Get piDbType   to iDbType
95479>>>        Get DriverIndex sDriverID to iDriver
95480>>>        Get psServer to sServer
95481>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
95482>>>        If (hDatabase = 0) Begin
95484>>>            Error DFERR_PROGRAM "Could not change the Default DateTime Value. Could not get a handle to the database."
95485>>>>
95485>>>            Procedure_Return
95486>>>        End
95486>>>>
95486>>>
95486>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME of iDriver hDatabase to sDateValue
95489>>>
95489>>>    End_Procedure
95490>>>
95490>>>    // Returns a struct array with the default column types for the SQL back-end and how they
95490>>>    // are mapped to the standard DataFlex data types.
95490>>>    // The DataFlex data types are: "ASCII", "BINARY", "DATE", "DATETIME", "NUMERIC" and "TEXT".
95490>>>    Function UtilDefaultSqlTypeMappings String sDriverID Integer iDbType Returns tColumnType[]
95492>>>        tColumnType[] ColumnTypeArray EmptyArray
95492>>>        tColumnType[] ColumnTypeArray EmptyArray
95494>>>        String sDataType
95494>>>        Integer iDataType iDriverID iCount
95494>>>        Boolean bSQLDriver
95494>>>
95494>>>        Move 0 to iCount
95495>>>        Get DriverIndex sDriverID to iDriverID
95496>>>        Get IsSQLDriver sDriverID to bSQLDriver
95497>>>        If (bSQLDriver = False) Begin
95499>>>            Function_Return EmptyArray
95500>>>        End
95500>>>>
95500>>>
95500>>>        // DF_ASCII
95500>>>        If (sDriverID = ODBC_DRV_ID) Begin
95502>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
95505>>>        End
95505>>>>
95505>>>        Else Begin
95506>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
95509>>>        End
95509>>>>
95509>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
95510>>>        Move DF_ASCII    to ColumnTypeArray[iCount].iDataFlexType
95511>>>        Move "ASCII"     to ColumnTypeArray[iCount].sDataFlexType
95512>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
95513>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
95514>>>        Increment iCount
95515>>>
95515>>>        // DF_BINARY
95515>>>        If (sDriverID = ODBC_DRV_ID) Begin
95517>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
95520>>>        End
95520>>>>
95520>>>        Else Begin
95521>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
95524>>>        End
95524>>>>
95524>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
95525>>>        Move DF_BINARY   to ColumnTypeArray[iCount].iDataFlexType
95526>>>        Move "Binary"    to ColumnTypeArray[iCount].sDataFlexType
95527>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
95528>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
95529>>>        Increment iCount
95530>>>
95530>>>        // DF_DATE
95530>>>        If (sDriverID = ODBC_DRV_ID) Begin
95532>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
95535>>>        End
95535>>>>
95535>>>        Else Begin
95536>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
95539>>>        End
95539>>>>
95539>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
95540>>>        Move DF_DATE     to ColumnTypeArray[iCount].iDataFlexType
95541>>>        Move "Date"      to ColumnTypeArray[iCount].sDataFlexType
95542>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
95543>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
95544>>>        Increment iCount
95545>>>
95545>>>        // DF_DATETIME
95545>>>        If (sDriverID = ODBC_DRV_ID) Begin
95547>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
95550>>>        End
95550>>>>
95550>>>        Else Begin
95551>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
95554>>>        End
95554>>>>
95554>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
95555>>>        Move DF_DATETIME to ColumnTypeArray[iCount].iDataFlexType
95556>>>        Move "DateTime"  to ColumnTypeArray[iCount].sDataFlexType
95557>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
95558>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
95559>>>        Increment iCount
95560>>>
95560>>>        // DF_NUMERIC
95560>>>        // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
95560>>>        // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
95560>>>        // we make them here all "Numeric"...
95560>>>        Case Begin
95560>>>            Case (sDriverID = MSSQLDRV_ID)
95562>>>                Move SQL_NUMERIC to iDataType
95563>>>                Move "numeric"   to sDataType
95564>>>                Case Break
95565>>>            Case (sDriverID = DB2_DRV_ID)
95568>>>                Move SQL_NUMERIC to iDataType
95569>>>                Move "NUMERIC"   to sDataType
95570>>>                Case Break
95571>>>            Case (sDriverID = SQLFLEX)
95574>>>                Move eSQLServer_NUMERIC to iDataType
95575>>>                Move "numeric"   to sDataType
95576>>>                Case Break
95577>>>            Case (sDriverID = MDSMySQL)
95580>>>                Move eMySQL_DECIMAL to iDataType
95581>>>                Move "decimal"   to sDataType
95582>>>                Case Break
95583>>>            Case (sDriverID = ORAFLEX)
95586>>>                Move eOracle_NUMBER to iDataType
95587>>>                Move "NUMBER"   to sDataType
95588>>>                Case Break
95589>>>            Case (sDriverID = MDSPgSQL)
95592>>>                Move ePgSQL_FLOAT4 to iDataType
95593>>>                Move "decimal"   to sDataType
95594>>>                Case Break
95595>>>            Case Else
95595>>>                Move DF_BCD      to iDataType
95596>>>                Move "Numeric"   to sDataType
95597>>>        Case End
95597>>>        Move DF_BCD      to ColumnTypeArray[iCount].iDataFlexType
95598>>>        Move "Numeric"   to ColumnTypeArray[iCount].sDataFlexType
95599>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
95600>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
95601>>>        Increment iCount
95602>>>
95602>>>        // DF_TEXT
95602>>>        If (sDriverID = ODBC_DRV_ID) Begin
95604>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
95607>>>        End
95607>>>>
95607>>>        Else Begin
95608>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
95611>>>        End
95611>>>>
95611>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
95612>>>        Move DF_TEXT     to ColumnTypeArray[iCount].iDataFlexType
95613>>>        Move "Text"      to ColumnTypeArray[iCount].sDataFlexType
95614>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
95615>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
95616>>>
95616>>>        Function_Return ColumnTypeArray
95617>>>    End_Function
95618>>>
95618>>>    Function UtilDFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
95620>>>        tColumnType[] ColumnTypeArray
95620>>>        tColumnType[] ColumnTypeArray
95621>>>        tColumnType   ColumnType
95621>>>        tColumnType   ColumnType
95621>>>        Integer iCount iSize
95621>>>
95621>>>        Get UtilDefaultSqlTypeMappings sDriverID iDbType iType to ColumnTypeArray
95622>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
95623>>>        Decrement iSize
95624>>>
95624>>>        for iCount from 0 to iSize
95630>>>>
95630>>>            If (iType = ColumnTypeArray[iCount].iDataFlexType) Begin
95632>>>                Move ColumnTypeArray[iCount].bCanEditSize   to ColumnType.bCanEditSize
95633>>>                Move ColumnTypeArray[iCount].iDataFlexType  to ColumnType.iDataFlexType
95634>>>                Move ColumnTypeArray[iCount].iSQLType       to ColumnType.iSQLType
95635>>>                Move ColumnTypeArray[iCount].sDataFlexType  to ColumnType.sDataFlexType
95636>>>                Move ColumnTypeArray[iCount].sPrecision     to ColumnType.sPrecision
95637>>>                Move ColumnTypeArray[iCount].sSQLType       to ColumnType.sSQLType
95638>>>                Move iSize to iCount
95639>>>            End
95639>>>>
95639>>>        Loop
95640>>>>
95640>>>
95640>>>        Function_Return ColumnType
95641>>>    End_Function
95642>>>
95642>>>    // Returns a struct with the default column types for the SQL back-end and how they
95642>>>    // are mapped to a DUF data type.
95642>>>    Function UtilDUFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
95644>>>        tColumnType ColumnType
95644>>>        tColumnType ColumnType
95644>>>        String sDataType
95644>>>        Integer iDriverID iCount
95644>>>
95644>>>        Move 0 to iCount
95645>>>        Get DriverIndex sDriverID to iDriverID
95646>>>
95646>>>        Case Begin
95646>>>            // DF_ASCII
95646>>>            Case (iType = DF_ASCII_DUF)
95648>>>                If (sDriverID = ODBC_DRV_ID) Begin
95650>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
95653>>>                End
95653>>>>
95653>>>                Else Begin
95654>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
95657>>>                End
95657>>>>
95657>>>                Move DF_ASCII    to ColumnType.iDataFlexType
95658>>>                Move "ASCII"     to ColumnType.sDataFlexType
95659>>>                Move sDataType   to ColumnType.sSQLType
95660>>>                Move DF_ASCII    to ColumnType.iSQLType
95661>>>                Move False       to ColumnType.bCanEditSize
95662>>>                Case Break
95663>>>
95663>>>            // DF_BINARY
95663>>>            Case (iType = DF_BINARY_DUF)
95666>>>                If (sDriverID = ODBC_DRV_ID) Begin
95668>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
95671>>>                End
95671>>>>
95671>>>                Else Begin
95672>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
95675>>>                End
95675>>>>
95675>>>                Move DF_BINARY   to ColumnType.iDataFlexType
95676>>>                Move "Binary"    to ColumnType.sDataFlexType
95677>>>                Move sDataType   to ColumnType.sSQLType
95678>>>                Move DF_BINARY   to ColumnType.iSQLType
95679>>>                Move False       to ColumnType.bCanEditSize
95680>>>                Case Break
95681>>>
95681>>>            // DF_DATE
95681>>>            Case (iType = DF_DATE_DUF)
95684>>>                If (sDriverID = ODBC_DRV_ID) Begin
95686>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
95689>>>                End
95689>>>>
95689>>>                Else Begin
95690>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
95693>>>                End
95693>>>>
95693>>>                Move DF_DATE     to ColumnType.iDataFlexType
95694>>>                Move "Date"      to ColumnType.sDataFlexType
95695>>>                Move sDataType   to ColumnType.sSQLType
95696>>>                Move DF_DATE     to ColumnType.iSQLType
95697>>>                Move True        to ColumnType.bCanEditSize
95698>>>                Case Break
95699>>>
95699>>>            // DF_DATETIME
95699>>>            Case (iType = DF_DATETIME_DUF)
95702>>>                If (sDriverID = ODBC_DRV_ID) Begin
95704>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
95707>>>                End
95707>>>>
95707>>>                Else Begin
95708>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
95711>>>                End
95711>>>>
95711>>>                Move DF_DATETIME to ColumnType.iDataFlexType
95712>>>                Move "DateTime"  to ColumnType.sDataFlexType
95713>>>                Move sDataType   to ColumnType.sSQLType
95714>>>                Move DF_DATETIME to ColumnType.iSQLType
95715>>>                Move True        to ColumnType.bCanEditSize
95716>>>                Case Break
95717>>>
95717>>>            // DF_NUMERIC
95717>>>            // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
95717>>>            // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
95717>>>            // we make them here all "Numeric"...
95717>>>            // If (sDriverID = ODBC_DRV_ID) Begin
95717>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
95717>>>            // End
95717>>>            // Else Begin
95717>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
95717>>>            // End
95717>>>            // ToDo: How should we find the best "Numeric" data type here?
95717>>>            Case (iType = DF_BCD_DUF)
95720>>>                Move DF_BCD      to ColumnType.iDataFlexType
95721>>>                Move "Numeric"   to ColumnType.sDataFlexType
95722>>>                Move "Numeric"   to ColumnType.sSQLType
95723>>>                Move SQL_NUMERIC to ColumnType.iSQLType
95724>>>                Move False       to ColumnType.bCanEditSize
95725>>>                Case Break
95726>>>
95726>>>            // DF_TEXT
95726>>>            Case (iType = DF_TEXT_DUF)
95729>>>                If (sDriverID = ODBC_DRV_ID) Begin
95731>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
95734>>>                End
95734>>>>
95734>>>                Else Begin
95735>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
95738>>>                End
95738>>>>
95738>>>                Move DF_TEXT     to ColumnType.iDataFlexType
95739>>>                Move "Text"      to ColumnType.sDataFlexType
95740>>>                Move sDataType   to ColumnType.sSQLType
95741>>>                Move DF_TEXT     to ColumnType.iSQLType
95742>>>                Move False       to ColumnType.bCanEditSize
95743>>>                Case Break
95744>>>
95744>>>            Case Else
95744>>>                Move -1999       to ColumnType.iDataFlexType
95745>>>                Move "Undefined" to ColumnType.sDataFlexType
95746>>>                Move "Undefined" to ColumnType.sSQLType
95747>>>                Move -1999       to ColumnType.iSQLType
95748>>>                Move True        to ColumnType.bCanEditSize
95749>>>
95749>>>        Case End
95749>>>
95749>>>        Function_Return ColumnType
95750>>>    End_Function
95751>>>
95751>>>    Function UtilDeleteCacheFile String sTableName Returns Boolean
95753>>>        String sDataPath sDriverID
95753>>>        Boolean bMertechDriver bOK
95753>>>        Integer iPos
95753>>>
95753>>>        If (sTableName contains ".") Begin
95755>>>            Move (Pos(".", sTableName)) to iPos
95756>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
95757>>>        End
95757>>>>
95757>>>
95757>>>        Get psDriverID to sDriverID
95758>>>        Get psDataPathFirstPart to sDataPath
95759>>>        Get IsMertechDriver sDriverID to bMertechDriver
95760>>>        // First delete the cache file:
95760>>>        If (bMertechDriver = False) Begin
95762>>>            Get vDeleteFile (sDataPath + sTableName + ".cch") to bOK
95763>>>        End
95763>>>>
95763>>>        Else Begin
95764>>>            Get _MertechDeleteTDFile sTableName to bOK
95765>>>        End
95765>>>>
95765>>>
95765>>>        Function_Return bOK
95766>>>    End_Function
95767>>>
95767>>>    // Changes source code files.
95767>>>    // Pass a file name with full path and a value to search for, together with the value
95767>>>    // to change to. Can e.g. be used for changing all .int files from using a fixed server name,
95767>>>    // to use a Connection ID.
95767>>>    // Sample: Get UtilChangeSourceCodeLine "C:\DataFlex 18.2 Examples\Order Entry\Data\Order.int" "SERVER_NAME SERVER=(local)\SQLEXPRESS1" "SERVER_NAME DFCONNID=ChinookDb"
95767>>>    // Pass "True" for the bShowResult if you want to see the result while it works. Showln will then be used for output
95767>>>    // Returns True if no errors occured.
95767>>>    Function UtilChangeSourceCodeLine String sFileName String sChangeFrom String sChangeTo Boolean bShowResult Returns Boolean
95769>>>        Integer iCh iRow iItems iCount
95769>>>        String sValue sRow
95769>>>        String[] sFileArray
95770>>>        Boolean bExists bIsActive
95770>>>
95770>>>        Move False to Err
95771>>>        Move 0 to iRow
95772>>>
95772>>>        If (ghoStatusPanel <> 0) Begin
95774>>>            Get Active_state of ghoStatusPanel to bIsActive
95775>>>        End
95775>>>>
95775>>>
95775>>>        Get vFilePathExists sFileName to bExists
95776>>>        If (bExists = False) Begin
95778>>>            If (bShowResult = True) Begin
95780>>>                If (bIsActive = True) Begin
95782>>>                    Send Update_StatusPanel of ghoStatusPanel ("File does not exist:" * String(sFileName))
95783>>>                End
95783>>>>
95783>>>                Else Begin
95784>>>                    Showln "File does not exist: " sFileName
95787>>>                End
95787>>>>
95787>>>            End
95787>>>>
95787>>>            Function_Return False
95788>>>        End
95788>>>>
95788>>>
95788>>>        Get Seq_Open_Input_Channel sFileName to iCh
95789>>>        If (iCh < 1) Begin
95791>>>            Function_Return False
95792>>>        End
95792>>>>
95792>>>
95792>>>        If (bShowResult = True) Begin
95794>>>            If (ghoStatusPanel <> 0) Begin
95796>>>                Get Active_state of ghoStatusPanel to bIsActive
95797>>>                If (bIsActive = True) Begin
95799>>>                    Set Message_Text of ghoStatusPanel to sFileName
95800>>>                    Send Update_StatusPanel of ghoStatusPanel ("sChangeFrom =" * String(sChangeFrom) * "sChangeTo =" * String(sChangeTo))
95801>>>                    Send DoAdvance of ghoProgressBar
95802>>>                End
95802>>>>
95802>>>            End
95802>>>>
95802>>>            Else Begin
95803>>>                Showln ""
95805>>>                Showln "sFileName = " sFileName
95808>>>                Showln "sChangeFrom = " sChangeFrom " sChangeTo = " sChangeTo
95813>>>            End
95813>>>>
95813>>>        End
95813>>>>
95813>>>
95813>>>        While (not(SeqEof))
95817>>>            Readln channel iCh sRow
95819>>>            If (Uppercase(sRow) contains Uppercase(sChangeFrom)) Begin
95821>>>//                If (bShowResult = True) Begin
95821>>>//                    If (bIsActive = True) Begin
95821>>>//                        Send Update_StatusPanel of ghoStatusPanel ("Changed from:" * String(sRow) * "to:" * String(sChangeTo))
95821>>>//                    End
95821>>>//                    Else Begin
95821>>>//                        Showln "Changed from: " sRow " to: " sChangeTo
95821>>>//                    End
95821>>>//                End
95821>>>                // Change the whole line to the new connection id:
95821>>>                Move sChangeTo to sRow
95822>>>                // Move (Replaces(sChangeFrom, sRow, sChangeTo)) to sValue
95822>>>            End
95822>>>>
95822>>>            Move sRow to sFileArray[iRow]
95823>>>            Increment iRow
95824>>>        End
95825>>>>
95825>>>        Send Seq_Close_Channel iCh
95826>>>
95826>>>        Sleep 1 // Wait for Windows to close the file
95827>>>
95827>>>        Get Seq_Open_Output_Channel sFileName to iCh
95828>>>        If (iCh < 1) Begin
95830>>>            Function_Return False
95831>>>        End
95831>>>>
95831>>>        Move (SizeOfArray(sFileArray)) to iItems
95832>>>        Decrement iItems
95833>>>
95833>>>        For iCount from 0 to iItems
95839>>>>
95839>>>            Move sFileArray[iCount] to sValue
95840>>>            Writeln channel iCh sValue
95843>>>        Loop
95844>>>>
95844>>>        Send Seq_Close_Channel iCh
95845>>>
95845>>>        Function_Return (Err = False)
95846>>>    End_Function
95847>>>
95847>>>    // This might be needed by API-methods when a connection id is to be used and
95847>>>    // the connection ID hasn't been established with the driver's CLI interface.
95847>>>    // NOTE: Only applicable for DAW drivers, as Mertech drivers doesn't use connection ID's.
95847>>>    Function UtilCreateConnectionID String sConnectionID Returns Boolean
95849>>>        String sConnectionString sDriverID
95849>>>        Boolean bOK bSilent bDawDriver
95849>>>        Handle hoCLI
95849>>>
95849>>>        Move False to bOK
95850>>>        Get psDriverID to sDriverID
95851>>>        Get IsDAWSQLDriver sDriverID to bDawDriver
95852>>>        If (bDawDriver = False) Begin
95854>>>            Error DFERR_PROGRAM "The UtilCreateConnectionID function is only available for DAW drivers. (Not Mertech)."
95855>>>>
95855>>>            Function_Return False
95856>>>        End
95856>>>>
95856>>>
95856>>>        Get psConnectionString to sConnectionString
95857>>>        Get pbSilentLogin      to bSilent
95858>>>
95858>>>        Get phoCLIHandler to hoCLI
95859>>>        If (hoCLI <> 0) Begin
95861>>>            Set psDriverID of hoCLI to sDriverID
95862>>>            Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to bOK
95863>>>        End
95863>>>>
95863>>>
95863>>>        Function_Return (bOK = False)
95864>>>    End_Function
95865>>>
95865>>>    // This message creates an error log in the "Home" folder named "SQLErrorLog.txt",
95865>>>    // and opens it in "notepad.exe".
95865>>>    // Note: This is _not_ used by the cDbUpdateHandler & cDbUpdateVersion classes!
95865>>>    //       Instead the cDbUpdateLogFile's WriteErrorLog & ShowErrorLog are used.
95865>>>    Procedure UtilShowErrorList
95867>>>        tSqlErrorArray aSqlErrorArray
95867>>>        tSqlErrorArray aSqlErrorArray
95867>>>        Integer iRows iCount iCh iErrorNum
95867>>>        String sPath sFileName sErrorTxt sStatement
95867>>>
95867>>>        Get psHome of (phoWorkspace(ghoApplication)) to sPath
95868>>>        Get vFolderFormat sPath to sPath
95869>>>        Move "SQLErrorLog.txt"  to sFileName
95870>>>        Get Seq_Open_Output_Channel (sPath + sFileName) to iCh
95871>>>            Get paSqlErrorArray to aSqlErrorArray
95872>>>            Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iRows
95873>>>            If (iRows > 0) Begin
95875>>>                Decrement iRows
95876>>>                for iCount from 0 to iRows
95882>>>>
95882>>>                    Move aSqlErrorArray.sSqlErrorArray[iCount]      to sErrorTxt
95883>>>                    Move aSqlErrorArray.sSqlStatementArray[iCount]  to sStatement
95884>>>                    Move aSqlErrorArray.iSqlErrorArray[iCount]      to iErrorNum
95885>>>                    Writeln channel iCh "Error No: " iErrorNum " Error Text: " sErrorTxt
95891>>>                    Writeln channel iCh "SQL Statement: " sStatement
95895>>>                Loop
95896>>>>
95896>>>            End
95896>>>>
95896>>>        Send Seq_Close_Channel iCh
95897>>>
95897>>>        If (iRows > 0) Begin
95899>>>            Runprogram Shell Background (sPath + sFileName)
95900>>>        End
95900>>>>
95900>>>    End_Procedure
95901>>>
95901>>>    // For this to be returning a True value, the table number needs to be in the Filelist.cfg,
95901>>>    // and the table needs to exist as an SQL table.
95901>>>    Function UtilTableIsSql Handle hTable Returns Boolean
95903>>>        String sRootName sDriverID
95903>>>        Boolean bIsSQL
95903>>>
95903>>>        Move False to bIsSQL
95904>>>        If (hTable > 0) Begin
95906>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
95909>>>            Move (sRootName contains ":") to bIsSQL
95910>>>            If (bIsSQL = True) Begin
95912>>>                Get psDriverID to sDriverID
95913>>>                Get _TableNameOnly sRootName to sRootName
95914>>>                Get SqlUtilCheckIfTableNameExists sRootName sDriverID to bIsSQL
95915>>>            End
95915>>>>
95915>>>        End
95915>>>>
95915>>>
95915>>>        Function_Return bIsSQL
95916>>>    End_Function
95917>>>
95917>>>    Function UtilTableIsSqlByRootName String sRootName Returns Boolean
95919>>>        Boolean bIsSQL
95919>>>        Move (sRootName contains ":") to bIsSQL
95920>>>        Function_Return bIsSQL
95921>>>    End_Function
95922>>>
95922>>>
95922>>>    // Returns True if the passed hTable (filelist slot number) is an Alias table.
95922>>>    // An Alias file/table is a filelist number that share the same Physical filename
95922>>>    // but the Logical name is different.
95922>>>    // Note: If the table cannot be opened; the table is not considered to be an Alias.
95922>>>//    Function UtilTableIsAlias Handle hTable Returns Boolean
95922>>>//        String sPhysicalName sPhysicalNameCompare
95922>>>//        Boolean bWasOpen bOpened bOK
95922>>>//        Integer iCount
95922>>>//
95922>>>//        Move 0 to iCount
95922>>>//        Get_Attribute DF_FILE_OPENED of hTable to bWasOpen
95922>>>//        If (bWasOpen = False) Begin
95922>>>//            Open hTable
95922>>>//            Get_Attribute DF_FILE_OPENED of hTable to bOpened
95922>>>//            If (bOpened = False) Begin
95922>>>//                Function_Return False
95922>>>//            End
95922>>>//        End
95922>>>//
95922>>>//        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName
95922>>>//        Get _TableNameOnly sPhysicalName to sPhysicalName
95922>>>//        If (bWasOpen = False and bOpened = True) Begin
95922>>>//            Close hTable
95922>>>//        End
95922>>>//
95922>>>//        Move 0 to hTable
95922>>>//        Repeat
95922>>>//            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
95922>>>//            If (hTable > 0 and hTable <> 50) Begin
95922>>>//                Open hTable
95922>>>//                Get_Attribute DF_FILE_OPENED of hTable to bOpened
95922>>>//                If (bOpened = True) Begin
95922>>>//                    Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalNameCompare
95922>>>//                    Close hTable
95922>>>//                    Get _TableNameOnly sPhysicalNameCompare to sPhysicalNameCompare
95922>>>//                    If (Uppercase(sPhysicalName) = Uppercase(sPhysicalNameCompare)) Begin
95922>>>//                        Increment iCount
95922>>>//                    End
95922>>>//                End
95922>>>//            End
95922>>>//        Until (hTable = 0)
95922>>>//
95922>>>//        If (iCount > 1) Begin
95922>>>//            Function_Return True
95922>>>//        End
95922>>>//
95922>>>//        Function_Return False
95922>>>//    End_Function
95922>>>
95922>>>    Function UtilTableIsAlias Handle hTable Returns Boolean
95924>>>        String sPhysicalName sPhysicalNameCompare
95924>>>        Integer iCount iMaster iAlias iInTable
95924>>>
95924>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sPhysicalName
95927>>>        Get _TableNameOnly sPhysicalName to sPhysicalName
95928>>>        Move hTable to iInTable
95929>>>        Move 0 to hTable
95930>>>        Move 0 to iCount
95931>>>
95931>>>        Repeat
95931>>>>
95931>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
95934>>>            If (hTable > 0 and hTable <> 50) Begin
95936>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sPhysicalNameCompare
95939>>>                Get _TableNameOnly sPhysicalNameCompare to sPhysicalNameCompare
95940>>>                If (Uppercase(sPhysicalName) = Uppercase(sPhysicalNameCompare)) Begin
95942>>>
95942>>>                    If (iCount = 0) Begin
95944>>>                        Move hTable to iMaster
95945>>>                    End
95945>>>>
95945>>>                    If (iCount > 0) Begin
95947>>>                        Move hTable to iAlias
95948>>>                    End
95948>>>>
95948>>>                    Increment iCount
95949>>>                End
95949>>>>
95949>>>            End
95949>>>>
95949>>>        Until (hTable = 0)
95951>>>
95951>>>        If (iCount > 1) Begin
95953>>>            Function_Return (iInTable >= iAlias and iAlias > iMaster)
95954>>>        End
95954>>>>
95954>>>
95954>>>        Function_Return False
95955>>>    End_Function
95956>>>
95956>>>//    Function UtilTableIsAliasFdFile Handle hTable Returns Boolean
95956>>>//        String sDDSrcPath sDataPath sLogicalName
95956>>>//        Boolean bOK bExists
95956>>>//
95956>>>//        Get psDataPath  of (phoWorkspace(ghoApplication)) to sDataPath
95956>>>//        If (Right(sDataPath, 1) = "\") Begin
95956>>>//            Move (Left(sDataPath, (Length(sDataPath) -1))) to sDataPath
95956>>>//        End
95956>>>//        Move (StringFromRightOfChar(sDataPath, "\")) to sDDSrcPath
95956>>>//        Move (Replace(sDDSrcPath, sDataPath, ""))    to sDDSrcPath
95956>>>//        Move (sDDSrcPath + "DDSrc")                  to sDDSrcPath
95956>>>//        Get vFolderFormat sDDSrcPath                 to sDDSrcPath
95956>>>//
95956>>>//        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
95956>>>//        Get vFilePathExists (sDDSrcPath + sLogicalName + ".fd") to bExists
95956>>>//
95956>>>//        Function_Return bExists
95956>>>//    End_Function
95956>>>
95956>>>    // To Open a table with any driver.
95956>>>    // Note: If the driver is <> DATAFLEX_ID  - login credentials are used; it is then assumed
95956>>>    //       that the proper login properties has been setup properly with the cSQLConnections object.
95956>>>    //
95956>>>    // If the open command fails the Err flag will be reset to false, at the end of the function!
95956>>>    // The found flag is still used to indicate if the open was successful or not. The function
95956>>>    // returns a True if successful (table could be opened).
95956>>>    //
95956>>>    // Using the "Open As" syntax with drivers means that we don't need to rely on .int file settings.
95956>>>    // This is good because with DFConnectionID's those credentials doesn't need to be available in
95956>>>    // the .int file (and probably aren't). As long as the login properties of this object have been
95956>>>    // set properly we can open the table.
95956>>>    //
95956>>>    // DAW Driver Syntax:
95956>>>    //  <CKId>:<Schema>#<Table>@<ConnectString>|<Filename>.int
95956>>>    //  Now the @<ConnectString> can be followed by a pipe character '|' followed by the name of the INT file.
95956>>>    //  Doing so, the driver will apply the information from the .INT file to the passed direct Open String.
95956>>>    //  Note that when an INT file has been passed, it will skip the keyword DRIVER_NAME, SERVER_NAME,
95956>>>    //  DATABASE_NAME and SCHEMA_NAME from the INT file because those are supposed to be supplied in the String already.
95956>>>    //  Open mode; iMode = DF_SHARE or DF_EXCLUSIVE.
95956>>>    //
95956>>>    // DAW Driver Sample:
95956>>>    //   Open "MSSQLDRV:dbo#MyFile@SERVER=(local)\SQLEXPRESS;Trusted_Connection=yes;DATABASE=OrderEntry|options|intfile=MyFile.int"
95956>>>    //
95956>>>    // Mertech Driver Samples:
95956>>>    //   SQLFlex:   Open "sql_drv:\\<serverName>\<database>*<owner>*<tableName>=<numberFieds>" as table
95956>>>    //   MySQLFlex: Open "mdsmysql:\\<serverName>\<database>*<tableName>=<numberFieds>" as table
95956>>>    //   PgFlex:    Open "mdspgsql:\\<serverName>\<database>*<schema>*<tableName>=<numberFieds>" as table
95956>>>    //   ORAFlex:   Open "ora_drv:\\<serverName>\<owner>*<tableName>=<numberFieds>" as table
95956>>>    Function UtilTableOpen Integer hTable String sTableName Integer iMode Returns Boolean
95958>>>        String sDriverID sConnection sSchema sExt sTableNameShort sTableNameOrg
95958>>>        Boolean bOpen bMertechDriver bOK
95958>>>        tSQLConnection SQLConnection
95958>>>        tSQLConnection SQLConnection
95958>>>
95958>>>        Move sTableName to sTableNameOrg
95959>>>        If (hTable > 0) Begin
95961>>>            Send Ignore_Error of Error_Object_Id 20529
95962>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
95963>>>            Send Ignore_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
95964>>>            Open hTable
95966>>>            Send Trap_Error of Error_Object_Id 20529
95967>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
95968>>>            Send Trap_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
95969>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
95972>>>            If (bOpen = True) Begin
95974>>>                Function_Return True
95975>>>            End
95975>>>>
95975>>>        End
95975>>>>
95975>>>
95975>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
95976>>>        Move SQLConnection.sDriverID to sDriverID
95977>>>        Get IsMertechDriver sDriverID to bMertechDriver
95978>>>        Move SQLConnection.sConnectionString to sConnection
95979>>>        Move SQLConnection.sSchema to sSchema
95980>>>        If (sSchema = "") Begin
95982>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
95983>>>        End
95983>>>>
95983>>>
95983>>>        // We need to remove the ".int" part of the table name because
95983>>>        // the table name after the "#" in the connection syntax below wants the
95983>>>        // "bare" table name without any extension.
95983>>>        If (sDriverID <> DATAFLEX_ID) Begin
95985>>>            If (Lowercase(sTableName) contains ".int") Begin
95987>>>                Get ParseFileExtension sTableName to sExt
95988>>>                Move (Replace(("." + sExt), sTableName, "")) to sTableNameShort
95989>>>            End
95989>>>>
95989>>>            Else Begin
95990>>>                Move sTableName to sTableNameShort
95991>>>                Move (Append(sTableName, ".int")) to sTableName
95992>>>            End
95992>>>>
95992>>>            If (bMertechDriver = False) Begin
95994>>>                Move (sDriverID + ":" + sSchema + "#" + sTableNameShort + "@" + sConnection + "|options|intfile=" + sTableName) to sConnection
95995>>>                Move sConnection to sTableName
95996>>>            End
95996>>>>
95996>>>        End
95996>>>>
95996>>>
95996>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
95997>>>        Send Ignore_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
95998>>>        If (hTable = 0) Begin
96000>>>            Get NextFreeFilelistSlot to hTable
96001>>>        End
96001>>>>
96001>>>
96001>>>        Case Begin
96001>>>            Case (sDriverID = MSSQLDRV_ID)
96003>>>                // If not df_exclusive mode, we use the "Open As" syntax.
96003>>>                If (iMode <> DF_EXCLUSIVE) Begin
96005>>>                    Open sTableName as hTable
96007>>>                End
96007>>>>
96007>>>                Else Begin
96008>>>                    Get OpenTableExclusive hTable to bOK
96009>>>                    If (bOK = False) Begin
96011>>>                        Function_Return False
96012>>>                    End
96012>>>>
96012>>>                End
96012>>>>
96012>>>                Case Break
96013>>>
96013>>>            Case (sDriverID = DB2_DRV_ID)
96016>>>                // If not df_exclusive mode, we use the "Open As" syntax.
96016>>>                If (iMode <> DF_EXCLUSIVE) Begin
96018>>>                    Open sTableName as hTable
96020>>>                End
96020>>>>
96020>>>                Else Begin
96021>>>                    Get OpenTableExclusive hTable to bOK
96022>>>                    If (bOK = False) Begin
96024>>>                        Function_Return False
96025>>>                    End
96025>>>>
96025>>>                End
96025>>>>
96025>>>                Case Break
96026>>>
96026>>>            Case (sDriverID = ODBC_DRV_ID)
96029>>>                // If not df_exclusive mode, we use the "Open As" syntax.
96029>>>                If (iMode <> DF_EXCLUSIVE) Begin
96031>>>                    Open sTableName as hTable
96033>>>                End
96033>>>>
96033>>>                Else Begin
96034>>>                    Get OpenTableExclusive hTable to bOK
96035>>>                    If (bOK = False) Begin
96037>>>                        Function_Return False
96038>>>                    End
96038>>>>
96038>>>                End
96038>>>>
96038>>>                Case Break
96039>>>
96039>>>            Case (sDriverID = SQLFLEX)
96042>>>                // ToDo: What is the <owner>? Same as Schema?
96042>>>                // SQLFlex:   Open "sql_drv:\\<serverName>\<database>*<owner>*<tableName>=<numberFieds>" as table
96042>>>                Move (SQLFLEX + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + SQLConnection.sSchema + "*" + sTableNameOrg) to sTableName
96043>>>                // If not df_exclusive mode, we use the "Open As" syntax.
96043>>>                If (iMode <> DF_EXCLUSIVE) Begin
96045>>>                    Open sTableName as hTable
96047>>>                End
96047>>>>
96047>>>                Else Begin
96048>>>                    Get OpenTableExclusive hTable to bOK
96049>>>                    If (bOK = False) Begin
96051>>>                        Function_Return False
96052>>>                    End
96052>>>>
96052>>>                End
96052>>>>
96052>>>                Case Break
96053>>>
96053>>>            Case (sDriverID = MDSMySQL)
96056>>>                // MySQLFlex: Open "mdsmysql:\\<serverName>\<database>*<tableName>=<numberFieds>" as table
96056>>>                Move (MDSMySQL + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + "*" + sTableNameOrg) to sTableName
96057>>>                // If not df_exclusive mode, we use the "Open As" syntax.
96057>>>                If (iMode <> DF_EXCLUSIVE) Begin
96059>>>                    Open sTableName as hTable
96061>>>                End
96061>>>>
96061>>>                Else Begin
96062>>>                    Get OpenTableExclusive hTable to bOK
96063>>>                    If (bOK = False) Begin
96065>>>                        Function_Return False
96066>>>                    End
96066>>>>
96066>>>                End
96066>>>>
96066>>>                Case Break
96067>>>
96067>>>            Case (sDriverID = MDSPgSQL)
96070>>>                // PgFlex: Open "mdspgsql:\\<serverName>\<database>*<schema>*<tableName>=<numberFieds>" as table
96070>>>                Move (MDSPgSQL + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + "*" + SQLConnection.sSchema + "*" + sTableNameOrg) to sTableName
96071>>>                // If not df_exclusive mode, we use the "Open As" syntax.
96071>>>                If (iMode <> DF_EXCLUSIVE) Begin
96073>>>                    Open sTableName as hTable
96075>>>                End
96075>>>>
96075>>>                Else Begin
96076>>>                    Get OpenTableExclusive hTable to bOK
96077>>>                    If (bOK = False) Begin
96079>>>                        Function_Return False
96080>>>                    End
96080>>>>
96080>>>                End
96080>>>>
96080>>>                Case Break
96081>>>
96081>>>            Case (sDriverID = ORAFLEX)
96084>>>                // ToDo: What is the <owner>? Same as Schema?
96084>>>                // ORAFlex: Open "ora_drv:\\<serverName>\<owner>*<tableName>=<numberFieds>" as table
96084>>>                Move (ORAFLEX + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sSchema + "*" + sTableName) to sTableName
96085>>>                // If not df_exclusive mode, we use the "Open As" syntax.
96085>>>                If (iMode <> DF_EXCLUSIVE) Begin
96087>>>                    Open sTableName as hTable
96089>>>                End
96089>>>>
96089>>>                Else Begin
96090>>>                    Get OpenTableExclusive hTable to bOK
96091>>>                    If (bOK = False) Begin
96093>>>                        Function_Return False
96094>>>                    End
96094>>>>
96094>>>                End
96094>>>>
96094>>>                Case Break
96095>>>
96095>>>            Case (sDriverID = DATAFLEX_ID)
96098>>>                If (sTableName <> "" and iMode <> DF_EXCLUSIVE) Begin
96100>>>                    Open sTableName as hTable
96102>>>                End
96102>>>>
96102>>>                Else If (iMode = DF_EXCLUSIVE) Begin
96105>>>                    Get OpenTableExclusive hTable to bOK
96106>>>                    If (bOK = False) Begin
96108>>>                        Function_Return False
96109>>>                    End
96109>>>>
96109>>>                End
96109>>>>
96109>>>                Else Begin
96110>>>                    Open hTable
96112>>>                End
96112>>>>
96112>>>                Case Break
96113>>>
96113>>>            // ToDo: Logic needs to be expanded for Mertech drivers!
96113>>>
96113>>>            Case Else
96113>>>                Error DFERR_PROGRAM ("Invalid driver:" * sDriverID)
96114>>>>
96114>>>        Case End
96114>>>
96114>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
96115>>>        Send Trap_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
96116>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
96118>>>            Move False to Found
96119>>>        End
96119>>>>
96119>>>        // If open failed, the Err is set to true,
96119>>>        // but we don't want that because it could end our loop.
96119>>>        Move False to Err
96120>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
96123>>>
96123>>>        Function_Return bOpen
96124>>>    End_Function
96125>>>
96125>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
96125>>>    // that the embedded .dat file exists on disk _or_ that the SQL table exists
96125>>>    // if it is an SQL table
96125>>>    Function UtilTableExists Handle hTable Returns Boolean
96127>>>        Boolean bExists bIsSQLTable
96127>>>        String sDataPath sRootName
96127>>>
96127>>>        Get UtilTableNumberIsInUse hTable to bExists
96128>>>        If (bExists = False) Begin
96130>>>            Function_Return False
96131>>>        End
96131>>>>
96131>>>
96131>>>        Move False to bIsSQLTable
96132>>>        If (hTable > 0) Begin
96134>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
96137>>>            Move (sRootName contains ":") to bIsSQLTable
96138>>>        End
96138>>>>
96138>>>        If (bIsSQLTable = True) Begin
96140>>>            Get UtilTableIsSQL hTable to bExists
96141>>>            Function_Return bExists
96142>>>        End
96142>>>>
96142>>>        Else Begin
96143>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
96144>>>            Get vFolderFormat sDataPath to sDataPath
96145>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
96146>>>        End
96146>>>>
96146>>>
96146>>>        Function_Return bExists
96147>>>    End_Function
96148>>>
96148>>>    // Pass a table handle
96148>>>    // Returns True if the table exists in filelist.cfg.
96148>>>    Function UtilTableNumberIsInUse Handle hCheckTable Returns Boolean
96150>>>        Handle hTable
96150>>>        Boolean bFound
96150>>>
96150>>>        Move False to bFound
96151>>>        Move 0 to hTable
96152>>>        Repeat
96152>>>>
96152>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
96155>>>            If (hTable > 0) Begin
96157>>>                If (hTable = hCheckTable) Begin
96159>>>                    Move True to bFound
96160>>>                End
96160>>>>
96160>>>            End
96160>>>>
96160>>>            If (bFound = True) ;                Break
96163>>>        Until (hTable = 0)
96165>>>
96165>>>        Function_Return (bFound = True)
96166>>>    End_Function
96167>>>
96167>>>    Function UtilDriverFromTableNumber Handle hTable Returns String
96169>>>        Boolean bOK bExists                              
96169>>>        String sDriverID
96169>>>        
96169>>>        Get UtilTableExists hTable to bExists
96170>>>        If (bExists = False) Begin
96172>>>            Function_Return ""
96173>>>        End
96173>>>>
96173>>>        Get OpenTableExclusive hTable to bOK
96174>>>        If (bOK = False) Begin
96176>>>            Function_Return ""
96177>>>        End 
96177>>>>
96177>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
96180>>>        
96180>>>        Function_Return sDriverID
96181>>>    End_Function        
96182>>>    
96182>>>    // Number of tables in Filelist.cfg. Returns integger
96182>>>    Function UtilFilelistNoOfTables Returns Integer
96184>>>        Handle hTable
96184>>>        Integer iRetval
96184>>>
96184>>>        Move 0 to hTable
96185>>>        Move 0 to iRetval
96186>>>
96186>>>        Repeat
96186>>>>
96186>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
96189>>>            If (hTable > 0) Begin
96191>>>                Increment iRetval
96192>>>            End
96192>>>>
96192>>>        Until (hTable = 0)
96194>>>
96194>>>        Function_Return iRetval
96195>>>    End_Function
96196>>>
96196>>>    Function UtilFilelistIsDataFlexTablesOnly Returns Boolean
96198>>>        String sRootName
96198>>>        Boolean bIsSQL
96198>>>        Handle hTable
96198>>>
96198>>>        Move False to bIsSQL
96199>>>        Move 0 to hTable
96200>>>        Repeat
96200>>>>
96200>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
96203>>>            If (hTable > 0) Begin
96205>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
96208>>>                Move (sRootName contains ":") to bIsSQL
96209>>>                If (bIsSQL = True) Begin
96211>>>                    Move 0 to hTable
96212>>>                End
96212>>>>
96212>>>            End
96212>>>>
96212>>>        Until (hTable = 0)
96214>>>
96214>>>        Function_Return (bIsSQL = False)
96215>>>    End_Function
96216>>>
96216>>>    // Pass a table's logical name
96216>>>    // Returns True if the table exists in filelist.cfg.
96216>>>    Function UtilTableLogicalNameIsInUse String sCheckTable Returns Boolean
96218>>>        Handle hTable
96218>>>        Boolean bFound
96218>>>        String sCompareTable
96218>>>
96218>>>        Move False to bFound
96219>>>        Move 0 to hTable
96220>>>        Repeat
96220>>>>
96220>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
96223>>>            If (hTable > 0) Begin
96225>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sCompareTable
96228>>>                If (Uppercase(sCompareTable) = Uppercase(sCheckTable)) Begin
96230>>>                    Move True to bFound
96231>>>                End
96231>>>>
96231>>>            End
96231>>>>
96231>>>            If (bFound = True) ;                Break
96234>>>        Until (hTable = 0)
96236>>>
96236>>>        Function_Return (bFound = True)
96237>>>    End_Function
96238>>>
96238>>>    // * Dummy function for the Studio's Code Explorer *
96238>>>    Function UTIL_ENUMERATION_FUNCTIONS Returns Boolean
96240>>>        Function_Return False
96241>>>    End_Function
96242>>>
96242>>>    Function UtilEnumerateOverlapFields Integer hTable Integer iField Returns String[]
96244>>>        String  sRetval
96244>>>        String[] sOverlapFieldsArray
96245>>>        Integer iType iColumn iColumns
96245>>>        Boolean bOpen bOverlap
96245>>>
96245>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
96248>>>        If (bOpen = False) Begin
96250>>>            Open hTable
96252>>>        End
96252>>>>
96252>>>
96252>>>        Move "" to sRetval
96253>>>
96253>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iColumns
96256>>>
96256>>>        for iColumn from 0 to iColumns
96262>>>>
96262>>>            Get_Attribute DF_FIELD_TYPE of hTable iColumn to iType
96265>>>            If (iField <> iColumn and iType <> DF_OVERLAP) Begin
96267>>>                Get_Attribute DF_FIELD_OVERLAP of hTable iField iColumn to bOverlap
96270>>>                If (bOverlap) Begin
96272>>>                    If (sRetval <> "") Begin
96274>>>                        Append sRetval ","
96275>>>                    End
96275>>>>
96275>>>                    Append sRetval iColumn
96276>>>                End
96276>>>>
96276>>>            End
96276>>>>
96276>>>        Loop
96277>>>>
96277>>>
96277>>>        If (bOpen = False) Begin
96279>>>            Close hTable
96280>>>        End
96280>>>>
96280>>>
96280>>>        Get StrSplitToArray sRetval "," to sOverlapFieldsArray
96281>>>
96281>>>        Function_Return sOverlapFieldsArray
96282>>>    End_Function
96283>>>
96283>>>    // Returns a struct array with all data types for the passed driver & dbtype.
96283>>>    Function UtilEnumerateColumnTypes String sDriverID Integer iDbType Returns tColumnType[]
96285>>>        tColumnType[] ColumnType
96285>>>        tColumnType[] ColumnType
96286>>>
96286>>>        Case Begin
96286>>>            Case (iDbType = EN_dbTypeDataFlex)
96288>>>                Get _UtilEnumerateDataFlexTypes to ColumnType
96289>>>                Case Break
96290>>>
96290>>>            Case (iDbType = EN_DbTypeDB2)
96293>>>                Get _UtilEnumerateDB2Types to ColumnType
96294>>>                Case Break
96295>>>
96295>>>            Case (iDbType = EN_DbTypeMSSQL)
96298>>>                Get _UtilEnumerateMSSQLTypes sDriverID to ColumnType
96299>>>                Case Break
96300>>>
96300>>>            Case (sDriverID = MDSMySQL)
96303>>>                Get _UtilEnumerateMySQLTypes to ColumnType
96304>>>                Case Break
96305>>>
96305>>>            Case (sDriverID = ORAFLEX)
96308>>>                Get _UtilEnumerateOracleTypes to ColumnType
96309>>>                Case Break
96310>>>
96310>>>            Case (sDriverID = MDSPgSQL)
96313>>>                Get _UtilEnumeratePostgreSQLTypes to ColumnType
96314>>>                Case Break
96315>>>        Case End
96315>>>
96315>>>        Function_Return ColumnType
96316>>>    End_Function
96317>>>
96317>>>    Function UtilEnumerateMSSQLODBCDrivers Returns String
96319>>>        Handle hoRegistry hoODBCDriverNames
96319>>>        Boolean bExists bKeyOpened
96319>>>        String sKey
96319>>>        String[] sDrivers
96320>>>        Integer iDriverNames iDriverName
96320>>>
96320>>>        Get Create (RefClass (cRegistry)) to hoRegistry
96321>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
96322>>>        Set pfAccessRights of hoRegistry to Key_Read
96323>>>        Move "SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers" to sKey
96324>>>        Get KeyExists of hoRegistry sKey to bExists
96325>>>        If (bExists) Begin
96327>>>            Get OpenKey of hoRegistry sKey to bKeyOpened
96328>>>            If (bKeyOpened) Begin
96330>>>                Get Create (RefClass (Array)) to hoODBCDriverNames
96331>>>                Get GetValues of hoRegistry hoODBCDriverNames to iDriverNames
96332>>>                If (iDriverNames > 0) Begin
96334>>>                    Move (ResizeArray (sDrivers, iDriverNames)) to sDrivers
96335>>>                    Decrement iDriverNames
96336>>>                    for iDriverName from 0 to iDriverNames
96342>>>>
96342>>>                        Get Value of hoODBCDriverNames iDriverName to sDrivers[iDriverName]
96343>>>                      Loop
96344>>>>
96344>>>                End
96344>>>>
96344>>>                Send CloseKey of hoRegistry
96345>>>            End
96345>>>>
96345>>>        End
96345>>>>
96345>>>        Send Destroy of hoRegistry
96346>>>
96346>>>        Function_Return sDrivers
96347>>>    End_Function
96348>>>
96348>>>    // DataFlex Embedded Database Data Types:
96348>>>    // Helper function for UtilEnumerateColumnTypes
96348>>>    Function _UtilEnumerateDataFlexTypes Returns tColumnType[]
96350>>>        tColumnType[] ColumnType
96350>>>        tColumnType[] ColumnType
96351>>>        Integer i
96351>>>
96351>>>        Move DF_ASCII           to ColumnType[i].iSQLType
96352>>>        Move "ASCII"            to ColumnType[i].sSQLType
96353>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
96354>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
96355>>>        Move "254"              to ColumnType[i].sPrecision
96356>>>        Increment i
96357>>>
96357>>>        Move DF_BCD             to ColumnType[i].iSQLType
96358>>>        Move "Numeric"          to ColumnType[i].sSQLType
96359>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
96360>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
96361>>>        Move "14.8"             to ColumnType[i].sPrecision
96362>>>        Increment i
96363>>>
96363>>>        Move DF_DATE            to ColumnType[i].iSQLType
96364>>>        Move "Date"             to ColumnType[i].sSQLType
96365>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
96366>>>        Move "Date"             to ColumnType[i].sDataFlexType
96367>>>        Move "6.0"              to ColumnType[i].sPrecision
96368>>>        Move True               to ColumnType[i].bCanEditSize
96369>>>        Increment i
96370>>>
96370>>>        Move DF_TEXT            to ColumnType[i].iSQLType
96371>>>        Move "Text"             to ColumnType[i].sSQLType
96372>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
96373>>>        Move "Text"             to ColumnType[i].sDataFlexType
96374>>>        Move "16384"            to ColumnType[i].sPrecision
96375>>>        Increment i
96376>>>
96376>>>        Move DF_BINARY          to ColumnType[i].iSQLType
96377>>>        Move "Binary"           to ColumnType[i].sSQLType
96378>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
96379>>>        Move "Binary"           to ColumnType[i].sDataFlexType
96380>>>        Move "16384"            to ColumnType[i].sPrecision
96381>>>        Increment i
96382>>>
96382>>>        Move DF_DATETIME        to ColumnType[i].iSQLType
96383>>>        Move "DateTime"         to ColumnType[i].sSQLType
96384>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
96385>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
96386>>>        Move "23"               to ColumnType[i].sPrecision
96387>>>        Move True               to ColumnType[i].bCanEditSize
96388>>>        Increment i
96389>>>
96389>>>        Move DF_OVERLAP         to ColumnType[i].iSQLType
96390>>>        Move "Overlap"          to ColumnType[i].sSQLType
96391>>>        Move DF_OVERLAP         to ColumnType[i].iDataFlexType
96392>>>        Move "Overlap"          to ColumnType[i].sDataFlexType
96393>>>        Move "0.0"              to ColumnType[i].sPrecision
96394>>>
96394>>>        Function_Return ColumnType
96395>>>    End_Function
96396>>>
96396>>>    Function _UtilEnumerateDB2Types Returns tColumnType[]
96398>>>        tColumnType[] aColumnType
96398>>>        tColumnType[] aColumnType
96399>>>        Integer i
96399>>>
Including file: DB2_DRV_DriverDef.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\DB2_DRV_DriverDef.inc)
96399>>>>// Generated By The Database Update Framework
96399>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\DB2_DRV_DriverDef.xml
96399>>>>// Driver COLUMN DATA TYPES
96399>>>>//
96399>>>>// Created: 2018-03-14 23:46:34.033
96399>>>>
96399>>>>            Move "bigint"                                to aColumnType[i].sSQLType
96400>>>>            Move -5                                      to aColumnType[i].iSQLType
96401>>>>            Move True                                    to aColumnType[i].bCanEditSize
96402>>>>            Move True                                    to aColumnType[i].bNativeDataType
96403>>>>            Move 14                                      to aColumnType[i].iDefaultSize
96404>>>>            Move 1                                       to aColumnType[i].iMinSize
96405>>>>            Move 14                                      to aColumnType[i].nMaxSize
96406>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
96407>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
96408>>>>            Move 14                                      to aColumnType[i].sPrecision
96409>>>>            Increment i
96410>>>>
96410>>>>            Move "blob"                                  to aColumnType[i].sSQLType
96411>>>>            Move -98                                     to aColumnType[i].iSQLType
96412>>>>            Move True                                    to aColumnType[i].bCanEditSize
96413>>>>            Move True                                    to aColumnType[i].bNativeDataType
96414>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
96415>>>>            Move 1                                       to aColumnType[i].iMinSize
96416>>>>            Move 2147483647                              to aColumnType[i].nMaxSize
96417>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
96418>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
96419>>>>            Move 2147483647                              to aColumnType[i].sPrecision
96420>>>>            Increment i
96421>>>>
96421>>>>            Move "char"                                  to aColumnType[i].sSQLType
96422>>>>            Move 1                                       to aColumnType[i].iSQLType
96423>>>>            Move True                                    to aColumnType[i].bCanEditSize
96424>>>>            Move True                                    to aColumnType[i].bNativeDataType
96425>>>>            Move -1                                      to aColumnType[i].iDefaultSize
96426>>>>            Move 1                                       to aColumnType[i].iMinSize
96427>>>>            Move 254                                     to aColumnType[i].nMaxSize
96428>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
96429>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
96430>>>>            Move 254                                     to aColumnType[i].sPrecision
96431>>>>            Increment i
96432>>>>
96432>>>>            Move "char for bit data"                     to aColumnType[i].sSQLType
96433>>>>            Move -2                                      to aColumnType[i].iSQLType
96434>>>>            Move True                                    to aColumnType[i].bCanEditSize
96435>>>>            Move True                                    to aColumnType[i].bNativeDataType
96436>>>>            Move -1                                      to aColumnType[i].iDefaultSize
96437>>>>            Move 1                                       to aColumnType[i].iMinSize
96438>>>>            Move 254                                     to aColumnType[i].nMaxSize
96439>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
96440>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
96441>>>>            Move 254                                     to aColumnType[i].sPrecision
96442>>>>            Increment i
96443>>>>
96443>>>>            Move "clob"                                  to aColumnType[i].sSQLType
96444>>>>            Move -99                                     to aColumnType[i].iSQLType
96445>>>>            Move True                                    to aColumnType[i].bCanEditSize
96446>>>>            Move True                                    to aColumnType[i].bNativeDataType
96447>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
96448>>>>            Move 1                                       to aColumnType[i].iMinSize
96449>>>>            Move 2147483647                              to aColumnType[i].nMaxSize
96450>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
96451>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
96452>>>>            Move 2147483647                              to aColumnType[i].sPrecision
96453>>>>            Increment i
96454>>>>
96454>>>>            Move "date"                                  to aColumnType[i].sSQLType
96455>>>>            Move 91                                      to aColumnType[i].iSQLType
96456>>>>            Move False                                   to aColumnType[i].bCanEditSize
96457>>>>            Move True                                    to aColumnType[i].bNativeDataType
96458>>>>            Move 0                                       to aColumnType[i].iDefaultSize
96459>>>>            Move 0                                       to aColumnType[i].iMinSize
96460>>>>            Move 0                                       to aColumnType[i].nMaxSize
96461>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
96462>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
96463>>>>            Move 1                                       to aColumnType[i].sPrecision
96464>>>>            Increment i
96465>>>>
96465>>>>            Move "dbclob"                                to aColumnType[i].sSQLType
96466>>>>            Move -350                                    to aColumnType[i].iSQLType
96467>>>>            Move True                                    to aColumnType[i].bCanEditSize
96468>>>>            Move True                                    to aColumnType[i].bNativeDataType
96469>>>>            Move -1                                      to aColumnType[i].iDefaultSize
96470>>>>            Move 1                                       to aColumnType[i].iMinSize
96471>>>>            Move 1073741823                              to aColumnType[i].nMaxSize
96472>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
96473>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
96474>>>>            Move 1073741823                              to aColumnType[i].sPrecision
96475>>>>            Increment i
96476>>>>
96476>>>>            Move "decimal"                               to aColumnType[i].sSQLType
96477>>>>            Move 3                                       to aColumnType[i].iSQLType
96478>>>>            Move True                                    to aColumnType[i].bCanEditSize
96479>>>>            Move True                                    to aColumnType[i].bNativeDataType
96480>>>>            Move -1                                      to aColumnType[i].iDefaultSize
96481>>>>            Move 1                                       to aColumnType[i].iMinSize
96482>>>>            Move 14                                      to aColumnType[i].nMaxSize
96483>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
96484>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
96485>>>>            Move 14                                      to aColumnType[i].sPrecision
96486>>>>            Increment i
96487>>>>
96487>>>>            Move "double"                                to aColumnType[i].sSQLType
96488>>>>            Move 8                                       to aColumnType[i].iSQLType
96489>>>>            Move True                                    to aColumnType[i].bCanEditSize
96490>>>>            Move True                                    to aColumnType[i].bNativeDataType
96491>>>>            Move 14                                      to aColumnType[i].iDefaultSize
96492>>>>            Move 1                                       to aColumnType[i].iMinSize
96493>>>>            Move 14                                      to aColumnType[i].nMaxSize
96494>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
96495>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
96496>>>>            Move 14                                      to aColumnType[i].sPrecision
96497>>>>            Increment i
96498>>>>
96498>>>>            Move "graphic"                               to aColumnType[i].sSQLType
96499>>>>            Move -95                                     to aColumnType[i].iSQLType
96500>>>>            Move True                                    to aColumnType[i].bCanEditSize
96501>>>>            Move True                                    to aColumnType[i].bNativeDataType
96502>>>>            Move -1                                      to aColumnType[i].iDefaultSize
96503>>>>            Move 1                                       to aColumnType[i].iMinSize
96504>>>>            Move 127                                     to aColumnType[i].nMaxSize
96505>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
96506>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
96507>>>>            Move 127                                     to aColumnType[i].sPrecision
96508>>>>            Increment i
96509>>>>
96509>>>>            Move "integer"                               to aColumnType[i].sSQLType
96510>>>>            Move 4                                       to aColumnType[i].iSQLType
96511>>>>            Move True                                    to aColumnType[i].bCanEditSize
96512>>>>            Move True                                    to aColumnType[i].bNativeDataType
96513>>>>            Move 14                                      to aColumnType[i].iDefaultSize
96514>>>>            Move 1                                       to aColumnType[i].iMinSize
96515>>>>            Move 14                                      to aColumnType[i].nMaxSize
96516>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
96517>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
96518>>>>            Move 14                                      to aColumnType[i].sPrecision
96519>>>>            Increment i
96520>>>>
96520>>>>            Move "long varchar"                          to aColumnType[i].sSQLType
96521>>>>            Move -1                                      to aColumnType[i].iSQLType
96522>>>>            Move True                                    to aColumnType[i].bCanEditSize
96523>>>>            Move True                                    to aColumnType[i].bNativeDataType
96524>>>>            Move -1                                      to aColumnType[i].iDefaultSize
96525>>>>            Move 1                                       to aColumnType[i].iMinSize
96526>>>>            Move 32000                                   to aColumnType[i].nMaxSize
96527>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
96528>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
96529>>>>            Move 32000                                   to aColumnType[i].sPrecision
96530>>>>            Increment i
96531>>>>
96531>>>>            Move "long varchar for bit data"             to aColumnType[i].sSQLType
96532>>>>            Move -4                                      to aColumnType[i].iSQLType
96533>>>>            Move True                                    to aColumnType[i].bCanEditSize
96534>>>>            Move True                                    to aColumnType[i].bNativeDataType
96535>>>>            Move -1                                      to aColumnType[i].iDefaultSize
96536>>>>            Move 1                                       to aColumnType[i].iMinSize
96537>>>>            Move 32700                                   to aColumnType[i].nMaxSize
96538>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
96539>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
96540>>>>            Move 32700                                   to aColumnType[i].sPrecision
96541>>>>            Increment i
96542>>>>
96542>>>>            Move "long vargraphic"                       to aColumnType[i].sSQLType
96543>>>>            Move -97                                     to aColumnType[i].iSQLType
96544>>>>            Move True                                    to aColumnType[i].bCanEditSize
96545>>>>            Move True                                    to aColumnType[i].bNativeDataType
96546>>>>            Move -1                                      to aColumnType[i].iDefaultSize
96547>>>>            Move 1                                       to aColumnType[i].iMinSize
96548>>>>            Move 16350                                   to aColumnType[i].nMaxSize
96549>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
96550>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
96551>>>>            Move 16350                                   to aColumnType[i].sPrecision
96552>>>>            Increment i
96553>>>>
96553>>>>            Move "real"                                  to aColumnType[i].sSQLType
96554>>>>            Move 7                                       to aColumnType[i].iSQLType
96555>>>>            Move True                                    to aColumnType[i].bCanEditSize
96556>>>>            Move True                                    to aColumnType[i].bNativeDataType
96557>>>>            Move 14                                      to aColumnType[i].iDefaultSize
96558>>>>            Move 1                                       to aColumnType[i].iMinSize
96559>>>>            Move 14                                      to aColumnType[i].nMaxSize
96560>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
96561>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
96562>>>>            Move 14                                      to aColumnType[i].sPrecision
96563>>>>            Increment i
96564>>>>
96564>>>>            Move "smallint"                              to aColumnType[i].sSQLType
96565>>>>            Move 5                                       to aColumnType[i].iSQLType
96566>>>>            Move True                                    to aColumnType[i].bCanEditSize
96567>>>>            Move True                                    to aColumnType[i].bNativeDataType
96568>>>>            Move 14                                      to aColumnType[i].iDefaultSize
96569>>>>            Move 1                                       to aColumnType[i].iMinSize
96570>>>>            Move 14                                      to aColumnType[i].nMaxSize
96571>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
96572>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
96573>>>>            Move 14                                      to aColumnType[i].sPrecision
96574>>>>            Increment i
96575>>>>
96575>>>>            Move "time"                                  to aColumnType[i].sSQLType
96576>>>>            Move 92                                      to aColumnType[i].iSQLType
96577>>>>            Move False                                   to aColumnType[i].bCanEditSize
96578>>>>            Move True                                    to aColumnType[i].bNativeDataType
96579>>>>            Move 0                                       to aColumnType[i].iDefaultSize
96580>>>>            Move 0                                       to aColumnType[i].iMinSize
96581>>>>            Move 0                                       to aColumnType[i].nMaxSize
96582>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
96583>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
96584>>>>            Move 1                                       to aColumnType[i].sPrecision
96585>>>>            Increment i
96586>>>>
96586>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
96587>>>>            Move 93                                      to aColumnType[i].iSQLType
96588>>>>            Move False                                   to aColumnType[i].bCanEditSize
96589>>>>            Move True                                    to aColumnType[i].bNativeDataType
96590>>>>            Move 0                                       to aColumnType[i].iDefaultSize
96591>>>>            Move 0                                       to aColumnType[i].iMinSize
96592>>>>            Move 0                                       to aColumnType[i].nMaxSize
96593>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
96594>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
96595>>>>            Move 1                                       to aColumnType[i].sPrecision
96596>>>>            Increment i
96597>>>>
96597>>>>            Move "varchar"                               to aColumnType[i].sSQLType
96598>>>>            Move 12                                      to aColumnType[i].iSQLType
96599>>>>            Move True                                    to aColumnType[i].bCanEditSize
96600>>>>            Move True                                    to aColumnType[i].bNativeDataType
96601>>>>            Move -1                                      to aColumnType[i].iDefaultSize
96602>>>>            Move 1                                       to aColumnType[i].iMinSize
96603>>>>            Move 32672                                   to aColumnType[i].nMaxSize
96604>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
96605>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
96606>>>>            Move 32672                                   to aColumnType[i].sPrecision
96607>>>>            Increment i
96608>>>>
96608>>>>            Move "varchar for bit data"                  to aColumnType[i].sSQLType
96609>>>>            Move -3                                      to aColumnType[i].iSQLType
96610>>>>            Move True                                    to aColumnType[i].bCanEditSize
96611>>>>            Move True                                    to aColumnType[i].bNativeDataType
96612>>>>            Move -1                                      to aColumnType[i].iDefaultSize
96613>>>>            Move 1                                       to aColumnType[i].iMinSize
96614>>>>            Move 32672                                   to aColumnType[i].nMaxSize
96615>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
96616>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
96617>>>>            Move 32672                                   to aColumnType[i].sPrecision
96618>>>>            Increment i
96619>>>>
96619>>>>            Move "vargraphic"                            to aColumnType[i].sSQLType
96620>>>>            Move -96                                     to aColumnType[i].iSQLType
96621>>>>            Move True                                    to aColumnType[i].bCanEditSize
96622>>>>            Move True                                    to aColumnType[i].bNativeDataType
96623>>>>            Move -1                                      to aColumnType[i].iDefaultSize
96624>>>>            Move 1                                       to aColumnType[i].iMinSize
96625>>>>            Move 16336                                   to aColumnType[i].nMaxSize
96626>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
96627>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
96628>>>>            Move 16336                                   to aColumnType[i].sPrecision
96629>>>>            Increment i
96630>>>>
96630>>>>            Move "xml"                                   to aColumnType[i].sSQLType
96631>>>>            Move -370                                    to aColumnType[i].iSQLType
96632>>>>            Move True                                    to aColumnType[i].bCanEditSize
96633>>>>            Move True                                    to aColumnType[i].bNativeDataType
96634>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
96635>>>>            Move 1                                       to aColumnType[i].iMinSize
96636>>>>            Move 2147483647                              to aColumnType[i].nMaxSize
96637>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
96638>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
96639>>>>            Move 2147483647                              to aColumnType[i].sPrecision
96640>>>>            Increment i
96641>>>>
96641>>>>
96641>>>//        Move SQL_DBCLOB         to ColumnType[i].iSQLType
96641>>>//        Move "DBCLOB"           to ColumnType[i].sSQLType
96641>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
96641>>>//        Move "Text"             to ColumnType[i].sDataFlexType
96641>>>//        Move "16384"            to ColumnType[i].sPrecision
96641>>>//        Increment i
96641>>>//
96641>>>//        Move SQL_BIGINT         to ColumnType[i].iSQLType
96641>>>//        Move "BIGINT"           to ColumnType[i].sSQLType
96641>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
96641>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
96641>>>//        Move "14.0"             to ColumnType[i].sPrecision
96641>>>//        Increment i
96641>>>//
96641>>>//        Move SQL_BLOB           to ColumnType[i].iSQLType
96641>>>//        Move "BLOB"             to ColumnType[i].sSQLType
96641>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
96641>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
96641>>>//        Move "16384"            to ColumnType[i].sPrecision
96641>>>//        Increment i
96641>>>//
96641>>>//        Move SQL_CHAR           to ColumnType[i].iSQLType
96641>>>//        Move "CHAR"             to ColumnType[i].sSQLType
96641>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
96641>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
96641>>>//        Move "254"              to ColumnType[i].sPrecision
96641>>>//        Increment i
96641>>>//
96641>>>//        // ToDo: We need to change the sType when using this!
96641>>>//        Move SQL_CHARBIT            to ColumnType[i].iSQLType
96641>>>//        Move "CHAR FOR BIT DATA"    to ColumnType[i].sSQLType
96641>>>//        Move DF_BINARY              to ColumnType[i].iDataFlexType
96641>>>//        Move "Binary"               to ColumnType[i].sDataFlexType
96641>>>//        Move "254"                  to ColumnType[i].sPrecision
96641>>>//        Increment i
96641>>>//
96641>>>//        Move SQL_DATE           to ColumnType[i].iSQLType
96641>>>//        Move "DATE"             to ColumnType[i].sSQLType
96641>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
96641>>>//        Move "Date"             to ColumnType[i].sDataFlexType
96641>>>//        Move "6.0"              to ColumnType[i].sPrecision
96641>>>//        Move True               to ColumnType[i].bCanEditSize
96641>>>//        Increment i
96641>>>//
96641>>>//        Move SQL_CLOB           to ColumnType[i].iSQLType
96641>>>//        Move "CLOB"             to ColumnType[i].sSQLType
96641>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
96641>>>//        Move "Text"             to ColumnType[i].sDataFlexType
96641>>>//        Move "16384"            to ColumnType[i].sPrecision
96641>>>//        Increment i
96641>>>//
96641>>>//        Move SQL_DECIMAL        to ColumnType[i].iSQLType
96641>>>//        Move "DECIMAL"          to ColumnType[i].sSQLType
96641>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
96641>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
96641>>>//        Move "14.8"             to ColumnType[i].sPrecision
96641>>>//        Increment i
96641>>>//
96641>>>//        Move SQL_DOUBLE         to ColumnType[i].iSQLType
96641>>>//        Move "DOUBLE"           to ColumnType[i].sSQLType
96641>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
96641>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
96641>>>//        Move "14.8"             to ColumnType[i].sPrecision
96641>>>//        Increment i
96641>>>//
96641>>>//        Move SQL_FLOAT          to ColumnType[i].iSQLType
96641>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
96641>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
96641>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
96641>>>//        Move "14.8"             to ColumnType[i].sPrecision
96641>>>//        Increment i
96641>>>//
96641>>>//        Move SQL_GRAPHIC        to ColumnType[i].iSQLType
96641>>>//        Move "GRAPHIC"          to ColumnType[i].sSQLType
96641>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
96641>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
96641>>>//        Move "255"              to ColumnType[i].sPrecision
96641>>>//        Increment i
96641>>>//
96641>>>//        Move SQL_INTEGER        to ColumnType[i].iSQLType
96641>>>//        Move "INTEGER"          to ColumnType[i].sSQLType
96641>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
96641>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
96641>>>//        Move "9.0"              to ColumnType[i].sPrecision
96641>>>//        Increment i
96641>>>//
96641>>>//        Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
96641>>>//        Move "LONG VARCHAR"     to ColumnType[i].sSQLType
96641>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
96641>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
96641>>>//        Move "32000"            to ColumnType[i].sPrecision
96641>>>//        Increment i
96641>>>//
96641>>>//        Move SQL_LONGVARCHARBIT to ColumnType[i].iSQLType
96641>>>//        Move "LONG VARCHAR BIT" to ColumnType[i].sSQLType
96641>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
96641>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
96641>>>//        Move "32000"            to ColumnType[i].sPrecision
96641>>>//        Increment i
96641>>>//
96641>>>//        Move SQL_LONGVARGRAPHIC to ColumnType[i].iSQLType
96641>>>//        Move "LONG VARGRAPHIC"  to ColumnType[i].sSQLType
96641>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
96641>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
96641>>>//        Move "32000"            to ColumnType[i].sPrecision
96641>>>//        Increment i
96641>>>//
96641>>>//        Move SQL_NUMERIC        to ColumnType[i].iSQLType
96641>>>//        Move "NUMERIC"          to ColumnType[i].sSQLType
96641>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
96641>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
96641>>>//        Move "14.8"             to ColumnType[i].sPrecision
96641>>>//        Increment i
96641>>>//
96641>>>//        Move SQL_REAL           to ColumnType[i].iSQLType
96641>>>//        Move "REAL"             to ColumnType[i].sSQLType
96641>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
96641>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
96641>>>//        Move "14.8"             to ColumnType[i].sPrecision
96641>>>//        Increment i
96641>>>//
96641>>>//        Move SQL_SMALLINT       to ColumnType[i].iSQLType
96641>>>//        Move "SMALLINT"         to ColumnType[i].sSQLType
96641>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
96641>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
96641>>>//        Move "5.0"              to ColumnType[i].sPrecision
96641>>>//        Increment i
96641>>>//
96641>>>//        Move SQL_TIME           to ColumnType[i].iSQLType
96641>>>//        Move "TIME"             to ColumnType[i].sSQLType
96641>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
96641>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
96641>>>//        Move "19.0"             to ColumnType[i].sPrecision
96641>>>//        Move True               to ColumnType[i].bCanEditSize
96641>>>//        Increment i
96641>>>//
96641>>>//        Move SQL_TIMESTAMP      to ColumnType[i].iSQLType
96641>>>//        Move "TIMESTAMP"        to ColumnType[i].sSQLType
96641>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
96641>>>//        Move "DATETIME"         to ColumnType[i].sDataFlexType
96641>>>//        Move "23.6"             to ColumnType[i].sPrecision
96641>>>//        Move True               to ColumnType[i].bCanEditSize
96641>>>//        Increment i
96641>>>//
96641>>>//        Move SQL_VARCHAR        to ColumnType[i].iSQLType
96641>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
96641>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
96641>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
96641>>>//        Move "16384"            to ColumnType[i].sPrecision
96641>>>//        Increment i
96641>>>//
96641>>>//        // ToDo: We need to change the sType when using this!
96641>>>//        Move SQL_VARCHARBIT         to ColumnType[i].iSQLType
96641>>>//        Move "VARCHAR FOR BIT DATA" to ColumnType[i].sSQLType
96641>>>//        Move DF_TEXT                to ColumnType[i].iDataFlexType
96641>>>//        Move "TEXT"                 to ColumnType[i].sDataFlexType
96641>>>//        Move "16384"                to ColumnType[i].sPrecision
96641>>>//        Increment i
96641>>>//
96641>>>//        Move SQL_VARGRAPHIC     to ColumnType[i].iSQLType
96641>>>//        Move "VARGRAPHIC"       to ColumnType[i].sSQLType
96641>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
96641>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
96641>>>//        Move "16384"            to ColumnType[i].sPrecision
96641>>>//
96641>>>//        Move SQL_XML            to ColumnType[i].iSQLType
96641>>>//        Move "XML"              to ColumnType[i].sSQLType
96641>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
96641>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
96641>>>//        Move "16384"            to ColumnType[i].sPrecision
96641>>>
96641>>>        Function_Return aColumnType
96642>>>    End_Function
96643>>>
96643>>>    // Microsoft SQL Server Database Data Types:
96643>>>    // Helper function for UtilEnumerateColumnTypes
96643>>>    Function _UtilEnumerateMSSQLTypes String sDriverID Returns tColumnType[]
96645>>>        tColumnType[] aColumnType
96645>>>        tColumnType[] aColumnType
96646>>>        Integer i
96646>>>
96646>>>        If (sDriverID = MSSQLDRV_ID) Begin
Including file: MSSQLDRV_DriverDef.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\MSSQLDRV_DriverDef.inc)
96648>>>>// Generated By The Database Update Framework
96648>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\bin\MSSQLDRV_DriverDef.xml
96648>>>>// Driver COLUMN DATA TYPES
96648>>>>//
96648>>>>// Created: 2018-03-15 00:00:57.024
96648>>>>
96648>>>>            Move "bigint"                                to aColumnType[i].sSQLType
96649>>>>            Move -5                                      to aColumnType[i].iSQLType
96650>>>>            Move True                                    to aColumnType[i].bCanEditSize
96651>>>>            Move True                                    to aColumnType[i].bNativeDataType
96652>>>>            Move 14                                      to aColumnType[i].iDefaultSize
96653>>>>            Move 1                                       to aColumnType[i].iMinSize
96654>>>>            Move 14                                      to aColumnType[i].nMaxSize
96655>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
96656>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
96657>>>>            Move 14                                      to aColumnType[i].sPrecision
96658>>>>            Increment i
96659>>>>
96659>>>>            Move "binary"                                to aColumnType[i].sSQLType
96660>>>>            Move -2                                      to aColumnType[i].iSQLType
96661>>>>            Move True                                    to aColumnType[i].bCanEditSize
96662>>>>            Move True                                    to aColumnType[i].bNativeDataType
96663>>>>            Move -1                                      to aColumnType[i].iDefaultSize
96664>>>>            Move 1                                       to aColumnType[i].iMinSize
96665>>>>            Move 8000                                    to aColumnType[i].nMaxSize
96666>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
96667>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
96668>>>>            Move 8000                                    to aColumnType[i].sPrecision
96669>>>>            Increment i
96670>>>>
96670>>>>            Move "bit"                                   to aColumnType[i].sSQLType
96671>>>>            Move -7                                      to aColumnType[i].iSQLType
96672>>>>            Move False                                   to aColumnType[i].bCanEditSize
96673>>>>            Move True                                    to aColumnType[i].bNativeDataType
96674>>>>            Move 0                                       to aColumnType[i].iDefaultSize
96675>>>>            Move 0                                       to aColumnType[i].iMinSize
96676>>>>            Move 0                                       to aColumnType[i].nMaxSize
96677>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
96678>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
96679>>>>            Move 1                                       to aColumnType[i].sPrecision
96680>>>>            Increment i
96681>>>>
96681>>>>            Move "char"                                  to aColumnType[i].sSQLType
96682>>>>            Move 1                                       to aColumnType[i].iSQLType
96683>>>>            Move True                                    to aColumnType[i].bCanEditSize
96684>>>>            Move True                                    to aColumnType[i].bNativeDataType
96685>>>>            Move -1                                      to aColumnType[i].iDefaultSize
96686>>>>            Move 1                                       to aColumnType[i].iMinSize
96687>>>>            Move 8000                                    to aColumnType[i].nMaxSize
96688>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
96689>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
96690>>>>            Move 8000                                    to aColumnType[i].sPrecision
96691>>>>            Increment i
96692>>>>
96692>>>>            Move "date"                                  to aColumnType[i].sSQLType
96693>>>>            Move 91                                      to aColumnType[i].iSQLType
96694>>>>            Move False                                   to aColumnType[i].bCanEditSize
96695>>>>            Move True                                    to aColumnType[i].bNativeDataType
96696>>>>            Move 0                                       to aColumnType[i].iDefaultSize
96697>>>>            Move 0                                       to aColumnType[i].iMinSize
96698>>>>            Move 0                                       to aColumnType[i].nMaxSize
96699>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
96700>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
96701>>>>            Move 6                                       to aColumnType[i].sPrecision
96702>>>>            Increment i
96703>>>>
96703>>>>            Move "datetime"                              to aColumnType[i].sSQLType
96704>>>>            Move 93                                      to aColumnType[i].iSQLType
96705>>>>            Move False                                   to aColumnType[i].bCanEditSize
96706>>>>            Move True                                    to aColumnType[i].bNativeDataType
96707>>>>            Move -1                                      to aColumnType[i].iDefaultSize
96708>>>>            Move -1                                      to aColumnType[i].iMinSize
96709>>>>            Move -1                                      to aColumnType[i].nMaxSize
96710>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
96711>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
96712>>>>            Move 23                                      to aColumnType[i].sPrecision
96713>>>>            Increment i
96714>>>>
96714>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
96715>>>>            Move -200                                    to aColumnType[i].iSQLType
96716>>>>            Move True                                    to aColumnType[i].bCanEditSize
96717>>>>            Move True                                    to aColumnType[i].bNativeDataType
96718>>>>            Move 23                                      to aColumnType[i].iDefaultSize
96719>>>>            Move 23                                      to aColumnType[i].iMinSize
96720>>>>            Move 23                                      to aColumnType[i].nMaxSize
96721>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
96722>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
96723>>>>            Move 23                                      to aColumnType[i].sPrecision
96724>>>>            Increment i
96725>>>>
96725>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
96726>>>>            Move -155                                    to aColumnType[i].iSQLType
96727>>>>            Move True                                    to aColumnType[i].bCanEditSize
96728>>>>            Move True                                    to aColumnType[i].bNativeDataType
96729>>>>            Move 34                                      to aColumnType[i].iDefaultSize
96730>>>>            Move 34                                      to aColumnType[i].iMinSize
96731>>>>            Move 34                                      to aColumnType[i].nMaxSize
96732>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
96733>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
96734>>>>            Move 34                                      to aColumnType[i].sPrecision
96735>>>>            Increment i
96736>>>>
96736>>>>            Move "decimal"                               to aColumnType[i].sSQLType
96737>>>>            Move 3                                       to aColumnType[i].iSQLType
96738>>>>            Move True                                    to aColumnType[i].bCanEditSize
96739>>>>            Move True                                    to aColumnType[i].bNativeDataType
96740>>>>            Move -1                                      to aColumnType[i].iDefaultSize
96741>>>>            Move 1                                       to aColumnType[i].iMinSize
96742>>>>            Move 14                                      to aColumnType[i].nMaxSize
96743>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
96744>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
96745>>>>            Move 14                                      to aColumnType[i].sPrecision
96746>>>>            Increment i
96747>>>>
96747>>>>            Move "float"                                 to aColumnType[i].sSQLType
96748>>>>            Move 6                                       to aColumnType[i].iSQLType
96749>>>>            Move True                                    to aColumnType[i].bCanEditSize
96750>>>>            Move True                                    to aColumnType[i].bNativeDataType
96751>>>>            Move 14                                      to aColumnType[i].iDefaultSize
96752>>>>            Move 1                                       to aColumnType[i].iMinSize
96753>>>>            Move 14                                      to aColumnType[i].nMaxSize
96754>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
96755>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
96756>>>>            Move 14                                      to aColumnType[i].sPrecision
96757>>>>            Increment i
96758>>>>
96758>>>>            Move "image"                                 to aColumnType[i].sSQLType
96759>>>>            Move -4                                      to aColumnType[i].iSQLType
96760>>>>            Move True                                    to aColumnType[i].bCanEditSize
96761>>>>            Move True                                    to aColumnType[i].bNativeDataType
96762>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
96763>>>>            Move 1                                       to aColumnType[i].iMinSize
96764>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
96765>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
96766>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
96767>>>>            Move 2000000000                              to aColumnType[i].sPrecision
96768>>>>            Increment i
96769>>>>
96769>>>>            Move "int"                                   to aColumnType[i].sSQLType
96770>>>>            Move 4                                       to aColumnType[i].iSQLType
96771>>>>            Move True                                    to aColumnType[i].bCanEditSize
96772>>>>            Move True                                    to aColumnType[i].bNativeDataType
96773>>>>            Move 10                                      to aColumnType[i].iDefaultSize
96774>>>>            Move 1                                       to aColumnType[i].iMinSize
96775>>>>            Move 10                                      to aColumnType[i].nMaxSize
96776>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
96777>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
96778>>>>            Move 10                                      to aColumnType[i].sPrecision
96779>>>>            Increment i
96780>>>>
96780>>>>            Move "money"                                 to aColumnType[i].sSQLType
96781>>>>            Move -204                                    to aColumnType[i].iSQLType
96782>>>>            Move False                                   to aColumnType[i].bCanEditSize
96783>>>>            Move True                                    to aColumnType[i].bNativeDataType
96784>>>>            Move 0                                       to aColumnType[i].iDefaultSize
96785>>>>            Move 0                                       to aColumnType[i].iMinSize
96786>>>>            Move 0                                       to aColumnType[i].nMaxSize
96787>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
96788>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
96789>>>>            Move 1                                       to aColumnType[i].sPrecision
96790>>>>            Increment i
96791>>>>
96791>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
96792>>>>            Move -8                                      to aColumnType[i].iSQLType
96793>>>>            Move True                                    to aColumnType[i].bCanEditSize
96794>>>>            Move True                                    to aColumnType[i].bNativeDataType
96795>>>>            Move -1                                      to aColumnType[i].iDefaultSize
96796>>>>            Move 1                                       to aColumnType[i].iMinSize
96797>>>>            Move 4000                                    to aColumnType[i].nMaxSize
96798>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
96799>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
96800>>>>            Move 4000                                    to aColumnType[i].sPrecision
96801>>>>            Increment i
96802>>>>
96802>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
96803>>>>            Move -10                                     to aColumnType[i].iSQLType
96804>>>>            Move True                                    to aColumnType[i].bCanEditSize
96805>>>>            Move True                                    to aColumnType[i].bNativeDataType
96806>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
96807>>>>            Move 1                                       to aColumnType[i].iMinSize
96808>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
96809>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
96810>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
96811>>>>            Move 2000000000                              to aColumnType[i].sPrecision
96812>>>>            Increment i
96813>>>>
96813>>>>            Move "numeric"                               to aColumnType[i].sSQLType
96814>>>>            Move 2                                       to aColumnType[i].iSQLType
96815>>>>            Move True                                    to aColumnType[i].bCanEditSize
96816>>>>            Move True                                    to aColumnType[i].bNativeDataType
96817>>>>            Move -1                                      to aColumnType[i].iDefaultSize
96818>>>>            Move 1                                       to aColumnType[i].iMinSize
96819>>>>            Move 14                                      to aColumnType[i].nMaxSize
96820>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
96821>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
96822>>>>            Move 14                                      to aColumnType[i].sPrecision
96823>>>>            Increment i
96824>>>>
96824>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
96825>>>>            Move -9                                      to aColumnType[i].iSQLType
96826>>>>            Move True                                    to aColumnType[i].bCanEditSize
96827>>>>            Move True                                    to aColumnType[i].bNativeDataType
96828>>>>            Move -1                                      to aColumnType[i].iDefaultSize
96829>>>>            Move 1                                       to aColumnType[i].iMinSize
96830>>>>            Move 4000                                    to aColumnType[i].nMaxSize
96831>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
96832>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
96833>>>>            Move 4000                                    to aColumnType[i].sPrecision
96834>>>>            Increment i
96835>>>>
96835>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
96836>>>>            Move -202                                    to aColumnType[i].iSQLType
96837>>>>            Move True                                    to aColumnType[i].bCanEditSize
96838>>>>            Move True                                    to aColumnType[i].bNativeDataType
96839>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
96840>>>>            Move 1                                       to aColumnType[i].iMinSize
96841>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
96842>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
96843>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
96844>>>>            Move 2000000000                              to aColumnType[i].sPrecision
96845>>>>            Increment i
96846>>>>
96846>>>>            Move "real"                                  to aColumnType[i].sSQLType
96847>>>>            Move 7                                       to aColumnType[i].iSQLType
96848>>>>            Move True                                    to aColumnType[i].bCanEditSize
96849>>>>            Move True                                    to aColumnType[i].bNativeDataType
96850>>>>            Move 14                                      to aColumnType[i].iDefaultSize
96851>>>>            Move 1                                       to aColumnType[i].iMinSize
96852>>>>            Move 14                                      to aColumnType[i].nMaxSize
96853>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
96854>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
96855>>>>            Move 14                                      to aColumnType[i].sPrecision
96856>>>>            Increment i
96857>>>>
96857>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
96858>>>>            Move -206                                    to aColumnType[i].iSQLType
96859>>>>            Move False                                   to aColumnType[i].bCanEditSize
96860>>>>            Move True                                    to aColumnType[i].bNativeDataType
96861>>>>            Move 0                                       to aColumnType[i].iDefaultSize
96862>>>>            Move 0                                       to aColumnType[i].iMinSize
96863>>>>            Move 0                                       to aColumnType[i].nMaxSize
96864>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
96865>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
96866>>>>            Move 1                                       to aColumnType[i].sPrecision
96867>>>>            Increment i
96868>>>>
96868>>>>            Move "smallint"                              to aColumnType[i].sSQLType
96869>>>>            Move 5                                       to aColumnType[i].iSQLType
96870>>>>            Move True                                    to aColumnType[i].bCanEditSize
96871>>>>            Move True                                    to aColumnType[i].bNativeDataType
96872>>>>            Move 5                                       to aColumnType[i].iDefaultSize
96873>>>>            Move 1                                       to aColumnType[i].iMinSize
96874>>>>            Move 5                                       to aColumnType[i].nMaxSize
96875>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
96876>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
96877>>>>            Move 5                                       to aColumnType[i].sPrecision
96878>>>>            Increment i
96879>>>>
96879>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
96880>>>>            Move -205                                    to aColumnType[i].iSQLType
96881>>>>            Move False                                   to aColumnType[i].bCanEditSize
96882>>>>            Move True                                    to aColumnType[i].bNativeDataType
96883>>>>            Move 0                                       to aColumnType[i].iDefaultSize
96884>>>>            Move 0                                       to aColumnType[i].iMinSize
96885>>>>            Move 0                                       to aColumnType[i].nMaxSize
96886>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
96887>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
96888>>>>            Move 1                                       to aColumnType[i].sPrecision
96889>>>>            Increment i
96890>>>>
96890>>>>            Move "text"                                  to aColumnType[i].sSQLType
96891>>>>            Move -1                                      to aColumnType[i].iSQLType
96892>>>>            Move True                                    to aColumnType[i].bCanEditSize
96893>>>>            Move True                                    to aColumnType[i].bNativeDataType
96894>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
96895>>>>            Move 1                                       to aColumnType[i].iMinSize
96896>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
96897>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
96898>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
96899>>>>            Move 2000000000                              to aColumnType[i].sPrecision
96900>>>>            Increment i
96901>>>>
96901>>>>            Move "time"                                  to aColumnType[i].sSQLType
96902>>>>            Move -154                                    to aColumnType[i].iSQLType
96903>>>>            Move True                                    to aColumnType[i].bCanEditSize
96904>>>>            Move True                                    to aColumnType[i].bNativeDataType
96905>>>>            Move 10                                      to aColumnType[i].iDefaultSize
96906>>>>            Move 10                                      to aColumnType[i].iMinSize
96907>>>>            Move 19                                      to aColumnType[i].nMaxSize
96908>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
96909>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
96910>>>>            Move 19                                      to aColumnType[i].sPrecision
96911>>>>            Increment i
96912>>>>
96912>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
96913>>>>            Move -6                                      to aColumnType[i].iSQLType
96914>>>>            Move True                                    to aColumnType[i].bCanEditSize
96915>>>>            Move True                                    to aColumnType[i].bNativeDataType
96916>>>>            Move 3                                       to aColumnType[i].iDefaultSize
96917>>>>            Move 1                                       to aColumnType[i].iMinSize
96918>>>>            Move 3                                       to aColumnType[i].nMaxSize
96919>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
96920>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
96921>>>>            Move 3                                       to aColumnType[i].sPrecision
96922>>>>            Increment i
96923>>>>
96923>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
96924>>>>            Move -11                                     to aColumnType[i].iSQLType
96925>>>>            Move False                                   to aColumnType[i].bCanEditSize
96926>>>>            Move True                                    to aColumnType[i].bNativeDataType
96927>>>>            Move 0                                       to aColumnType[i].iDefaultSize
96928>>>>            Move 0                                       to aColumnType[i].iMinSize
96929>>>>            Move 0                                       to aColumnType[i].nMaxSize
96930>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
96931>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
96932>>>>            Move 1                                       to aColumnType[i].sPrecision
96933>>>>            Increment i
96934>>>>
96934>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
96935>>>>            Move -3                                      to aColumnType[i].iSQLType
96936>>>>            Move True                                    to aColumnType[i].bCanEditSize
96937>>>>            Move True                                    to aColumnType[i].bNativeDataType
96938>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
96939>>>>            Move 1                                       to aColumnType[i].iMinSize
96940>>>>            Move 8000                                    to aColumnType[i].nMaxSize
96941>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
96942>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
96943>>>>            Move 8000                                    to aColumnType[i].sPrecision
96944>>>>            Increment i
96945>>>>
96945>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
96946>>>>            Move -203                                    to aColumnType[i].iSQLType
96947>>>>            Move True                                    to aColumnType[i].bCanEditSize
96948>>>>            Move True                                    to aColumnType[i].bNativeDataType
96949>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
96950>>>>            Move 1                                       to aColumnType[i].iMinSize
96951>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
96952>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
96953>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
96954>>>>            Move 2000000000                              to aColumnType[i].sPrecision
96955>>>>            Increment i
96956>>>>
96956>>>>            Move "varchar"                               to aColumnType[i].sSQLType
96957>>>>            Move 12                                      to aColumnType[i].iSQLType
96958>>>>            Move True                                    to aColumnType[i].bCanEditSize
96959>>>>            Move True                                    to aColumnType[i].bNativeDataType
96960>>>>            Move -1                                      to aColumnType[i].iDefaultSize
96961>>>>            Move 1                                       to aColumnType[i].iMinSize
96962>>>>            Move 8000                                    to aColumnType[i].nMaxSize
96963>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
96964>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
96965>>>>            Move 8000                                    to aColumnType[i].sPrecision
96966>>>>            Increment i
96967>>>>
96967>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
96968>>>>            Move -201                                    to aColumnType[i].iSQLType
96969>>>>            Move True                                    to aColumnType[i].bCanEditSize
96970>>>>            Move True                                    to aColumnType[i].bNativeDataType
96971>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
96972>>>>            Move 1                                       to aColumnType[i].iMinSize
96973>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
96974>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
96975>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
96976>>>>            Move 2000000000                              to aColumnType[i].sPrecision
96977>>>>            Increment i
96978>>>>
96978>>>>            Move "xml"                                   to aColumnType[i].sSQLType
96979>>>>            Move -152                                    to aColumnType[i].iSQLType
96980>>>>            Move True                                    to aColumnType[i].bCanEditSize
96981>>>>            Move True                                    to aColumnType[i].bNativeDataType
96982>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
96983>>>>            Move 1                                       to aColumnType[i].iMinSize
96984>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
96985>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
96986>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
96987>>>>            Move 2000000000                              to aColumnType[i].sPrecision
96988>>>>            Increment i
96989>>>>
96989>>>>
96989>>>            
96989>>>//            Move SQL_BIGINT         to ColumnType[i].iSQLType
96989>>>//            Move "bigint"           to ColumnType[i].sSQLType
96989>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
96989>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
96989>>>//            Move "14.0"             to ColumnType[i].sPrecision
96989>>>//            Move True               to ColumnType[i].bCanEditSize
96989>>>//            Increment i
96989>>>//
96989>>>//            Move SQL_BINARY         to ColumnType[i].iSQLType
96989>>>//            Move "binary"           to ColumnType[i].sSQLType
96989>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
96989>>>//            Move "Binary"           to ColumnType[i].sDataFlexType
96989>>>//            Move "8000"             to ColumnType[i].sPrecision
96989>>>//            Increment i
96989>>>//
96989>>>//            Move SQL_BIT            to ColumnType[i].iSQLType
96989>>>//            Move "bit"              to ColumnType[i].sSQLType
96989>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
96989>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
96989>>>//            Move "1.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
96989>>>//            Move True               to ColumnType[i].bCanEditSize
96989>>>//            Increment i
96989>>>//
96989>>>//            Move SQL_CHAR           to ColumnType[i].iSQLType
96989>>>//            Move "char"             to ColumnType[i].sSQLType
96989>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
96989>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
96989>>>//            Move "8000"             to ColumnType[i].sPrecision
96989>>>//            Increment i
96989>>>//
96989>>>//            Move SQL_DATE           to ColumnType[i].iSQLType
96989>>>//            Move "date"             to ColumnType[i].sSQLType
96989>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
96989>>>//            Move "Date"             to ColumnType[i].sDataFlexType
96989>>>//            Move "6.0"              to ColumnType[i].sPrecision
96989>>>//            Move True               to ColumnType[i].bCanEditSize
96989>>>//            Increment i
96989>>>//
96989>>>//            Move SQL_DATETIME       to ColumnType[i].iSQLType
96989>>>//            Move "datetime"         to ColumnType[i].sSQLType
96989>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
96989>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
96989>>>//            Move "23.3"             to ColumnType[i].sPrecision
96989>>>//            Move True               to ColumnType[i].bCanEditSize
96989>>>//            Increment i
96989>>>//
96989>>>//            Move SQL_TYPE_TIMESTAMP2 to ColumnType[i].iSQLType
96989>>>//            Move "datetime2"         to ColumnType[i].sSQLType
96989>>>//            Move DF_DATETIME         to ColumnType[i].iDataFlexType
96989>>>//            Move "DateTime"          to ColumnType[i].sDataFlexType
96989>>>//            Move "23.6"              to ColumnType[i].sPrecision
96989>>>//            Move True                to ColumnType[i].bCanEditSize
96989>>>//            Increment i
96989>>>//
96989>>>//            Move SQL_SS_TIMESTAMPOFFSET to ColumnType[i].iSQLType
96989>>>//            Move "datetimeoffset"       to ColumnType[i].sSQLType
96989>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
96989>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
96989>>>//            Move "34.0"                 to ColumnType[i].sPrecision
96989>>>//            Move True                   to ColumnType[i].bCanEditSize
96989>>>//            Increment i
96989>>>//
96989>>>//            Move SQL_DECIMAL        to ColumnType[i].iSQLType
96989>>>//            Move "decimal"          to ColumnType[i].sSQLType
96989>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
96989>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
96989>>>//            Move "14.8"             to ColumnType[i].sPrecision
96989>>>//            Increment i
96989>>>//
96989>>>//            Move SQL_FLOAT          to ColumnType[i].iSQLType
96989>>>//            Move "float"            to ColumnType[i].sSQLType
96989>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
96989>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
96989>>>//            Move "14.8"             to ColumnType[i].sPrecision
96989>>>//            Increment i
96989>>>//
96989>>>//            Move SQL_INTEGER        to ColumnType[i].iSQLType
96989>>>//            Move "int"              to ColumnType[i].sSQLType
96989>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
96989>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
96989>>>//            Move "8.0"              to ColumnType[i].sPrecision
96989>>>//            Move True               to ColumnType[i].bCanEditSize
96989>>>//            Increment i
96989>>>//
96989>>>//            Move SQL_TYPE_MONEY     to ColumnType[i].iSQLType
96989>>>//            Move "money"            to ColumnType[i].sSQLType
96989>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
96989>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
96989>>>//            Move "15.4"             to ColumnType[i].sPrecision // Studio 18.0 (!)
96989>>>//            Increment i
96989>>>//
96989>>>//            Move SQL_WCHAR          to ColumnType[i].iSQLType
96989>>>//            Move "nchar"            to ColumnType[i].sSQLType
96989>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
96989>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
96989>>>//            Move "4000"             to ColumnType[i].sPrecision
96989>>>//            Increment i
96989>>>//
96989>>>//            Move SQL_WLONGVARCHAR   to ColumnType[i].iSQLType
96989>>>//            Move "ntext"            to ColumnType[i].sSQLType
96989>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
96989>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
96989>>>//            Move "16384"            to ColumnType[i].sPrecision
96989>>>//            Increment i
96989>>>//
96989>>>//            Move SQL_NUMERIC        to ColumnType[i].iSQLType
96989>>>//            Move "numeric"          to ColumnType[i].sSQLType
96989>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
96989>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
96989>>>//            Move "14.8"             to ColumnType[i].sPrecision
96989>>>//            Increment i
96989>>>//
96989>>>//            Move SQL_WVARCHAR       to ColumnType[i].iSQLType
96989>>>//            Move "nvarchar"         to ColumnType[i].sSQLType
96989>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
96989>>>//            Move "Text"             to ColumnType[i].sDataFlexType
96989>>>//            Move "4000"             to ColumnType[i].sPrecision
96989>>>//            Increment i
96989>>>//
96989>>>//            Move SQL_VARCHARMAX     to ColumnType[i].iSQLType
96989>>>//            Move "nvarchar(max)"    to ColumnType[i].sSQLType
96989>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
96989>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
96989>>>//            Move "16384"            to ColumnType[i].sPrecision
96989>>>//            Move True               to ColumnType[i].bCanEditSize
96989>>>//            Increment i
96989>>>//
96989>>>//            Move SQL_REAL           to ColumnType[i].iSQLType
96989>>>//            Move "real"             to ColumnType[i].sSQLType
96989>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
96989>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
96989>>>//            Move "14.8"             to ColumnType[i].sPrecision
96989>>>//            Increment i
96989>>>//
96989>>>//            Move SQL_TYPE_SMALLDATETIME to ColumnType[i].iSQLType
96989>>>//            Move "smalldatetime"        to ColumnType[i].sSQLType
96989>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
96989>>>//            Move "DATETIME"             to ColumnType[i].sDataFlexType
96989>>>//            Move "23.0"                 to ColumnType[i].sPrecision
96989>>>//            Move True                   to ColumnType[i].bCanEditSize
96989>>>//            Increment i
96989>>>//
96989>>>//            Move SQL_SMALLINT       to ColumnType[i].iSQLType
96989>>>//            Move "smallint"         to ColumnType[i].sSQLType
96989>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
96989>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
96989>>>//            Move "4.0"              to ColumnType[i].sPrecision
96989>>>//            Move True               to ColumnType[i].bCanEditSize
96989>>>//            Increment i
96989>>>//
96989>>>//            Move SQL_TYPE_SMALLMONEY to ColumnType[i].iSQLType
96989>>>//            Move "smallmoney"        to ColumnType[i].sSQLType
96989>>>//            Move DF_BCD              to ColumnType[i].iDataFlexType
96989>>>//            Move "NUMERIC"           to ColumnType[i].sDataFlexType
96989>>>//            Move "10.0"              to ColumnType[i].sPrecision
96989>>>//            Increment i
96989>>>//
96989>>>//            Move SQL_TEXT           to ColumnType[i].iSQLType
96989>>>//            Move "text"             to ColumnType[i].sSQLType
96989>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
96989>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
96989>>>//            Move "8000"             to ColumnType[i].sPrecision
96989>>>//            Move True               to ColumnType[i].bCanEditSize
96989>>>//            Increment i
96989>>>//
96989>>>//            Move SQL_TIME           to ColumnType[i].iSQLType
96989>>>//            Move "time"             to ColumnType[i].sSQLType
96989>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
96989>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
96989>>>//            Move "19.0"             to ColumnType[i].sPrecision
96989>>>//            Move True               to ColumnType[i].bCanEditSize
96989>>>//            Increment i
96989>>>//
96989>>>//            Move SQL_TINYINT        to ColumnType[i].iSQLType
96989>>>//            Move "tinyint"          to ColumnType[i].sSQLType
96989>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
96989>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
96989>>>//            Move "2.0"              to ColumnType[i].sPrecision
96989>>>//            Move True               to ColumnType[i].bCanEditSize
96989>>>//            Increment i
96989>>>//
96989>>>//            Move SQL_GUID           to ColumnType[i].iSQLType
96989>>>//            Move "uniqueidentifier" to ColumnType[i].sSQLType
96989>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
96989>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
96989>>>//            Move "36"               to ColumnType[i].sPrecision
96989>>>//            Move True               to ColumnType[i].bCanEditSize
96989>>>//            Increment i
96989>>>//
96989>>>//            Move SQL_VARBINARY      to ColumnType[i].iSQLType
96989>>>//            Move "varbinary"        to ColumnType[i].sSQLType
96989>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
96989>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
96989>>>//            Move "16384"            to ColumnType[i].sPrecision
96989>>>//            Increment i
96989>>>//
96989>>>//            Move SQL_LONGVARBINARY  to ColumnType[i].iSQLType
96989>>>//            Move "varbinary(max)"   to ColumnType[i].sSQLType
96989>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
96989>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
96989>>>//            Move "16384"            to ColumnType[i].sPrecision
96989>>>//            Move True               to ColumnType[i].bCanEditSize
96989>>>//            Increment i
96989>>>//
96989>>>//            Move SQL_VARCHAR        to ColumnType[i].iSQLType
96989>>>//            Move "varchar"          to ColumnType[i].sSQLType
96989>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
96989>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
96989>>>//            Move "8000"             to ColumnType[i].sPrecision
96989>>>//            Increment i
96989>>>//
96989>>>//            Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
96989>>>//            Move "varchar(max)"     to ColumnType[i].sSQLType
96989>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
96989>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
96989>>>//            Move "16384"            to ColumnType[i].sPrecision
96989>>>//            Move True               to ColumnType[i].bCanEditSize
96989>>>//            Increment i
96989>>>//
96989>>>//            Move SQL_SS_XML         to ColumnType[i].iSQLType
96989>>>//            Move "xml"              to ColumnType[i].sSQLType
96989>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
96989>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
96989>>>//            Move "16384"            to ColumnType[i].sPrecision
96989>>>//            Increment i
96989>>>//
96989>>>//            Move SQL_TYPE_DATE      to ColumnType[i].iSQLType
96989>>>//            Move "DATE"             to ColumnType[i].sSQLType
96989>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
96989>>>//            Move "date"             to ColumnType[i].sDataFlexType
96989>>>//            Move "6.0"              to ColumnType[i].sPrecision
96989>>>//            Move True               to ColumnType[i].bCanEditSize
96989>>>//            Increment i
96989>>>//
96989>>>//            Move SQL_TYPE_TIME      to ColumnType[i].iSQLType
96989>>>//            Move "time"             to ColumnType[i].sSQLType
96989>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
96989>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
96989>>>//            Move "8.7"              to ColumnType[i].sPrecision
96989>>>//            Move True               to ColumnType[i].bCanEditSize
96989>>>//            Increment i
96989>>>//
96989>>>//            Move SQL_TYPE_TIMESTAMP to ColumnType[i].iSQLType
96989>>>//            Move "datetime"         to ColumnType[i].sSQLType
96989>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
96989>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
96989>>>//            Move "23.6"             to ColumnType[i].sPrecision
96989>>>//            Move True               to ColumnType[i].bCanEditSize
96989>>>//            Increment i
96989>>>
96989>>>        End
96989>>>>
96989>>>
96989>>>        // Mertech SQLFlex driver
96989>>>        If (sDriverID = SQLFLEX) Begin
96991>>>
Including file: sql_drv_DriverDef.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\sql_drv_DriverDef.inc)
96991>>>>// Generated By The Database Update Framework
96991>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\sql_drv_DriverDef.xml
96991>>>>// Driver COLUMN DATA TYPES
96991>>>>//
96991>>>>// Created: 2018-03-14 23:47:46.885
96991>>>>
96991>>>>            Move "bigint"                                to aColumnType[i].sSQLType
96992>>>>            Move -5                                      to aColumnType[i].iSQLType
96993>>>>            Move True                                    to aColumnType[i].bCanEditSize
96994>>>>            Move True                                    to aColumnType[i].bNativeDataType
96995>>>>            Move 14                                      to aColumnType[i].iDefaultSize
96996>>>>            Move 1                                       to aColumnType[i].iMinSize
96997>>>>            Move 14                                      to aColumnType[i].nMaxSize
96998>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
96999>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
97000>>>>            Move 14                                      to aColumnType[i].sPrecision
97001>>>>            Increment i
97002>>>>
97002>>>>            Move "binary"                                to aColumnType[i].sSQLType
97003>>>>            Move -2                                      to aColumnType[i].iSQLType
97004>>>>            Move True                                    to aColumnType[i].bCanEditSize
97005>>>>            Move True                                    to aColumnType[i].bNativeDataType
97006>>>>            Move -1                                      to aColumnType[i].iDefaultSize
97007>>>>            Move 1                                       to aColumnType[i].iMinSize
97008>>>>            Move 8000                                    to aColumnType[i].nMaxSize
97009>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
97010>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
97011>>>>            Move 8000                                    to aColumnType[i].sPrecision
97012>>>>            Increment i
97013>>>>
97013>>>>            Move "bit"                                   to aColumnType[i].sSQLType
97014>>>>            Move -7                                      to aColumnType[i].iSQLType
97015>>>>            Move False                                   to aColumnType[i].bCanEditSize
97016>>>>            Move True                                    to aColumnType[i].bNativeDataType
97017>>>>            Move 1                                       to aColumnType[i].iDefaultSize
97018>>>>            Move -1                                      to aColumnType[i].iMinSize
97019>>>>            Move -1                                      to aColumnType[i].nMaxSize
97020>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
97021>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
97022>>>>            Move -1                                      to aColumnType[i].sPrecision
97023>>>>            Increment i
97024>>>>
97024>>>>            Move "char"                                  to aColumnType[i].sSQLType
97025>>>>            Move 1                                       to aColumnType[i].iSQLType
97026>>>>            Move True                                    to aColumnType[i].bCanEditSize
97027>>>>            Move True                                    to aColumnType[i].bNativeDataType
97028>>>>            Move -1                                      to aColumnType[i].iDefaultSize
97029>>>>            Move 1                                       to aColumnType[i].iMinSize
97030>>>>            Move 8000                                    to aColumnType[i].nMaxSize
97031>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
97032>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
97033>>>>            Move 8000                                    to aColumnType[i].sPrecision
97034>>>>            Increment i
97035>>>>
97035>>>>            Move "date"                                  to aColumnType[i].sSQLType
97036>>>>            Move 40                                      to aColumnType[i].iSQLType
97037>>>>            Move False                                   to aColumnType[i].bCanEditSize
97038>>>>            Move True                                    to aColumnType[i].bNativeDataType
97039>>>>            Move 12                                      to aColumnType[i].iDefaultSize
97040>>>>            Move -1                                      to aColumnType[i].iMinSize
97041>>>>            Move -1                                      to aColumnType[i].nMaxSize
97042>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
97043>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
97044>>>>            Move -1                                      to aColumnType[i].sPrecision
97045>>>>            Increment i
97046>>>>
97046>>>>            Move "datetime"                              to aColumnType[i].sSQLType
97047>>>>            Move 11                                      to aColumnType[i].iSQLType
97048>>>>            Move True                                    to aColumnType[i].bCanEditSize
97049>>>>            Move True                                    to aColumnType[i].bNativeDataType
97050>>>>            Move 6                                       to aColumnType[i].iDefaultSize
97051>>>>            Move 6                                       to aColumnType[i].iMinSize
97052>>>>            Move 23                                      to aColumnType[i].nMaxSize
97053>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
97054>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
97055>>>>            Move 23                                      to aColumnType[i].sPrecision
97056>>>>            Increment i
97057>>>>
97057>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
97058>>>>            Move 42                                      to aColumnType[i].iSQLType
97059>>>>            Move True                                    to aColumnType[i].bCanEditSize
97060>>>>            Move True                                    to aColumnType[i].bNativeDataType
97061>>>>            Move 6                                       to aColumnType[i].iDefaultSize
97062>>>>            Move 6                                       to aColumnType[i].iMinSize
97063>>>>            Move 23                                      to aColumnType[i].nMaxSize
97064>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
97065>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
97066>>>>            Move 23                                      to aColumnType[i].sPrecision
97067>>>>            Increment i
97068>>>>
97068>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
97069>>>>            Move 43                                      to aColumnType[i].iSQLType
97070>>>>            Move True                                    to aColumnType[i].bCanEditSize
97071>>>>            Move True                                    to aColumnType[i].bNativeDataType
97072>>>>            Move 12                                      to aColumnType[i].iDefaultSize
97073>>>>            Move 12                                      to aColumnType[i].iMinSize
97074>>>>            Move 23                                      to aColumnType[i].nMaxSize
97075>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
97076>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
97077>>>>            Move 23                                      to aColumnType[i].sPrecision
97078>>>>            Increment i
97079>>>>
97079>>>>            Move "decimal"                               to aColumnType[i].sSQLType
97080>>>>            Move 3                                       to aColumnType[i].iSQLType
97081>>>>            Move True                                    to aColumnType[i].bCanEditSize
97082>>>>            Move True                                    to aColumnType[i].bNativeDataType
97083>>>>            Move 14                                      to aColumnType[i].iDefaultSize
97084>>>>            Move 1                                       to aColumnType[i].iMinSize
97085>>>>            Move 14                                      to aColumnType[i].nMaxSize
97086>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
97087>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
97088>>>>            Move 14                                      to aColumnType[i].sPrecision
97089>>>>            Increment i
97090>>>>
97090>>>>            Move "float"                                 to aColumnType[i].sSQLType
97091>>>>            Move 6                                       to aColumnType[i].iSQLType
97092>>>>            Move True                                    to aColumnType[i].bCanEditSize
97093>>>>            Move True                                    to aColumnType[i].bNativeDataType
97094>>>>            Move 14                                      to aColumnType[i].iDefaultSize
97095>>>>            Move 1                                       to aColumnType[i].iMinSize
97096>>>>            Move 14                                      to aColumnType[i].nMaxSize
97097>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
97098>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
97099>>>>            Move 14                                      to aColumnType[i].sPrecision
97100>>>>            Increment i
97101>>>>
97101>>>>            Move "geography"                             to aColumnType[i].sSQLType
97102>>>>            Move 130                                     to aColumnType[i].iSQLType
97103>>>>            Move False                                   to aColumnType[i].bCanEditSize
97104>>>>            Move True                                    to aColumnType[i].bNativeDataType
97105>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
97106>>>>            Move -1                                      to aColumnType[i].iMinSize
97107>>>>            Move -1                                      to aColumnType[i].nMaxSize
97108>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
97109>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
97110>>>>            Move -1                                      to aColumnType[i].sPrecision
97111>>>>            Increment i
97112>>>>
97112>>>>            Move "geometry"                              to aColumnType[i].sSQLType
97113>>>>            Move 129                                     to aColumnType[i].iSQLType
97114>>>>            Move False                                   to aColumnType[i].bCanEditSize
97115>>>>            Move True                                    to aColumnType[i].bNativeDataType
97116>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
97117>>>>            Move -1                                      to aColumnType[i].iMinSize
97118>>>>            Move -1                                      to aColumnType[i].nMaxSize
97119>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
97120>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
97121>>>>            Move -1                                      to aColumnType[i].sPrecision
97122>>>>            Increment i
97123>>>>
97123>>>>            Move "hierarchyid"                           to aColumnType[i].sSQLType
97124>>>>            Move 128                                     to aColumnType[i].iSQLType
97125>>>>            Move False                                   to aColumnType[i].bCanEditSize
97126>>>>            Move True                                    to aColumnType[i].bNativeDataType
97127>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
97128>>>>            Move -1                                      to aColumnType[i].iMinSize
97129>>>>            Move -1                                      to aColumnType[i].nMaxSize
97130>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
97131>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
97132>>>>            Move -1                                      to aColumnType[i].sPrecision
97133>>>>            Increment i
97134>>>>
97134>>>>            Move "image"                                 to aColumnType[i].sSQLType
97135>>>>            Move -4                                      to aColumnType[i].iSQLType
97136>>>>            Move True                                    to aColumnType[i].bCanEditSize
97137>>>>            Move True                                    to aColumnType[i].bNativeDataType
97138>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
97139>>>>            Move 1                                       to aColumnType[i].iMinSize
97140>>>>            Move 16384                                   to aColumnType[i].nMaxSize
97141>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
97142>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
97143>>>>            Move 16384                                   to aColumnType[i].sPrecision
97144>>>>            Increment i
97145>>>>
97145>>>>            Move "int"                                   to aColumnType[i].sSQLType
97146>>>>            Move 4                                       to aColumnType[i].iSQLType
97147>>>>            Move True                                    to aColumnType[i].bCanEditSize
97148>>>>            Move True                                    to aColumnType[i].bNativeDataType
97149>>>>            Move 11                                      to aColumnType[i].iDefaultSize
97150>>>>            Move 1                                       to aColumnType[i].iMinSize
97151>>>>            Move 11                                      to aColumnType[i].nMaxSize
97152>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
97153>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
97154>>>>            Move 11                                      to aColumnType[i].sPrecision
97155>>>>            Increment i
97156>>>>
97156>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
97157>>>>            Move -8                                      to aColumnType[i].iSQLType
97158>>>>            Move True                                    to aColumnType[i].bCanEditSize
97159>>>>            Move True                                    to aColumnType[i].bNativeDataType
97160>>>>            Move -1                                      to aColumnType[i].iDefaultSize
97161>>>>            Move 1                                       to aColumnType[i].iMinSize
97162>>>>            Move 4000                                    to aColumnType[i].nMaxSize
97163>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
97164>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
97165>>>>            Move 4000                                    to aColumnType[i].sPrecision
97166>>>>            Increment i
97167>>>>
97167>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
97168>>>>            Move -10                                     to aColumnType[i].iSQLType
97169>>>>            Move True                                    to aColumnType[i].bCanEditSize
97170>>>>            Move True                                    to aColumnType[i].bNativeDataType
97171>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
97172>>>>            Move 1                                       to aColumnType[i].iMinSize
97173>>>>            Move 16384                                   to aColumnType[i].nMaxSize
97174>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
97175>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
97176>>>>            Move 16384                                   to aColumnType[i].sPrecision
97177>>>>            Increment i
97178>>>>
97178>>>>            Move "numeric"                               to aColumnType[i].sSQLType
97179>>>>            Move 2                                       to aColumnType[i].iSQLType
97180>>>>            Move True                                    to aColumnType[i].bCanEditSize
97181>>>>            Move True                                    to aColumnType[i].bNativeDataType
97182>>>>            Move 14                                      to aColumnType[i].iDefaultSize
97183>>>>            Move 1                                       to aColumnType[i].iMinSize
97184>>>>            Move 14                                      to aColumnType[i].nMaxSize
97185>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
97186>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
97187>>>>            Move 14                                      to aColumnType[i].sPrecision
97188>>>>            Increment i
97189>>>>
97189>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
97190>>>>            Move -9                                      to aColumnType[i].iSQLType
97191>>>>            Move True                                    to aColumnType[i].bCanEditSize
97192>>>>            Move True                                    to aColumnType[i].bNativeDataType
97193>>>>            Move 1                                       to aColumnType[i].iDefaultSize
97194>>>>            Move 1                                       to aColumnType[i].iMinSize
97195>>>>            Move 4000                                    to aColumnType[i].nMaxSize
97196>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
97197>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
97198>>>>            Move 4000                                    to aColumnType[i].sPrecision
97199>>>>            Increment i
97200>>>>
97200>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
97201>>>>            Move -100                                    to aColumnType[i].iSQLType
97202>>>>            Move True                                    to aColumnType[i].bCanEditSize
97203>>>>            Move True                                    to aColumnType[i].bNativeDataType
97204>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
97205>>>>            Move 1                                       to aColumnType[i].iMinSize
97206>>>>            Move 16384                                   to aColumnType[i].nMaxSize
97207>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
97208>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
97209>>>>            Move 16384                                   to aColumnType[i].sPrecision
97210>>>>            Increment i
97211>>>>
97211>>>>            Move "real"                                  to aColumnType[i].sSQLType
97212>>>>            Move 7                                       to aColumnType[i].iSQLType
97213>>>>            Move True                                    to aColumnType[i].bCanEditSize
97214>>>>            Move True                                    to aColumnType[i].bNativeDataType
97215>>>>            Move 14                                      to aColumnType[i].iDefaultSize
97216>>>>            Move 1                                       to aColumnType[i].iMinSize
97217>>>>            Move 14                                      to aColumnType[i].nMaxSize
97218>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
97219>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
97220>>>>            Move 14                                      to aColumnType[i].sPrecision
97221>>>>            Increment i
97222>>>>
97222>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
97223>>>>            Move 58                                      to aColumnType[i].iSQLType
97224>>>>            Move True                                    to aColumnType[i].bCanEditSize
97225>>>>            Move True                                    to aColumnType[i].bNativeDataType
97226>>>>            Move 12                                      to aColumnType[i].iDefaultSize
97227>>>>            Move 12                                      to aColumnType[i].iMinSize
97228>>>>            Move 23                                      to aColumnType[i].nMaxSize
97229>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
97230>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
97231>>>>            Move 23                                      to aColumnType[i].sPrecision
97232>>>>            Increment i
97233>>>>
97233>>>>            Move "smallint"                              to aColumnType[i].sSQLType
97234>>>>            Move 5                                       to aColumnType[i].iSQLType
97235>>>>            Move True                                    to aColumnType[i].bCanEditSize
97236>>>>            Move True                                    to aColumnType[i].bNativeDataType
97237>>>>            Move 6                                       to aColumnType[i].iDefaultSize
97238>>>>            Move -1                                      to aColumnType[i].iMinSize
97239>>>>            Move 6                                       to aColumnType[i].nMaxSize
97240>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
97241>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
97242>>>>            Move 6                                       to aColumnType[i].sPrecision
97243>>>>            Increment i
97244>>>>
97244>>>>            Move "sql_variant"                           to aColumnType[i].sSQLType
97245>>>>            Move -150                                    to aColumnType[i].iSQLType
97246>>>>            Move False                                   to aColumnType[i].bCanEditSize
97247>>>>            Move True                                    to aColumnType[i].bNativeDataType
97248>>>>            Move 8016                                    to aColumnType[i].iDefaultSize
97249>>>>            Move -1                                      to aColumnType[i].iMinSize
97250>>>>            Move -1                                      to aColumnType[i].nMaxSize
97251>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
97252>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
97253>>>>            Move -1                                      to aColumnType[i].sPrecision
97254>>>>            Increment i
97255>>>>
97255>>>>            Move "text"                                  to aColumnType[i].sSQLType
97256>>>>            Move -1                                      to aColumnType[i].iSQLType
97257>>>>            Move True                                    to aColumnType[i].bCanEditSize
97258>>>>            Move True                                    to aColumnType[i].bNativeDataType
97259>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
97260>>>>            Move 1                                       to aColumnType[i].iMinSize
97261>>>>            Move 16384                                   to aColumnType[i].nMaxSize
97262>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
97263>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
97264>>>>            Move 16384                                   to aColumnType[i].sPrecision
97265>>>>            Increment i
97266>>>>
97266>>>>            Move "time"                                  to aColumnType[i].sSQLType
97267>>>>            Move 41                                      to aColumnType[i].iSQLType
97268>>>>            Move True                                    to aColumnType[i].bCanEditSize
97269>>>>            Move True                                    to aColumnType[i].bNativeDataType
97270>>>>            Move 8                                       to aColumnType[i].iDefaultSize
97271>>>>            Move 8                                       to aColumnType[i].iMinSize
97272>>>>            Move 16                                      to aColumnType[i].nMaxSize
97273>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
97274>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
97275>>>>            Move 16                                      to aColumnType[i].sPrecision
97276>>>>            Increment i
97277>>>>
97277>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
97278>>>>            Move 93                                      to aColumnType[i].iSQLType
97279>>>>            Move False                                   to aColumnType[i].bCanEditSize
97280>>>>            Move True                                    to aColumnType[i].bNativeDataType
97281>>>>            Move 8                                       to aColumnType[i].iDefaultSize
97282>>>>            Move -1                                      to aColumnType[i].iMinSize
97283>>>>            Move -1                                      to aColumnType[i].nMaxSize
97284>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
97285>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
97286>>>>            Move -1                                      to aColumnType[i].sPrecision
97287>>>>            Increment i
97288>>>>
97288>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
97289>>>>            Move -6                                      to aColumnType[i].iSQLType
97290>>>>            Move True                                    to aColumnType[i].bCanEditSize
97291>>>>            Move True                                    to aColumnType[i].bNativeDataType
97292>>>>            Move 3                                       to aColumnType[i].iDefaultSize
97293>>>>            Move -1                                      to aColumnType[i].iMinSize
97294>>>>            Move 3                                       to aColumnType[i].nMaxSize
97295>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
97296>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
97297>>>>            Move 3                                       to aColumnType[i].sPrecision
97298>>>>            Increment i
97299>>>>
97299>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
97300>>>>            Move -11                                     to aColumnType[i].iSQLType
97301>>>>            Move False                                   to aColumnType[i].bCanEditSize
97302>>>>            Move True                                    to aColumnType[i].bNativeDataType
97303>>>>            Move 38                                      to aColumnType[i].iDefaultSize
97304>>>>            Move -1                                      to aColumnType[i].iMinSize
97305>>>>            Move -1                                      to aColumnType[i].nMaxSize
97306>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
97307>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
97308>>>>            Move -1                                      to aColumnType[i].sPrecision
97309>>>>            Increment i
97310>>>>
97310>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
97311>>>>            Move -3                                      to aColumnType[i].iSQLType
97312>>>>            Move True                                    to aColumnType[i].bCanEditSize
97313>>>>            Move True                                    to aColumnType[i].bNativeDataType
97314>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
97315>>>>            Move 1                                       to aColumnType[i].iMinSize
97316>>>>            Move 8000                                    to aColumnType[i].nMaxSize
97317>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
97318>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
97319>>>>            Move 8000                                    to aColumnType[i].sPrecision
97320>>>>            Increment i
97321>>>>
97321>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
97322>>>>            Move -98                                     to aColumnType[i].iSQLType
97323>>>>            Move True                                    to aColumnType[i].bCanEditSize
97324>>>>            Move True                                    to aColumnType[i].bNativeDataType
97325>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
97326>>>>            Move 1                                       to aColumnType[i].iMinSize
97327>>>>            Move 16384                                   to aColumnType[i].nMaxSize
97328>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
97329>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
97330>>>>            Move 16384                                   to aColumnType[i].sPrecision
97331>>>>            Increment i
97332>>>>
97332>>>>            Move "varchar"                               to aColumnType[i].sSQLType
97333>>>>            Move 12                                      to aColumnType[i].iSQLType
97334>>>>            Move True                                    to aColumnType[i].bCanEditSize
97335>>>>            Move True                                    to aColumnType[i].bNativeDataType
97336>>>>            Move 1                                       to aColumnType[i].iDefaultSize
97337>>>>            Move 1                                       to aColumnType[i].iMinSize
97338>>>>            Move 8000                                    to aColumnType[i].nMaxSize
97339>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
97340>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
97341>>>>            Move 8000                                    to aColumnType[i].sPrecision
97342>>>>            Increment i
97343>>>>
97343>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
97344>>>>            Move -99                                     to aColumnType[i].iSQLType
97345>>>>            Move True                                    to aColumnType[i].bCanEditSize
97346>>>>            Move True                                    to aColumnType[i].bNativeDataType
97347>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
97348>>>>            Move 1                                       to aColumnType[i].iMinSize
97349>>>>            Move 16384                                   to aColumnType[i].nMaxSize
97350>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
97351>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
97352>>>>            Move 16384                                   to aColumnType[i].sPrecision
97353>>>>            Increment i
97354>>>>
97354>>>>            Move "xml"                                   to aColumnType[i].sSQLType
97355>>>>            Move -370                                    to aColumnType[i].iSQLType
97356>>>>            Move True                                    to aColumnType[i].bCanEditSize
97357>>>>            Move True                                    to aColumnType[i].bNativeDataType
97358>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
97359>>>>            Move 1                                       to aColumnType[i].iMinSize
97360>>>>            Move 16384                                   to aColumnType[i].nMaxSize
97361>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
97362>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
97363>>>>            Move 16384                                   to aColumnType[i].sPrecision
97364>>>>            Increment i
97365>>>>
97365>>>>
97365>>>            
97365>>>//            Move eSQLServer_BIGINT  to ColumnType[i].iSQLType
97365>>>//            Move "BigInt"           to ColumnType[i].sSQLType
97365>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
97365>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
97365>>>//            Move "14.0"             to ColumnType[i].sPrecision
97365>>>//            Move True               to ColumnType[i].bCanEditSize
97365>>>//            Increment i
97365>>>//
97365>>>//            Move eSQLServer_BINARY  to ColumnType[i].iSQLType
97365>>>//            Move "Binary"           to ColumnType[i].sSQLType
97365>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
97365>>>//            Move "Binary"           to ColumnType[i].sDataFlexType
97365>>>//            Move "8000"             to ColumnType[i].sPrecision
97365>>>//            Increment i
97365>>>//
97365>>>//            Move eSQLServer_BIT     to ColumnType[i].iSQLType
97365>>>//            Move "Bit"              to ColumnType[i].sSQLType
97365>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
97365>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
97365>>>//            Move "1.0"              to ColumnType[i].sPrecision
97365>>>//            Move True               to ColumnType[i].bCanEditSize // In SQL allows 1, 0, or "NULL"
97365>>>//            Increment i
97365>>>//
97365>>>//            Move eSQLServer_CHAR    to ColumnType[i].iSQLType
97365>>>//            Move "Char"             to ColumnType[i].sSQLType
97365>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
97365>>>//            Move "Text"             to ColumnType[i].sDataFlexType
97365>>>//            Move "8000"             to ColumnType[i].sPrecision
97365>>>//            Increment i
97365>>>//
97365>>>//            Move eSQLServer_DATE    to ColumnType[i].iSQLType
97365>>>//            Move "Date"             to ColumnType[i].sSQLType
97365>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
97365>>>//            Move "Date"             to ColumnType[i].sDataFlexType
97365>>>//            Move "6.0"              to ColumnType[i].sPrecision
97365>>>//            Move True               to ColumnType[i].bCanEditSize
97365>>>//            Increment i
97365>>>//
97365>>>//            Move eSQLServer_DATETIME    to ColumnType[i].iSQLType
97365>>>//            Move "DateTime"             to ColumnType[i].sSQLType
97365>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
97365>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
97365>>>//            Move "23.3"                 to ColumnType[i].sPrecision
97365>>>//            Move True                   to ColumnType[i].bCanEditSize
97365>>>//            Increment i
97365>>>//
97365>>>//            Move eSQLServer_DATETIME2   to ColumnType[i].iSQLType
97365>>>//            Move "DateTime2"            to ColumnType[i].sSQLType
97365>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
97365>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
97365>>>//            Move "23.6"                 to ColumnType[i].sPrecision
97365>>>//            Move True                   to ColumnType[i].bCanEditSize
97365>>>//            Increment i
97365>>>//
97365>>>//            Move eSQLServer_DATETIMEOFFSET  to ColumnType[i].iSQLType
97365>>>//            Move "DateTimeOffest"           to ColumnType[i].sSQLType
97365>>>//            Move DF_DATETIME                to ColumnType[i].iDataFlexType
97365>>>//            Move "DateTime"                 to ColumnType[i].sDataFlexType
97365>>>//            Move "23.0"                     to ColumnType[i].sPrecision
97365>>>//            Move True                       to ColumnType[i].bCanEditSize
97365>>>//            Increment i
97365>>>//
97365>>>//            Move eSQLServer_DECIMAL to ColumnType[i].iSQLType
97365>>>//            Move "Decimal"          to ColumnType[i].sSQLType
97365>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
97365>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
97365>>>//            Move "14.8"             to ColumnType[i].sPrecision
97365>>>//            Increment i
97365>>>//
97365>>>//            Move eSQLServer_DOUBLE  to ColumnType[i].iSQLType
97365>>>//            Move "Double"           to ColumnType[i].sSQLType
97365>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
97365>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
97365>>>//            Move "14.8"             to ColumnType[i].sPrecision
97365>>>//            Increment i
97365>>>//
97365>>>//            Move eSQLServer_FLOAT   to ColumnType[i].iSQLType
97365>>>//            Move "Float"            to ColumnType[i].sSQLType
97365>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
97365>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
97365>>>//            Move "14.8"             to ColumnType[i].sPrecision
97365>>>//            Increment i
97365>>>//
97365>>>//            Move eSQLServer_INT     to ColumnType[i].iSQLType
97365>>>//            Move "Int"              to ColumnType[i].sSQLType
97365>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
97365>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
97365>>>//            Move "11.0"             to ColumnType[i].sPrecision
97365>>>//            Increment i
97365>>>//
97365>>>//            Move eSQLServer_NCHAR   to ColumnType[i].iSQLType
97365>>>//            Move "Nchar"            to ColumnType[i].sSQLType
97365>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
97365>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
97365>>>//            Move "4000"             to ColumnType[i].sPrecision
97365>>>//            Increment i
97365>>>//
97365>>>//            Move eSQLServer_NTEXT   to ColumnType[i].iSQLType
97365>>>//            Move "Ntext"            to ColumnType[i].sSQLType
97365>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
97365>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
97365>>>//            Move "16384"            to ColumnType[i].sPrecision
97365>>>//            Increment i
97365>>>//
97365>>>//            Move eSQLServer_NUMERIC to ColumnType[i].iSQLType
97365>>>//            Move "Numeric"          to ColumnType[i].sSQLType
97365>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
97365>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
97365>>>//            Move "14.8"             to ColumnType[i].sPrecision
97365>>>//            Increment i
97365>>>//
97365>>>//            Move eSQLServer_NVARCHAR    to ColumnType[i].iSQLType
97365>>>//            Move "NvarChar"             to ColumnType[i].sSQLType
97365>>>//            Move DF_TEXT                to ColumnType[i].iDataFlexType
97365>>>//            Move "Text"                 to ColumnType[i].sDataFlexType
97365>>>//            Move "4000"                 to ColumnType[i].sPrecision
97365>>>//            Increment i
97365>>>//
97365>>>//            Move eSQLServer_NVARCHARMAX to ColumnType[i].iSQLType
97365>>>//            Move "NvarCharMax"          to ColumnType[i].sSQLType
97365>>>//            Move DF_TEXT                to ColumnType[i].iDataFlexType
97365>>>//            Move "Text"                 to ColumnType[i].sDataFlexType
97365>>>//            Move "16384"                to ColumnType[i].sPrecision
97365>>>//            Move True                   to ColumnType[i].bCanEditSize
97365>>>//            Increment i
97365>>>//
97365>>>//            Move eSQLServer_REAL    to ColumnType[i].iSQLType
97365>>>//            Move "Real"             to ColumnType[i].sSQLType
97365>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
97365>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
97365>>>//            Move "14.8"             to ColumnType[i].sPrecision
97365>>>//            Increment i
97365>>>//
97365>>>//            Move eSQLServer_SMALLDATETIME   to ColumnType[i].iSQLType
97365>>>//            Move "SmallDateTime"            to ColumnType[i].sSQLType
97365>>>//            Move DF_DATETIME                to ColumnType[i].iDataFlexType
97365>>>//            Move "DATETIME"                 to ColumnType[i].sDataFlexType
97365>>>//            Move "23.0"                     to ColumnType[i].sPrecision
97365>>>//            Move True                       to ColumnType[i].bCanEditSize
97365>>>//            Increment i
97365>>>//
97365>>>//            Move eSQLServer_SMALLINT    to ColumnType[i].iSQLType
97365>>>//            Move "SmallInt"             to ColumnType[i].sSQLType
97365>>>//            Move DF_BCD                 to ColumnType[i].iDataFlexType
97365>>>//            Move "NUMERIC"              to ColumnType[i].sDataFlexType
97365>>>//            Move "6.0"                  to ColumnType[i].sPrecision
97365>>>//            Increment i
97365>>>//
97365>>>//            Move eSQLServer_TEXT    to ColumnType[i].iSQLType
97365>>>//            Move "Text"             to ColumnType[i].sSQLType
97365>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
97365>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
97365>>>//            Move "8000"             to ColumnType[i].sPrecision
97365>>>//            Move True               to ColumnType[i].bCanEditSize
97365>>>//            Increment i
97365>>>//
97365>>>//            Move eSQLServer_TIME    to ColumnType[i].iSQLType
97365>>>//            Move "Time"             to ColumnType[i].sSQLType
97365>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
97365>>>//            Move "Date"             to ColumnType[i].sDataFlexType
97365>>>//            Move "16.0"             to ColumnType[i].sPrecision
97365>>>//            Move True               to ColumnType[i].bCanEditSize
97365>>>//            Increment i
97365>>>//
97365>>>//            Move eSQLServer_TIMESTAMP   to ColumnType[i].iSQLType
97365>>>//            Move "TimeStamp"            to ColumnType[i].sSQLType
97365>>>//            Move DF_ASCII               to ColumnType[i].iDataFlexType
97365>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
97365>>>//            Move "8.0"                  to ColumnType[i].sPrecision
97365>>>//            Move True                   to ColumnType[i].bCanEditSize
97365>>>//            Increment i
97365>>>//
97365>>>//            Move eSQLServer_TINYINT to ColumnType[i].iSQLType
97365>>>//            Move "TinyInt"          to ColumnType[i].sSQLType
97365>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
97365>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
97365>>>//            Move "3.0"              to ColumnType[i].sPrecision
97365>>>//            Increment i
97365>>>//
97365>>>//            Move eSQLServer_GUID    to ColumnType[i].iSQLType
97365>>>//            Move "UniqueIdentifier" to ColumnType[i].sSQLType
97365>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
97365>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
97365>>>//            Move "38"               to ColumnType[i].sPrecision
97365>>>//            Move True               to ColumnType[i].bCanEditSize
97365>>>//            Increment i
97365>>>//
97365>>>//            Move eSQLServer_VARBINARY   to ColumnType[i].iSQLType
97365>>>//            Move "VarBinary"            to ColumnType[i].sSQLType
97365>>>//            Move DF_BINARY              to ColumnType[i].iDataFlexType
97365>>>//            Move "BINARY"               to ColumnType[i].sDataFlexType
97365>>>//            Move "8000"                 to ColumnType[i].sPrecision
97365>>>//            Increment i
97365>>>//
97365>>>//            Move eSQLServer_VARBINARYMAX to ColumnType[i].iSQLType
97365>>>//            Move "VarBinary(Max)"        to ColumnType[i].sSQLType
97365>>>//            Move DF_BINARY               to ColumnType[i].iDataFlexType
97365>>>//            Move "BINARY"                to ColumnType[i].sDataFlexType
97365>>>//            Move "16384"                 to ColumnType[i].sPrecision
97365>>>//            Move True                    to ColumnType[i].bCanEditSize
97365>>>//            Increment i
97365>>>//
97365>>>//            Move eSQLServer_VARCHAR to ColumnType[i].iSQLType
97365>>>//            Move "VarChar"          to ColumnType[i].sSQLType
97365>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
97365>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
97365>>>//            Move "8000"             to ColumnType[i].sPrecision
97365>>>//            Increment i
97365>>>//
97365>>>//            Move eSQLServer_VARCHARMAX  to ColumnType[i].iSQLType
97365>>>//            Move "VarChar(Max)"         to ColumnType[i].sSQLType
97365>>>//            Move DF_TEXT                to ColumnType[i].iDataFlexType
97365>>>//            Move "TEXT"                 to ColumnType[i].sDataFlexType
97365>>>//            Move "16384"                to ColumnType[i].sPrecision
97365>>>//            Move True                   to ColumnType[i].bCanEditSize
97365>>>//            Increment i
97365>>>//
97365>>>//            Move eSQLServer_SQLVARIANT  to ColumnType[i].iSQLType
97365>>>//            Move "SQL_Variant"          to ColumnType[i].sSQLType
97365>>>//            Move DF_BINARY              to ColumnType[i].iDataFlexType
97365>>>//            Move "Binary"               to ColumnType[i].sDataFlexType
97365>>>//            Move "8016"                 to ColumnType[i].sPrecision
97365>>>//            Move True                   to ColumnType[i].bCanEditSize
97365>>>//            Increment i
97365>>>//
97365>>>//            Move eSQLServer_XML     to ColumnType[i].iSQLType
97365>>>//            Move "XML"              to ColumnType[i].sSQLType
97365>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
97365>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
97365>>>//            Move "16384"            to ColumnType[i].sPrecision
97365>>>        End
97365>>>>
97365>>>
97365>>>        Function_Return aColumnType
97366>>>    End_Function
97367>>>
97367>>>    // MySQL Data Types
97367>>>    Function _UtilEnumerateMySQLTypes Returns tColumnType[]
97369>>>        tColumnType[] aColumnType
97369>>>        tColumnType[] aColumnType
97370>>>        Integer i
97370>>>        
Including file: mdsmysql_DriverDef.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\mdsmysql_DriverDef.inc)
97370>>>>// Generated By The Database Update Framework
97370>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdsmysql_DriverDef.xml
97370>>>>// Driver COLUMN DATA TYPES
97370>>>>//
97370>>>>// Created: 2018-03-14 23:46:49.593
97370>>>>
97370>>>>            Move "bigint"                                to aColumnType[i].sSQLType
97371>>>>            Move 8                                       to aColumnType[i].iSQLType
97372>>>>            Move True                                    to aColumnType[i].bCanEditSize
97373>>>>            Move True                                    to aColumnType[i].bNativeDataType
97374>>>>            Move 14                                      to aColumnType[i].iDefaultSize
97375>>>>            Move 1                                       to aColumnType[i].iMinSize
97376>>>>            Move 14                                      to aColumnType[i].nMaxSize
97377>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
97378>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
97379>>>>            Move 14                                      to aColumnType[i].sPrecision
97380>>>>            Increment i
97381>>>>
97381>>>>            Move "bit"                                   to aColumnType[i].sSQLType
97382>>>>            Move 16                                      to aColumnType[i].iSQLType
97383>>>>            Move True                                    to aColumnType[i].bCanEditSize
97384>>>>            Move True                                    to aColumnType[i].bNativeDataType
97385>>>>            Move -1                                      to aColumnType[i].iDefaultSize
97386>>>>            Move -1                                      to aColumnType[i].iMinSize
97387>>>>            Move 64                                      to aColumnType[i].nMaxSize
97388>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
97389>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
97390>>>>            Move 64                                      to aColumnType[i].sPrecision
97391>>>>            Increment i
97392>>>>
97392>>>>            Move "blob"                                  to aColumnType[i].sSQLType
97393>>>>            Move 252                                     to aColumnType[i].iSQLType
97394>>>>            Move True                                    to aColumnType[i].bCanEditSize
97395>>>>            Move True                                    to aColumnType[i].bNativeDataType
97396>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
97397>>>>            Move 1                                       to aColumnType[i].iMinSize
97398>>>>            Move 16384                                   to aColumnType[i].nMaxSize
97399>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
97400>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
97401>>>>            Move 16384                                   to aColumnType[i].sPrecision
97402>>>>            Increment i
97403>>>>
97403>>>>            Move "char"                                  to aColumnType[i].sSQLType
97404>>>>            Move 254                                     to aColumnType[i].iSQLType
97405>>>>            Move True                                    to aColumnType[i].bCanEditSize
97406>>>>            Move True                                    to aColumnType[i].bNativeDataType
97407>>>>            Move 1                                       to aColumnType[i].iDefaultSize
97408>>>>            Move 1                                       to aColumnType[i].iMinSize
97409>>>>            Move 255                                     to aColumnType[i].nMaxSize
97410>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
97411>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
97412>>>>            Move 255                                     to aColumnType[i].sPrecision
97413>>>>            Increment i
97414>>>>
97414>>>>            Move "date"                                  to aColumnType[i].sSQLType
97415>>>>            Move 10                                      to aColumnType[i].iSQLType
97416>>>>            Move False                                   to aColumnType[i].bCanEditSize
97417>>>>            Move True                                    to aColumnType[i].bNativeDataType
97418>>>>            Move 6                                       to aColumnType[i].iDefaultSize
97419>>>>            Move -1                                      to aColumnType[i].iMinSize
97420>>>>            Move -1                                      to aColumnType[i].nMaxSize
97421>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
97422>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
97423>>>>            Move 6                                       to aColumnType[i].sPrecision
97424>>>>            Increment i
97425>>>>
97425>>>>            Move "datetime"                              to aColumnType[i].sSQLType
97426>>>>            Move 12                                      to aColumnType[i].iSQLType
97427>>>>            Move True                                    to aColumnType[i].bCanEditSize
97428>>>>            Move True                                    to aColumnType[i].bNativeDataType
97429>>>>            Move 23                                      to aColumnType[i].iDefaultSize
97430>>>>            Move 6                                       to aColumnType[i].iMinSize
97431>>>>            Move 23                                      to aColumnType[i].nMaxSize
97432>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
97433>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
97434>>>>            Move 23                                      to aColumnType[i].sPrecision
97435>>>>            Increment i
97436>>>>
97436>>>>            Move "decimal"                               to aColumnType[i].sSQLType
97437>>>>            Move 246                                     to aColumnType[i].iSQLType
97438>>>>            Move True                                    to aColumnType[i].bCanEditSize
97439>>>>            Move True                                    to aColumnType[i].bNativeDataType
97440>>>>            Move 14                                      to aColumnType[i].iDefaultSize
97441>>>>            Move -1                                      to aColumnType[i].iMinSize
97442>>>>            Move 14                                      to aColumnType[i].nMaxSize
97443>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
97444>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
97445>>>>            Move 14                                      to aColumnType[i].sPrecision
97446>>>>            Increment i
97447>>>>
97447>>>>            Move "decimal-MySQL4"                        to aColumnType[i].sSQLType
97448>>>>            Move 0                                       to aColumnType[i].iSQLType
97449>>>>            Move True                                    to aColumnType[i].bCanEditSize
97450>>>>            Move True                                    to aColumnType[i].bNativeDataType
97451>>>>            Move 14                                      to aColumnType[i].iDefaultSize
97452>>>>            Move -1                                      to aColumnType[i].iMinSize
97453>>>>            Move 14                                      to aColumnType[i].nMaxSize
97454>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
97455>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
97456>>>>            Move 14                                      to aColumnType[i].sPrecision
97457>>>>            Increment i
97458>>>>
97458>>>>            Move "double"                                to aColumnType[i].sSQLType
97459>>>>            Move 5                                       to aColumnType[i].iSQLType
97460>>>>            Move True                                    to aColumnType[i].bCanEditSize
97461>>>>            Move True                                    to aColumnType[i].bNativeDataType
97462>>>>            Move 14                                      to aColumnType[i].iDefaultSize
97463>>>>            Move -1                                      to aColumnType[i].iMinSize
97464>>>>            Move 14                                      to aColumnType[i].nMaxSize
97465>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
97466>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
97467>>>>            Move 14                                      to aColumnType[i].sPrecision
97468>>>>            Increment i
97469>>>>
97469>>>>            Move "enum"                                  to aColumnType[i].sSQLType
97470>>>>            Move 247                                     to aColumnType[i].iSQLType
97471>>>>            Move True                                    to aColumnType[i].bCanEditSize
97472>>>>            Move True                                    to aColumnType[i].bNativeDataType
97473>>>>            Move -1                                      to aColumnType[i].iDefaultSize
97474>>>>            Move -1                                      to aColumnType[i].iMinSize
97475>>>>            Move 255                                     to aColumnType[i].nMaxSize
97476>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
97477>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
97478>>>>            Move 255                                     to aColumnType[i].sPrecision
97479>>>>            Increment i
97480>>>>
97480>>>>            Move "float"                                 to aColumnType[i].sSQLType
97481>>>>            Move 4                                       to aColumnType[i].iSQLType
97482>>>>            Move True                                    to aColumnType[i].bCanEditSize
97483>>>>            Move True                                    to aColumnType[i].bNativeDataType
97484>>>>            Move 4                                       to aColumnType[i].iDefaultSize
97485>>>>            Move -1                                      to aColumnType[i].iMinSize
97486>>>>            Move 14                                      to aColumnType[i].nMaxSize
97487>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
97488>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
97489>>>>            Move 14                                      to aColumnType[i].sPrecision
97490>>>>            Increment i
97491>>>>
97491>>>>            Move "int"                                   to aColumnType[i].sSQLType
97492>>>>            Move 3                                       to aColumnType[i].iSQLType
97493>>>>            Move True                                    to aColumnType[i].bCanEditSize
97494>>>>            Move True                                    to aColumnType[i].bNativeDataType
97495>>>>            Move 10                                      to aColumnType[i].iDefaultSize
97496>>>>            Move -1                                      to aColumnType[i].iMinSize
97497>>>>            Move 11                                      to aColumnType[i].nMaxSize
97498>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
97499>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
97500>>>>            Move 11                                      to aColumnType[i].sPrecision
97501>>>>            Increment i
97502>>>>
97502>>>>            Move "longblob"                              to aColumnType[i].sSQLType
97503>>>>            Move 251                                     to aColumnType[i].iSQLType
97504>>>>            Move True                                    to aColumnType[i].bCanEditSize
97505>>>>            Move True                                    to aColumnType[i].bNativeDataType
97506>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
97507>>>>            Move 1                                       to aColumnType[i].iMinSize
97508>>>>            Move 16384                                   to aColumnType[i].nMaxSize
97509>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
97510>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
97511>>>>            Move 16384                                   to aColumnType[i].sPrecision
97512>>>>            Increment i
97513>>>>
97513>>>>            Move "longtext"                              to aColumnType[i].sSQLType
97514>>>>            Move -251                                    to aColumnType[i].iSQLType
97515>>>>            Move True                                    to aColumnType[i].bCanEditSize
97516>>>>            Move True                                    to aColumnType[i].bNativeDataType
97517>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
97518>>>>            Move 1                                       to aColumnType[i].iMinSize
97519>>>>            Move 16384                                   to aColumnType[i].nMaxSize
97520>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
97521>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
97522>>>>            Move 16384                                   to aColumnType[i].sPrecision
97523>>>>            Increment i
97524>>>>
97524>>>>            Move "mediumblob"                            to aColumnType[i].sSQLType
97525>>>>            Move 250                                     to aColumnType[i].iSQLType
97526>>>>            Move True                                    to aColumnType[i].bCanEditSize
97527>>>>            Move True                                    to aColumnType[i].bNativeDataType
97528>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
97529>>>>            Move 1                                       to aColumnType[i].iMinSize
97530>>>>            Move 16384                                   to aColumnType[i].nMaxSize
97531>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
97532>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
97533>>>>            Move 16384                                   to aColumnType[i].sPrecision
97534>>>>            Increment i
97535>>>>
97535>>>>            Move "mediumint"                             to aColumnType[i].sSQLType
97536>>>>            Move 9                                       to aColumnType[i].iSQLType
97537>>>>            Move True                                    to aColumnType[i].bCanEditSize
97538>>>>            Move True                                    to aColumnType[i].bNativeDataType
97539>>>>            Move 8                                       to aColumnType[i].iDefaultSize
97540>>>>            Move 1                                       to aColumnType[i].iMinSize
97541>>>>            Move 9                                       to aColumnType[i].nMaxSize
97542>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
97543>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
97544>>>>            Move 9                                       to aColumnType[i].sPrecision
97545>>>>            Increment i
97546>>>>
97546>>>>            Move "mediumtext"                            to aColumnType[i].sSQLType
97547>>>>            Move -250                                    to aColumnType[i].iSQLType
97548>>>>            Move True                                    to aColumnType[i].bCanEditSize
97549>>>>            Move True                                    to aColumnType[i].bNativeDataType
97550>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
97551>>>>            Move 1                                       to aColumnType[i].iMinSize
97552>>>>            Move 16384                                   to aColumnType[i].nMaxSize
97553>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
97554>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
97555>>>>            Move 16384                                   to aColumnType[i].sPrecision
97556>>>>            Increment i
97557>>>>
97557>>>>            Move "set"                                   to aColumnType[i].sSQLType
97558>>>>            Move 248                                     to aColumnType[i].iSQLType
97559>>>>            Move True                                    to aColumnType[i].bCanEditSize
97560>>>>            Move True                                    to aColumnType[i].bNativeDataType
97561>>>>            Move -1                                      to aColumnType[i].iDefaultSize
97562>>>>            Move -1                                      to aColumnType[i].iMinSize
97563>>>>            Move 255                                     to aColumnType[i].nMaxSize
97564>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
97565>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
97566>>>>            Move 255                                     to aColumnType[i].sPrecision
97567>>>>            Increment i
97568>>>>
97568>>>>            Move "smallint"                              to aColumnType[i].sSQLType
97569>>>>            Move 2                                       to aColumnType[i].iSQLType
97570>>>>            Move True                                    to aColumnType[i].bCanEditSize
97571>>>>            Move True                                    to aColumnType[i].bNativeDataType
97572>>>>            Move 5                                       to aColumnType[i].iDefaultSize
97573>>>>            Move 1                                       to aColumnType[i].iMinSize
97574>>>>            Move 6                                       to aColumnType[i].nMaxSize
97575>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
97576>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
97577>>>>            Move 6                                       to aColumnType[i].sPrecision
97578>>>>            Increment i
97579>>>>
97579>>>>            Move "text"                                  to aColumnType[i].sSQLType
97580>>>>            Move -252                                    to aColumnType[i].iSQLType
97581>>>>            Move True                                    to aColumnType[i].bCanEditSize
97582>>>>            Move True                                    to aColumnType[i].bNativeDataType
97583>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
97584>>>>            Move 1                                       to aColumnType[i].iMinSize
97585>>>>            Move 16384                                   to aColumnType[i].nMaxSize
97586>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
97587>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
97588>>>>            Move 16384                                   to aColumnType[i].sPrecision
97589>>>>            Increment i
97590>>>>
97590>>>>            Move "time"                                  to aColumnType[i].sSQLType
97591>>>>            Move 11                                      to aColumnType[i].iSQLType
97592>>>>            Move False                                   to aColumnType[i].bCanEditSize
97593>>>>            Move True                                    to aColumnType[i].bNativeDataType
97594>>>>            Move 10                                      to aColumnType[i].iDefaultSize
97595>>>>            Move -1                                      to aColumnType[i].iMinSize
97596>>>>            Move -1                                      to aColumnType[i].nMaxSize
97597>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
97598>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
97599>>>>            Move -1                                      to aColumnType[i].sPrecision
97600>>>>            Increment i
97601>>>>
97601>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
97602>>>>            Move 7                                       to aColumnType[i].iSQLType
97603>>>>            Move True                                    to aColumnType[i].bCanEditSize
97604>>>>            Move True                                    to aColumnType[i].bNativeDataType
97605>>>>            Move 6                                       to aColumnType[i].iDefaultSize
97606>>>>            Move 6                                       to aColumnType[i].iMinSize
97607>>>>            Move 23                                      to aColumnType[i].nMaxSize
97608>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
97609>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
97610>>>>            Move 23                                      to aColumnType[i].sPrecision
97611>>>>            Increment i
97612>>>>
97612>>>>            Move "tinyblob"                              to aColumnType[i].sSQLType
97613>>>>            Move 249                                     to aColumnType[i].iSQLType
97614>>>>            Move True                                    to aColumnType[i].bCanEditSize
97615>>>>            Move True                                    to aColumnType[i].bNativeDataType
97616>>>>            Move 255                                     to aColumnType[i].iDefaultSize
97617>>>>            Move 1                                       to aColumnType[i].iMinSize
97618>>>>            Move 255                                     to aColumnType[i].nMaxSize
97619>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
97620>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
97621>>>>            Move 255                                     to aColumnType[i].sPrecision
97622>>>>            Increment i
97623>>>>
97623>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
97624>>>>            Move 1                                       to aColumnType[i].iSQLType
97625>>>>            Move True                                    to aColumnType[i].bCanEditSize
97626>>>>            Move True                                    to aColumnType[i].bNativeDataType
97627>>>>            Move 4                                       to aColumnType[i].iDefaultSize
97628>>>>            Move 1                                       to aColumnType[i].iMinSize
97629>>>>            Move 4                                       to aColumnType[i].nMaxSize
97630>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
97631>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
97632>>>>            Move 4                                       to aColumnType[i].sPrecision
97633>>>>            Increment i
97634>>>>
97634>>>>            Move "tinytext"                              to aColumnType[i].sSQLType
97635>>>>            Move -249                                    to aColumnType[i].iSQLType
97636>>>>            Move True                                    to aColumnType[i].bCanEditSize
97637>>>>            Move True                                    to aColumnType[i].bNativeDataType
97638>>>>            Move 255                                     to aColumnType[i].iDefaultSize
97639>>>>            Move 1                                       to aColumnType[i].iMinSize
97640>>>>            Move 255                                     to aColumnType[i].nMaxSize
97641>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
97642>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
97643>>>>            Move 255                                     to aColumnType[i].sPrecision
97644>>>>            Increment i
97645>>>>
97645>>>>            Move "varchar"                               to aColumnType[i].sSQLType
97646>>>>            Move 253                                     to aColumnType[i].iSQLType
97647>>>>            Move True                                    to aColumnType[i].bCanEditSize
97648>>>>            Move True                                    to aColumnType[i].bNativeDataType
97649>>>>            Move -1                                      to aColumnType[i].iDefaultSize
97650>>>>            Move -1                                      to aColumnType[i].iMinSize
97651>>>>            Move 16384                                   to aColumnType[i].nMaxSize
97652>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
97653>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
97654>>>>            Move 16384                                   to aColumnType[i].sPrecision
97655>>>>            Increment i
97656>>>>
97656>>>>            Move "year"                                  to aColumnType[i].sSQLType
97657>>>>            Move 13                                      to aColumnType[i].iSQLType
97658>>>>            Move False                                   to aColumnType[i].bCanEditSize
97659>>>>            Move True                                    to aColumnType[i].bNativeDataType
97660>>>>            Move 4                                       to aColumnType[i].iDefaultSize
97661>>>>            Move -1                                      to aColumnType[i].iMinSize
97662>>>>            Move -1                                      to aColumnType[i].nMaxSize
97663>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
97664>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
97665>>>>            Move -1                                      to aColumnType[i].sPrecision
97666>>>>            Increment i
97667>>>>
97667>>>>
97667>>>        
97667>>>//        Move eMySQL_LONGLONG    to ColumnType[i].iSQLType
97667>>>//        Move "bigint"           to ColumnType[i].sSQLType
97667>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
97667>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
97667>>>//        Move "14.0"             to ColumnType[i].sPrecision
97667>>>//        Increment i
97667>>>//
97667>>>//        Move eMySQL_BIT         to ColumnType[i].iSQLType
97667>>>//        Move "bit"              to ColumnType[i].sSQLType
97667>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
97667>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
97667>>>//        Move "4.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
97667>>>//        Move True               to ColumnType[i].bCanEditSize
97667>>>//        Increment i
97667>>>//
97667>>>//        Move eMySQL_BLOB        to ColumnType[i].iSQLType
97667>>>//        Move "blob"             to ColumnType[i].sSQLType
97667>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
97667>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
97667>>>//        Move "16384"            to ColumnType[i].sPrecision
97667>>>//        Increment i
97667>>>//
97667>>>//        Move eMySQL_STRING      to ColumnType[i].iSQLType
97667>>>//        Move "char"             to ColumnType[i].sSQLType
97667>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
97667>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
97667>>>//        Move "254"              to ColumnType[i].sPrecision
97667>>>//        Increment i
97667>>>//
97667>>>//        Move eMySQL_DATE        to ColumnType[i].iSQLType
97667>>>//        Move "date"             to ColumnType[i].sSQLType
97667>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
97667>>>//        Move "Date"             to ColumnType[i].sDataFlexType
97667>>>//        Move "6.0"              to ColumnType[i].sPrecision
97667>>>//        Move True               to ColumnType[i].bCanEditSize
97667>>>//        Increment i
97667>>>//
97667>>>//        Move eMySQL_DATETIME    to ColumnType[i].iSQLType
97667>>>//        Move "datetime"         to ColumnType[i].sSQLType
97667>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
97667>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
97667>>>//        Move "23.0"             to ColumnType[i].sPrecision
97667>>>//        Move True               to ColumnType[i].bCanEditSize
97667>>>//        Increment i
97667>>>//
97667>>>//        Move eMySQL_DECIMAL     to ColumnType[i].iSQLType
97667>>>//        Move "decimal"          to ColumnType[i].sSQLType
97667>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
97667>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
97667>>>//        Move "14.8"             to ColumnType[i].sPrecision
97667>>>//        Increment i
97667>>>//
97667>>>//        Move eMySQL_DOUBLE      to ColumnType[i].iSQLType
97667>>>//        Move "double"           to ColumnType[i].sSQLType
97667>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
97667>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
97667>>>//        Move "14.8"             to ColumnType[i].sPrecision
97667>>>//        Increment i
97667>>>//
97667>>>//        Move eMySQL_ENUM        to ColumnType[i].iSQLType
97667>>>//        Move "enum"             to ColumnType[i].sSQLType
97667>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
97667>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
97667>>>//        Move "254"              to ColumnType[i].sPrecision
97667>>>//        Increment i
97667>>>//
97667>>>//        Move eMySQL_FLOAT       to ColumnType[i].iSQLType
97667>>>//        Move "float"            to ColumnType[i].sSQLType
97667>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
97667>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
97667>>>//        Move "14.8"             to ColumnType[i].sPrecision
97667>>>//        Increment i
97667>>>//
97667>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
97667>>>//        Move "int"              to ColumnType[i].sSQLType
97667>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
97667>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
97667>>>//        Move "11.0"             to ColumnType[i].sPrecision
97667>>>//        Increment i
97667>>>//
97667>>>//        Move eMySQL_LONG_BLOB   to ColumnType[i].iSQLType
97667>>>//        Move "longblob"         to ColumnType[i].sSQLType
97667>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
97667>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
97667>>>//        Move "16384"            to ColumnType[i].sPrecision
97667>>>//        Increment i
97667>>>//
97667>>>//        Move eMySQL_LONG_TEXT   to ColumnType[i].iSQLType
97667>>>//        Move "longtext"         to ColumnType[i].sSQLType
97667>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
97667>>>//        Move "Text"             to ColumnType[i].sDataFlexType
97667>>>//        Move "16384"            to ColumnType[i].sPrecision
97667>>>//        Increment i
97667>>>//
97667>>>//        Move eMySQL_MEDIUM_BLOB to ColumnType[i].iSQLType
97667>>>//        Move "mediumblob"       to ColumnType[i].sSQLType
97667>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
97667>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
97667>>>//        Move "16384"            to ColumnType[i].sPrecision
97667>>>//        Increment i
97667>>>//
97667>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
97667>>>//        Move "mediumint"        to ColumnType[i].sSQLType
97667>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
97667>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
97667>>>//        Move "9.0"              to ColumnType[i].sPrecision
97667>>>//
97667>>>//        Move eMySQL_MEDIUM_TEXT to ColumnType[i].iSQLType
97667>>>//        Move "mediumtext"       to ColumnType[i].sSQLType
97667>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
97667>>>//        Move "Text"             to ColumnType[i].sDataFlexType
97667>>>//        Move "16384"            to ColumnType[i].sPrecision
97667>>>//        Increment i
97667>>>//
97667>>>//        Move eMySQL_SET         to ColumnType[i].iSQLType
97667>>>//        Move "set"              to ColumnType[i].sSQLType
97667>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
97667>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
97667>>>//        Move "254"              to ColumnType[i].sPrecision
97667>>>//        Increment i
97667>>>//
97667>>>//        Move eMySQL_SHORT       to ColumnType[i].iSQLType
97667>>>//        Move "smallint"         to ColumnType[i].sSQLType
97667>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
97667>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
97667>>>//        Move "6.0"              to ColumnType[i].sPrecision
97667>>>//        Increment i
97667>>>//
97667>>>//        Move eMySQL_TEXT        to ColumnType[i].iSQLType
97667>>>//        Move "text"             to ColumnType[i].sSQLType
97667>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
97667>>>//        Move "Text"             to ColumnType[i].sDataFlexType
97667>>>//        Move "16384"            to ColumnType[i].sPrecision
97667>>>//        Increment i
97667>>>//
97667>>>//        Move eMySQL_TIME        to ColumnType[i].iSQLType
97667>>>//        Move "time"             to ColumnType[i].sSQLType
97667>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
97667>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
97667>>>//        Move "10.0"             to ColumnType[i].sPrecision
97667>>>//        Move True               to ColumnType[i].bCanEditSize
97667>>>//        Increment i
97667>>>//
97667>>>//        Move eMySQL_TIMESTAMP   to ColumnType[i].iSQLType
97667>>>//        Move "timestamp"        to ColumnType[i].sSQLType
97667>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
97667>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
97667>>>//        Move "23.0"             to ColumnType[i].sPrecision
97667>>>//        Move True               to ColumnType[i].bCanEditSize
97667>>>//        Increment i
97667>>>//
97667>>>//        Move eMySQL_TINY_BLOB   to ColumnType[i].iSQLType
97667>>>//        Move "tinyblob"         to ColumnType[i].sSQLType
97667>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
97667>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
97667>>>//        Move "254"              to ColumnType[i].sPrecision
97667>>>//        Increment i
97667>>>//
97667>>>//        Move eMySQL_TINY        to ColumnType[i].iSQLType
97667>>>//        Move "tinyint"          to ColumnType[i].sSQLType
97667>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
97667>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
97667>>>//        Move "4.0"              to ColumnType[i].sPrecision
97667>>>//        Increment i
97667>>>//
97667>>>//        Move eMySQL_TINY_TEXT   to ColumnType[i].iSQLType
97667>>>//        Move "tinytext"         to ColumnType[i].sSQLType
97667>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
97667>>>//        Move "Text"             to ColumnType[i].sDataFlexType
97667>>>//        Move "254"              to ColumnType[i].sPrecision
97667>>>//        Increment i
97667>>>//
97667>>>//        Move eMySQL_VAR_STRING  to ColumnType[i].iSQLType
97667>>>//        Move "varchar"          to ColumnType[i].sSQLType
97667>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
97667>>>//        Move "Text"             to ColumnType[i].sDataFlexType
97667>>>//        Move "16384"            to ColumnType[i].sPrecision
97667>>>//        Increment i
97667>>>//
97667>>>//        Move eMySQL_YEAR        to ColumnType[i].iSQLType
97667>>>//        Move "year"             to ColumnType[i].sSQLType
97667>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
97667>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
97667>>>//        Move "4.0"              to ColumnType[i].sPrecision
97667>>>//        Move True               to ColumnType[i].bCanEditSize
97667>>>//        Increment i
97667>>>
97667>>>        Function_Return aColumnType
97668>>>    End_Function
97669>>>
97669>>>    // Oracle Data Types
97669>>>    Function _UtilEnumerateOracleTypes Returns tColumnType[]
97671>>>        tColumnType[] aColumnType
97671>>>        tColumnType[] aColumnType
97672>>>        Integer i
97672>>>        
Including file: ora_drv_DriverDef.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\ora_drv_DriverDef.inc)
97672>>>>// Generated By The Database Update Framework
97672>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\ora_drv_DriverDef.xml
97672>>>>// Driver COLUMN DATA TYPES
97672>>>>//
97672>>>>// Created: 2018-03-14 23:47:34.82
97672>>>>
97672>>>>            Move "blob"                                  to aColumnType[i].sSQLType
97673>>>>            Move 113                                     to aColumnType[i].iSQLType
97674>>>>            Move True                                    to aColumnType[i].bCanEditSize
97675>>>>            Move True                                    to aColumnType[i].bNativeDataType
97676>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
97677>>>>            Move 1                                       to aColumnType[i].iMinSize
97678>>>>            Move 16384                                   to aColumnType[i].nMaxSize
97679>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
97680>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
97681>>>>            Move 16384                                   to aColumnType[i].sPrecision
97682>>>>            Increment i
97683>>>>
97683>>>>            Move "char"                                  to aColumnType[i].sSQLType
97684>>>>            Move 96                                      to aColumnType[i].iSQLType
97685>>>>            Move True                                    to aColumnType[i].bCanEditSize
97686>>>>            Move True                                    to aColumnType[i].bNativeDataType
97687>>>>            Move 1                                       to aColumnType[i].iDefaultSize
97688>>>>            Move 1                                       to aColumnType[i].iMinSize
97689>>>>            Move 2000                                    to aColumnType[i].nMaxSize
97690>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
97691>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
97692>>>>            Move 2000                                    to aColumnType[i].sPrecision
97693>>>>            Increment i
97694>>>>
97694>>>>            Move "clob"                                  to aColumnType[i].sSQLType
97695>>>>            Move 112                                     to aColumnType[i].iSQLType
97696>>>>            Move True                                    to aColumnType[i].bCanEditSize
97697>>>>            Move True                                    to aColumnType[i].bNativeDataType
97698>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
97699>>>>            Move 1                                       to aColumnType[i].iMinSize
97700>>>>            Move 16384                                   to aColumnType[i].nMaxSize
97701>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
97702>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
97703>>>>            Move 16384                                   to aColumnType[i].sPrecision
97704>>>>            Increment i
97705>>>>
97705>>>>            Move "date"                                  to aColumnType[i].sSQLType
97706>>>>            Move 12                                      to aColumnType[i].iSQLType
97707>>>>            Move True                                    to aColumnType[i].bCanEditSize
97708>>>>            Move True                                    to aColumnType[i].bNativeDataType
97709>>>>            Move 6                                       to aColumnType[i].iDefaultSize
97710>>>>            Move 6                                       to aColumnType[i].iMinSize
97711>>>>            Move 23                                      to aColumnType[i].nMaxSize
97712>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
97713>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
97714>>>>            Move 6                                       to aColumnType[i].sPrecision
97715>>>>            Increment i
97716>>>>
97716>>>>            Move "float"                                 to aColumnType[i].sSQLType
97717>>>>            Move 4                                       to aColumnType[i].iSQLType
97718>>>>            Move True                                    to aColumnType[i].bCanEditSize
97719>>>>            Move True                                    to aColumnType[i].bNativeDataType
97720>>>>            Move 1                                       to aColumnType[i].iDefaultSize
97721>>>>            Move 1                                       to aColumnType[i].iMinSize
97722>>>>            Move 14                                      to aColumnType[i].nMaxSize
97723>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
97724>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
97725>>>>            Move 14                                      to aColumnType[i].sPrecision
97726>>>>            Increment i
97727>>>>
97727>>>>            Move "int"                                   to aColumnType[i].sSQLType
97728>>>>            Move 3                                       to aColumnType[i].iSQLType
97729>>>>            Move True                                    to aColumnType[i].bCanEditSize
97730>>>>            Move True                                    to aColumnType[i].bNativeDataType
97731>>>>            Move 14                                      to aColumnType[i].iDefaultSize
97732>>>>            Move 1                                       to aColumnType[i].iMinSize
97733>>>>            Move 14                                      to aColumnType[i].nMaxSize
97734>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
97735>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
97736>>>>            Move 14                                      to aColumnType[i].sPrecision
97737>>>>            Increment i
97738>>>>
97738>>>>            Move "intervalds"                            to aColumnType[i].sSQLType
97739>>>>            Move 190                                     to aColumnType[i].iSQLType
97740>>>>            Move False                                   to aColumnType[i].bCanEditSize
97741>>>>            Move True                                    to aColumnType[i].bNativeDataType
97742>>>>            Move 23                                      to aColumnType[i].iDefaultSize
97743>>>>            Move -1                                      to aColumnType[i].iMinSize
97744>>>>            Move -1                                      to aColumnType[i].nMaxSize
97745>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
97746>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
97747>>>>            Move -1                                      to aColumnType[i].sPrecision
97748>>>>            Increment i
97749>>>>
97749>>>>            Move "intervalym"                            to aColumnType[i].sSQLType
97750>>>>            Move 189                                     to aColumnType[i].iSQLType
97751>>>>            Move False                                   to aColumnType[i].bCanEditSize
97752>>>>            Move True                                    to aColumnType[i].bNativeDataType
97753>>>>            Move 23                                      to aColumnType[i].iDefaultSize
97754>>>>            Move -1                                      to aColumnType[i].iMinSize
97755>>>>            Move -1                                      to aColumnType[i].nMaxSize
97756>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
97757>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
97758>>>>            Move -1                                      to aColumnType[i].sPrecision
97759>>>>            Increment i
97760>>>>
97760>>>>            Move "long"                                  to aColumnType[i].sSQLType
97761>>>>            Move 8                                       to aColumnType[i].iSQLType
97762>>>>            Move True                                    to aColumnType[i].bCanEditSize
97763>>>>            Move True                                    to aColumnType[i].bNativeDataType
97764>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
97765>>>>            Move 1                                       to aColumnType[i].iMinSize
97766>>>>            Move 16384                                   to aColumnType[i].nMaxSize
97767>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
97768>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
97769>>>>            Move 16384                                   to aColumnType[i].sPrecision
97770>>>>            Increment i
97771>>>>
97771>>>>            Move "longraw"                               to aColumnType[i].sSQLType
97772>>>>            Move 24                                      to aColumnType[i].iSQLType
97773>>>>            Move True                                    to aColumnType[i].bCanEditSize
97774>>>>            Move True                                    to aColumnType[i].bNativeDataType
97775>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
97776>>>>            Move 1                                       to aColumnType[i].iMinSize
97777>>>>            Move 16384                                   to aColumnType[i].nMaxSize
97778>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
97779>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
97780>>>>            Move 16384                                   to aColumnType[i].sPrecision
97781>>>>            Increment i
97782>>>>
97782>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
97783>>>>            Move 286                                     to aColumnType[i].iSQLType
97784>>>>            Move True                                    to aColumnType[i].bCanEditSize
97785>>>>            Move True                                    to aColumnType[i].bNativeDataType
97786>>>>            Move 1                                       to aColumnType[i].iDefaultSize
97787>>>>            Move 1                                       to aColumnType[i].iMinSize
97788>>>>            Move 2000                                    to aColumnType[i].nMaxSize
97789>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
97790>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
97791>>>>            Move 2000                                    to aColumnType[i].sPrecision
97792>>>>            Increment i
97793>>>>
97793>>>>            Move "nclob"                                 to aColumnType[i].sSQLType
97794>>>>            Move 288                                     to aColumnType[i].iSQLType
97795>>>>            Move True                                    to aColumnType[i].bCanEditSize
97796>>>>            Move True                                    to aColumnType[i].bNativeDataType
97797>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
97798>>>>            Move 1                                       to aColumnType[i].iMinSize
97799>>>>            Move 16384                                   to aColumnType[i].nMaxSize
97800>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
97801>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
97802>>>>            Move 16384                                   to aColumnType[i].sPrecision
97803>>>>            Increment i
97804>>>>
97804>>>>            Move "number"                                to aColumnType[i].sSQLType
97805>>>>            Move 2                                       to aColumnType[i].iSQLType
97806>>>>            Move True                                    to aColumnType[i].bCanEditSize
97807>>>>            Move True                                    to aColumnType[i].bNativeDataType
97808>>>>            Move 1                                       to aColumnType[i].iDefaultSize
97809>>>>            Move 1                                       to aColumnType[i].iMinSize
97810>>>>            Move 14                                      to aColumnType[i].nMaxSize
97811>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
97812>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
97813>>>>            Move 14                                      to aColumnType[i].sPrecision
97814>>>>            Increment i
97815>>>>
97815>>>>            Move "nvarchar2"                             to aColumnType[i].sSQLType
97816>>>>            Move 287                                     to aColumnType[i].iSQLType
97817>>>>            Move True                                    to aColumnType[i].bCanEditSize
97818>>>>            Move True                                    to aColumnType[i].bNativeDataType
97819>>>>            Move 1                                       to aColumnType[i].iDefaultSize
97820>>>>            Move 1                                       to aColumnType[i].iMinSize
97821>>>>            Move 4000                                    to aColumnType[i].nMaxSize
97822>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
97823>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
97824>>>>            Move 4000                                    to aColumnType[i].sPrecision
97825>>>>            Increment i
97826>>>>
97826>>>>            Move "raw"                                   to aColumnType[i].sSQLType
97827>>>>            Move 23                                      to aColumnType[i].iSQLType
97828>>>>            Move True                                    to aColumnType[i].bCanEditSize
97829>>>>            Move True                                    to aColumnType[i].bNativeDataType
97830>>>>            Move 1                                       to aColumnType[i].iDefaultSize
97831>>>>            Move 1                                       to aColumnType[i].iMinSize
97832>>>>            Move 2000                                    to aColumnType[i].nMaxSize
97833>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
97834>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
97835>>>>            Move 2000                                    to aColumnType[i].sPrecision
97836>>>>            Increment i
97837>>>>
97837>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
97838>>>>            Move 187                                     to aColumnType[i].iSQLType
97839>>>>            Move False                                   to aColumnType[i].bCanEditSize
97840>>>>            Move True                                    to aColumnType[i].bNativeDataType
97841>>>>            Move 23                                      to aColumnType[i].iDefaultSize
97842>>>>            Move -1                                      to aColumnType[i].iMinSize
97843>>>>            Move -1                                      to aColumnType[i].nMaxSize
97844>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
97845>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
97846>>>>            Move -1                                      to aColumnType[i].sPrecision
97847>>>>            Increment i
97848>>>>
97848>>>>            Move "timestampltz"                          to aColumnType[i].sSQLType
97849>>>>            Move 232                                     to aColumnType[i].iSQLType
97850>>>>            Move False                                   to aColumnType[i].bCanEditSize
97851>>>>            Move True                                    to aColumnType[i].bNativeDataType
97852>>>>            Move 23                                      to aColumnType[i].iDefaultSize
97853>>>>            Move -1                                      to aColumnType[i].iMinSize
97854>>>>            Move -1                                      to aColumnType[i].nMaxSize
97855>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
97856>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
97857>>>>            Move -1                                      to aColumnType[i].sPrecision
97858>>>>            Increment i
97859>>>>
97859>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
97860>>>>            Move 188                                     to aColumnType[i].iSQLType
97861>>>>            Move False                                   to aColumnType[i].bCanEditSize
97862>>>>            Move True                                    to aColumnType[i].bNativeDataType
97863>>>>            Move 23                                      to aColumnType[i].iDefaultSize
97864>>>>            Move -1                                      to aColumnType[i].iMinSize
97865>>>>            Move -1                                      to aColumnType[i].nMaxSize
97866>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
97867>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
97868>>>>            Move -1                                      to aColumnType[i].sPrecision
97869>>>>            Increment i
97870>>>>
97870>>>>            Move "varchar2"                              to aColumnType[i].sSQLType
97871>>>>            Move 1                                       to aColumnType[i].iSQLType
97872>>>>            Move True                                    to aColumnType[i].bCanEditSize
97873>>>>            Move True                                    to aColumnType[i].bNativeDataType
97874>>>>            Move 1                                       to aColumnType[i].iDefaultSize
97875>>>>            Move 1                                       to aColumnType[i].iMinSize
97876>>>>            Move 4000                                    to aColumnType[i].nMaxSize
97877>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
97878>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
97879>>>>            Move 4000                                    to aColumnType[i].sPrecision
97880>>>>            Increment i
97881>>>>
97881>>>>
97881>>>        
97881>>>//        Move eOracle_BLOB       to ColumnType[i].iSQLType
97881>>>//        Move "BLOB"             to ColumnType[i].sSQLType
97881>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
97881>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
97881>>>//        Move "16384"            to ColumnType[i].sPrecision
97881>>>//        Increment i
97881>>>//
97881>>>//        Move eOracle_CHAR       to ColumnType[i].iSQLType
97881>>>//        Move "CHAR"             to ColumnType[i].sSQLType
97881>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
97881>>>//        Move "Text"             to ColumnType[i].sDataFlexType
97881>>>//        Move "2000"             to ColumnType[i].sPrecision
97881>>>//        Increment i
97881>>>//
97881>>>//        Move eOracle_CLOB       to ColumnType[i].iSQLType
97881>>>//        Move "CLOB"             to ColumnType[i].sSQLType
97881>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
97881>>>//        Move "Text"             to ColumnType[i].sDataFlexType
97881>>>//        Move "16384"            to ColumnType[i].sPrecision
97881>>>//        Increment i
97881>>>//
97881>>>//        Move eOracle_DATE       to ColumnType[i].iSQLType
97881>>>//        Move "DATE"             to ColumnType[i].sSQLType
97881>>>//        Move DF_Date            to ColumnType[i].iDataFlexType
97881>>>//        Move "Date"             to ColumnType[i].sDataFlexType
97881>>>//        Move "6.0"              to ColumnType[i].sPrecision
97881>>>//        Move True               to ColumnType[i].bCanEditSize
97881>>>//        Increment i
97881>>>//
97881>>>//        Move eOracle_FLOAT      to ColumnType[i].iSQLType
97881>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
97881>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
97881>>>//        Move "Number"           to ColumnType[i].sDataFlexType
97881>>>//        Move "14.8"             to ColumnType[i].sPrecision
97881>>>//        Increment i
97881>>>//
97881>>>//        Move eOracle_INT        to ColumnType[i].iSQLType
97881>>>//        Move "INT"              to ColumnType[i].sSQLType
97881>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
97881>>>//        Move "Number"           to ColumnType[i].sDataFlexType
97881>>>//        Move "14.0"             to ColumnType[i].sPrecision
97881>>>//        Increment i
97881>>>//
97881>>>//        Move eOracle_INTERVALDS to ColumnType[i].iSQLType
97881>>>//        Move "INTERVALDAYTOSEC" to ColumnType[i].sSQLType
97881>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
97881>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
97881>>>//        Move "23.0"             to ColumnType[i].sPrecision
97881>>>//        Move True               to ColumnType[i].bCanEditSize
97881>>>//        Increment i
97881>>>//
97881>>>//        Move eOracle_INTERVALYM  to ColumnType[i].iSQLType
97881>>>//        Move "INTERVALYEARTOMON" to ColumnType[i].sSQLType
97881>>>//        Move DF_DATETIME         to ColumnType[i].iDataFlexType
97881>>>//        Move "DateTime"          to ColumnType[i].sDataFlexType
97881>>>//        Move "23.0"              to ColumnType[i].sPrecision
97881>>>//        Move True                to ColumnType[i].bCanEditSize
97881>>>//        Increment i
97881>>>//
97881>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
97881>>>//        Move "LONG"             to ColumnType[i].sSQLType
97881>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
97881>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
97881>>>//        Move "16384"            to ColumnType[i].sPrecision
97881>>>//        Increment i
97881>>>//
97881>>>//        Move eOracle_LONGRAW    to ColumnType[i].iSQLType
97881>>>//        Move "LONG RAW"         to ColumnType[i].sSQLType
97881>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
97881>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
97881>>>//        Move "16384"            to ColumnType[i].sPrecision
97881>>>//        Increment i
97881>>>//
97881>>>//        Move eOracle_NCHAR      to ColumnType[i].iSQLType
97881>>>//        Move "NCHAR"            to ColumnType[i].sSQLType
97881>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
97881>>>//        Move "Text"             to ColumnType[i].sDataFlexType
97881>>>//        Move "2000"             to ColumnType[i].sPrecision
97881>>>//        Increment i
97881>>>//
97881>>>//        Move eOracle_NCLOB      to ColumnType[i].iSQLType
97881>>>//        Move "NCLOB"            to ColumnType[i].sSQLType
97881>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
97881>>>//        Move "Text"             to ColumnType[i].sDataFlexType
97881>>>//        Move "16384"            to ColumnType[i].sPrecision
97881>>>//        Increment i
97881>>>//
97881>>>//        Move eOracle_NUMBER     to ColumnType[i].iSQLType
97881>>>//        Move "NUMBER"           to ColumnType[i].sSQLType
97881>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
97881>>>//        Move "Number"           to ColumnType[i].sDataFlexType
97881>>>//        Move "14.8"             to ColumnType[i].sPrecision
97881>>>//        Increment i
97881>>>//
97881>>>//        Move eOracle_NVARCHAR2  to ColumnType[i].iSQLType
97881>>>//        Move "NVARCHAR2"        to ColumnType[i].sSQLType
97881>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
97881>>>//        Move "Text"             to ColumnType[i].sDataFlexType
97881>>>//        Move "4000"             to ColumnType[i].sPrecision
97881>>>//        Increment i
97881>>>//
97881>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
97881>>>//        Move "RAW"              to ColumnType[i].sSQLType
97881>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
97881>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
97881>>>//        Move "2000"             to ColumnType[i].sPrecision
97881>>>//        Increment i
97881>>>//
97881>>>//        Move eOracle_ROWID      to ColumnType[i].iSQLType
97881>>>//        Move "ROWID"            to ColumnType[i].sSQLType
97881>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
97881>>>//        Move "Text"             to ColumnType[i].sDataFlexType
97881>>>//        Move "16384"            to ColumnType[i].sPrecision
97881>>>//        Increment i
97881>>>//
97881>>>//        Move eOracle_TIMESTAMP  to ColumnType[i].iSQLType
97881>>>//        Move "TimeStamp"        to ColumnType[i].sSQLType
97881>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
97881>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
97881>>>//        Move "11.0"             to ColumnType[i].sPrecision
97881>>>//        Move True               to ColumnType[i].bCanEditSize
97881>>>//        Increment i
97881>>>//
97881>>>//        Move eOracle_TIMESTAMPLTZ   to ColumnType[i].iSQLType
97881>>>//        Move "TIMESTAMPLOCALTZ"     to ColumnType[i].sSQLType
97881>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
97881>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
97881>>>//        Move "13.0"                 to ColumnType[i].sPrecision
97881>>>//        Move True                   to ColumnType[i].bCanEditSize
97881>>>//        Increment i
97881>>>//
97881>>>//        Move eOracle_TIMESTAMPTZ    to ColumnType[i].iSQLType
97881>>>//        Move "TIMEZONETIMEZONE"     to ColumnType[i].sSQLType
97881>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
97881>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
97881>>>//        Move "11.0"                 to ColumnType[i].sPrecision
97881>>>//        Move True                   to ColumnType[i].bCanEditSize
97881>>>//        Increment i
97881>>>//
97881>>>//        Move eOracle_VARCHAR2   to ColumnType[i].iSQLType
97881>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
97881>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
97881>>>//        Move "Text"             to ColumnType[i].sDataFlexType
97881>>>//        Move "16384"            to ColumnType[i].sPrecision
97881>>>
97881>>>        Function_Return aColumnType
97882>>>    End_Function
97883>>>
97883>>>    // PostgreSQL Data Types
97883>>>    Function _UtilEnumeratePostgreSQLTypes Returns tColumnType[]
97885>>>        tColumnType[] aColumnType
97885>>>        tColumnType[] aColumnType
97886>>>        Integer i
97886>>>        
Including file: mdspgsql_DriverDef.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\mdspgsql_DriverDef.inc)
97886>>>>// Generated By The Database Update Framework
97886>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdspgsql_DriverDef.xml
97886>>>>// Driver COLUMN DATA TYPES
97886>>>>//
97886>>>>// Created: 2018-03-14 23:47:02.984
97886>>>>
97886>>>>            Move "bigint"                                to aColumnType[i].sSQLType
97887>>>>            Move 20                                      to aColumnType[i].iSQLType
97888>>>>            Move True                                    to aColumnType[i].bCanEditSize
97889>>>>            Move True                                    to aColumnType[i].bNativeDataType
97890>>>>            Move 14                                      to aColumnType[i].iDefaultSize
97891>>>>            Move 1                                       to aColumnType[i].iMinSize
97892>>>>            Move 14                                      to aColumnType[i].nMaxSize
97893>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
97894>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
97895>>>>            Move 14                                      to aColumnType[i].sPrecision
97896>>>>            Increment i
97897>>>>
97897>>>>            Move "bit"                                   to aColumnType[i].sSQLType
97898>>>>            Move 1560                                    to aColumnType[i].iSQLType
97899>>>>            Move True                                    to aColumnType[i].bCanEditSize
97900>>>>            Move True                                    to aColumnType[i].bNativeDataType
97901>>>>            Move 1                                       to aColumnType[i].iDefaultSize
97902>>>>            Move 1                                       to aColumnType[i].iMinSize
97903>>>>            Move 16384                                   to aColumnType[i].nMaxSize
97904>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
97905>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
97906>>>>            Move 16384                                   to aColumnType[i].sPrecision
97907>>>>            Increment i
97908>>>>
97908>>>>            Move "boolean"                               to aColumnType[i].sSQLType
97909>>>>            Move 16                                      to aColumnType[i].iSQLType
97910>>>>            Move False                                   to aColumnType[i].bCanEditSize
97911>>>>            Move True                                    to aColumnType[i].bNativeDataType
97912>>>>            Move 1                                       to aColumnType[i].iDefaultSize
97913>>>>            Move -1                                      to aColumnType[i].iMinSize
97914>>>>            Move -1                                      to aColumnType[i].nMaxSize
97915>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
97916>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
97917>>>>            Move -1                                      to aColumnType[i].sPrecision
97918>>>>            Increment i
97919>>>>
97919>>>>            Move "bytea"                                 to aColumnType[i].sSQLType
97920>>>>            Move 17                                      to aColumnType[i].iSQLType
97921>>>>            Move True                                    to aColumnType[i].bCanEditSize
97922>>>>            Move True                                    to aColumnType[i].bNativeDataType
97923>>>>            Move 1                                       to aColumnType[i].iDefaultSize
97924>>>>            Move 1                                       to aColumnType[i].iMinSize
97925>>>>            Move 16384                                   to aColumnType[i].nMaxSize
97926>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
97927>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
97928>>>>            Move 16384                                   to aColumnType[i].sPrecision
97929>>>>            Increment i
97930>>>>
97930>>>>            Move "char"                                  to aColumnType[i].sSQLType
97931>>>>            Move 18                                      to aColumnType[i].iSQLType
97932>>>>            Move True                                    to aColumnType[i].bCanEditSize
97933>>>>            Move True                                    to aColumnType[i].bNativeDataType
97934>>>>            Move 1                                       to aColumnType[i].iDefaultSize
97935>>>>            Move 1                                       to aColumnType[i].iMinSize
97936>>>>            Move 16384                                   to aColumnType[i].nMaxSize
97937>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
97938>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
97939>>>>            Move 16384                                   to aColumnType[i].sPrecision
97940>>>>            Increment i
97941>>>>
97941>>>>            Move "citext"                                to aColumnType[i].sSQLType
97942>>>>            Move -25                                     to aColumnType[i].iSQLType
97943>>>>            Move True                                    to aColumnType[i].bCanEditSize
97944>>>>            Move True                                    to aColumnType[i].bNativeDataType
97945>>>>            Move 1                                       to aColumnType[i].iDefaultSize
97946>>>>            Move 1                                       to aColumnType[i].iMinSize
97947>>>>            Move 16384                                   to aColumnType[i].nMaxSize
97948>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
97949>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
97950>>>>            Move 16384                                   to aColumnType[i].sPrecision
97951>>>>            Increment i
97952>>>>
97952>>>>            Move "date"                                  to aColumnType[i].sSQLType
97953>>>>            Move 1082                                    to aColumnType[i].iSQLType
97954>>>>            Move False                                   to aColumnType[i].bCanEditSize
97955>>>>            Move True                                    to aColumnType[i].bNativeDataType
97956>>>>            Move 6                                       to aColumnType[i].iDefaultSize
97957>>>>            Move -1                                      to aColumnType[i].iMinSize
97958>>>>            Move -1                                      to aColumnType[i].nMaxSize
97959>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
97960>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
97961>>>>            Move 6                                       to aColumnType[i].sPrecision
97962>>>>            Increment i
97963>>>>
97963>>>>            Move "double"                                to aColumnType[i].sSQLType
97964>>>>            Move 701                                     to aColumnType[i].iSQLType
97965>>>>            Move True                                    to aColumnType[i].bCanEditSize
97966>>>>            Move True                                    to aColumnType[i].bNativeDataType
97967>>>>            Move 14                                      to aColumnType[i].iDefaultSize
97968>>>>            Move 1                                       to aColumnType[i].iMinSize
97969>>>>            Move 14                                      to aColumnType[i].nMaxSize
97970>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
97971>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
97972>>>>            Move 14                                      to aColumnType[i].sPrecision
97973>>>>            Increment i
97974>>>>
97974>>>>            Move "integer"                               to aColumnType[i].sSQLType
97975>>>>            Move 23                                      to aColumnType[i].iSQLType
97976>>>>            Move True                                    to aColumnType[i].bCanEditSize
97977>>>>            Move True                                    to aColumnType[i].bNativeDataType
97978>>>>            Move 11                                      to aColumnType[i].iDefaultSize
97979>>>>            Move 1                                       to aColumnType[i].iMinSize
97980>>>>            Move 11                                      to aColumnType[i].nMaxSize
97981>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
97982>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
97983>>>>            Move 11                                      to aColumnType[i].sPrecision
97984>>>>            Increment i
97985>>>>
97985>>>>            Move "money"                                 to aColumnType[i].sSQLType
97986>>>>            Move 790                                     to aColumnType[i].iSQLType
97987>>>>            Move True                                    to aColumnType[i].bCanEditSize
97988>>>>            Move True                                    to aColumnType[i].bNativeDataType
97989>>>>            Move 30                                      to aColumnType[i].iDefaultSize
97990>>>>            Move 1                                       to aColumnType[i].iMinSize
97991>>>>            Move 30                                      to aColumnType[i].nMaxSize
97992>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
97993>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
97994>>>>            Move 30                                      to aColumnType[i].sPrecision
97995>>>>            Increment i
97996>>>>
97996>>>>            Move "numeric"                               to aColumnType[i].sSQLType
97997>>>>            Move 1700                                    to aColumnType[i].iSQLType
97998>>>>            Move True                                    to aColumnType[i].bCanEditSize
97999>>>>            Move True                                    to aColumnType[i].bNativeDataType
98000>>>>            Move 14                                      to aColumnType[i].iDefaultSize
98001>>>>            Move 1                                       to aColumnType[i].iMinSize
98002>>>>            Move 14                                      to aColumnType[i].nMaxSize
98003>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98004>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98005>>>>            Move 14                                      to aColumnType[i].sPrecision
98006>>>>            Increment i
98007>>>>
98007>>>>            Move "oid"                                   to aColumnType[i].sSQLType
98008>>>>            Move 26                                      to aColumnType[i].iSQLType
98009>>>>            Move False                                   to aColumnType[i].bCanEditSize
98010>>>>            Move True                                    to aColumnType[i].bNativeDataType
98011>>>>            Move 20                                      to aColumnType[i].iDefaultSize
98012>>>>            Move -1                                      to aColumnType[i].iMinSize
98013>>>>            Move -1                                      to aColumnType[i].nMaxSize
98014>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
98015>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
98016>>>>            Move -1                                      to aColumnType[i].sPrecision
98017>>>>            Increment i
98018>>>>
98018>>>>            Move "real"                                  to aColumnType[i].sSQLType
98019>>>>            Move 700                                     to aColumnType[i].iSQLType
98020>>>>            Move True                                    to aColumnType[i].bCanEditSize
98021>>>>            Move True                                    to aColumnType[i].bNativeDataType
98022>>>>            Move 6                                       to aColumnType[i].iDefaultSize
98023>>>>            Move 1                                       to aColumnType[i].iMinSize
98024>>>>            Move 6                                       to aColumnType[i].nMaxSize
98025>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
98026>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
98027>>>>            Move 6                                       to aColumnType[i].sPrecision
98028>>>>            Increment i
98029>>>>
98029>>>>            Move "regproc"                               to aColumnType[i].sSQLType
98030>>>>            Move 24                                      to aColumnType[i].iSQLType
98031>>>>            Move False                                   to aColumnType[i].bCanEditSize
98032>>>>            Move True                                    to aColumnType[i].bNativeDataType
98033>>>>            Move 64                                      to aColumnType[i].iDefaultSize
98034>>>>            Move -1                                      to aColumnType[i].iMinSize
98035>>>>            Move -1                                      to aColumnType[i].nMaxSize
98036>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98037>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98038>>>>            Move -1                                      to aColumnType[i].sPrecision
98039>>>>            Increment i
98040>>>>
98040>>>>            Move "smallint"                              to aColumnType[i].sSQLType
98041>>>>            Move 21                                      to aColumnType[i].iSQLType
98042>>>>            Move True                                    to aColumnType[i].bCanEditSize
98043>>>>            Move True                                    to aColumnType[i].bNativeDataType
98044>>>>            Move 6                                       to aColumnType[i].iDefaultSize
98045>>>>            Move 1                                       to aColumnType[i].iMinSize
98046>>>>            Move 6                                       to aColumnType[i].nMaxSize
98047>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
98048>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
98049>>>>            Move 6                                       to aColumnType[i].sPrecision
98050>>>>            Increment i
98051>>>>
98051>>>>            Move "text"                                  to aColumnType[i].sSQLType
98052>>>>            Move 25                                      to aColumnType[i].iSQLType
98053>>>>            Move True                                    to aColumnType[i].bCanEditSize
98054>>>>            Move True                                    to aColumnType[i].bNativeDataType
98055>>>>            Move 1                                       to aColumnType[i].iDefaultSize
98056>>>>            Move 1                                       to aColumnType[i].iMinSize
98057>>>>            Move 16384                                   to aColumnType[i].nMaxSize
98058>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98059>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98060>>>>            Move 16384                                   to aColumnType[i].sPrecision
98061>>>>            Increment i
98062>>>>
98062>>>>            Move "time"                                  to aColumnType[i].sSQLType
98063>>>>            Move 1083                                    to aColumnType[i].iSQLType
98064>>>>            Move True                                    to aColumnType[i].bCanEditSize
98065>>>>            Move True                                    to aColumnType[i].bNativeDataType
98066>>>>            Move 8                                       to aColumnType[i].iDefaultSize
98067>>>>            Move 8                                       to aColumnType[i].iMinSize
98068>>>>            Move 15                                      to aColumnType[i].nMaxSize
98069>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98070>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98071>>>>            Move 15                                      to aColumnType[i].sPrecision
98072>>>>            Increment i
98073>>>>
98073>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
98074>>>>            Move 1114                                    to aColumnType[i].iSQLType
98075>>>>            Move False                                   to aColumnType[i].bCanEditSize
98076>>>>            Move True                                    to aColumnType[i].bNativeDataType
98077>>>>            Move 23                                      to aColumnType[i].iDefaultSize
98078>>>>            Move -1                                      to aColumnType[i].iMinSize
98079>>>>            Move -1                                      to aColumnType[i].nMaxSize
98080>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
98081>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
98082>>>>            Move -1                                      to aColumnType[i].sPrecision
98083>>>>            Increment i
98084>>>>
98084>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
98085>>>>            Move 1184                                    to aColumnType[i].iSQLType
98086>>>>            Move False                                   to aColumnType[i].bCanEditSize
98087>>>>            Move True                                    to aColumnType[i].bNativeDataType
98088>>>>            Move 23                                      to aColumnType[i].iDefaultSize
98089>>>>            Move -1                                      to aColumnType[i].iMinSize
98090>>>>            Move -1                                      to aColumnType[i].nMaxSize
98091>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98092>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98093>>>>            Move -1                                      to aColumnType[i].sPrecision
98094>>>>            Increment i
98095>>>>
98095>>>>            Move "uuid"                                  to aColumnType[i].sSQLType
98096>>>>            Move 2950                                    to aColumnType[i].iSQLType
98097>>>>            Move False                                   to aColumnType[i].bCanEditSize
98098>>>>            Move True                                    to aColumnType[i].bNativeDataType
98099>>>>            Move 40                                      to aColumnType[i].iDefaultSize
98100>>>>            Move -1                                      to aColumnType[i].iMinSize
98101>>>>            Move -1                                      to aColumnType[i].nMaxSize
98102>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98103>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98104>>>>            Move -1                                      to aColumnType[i].sPrecision
98105>>>>            Increment i
98106>>>>
98106>>>>            Move "varbit"                                to aColumnType[i].sSQLType
98107>>>>            Move 1562                                    to aColumnType[i].iSQLType
98108>>>>            Move True                                    to aColumnType[i].bCanEditSize
98109>>>>            Move True                                    to aColumnType[i].bNativeDataType
98110>>>>            Move 1                                       to aColumnType[i].iDefaultSize
98111>>>>            Move 1                                       to aColumnType[i].iMinSize
98112>>>>            Move 16384                                   to aColumnType[i].nMaxSize
98113>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98114>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98115>>>>            Move 16384                                   to aColumnType[i].sPrecision
98116>>>>            Increment i
98117>>>>
98117>>>>            Move "varchar"                               to aColumnType[i].sSQLType
98118>>>>            Move 1043                                    to aColumnType[i].iSQLType
98119>>>>            Move True                                    to aColumnType[i].bCanEditSize
98120>>>>            Move True                                    to aColumnType[i].bNativeDataType
98121>>>>            Move 1                                       to aColumnType[i].iDefaultSize
98122>>>>            Move 1                                       to aColumnType[i].iMinSize
98123>>>>            Move 16384                                   to aColumnType[i].nMaxSize
98124>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98125>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98126>>>>            Move 16384                                   to aColumnType[i].sPrecision
98127>>>>            Increment i
98128>>>>
98128>>>>
98128>>>        
98128>>>//        Move ePgSQL_INT8        to ColumnType[i].iSQLType
98128>>>//        Move "bigint"           to ColumnType[i].sSQLType
98128>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
98128>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
98128>>>//        Move "14.0"             to ColumnType[i].sPrecision
98128>>>//        Move True               to ColumnType[i].bCanEditSize
98128>>>//        Increment i
98128>>>//
98128>>>//        Move ePgSQL_BIT         to ColumnType[i].iSQLType
98128>>>//        Move "bit"              to ColumnType[i].sSQLType
98128>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
98128>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
98128>>>//        Move "16384"            to ColumnType[i].sPrecision
98128>>>//        Increment i
98128>>>//
98128>>>//        Move ePgSQL_BOOL        to ColumnType[i].iSQLType
98128>>>//        Move "boolean"          to ColumnType[i].sSQLType
98128>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
98128>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
98128>>>//        Move "1"                to ColumnType[i].sPrecision
98128>>>//        Increment i
98128>>>//
98128>>>//        Move ePgSQL_BYTEA       to ColumnType[i].iSQLType
98128>>>//        Move "bytea"            to ColumnType[i].sSQLType
98128>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
98128>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
98128>>>//        Move "16384"            to ColumnType[i].sPrecision
98128>>>//        Increment i
98128>>>//
98128>>>//        Move ePgSQL_CHAR        to ColumnType[i].iSQLType
98128>>>//        Move "char"             to ColumnType[i].sSQLType
98128>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
98128>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
98128>>>//        Move "2000"             to ColumnType[i].sPrecision
98128>>>//        Increment i
98128>>>//
98128>>>//        Move ePgSQL_CITEXT      to ColumnType[i].iSQLType
98128>>>//        Move "citext"           to ColumnType[i].sSQLType
98128>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
98128>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
98128>>>//        Move "254"              to ColumnType[i].sPrecision
98128>>>//        Increment i
98128>>>//
98128>>>//        Move ePgSQL_DATE        to ColumnType[i].iSQLType
98128>>>//        Move "date"             to ColumnType[i].sSQLType
98128>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
98128>>>//        Move "Date"             to ColumnType[i].sDataFlexType
98128>>>//        Move "6.0"              to ColumnType[i].sPrecision
98128>>>//        Move True               to ColumnType[i].bCanEditSize
98128>>>//        Increment i
98128>>>//
98128>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
98128>>>//        Move "decimal"          to ColumnType[i].sSQLType
98128>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
98128>>>//        Move "Decimal"          to ColumnType[i].sDataFlexType
98128>>>//        Move "14.8"             to ColumnType[i].sPrecision
98128>>>//        Increment i
98128>>>//
98128>>>//        Move ePgSQL_FLOAT8      to ColumnType[i].iSQLType
98128>>>//        Move "double"           to ColumnType[i].sSQLType
98128>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
98128>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
98128>>>//        Move "22"               to ColumnType[i].sPrecision
98128>>>//        Increment i
98128>>>//
98128>>>//        Move ePgSQL_INT4        to ColumnType[i].iSQLType
98128>>>//        Move "integer"          to ColumnType[i].sSQLType
98128>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
98128>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
98128>>>//        Move "8.0"              to ColumnType[i].sPrecision
98128>>>//        Increment i
98128>>>//
98128>>>//        Move ePgSQL_MONEY       to ColumnType[i].iSQLType
98128>>>//        Move "money"            to ColumnType[i].sSQLType
98128>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
98128>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
98128>>>//        Move "8.0"              to ColumnType[i].sPrecision
98128>>>//        Increment i
98128>>>//
98128>>>//        Move ePgSQL_OID         to ColumnType[i].iSQLType
98128>>>//        Move "oid"              to ColumnType[i].sSQLType
98128>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
98128>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
98128>>>//        Move "16384"            to ColumnType[i].sPrecision
98128>>>//        Increment i
98128>>>//
98128>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
98128>>>//        Move "real"             to ColumnType[i].sSQLType
98128>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
98128>>>//        Move "Real"             to ColumnType[i].sDataFlexType
98128>>>//        Move "6.6"              to ColumnType[i].sPrecision
98128>>>//        Increment i
98128>>>//
98128>>>//        Move ePgSQL_REGPROC     to ColumnType[i].iSQLType
98128>>>//        Move "regproc"          to ColumnType[i].sSQLType
98128>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
98128>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
98128>>>//        Move "64"               to ColumnType[i].sPrecision
98128>>>//        Increment i
98128>>>//
98128>>>//        Move ePgSQL_INT2        to ColumnType[i].iSQLType
98128>>>//        Move "smallint"         to ColumnType[i].sSQLType
98128>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
98128>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
98128>>>//        Move "6.0"              to ColumnType[i].sPrecision
98128>>>//        Increment i
98128>>>//
98128>>>//        Move ePgSQL_TEXT        to ColumnType[i].iSQLType
98128>>>//        Move "text"             to ColumnType[i].sSQLType
98128>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
98128>>>//        Move "Text"             to ColumnType[i].sDataFlexType
98128>>>//        Move "16384"            to ColumnType[i].sPrecision
98128>>>//        Increment i
98128>>>//
98128>>>//        Move ePgSQL_TIME        to ColumnType[i].iSQLType
98128>>>//        Move "time"             to ColumnType[i].sSQLType
98128>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
98128>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
98128>>>//        Move "15.0"             to ColumnType[i].sPrecision
98128>>>//        Increment i
98128>>>//
98128>>>//        Move ePgSQL_TIMESTAMP   to ColumnType[i].iSQLType
98128>>>//        Move "timestamp"        to ColumnType[i].sSQLType
98128>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
98128>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
98128>>>//        Move "23.0"             to ColumnType[i].sPrecision
98128>>>//        Move True               to ColumnType[i].bCanEditSize
98128>>>//        Increment i
98128>>>//
98128>>>//        Move ePgSQL_UUID        to ColumnType[i].iSQLType
98128>>>//        Move "uuid"             to ColumnType[i].sSQLType
98128>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
98128>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
98128>>>//        Move "40"               to ColumnType[i].sPrecision
98128>>>//        Move True               to ColumnType[i].bCanEditSize
98128>>>//        Increment i
98128>>>//
98128>>>//        Move ePgSQL_VARCHAR     to ColumnType[i].iSQLType
98128>>>//        Move "varchar"          to ColumnType[i].sSQLType
98128>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
98128>>>//        Move "DF_TEXT"          to ColumnType[i].sDataFlexType
98128>>>//        Move "16384"            to ColumnType[i].sPrecision
98128>>>//        Increment i
98128>>>
98128>>>        Function_Return aColumnType
98129>>>    End_Function
98130>>>
98130>>>    // Internal usage. Use the UtilColumnTypeXXX functions instead.
98130>>>    Function _UtilColumnType String sDriverID Integer iDbType Integer iType String sType Boolean bIntegerInputType Returns tColumnType
98132>>>        Integer iValue iSize iCount iStart
98132>>>        tColumnType[] ColumnTypeArray
98132>>>        tColumnType[] ColumnTypeArray
98133>>>        tColumnType RetvalType
98133>>>        tColumnType RetvalType
98133>>>        String sValue
98133>>>        Boolean bFrameworkDataFlexType
98133>>>
98133>>>        Move "Undefined" to RetvalType.sSQLType
98134>>>        Move -1999       to RetvalType.iSQLType
98135>>>
98135>>>        Move 0 to iStart
98136>>>        Move (Uppercase(sType)) to sType
98137>>>        Move (iType <= -1490) to bFrameworkDataFlexType
98138>>>        If (bFrameworkDataFlexType = True) Begin
98140>>>            Get UtilDUFDataTypeToSqlTypeMapping sDriverID iDbType iType to RetvalType
98141>>>            Function_Return RetvalType
98142>>>        End
98142>>>>
98142>>>
98142>>>        Get UtilEnumerateColumnTypes sDriverID iDbType to ColumnTypeArray
98143>>>
98143>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
98144>>>        Decrement iSize
98145>>>
98145>>>        for iCount from iStart to iSize
98151>>>>
98151>>>            Move ColumnTypeArray[iCount].iSQLType to iValue
98152>>>            Move ColumnTypeArray[iCount].sSQLType to sValue
98153>>>            If (bIntegerInputType = True) Begin
98155>>>                If (iValue = iType) Begin
98157>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
98158>>>                    Move iType                                  to RetvalType.iSQLType
98159>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
98160>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
98161>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
98162>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
98163>>>                    Move iSize to iCount // We're done!
98164>>>                End
98164>>>>
98164>>>            End
98164>>>>
98164>>>            Else Begin
98165>>>                Move (Uppercase(sValue)) to sValue
98166>>>                If (sValue = sType) Begin
98168>>>                    Move sType                                  to RetvalType.sSQLType
98169>>>                    Move ColumnTypeArray[iCount].iSQLType       to RetvalType.iSQLType
98170>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
98171>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
98172>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
98173>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
98174>>>                    Move iSize to iCount // We're done!
98175>>>                End
98175>>>>
98175>>>            End
98175>>>>
98175>>>        Loop
98176>>>>
98176>>>
98176>>>        // If no match was found it was probably because it was a DataFlex standard type that was passed.
98176>>>        // In which case we search for a match in DataFlex standard types:
98176>>>        If (RetvalType.sSQLType = "Undefined") Begin
98178>>>            Get _UtilEnumerateDataFlexTypes to ColumnTypeArray
98179>>>            Move (SizeOfArray(ColumnTypeArray)) to iSize
98180>>>            Decrement iSize
98181>>>
98181>>>            for iCount from iStart to iSize
98187>>>>
98187>>>                Move ColumnTypeArray[iCount].iSQLType to iValue
98188>>>                Move ColumnTypeArray[iCount].sSQLType to sValue
98189>>>                If (iValue = iType) Begin
98191>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
98192>>>                    Move iType                                  to RetvalType.iSQLType
98193>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
98194>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
98195>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
98196>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
98197>>>                    Move iSize to iCount // We're done!
98198>>>                End
98198>>>>
98198>>>            Loop
98199>>>>
98199>>>        End
98199>>>>
98199>>>
98199>>>        Function_Return RetvalType
98200>>>    End_Function
98201>>>
98201>>>    Function _AllTablesToConvert Returns Integer[]
98203>>>        Integer[] aTableConvertExceptions iTablesArray
98205>>>        Handle hTable
98205>>>        Integer iIndex
98205>>>        String sTableName
98205>>>        Boolean bFlexErrs
98205>>>
98205>>>        // a) Get the exception table array the developer has specified
98205>>>        Get paTableConvertExceptions to aTableConvertExceptions
98206>>>
98206>>>        // b) Add CodeMast, CodeType & DbVersion to exceptions
98206>>>        Repeat
98206>>>>
98206>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
98209>>>            If (hTable <> 0) Begin
98211>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
98214>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
98215>>>                If (bFlexErrs = False) Begin
98217>>>                    If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "DBVERSION") Begin
98219>>>                        Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
98220>>>                        If (iIndex = -1) Begin
98222>>>                            Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
98223>>>                        End
98223>>>>
98223>>>                    End
98223>>>>
98223>>>                End
98223>>>>
98223>>>            End
98223>>>>
98223>>>        Until (hTable = 0)
98225>>>
98225>>>        Move 0 to hTable
98226>>>
98226>>>        // c) Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
98226>>>        Repeat
98226>>>>
98226>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
98229>>>            If (hTable > 0) Begin
98231>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
98234>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
98235>>>                If (bFlexErrs = False) Begin
98237>>>                    Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
98238>>>                    If (iIndex = -1) Begin
98240>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
98241>>>                    End
98241>>>>
98241>>>                End
98241>>>>
98241>>>            End
98241>>>>
98241>>>        Until (hTable = 0)
98243>>>
98243>>>        Function_Return iTablesArray
98244>>>    End_Function
98245>>>
98245>>>    Function _AllTablesDateCorrections Returns Integer[]
98247>>>        Integer[] aTableDateCorrectionExceptions iTablesArray
98249>>>        Handle hTable
98249>>>        Integer iIndex
98249>>>        String sTableName
98249>>>        Boolean bFlexErrs
98249>>>
98249>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
98250>>>        Move 0 to hTable
98251>>>
98251>>>        // Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
98251>>>        Repeat
98251>>>>
98251>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
98254>>>            If (hTable > 0) Begin
98256>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
98259>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
98260>>>                If (bFlexErrs = False) Begin
98262>>>                    Move (SearchArray(hTable, aTableDateCorrectionExceptions)) to iIndex
98263>>>                    If (iIndex = -1) Begin
98265>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
98266>>>                    End
98266>>>>
98266>>>                End
98266>>>>
98266>>>            End
98266>>>>
98266>>>        Until (hTable = 0)
98268>>>
98268>>>        Function_Return iTablesArray
98269>>>    End_Function
98270>>>
98270>>>    Function _AppendAPIColumn tAPIColumn[] aCurrent String sFieldName Integer iType Integer iLength Integer iPrecision Integer iOptions Returns tAPIColumn[]
98272>>>        tAPIColumn NewAPIColumn
98272>>>        tAPIColumn NewAPIColumn
98272>>>
98272>>>        Move sFieldName to NewAPIColumn.sFieldName
98273>>>        Move iType      to NewAPIColumn.iType
98274>>>        Move iLength    to NewAPIColumn.iLength
98275>>>        Move iPrecision to NewAPIColumn.iPrecision
98276>>>        Move iOptions   to NewAPIColumn.iOptions
98277>>>
98277>>>        Move NewAPIColumn to aCurrent[SizeOfArray(aCurrent)]
98278>>>
98278>>>        Function_Return aCurrent
98279>>>    End_Function
98280>>>
98280>>>    Function _UtilIndexAppendSegmentFieldNames tAPIIndexSegment[] APIIndexSegment Returns String
98282>>>        String sRetval sFieldName
98282>>>        Integer iCount iSize
98282>>>
98282>>>        Move (SizeOfArray(APIIndexSegment)) to iSize
98283>>>        Decrement iSize
98284>>>        for iCount from 0 to iSize
98290>>>>
98290>>>            Move APIIndexSegment[iCount].sFieldName to sFieldName
98291>>>            Move (sRetval * (String(sFieldName))) to sRetval
98292>>>        Loop
98293>>>>
98293>>>        Move (Trim(sRetval)) to sRetval
98294>>>
98294>>>        Function_Return sRetval
98295>>>    End_Function
98296>>>
98296>>>    // *** Miscellaneous other functions ***
98296>>>    // Some of which can be used by both "Sqlxxx" and "Apixxx" functions.
98296>>>    //
98296>>>
98296>>>    // Callback functionality used when e.g. calling driver functions directly.
98296>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
98298>>>        Integer iPerc
98298>>>        Number nReady nTotal
98298>>>
98298>>>        Send DoAdvance of ghoProgressBar
98299>>>
98299>>>        If (sCallback_Text contains "Copy records") Begin
98301>>>            Move CS_SQLCopyingData to sCallback_Text
98302>>>        End
98302>>>>
98302>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
98304>>>            Move (Replace("Dropping index", sCallback_Text, CS_SQLDeletingIndex)) to sCallback_Text
98305>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_SQLDeletingIndex)) to sCallback_Text
98306>>>        End
98306>>>>
98306>>>        If (sCallback_Text contains "Creating index") Begin
98308>>>            Move (Replace("Creating index", sCallback_Text, CS_SQLCreatingIndex)) to sCallback_Text
98309>>>        End
98309>>>>
98309>>>
98309>>>        Case Begin
98309>>>            Case (iCallback_Type = DF_Message_Text)
98311>>>//                Set Message_Text of ghoStatusPanel to sCallback_Text
98311>>>                Set Action_Text  of ghoStatusPanel to ""
98312>>>                Case Break
98313>>>            Case (iCallback_Type = DF_Message_Heading_1)
98316>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
98317>>>                Set Action_Text  of ghoStatusPanel to ""
98318>>>                Case Break
98319>>>            Case (iCallback_Type = DF_Message_Heading_2)
98322>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
98323>>>                Set Action_Text  of ghoStatusPanel to ""
98324>>>                Case Break
98325>>>            Case (iCallback_Type = DF_Message_Heading_3)
98328>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
98329>>>                Set Action_Text  of ghoStatusPanel to ""
98330>>>                Case Break
98331>>>            Case (iCallback_Type = DF_Message_Heading_4)
98334>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
98335>>>                Set Action_Text  of ghoStatusPanel to ""
98336>>>                Case Break
98337>>>            Case (iCallback_Type = DF_Message_Heading_5)
98340>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
98341>>>                Set Action_Text  of ghoStatusPanel to ""
98342>>>                Case Break
98343>>>            Case (iCallback_Type = DF_Message_Warning)
98346>>>                Send None
98347>>>                Case Break
98348>>>            Case (iCallback_Type = DF_Message_Progress_Title)
98351>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
98352>>>                Set Action_Text  of ghoStatusPanel to ""
98353>>>                Case Break
98354>>>            Case (iCallback_Type = DF_Message_Progress_Value)
98357>>>                //*** Interpret numbers
98357>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
98358>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
98359>>>                Move ((nReady / nTotal) * 100)                                                    to iPerc
98360>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% Done (Total Number of Records:") * String(nTotal) + ")")
98361>>>                Case Break
98362>>>            Case Else
98362>>>                Set Message_Text to ""
98363>>>                Set Action_Text  to ""
98364>>>        Case End
98364>>>
98364>>>        Send ProcessEvents of ghoStatusPanel
98365>>>        Function_Return False
98366>>>    End_Function
98367>>>
98367>>>    Procedure IncreaseSortBufferSize
98369>>>        String sNull
98369>>>        Integer iSortBufferSize
98369>>>        Boolean bBufferSet
98369>>>
98369>>>        Move "" to sNull
98370>>>        Move (1024 * 128) to iSortBufferSize
98371>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_SET_MAX_SORT_BUFFER Callback ghoDbUpdateHandler Passing sNull sNull iSortBufferSize Result bBufferSet
98376>>>
98376>>>    End_Procedure
98377>>>
98377>>>    Procedure SetAllIndexesToBatch Handle hTable Boolean bSetToBatch
98379>>>        Integer iLastIndex iIndex iNumSegments
98379>>>        Boolean bOK    
98379>>>        String sDriverID
98379>>>
98379>>>        If (hTable > 0) Begin
98381>>>            Get UtilDriverFromTableNumber hTable to sDriverID
98382>>>            Close hTable
98383>>>            Get OpenTableExclusive hTable to bOK
98384>>>            If (bOK = False) Begin
98386>>>                Function_Return False
98387>>>            End
98387>>>>
98387>>>            Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex   
98390>>>            Structure_Start hTable sDriverID
98391>>>                for iIndex from 1 to iLastIndex
98397>>>>
98397>>>                    Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
98400>>>                    If (iNumSegments > 0) Begin                     
98402>>>                        If (bSetToBatch = True) Begin
98404>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_BATCH
98407>>>                        End                 
98407>>>>
98407>>>                        Else Begin
98408>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_ONLINE
98411>>>                        End
98411>>>>
98411>>>                    End
98411>>>>
98411>>>                Loop
98412>>>>
98412>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
98414>>>        End
98414>>>>
98414>>>    End_Procedure
98415>>>
98415>>>    Function NextFreeFilelistSlot Returns Handle
98417>>>        Handle hTable
98417>>>
98417>>>        Move 0 to hTable
98418>>>        Get_Attribute DF_FILE_NEXT_EMPTY of hTable to hTable
98421>>>
98421>>>        Function_Return hTable
98422>>>    End_Function
98423>>>
98423>>>    // For debugging purposes. To print Sql statements as they are build...
98423>>>    Procedure DebugPrint String sStmt String sFileName
98425>>>        Integer iCh
98425>>>        Get Seq_Append_Output_Channel sFileName to iCh
98426>>>            Write channel iCh sStmt
98428>>>        Send Seq_Close_Channel iCh
98429>>>    End_Procedure
98430>>>
98430>>>    // Returns the integer number for the passed Driver ID that is
98430>>>    // needed by some database API calls.
98430>>>    Function DriverIndex String sDriverID Returns Integer
98432>>>        String  sCurrentDriver
98432>>>        Integer iNumberOfDrivers iDriver iCount
98432>>>
98432>>>        Move 0 to iDriver
98433>>>
98433>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
98436>>>        for iCount from 1 to iNumberOfDrivers
98442>>>>
98442>>>
98442>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
98445>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
98447>>>                Move iCount to iDriver
98448>>>            End
98448>>>>
98448>>>        Loop
98449>>>>
98449>>>
98449>>>        // In case it was not found, it wasn't loaded so we do that now.
98449>>>        If (iDriver = 0) Begin
98451>>>            Move False to Err
98452>>>            Load_Driver sDriverID
98453>>>            If (Err = False) Begin
98455>>>                Move 1 to iDriver
98456>>>            End
98456>>>>
98456>>>        End
98456>>>>
98456>>>
98456>>>        Function_Return iDriver
98457>>>    End_Function
98458>>>
98458>>>    // Returns TRUE if table is opened exclusive, otherwise FALSE
98458>>>    // Note: If run from the Studio, CodeMast & CodeType _is_ open by the Studio,
98458>>>    //       so in that case we "cheat" and report those tables were opened OK.
98458>>>    Function OpenTableExclusive Handle hTable Returns Boolean
98460>>>        Integer iMode
98460>>>        Boolean bOpened
98460>>>        String sTableName
98460>>>
98460>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
98461>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
98464>>>        If (bOpened) Begin
98466>>>            If (IsDebuggerPresent()) Begin
98468>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
98471>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
98473>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
98474>>>                    Function_Return True
98475>>>                End
98475>>>>
98475>>>            End
98475>>>>
98475>>>            Get_Attribute DF_FILE_OPEN_MODE of hTable to iMode
98478>>>            If (iMode=DF_EXCLUSIVE) Begin
98480>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
98481>>>                Function_Return True
98482>>>            End
98482>>>>
98482>>>            Close hTable
98483>>>        End
98483>>>>
98483>>>        Else Begin
98484>>>            Open hTable
98486>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
98489>>>            If (bOpened and IsDebuggerPresent()) Begin
98491>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
98494>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
98496>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
98497>>>                    Function_Return True
98498>>>                End
98498>>>>
98498>>>            End
98498>>>>
98498>>>
98498>>>        End
98498>>>>
98498>>>        
98498>>>        Close hTable
98499>>>        Open hTable Mode DF_EXCLUSIVE
98501>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
98504>>>
98504>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
98505>>>        Function_Return bOpened
98506>>>    End_Function
98507>>>
98507>>>    Function AutoConnectionIDLogin Returns Boolean
98509>>>        String sConnectionID sConnectionString sDriverID
98509>>>        Boolean bExists bOK bSQLDriver
98509>>>        Handle hoCLI hoDriver
98509>>>        Integer iRetval
98509>>>        tSQLConnection SQLConnection
98509>>>        tSQLConnection SQLConnection
98509>>>
98509>>>        Get psDriverID to sDriverID
98510>>>        Get IsSQLDriver sDriverID to bSQLDriver
98511>>>        If (bSQLDriver = False) Begin
98513>>>            Function_Return True
98514>>>        End
98514>>>>
98514>>>
98514>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
98515>>>        Move SQLConnection.sDriverID                  to sDriverID
98516>>>        Move SQLConnection.sConnectionString          to sConnectionString
98517>>>        Get IsDAWSQLDriver sDriverID to bOK
98518>>>        If (bOK = True) Begin
98520>>>//            Get SQLLogin of ghoSQLConnectionHandler SQLConnection to bOK
98520>>>        End
98520>>>>
98520>>>        If (bOK = False) Begin
98522>>>            Get _MertechSQLManagerHandle to hoCLI
98523>>>            Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
98524>>>            Set psDriverID of hoDriver to SQLConnection.sDriverID
98525>>>            If (SQLConnection.sDriverID <> DATAFLEX_ID) Begin
98527>>>                Get DbLogin  of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
98528>>>                Send Destroy of hoDriver
98529>>>            End
98529>>>>
98529>>>            Function_Return False
98530>>>        End
98530>>>>
98530>>>
98530>>>        Move SQLConnection.sConnectionID to sConnectionID
98531>>>
98531>>>        Get IsConnectionID sConnectionID sDriverID to bExists
98532>>>        If (bExists = False) Begin
98534>>>            // We always start by deleting the current connection - if any - because the
98534>>>            // login details my have changed.
98534>>>            Get phoCLIHandler to hoCLI
98535>>>            Set psDriverID    of hoCLI to sDriverID
98536>>>            Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
98537>>>            Get UtilCreateConnectionID sConnectionID to bOk
98538>>>            If (bOk = False) Begin
98540>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be changed.")
98541>>>>
98541>>>                Function_Return False
98542>>>            End
98542>>>>
98542>>>            Move bOK to bExists
98543>>>        End
98543>>>>
98543>>>
98543>>>        Function_Return (bExists = True)
98544>>>    End_Function
98545>>>
98545>>>    // Scans to see if all tables can be opened exclusivly. I.e. that nobody else is running the application.
98545>>>    // Returns: False if nobody else is running
98545>>>    //          True if at least one table is open by another process (e.g. another user is running the application)
98545>>>    // N.B! Only works for Embedded DataFlex Tables! It will _not_ work for Sql tables because; these
98545>>>    //      tables are not locked as DataFlex tables are.
98545>>>    Function IsDatabaseInUse Returns Boolean
98547>>>        Handle  hTable
98547>>>        String  sRootName
98547>>>        Boolean bOpen bErr bAlias bOK bIsSQLTable bFlexErrs
98547>>>        Integer iCount iTables
98547>>>        
98547>>>        Move 0 to iTables
98548>>>        Set Action_Text of ghoStatusPanel to "Database in use check..."
98549>>>        Get AutoConnectionIDLogin to bOK
98550>>>        Get UtilFilelistNoOfTables to iTables
98551>>>        Set piPosition   of ghoProgressBar to 0
98552>>>        Set piAdvanceBy  of ghoProgressBar to 1      
98553>>>        Set piMaximum    of ghoProgressBar to iTables
98554>>>        Move 0 to hTable
98555>>>        Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
98558>>>        Move False to bErr
98559>>>        Send Ignore_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
98560>>>
98560>>>        Repeat
98560>>>>
98560>>>            Set piPosition of ghoProgressBar to iCount
98561>>>            Increment iCount
98562>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
98565>>>            Move (Uppercase(sRootName) = "FLEXERRS")  to bFlexErrs
98566>>>
98566>>>            // This test is only applicable for DataFlex embedded tables; so skip test if driver based table.
98566>>>            Get UtilTableIsSQLByRootName sRootName to bIsSQLTable
98567>>>            Move False to bOpen
98568>>>
98568>>>            // Don't bother about FlexErrs (Normally table 50)
98568>>>            If (bIsSQLTable = False and hTable <> 0 and bFlexErrs = False) Begin
98570>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
98571>>>                Open hTable
98573>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
98576>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
98577>>>                If (bOpen = True) Begin
98579>>>                    // We cannot open an Alias file exclusive as it will generate an error (4177 - "File in use")
98579>>>                    Get UtilTableIsAlias hTable to bAlias
98580>>>                    If (bAlias = False) Begin
98582>>>                        Close hTable
98583>>>                        Get OpenTableExclusive hTable to bOpen
98584>>>                        If (bOpen = False) Begin
98586>>>                            Move True to bErr
98587>>>                        End
98587>>>>
98587>>>                    End
98587>>>>
98587>>>                End
98587>>>>
98587>>>                Close hTable
98588>>>            End
98588>>>>
98588>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
98591>>>            If (bErr = True ) ;                Break
98594>>>        Until (not(hTable))
98596>>>
98596>>>        Set Action_Text of ghoStatusPanel to ""
98597>>>        Send Trap_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
98598>>>        Move False to Err
98599>>>
98599>>>        Function_Return bErr
98600>>>    End_Function
98601>>>
98601>>>    // Checks if the passed connection id exists in the CLI interface.
98601>>>    // This might be needed by API-methods when a connection id is to be used and
98601>>>    // the connection id hasn't been established with the driver's CLI interface.
98601>>>    // NOTE: Only applicable for DAW drivers.
98601>>>    Function IsConnectionID String sConnectionID String sDriverID Returns Boolean
98603>>>        String sID sConnString
98603>>>        Integer iDriver iNumConn iCount
98603>>>        Handle hoCLI
98603>>>        Boolean bOK
98603>>>
98603>>>        Get IsDAWSQLDriver sDriverID to bOK
98604>>>        If (bOK = False) Begin
98606>>>            Error DFERR_PROGRAM "Connection ID's can only be used with DAW drivers (not Mertech)."
98607>>>>
98607>>>            Function_Return False
98608>>>        End
98608>>>>
98608>>>
98608>>>        Move False to bOK
98609>>>        Get phoCLIHandler to hoCLI
98610>>>        If (hoCLI <> 0) Begin
98612>>>            Set psDriverID of hoCLI to sDriverID
98613>>>            Get DriverIndex of hoCLI sDriverID to iDriver
98614>>>
98614>>>            // If driver not loaded; load it.
98614>>>            If (iDriver = 0) Begin
98616>>>                Load_Driver sDriverID
98617>>>                Get DriverIndex sDriverID to iDriver
98618>>>            End
98618>>>>
98618>>>            If (iDriver <> 0) Begin
98620>>>                Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
98623>>>                Decrement iNumConn
98624>>>                for iCount from 0 to iNumConn
98630>>>>
98630>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iCount to sConnString
98633>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iCount to sID
98636>>>                    If (sID = sConnectionID) Begin
98638>>>                        Move True to bOK
98639>>>                    End
98639>>>>
98639>>>                Loop
98640>>>>
98640>>>            End
98640>>>>
98640>>>        End
98640>>>>
98640>>>
98640>>>        Function_Return bOK
98641>>>    End_Function
98642>>>
98642>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
98644>>>        Boolean bOK
98644>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
98645>>>        Function_Return bOK
98646>>>    End_Function
98647>>>
98647>>>    Function IsMertechDriver String sDriverID Returns Boolean
98649>>>        Boolean bOK
98649>>>        Move False to bOK
98650>>>        Move (sDriverID = SQLFLEX or sDriverID = ORAFLEX or sDriverID = MDSPgSQL or sDriverID = MDSMySQL) to bOK
98651>>>        Function_Return bOK
98652>>>    End_Function
98653>>>
98653>>>    Function IsMSSQLDriver Returns Boolean
98655>>>        Integer iDriverIndex
98655>>>
98655>>>        Get DriverIndex MSSQLDRV_ID to iDriverIndex
98656>>>
98656>>>        Function_Return (iDriverIndex <> 0)
98657>>>    End_Function
98658>>>
98658>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
98658>>>    // attempt to load the driver.
98658>>>    // Returns true if the passed driver is SQL based.
98658>>>    Function IsSQLDriver String sDriverID Returns Boolean
98660>>>        Boolean bOK
98660>>>
98660>>>        Get IsDAWSQLDriver sDriverID to bOK
98661>>>
98661>>>        If (bOK = False) Begin
98663>>>            Get IsMertechDriver sDriverID to bOK
98664>>>        End
98664>>>>
98664>>>
98664>>>        Function_Return bOK
98665>>>    End_Function
98666>>>
98666>>>    // *** Error Handler ***
98666>>>    //
98666>>>    // Note: If the cDbUpdateHandler & cDbUpdateVersion classes are used this error handler is _not_
98666>>>    //       used. Instead the Error_Report in the cDbUpdateHandler i used.
98666>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
98668>>>        Integer iSize iErrorMode
98668>>>        tSqlErrorArray aSqlErrorArray
98668>>>        tSqlErrorArray aSqlErrorArray
98668>>>
98668>>>        If (pbProcessingError(Self)) Begin
98670>>>            Procedure_Return
98671>>>        End
98671>>>>
98671>>>
98671>>>        Get Error_Report_Mode to iErrorMode
98672>>>        If (iErrorMode = DUF_ERROR_NO_REPORT) Begin
98674>>>            Procedure_Return
98675>>>        End
98675>>>>
98675>>>
98675>>>        Set pbProcessingError to True
98676>>>        Set pbSqlError to True
98677>>>        Get paSqlErrorArray      to aSqlErrorArray
98678>>>        Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iSize
98679>>>        Move sErrorText          to aSqlErrorArray.sSqlErrorArray[iSize]
98680>>>        Get psSQLStatementString to aSqlErrorArray.sSqlStatementArray[iSize]
98681>>>        Move iErrorNumber        to aSqlErrorArray.iSqlErrorArray[iSize]
98682>>>        Set paSqlErrorArray      to aSqlErrorArray
98683>>>        Set pbProcessingError to False
98684>>>    End_Procedure
98685>>>
98685>>>    // *** Miscellanous Helper Functions ***
98685>>>    //
98685>>>    // Helper function. Takes a DF_FILE_XXXX_NAME value as parameter and
98685>>>    // returns the table name only; stripped of any path or filename extension.
98685>>>    Function _TableNameOnly String sName Returns String
98687>>>        String sPath sExt
98687>>>
98687>>>        Get ParseFolderName sName to sPath
98688>>>        If (sPath <> "") Begin
98690>>>            Move (Replace(sPath, sName, "")) to sName
98691>>>        End
98691>>>>
98691>>>        Get ParseFileExtension sName to sExt
98692>>>        If (sExt <> "") Begin
98694>>>            Move (Replace(("." + sExt), sName, "")) to sName
98695>>>        End
98695>>>>
98695>>>
98695>>>        Function_Return sName
98696>>>    End_Function
98697>>>
98697>>>    // Removes any prefix to a table name.
98697>>>    // Example mssqldrv:mytable returns mytable
98697>>>    //         dbo.mytable returns mytable
98697>>>    Function _TableNoPrefix String sName Returns String
98699>>>        Integer iPos
98699>>>
98699>>>        Move (Pos(":", sName)) to iPos
98700>>>        If (iPos <> 0) Begin
98702>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
98703>>>        End
98703>>>>
98703>>>        Move (Pos(".", sName)) to iPos
98704>>>        If (iPos <> 0) Begin
98706>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
98707>>>        End
98707>>>>
98707>>>
98707>>>        Function_Return sName
98708>>>    End_Function
98709>>>
98709>>>    // Returns the first datapath found in the psDataPath property.
98709>>>    // The returned path always ends with a "\"
98709>>>    Function psDataPathFirstPart Returns String
98711>>>        String sDataPath
98711>>>        Integer iCount
98711>>>
98711>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
98712>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
98713>>>        If (iCount > 1) Begin
98715>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
98716>>>        End
98716>>>>
98716>>>        If (sDataPath <> "") Begin
98718>>>            Get vFolderFormat sDataPath to sDataPath
98719>>>        End
98719>>>>
98719>>>
98719>>>        Function_Return sDataPath
98720>>>    End_Function
98721>>>
98721>>>    Function psLogTextFileWithPath Returns String
98723>>>        String sFileName 
98723>>>        Handle hoLogFile
98723>>>        Get phoLogFile to hoLogFile
98724>>>        Get psLogTextFileWithPath of hoLogFile to sFileName
98725>>>        Function_Return sFileName
98726>>>    End_Function                     
98727>>>    
98727>>>    // *** Property Messages ***
98727>>>    //
98727>>>    // These "properties" are settings for the cSQLConnectionHandler class, but have been
98727>>>    // "duplicated" here so connection properties can be relayed to the ghoSQLConnectionHandler object
98727>>>    //
98727>>>
98727>>>    Function pSQLConnection Returns tSQLConnection
98729>>>        tSQLConnection SQLConnection
98729>>>        tSQLConnection SQLConnection
98729>>>        If (ghoSQLConnectionHandler = 0) Begin
98731>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
98731>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
98732>>>>
98732>>>            Function_Return
98733>>>        End
98733>>>>
98733>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
98734>>>        Function_Return SQLConnection
98735>>>    End_Function
98736>>>
98736>>>    // * Dummy function for the Studio's Code Explorer *
98736>>>    Function OTHER_CLASS_PROPERTIES Returns Boolean
98738>>>        Function_Return False
98739>>>    End_Function
98740>>>
98740>>>    Procedure Set psServer String sValue
98742>>>        If (ghoSQLConnectionHandler = 0) Begin
98744>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
98744>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
98745>>>>
98745>>>            Procedure_Return
98746>>>        End
98746>>>>
98746>>>        Set psServer of ghoSQLConnectionHandler to sValue
98747>>>    End_Procedure
98748>>>
98748>>>    Function psServer Returns String
98750>>>        String sValue
98750>>>        If (ghoSQLConnectionHandler = 0) Begin
98752>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
98753>>>>
98753>>>            Function_Return
98754>>>        End
98754>>>>
98754>>>        Get psServer of ghoSQLConnectionHandler to sValue
98755>>>        Function_Return sValue
98756>>>    End_Function
98757>>>
98757>>>    Procedure Set psDatabase String sValue
98759>>>        If (ghoSQLConnectionHandler = 0) Begin
98761>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
98762>>>>
98762>>>            Procedure_Return
98763>>>        End
98763>>>>
98763>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
98764>>>    End_Procedure
98765>>>
98765>>>    Function psDatabase Returns String
98767>>>        String sValue
98767>>>        If (ghoSQLConnectionHandler = 0) Begin
98769>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
98770>>>>
98770>>>            Function_Return
98771>>>        End
98771>>>>
98771>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
98772>>>        Function_Return sValue
98773>>>    End_Function
98774>>>
98774>>>    Procedure Set psUserID String sValue
98776>>>        If (ghoSQLConnectionHandler = 0) Begin
98778>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
98779>>>>
98779>>>            Function_Return
98780>>>        End
98780>>>>
98780>>>        Set psUserID of ghoSQLConnectionHandler to sValue
98781>>>    End_Procedure
98782>>>
98782>>>    Function psUserID Returns String
98784>>>        String sValue
98784>>>        If (ghoSQLConnectionHandler = 0) Begin
98786>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
98787>>>>
98787>>>            Function_Return
98788>>>        End
98788>>>>
98788>>>        Get psUserID of ghoSQLConnectionHandler to sValue
98789>>>        Function_Return sValue
98790>>>    End_Function
98791>>>
98791>>>    Procedure Set psPassword String sValue
98793>>>        If (ghoSQLConnectionHandler = 0) Begin
98795>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
98796>>>>
98796>>>            Procedure_Return
98797>>>        End
98797>>>>
98797>>>        Set psPassword of ghoSQLConnectionHandler to sValue
98798>>>    End_Procedure
98799>>>
98799>>>    Function psPassword Returns String
98801>>>        String sValue
98801>>>        If (ghoSQLConnectionHandler = 0) Begin
98803>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
98804>>>>
98804>>>            Function_Return
98805>>>        End
98805>>>>
98805>>>        Get psPassword of ghoSQLConnectionHandler to sValue
98806>>>        Function_Return sValue
98807>>>    End_Function
98808>>>
98808>>>    Procedure Set pbTrusted Boolean bValue
98810>>>        If (ghoSQLConnectionHandler = 0) Begin
98812>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
98813>>>>
98813>>>            Procedure_Return
98814>>>        End
98814>>>>
98814>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
98815>>>    End_Procedure
98816>>>
98816>>>    Function pbTrusted Returns Boolean
98818>>>        Boolean bValue
98818>>>        If (ghoSQLConnectionHandler = 0) Begin
98820>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
98821>>>>
98821>>>            Function_Return
98822>>>        End
98822>>>>
98822>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
98823>>>        Function_Return bValue
98824>>>    End_Function
98825>>>
98825>>>    Procedure Set pbSilentLogin Boolean bValue
98827>>>        If (ghoSQLConnectionHandler = 0) Begin
98829>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
98830>>>>
98830>>>            Procedure_Return
98831>>>        End
98831>>>>
98831>>>        Set pbSilentLogin of ghoSQLConnectionHandler to bValue
98832>>>    End_Procedure
98833>>>
98833>>>    Function pbSilentLogin Returns Boolean
98835>>>        Boolean bValue
98835>>>        If (ghoSQLConnectionHandler = 0) Begin
98837>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
98838>>>>
98838>>>            Function_Return
98839>>>        End
98839>>>>
98839>>>        Get pbSilentLogin of ghoSQLConnectionHandler to bValue
98840>>>        Function_Return bValue
98841>>>    End_Function
98842>>>
98842>>>    Procedure Set psConnectionID String sValue
98844>>>        If (ghoSQLConnectionHandler = 0) Begin
98846>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
98847>>>>
98847>>>            Procedure_Return
98848>>>        End
98848>>>>
98848>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
98849>>>    End_Procedure
98850>>>
98850>>>    Function psConnectionID Returns String
98852>>>        String sValue
98852>>>        If (ghoSQLConnectionHandler = 0) Begin
98854>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
98855>>>>
98855>>>            Function_Return
98856>>>        End
98856>>>>
98856>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
98857>>>        Function_Return sValue
98858>>>    End_Function
98859>>>
98859>>>    Procedure Set psConnectionString String sValue
98861>>>        If (ghoSQLConnectionHandler = 0) Begin
98863>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
98864>>>>
98864>>>            Procedure_Return
98865>>>        End
98865>>>>
98865>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
98866>>>    End_Procedure
98867>>>
98867>>>    Function psConnectionString Returns String
98869>>>        String sValue
98869>>>        If (ghoSQLConnectionHandler = 0) Begin
98871>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
98872>>>>
98872>>>            Function_Return
98873>>>        End
98873>>>>
98873>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
98874>>>        Function_Return sValue
98875>>>    End_Function
98876>>>
98876>>>    // The normal connection string looks something like this;
98876>>>    // SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
98876>>>    // ...and the full connection string looks like this;
98876>>>    // DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
98876>>>    Function psFullConnectionString Returns String
98878>>>        String sConnectionID sConnectionString
98878>>>        If (ghoSQLConnectionHandler = 0) Begin
98880>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
98881>>>>
98881>>>            Function_Return
98882>>>        End
98882>>>>
98882>>>        Get psConnectionID     of ghoSQLConnectionHandler to sConnectionID
98883>>>        Move (Trim(sConnectionID)) to sConnectionID
98884>>>        Get psConnectionString of ghoSQLConnectionHandler to sConnectionString
98885>>>        Function_Return (CS_SQLConnectionIDText * sConnectionID + "," * String(sConnectionString))
98886>>>    End_Function
98887>>>
98887>>>    Function piConnectionOptions Returns Integer
98889>>>        Integer iValue
98889>>>        If (ghoSQLConnectionHandler = 0) Begin
98891>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
98892>>>>
98892>>>            Function_Return
98893>>>        End
98893>>>>
98893>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
98894>>>        Function_Return iValue
98895>>>    End_Function
98896>>>
98896>>>    Procedure Set psSchema String sValue
98898>>>        tSQLConnection SQLConnection
98898>>>        tSQLConnection SQLConnection
98898>>>        If (ghoSQLConnectionHandler = 0) Begin
98900>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
98901>>>>
98901>>>            Procedure_Return
98902>>>        End
98902>>>>
98902>>>        Set psSchema of ghoSQLConnectionHandler to sValue
98903>>>    End_Procedure
98904>>>
98904>>>    Function psSchema Returns String
98906>>>        String sRetval
98906>>>        If (ghoSQLConnectionHandler = 0) Begin
98908>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
98909>>>>
98909>>>            Function_Return
98910>>>        End
98910>>>>
98910>>>        Get psSchema of ghoSQLConnectionHandler to sRetval
98911>>>        Function_Return sRetval
98912>>>    End_Function
98913>>>
98913>>>    Procedure Set psBaseTableSpace String sValue
98915>>>        If (ghoSQLConnectionHandler = 0) Begin
98917>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
98918>>>>
98918>>>            Procedure_Return
98919>>>        End
98919>>>>
98919>>>        Set psBaseTableSpace of ghoSQLConnectionHandler to sValue
98920>>>    End_Procedure
98921>>>
98921>>>    Function psBaseTableSpace Returns String
98923>>>        String sRetval
98923>>>        If (ghoSQLConnectionHandler = 0) Begin
98925>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
98926>>>>
98926>>>            Function_Return
98927>>>        End
98927>>>>
98927>>>        Get psBaseTableSpace of ghoSQLConnectionHandler to sRetval
98928>>>        Function_Return sRetval
98929>>>    End_Function
98930>>>
98930>>>    Procedure Set psLongTableSpace String sValue
98932>>>        If (ghoSQLConnectionHandler = 0) Begin
98934>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
98935>>>>
98935>>>            Procedure_Return
98936>>>        End
98936>>>>
98936>>>        Set psLongTableSpace of ghoSQLConnectionHandler to sValue
98937>>>    End_Procedure
98938>>>
98938>>>    Function psLongTableSpace Returns String
98940>>>        String sRetval
98940>>>        If (ghoSQLConnectionHandler = 0) Begin
98942>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
98943>>>>
98943>>>            Function_Return
98944>>>        End
98944>>>>
98944>>>        Get psLongTableSpace of ghoSQLConnectionHandler to sRetval
98945>>>        Function_Return sRetval
98946>>>    End_Function
98947>>>
98947>>>    Procedure Set psIndexTableSpace String sValue
98949>>>        If (ghoSQLConnectionHandler = 0) Begin
98951>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
98952>>>>
98952>>>            Procedure_Return
98953>>>        End
98953>>>>
98953>>>        Set psIndexTableSpace of ghoSQLConnectionHandler to sValue
98954>>>    End_Procedure
98955>>>
98955>>>    Function psIndexTableSpace Returns String
98957>>>        String sRetval
98957>>>        If (ghoSQLConnectionHandler = 0) Begin
98959>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
98960>>>>
98960>>>            Function_Return
98961>>>        End
98961>>>>
98961>>>        Get psIndexTableSpace of ghoSQLConnectionHandler to sRetval
98962>>>        Function_Return sRetval
98963>>>    End_Function
98964>>>
98964>>>    Procedure Set pbUseConnectionID Boolean bState
98966>>>        If (ghoSQLConnectionHandler = 0) Begin
98968>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
98969>>>>
98969>>>            Procedure_Return
98970>>>        End
98970>>>>
98970>>>        Set pbUseConnectionID of ghoSQLConnectionHandler to bState
98971>>>    End_Procedure
98972>>>
98972>>>    Function pbUseConnectionID Returns Boolean
98974>>>        Boolean bState
98974>>>        If (ghoSQLConnectionHandler = 0) Begin
98976>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
98977>>>>
98977>>>            Function_Return
98978>>>        End
98978>>>>
98978>>>        Get pbUseConnectionID of ghoSQLConnectionHandler to bState
98979>>>        Function_Return bState
98980>>>    End_Function
98981>>>
98981>>>    Procedure Set pbToANSI Boolean bState
98983>>>        If (ghoSQLConnectionHandler = 0) Begin
98985>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
98986>>>>
98986>>>            Procedure_Return
98987>>>        End
98987>>>>
98987>>>        Set pbToANSI of ghoSQLConnectionHandler to bState
98988>>>    End_Procedure
98989>>>
98989>>>    Function pbToANSI Returns Boolean
98991>>>        Boolean bState
98991>>>        If (ghoSQLConnectionHandler = 0) Begin
98993>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
98994>>>>
98994>>>            Function_Return
98995>>>        End
98995>>>>
98995>>>        Get pbToANSI of ghoSQLConnectionHandler to bState
98996>>>        Function_Return bState
98997>>>    End_Function
98998>>>
98998>>>    Procedure Set pbRecnum Boolean bState
99000>>>        If (ghoSQLConnectionHandler = 0) Begin
99002>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
99003>>>>
99003>>>            Procedure_Return
99004>>>        End
99004>>>>
99004>>>        Set pbRecnum of ghoSQLConnectionHandler to bState
99005>>>    End_Procedure
99006>>>
99006>>>    Function pbRecnum Returns Boolean
99008>>>        Boolean bState
99008>>>        If (ghoSQLConnectionHandler = 0) Begin
99010>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
99011>>>>
99011>>>            Function_Return
99012>>>        End
99012>>>>
99012>>>        Get pbRecnum of ghoSQLConnectionHandler to bState
99013>>>        Function_Return bState
99014>>>    End_Function
99015>>>
99015>>>    Procedure Set pbCopyData Boolean bState
99017>>>        If (ghoSQLConnectionHandler = 0) Begin
99019>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
99020>>>>
99020>>>            Procedure_Return
99021>>>        End
99021>>>>
99021>>>        Set pbCopyData of ghoSQLConnectionHandler to bState
99022>>>    End_Procedure
99023>>>
99023>>>    Function pbCopyData Returns Boolean
99025>>>        Boolean bState
99025>>>        If (ghoSQLConnectionHandler = 0) Begin
99027>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
99028>>>>
99028>>>            Function_Return
99029>>>        End
99029>>>>
99029>>>        Get pbCopyData of ghoSQLConnectionHandler to bState
99030>>>        Function_Return bState
99031>>>    End_Function
99032>>>
99032>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
99034>>>        If (ghoSQLConnectionHandler = 0) Begin
99036>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
99037>>>>
99037>>>            Procedure_Return
99038>>>        End
99038>>>>
99038>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
99039>>>    End_Procedure
99040>>>
99040>>>    Function pbApiTableUpdateAuto Returns Boolean
99042>>>        Boolean bState
99042>>>        If (ghoSQLConnectionHandler = 0) Begin
99044>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
99045>>>>
99045>>>            Function_Return
99046>>>        End
99046>>>>
99046>>>        Get pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
99047>>>        Function_Return bState
99048>>>    End_Function
99049>>>
99049>>>    Procedure Set pbCompareDate_DateTime Boolean bState
99051>>>        If (ghoSQLConnectionHandler = 0) Begin
99053>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
99054>>>>
99054>>>            Procedure_Return
99055>>>        End
99055>>>>
99055>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
99056>>>    End_Procedure
99057>>>
99057>>>    Function pbCompareDate_DateTime Returns Boolean
99059>>>        Boolean bState
99059>>>        If (ghoSQLConnectionHandler = 0) Begin
99061>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
99062>>>>
99062>>>            Function_Return
99063>>>        End
99063>>>>
99063>>>        Get pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
99064>>>        Function_Return bState
99065>>>    End_Function
99066>>>
99066>>>    Procedure Set pbCompareIndexAscending Boolean bState
99068>>>        If (ghoSQLConnectionHandler = 0) Begin
99070>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
99071>>>>
99071>>>            Procedure_Return
99072>>>        End
99072>>>>
99072>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
99073>>>    End_Procedure
99074>>>
99074>>>    Function pbCompareIndexAscending Returns Boolean
99076>>>        Boolean bState
99076>>>        If (ghoSQLConnectionHandler = 0) Begin
99078>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
99079>>>>
99079>>>            Function_Return
99080>>>        End
99080>>>>
99080>>>        Get pbCompareIndexAscending of ghoSQLConnectionHandler to bState
99081>>>        Function_Return bState
99082>>>    End_Function
99083>>>
99083>>>    Procedure Set pbCompareIndexUppercase Boolean bState
99085>>>        If (ghoSQLConnectionHandler = 0) Begin
99087>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
99088>>>>
99088>>>            Procedure_Return
99089>>>        End
99089>>>>
99089>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
99090>>>    End_Procedure
99091>>>
99091>>>    Function pbCompareIndexUppercase Returns Boolean
99093>>>        Boolean bState
99093>>>        If (ghoSQLConnectionHandler = 0) Begin
99095>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
99096>>>>
99096>>>            Function_Return
99097>>>        End
99097>>>>
99097>>>        Get pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
99098>>>        Function_Return bState
99099>>>    End_Function
99100>>>
99100>>>    Procedure Set psDriverDefaultValueASCII String sValue
99102>>>        If (ghoSQLConnectionHandler = 0) Begin
99104>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
99105>>>>
99105>>>            Procedure_Return
99106>>>        End
99106>>>>
99106>>>        Set psDriverDefaultValueASCII of ghoSQLConnectionHandler to sValue
99107>>>    End_Procedure
99108>>>
99108>>>    Function psDriverDefaultValueASCII Returns String
99110>>>        String sRetval
99110>>>        If (ghoSQLConnectionHandler = 0) Begin
99112>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
99113>>>>
99113>>>            Function_Return
99114>>>        End
99114>>>>
99114>>>        Get psDriverDefaultValueASCII of ghoSQLConnectionHandler to sRetval
99115>>>        Function_Return sRetval
99116>>>    End_Function
99117>>>
99117>>>    Procedure Set psDriverDefaultValueBinary String sValue
99119>>>        If (ghoSQLConnectionHandler = 0) Begin
99121>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
99122>>>>
99122>>>            Procedure_Return
99123>>>        End
99123>>>>
99123>>>        Set psDriverDefaultValueBinary of ghoSQLConnectionHandler to sValue
99124>>>    End_Procedure
99125>>>
99125>>>    Function psDriverDefaultValueBinary Returns String
99127>>>        String sRetval
99127>>>        If (ghoSQLConnectionHandler = 0) Begin
99129>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
99130>>>>
99130>>>            Function_Return
99131>>>        End
99131>>>>
99131>>>        Get psDriverDefaultValueBinary of ghoSQLConnectionHandler to sRetval
99132>>>        Function_Return sRetval
99133>>>    End_Function
99134>>>
99134>>>    Procedure Set psDriverDefaultValueDate String sValue
99136>>>        If (ghoSQLConnectionHandler = 0) Begin
99138>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
99139>>>>
99139>>>            Procedure_Return
99140>>>        End
99140>>>>
99140>>>        Set psDriverDefaultValueDate of ghoSQLConnectionHandler to sValue
99141>>>    End_Procedure
99142>>>
99142>>>    Function psDriverDefaultValueDate Returns String
99144>>>        String sRetval
99144>>>        If (ghoSQLConnectionHandler = 0) Begin
99146>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
99147>>>>
99147>>>            Function_Return
99148>>>        End
99148>>>>
99148>>>        Get psDriverDefaultValueDate of ghoSQLConnectionHandler to sRetval
99149>>>        Function_Return sRetval
99150>>>    End_Function
99151>>>
99151>>>    Procedure Set psDriverDefaultValueDateTime String sValue
99153>>>        If (ghoSQLConnectionHandler = 0) Begin
99155>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
99156>>>>
99156>>>            Procedure_Return
99157>>>        End
99157>>>>
99157>>>        Set psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sValue
99158>>>    End_Procedure
99159>>>
99159>>>    Function psDriverDefaultValueDateTime Returns String
99161>>>        String sRetval
99161>>>        If (ghoSQLConnectionHandler = 0) Begin
99163>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
99164>>>>
99164>>>            Function_Return
99165>>>        End
99165>>>>
99165>>>        Get psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sRetval
99166>>>        Function_Return sRetval
99167>>>    End_Function
99168>>>
99168>>>    Procedure Set psDriverDefaultValueNumeric String sValue
99170>>>        If (ghoSQLConnectionHandler = 0) Begin
99172>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
99173>>>>
99173>>>            Procedure_Return
99174>>>        End
99174>>>>
99174>>>        Set psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sValue
99175>>>    End_Procedure
99176>>>
99176>>>    Function psDriverDefaultValueNumeric Returns String
99178>>>        String sRetval
99178>>>        If (ghoSQLConnectionHandler = 0) Begin
99180>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
99181>>>>
99181>>>            Function_Return
99182>>>        End
99182>>>>
99182>>>        Get psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sRetval
99183>>>        Function_Return sRetval
99184>>>    End_Function
99185>>>
99185>>>    Procedure Set psDriverDefaultValueText String sValue
99187>>>        If (ghoSQLConnectionHandler = 0) Begin
99189>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
99190>>>>
99190>>>            Procedure_Return
99191>>>        End
99191>>>>
99191>>>        Set psDriverDefaultValueText of ghoSQLConnectionHandler to sValue
99192>>>    End_Procedure
99193>>>
99193>>>    Function psDriverDefaultValueText Returns String
99195>>>        String sRetval
99195>>>        If (ghoSQLConnectionHandler = 0) Begin
99197>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
99198>>>>
99198>>>            Function_Return
99199>>>        End
99199>>>>
99199>>>        Get psDriverDefaultValueText of ghoSQLConnectionHandler to sRetval
99200>>>        Function_Return sRetval
99201>>>    End_Function
99202>>>
99202>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
99204>>>        If (ghoSQLConnectionHandler = 0) Begin
99206>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
99207>>>>
99207>>>            Procedure_Return
99208>>>        End
99208>>>>
99208>>>        Set pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
99209>>>    End_Procedure
99210>>>
99210>>>    Function pbDriverDefaultNullableASCII Returns Boolean
99212>>>        Boolean bState
99212>>>        If (ghoSQLConnectionHandler = 0) Begin
99214>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
99215>>>>
99215>>>            Function_Return
99216>>>        End
99216>>>>
99216>>>        Get pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
99217>>>        Function_Return bState
99218>>>    End_Function
99219>>>
99219>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
99221>>>        If (ghoSQLConnectionHandler = 0) Begin
99223>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
99224>>>>
99224>>>            Procedure_Return
99225>>>        End
99225>>>>
99225>>>        Set pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
99226>>>    End_Procedure
99227>>>
99227>>>    Function pbDriverDefaultNullableBinary Returns Boolean
99229>>>        Boolean bState
99229>>>        If (ghoSQLConnectionHandler = 0) Begin
99231>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
99232>>>>
99232>>>            Function_Return
99233>>>        End
99233>>>>
99233>>>        Get pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
99234>>>        Function_Return bState
99235>>>    End_Function
99236>>>
99236>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
99238>>>        If (ghoSQLConnectionHandler = 0) Begin
99240>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
99241>>>>
99241>>>            Procedure_Return
99242>>>        End
99242>>>>
99242>>>        Set pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
99243>>>    End_Procedure
99244>>>
99244>>>    Function pbDriverDefaultNullableDate Returns Boolean
99246>>>        Boolean bState
99246>>>        If (ghoSQLConnectionHandler = 0) Begin
99248>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
99249>>>>
99249>>>            Function_Return
99250>>>        End
99250>>>>
99250>>>        Get pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
99251>>>        Function_Return bState
99252>>>    End_Function
99253>>>
99253>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
99255>>>        If (ghoSQLConnectionHandler = 0) Begin
99257>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
99258>>>>
99258>>>            Procedure_Return
99259>>>        End
99259>>>>
99259>>>        Set pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
99260>>>    End_Procedure
99261>>>
99261>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
99263>>>        Boolean bState
99263>>>        If (ghoSQLConnectionHandler = 0) Begin
99265>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
99266>>>>
99266>>>            Function_Return
99267>>>        End
99267>>>>
99267>>>        Get pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
99268>>>        Function_Return bState
99269>>>    End_Function
99270>>>
99270>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
99272>>>        If (ghoSQLConnectionHandler = 0) Begin
99274>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
99275>>>>
99275>>>            Procedure_Return
99276>>>        End
99276>>>>
99276>>>        Set pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
99277>>>    End_Procedure
99278>>>
99278>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
99280>>>        Boolean bState
99280>>>        If (ghoSQLConnectionHandler = 0) Begin
99282>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
99283>>>>
99283>>>            Function_Return
99284>>>        End
99284>>>>
99284>>>        Get pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
99285>>>        Function_Return bState
99286>>>    End_Function
99287>>>
99287>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
99289>>>        If (ghoSQLConnectionHandler = 0) Begin
99291>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
99292>>>>
99292>>>            Procedure_Return
99293>>>        End
99293>>>>
99293>>>        Set pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
99294>>>    End_Procedure
99295>>>
99295>>>    Function pbDriverDefaultNullableText Returns Boolean
99297>>>        Boolean bState
99297>>>        If (ghoSQLConnectionHandler = 0) Begin
99299>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
99300>>>>
99300>>>            Function_Return
99301>>>        End
99301>>>>
99301>>>        Get pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
99302>>>        Function_Return bState
99303>>>    End_Function
99304>>>
99304>>>    // Note: If the psDriverID + other connection properties are to be changed,
99304>>>    //       the psDriverID *must* be the first property that gets changed!
99304>>>    //       Otherwise errors might be raised by the driver when e.g. the format
99304>>>    //       for a connection string has the wrong format for that driver.
99304>>>    Procedure Set psDriverID String sValue
99306>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
99307>>>        Delegate Set psDriverID to sValue
99309>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
99310>>>        Set psDriverID of ghoSQLConnectionHandler to sValue
99311>>>    End_Procedure
99312>>>
99312>>>    Function psDriverID Returns String
99314>>>        String sDriverID
99314>>>
99314>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
99315>>>        // This should get it from the parent object (when using the cDbUpdateHandler class)
99315>>>        Delegate Get psDriverID to sDriverID
99317>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
99318>>>        Move False to Err
99319>>>
99319>>>        // ...and in case it didn't use property of this class. Then the library is
99319>>>        // probably used as "utilites" from a special made program and
99319>>>        // the ghoSQLConnectionHandler must have been setup
99319>>>        If (sDriverID = "") Begin
99321>>>            Get psDriverID of ghoSQLConnectionHandler to sDriverID
99322>>>        End
99322>>>>
99322>>>        Function_Return sDriverID
99323>>>    End_Function
99324>>>
99324>>>    Procedure Set piDbType Integer iValue
99326>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
99327>>>        Delegate Set piDbType to iValue
99329>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
99330>>>        Set piDbType of ghoSQLConnectionHandler to iValue
99331>>>    End_Procedure
99332>>>
99332>>>    Function piDbType Returns String
99334>>>        Integer iRetval
99334>>>
99334>>>//        Move False to Err
99334>>>//        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
99334>>>        // This should get it from the parent object (when using the cDbUpdateHandler class)
99334>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
99334>>>//        Delegate Get piDbType to iRetval
99334>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
99334>>>//        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
99334>>>
99334>>>        // ...and in case it didn't use property of this class. Then the library is
99334>>>        // probably used as "utilites" from a special made program and
99334>>>        // the ghoSQLConnectionHandler must have been setup
99334>>>//        If (Err = True) Begin
99334>>>            Get piDbType of ghoSQLConnectionHandler to iRetval
99335>>>//        End
99335>>>
99335>>>//        Move False to Err
99335>>>        Function_Return iRetval
99336>>>    End_Function
99337>>>
99337>>>    Function phoLogFile Returns Handle
99339>>>        Handle hoLogFile
99339>>>
99339>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
99340>>>        Delegate Get phoLogFile to hoLogFile
99342>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
99343>>>
99343>>>        Function_Return hoLogFile
99344>>>    End_Function
99345>>>
99345>>>    Function pnCurrentVersionUpdate Returns Number
99347>>>        Number nCurrentVersionUpdate
99347>>>
99347>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
99348>>>        Delegate Get pnCurrentVersionUpdate to nCurrentVersionUpdate
99350>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
99351>>>
99351>>>        Function_Return nCurrentVersionUpdate
99352>>>    End_Function
99353>>>
99353>>>    Procedure LogError String sText Boolean bError
99355>>>        Handle hoLogFile
99355>>>        Number nCurrentVersionUpdate
99355>>>
99355>>>        Get phoLogFile to hoLogFile
99356>>>        If (hoLogFile = 0) Begin
99358>>>            Procedure_Return
99359>>>        End
99359>>>>
99359>>>        Get pnCurrentVersionUpdate to nCurrentVersionUpdate
99360>>>
99360>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
99361>>>        Send LogError of hoLogFile nCurrentVersionUpdate 0 sText 0 bError
99362>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
99363>>>    End_Procedure
99364>>>
99364>>>    Function pbContinueOnError Returns Boolean
99366>>>        Boolean bContinueOnError
99366>>>        If (ghoDbUpdateHandler > 0) Begin
99368>>>            Get pbContinueOnError of ghoDbUpdateHandler to bContinueOnError
99369>>>        End
99369>>>>
99369>>>        Function_Return bContinueOnError
99370>>>    End_Function
99371>>>
99371>>>    Function psCollation Returns String
99373>>>        String sCollation
99373>>>        If (ghoDbUpdateHandler > 0) Begin
99375>>>            Get psCollation of ghoDbUpdateHandler to sCollation
99376>>>        End
99376>>>>
99376>>>        Function_Return sCollation
99377>>>    End_Function
99378>>>
99378>>>
99378>>>    Function StrToFieldNumber Integer iFile String sField Returns Integer
99380>>>        Integer iMax iPos
99380>>>        String sName
99380>>>
99380>>>        Move (Lowercase(sField)) to sField
99381>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iMax
99384>>>        for iPos from 0 to iMax
99390>>>>
99390>>>            Get_Attribute DF_FIELD_NAME of iFile iPos to sName
99393>>>            Move (Lowercase(sName)) to sName
99394>>>            If (sName = sField) Begin
99396>>>                Function_Return iPos
99397>>>            End
99397>>>>
99397>>>        Loop
99398>>>>
99398>>>        Function_Return -1
99399>>>    End_Function
99400>>>
99400>>>
99400>>>    // * Dummy function for the Studio's Code Explorer *
99400>>>    Function PRIVATE_SUB_FUNCTIONS Returns Boolean
99402>>>        Function_Return False
99403>>>    End_Function
99404>>>
99404>>>    // When dropping columns on some SQL back-ends they doesn't reclaim the space taken up by the columns dropped.
99404>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
99404>>>    // the new rows added after the alter statement. to get around this you need to create a clustered
99404>>>    // index on the table _or_ rebuild the clustered Index if it already has one. Rebuilding the index
99404>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
99404>>>    //   ALTER TABLE MyTable
99404>>>    //       REBUILD
99404>>>    Function _SqlUtilRemoveTableColumnMSSQL String sTableName String sColumnName Returns Boolean
99406>>>        Boolean bOK
99406>>>
99406>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
99408>>>            Function_Return False
99409>>>        End
99409>>>>
99409>>>
99409>>>        SQLIncludeScriptFile ..\Scripts\DropConstraintAndColumnNameMSSQL.sql as DropConstraintAndColumnNameMSSQL.sql
99409>>>        Get _SqlUtilRemoveTableColumnByScript "DropConstraintAndColumnNameMSSQL.sql" sTableName sColumnName to bOK
99410>>>
99410>>>        Function_Return (bOK = True)
99411>>>    End_Function
99412>>>
99412>>>
99412>>>    // *** Helper functions with compiled sql script code ***
99412>>>    //
99412>>>    // When dropping columns SQL Sever does not reclaim the space taken up by the columns dropped.
99412>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
99412>>>    // the new rows added after the alter statement. To get around this you need to create a clustered
99412>>>    // index on the table or rebuild the clustered Index if it already has one. Rebuilding the index
99412>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
99412>>>    //   ALTER TABLE MyTable
99412>>>    //       REBUILD
99412>>>    Function _SqlUtilRemoveTableColumnByScript String sMemScriptFile String sTableName String sColumnName Returns Boolean
99414>>>        tSQLScriptArray SQLScriptArray
99414>>>        tSQLScriptArray SQLScriptArray
99414>>>        String sDriverID
99414>>>        Boolean bOK
99414>>>        Integer iSize iCount
99414>>>
99414>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
99416>>>            Function_Return False
99417>>>        End
99417>>>>
99417>>>
99417>>>        Get psDriverID to sDriverID
99418>>>        Get SqlUtilReadResource sMemScriptFile to SQLScriptArray
99419>>>        If (SQLScriptArray.bError = True) Begin
99421>>>            Function_Return False
99422>>>        End
99422>>>>
99422>>>
99422>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
99423>>>        Decrement iSize
99424>>>
99424>>>        for iCount from 0 to iSize
99430>>>>
99430>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "TABLE_NAME_XXX") Begin
99432>>>                Move (Replaces("TABLE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sTableName))) to SQLScriptArray.sSQLScriptArray[iCount]
99433>>>            End
99433>>>>
99433>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLUMN_NAME_XXX") Begin
99435>>>                Move (Replaces("COLUMN_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sColumnName))) to SQLScriptArray.sSQLScriptArray[iCount]
99436>>>            End
99436>>>>
99436>>>        Loop
99437>>>>
99437>>>
99437>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
99438>>>
99438>>>        Function_Return (bOK = True)
99439>>>    End_Function
99440>>>
99440>>>    // *** Helper functions for Mertech Drivers ***
99440>>>    // Created to not clutter up the standard function code with lots of #IFDEF's
99440>>>    // and commands that the Studio editor knows nothing about.
99440>>>    Function _MertechDeleteTDFile String sTableName Returns Integer
99442>>>        Integer iRetval
99442>>>        String sPath
99442>>>
99442>>>            SQL_GET_LOCAL_TD_PATH to sPath
99456>>>>
99456>>>        If (sPath = "" or sTableName = "") Begin
99458>>>            Function_Return 0
99459>>>        End
99459>>>>
99459>>>
99459>>>        Get vFolderFormat sPath to sPath
99460>>>        Get vDeleteFile (sPath + String(sTableName) + ".td") to iRetval
99461>>>        Function_Return iRetval
99462>>>    End_Function
99463>>>
99463>>>    Function _MertechSqlUtilCreateIntFile Handle hTable String sDataPath String sPhysicalFileName Returns Boolean
99465>>>        Move False to Err
99466>>>            Set_Attribute DF_FILE_SUPPRESS_SERVERNAME_OUTPUT   of hTable to False
99469>>>            Set_Attribute DF_FILE_SUPPRESS_DATABASENAME_OUTPUT of hTable to False
99472>>>            Set_Attribute DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT   of hTable to False
99475>>>            OUTPUT_INT_FILE for hTable to (sDataPath + sPhysicalFileName)
99496>>>>
99496>>>        Function_Return (Err = False)
99497>>>    End_Function
99498>>>
99498>>>    Function _MertechEnumerateSQLFlexServers Returns String[]
99500>>>        Integer iNumItems iCount
99500>>>        String[] sReturnArray
99501>>>        String sServer
99501>>>
99501>>>        Get SQL_AVAILABLE_SQL_SERVERS to iNumItems
99502>>>        For iCount from 1 to iNumItems
99508>>>>
99508>>>            Get SQL_AVAILABLE_SQL_SERVER_NAME iCount to sServer
99509>>>            Move sServer to sReturnArray[iCount -1]
99510>>>        Loop
99511>>>>
99511>>>
99511>>>        Function_Return sReturnArray
99512>>>    End_Function
99513>>>
99513>>>    Function _MertechEnumerateORAFLEXServers Returns String[]
99515>>>        String[] sReturnArray
99516>>>        String sServer
99516>>>
99516>>>        GET_CURRENT_SQL_SERVER to sServer
99536>>>>
99536>>>        Move sServer to sReturnArray[0]
99537>>>
99537>>>        Function_Return sReturnArray
99538>>>    End_Function
99539>>>
99539>>>    Function _MertechSQLConnect String sDriverID String sServer String sUserID String sPassword Returns Handle
99541>>>        Handle hoSQLHandler hoSQLConnect
99541>>>
99541>>>        Move 0 to hoSQLConnect
99542>>>            Get _MertechSQLManagerHandle to hoSQLHandler
99543>>>            Get SQLConnect of hoSqlHandler sDriverID sServer sUserID sPassword to hoSQLConnect
99544>>>
99544>>>        Function_Return hoSQLConnect
99545>>>    End_Function
99546>>>
99546>>>    // Returns the handle of the Mertech SQL handler.
99546>>>    // It also ensures that the correct Server & Database attributes are set both for
99546>>>    // embedded SQL calls and "normal" database commands like e.g. "Open".
99546>>>    Function _MertechSQLManagerHandle Returns Handle
99548>>>        Handle hoSQLHandler
99548>>>        String sDriverID sServer sDatabase
99548>>>
99548>>>        Move 0 to hoSQLHandler
99549>>>        Get psDriverID to sDriverID
99550>>>        Get psServer   to sServer
99551>>>        Get psDatabase to sDatabase
99552>>>        // This command is used to set the server to be used when opening tables
99552>>>        SET_CURRENT_SQL_SERVER            to sServer
99571>>>>
99571>>>        // This command is used to specify which server to use for embedded SQL statements,
99571>>>        // but it has been constructed rather studidly as only constants and not variables
99571>>>        // are allowed...
99571>>>        If (sDriverID = MDSPgSQL) Begin
99573>>>            SET_CURRENT_SQL_SERVER_CONNECTION of MDSPgSQL to sServer
99589>>>        End
99589>>>>
99589>>>        If (sDriverID = MDSMySQL) Begin
99591>>>            SET_CURRENT_SQL_SERVER_CONNECTION of MDSMySQL to sServer
99607>>>        End
99607>>>>
99607>>>        If (sDriverID = ORAFLEX) Begin
99609>>>            SET_CURRENT_SQL_SERVER_CONNECTION of ORAFLEX to sServer
99625>>>        End
99625>>>>
99625>>>        If (sDriverID = SQLFLEX) Begin
99627>>>            SET_CURRENT_SQL_SERVER_CONNECTION of SQLFLEX to sServer
99643>>>        End
99643>>>>
99643>>>
99643>>>        // This command is used to specify which database is used for SQL statements only.
99643>>>        SQL_USE_DATABASE sDatabase
99657>>>>
99657>>>        SET_DATABASE_NAME to sDatabase
99671>>>>
99671>>>
99671>>>        Get phoSQLManagerMT to hoSQLHandler
99672>>>
99672>>>        Function_Return hoSQLHandler
99673>>>    End_Function
99674>>>
99674>>>    // For Mertech drivers we cannot use Structure_Start/End. Instead we must use
99674>>>    // macro-commands <sigh!>
99674>>>    // Note: The function sets the Err flag.
99674>>>    Function _MertechApiTableConvertToSQL Handle hTable String sRootName String sDatabase String sDriverID String sBaseTableSpace String sIndexTableSpace Boolean bCopyData Returns Boolean
99676>>>        Move False to Err
99677>>>
99677>>>            MERTECH_WARNING_MESSAGE Disabled
99686>>>>
99686>>>            SET_DATABASE_NAME to sDatabase
99700>>>>
99700>>>            If (sBaseTableSpace <> "") Begin
99702>>>                SET_DEFAULT_TABLESPACE to sBaseTableSpace
99715>>>>
99715>>>            End
99715>>>>
99715>>>            If (sIndexTableSpace <> "") Begin
99717>>>                SET_DEFAULT_INDEX_TABLESPACE to sIndexTableSpace
99730>>>>
99730>>>            End
99730>>>>
99730>>>            CREATE_TABLE_FROM_DAT_FILE hTable DF_STRUCTEND_OPT_FORCE_NOT_NULL sRootName
99752>>>>
99752>>>            If (bCopyData = True) Begin
99754>>>                COPY_DATA sRootName to (sDriverID + ":" + sRootName) CALLBACK (Callback(Self))
99769>>>>
99769>>>            End
99769>>>>
99769>>>
99769>>>        Function_Return (Err = False)
99770>>>    End_Function
99771>>>
99771>>>End_Class
99772>// Needs to be after the cSQLConnectionHandler object
99772>Object oDbUpdateFunctionLibrary is a cDbUpdateFunctionLibrary
99774>End_Object
99775>
99775>Object oToolTipController is a cToolTipController
99777>    Move Self to ghoToolTipController
99778>    Set pbBalloonStyle to False
99779>    Set piIcon to TTI_INFO
99780>    Set psTitle to "Information"
99781>    Set piMaxWidth to 400
99782>    Set piDurationPopup to 14000    // 14 seconds, needed for long tooltips.
99783>End_Object
99784>
99784>Use oEditContextMenu.pkg
Including file: oEditContextMenu.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\oEditContextMenu.pkg)
99784>>>Use cCJStandardMenuItemClasses.pkg
99784>>>
99784>>>Object oEditContextMenu is a cCJContextMenu
99786>>>    
99786>>>    Move Self to Default_Form_Floating_Menu_ID
99787>>>    
99787>>>    Object oUndoMenuItem is a cCJUndoMenuItem
99789>>>    End_Object
99790>>>    
99790>>>    Object oCutMenuItem is a cCJCutMenuItem
99792>>>        Set pbControlBeginGroup to True
99793>>>    End_Object
99794>>>    
99794>>>    Object oCopyMenuItem is a cCJCopyMenuItem
99796>>>    End_Object
99797>>>
99797>>>    Object oPasteMenuItem is a cCJPasteMenuItem
99799>>>    End_Object
99800>>>
99800>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
99802>>>    End_Object
99803>>>
99803>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
99805>>>        Set pbControlBeginGroup to True
99806>>>    End_Object
99807>>>
99807>>>End_Object
99808>>>
99808>Use oDEOEditContextMenu17.pkg
Including file: oDEOEditContextMenu17.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\oDEOEditContextMenu17.pkg)
99808>>>Use Windows.pkg
99808>>>Use cCJStandardMenuItemClasses.pkg
99808>>>Use cCJDeoMenuItemClasses.pkg
99808>>>
99808>>>
99808>>>Object oDEOEditContextMenu17 is a cCJContextMenu
99810>>>    
99810>>>    Move Self to Default_dbFloating_Menu_ID
99811>>>    
99811>>>    Object oUndoMenuItem is a cCJUndoMenuItem
99813>>>    End_Object
99814>>>    
99814>>>    Object oCutMenuItem is a cCJCutMenuItem
99816>>>        Set pbControlBeginGroup to True
99817>>>    End_Object
99818>>>    
99818>>>    Object oCopyMenuItem is a cCJCopyMenuItem
99820>>>    End_Object
99821>>>
99821>>>    Object oPasteMenuItem is a cCJPasteMenuItem
99823>>>    End_Object
99824>>>
99824>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
99826>>>    End_Object
99827>>>
99827>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
99829>>>        Set pbControlBeginGroup to True
99830>>>    End_Object
99831>>>
99831>>>    Object oPromptMenuItem is a cCJPromptMenuItem
99833>>>        Set pbControlBeginGroup to True
99834>>>    End_Object
99835>>>
99835>>>    Object oFindNextMenu is a cCJFindNextMenuItem
99837>>>        Set pbControlBeginGroup to True
99838>>>    End_Object
99839>>>
99839>>>    Object oFindPreviousMenu is a cCJFindPreviousMenuItem
99841>>>    End_Object
99842>>>
99842>>>    Object oClearMenuItem is a cCJClearMenuItem
99844>>>        Set pbControlBeginGroup to True
99845>>>    End_Object
99846>>>
99846>>>    Object oClearAllMenu is a cCJClearAllMenuItem
99848>>>    End_Object
99849>>>
99849>>>    Object oSaveMenu is a cCJSaveMenuItem
99851>>>    End_Object
99852>>>    
99852>>>    Object oDeleteMenu is a cCJDeleteMenuItem
99854>>>    End_Object
99855>>>
99855>>>    Object oRememberitem is a cCJRememberFieldMenuItem
99857>>>        Set pbControlBeginGroup to True
99858>>>    End_Object
99859>>>
99859>>>    Object oRetainItem is a cCJRememberLastFieldMenuItem
99861>>>    End_Object
99862>>>
99862>>>    Object oUnRememberitem is a cCJUnRememberFieldMenuItem
99864>>>    End_Object
99865>>>
99865>>>    Object oCJClearAllDynamicDefaults is a cCJUnRememberFieldAllMenuItem
99867>>>    End_Object
99868>>>
99868>>>End_Object
99869>
99869>Object oMain is a Panel
99871>    Set Label to (psProduct(ghoApplication))
99872>    Set Location to 105 166
99873>    Set Size to 196 493
99874>    Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
99875>    Set Icon to "SQLConnections.ico"
99876>
99876>    Object oCommandBarSystem is a cCJCommandBarSystem
99878>        Set pbTimerUpdate to True
99879>            Set pbAutoResizeIcons to True
99880>
99880>        Procedure OnCreateCommandBars
99883>            Handle hoOptions
99883>            Get OptionsObject to hoOptions
99884>            Forward Send OnCreateCommandBars
99886>        End_Procedure
99887>
99887>        Object oStatusBar is a cCJStatusBar
99889>
99889>            Object oStatusPane1 is a cCJStatusBarPane
99891>                Set pbStyleStretch to True
99892>            End_Object
99893>
99893>            Object oStatusPane2 is a cCJStatusBarPane
99895>                Set phoViewPane to Self
99896>                Set pbStyleStretch to True
99897>                Set piTextColor to clRed
99898>            End_Object
99899>
99899>        End_Object
99900>
99900>    End_Object
99901>
99901>    Object oClientArea is a ClientArea
99903>        Use StdAbout.pkg
Including file: StdAbout.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\StdAbout.pkg)
99903>>>//************************************************************************
99903>>>// Confidential Trade Secret.
99903>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
99903>>>// as an unpublished work.  All rights reserved.
99903>>>// DataFlex is a registered trademark of Data Access Corporation.
99903>>>//
99903>>>//************************************************************************
99903>>>//************************************************************************
99903>>>//
99903>>>// $File name  : StdAbout.pkg
99903>>>// $File title : Standard about object package for VDF
99903>>>// Notice      :
99903>>>// $Author(s)  : John Tuohy
99903>>>//
99903>>>// $Rev History
99903>>>//
99903>>>// JT 06/27/97   File created
99903>>>//************************************************************************
99903>>>
99903>>>// This provides a quick and simple way to create an about package for a program.
99903>>>// You need to create a message inside you client area called Activate_About.
99903>>>// Within this message you should send the message DoAbout passing needed
99903>>>// string information.
99903>>>//
99903>>>//       Procedure Activate_About
99903>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
99903>>>//       End_Procedure
99903>>>//    where: sTitle =     Name of application. If none provided, uses caption
99903>>>//                        bar title
99903>>>//           sVersion   = Version Line. If none provided, will be blank
99903>>>//           sCopyRight = Copyright Line. If none provided, will be blank
99903>>>//           sAuthor    = Author name, blank if none provided
99903>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
99903>>>//                        is used.
99903>>>// It is expected that you will place this in your own object package. For
99903>>>// example an order about package may look like this:
99903>>>//
99903>>>//   // OrderAbout.pkg
99903>>>//   Use StdAbout.pkg
99903>>>//   Procedure Activate_About
99903>>>//      String sTitle sCopyright sVersion sAuthor
99903>>>//      Move "My Order Entry System" to sTitle
99903>>>//      Move "Version 2.1" to sVersion
99903>>>//      Move "Copyright 1997, Super Software Inc." to sCopyright
99903>>>//      Move "John Smith"  to sAuthor
99903>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
99903>>>//   end_procedure
99903>>>//   // end of file.
99903>>>
99903>>>Use DfAbout.pkg
Including file: DfAbout.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\DfAbout.pkg)
99903>>>>>//************************************************************************
99903>>>>>// Confidential Trade Secret.
99903>>>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
99903>>>>>// as an unpublished work.  All rights reserved.
99903>>>>>// DataFlex Is A registered trademark Of Data Access Corporation.
99903>>>>>//
99903>>>>>//************************************************************************
99903>>>>>//************************************************************************
99903>>>>>//
99903>>>>>// $File name  : DfAbout.pkg
99903>>>>>// $File title : About class support
99903>>>>>// Notice      :
99903>>>>>// $Author(s)  : Vincent Oorsprong, Ken Ross
99903>>>>>//
99903>>>>>// $Rev History
99903>>>>>//
99903>>>>>// NGS 08/16/2013 Improved by using a cRichEdit object were the params gets added to.
99903>>>>>//                The objects that previously were popupated with values from the params,
99903>>>>>//                and their corresponding "Procedure Set..." messages, were removed as
99903>>>>>//                the edit object is used instead.
99903>>>>>//                The number of params to the DoAbout procedure was increased to ten, so
99903>>>>>//                it is easier to add whatever extra text strings needed/wanted.
99903>>>>>//                The StdAbout.pkg was also changed for this to work. It allows for an extra
99903>>>>>//                five new params to be passed, but these new params are all optional.
99903>>>>>//                So the interface will work exactly as before - if no extra parameters are passed.
99903>>>>>//                Also added an extra bitmap object to show the "Powered By Visual DataFlex" logo, in
99903>>>>>//                the lower left corner of the About object, beneath the "main" About bitmap.
99903>>>>>//                Note: It is assumed that the bitmap "PoweredByVisualDataFlex.bmp" exists.
99903>>>>>//                The background was changed to clWhite for easier usage of bitmaps. Just set the background
99903>>>>>//                color of your bitmap to white and the bitmap will not look jagged.
99903>>>>>//                If an Internet address is passed as one of the params, it will be underlined and clickable.
99903>>>>>//                An e-mail address can also be passed; e.g. "E-mail: mailto:mail@myemailaccount.com" and will
99903>>>>>//                also be clickable.
99903>>>>>// VOO 02/22/2012 Replaced obsolete code, improved Network_User_Name by asking
99903>>>>>//                Windows for the size first.
99903>>>>>// VOO 07/25/2003 Removed OnResize procedure for sysinfo dialog. Replaced logic
99903>>>>>//                with anchor technique. Removed unnessary property in the
99903>>>>>//                sysinfo dialog. Changed the size Of the about & sysinfo dialog
99903>>>>>//                object To better look in Windows XP. Repositioned the close
99903>>>>>//                button in the sysinfo dialog To line up with the display area
99903>>>>>//                Replaced obsolete code and techniques. Removed dead code.
99903>>>>>// JJT 10/23/2001 removed all ghoworkspace support. Uses app object or nothing
99903>>>>>// SWB 07/19/01   Added support Of the Application object in preference to
99903>>>>>//                the global Workspace object, if it is present
99903>>>>>// JJT 11/05/98   Added version information
99903>>>>>// VOO 29/10/98   Replaced the GetFreeSystemResources for the Win32 variant
99903>>>>>// JJT 7/31/97    Registered Enumerate Workspace so dfabout can exist without
99903>>>>>//                workspace package.
99903>>>>>// JJT 6/27/97    Turned the sysinfo objects into classes so the AboutDialog
99903>>>>>//                class can create this object.
99903>>>>>//                Cleaned up the interface (used correct classes and messages)
99903>>>>>//                Added workspace reporting support To sys-info.
99903>>>>>//                Turned off wrapping in the sys-info editor.
99903>>>>>// KR  ??/??/96   File created
99903>>>>>//************************************************************************
99903>>>>>Use LanguageText.pkg
99903>>>>>Use Windows.pkg
99903>>>>>Use DFbitmap.pkg
99903>>>>>Use GlobalFunctionsProcedures.pkg
99903>>>>>Use cRichEdit.pkg
Including file: cRichEdit.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cRichEdit.pkg)
99903>>>>>>>use Windows.pkg
99903>>>>>>>Use cEdit_Mixin.pkg
99903>>>>>>>
99903>>>>>>>// DFO: cRichEdit.Dfo
99903>>>>>>>// DFC: cRichEdit.Dfc
99903>>>>>>>
99903>>>>>>>// constants used for RichEdit Properties
99903>>>>>>>// peAlignment 
99903>>>>>>>Enum_List 
99903>>>>>>>    Define alLeft   for 1 
99903>>>>>>>    Define alRight  for 2 
99903>>>>>>>    Define alCenter for 3 
99903>>>>>>>End_Enum_List 
99903>>>>>>>
99903>>>>>>>// peBullets 
99903>>>>>>>Enum_List 
99903>>>>>>>    Define buNone 
99903>>>>>>>    Define buBullets 
99903>>>>>>>    Define buArabicNumbers 
99903>>>>>>>    Define buLowerLetters 
99903>>>>>>>    Define buUpperLetters 
99903>>>>>>>    Define buLowerRomans 
99903>>>>>>>    Define buUpperRomans 
99903>>>>>>>End_Enum_List 
99903>>>>>>>
99903>>>>>>>// peBulletStyle 
99903>>>>>>>Enum_List 
99903>>>>>>>    Define busRightParen   for 0 
99903>>>>>>>    Define busEncloseParen for 256 
99903>>>>>>>    Define busPeriod       for 512 
99903>>>>>>>    Define busNumberOnly   for 768 
99903>>>>>>>    Define busNoDisplay    for 1024 
99903>>>>>>>End_Enum_List
99903>>>>>>>    
99903>>>>>>>// peLineSpacingType
99903>>>>>>>Enum_List 
99903>>>>>>>    Define lstSingle
99903>>>>>>>    Define lstSingleAndOneHalf
99903>>>>>>>    Define lstDouble
99903>>>>>>>End_Enum_List
99903>>>>>>>
99903>>>>>>>Class cRichEdit Is A DFBaseRichEdit
99904>>>>>>>
99904>>>>>>>    Procedure Construct_Object
99906>>>>>>>        Forward Send Construct_Object
99908>>>>>>>        Send Define_cEdit_Mixin
99909>>>>>>>
99909>>>>>>>        On_key Key_Ctrl+Key_B send ToggleBold
99910>>>>>>>        On_key Key_Ctrl+Key_I send ToggleItalics
99911>>>>>>>        On_key Key_Ctrl+Key_U send ToggleUnderline
99912>>>>>>>
99912>>>>>>>    End_Procedure // Construct_Object
99913>>>>>>>
99913>>>>>>>    Import_Class_Protocol cEdit_Mixin
99914>>>>>>>    
99914>>>>>>>    Procedure ToggleBold
99916>>>>>>>        Set pbBold to (not(pbBold(self))) 
99917>>>>>>>    end_procedure
99918>>>>>>>    
99918>>>>>>>    Procedure ToggleItalics
99920>>>>>>>        Set pbItalics to (not(pbItalics(self))) 
99921>>>>>>>    end_procedure
99922>>>>>>>    
99922>>>>>>>    Procedure ToggleUnderline
99924>>>>>>>       Set pbUnderLine to (not(pbUnderLine(self))) 
99925>>>>>>>    end_procedure
99926>>>>>>>
99926>>>>>>>End_Class
99927>>>>>>>
99927>>>>>Use cTextEdit.pkg
99927>>>>>Use gFormatNumbers.pkg
Including file: gFormatNumbers.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\gFormatNumbers.pkg)
99927>>>>>>>//****************************************************************************//
99927>>>>>>>//                                                                            //
99927>>>>>>>// $File name  : gFormatNumbers.pkg                                           //
99927>>>>>>>// $File title : Globals for formating numbers and currency                   //
99927>>>>>>>// Notice      :                                                              //
99927>>>>>>>// $Author(s)  : John Tuohy                                                   //
99927>>>>>>>//                                                                            //
99927>>>>>>>// Confidential Trade Secret.                                                 //
99927>>>>>>>// Copyright 1999 Data Access Corporation, Miami FL, USA                      //
99927>>>>>>>// All Rights reserved                                                        //
99927>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.             //
99927>>>>>>>// $Rev History                                                               //
99927>>>>>>>//                                                                            //
99927>>>>>>>// 25.08.99 Created                                                           //
99927>>>>>>>//****************************************************************************//
99927>>>>>>>
99927>>>>>>>Use cFormatter.pkg
Including file: cFormatter.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cFormatter.pkg)
99927>>>>>>>>>//****************************************************************************//
99927>>>>>>>>>//                                                                            //
99927>>>>>>>>>// $File name  : cFormatter.pkg                                               //
99927>>>>>>>>>// $File title : cFormatter class (private class)                             //
99927>>>>>>>>>// $Author(s)  : John Tuohy                                                   //
99927>>>>>>>>>//                                                                            //
99927>>>>>>>>>// Confidential Trade Secret.                                                 //
99927>>>>>>>>>// Copyright 1999 Data Access Corporation, Miami FL, USA                      //
99927>>>>>>>>>// All Rights reserved                                                        //
99927>>>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.             //
99927>>>>>>>>>//                                                                            //
99927>>>>>>>>>// $Rev History                                                               //
99927>>>>>>>>>//                                                                            //
99927>>>>>>>>>// 25.08.99 Created                                                           //
99927>>>>>>>>>//****************************************************************************//
99927>>>>>>>>>use VDFBase.pkg
99927>>>>>>>>>
99927>>>>>>>>>Class cFormatter is an cObject
99928>>>>>>>>>
99928>>>>>>>>>    Procedure Construct_object
99930>>>>>>>>>        Integer iCh
99930>>>>>>>>>        forward send construct_object
99932>>>>>>>>>        Property String  psCurrencySymbol
99933>>>>>>>>>        Set psCurrencySymbol to (Default_Currency_Symbol())
99934>>>>>>>>>
99934>>>>>>>>>        Property string  psLeft
99935>>>>>>>>>        Property string  psright
99936>>>>>>>>>        Property integer pbThousandsSep
99937>>>>>>>>>        Property integer piPoints
99938>>>>>>>>>
99938>>>>>>>>>        Property string  psCurPosLeft
99939>>>>>>>>>        Property string  psCurPosright
99940>>>>>>>>>        Property integer pbCurPosThousandsSep
99941>>>>>>>>>        Property integer piCurPosPoints
99942>>>>>>>>>
99942>>>>>>>>>        Property string  psCurNegLeft
99943>>>>>>>>>        Property string  psCurNegright
99944>>>>>>>>>        Property integer pbCurNegThousandsSep
99945>>>>>>>>>        Property integer piCurNegPoints
99946>>>>>>>>>
99946>>>>>>>>>        Property string  psNumPosLeft
99947>>>>>>>>>        Property string  psNumPosright
99948>>>>>>>>>        Property integer pbNumPosThousandsSep
99949>>>>>>>>>        Property integer piNumPosPoints
99950>>>>>>>>>
99950>>>>>>>>>        Property string  psNumNegLeft
99951>>>>>>>>>        Property string  psNumNegright
99952>>>>>>>>>        Property integer pbNumNegThousandsSep
99953>>>>>>>>>        Property integer piNumNegPoints
99954>>>>>>>>>
99954>>>>>>>>>        Send SetFormat "$,#.##;($,#.##)" true  // currency
99955>>>>>>>>>        Send SetFormat  ",#.*"           false // numeric
99956>>>>>>>>>
99956>>>>>>>>>    end_procedure
99957>>>>>>>>>
99957>>>>>>>>>    // internal
99957>>>>>>>>>    // parse passed format string and set temporary properties with result
99957>>>>>>>>>    //
99957>>>>>>>>>    Procedure ParseFormat string sFmt
99959>>>>>>>>>
99959>>>>>>>>>        string sLeft sRight sDigit
99959>>>>>>>>>        integer bSep iPos i iDigits
99959>>>>>>>>>
99959>>>>>>>>>        // replace any literals. A "/" followed by anything.
99959>>>>>>>>>        // some literals are special. $ . , / #
99959>>>>>>>>>        Move (Replaces("/$",sFmt,Character(1)))    to sFmt
99960>>>>>>>>>        Move (Replaces("/.",sFmt,Character(2)))    to sFmt
99961>>>>>>>>>        Move (Replaces("/,",sFmt,Character(3)))    to sFmt
99962>>>>>>>>>        Move (Replaces("/"+"/",sFmt,Character(4))) to sFmt
99963>>>>>>>>>        Move (Replaces("/#",sFmt,Character(5)))    to sFmt
99964>>>>>>>>>        Move (Character(9)) to sDigit
99965>>>>>>>>>        Move (Replaces("#",sFmt,sDigit))           to sFmt
99966>>>>>>>>>        Move (Replaces("/",sFmt,""))               to sFmt // replace all others
99967>>>>>>>>>
99967>>>>>>>>>        Move (Pos(",",sFmt))                 to bSep // if we have any , we use thousand seps
99968>>>>>>>>>        If bSep Move (Replaces(",",sFmt,"")) to sFmt // remove all ,
99971>>>>>>>>>
99971>>>>>>>>>        Move (Replaces("$",sFmt,psCurrencySymbol(self))) to sFmt // replace any $ with currency symbol
99972>>>>>>>>>
99972>>>>>>>>>        Move (Pos(".",sFmt)) to iPos                 // position of decimal
99973>>>>>>>>>
99973>>>>>>>>>        // Move all the special literals back into place before parsing
99973>>>>>>>>>        Move (Replaces(Character(1),sFmt,"$")) to sFmt
99974>>>>>>>>>        Move (Replaces(Character(2),sFmt,".")) to sFmt
99975>>>>>>>>>        Move (Replaces(Character(3),sFmt,",")) to sFmt
99976>>>>>>>>>        Move (Replaces(Character(4),sFmt,"/")) to sFmt
99977>>>>>>>>>        Move (Replaces(Character(5),sFmt,"#")) to sFmt
99978>>>>>>>>>
99978>>>>>>>>>        If (iPos>0) Begin                      // if we have a decimanl point
99980>>>>>>>>>            Move 1 to i                        // look for first non # to right and count the #s
99981>>>>>>>>>            If (mid(sFmt,1,iPos+i)="*") Begin  // the "*" is special. It means as many as you want
99983>>>>>>>>>               Move -2 to iDigits
99984>>>>>>>>>               increment i
99985>>>>>>>>>            end
99985>>>>>>>>>>
99985>>>>>>>>>            While (mid(sFmt,1,iPos+i)=sDigit)
99989>>>>>>>>>                 Increment i
99990>>>>>>>>>            end
99991>>>>>>>>>>
99991>>>>>>>>>            Move (Mid(sFmt,255,iPos+i)) to sRight // everything to the right of the last # is format stuff
99992>>>>>>>>>            If (iDigits=0) Move (i-1) to iDigits
99995>>>>>>>>>            //
99995>>>>>>>>>            Move 1 to i                           // find the first non-# to the left of the point
99996>>>>>>>>>            While (mid(sFmt,1,iPos-i)=sDigit)     // everything to the left is format stuff
100000>>>>>>>>>                 increment i
100001>>>>>>>>>            end
100002>>>>>>>>>>
100002>>>>>>>>>            Move (left(sFmt,iPos-i)) to sLeft
100003>>>>>>>>>        end
100003>>>>>>>>>>
100003>>>>>>>>>        else begin                             // we have no decinal
100004>>>>>>>>>            Move 0 to iDigits                  // so points is none
100005>>>>>>>>>            Move (Pos(sDigit,sFmt)) to iPos    // find first #.
100006>>>>>>>>>            If (iPos=0) Begin                  // if none, entire string is left format stuff..wierd!
100008>>>>>>>>>                Move sFmt to sLeft
100009>>>>>>>>>                Move ""   to sRight
100010>>>>>>>>>            end
100010>>>>>>>>>>
100010>>>>>>>>>            else begin
100011>>>>>>>>>                Move (left(sFmt,iPos-1)) to sLeft // all char to left of first # is left format stuff
100012>>>>>>>>>                Move 1 to i
100013>>>>>>>>>                While (mid(sFmt,1,iPos+i)=sDigit) // find last #, all char to right is right format
100017>>>>>>>>>                    Increment i
100018>>>>>>>>>                end
100019>>>>>>>>>>
100019>>>>>>>>>                Move (Mid(sFmt,255,i+iPos)) to sRight
100020>>>>>>>>>            end
100020>>>>>>>>>>
100020>>>>>>>>>        end
100020>>>>>>>>>>
100020>>>>>>>>>        // set temporary format properties and exit
100020>>>>>>>>>        Set pbThousandsSep to bSep
100021>>>>>>>>>        set psLeft         to sLeft
100022>>>>>>>>>        set psRight        to sRight
100023>>>>>>>>>        Set piPoints       to iDigits
100024>>>>>>>>>     End_procedure
100025>>>>>>>>>
100025>>>>>>>>>    // Public: Sets a format string. Pass full format for Positve and negative in sFmt. Pass
100025>>>>>>>>>    //         bCurrency true is this is a currency format, false if a numeric format
100025>>>>>>>>>    //
100025>>>>>>>>>    //  e.g. Send SetFormat "$,#.##;($,#.##)" True
100025>>>>>>>>>    //
100025>>>>>>>>>    Procedure SetFormat string sFmt integer bCurrency
100027>>>>>>>>>        string sPos sNeg
100027>>>>>>>>>        integer iPos
100027>>>>>>>>>
100027>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
100028>>>>>>>>>        If iPos begin
100030>>>>>>>>>            Move (left(sFmt,iPos-1))    to sPos
100031>>>>>>>>>            Move (mid(sFmt,255,iPos+1)) to sNeg
100032>>>>>>>>>        end
100032>>>>>>>>>>
100032>>>>>>>>>        else Begin
100033>>>>>>>>>            Move sFmt         to sPos
100034>>>>>>>>>            Move ("-" + sFmt) to sNeg
100035>>>>>>>>>        end
100035>>>>>>>>>>
100035>>>>>>>>>        Send ParseFormat sPos
100036>>>>>>>>>        If bCurrency begin
100038>>>>>>>>>            Set pbCurPosThousandsSep to (pbThousandsSep(self))
100039>>>>>>>>>            set psCurPosLeft         to (psLeft(self))
100040>>>>>>>>>            set psCurPosRight        to (psRight(self))
100041>>>>>>>>>            Set piCurPosPoints       to (piPoints(self))
100042>>>>>>>>>        End
100042>>>>>>>>>>
100042>>>>>>>>>        else Begin
100043>>>>>>>>>            Set pbNumPosThousandsSep to (pbThousandsSep(self))
100044>>>>>>>>>            set psNumPosLeft         to (psLeft(self))
100045>>>>>>>>>            set psNumPosRight        to (psRight(self))
100046>>>>>>>>>            Set piNumPosPoints       to (piPoints(self))
100047>>>>>>>>>        end
100047>>>>>>>>>>
100047>>>>>>>>>
100047>>>>>>>>>        Send ParseFormat sNeg
100048>>>>>>>>>        If bCurrency begin
100050>>>>>>>>>            Set pbCurNegThousandsSep to (pbThousandsSep(self))
100051>>>>>>>>>            set psCurNegLeft         to (psLeft(self))
100052>>>>>>>>>            set psCurNegRight        to (psRight(self))
100053>>>>>>>>>            Set piCurNegPoints       to (piPoints(self))
100054>>>>>>>>>        End
100054>>>>>>>>>>
100054>>>>>>>>>        else Begin
100055>>>>>>>>>            Set pbNumNegThousandsSep to (pbThousandsSep(self))
100056>>>>>>>>>            set psNumNegLeft         to (psLeft(self))
100057>>>>>>>>>            set psNumNegRight        to (psRight(self))
100058>>>>>>>>>            Set piNumNegPoints       to (piPoints(self))
100059>>>>>>>>>        end
100059>>>>>>>>>>
100059>>>>>>>>>    End_procedure
100060>>>>>>>>>
100060>>>>>>>>>    // low level formatting. Pass parameters
100060>>>>>>>>>    Function Format_Num number nNumber integer iPoints integer bSep ;                       string sPrefix string sSuffix returns string
100062>>>>>>>>>        string  sLeft sRight sNumber sSep sDec
100062>>>>>>>>>        integer bIsNegative iDec iLen iCh
100062>>>>>>>>>
100062>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iCh
100065>>>>>>>>>        Move (Character(iCh)) to sDec
100066>>>>>>>>>
100066>>>>>>>>>        Move (abs(nNumber)) to sNumber
100067>>>>>>>>>        Move (Pos(sDec,sNumber)) to iDec
100068>>>>>>>>>        Move (If(iDec=0, sNumber, left(sNumber,iDec-1))) to sLeft
100069>>>>>>>>>        Move (If(iDec=0, "", mid(sNumber,255,iDec+1)))   to sRight
100070>>>>>>>>>        // format for decimal separator
100070>>>>>>>>>        If (iPoints>=0) ; // if -2, leave it alone, it should not be -1            Move (left(sRight+repeat("0",iPoints),iPoints)) to sRight
100073>>>>>>>>>
100073>>>>>>>>>        // format for thousand sep.
100073>>>>>>>>>        If bSep Begin
100075>>>>>>>>>            Get_Attribute DF_THOUSANDS_SEPARATOR to iCh
100078>>>>>>>>>            Move (Character(iCh)) to sSep
100079>>>>>>>>>            Move (Length(sLeft)) to iLen
100080>>>>>>>>>            While (iLen>3)
100084>>>>>>>>>                Move (insert(sSep,sLeft,iLen-2)) to sLeft
100085>>>>>>>>>                Move (iLen-3) to iLen
100086>>>>>>>>>            End
100087>>>>>>>>>>
100087>>>>>>>>>        End
100087>>>>>>>>>>
100087>>>>>>>>>        // if decimal points or -2 (allow anything) and there are points to show
100087>>>>>>>>>        If (iPoints>0 OR (iPoints=-2 AND sRight<>"")) ;            Move (sLeft + sDec + sright) to sLeft
100090>>>>>>>>>        Function_return (sPrefix + sLeft+ sSuffix)
100091>>>>>>>>>    End_Function
100092>>>>>>>>>
100092>>>>>>>>>    // Public: Format for currency
100092>>>>>>>>>    //
100092>>>>>>>>>    Function FormatCur number nNumber integer iPoints returns string
100094>>>>>>>>>        string  sLeft sRight
100094>>>>>>>>>        integer bSep
100094>>>>>>>>>        If (nNumber<0) Begin
100096>>>>>>>>>            get pbCurNegThousandsSep to bSep
100097>>>>>>>>>            get psCurNegLeft         to sLeft
100098>>>>>>>>>            get psCurNegRight        to sRight
100099>>>>>>>>>            If (iPoints=-1) get piCurNegPoints       to iPoints
100102>>>>>>>>>        end
100102>>>>>>>>>>
100102>>>>>>>>>        Else Begin
100103>>>>>>>>>            get pbCurPosThousandsSep to bSep
100104>>>>>>>>>            get psCurPosLeft         to sLeft
100105>>>>>>>>>            get psCurPosRight        to sRight
100106>>>>>>>>>            If (iPoints=-1) get piCurPosPoints       to iPoints
100109>>>>>>>>>        end
100109>>>>>>>>>>
100109>>>>>>>>>        Function_return (Format_Num(self, nNumber,iPoints,bSep,sLeft,sRight))
100110>>>>>>>>>    End_function
100111>>>>>>>>>
100111>>>>>>>>>    // Public: Format for numeric
100111>>>>>>>>>    //
100111>>>>>>>>>    Function FormatNum number nNumber integer iPoints returns string
100113>>>>>>>>>        string  sLeft sRight
100113>>>>>>>>>        integer bSep
100113>>>>>>>>>        If (nNumber<0) Begin
100115>>>>>>>>>            get pbNumNegThousandsSep to bSep
100116>>>>>>>>>            get psNumNegLeft         to sLeft
100117>>>>>>>>>            get psNumNegRight        to sRight
100118>>>>>>>>>            If (iPoints=-1) get piNumNegPoints       to iPoints
100121>>>>>>>>>        end
100121>>>>>>>>>>
100121>>>>>>>>>        Else Begin
100122>>>>>>>>>            get pbNumPosThousandsSep to bSep
100123>>>>>>>>>            get psNumPosLeft         to sLeft
100124>>>>>>>>>            get psNumPosRight        to sRight
100125>>>>>>>>>            If (iPoints=-1) get piNumPosPoints       to iPoints
100128>>>>>>>>>        end
100128>>>>>>>>>>
100128>>>>>>>>>        Function_return (Format_Num(self, nNumber,iPoints,bSep,sLeft,sRight))
100129>>>>>>>>>    End_function
100130>>>>>>>>>
100130>>>>>>>>>
100130>>>>>>>>>    // Public: Format passing format string
100130>>>>>>>>>    //
100130>>>>>>>>>    Function FormatVal number nNumber string sFmt returns string
100132>>>>>>>>>        integer iPos bIsNeg
100132>>>>>>>>>        string  sLeft sRight
100132>>>>>>>>>        integer iPoints bSep
100132>>>>>>>>>        Move (nNumber<0) to bIsNeg
100133>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
100134>>>>>>>>>        Case Begin
100134>>>>>>>>>            Case (iPos and Not(bIsNeg))      Move (left(sFmt,iPos-1))    to sFmt
100137>>>>>>>>>            Case (iPos and bIsNeg)           Move (mid(sFmt,255,iPos+1)) to sFmt
100141>>>>>>>>>            Case (not(iPos) and not(bIsNeg)) Move sFmt                   to sFmt
100145>>>>>>>>>            Case else                        Move ("-" + sFmt)           to sFmt
100147>>>>>>>>>        case end
100147>>>>>>>>>        Send ParseFormat sFmt
100148>>>>>>>>>        get pbThousandsSep to bSep
100149>>>>>>>>>        get psLeft         to sLeft
100150>>>>>>>>>        get psRight        to sRight
100151>>>>>>>>>        get piPoints       to iPoints
100152>>>>>>>>>        Function_return (Format_Num(self, nNumber,iPoints,bSep,sLeft,sRight))
100153>>>>>>>>>    end_function
100154>>>>>>>>>
100154>>>>>>>>>End_Class
100155>>>>>>>
100155>>>>>>>// for now, this object is private. All access is through the following
100155>>>>>>>// global functions
100155>>>>>>>
100155>>>>>>>//Object oFmt is a cFormatter
100155>>>>>>>//end_object
100155>>>>>>>
100155>>>>>>>Global_variable handle ghoFormatter
100155>>>>>>>Get Create of desktop U_cFormatter to ghoFormatter
100156>>>>>>>
100156>>>>>>>Function FormatNumber Global number nNum integer iPoints returns string
100158>>>>>>>    Function_return (FormatNum(ghoFormatter, nNum,iPoints))
100159>>>>>>>end_function
100160>>>>>>>
100160>>>>>>>Function FormatCurrency Global number nNum integer iPoints returns string
100162>>>>>>>    Function_return (FormatCur(ghoFormatter, nNum,iPoints))
100163>>>>>>>end_function
100164>>>>>>>
100164>>>>>>>Function FormatValue Global number nNum string sFmt returns string
100166>>>>>>>    Function_return (FormatVal(ghoFormatter, nNum,sFmt))
100167>>>>>>>end_function
100168>>>>>>>
100168>>>>>>>Procedure SetCurrencyFormat Global string sFmt
100170>>>>>>>    Send SetFormat of ghoFormatter sFmt True
100171>>>>>>>end_function
100172>>>>>>>
100172>>>>>>>Procedure SetNumberFormat Global string sFmt
100174>>>>>>>    Send SetFormat of ghoFormatter sFmt False
100175>>>>>>>end_function
100176>>>>>>>
100176>>>>>Use MapiDllCalls.Pkg
Including file: MapiDllCalls.Pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\MapiDllCalls.Pkg)
100176>>>>>>>Use MapiConstants.Pkg
Including file: MapiConstants.Pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\MapiConstants.Pkg)
100176>>>>>>>>>Type MapiSession
100176>>>>>>>>>   Field MapiSession.SessionID As Integer
100176>>>>>>>>>End_type // MapiSession
100176>>>>>>>>>
100176>>>>>>>>>Type MapiMessagePointer
100176>>>>>>>>>   Field MapiMessagePointer.lppMessage As Pointer
100176>>>>>>>>>End_Type // MapiMessagePointer
100176>>>>>>>>>
100176>>>>>>>>>Type MapiRecipPointer
100176>>>>>>>>>   Field MapiRecipPointer.lppRecip As Pointer
100176>>>>>>>>>End_Type // MapiRecipPointer
100176>>>>>>>>>
100176>>>>>>>>>Type MapiNewRecipsPointer
100176>>>>>>>>>   Field MapiNewRecipsPointer.lppNewRecips As Pointer
100176>>>>>>>>>End_Type // MapiNewRecipsPointer
100176>>>>>>>>>
100176>>>>>>>>>Type MapiNewRecipsCounter
100176>>>>>>>>>   Field MapiNewRecipsCounter.lpnNewRecips As Integer
100176>>>>>>>>>End_Type // MapiNewRecipsCounter
100176>>>>>>>>>
100176>>>>>>>>>Type MapiFileDesc
100176>>>>>>>>>   Field MapiFileDesc.ulReserved As Integer      // Reserved for future use (must be 0)
100176>>>>>>>>>   Field MapiFileDesc.flFlags As Integer         // Flags
100176>>>>>>>>>   Field MapiFileDesc.nPosition As Integer       // character in text to be replaced by attachment
100176>>>>>>>>>   Field MapiFileDesc.lpszPathName As Pointer    // Full path name of attachment file
100176>>>>>>>>>   Field MapiFileDesc.lpszFileName As Pointer    // Original file name (optional)
100176>>>>>>>>>   Field MapiFileDesc.lpFileType As Pointer     // Attachment file type (can be lpMapiFileTagExt)
100176>>>>>>>>>End_Type // MapiFileDesc
100176>>>>>>>>>
100176>>>>>>>>>Define MAPI_OLE        For |CI$00000001
100176>>>>>>>>>Define MAPI_OLE_STATIC For |CI$00000002
100176>>>>>>>>>
100176>>>>>>>>>Define MAPI_NOATTACHMENT_POSITION For |CI$FFFFFFFF
100176>>>>>>>>>
100176>>>>>>>>>Type MapiFileTagExt
100176>>>>>>>>>   Field MapiFileTagExt.ulReserved As Integer  // Reserved, must be zero.
100176>>>>>>>>>   Field MapiFileTagExt.cbTag As Integer       // Size (in bytes) of
100176>>>>>>>>>   Field MapiFileTagExt.lpTag As Pointer       // X.400 OID for this attachment type
100176>>>>>>>>>   Field MapiFileTagExt.cbEncoding As Integer  // Size (in bytes) of
100176>>>>>>>>>   Field MapiFileTagExt.lpEncoding As Pointer  // X.400 OID for this attachment's encoding
100176>>>>>>>>>End_Type // MapiFileTagExt
100176>>>>>>>>>
100176>>>>>>>>>Type MapiRecipDesc
100176>>>>>>>>>   Field MapiRecipDesc.ulReserved As Integer   // Reserved for future use
100176>>>>>>>>>   Field MapiRecipDesc.ulRecipClass As Integer // Recipient class
100176>>>>>>>>>                                               // MAPI_TO, MAPI_CC, MAPI_BCC, MAPI_ORIG
100176>>>>>>>>>   Field MapiRecipDesc.lpszName As Pointer     // Recipient name
100176>>>>>>>>>   Field MapiRecipDesc.lpszAddress As Pointer  // Recipient address (optional)
100176>>>>>>>>>   Field MapiRecipDesc.ulEIDSize As Pointer    // Count in bytes of size of pEntryID
100176>>>>>>>>>   Field MapiRecipDesc.lpEntryID As Pointer    // System-specific recipient reference
100176>>>>>>>>>End_Type // MapiRecipDesc
100176>>>>>>>>>
100176>>>>>>>>>Define MAPI_ORIG   For 0 // Recipient is message originator
100176>>>>>>>>>Define MAPI_TO     For 1 // Recipient is a primary recipient
100176>>>>>>>>>Define MAPI_CC     For 2 // Recipient is a copy recipient
100176>>>>>>>>>Define MAPI_BCC    For 3 // Recipient is blind copy recipient
100176>>>>>>>>>
100176>>>>>>>>>Type MapiMessage
100176>>>>>>>>>   Field MapiMessage.ulReserved As Integer                   // Reserved for future use (M.B. 0)
100176>>>>>>>>>   Field MapiMessage.lpszSubject As Pointer                  // Message Subject
100176>>>>>>>>>   Field MapiMessage.lpszNoteText As Pointer                 // Message Text
100176>>>>>>>>>   Field MapiMessage.lpszMessageType As Pointer              // Message Class
100176>>>>>>>>>   Field MapiMessage.lpszDateReceived As Pointer             // in YYYY/MM/DD HH:MM format
100176>>>>>>>>>   Field MapiMessage.lpszConversationID As Pointer           // conversation thread ID
100176>>>>>>>>>   Field MapiMessage.flFlags As Integer                      // unread,return receipt
100176>>>>>>>>>   Field MapiMessage.lpOriginator As Pointer                 // Originator descriptor
100176>>>>>>>>>   Field MapiMessage.nRecipCount As Integer                  // Number of recipients
100176>>>>>>>>>   Field MapiMessage.lpRecips As Pointer                     // Recipient descriptors
100176>>>>>>>>>   Field MapiMessage.nFileCount As Integer                   // # of file attachments
100176>>>>>>>>>   Field MapiMessage.lpFiles As Pointer                      // Attachment descriptors
100176>>>>>>>>>End_Type // MapiMessage
100176>>>>>>>>>
100176>>>>>>>>>Define MAPI_UNREAD            For |CI$00000001
100176>>>>>>>>>Define MAPI_RECEIPT_REQUESTED For |CI$00000002
100176>>>>>>>>>Define MAPI_SENT              For |CI$00000004
100176>>>>>>>>>
100176>>>>>>>>>// MAPILogon() flags.
100176>>>>>>>>>Define MAPI_LOGON_UI         For |CI$00000001 // Display logon UI
100176>>>>>>>>>Define MAPI_PASSWORD_UI      For |CI$00020000 // prompt for password only
100176>>>>>>>>>Define MAPI_NEW_SESSION      For |CI$00000002 // Don't use shared session
100176>>>>>>>>>Define MAPI_FORCE_DOWNLOAD   For |CI$00001000 // Get new mail before return
100176>>>>>>>>>Define MAPI_ALLOW_OTHERS     For |CI$00000008 // Make this a shared session
100176>>>>>>>>>Define MAPI_EXPLICIT_PROFILE For |CI$00000010 // Don't use default profile
100176>>>>>>>>>Define MAPI_EXTENDED         For |CI$00000020 // Extended MAPI Logon
100176>>>>>>>>>Define MAPI_USE_DEFAULT      For |CI$00000040 // Use default profile in logon
100176>>>>>>>>>
100176>>>>>>>>>Define MAPI_SIMPLE_DEFAULT  For (MAPI_LOGON_UI + MAPI_FORCE_DOWNLOAD + MAPI_ALLOW_OTHERS)
100176>>>>>>>>>Define MAPI_SIMPLE_EXPLICIT For (MAPI_NEW_SESSION + MAPI_FORCE_DOWNLOAD + MAPI_EXPLICIT_PROFILE)
100176>>>>>>>>>
100176>>>>>>>>>// MAPILogoff() flags.
100176>>>>>>>>>Define MAPI_LOGOFF_SHARED For |CI$00000001 // Close all shared sessions
100176>>>>>>>>>Define MAPI_LOGOFF_UI     For |CI$00000002 // It's OK to present UI
100176>>>>>>>>>
100176>>>>>>>>>// MAPISendMail() flags.
100176>>>>>>>>>Define MAPI_LOGON_UI    For |CI$00000001 // Display logon UI
100176>>>>>>>>>Define MAPI_NEW_SESSION For |CI$00000002 // Don't use shared session
100176>>>>>>>>>
100176>>>>>>>>>Define MAPI_DIALOG      For |CI$00000008 // Display a send note UI
100176>>>>>>>>>Define MAPI_USE_DEFAULT For |CI$00000040 // Use default profile in logon
100176>>>>>>>>>
100176>>>>>>>>>// MAPIFindNext() flags.
100176>>>>>>>>>Define MAPI_UNREAD_ONLY    For |CI$00000020 // Only unread messages
100176>>>>>>>>>Define MAPI_GUARANTEE_FIFO For |CI$00000100 // use date order
100176>>>>>>>>>Define MAPI_LONG_MSGID     For |CI$00004000 // allow 512 char returned ID
100176>>>>>>>>>
100176>>>>>>>>>// MAPIReadMail() flags.
100176>>>>>>>>>Define MAPI_PEEK            For |CI$00000080 // Do not mark as read.
100176>>>>>>>>>Define MAPI_SUPPRESS_ATTACH For |CI$00000800 // header + body, no files
100176>>>>>>>>>Define MAPI_ENVELOPE_ONLY   For |CI$00000040 // Only header information
100176>>>>>>>>>Define MAPI_BODY_AS_FILE    For |CI$00000200
100176>>>>>>>>>
100176>>>>>>>>>// MAPISaveMail() flags.
100176>>>>>>>>>Define MAPI_LOGON_UI    For |CI$00000001 // Display logon UI
100176>>>>>>>>>Define MAPI_NEW_SESSION For |CI$00000002 // Don't use shared session
100176>>>>>>>>>Define MAPI_LONG_MSGID  For |CI$00004000 // allow 512 char returned ID
100176>>>>>>>>>
100176>>>>>>>>>// MAPIAddress() flags.
100176>>>>>>>>>Define MAPI_LOGON_UI    For |CI$00000001 // Display logon UI
100176>>>>>>>>>Define MAPI_NEW_SESSION For |CI$00000002 // Don't use shared session
100176>>>>>>>>>
100176>>>>>>>>>// MAPIDetails() flags.
100176>>>>>>>>>Define MAPI_LOGON_UI    For |CI$00000001 // Display logon UI
100176>>>>>>>>>Define MAPI_NEW_SESSION For |CI$00000002 // Don't use shared session
100176>>>>>>>>>Define MAPI_AB_NOMODIFY For |CI$00000400 // Don't allow mods of AB entries
100176>>>>>>>>>
100176>>>>>>>>>// MAPIResolveName() flags.
100176>>>>>>>>>Define MAPI_LOGON_UI    For |CI$00000001 // Display logon UI
100176>>>>>>>>>Define MAPI_NEW_SESSION For |CI$00000002 // Don't use shared session
100176>>>>>>>>>Define MAPI_DIALOG      For |CI$00000008 // Prompt for choices if ambiguous
100176>>>>>>>>>Define MAPI_AB_NOMODIFY For |CI$00000400 // Don't allow mods of AB entries
100176>>>>>>>>>
100176>>>>>>>>>Define SUCCESS_SUCCESS                 For 0
100176>>>>>>>>>Define MAPI_USER_ABORT                 For 1
100176>>>>>>>>>Define MAPI_E_USER_ABORT               For MAPI_USER_ABORT
100176>>>>>>>>>Define MAPI_E_FAILURE                  For 2
100176>>>>>>>>>Define MAPI_E_LOGON_FAILURE            For 3
100176>>>>>>>>>Define MAPI_E_LOGIN_FAILURE            For MAPI_E_LOGON_FAILURE
100176>>>>>>>>>Define MAPI_E_DISK_FULL                For 4
100176>>>>>>>>>Define MAPI_E_INSUFFICIENT_MEMORY      For 5
100176>>>>>>>>>Define MAPI_E_ACCESS_DENIED            For 6
100176>>>>>>>>>Define MAPI_E_TOO_MANY_SESSIONS        For 8
100176>>>>>>>>>Define MAPI_E_TOO_MANY_FILES           For 9
100176>>>>>>>>>Define MAPI_E_TOO_MANY_RECIPIENTS      For 10
100176>>>>>>>>>Define MAPI_E_ATTACHMENT_NOT_FOUND     For 11
100176>>>>>>>>>Define MAPI_E_ATTACHMENT_OPEN_FAILURE  For 12
100176>>>>>>>>>Define MAPI_E_ATTACHMENT_WRITE_FAILURE For 13
100176>>>>>>>>>Define MAPI_E_UNKNOWN_RECIPIENT        For 14
100176>>>>>>>>>Define MAPI_E_BAD_RECIPTYPE            For 15
100176>>>>>>>>>Define MAPI_E_NO_MESSAGES              For 16
100176>>>>>>>>>Define MAPI_E_INVALID_MESSAGE          For 17
100176>>>>>>>>>Define MAPI_E_TEXT_TOO_LARGE           For 18
100176>>>>>>>>>Define MAPI_E_INVALID_SESSION          For 19
100176>>>>>>>>>Define MAPI_E_TYPE_NOT_SUPPORTED       For 20
100176>>>>>>>>>Define MAPI_E_AMBIGUOUS_RECIPIENT      For 21
100176>>>>>>>>>Define MAPI_E_AMBIG_RECIP              For MAPI_E_AMBIGUOUS_RECIPIENT
100176>>>>>>>>>Define MAPI_E_MESSAGE_IN_USE           For 22
100176>>>>>>>>>Define MAPI_E_NETWORK_FAILURE          For 23
100176>>>>>>>>>Define MAPI_E_INVALID_EDITFIELDS       For 24
100176>>>>>>>>>Define MAPI_E_INVALID_RECIPS           For 25
100176>>>>>>>>>Define MAPI_E_NOT_SUPPORTED            For 26
100176>>>>>>>Use WinKern.pkg
100176>>>>>>>
100176>>>>>>>External_Function MAPILogon "MAPILogon" Mapi32.Dll ;   Integer ulUIParam ;   Pointer lpszProfileName ;   Pointer lpszPassword ;   Integer flFlags ;   Integer ulReserved ;   Pointer lplhSession ;   Returns Integer
100177>>>>>>>External_Function MAPILogoff "MAPILogoff" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Integer flFlags ;   Integer ulReserved ;   Returns Integer
100178>>>>>>>External_Function MAPIFindNext "MAPIFindNext" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpszMessageType ;   Pointer lpszSeedMessageID ;   Integer flFlags ;   Integer ulReserved ;   Pointer lpszMessageID ;   Returns Integer
100179>>>>>>>External_Function MAPIFreeBuffer "MAPIFreeBuffer" Mapi32.Dll ;   Pointer pv ;   Returns Integer
100180>>>>>>>External_Function MAPIReadMail "MAPIReadMail" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpszMessageID ;   Integer flFlags ;   Integer ulReserved ;   Pointer lppMessage ;   Returns Integer
100181>>>>>>>External_Function MAPIAddress "MAPIAddress" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpszCaption ;   Integer nEditFields ;   Pointer lpszLabels ;   Integer nRecips ;   Pointer lpRecips ;   Integer flFlags ;   Integer ulReserved ;   Pointer lpnNewRecips ;   Pointer lppNewRecips ;   Returns Integer
100182>>>>>>>External_Function MAPIResolveName "MAPIResolveName" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpszName ;   Integer flFlags ;   Integer ulReserved ;   Pointer lppRecip ;   Returns Integer
100183>>>>>>>External_Function MAPISendMail "MAPISendMail" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpMessage ;   Integer flFlags ;   Integer ulReserved ;   Returns Integer
100184>>>>>>>External_Function MAPISaveMail "MAPISaveMail" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpMessage ;   Integer flFlags ;   Integer ulReserved ;   Pointer lpszMessageID ;   Returns Integer
100185>>>>>>>External_Function MAPIDeleteMail "MAPIDeleteMail" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpszMessageID ;   Integer flFlags ;   Integer ulReserved ;   Returns Integer
100186>>>>>>>External_Function MAPISendDocuments "MAPISendDocuments" Mapi32.Dll ;   Integer ulUIParam ;   Pointer lpszDelimChar ;   Pointer lpszFullPaths ;   Pointer lpszFileNames ;   Integer ulReserved ;   Returns Integer
100187>>>>>>>External_Function MAPIDetails "MAPIDetails" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpRecip ;   Integer flFlags ;   Integer ulReserved ;   Returns Integer
100188>>>>>>>
100188>>>>>>>External_Function ShellExecute "ShellExecuteA" Shell32.Dll ;   Handle hwnd ;   String sOperation ;   String sFile ;   String sParameters ;   String sDirectory ;   Integer nShowCmd ;   Returns VOID_TYPE
100189>>>>>Use DFBTRDRV.PKG
100189>>>>>Use MSSqldrv.pkg
100189>>>>>Use db2_drv.pkg
100189>>>>>Use odbc_drv.pkg
100189>>>>>Use seq_chnl.pkg
100189>>>>>//Use Std_help.pkg
100189>>>>>
100189>>>>>Register_Function phoWorkspace Returns Handle
100189>>>>>Register_Function Help_filename Returns String
100189>>>>>Register_Function GetHelpFile Returns String
100189>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
100189>>>>>
100189>>>>>// Use of Mertech drivers:
100189>>>>>// Ad the line "Define DUF_Use_Mertech_Drivers" prior "Use" of this package to your source code if using Mertech drivers!
100189>>>>>    Use mertech.inc
100189>>>>>
100189>>>>>
100189>>>>>
100189>>>>>
100189>>>>>
100189>>>>>// *** Constant Declarations: ***
100189>>>>>//
100189>>>>>
100189>>>>>// NOTE: These text constants should be added to the various "Language_xxx.inc" files:
100189>>>>>
100189>>>>>
100189>>>>>
100189>>>>>
100189>>>>>
100189>>>>>// 2016-12-12, Samuel:  Added section for Portuguese
100189>>>>>
100189>>>>>
100189>>>>>
100189>>>>>
100189>>>>>
100189>>>>>
100189>>>>>
100189>>>>>
100189>>>>>
100189>>>>>// System icon menu constants. If the upper left hand
100189>>>>>// icon in dialogs is clicked, shadow all menu items except Move & Close.
100189>>>>>    Define SC_RESTORE  for |CI$F120
100189>>>>>    Define SC_MOVE     for |CI$F010
100189>>>>>    Define SC_SIZE     for |CI$F000
100189>>>>>    Define SC_MINIMIZE for |CI$F020
100189>>>>>    Define SC_MAXIMIZE for |CI$F030
100189>>>>>    Define SC_CLOSE    for |CI$F060
100189>>>>>    Define SC_KEYMENU  for |CI$F100
100189>>>>>    Define SC_NEXTWINDOW for |CI$F040
100189>>>>>    Define SC_PREVWINDOW for |CI$F050
100189>>>>>
100189>>>>>// *** Struct Declarations: ***
100189>>>>>//#IF (Required_RT_Version > 18) // Temp! Should be "19". Fix after 19.1 beta phase1
100189>>>>>//#ELSE
100189>>>>>Struct tWinMemoryStatusEx
100189>>>>>    UInteger dwLength
100189>>>>>    UInteger dwMemoryLoad
100189>>>>>    UBigInt ullTotalPhys
100189>>>>>    UBigInt ullAvailPhys
100189>>>>>    UBigInt ullTotalPageFile
100189>>>>>    UBigInt ullAvailPageFile
100189>>>>>    UBigInt ullTotalVirtual
100189>>>>>    UBigInt ullAvailVirtual
100189>>>>>    UBigInt ullAvailExtendedVirtual
100189>>>>>End_Struct
100189>>>>>//#ENDIF
100189>>>>>
100189>>>>>// OBSOLETE STRUCTURE AND WINDOWS API CALL. KEPT FOR BACKWARDS COMPATIBILITY
100189>>>>>//Type MEMORYSTATUS
100189>>>>>//   Field MEMORYSTATUS.dwLength         as DWord // sizeof(MEMORYSTATUS)
100189>>>>>//   Field MEMORYSTATUS.dwMemoryLoad     as DWord // percent Of memory in use
100189>>>>>//   Field MEMORYSTATUS.dwTotalPhys      as DWord // bytes Of physical memory
100189>>>>>//   Field MEMORYSTATUS.dwAvailPhys      as DWord // free physical memory bytes
100189>>>>>//   Field MEMORYSTATUS.dwTotalPageFile  as DWord // bytes Of paging file
100189>>>>>//   Field MEMORYSTATUS.dwAvailPageFile  as DWord // free bytes Of paging file
100189>>>>>//   Field MEMORYSTATUS.dwTotalVirtual   as DWord // user bytes Of address space
100189>>>>>//   Field MEMORYSTATUS.dwAvailVirtual   as DWord // free user bytes
100189>>>>>//End_Type
100189>>>>>
100189>>>>>// *** External Function calls: ***
100189>>>>>//
100189>>>>>    External_Function GetSystemMenu "GetSystemMenu" User32.dll Handle hWnd Boolean bRevert Returns Handle
100190>>>>>
100190>>>>>    External_Function GetRemoveMenu "RemoveMenu" user32.dll Handle hWnd UInteger uPosition UInteger uFlags Returns Handle
100191>>>>>
100191>>>>>    External_Function WNetGetUser "WNetGetUserA" MPR.DLL Pointer lpName Pointer lpUser_Name Pointer lpLength Returns DWord
100192>>>>>
100192>>>>>    External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
100193>>>>>
100193>>>>>    External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
100194>>>>>
100194>>>>>// *** Global/Desktop Function Declarations: ***
100194>>>>>
100194>>>>>Function ComputerName for Desktop Returns String
100196>>>>>    String sName
100196>>>>>    Get_Environment "COMPUTERNAME" to sName
100197>>>>>>
100197>>>>>    Function_Return sName
100198>>>>>End_Function
100199>>>>>
100199>>>>>Function Network_User_Name for cDesktop Returns String
100201>>>>>    String sName
100201>>>>>    Get_Environment "USERNAME" to sName
100202>>>>>>
100202>>>>>    Function_Return sName
100203>>>>>End_Function
100204>>>>>
100204>>>>>// *** Class Declarations: ***
100204>>>>>//
100204>>>>>Class cBitmapContainerVDFLink is a BitmapContainer
100205>>>>>    Procedure Mouse_Click Integer iWindowNumber Integer iPosition
100207>>>>>        Send Mouse_Up iWindowNumber iPosition
100208>>>>>    End_Procedure
100209>>>>>    Procedure Mouse_Up Integer iWindowNumber Integer iPosition
100211>>>>>        Forward Send Mouse_Up iWindowNumber iPosition
100213>>>>>        Send Show_HomePage "http://www.dataaccess.com/"
100214>>>>>    End_Procedure
100215>>>>>End_Class
100216>>>>>
100216>>>>>Class cCopyEditorContentButton is a Button
100217>>>>>    Procedure Construct_Object
100219>>>>>        Forward Send Construct_Object
100221>>>>>        Property Handle phoEditorHandle
100222>>>>>        Set psToolTip to C_$DescCopy
100223>>>>>    End_Procedure
100224>>>>>
100224>>>>>    Procedure CopyToWindowsClipboard
100226>>>>>        String sValue
100226>>>>>        Handle hoEditor
100226>>>>>        Boolean bCanCopy
100226>>>>>        Address aEditorAddress
100226>>>>>
100226>>>>>        Get phoEditorHandle to hoEditor
100227>>>>>        Send Select_All of hoEditor
100228>>>>>        Get CanCopy of hoEditor to bCanCopy
100229>>>>>        If (bCanCopy = True) Begin
100231>>>>>            Get paValue of hoEditor to aEditorAddress
100232>>>>>            Move aEditorAddress to sValue
100233>>>>>            Send Copy   of hoEditor
100234>>>>>            // Remove the selection after text is copied to the clipboard.
100234>>>>>            Send Beginning_of_Data of hoEditor
100235>>>>>            Send Info_Box C_$CopyToClipboard_Text
100236>>>>>        End
100236>>>>>>
100236>>>>>    End_Procedure
100237>>>>>End_Class
100238>>>>>
100238>>>>>Class SysinfoDisplay is a cTextEdit
100239>>>>>    Procedure Construct_Object
100241>>>>>        Forward Send Construct_Object
100243>>>>>
100243>>>>>        Set Size to 104 247
100244>>>>>        Set Location to 4 6
100245>>>>>        Set Border_Style to Border_None
100246>>>>>        Set peAnchors to anAll
100247>>>>>        Set Read_Only_State to True
100248>>>>>        Set pbWrap to True
100249>>>>>    End_Procedure
100250>>>>>
100250>>>>>    // Augmented class message to adjust certain text strings that are wrong...
100250>>>>>
100250>>>>>    Procedure AppendTextLn String sText
100252>>>>>        String sWorkspaceWSFile
100252>>>>>
100252>>>>>        // Only works for English:
100252>>>>>        If (ghoApplication > 0) Begin
100254>>>>>            If (sText contains "Workspace Name") Begin
100256>>>>>                Move "Workspace Config Filename:" to sText
100257>>>>>                Get psWorkspaceWSFile of (phoWorkspace(ghoApplication)) to sWorkspaceWSFile
100258>>>>>                Move (sText * sWorkspaceWSFile) to sText
100259>>>>>            End
100259>>>>>>
100259>>>>>        End
100259>>>>>>
100259>>>>>        Send AppendText sText
100260>>>>>        Send AppendText (character(10))
100261>>>>>    End_Procedure
100262>>>>>
100262>>>>>    //****************************************************************************
100262>>>>>    // $Module type: PROCEDURE
100262>>>>>    // $Module name: Show_Current_Directory
100262>>>>>    // $Author     : VOO
100262>>>>>    // Created     : 06-10-96 @ 15:24
100262>>>>>    //
100262>>>>>    // Description
100262>>>>>    //    This method will show the name Of the current directory in the system
100262>>>>>    //    information box
100262>>>>>    //
100262>>>>>    // $Rev History
100262>>>>>    //    06-10-96  Module header created
100262>>>>>    //****************************************************************************
100262>>>>>    Procedure Show_Current_Directory
100264>>>>>        String sDir
100264>>>>>
100264>>>>>        Get_Current_Directory To sDir
100265>>>>>
100265>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
100266>>>>>    End_Procedure
100267>>>>>
100267>>>>>    Procedure Show_Windows_Directory
100269>>>>>        String sWindir
100269>>>>>
100269>>>>>        Get_Windows_Directory To sWindir
100270>>>>>
100270>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
100271>>>>>    End_Procedure
100272>>>>>
100272>>>>>    Procedure Show_Current_User
100274>>>>>        Send AppendTextLn (SFormat (C_$Computer_Name, ComputerName (Self)))
100275>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
100276>>>>>    End_Procedure
100277>>>>>
100277>>>>>    Procedure Show_Number_Format
100279>>>>>        Integer iFormat
100279>>>>>        String sFormatText
100279>>>>>
100279>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
100282>>>>>        Move (Character (iFormat)) To sFormatText
100283>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
100284>>>>>
100284>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
100287>>>>>        Move (Character (iFormat)) to sFormatText
100288>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
100289>>>>>    End_Procedure
100290>>>>>
100290>>>>>    Procedure Show_Filelist_Name
100292>>>>>        String sFilename
100292>>>>>
100292>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
100295>>>>>
100295>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
100296>>>>>    End_Procedure
100297>>>>>
100297>>>>>    Procedure Show_Lock_Delay
100299>>>>>        Integer iLockdelay
100299>>>>>
100299>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
100302>>>>>
100302>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
100303>>>>>    End_Procedure
100304>>>>>
100304>>>>>    Procedure Show_Lock_Timeout
100306>>>>>        Integer iLockTimeout
100306>>>>>
100306>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
100309>>>>>
100309>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
100310>>>>>    End_Procedure
100311>>>>>
100311>>>>>    Procedure Show_Screen_Size
100313>>>>>        Integer iYscreensize iXscreensize
100313>>>>>
100313>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) To iXscreensize
100314>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) To iYscreensize
100315>>>>>
100315>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
100316>>>>>    End_Procedure
100317>>>>>
100317>>>>>    Procedure Show_Page_Size
100319>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
100320>>>>>    End_procedure
100321>>>>>
100321>>>>>    Procedure Show_Date
100323>>>>>        Date dToday
100323>>>>>
100323>>>>>        Sysdate dToday
100324>>>>>
100324>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
100325>>>>>    End_procedure
100326>>>>>
100326>>>>>    Procedure Show_Date_Format
100328>>>>>        Integer iDateFormat
100328>>>>>        String sDateFormat
100328>>>>>
100328>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
100331>>>>>        Case Begin
100331>>>>>            Case (iDateFormat = DF_DATE_USA)
100333>>>>>                Move C_$USA To sDateFormat
100334>>>>>                Case Break
100335>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
100338>>>>>                Move C_$European To sDateFormat
100339>>>>>                Case Break
100340>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
100343>>>>>                Move C_$Military To sDateFormat
100344>>>>>                Case Break
100345>>>>>            Case Else
100345>>>>>                Move C_$UnknownDateType To sDateFormat
100346>>>>>                Case Break
100347>>>>>        Case End
100347>>>>>
100347>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
100348>>>>>    End_Procedure
100349>>>>>
100349>>>>>    // 2013-08-14 NGS
100349>>>>>    // Unformatted numeric values shown doesn't look good. These looks much better.
100349>>>>>    Procedure Show_Systemresources
100351>>>>>        tWinMemoryStatusEx MemoryStatusInfo
100351>>>>>        tWinMemoryStatusEx MemoryStatusInfo
100351>>>>>        Integer iRetval
100351>>>>>        Number nValue
100351>>>>>        String sValue
100351>>>>>
100351>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
100352>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
100353>>>>>        If (iRetval = 0) Begin
100355>>>>>            Move (ShowLastError ()) to iRetval
100356>>>>>            Procedure_Return
100357>>>>>        End
100357>>>>>>
100357>>>>>
100357>>>>>        Send AppendTextLn ""
100358>>>>>        Move MemoryStatusInfo.ullTotalPhys to nValue
100359>>>>>
100359>>>>>        // Show memory in Gigabytes:
100359>>>>>        Move (nValue/1024/1024/1024) to nValue
100360>>>>>        Move (Round(nValue)) to nValue
100361>>>>>        Get FormatNumber nValue 2 to sValue
100362>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, (sValue * "GB")))
100363>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, String(MemoryStatusInfo.dwMemoryLoad) * "%"))
100364>>>>>
100364>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0))
100364>>>>>        Move (Real(MemoryStatusInfo.ullAvailPhys) / Real(MemoryStatusInfo.ullTotalPhys) * 100.0) to nValue
100365>>>>>        Move (Round(nValue)) to nValue
100366>>>>>        Get FormatNumber nValue 0 to sValue
100367>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, (sValue * "%")))
100368>>>>>
100368>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0))
100368>>>>>        Move (Real(MemoryStatusInfo.ullAvailPageFile) / Real(MemoryStatusInfo.ullTotalPageFile) * 100.0) to nValue
100369>>>>>        Move (Round(nValue)) to nValue
100370>>>>>        Get FormatNumber nValue 0 to sValue
100371>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, (sValue * "%")))
100372>>>>>
100372>>>>>//        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0))
100372>>>>>        Move (Real(MemoryStatusInfo.ullAvailVirtual) / Real(MemoryStatusInfo.ullTotalVirtual) * 100.0) to nValue
100373>>>>>        Move (Round(nValue)) to nValue
100374>>>>>        Get FormatNumber nValue 0 to sValue
100375>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, (sValue * "%")))
100376>>>>>
100376>>>>>        // Add an empty row after the memory information:
100376>>>>>        Send AppendTextLn ""
100377>>>>>    End_Procedure
100378>>>>>
100378>>>>>    Procedure Show_Registration
100380>>>>>        String sRegName
100380>>>>>        Integer iSN iUsersMax iUserCount
100380>>>>>
100380>>>>>        Registration sRegName iSN
100381>>>>>>
100381>>>>>        Get_Licensed_Max_Users to iUsersMax
100382>>>>>        Get_Current_User_Count to iUserCount
100383>>>>>
100383>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
100384>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
100385>>>>>        Send AppendTextLn (SFormat (C_$Current_User_Count, iUserCount))
100386>>>>>        Send AppendTextLn (SFormat (C_$Max_Licensed_User_Count, iUsersMax))
100387>>>>>    End_Procedure
100388>>>>>
100388>>>>>    //****************************************************************************
100388>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
100388>>>>>    // To the workspace object passing the an object and message To send back
100388>>>>>    // To this object. It is expected that the workspace object will send this
100388>>>>>    // message for every line Of information it wants displayed (passing the
100388>>>>>    // information To be displayed
100388>>>>>    //****************************************************************************
100388>>>>>    Register_Procedure EnumerateWorkspaceData Integer hObjId Integer hmMessId
100388>>>>>
100388>>>>>    Procedure Show_ServicePack
100390>>>>>        String sKey sVersion sDataFlex
100390>>>>>        Handle hoRegistry
100390>>>>>        Boolean bExists bOpened
100390>>>>>
100390>>>>>        Move "DataFlex"        to sDataFlex
100391>>>>>
100391>>>>>        Get Create U_cRegistry to hoRegistry
100392>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
100393>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
100394>>>>>        Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
100395>>>>>
100395>>>>>        If (bExists) Begin
100397>>>>>            Move ("SOFTWARE\Wow6432Node\Data Access Worldwide\" + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
100398>>>>>        End
100398>>>>>>
100398>>>>>        Else Begin
100399>>>>>            Move ("SOFTWARE\Data Access Worldwide\"             + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
100400>>>>>        End
100400>>>>>>
100400>>>>>        Get KeyExists of hoRegistry sKey to bExists
100401>>>>>        If (bExists) Begin
100403>>>>>            Get OpenKey of hoRegistry sKey to bOpened
100404>>>>>            If (bOpened) Begin
100406>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
100407>>>>>                If (bExists) Begin
100409>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersion
100410>>>>>                End
100410>>>>>>
100410>>>>>                Send CloseKey of hoRegistry
100411>>>>>            End
100411>>>>>>
100411>>>>>        End
100411>>>>>>
100411>>>>>        Send Destroy of hoRegistry
100412>>>>>
100412>>>>>        If (sVersion <> "") Begin
100414>>>>>           Send AppendTextLn sVersion
100415>>>>>           Send AppendTextLn ""
100416>>>>>        End
100416>>>>>>
100416>>>>>    End_Procedure
100417>>>>>
100417>>>>>    Procedure Show_WorkspaceInformation
100419>>>>>        Integer hoWorkspace
100419>>>>>
100419>>>>>        If (ghoApplication <> 0) Begin
100421>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
100422>>>>>            If (hoWorkspace <> 0) Begin
100424>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self msg_AppendTextLn
100425>>>>>            End
100425>>>>>>
100425>>>>>        End
100425>>>>>>
100425>>>>>    End_Procedure
100426>>>>>
100426>>>>>    //****************************************************************************
100426>>>>>    // If connection ids are used, we will send the message EnumerateConnections
100426>>>>>    // to the connection manager object passing the an object and message to send
100426>>>>>    // back to this object. It is expected that the connection manager object will
100426>>>>>    // send this message for every line Of information it wants displayed (passing
100426>>>>>    // the information To be displayed
100426>>>>>    //****************************************************************************
100426>>>>>    Register_Procedure EnumerateConnections Integer hObjId Integer hmMessId
100426>>>>>
100426>>>>>    Procedure Show_ConnectionIdInformation
100428>>>>>        If (ghoConnection > 0) Begin
100430>>>>>            Send EnumerateConnections of ghoConnection Self (RefProc(AppendTextLn))
100431>>>>>            Send AppendTextLn ""
100432>>>>>        End
100432>>>>>>
100432>>>>>    End_Procedure
100433>>>>>
100433>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
100435>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
100436>>>>>    End_Function
100437>>>>>
100437>>>>>    Procedure Show_Versions
100439>>>>>        Integer iVersion iRevision iBuild
100439>>>>>
100439>>>>>        Version_information iVersion iRevision iBuild
100441>>>>>
100441>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(self,iVersion,iRevision,iBuild) ))
100442>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
100443>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
100444>>>>>    End_Procedure
100445>>>>>
100445>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
100447>>>>>        Boolean bOK
100447>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
100448>>>>>        Function_Return bOK
100449>>>>>    End_Function
100450>>>>>
100450>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
100452>>>>>        Boolean bOK
100452>>>>>        Move (sDriverID = SQLFLEX or sDriverID = ORAFLEX or sDriverID = MDSPgSQL or sDriverID = MySQLFlex) to bOK
100453>>>>>        Function_Return bOK
100454>>>>>    End_Function
100455>>>>>
100455>>>>>    //***
100455>>>>>    //*** BW
100455>>>>>    //*** Procedure: Show_Drivers
100455>>>>>    //*** Purpose  : Show loaded database drivers
100455>>>>>    //***
100455>>>>>
100455>>>>>    Procedure Show_Drivers
100457>>>>>        String sDriverID sVersion sClient sValue
100457>>>>>        Integer iNumberOfDrivers iDriver iClient iUsersMax iSerialNo iNumServers iCount
100457>>>>>        Handle hoCLIHandler hoBtrvHandler
100457>>>>>        Boolean bStudioLicense bIsDAWDriver bIsMertechDriver
100457>>>>>
100457>>>>>        Move False to bStudioLicense
100458>>>>>
100458>>>>>        Get Create U_cCLIHandler      to hoCLIHandler
100459>>>>>        Get Create U_cDFBtrDrvHandler to hoBtrvHandler
100460>>>>>
100460>>>>>        // For testing purposes:
100460>>>>>//        Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
100460>>>>>//        Load_Driver MSSQLDRV_ID
100460>>>>>//        Load_Driver ODBC_DRV_ID
100460>>>>>//        Load_Driver DB2_DRV_ID
100460>>>>>//        Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
100460>>>>>//
100460>>>>>//        #IFDEF DUF_Use_Mertech_Drivers
100460>>>>>//            Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
100460>>>>>//            Load_Driver SQLFLEX
100460>>>>>//            Load_Driver MDSPgSQL
100460>>>>>//            Load_Driver MDSMySQL
100460>>>>>//            Load_Driver ORAFLEX
100460>>>>>//            Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
100460>>>>>//        #ENDIF
100460>>>>>        Move False to Err
100461>>>>>
100461>>>>>        // Loop through all loaded drivers.
100461>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
100464>>>>>        If (iNumberOfDrivers > 1) Begin
100466>>>>>            Send AppendTextLn ""
100467>>>>>        End
100467>>>>>>
100467>>>>>        For iDriver from 1 to iNumberOfDrivers
100473>>>>>>
100473>>>>>            // For some weird reason it can happen that - when using Mertech drivers - that the driver index
100473>>>>>            // was increased in the CLI array, but it has no value. In that case a "Bad parameter..." error
100473>>>>>            // would be thrown, so we safeguard from that here.
100473>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
100474>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
100477>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
100478>>>>>            Get IsDAWSQLDriver sDriverID to bIsDAWDriver
100479>>>>>            Get IsMertechDriver sDriverID to bIsMertechDriver
100480>>>>>
100480>>>>>            If (sDriverID = DFBTRDRV_ID or bIsDAWDriver = True or bIsMertechDriver = True) Begin
100482>>>>>
100482>>>>>                // Pervasive/Btrieve database
100482>>>>>                If (sDriverID = DFBTRDRV_ID) Begin
100484>>>>>                    Get CKRevision of hoBtrvHandler to sVersion
100485>>>>>                    Get PSQLLocalEngineVersionInfo of hoBtrvHandler 0 to sClient
100486>>>>>                    If (sClient <> "0.0.0") Begin
100488>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Local_Engine_Version, sClient))
100489>>>>>                    End
100489>>>>>>
100489>>>>>                    Get PSQLServerEngineVersionInfo of hoBtrvHandler 0 to sClient
100490>>>>>                    If (sClient <> "0.0.0") Begin
100492>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Server_Engine_Version, sClient))
100493>>>>>                    End
100493>>>>>>
100493>>>>>                End
100493>>>>>>
100493>>>>>
100493>>>>>                Else Begin
100494>>>>>                    Set psDriverID of hoCLIHandler to sDriverID
100495>>>>>                    Move 0 to iNumServers
100496>>>>>                    If (sDriverID <> DATAFLEX_ID) Begin
100498>>>>>                        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iNumServers
100501>>>>>                    End
100501>>>>>>
100501>>>>>
100501>>>>>                    If (bIsDAWDriver = True) Begin
100503>>>>>                        If (sDriverID = MSSQLDRV_ID) Begin
100505>>>>>                            // This info is only available for the MS SQL driver:
100505>>>>>                            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClient
100508>>>>>                            If (iClient = 13) Begin
100510>>>>>                                Move C_$SQLSERVER2016DRVRSTR              to sClient
100511>>>>>                            End
100511>>>>>>
100511>>>>>                            If (iClient = 12) Begin
100513>>>>>                                Move C_$SQLSERVER2014DRVRSTR              to sClient
100514>>>>>                            End
100514>>>>>>
100514>>>>>                            If (iClient = 11) Begin
100516>>>>>                                Move C_$SQL_Server_Native_Client_11_0     to sClient
100517>>>>>                            End
100517>>>>>>
100517>>>>>                            If (iClient = 10) Begin
100519>>>>>                                Move C_$SQL_Server_Native_Client_10_0     to sClient
100520>>>>>                            End
100520>>>>>>
100520>>>>>                            If (iClient = 9) Begin
100522>>>>>                                Move C_$SQL_Native_Client                 to sClient
100523>>>>>                            End
100523>>>>>>
100523>>>>>                            If (iClient = 8) Begin
100525>>>>>                                Move C_$SQL_Server_SQL_Server_2000_client to sClient
100526>>>>>                            End
100526>>>>>>
100526>>>>>                            If (sClient <> "") Begin
100528>>>>>                                Move ("    " + sClient) to sClient
100529>>>>>                            End
100529>>>>>>
100529>>>>>                        End
100529>>>>>>
100529>>>>>
100529>>>>>                        Get CKRevision of hoCLIHandler to sVersion
100530>>>>>                    End
100530>>>>>>
100530>>>>>
100530>>>>>                    If (bIsMertechDriver = True) Begin
100532>>>>>                        GET_DRIVER_REVISION to sVersion
100545>>>>>>
100545>>>>>                    End
100545>>>>>>
100545>>>>>
100545>>>>>                    // If the serialnumber is = 0, it means that the
100545>>>>>                    // Studio licens is in use and there is no
100545>>>>>                    // number of max users defined because the driver is
100545>>>>>                    // relying on the info from the VDF license.
100545>>>>>                    If (bStudioLicense = False) Begin
100547>>>>>                        Get SerialNumber of hoCLIHandler to iSerialNo
100548>>>>>                        Move (iSerialNo = 0) to bStudioLicense
100549>>>>>                    End
100549>>>>>>
100549>>>>>                End
100549>>>>>>
100549>>>>>                Send AppendTextLn (SFormat (C_$DatabaseDriver, (sDriverID * "-" * (C_$Version + ": " + sVersion))))
100550>>>>>                If (iNumServers <> 0) Begin
100552>>>>>                    For iCount from 1 to iNumServers
100558>>>>>>
100558>>>>>                        Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
100561>>>>>                        Send AppendTextLn ("    " + "Server/DSN:" * sValue)
100562>>>>>                    Loop
100563>>>>>>
100563>>>>>                End
100563>>>>>>
100563>>>>>                If (sClient <> "" and sDriverID = MSSQLDRV_ID) Begin
100565>>>>>                    Send AppendTextLn sClient
100566>>>>>                End
100566>>>>>>
100566>>>>>            End
100566>>>>>>
100566>>>>>        Loop
100567>>>>>>
100567>>>>>
100567>>>>>        Send AppendTextLn ""
100568>>>>>        If (bStudioLicense = False) Begin
100570>>>>>            Get MaxUsers of hoCLIHandler to iUsersMax
100571>>>>>            Send AppendTextLn (SFormat (C_$Max_DbDriver_Licensed_User_Count, iUsersMax))
100572>>>>>        End
100572>>>>>>
100572>>>>>        Else Begin
100573>>>>>            Send AppendTextLn C_$VDF_Studio_License_Text
100574>>>>>        End
100574>>>>>>
100574>>>>>        Send Destroy of hoCLIHandler
100575>>>>>        Send Destroy of hoBtrvHandler
100576>>>>>    End_Procedure
100577>>>>>
100577>>>>>    Procedure Show_HelpFile
100579>>>>>        String sHelpFile
100579>>>>>        Integer eHelpType
100579>>>>>
100579>>>>>        If (ghoApplication <> 0) Begin
100581>>>>>            Get peHelpType Of ghoApplication To eHelpType
100582>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
100584>>>>>                Get GetHelpFile Of ghoHtmlHelp To sHelpFile
100585>>>>>            End
100585>>>>>>
100585>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
100588>>>>>                Get Help_filename Of Help_object_id To sHelpFile
100589>>>>>            End
100589>>>>>>
100589>>>>>            Else Begin
100590>>>>>                Move C_$ThereIsNoHelpfileDefined To sHelpFile
100591>>>>>            End
100591>>>>>>
100591>>>>>
100591>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
100592>>>>>        End
100592>>>>>>
100592>>>>>    End_Procedure
100593>>>>>
100593>>>>>    Procedure Show_EnterAsTab
100595>>>>>        Boolean bEnterKeyAsTabKey
100595>>>>>        String sText
100595>>>>>
100595>>>>>        If (ghoApplication <> 0) Begin
100597>>>>>            Get pbEnterKeyAsTabKey Of ghoApplication To bEnterKeyAsTabKey
100598>>>>>            If (bEnterKeyAsTabKey) Begin
100600>>>>>                Move "True" To sText
100601>>>>>            End
100601>>>>>>
100601>>>>>            Else Begin
100602>>>>>                Move "False" To sText
100603>>>>>            End
100603>>>>>>
100603>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
100604>>>>>        End
100604>>>>>>
100604>>>>>    End_Procedure
100605>>>>>
100605>>>>>    //****************************************************************************
100605>>>>>    // $Module type: PROCEDURE
100605>>>>>    // $Module name: Add_Focus
100605>>>>>    // $Author     : VOO
100605>>>>>    // Created     : 24-09-96 @ 19:43
100605>>>>>    //
100605>>>>>    // Description
100605>>>>>    //    During activation we will remove the old information and add the newly
100605>>>>>    //    found systeminformation
100605>>>>>    //
100605>>>>>    // $Rev History
100605>>>>>    //    24-09-96  Module header created
100605>>>>>    //****************************************************************************
100605>>>>>    Procedure Add_Focus Integer hoRoot
100607>>>>>        Forward Send Add_Focus hoRoot
100609>>>>>
100609>>>>>        Send Delete_Data
100610>>>>>
100610>>>>>        Set Changed_State To False
100611>>>>>        Set Read_Only_State To True
100612>>>>>
100612>>>>>        Send Show_Registration
100613>>>>>        Send Show_Drivers
100614>>>>>        Send AppendTextLn ""
100615>>>>>
100615>>>>>        Send Show_ServicePack
100616>>>>>        If (ghoApplication <> 0) Begin
100618>>>>>            Send Show_WorkSpaceInformation
100619>>>>>            Send Show_HelpFile
100620>>>>>            Send AppendTextLn ""
100621>>>>>        End
100621>>>>>>
100621>>>>>        Else Begin
100622>>>>>            Send AppendTextLn ""
100623>>>>>        End
100623>>>>>>
100623>>>>>
100623>>>>>        If (ghoConnection <> 0) Begin
100625>>>>>            Send Show_ConnectionIdInformation
100626>>>>>        End
100626>>>>>>
100626>>>>>
100626>>>>>        Send Show_Current_User
100627>>>>>        Send Show_Windows_Directory
100628>>>>>        Send Show_Current_Directory
100629>>>>>
100629>>>>>        // This is already shown in the workspace details,
100629>>>>>        // unless no workspace object is present:
100629>>>>>        If (ghoApplication = 0) Begin
100631>>>>>            Send Show_Filelist_Name
100632>>>>>        End
100632>>>>>>
100632>>>>>
100632>>>>>        If (ghoApplication <> 0) Begin
100634>>>>>            Send AppendTextLn ""
100635>>>>>            Send Show_EnterAsTab
100636>>>>>        End
100636>>>>>>
100636>>>>>
100636>>>>>        Send Show_Versions
100637>>>>>        Send Show_Screen_Size
100638>>>>>        Send Show_Page_Size
100639>>>>>        Send Show_Number_Format
100640>>>>>        Send Show_Date_Format
100641>>>>>        Send Show_Lock_Delay
100642>>>>>        Send Show_Lock_Timeout
100643>>>>>        Send Show_Date
100644>>>>>        Send Show_Systemresources
100645>>>>>        Send Beginning_of_Data
100646>>>>>
100646>>>>>        Set Icon to 'default.ico'
100647>>>>>    End_Procedure
100648>>>>>End_Class
100649>>>>>
100649>>>>>//****************************************************************************
100649>>>>>// $Module type: OBJECT
100649>>>>>// $Module name: Sysinfo_Dialog
100649>>>>>// $Author     : VOO
100649>>>>>// Created     : 24-09-96 @ 18:47
100649>>>>>//
100649>>>>>// Description
100649>>>>>//    This object shows the systeminformation on the screen
100649>>>>>//
100649>>>>>// $Rev History
100649>>>>>//    24-09-96  Module header created
100649>>>>>//****************************************************************************
100649>>>>>Class SysInfoDialog is a ModalPanel
100650>>>>>    Procedure Construct_Object
100652>>>>>        Forward Send Construct_Object
100654>>>>>
100654>>>>>        Set Label to C_$SystemInformation
100655>>>>>        Set Size to 140 267
100656>>>>>        Set Locate_Mode to CENTER_ON_PARENT
100657>>>>>        Set Border_Style to Border_Thick
100658>>>>>        Set Sysmenu_Icon to False
100659>>>>>
100659>>>>>        // "+1" will make the panel to paint correctly.
100659>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)) +1)
100660>>>>>
100660>>>>>        // 2014-09-14 NGS
100660>>>>>        // Added a container object around the cTexteditor
100660>>>>>        // object to get a border around the text.
100660>>>>>        Object oSysinfoDisplayContainer is a Container3d
100662>>>>>            Set Location to 2 4
100663>>>>>            Set Size to 110 255
100664>>>>>            Set Border_Style to Border_ClientEdge
100665>>>>>            Set Color to clWhite
100666>>>>>            Set peAnchors to anAll
100667>>>>>
100667>>>>>            Object oSysinfoDisplay is a SysInfoDisplay
100669>>>>>            End_Object
100670>>>>>
100670>>>>>        End_Object
100671>>>>>
100671>>>>>        Object oCloseButton is a Button
100673>>>>>            Set Label to C_$Close
100674>>>>>            Set Location to 120 210
100675>>>>>            Set Message item 0 to msg_Close_Panel
100676>>>>>            Set Default_State To True
100677>>>>>            // In case someone likes to make the AboutDialog's Border_Style to thick,
100677>>>>>            // and changes its peAnchors, we might as well prepare this object
100677>>>>>            // for that situation.
100677>>>>>            Set peAnchors to anBottomRight
100678>>>>>        End_Object
100679>>>>>
100679>>>>>        Object oCopyButton is a cCopyEditorContentButton
100681>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
100682>>>>>            Set Size to 14 50
100683>>>>>            Set Location to 120 158
100684>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
100684>>>>>            // we might as well prepare the object for it.
100684>>>>>            Set peAnchors to anBottomRight
100685>>>>>            Set phoEditorHandle to (oSysinfoDisplay(Self))
100686>>>>>        End_Object
100687>>>>>
100687>>>>>        On_Key kCancel Send Close_Panel
100688>>>>>    End_Procedure
100689>>>>>
100689>>>>>    Procedure Page Integer iPageObject
100691>>>>>        Handle hMenu
100691>>>>>        Integer iPrevState
100691>>>>>
100691>>>>>        Forward Send Page iPageObject
100693>>>>>
100693>>>>>        // Ok, this seems to have been fixed in VDF 17.1!
100693>>>>>        //
100693>>>>>    End_Procedure
100694>>>>>
100694>>>>>End_Class
100695>>>>>
100695>>>>>Class cAboutEdit is an cRichEdit
100696>>>>>    Procedure Construct_Object
100698>>>>>        Forward Send Construct_Object
100700>>>>>
100700>>>>>        Set Size to 57 153
100701>>>>>        Set Location to 8 60
100702>>>>>
100702>>>>>        Set Read_Only_State to True
100703>>>>>        Set Skip_State to True
100704>>>>>        // Font size is calculated in "Twips", which are 1/1440 of an inch,
100704>>>>>        // or 1/20 of a printer's point.
100704>>>>>//        Set piFontSize    to (9 * 20)
100704>>>>>        Set piRightMargin to (0.1 * 1440)
100705>>>>>        Set Border_Style  to Border_None
100706>>>>>    End_Procedure
100707>>>>>
100707>>>>>    // Adds a line of text to the edit object
100707>>>>>    Procedure Add_Line String sVal
100709>>>>>        String sText
100709>>>>>        Address aAddress
100709>>>>>        Get paValue to aAddress
100710>>>>>        Move aAddress to sText
100711>>>>>        Move (sText + String(sVal)) to sVal
100712>>>>>        Move (AddressOf(sVal)) to aAddress
100713>>>>>        Set paValue to aAddress
100714>>>>>    End_Procedure
100715>>>>>
100715>>>>>    // Compared to Add_Line above, this adds an extra empty line after the passed value.
100715>>>>>    // Note that we use the paValue interface,
100715>>>>>    // because the object isn't paged yet when we add the
100715>>>>>    // values and the COM edit object needs to be paged
100715>>>>>    // for the "Set Value" interface to be used.
100715>>>>>    Procedure Add_LineLn String sVal
100717>>>>>        String sText
100717>>>>>        Address aAddress
100717>>>>>        Get paValue to aAddress
100718>>>>>        Move aAddress to sText
100719>>>>>        Move (sText + String(sVal) + Character(10) + Character(13)) to sVal
100720>>>>>        Move (AddressOf(sVal)) to aAddress
100721>>>>>        Set paValue to aAddress
100722>>>>>    End_Procedure
100723>>>>>
100723>>>>>    Procedure OnLinkClicked Integer iPositionStart Integer iPositionEnd
100725>>>>>        String sLinkText
100725>>>>>        Get TextRange iPositionStart iPositionEnd to sLinkText
100726>>>>>        Send Show_HomePage sLinkText
100727>>>>>    End_Procedure
100728>>>>>
100728>>>>>End_Class
100729>>>>>
100729>>>>>// Purpose:
100729>>>>>//
100729>>>>>// Ken Ross 12/17/96 5:16PM
100729>>>>>//
100729>>>>>Class AboutDialog is a ModalPanel
100730>>>>>    Procedure Construct_Object
100732>>>>>
100732>>>>>        Forward Send Construct_Object
100734>>>>>
100734>>>>>        Set Label to C_$About
100735>>>>>        Set Size to 96 230
100736>>>>>        Set Locate_Mode To CENTER_ON_PARENT
100737>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
100738>>>>>//        Set Sysmenu_Icon to True
100738>>>>>
100738>>>>>        Object oSysInfoDialog is a SysInfoDialog
100740>>>>>        End_Object
100741>>>>>
100741>>>>>        Object oBox is a Container3d
100743>>>>>            Set Border_Style to Border_Normal
100744>>>>>            Set Size to 70 220
100745>>>>>            Set Location to 4 5
100746>>>>>            Set Color to clWhite
100747>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
100747>>>>>            // we might as well prepare the object for it.
100747>>>>>            Set peAnchors to anAll
100748>>>>>
100748>>>>>            Object oAboutGraphic is a BitmapContainer
100750>>>>>                Set Border_Style To Border_None
100751>>>>>                Set Bitmap_Style to Bitmap_Center
100752>>>>>                Set Color to clWhite
100753>>>>>                Set Size to 45 50
100754>>>>>                Set Location to 0 3
100755>>>>>            End_Object
100756>>>>>
100756>>>>>            Object oPoweredByVDFGraphic is a cBitmapContainerVDFLink
100758>>>>>                Set Border_Style to Border_None
100759>>>>>                Set Bitmap_Style to Bitmap_Center
100760>>>>>                Set Color to clWhite
100761>>>>>                Set Size to 30 55 //28 50
100762>>>>>                Set Location to 44 3
100763>>>>>            End_Object
100764>>>>>
100764>>>>>            Object oInfoList_Editor is an cAboutEdit
100766>>>>>                // In case someone wants to set the AboutDialog's Border_Style to thick,
100766>>>>>                // we might as well prepare the object for it.
100766>>>>>                Set peAnchors to anAll
100767>>>>>            End_Object
100768>>>>>
100768>>>>>            // These objects are here for backwards compatability only.
100768>>>>>            // They are not used.
100768>>>>>            Object oProductName is a TextBox
100770>>>>>                Set Label To C_$ProductName
100771>>>>>                Set Size To 10 45
100772>>>>>                Set Location To 8 53
100773>>>>>                Set Visible_State to False
100774>>>>>                Set Focus_Mode to NonFocusable
100775>>>>>            End_Object
100776>>>>>
100776>>>>>            Object oVersion is a TextBox
100778>>>>>                Set Label To C_$Version
100779>>>>>                Set Size To 10 25
100780>>>>>                Set Location To 21 53
100781>>>>>                Set Visible_State to False
100782>>>>>                Set Focus_Mode to NonFocusable
100783>>>>>            End_Object
100784>>>>>
100784>>>>>            Object oCopyright is a TextBox
100786>>>>>                Set Label To C_$Copyright
100787>>>>>                Set Size To 10 31
100788>>>>>                Set Location To 34 53
100789>>>>>                Set Visible_State to False
100790>>>>>                Set Focus_Mode to NonFocusable
100791>>>>>            End_Object
100792>>>>>
100792>>>>>            Object oAuthor is a TextBox
100794>>>>>                Set Label To C_$Author
100795>>>>>                Set Size To 10 22
100796>>>>>                Set Location To 46 53
100797>>>>>                Set Visible_State to False
100798>>>>>                Set Focus_Mode to NonFocusable
100799>>>>>            End_Object
100800>>>>>
100800>>>>>        End_Object
100801>>>>>
100801>>>>>        Object oOKButton Is A Button
100803>>>>>            On_Item C_$Close Send Close_Panel
100804>>>>>            Set Location to 78 176
100805>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
100805>>>>>            // we might as well prepare the object for it.
100805>>>>>            Set peAnchors to anBottomRight
100806>>>>>        End_Object
100807>>>>>
100807>>>>>        Object oSysInfoButton Is A Button
100809>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
100810>>>>>            Set Location to 78 123
100811>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
100811>>>>>            // we might as well prepare the object for it.
100811>>>>>            Set peAnchors to anBottomRight
100812>>>>>        End_Object
100813>>>>>
100813>>>>>        Object oCopyButton is a cCopyEditorContentButton
100815>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
100816>>>>>            Set Size to 14 50
100817>>>>>            Set Location to 78 70
100818>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
100818>>>>>            // we might as well prepare the object for it.
100818>>>>>            Set peAnchors to anBottomRight
100819>>>>>            Set phoEditorHandle to (oInfoList_Editor(Self))
100820>>>>>        End_Object
100821>>>>>
100821>>>>>        On_Key Kcancel Send KeyAction of oOKButton
100822>>>>>        Set Logo    to "DacAbout.bmp"  // Square bitmaps of 80x80 work best
100823>>>>>//        Set LogoVDF to "PoweredByDataFlex.bmp"
100823>>>>>        Set LogoVDF to "PoweredByOrange.bmp"
100824>>>>>    End_Procedure
100825>>>>>
100825>>>>>    Procedure Page Integer iPageObject
100827>>>>>        Handle hMenu
100827>>>>>        Integer iPrevState
100827>>>>>
100827>>>>>        Forward Send Page iPageObject
100829>>>>>        // Due to a bug in the ModalPanel class, we need to set the icon here:
100829>>>>>//        Set Icon to "ActionAbout.ico"
100829>>>>>
100829>>>>>        // Shadow upper left corner menu items: (icon menu items)
100829>>>>>        Move (GetSystemMenu(Window_Handle(Self), False)) to hMenu
100830>>>>>        Move (EnableMenuItem(hMenu, SC_RESTORE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
100831>>>>>        // The "Move" menu command may come in handy to have.
100831>>>>>        // Move (EnableMenuItem(hMenu, SC_MOVE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
100831>>>>>        Move (EnableMenuItem(hMenu, SC_SIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
100832>>>>>        Move (EnableMenuItem(hMenu, SC_MINIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
100833>>>>>        Move (EnableMenuItem(hMenu, SC_MAXIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
100834>>>>>        // The "Close" menu command may be good to have.
100834>>>>>        // Move (EnableMenuItem(hMenu, SC_CLOSE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
100834>>>>>    End_Procedure
100835>>>>>
100835>>>>>    Procedure Set ProductName String sText
100837>>>>>        Set Value of oProductName to sText
100838>>>>>    End_Procedure
100839>>>>>
100839>>>>>    Procedure Set Copyright String sText
100841>>>>>        Set Value of oCopyright to sText
100842>>>>>    End_Procedure
100843>>>>>
100843>>>>>    Procedure Set Author String sText
100845>>>>>        Set Value of oAuthor to sText
100846>>>>>    End_Procedure
100847>>>>>
100847>>>>>    Procedure Set Version String sVersion
100849>>>>>        Handle hoVersionInfo
100849>>>>>        Boolean bIncluded
100849>>>>>        Integer iMajor iMinor iRelease iBuild
100849>>>>>        Date dCompileDate
100849>>>>>
100849>>>>>        If (sVersion = "") Begin
100851>>>>>            // This automatically shows the program version of the program, if available.
100851>>>>>            // It will be displayed as the second item in the edit object.
100851>>>>>            If (ghoApplication <> 0) Begin
100853>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
100854>>>>>                If (hoVersionInfo <> 0) Begin
100856>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
100857>>>>>                    If (bIncluded) Begin
100859>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
100860>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
100861>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
100862>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
100863>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sVersion
100864>>>>>                    End
100864>>>>>>
100864>>>>>                End
100864>>>>>>
100864>>>>>            End
100864>>>>>>
100864>>>>>        End
100864>>>>>>
100864>>>>>
100864>>>>>        // Display the compiled date as the next row in the edit object, after the program version.
100864>>>>>        Get GetCompileDate to dCompileDate
100865>>>>>        If (sVersion <> "") Begin
100867>>>>>            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(dCompileDate))
100868>>>>>        End
100868>>>>>>
100868>>>>>    End_Procedure
100869>>>>>
100869>>>>>    Function GetCompileDate Returns Date
100871>>>>>        Date dCompileDate
100871>>>>>        String sAppFilename sData sCompileDate
100871>>>>>        Integer iChannel iPos iDateFormat
100871>>>>>
100871>>>>>        // Get full path to the current running executable
100871>>>>>        Get GetApplicationFileName of ghoApplication to sAppFilename
100872>>>>>
100872>>>>>        //Read the current file  up to where the data we're interesting in is (this was hand calced and so could vary)
100872>>>>>        Get Seq_Open_Input_Channel ("binary:" * sAppFilename) to iChannel
100873>>>>>        Read_Block channel iChannel sData (8 * 1024)    // First 8K is .exe header skip it
100875>>>>>        Read_Block channel iChannel sData 75            // The compile information we're interested in
100877>>>>>        Send Seq_Close_Channel iChannel
100878>>>>>
100878>>>>>        // The data is padded with Character(0)s. Strip them out
100878>>>>>        Move (CString(sData)) to sData
100879>>>>>
100879>>>>>        // The compile date is after the first ", ", so string parsing is required
100879>>>>>        Move (Pos(", ", sData)) to iPos
100880>>>>>        Move (Mid(sData, 10, (iPos + 2) ))  to sCompileDate // In US format
100881>>>>>        // If the current date format is non US, we need to temporary
100881>>>>>        // change the format and then move the string to the date variable.
100881>>>>>        Get_Attribute DF_DATE_FORMAT        to iDateFormat
100884>>>>>        Set_Attribute DF_DATE_FORMAT        to DF_DATE_USA
100887>>>>>        Move (Date(sCompileDate))           to dCompileDate
100888>>>>>        Set_Attribute DF_DATE_FORMAT        to iDateFormat // Reset date format
100891>>>>>
100891>>>>>        Function_Return dCompileDate
100892>>>>>    End_Function
100893>>>>>
100893>>>>>    Procedure Add_LineLn String sValue
100895>>>>>        Send Add_LineLn of oInfoList_Editor sValue
100896>>>>>    End_Procedure
100897>>>>>
100897>>>>>    Procedure Add_Line String sValue
100899>>>>>        Send Add_Line of oInfoList_Editor sValue
100900>>>>>    End_Procedure
100901>>>>>
100901>>>>>    Procedure Set Logo string sLogo
100903>>>>>        // Square bitmaps of 80x80 work best
100903>>>>>        Set Bitmap of oAboutGraphic to sLogo
100904>>>>>    End_Procedure
100905>>>>>
100905>>>>>    Procedure Set LogoVDF String sLogo
100907>>>>>        Set Bitmap of oPoweredByVDFGraphic to sLogo
100908>>>>>    End_Procedure
100909>>>>>
100909>>>>>    Procedure Show_Sysinfo
100911>>>>>        Send Popup_Modal of oSysinfoDialog
100912>>>>>    End_Procedure
100913>>>>>
100913>>>>>    Procedure Show_HomePage String sWebpage
100915>>>>>        Handle hWnd hInstance
100915>>>>>        Get Window_Handle to hWnd
100916>>>>>        Move (ShellExecute(hWnd, "open", (Trim(sWebpage)), "", "", 1)) to hInstance
100917>>>>>    End_Procedure
100918>>>>>
100918>>>>>//    Procedure End_Construct_Object
100918>>>>>//        Handle hoVersionInfo
100918>>>>>//        Boolean bIncluded
100918>>>>>//        Integer iMajor iMinor iRelease iBuild
100918>>>>>//        String sLabel sVersion
100918>>>>>//
100918>>>>>//        If (sVersion = "") Begin
100918>>>>>//            // This automatically shows the program version of the program, if available.
100918>>>>>//            // It will be displayed as the last item in the edit object.
100918>>>>>//            If (ghoApplication <> 0) Begin
100918>>>>>//                Get phoVersionInfo of ghoApplication to hoVersionInfo
100918>>>>>//                If (hoVersionInfo <> 0) Begin
100918>>>>>//                    Get pbIncluded of hoVersionInfo to bIncluded
100918>>>>>//                    If (bIncluded) Begin
100918>>>>>//                        Get piVersionMajor of hoVersionInfo to iMajor
100918>>>>>//                        Get piVersionMinor of hoVersionInfo to iMinor
100918>>>>>//                        Get piVersionRelease of hoVersionInfo to iRelease
100918>>>>>//                        Get piVersionBuild of hoVersionInfo to iBuild
100918>>>>>//                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sLabel
100918>>>>>//                        Set Version to sLabel
100918>>>>>//                    End
100918>>>>>//                End
100918>>>>>//            End
100918>>>>>//        End
100918>>>>>//
100918>>>>>//        Forward Send End_Construct_Object
100918>>>>>//    End_Procedure
100918>>>>>
100918>>>>>End_Class
100919>>>
100919>>>// *************************************************************************
100919>>>//  Public message. This is the default message. It is expected that you will
100919>>>//   create your own message to override this
100919>>>// *************************************************************************
100919>>>
100919>>>Procedure Activate_About
100922>>>   Send DoAbout "" "" "" "" ""
100923>>>End_Procedure
100924>>>
100924>>>// *************************************************************************
100924>>>//  Public message. It is expected that you will send this message (most
100924>>>//  likely from Activate_About. This creates an about object, activates it
100924>>>//  and destroys it when done. It is not exepected that you will augment this.
100924>>>// *************************************************************************
100924>>>// Sample usage:
100924>>>//   The first two params will automatically be filled from the application settings if not provided.
100924>>>//   Send DoAbout "" "" ("Copyright: 2013" * psCompany(ghoApplication)) "Created by: Your Name" "YourAppBitmap.bmp" "Internet: http://www.YourWebAddress.com" "E-mail: mailto:support@YourEmailAddress.com" "Some other description of choice" "9th param" "and last param"
100924>>>
100924>>>Procedure DoAbout String sTitle String sVersion String sCopyRight String sAuthor String sBitmap ;                  String sParam6 String sParam7 String sParam8 String sParam9 String sParam10
100927>>>        Integer hoObj hoMain iArgs
100927>>>        String sValue
100927>>>
100927>>>        // Create object
100927>>>        Object About is an AboutDialog
100929>>>            // Uncomment these two lines if you would like to have a resizable About object.
100929>>>//            Set Border_Style to Border_Thick
100929>>>//            Set peAnchors to anAll
100929>>>
100929>>>            // Add checking for the number of arguments passed to avoid runtime errors
100929>>>            // if one of them is not passed. This makes the interface
100929>>>            // more flexible.
100929>>>            Move num_arguments to iArgs
100930>>>
100930>>>            // If no title is passed use the label of the main panel (if a main panel exists).
100930>>>            If (iArgs > 0 and sTitle = "") Begin
100932>>>                Get Main_Window of Desktop to hoMain
100933>>>                If hoMain Begin
100935>>>                    Get Label of hoMain to sValue
100936>>>                End
100936>>>>
100936>>>            End
100936>>>>
100936>>>            Else If (iArgs > 0 and sTitle <> "") Begin
100939>>>                Move sTitle to sValue
100940>>>            End
100940>>>>
100940>>>            Else If (iArgs = 0) Begin
100943>>>                Get Main_Window of Desktop to hoMain
100944>>>                If hoMain Begin
100946>>>                    Get Label of hoMain to sValue
100947>>>                End
100947>>>>
100947>>>            End
100947>>>>
100947>>>
100947>>>            If (sValue <> "") Begin
100949>>>                Send Add_LineLn sValue
100950>>>            End
100950>>>>
100950>>>            Move "" to sValue
100951>>>
100951>>>            // If the passed sVersion value is blank, the info will be retrieved from the cApplication object.
100951>>>            // For this to work the Project Properties Version must have been set in the Studio.
100951>>>            If (iArgs < 2) Begin
100953>>>                Move "" to sValue
100954>>>            End
100954>>>>
100954>>>            Else Begin
100955>>>                Move sVersion to sValue
100956>>>            End
100956>>>>
100956>>>            Set Version to sValue
100957>>>
100957>>>            If (iArgs > 2 and sCopyRight <> "") Begin
100959>>>                Send Add_LineLn sCopyRight
100960>>>            End
100960>>>>
100960>>>
100960>>>            // If only the five "standard" params were passed we don't add an extra linefeed;
100960>>>            // else we do.
100960>>>            If (iArgs > 3 and iArgs < 6 and sAuthor <> "") Begin
100962>>>                Send Add_Line sAuthor
100963>>>            End
100963>>>>
100963>>>            Else If (iArgs > 5 and sAuthor <> "") Begin
100966>>>                Send Add_LineLn sAuthor
100967>>>            End
100967>>>>
100967>>>
100967>>>            // Square bitmaps of 80x80 works best
100967>>>            If (iArgs > 4 and sBitmap <> "") Begin
100969>>>               Set Logo to sBitMap
100970>>>            End
100970>>>>
100970>>>
100970>>>            // Here starts handling of the five optional params:
100970>>>            If (iArgs = 6 and sParam6  <> "") Begin
100972>>>                Send Add_Line sParam6
100973>>>            End
100973>>>>
100973>>>            Else If (iArgs > 6 and sParam6  <> "") Begin
100976>>>                Send Add_LineLn sParam6
100977>>>            End
100977>>>>
100977>>>
100977>>>            If (iArgs = 7 and sParam7  <> "") Begin
100979>>>                Send Add_Line sParam7
100980>>>            End
100980>>>>
100980>>>            Else If (iArgs > 7 and sParam7  <> "") Begin
100983>>>                Send Add_LineLn sParam7
100984>>>            End
100984>>>>
100984>>>
100984>>>            If (iArgs = 8 and sParam8  <> "") Begin
100986>>>                Send Add_Line sParam8
100987>>>            End
100987>>>>
100987>>>            Else If (iArgs > 8 and sParam8  <> "") Begin
100990>>>                Send Add_LineLn sParam8
100991>>>            End
100991>>>>
100991>>>
100991>>>            If (iArgs = 9 and sParam9  <> "") Begin
100993>>>                Send Add_Line sParam9
100994>>>            End
100994>>>>
100994>>>            Else If (iArgs > 9 and sParam9  <> "") Begin
100997>>>                Send Add_LineLn sParam9
100998>>>            End
100998>>>>
100998>>>
100998>>>            If (iArgs = 10 and sParam10 <> "") Begin
101000>>>                Send Add_Line sParam10
101001>>>            End
101001>>>>
101001>>>
101001>>>            Move Self to hoObj
101002>>>        End_Object
101003>>>
101003>>>        Send Popup   of hoObj // Popup the about object
101004>>>        Send Destroy of hoObj // When done, it will be destroyed
101005>>>End_Procedure
101006>        Use ManageSQLConnections.vw
Including file: ManageSQLConnections.vw    (C:\Projects\DF18\DbUpdateFramework\AppSrc\ManageSQLConnections.vw)
101006>>>Use DFClient.pkg
101006>>>Use cCJCommandBarSystem.pkg
101006>>>Use cCJGrid.pkg
101006>>>Use cCJGridColumnRowIndicator.pkg
Including file: cCJGridColumnRowIndicator.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJGridColumnRowIndicator.pkg)
101006>>>>>Use cCJGridColumn.pkg
101006>>>>>
101006>>>>>Class cCJGridColumnRowIndicator is a cCJGridColumn
101007>>>>>    
101007>>>>>    Procedure Construct_Object
101009>>>>>        Forward Send Construct_Object
101011>>>>>    
101011>>>>>        Property Integer piImage 0
101012>>>>>        
101012>>>>>        Set psCaption to ""
101013>>>>>        Set piWidth to 20
101014>>>>>        Set pbResizable to False
101015>>>>>        Set pbEditable to False
101016>>>>>        Set pbFocusable to False
101017>>>>>        Set pbAllowDrag to False
101018>>>>>        Set psToolTip to "Row Indicator"
101019>>>>>//        Set Color to (RGB(217,222,243))   //JVH
101019>>>>>    End_Procedure
101020>>>>>    
101020>>>>>    Procedure OnCreateColumn
101022>>>>>        Integer iImage
101022>>>>>        Delegate Get AddImage "GridColumnRowIndicator.bmp" 0 to iImage
101024>>>>>        Set piImage to iImage
101025>>>>>    End_Procedure
101026>>>>>            
101026>>>>>    Procedure OnSetDisplayMetrics Handle hoGridItemMetrics Integer iRow String ByRef sValue
101028>>>>>        Integer iImage iFocusedRow
101028>>>>>        Handle hoDataSource
101028>>>>>        
101028>>>>>        Get phoDataSource to hoDataSource
101029>>>>>        Get SelectedRow of hoDataSource to iFocusedRow
101030>>>>>        Move -1 to iImage
101031>>>>>        If (iRow = iFocusedRow) Begin
101033>>>>>            Get piImage to iImage
101034>>>>>            Set ComItemIcon of hoGridItemMetrics to iImage
101035>>>>>        End
101035>>>>>>
101035>>>>>    End_Procedure
101036>>>>>
101036>>>>>End_Class
101037>>>Use cCJGridColumn.pkg
101037>>>Use cSQLConnectionButton.pkg
Including file: cSQLConnectionButton.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cSQLConnectionButton.pkg)
101037>>>>>Use cButtonDPI.pkg
Including file: cButtonDPI.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cButtonDPI.pkg)
101037>>>>>>>Use cButton.pkg
Including file: cButton.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cButton.pkg)
101037>>>>>>>>>//****************************************************************************
101037>>>>>>>>>// $Module type: Package
101037>>>>>>>>>// $Module name: cButton.pkg
101037>>>>>>>>>//
101037>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
101037>>>>>>>>>// Copyright (c) 2012 RDC Tools International
101037>>>>>>>>>// E-mail      : support@rdctools.com
101037>>>>>>>>>// Web-site    : http://www.rdctools.com
101037>>>>>>>>>//
101037>>>>>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
101037>>>>>>>>>//
101037>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
101037>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
101037>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
101037>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
101037>>>>>>>>>// in the help folder for more details.
101037>>>>>>>>>//
101037>>>>>>>>>//****************************************************************************
101037>>>>>>>>>Use Windows.pkg
101037>>>>>>>>>Use Enclient.pkg
101037>>>>>>>>>Use errornum.inc
101037>>>>>>>>>
101037>>>>>>>>>Class cButtonIdleHandler is a cIdleHandler
101038>>>>>>>>>    Procedure Construct_Object
101040>>>>>>>>>        Forward Send Construct_Object
101042>>>>>>>>>
101042>>>>>>>>>    End_Procedure
101043>>>>>>>>>
101043>>>>>>>>>    Procedure OnIdle
101045>>>>>>>>>        Delegate Send DoEnable
101047>>>>>>>>>    End_Procedure
101048>>>>>>>>>
101048>>>>>>>>>End_Class
101049>>>>>>>>>
101049>>>>>>>>>Class cButton is a Button
101050>>>>>>>>>
101050>>>>>>>>>    Procedure Construct_Object
101052>>>>>>>>>        Forward Send Construct_Object
101054>>>>>>>>>
101054>>>>>>>>>//#IF (Required_FMAC_Version < 17)
101054>>>>>>>>>//        Set Typeface to "Segoe UI"
101054>>>>>>>>>//        Set FontSize to 18 0
101054>>>>>>>>>//#ENDIF
101054>>>>>>>>>
101054>>>>>>>>>        Property Boolean pbAutoEnable False
101055>>>>>>>>>
101055>>>>>>>>>        Object oButtonIdleHandler is a cButtonIdleHandler
101057>>>>>>>>>        End_Object
101058>>>>>>>>>    End_Procedure
101059>>>>>>>>>
101059>>>>>>>>>    Procedure End_Construct_Object
101061>>>>>>>>>        String sTooltip sStatus_Help
101061>>>>>>>>>
101061>>>>>>>>>        Forward Send End_Construct_Object
101063>>>>>>>>>
101063>>>>>>>>>        Get psToolTip   to sTooltip
101064>>>>>>>>>        Get Status_Help to sStatus_Help
101065>>>>>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
101067>>>>>>>>>            Set psToolTip to sStatus_Help
101068>>>>>>>>>        End
101068>>>>>>>>>>
101068>>>>>>>>>        Set pbEnabled of oButtonIdleHandler to (pbAutoEnable(Self))
101069>>>>>>>>>    End_Procedure
101070>>>>>>>>>
101070>>>>>>>>>    Procedure DoEnable
101072>>>>>>>>>        Boolean bAutoEnable bHasRecord
101072>>>>>>>>>        Handle hoDD
101072>>>>>>>>>        Get pbAutoEnable to bAutoEnable
101073>>>>>>>>>        If (bAutoEnable = False) Begin
101075>>>>>>>>>            Procedure_Return
101076>>>>>>>>>        End
101076>>>>>>>>>>
101076>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
101077>>>>>>>>>        Move (Main_DD(Self)) to hoDD
101078>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
101079>>>>>>>>>        If (hoDD <> 0) Begin
101081>>>>>>>>>            Get HasRecord of hoDD to bHasRecord
101082>>>>>>>>>        End
101082>>>>>>>>>>
101082>>>>>>>>>        Set Enabled_State to (bHasRecord = True)
101083>>>>>>>>>    End_Procedure
101084>>>>>>>>>
101084>>>>>>>>>    // Enable the idle handler timer when the button is activated
101084>>>>>>>>>    Procedure Activating
101086>>>>>>>>>       Forward Send Activating
101088>>>>>>>>>       Set pbEnabled of oButtonIdleHandler to True
101089>>>>>>>>>    End_Procedure
101090>>>>>>>>>
101090>>>>>>>>>    // Disable the idle handler when the button is deactivated
101090>>>>>>>>>    Procedure Deactivating
101092>>>>>>>>>       Set pbEnabled of oButtonIdleHandler to False
101093>>>>>>>>>       Forward Send Deactivating
101095>>>>>>>>>    End_Procedure
101096>>>>>>>>>
101096>>>>>>>>>End_Class
101097>>>>>>>
101097>>>>>>>// Button class that automatically shows the correct icon size for the current DPI-setting:
101097>>>>>>>Class cButtonDPI is a cButton
101098>>>>>>>    Procedure Construct_Object
101100>>>>>>>        Integer iIconSize
101100>>>>>>>        Forward Send Construct_Object
101102>>>>>>>        Get GetCorrectIconSize to iIconSize
101103>>>>>>>        Set piImageSize to iIconSize
101104>>>>>>>        Set piImageMarginLeft to 10
101105>>>>>>>    End_Procedure
101106>>>>>>>
101106>>>>>>>    // Returns: DPI setting as an integer.
101106>>>>>>>    //  Normal DPI setting: iDPI=96  is "Normal setting" 100%
101106>>>>>>>    //                      iDPI=120 is "Medium setting" 125%
101106>>>>>>>    //                      iDPI= 144 is "Large setting" 150%
101106>>>>>>>    Function GetCurrentDPI Returns Integer
101108>>>>>>>        Handle hDC
101108>>>>>>>        Integer iPixelsX
101108>>>>>>>        Move (GetDC(0)) to hDC
101109>>>>>>>        Move (GetDeviceCaps(hDC, LOGPIXELSX)) to iPixelsX
101110>>>>>>>        Move (ReleaseDC(0, hDC)) to hDC
101111>>>>>>>        Function_Return iPixelsX
101112>>>>>>>    End_Function
101113>>>>>>>
101113>>>>>>>    Function GetCorrectIconSize Returns Integer
101115>>>>>>>        Integer iPixelsX iIndex iSize
101115>>>>>>>        Integer[] iaSizes
101116>>>>>>>
101116>>>>>>>        Move 16 to iaSizes[0]
101117>>>>>>>        Move 24 to iaSizes[1]
101118>>>>>>>        Move 32 to iaSizes[2]
101119>>>>>>>        Move 48 to iaSizes[3]
101120>>>>>>>        Move 64 to iaSizes[4]
101121>>>>>>>
101121>>>>>>>        Get piImageSize to iSize  // the "100%" size
101122>>>>>>>        Move (SearchArray(iSize,iaSizes)) to iIndex
101123>>>>>>>        Move (0 max iIndex) to iIndex
101124>>>>>>>        Get GetCurrentDPI to iPixelsX
101125>>>>>>>        // Use a Case Statement here. Wherever we jump in we will continue onwards, regardless of whether
101125>>>>>>>        // we match the remaining Case statements or not. So list our Cases in reverse order, meaning we
101125>>>>>>>        // will increment iIndex as many times as we need here.
101125>>>>>>>        Case Begin
101125>>>>>>>            Case (iPixelsX > 144)
101127>>>>>>>                Increment iIndex
101128>>>>>>>            Case (iPixelsX = 144)
101131>>>>>>>                Increment iIndex
101132>>>>>>>            Case (iPixelsX = 120)
101135>>>>>>>                Increment iIndex
101136>>>>>>>        Case End
101136>>>>>>>        Move (iIndex min 4) to iIndex
101137>>>>>>>        Function_Return iaSizes[iIndex]
101138>>>>>>>    End_Function
101139>>>>>>>
101139>>>>>>>    Procedure Set psToolTip String sToolTip
101141>>>>>>>        String sStatusHelp
101141>>>>>>>
101141>>>>>>>        Get Status_Help to sStatusHelp
101142>>>>>>>        If (sStatusHelp = "") Begin
101144>>>>>>>            Set Status_Help to sToolTip
101145>>>>>>>        End
101145>>>>>>>>
101145>>>>>>>
101145>>>>>>>        Forward Set psToolTip to sToolTip
101147>>>>>>>    End_Function
101148>>>>>>>
101148>>>>>>>End_Class
101149>>>>>
101149>>>>>// New button class so we constantly can display the ini-filename in the status_help area:
101149>>>>>Class cSQLConnectionButton is a cButtonDPI
101150>>>>>    Procedure Construct_Object
101152>>>>>        Forward Send Construct_Object
101154>>>>>    End_Procedure
101155>>>>>
101155>>>>>    Procedure End_Construct_Object
101157>>>>>        String sLabel sImage
101157>>>>>        Forward Send End_Construct_Object
101159>>>>>        Get psImage to sImage
101160>>>>>        If (sImage = "") Begin
101162>>>>>            Get Label to sLabel
101163>>>>>            Move (Replace("&", sLabel, "")) to sLabel
101164>>>>>            Move (Replace("...", sLabel, "")) to sLabel
101165>>>>>            Set psImage to ("Action" + sLabel + ".ico")
101166>>>>>        End
101166>>>>>>
101166>>>>>    End_Procedure
101167>>>>>
101167>>>>>    Function Status_Help String Item# Returns String
101169>>>>>        String sRetval
101169>>>>>//        #IF (Required_RT_Version > 18)
101169>>>>>        Get IniFileName to sRetval
101170>>>>>//        #ENDIF
101170>>>>>        Function_Return sRetval
101171>>>>>    End_Function
101172>>>>>
101172>>>>>End_Class
101173>>>
101173>>>Use DatabaseSelection.dg
Including file: DatabaseSelection.dg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\DatabaseSelection.dg)
101173>>>>>Use Windows.pkg
101173>>>>>Use cCJGridPromptList.pkg
Including file: cCJGridPromptList.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJGridPromptList.pkg)
101173>>>>>>>Use Windows.pkg
101173>>>>>>>Use cCJGrid.pkg
101173>>>>>>>
101173>>>>>>>
101173>>>>>>>
101173>>>>>>>Class cCJGridPromptList is a cCJGrid
101174>>>>>>>
101174>>>>>>>    Procedure Construct_Object
101176>>>>>>>        Forward Send Construct_Object
101178>>>>>>>
101178>>>>>>>        Property Boolean pbAutoSeed True     // if we should seed list from invoking data
101179>>>>>>>        Property Boolean Private_pbAutoOrdering True
101180>>>>>>>        Property Boolean pbAutoSearch True  // pops up search window
101181>>>>>>>        Property Integer peUpdateMode umPromptValue
101182>>>>>>>        Property Integer piUpdateColumn 0
101183>>>>>>>        Property Integer piInitialColumn -1
101184>>>>>>>        Property String  psSeedValue ''
101185>>>>>>>        Property Handle phmPromptUpdateCallback 0
101186>>>>>>>        Property Integer phoInvokingObject
101187>>>>>>>        
101187>>>>>>>        Property Boolean pbStoredAutoSeed
101188>>>>>>>        Property Boolean pbStoredAutoOrdering
101189>>>>>>>        Property Boolean pbStoredAutoSearch
101190>>>>>>>        Property Integer peStoredUpdateMode
101191>>>>>>>        Property Integer piStoredUpdateColumn
101192>>>>>>>        Property Integer piStoredInitialColumn
101193>>>>>>>        Property Handle  phmStoredPromptUpdateCallback
101194>>>>>>>        Property Boolean pbStoredSelectionEnable
101195>>>>>>>        Property Boolean pbStoredMultipleSelection
101196>>>>>>>
101196>>>>>>>        // internally set by list
101196>>>>>>>        // these must be set upon closing the list and can be used for manual list updates
101196>>>>>>>        Property Boolean pbCanceled
101197>>>>>>>        Property Integer[] pSelectedRows
101198>>>>>>>
101198>>>>>>>        Property Boolean pbNeedsNewOrdering
101199>>>>>>>        Property Boolean pbRequestSearch
101200>>>>>>>        Property tGridKeyPair[] pSearchKeys
101201>>>>>>>        
101201>>>>>>>        // these properties makes a prompt list a prompt list
101201>>>>>>>        // and should not be changed.
101201>>>>>>>        Set pbEditOnKeyNavigation to False
101202>>>>>>>        Set pbEditOnClick to False
101203>>>>>>>        Set pbReadOnly to True
101204>>>>>>>        Set pbFocusSubItems to True
101205>>>>>>>        
101205>>>>>>>        // these could maybe be changed
101205>>>>>>>        Set pbShadeSortColumn to True
101206>>>>>>>        Set pbHeaderReorders to True
101207>>>>>>>        Set pbHeaderTogglesDirection to True
101208>>>>>>>        Set pbHeaderSelectsColumn to True
101209>>>>>>>        Set peHorizontalGridStyle to xtpGridNoLines
101210>>>>>>>        Set piFocusCellBackColor to clNone
101211>>>>>>>        Set piFocusCellForeColor to clNone
101212>>>>>>>        Set piFocusCellRectangleColor to clBlack
101213>>>>>>>        Set pbUseFocusCellRectangle to False
101214>>>>>>>        Set pbSelectionEnable to True
101215>>>>>>>        
101215>>>>>>>        On_Key kEnter Send Ok
101216>>>>>>>        On_Key kCancel Send Cancel
101217>>>>>>>
101217>>>>>>>    End_Procedure
101218>>>>>>>    
101218>>>>>>>    // reorder list automatically on column change
101218>>>>>>>    // this also set pbFocusSubItems which is required to make the two states work
101218>>>>>>>    Procedure Set pbAutoOrdering Boolean bAutoOrder
101220>>>>>>>        Set Private_pbAutoOrdering to bAutoOrder
101221>>>>>>>        Set pbFocusSubItems to bAutoOrder
101222>>>>>>>    End_Procedure
101223>>>>>>>    
101223>>>>>>>    Function pbAutoOrdering Returns Boolean
101225>>>>>>>        Boolean bAutoOrder
101225>>>>>>>        Get Private_pbAutoOrdering to bAutoOrder
101226>>>>>>>        Function_Return bAutoOrder
101227>>>>>>>    End_Function
101228>>>>>>>
101228>>>>>>>    // augmented to handle auto-ordering and invoking the search popup list
101228>>>>>>>    Procedure OnIdle
101230>>>>>>>        Boolean bNeedsReorder bSearch bOldToggle
101230>>>>>>>        Handle hoCol
101230>>>>>>>        Integer iKy1 iKy2 iCol
101230>>>>>>>
101230>>>>>>>        Get pbNeedsNewOrdering to bNeedsReorder
101231>>>>>>>        If bNeedsReorder Begin
101233>>>>>>>            Get SelectedColumn to iCol
101234>>>>>>>            If (iCol<>-1) Begin
101236>>>>>>>                
101236>>>>>>>                Get pbHeaderTogglesDirection to bOldToggle
101237>>>>>>>                Set pbHeaderTogglesDirection to False
101238>>>>>>>                Send HeaderReorder iCol
101239>>>>>>>                Set pbHeaderTogglesDirection to bOldToggle
101240>>>>>>>                
101240>>>>>>>                Set pbNeedsNewOrdering to False
101241>>>>>>>            End
101241>>>>>>>>
101241>>>>>>>        End
101241>>>>>>>>
101241>>>>>>>        
101241>>>>>>>        Get pbRequestSearch to bSearch
101242>>>>>>>        If bSearch Begin
101244>>>>>>>            Send Request_SearchEx // will use the keys pSearchKeys as eed
101245>>>>>>>        End
101245>>>>>>>>
101245>>>>>>>        
101245>>>>>>>        Forward Send OnIdle
101247>>>>>>>    End_Procedure
101248>>>>>>>    
101248>>>>>>>    Procedure OnStoreDefaults
101250>>>>>>>        Integer iVal
101250>>>>>>>        Boolean bVal
101250>>>>>>>
101250>>>>>>>        Get pbAutoSeed to bVal           
101251>>>>>>>        Set pbStoredAutoSeed to bVal           
101252>>>>>>>        
101252>>>>>>>        Get pbAutoOrdering to bVal        
101253>>>>>>>        Set pbStoredAutoOrdering to bVal      
101254>>>>>>>        
101254>>>>>>>        Get pbAutoSearch to bVal         
101255>>>>>>>        Set pbStoredAutoSearch to bVal         
101256>>>>>>>        
101256>>>>>>>        Get peUpdateMode to iVal
101257>>>>>>>        Set peStoredUpdateMode to iVal
101258>>>>>>>        
101258>>>>>>>        Get piUpdateColumn to iVal       
101259>>>>>>>        Set piStoredUpdateColumn to iVal       
101260>>>>>>>
101260>>>>>>>        Get piInitialColumn to iVal       
101261>>>>>>>        Set piStoredInitialColumn to iVal       
101262>>>>>>>
101262>>>>>>>        Get phmPromptUpdateCallback to iVal       
101263>>>>>>>        Set phmStoredPromptUpdateCallback to iVal       
101264>>>>>>>
101264>>>>>>>        Get pbSelectionEnable to bVal
101265>>>>>>>        Set pbStoredSelectionEnable to bVal
101266>>>>>>>        
101266>>>>>>>        Get pbMultipleSelection to bVal
101267>>>>>>>        Set pbStoredMultipleSelection to bVal
101268>>>>>>>        
101268>>>>>>>    End_Procedure
101269>>>>>>>
101269>>>>>>>    Procedure OnRestoreDefaults
101271>>>>>>>        Integer iVal
101271>>>>>>>        Boolean bVal
101271>>>>>>>
101271>>>>>>>        Get pbStoredAutoSeed to bVal           
101272>>>>>>>        Set pbAutoSeed to bVal           
101273>>>>>>>        
101273>>>>>>>        Get pbStoredAutoOrdering to bVal        
101274>>>>>>>        Set pbAutoOrdering to bVal      
101275>>>>>>>        
101275>>>>>>>        Get pbStoredAutoSearch to bVal         
101276>>>>>>>        Set pbAutoSearch to bVal         
101277>>>>>>>        
101277>>>>>>>        Get peStoredUpdateMode to iVal
101278>>>>>>>        Set peUpdateMode to iVal
101279>>>>>>>        
101279>>>>>>>        Get piStoredInitialColumn to iVal       
101280>>>>>>>        Set piInitialColumn to iVal       
101281>>>>>>>        
101281>>>>>>>        Get phmStoredPromptUpdateCallback to iVal       
101282>>>>>>>        Set phmPromptUpdateCallback to iVal       
101283>>>>>>>
101283>>>>>>>        Get pbStoredSelectionEnable to bVal
101284>>>>>>>        Set pbSelectionEnable to bVal
101285>>>>>>>        
101285>>>>>>>        Get pbStoredMultipleSelection to bVal
101286>>>>>>>        Set pbMultipleSelection to bVal
101287>>>>>>>
101287>>>>>>>    End_Procedure
101288>>>>>>>    
101288>>>>>>>    // finds the target seed value in the updatecolumn. If we autoseed and there is a
101288>>>>>>>    // seed value (psSeedValue), attempt to find GE that value, else move to first row
101288>>>>>>>    // Suitable for augmentation
101288>>>>>>>    Procedure OnSeedData
101290>>>>>>>        Integer iUpdateColumn iSortColumn
101290>>>>>>>        Boolean bSeed bAuto
101290>>>>>>>        String sValue
101290>>>>>>>        Handle hoCol
101290>>>>>>>
101290>>>>>>>        Get piUpdateColumn to iUpdateColumn
101291>>>>>>>        Get psSeedValue to sValue
101292>>>>>>>        Get pbAutoSeed to bSeed
101293>>>>>>>        Get piSortColumn to iSortColumn
101294>>>>>>>        Get pbAutoOrdering to bAuto
101295>>>>>>>        // if not yet sorted and this is auto ordering we will
101295>>>>>>>        // sort the data for the search column. We do this to make the
101295>>>>>>>        // column search GE logic work properly. 
101295>>>>>>>        If (bSeed and bAuto and iUpdateColumn<>-1 and iSortColumn<>iUpdateColumn) Begin
101297>>>>>>>            Get ColumnObject iUpdateColumn to hoCol
101298>>>>>>>            Send SortGridByColumn hoCol False
101299>>>>>>>        End
101299>>>>>>>>
101299>>>>>>>
101299>>>>>>>        If (bSeed and sValue<>"" and iUpdateColumn<>-1) Begin
101301>>>>>>>            Send RequestFindColumnValue iUpdateColumn sValue True 0  
101302>>>>>>>        End
101302>>>>>>>>
101302>>>>>>>        Else Begin
101303>>>>>>>            Send MovetoFirstRow
101304>>>>>>>        End
101304>>>>>>>>
101304>>>>>>>
101304>>>>>>>    End_Function
101305>>>>>>>
101305>>>>>>>    Procedure OnMoveValueOutByValue
101307>>>>>>>        String sValue
101307>>>>>>>        Handle hoInvokingObject hoCol  hoDataSource
101307>>>>>>>        Integer iRow iCol
101307>>>>>>>        Integer[] SelRowsIndexes
101308>>>>>>>
101308>>>>>>>        Get phoInvokingObject to hoInvokingObject
101309>>>>>>>        Get pSelectedRows to SelRowsIndexes
101310>>>>>>>        If (SizeOfArray(SelRowsIndexes)>0) Begin
101312>>>>>>>            Get piUpdateColumn to iCol
101313>>>>>>>            Get ColumnObject iCol to hoCol
101314>>>>>>>            Get RowValue of hoCol SelRowsIndexes[0] to sValue
101315>>>>>>>            Set Value of hoInvokingObject to sValue
101316>>>>>>>            Set Item_Changed_State of hoInvokingObject to True
101317>>>>>>>        End
101317>>>>>>>>
101317>>>>>>>    End_Procedure
101318>>>>>>>
101318>>>>>>>    Procedure OnMoveValueOutByCustom
101320>>>>>>>    End_Procedure
101321>>>>>>>
101321>>>>>>>    // augment to popup a search window when allowed
101321>>>>>>>    Procedure OnComKeyDown Short ByRef llKeyCode Short llShift
101323>>>>>>>        Boolean bSubFocus bAutoSearch bChar
101323>>>>>>>        Integer iVal
101323>>>>>>>        
101323>>>>>>>        Get pbFocusSubItems to bSubFocus
101324>>>>>>>        Get pbAutoSearch to bAutoSearch
101325>>>>>>>        Forward Send OnComKeyDown llKeyCode llShift
101327>>>>>>>        If (bAutoSearch and not(bSubFocus)) Begin
101329>>>>>>>            If ((llShift iand 6)=0) Begin // skip alt and ctrl
101331>>>>>>>                Get GetVKeyToAnsi llKeyCode llShift to iVal
101332>>>>>>>                Move (iVal<>0) to bChar
101333>>>>>>>            End
101333>>>>>>>>
101333>>>>>>>            If bChar Begin
101335>>>>>>>                // this can get called multiple times before a search dialog pops up
101335>>>>>>>                Send AddToSearchKeys llKeyCode llShift
101336>>>>>>>            End
101336>>>>>>>>
101336>>>>>>>        End
101336>>>>>>>>
101336>>>>>>>    End_Procedure
101337>>>>>>>    
101337>>>>>>>    Procedure OnComRequestEdit Variant llRow Variant llColumn Variant llItem Boolean ByRef llCancel
101339>>>>>>>        Boolean bAutoSearch
101339>>>>>>>        Integer iKeyCode iShiftCode
101339>>>>>>>        Get pbAutoSearch to bAutoSearch
101340>>>>>>>        If bAutoSearch Begin
101342>>>>>>>            // this can get called multiple times before a search dialog pops up
101342>>>>>>>            Get piLastKey to iKeyCode
101343>>>>>>>            Get piLastKey2 to iShiftCode
101344>>>>>>>            Send AddToSearchKeys iKeyCode iShiftCode
101345>>>>>>>        End
101345>>>>>>>>
101345>>>>>>>        Move True to llCancel
101346>>>>>>>    End_Procedure  // OnComRequestEdit
101347>>>>>>>    
101347>>>>>>>    Procedure OnComRowDblClick Variant llRow Variant llItem
101349>>>>>>>        Send ClearSearchRequest // kill any deferred search popup
101350>>>>>>>        Forward Send OnComRowDblClick llRow llItem
101352>>>>>>>    End_Procedure
101353>>>>>>>    
101353>>>>>>>    Procedure OnRowDoubleClick Integer iRow Integer iCol
101355>>>>>>>        Send Ok
101356>>>>>>>    End_Procedure
101357>>>>>>>    
101357>>>>>>>    
101357>>>>>>>    // we don't want a menu for prompt lists
101357>>>>>>>    Function CreateContextMenu Returns Handle
101359>>>>>>>        Function_Return 0
101360>>>>>>>    End_Function
101361>>>>>>>
101361>>>>>>>    // if we use auto-ordering, change the order when the column changes
101361>>>>>>>    Procedure ColumnChanged Integer iOld Integer iNew
101363>>>>>>>        Boolean bAutoOrder
101363>>>>>>>        Forward Send ColumnChanged iOld iNew
101365>>>>>>>        Get pbAutoOrdering to bAutoOrder
101366>>>>>>>        If bAutoOrder Begin
101368>>>>>>>            // will be reordered in idle event
101368>>>>>>>            Set pbNeedsNewOrdering to True
101369>>>>>>>        End
101369>>>>>>>>
101369>>>>>>>    End_Procedure
101370>>>>>>>    
101370>>>>>>>
101370>>>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
101372>>>>>>>        Integer eMode
101372>>>>>>>        Integer[] SelRowsIndexes
101373>>>>>>>        Set pbCanceled to True // assume cancel unless changed
101374>>>>>>>        Set pSelectedRows to SelRowsIndexes // empty
101375>>>>>>>        Get peUpdateMode to eMode
101376>>>>>>>        If (eMode<>umPromptNonInvoking) Begin
101378>>>>>>>            Send OnStoreDefaults
101379>>>>>>>        End
101379>>>>>>>>
101379>>>>>>>        Send InitializePromptList
101380>>>>>>>        Forward Send Add_Focus hoParent
101382>>>>>>>        Send LoadData
101383>>>>>>>        Set psSeedValue to ""
101384>>>>>>>    End_Procedure
101385>>>>>>>    
101385>>>>>>>    // called before the list is activated. 
101385>>>>>>>    Procedure InitializePromptList
101387>>>>>>>        Integer hoInvokingObject
101387>>>>>>>        Boolean bAutoColumn bAutoSeed 
101387>>>>>>>        Integer i iOldMode eUpdateMode
101387>>>>>>>        String sValue
101387>>>>>>>        
101387>>>>>>>        Get peUpdateMode to eUpdateMode
101388>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
101390>>>>>>>            Get Focus of Desktop to hoInvokingObject
101391>>>>>>>            If (hoInvokingObject<=Desktop) Begin
101393>>>>>>>                Error DFERR_PROGRAM "Prompt list has no invoking object"
101394>>>>>>>>
101394>>>>>>>                Procedure_Return
101395>>>>>>>            End
101395>>>>>>>>
101395>>>>>>>
101395>>>>>>>            Set phoInvokingObject to hoInvokingObject
101396>>>>>>>
101396>>>>>>>            Send Prompt_Callback to hoInvokingObject Self
101397>>>>>>>            Get peUpdateMode to eUpdateMode
101398>>>>>>>        End
101398>>>>>>>>
101398>>>>>>>
101398>>>>>>>        Send ClearSearchRequest // clear the search keys
101399>>>>>>>        Set pbNeedsNewOrdering to False
101400>>>>>>>
101400>>>>>>>        Get pbAutoSeed to bAutoSeed
101401>>>>>>>
101401>>>>>>>        If (eUpdateMode=umPromptValue) Begin // else not used here intentionally
101403>>>>>>>            Get Value of hoInvokingObject to sValue
101404>>>>>>>            Set psSeedValue to sValue
101405>>>>>>>        End
101405>>>>>>>>
101405>>>>>>>        
101405>>>>>>>    End_Procedure
101406>>>>>>>    
101406>>>>>>>    // called after list is created and active. Load Data, seed list, select start column, etc.
101406>>>>>>>    Procedure LoadData
101408>>>>>>>        Handle hoInvokingObject hoDataSource hoInitialColumn
101408>>>>>>>        Integer iUpdateColumn iRows iInitialColumn iInitialOrder
101408>>>>>>>        Integer eUpdateMode
101408>>>>>>>        Boolean bAutoSeed bAutoColumn bCancel bSubFocus bAutoOrder 
101408>>>>>>>        
101408>>>>>>>        Get phoDataSource to hoDataSource
101409>>>>>>>        Get peUpdateMode to eUpdateMode
101410>>>>>>>        Get phoInvokingObject to hoInvokingObject
101411>>>>>>>        Get pbAutoSeed to bAutoSeed
101412>>>>>>>        Get piInitialColumn to iInitialColumn
101413>>>>>>>        Get piUpdateColumn to iUpdateColumn
101414>>>>>>>        Get RowCount of hoDataSource to iRows
101415>>>>>>>        
101415>>>>>>>        // We need an initial column. if you specified an initial column that will get used for the start column
101415>>>>>>>        // and the initial sort order. If you did not, which is typical, it will use the update column
101415>>>>>>>        If (iInitialColumn=-1) Begin
101417>>>>>>>            Move iUpdateColumn to iInitialColumn
101418>>>>>>>        End
101418>>>>>>>>
101418>>>>>>>        If (iInitialColumn>=0) Begin
101420>>>>>>>            Get ColumnObject iInitialColumn to hoInitialColumn
101421>>>>>>>            Set pbVisible of hoInitialColumn to True // initial column should be visible
101422>>>>>>>        End
101422>>>>>>>>
101422>>>>>>>        Send OnSeedData // find a good starting place for the row
101423>>>>>>>        Get pbFocusSubItems to bSubFocus
101424>>>>>>>        If bSubFocus Begin
101426>>>>>>>            // if column focus, which is normal, go to initialcolumn       
101426>>>>>>>            If hoInitialColumn Begin
101428>>>>>>>                Get MoveToColumnObject hoInitialColumn to bCancel
101429>>>>>>>            End
101429>>>>>>>>
101429>>>>>>>            Else Begin
101430>>>>>>>                Send MoveToFirstEnterableColumn
101431>>>>>>>            End
101431>>>>>>>>
101431>>>>>>>        End
101431>>>>>>>>
101431>>>>>>>
101431>>>>>>>    End_Procedure
101432>>>>>>>    
101432>>>>>>>    // This is only called in a successful close
101432>>>>>>>    Procedure ClosePromptList
101434>>>>>>>        Handle hoDataSource hoInvokingObject
101434>>>>>>>        Handle hmCallBack
101434>>>>>>>        Integer iRow eUpdateMode
101434>>>>>>>        Integer[] SelRowsIndexes
101435>>>>>>>        
101435>>>>>>>        Get phoDataSource to hoDataSource
101436>>>>>>>        Get phoInvokingObject to hoInvokingObject
101437>>>>>>>        
101437>>>>>>>        If (pbMultipleSelection(Self)) Begin
101439>>>>>>>            Get GetIndexesForSelectedRows to SelRowsIndexes
101440>>>>>>>        End
101440>>>>>>>>
101440>>>>>>>        Else Begin
101441>>>>>>>            Get SelectedRow of hoDataSource to iRow
101442>>>>>>>            If (iRow<>-1) Begin
101444>>>>>>>                Move iRow to SelRowsIndexes[0]
101445>>>>>>>            End
101445>>>>>>>>
101445>>>>>>>        End
101445>>>>>>>>
101445>>>>>>>        
101445>>>>>>>        Set pbCanceled to False
101446>>>>>>>        Set pSelectedRows to SelRowsIndexes
101447>>>>>>>        
101447>>>>>>>        Get peUpdateMode to eUpdateMode
101448>>>>>>>        // if non-invoking there is by definition, no move value out
101448>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
101450>>>>>>>            
101450>>>>>>>            If (eUpdateMode=umPromptValue) Begin
101452>>>>>>>                Send OnMoveValueOutByValue
101453>>>>>>>            End
101453>>>>>>>>
101453>>>>>>>            Else If (eUpdateMode=umPromptCustom) Begin
101456>>>>>>>                Send OnMoveValueOutByCustom
101457>>>>>>>            End
101457>>>>>>>>
101457>>>>>>>                Get phmPromptUpdateCallback to hmCallBack
101458>>>>>>>                If hmCallBack Begin
101460>>>>>>>                    Send hmCallBack of hoInvokingObject Self
101461>>>>>>>                End
101461>>>>>>>>
101461>>>>>>>        End
101461>>>>>>>>
101461>>>>>>>
101461>>>>>>>        Send Close_Panel
101462>>>>>>>    End_Procedure
101463>>>>>>>
101463>>>>>>>    // augment to send OnRestoreDefaults.
101463>>>>>>>    Procedure Release_Focus
101465>>>>>>>        Integer eUpdateMode
101465>>>>>>>        Get peUpdateMode to eUpdateMode
101466>>>>>>>        Forward Send Release_Focus
101468>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
101470>>>>>>>            Send OnRestoreDefaults
101471>>>>>>>        End
101471>>>>>>>>
101471>>>>>>>    End_Procedure
101472>>>>>>>    
101472>>>>>>>    Function SelectedRowIds Returns RowID[]
101474>>>>>>>        RowID[] SelectedRowids
101475>>>>>>>        Integer[] SelectedRows
101476>>>>>>>        Integer i iRows
101476>>>>>>>        Handle hoDataSource
101476>>>>>>>        Get phoDataSource to hoDataSource
101477>>>>>>>        Get pSelectedRows to SelectedRows
101478>>>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
101479>>>>>>>        For i from 0 to (iRows-1)
101485>>>>>>>>
101485>>>>>>>            Get RowTag of hoDataSource SelectedRows[i] to SelectedRowIds[i]
101486>>>>>>>        Loop
101487>>>>>>>>
101487>>>>>>>        Function_Return SelectedRowids
101488>>>>>>>    End_Function
101489>>>>>>>
101489>>>>>>>    Function SelectedColumnValues Integer iCol Returns String[]
101491>>>>>>>        String[] SelectedValues
101492>>>>>>>        Integer[] SelectedRows
101493>>>>>>>        Integer i iRows
101493>>>>>>>        Handle hoCol
101493>>>>>>>        Get ColumnObject iCol to hoCol
101494>>>>>>>        Get pSelectedRows to SelectedRows
101495>>>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
101496>>>>>>>        For i from 0 to (iRows-1)
101502>>>>>>>>
101502>>>>>>>            Get RowValue of hoCol SelectedRows[i] to SelectedValues[i]
101503>>>>>>>        Loop
101504>>>>>>>>
101504>>>>>>>        Function_Return SelectedValues
101505>>>>>>>    End_Function
101506>>>>>>>
101506>>>>>>>    Procedure Ok Returns Integer
101508>>>>>>>        Send ClosePromptList
101509>>>>>>>    End_Procedure
101510>>>>>>>
101510>>>>>>>    Procedure Cancel Returns Integer
101512>>>>>>>        Send Close_Panel
101513>>>>>>>    End_Procedure
101514>>>>>>>        
101514>>>>>>>    Procedure Search
101516>>>>>>>        Send Activate // give focus back to list so focus things are correct
101517>>>>>>>        Send Request_Search 0 0
101518>>>>>>>    End_Procedure
101519>>>>>>>    
101519>>>>>>>    // do a search using the current keys in the search key buffer for the sort column.
101519>>>>>>>    // Becaue this is called via an OnIdle it is possible to have multiple keys pressed before
101519>>>>>>>    // the OnIdle. These have been stored in pSearchKeys and will be passed to the popup dialog
101519>>>>>>>    Procedure Request_SearchEx
101521>>>>>>>        tGridKeyPair[] Keys
101521>>>>>>>        tGridKeyPair[] Keys
101522>>>>>>>        Integer iCol
101522>>>>>>>        Handle hoCol hoSearchDialog 
101522>>>>>>>        Boolean bOk
101522>>>>>>>        String sValue
101522>>>>>>>
101522>>>>>>>        Get piSortColumn to iCol
101523>>>>>>>        If (iCol<>-1) Begin
101525>>>>>>>            Get ColumnObject iCol to hoCol
101526>>>>>>>                Get pSearchKeys to Keys
101527>>>>>>>            Get CreateGridSearchDialogObject to hoSearchDialog
101528>>>>>>>            Get RequestGridSearchEx of hoSearchDialog Keys hoCol (&sValue) to bOk
101529>>>>>>>            If bOk Begin
101531>>>>>>>               Send RequestFindColumnValue iCol sValue True 0  
101532>>>>>>>            End
101532>>>>>>>>
101532>>>>>>>            Send Destroy of hoSearchDialog
101533>>>>>>>        End
101533>>>>>>>>
101533>>>>>>>        Send ClearSearchRequest // clear the search keys
101534>>>>>>>    End_Procedure
101535>>>>>>>    
101535>>>>>>>    // set pbRequestSearch to true and add the keys to the search buffer.
101535>>>>>>>    Procedure AddToSearchKeys Integer iKeyCode Integer iShiftCode
101537>>>>>>>        tGridKeyPair[] Keys
101537>>>>>>>        tGridKeyPair[] Keys
101538>>>>>>>        tGridKeyPair KeyPair
101538>>>>>>>        tGridKeyPair KeyPair
101538>>>>>>>        Set pbRequestSearch to True
101539>>>>>>>        Move iKeyCode to KeyPair.KeyCode
101540>>>>>>>        Move iShiftCode to KeyPair.ShiftCode
101541>>>>>>>        Get pSearchKeys to Keys                
101542>>>>>>>        Move KeyPair to Keys[SizeOfArray(Keys)]
101543>>>>>>>        Set pSearchKeys to Keys                
101544>>>>>>>    End_Procedure
101545>>>>>>>
101545>>>>>>>    Procedure ClearSearchRequest
101547>>>>>>>        tGridKeyPair[] SearchKeys
101547>>>>>>>        tGridKeyPair[] SearchKeys
101548>>>>>>>        Set pSearchKeys to SearchKeys
101549>>>>>>>        Set pbRequestSearch to False
101550>>>>>>>    End_Procedure
101551>>>>>>>    
101551>>>>>>>End_Class
101552>>>>>Use cDbUpdateFunctionLibrary.pkg
101552>>>>>Use MSSqldrv.pkg
101552>>>>>Use db2_drv.pkg
101552>>>>>Use odbc_drv.pkg
101552>>>>>
101552>>>>>Object oDatabaseSelection_sl is a ModalPanel
101554>>>>>    Set Label to "SQL Database Selection"
101555>>>>>    Set Size to 121 183
101556>>>>>    Set piMinSize to 89 170
101557>>>>>    Set Location to 2 2
101558>>>>>    Set Border_Style to Border_Thick
101559>>>>>
101559>>>>>    Property String[] psTheData
101561>>>>>
101561>>>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
101563>>>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
101565>>>>>        End_Object
101566>>>>>    End
101566>>>>>>
101566>>>>>
101566>>>>>    Object oSelList is a cCJGridPromptList
101568>>>>>        Set Size to 89 167
101569>>>>>        Set Location to 6 6
101570>>>>>        Set peAnchors to anAll
101571>>>>>        Set pbAllowColumnRemove to False
101572>>>>>        Set pbUseAlternateRowBackgroundColor to True
101573>>>>>        Set pbGrayIfDisable to False
101574>>>>>        Set pbHeaderReorders to False
101575>>>>>        Set pbHeaderSelectsColumn to False
101576>>>>>        Set pbHeaderTogglesDirection to False
101577>>>>>        Set pbShadeSortColumn to False
101578>>>>>        Set piFocusCellBackColor to clDkGray
101579>>>>>
101579>>>>>        Object oName is a cCJGridColumn
101581>>>>>            Set piWidth to 334
101582>>>>>            Set psCaption to "Database Name"
101583>>>>>        End_Object
101584>>>>>
101584>>>>>        Procedure Activating
101587>>>>>            tDataSourceRow[] MyData
101587>>>>>            tDataSourceRow[] MyData
101588>>>>>            Handle hoDataSource
101588>>>>>            String[] sTheData
101589>>>>>            Integer iCount iSize
101589>>>>>
101589>>>>>            Send Cursor_Wait of Cursor_Control
101590>>>>>            Forward Send Activating
101592>>>>>
101592>>>>>            Get psTheData to sTheData
101593>>>>>            Move (SizeOfArray(sTheData)) to iSize
101594>>>>>            Decrement iSize
101595>>>>>            For iCount from 0 to iSize
101601>>>>>>
101601>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
101602>>>>>            Loop
101603>>>>>>
101603>>>>>
101603>>>>>            Get phoDataSource to hoDataSource
101604>>>>>            Send InitializeData of hoDataSource MyData
101605>>>>>            Send Cursor_Ready of Cursor_Control
101606>>>>>        End_Procedure
101607>>>>>
101607>>>>>    End_Object
101608>>>>>
101608>>>>>    Object oOK_Btn is a Button
101610>>>>>        Set Label    to "&OK"
101611>>>>>        Set Location to 100 68
101612>>>>>        Set peAnchors To anBottomRight
101613>>>>>
101613>>>>>        Procedure OnClick
101616>>>>>            Send Ok of oSelList
101617>>>>>        End_Procedure
101618>>>>>
101618>>>>>    End_Object
101619>>>>>
101619>>>>>    Object oCancel_Btn is a Button
101621>>>>>        Set Label    to "&Cancel"
101622>>>>>        Set Location to 100 123
101623>>>>>        Set peAnchors to anBottomRight
101624>>>>>
101624>>>>>        Procedure OnClick
101627>>>>>            Send Close_Panel
101628>>>>>        End_Procedure
101629>>>>>
101629>>>>>    End_Object
101630>>>>>
101630>>>>>    Procedure Page Integer iPageObject
101633>>>>>        Set Icon to "DatabaseLookup.ico"
101634>>>>>        Forward Send Page iPageObject
101636>>>>>    End_Procedure
101637>>>>>
101637>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
101638>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
101639>>>>>End_Object
101640>>>Use ServerSelection.dg
Including file: ServerSelection.dg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\ServerSelection.dg)
101640>>>>>Use Windows.pkg
101640>>>>>Use cCJGridPromptList.pkg
101640>>>>>Use cDbUpdateFunctionLibrary.pkg
101640>>>>>Use MSSqldrv.pkg
101640>>>>>Use db2_drv.pkg
101640>>>>>Use odbc_drv.pkg
101640>>>>>
101640>>>>>Object oServerSelection_sl is a ModalPanel
101642>>>>>    Set Size to 148 274
101643>>>>>    Set Label to "Database Server/DSN Selection"
101644>>>>>    Set piMinSize to 89 211
101645>>>>>    Set Location to 2 2
101646>>>>>    Set Border_Style to Border_Thick
101647>>>>>
101647>>>>>    Property String[] psTheData
101649>>>>>
101649>>>>>    Object oSelList is a cCJGridPromptList
101651>>>>>        Set Size to 115 264
101652>>>>>        Set Location to 6 6
101653>>>>>        Set peAnchors to anAll
101654>>>>>        Set pbAllowColumnRemove to False
101655>>>>>        Set pbUseAlternateRowBackgroundColor to True
101656>>>>>        Set pbGrayIfDisable to False
101657>>>>>        Set pbHeaderReorders to False
101658>>>>>        Set pbHeaderSelectsColumn to False
101659>>>>>        Set pbHeaderTogglesDirection to False
101660>>>>>        Set pbShadeSortColumn to False
101661>>>>>        Set piFocusCellBackColor to clDkGray
101662>>>>>
101662>>>>>        Object oName is a cCJGridColumn
101664>>>>>            Set piWidth to 528
101665>>>>>            Set psCaption to "Name"
101666>>>>>        End_Object
101667>>>>>
101667>>>>>        Procedure Activating
101670>>>>>            tDataSourceRow[] MyData
101670>>>>>            tDataSourceRow[] MyData
101671>>>>>            Handle hoDataSource
101671>>>>>            String[] sTheData
101672>>>>>            Integer iCount iSize
101672>>>>>
101672>>>>>            Send Cursor_Wait of Cursor_Control
101673>>>>>            Get psTheData to sTheData
101674>>>>>            Move (SizeOfArray(sTheData)) to iSize
101675>>>>>            Decrement iSize
101676>>>>>            For iCount from 0 to iSize
101682>>>>>>
101682>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
101683>>>>>            Loop
101684>>>>>>
101684>>>>>
101684>>>>>            Forward Send Activating
101686>>>>>
101686>>>>>            Get phoDataSource to hoDataSource
101687>>>>>            Send InitializeData of hoDataSource MyData
101688>>>>>            Send Cursor_Ready of Cursor_Control
101689>>>>>        End_Procedure
101690>>>>>
101690>>>>>    End_Object
101691>>>>>
101691>>>>>    Object oOK_Btn is a Button
101693>>>>>        Set Label    to "&OK"
101694>>>>>        Set Location to 130 165
101695>>>>>        Set peAnchors To anBottomRight
101696>>>>>
101696>>>>>        Procedure OnClick
101699>>>>>            Send Ok of oSelList
101700>>>>>        End_Procedure
101701>>>>>
101701>>>>>    End_Object
101702>>>>>
101702>>>>>    Object oCancel_Btn is a Button
101704>>>>>        Set Label    to "&Cancel"
101705>>>>>        Set Location to 130 220
101706>>>>>        Set peAnchors to anBottomRight
101707>>>>>
101707>>>>>        Procedure OnClick
101710>>>>>            Send Close_Panel
101711>>>>>        End_Procedure
101712>>>>>
101712>>>>>    End_Object
101713>>>>>
101713>>>>>    Procedure Page Integer iPageObject
101716>>>>>        Set Icon to "ServerLookup.ico"
101717>>>>>        Forward Send Page iPageObject
101719>>>>>    End_Procedure
101720>>>>>
101720>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
101721>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
101722>>>>>End_Object
101723>>>Use ManageSQLConnections.dg
Including file: ManageSQLConnections.dg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\ManageSQLConnections.dg)
101723>>>>>Use Windows.pkg
101723>>>>>Use Cursor.pkg
101723>>>>>Use cButtonDPI.pkg
101723>>>>>Use cSQLCheckBox.pkg
Including file: cSQLCheckBox.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cSQLCheckBox.pkg)
101723>>>>>>>Use Windows.pkg
101723>>>>>>>
101723>>>>>>>// Used by the "Page" message below to show
101723>>>>>>>// a rectangle around ComboForm and Checkbox objects.
101723>>>>>>>    Define WM_CHANGEUISTATE for |CI$0127
101723>>>>>>>    Define WM_UPDATEUISTATE for |CI$0128
101723>>>>>>>    Define WM_QUERYUISTATE  for |CI$0129
101723>>>>>>>    Define UIS_SET          for 1
101723>>>>>>>    Define UIS_CLEAR        for 2
101723>>>>>>>    Define UIS_INITIALIZE   for 3
101723>>>>>>>    Define UISF_HIDEFOCUS   for |CI$1
101723>>>>>>>    Define UISF_HIDEACCEL   for |CI$2
101723>>>>>>>    Define UISF_ACTIVE      for |CI$4
101723>>>>>>>
101723>>>>>>>Class cSQLCheckBox is a CheckBox
101724>>>>>>>    Procedure Construct_Object
101726>>>>>>>        Forward Send Construct_Object
101728>>>>>>>        // The piItem should be set to the object's corresponding tSQLConnection member (One based)
101728>>>>>>>        Property Integer piItem
101729>>>>>>>    End_Procedure
101730>>>>>>>
101730>>>>>>>    Procedure DbTypeUpdate Integer iDbType String sDriverID
101732>>>>>>>    End_Procedure
101733>>>>>>>
101733>>>>>>>    Procedure ReadConnectionData String[] sConnectionData
101735>>>>>>>        Integer iItem
101735>>>>>>>        Get piItem to iItem
101736>>>>>>>        Set Checked_State to (sConnectionData[iItem] = "1")
101737>>>>>>>    End_Procedure
101738>>>>>>>
101738>>>>>>>    Procedure WriteConnectionData String[] ByRef sConnectionData
101740>>>>>>>        Boolean bState
101740>>>>>>>        Integer iItem
101740>>>>>>>        Get piItem to iItem
101741>>>>>>>        Get Checked_State to bState
101742>>>>>>>        Move bState to sConnectionData[iItem]
101743>>>>>>>    End_Procedure
101744>>>>>>>
101744>>>>>>>    Procedure Set psToolTip String sToolTip
101746>>>>>>>        String sStatusHelp
101746>>>>>>>
101746>>>>>>>        Get Status_Help to sStatusHelp
101747>>>>>>>        If (sStatusHelp = "") Begin
101749>>>>>>>            Set Status_Help to sToolTip
101750>>>>>>>        End
101750>>>>>>>>
101750>>>>>>>
101750>>>>>>>        Forward Set psToolTip to sToolTip
101752>>>>>>>    End_Function
101753>>>>>>>
101753>>>>>>>    // Fix for a bug when using manifest files & running Vista and above.
101753>>>>>>>    // The bug being that the focus rectangle doesn't show.
101753>>>>>>>    Procedure Page Integer iPageObject
101755>>>>>>>        Handle hWnd
101755>>>>>>>        Integer iRet iState
101755>>>>>>>
101755>>>>>>>        Forward Send Page iPageObject
101757>>>>>>>
101757>>>>>>>        If (iPageObject) Begin
101759>>>>>>>            Get Window_Handle to hWnd
101760>>>>>>>            If (hWnd) Begin
101762>>>>>>>                Move (SendMessage(hWnd, WM_QUERYUISTATE, 0, 0)) to iRet
101763>>>>>>>                If (iRet iand UISF_HIDEFOCUS) Begin
101765>>>>>>>                    Move (UIS_CLEAR + (UISF_HIDEFOCUS * 65536)) to iState
101766>>>>>>>                    Move (SendMessage(hWnd, WM_UPDATEUISTATE, iState, 0)) to iRet
101767>>>>>>>                End
101767>>>>>>>>
101767>>>>>>>            End
101767>>>>>>>>
101767>>>>>>>        End
101767>>>>>>>>
101767>>>>>>>    End_Procedure
101768>>>>>>>
101768>>>>>>>End_Class
101769>>>>>Use cSQLComboForm.pkg
Including file: cSQLComboForm.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cSQLComboForm.pkg)
101769>>>>>>>Use Windows.pkg
101769>>>>>>>
101769>>>>>>>// Used by the "Page" message below to show
101769>>>>>>>// a rectangle around ComboForm and Checkbox objects.
101769>>>>>>>
101769>>>>>>>Class cSQLComboForm is a ComboForm
101770>>>>>>>    Procedure Construct_Object
101772>>>>>>>        Forward Send Construct_Object
101774>>>>>>>
101774>>>>>>>        // This will shadow the label if the form itself has its Enabled_State=False
101774>>>>>>>        Property Boolean pbAutoShadowLabelObject True
101775>>>>>>>
101775>>>>>>>        // The piItem should be set to the object's corresponding tSQLConnection member (One based)
101775>>>>>>>        Property Integer piItem
101776>>>>>>>    End_Procedure
101777>>>>>>>
101777>>>>>>>    Procedure End_Construct_Object
101779>>>>>>>        Boolean bAutoShadowLabelObject
101779>>>>>>>        Get pbAutoShadowLabelObject to bAutoShadowLabelObject
101780>>>>>>>        If (bAutoShadowLabelObject = True) Begin
101782>>>>>>>            Set Private.Label_Shadow_Display_Mode to TBSHADOW_ON_LOCAL
101783>>>>>>>        End
101783>>>>>>>>
101783>>>>>>>        Forward Send End_Construct_Object
101785>>>>>>>    End_Procedure
101786>>>>>>>
101786>>>>>>>    Procedure DbTypeUpdate Integer iDbType String sDriverID
101788>>>>>>>    End_Procedure
101789>>>>>>>
101789>>>>>>>    Procedure ReadConnectionData String[] sConnectionData
101791>>>>>>>        Integer iItem
101791>>>>>>>        Get piItem to iItem
101792>>>>>>>        Set Value to sConnectionData[iItem]
101793>>>>>>>    End_Procedure
101794>>>>>>>
101794>>>>>>>    Procedure WriteConnectionData String[] ByRef sConnectionData
101796>>>>>>>        String sValue
101796>>>>>>>        Integer iItem
101796>>>>>>>        Get piItem to iItem
101797>>>>>>>        Get Value to sValue
101798>>>>>>>        Move sValue to sConnectionData[iItem]
101799>>>>>>>    End_Procedure
101800>>>>>>>
101800>>>>>>>    Procedure Set psToolTip String sToolTip
101802>>>>>>>        String sStatusHelp
101802>>>>>>>
101802>>>>>>>        Get Status_Help to sStatusHelp
101803>>>>>>>        If (sStatusHelp = "") Begin
101805>>>>>>>            Set Status_Help to sToolTip
101806>>>>>>>        End
101806>>>>>>>>
101806>>>>>>>
101806>>>>>>>        Forward Set psToolTip to sToolTip
101808>>>>>>>    End_Function
101809>>>>>>>
101809>>>>>>>    // Fix for a bug when using manifest files & running Vista and above.
101809>>>>>>>    // The bug being that the focus rectangle doesn't show.
101809>>>>>>>    Procedure Page Integer iPageObject
101811>>>>>>>        Handle hWnd
101811>>>>>>>        Integer iRet iState
101811>>>>>>>
101811>>>>>>>        Forward Send Page iPageObject
101813>>>>>>>
101813>>>>>>>        If (iPageObject) Begin
101815>>>>>>>            Get Window_Handle to hWnd
101816>>>>>>>            If (hWnd) Begin
101818>>>>>>>                Move (SendMessage(hWnd, WM_QUERYUISTATE, 0, 0)) to iRet
101819>>>>>>>                If (iRet iand UISF_HIDEFOCUS) Begin
101821>>>>>>>                    Move (UIS_CLEAR + (UISF_HIDEFOCUS * 65536)) to iState
101822>>>>>>>                    Move (SendMessage(hWnd, WM_UPDATEUISTATE, iState, 0)) to iRet
101823>>>>>>>                End
101823>>>>>>>>
101823>>>>>>>            End
101823>>>>>>>>
101823>>>>>>>        End
101823>>>>>>>>
101823>>>>>>>    End_Procedure
101824>>>>>>>
101824>>>>>>>End_Class
101825>>>>>Use cSQLForm.pkg
Including file: cSQLForm.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cSQLForm.pkg)
101825>>>>>>>Use Windows.pkg
101825>>>>>>>
101825>>>>>>>Class cSQLForm is a Form
101826>>>>>>>    Procedure Construct_Object
101828>>>>>>>        Forward Send Construct_Object
101830>>>>>>>
101830>>>>>>>        // This will shadow the label if the form itself has its Enabled_State=False
101830>>>>>>>        Property Boolean pbAutoShadowLabelObject True
101831>>>>>>>
101831>>>>>>>        // The piItem should be set to the object's corresponding tSQLConnection member (One based)
101831>>>>>>>        Property Integer piItem
101832>>>>>>>    End_Procedure
101833>>>>>>>
101833>>>>>>>    Procedure End_Construct_Object
101835>>>>>>>        Boolean bAutoShadowLabelObject
101835>>>>>>>        Get pbAutoShadowLabelObject to bAutoShadowLabelObject
101836>>>>>>>        If (bAutoShadowLabelObject = True) Begin
101838>>>>>>>            Set Private.Label_Shadow_Display_Mode to TBSHADOW_ON_LOCAL
101839>>>>>>>        End
101839>>>>>>>>
101839>>>>>>>        Forward Send End_Construct_Object
101841>>>>>>>    End_Procedure
101842>>>>>>>
101842>>>>>>>    Procedure DbTypeUpdate Integer iDbType String sDriverID
101844>>>>>>>    End_Procedure
101845>>>>>>>
101845>>>>>>>    Procedure ReadConnectionData String[] sConnectionData
101847>>>>>>>        Integer iItem
101847>>>>>>>        Get piItem to iItem
101848>>>>>>>        Set Value to sConnectionData[iItem]
101849>>>>>>>    End_Procedure
101850>>>>>>>
101850>>>>>>>    Procedure WriteConnectionData String[] ByRef sConnectionData
101852>>>>>>>        String sValue
101852>>>>>>>        Integer iItem
101852>>>>>>>        Get piItem to iItem
101853>>>>>>>        Get Value to sValue
101854>>>>>>>        Move sValue to sConnectionData[iItem]
101855>>>>>>>    End_Procedure
101856>>>>>>>
101856>>>>>>>    Procedure Set psToolTip String sToolTip
101858>>>>>>>        String sStatusHelp
101858>>>>>>>
101858>>>>>>>        Get Status_Help to sStatusHelp
101859>>>>>>>        If (sStatusHelp = "") Begin
101861>>>>>>>            Set Status_Help to sToolTip
101862>>>>>>>        End
101862>>>>>>>>
101862>>>>>>>
101862>>>>>>>        Forward Set psToolTip to sToolTip
101864>>>>>>>    End_Function
101865>>>>>>>
101865>>>>>>>End_Class
101866>>>>>Use cSQLConnectionHandler.pkg
101866>>>>>Use cDbUpdateFunctionLibrary.pkg
101866>>>>>Use cDbUpdateDatabaseDriver.pkg
101866>>>>>Use DatabaseSelection.dg
101866>>>>>Use ServerSelection.dg
101866>>>>>Use TableSpaceSelection.dg
Including file: TableSpaceSelection.dg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\TableSpaceSelection.dg)
101866>>>>>>>Use Windows.pkg
101866>>>>>>>Use cCJGridPromptList.pkg
101866>>>>>>>Use cDbUpdateFunctionLibrary.pkg
101866>>>>>>>
101866>>>>>>>Object oTableSpaceSelection_sl is a ModalPanel
101868>>>>>>>    Set Size to 118 177
101869>>>>>>>    Set Label to "SQL Tablespace Selection"
101870>>>>>>>    Set piMinSize to 89 177
101871>>>>>>>    Set Location to 2 2
101872>>>>>>>    Set Border_Style to Border_Thick
101873>>>>>>>
101873>>>>>>>    Property String[] psTheData
101875>>>>>>>
101875>>>>>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
101877>>>>>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
101879>>>>>>>        End_Object
101880>>>>>>>    End
101880>>>>>>>>
101880>>>>>>>
101880>>>>>>>    Object oSelList is a cCJGridPromptList
101882>>>>>>>        Set Size to 89 167
101883>>>>>>>        Set Location to 6 6
101884>>>>>>>        Set peAnchors to anAll
101885>>>>>>>        Set pbAllowColumnRemove to False
101886>>>>>>>        Set pbUseAlternateRowBackgroundColor to True
101887>>>>>>>        Set pbGrayIfDisable to False
101888>>>>>>>        Set pbHeaderReorders to False
101889>>>>>>>        Set pbHeaderSelectsColumn to False
101890>>>>>>>        Set pbHeaderTogglesDirection to False
101891>>>>>>>        Set pbShadeSortColumn to False
101892>>>>>>>        Set piFocusCellBackColor to clDkGray
101893>>>>>>>
101893>>>>>>>        Object oName is a cCJGridColumn
101895>>>>>>>            Set piWidth to 334
101896>>>>>>>            Set psCaption to "Table Space Name"
101897>>>>>>>        End_Object
101898>>>>>>>
101898>>>>>>>        Procedure Activating
101901>>>>>>>            tDataSourceRow[] MyData
101901>>>>>>>            tDataSourceRow[] MyData
101902>>>>>>>            Handle hoDataSource
101902>>>>>>>            String[] sTheData
101903>>>>>>>            Integer iCount iSize
101903>>>>>>>
101903>>>>>>>            Send Cursor_Wait of Cursor_Control
101904>>>>>>>            Forward Send Activating
101906>>>>>>>
101906>>>>>>>            Get psTheData to sTheData
101907>>>>>>>            Move (SizeOfArray(sTheData)) to iSize
101908>>>>>>>            Decrement iSize
101909>>>>>>>            For iCount from 0 to iSize
101915>>>>>>>>
101915>>>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
101916>>>>>>>            Loop
101917>>>>>>>>
101917>>>>>>>
101917>>>>>>>            Get phoDataSource to hoDataSource
101918>>>>>>>            Send InitializeData of hoDataSource MyData
101919>>>>>>>            Send Cursor_Ready of Cursor_Control
101920>>>>>>>        End_Procedure
101921>>>>>>>
101921>>>>>>>    End_Object
101922>>>>>>>
101922>>>>>>>    Object oOK_Btn is a Button
101924>>>>>>>        Set Label    to "&OK"
101925>>>>>>>        Set Location to 100 68
101926>>>>>>>        Set peAnchors To anBottomRight
101927>>>>>>>
101927>>>>>>>        Procedure OnClick
101930>>>>>>>            Send Ok of oSelList
101931>>>>>>>        End_Procedure
101932>>>>>>>
101932>>>>>>>    End_Object
101933>>>>>>>
101933>>>>>>>    Object oCancel_Btn is a Button
101935>>>>>>>        Set Label    to "&Cancel"
101936>>>>>>>        Set Location to 100 123
101937>>>>>>>        Set peAnchors to anBottomRight
101938>>>>>>>
101938>>>>>>>        Procedure OnClick
101941>>>>>>>            Send Close_Panel
101942>>>>>>>        End_Procedure
101943>>>>>>>
101943>>>>>>>    End_Object
101944>>>>>>>
101944>>>>>>>    Procedure Page Integer iPageObject
101947>>>>>>>        Set Icon to "DatabaseLookup.ico"
101948>>>>>>>        Forward Send Page iPageObject
101950>>>>>>>    End_Procedure
101951>>>>>>>
101951>>>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
101952>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
101953>>>>>>>End_Object
101954>>>>>Use SchemasSelection.dg
Including file: SchemasSelection.dg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\SchemasSelection.dg)
101954>>>>>>>Use Windows.pkg
101954>>>>>>>Use cCJGridPromptList.pkg
101954>>>>>>>Use cDbUpdateFunctionLibrary.pkg
101954>>>>>>>
101954>>>>>>>Object oSchemasSelection_sl is a ModalPanel
101956>>>>>>>    Set Size to 118 177
101957>>>>>>>    Set Label to "SQL Schemas Selection"
101958>>>>>>>    Set piMinSize to 89 177
101959>>>>>>>    Set Location to 2 2
101960>>>>>>>    Set Border_Style to Border_Thick
101961>>>>>>>
101961>>>>>>>    Property String[] psTheData
101963>>>>>>>
101963>>>>>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
101965>>>>>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
101967>>>>>>>        End_Object
101968>>>>>>>    End
101968>>>>>>>>
101968>>>>>>>
101968>>>>>>>    Object oSelList is a cCJGridPromptList
101970>>>>>>>        Set Size to 89 167
101971>>>>>>>        Set Location to 6 6
101972>>>>>>>        Set peAnchors to anAll
101973>>>>>>>        Set pbAllowColumnRemove to False
101974>>>>>>>        Set pbUseAlternateRowBackgroundColor to True
101975>>>>>>>        Set pbGrayIfDisable to False
101976>>>>>>>        Set pbHeaderReorders to False
101977>>>>>>>        Set pbHeaderSelectsColumn to False
101978>>>>>>>        Set pbHeaderTogglesDirection to False
101979>>>>>>>        Set pbShadeSortColumn to False
101980>>>>>>>        Set piFocusCellBackColor to clDkGray
101981>>>>>>>
101981>>>>>>>        Object oName is a cCJGridColumn
101983>>>>>>>            Set piWidth to 334
101984>>>>>>>            Set psCaption to "Schema Name"
101985>>>>>>>        End_Object
101986>>>>>>>
101986>>>>>>>        Procedure Activating
101989>>>>>>>            tDataSourceRow[] MyData
101989>>>>>>>            tDataSourceRow[] MyData
101990>>>>>>>            Handle hoDataSource
101990>>>>>>>            String[] sTheData
101991>>>>>>>            Integer iCount iSize
101991>>>>>>>
101991>>>>>>>            Send Cursor_Wait of Cursor_Control
101992>>>>>>>            Forward Send Activating
101994>>>>>>>
101994>>>>>>>            Get psTheData to sTheData
101995>>>>>>>
101995>>>>>>>            Move (SizeOfArray(sTheData)) to iSize
101996>>>>>>>            Decrement iSize
101997>>>>>>>            For iCount from 0 to iSize
102003>>>>>>>>
102003>>>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
102004>>>>>>>            Loop
102005>>>>>>>>
102005>>>>>>>
102005>>>>>>>            Get phoDataSource to hoDataSource
102006>>>>>>>            Send InitializeData of hoDataSource MyData
102007>>>>>>>            Send Cursor_Ready of Cursor_Control
102008>>>>>>>        End_Procedure
102009>>>>>>>
102009>>>>>>>    End_Object
102010>>>>>>>
102010>>>>>>>    Object oOK_Btn is a Button
102012>>>>>>>        Set Label    to "&OK"
102013>>>>>>>        Set Location to 100 68
102014>>>>>>>        Set peAnchors To anBottomRight
102015>>>>>>>
102015>>>>>>>        Procedure OnClick
102018>>>>>>>            Send Ok of oSelList
102019>>>>>>>        End_Procedure
102020>>>>>>>
102020>>>>>>>    End_Object
102021>>>>>>>
102021>>>>>>>    Object oCancel_Btn is a Button
102023>>>>>>>        Set Label    to "&Cancel"
102024>>>>>>>        Set Location to 100 123
102025>>>>>>>        Set peAnchors to anBottomRight
102026>>>>>>>
102026>>>>>>>        Procedure OnClick
102029>>>>>>>            Send Close_Panel
102030>>>>>>>        End_Procedure
102031>>>>>>>
102031>>>>>>>    End_Object
102032>>>>>>>
102032>>>>>>>    Procedure Page Integer iPageObject
102035>>>>>>>        Set Icon to "DatabaseLookup.ico"
102036>>>>>>>        Forward Send Page iPageObject
102038>>>>>>>    End_Procedure
102039>>>>>>>
102039>>>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
102040>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
102041>>>>>>>End_Object
102042>>>>>Use cHeaderGroup.pkg
Including file: cHeaderGroup.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cHeaderGroup.pkg)
102042>>>>>>>Use Windows.pkg
102042>>>>>>>
102042>>>>>>>Use cCommandLinkButton.pkg
Including file: cCommandLinkButton.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCommandLinkButton.pkg)
102042>>>>>>>>>// cCommandLinkButton class
102042>>>>>>>>>
102042>>>>>>>>>// This requires version 6 of common controls (vista or windows server 2008). If used with
102042>>>>>>>>>// older versions you will just get a regular great big button.
102042>>>>>>>>> 
102042>>>>>>>>>Use Windows.pkg
102042>>>>>>>>>Use CharTranslate.pkg
102042>>>>>>>>>
102042>>>>>>>>>Class cCommandLinkButton is a Button
102043>>>>>>>>>
102043>>>>>>>>>        Procedure Construct_Object
102045>>>>>>>>>            Forward Send Construct_Object
102047>>>>>>>>>            Property String psPrivateNote
102048>>>>>>>>>        End_Procedure
102049>>>>>>>>>        
102049>>>>>>>>>        Procedure Set psNote String sNote
102051>>>>>>>>>            Boolean bSupported
102051>>>>>>>>>            Set psPrivateNote to sNote
102052>>>>>>>>>            Get IsExControlSupported to bSupported
102053>>>>>>>>>            If bSupported Begin
102055>>>>>>>>>                Send SetWinNote
102056>>>>>>>>>            End
102056>>>>>>>>>>
102056>>>>>>>>>        End_Procedure
102057>>>>>>>>>        
102057>>>>>>>>>        Procedure SetWinNote
102059>>>>>>>>>            String sNote
102059>>>>>>>>>            Handle hWnd
102059>>>>>>>>>            Integer i
102059>>>>>>>>>            Address aVar
102059>>>>>>>>>            Get Form_Window_Handle 0 to hWnd
102060>>>>>>>>>            If hWnd Begin
102062>>>>>>>>>                Get psNote to sNote
102063>>>>>>>>>                Move (OemToUtf16Buffer(AddressOf(sNote),Length(sNote))) to aVar
102064>>>>>>>>>                Move (SendMessage(hwnd, BCM_SETNOTE, 0, aVar)) to i
102065>>>>>>>>>                Move (Free(aVar)) to i 
102066>>>>>>>>>            End
102066>>>>>>>>>>
102066>>>>>>>>>        End_Procedure
102067>>>>>>>>>        
102067>>>>>>>>>        
102067>>>>>>>>>        Function psNote Returns String
102069>>>>>>>>>            Function_Return (psPrivateNote(Self))
102070>>>>>>>>>        End_Function
102071>>>>>>>>>        
102071>>>>>>>>>
102071>>>>>>>>>        Procedure Page Integer iState
102073>>>>>>>>>            Integer i hWnd
102073>>>>>>>>>            Boolean bSupported
102073>>>>>>>>>            Get IsExControlSupported to bSupported
102074>>>>>>>>>            If (iState=1 and bSupported) Begin
102076>>>>>>>>>                Get form_style i to i
102077>>>>>>>>>                Set Form_Style 0 to (i ior (BS_COMMANDLINK + BS_FLAT))
102078>>>>>>>>>                Forward Send Page iState
102080>>>>>>>>>                Send SetWinNote
102081>>>>>>>>>            End
102081>>>>>>>>>>
102081>>>>>>>>>            Else Begin
102082>>>>>>>>>                Forward Send Page iState
102084>>>>>>>>>            End
102084>>>>>>>>>>
102084>>>>>>>>>        End_Procedure        
102085>>>>>>>>>
102085>>>>>>>>>End_Class
102086>>>>>>>Class cHeaderGroupImage is a cCommandLinkButton
102087>>>>>>>    Procedure Construct_Object
102089>>>>>>>        Forward Send Construct_Object
102091>>>>>>>            Set piImageSize to 24
102092>>>>>>>        Set Focus_Mode to NonFocusable
102093>>>>>>>    End_Procedure
102094>>>>>>>
102094>>>>>>>
102094>>>>>>>    Procedure OnClick
102096>>>>>>>        Broadcast Send Prompt of (Parent(Self))
102098>>>>>>>    End_Procedure
102099>>>>>>>
102099>>>>>>>    Procedure Set Bitmap String sBitmapName
102101>>>>>>>        Forward Set psImage to sBitmapName
102103>>>>>>>    End_Procedure
102104>>>>>>>
102104>>>>>>>    Procedure End_Construct_Object
102106>>>>>>>        Forward Send End_Construct_Object
102108>>>>>>>    End_Procedure
102109>>>>>>>
102109>>>>>>>End_Class
102110>>>>>>>
102110>>>>>>>// Intermediate class - don't use.
102110>>>>>>>Class _cHeaderGroup is a Container3d
102111>>>>>>>
102111>>>>>>>    Register_Object oInfo_tb
102111>>>>>>>
102111>>>>>>>    Procedure Construct_Object
102113>>>>>>>        Forward Send Construct_Object
102115>>>>>>>
102115>>>>>>>        Property String private.psImage
102116>>>>>>>        Property String private.psLabel
102117>>>>>>>    End_Procedure
102118>>>>>>>
102118>>>>>>>    Procedure Set psImage String sImage
102120>>>>>>>        Set private.psImage to sImage
102121>>>>>>>    End_Procedure
102122>>>>>>>
102122>>>>>>>    Function psImage Returns String
102124>>>>>>>        Function_Return (private.psImage(Self))
102125>>>>>>>    End_Function
102126>>>>>>>
102126>>>>>>>    Procedure Set psLabel String sLabel
102128>>>>>>>        Set private.psLabel to sLabel
102129>>>>>>>    End_Procedure
102130>>>>>>>
102130>>>>>>>    Function psLabel Returns String
102132>>>>>>>        Function_Return (private.psLabel(Self))
102133>>>>>>>    End_Function
102134>>>>>>>
102134>>>>>>>    // Don't display but allow to use old "Label" syntax to set the value of the oInfo_tb object (header text)
102134>>>>>>>    Procedure Set Label String sLabel
102136>>>>>>>        Set private.psLabel to sLabel
102137>>>>>>>        Set Label of oInfo_tb to sLabel
102138>>>>>>>    End_Procedure
102139>>>>>>>
102139>>>>>>>    Function Label Returns String
102141>>>>>>>        Function_Return (private.psLabel(Self))
102142>>>>>>>    End_Function
102143>>>>>>>
102143>>>>>>>End_Class
102144>>>>>>>
102144>>>>>>>Class cHeaderGroup is a _cHeaderGroup
102145>>>>>>>
102145>>>>>>>    Procedure Construct_Object
102147>>>>>>>        Forward Send Construct_Object
102149>>>>>>>
102149>>>>>>>        Set peAnchors to anTopLeftRight
102150>>>>>>>        //Set Color to clWhite
102150>>>>>>>        Set pbAcceptDropFiles to True
102151>>>>>>>        Set Border_Style to Border_Normal
102152>>>>>>>
102152>>>>>>>        Property Integer private.piColorOrg
102153>>>>>>>        Property Boolean private.pbIsHeaderGroup True // Don't touch!
102154>>>>>>>
102154>>>>>>>            Property Integer piBitmapColOffset 4
102155>>>>>>>            Property Integer piBitmapRowOffset 1
102156>>>>>>>
102156>>>>>>>        Property Boolean pbUseHotspotColor True
102157>>>>>>>        Property Integer piHeaderHotspotColor clAqua
102158>>>>>>>        Property String psLabel ""
102159>>>>>>>        Property Integer piLabelColor clBlack
102160>>>>>>>        Property Boolean pbLabelFontItalics False
102161>>>>>>>        Property Integer piLabelFontPointHeight False
102162>>>>>>>        Property Integer piLabelFontPointWeight fw_Bold
102163>>>>>>>        Property Integer piLabelColOffset 25
102164>>>>>>>        Property Integer piLabelRowOffset 3 //4
102165>>>>>>>
102165>>>>>>>    End_Procedure
102166>>>>>>>
102166>>>>>>>    Procedure End_Construct_Object
102168>>>>>>>
102168>>>>>>>        Object oImage_bmp is a cHeaderGroupImage
102170>>>>>>>            Set Location to (piBitmapRowOffset(Self)) (piBitmapColOffset(Self))
102171>>>>>>>                Set Size to 14 18
102172>>>>>>>            Set Bitmap to (private.psImage(Self))
102173>>>>>>>        End_Object
102174>>>>>>>
102174>>>>>>>        Object oInfo_tb is a TextBox
102176>>>>>>>            Set Auto_Size_State to False
102177>>>>>>>            Set Size to 10 150
102178>>>>>>>            Set Location to (piLabelRowOffset(Self)) (piLabelColOffset(Self))
102179>>>>>>>            Set FontWeight to (piLabelFontPointWeight(Self))
102180>>>>>>>            Set FontItalics to (pbLabelFontItalics(Self))
102181>>>>>>>            Set FontPointHeight to (piLabelFontPointHeight(Self))
102182>>>>>>>            Set Label to (psLabel(Self))
102183>>>>>>>            Set TextColor to (piLabelColor(Self))
102184>>>>>>>        End_Object
102185>>>>>>>
102185>>>>>>>        Forward Send End_Construct_Object
102187>>>>>>>    End_Procedure
102188>>>>>>>
102188>>>>>>>    Procedure OnEnterArea Handle hoFrom
102190>>>>>>>        Integer iColor
102190>>>>>>>        Forward Send OnEnterArea hoFrom
102192>>>>>>>        // ToDo: Not perfect, but works most of the time.
102192>>>>>>>        //       When navigating to i.e a popup we don't want
102192>>>>>>>        //       the coloring to appear. Else there will be 2
102192>>>>>>>        //       cHeaderGroup's with the highlight color...
102192>>>>>>>        // Is there a better way?
102192>>>>>>>        If (hoFrom <> Desktop and hoFrom < Parent(Self)) Begin
102194>>>>>>>            Procedure_Return
102195>>>>>>>        End
102195>>>>>>>>
102195>>>>>>>        If (pbUseHotspotColor(Self) = True) Begin
102197>>>>>>>            Get Color to iColor
102198>>>>>>>            Set private.piColorOrg to iColor
102199>>>>>>>            Get piHeaderHotspotColor to iColor
102200>>>>>>>            Set Color to iColor
102201>>>>>>>            Broadcast Recursive Set Color to iColor
102203>>>>>>>        End
102203>>>>>>>>
102203>>>>>>>    End_Procedure
102204>>>>>>>
102204>>>>>>>    Procedure OnExitArea Handle hoFrom
102206>>>>>>>        Integer iColor
102206>>>>>>>        Forward Send OnExitArea hoFrom
102208>>>>>>>        If (pbUseHotspotColor(Self) = True) Begin
102210>>>>>>>            Get private.piColorOrg to iColor
102211>>>>>>>            Set Color to iColor
102212>>>>>>>            Broadcast Recursive Set Color to iColor
102214>>>>>>>        End
102214>>>>>>>>
102214>>>>>>>    End_Procedure
102215>>>>>>>
102215>>>>>>>    // Public access message to change the group header text color at runtime.
102215>>>>>>>    Procedure Set Label_Color Integer iColor
102217>>>>>>>        Set TextColor of oInfo_tb to iColor
102218>>>>>>>    End_Procedure
102219>>>>>>>
102219>>>>>>>    Procedure NavigatePrevious
102221>>>>>>>        Integer iMulti ivoid
102221>>>>>>>        Handle hWnd
102221>>>>>>>
102221>>>>>>>        Move False to Err
102222>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
102223>>>>>>>        Get Select_Mode of (Focus(Self)) to iMulti
102224>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
102225>>>>>>>        If (Err) Begin
102227>>>>>>>            Procedure_Return
102228>>>>>>>        End
102228>>>>>>>>
102228>>>>>>>
102228>>>>>>>        If (iMulti = Multi_Select) Begin
102230>>>>>>>            Send Previous
102231>>>>>>>        End
102231>>>>>>>>
102231>>>>>>>        Else Begin
102232>>>>>>>            Get Form_Window_Handle of (Focus(Self)) to hWnd
102233>>>>>>>            Move (Sendmessage(hWnd,WM_KEYDOWN,Ascii(VK_LEFT),0)) to iVoid
102234>>>>>>>        End
102234>>>>>>>>
102234>>>>>>>    End_Procedure
102235>>>>>>>
102235>>>>>>>    Procedure NavigateNext
102237>>>>>>>        Integer iMulti ivoid
102237>>>>>>>        Handle hWnd
102237>>>>>>>
102237>>>>>>>        Move False to Err
102238>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
102239>>>>>>>        Get Select_Mode of (Focus(Self)) to iMulti
102240>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
102241>>>>>>>        If (Err) Begin
102243>>>>>>>            Procedure_Return
102244>>>>>>>        End
102244>>>>>>>>
102244>>>>>>>
102244>>>>>>>        If (iMulti = Multi_Select) Begin
102246>>>>>>>            Send Next
102247>>>>>>>        End
102247>>>>>>>>
102247>>>>>>>        Else Begin
102248>>>>>>>            Get Form_Window_Handle of (Focus(Self)) to hWnd
102249>>>>>>>            Move (Sendmessage(hWnd,WM_KEYDOWN,Ascii(VK_LEFT),0)) to iVoid
102250>>>>>>>        End
102250>>>>>>>>
102250>>>>>>>
102250>>>>>>>    End_Procedure
102251>>>>>>>
102251>>>>>>>    On_Key kLeftArrow  Send NavigatePrevious
102252>>>>>>>    On_Key kRightArrow Send NavigateNext
102253>>>>>>>End_Class
102254>>>>>>>
102254>>>>>>>// We don't want the broadcast of setting color to set the background
102254>>>>>>>// color for forms that are within a cHeaderGroup object.
102254>>>>>>>Procedure Set Color for Form Integer eColor
102256>>>>>>>    Boolean bIsHeaderGroup
102256>>>>>>>    Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
102257>>>>>>>    Delegate Get private.pbIsHeaderGroup to bIsHeaderGroup
102259>>>>>>>    Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
102260>>>>>>>    If (bIsHeaderGroup = False) Begin
102262>>>>>>>        Forward Set Color to eColor
102264>>>>>>>    End
102264>>>>>>>>
102264>>>>>>>End_Procedure
102265>>>>>>>
102265>>>>>
102265>>>>>Define CS_LoadingServers        for "Enumerating servers..."
102265>>>>>Define CS_LoadingDatabases      for "Enumerating databases..."
102265>>>>>Define CS_LoadingTableSpaces    for "Enumerating table spaces..."
102265>>>>>Define CS_LoadingSchemas        for "Enumerating schemas..."
102265>>>>>Define CS_LoginAttempt          for "Connecting..."
102265>>>>>Define CS_LoginSuccessful       for "Login successful!"
102265>>>>>Define CS_LoginFailed           for "Login failed!"
102265>>>>>Define CS_DF_File_Schema        for "Schema"
102265>>>>>Define CS_DF_File_Owner         for "Owner"
102265>>>>>
102265>>>>>Object oSQLMaintainConnections_dg is a ModalPanel
102267>>>>>    Set Label to "Edit SQL Connection"
102268>>>>>    Set Size to 291 410
102269>>>>>    Set Location to 4 6
102270>>>>>    Set Locate_Mode to Center_On_Parent
102271>>>>>    Set Border_Style to Border_Thick
102272>>>>>    Set piMaxSize to (Hi(Size(Self))) (Low(Size(Self)) + 300)
102273>>>>>    Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
102274>>>>>
102274>>>>>    Property Boolean pbReadOnly  False
102276>>>>>    Property Boolean pbNew       False // First time for a workspace, which means the .ini-file is empty.
102278>>>>>    Property Integer piCurrentRow -1   // The current row of the grid that was passed to this dialog.
102280>>>>>    Property Boolean pbChanged   False // If any change was made to the data.
102282>>>>>    Property Handle phoDialogCommandbar
102284>>>>>    Property tSQLConnection pSQLConnectionData
102286>>>>>    Property tDataSourceRow[] pTheData
102288>>>>>    Property Boolean pbDFConnId  False // Is set to True if this is a DAW "DFConnId.ini" file; in which case we warn to not encrypt/decrypt password. (different algorithms and don't touch password)
102290>>>>>    Property String psUncryptedPw     // Used if  pbDFConnId = True to temporary save the un-encrypted password.
102292>>>>>
102292>>>>>    Object oConnectionType_grp is a cHeaderGroup
102294>>>>>        Set Size to 70 389
102295>>>>>        Set Location to 2 11
102296>>>>>        Set psImage to "SelectTablesBlack24.bmp"
102297>>>>>        Set psLabel to "Connection Type"
102298>>>>>
102298>>>>>        Object oDbType_cf is a cSQLComboForm
102300>>>>>            Set Size to 11 120
102301>>>>>            Set Location to 23 86
102302>>>>>            Set Label_Col_Offset to 2
102303>>>>>            Set Label_Justification_Mode to JMode_Right
102304>>>>>            Set Label to "Database Type"
102305>>>>>            Set Entry_State to False
102306>>>>>            Set Combo_Sort_State to False
102307>>>>>            Set piItem to 3
102308>>>>>
102308>>>>>            Procedure Combo_Fill_List
102311>>>>>                Send Combo_Add_Item CS_dbTypeMSSQL
102312>>>>>                Send Combo_Add_Item CS_dbTypeMySQL
102313>>>>>                Send Combo_Add_Item CS_dbTypeOracle
102314>>>>>                Send Combo_Add_Item CS_dbTypeDB2
102315>>>>>                Send Combo_Add_Item CS_dbTypePostgre
102316>>>>>            End_Procedure
102317>>>>>
102317>>>>>        Procedure OnChange
102320>>>>>            Integer iDbType
102320>>>>>            String sDriverID
102320>>>>>
102320>>>>>            Get SelectedDbType to iDbType
102321>>>>>            Send Refill_Comboform of oDriverID_cf iDbType
102322>>>>>            Get Value of oDriverID_cf to sDriverID
102323>>>>>            If (sDriverID = "") Begin
102325>>>>>                Move MSSQLDRV_ID to sDriverID
102326>>>>>            End
102326>>>>>>
102326>>>>>            Send DbTypeUpdate of oSettings_grp iDbType sDriverID
102327>>>>>        End_Procedure
102328>>>>>
102328>>>>>        Function SelectedDbType Returns Integer
102331>>>>>            Integer iRetval
102331>>>>>            String sDbType
102331>>>>>
102331>>>>>            Get Value to sDbType
102332>>>>>            Get SqlUtilDbTypeToInteger of ghoDbUpdateFunctionLibrary sDbType to iRetval
102333>>>>>
102333>>>>>            Function_Return iRetval
102334>>>>>        End_Function
102335>>>>>
102335>>>>>        End_Object
102336>>>>>
102336>>>>>        Object oDriverID_cf is a cSQLComboForm
102338>>>>>            Set Size to 11 120
102339>>>>>            Set Location to 36 86
102340>>>>>            Set Label_Col_Offset to 2
102341>>>>>            Set Label_Justification_Mode to JMode_Right
102342>>>>>            Set Label to "Driver ID"
102343>>>>>            Set psToolTip to "Depending on the database type selected and if Mertech drivers have been installed, the comboform list will vary."
102344>>>>>            Set Entry_State to False
102345>>>>>            Set Combo_Sort_State to False
102346>>>>>            Set piItem to 4
102347>>>>>
102347>>>>>            Procedure Refill_Comboform Integer iDbType
102350>>>>>                String sValue
102350>>>>>                Send Combo_Delete_Data
102351>>>>>                Case Begin
102351>>>>>                    Case (iDbType = EN_dbTypeMSSQL)
102353>>>>>                        Send Combo_Add_Item MSSQLDRV_ID
102354>>>>>                        Send Combo_Add_Item SQLFLEX
102355>>>>>                        Move MSSQLDRV_ID to sValue
102356>>>>>                        Case Break
102357>>>>>                    Case (iDbType = EN_dbTypeMySQL)
102360>>>>>                        Send Combo_Add_Item ODBC_DRV_ID
102361>>>>>                        Send Combo_Add_Item MDSMySQL
102362>>>>>                        Move MDSMySQL to sValue
102363>>>>>                        Case Break
102364>>>>>                    Case (iDbType = EN_dbTypeOracle)
102367>>>>>                        Send Combo_Add_Item ODBC_DRV_ID
102368>>>>>                        Send Combo_Add_Item ORAFLEX
102369>>>>>                        Move ORAFLEX to sValue
102370>>>>>                        Case Break
102371>>>>>                    Case (iDbType = EN_dbTypeDB2)
102374>>>>>                        Send Combo_Add_Item DB2_DRV_ID
102375>>>>>                        Move DB2_DRV_ID to sValue
102376>>>>>                        Case Break
102377>>>>>                    Case (iDbType = EN_dbTypePostgre)
102380>>>>>                        Send Combo_Add_Item ODBC_DRV_ID
102381>>>>>                        Send Combo_Add_Item MDSPgSQL
102382>>>>>                        Move MDSPgSQL to sValue
102383>>>>>                        Case Break
102384>>>>>                    Case Else
102384>>>>>                        Send Combo_Add_Item DATAFLEX_ID
102385>>>>>                        Move DATAFLEX_ID to sValue
102386>>>>>    //                Case (iDbType = EN_dbTypeMSSQL)
102386>>>>>    //                    Send Combo_Add_Item (MSSQLDRV_ID * "- (DAW)")
102386>>>>>    //                    Send Combo_Add_Item (SQLFLEX * "- (Mertech)")
102386>>>>>    //                    Move (MSSQLDRV_ID * "- (DAW)") to sValue
102386>>>>>    //                    Case Break
102386>>>>>    //                Case (iDbType = EN_dbTypeMySQL)
102386>>>>>    //                    Send Combo_Add_Item (ODBC_DRV_ID * "- (DAW)")
102386>>>>>    //                    Send Combo_Add_Item (MDSMySQL * "- (Mertech)")
102386>>>>>    //                    Move (MDSMySQL * "- (Mertech)") to sValue
102386>>>>>    //                    Case Break
102386>>>>>    //                Case (iDbType = EN_dbTypeOracle)
102386>>>>>    //                    Send Combo_Add_Item (ODBC_DRV_ID * "- (DAW)")
102386>>>>>    //                    Send Combo_Add_Item (ORAFLEX * "- (Mertech)")
102386>>>>>    //                    Move (ORAFLEX * "- (Mertech)") to sValue
102386>>>>>    //                    Case Break
102386>>>>>    //                Case (iDbType = EN_dbTypeDB2)
102386>>>>>    //                    Send Combo_Add_Item (DB2_DRV_ID * "- (DAW)")
102386>>>>>    //                    Move (DB2_DRV_ID * "- (DAW)") to sValue
102386>>>>>    //                    Case Break
102386>>>>>    //                Case (iDbType = EN_dbTypePostgre)
102386>>>>>    //                    Send Combo_Add_Item (ODBC_DRV_ID * "- (DAW)")
102386>>>>>    //                    Send Combo_Add_Item (MDSPgSQL * "- (Mertech)")
102386>>>>>    //                    Move (MDSPgSQL * "- (Mertech)") to sValue
102386>>>>>    //                    Case Break
102386>>>>>    //                Case Else
102386>>>>>    //                    Send Combo_Add_Item (DATAFLEX_ID * "- (DAW)")
102386>>>>>    //                    Move (DATAFLEX_ID * "- (DAW)") to sValue
102386>>>>>                Case End
102386>>>>>                Set Value to sValue
102387>>>>>            End_Procedure
102388>>>>>
102388>>>>>            Procedure OnChange
102391>>>>>                String sDriverID
102391>>>>>                Integer iDbType iPos
102391>>>>>
102391>>>>>                Get Value to sDriverID
102392>>>>>                Move (Pos("-", sDriverID)) to iPos
102393>>>>>                Move (Left(sDriverID, (iPos - 2))) to sDriverID
102394>>>>>                If (sDriverID = "") Begin
102396>>>>>                    Move MSSQLDRV_ID to sDriverID
102397>>>>>                End
102397>>>>>>
102397>>>>>                Get SelectedDbType of oDbType_cf to iDbType
102398>>>>>                Broadcast Recursive Send DbTypeUpdate of oSettings_grp iDbType sDriverID
102400>>>>>            End_Procedure
102401>>>>>
102401>>>>>        End_Object
102402>>>>>
102402>>>>>        Object oConnectionID_fm is a cSQLForm
102404>>>>>            Set Size to 13 120
102405>>>>>            Set Location to 49 86
102406>>>>>            Set Label to "Connection ID"
102407>>>>>            Set Label_Col_Offset to 2
102408>>>>>            Set Label_Justification_Mode to JMode_Right
102409>>>>>            Set psToolTip to "The DFConnectionID keyword to set a default connection id for the driver. This is the connection ID that appear in database table .int files with the format; 'SERVER_NAME DFCONNID=MyConnID'"
102410>>>>>            Set piItem to 2
102411>>>>>        End_Object
102412>>>>>
102412>>>>>        Object oEnabled_cb is a cSQLCheckBox
102414>>>>>            Set Auto_Size_State to False
102415>>>>>            Set Size to 9 38
102416>>>>>            Set Location to 51 216
102417>>>>>            Set Label to "Enabled"
102418>>>>>            Set psToolTip to "Check to indicate that this is the enabled connection. Note: There can only be one enabled connection at a time."
102419>>>>>            Set piItem to 1
102420>>>>>
102420>>>>>            Procedure OnChange
102423>>>>>                Boolean bChecked bNew
102423>>>>>                tSQLConnection SQLConnection
102423>>>>>                tSQLConnection SQLConnection
102423>>>>>
102423>>>>>                Get pbNew to bNew
102424>>>>>                Get Checked_State to bChecked
102425>>>>>                If (bNew = False and bChecked = True) Begin
102427>>>>>                    Get pSQLConnectionData to SQLConnection
102428>>>>>                    Move True to SQLConnection.bEnabled
102429>>>>>                End
102429>>>>>>
102429>>>>>
102429>>>>>            End_Procedure
102430>>>>>
102430>>>>>        End_Object
102431>>>>>
102431>>>>>    End_Object
102432>>>>>
102432>>>>>    Object oSettings_grp is a cHeaderGroup
102434>>>>>        Set Size to 178 389
102435>>>>>        Set Location to 81 11
102436>>>>>        Set Label to "SQL Server Details"
102437>>>>>        Set peAnchors to anTopLeftRight
102438>>>>>        Set psImage to "SettingsBlack24.bmp"
102439>>>>>        Set psLabel to "SQL Connection Settings"
102440>>>>>
102440>>>>>        Object oServer_fm is a cSQLForm
102442>>>>>            Set Size to 13 120
102443>>>>>            Set Location to 24 74
102444>>>>>            Set Label to "Server"
102445>>>>>            Set Label_Col_Offset to 2
102446>>>>>            Set Label_Justification_Mode to JMode_Right
102447>>>>>            Set psToolTip to "Server/DSN: Depending on the selected database type the label can either display as 'Server' or 'DSN'. Either enter the name - if you know it - or by using the selection list (F4). Tip: If you are using Microsoft SQL Server and you are testing on the same machine as the MS SQL Server instance is running and you are using SQLEXPRESS you can enter e.g. '.\SQLEXPRESS'. That will mean use the SQLEXPRESS instance of Microsoft SQL Server running on this machine. If you press [F4] and the selection list comes up empty for Microsoft SQL Server it probably is because the service hasn't been started. Type 'Services' in Windows menu system to start Windows Services app. Type 'SQL' to jump to the SQL Server services. Check that the 'SQL Server Browser' service is started and set to 'Automatic'."
102448>>>>>            Set peAnchors to anTopLeftRight
102449>>>>>            Set piItem to 5
102450>>>>>
102450>>>>>            Property Handle phoPromptObject (oServerSelection_sl(Self))
102452>>>>>
102452>>>>>            Procedure Prompt
102455>>>>>                String sDriverID sValue
102455>>>>>                String[] sTheData
102456>>>>>                Integer iDbType iODBCType iRadio iPos
102456>>>>>                Handle ho
102456>>>>>
102456>>>>>                Get Prompt_Object to ho
102457>>>>>                If (ho = 0) Begin
102459>>>>>                    Procedure_Return
102460>>>>>                End
102460>>>>>>
102460>>>>>
102460>>>>>                Set Label of oServersInfo_tb to CS_LoadingServers
102461>>>>>                Send Cursor_Wait of Cursor_Control
102462>>>>>                Get SelectedDbType of oDbType_cf to iDbType
102463>>>>>                Get Value of oDriverID_cf to sDriverID
102464>>>>>                Get Current_Radio of oODBC_rgp to iRadio
102465>>>>>                If (iRadio = 0) Begin
102467>>>>>                    Move SQL_FETCH_USER     to iODBCType
102468>>>>>                End
102468>>>>>>
102468>>>>>                If (iRadio = 1) Begin
102470>>>>>                    Move SQL_FETCH_SYSTEM   to iODBCType
102471>>>>>                End
102471>>>>>>
102471>>>>>                If (iRadio = 2) Begin
102473>>>>>                    Move SQL_FETCH_ALL      to iODBCType
102474>>>>>                End
102474>>>>>>
102474>>>>>
102474>>>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
102475>>>>>                Load_Driver sDriverID
102476>>>>>                Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
102477>>>>>                If (LastErr = 4255) Begin
102479>>>>>                    Send Cursor_Ready of Cursor_Control
102480>>>>>                    Send Info_Box ("Can't display any items because the database driver could not be loaded. (" + sDriverID + ")")
102481>>>>>                    Procedure_Return
102482>>>>>                End
102482>>>>>>
102482>>>>>
102482>>>>>                Get SqlUtilEnumerateServers of ghoDbUpdateFunctionLibrary sDriverID iODBCType to sTheData
102483>>>>>                Set psTheData  of ho to sTheData
102484>>>>>                Set Label of oServersInfo_tb to ""
102485>>>>>
102485>>>>>                Forward Send Prompt
102487>>>>>
102487>>>>>                // The selection list will show the ODBC DataSource name + a comma (,) + a description.
102487>>>>>                // We need to remove those parts from the comma and to the end of string.
102487>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
102489>>>>>                    Get Value to sValue
102490>>>>>                    Move (Pos(",", sValue)) to iPos
102491>>>>>                    Move (Left(sValue, (iPos - 1))) to sValue
102492>>>>>                    Set Value to sValue
102493>>>>>                End
102493>>>>>>
102493>>>>>            End_Procedure
102494>>>>>
102494>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
102497>>>>>                String sLabel
102497>>>>>                Handle ho
102497>>>>>
102497>>>>>                Get phoPromptObject to ho
102498>>>>>                Set Prompt_Button_Mode to PB_PromptOn
102499>>>>>                Case Begin
102499>>>>>                    Case (iDbType = EN_dbTypeDB2)
102501>>>>>                        Move "DSN" to sLabel
102502>>>>>                        Case Break
102503>>>>>                    Case (iDbType = EN_dbTypeMSSQL)
102506>>>>>                        Move "Server" to sLabel
102507>>>>>                        Case Break
102508>>>>>                    Case (iDbType = EN_dbTypeMySQL)
102511>>>>>                        If (sDriverID = ODBC_DRV_ID) Begin
102513>>>>>                            Move "ODBC Data Source" to sLabel
102514>>>>>                        End
102514>>>>>>
102514>>>>>                        Else Begin
102515>>>>>                            Move "DSN" to sLabel
102516>>>>>                        End
102516>>>>>>
102516>>>>>                        Case Break
102517>>>>>                    Case (iDbType = EN_dbTypeOracle)
102520>>>>>                        If (sDriverID = ODBC_DRV_ID) Begin
102522>>>>>                            Move "ODBC Data Source" to sLabel
102523>>>>>                        End
102523>>>>>>
102523>>>>>                        Else Begin
102524>>>>>                            Move "Server" to sLabel
102525>>>>>                        End
102525>>>>>>
102525>>>>>                        Case Break
102526>>>>>                    Case (iDbType = EN_dbTypePostgre)
102529>>>>>                        If (sDriverID = ODBC_DRV_ID) Begin
102531>>>>>                            Move "ODBC Data Source" to sLabel
102532>>>>>                        End
102532>>>>>>
102532>>>>>                        Else Begin
102533>>>>>                            Move "Server" to sLabel
102534>>>>>                        End
102534>>>>>>
102534>>>>>                        Case Break
102535>>>>>                    Case Else
102535>>>>>                Case End
102535>>>>>
102535>>>>>                Set Prompt_Object to ho
102536>>>>>                Set Label to sLabel
102537>>>>>            End_Procedure
102538>>>>>
102538>>>>>        End_Object
102539>>>>>
102539>>>>>        Object oSilentLogin_fm is a cSQLCheckBox
102541>>>>>            Set Auto_Size_State to False
102542>>>>>            Set Size to 9 51
102543>>>>>            Set Location to 27 205
102544>>>>>            Set Label to "Silent Login"
102545>>>>>            Set psToolTip to "Silent login to database is to not show error if login was unsuccessive."
102546>>>>>            Set peAnchors to anTopRight
102547>>>>>            Set piItem to 15
102548>>>>>        End_Object
102549>>>>>
102549>>>>>        Object oServersInfo_tb is a TextBox
102551>>>>>            Set Auto_Size_State to False
102552>>>>>            Set Size to 9 100
102553>>>>>            Set Location to 28 262
102554>>>>>            Set TextColor to clGreen
102555>>>>>            Set Justification_Mode to JMode_Right
102556>>>>>            Set peAnchors to anTopRight
102557>>>>>        End_Object
102558>>>>>
102558>>>>>        Object oODBCInfo_tb is a TextBox
102560>>>>>            Set Size to 9 63
102561>>>>>            Set Location to 51 7
102562>>>>>            Set Label to "ODBC Source Type"
102563>>>>>            Set Label_Shadow_Display_Mode to TBShadow_On_All
102564>>>>>        End_Object
102565>>>>>
102565>>>>>        Object oODBC_rgp is a RadioGroup
102567>>>>>            Set Location to 41 75
102568>>>>>            Set Size to 25 298
102569>>>>>//            Set psToolTip to "Only available if the ODBC_DRV has been selected. Depending on the radio button that is selected the 'Server/DSN' selection list shows different values."
102569>>>>>
102569>>>>>            Object oRadio1 is a Radio
102571>>>>>                Set Label to "User data"
102572>>>>>                Set Size to 10 49
102573>>>>>                Set Location to 10 5
102574>>>>>            End_Object
102575>>>>>
102575>>>>>            Object oRadio2 is a Radio
102577>>>>>                Set Label to "System data"
102578>>>>>                Set Size to 10 55
102579>>>>>                Set Location to 10 64
102580>>>>>            End_Object
102581>>>>>
102581>>>>>            Object oRadio3 is a Radio
102583>>>>>                Set Label to "Both"
102584>>>>>                Set Size to 10 28
102585>>>>>                Set Location to 11 130
102586>>>>>            End_Object
102587>>>>>
102587>>>>>            Procedure Notify_Select_State Integer iToItem Integer iFromItem
102590>>>>>                Forward Send Notify_Select_State iToItem iFromItem
102592>>>>>            End_Procedure
102593>>>>>
102593>>>>>            Object oFileDSN_btn is a cButtonDPI
102595>>>>>                Set Size to 13 62
102596>>>>>                Set Location to 8 168
102597>>>>>                Set Label to "Select File DSN..."
102598>>>>>
102598>>>>>                Procedure OnClick
102601>>>>>                    String sFileName
102601>>>>>                    Get vSelect_File ("Data Sources (*.dsn)|*.dsn|All Files (*.*)|*.*") "Select a file data source" "" to sFileName
102602>>>>>                    If (sFileName <> "") Begin
102604>>>>>                        Set Value of oServer_fm to sFileName
102605>>>>>                    End
102605>>>>>>
102605>>>>>                End_Procedure
102606>>>>>
102606>>>>>                Set Current_Radio to 2
102607>>>>>            End_Object
102608>>>>>
102608>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
102611>>>>>                Set Enabled_State to (sDriverID = ODBC_DRV_ID)
102612>>>>>                Set Enabled_State of oODBCInfo_tb to (sDriverID = ODBC_DRV_ID)
102613>>>>>            End_Procedure
102614>>>>>
102614>>>>>            Object oODBCAdmin_btn is a cButtonDPI
102616>>>>>                Set Size to 13 55
102617>>>>>                Set Location to 8 234
102618>>>>>                Set Label to "ODBC Admin"
102619>>>>>                Procedure OnClick
102622>>>>>                    Handle hWnd
102622>>>>>                    Get Window_Handle to hWnd
102623>>>>>                    If (hWnd <> 0) Begin
102625>>>>>                        Call_Driver 0 ODBC_DRV_ID Function ODBC_MANAGE_DATA_SOURCES Callback 0 Passing CLI$StrDummy CLI$StrDummy !1 Result CLI$IntDummy
102630>>>>>                    End
102630>>>>>>
102630>>>>>                    Else Begin
102631>>>>>                        Send Stop_Box "Could not get a Windows handle.."
102632>>>>>                    End
102632>>>>>>
102632>>>>>                End_Procedure
102633>>>>>            End_Object
102634>>>>>
102634>>>>>        End_Object
102635>>>>>
102635>>>>>        Object oTrusted_cb is a cSQLCheckBox
102637>>>>>            Set Size to 10 50
102638>>>>>            Set Location to 75 74
102639>>>>>            Set Label to "Use Trusted Connection"
102640>>>>>            Set psToolTip to "(Windows Authentication) When selected, SQL Server uses integrated login (Windows login information) security to establish connections using this data source, regardless of the current login security mode at the server."
102641>>>>>            Set piItem to 8
102642>>>>>
102642>>>>>            Procedure OnChange
102645>>>>>                Boolean bChecked
102645>>>>>                Get Checked_State to bChecked
102646>>>>>                Set Enabled_State of oUserID_fm   to (bChecked = False)
102647>>>>>                Set Enabled_State of oPassword_fm to (bChecked = False)
102648>>>>>                Set Enabled_State of oViewPassword_btn to (bChecked = False)
102649>>>>>            End_Procedure
102650>>>>>
102650>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
102653>>>>>                Boolean bChecked
102653>>>>>
102653>>>>>                Get Checked_State to bChecked
102654>>>>>                If (iDbType <> EN_dbTypeMSSQL) Begin
102656>>>>>                    Set Enabled_State to (iDbType = EN_dbTypeMSSQL)
102657>>>>>                    If (bChecked = True) Begin
102659>>>>>                        Set Checked_State to False
102660>>>>>                    End
102660>>>>>>
102660>>>>>                End
102660>>>>>>
102660>>>>>                Else Begin
102661>>>>>                    Set Enabled_State to True
102662>>>>>                End
102662>>>>>>
102662>>>>>
102662>>>>>                Send OnChange
102663>>>>>            End_Procedure
102664>>>>>
102664>>>>>        End_Object
102665>>>>>
102665>>>>>        Object oUserID_fm is a cSQLForm
102667>>>>>            Set Size to 13 120
102668>>>>>            Set Location to 86 74
102669>>>>>            Set Label to "User ID"
102670>>>>>            Set Label_Col_Offset to 2
102671>>>>>            Set Label_Justification_Mode to JMode_Right
102672>>>>>            Set psToolTip to "Enter the user name to use for authentication when you log on to the database."
102673>>>>>            Set piItem to 9
102674>>>>>        End_Object
102675>>>>>
102675>>>>>        Object oPassword_fm is a cSQLForm
102677>>>>>            Set Size to 13 80
102678>>>>>            Set Location to 86 270
102679>>>>>            Set Label to "Password"
102680>>>>>            Set Label_Col_Offset to 2
102681>>>>>            Set Label_Justification_Mode to JMode_Right
102682>>>>>            Set psToolTip to "Enter the password for your user name. The password will automatically be encrypted & decrypted when writing/reading from the ini file. Of Special Note: If the cConnection class is used with DataFlex 19 or later and such an .ini file is edited with this program you will get a question if you would like the program to 'touch' the password or not. If you answer No, the ini-file will keep working with the DataFlex tools. You should probably never try to change the password with this program for a DFConnid.ini file as the two programs uses different encryption/decryption algorithms."
102683>>>>>            Set piItem to 10
102684>>>>>            Set Password_State to True
102685>>>>>        End_Object
102686>>>>>
102686>>>>>        Object oViewPassword_btn is a cButtonDPI
102688>>>>>            Set Size to 13 19
102689>>>>>            Set Location to 86 354
102690>>>>>            Set psToolTip to "Toggle password"
102691>>>>>            Set psImage to "PasswordViewBlack.ico"
102692>>>>>            Set piImageMarginLeft to 3
102693>>>>>
102693>>>>>            Procedure OnClick
102696>>>>>                Handle ho
102696>>>>>                Boolean bState
102696>>>>>
102696>>>>>                Move (oPassword_fm(Self)) to ho
102697>>>>>                Get Password_State of ho item 0 to bState
102698>>>>>                Send Deactivate of ho
102699>>>>>                Set Password_State of ho item 0 to (not(bState))
102700>>>>>                // Finally we need to re-add the object to the focus tree or it will be invisible.
102700>>>>>                Send Activate of ho (Parent(Self))
102701>>>>>            End_Procedure
102702>>>>>
102702>>>>>        End_Object
102703>>>>>
102703>>>>>        Object oLoginInfo_tb is a TextBox
102705>>>>>            Set Auto_Size_State to False
102706>>>>>            Set Size to 9 64
102707>>>>>            Set Location to 105 203
102708>>>>>            Set TextColor to clGreen
102709>>>>>            Set Justification_Mode to JMode_Right
102710>>>>>        End_Object
102711>>>>>
102711>>>>>        Object oCheckLogin_btn is a cButtonDPI
102713>>>>>            Set Size to 13 64
102714>>>>>            Set Location to 102 270
102715>>>>>            Set Label to "Check &Login"
102716>>>>>            Set psImage to "ActionLoginBlack.ico"
102717>>>>>            Set psToolTip to "You should always use this button when adding a new SQL Connection to ensure that the entered credentials are correct. (Ctrl+L)"
102718>>>>>            Set piImageMarginLeft to 3
102719>>>>>
102719>>>>>            Procedure OnClick
102722>>>>>                String sConnectionString sServer sDatabase sUserId sPassword sDriverID
102722>>>>>                Boolean bTrusted bLoginSuccessful bMertechDriver
102722>>>>>                Integer iDriverID
102722>>>>>                Handle hoErrorObj hoDriver
102722>>>>>
102722>>>>>                Send Cursor_Wait of Cursor_Control // Note: The Cursor_Wait changes the Err flag!
102723>>>>>                Move Error_Object_Id to hoErrorObj
102724>>>>>                Move Self to Error_Object_Id
102725>>>>>                Move False to Err
102726>>>>>
102726>>>>>                Set Value of oLoginInfo_tb to CS_LoginAttempt
102727>>>>>                Send PumpMsgQueue
102728>>>>>
102728>>>>>                Get Checked_State of oTrusted_cb to bTrusted
102729>>>>>                Get Value of oDriverID_cf to sDriverID
102730>>>>>                Get Value of oServer_fm   to sServer
102731>>>>>                Get Value of oDatabase_fm to sDatabase
102732>>>>>                Get Value of oUserID_fm   to sUserId
102733>>>>>                Get Value of oPassword_fm to sPassword
102734>>>>>
102734>>>>>                If (sServer = "") Begin
102736>>>>>                    Send Info_Box "Please enter a server first, then try again."
102737>>>>>                    Procedure_Return
102738>>>>>                End
102738>>>>>>
102738>>>>>
102738>>>>>                Get ConstructConnectionString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverID sServer sDatabase bTrusted sUserId sPassword to sConnectionString
102739>>>>>
102739>>>>>                Get DriverIndex of ghoSQLConnectionHandler sDriverID to iDriverID
102740>>>>>                If (iDriverID = 0) Begin
102742>>>>>                    Set TextColor of oLoginInfo_tb to clRed
102743>>>>>                    Set Value of oLoginInfo_tb to CS_LoginFailed
102744>>>>>                    Send Info_Box ("The driver" * sDriverID * "could not be loaded. Is the driver installed? And equally imporant; Is the corresponding database server or client software installed?")
102745>>>>>                    Procedure_Return
102746>>>>>                End
102746>>>>>>
102746>>>>>
102746>>>>>                Get IsMertechDriver of ghoSQLConnectionHandler sDriverID to bMertechDriver
102747>>>>>                If (bMertechDriver = False) Begin
102749>>>>>                    Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to True
102752>>>>>                End
102752>>>>>>
102752>>>>>
102752>>>>>                Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
102753>>>>>                Set psDriverID of hoDriver to sDriverID
102754>>>>>                Get DbLogin    of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
102755>>>>>                Send Destroy   of hoDriver
102756>>>>>
102756>>>>>                If bLoginSuccessful Begin
102758>>>>>                    Set TextColor of oLoginInfo_tb to clGreen
102759>>>>>                    Set Value of oLoginInfo_tb to CS_LoginSuccessful
102760>>>>>                End
102760>>>>>>
102760>>>>>                Else Begin
102761>>>>>                    Set TextColor of oLoginInfo_tb to clRed
102762>>>>>                    Set Value of oLoginInfo_tb to CS_LoginFailed
102763>>>>>                End
102763>>>>>>
102763>>>>>
102763>>>>>                Move hoErrorObj to Error_Object_Id
102764>>>>>                Send Cursor_Ready of Cursor_Control
102765>>>>>            End_Procedure
102766>>>>>
102766>>>>>            // This method is here simply to intercept any error that may occur while logging in
102766>>>>>            // it does not have to do anything with the error, but it suppresses the normal error display
102766>>>>>            Procedure Error_Report Integer iErrNum Integer iErrLine String sErrMsg
102769>>>>>                    If (LastErr = 25000) Begin
102771>>>>>                        If (Trim(sErrMsg) <> "") Begin
102773>>>>>                            Send Info_Box sErrMsg
102774>>>>>                        End
102774>>>>>>
102774>>>>>                    End
102774>>>>>>
102774>>>>>            End_Procedure
102775>>>>>
102775>>>>>        End_Object
102776>>>>>
102776>>>>>        Object oTableSpaceInfo_tb is a TextBox
102778>>>>>            Set Auto_Size_State to False
102779>>>>>            Set Size to 9 118
102780>>>>>            Set Location to 112 75
102781>>>>>            Set TextColor to clGreen
102782>>>>>            Set Justification_Mode to JMode_Right
102783>>>>>            Set peAnchors to anNone
102784>>>>>        End_Object
102785>>>>>
102785>>>>>        Object oBaseTableSpace_fm is a cSQLForm
102787>>>>>            Set Size to 13 120
102788>>>>>            Set Location to 125 74
102789>>>>>            Set Label to "Table Space"
102790>>>>>            Set Label_Col_Offset to 2
102791>>>>>            Set Label_Justification_Mode to JMode_Right
102792>>>>>            Set piItem to 12
102793>>>>>            Set psToolTip to "Sets the name of the table space where the data will be stored. Applicable for IBM DB2, Oracle and PostgreSQL databases. Table spaces allow you to assign a physical location to logical objects (tables). They can be used to improve performance or to increase the page size, thus increasing the maximum size of a record that can be stored in the table space. You can specify what table space must be used to store table, index or long data. The index and long data table space will only be set when the table tables pace is also set."
102794>>>>>            Set Prompt_Button_Mode to PB_PromptOn
102795>>>>>            Set Prompt_Object to (oTableSpaceSelection_sl(Self))
102796>>>>>
102796>>>>>            Procedure Prompt
102799>>>>>                String[] sTheData
102800>>>>>                Handle ho
102800>>>>>                tSQLConnection SQLConnection
102800>>>>>                tSQLConnection SQLConnection
102800>>>>>
102800>>>>>                Set Label of oTableSpaceInfo_tb to CS_LoadingTableSpaces
102801>>>>>                Get ReadCurrentSQLSettings to SQLConnection
102802>>>>>                Get SqlUtilEnumerateTableSpaces of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
102803>>>>>
102803>>>>>                Get Prompt_Object to ho
102804>>>>>                Set psTheData  of ho to sTheData
102805>>>>>                Set Label of oTableSpaceInfo_tb to ""
102806>>>>>
102806>>>>>                Forward Send Prompt
102808>>>>>            End_Procedure
102809>>>>>
102809>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
102812>>>>>                Set Enabled_State to ((iDbType = EN_dbTypeDB2 or iDbType = EN_dbTypeOracle or iDbType = EN_dbTypePostgre) and sDriverID <> ODBC_DRV_ID)
102813>>>>>            End_Procedure
102814>>>>>
102814>>>>>        End_Object
102815>>>>>
102815>>>>>        Object oIndexTableSpace_fm is a cSQLForm
102817>>>>>            Set Size to 13 80
102818>>>>>            Set Location to 125 270
102819>>>>>            Set Label to "Index Table Space"
102820>>>>>            Set Label_Col_Offset to 2
102821>>>>>            Set Label_Justification_Mode to JMode_Right
102822>>>>>            Set piItem to 14
102823>>>>>            Set psToolTip to "To set the name of the table space where indexes will be stored. Only applicable for IBM DB2, Oracle and PostgreSQL databases."
102824>>>>>            Set Prompt_Button_Mode to PB_PromptOn
102825>>>>>            Set Prompt_Object to (oTableSpaceSelection_sl(Self))
102826>>>>>
102826>>>>>            Procedure Prompt
102829>>>>>                String[] sTheData
102830>>>>>                Handle ho
102830>>>>>                Integer iDbType
102830>>>>>                tSQLConnection SQLConnection
102830>>>>>                tSQLConnection SQLConnection
102830>>>>>
102830>>>>>                Set Label of oTableSpaceInfo_tb to CS_LoadingTableSpaces
102831>>>>>                Get ReadCurrentSQLSettings to SQLConnection
102832>>>>>
102832>>>>>                Get SqlUtilEnumerateTableSpaces of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
102833>>>>>
102833>>>>>                Get Prompt_Object to ho
102834>>>>>                Set psTheData     of ho to sTheData
102835>>>>>                Set Label of oTableSpaceInfo_tb to ""
102836>>>>>
102836>>>>>                Forward Send Prompt
102838>>>>>            End_Procedure
102839>>>>>
102839>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
102842>>>>>                Set Enabled_State to ((iDbType = EN_dbTypeDB2 or iDbType = EN_dbTypeOracle or iDbType = EN_dbTypePostgre) and sDriverID <> ODBC_DRV_ID)
102843>>>>>            End_Procedure
102844>>>>>
102844>>>>>        End_Object
102845>>>>>
102845>>>>>        Object oLongTableSpace_fm is a cSQLForm
102847>>>>>            Set Size to 13 120
102848>>>>>            Set Location to 140 74
102849>>>>>            Set Label to "Long Table Space"
102850>>>>>            Set Label_Col_Offset to 2
102851>>>>>            Set Label_Justification_Mode to JMode_Right
102852>>>>>            Set piItem to 13
102853>>>>>            Set psToolTip to "Only applicable for IBM DB2 databases. If you are unsure on what to enter your best bet is to use the same value as for the 'Table Space' above."
102854>>>>>            Set Prompt_Button_Mode to PB_PromptOn
102855>>>>>            Set Prompt_Object to (oTableSpaceSelection_sl(Self))
102856>>>>>
102856>>>>>            Procedure Prompt
102859>>>>>                String[] sTheData
102860>>>>>                Handle ho
102860>>>>>                Integer iDbType
102860>>>>>                tSQLConnection SQLConnection
102860>>>>>                tSQLConnection SQLConnection
102860>>>>>
102860>>>>>                Set Label of oTableSpaceInfo_tb to CS_LoadingTableSpaces
102861>>>>>                Get ReadCurrentSQLSettings to SQLConnection
102862>>>>>
102862>>>>>                Get SqlUtilEnumerateTableSpaces of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
102863>>>>>
102863>>>>>                Get Prompt_Object to ho
102864>>>>>                Set psTheData     of ho to sTheData
102865>>>>>                Set Label of oTableSpaceInfo_tb to ""
102866>>>>>
102866>>>>>                Forward Send Prompt
102868>>>>>            End_Procedure
102869>>>>>
102869>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
102872>>>>>                Set Enabled_State to (iDbType = EN_dbTypeDB2)
102873>>>>>            End_Procedure
102874>>>>>
102874>>>>>        End_Object
102875>>>>>
102875>>>>>        Object oSchema_fm is a cSQLForm
102877>>>>>            Set Size to 13 80
102878>>>>>            Set Location to 140 270
102879>>>>>            Set Label to "Schema"
102880>>>>>            Set psToolTip to "The name of the schema the table belongs to. A schema is a collection of names or objects. A schema can contain tables, views, and triggers. Schemas provide a logical classification of objects in the database. It can have a slightly different meaning depending on the selected database type. Please consult your database manager to ensure the correct value is selected. Applicable for IBM DB2, Oracle and PostgreSQL databases. For IBM DB2 not specifying a schema will result in the user name being used. Microsoft SQL Server has a completely different approach to security and privileges and uses owners instead."
102881>>>>>            Set Label_Col_Offset to 2
102882>>>>>            Set Label_Justification_Mode to JMode_Right
102883>>>>>            Set piItem to 11
102884>>>>>            Set Enabled_State to False
102885>>>>>
102885>>>>>            Property String psSchemaToolTip "The name of the schema the table belongs to. A schema is a collection of names or objects. A schema can contain tables, views, and triggers. Schemas provide a logical classification of objects in the database. It can have a slightly different meaning depending on the selected database type. Please consult a database manager to ensure the correct value is selected. Applicable for IBM DB2, Oracle and PostgreSQL databases. For IBM DB2 not specifying a schema will result in the user name being used. Microsoft SQL Server has a completely different approach to security and privileges and uses owners instead."
102887>>>>>            Property String psOwnerTooltip  "The owner name to use within the database where the tables must be placed. If you want to specify an owner of the table that will be converted you can do so, not specifying an owner will result in the default owner being used. The suggested owner name to use is 'dbo'"
102889>>>>>
102889>>>>>            Procedure Prompt
102892>>>>>                String[] sTheData
102893>>>>>                Handle ho
102893>>>>>                Integer iDbType
102893>>>>>                tSQLConnection SQLConnection
102893>>>>>                tSQLConnection SQLConnection
102893>>>>>
102893>>>>>                Set Label of oTableSpaceInfo_tb to CS_LoadingSchemas
102894>>>>>                Get ReadCurrentSQLSettings to SQLConnection
102895>>>>>
102895>>>>>                Get SqlUtilEnumerateSchemas of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
102896>>>>>
102896>>>>>                Get Prompt_Object to ho
102897>>>>>                Set psTheData     of ho to sTheData
102898>>>>>                Set Label of oTableSpaceInfo_tb to ""
102899>>>>>
102899>>>>>                Forward Send Prompt
102901>>>>>            End_Procedure
102902>>>>>
102902>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
102905>>>>>                String sValue
102905>>>>>
102905>>>>>                Set Enabled_State to ((iDbType = EN_dbTypeMSSQL or iDbType = EN_dbTypeDB2 or iDbType = EN_dbTypeOracle or iDbType = EN_dbTypePostgre) and sDriverID <> ODBC_DRV_ID)
102906>>>>>                If (iDbType = EN_dbTypeMSSQL) Begin
102908>>>>>                    Set Label to CS_DF_File_Owner
102909>>>>>                    Set Prompt_Button_Mode to PB_PromptOff
102910>>>>>                    Set Prompt_Object to 0
102911>>>>>                    Set psToolTip to (psOwnerTooltip(Self))
102912>>>>>                    Get Value to sValue
102913>>>>>                    If (Trim(sValue) = "") Begin
102915>>>>>                        Set Value to "dbo"
102916>>>>>                    End
102916>>>>>>
102916>>>>>                End
102916>>>>>>
102916>>>>>                Else Begin
102917>>>>>                    Set Label to CS_DF_File_Schema
102918>>>>>                    Set Prompt_Button_Mode to PB_PromptOn
102919>>>>>                    Set Prompt_Object to (oSchemasSelection_sl(Self))
102920>>>>>                    Set psToolTip to (psSchemaToolTip(Self))
102921>>>>>                    If (Trim(sValue) = "dbo") Begin
102923>>>>>                        Set Value to ""
102924>>>>>                    End
102924>>>>>>
102924>>>>>                End
102924>>>>>>
102924>>>>>                If (Enabled_State(Self) = False) Begin
102926>>>>>                    Set Value to ""
102927>>>>>                End
102927>>>>>>
102927>>>>>            End_Procedure
102928>>>>>
102928>>>>>        End_Object
102929>>>>>
102929>>>>>        Object oDatabase_fm is a cSQLForm
102931>>>>>            Set Size to 13 120
102932>>>>>            Set Location to 156 74
102933>>>>>            Set Label to "Database"
102934>>>>>            Set Label_Col_Offset to 2
102935>>>>>            Set Label_Justification_Mode to JMode_Right
102936>>>>>            Set peAnchors to anTopLeftRight
102937>>>>>            Set psToolTip to "Name of the SQL database. Note: If you are setting up your first connection for a workspace and your SQL database doesn't exist yet, leave the default 'Master' as it is always available. The 'SqlDatabaseCreate' function will take care of the rest when creating your new SQL database."
102938>>>>>            Set piItem to 6
102939>>>>>
102939>>>>>            Procedure Prompt
102942>>>>>                String[] sTheData
102943>>>>>                Handle ho
102943>>>>>                tSQLConnection SQLConnection
102943>>>>>                tSQLConnection SQLConnection
102943>>>>>
102943>>>>>                Set Label of oTableSpaceInfo_tb to CS_LoadingDatabases
102944>>>>>                Get ReadCurrentSQLSettings to SQLConnection
102945>>>>>
102945>>>>>                Get SqlUtilEnumerateDatabases of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID to sTheData
102946>>>>>
102946>>>>>                Get Prompt_Object to ho
102947>>>>>                Set psTheData     of ho to sTheData
102948>>>>>                Set Label of oTableSpaceInfo_tb to ""
102949>>>>>
102949>>>>>                Forward Send Prompt
102951>>>>>            End_Procedure
102952>>>>>
102952>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
102955>>>>>                Boolean bAdd
102955>>>>>                String sValue
102955>>>>>
102955>>>>>                If (sDriverID <> "") Begin
102957>>>>>                    Set Enabled_State to (sDriverID = MSSQLDRV_ID or sDriverID = SQLFLEX or sDriverID = MDSMySQL or sDriverID = MDSPgSQL or sDriverID = ORAFLEX)
102958>>>>>                    If (Enabled_State(Self) = True) Begin
102960>>>>>                        Move (piCurrentRow(Self) = -1) to bAdd
102961>>>>>                        Get Value to sValue
102962>>>>>                        If (bAdd = True and sValue = "" and iDbType = EN_dbTypeMSSQL) Begin
102964>>>>>                            Set Value to "master"
102965>>>>>                        End
102965>>>>>>
102965>>>>>                        Else Begin
102966>>>>>                            Set Prompt_Button_Mode to PB_PromptOn
102967>>>>>                            Set Prompt_Object to (oDatabaseSelection_sl(Self))
102968>>>>>                            If (Value(Self) = "master") Begin
102970>>>>>                                Set Value to ""
102971>>>>>                            End
102971>>>>>>
102971>>>>>                        End
102971>>>>>>
102971>>>>>                    End
102971>>>>>>
102971>>>>>                    If (Enabled_State(Self) = False) Begin
102973>>>>>                        Set Value to ""
102974>>>>>                    End
102974>>>>>>
102974>>>>>                End
102974>>>>>>
102974>>>>>            End_Procedure
102975>>>>>
102975>>>>>        End_Object
102976>>>>>
102976>>>>>        Function ReadCurrentSQLSettings Returns tSQLConnection
102979>>>>>            tSQLConnection SQLConnection
102979>>>>>            tSQLConnection SQLConnection
102979>>>>>
102979>>>>>            Get Value of oDriverID_cf to SQLConnection.sDriverID
102980>>>>>            Get SelectedDbType of oDbType_cf to SQLConnection.iDbType
102981>>>>>
102981>>>>>            Get Checked_State of oTrusted_cb to SQLConnection.bTrusted
102982>>>>>            Get Value of oDriverID_cf        to SQLConnection.sDriverID
102983>>>>>            Get Value of oServer_fm          to SQLConnection.sServer
102984>>>>>            Get Value of oUserID_fm          to SQLConnection.sUserID
102985>>>>>            Get Value of oPassword_fm        to SQLConnection.sPassword
102986>>>>>            Get ConstructConnectionString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) ;                SQLConnection.sDriverID SQLConnection.sServer "" SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
102987>>>>>            Set pSQLConnection of ghoSQLConnectionHandler to SQLConnection
102988>>>>>
102988>>>>>            Function_Return SQLConnection
102989>>>>>        End_Function
102990>>>>>
102990>>>>>        Procedure DbTypeUpdate Integer iDbType String sDriverID
102993>>>>>            String sDbType
102993>>>>>            Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary iDbType to sDbType
102994>>>>>            Set Label to (sDbType * "Connection Details")
102995>>>>>        End_Procedure
102996>>>>>
102996>>>>>    End_Object
102997>>>>>
102997>>>>>    Object oOK_Btn is a cButtonDPI
102999>>>>>        Set Label    to "OK"
103000>>>>>        Set Location to 264 296
103001>>>>>        Set peAnchors to anBottomRight
103002>>>>>
103002>>>>>        Procedure OnClick
103005>>>>>            String sConnectionID sLoginText
103005>>>>>            String[] sConnectionData
103006>>>>>            tSQLConnection SQLIniFileConnection
103006>>>>>            tSQLConnection SQLIniFileConnection
103006>>>>>            Boolean bTrusted bNew bOK bShouldSave
103006>>>>>            Handle ho
103006>>>>>            Integer iRetval
103006>>>>>
103006>>>>>            Delegate Get Should_Save to bShouldSave
103008>>>>>            If (bShouldSave = False) Begin
103010>>>>>                Set pbChanged to False
103011>>>>>                Send Close_Panel
103012>>>>>                Procedure_Return
103013>>>>>            End
103013>>>>>>
103013>>>>>
103013>>>>>            Broadcast Recursive Send WriteConnectionData of (Parent(Self)) (&sConnectionData)
103015>>>>>
103015>>>>>            Get pbNew to bNew
103016>>>>>            Get MoveStringArrayToSQLConnection sConnectionData to SQLIniFileConnection
103017>>>>>            Case Begin
103017>>>>>                Case (SQLIniFileConnection.sDriverID = DB2_DRV_ID or SQLIniFileConnection.sDriverID = ODBC_DRV_ID)
103019>>>>>                    If (SQLIniFileConnection.sDriverID = DB2_DRV_ID) Begin
103021>>>>>                        Move "" to SQLIniFileConnection.sDatabase
103022>>>>>                    End
103022>>>>>>
103022>>>>>                    If (SQLIniFileConnection.bTrusted = True) Begin
103024>>>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "") to bOK
103025>>>>>                    End
103025>>>>>>
103025>>>>>                    Else Begin
103026>>>>>                        // It should probably be allowed to use an UID but no password...
103026>>>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
103027>>>>>                    End
103027>>>>>>
103027>>>>>                    Case Break
103028>>>>>                Case (SQLIniFileConnection.sDriverID = MSSQLDRV_ID or SQLIniFileConnection.sDriverID = SQLFLEX)
103031>>>>>                    If (SQLIniFileConnection.bTrusted = True) Begin
103033>>>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sDatabase <> "") to bOK
103034>>>>>                    End
103034>>>>>>
103034>>>>>                    Else Begin
103035>>>>>                        // It should probably be allowed to use an UID but no password...
103035>>>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sDatabase <> "" and SQLIniFileConnection.sUserID <> "") to bOK
103036>>>>>                    End
103036>>>>>>
103036>>>>>                    Case Break
103037>>>>>                Case (SQLIniFileConnection.sDriverID = ORAFLEX or SQLIniFileConnection.sDriverID = MDSPgSQL)
103040>>>>>                    // It should probably be allowed to use an UID but no password...
103040>>>>>                    Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
103041>>>>>                    Case Break
103042>>>>>                Case (SQLIniFileConnection.sDriverID = MDSPgSQL)
103045>>>>>                    // It should probably be allowed to use an UID but no password...
103045>>>>>                    Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
103046>>>>>                    Case Break
103047>>>>>                Case (SQLIniFileConnection.sDriverID = MDSMySQL)
103050>>>>>                    // It should probably be allowed to use an UID but no password...
103050>>>>>                    Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
103051>>>>>                    Case Break
103052>>>>>            Case End
103052>>>>>
103052>>>>>            If (bOK = False) Begin
103054>>>>>                Send Info_Box "Please fill in all connection data."
103055>>>>>                Procedure_Return
103056>>>>>            End
103056>>>>>>
103056>>>>>
103056>>>>>            // Oct 28 2017 NGS. Don't think this restriction is needed!
103056>>>>>            // As long as only one connection can be active, we should be fine.
103056>>>>>            // Check that the connection ID is unique:
103056>>>>>//            Get IsConnectionIDDuplicate SQLIniFileConnection to bOK
103056>>>>>//            If (bOK = True) Begin
103056>>>>>//                Get Message_Box (CS_DUF_DuplicateConnectionIDPre * "'" + SQLIniFileConnection.sConnectionID + "'." * CS_DUF_DuplicateConnectionIDPost) ""  MB_OK MB_ICONEXCLAMATION to bOK
103056>>>>>//                Procedure_Return
103056>>>>>//            End
103056>>>>>
103056>>>>>            Move MBR_Yes to iRetval
103057>>>>>            Get Label of oLoginInfo_tb to sLoginText
103058>>>>>            If (sLoginText = CS_LoginFailed) Begin
103060>>>>>                Get YesNo_Box "The login failed. Are you sure you want to use these connection settings?" to iRetval
103061>>>>>            End
103061>>>>>>
103061>>>>>            Else If (sLoginText = "") Begin
103064>>>>>                Get YesNo_Box "The login has not been tested. Are you sure you want to use these connection settings?" to iRetval
103065>>>>>            End
103065>>>>>>
103065>>>>>            If (iRetval <> MBR_Yes) Begin
103067>>>>>                Procedure_Return
103068>>>>>            End
103068>>>>>>
103068>>>>>
103068>>>>>            Set pSQLConnectionData to SQLIniFileConnection
103069>>>>>            Set pbChanged to True
103070>>>>>            Send Close_Panel
103071>>>>>        End_Procedure
103072>>>>>
103072>>>>>    End_Object
103073>>>>>
103073>>>>>    Object oCancel_Btn is a cButtonDPI
103075>>>>>        Set Label    to "Cancel"
103076>>>>>        Set Location to 264 350
103077>>>>>        Set peAnchors to anBottomRight
103078>>>>>
103078>>>>>        Procedure OnClick
103081>>>>>            Set pbChanged to False
103082>>>>>            Send Close_Panel
103083>>>>>        End_Procedure
103084>>>>>
103084>>>>>    End_Object
103085>>>>>
103085>>>>>    Object oHelp_Btn is a cButtonDPI
103087>>>>>        Set Label to "Help"
103088>>>>>        Set Location to 264 11
103089>>>>>        Set peAnchors to anBottomLeft
103090>>>>>        Set psImage to "ActionHelp.ico"
103091>>>>>
103091>>>>>        Procedure OnClick
103094>>>>>            Send DoDisplayKeyword of ghoHtmlHelp "SQLConnections Tool"
103095>>>>>        End_Procedure
103096>>>>>    End_Object
103097>>>>>
103097>>>>>    // Returns True if anything has changed.
103097>>>>>    Function Should_Save Returns Boolean
103100>>>>>        String[] sConnectionData sConnectionData2
103102>>>>>        tSQLConnection SQLConnectionData
103102>>>>>        tSQLConnection SQLConnectionData
103102>>>>>        Boolean bState
103102>>>>>
103102>>>>>        Broadcast Recursive Send WriteConnectionData (&sConnectionData)
103104>>>>>        Get pSQLConnectionData to SQLConnectionData
103105>>>>>        Get MoveSQLConnectionToStringArray SQLConnectionData to sConnectionData2
103106>>>>>        // We don't have a form here for the sConnectionString, so we "blank it out"
103106>>>>>        // to be able to compare properly.
103106>>>>>        Move "" to sConnectionData2[7]
103107>>>>>
103107>>>>>        Move (IsSameArray(sConnectionData, sConnectionData2)) to bState
103108>>>>>        Function_Return (bState = False)
103109>>>>>    End_Function
103110>>>>>
103110>>>>>    Function IsConnectionIDDuplicate tSQLConnection SQLConnection Returns Boolean
103113>>>>>        Integer iCount iSize iItems iCurrentRow
103113>>>>>        String sValue sConnectionID
103113>>>>>        Boolean bExists
103113>>>>>        tDataSourceRow[] TheData
103113>>>>>        tDataSourceRow[] TheData
103114>>>>>        tDataSourceRow TheRow
103114>>>>>        tDataSourceRow TheRow
103114>>>>>
103114>>>>>        Move 0 to iItems
103115>>>>>        Get piCurrentRow to iCurrentRow
103116>>>>>        Move SQLConnection.sConnectionID to sConnectionID
103117>>>>>        Get MoveSQLConnectionToGridRow SQLConnection to TheRow
103118>>>>>        Get pTheData to TheData
103119>>>>>        Move (SizeOfArray(TheData)) to iSize
103120>>>>>        If (iCurrentRow <> -1) Begin
103122>>>>>            // This is the sConnectionID:
103122>>>>>            Move TheRow.sValue[2] to TheData[iCurrentRow].sValue[2]
103123>>>>>        End
103123>>>>>>
103123>>>>>        Else Begin
103124>>>>>            Move TheRow to TheData[iSize]
103125>>>>>        End
103125>>>>>>
103125>>>>>        Move (SizeOfArray(TheData)) to iSize
103126>>>>>        Decrement iSize
103127>>>>>        For iCount from 0 to iSize
103133>>>>>>
103133>>>>>            Move TheData[iCount].sValue[2] to sValue
103134>>>>>            Move (sValue = sConnectionID) to bExists
103135>>>>>            If (bExists) Begin
103137>>>>>                Increment iItems
103138>>>>>            End
103138>>>>>>
103138>>>>>        Loop
103139>>>>>>
103139>>>>>
103139>>>>>        Function_Return (iItems > 1)
103140>>>>>    End_Function
103141>>>>>
103141>>>>>    // Transfers data between a tSQLConnection struct and a grid data row.
103141>>>>>    Function MoveSQLConnectionToGridRow tSQLConnection SQLConnection Returns tDataSourceRow
103144>>>>>        tDataSourceRow TheRow
103144>>>>>        tDataSourceRow TheRow
103144>>>>>        Integer iDbType
103144>>>>>        String sValue
103144>>>>>
103144>>>>>        Move 0                                  to TheRow.sValue[0]
103145>>>>>        Move SQLConnection.bEnabled             to TheRow.sValue[1]
103146>>>>>        Move SQLConnection.sConnectionID        to TheRow.sValue[2]
103147>>>>>        Move SQLConnection.sDriverID            to TheRow.sValue[3]
103148>>>>>
103148>>>>>        // We only show three asterisks ("***") instead of the password in the grid.
103148>>>>>        Move (Replace(SQLConnection.sPassword, SQLConnection.sConnectionString, "***")) to sValue
103149>>>>>        Move sValue                             to TheRow.sValue[4]
103150>>>>>
103150>>>>>        Move SQLConnection.iDbType to iDbType
103151>>>>>        Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary iDbType to sValue
103152>>>>>        Move sValue                             to TheRow.sValue[5]
103153>>>>>        Move SQLConnection.sServer              to TheRow.sValue[6]
103154>>>>>        Move SQLConnection.sDatabase            to TheRow.sValue[7]
103155>>>>>
103155>>>>>        // Hidden columns (to make Should_Save function work)
103155>>>>>        Move SQLConnection.sConnectionString    to TheRow.sValue[8] // "Untouched" connection string.
103156>>>>>        Move SQLConnection.bTrusted             to TheRow.sValue[9]
103157>>>>>        Move SQLConnection.sUserID              to TheRow.sValue[10]
103158>>>>>        Move SQLConnection.sPassword            to TheRow.sValue[11]
103159>>>>>        Move SQLConnection.sSchema              to TheRow.sValue[12]
103160>>>>>        Move SQLConnection.sBaseTableSpace      to TheRow.sValue[13]
103161>>>>>        Move SQLConnection.sLongTableSpace      to TheRow.sValue[14]
103162>>>>>        Move SQLConnection.sIndexTableSpace     to TheRow.sValue[15]
103163>>>>>        Move SQLConnection.bSilentLogin         to TheRow.sValue[16]
103164>>>>>//        Move SQLConnection.bDisabled            to TheRow.sValue[17]
103164>>>>>//        Move SQLConnection.iDriverIndex         to TheRow.sValue[18]
103164>>>>>
103164>>>>>        Function_Return TheRow
103165>>>>>    End_Function
103166>>>>>
103166>>>>>    Function MoveSQLConnectionToStringArray tSQLConnection SQLConnection Returns String[]
103169>>>>>        String[] sConnectionData
103170>>>>>        Integer iRetval
103170>>>>>
103170>>>>>        Move SQLConnection.bEnabled          to sConnectionData[1]
103171>>>>>        Move SQLConnection.sConnectionID     to sConnectionData[2]
103172>>>>>        Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary SQLConnection.iDbType to sConnectionData[3]
103173>>>>>        Move SQLConnection.sDriverID         to sConnectionData[4]
103174>>>>>        Move SQLConnection.sServer           to sConnectionData[5]
103175>>>>>        Move SQLConnection.sDatabase         to sConnectionData[6]
103176>>>>>        Move SQLConnection.sConnectionString to sConnectionData[7]
103177>>>>>        Move SQLConnection.bTrusted          to sConnectionData[8]
103178>>>>>        Move SQLConnection.sUserID           to sConnectionData[9]
103179>>>>>
103179>>>>>        If (SQLConnection.sPassword <> "") Begin
103181>>>>>            Move MBR_Yes to iRetval
103182>>>>>            If (pbDFConnId(Self) = True) Begin
103184>>>>>                Get YesNo_Box "You are working with a DAW 'DFConnId.ini' file. Although this program can both read/write to such a file, the password encryption/decryption algorithms are (obviously) different. This password will not be touched. Continue?" to iRetval
103185>>>>>                If (iRetval = MBR_Yes) Begin
103187>>>>>                    Set psUncryptedPw to SQLConnection.sPassword
103188>>>>>                    Move "" to SQLConnection.sPassword
103189>>>>>                End
103189>>>>>>
103189>>>>>                Else Begin
103190>>>>>                    Send Stop_UI
103191>>>>>                End
103191>>>>>>
103191>>>>>            End
103191>>>>>>
103191>>>>>            Else Begin
103192>>>>>                Move SQLConnection.sPassword to sConnectionData[10]
103193>>>>>            End
103193>>>>>>
103193>>>>>        End
103193>>>>>>
103193>>>>>
103193>>>>>        Move SQLConnection.sSchema           to sConnectionData[11]
103194>>>>>        Move SQLConnection.sBaseTableSpace   to sConnectionData[12]
103195>>>>>        Move SQLConnection.sLongTableSpace   to sConnectionData[13]
103196>>>>>        Move SQLConnection.sIndexTableSpace  to sConnectionData[14]
103197>>>>>        Move SQLConnection.bSilentLogin      to sConnectionData[15]
103198>>>>>
103198>>>>>        Function_Return sConnectionData
103199>>>>>    End_Function
103200>>>>>
103200>>>>>    Function MoveStringArrayToSQLConnection String[] sConnectionData Returns tSQLConnection
103203>>>>>        tSQLConnection SQLConnection
103203>>>>>        tSQLConnection SQLConnection
103203>>>>>
103203>>>>>        Move sConnectionData[1]  to SQLConnection.bEnabled
103204>>>>>        Move sConnectionData[2]  to SQLConnection.sConnectionID
103205>>>>>        Get SqlUtilDbTypeToInteger of ghoDbUpdateFunctionLibrary sConnectionData[3] to SQLConnection.iDbType
103206>>>>>        Move sConnectionData[4]  to SQLConnection.sDriverID
103207>>>>>        Move sConnectionData[5]  to SQLConnection.sServer
103208>>>>>        Move sConnectionData[6]  to SQLConnection.sDatabase
103209>>>>>
103209>>>>>        Move sConnectionData[8]  to SQLConnection.bTrusted
103210>>>>>        Move sConnectionData[9]  to SQLConnection.sUserID
103211>>>>>
103211>>>>>        If (sConnectionData[10] <> "" and pbDFConnId(Self) = False) Begin
103213>>>>>            Move sConnectionData[10] to SQLConnection.sPassword
103214>>>>>        End
103214>>>>>>
103214>>>>>        // In case of we're dealing with a DfConnID.ini file (DF 19+) we don't want to change the password
103214>>>>>        // as DAW's 'Managed Connections' program has a different password encryption/decryption algorithm.
103214>>>>>        If (pbDFConnId(Self) = True) Begin
103216>>>>>            Get psUncryptedPw to SQLConnection.sPassword
103217>>>>>        End
103217>>>>>>
103217>>>>>
103217>>>>>        Move sConnectionData[11] to SQLConnection.sSchema
103218>>>>>        Move sConnectionData[12] to SQLConnection.sBaseTableSpace
103219>>>>>        Move sConnectionData[13] to SQLConnection.sLongTableSpace
103220>>>>>        Move sConnectionData[14] to SQLConnection.sIndexTableSpace
103221>>>>>        Move sConnectionData[15] to SQLConnection.bSilentLogin
103222>>>>>
103222>>>>>        // Connection string:
103222>>>>>        Get ConstructConnectionString of ghoSQLConnectionHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase ;                                                                 SQLConnection.bTrusted  SQLConnection.sUserID SQLConnection.sPassword ;                                      to SQLConnection.sConnectionString
103223>>>>>
103223>>>>>        Function_Return SQLConnection
103224>>>>>    End_Function
103225>>>>>
103225>>>>>    Procedure Popup
103228>>>>>        tSQLConnection SQLIniFileConnection
103228>>>>>        tSQLConnection SQLIniFileConnection
103228>>>>>        String[] sConnectionData
103229>>>>>        String sDriverID
103229>>>>>        Integer iDbType
103229>>>>>        Boolean bAdd
103229>>>>>
103229>>>>>        Move (piCurrentRow(Self) = -1) to bAdd
103230>>>>>        Get pSQLConnectionData to SQLIniFileConnection
103231>>>>>        If (SQLIniFileConnection.bEnabled = False and bAdd = True) Begin
103233>>>>>            Move True to SQLIniFileConnection.bEnabled
103234>>>>>        End
103234>>>>>>
103234>>>>>        Get MoveSQLConnectionToStringArray SQLIniFileConnection to sConnectionData
103235>>>>>
103235>>>>>        Broadcast Recursive Send ReadConnectionData sConnectionData
103237>>>>>
103237>>>>>        // We need this message to "auto-default" certain fields.
103237>>>>>        If (bAdd = True) Begin
103239>>>>>            Get SelectedDbType of oDbType_cf to iDbType
103240>>>>>            Get Value of oDriverID_cf to sDriverID
103241>>>>>            If (sDriverID = "") Begin
103243>>>>>                Move MSSQLDRV_ID to sDriverID
103244>>>>>            End
103244>>>>>>
103244>>>>>            Broadcast Recursive Send DbTypeUpdate of oSettings_grp iDbType sDriverID
103246>>>>>        End
103246>>>>>>
103246>>>>>
103246>>>>>        Set Password_State of oPassword_fm to True
103247>>>>>        Set Value of oLoginInfo_tb to ""
103248>>>>>        Set Statusbar_Id to (phoDialogCommandbar(Self))
103249>>>>>
103249>>>>>        Forward Send Popup
103251>>>>>    End_Procedure
103252>>>>>
103252>>>>>    Procedure Page Integer iPageObject
103255>>>>>        Boolean bNew bReadOnly
103255>>>>>        String sText
103255>>>>>        Handle hWnd
103255>>>>>
103255>>>>>        Send Cursor_Ready of Cursor_Control
103256>>>>>        Forward Send Page iPageObject
103258>>>>>
103258>>>>>        Set Icon to "SQLConnections.ico"
103259>>>>>        Get pbNew to bNew
103260>>>>>        If (bNew = True) Begin
103262>>>>>            Move ("The" * CS_SQLIniFileName * "file doesn't exist yet for this workspace and needs to be created. Here's what you need to do:\n\n") to sText
103263>>>>>            Move (sText * "1. Enter a Connection ID (the same that is being used by your workspace .int files) and other data that is used to login to the database.\n") to sText
103264>>>>>            Move (sText * "2. Press the 'Test Login' button to ensure entered details are correct.\n") to sText
103265>>>>>            Move (sText * "3. Press the 'OK' button and then save your changes.\n") to sText
103266>>>>>            Send Info_Box sText
103267>>>>>        End
103267>>>>>>
103267>>>>>
103267>>>>>        If (ghoSkinFramework <> 0 and hWnd <> 0) Begin
103269>>>>>            Send ComRemoveWindow to ghoSkinFramework hWnd
103270>>>>>            Send ComApplyWindow  to ghoSkinFramework hWnd
103271>>>>>        End
103271>>>>>>
103271>>>>>
103271>>>>>        Get pbReadOnly to bReadOnly
103272>>>>>        If (bReadOnly = True) Begin
103274>>>>>            Broadcast Recursive Set Enabled_State    to (not(bReadOnly))
103276>>>>>            Set Enabled_State of oSettings_grp       to True
103277>>>>>            Set Enabled_State of oPassword_fm        to True
103278>>>>>            Set Enabled_State of oViewPassword_btn   to True
103279>>>>>            Set Enabled_State of oCheckLogin_btn     to True
103280>>>>>            Set Enabled_State of oCancel_Btn         to True
103281>>>>>            Send Activate of oCancel_Btn
103282>>>>>        End
103282>>>>>>
103282>>>>>    End_Procedure
103283>>>>>
103283>>>>>    Function IniFileName Returns String
103286>>>>>        String sRetval
103286>>>>>        Function_Return sRetval
103287>>>>>    End_Function
103288>>>>>
103288>>>>>    // Put a status bar at the bottom of the panel, which makes
103288>>>>>    // status_help work and puts a gripper in the lower right corner.
103288>>>>>    Procedure End_Construct_Object
103291>>>>>        Integer iStyle iSize iOffset
103291>>>>>
103291>>>>>        Forward Send End_Construct_Object
103293>>>>>
103293>>>>>        Get Border_Style to iStyle
103294>>>>>        Move 8 to iOffset
103295>>>>>        If (iStyle = Border_Thick) Begin
103297>>>>>            Object oDialogCommandbar is a cCJCommandBarSystem
103299>>>>>                Object oStatusBar is a cCJStatusBar
103301>>>>>                    Set phoDialogCommandbar to Self
103302>>>>>                    Object oStatusIdle is a cCJStatusBarPane
103304>>>>>                        Set piId to sbpIDIdlePane
103305>>>>>                        Set pbStyleStretch to True
103306>>>>>                    End_Object
103307>>>>>                End_Object
103308>>>>>            End_Object
103309>>>>>
103309>>>>>            Get Size to iSize
103310>>>>>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
103311>>>>>        End
103311>>>>>>
103311>>>>>    End_Procedure
103312>>>>>
103312>>>>>    Procedure ShowProgramHelp
103315>>>>>        Send DoDisplayKeyword of ghoHtmlHelp "SQLConnections Tool"
103316>>>>>    End_Procedure
103317>>>>>
103317>>>>>    On_Key Key_F1         Send ShowProgramHelp
103318>>>>>    On_Key Key_Ctrl+Key_L Send KeyAction of oCheckLogin_btn
103319>>>>>    On_Key kCancel        Send KeyAction of oCancel_Btn
103320>>>>>End_Object
103321>>>>>
103321>>>>>// General purpose edit-mode message                                                                                                                        // If ini-file= "DFConnId.ini" (DAW file)
103321>>>>>Procedure Activate_SQLMaintainConnections_dg Boolean bNew Integer iCurrentRow tSQLConnection ByRef SQLConnectionData Boolean ByRef bChanged Boolean bDFConnId tDataSourceRow[] TheData
103324>>>>>    Handle ho
103324>>>>>    String sPath sSQLConnectionsFileName
103324>>>>>
103324>>>>>    Send Cursor_Wait of Cursor_Control
103325>>>>>    Move (oSQLMaintainConnections_dg(Self)) to ho
103326>>>>>    Set pbReadOnly              of ho to False
103327>>>>>    Set pbNew                   of ho to bNew
103328>>>>>    Set piCurrentRow            of ho to iCurrentRow
103329>>>>>    Set pbDFConnId              of ho to bDFConnId
103330>>>>>    Set pSQLConnectionData      of ho to SQLConnectionData
103331>>>>>    If (SQLConnectionData.sConnectionString <> "") Begin
103333>>>>>        Get psIniFilePath of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sPath
103334>>>>>        Get psIniFileName of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sSQLConnectionsFileName
103335>>>>>    End
103335>>>>>>
103335>>>>>    Set Label  of ho to ("Connection Properties" * "[" + String(sPath) + String(sSQLConnectionsFileName) + "]")
103336>>>>>    Set pTheData                of ho to TheData
103337>>>>>
103337>>>>>    Send Popup                  of ho
103338>>>>>
103338>>>>>    Get pSQLConnectionData      of ho to SQLConnectionData
103339>>>>>    Get pbChanged               of ho to bChanged
103340>>>>>End_Procedure
103341>>>>>
103341>>>>>// Read-only access message
103341>>>>>Procedure Activate_ReadOnlySQLMaintainConnections_dg tSQLConnection SQLConnectionData
103344>>>>>    Handle ho
103344>>>>>    String sPath sSQLConnectionsFileName
103344>>>>>
103344>>>>>    Send Cursor_Wait of Cursor_Control
103345>>>>>    Move (oSQLMaintainConnections_dg(Self)) to ho
103346>>>>>    Set pbReadOnly              of ho to True
103347>>>>>    Set pSQLConnectionData      of ho to SQLConnectionData
103348>>>>>    If (SQLConnectionData.sConnectionString <> "") Begin
103350>>>>>        Get psIniFilePath of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sPath
103351>>>>>        Get psIniFileName of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sSQLConnectionsFileName
103352>>>>>    End
103352>>>>>>
103352>>>>>    Set Label  of ho to ("Connection Properties (Read-Only)" * "[" + String(sPath) + String(sSQLConnectionsFileName) + "]")
103353>>>>>
103353>>>>>    Send Popup of ho
103354>>>>>End_Procedure
103355>>>>>
103355>>>Use AddToStudio.dg
Including file: AddToStudio.dg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\AddToStudio.dg)
103355>>>>>Use Windows.pkg
103355>>>>>Use Dfspnfrm.pkg
103355>>>>>Use cRegistry.pkg
103355>>>>>Use vWin32fh.pkg
103355>>>>>
103355>>>>>Enum_List
103355>>>>>    Define cx_RegKeyAlreadyExist
103355>>>>>    Define cx_RegKeyCreated
103355>>>>>    Define cx_RegkeyFailed
103355>>>>>    Define cx_RegKeyVDFKeyDoesNotExist
103355>>>>>    Define CX_InstalledOkVdfUnder16
103355>>>>>End_Enum_List
103355>>>>>
103355>>>>>// Note: The "Visual" part will automatically be removed if
103355>>>>>// the current DataFlex version is above 17.
103355>>>>>Define CS_StudioPath        for "Software\Data Access Worldwide\Visual DataFlex Tools\"
103355>>>>>Define CS_StudioTools       for "\Studio\Tools"
103355>>>>>Define CS_RegApplication    for "<application>"
103355>>>>>Define CS_RegWorkspace      for "<workspace>"
103355>>>>>Define CS_CommandLine       for "CommandLine"
103355>>>>>Define CS_Name              for "Name"
103355>>>>>Define CS_Separator         for "Separator"
103355>>>>>Define CS_Command           for "Command"
103355>>>>>
103355>>>>>
103355>>>>>Object oAddToStudio_dg is a ModalPanel
103357>>>>>    Set Size to 81 330
103358>>>>>    Set Label to "Add Program To DataFlex Studio's Tools Menu"
103359>>>>>    Set piMinSize to 79 211
103360>>>>>    Set Location to 5 4
103361>>>>>    Set Locate_Mode to Center_On_Parent
103362>>>>>
103362>>>>>    Property String psTag CS_RegApplication
103364>>>>>
103364>>>>>    Object oStudioIntegration_grp is a Group
103366>>>>>        Set Size to 45 299
103367>>>>>        Set Location to 8 15
103368>>>>>        Set Label to "DataFlex Studio Integration"
103369>>>>>
103369>>>>>        Object oStudioMajorVersion_sf is a SpinForm
103371>>>>>            Set Size to 12 27
103372>>>>>            Set Location to 18 168
103373>>>>>            Set Maximum_Position to 30
103374>>>>>            Set Minimum_Position to 14
103375>>>>>            Set Label_Col_Offset to 2
103376>>>>>            Set Label_Justification_Mode to JMode_Right
103377>>>>>            Set Label to "Add to Studio's Tools Menu:     Major Version"
103378>>>>>            Set Status_Help to "DataFlex main version - e.g. '18'"
103379>>>>>            Set Value to FMAC_VERSION
103380>>>>>            Set peAnchors to anNone
103381>>>>>        End_Object
103382>>>>>
103382>>>>>        Object oStudioMinorVersion_sf is a SpinForm
103384>>>>>            Set Size to 12 27
103385>>>>>            Set Location to 18 254
103386>>>>>            Set Label_Col_Offset to 2
103387>>>>>            Set Label to "Minor Version"
103388>>>>>            Set Status_Help to "DataFlex minor version - e.g. '0'"
103389>>>>>            Set Maximum_Position to 9
103390>>>>>            Set Minimum_Position to 0
103391>>>>>            Set Value to FMAC_REVISION
103392>>>>>            Set Label_Justification_Mode to JMode_Right
103393>>>>>            Set peAnchors to anNone
103394>>>>>        End_Object
103395>>>>>
103395>>>>>    End_Object
103396>>>>>
103396>>>>>    Object oOK_btn is a Button
103398>>>>>        Set Size to 14 50
103399>>>>>        Set Location to 59 207
103400>>>>>        Set Label to "Add Now"
103401>>>>>        Set Status_Help to "Add to DataFlex Studios 'Tools' menu. The Studio version can be selected with the two spinforms. The COMManifestStudio program gets added to the Studios Tools menu. When selected from the Studio it will pass the current project name on the command line so that the current program's manifest file is automatically loaded by the COMManifestStudio program."
103402>>>>>        Set peAnchors to anTopRight
103403>>>>>
103403>>>>>        Procedure OnClick
103406>>>>>            Integer iRetval iMajorVersion iMinorVersion
103406>>>>>            String sText sStudioVersion
103406>>>>>            Get Value of oStudioMajorVersion_sf to iMajorVersion
103407>>>>>            Get Value of oStudioMinorVersion_sf to iMinorVersion
103408>>>>>            Move (String(iMajorVersion) + "." + String(iMinorVersion)) to sStudioVersion
103409>>>>>            Get AddProgramToStudioToolsMenu sStudioVersion to iRetval
103410>>>>>            Case Begin
103410>>>>>                Case (iRetval = cx_RegKeyAlreadyExist)
103412>>>>>                    Move ("The program already exists in the" * sStudioVersion * "DataFlex Studios Tools menu.") to sText
103413>>>>>                    Break
103414>>>>>                Case (iRetval = cx_RegKeyCreated)
103417>>>>>                    Move ("Success. The tool was added to the" * sStudioVersion *  "DataFlex Studios Tools menu.") to sText
103418>>>>>                    Break
103419>>>>>                Case (iRetval = cx_RegkeyFailed)
103422>>>>>                    Move "Failed. Could not create the registry key for adding the program to the DataFlex Studio's Tools menu." to sText
103423>>>>>                    Break
103424>>>>>                Case (iRetval = cx_RegKeyVDFKeyDoesNotExist)
103427>>>>>                    Move ("Could not find the Studio registry key. Is DataFlex Studio version" * sStudioVersion * "really installed on this machine?") to sText
103428>>>>>                    Break
103429>>>>>                Case (iRetval = CX_InstalledOkVdfUnder16)
103432>>>>>                    Move ("The program was added to the" * sStudioVersion * "Studios Tools menu successfully, but because you installed for an earlier version of the Studio than 16.0 you need to compile the program under that same VDF version, else the Studio can't start the program properly. (Sorry, just a 'feature' of earlier versions of the Studio)") to sText
103433>>>>>                    Break
103434>>>>>            Case End
103434>>>>>
103434>>>>>            Send Info_Box sText
103435>>>>>        End_Procedure
103436>>>>>    End_Object
103437>>>>>
103437>>>>>    Object oCancel_Btn is a Button
103439>>>>>        Set Label to "&Close"
103440>>>>>        Set Location to 59 264
103441>>>>>        Set peAnchors to anBottomRight
103442>>>>>
103442>>>>>        Procedure OnClick
103445>>>>>            Send Close_Panel
103446>>>>>        End_Procedure
103447>>>>>
103447>>>>>    End_Object
103448>>>>>
103448>>>>>    Function AddProgramToStudioToolsMenu String sStudioVersion Returns Integer
103451>>>>>        Boolean bOk bExists bOpen
103451>>>>>        String sKey sValue sProgramPath sProgram sProduct sStudioPath
103451>>>>>        Handle hoReg hoArray
103451>>>>>        Integer i iItems iCreated iRetval
103451>>>>>
103451>>>>>        Move False to bOk
103452>>>>>        Move (CS_StudioPath + (Trim(sStudioVersion)))  to sStudioPath
103453>>>>>        If (sStudioVersion > "17.1") Begin
103455>>>>>            Move (Replace("Visual ", sStudioPath, "")) to sStudioPath
103456>>>>>        End
103456>>>>>>
103456>>>>>
103456>>>>>        Get psProgramPath of (phoWorkspace(ghoApplication)) to sProgramPath
103457>>>>>        Get PathAtIndex of (phoWorkspace(ghoApplication)) sProgramPath 1 to sProgramPath
103458>>>>>        Get vFolderFormat sProgramPath to sProgramPath
103459>>>>>        Get Module_Name to sProgram
103460>>>>>//        Get psProduct     of (phoWorkspace(ghoApplication)) to sProduct
103460>>>>>        Move sProgram to sProduct
103461>>>>>        Get Create U_cRegistry to hoReg
103462>>>>>        Set phRootKey of hoReg to HKEY_CURRENT_USER
103463>>>>>
103463>>>>>        // First check if the DataFlex version is installed
103463>>>>>        Get KeyExists of hoReg sStudioPath to bExists
103464>>>>>        If (bExists = False) Begin
103466>>>>>            Send Destroy of hoReg
103467>>>>>            Function_Return cx_RegKeyVDFKeyDoesNotExist
103468>>>>>        End
103468>>>>>>
103468>>>>>
103468>>>>>        // Then check if any tools have been installed in the Tools Menu.
103468>>>>>        // If no tools created yet, create the Tools registry key.
103468>>>>>        Move (sStudioPath + CS_StudioTools) to sStudioPath
103469>>>>>        Get KeyExists of hoReg sStudioPath to bExists
103470>>>>>        If (bExists = False) Begin
103472>>>>>            Set pfAccessRights of hoReg to KEY_ALL_ACCESS
103473>>>>>            Get CreateKey of hoReg sStudioPath to iCreated
103474>>>>>            If (iCreated <> 0) Begin
103476>>>>>                Move cx_RegkeyFailed to iRetval
103477>>>>>            End
103477>>>>>>
103477>>>>>            Else Begin
103478>>>>>                Move True to bExists
103479>>>>>            End
103479>>>>>>
103479>>>>>        End
103479>>>>>>
103479>>>>>
103479>>>>>        If (bExists = True) Begin
103481>>>>>            Get OpenKey of hoReg sStudioPath to bOk
103482>>>>>            If (bOk = True) Begin
103484>>>>>                Get Create U_Array to hoArray
103485>>>>>                Get GetSubkeys of hoReg hoArray to iItems
103486>>>>>                Decrement iItems
103487>>>>>                Move False to bExists
103488>>>>>                Set pfAccessRights of hoReg to KEY_READ
103489>>>>>                // Check if the key already exists:
103489>>>>>                For i from 0 to iItems
103495>>>>>>
103495>>>>>                    Get Value of hoArray item i to sKey
103496>>>>>                    Move (sStudioPath + "\" + sKey) to sKey
103497>>>>>                    Get OpenKey of hoReg sKey to bOpen
103498>>>>>                    If (bOpen = True) Begin
103500>>>>>                        Get ReadString of hoReg CS_Name to sValue
103501>>>>>                        If (sValue = sProduct) Begin
103503>>>>>                            Move True to bExists
103504>>>>>                        End
103504>>>>>>
103504>>>>>                    End
103504>>>>>>
103504>>>>>                Loop
103505>>>>>>
103505>>>>>                Send Destroy of hoArray
103506>>>>>                If (bExists = False) Begin
103508>>>>>                    Set pfAccessRights of hoReg to KEY_ALL_ACCESS
103509>>>>>                    // We need to create the next key number:
103509>>>>>                    // The studio expect tools menu items to be numbered 1,2,3...n
103509>>>>>                    Increment iItems
103510>>>>>                    Increment iItems
103511>>>>>                    Get CreateKey of hoReg (sStudioPath + "\" + String(iItems)) to iCreated
103512>>>>>                    If (iCreated = 0) Begin
103514>>>>>                        Send WriteString of hoReg CS_Name sProduct
103515>>>>>                        // From DataFlex 16 and up the params for the Studio's Tools menu changed slightly:
103515>>>>>                        If (sStudioVersion >= "16.0") Begin
103517>>>>>                            Send WriteString of hoReg CS_Command (sProgramPath + sProgram)
103518>>>>>                            Send WriteString of hoReg CS_CommandLine (psTag(Self))
103519>>>>>                        End
103519>>>>>>
103519>>>>>                        Else Begin
103520>>>>>                            Send WriteString of hoReg CS_CommandLine ('"' + sProgramPath + sProgram + ".exe" + '"' * psTag(Self))
103521>>>>>                            Move CX_InstalledOkVdfUnder16 to iRetval
103522>>>>>                        End
103522>>>>>>
103522>>>>>                        Send WriteDword  of hoReg CS_Separator 1
103523>>>>>                        Move cx_RegKeyCreated to iRetval
103524>>>>>                    End
103524>>>>>>
103524>>>>>                    Else Begin
103525>>>>>                        Move cx_RegkeyFailed to iRetval
103526>>>>>                    End
103526>>>>>>
103526>>>>>                End
103526>>>>>>
103526>>>>>                Else Begin
103527>>>>>                    Move cx_RegKeyAlreadyExist to iRetval
103528>>>>>                End
103528>>>>>>
103528>>>>>                Send CloseKey of hoReg
103529>>>>>            End
103529>>>>>>
103529>>>>>        End
103529>>>>>>
103529>>>>>
103529>>>>>        Send Destroy of hoReg
103530>>>>>        Function_Return iRetval
103531>>>>>    End_Function
103532>>>>>
103532>>>>>    Procedure Page Integer iPageObject
103535>>>>>        Forward Send Page iPageObject
103537>>>>>        Set Icon to "ActionAdd.ico"
103538>>>>>    End_Procedure
103539>>>>>
103539>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
103540>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
103541>>>>>    On_Key kCancel       Send KeyAction of oCancel_Btn
103542>>>>>End_Object
103543>>>
103543>>>Activate_View Activate_oSQLMaintainConnection for oSQLMaintainConnection
103553>>>>
103553>>>Object oSQLMaintainConnection is a dbView
103555>>>    Set Size to 153 489
103556>>>    Set Location to 2 2
103557>>>    Set Maximize_Icon to True
103558>>>    Set Minimize_Icon to False
103559>>>    Set Border_Style to Border_Thick
103560>>>    Set View_Mode to Viewmode_Zoom
103561>>>    Set pbAutoActivate to True
103562>>>    Set pbAcceptDropFiles to True
103563>>>    Property Boolean pbEnabled False
103565>>>    Property Boolean pbNew False
103567>>>    Property tDataSourceRow[] pTheData
103569>>>
103569>>>    Function IniFileName Returns String
103572>>>        String sRetval
103572>>>        Get InfileName of oSQLConnections_grd to sRetval
103573>>>        Function_Return sRetval
103574>>>    End_Function
103575>>>
103575>>>    Object oGridInfo_tb is a TextBox
103577>>>        Set Auto_Size_State to False
103578>>>        Set Size to 9 473
103579>>>        Set Location to 3 17
103580>>>        Set Label to "You can drag and drop a connection file on to the grid."
103581>>>        Set FontItalics to True
103582>>>        Set peAnchors to anTopLeftRight
103583>>>        Set Justification_Mode to JMode_Center
103584>>>    End_Object
103585>>>
103585>>>    Object oSQLConnections_grd is a cCJGrid
103587>>>        Set Size to 100 454
103588>>>        Set Location to 14 19
103589>>>        Set peAnchors to anAll
103590>>>        Set pbShowRowFocus to True
103591>>>        Set pbUseAlternateRowBackgroundColor to True
103592>>>        Set pbSelectionEnable to True
103593>>>        Set pbRestoreLayout to True
103594>>>        Set psLayoutSection to "oSQLConnections_grd"
103595>>>        Set piLayoutBuild to 12
103596>>>        Set pbShowFooter to True
103597>>>        Set pbAllowAppendRow to False
103598>>>        Set pbAllowEdit to False
103599>>>        Set pbAllowInsertRow to False
103600>>>        Set pbAutoAppend to False
103601>>>        Set pbAutoSave to False
103602>>>        Set pbEditOnTyping to False
103603>>>        Set peVisualTheme to xtpReportThemeOffice2003
103604>>>
103604>>>        Object oCJGridColumnRowIndicator is a cCJGridColumnRowIndicator
103606>>>            Set piWidth to 17
103607>>>        End_Object
103608>>>
103608>>>        Object oActive_Col is a cCJGridColumn
103610>>>            Set piWidth to 65
103611>>>            Set psCaption to "Enabled"
103612>>>            Set pbCheckbox to True
103613>>>            Set pbResizable to False
103614>>>            Set psToolTip to "Only one connection can be the active one at any time. Press the 'Edit' button or double-click on a row to edit."
103615>>>            Set pbResizable to False
103616>>>        End_Object
103617>>>
103617>>>        Object oConnectionID_Col is a cCJGridColumn
103619>>>            Set piWidth to 81
103620>>>            Set psCaption to "ID"
103621>>>//            Set piMaximumWidth to 170
103621>>>        End_Object
103622>>>
103622>>>        Object oDbType_Col is a cCJGridColumn
103624>>>            Set piWidth to 135
103625>>>            Set psCaption to "Database Type"
103626>>>//            Set pbResizable to False
103626>>>        End_Object
103627>>>
103627>>>        Object oServer_Col is a cCJGridColumn
103629>>>            Set piWidth to 124
103630>>>            Set psCaption to "Server"
103631>>>        End_Object
103632>>>
103632>>>        Object oDatabase_Col is a cCJGridColumn
103634>>>            Set piWidth to 82
103635>>>            Set psCaption to "Database"
103636>>>        End_Object
103637>>>
103637>>>        Object oDriver_Col is a cCJGridColumn
103639>>>            Set piWidth to 90
103640>>>            Set psCaption to "Driver ID"
103641>>>//            Set pbResizable to False
103641>>>        End_Object
103642>>>
103642>>>        Object oConnectionString_Col is a cCJGridColumn
103644>>>            Set piWidth to 328
103645>>>            Set psCaption to "Connection String"
103646>>>            Set psTooltip to "The full connection string as read from the connections ini-file. Press the 'Edit' button or double-click on a row to edit."
103647>>>        End_Object
103648>>>
103648>>>        // The following columns are all hidden. The only reason they are here is to make the grid data exactly the same
103648>>>        // as the tSQLConnection data.
103648>>>        // See the "Should_Save" function
103648>>>        //
103648>>>        // "Untouched" connection string column. Needed when passing data between grid and popup dialog as we mask pw in connection string.
103648>>>        Object oConnectionStringFull_Col is a cCJGridColumn
103650>>>            Set piWidth to 50
103651>>>            Set psCaption to "Connection String (Untouched)"
103652>>>            Set pbVisible to False
103653>>>        End_Object
103654>>>
103654>>>        Object oTrusted_Col is a cCJGridColumn
103656>>>            Set piWidth to 50
103657>>>            Set psCaption to "Trusted"
103658>>>            Set pbCheckbox to True
103659>>>            Set pbVisible to False
103660>>>        End_Object
103661>>>
103661>>>        Object oUserID_Col is a cCJGridColumn
103663>>>            Set piWidth to 50
103664>>>            Set psCaption to "UserID"
103665>>>            Set pbVisible to False
103666>>>        End_Object
103667>>>
103667>>>        Object oPassword_Col is a cCJGridColumn
103669>>>            Set piWidth to 50
103670>>>            Set psCaption to "Password"
103671>>>            Set pbVisible to False
103672>>>        End_Object
103673>>>
103673>>>        Object oSchema_Col is a cCJGridColumn
103675>>>            Set piWidth to 50
103676>>>            Set psCaption to "Schema"
103677>>>            Set pbVisible to False
103678>>>        End_Object
103679>>>
103679>>>        Object oBaseTableSpace_Col is a cCJGridColumn
103681>>>            Set piWidth to 50
103682>>>            Set psCaption to "Base Table Space"
103683>>>            Set pbVisible to False
103684>>>        End_Object
103685>>>
103685>>>        Object oLongTableSpace_Col is a cCJGridColumn
103687>>>            Set piWidth to 50
103688>>>            Set psCaption to "Long Table Space"
103689>>>            Set pbVisible to False
103690>>>        End_Object
103691>>>
103691>>>        Object oIndexTableSpace_Col is a cCJGridColumn
103693>>>            Set piWidth to 50
103694>>>            Set psCaption to "Index Table Space"
103695>>>            Set pbVisible to False
103696>>>        End_Object
103697>>>
103697>>>        Object oSilentLogin_Col is a cCJGridColumn
103699>>>            Set piWidth to 50
103700>>>            Set psCaption to "Silent Login"
103701>>>            Set pbCheckbox to True
103702>>>            Set pbVisible to False
103703>>>        End_Object
103704>>>
103704>>>//        Object oDisabled_Col is a cCJGridColumn
103704>>>//            Set piWidth to 50
103704>>>//            Set psCaption to "Disabled"
103704>>>//            Set pbVisible to False
103704>>>//        End_Object
103704>>>
103704>>>        Object oCJContextMenu is a cCJContextMenu
103706>>>            Set pbShowPopupBarToolTips of ghoCommandBars to True
103707>>>
103707>>>            Object oAddMenuItem is a cCJMenuItem
103709>>>                Set psCaption to "Add"
103710>>>                Set psTooltip to "Add new connection"
103711>>>                Set psImage to "ActionNew.ico"
103712>>>                Procedure OnExecute Variant vCommandBarControl
103715>>>                    Forward Send OnExecute vCommandBarControl
103717>>>                    Send KeyAction of oAdd_btn
103718>>>                End_Procedure
103719>>>            End_Object
103720>>>
103720>>>            Object oEditMenuItem is a cCJMenuItem
103722>>>                Set psCaption to "Edit"
103723>>>                Set psTooltip to "Edit existing connection"
103724>>>                Set psImage to "ActionEdit.ico"
103725>>>                Procedure OnExecute Variant vCommandBarControl
103728>>>                    Forward Send OnExecute vCommandBarControl
103730>>>                    Send KeyAction of oEdit_btn
103731>>>                End_Procedure
103732>>>            End_Object
103733>>>
103733>>>            Object oDeleteMenuItem is a cCJMenuItem
103735>>>                Set psCaption to "Delete"
103736>>>                Set psTooltip to "Delete current connection"
103737>>>                Set psImage to "ActionDelete.ico"
103738>>>                Procedure OnExecute Variant vCommandBarControl
103741>>>                    Forward Send OnExecute vCommandBarControl
103743>>>                    Send KeyAction of oDelete_btn
103744>>>                End_Procedure
103745>>>            End_Object
103746>>>
103746>>>            Object oRefreshMenuItem is a cCJMenuItem
103748>>>                Set pbControlBeginGroup to True
103749>>>                Set psCaption to "Refresh"
103750>>>                Set psTooltip to "Refresh grid (read values from ini-file)"
103751>>>                Set psImage to "ActionRefresh.ico"
103752>>>                Procedure OnExecute Variant vCommandBarControl
103755>>>                    Forward Send OnExecute vCommandBarControl
103757>>>                    Send KeyAction of oRefresh_btn
103758>>>                End_Procedure
103759>>>            End_Object
103760>>>
103760>>>            Object oSaveMenuItem is a cCJMenuItem
103762>>>                Set psCaption to "Save"
103763>>>                Set psTooltip to "Save changes"
103764>>>                Set psImage to "ActionSave.ico"
103765>>>                Procedure OnExecute Variant vCommandBarControl
103768>>>                    Forward Send OnExecute vCommandBarControl
103770>>>                    Send KeyAction of oSave_btn
103771>>>                End_Procedure
103772>>>
103772>>>                Function IsEnabled Returns Boolean
103775>>>                    Boolean bState
103775>>>                    Get Should_Save to bState
103776>>>                    Function_Return (bState = True)
103777>>>                End_Function
103778>>>            End_Object
103779>>>
103779>>>            Object oOpenMenuItem is a cCJMenuItem
103781>>>                Set psCaption to "Open"
103782>>>                Set psTooltip to "Open connection ini-file"
103783>>>                Set psImage to "ActionOpen.ico"
103784>>>                Procedure OnExecute Variant vCommandBarControl
103787>>>                    Forward Send OnExecute vCommandBarControl
103789>>>                    Send KeyAction of oOpen_btn
103790>>>                End_Procedure
103791>>>            End_Object
103792>>>
103792>>>
103792>>>            Set phoContextMenu to Self
103793>>>        End_Object
103794>>>
103794>>>        Function Should_Save Returns Boolean
103797>>>            tDataSourceRow[] TheData1 TheData2
103797>>>            tDataSourceRow[] TheData1 TheData2
103799>>>            Handle hoDataSource
103799>>>            Boolean bShouldSave
103799>>>
103799>>>            Move True to bShouldSave
103800>>>            Get pTheData to TheData1
103801>>>            Get phoDataSource to hoDataSource
103802>>>            Get DataSource    of hoDataSource to TheData2
103803>>>            Move (not(IsSameArray(TheData1, TheData2))) to bShouldSave
103804>>>
103804>>>            Function_Return bShouldSave
103805>>>        End_Function
103806>>>
103806>>>        Function HasRecord Returns Boolean
103809>>>            tDataSourceRow[] TheData
103809>>>            tDataSourceRow[] TheData
103810>>>            Handle hoDataSource
103810>>>            Integer iSize
103810>>>
103810>>>            Get phoDataSource to hoDataSource
103811>>>            Get DataSource    of hoDataSource to TheData
103812>>>            Move (SizeOfArray(TheData)) to iSize
103813>>>
103813>>>            Function_Return (iSize > 0)
103814>>>        End_Function
103815>>>
103815>>>        Procedure ChangeHeaderText
103818>>>            Handle[] hoPanels
103819>>>            String sFileName
103819>>>
103819>>>            Send ChangeStatusRowText ""
103820>>>            Get IniFileName to sFileName
103821>>>            // Not sure why, but if the oStatusPane1 was set to "Set piID to sbpIDIdlePane",
103821>>>            // it wasn't always updated when this message was send. So instead change the
103821>>>            // text explicitly:
103821>>>            Get PaneObjects of (phoStatusBar(ghoCommandBars)) to hoPanels
103822>>>            Set psText of hoPanels[0] to sFileName
103823>>>        End_Procedure
103824>>>
103824>>>        Function InFileName Returns String
103827>>>            String sFileName sPath
103827>>>            Handle ho
103827>>>            Boolean bChangesExist
103827>>>
103827>>>            Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
103828>>>            Get psIniFilePath of ho to sPath
103829>>>            Get psIniFileName of ho to sFileName
103830>>>            Get Should_Save to bChangesExist
103831>>>            If (bChangesExist = True) Begin
103833>>>                Move (sFileName + "*") to sFileName
103834>>>            End
103834>>>>
103834>>>            Function_Return (sPath + sFileName)
103835>>>        End_Function
103836>>>
103836>>>        Procedure LoadData
103839>>>            Handle hoDataSource ho
103839>>>            tDataSourceRow[] TheData
103839>>>            tDataSourceRow[] TheData
103840>>>            tDataSourceRow TheRow
103840>>>            tDataSourceRow TheRow
103840>>>            Integer iCount iSize
103840>>>            tSQLConnection[] SQLConnectionsArray
103840>>>            tSQLConnection[] SQLConnectionsArray
103841>>>
103841>>>            Send ChangeHeaderText
103842>>>            Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
103843>>>
103843>>>            Get phoDataSource to hoDataSource
103844>>>            Send Reset of hoDataSource
103845>>>
103845>>>            Get ReadIniFile to SQLConnectionsArray
103846>>>            Move (SizeOfArray(SQLConnectionsArray)) to iSize
103847>>>            Decrement iSize
103848>>>
103848>>>            // Load data to the grid datasource array
103848>>>            For iCount from 0 to iSize
103854>>>>
103854>>>                Get MoveSQLConnectionToGridRow SQLConnectionsArray[iCount] to TheRow
103855>>>                Move TheRow to TheData[iCount]
103856>>>            Loop
103857>>>>
103857>>>
103857>>>            Set pTheData to TheData
103858>>>
103858>>>            // Initialize Grid with new data
103858>>>            Send InitializeData TheData
103859>>>
103859>>>            Set psFooterText of oConnectionString_Col to ("Number of connections:" * String(iSize +1))
103860>>>            Send MovetoFirstRow
103861>>>        End_Procedure
103862>>>
103862>>>        // Transfers data between a tSQLConnection struct and a grid data row.
103862>>>        Function MoveSQLConnectionToGridRow tSQLConnection SQLConnection Returns tDataSourceRow
103865>>>            tDataSourceRow TheRow
103865>>>            tDataSourceRow TheRow
103865>>>            Integer iDbType
103865>>>            String sValue
103865>>>
103865>>>            Move SQLConnection.bEnabled             to TheRow.sValue[piColumnId(oActive_Col(Self))]
103866>>>            Move SQLConnection.sConnectionID        to TheRow.sValue[piColumnId(oConnectionID_Col(Self))]
103867>>>            Move SQLConnection.sDriverID            to TheRow.sValue[piColumnId(oDriver_Col(Self))]
103868>>>
103868>>>            // We only show three asterisks ("***") instead of the password in the grid.
103868>>>            Move (Replace(("PWD=" + SQLConnection.sPassword), SQLConnection.sConnectionString, "PWD=***")) to sValue
103869>>>            Move sValue                             to TheRow.sValue[piColumnId(oConnectionString_Col(Self))]
103870>>>
103870>>>            Move SQLConnection.iDbType to iDbType
103871>>>            Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary iDbType to sValue
103872>>>            Move sValue                             to TheRow.sValue[piColumnId(oDbType_Col(Self))]
103873>>>            Move SQLConnection.sServer              to TheRow.sValue[piColumnId(oServer_Col(Self))]
103874>>>            Move SQLConnection.sDatabase            to TheRow.sValue[piColumnId(oDatabase_Col(Self))]
103875>>>
103875>>>            // Hidden columns (to make Should_Save function work)
103875>>>            Move SQLConnection.sConnectionString    to TheRow.sValue[piColumnId(oConnectionStringFull_Col(Self))] // "Untouched" connection string.
103876>>>            Move SQLConnection.bTrusted             to TheRow.sValue[piColumnId(oTrusted_Col(Self))]
103877>>>            Move SQLConnection.sUserID              to TheRow.sValue[piColumnId(oUserID_Col(Self))]
103878>>>            Move SQLConnection.sPassword            to TheRow.sValue[piColumnId(oPassword_Col(Self))]
103879>>>            Move SQLConnection.sSchema              to TheRow.sValue[piColumnId(oSchema_Col(Self))]
103880>>>            Move SQLConnection.sBaseTableSpace      to TheRow.sValue[piColumnId(oBaseTableSpace_Col(Self))]
103881>>>            Move SQLConnection.sLongTableSpace      to TheRow.sValue[piColumnId(oLongTableSpace_Col(Self))]
103882>>>            Move SQLConnection.sIndexTableSpace     to TheRow.sValue[piColumnId(oIndexTableSpace_Col(Self))]
103883>>>            Move SQLConnection.bSilentLogin         to TheRow.sValue[piColumnId(oSilentLogin_Col(Self))]
103884>>>//            Move SQLConnection.bDisabled            to TheRow.sValue[piColumnId(oDisabled_Col(Self))]
103884>>>
103884>>>            Function_Return TheRow
103885>>>        End_Function
103886>>>
103886>>>        // Transfers data between a grid data row and a tSQLConnection struct.
103886>>>        Function MoveGridRowToSQLConnection tDataSourceRow TheRow Returns tSQLConnection
103889>>>            tSQLConnection SQLConnection
103889>>>            tSQLConnection SQLConnection
103889>>>            Integer iDbType
103889>>>            String sValue
103889>>>
103889>>>            Move TheRow.sValue[piColumnId(oActive_Col(Self))]               to SQLConnection.bEnabled
103890>>>            Move TheRow.sValue[piColumnId(oConnectionID_Col(Self))]         to SQLConnection.sConnectionID
103891>>>
103891>>>            Move TheRow.sValue[piColumnId(oDbType_Col(Self))]               to sValue
103892>>>            Get SqlUtilDbTypeToInteger of ghoDbUpdateFunctionLibrary sValue to SQLConnection.iDbType
103893>>>            Move TheRow.sValue[piColumnId(oServer_Col(Self))]               to SQLConnection.sServer
103894>>>            Move TheRow.sValue[piColumnId(oDatabase_Col(Self))]             to SQLConnection.sDatabase
103895>>>            Move TheRow.sValue[piColumnId(oDriver_Col(Self))]               to SQLConnection.sDriverID
103896>>>
103896>>>            // Hidden columns (to make Should_Save function work)
103896>>>            Move TheRow.sValue[piColumnId(oConnectionStringFull_Col(Self))] to SQLConnection.sConnectionString
103897>>>            Move TheRow.sValue[piColumnId(oTrusted_Col(Self))]              to SQLConnection.bTrusted
103898>>>            Move TheRow.sValue[piColumnId(oUserID_Col(Self))]               to SQLConnection.sUserID
103899>>>            Move TheRow.sValue[piColumnId(oPassword_Col(Self))]             to SQLConnection.sPassword
103900>>>            Move TheRow.sValue[piColumnId(oSchema_Col(Self))]               to SQLConnection.sSchema
103901>>>            Move TheRow.sValue[piColumnId(oBaseTableSpace_Col(Self))]       to SQLConnection.sBaseTableSpace
103902>>>            Move TheRow.sValue[piColumnId(oLongTableSpace_Col(Self))]       to SQLConnection.sLongTableSpace
103903>>>            Move TheRow.sValue[piColumnId(oIndexTableSpace_Col(Self))]      to SQLConnection.sIndexTableSpace
103904>>>            Move TheRow.sValue[piColumnId(oSilentLogin_Col(Self))]          to SQLConnection.bSilentLogin
103905>>>//            Move TheRow.sValue[piColumnId(oDisabled_Col(Self))]             to SQLConnection.bDisabled
103905>>>
103905>>>            Function_Return SQLConnection
103906>>>        End_Function
103907>>>
103907>>>        // Called when the grid object is created:
103907>>>        Procedure Activating
103910>>>            Forward Send Activating
103912>>>            Send LoadData
103913>>>        End_Procedure
103914>>>
103914>>>        Function CurrentRow Returns Integer
103917>>>            Handle hoDataSource
103917>>>            Integer iRow
103917>>>
103917>>>            Get phoDataSource to hoDataSource
103918>>>            Get SelectedRow   of hoDataSource to iRow
103919>>>            Function_Return iRow
103920>>>        End_Function
103921>>>
103921>>>        Function CurrentRowData Returns tDataSourceRow
103924>>>            tDataSourceRow[] TheData
103924>>>            tDataSourceRow[] TheData
103925>>>            tDataSourceRow TheRow
103925>>>            tDataSourceRow TheRow
103925>>>            Handle ho hoDataSource
103925>>>            Integer iRow
103925>>>
103925>>>            Get phoDataSource  to hoDataSource
103926>>>            Get DataSource     of hoDataSource to TheData
103927>>>            Get SelectedRow    of hoDataSource to iRow
103928>>>            Move TheData[iRow] to TheRow
103929>>>
103929>>>            Function_Return TheRow
103930>>>        End_Function
103931>>>
103931>>>        Procedure OnRowChanged Integer iOldRow Integer iNewSelectedRow
103934>>>            Integer iRow
103934>>>            Handle hoDataSource
103934>>>            tDataSourceRow[] RowData
103934>>>            tDataSourceRow[] RowData
103935>>>
103935>>>            Forward Send OnRowChanged iOldRow iNewSelectedRow
103937>>>            Send ChangeHeaderText
103938>>>
103938>>>            Get phoDataSource to hoDataSource
103939>>>
103939>>>            Get SelectedRow of hoDataSource to iRow
103940>>>            If (iRow <> -1) Begin
103942>>>                Get DataSource of hoDataSource to RowData
103943>>>                Set pbEnabled to RowData[iRow].sValue[piColumnid(oActive_Col(Self))]
103944>>>                Set Enabled_State of oEdit_btn   to True
103945>>>                Set Enabled_State of oDelete_btn to True
103946>>>            End
103946>>>>
103946>>>        End_Procedure
103947>>>
103947>>>        Procedure OnComRowDblClick Variant llRow Variant llItem
103950>>>            Forward Send OnComRowDblClick llRow llItem
103952>>>            Send KeyAction of oEdit_btn
103953>>>        End_Procedure
103954>>>
103954>>>        Procedure OnEnterKey
103957>>>            Forward Send OnEnterKey
103959>>>            Send KeyAction of oEdit_btn
103960>>>        End_Procedure
103961>>>
103961>>>        Procedure AddConnection tDataSourceRow TheRow
103964>>>            Integer iSize iCount
103964>>>            Handle hoDataSource
103964>>>            tDataSourceRow[] TheData
103964>>>            tDataSourceRow[] TheData
103965>>>            Boolean bEnabled
103965>>>
103965>>>            Get phoDataSource to hoDataSource
103966>>>            Get DataSource    of hoDataSource to TheData
103967>>>
103967>>>            Move (SizeOfArray(TheData)) to iSize
103968>>>            Move (TheRow.sValue[piColumnid(oActive_Col(Self))]) to bEnabled
103969>>>            If (bEnabled = True) Begin
103971>>>                // Then bEnabled state have changed; deactivate all current rows.
103971>>>                For iCount from 0 to (iSize -1)
103977>>>>
103977>>>                    Move False to TheData[iCount].sValue[piColumnId(oActive_Col(Self))]
103978>>>                Loop
103979>>>>
103979>>>            End
103979>>>>
103979>>>
103979>>>            Move TheRow to TheData[iSize]
103980>>>
103980>>>            // Initialize Grid with new data
103980>>>            Send InitializeData TheData True
103981>>>            Move (SizeOfArray(TheData)) to iSize
103982>>>            Send MoveToLastRow
103983>>>
103983>>>            Set psFooterText of oConnectionString_Col to ("Number of connections:" * String(iSize))
103984>>>        End_Procedure
103985>>>
103985>>>        Procedure UpdateConnection tDataSourceRow TheRow
103988>>>            Integer iRow iSize iCount
103988>>>            Handle hoDataSource
103988>>>            tDataSourceRow[] TheData
103988>>>            tDataSourceRow[] TheData
103989>>>            String sValue
103989>>>            Boolean bEnabled
103989>>>
103989>>>            Get phoDataSource to hoDataSource
103990>>>            Get SelectedRow of hoDataSource to iRow
103991>>>            If (iRow <> -1) Begin
103993>>>                Get DataSource of hoDataSource to TheData
103994>>>
103994>>>                // If bEnabled state has changed; deactivate all rows.
103994>>>                Move (TheRow.sValue[piColumnId(oActive_Col(Self))]) to bEnabled
103995>>>                If (bEnabled = True) Begin
103997>>>                    Move (SizeOfArray(TheData)) to iSize
103998>>>                    Decrement iSize
103999>>>                    For iCount from 0 to iSize
104005>>>>
104005>>>                        Move False to TheData[iCount].sValue[piColumnId(oActive_Col(Self))]
104006>>>                    Loop
104007>>>>
104007>>>                End
104007>>>>
104007>>>
104007>>>                Move TheRow to TheData[iRow]
104008>>>            End
104008>>>>
104008>>>
104008>>>            // Initialize Grid with new data
104008>>>            Send ReInitializeData TheData True
104009>>>            Move (SizeOfArray(TheData)) to iSize
104010>>>            Set psFooterText of oConnectionString_Col to ("Number of connections:" * String(iSize))
104011>>>        End_Procedure
104012>>>
104012>>>        Procedure RemoveCurrentConnection
104015>>>            Integer iSize iRow iItem
104015>>>            Handle hoDataSource
104015>>>            tDataSourceRow[] TheData
104015>>>            tDataSourceRow[] TheData
104016>>>
104016>>>            Move 0 to iItem
104017>>>            Get phoDataSource to hoDataSource
104018>>>            Get DataSource of hoDataSource to TheData
104019>>>
104019>>>            Get SelectedRow of hoDataSource to iRow
104020>>>            If (iRow = -1) Begin
104022>>>                Procedure_Return
104023>>>            End
104023>>>>
104023>>>
104023>>>            Move False to Err
104024>>>            Send Request_Delete
104025>>>
104025>>>            Get DataSource of hoDataSource to TheData
104026>>>            Move (SizeOfArray(TheData)) to iSize
104027>>>            Set psFooterText of oConnectionString_Col to ("Number of connections:" * String(iSize))
104028>>>        End_Procedure
104029>>>
104029>>>        Function IsOneItemActive Returns Boolean
104032>>>            Handle hoDataSource ho
104032>>>            tDataSourceRow[] TheData
104032>>>            tDataSourceRow[] TheData
104033>>>            Integer iSize iCount
104033>>>            Boolean bRetval bExists
104033>>>            String sSection
104033>>>
104033>>>            Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
104034>>>            Get psIniSectionName of ho to sSection
104035>>>            Get SectionExists    of ho sSection to bExists
104036>>>
104036>>>            Get phoDataSource to hoDataSource
104037>>>            Get DataSource of hoDataSource to TheData
104038>>>
104038>>>            Move (SizeOfArray(TheData)) to iSize
104039>>>            If (iSize = 0) Begin
104041>>>                Function_Return True
104042>>>            End
104042>>>>
104042>>>
104042>>>            Decrement iSize
104043>>>            For iCount from 0 to iSize
104049>>>>
104049>>>                If (TheData[iCount].sValue[piColumnId(oActive_Col(Self))] = True) Begin
104051>>>                    Move True to bRetval
104052>>>                End
104052>>>>
104052>>>            Loop
104053>>>>
104053>>>
104053>>>            Function_Return bRetval
104054>>>        End_Function
104055>>>
104055>>>        Function ReadIniFile Returns tSQLConnection[]
104058>>>            tSQLConnection[] SQLConnectionsArray
104058>>>            tSQLConnection[] SQLConnectionsArray
104059>>>            Handle ho
104059>>>
104059>>>            Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
104060>>>            Get SQLIniFileReadConnections of ho to SQLConnectionsArray
104061>>>
104061>>>            Function_Return SQLConnectionsArray
104062>>>        End_Function
104063>>>
104063>>>        Procedure WriteIniFile
104066>>>            Integer iCount iSize
104066>>>            Handle hoDataSource ho
104066>>>            tDataSourceRow[] TheData
104066>>>            tDataSourceRow[] TheData
104067>>>            tDataSourceRow TheRow
104067>>>            tDataSourceRow TheRow
104067>>>            tSQLConnection[] SQLConnectionArray
104067>>>            tSQLConnection[] SQLConnectionArray
104068>>>            tSQLConnection SQLConnection
104068>>>            tSQLConnection SQLConnection
104068>>>            Boolean bIsOneActive bOK
104068>>>
104068>>>            Get IsOneItemActive to bIsOneActive
104069>>>            If (bIsOneActive = False) Begin
104071>>>                Send Info_Box "Sorry, you need to set one connection as active before changes can be saved."
104072>>>                Procedure_Return
104073>>>            End
104073>>>>
104073>>>
104073>>>            Move 0 to iCount
104074>>>            Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
104075>>>            Get phoDataSource to hoDataSource
104076>>>            Get DataSource of hoDataSource to TheData
104077>>>            Move (SizeOfArray(TheData)) to iSize
104078>>>            Decrement iSize
104079>>>
104079>>>            // Load data from the grid datasource array to SQLConnection array
104079>>>            For iCount from 0 to iSize
104085>>>>
104085>>>                Move TheData[iCount] to TheRow
104086>>>                Get MoveGridRowToSQLConnection TheRow to SQLConnection
104087>>>                Move SQLConnection to SQLConnectionArray[iCount]
104088>>>            Loop
104089>>>>
104089>>>
104089>>>            Get SQLIniFileWriteConnections of ho SQLConnectionArray to bOK
104090>>>            If (bOK = False) Begin
104092>>>                Send ChangeStatusRowText "Sorry, an error occured while saving the file and changes were not saved."
104093>>>                Procedure_Return
104094>>>            End
104094>>>>
104094>>>
104094>>>            // Update the view property with the newly saved values. (Used to check if anything has changed)
104094>>>            Set pTheData to TheData
104095>>>            Send ChangeHeaderText
104096>>>            Send ChangeStatusRowText "Ready! File saved."
104097>>>        End_Procedure
104098>>>
104098>>>        Procedure OnHeaderClick Integer iCol
104101>>>            String sPath sFileName
104101>>>            Handle ho
104101>>>
104101>>>            Forward Send OnHeaderClick iCol
104103>>>
104103>>>            Get vSelect_File "SQLConnections ini-files (*.ini)|SQLConnections.ini|All Ini Files (*.ini)|*.ini|All Files (*.*)|*.*" "Select a connection ini-file" "" to sFileName
104104>>>            If (sFileName <> "") Begin
104106>>>                Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
104107>>>                Get ParseFolderName sFileName to sPath
104108>>>                Set psIniFilePath of ho to sPath
104109>>>                Get ParseFileName sFileName to sFileName
104110>>>                Set psIniFileName of ho to sFilename
104111>>>                Set pbDFConnId of ho to (sFileName <> CS_SQLIniFileName)
104112>>>                Send LoadData of oSQLConnections_grd
104113>>>            End
104113>>>>
104113>>>        End_Procedure
104114>>>
104114>>>        // These overrides the grid standar behaviour
104114>>>        On_Key kSave_Record Send KeyAction of oSave_btn
104115>>>        On_Key Key_F5       Send KeyAction of oRefresh_btn
104116>>>    End_Object
104117>>>
104117>>>    Object oAdd_btn is a cSQLConnectionButton
104119>>>        Set Size to 14 50
104120>>>        Set Location to 128 262
104121>>>        Set Label to "&Add..."
104122>>>        Set peAnchors to anBottomRight
104123>>>        Set MultiLineState to True
104124>>>        Set psToolTip to "Add a new connection. (Ctrl+A)"
104125>>>        Set psImage to "ActionNew.ico"
104126>>>
104126>>>        Procedure OnClick
104129>>>            Boolean bChanged bDFConnId
104129>>>            tSQLConnection SQLConnection
104129>>>            tSQLConnection SQLConnection
104129>>>            tDataSourceRow[] TheData
104129>>>            tDataSourceRow[] TheData
104130>>>            tDataSourceRow   TheRow
104130>>>            tDataSourceRow   TheRow
104130>>>            Handle hoDataSource
104130>>>
104130>>>            Send ChangeStatusRowText ""
104131>>>            Get IsDFConnId to bDFConnId
104132>>>
104132>>>            Get phoDataSource of oSQLConnections_grd to hoDataSource
104133>>>            Get DataSource of hoDataSource to TheData
104134>>>            Send Activate_SQLMaintainConnections_dg of (Client_Id(phoMainPanel(ghoApplication))) (pbNew(Self)) -1 (&SQLConnection) (&bChanged) bDFConnId TheData
104135>>>            If (bChanged = True) Begin
104137>>>                Get MoveSQLConnectionToGridRow of oSQLConnections_grd SQLConnection to TheRow
104138>>>                Send AddConnection of oSQLConnections_grd TheRow
104139>>>            End
104139>>>>
104139>>>        End_Procedure
104140>>>
104140>>>    End_Object
104141>>>
104141>>>    Object oEdit_btn is a cSQLConnectionButton
104143>>>        Set Size to 14 50
104144>>>        Set Location to 128 317
104145>>>        Set Label to "&Edit..."
104146>>>        Set peAnchors to anBottomRight
104147>>>        Set MultiLineState to True
104148>>>        Set psToolTip to "Edit the selected connection. (Ctrl+E)"
104149>>>
104149>>>        Procedure OnClick
104152>>>            Boolean bEnabled bChanged bDFConnId
104152>>>            tSQLConnection SQLConnection
104152>>>            tSQLConnection SQLConnection
104152>>>            tDataSourceRow TheRow
104152>>>            tDataSourceRow TheRow
104152>>>            tDataSourceRow[] TheData
104152>>>            tDataSourceRow[] TheData
104153>>>            Handle hoDataSource
104153>>>            Integer iCurrentRow
104153>>>
104153>>>            Get CurrentRowData of oSQLConnections_grd to TheRow
104154>>>            Get MoveGridRowToSQLConnection of oSQLConnections_grd TheRow to SQLConnection
104155>>>            Send ChangeStatusRowText ""
104156>>>            Get pbEnabled to bEnabled
104157>>>            Get IsDFConnId to bDFConnId
104158>>>
104158>>>            Get phoDataSource of oSQLConnections_grd to hoDataSource
104159>>>            Get DataSource of hoDataSource to TheData
104160>>>            Get CurrentRow of oSQLConnections_grd to iCurrentRow
104161>>>
104161>>>            Send Activate_SQLMaintainConnections_dg of (Client_Id(phoMainPanel(ghoApplication))) (pbNew(Self)) iCurrentRow (&SQLConnection) (&bChanged) bDFConnId TheData
104162>>>            If (bChanged = True) Begin
104164>>>                Get MoveSQLConnectionToGridRow of oSQLConnections_grd SQLConnection to TheRow
104165>>>                Send UpdateConnection of oSQLConnections_grd TheRow
104166>>>            End
104166>>>>
104166>>>        End_Procedure
104167>>>
104167>>>    End_Object
104168>>>
104168>>>    Object oDelete_btn is a cSQLConnectionButton
104170>>>        Set Size to 14 50
104171>>>        Set Location to 128 371
104172>>>        Set Label to "&Delete"
104173>>>        Set peAnchors to anBottomRight
104174>>>        Set MultiLineState to True
104175>>>        Set psToolTip to "Remove the selected connection. (Ctrl+D) or (Del)"
104176>>>
104176>>>        Procedure OnClick
104179>>>            Send ChangeStatusRowText ""
104180>>>            Send RemoveCurrentConnection of oSQLConnections_grd
104181>>>        End_Procedure
104182>>>
104182>>>    End_Object
104183>>>
104183>>>    Object oSave_btn is a cSQLConnectionButton
104185>>>        Set Size to 14 50
104186>>>        Set Location to 128 425
104187>>>        Set Label to "&Save"
104188>>>        Set peAnchors to anBottomRight
104189>>>        Set MultiLineState to True
104190>>>        Set psToolTip to ("Save changes to the" * CS_SQLIniFileName * "file. Note: As long as you haven't saved - you are only making changes to the grid. (Ctrl+S) or (F2)")
104191>>>
104191>>>        Procedure OnClick
104194>>>            Send ChangeStatusRowText ""
104195>>>            Send WriteIniFile of oSQLConnections_grd
104196>>>        End_Procedure
104197>>>
104197>>>    End_Object
104198>>>
104198>>>    Object oAbout_btn is a cSQLConnectionButton
104200>>>        Set Location to 128 19
104201>>>        Set Label to "About..."
104202>>>        Set peAnchors to anBottomLeft
104203>>>        Set psToolTip to "Info about the program..."
104204>>>
104204>>>        Procedure OnClick
104207>>>            Send ChangeStatusRowText ""
104208>>>            Send Activate_About of (Client_Id(phoMainPanel(ghoApplication)))
104209>>>        End_Procedure
104210>>>
104210>>>    End_Object
104211>>>
104211>>>    Object oAddToStudio_btn is a cSQLConnectionButton
104213>>>        Set Size to 14 72
104214>>>        Set Location to 128 74
104215>>>        Set Label to "Add to Studio..."
104216>>>        Set peAnchors to anBottomLeft
104217>>>        Set psToolTip to "Dialog that adds this program to the Studio's 'Tools' menu."
104218>>>        Set psImage to "ActionAdd.ico"
104219>>>        Set piImageMarginLeft to 8
104220>>>
104220>>>        Procedure OnClick
104223>>>            Send ChangeStatusRowText ""
104224>>>            Send Popup of (oAddToStudio_dg(Client_Id(phoMainPanel(ghoApplication))))
104225>>>        End_Procedure
104226>>>
104226>>>    End_Object
104227>>>
104227>>>    Object oRefresh_btn is a cSQLConnectionButton
104229>>>        Set Location to 128 150
104230>>>        Set Label to "&Refresh"
104231>>>        Set peAnchors to anBottomLeft
104232>>>        Set psToolTip to ("Reloads the ini-file (Ctrl+R) or (F5)")
104233>>>
104233>>>        Procedure OnClick
104236>>>            Boolean bChanged
104236>>>            Handle ho
104236>>>            Integer iRetval
104236>>>
104236>>>            Move (oSQLConnections_grd(Self)) to ho
104237>>>            Get Should_Save of ho to bChanged
104238>>>            If (bChanged = True) Begin
104240>>>                Get YesNo_Box "Changes exists! If you press 'Yes' changes will be lost." to iRetval
104241>>>                If (iRetval <> MBR_Yes) Begin
104243>>>                    Procedure_Return
104244>>>                End
104244>>>>
104244>>>            End
104244>>>>
104244>>>            Send ChangeStatusRowText ""
104245>>>            Send LoadData of oSQLConnections_grd
104246>>>        End_Procedure
104247>>>
104247>>>    End_Object
104248>>>
104248>>>    Object oOpen_btn is a cSQLConnectionButton
104250>>>        Set Location to 128 204
104251>>>        Set Label to "&Open"
104252>>>        Set peAnchors to anBottomLeft
104253>>>        Set psToolTip to ("Opens an ini-file (Ctrl+O)")
104254>>>
104254>>>        Procedure OnClick
104257>>>            Send ChangeStatusRowText ""
104258>>>            Send OnHeaderClick of oSQLConnections_grd 1
104259>>>        End_Procedure
104260>>>
104260>>>    End_Object
104261>>>
104261>>>    Object oIdle is a cIdleHandler
104263>>>        Procedure OnIdle
104266>>>          Delegate Send OnIdle
104268>>>        End_Procedure
104269>>>    End_Object
104270>>>
104270>>>    Function IsDFConnId Returns Boolean
104273>>>        Boolean bDFConnId
104273>>>        Handle ho
104273>>>        String sFileName
104273>>>
104273>>>        Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
104274>>>        Get psIniFileName of ho to sFileName
104275>>>        Move (Uppercase(sFileName) = Uppercase(CS_SQLDF19IniFileName)) to bDFConnId
104276>>>        Set pbDFConnId of ho to bDFConnId
104277>>>
104277>>>        Function_Return bDFConnId
104278>>>    End_Function
104279>>>
104279>>>    Procedure OnFileDropped String sFilename Boolean bLast
104282>>>        Boolean bHasChange
104282>>>        Handle ho hoGrid
104282>>>        Integer iRetval
104282>>>        String sPath
104282>>>
104282>>>        Forward Send OnFileDropped sFilename bLast
104284>>>
104284>>>        If (bLast = True) Begin
104286>>>            Move (oSQLConnections_grd(Self)) to hoGrid
104287>>>            Get ParseFolderName sFilename to sPath
104288>>>            Get ParseFileName   sFilename to sFilename
104289>>>            If (Uppercase(sFilename) <> Uppercase(CS_SQLIniFileName) and Uppercase(sFilename) <> Uppercase(CS_SQLDF19IniFileName)) Begin
104291>>>                Send Info_Box ("Sorry, only" * CS_SQLIniFileName * "files can be dropped!")
104292>>>                Procedure_Return
104293>>>            End
104293>>>>
104293>>>            Get Should_Save of hoGrid to bHasChange
104294>>>            If (bHasChange = True) Begin
104296>>>                Get YesNo_Box "Changes exist! Do you still want to load the new file?" to iRetval
104297>>>                If (iRetval <> MBR_Yes) Begin
104299>>>                    Procedure_Return
104300>>>                End
104300>>>>
104300>>>            End
104300>>>>
104300>>>            Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
104301>>>            Set psIniFilePath of ho to sPath
104302>>>            Set psIniFileName of ho to sFilename
104303>>>            Send LoadData of oSQLConnections_grd
104304>>>        End
104304>>>>
104304>>>    End_Procedure
104305>>>
104305>>>    // This is only being called where no SQLConnections.ini file exists;
104305>>>    // thus a new active/enabled DFConnection ID needs to be established.
104305>>>    Procedure ConnectionDoesNotExist
104308>>>        tSQLConnection SQLConnection
104308>>>        tSQLConnection SQLConnection
104308>>>        Boolean bChanged bDFConnId bEnabled
104308>>>        Handle ho
104308>>>        tDataSourceRow TheRow
104308>>>        tDataSourceRow TheRow
104308>>>        Handle hoDataSource
104308>>>        tDataSourceRow[] TheData
104308>>>        tDataSourceRow[] TheData
104309>>>
104309>>>        Get IsDFConnId to bDFConnId
104310>>>
104310>>>        Move (oSQLMaintainConnections_dg(Self)) to ho
104311>>>        Move True to bEnabled
104312>>>        Set pbNew to True
104313>>>        Set pbNew of ho to True
104314>>>
104314>>>        Get phoDataSource of oSQLConnections_grd to hoDataSource
104315>>>        Get DataSource of hoDataSource to TheData
104316>>>
104316>>>        Send Activate_SQLMaintainConnections_dg of (Client_Id(phoMainPanel(ghoApplication))) (pbNew(Self)) -1 (&SQLConnection) (&bChanged) bDFConnId TheData
104317>>>        If (bChanged = True) Begin
104319>>>            // We also need to tell the main connection object that we now have
104319>>>            // created a connection.
104319>>>            Set pSQLConnection            of ghoSQLConnectionHandler to SQLConnection
104320>>>//            Set psConnectionID            of ghoSQLConnectionHandler to SQLConnection.sConnectionID
104320>>>//            Send UpdateConnectionString   of ghoSQLConnectionHandler SQLConnection
104320>>>//            Set psConnectionString        of ghoSQLConnectionHandler to SQLConnection.sConnectionString
104320>>>            // And add the data to the grid.
104320>>>            Get MoveSQLConnectionToGridRow of oSQLConnections_grd SQLConnection to TheRow
104321>>>            Send AddConnection of oSQLConnections_grd TheRow
104322>>>            // Not new anymore.
104322>>>            Set pbNew to False
104323>>>            Set pbNew of ho to False
104324>>>        End
104324>>>>
104324>>>    End_Procedure
104325>>>
104325>>>    Procedure ChangeStatusRowText String sText
104328>>>        Handle[] hoPanels
104329>>>        Get PaneObjects of (phoStatusBar(ghoCommandBars)) to hoPanels
104330>>>        Set psText of hoPanels[1] to sText
104331>>>    End_Procedure
104332>>>
104332>>>    Procedure ActivateOpenDialog
104335>>>        Send OnHeaderClick of oSQLConnections_grd 1
104336>>>    End_Procedure
104337>>>
104337>>>    Procedure Activating
104340>>>        Handle ho
104340>>>
104340>>>        Set Maximize_Icon to True
104341>>>        Set Minimize_Icon to False
104342>>>        Set Border_Style to Border_Thick
104343>>>        Set View_Mode to Viewmode_Zoom
104344>>>
104344>>>        // Note: The following line is essential for the resizing logic
104344>>>        // to work when starting the program.
104344>>>        Move (Client_Id(ghoCommandBars)) to ho
104345>>>        Set Border_Style of ho to Border_ClientEdge
104346>>>
104346>>>        Set pbEnabled of oIdle to True
104347>>>    End_Procedure
104348>>>
104348>>>    Procedure Deactivating
104351>>>        Set pbEnabled of oIdle to False
104352>>>        Forward Send Deactivating
104354>>>    End_Procedure
104355>>>
104355>>>    Procedure OnIdle
104358>>>        Boolean bChanged bRecord
104358>>>        Handle ho
104358>>>
104358>>>        Move (oSQLConnections_grd(Self)) to ho
104359>>>        Send ChangeHeaderText of ho
104360>>>        Get Should_Save   of ho to bChanged
104361>>>        Get HasRecord     of ho to bRecord
104362>>>        Set Enabled_State of oSave_btn   to bChanged
104363>>>        Set Enabled_State of oEdit_btn   to bRecord
104364>>>        Set Enabled_State of oDelete_btn to bRecord
104365>>>
104365>>>    End_Procedure
104366>>>
104366>>>    Function Verify_Exit_Application Returns Integer
104369>>>        Integer iRetval
104369>>>        Boolean bChanged
104369>>>
104369>>>        Get Should_Save of oSQLConnections_grd to bChanged
104370>>>        If (bChanged = False) Begin
104372>>>            Function_Return False
104373>>>        End
104373>>>>
104373>>>        Else Begin
104374>>>            Get YesNoCancel_Box "Changes exists. Save changes first?" to iRetval
104375>>>            If (iRetval = MBR_Cancel) Begin
104377>>>                Function_Return True
104378>>>            End
104378>>>>
104378>>>            If (iRetval = MBR_Yes) Begin
104380>>>                Send KeyAction of oSave_btn
104381>>>                Send Exit_Application
104382>>>            End
104382>>>>
104382>>>            If (iRetval = MBR_No) Begin
104384>>>                Function_Return False
104385>>>            End
104385>>>>
104385>>>        End
104385>>>>
104385>>>        Function_Return True
104386>>>    End_Function
104387>>>
104387>>>    On_Key kDelete_Character Send KeyAction of oDelete_btn
104388>>>    On_Key Key_F5            Send KeyAction of oRefresh_btn
104389>>>    On_Key Key_Ctrl+Key_E    Send KeyAction of oEdit_btn
104390>>>    On_Key Key_Ctrl+Key_A    Send KeyAction of oAdd_btn
104391>>>    On_Key Key_Ctrl+Key_D    Send KeyAction of oDelete_btn
104392>>>    On_Key Key_Ctrl+Key_R    Send KeyAction of oRefresh_btn
104393>>>    On_Key Key_F5            Send KeyAction of oRefresh_btn
104394>>>    On_Key kSave_Record      Send KeyAction of oSave_btn
104395>>>    On_Key Key_Ctrl+Key_S    Send KeyAction of oSave_btn
104396>>>    On_Key Key_F2            Send KeyAction of oSave_btn
104397>>>    On_Key Key_Ctrl+Key_O    Send ActivateOpenDialog
104398>>>    On_Key kCancel           Send None
104399>>>    On_Key Key_Ctrl+Key_F4   Send None
104400>>>End_Object
104401>        Use ManageSQLConnections.dg
104401>        Use AddToStudio.dg
104401>
104401>        Procedure Activate_About
104404>            Send DoAbout "" "" ("Copyright 2016-2018" * psCompany(ghoApplication)) "Author: Nils Svedmyr" "SQLConnections.bmp" "E-mail: mailto:support@rdctools.com" "Web-site: www.rdctools.com"
104405>        End_Procedure
104406>
104406>    End_Object
104407>
104407>    Procedure ShowProgramHelp
104410>        Send DoDisplayKeyword of ghoHtmlHelp "SQLConnections Tool"
104411>    End_Procedure
104412>
104412>    On_Key Key_F1 Send ShowProgramHelp
104413>End_Object
104414>
104414>// Check if a SQLConnections.ini file exists;
104414>// else the user needs to setup a Connection ID and login info & save the new connection file.
104414>Procedure CheckIfConnectionExists
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
104416>    Boolean bIniFileExists
104416>    Get pbIniFileExists of ghoApplication to bIniFileExists
104417>    If (bIniFileExists = False) Begin
104419>        Send ConnectionDoesNotExist of (oSQLMaintainConnection(Client_Id(phoMainPanel(ghoApplication))))
104420>    End
104420>End_Procedure
104421>Send CheckIfConnectionExists
104422>
104422>Start_UI
104423>
Including Resources...
Summary
Memory Available: 2147483646
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 55039
Total Resources: 4
Total Commands : 104422
Total Windows  : 1
Total Pages    : 1
Static Data    : 790289
Message area   : 649594
Total Blocks   : 37007
