Compiling Program: C:\Projects\DF18\DbUpdateFramework\AppSrc\DUFCreateDbVersionTable.src
Memory Available: 2147483646
1>Use DfAllEnt.pkg
Using pre-compiled package DFALLENT.PKG
Including file: dfallent.pkd    (C:\Program Files (x86)\DataFlex 19.0\Pkg\dfallent.pkd)
79228>Use cCJStandardCommandBarSystem.pkg
Including file: cCJStandardCommandBarSystem.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJStandardCommandBarSystem.pkg)
79228>>>// these are all the packages used in a standard MDI menubar/toolbar system
79228>>>
79228>>>Use cCJCommandBarSystem.pkg
79228>>>Use cCJStandardMenuItemClasses.pkg
Including file: cCJStandardMenuItemClasses.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJStandardMenuItemClasses.pkg)
79228>>>>>Use Dfpanel.pkg
79228>>>>>Use cCJCommandBarSystem.pkg
79228>>>>>Use LanguageText.pkg
79228>>>>>
79228>>>>>
79228>>>>>Class cCJUndoMenuItem is a cCJMenuItem
79229>>>>>    
79229>>>>>    Procedure Construct_Object
79231>>>>>        Forward Send Construct_Object
79233>>>>>        Set psCaption   to C_$CaptionUndo
79234>>>>>        Set psToolTip to C_$ToolTipUndo
79235>>>>>        Set psDescription to C_$DescUndo
79236>>>>>        Set psImage to "ActionUndo.ico"
79237>>>>>        Set pbActiveUpdate to True
79238>>>>>        Set psCategory to C_$CategoryEdit
79239>>>>>        Set psShortcut to C_$Key_Ctrl_Z
79240>>>>>    End_Procedure
79241>>>>>
79241>>>>>    Procedure OnExecute Variant vCommandBarControl
79243>>>>>        Send Undo of (focus(Self))
79244>>>>>    End_Procedure
79245>>>>>    
79245>>>>>    Function IsEnabled Returns Boolean
79247>>>>>        Boolean bEnabled
79247>>>>>        Get CanUndo of (Focus(Self)) to bEnabled
79248>>>>>        Function_Return bEnabled
79249>>>>>    End_Function
79250>>>>>         
79250>>>>>End_Class
79251>>>>>
79251>>>>>
79251>>>>>Class cCJDeleteEditMenuItem is a cCJMenuItem
79252>>>>>    
79252>>>>>    Procedure Construct_Object
79254>>>>>        Forward Send Construct_Object
79256>>>>>        Set psCaption   to C_$CaptionDelete
79257>>>>>        Set psToolTip to C_$ToolTipDelete
79258>>>>>        Set psDescription to C_$DescDelete
79259>>>>>        Set psImage to "actionDelete.ico"
79260>>>>>        Set psShortcut to C_$Key_Delete
79261>>>>>        Set pbActiveUpdate to True
79262>>>>>        Set psCategory to C_$CategoryEdit
79263>>>>>    End_Procedure
79264>>>>>
79264>>>>>
79264>>>>>    Procedure OnExecute Variant vCommandBarControl
79266>>>>>        Send Delete of (focus(Self))
79267>>>>>    End_Procedure
79268>>>>>    
79268>>>>>    Function IsEnabled Returns Boolean
79270>>>>>        Boolean bEnabled
79270>>>>>        Get CanDelete of (Focus(Self)) to bEnabled
79271>>>>>        Function_Return bEnabled
79272>>>>>    End_Function
79273>>>>>         
79273>>>>>End_Class
79274>>>>>
79274>>>>>
79274>>>>>Class cCJCutMenuItem is a cCJMenuItem
79275>>>>>    
79275>>>>>    Procedure Construct_Object
79277>>>>>        Forward Send Construct_Object
79279>>>>>        Set psCaption   to C_$CaptionCut
79280>>>>>        Set psToolTip to C_$TooltipCut
79281>>>>>        Set psDescription to C_$DescCut
79282>>>>>        Set psImage to "actionCut.ico"
79283>>>>>        Set psShortcut to C_$Key_Ctrl_X
79284>>>>>        Set pbActiveUpdate to True
79285>>>>>        Set psCategory to C_$CategoryEdit
79286>>>>>    End_Procedure
79287>>>>>
79287>>>>>
79287>>>>>    Procedure OnExecute Variant vCommandBarControl
79289>>>>>        Send Cut of (focus(Self))
79290>>>>>    End_Procedure
79291>>>>>    
79291>>>>>    Function IsEnabled Returns Boolean
79293>>>>>        Boolean bEnabled
79293>>>>>        Get CanCut of (Focus(Self)) to bEnabled
79294>>>>>        Function_Return bEnabled
79295>>>>>    End_Function
79296>>>>>         
79296>>>>>End_Class
79297>>>>>
79297>>>>>
79297>>>>>Class cCJCopyMenuItem is a cCJMenuItem
79298>>>>>    
79298>>>>>    Procedure Construct_Object
79300>>>>>        Forward Send Construct_Object
79302>>>>>        Set psCaption   to C_$CaptionCopy
79303>>>>>        Set psToolTip to C_$ToolTipCopy
79304>>>>>        Set psDescription to C_$DescCopy
79305>>>>>        Set psImage to "actionCopy.ico"
79306>>>>>        Set psShortcut to C_$Key_Ctrl_C
79307>>>>>        Set pbActiveUpdate to True
79308>>>>>        Set psCategory to C_$CategoryEdit
79309>>>>>    End_Procedure
79310>>>>>
79310>>>>>
79310>>>>>    Procedure OnExecute Variant vCommandBarControl
79312>>>>>        Send Copy of (focus(Self))
79313>>>>>    End_Procedure
79314>>>>>    
79314>>>>>    Function IsEnabled Returns Boolean
79316>>>>>        Boolean bEnabled
79316>>>>>        Get CanCopy of (Focus(Self)) to bEnabled
79317>>>>>        Function_Return bEnabled
79318>>>>>    End_Function
79319>>>>>         
79319>>>>>End_Class
79320>>>>>
79320>>>>>
79320>>>>>Class cCJPasteMenuItem is a cCJMenuItem
79321>>>>>    
79321>>>>>    Procedure Construct_Object
79323>>>>>        Forward Send Construct_Object
79325>>>>>        Set psCaption   to C_$CaptionPaste
79326>>>>>        Set psToolTip to C_$ToolTipPaste
79327>>>>>        Set psDescription to C_$DescPaste
79328>>>>>        Set psImage to "actionPaste.ico"
79329>>>>>        Set pbActiveUpdate to True
79330>>>>>        Set psShortcut to C_$Key_Ctrl_V
79331>>>>>        Set psCategory to C_$CategoryEdit
79332>>>>>    End_Procedure
79333>>>>>
79333>>>>>
79333>>>>>    Procedure OnExecute Variant vCommandBarControl
79335>>>>>        Send Paste of (focus(Self))
79336>>>>>    End_Procedure
79337>>>>>    
79337>>>>>    Function IsEnabled Returns Boolean
79339>>>>>        Boolean bEnabled
79339>>>>>        Get CanPaste of (Focus(Self)) to bEnabled
79340>>>>>        Function_Return bEnabled
79341>>>>>    End_Function
79342>>>>>         
79342>>>>>End_Class
79343>>>>>
79343>>>>>Class cCJSelectAllMenuItem is a cCJMenuItem
79344>>>>>    
79344>>>>>    Procedure Construct_Object
79346>>>>>        Forward Send Construct_Object
79348>>>>>        Set psCaption   to C_$CaptionSelectAll
79349>>>>>        Set psToolTip to C_$ToolTipSelectAll
79350>>>>>        Set psDescription to C_$DescSelectAll
79351>>>>>        Set pbActiveUpdate to True
79352>>>>>        Set psShortcut to C_$Key_Ctrl_A
79353>>>>>        Set psCategory to C_$CategoryEdit
79354>>>>>    End_Procedure
79355>>>>>
79355>>>>>
79355>>>>>    Procedure OnExecute Variant vCommandBarControl
79357>>>>>        Send Select_All of (focus(Self))
79358>>>>>    End_Procedure
79359>>>>>    
79359>>>>>    Function IsEnabled Returns Boolean
79361>>>>>        Boolean bEnabled
79361>>>>>        Get CanSelect of (Focus(Self)) to bEnabled
79362>>>>>        Function_Return bEnabled
79363>>>>>    End_Function
79364>>>>>         
79364>>>>>End_Class
79365>>>>>
79365>>>>> 
79365>>>>>Class cCJExitMenuItem is a cCJMenuItem
79366>>>>>
79366>>>>>    Procedure Construct_Object
79368>>>>>        Forward Send Construct_Object
79370>>>>>        Set psCaption to C_$CaptionExit
79371>>>>>        Set psToolTip to C_$ToolTipExit
79372>>>>>        Set psDescription to C_$ToolTipExit
79373>>>>>        Set psShortcut to C_$Key_Alt_F4
79374>>>>>        Set psCategory to C_$CategoryFile
79375>>>>>    End_Procedure
79376>>>>>
79376>>>>>    Procedure OnExecute Variant vCommandBarControl
79378>>>>>        Send Exit_Application of Desktop
79379>>>>>    End_Procedure
79380>>>>>
79380>>>>>End_Class           
79381>>>>>
79381>>>>>Class cCJHelpMenuItem is a cCJMenuItem    
79382>>>>>
79382>>>>>    Procedure Construct_Object
79384>>>>>        Forward Send Construct_Object
79386>>>>>        Set psCaption to C_$CaptionHelp
79387>>>>>        Set psDescription to C_$ToolTipHelp
79388>>>>>        Set psToolTip to C_$DescHelp
79389>>>>>        Set psImage to "ActionHelp.ico"
79390>>>>>        Set psShortcut to "F1"
79391>>>>>        Set psCategory to C_$CategoryHelp
79392>>>>>    End_Procedure
79393>>>>>    
79393>>>>>    Procedure OnExecute Variant vCommandBarControl
79395>>>>>        Send Help of (Focus(Self))
79396>>>>>    End_Procedure
79397>>>>>
79397>>>>>End_Class
79398>>>>>
79398>>>>>Class cCJStatusbarMenuItem is a cCJMenuItem
79399>>>>>
79399>>>>>    Procedure Construct_Object
79401>>>>>        Forward Send Construct_Object
79403>>>>>        Set psCaption to C_$CaptionAddStatusbar
79404>>>>>        Set psToolTip to C_$ToolTipAddStatusbar
79405>>>>>        Set psDescription to  C_$DescAddStatusbar
79406>>>>>        Set psCategory to C_$CategoryWindow
79407>>>>>    End_Procedure
79408>>>>>
79408>>>>>    Procedure OnExecute Variant vCommandBarControl
79410>>>>>        Handle hoCommandBars hoClientArea
79410>>>>>        Get CommandBarSystemObject to hoCommandBars
79411>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79412>>>>>        If hoClientArea Begin
79414>>>>>            // the clientarea's parent panel has message
79414>>>>>            Send Toggle_StatusBar of (Parent(hoClientArea))
79415>>>>>        End
79415>>>>>>
79415>>>>>    End_Procedure
79416>>>>>
79416>>>>>     Function IsChecked Returns Boolean
79418>>>>>        Boolean bOn
79418>>>>>        Handle hoCommandBars hoClientArea
79418>>>>>        Get CommandBarSystemObject to hoCommandBars
79419>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79420>>>>>        If hoClientArea Begin
79422>>>>>            // the clientarea's parent panel has message
79422>>>>>            Get StatusBar_State of (Parent(hoClientArea)) to bOn
79423>>>>>        End
79423>>>>>>
79423>>>>>        Function_Return bOn
79424>>>>>     End_Function
79425>>>>>End_Class
79426>>>>>
79426>>>>>Class cCJAutoArrangeIconsMenuItem is a cCJMenuItem
79427>>>>>
79427>>>>>    Procedure Construct_Object
79429>>>>>        Forward Send Construct_Object
79431>>>>>        Set psCaption to C_$CaptionAutoArrangeIcons
79432>>>>>        Set psToolTip to C_$ToolTipAutoArrangeIcons
79433>>>>>        Set psDescription to C_$DescAutoArrangeIcons
79434>>>>>        Set psCategory to C_$CategoryWindow
79435>>>>>    End_Procedure
79436>>>>>
79436>>>>>    Procedure OnExecute Variant vCommandBarControl
79438>>>>>        Handle hoCommandBars hoClientArea
79438>>>>>        Get CommandBarSystemObject to hoCommandBars
79439>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79440>>>>>        If hoClientArea Begin
79442>>>>>            // the clientarea's parent panel has message
79442>>>>>            Send Toggle_Auto_Arrange_Icons of (Parent(hoClientArea))
79443>>>>>        End
79443>>>>>>
79443>>>>>    End_Procedure
79444>>>>>    
79444>>>>>     Function IsChecked Returns Boolean
79446>>>>>        Boolean bOn
79446>>>>>        Handle hoCommandBars hoClientArea
79446>>>>>        Get CommandBarSystemObject to hoCommandBars
79447>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79448>>>>>        If hoClientArea Begin
79450>>>>>            // the clientarea's parent panel has message
79450>>>>>            Get Auto_Arrange_Icons_State of (Parent(hoClientArea)) to bOn
79451>>>>>        End
79451>>>>>>
79451>>>>>        Function_Return bOn
79452>>>>>     End_Function
79453>>>>>End_Class
79454>>>>>
79454>>>>>Class cCJRestoreMenusMenuItem is a cCJMenuItem
79455>>>>>
79455>>>>>    Procedure Construct_Object
79457>>>>>        Forward Send Construct_Object
79459>>>>>        Set psCaption to C_$CaptionRestoreMenus
79460>>>>>        Set psToolTip to C_$ToolTipRestoreMenus
79461>>>>>        Set psDescription to C_$DescRestoreMenus
79462>>>>>        Set psCategory to C_$CategoryWindow
79463>>>>>    End_Procedure
79464>>>>>
79464>>>>>    Procedure OnExecute Variant vCommandBarControl
79466>>>>>        Handle hoCommandBars
79466>>>>>        Get CommandBarSystemObject to hoCommandBars
79467>>>>>        Send RestoreLayout of hoCommandBars
79468>>>>>    End_Procedure
79469>>>>>    
79469>>>>>End_Class
79470>>>>>
79470>>>>>Class cCJCascadeMenuItem is a cCJMenuItem
79471>>>>>
79471>>>>>    Procedure Construct_Object
79473>>>>>        Forward Send Construct_Object
79475>>>>>        Set psCaption to C_$CaptionCascade
79476>>>>>        Set psToolTip to C_$ToolTipCascade
79477>>>>>        Set psDescription to  C_$DescCascade
79478>>>>>        Set psImage to "ActionCascade.ico"
79479>>>>>        Set psCategory to C_$CategoryWindow
79480>>>>>    End_Procedure
79481>>>>>    
79481>>>>>    Procedure OnExecute Variant vCommandBarControl
79483>>>>>        Handle hoCommandBars hoClientArea
79483>>>>>        Get CommandBarSystemObject to hoCommandBars
79484>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79485>>>>>        If hoClientArea Begin
79487>>>>>            Send Cascade_Windows of hoClientArea
79488>>>>>        End
79488>>>>>>
79488>>>>>    End_Procedure
79489>>>>>End_Class
79490>>>>>
79490>>>>>Class cCJTileHorizontally is a cCJMenuItem
79491>>>>>
79491>>>>>    Procedure Construct_Object
79493>>>>>        Forward Send Construct_Object
79495>>>>>        Set psCaption to C_$CaptionTileHorizontally 
79496>>>>>        Set psToolTip to C_$ToolTipTileHorizontally  
79497>>>>>        Set psDescription to  C_$DescTileHorizontally
79498>>>>>        Set psImage to "ActionTileHorizontally.ico"
79499>>>>>        Set psCategory to C_$CategoryWindow
79500>>>>>    End_Procedure
79501>>>>>
79501>>>>>    Procedure OnExecute Variant vCommandBarControl
79503>>>>>        Handle hoCommandBars hoClientArea
79503>>>>>        Get CommandBarSystemObject to hoCommandBars
79504>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79505>>>>>        If hoClientArea Begin
79507>>>>>            Send Tile_Windows_Horizontal of hoClientArea
79508>>>>>        End
79508>>>>>>
79508>>>>>    End_Procedure
79509>>>>>End_Class
79510>>>>>
79510>>>>>Class cCJTileVertically is a cCJMenuItem
79511>>>>>
79511>>>>>    Procedure Construct_Object
79513>>>>>        Forward Send Construct_Object
79515>>>>>        Set psCaption to C_$CaptionTileVertically  
79516>>>>>        Set psToolTip to C_$ToolTipTileVertically
79517>>>>>        Set psDescription to  C_$DescTileVertically
79518>>>>>        Set psImage to "ActionTileVertically.ico"
79519>>>>>        Set psCategory to C_$CategoryWindow
79520>>>>>    End_Procedure
79521>>>>>
79521>>>>>    Procedure OnExecute Variant vCommandBarControl
79523>>>>>        Handle hoCommandBars hoClientArea
79523>>>>>        Get CommandBarSystemObject to hoCommandBars
79524>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79525>>>>>        If hoClientArea Begin
79527>>>>>            Send Tile_Windows_Vertical of hoClientArea
79528>>>>>        End
79528>>>>>>
79528>>>>>    End_Procedure
79529>>>>>End_Class
79530>>>>>
79530>>>>>Class cCJMinimizeWindowsMenuItem is a cCJMenuItem
79531>>>>>
79531>>>>>    Procedure Construct_Object
79533>>>>>        Forward Send Construct_Object
79535>>>>>        Set psCaption to C_$CaptionMinimizeWindows 
79536>>>>>        Set psToolTip to C_$ToolTipMinimizeWindows
79537>>>>>        Set psDescription to  C_$DescMinimizeWindows
79538>>>>>        Set psCategory to C_$CategoryWindow
79539>>>>>    End_Procedure
79540>>>>>
79540>>>>>    Procedure OnExecute Variant vCommandBarControl
79542>>>>>        Handle hoCommandBars hoClientArea
79542>>>>>        Get CommandBarSystemObject to hoCommandBars
79543>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79544>>>>>        If hoClientArea Begin
79546>>>>>            // the clientarea's parent panel has message
79546>>>>>            Send Minimize_all_Windows of (Parent(hoClientArea))
79547>>>>>        End
79547>>>>>>
79547>>>>>    End_Procedure
79548>>>>>End_Class
79549>>>>>
79549>>>>>
79549>>>>>Class cCJRestoreWindowsMenuItem is a cCJMenuItem
79550>>>>>
79550>>>>>    Procedure Construct_Object
79552>>>>>        Forward Send Construct_Object
79554>>>>>        Set psCaption to C_$CaptionRestoreWindows
79555>>>>>        Set psToolTip to C_$ToolTipRestoreWindows
79556>>>>>        Set psDescription to  C_$DescRestoreWindows
79557>>>>>        Set psCategory to C_$CategoryWindow
79558>>>>>    End_Procedure
79559>>>>>
79559>>>>>    Procedure OnExecute Variant vCommandBarControl
79561>>>>>        Handle hoCommandBars hoClientArea
79561>>>>>        Get CommandBarSystemObject to hoCommandBars
79562>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79563>>>>>        If hoClientArea Begin
79565>>>>>            // the clientarea's parent panel has message
79565>>>>>            Send Restore_all_Windows of (Parent(hoClientArea))
79566>>>>>        End
79566>>>>>>
79566>>>>>    End_Procedure
79567>>>>>End_Class
79568>>>>>
79568>>>>>Class cCJArrangeIconsMenuItem is a cCJMenuItem
79569>>>>>
79569>>>>>    Procedure Construct_Object
79571>>>>>        Forward Send Construct_Object
79573>>>>>        Set psCaption to C_$CaptionArrangeIcons  
79574>>>>>        Set psToolTip to C_$ToolTipArrangeIcons
79575>>>>>        Set psDescription to  C_$DescArrangeIcons
79576>>>>>        Set psCategory to C_$CategoryWindow
79577>>>>>    End_Procedure
79578>>>>>
79578>>>>>    Procedure OnExecute Variant vCommandBarControl
79580>>>>>        Handle hoCommandBars hoClientArea
79580>>>>>        Get CommandBarSystemObject to hoCommandBars
79581>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79582>>>>>        If hoClientArea Begin
79584>>>>>            Send Arrange_Icons of hoClientArea
79585>>>>>        End
79585>>>>>>
79585>>>>>    End_Procedure
79586>>>>>
79586>>>>>End_Class
79587>>>>>    
79587>>>Use cCJAboutMenuItem.pkg
Including file: cCJAboutMenuItem.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJAboutMenuItem.pkg)
79587>>>>>Use cCJCommandBarSystem.pkg
79587>>>>>Use LanguageText.pkg
79587>>>>>
79587>>>>>// It is expected that if you use this class that you provide an about object that is
79587>>>>>// activated via activate_about such as DfAbout.pkg. We don't use this for you automatically
79587>>>>>// because you may wish to create your own custom about package.
79587>>>>>
79587>>>>>Class cCJAboutMenuItem is a cCJMenuItem    
79588>>>>>
79588>>>>>    Procedure Construct_Object
79590>>>>>        Forward Send Construct_Object
79592>>>>>        Set psCaption to C_$CaptionAbout
79593>>>>>        Set psDescription to C_$ToolTipAbout
79594>>>>>        Set psToolTip to C_$DescAbout
79595>>>>>        Set psImage to "ActionAbout.ico"
79596>>>>>        Set psCategory to C_$CategoryHelp
79597>>>>>    End_Procedure
79598>>>>>    
79598>>>>>    Procedure OnExecute Variant vCommandBarControl
79600>>>>>        Handle hoCommandBars hoClientArea
79600>>>>>        Get CommandBarSystemObject to hoCommandBars
79601>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79602>>>>>        If hoClientArea Begin
79604>>>>>            Send Activate_About of hoClientArea
79605>>>>>        End
79605>>>>>>
79605>>>>>    End_Procedure
79606>>>>>
79606>>>>>End_Class
79607>>>>>
79607>>>>>
79607>>>Use cCJDeoMenuItemClasses.pkg
79607>>>Use cCJMDIWindowsMenuItem.pkg
Including file: cCJMDIWindowsMenuItem.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJMDIWindowsMenuItem.pkg)
79607>>>>>Use cCJCommandBarSystem.pkg
79607>>>>>
79607>>>>>Register_Function Client_ID Returns Integer
79607>>>>>
79607>>>>>// only used by cCJMDIWIndowsMenuItem
79607>>>>>Class cCJMDIWindowItem is a cCJMenuItem
79608>>>>>
79608>>>>>    Procedure Construct_Object
79610>>>>>        Forward Send Construct_Object
79612>>>>>        Property Handle phWindow 0 // object id of view
79613>>>>>        Set pbControlFlagNoMovable to True
79614>>>>>        Set pbActiveUpdate to True
79615>>>>>    End_Procedure
79616>>>>>    
79616>>>>>    Procedure OnExecute Variant vCommandBarControl
79618>>>>>        Handle hWindow
79618>>>>>        Get phWindow to hWindow
79619>>>>>        Send Activate_View of hWindow
79620>>>>>    End_Procedure
79621>>>>>    
79621>>>>>End_Class                
79622>>>>>
79622>>>>>
79622>>>>>Class cCJMDIWindowsMenuItem is a cCJMenuItem
79623>>>>>    
79623>>>>>    Procedure Construct_Object
79625>>>>>        Forward Send Construct_Object
79627>>>>>        Property Handle[] phArrayOfWindows
79628>>>>>        Set peControlType to xtpControlPopup
79629>>>>>        Set psCategory to C_$CategoryWindow
79630>>>>>    End_Procedure
79631>>>>>    
79631>>>>>     // This adds MDI windows to the existing menu items.
79631>>>>>     // This removes any existing windows menus and always adds a new set to the end
79631>>>>>
79631>>>>>     Procedure OnPopupInit Variant vCommandBarControl Handle hCommandBarControls
79633>>>>>        Handle  hClientArea hView
79633>>>>>        String  sLabel
79633>>>>>        Integer i iWindows
79633>>>>>        Handle[] hArrayOfWindows
79634>>>>>        Variant vItem
79634>>>>>        
79634>>>>>        // delete all windows actions and menu items. Assume we have an array of DF action objects for the windows
79634>>>>>        // also assume that destroying an action removes all menu instances of that action
79634>>>>>        Get phArrayOfWindows to hArrayOfWindows
79635>>>>>        Move (SizeOfArray(hArrayOfWindows)) to iWindows
79636>>>>>        For i from 0 to (iWindows-1)
79642>>>>>>
79642>>>>>            Send Destroy of hArrayOfWindows[i] // assume this removes all menu items of this action
79643>>>>>        Loop
79644>>>>>>
79644>>>>>        Move (ResizeArray(hArrayOfWindows,0)) to hArrayOfWindows
79645>>>>>
79645>>>>>        // Add all views to this menu. Create the action and add the item
79645>>>>>        Move 0 to i
79646>>>>>        Get Client_Id to hClientArea // object id of client area
79647>>>>>        If (hClientArea > 0) Begin
79649>>>>>            Get Next_Mdi_Dialog of hClientArea True to hView // find first view
79650>>>>>            While (hView <> 0)
79654>>>>>                If (Active_State(hView)) Begin
79656>>>>>                    // create the action
79656>>>>>                    Get Create U_cCJMDIWindowItem to hArrayOfWindows[i]
79657>>>>>                    Get Label of hView to sLabel // caption bar (name) of view
79658>>>>>                    Set psCaption of hArrayOfWindows[i] to sLabel
79659>>>>>                    Set psDescription of hArrayOfWindows[i] to ("Make this view (" - trim(sLabel) - ") the active window.")
79660>>>>>                    If (current_scope(desktop)=hView and View_mode(hView)<>VIEWMODE_ICONIZE) Begin
79662>>>>>                        Set pbChecked of hArrayOfWindows[i] to True
79663>>>>>                    End
79663>>>>>>
79663>>>>>                    Set phWindow of hArrayOfWindows[i] to hView // used by custom OnExecute
79664>>>>>                    If (i=0) Begin
79666>>>>>                        Set pbControlBeginGroup of hArrayOfWindows[i] to True
79667>>>>>                    End
79667>>>>>>
79667>>>>>                    // Create a menu item for this action
79667>>>>>                    Get AddDynamicControl of hArrayOfWindows[i] hCommandBarControls to vItem
79668>>>>>                    Increment i
79669>>>>>                End
79669>>>>>>
79669>>>>>                Get Next_Mdi_Dialog of hClientArea False to hView // find next
79670>>>>>            Loop
79671>>>>>>
79671>>>>>        End
79671>>>>>>
79671>>>>>
79671>>>>>        Set phArrayOfWindows to hArrayOfWindows
79672>>>>>
79672>>>>>     End_Procedure
79673>>>>>     
79673>>>>>End_Class
79674>>>>>
79674>Use Dfspnfrm.pkg
79674>Use Dfcursor.pkg
79674>Use Dfline.pkg
79674>Use vWin32fh.pkg
Including file: vWin32fh.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\vWin32fh.pkg)
79674>>>// This code is part of VDF GUIdance
79674>>>// Visit us @ http://www.vdf-guidance.com
79674>>>// e-Mail us @ info@vdf-guidance.com
79674>>>// VDF GUIdance is a mutual project of
79674>>>// Frank Vandervelpen - Vandervelpen Systems and
79674>>>// Wil van Antwerpen  - Antwise Solutions
79674>>>// All software source code should be used <<AS IS>> without any warranty.
79674>>>//
79674>>>//
79674>>>// *** Windows 32bit file handling wrapper class ***
79674>>>//
79674>>>
79674>>>// 05-09-2000 **WvA: Changed namingconvention of all classes and methods to new standard
79674>>>//                   This may be painfull for some of you, but it was really needed as it was
79674>>>//                   getting messy. The "vs" -prefix we used before was confusing and could
79674>>>//                   unintentionally have been interpreted as "Vdf-GUIdance String".
79674>>>//
79674>>>// The used naming-convention is:
79674>>>//     - a prefix of "vWin32_" for every external function declaration
79674>>>//     - a prefix of the letter "v" for the full API name for the vdf-wrapper function.
79674>>>//
79674>>>// By using this we are guarding ourselves for conflicts with variable declarations
79674>>>// of DataAccess in the future.
79674>>>// Or at least almost as the letter "v" is now also synonym for variant (duh~!)
79674>>>//
79674>>>// mm-dd-yyyy Author Description
79674>>>//
79674>>>//                   vSHGetFolderPath added to retrieve the new shell folders
79674>>>//                   vGetWindowsDirectory
79674>>>//
79674>>>//                   vGetTempFileName
79674>>>//                   vGetTempPath
79674>>>// 11-17-2001 **WvA: Removed User Interface Error popups such as Error handling.
79674>>>//                   This is an absolute need for WebApp. We expect you to handle the
79674>>>//                   error in your application anyways. Changed this for:
79674>>>//                   vDeleteFile, vCopyFile, vMoveFile and vRenameFile
79674>>>// 03-02-2002 **WvA: vRemoveDirectory added
79674>>>// 03-11-2002 **WvA: The parameter lpdword in the external function declaration for
79674>>>//                   vWin32_SHBrowsForFolder can cause compiler errors.
79674>>>//                   It is renamed too avoid this.
79674>>>// 11-11-2002 **WvA: Codecleanup, vcSelectFile_Dialog is now cvSelectFile_Dialog, its
79674>>>//                   function vSelectedFileName is now just SelectedFileName
79674>>>//                   Removed the local keyword in the variable declarations
79674>>>// 10-17-2003 **WvA: Cleaned up function vSelect_File and added code to destroy the dynamically
79674>>>//                   created file-open dialog
79674>>>// 02-12-2004 **WvA: Allan Ankerstjeme pointed me into a bug for the vCreateTempFileInPath
79674>>>//                   in that it didn't exactly return the correct filename of the file created.
79674>>>//                   This has now been taken care of.
79674>>>// 02-19-2004 **WvA: Removed all API declarations from the package itself to improve readability
79674>>>//                   These declarations are now included from the vWin32fh header file.
79674>>>// 02-19-2004 **WvA: Changed the default way in which the standard file handling works
79674>>>//                   Before today one could always undo the operation, as of now you cannot as
79674>>>//                   the default was a silly one using unnecessary resources (mainly diskspace)
79674>>>//                   Since i don't really expect someone to use that feature it has been removed.
79674>>>//                   One can however restore to the old way of handling by simply calling the
79674>>>//                   vWin32fhCompatibilityMode procedure ONE time before accessing any of the
79674>>>//                   filehandling operations
79674>>>// 02-19-2004 **WvA: The functions ParseFolderName, ParseFileName and ParseFileExtenstion added
79674>>>//                   as well as the StringFromRightOfChar function.
79674>>>// 02-19-2004 **WvA: sfoFormatDisk function added which can use to format a floppydisk
79674>>>//                   DISABLED now as testing shows that it does not work as advertised...
79674>>>// 02-20-2004 **WvA: The function vDDE_Error_Handler didn't pass the errornumber on to the DDE_Error_To_String function
79674>>>//                   Moved the hardcoded strings from vDDE_Error_Handler to define declarations for easier translation later on.
79674>>>// 09-10-2004 **WvA: Added the ToAnsi function to the fileoperations method so that
79674>>>//                   extended characters are treated ok too.
79674>>>//                   Reported by Flemming from
79674>>>// 12-17-2004 **WvA: Changed vFilePathExists to be global, reported by Peter van Mil
79674>>>// 12-28-2004 **WvA: WebApp compatibility added by introducing compiler directives
79674>>>// 03-10-2006 **WvA: Added more CSIDL types to our header file for use with the vSHGetFolderPath function
79674>>>// 01-02-2007 **WvA: Set NoChangeDir_State on vSelect_File and vSelectSaveFile to True but changed it back due to side effects.
79674>>>//                   Added vSelectSavefile function to create a file save dialog
79674>>>//                   Fixed ParseFolderName which was horribly broken (thanks for the reports)
79674>>>//                   Added vParentPath function to retrieve the parent "node" of a path
79674>>>// 01-04-2008 **WvA: Fixed vCreateTempFileInPath as the function wasn't working
79674>>>// 10-04-2009 **WvA: Added vshCreateDirectoryEx from Micheal Mullan, moved filedialogs to cvFileDialogs.pkg
79674>>>// 01-11-2010 **WvA: Added vWin32_APIFilesize as supplied by Renato Villa, to get the filesize of the specified file. See http://support.dataaccess.com/forums/showthread.php?t=41982
79674>>>// 10-02-2011 **WvA: Added vCSIDL_SYSTEMX86, courtesy of Ola Eldoy for pointing this out and providing the define statement.
79674>>>// 20-12-2012 **WvA: Default behavior on copy/move is now to autocreate subfolders, tip by Frank Cheng
79674>>>// 29-09-2014 **WvA: Added function vFolderFileCount to count the number of files in a folder, add vCSIDL_PROGRAM_FILESx86
79674>>>// 04-10-2014 **WvA: Added extra checks on vFilePathExists and vFolderExists courtesy of Nils Svedmyr
79674>>>
79674>>>//Use Case.mac
79674>>>Use File_Dlg.pkg      // Contains OpenDialog class definition
79674>>>Use cvFileDialogs.pkg
Including file: cvFileDialogs.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cvFileDialogs.pkg)
79674>>>>>//***************************************************************************
79674>>>>>//*
79674>>>>>//* Class:        cvSaveAsDialog
79674>>>>>//* Package Name: cvFileDialogs.pkg
79674>>>>>//*
79674>>>>>//***************************************************************************
79674>>>>>
79674>>>>>Use File_dlg.pkg
79674>>>>>
79674>>>>>// *WvA: 13-01-1999 Created
79674>>>>>// The Class cSelectFile_Dialog is created to support the function Select_File
79674>>>>>// This function opens the Windows standard file open dialog and returns the selected
79674>>>>>// file_name.
79674>>>>>Class cvSelectFile_Dialog Is An OpenDialog
79675>>>>>
79675>>>>>  Procedure Construct_Object Integer iImage_Id
79677>>>>>    Forward Send Construct_Object iImage_Id
79679>>>>>    Set HideReadOnly_State To True
79680>>>>>  End_Procedure // Construct_Object
79681>>>>>
79681>>>>>  Function SelectedFileName Returns String
79683>>>>>    String sFileName
79683>>>>>    Move "" To sFileName
79684>>>>>    If (Show_Dialog(Self)) Begin
79686>>>>>      Move (RTrim(File_Name(Self))) To sFileName
79687>>>>>    End
79687>>>>>>
79687>>>>>    Function_Return sFileName
79688>>>>>  End_Function // SelectedFileName
79689>>>>>End_Class // cvSelectFile_Dialog
79690>>>>>
79690>>>>>
79690>>>>>// *WvA: 13-01-1999 Created
79690>>>>>// This function opens the Windows standard file open dialog and returns the selected
79690>>>>>// file_name. Returns '' if the user didn't make a selection.
79690>>>>>// **WvA: 17-10-2003 Cleaned up and added code to destroy the dynamically created
79690>>>>>//                   file-open dialog
79690>>>>>Function vSelect_File Global String sSupportedFileTypes String sCaptionText String sInitialFolder Returns String
79692>>>>>  String sSelectedFile
79692>>>>>  Integer hoOpenFileDialog
79692>>>>>
79692>>>>>  Object oOpenFileDialog Is A cvSelectFile_Dialog
79694>>>>>
79694>>>>>    Set Dialog_Caption    To sCaptionText
79695>>>>>    Set Filter_String     To sSupportedFileTypes
79696>>>>>    Set Initial_Folder    To sInitialFolder
79697>>>>>
79697>>>>>    Move Self       To hoOpenFileDialog
79698>>>>>  End_Object // oOpenFileDialog
79699>>>>>
79699>>>>>  Get SelectedFileName Of hoOpenFileDialog To sSelectedFile
79700>>>>>  Send Destroy_Object To hoOpenFileDialog
79701>>>>>  Function_Return sSelectedFile
79702>>>>>End_Function // vSelect_File
79703>>>>>
79703>>>>>
79703>>>>>Class cvSaveAsDialog is a SaveAsDialog
79704>>>>>
79704>>>>>  Procedure Construct_Object
79706>>>>>    Forward Send Construct_Object
79708>>>>>    Set HideReadOnly_State To True
79709>>>>>  End_Procedure // Construct_Object
79710>>>>>
79710>>>>>  Function SelectedFileName Returns String
79712>>>>>    String sFileName
79712>>>>>    Move "" To sFileName
79713>>>>>    If (Show_Dialog(Self)) Begin
79715>>>>>      Move (RTrim(File_Name(Self))) To sFileName
79716>>>>>    End
79716>>>>>>
79716>>>>>    Function_Return sFileName
79717>>>>>  End_Function // SelectedFileName
79718>>>>>
79718>>>>>End_Class // cvSaveAsDialog
79719>>>>>
79719>>>>>// Added optional default filename as suggested by Nils
79719>>>>>Function vSelectSaveFile Global String sSupportedFileTypes String sCaptionText String sInitialFolder String sDefaultFileName Returns String
79721>>>>>  String sSelectedFile
79721>>>>>  Integer hoDialog
79721>>>>>
79721>>>>>  Move "" To sSelectedFile
79722>>>>>  Get Create U_cvSaveAsDialog To hoDialog
79723>>>>>  If (hoDialog) Begin
79725>>>>>    //Set NoChangeDir_State Of hoDialog To True
79725>>>>>    Set Dialog_Caption    Of hoDialog To sCaptionText
79726>>>>>    Set Filter_String     Of hoDialog To sSupportedFileTypes
79727>>>>>    Set Initial_Folder    Of hoDialog To sInitialFolder
79728>>>>>    If (Num_Arguments = 4) Begin
79730>>>>>      Set File_Title        of hoDialog to sDefaultFileName
79731>>>>>    End
79731>>>>>>
79731>>>>>    Get SelectedFileName  Of hoDialog To sSelectedFile
79732>>>>>    Send Destroy Of hoDialog
79733>>>>>  End
79733>>>>>>
79733>>>>>  Function_Return sSelectedFile
79734>>>>>End_Function // vSelectSaveFile
79735>>>Use Seq_chnl.pkg
79735>>>
79735>>>Use Windows.pkg
79735>>>//Use Dferror
79735>>>Use Dll.pkg
79735>>>Use vWin32fh.h       // Header file with WinAPI declarations
Including file: vwin32fh.h    (C:\Projects\DF18\DbUpdateFramework\AppSrc\vwin32fh.h)
79735>>>>>//TH-Header
79735>>>>>//*****************************************************************************************
79735>>>>>// Copyright (c)  2004 KURANT Project
79735>>>>>// All rights reserved.
79735>>>>>//
79735>>>>>// $FileName    : G:\Projects\vWin32fh\vWin32fh.h
79735>>>>>// $ProjectName : Windows 32 bits file handling
79735>>>>>// $Authors     : Wil van Antwerpen
79735>>>>>// $Created     : 19.02.2004  19:25
79735>>>>>// $Type        : BSD (as in do with it whatever you like)
79735>>>>>//
79735>>>>>// Contents:
79735>>>>>//  This file contains the Windows API external function call definitions and
79735>>>>>//  constants as they are used in the vWin32fh package.
79735>>>>>//*****************************************************************************************
79735>>>>>//TH-RevisionStart
79735>>>>>//TH-RevisionEnd
79735>>>>>
79735>>>>>Define CS_DDE_ERR_FILE_NOT_FOUND  For "The specified file was not found.\n"
79735>>>>>Define CS_DDE_ERR_PATH_NOT_FOUND  For "The specified path was not found.\n"
79735>>>>>Define CS_DDE_ERR_BAD_FORMAT      For "The .EXE file is invalid.\n"
79735>>>>>Define CS_DDE_ERR_ACCESSDENIED    For "The operating system denied access to the specified file.\n"
79735>>>>>Define CS_DDE_ERR_ASSOCINCOMPLETE For "The filename association is incomplete or invalid.\n"
79735>>>>>Define CS_DDE_ERR_DDEBUSY         For "The DDE transaction could not be completed because other DDE\ntransactions were being processed.\n"
79735>>>>>Define CS_DDE_ERR_DDEFAIL         For "The DDE transaction failed.\n"
79735>>>>>Define CS_DDE_ERR_DDETIMEOUT      For "The DDE transaction could not be completed,\nbecause the request timed out.\n"
79735>>>>>Define CS_DDE_ERR_DLLNOTFOUND     For "The specified dynamic-link library was not found.\n"
79735>>>>>Define CS_DDE_ERR_NOASSOC         For "There is no application associated with the given filename extension.\n"
79735>>>>>Define CS_DDE_ERR_OOM             For "There is not enough free memory available to complete the operation.\n"
79735>>>>>Define CS_DDE_ERR_PNF             For "The specified path was not found.\n"
79735>>>>>Define CS_DDE_ERR_SHARE           For "A sharing violation occurred.\n"
79735>>>>>Define CS_DDE_ERR_UNKNOWN_LINE1   For "Unknown DDE-error occurred.\nErrornumber"
79735>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
79735>>>>>Define CS_DDE_ERR_HANDL_PAKTC     For "\nPress a key to continue...\n\n"
79735>>>>>Define CS_DDE_ERR_HANDL_CAPTION   For "a DDE-error occurred"
79735>>>>>
79735>>>>>
79735>>>>>Define vMax_Path     For |CI260
79735>>>>>Define vMinChar      For |CI$80
79735>>>>>Define vMaxChar      For |CI$7F
79735>>>>>Define vMinShort     For |CI$8000
79735>>>>>Define vMaxShort     For |CI$7FFF
79735>>>>>Define vMinLong      For |CI$80000000
79735>>>>>Define vMaxLong      For |CI$7FFFFFFF
79735>>>>>Define vMaxByte      For |CI$FF
79735>>>>>Define vMaxWord      For |CI$FFFF
79735>>>>>Define vMaxDword     For |CI$FFFFFFFF
79735>>>>>
79735>>>>>
79735>>>>>
79735>>>>>// For FindFirstFile
79735>>>>>Define vINVALID_HANDLE_VALUE   For |CI-1
79735>>>>>Define vINVALID_FILE_SIZE      For |CI$FFFFFFFF
79735>>>>>Define vERROR_NO_MORE_FILES    For |CI18
79735>>>>>
79735>>>>>// The defines below can be used to find out what kind of error has occurred if
79735>>>>>// the API-call ShellExecute is used.
79735>>>>>Define vERROR_FILE_NOT_FOUND   For |CI0002
79735>>>>>Define vERROR_PATH_NOT_FOUND   For |CI0003
79735>>>>>Define vERROR_BAD_FORMAT       For |CI0011
79735>>>>>Define vSE_ERR_ACCESSDENIED    For |CI0005
79735>>>>>Define vSE_ERR_ASSOCINCOMPLETE For |CI0027
79735>>>>>Define vSE_ERR_DDEBUSY         For |CI0030
79735>>>>>Define vSE_ERR_DDEFAIL         For |CI0029
79735>>>>>Define vSE_ERR_DDETIMEOUT      For |CI0028
79735>>>>>Define vSE_ERR_DLLNOTFOUND     For |CI0032
79735>>>>>Define vSE_ERR_FNF             For |CI0002
79735>>>>>Define vSE_ERR_NOASSOC         For |CI0031
79735>>>>>Define vSE_ERR_OOM             For |CI0008
79735>>>>>Define vSE_ERR_PNF             For |CI0003
79735>>>>>Define vSE_ERR_SHARE           For |CI0026
79735>>>>>
79735>>>>>
79735>>>>>// C-Structure
79735>>>>>//typedef struct _browseinfo {
79735>>>>>//    HWND hwndOwner;
79735>>>>>//    LPCITEMIDLIST pidlRoot;
79735>>>>>//    LPSTR pszDisplayName;
79735>>>>>//    LPCSTR lpszTitle;
79735>>>>>//    UINT ulFlags;
79735>>>>>//    BFFCALLBACK lpfn;
79735>>>>>//    LPARAM lParam;
79735>>>>>//    int iImage;
79735>>>>>//} BROWSEINFO, *PBROWSEINFO, *LPBROWSEINFO;
79735>>>>>
79735>>>>>//declare C structure struct_browseinfo
79735>>>>>//as documented in MSDN under Windows Shell API
79735>>>>>Type vtBrowseInfo
79735>>>>>  Field vtBrowseInfo.hWndOwner      as Handle
79735>>>>>  Field vtBrowseInfo.pIDLRoot       as Pointer
79735>>>>>  Field vtBrowseInfo.pszDisplayName as Pointer
79735>>>>>  Field vtBrowseInfo.lpszTitle      as Pointer
79735>>>>>  Field vtBrowseInfo.ulFlags        as dWord
79735>>>>>  Field vtBrowseInfo.lpfnCallback   as Pointer
79735>>>>>  Field vtBrowseInfo.lParam         as dWord
79735>>>>>  Field vtBrowseInfo.iImage         as dWord
79735>>>>>End_Type // tBrowseInfo
79735>>>>>
79735>>>>>// Browsing for directory.
79735>>>>>Define vBIF_RETURNONLYFSDIRS   For |CI$0001  // For finding a folder to start document searching
79735>>>>>Define vBIF_DONTGOBELOWDOMAIN  For |CI$0002  // For starting the Find Computer
79735>>>>>Define vBIF_STATUSTEXT         For |CI$0004  // Includes a status area in the dialog box.
79735>>>>>                                            // The callback function can set the status text by
79735>>>>>                                            // sending messages to the dialog box.
79735>>>>>Define vBIF_RETURNFSANCESTORS  For |CI$0008  // Only returns file system ancestors.
79735>>>>>
79735>>>>>Define vBIF_BROWSEFORCOMPUTER  For |CI$1000  // Browsing for Computers.
79735>>>>>Define vBIF_BROWSEFORPRINTER   For |CI$2000  // Browsing for Printers
79735>>>>>
79735>>>>>// message from browser
79735>>>>>//Define BFFM_INITIALIZED        1
79735>>>>>//Define BFFM_SELCHANGED         2
79735>>>>>
79735>>>>>// messages to browser
79735>>>>>//Define BFFM_SETSTATUSTEXT      (WM_USER + 100)
79735>>>>>//Define BFFM_ENABLEOK           (WM_USER + 101)
79735>>>>>//Define BFFM_SETSELECTION       (WM_USER + 102)
79735>>>>>
79735>>>>>
79735>>>>>External_function vWin32_SHBrowseForFolder "SHBrowseForFolder" shell32.dll ;  Pointer lpsBrowseInfo Returns dWord
79736>>>>>
79736>>>>>External_function vWin32_SHGetPathFromIDList "SHGetPathFromIDList" shell32.dll ;  Pointer pidList Pointer lpBuffer Returns dWord
79737>>>>>
79737>>>>>External_function vWin32_CoTaskMemFree "CoTaskMemFree" ole32.dll Pointer pV Returns Integer
79738>>>>>
79738>>>>>
79738>>>>>
79738>>>>>
79738>>>>>Type vtSecurity_attributes
79738>>>>>  Field vtSecurity_attributes.nLength        as dWord
79738>>>>>  Field vtSecurity_attributes.lpDescriptor   as Pointer
79738>>>>>  Field vtSecurity_attributes.bInheritHandle as Integer
79738>>>>>End_Type // vtSecurity_attributes
79738>>>>>
79738>>>>>//nLength:
79738>>>>>// Specifies the size, in bytes, of this structure. Set this value to the size of the
79738>>>>>// SECURITY_ATTRIBUTES structure.
79738>>>>>// Windows NT: Some functions that use the SECURITY_ATTRIBUTES structure do not verify the
79738>>>>>// value of the nLength member. However, an application should still set it properly.
79738>>>>>// That ensures current, future, and cross-platform compatibility.
79738>>>>>//
79738>>>>>//lpSecurityDescriptor:
79738>>>>>// Points to a security descriptor for the object that controls the sharing of it.
79738>>>>>// If NULL is specified for this member, the object may be assigned the default security
79738>>>>>// descriptor of the calling process.
79738>>>>>//
79738>>>>>//bInheritHandle:
79738>>>>>// Specifies whether the returned handle is inherited when a new process is created.
79738>>>>>// If this member is TRUE, the new process inherits the handle.
79738>>>>>
79738>>>>>
79738>>>>>// BOOL CreateDirectory(
79738>>>>>//    LPCTSTR lpPathName,
79738>>>>>//    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // pointer to a security descriptor
79738>>>>>//   );
79738>>>>>//
79738>>>>>// lpPathName
79738>>>>>//  Points to a null-terminated string that specifies the path of the directory
79738>>>>>//  to be created.
79738>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
79738>>>>>//  This limit is related to how the CreateDirectory function parses paths.
79738>>>>>// lpSecurityAttributes
79738>>>>>//  Pointer to a SECURITY_ATTRIBUTES structure als called a security descriptor that
79738>>>>>//  determines whether the returned handle can be inherited by child processes.
79738>>>>>//  If lpSecurityAttributes is NULL, the handle cannot be inherited.
79738>>>>>// Returns:
79738>>>>>//  If the function succeeds, the return value is nonzero.
79738>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
79738>>>>>External_function vWin32_CreateDirectory "CreateDirectoryA" kernel32.dll ;  Pointer lpPathName Pointer lpSecurity_Attributes Returns Integer
79739>>>>>
79739>>>>>
79739>>>>>// lpPathName
79739>>>>>//  Points to a null-terminated string that specifies the path of the directory
79739>>>>>//  to be removed.
79739>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
79739>>>>>// Returns:
79739>>>>>//  If the function succeeds, the return value is nonzero.
79739>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
79739>>>>>External_function vWin32_RemoveDirectory "RemoveDirectoryA" kernel32.dll ;  Pointer lpPathName Returns Integer
79740>>>>>
79740>>>>>
79740>>>>>
79740>>>>>// The ShellExecute function opens or prints a specified file. The file can be an
79740>>>>>// executable file or a document file.
79740>>>>>//
79740>>>>>// Operation can be one of the following:
79740>>>>>//    "OPEN"  The function opens the file specified by lpFile.
79740>>>>>//            The file can be an executable file or a document file.
79740>>>>>//            The file can be a folder to open.
79740>>>>>//    "PRINT" The function prints the file specified by lpFile.
79740>>>>>//            The file should be a document file. If the file is an executable file,
79740>>>>>//            the function opens the file, as if "open" had been specified.
79740>>>>>//  "EXPLORE" The function explores the folder specified by lpFile.
79740>>>>>//
79740>>>>>// Return Values:
79740>>>>>//
79740>>>>>// If the function succeeds, the return value is the instance handle of the application that
79740>>>>>// was run, or the handle of a dynamic data exchange (DDE) server application.
79740>>>>>// If the function fails, the return value is an error value that is less than or equal to 32.
79740>>>>>//
79740>>>>>// The following table lists these error values:
79740>>>>>// Public Const ERROR_FILE_NOT_FOUND = 2&
79740>>>>>// Public Const ERROR_PATH_NOT_FOUND = 3&
79740>>>>>// Public Const ERROR_BAD_FORMAT = 11&
79740>>>>>// Public Const SE_ERR_ACCESSDENIED = 5
79740>>>>>// Public Const SE_ERR_ASSOCINCOMPLETE = 27
79740>>>>>// Public Const SE_ERR_DDEBUSY = 30
79740>>>>>// Public Const SE_ERR_DDEFAIL = 29
79740>>>>>// Public Const SE_ERR_DDETIMEOUT = 28
79740>>>>>// Public Const SE_ERR_DLLNOTFOUND = 32
79740>>>>>// Public Const SE_ERR_FNF = 2
79740>>>>>// Public Const SE_ERR_NOASSOC = 31
79740>>>>>// Public Const SE_ERR_OOM = 8
79740>>>>>// Public Const SE_ERR_PNF = 3
79740>>>>>// Public Const SE_ERR_SHARE = 26
79740>>>>>
79740>>>>>
79740>>>>>
79740>>>>>// Code to open the program that is associated with the selected file.
79740>>>>>//
79740>>>>>// External function call used in Procedure DoStartDocument
79740>>>>>External_function vWin32_ShellExecute "ShellExecuteA" shell32.dll ;  Handle hWnd ;  Pointer lpOperation ;  Pointer lpFile ;  Pointer lpParameters ;  Pointer lpDirectory ;  Dword iShowCmd Returns Handle
79741>>>>>
79741>>>>>
79741>>>>>
79741>>>>>
79741>>>>>
79741>>>>>                                          // Must be freed using SHFreeNameMappings
79741>>>>>
79741>>>>>Type vtShFileOpStruct
79741>>>>>  Field vtShFileOpStruct.hWnd                   as Handle
79741>>>>>  Field vtShFileOpStruct.wFunc                  as Integer
79741>>>>>  Field vtShFileOpStruct.pFrom                  as Pointer
79741>>>>>  Field vtShFileOpStruct.pTo                    as Pointer
79741>>>>>  Field vtShFileOpStruct.fFlags                 as Short
79741>>>>>  Field vtShFileOpStruct.fAnyOperationsAborted  as Short
79741>>>>>  Field vtShFileOpStruct.hNameMappings          as Pointer
79741>>>>>  Field vtShFileOpStruct.lpszProgressTitle      as Pointer // only used if FOF_SIMPLEPROGRESS
79741>>>>>End_Type // tShFileOpStruct
79741>>>>>
79741>>>>>// hwnd
79741>>>>>//   Handle of the dialog box to use to display information about the status of the operation.
79741>>>>>
79741>>>>>// wFunc
79741>>>>>//   Operation to perform. This member can be one of the following values:
79741>>>>>//     FO_COPY     Copies the files specified by pFrom to the location specified by pTo.
79741>>>>>//     FO_DELETE   Deletes the files specified by pFrom (pTo is ignored).
79741>>>>>//     FO_MOVE     Moves the files specified by pFrom to the location specified by pTo.
79741>>>>>//     FO_RENAME   Renames the files specified by pFrom.
79741>>>>>
79741>>>>>// pFrom
79741>>>>>//   Pointer to a buffer that specifies one or more source file names. Multiple names must
79741>>>>>//   be null-separated. The list of names must be double null-terminated.
79741>>>>>
79741>>>>>// pTo
79741>>>>>//   Pointer to a buffer that contains the name of the destination file or directory. The
79741>>>>>//   buffer can contain mutiple destination file names if the fFlags member specifies
79741>>>>>//   FOF_MULTIDESTFILES. Multiple names must be null-separated. The list of names must be
79741>>>>>//   double null-terminated.
79741>>>>>
79741>>>>>// fAnyOperationsAborted
79741>>>>>//   Value that receives TRUE if the user aborted any file operations before they
79741>>>>>//   were completed or FALSE otherwise.
79741>>>>>
79741>>>>>
79741>>>>>// Performs a copy, move, rename, or delete operation on a file system object.
79741>>>>>// This can be a file or a folder.
79741>>>>>// With thanks to Andrew S Kaplan
79741>>>>>External_function vWin32_SHFileOperation "SHFileOperationA" Shell32.dll ;        Pointer lpFileOp Returns Integer
79742>>>>>
79742>>>>>
79742>>>>>// Thanks To Oliver Nelson for posting this code on the newsgroups
79742>>>>>External_function vWin32_GetWindowsDirectory "GetWindowsDirectoryA" kernel32.dll ;                           Pointer lpBuffer Integer nSize Returns Integer
79743>>>>>
79743>>>>>
79743>>>>>
79743>>>>>// Courtesy Of Vincent Oorsprong
79743>>>>>//External_Function vWin32_GetTempFileName "GetTempFileNameA" Kernel32.Dll ;
79743>>>>>//   Pointer lpPathName ;
79743>>>>>//   Pointer lpPrefixString ;
79743>>>>>//   Integer uUnique ;
79743>>>>>//   Pointer lpTempFileName ;
79743>>>>>//   Returns Integer
79743>>>>>// **WvA: 28-04-2005 Changed string parameter type into pointers
79743>>>>>External_function vWin32_GetTempFileName "GetTempFileNameA" kernel32.dll Pointer lpsPath ;        Pointer lpsPrefix Integer iUnique Pointer pLoad Returns Integer
79744>>>>>
79744>>>>>External_function vWin32_GetTempPath "GetTempPathA" Kernel32.Dll ;   Dword nBufferLength ;   Pointer lpBuffer ;   Returns Integer
79745>>>>>
79745>>>>>External_function vWin32_DeleteFile "DeleteFileA" Kernel32.Dll ;   Pointer lpFileName ;   Returns Integer
79746>>>>>                  
79746>>>>>// from:
79746>>>>>// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/shell/reference/enums/csidl.asp
79746>>>>>//
79746>>>>>Define vCSIDL_FLAG_CREATE       For |CI$8000 // IE5+, use this to create a special folder
79746>>>>>Define vCSIDL_ADMIN_TOOLS       For |CI$0030 // IE5+, The file system directory that is used to store administrative tools for an individual user
79746>>>>>Define vCSIDL_ALT_STARTUP       For |CI$001D // The file system directory that corresponds to the user's nonlocalized Startup program group
79746>>>>>Define vCSIDL_APPDATA           For |CI$001A // Version 4.71. The file system directory that serves as a common repository for application-specific data. A typical path is C:\Documents and Settings\<username>\Application Data
79746>>>>>Define vCSIDL_BITBUCKET         For |CI$000A // The virtual folder containing the objects in the user's Recycle Bin
79746>>>>>Define vCSIDL_CDBURN_AREA       For |CI$003B // IE6+ The file system directory acting as a staging area for files waiting to be written to CD. A typical path is C:\Documents and Settings\<username>\Local Settings\Application Data\Microsoft\CD Burning
79746>>>>>Define vCSIDL_COMMON_ADMINTOOLS For |CI$002F // IE5+ The file system directory containing administrative tools for all users of the computer
79746>>>>>Define vCSIDL_COMMON_ALTSTARTUP For |CI$001E // The file system directory that corresponds to the nonlocalized Startup program group for all users
79746>>>>>Define vCSIDL_COMMON_APPDATA    For |CI$0023 // IE5+ The file system directory containing application data for all users. A typical path is C:\Documents and Settings\All Users\Application Data
79746>>>>>Define vCSIDL_COMMON_DESKTOPDIRECTORY for |CI$0019 // WinNT+ Only, The file system directory that contains files and folders that appear on the desktop for all users. A typical path is C:\Documents and Settings\All Users\Desktop
79746>>>>>Define vCSIDL_COMMON_DOCUMENTS  For |CI$002E // IE5+ The file system directory that contains documents that are common to all users. A typical paths is C:\Documents and Settings\All Users\Documents
79746>>>>>Define vCSIDL_COMMON_FAVORITES  For |CI$001F // The file system directory that serves as a common repository for favorite items common to all users
79746>>>>>Define vCSIDL_COMMON_MUSIC      For |CI$0035 // IE6+ The file system directory that serves as a repository for music files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Music
79746>>>>>Define vCSIDL_COMMON_PICTURES   For |CI$0036 // The file system directory that serves as a repository for image files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Pictures
79746>>>>>Define vCSIDL_COMMON_PROGRAMS   For |CI$0017 // WinNT+ The file system directory that contains the directories for the common program groups that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs
79746>>>>>Define vCSIDL_COMMON_STARTMENU  For |CI$0016 // WinNT+ The file system directory that contains the programs and folders that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu
79746>>>>>Define vCSIDL_COMMON_STARTUP    For |CI$0018 // WinNT+ The file system directory that contains the programs that appear in the Startup folder for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs\Startup
79746>>>>>Define vCSIDL_COMMON_TEMPLATES  For |CI$002D // WinNT+ The file system directory that contains the templates that are available to all users. A typical path is C:\Documents and Settings\All Users\Templates
79746>>>>>Define vCSIDL_COMMON_VIDEO      For |CI$0037 // IE6+ The file system directory that serves as a repository for video files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Videos
79746>>>>>Define vCSIDL_COMPUTERSNEARME   For |CI$003D // The folder representing other machines in your workgroup
79746>>>>>Define vCSIDL_CONNECTIONS       For |CI$0031 // The virtual folder representing Network Connections, containing network and dial-up connections
79746>>>>>Define vCSIDL_CONTROLS          For |CI$0003 // The virtual folder containing icons for the Control Panel applications
79746>>>>>Define vCSIDL_COOKIES           For |CI$0021 // The file system directory that serves as a common repository for Internet cookies. A typical path is C:\Documents and Settings\username\Cookies
79746>>>>>Define vCSIDL_DESKTOP           For |CI$0000 // The virtual folder representing the Windows desktop, the root of the namespace
79746>>>>>Define vCSIDL_DESKTOPDIRECTORY  For |CI$0010 // The file system directory used to physically store file objects on the desktop (not to be confused with the desktop folder itself). A typical path is C:\Documents and Settings\username\Desktop
79746>>>>>Define vCSIDL_DRIVES            For |CI$0011 // The virtual folder representing My Computer, containing everything on the local computer: storage devices, printers, and Control Panel. The folder may also contain mapped network drives
79746>>>>>Define vCSIDL_FAVORITES         For |CI$0006 // The file system directory that serves as a common repository for the user's favorite items. A typical path is C:\Documents and Settings\username\Favorites
79746>>>>>Define vCSIDL_FONTS             For |CI$0014 // A virtual folder containing fonts. A typical path is C:\Windows\Fonts
79746>>>>>Define vCSIDL_HISTORY           For |CI$0022 // The file system directory that serves as a common repository for Internet history items
79746>>>>>Define vCSIDL_INTERNET          For |CI$0001 // A virtual folder representing the Internet
79746>>>>>Define vCSIDL_INTERNET_CACHE    For |CI$0020 // Comctl4.72+, The file system directory that serves as a common repository for temporary Internet files. A typical path is C:\Documents and Settings\username\Local Settings\Temporary Internet Files
79746>>>>>Define vCSIDL_LOCAL_APPDATA     For |CI$001C // IE5+ The file system directory that serves as a data repository for local (nonroaming) applications. A typical path is C:\Documents and Settings\username\Local Settings\Application Data
79746>>>>>Define vCSIDL_MYDOCUMENTS       For |CI$000C // IE6+ The virtual folder representing the My Documents desktop item
79746>>>>>Define vCSIDL_MYMUSIC           For |CI$000D // The file system directory that serves as a common repository for music files. A typical path is C:\Documents and Settings\User\My Documents\My Music
79746>>>>>Define vCSIDL_MYPICTURES        For |CI$0027 // IE5+ The file system directory that serves as a common repository for image files. A typical path is C:\Documents and Settings\username\My Documents\My Pictures
79746>>>>>Define vCSIDL_MYVIDEO           For |CI$000E // IE6+ The file system directory that serves as a common repository for video files. A typical path is C:\Documents and Settings\username\My Documents\My Videos
79746>>>>>Define vCSIDL_NETHOOD           For |CI$0013 // A file system directory containing the link objects that may exist in the My Network Places virtual folder. It is not the same as CSIDL_NETWORK, which represents the network namespace root. A typical path is C:\Documents and Settings\username\NetHood
79746>>>>>Define vCSIDL_NETWORK           For |CI$0012 // A virtual folder representing Network Neighborhood, the root of the network namespace hierarchy
79746>>>>>Define vCSIDL_PERSONAL          For |CI$0005 // (Documents folder) IE6 The virtual folder representing the My Documents desktop item.
79746>>>>>                                             // This is equivalent to CSIDL_MYDOCUMENTS. Previous to Version 6.0. The file system directory used to physically store a user's common repository of documents. A typical path is C:\Documents and Settings\username\My Documents
79746>>>>>Define vCSIDL_PHOTOALBUMS       For |CI$0045 // Vista+ The virtual folder used to store photo albums, typically username\My Pictures\Photo Albums
79746>>>>>Define vCSIDL_PLAYLISTS         For |CI$003F // Vista+ The virtual folder used to store play albums, typically username\My Music\Playlists
79746>>>>>Define vCSIDL_PRINTERS          For |CI$0004 // The virtual folder containing installed printers
79746>>>>>Define vCSIDL_PRINTHOOD         For |CI$001B // The file system directory that contains the link objects that can exist in the Printers virtual folder. A typical path is C:\Documents and Settings\username\PrintHood
79746>>>>>Define vCSIDL_PROFILE           For |CI$0028 // IE5+ The user's profile folder. A typical path is C:\Documents and Settings\username
79746>>>>>Define vCSIDL_PROGRAM_FILES     For |CI$0026 // IE5+ The Program Files folder. A typical path is C:\Program Files
79746>>>>>Define vCSIDL_PROGRAM_FILESx86  for |CI$002A // The Program Files folder for x86 programs. A typical path is C:\Program Files (x86)
79746>>>>>Define vCSIDL_PROGRAM_FILES_COMMON For |CI$002B // IE5+, WinNT+ A folder for components that are shared across applications. A typical path is C:\Program Files\Common
79746>>>>>Define vCSIDL_PROGRAMS          For |CI$0002 // The file system directory that contains the user's program groups (which are themselves file system directories). A typical path is C:\Documents and Settings\username\Start Menu\Programs
79746>>>>>Define vCSIDL_RECENT            For |CI$0008 // The file system directory that contains shortcuts to the user's most recently used documents. A typical path is C:\Documents and Settings\username\My Recent Documents
79746>>>>>Define vCSIDL_RESOURCES         For |CI$0038 // undocumented
79746>>>>>Define vCSIDL_SAMPLE_MUSIC      For |CI$0040 // Vista+, The file system directory that contains sample music. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Music
79746>>>>>Define vCSIDL_SAMPLE_PLAYLISTS  For |CI$0041 // Vista+, The file system directory that contains sample playlists. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Playlists
79746>>>>>Define vCSIDL_SAMPLE_PICTURES   For |CI$0042 // Vista+, The file system directory that contains sample pictures. A typical path is C:\Documents and Settings\username\My Documents\My Pictures\Sample Pictures
79746>>>>>Define vCSIDL_SAMPLE_VIDEOS     For |CI$0043 // Vista+, The file system directory that contains sample videos. A typical path is C:\Documents and Settings\username\My Documents\My Videos\Sample Videos
79746>>>>>Define vCSIDL_SENDTO            For |CI$0009 // The file system directory that contains Send To menu items. A typical path is C:\Documents and Settings\username\SendTo
79746>>>>>Define vCSIDL_STARTMENU         For |CI$000B // The file system directory containing Start menu items. A typical path is C:\Documents and Settings\username\Start Menu
79746>>>>>Define vCSIDL_STARTUP           For |CI$0007 // The file system directory that corresponds to the user's Startup program group. The system starts these programs whenever any user logs onto Windows NT or starts Windows 95. A typical path is C:\Documents and Settings\username\Start Menu\Programs\Startup
79746>>>>>Define vCSIDL_SYSTEM            For |CI$0025 // The Windows System folder. A typical path is C:\Windows\System32
79746>>>>>Define vCSIDL_SYSTEMX86         For |CI$0029 //
79746>>>>>Define vCSIDL_TEMPLATES         For |CI$0015 // The file system directory that serves as a common repository for document templates. A typical path is C:\Documents and Settings\username\Templates
79746>>>>>Define vCSIDL_WINDOWS           For |CI$0024 // The Windows directory or SYSROOT. This corresponds to the %windir% or %SYSTEMROOT% environment variables. A typical path is C:\Windows
79746>>>>>
79746>>>>>
79746>>>>>//HRESULT SHGetFolderPath(
79746>>>>>//    HWND hwndOwner,
79746>>>>>//    int nFolder,
79746>>>>>//    HANDLE hToken,
79746>>>>>//    DWORD dwFlags,
79746>>>>>//    LPTSTR pszPath
79746>>>>>//);
79746>>>>>// This function is a superset of SHGetSpecialFolderPath, included with earlier versions of
79746>>>>>// the shell. It is implemented in a redistributable DLL, SHFolder.dll, that also simulates
79746>>>>>// many of the new shell folders on older platforms such as Windows 95, Windows 98, and
79746>>>>>// Windows NT 4.0. This DLL always calls the current platform's version of this function.
79746>>>>>// If that fails, it will try to simulate the appropriate behavior.
79746>>>>>//
79746>>>>>External_function vWin32_SHGetFolderPath "SHGetFolderPathA" SHFolder.Dll ;   Pointer hWnd ;   Integer nFolder ;   Pointer hToken ;   DWord   dwFlags ;   Pointer lpszPath ;   Returns Integer
79747>>>>>
79747>>>>>
79747>>>>>
79747>>>>>Type vWin32_Find_Data
79747>>>>>  Field vWin32_Find_Data.dwFileAttributes As Dword
79747>>>>>  Field vWin32_Find_Data.ftCreationLowDateTime As Dword
79747>>>>>  Field vWin32_Find_Data.ftCreationHighDateTime As Dword
79747>>>>>  Field vWin32_Find_Data.ftLastAccessLowDateTime As dword
79747>>>>>  Field vWin32_Find_Data.ftLastAccessHighDateTime As Dword
79747>>>>>  Field vWin32_Find_Data.ftLastWriteLowDateTime As Dword
79747>>>>>  Field vWin32_Find_Data.ftLastWriteHighDateTime As Dword
79747>>>>>  Field vWin32_Find_Data.nFileSizeHigh As Dword
79747>>>>>  Field vWin32_Find_Data.nFileSizeLow As Dword
79747>>>>>  Field vWin32_Find_Data.dwReserved0 As Dword
79747>>>>>  Field vWin32_Find_Data.dwReserved1 As Dword
79747>>>>>  Field vWin32_Find_Data.cFileName As Char vMax_Path
79747>>>>>  Field vWin32_Find_Data.cAlternateFileName As Char 14
79747>>>>>End_Type // vWin32_Find_Data
79747>>>>>
79747>>>>>// Courtesy Of Vincent Oorsprong
79747>>>>>// lpFileName      : address of name of file to search for
79747>>>>>// lpFindFileData  : address of returned information
79747>>>>>External_function vWin32_FindFirstFile "FindFirstFileA"  Kernel32.dll Pointer lpFileName ;          Pointer lpFindFileData Returns Handle
79748>>>>>
79748>>>>>// Courtesy Of Vincent Oorsprong
79748>>>>>// hFindFile       : handle of search
79748>>>>>// lpFindFileData  : address of structure for data on found file
79748>>>>>External_function vWin32_FindNextFile "FindNextFileA" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
79749>>>>>
79749>>>>>// Courtesy Of Vincent Oorsprong
79749>>>>>//  hFindFile      : file search handle
79749>>>>>External_function vWin32_FindClose "FindClose" Kernel32.dll Handle hFindFile Returns Integer
79750>>>>>
79750>>>>>
79750>>>>>
79750>>>>>Type vFileTime
79750>>>>>  Field vFileTime.dwLowDateTime As Dword
79750>>>>>  Field vFileTime.dwHighDateTime As Dword
79750>>>>>End_Type // vFileTime
79750>>>>>
79750>>>>>
79750>>>>>Type vSystemTime
79750>>>>>  Field vSystemTime.wYear As Word
79750>>>>>  Field vSystemTime.wMonth As Word
79750>>>>>  Field vSystemTime.wDayOfWeek As Word
79750>>>>>  Field vSystemTime.wDay As Word
79750>>>>>  Field vSystemTime.wHour As Word
79750>>>>>  Field vSystemTime.wMinute As Word
79750>>>>>  Field vSystemTime.wSecond As Word
79750>>>>>  Field vSystemTime.wMilliSeconds As Word
79750>>>>>End_Type // vSystemTime
79750>>>>>
79750>>>>>
79750>>>>>// Courtesy Of Vincent Oorsprong
79750>>>>>//  lpFileTime     : pointer to file time to convert
79750>>>>>//  lpSystemTime   : pointer to structure to receive system time
79750>>>>>External_function vWin32_FileTimeToSystemTime "FileTimeToSystemTime" Kernel32.Dll ;          Pointer lpFileTime Pointer lpsystemTime Returns Integer
79751>>>>>
79751>>>>>// Courtesy Of Vincent Oorsprong
79751>>>>>// This function formats the time in a picture-string passed
79751>>>>>//
79751>>>>>// Picture      Meaning
79751>>>>>//    h         Hours with no leading zero for single-digit hours; 12-hour clock
79751>>>>>//    hh        Hours with leading zero for single-digit hours; 12-hour clock
79751>>>>>//    H         Hours with no leading zero for single-digit hours; 24-hour clock
79751>>>>>//    HH        Hours with leading zero for single-digit hours; 24-hour clock
79751>>>>>//    m         Minutes with no leading zero for single-digit minutes
79751>>>>>//    mm        Minutes with leading zero for single-digit minutes
79751>>>>>//    s         Seconds with no leading zero for single-digit seconds
79751>>>>>//    ss        Seconds with leading zero for single-digit seconds
79751>>>>>//    t         One character time marker string, such as A or P
79751>>>>>//    tt        Multicharacter time marker string, such as AM or PM
79751>>>>>//
79751>>>>>// For example, to get the time string  "11:29:40 PM"
79751>>>>>//    use the following picture string: "hh" : "mm" : "ss tt"
79751>>>>>
79751>>>>>External_function vWin32_GetTimeFormat "GetTimeFormatA" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpTimeStr ;  Integer cchTime Returns Integer
79752>>>>>
79752>>>>>
79752>>>>>// Courtesy Of Vincent Oorsprong
79752>>>>>// This function formats the date in a picture-string passed
79752>>>>>//
79752>>>>>// Picture      Meaning
79752>>>>>//    d         Day of month as digits with no leading zero for single-digit days.
79752>>>>>//    dd        Day of month as digits with leading zero for single-digit days.
79752>>>>>//    ddd       Day of week as a three-letter abbreviation. The function uses the
79752>>>>>//              LOCALE_SABBREVOAYMAME value associated with the specified locale.
79752>>>>>//    dddd      Day of week as its full name. The function uses the LOCALE_SDAYNAME
79752>>>>>//              value associated with the specified locale.
79752>>>>>//    M         Month as digits with no leading zero for single-digit months.
79752>>>>>//    MM        Month as digits with leading zero for single-digit months.
79752>>>>>//    MMM       Month as a three-letter abbreviation. The function uses the
79752>>>>>//              LOCALE_SABBREVMONTHNAME value associated with the specified locale.
79752>>>>>//    MMMM      Month as its full name. The function uses the LOCALE_SMONTHNAME value
79752>>>>>//              associated with the specified locale.
79752>>>>>//    y         Year as last two digits, but with no leading zero for years less than 10.
79752>>>>>//    yy        Year as last two digits, but with leading zero for years less than 10.
79752>>>>>//    yyyy      Year represented hy full four digits.
79752>>>>>//    gg        Period/era string. The function uses the CAL_SERASTRING value associated
79752>>>>>//              with the specified locale. This element is ignored if the date to be formatted
79752>>>>>//              does not have an associated era or period string.
79752>>>>>// For example, to get the date string  "Wed, Aug 31 94"
79752>>>>>// use the following picture string:    "ddd","MMM dd yy"
79752>>>>>
79752>>>>>External_function vWin32_GetDateFormat "GetDateFormatA" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpDateStr ;  Integer cchDate Returns Integer
79753>>>>>
79753>>>>>Define LOCALE_NOUSEROVERRIDE    For |CI$80000000  //  do not use user overrides
79753>>>>>Define TIME_NOMIHUTESORSECONDS  For |CI$0000000l  //  do not use minutes or seconds
79753>>>>>Define TIME_NOSECONDS           For |CI$00000002  //  do not use seconds
79753>>>>>Define TIME_NOTIMEMARKER        For |CI$00000004  //  do not use time marker
79753>>>>>Define TIME_FORCE24HOURFORMAT   For |CI$00000008  //  always use 24 hour format
79753>>>>>
79753>>>>>//  Date Flags for GetDateFormatW.
79753>>>>>//
79753>>>>>Define DATE_SHORTDATE           For |CI$0000000l  //  use short date picture
79753>>>>>Define DATE_LONGDATE            For |CI$00000002  //  use long date picture
79753>>>>>Define DATE_USE_ALT_CALENDAR    For |CI$00000004  //  use alternate calendar (if any)
79753>>>>>
79753>>>>>
79753>>>>>External_function vWin32_SetLastError "SetLastError" Kernel32.Dll Dword dwLastError Returns Integer
79754>>>>>
79754>>>>>
79754>>>>>// **WvA: 20-02-2004
79754>>>>>// While i was testing the format capabilities i stumbled over a very
79754>>>>>// weird problem where it looks like that the integer value gets somehow translated
79754>>>>>// incorrectly into an unsigned integer.
79754>>>>>// I don't have the time to dive into this.. so added a workaround (and removed it again)
79754>>>>>// It does smell a bit fishy though
79754>>>>>// Tested it with the same results on both VDF7 and VDF9.1
79754>>>>>
79754>>>>>Define SHFMT_ID_DEFAULT        For |CI$0000FFFF // The default format ID
79754>>>>>Define SHFMT_OPT_DEFAULT       For |CI$00000000 // The default "Quick Format" option.
79754>>>>>Define SHFMT_OPT_FULL          For |CI$00000001 // Deselects the "Quick Format" option, providing a full format instead. This is useful when an unformatted disk is detected.
79754>>>>>Define SHFMT_OPT_SYSONLY       For |CI$00000002 // Selects the "Create an MS-DOS startup disk" option, creating a system boot disk.
79754>>>>>
79754>>>>>// Possible errors that can be returned by the shellformat function
79754>>>>>Define SHFMT_ERROR             For (|CI$FFFFFFFF+1) // An error occurred during the last format or no drive parameter passed. This does not indicate that the disk is unformatable.
79754>>>>>Define SHFMT_CANCEL            For (|CI$FFFFFFFE+1) // The last format was canceled.
79754>>>>>Define SHFMT_NOFORMAT          For (|CI$FFFFFFFD+1) // The drive cannot be formatted.
79754>>>>>                                                
79754>>>>>
79754>>>>> // Courtesy Of Steve Walter,
79754>>>>> // USA Software, Inc
79754>>>>> // Format a disk
79754>>>>> // Called By:  Move (vWin32_ShFormatDrive(hWnd,0,$FFFF,1)) To dwReturn
79754>>>>>External_function vWin32_ShFormatDrive "SHFormatDrive" shell32.dll Handle hWnd ;         Integer iDrive Integer iFormatID Integer iOptions Returns DWORD
79755>>>>>
79755>>>>>// Michael Mullan.  I Wanted to create all the folders in one statement...
79755>>>>>
79755>>>>>// SHCreateDirectoryEx
79755>>>>>
79755>>>>>//    Note  This function is available through Microsoft Windows XP Service Pack 2 (SP2) and Windows Server 2003.
79755>>>>>//    It might be altered or unavailable in subsequent versions of Windows.
79755>>>>>//
79755>>>>>//    This function creates a file system folder whose fully qualified path is given by pszPath. If one or more
79755>>>>>//    of the intermediate folders do not exist, they are created as well. SHCreateDirectoryEx also verifies that
79755>>>>>//    the files are visible. If they are not visible, expect one of the following:
79755>>>>>//
79755>>>>>//        * If hwnd is set to a valid window handle, a message box is displayed warning the user that he or she
79755>>>>>//        might not be able to access the files. If the user chooses not to proceed, the function returns
79755>>>>>//        ERROR_CANCELLED.
79755>>>>>//        * If hwnd is set to NULL, no user interface is displayed and the function returns ERROR_CANCELLED.
79755>>>>>
79755>>>>>//        Returns ERROR_SUCCESS if successful. If the operation fails, other error codes can be returned,
79755>>>>>//        including those listed here. For values not specifically listed, see System Error Codes.
79755>>>>>//      161  ERROR_BAD_PATHNAME                The pszPath parameter was set to a relative path.
79755>>>>>//      206  ERROR_FILENAME_EXCED_RANGE     The path pointed to by pszPath is too long.
79755>>>>>//      3    ERROR_PATH_NOT_FOUND            The system cannot find the path pointed to by pszPath. The path may contain an invalid entry.
79755>>>>>//      80   ERROR_FILE_EXISTS                The directory exists.
79755>>>>>//      183  ERROR_ALREADY_EXISTS            The directory exists.
79755>>>>>//      1223 ERROR_CANCELLED                The user canceled the operation.
79755>>>>>
79755>>>>>//        int SHCreateDirectoryEx(
79755>>>>>//            HWND hwnd,
79755>>>>>//            LPCTSTR pszPath,
79755>>>>>//            const SECURITY_ATTRIBUTES *psa
79755>>>>>//        );
79755>>>>>
79755>>>>>External_function vWin32_SHCreateDirectoryEx "SHCreateDirectoryExA" shell32.dll Handle hWnd;                  pointer pszPath  Pointer lpSecurity_Attributes Returns Integer
79756>>>
79756>>>
79756>>>
79756>>>
79756>>>
79756>>>//
79756>>>// Gets the string from the right of the last sStopChar in sFrom
79756>>>// If sStopChar has no occurences in the string an empty string is
79756>>>// returned.
79756>>>Function StringFromRightOfChar Global String sFrom String sStopChar Returns String
79758>>>  String  sRetVal
79758>>>  String  sChar
79758>>>  Integer iLength
79758>>>  Integer iPos
79758>>>  Boolean bStopChar
79758>>>  Move "" To sRetval
79759>>>  Move (Length(sFrom)) To iLength
79760>>>  If ((iLength>0) And (Pos(sStopChar,sFrom) <> 0)) Begin
79762>>>    Move iLength   To iPos
79763>>>    Move (False)   To bStopChar
79764>>>    While Not bStopChar
79768>>>      Move (Mid(sFrom,1,iPos)) To sChar
79769>>>      Decrement iPos
79770>>>      If ((sChar=sStopChar) Or (iPos<1)) Begin
79772>>>        Move (True) To bStopChar
79773>>>      End
79773>>>>
79773>>>      Else Begin
79774>>>        Move (sChar+sRetVal) To sRetVal
79775>>>      End
79775>>>>
79775>>>    Loop
79776>>>>
79776>>>  End
79776>>>>
79776>>>  Function_Return sRetVal
79777>>>End_Function // StringFromRightOfChar
79778>>>
79778>>>
79778>>>// Pre:  sFileName contains the complete path of the file.
79778>>>// Post: returns the complete path of the file.
79778>>>// This function is inspired on function SEQ_ExtractPathFromFileName of Sture Andersen.
79778>>>Function ParseFolderName Global String sFileName Returns String
79780>>>  String sFile
79780>>>  String sFolderName
79780>>>  String sDirSep // this is "\" for windows, or "/" for unix
79780>>>  MOve "" To sFolderName
79781>>>  Move (sysconf(SYSCONF_DIR_SEPARATOR)) To sDirSep
79782>>>  If sDirSep In sFileName Begin
79784>>>    Move (StringFromRightOfChar(sFileName,sDirSep)) To sFile
79785>>>    Move (Replace(sFile,sFileName,"")) To sFolderName
79786>>>  End
79786>>>>
79786>>>  Else If ":" In sFileName Begin
79789>>>    Move (StringFromRightOfChar(sFileName,":")) To sFile
79790>>>    Move (Replace(sFile,sFileName,"")) To sFolderName
79791>>>  End
79791>>>>
79791>>>  Function_Return sFolderName
79792>>>End_Function // ParseFolderName
79793>>>
79793>>>
79793>>>// Pre:  sFileName contains the complete path of the file.
79793>>>// post: The returned filename has it's path removed, but will have a extension
79793>>>Function ParseFileName Global String sFileName Returns String
79795>>>  String sFolderName
79795>>>  String sDirSep // this is "\" for windows, or "/" for unix
79795>>>  Move (sysconf(SYSCONF_DIR_SEPARATOR)) To sDirSep
79796>>>  Get ParseFolderName sFileName To sFolderName
79797>>>  If (sFolderName <> "") Begin
79799>>>    Move (Replace(sFolderName,sFileName,"")) to sFileName
79800>>>  End
79800>>>>
79800>>>  Move (Replace(sDirSep,sFileName,"")) To sFileName
79801>>>  Function_Return sFilename
79802>>>End_Function // ParseFileName
79803>>>
79803>>>
79803>>>// Pre:  sFileName may contain the complete path of the file.
79803>>>//       or contain multiple dots in the filename, so temp.gif.bak will
79803>>>//       return "bak" as the extension and not "gif"
79803>>>// Post: returns the extension only, this extension can be a valid unixlike extension
79803>>>//       such as "html" or "java"
79803>>>Function ParseFileExtension Global String sFileName Returns String
79805>>>  String  sFileExtension
79805>>>  Get StringFromRightOfChar sFileName "." To sFileExtension
79806>>>  Function_Return sFileExtension
79807>>>End_Function // ParseFileExtension
79808>>>
79808>>>
79808>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
79808>>>
79808>>>
79808>>>Function DDE_Error_To_String Integer iErrorID Returns String
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
79810>>>  String sMessage
79810>>>  Case Begin
79810>>>    Case (iErrorID = vERROR_FILE_NOT_FOUND)
79812>>>      Move CS_DDE_ERR_FILE_NOT_FOUND To sMessage
79813>>>      Case Break
79814>>>    Case (iErrorID = vERROR_PATH_NOT_FOUND)
79817>>>      Move CS_DDE_ERR_PATH_NOT_FOUND To sMessage
79818>>>      Case Break
79819>>>    Case (iErrorID = vERROR_BAD_FORMAT)
79822>>>      Move CS_DDE_ERR_BAD_FORMAT To sMessage
79823>>>      Case Break
79824>>>    Case (iErrorID = vSE_ERR_ACCESSDENIED)
79827>>>      Move CS_DDE_ERR_ACCESSDENIED To sMessage
79828>>>      Case Break
79829>>>    Case (iErrorID = vSE_ERR_ASSOCINCOMPLETE)
79832>>>      Move CS_DDE_ERR_ASSOCINCOMPLETE To sMessage
79833>>>      Case Break
79834>>>    Case (iErrorID = vSE_ERR_DDEBUSY)
79837>>>      Move CS_DDE_ERR_DDEBUSY To sMessage
79838>>>      Case Break
79839>>>    Case (iErrorID = vSE_ERR_DDEFAIL)
79842>>>      Move CS_DDE_ERR_DDEFAIL To sMessage
79843>>>      Case Break
79844>>>    Case (iErrorID = vSE_ERR_DDETIMEOUT)
79847>>>      Move CS_DDE_ERR_DDETIMEOUT To sMessage
79848>>>      Case Break
79849>>>    Case (iErrorID = vSE_ERR_DLLNOTFOUND)
79852>>>      Move CS_DDE_ERR_DLLNOTFOUND To sMessage
79853>>>      Case Break
79854>>>    Case (iErrorID = vSE_ERR_NOASSOC)
79857>>>      Move CS_DDE_ERR_NOASSOC To sMessage
79858>>>      Case Break
79859>>>    Case ((iErrorID = vSE_ERR_OOM) Or (iErrorID = 0))
79862>>>      Move CS_DDE_ERR_OOM To sMessage
79863>>>      Case Break
79864>>>    Case (iErrorID = vSE_ERR_PNF)
79867>>>      Move CS_DDE_ERR_PNF To sMessage
79868>>>      Case Break
79869>>>    Case (iErrorID = vSE_ERR_SHARE)
79872>>>      Move CS_DDE_ERR_SHARE To sMessage
79873>>>      Case Break
79874>>>    Case Else
79874>>>      Move CS_DDE_ERR_UNKNOWN_LINE1 To sMessage
79875>>>      Move (sMessage*Trim(iErrorID)*CS_DDE_ERR_UNKNOWN_LINE2) To sMessage
79876>>>      Case Break
79877>>>  Case End
79877>>>  Function_Return sMessage
79878>>>End_Function // DDE_Error_To_String
79879>>>
79879>>>
79879>>>Procedure vDDE_Error_Handler Integer iErrorID
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
79881>>>  String sMessage
79881>>>  Get DDE_Error_To_String iErrorID To sMessage
79882>>>  Append sMessage CS_DDE_ERR_HANDL_PAKTC //  "Press a key to continue..."
79883>>>  Send Stop_Box sMessage CS_DDE_ERR_HANDL_CAPTION
79884>>>End_Procedure // vDDE_Error_Handler hInstance
79885>>>
79885>>>
79885>>>// Does the directory exist? - No = 0, Yes = 1
79885>>>// This also works with UNC path encoding and wildcards
79885>>>Function vFolderExists Global String sFolderName Returns Integer
79887>>>  String  sFolder sTmp
79887>>>  Integer bFolderExists iCh
79887>>>
79887>>>  // 2013-09-29 NGS Check for empty folder name and convert to ANSI
79887>>>  Move (ToANSI(Trim(sFolderName))) to sFolderName
79888>>>  If (sFolderName = "") Begin
79890>>>    Function_Return False
79891>>>  End
79891>>>>
79891>>>
79891>>>  Move dfTrue To bFolderExists
79892>>>  Move "dir:" To sFolder
79893>>>  Append sFolder sFolderName
79894>>>  Get Seq_New_Channel To iCh  // get free channel for input
79895>>>  Direct_Input Channel iCh sFolder
79897>>>    Repeat
79897>>>>
79897>>>      Readln Channel iCh sTmp
79899>>>      If (Trim(sTmp)="") Begin
79901>>>        Move False to bFolderExists
79902>>>      End
79902>>>>
79902>>>      Else Begin
79903>>>        Move True to bFolderExists
79904>>>        Move True to SeqEof // end loop
79905>>>        End
79905>>>>
79905>>>    Until (seqeof)
79907>>>  Close_Input Channel iCh
79909>>>  Send Seq_Release_Channel iCh
79910>>>  Function_Return bFolderExists
79911>>>End_Function  // vFolderExists
79912>>>
79912>>>
79912>>>// returns folder name if a folder was selected, otherwise returns ""
79912>>>Function vSHBrowseForFolder Global String sDialogTitle Returns String
79914>>>  String sFolder sBrowseInfo sTitle
79914>>>  Pointer lpItemIdList lpsFolder lpsBrowseInfo lpsTitle
79914>>>  Integer iFolderSelected iRetval
79914>>>
79914>>>  // fill string variable with null characters
79914>>>  ZeroType vtBrowseInfo To sBrowseInfo
79915>>>
79915>>>  If (sDialogTitle<>"") Begin
79917>>>    Move sDialogTitle To sTitle
79918>>>    // Torben Lund suggested converting the string with toansi. Doing it like that
79918>>>    // disables showing some commonly used ascii characters like ascii 137 ()
79918>>>    // These chars are correctly shown if no toansi is used.
79918>>>    // I can imagine that he wanted to path to be ANSI, but as long as it isa just
79918>>>    // selected it will always be valid.
79918>>>    Move (AddressOf(sTitle)) to lpsTitle
79919>>>    Put lpsTitle To sBrowseInfo At vtBrowseInfo.lpszTitle
79920>>>  End
79920>>>>
79920>>>
79920>>>  Put vBIF_RETURNONLYFSDIRS To sBrowseInfo At vtBrowseInfo.ulFlags
79921>>>
79921>>>  // Torben Lund added line below. Move handle of focus object to structure before
79921>>>  // calling function. Otherwise, the folderdialog will be started as a seperate task.
79921>>>  Put (window_handle(focus(desktop))) To sBrowseInfo At vtBrowseInfo.hWndOwner
79922>>>
79922>>>  Move (AddressOf(sBrowseInfo)) to lpsBrowseInfo
79923>>>
79923>>>  // null 128 chars into var (make space)
79923>>>  Move (Repeat(Character(0), vMAX_PATH)) To sFolder
79924>>>  Move (AddressOf(sFolder)) to lpsFolder
79925>>>
79925>>>  // select folder
79925>>>  Move (vWin32_SHBrowseForFolder(lpsBrowseInfo)) To lpItemIdList
79926>>>  // get selected folder name
79926>>>  Move (vWin32_SHGetPathFromIDList(lpItemIdList, lpsFolder)) To iFolderSelected
79927>>>
79927>>>  // release memory resources that are used by the ItemIdList
79927>>>  Move (vWin32_CoTaskMemFree(lpItemIdList)) To iRetval
79928>>>
79928>>>  If (iFolderSelected<>0) Begin
79930>>>    Function_Return (CString(sFolder))
79931>>>  End
79931>>>>
79931>>>  Else Begin
79932>>>    Function_Return ""
79933>>>  End
79933>>>>
79933>>>End_Function // vSHBrowseForFolder
79934>>>
79934>>>
79934>>>// returns 0 if the folder is created.
79934>>>//         1 if the API-call returned an error.
79934>>>Function vCreateDirectory Global String sNewFolder Returns Integer
79936>>>  String  sFolder sSA
79936>>>  Pointer lpsFolder lpsSecurity_Attributes lpDescriptor
79936>>>  Integer iRetval bFolderCreated bInheritHandle
79936>>>
79936>>>  Move (False) To bFolderCreated
79937>>>  // fill string variable with null characters
79937>>>  ZeroType vtSecurity_attributes To sSA
79938>>>
79938>>>  // null MAX_PATH chars into var (make space)
79938>>>  Move (Repeat(Character(0), vMAX_PATH)) To sFolder
79939>>>
79939>>>  If (sNewFolder <> "") Begin
79941>>>
79941>>>    Move dfTrue To  bInheritHandle
79942>>>    // Setting this to NULL is already done by the zerotype command
79942>>>    // Move NULL   To  lpDescriptor
79942>>>    Put (length(sSA))   To sSA At vtSecurity_attributes.nLength
79943>>>    //Put lpDescriptor To sSA at vtSecurity_attributes.lpDescriptor
79943>>>    Put bInheritHandle To sSA At vtSecurity_attributes.bInheritHandle
79944>>>
79944>>>    Move (AddressOf(sSA)) to lpsSecurity_Attributes
79945>>>
79945>>>    //
79945>>>    Move sNewFolder To sFolder
79946>>>    Move (AddressOf(sFolder)) to lpsFolder
79947>>>    Move (vWin32_CreateDirectory(lpsFolder, lpsSecurity_Attributes)) To bFolderCreated
79948>>>  End
79948>>>>
79948>>>
79948>>>  If (not(bFolderCreated)) Begin
79950>>>    Move 1 to iRetVal
79951>>>  End
79951>>>>
79951>>>  Function_Return iRetVal
79952>>>End_Function // vCreateDirectory
79953>>>
79953>>>
79953>>>// **WvA: 03-02-2002 Function created.
79953>>>// With this function one can remove a directory.
79953>>>// returns 0 if the folder is removed.
79953>>>//         1 if the API-call returned an error (Use GetLastError API to get the details)
79953>>>//         2 if the folder did not exist
79953>>>//         3 if the sFolder parameter passed is equal to ""
79953>>>Function vRemoveDirectory Global String sFolder Returns Integer
79955>>>  String  sPath
79955>>>  Pointer lpsPath
79955>>>  Integer iRetval bRemoved
79955>>>
79955>>>  Move (False) To bRemoved
79956>>>  Move 0 To iRetVal
79957>>>  Move (Trim(sFolder)) To sFolder
79958>>>  If (sFolder="") Begin
79960>>>    Move 3 To iRetVal
79961>>>  End
79961>>>>
79961>>>  If (vFolderExists(sFolder)=False) Begin
79963>>>    Move 2 To iRetVal
79964>>>  End
79964>>>>
79964>>>  If (iRetVal=0) Begin
79966>>>    // null MAX_PATH chars into var (make space)
79966>>>    Move (Repeat(Character(0), vMAX_PATH)) To sPath
79967>>>    //
79967>>>    Move (Insert(sFolder,sPath,1)) To sPath
79968>>>    Move (AddressOf(sPath)) to lpsPath
79969>>>    Move (vWin32_RemoveDirectory(lpsPath)) To bRemoved
79970>>>  End
79970>>>>
79970>>>
79970>>>  If ((iRetVal=0) And (bRemoved=False)) Begin
79972>>>    Move 1 To iRetVal
79973>>>  End
79973>>>>
79973>>>  Function_Return iRetVal
79974>>>End_Function // vRemoveDirectory
79975>>>
79975>>>
79975>>>
79975>>>// This function informs the user that he entered a yet unknown folder and
79975>>>// asks if he/she wants to create the folder (Yes/No)
79975>>>// Choice: "Yes" - this creates the folder
79975>>>//                 if successful, the function returns false
79975>>>//                 else it will be true.
79975>>>// Choice: "No"  - returns TRUE, This allows the programmer to take action
79975>>>//                 For example: to stop a save
79975>>>// Precondition: A foldername must be entered. We do not check for empty paths
79975>>>// This function returns a non-zero value if the folder isn't created afterwards
79975>>>Function vVerifyNewFolder Global String sFolderName Returns Integer
79977>>>  Integer bIsNotValid
79977>>>  Integer iUsers_Choice
79977>>>  String  sMessage
79977>>>
79977>>>  If (vFolderExists(sFolderName) Eq 0) Begin
79979>>>    Move "The folder '" To sMessage
79980>>>    Append sMessage sFolderName
79981>>>    Append sMessage "' does not yet exist,\n"
79982>>>    Append sMessage "Do you want to create it now?"
79983>>>    Get YesNo_Box sMessage "Confirm" MB_DefButton1 To iUsers_Choice
79984>>>    Case Begin
79984>>>      Case (iUsers_Choice = MBR_Yes)
79986>>>        Move (vCreateDirectory(sFolderName)) To bIsNotValid
79987>>>        If bIsNotValid Begin
79989>>>          Move "An error occurred while trying to create folder '" To sMessage
79990>>>          Append sMessage sFolderName "'.\n\n"
79992>>>          Send Info_Box sMessage "Info"
79993>>>          End
79993>>>>
79993>>>        Case Break
79994>>>      Case (iUsers_Choice = MBR_No)
79997>>>        Move dfTrue To bIsNotValid // Cancel the save
79998>>>        Case Break
79999>>>    Case End
79999>>>  End
79999>>>>
79999>>>  Function_Return bIsNotValid
80000>>>End_Function // vVerifyNewFolder
80001>>>
80001>>>
80001>>>// This will perform an operation on a file (e.g. open) with the application
80001>>>// registered in the Windows Registry to open that type of file (via its extension)
80001>>>// sOperation would be "OPEN" (it could also be "PRINT" etc).
80001>>>Procedure vShellExecute global String sOperation String sDocument String sParameters String sPath
80003>>>  Handle  hInstance hWnd
80003>>>  Pointer lpsOperation
80003>>>  Pointer lpsDocument
80003>>>  Pointer lpsParameters
80003>>>  Pointer lpsPath
80003>>>  // remove any leading/trailing spaces in the string
80003>>>  Move (Trim(sDocument)) To sDocument
80004>>>  Move (Trim(sPath))     To sPath
80005>>>  // Make the strings readable for windows API, by converting them to null-terminated
80005>>>  Append sOperation   (Character(0))
80006>>>  Append sDocument    (Character(0))
80007>>>  Append sParameters  (Character(0))
80008>>>  Append sPath        (Character(0))
80009>>>  // Connect the corresponding pointers to the strings
80009>>>  Move (AddressOf(sOperation))  to lpsOperation
80010>>>  Move (AddressOf(sDocument))   to lpsDocument
80011>>>  Move (AddressOf(sParameters)) To lpsParameters
80012>>>  Move (AddressOf(sPath))       to lpsPath
80013>>>
80013>>>  Get Window_Handle To hWnd
80014>>>  Move (vWin32_ShellExecute (hWnd, lpsOperation, lpsDocument, lpsParameters, lpsPath, 1)) To hInstance
80015>>>  If (hInstance <= 32) Begin
80017>>>    Send vDDE_Error_Handler hInstance
80018>>>  End
80018>>>>
80018>>>End_Procedure // vShellExecute
80019>>>
80019>>>
80019>>>Class cShellFileOperations Is a Array
80020>>>
80020>>>  Procedure Construct_Object
80022>>>    Forward Send Construct_Object
80024>>>    Property Integer piDeleteFlags 0
80025>>>    Property Integer piCopyFlags   0
80026>>>    Property Integer piMoveFlags   0
80027>>>    Property Integer piRenameFlags 0
80028>>>
80028>>>    Set piDeleteFlags To (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
80029>>>    Set piCopyFlags   To (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR Ior vFOF_NOCONFIRMATION)
80030>>>    Set piMoveFlags   To (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR iOr vFOF_NOCONFIRMATION)
80031>>>    Set piRenameFlags To (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
80032>>>  End_Procedure // Construct_Object
80033>>>
80033>>>
80033>>>  // This function uses the shell API to perform a file operation on the
80033>>>  // files supplied.
80033>>>  //
80033>>>  Function FileOperation String sSource String sDestination Integer iOperation Integer iFlags Returns Integer
80035>>>    String   sShFileOp
80035>>>    Pointer  lpShFileOp
80035>>>    Pointer  lpsSource
80035>>>    Pointer  lpsDestination
80035>>>    Integer  iRetVal
80035>>>    Integer  bUserAbort
80035>>>
80035>>>    ZeroType vtShFileOpStruct To sShFileOp
80036>>>    Move (ToAnsi(sSource)+Character(0)+Character(0))      To sSource
80037>>>    Move (ToAnsi(sDestination)+Character(0)+Character(0)) To sDestination
80038>>>    Move (AddressOf(sSource))    To lpsSource
80039>>>    If iOperation Ne vFO_DELETE Begin
80041>>>      Move (AddressOf(sDestination))      To lpsDestination
80042>>>      Put lpsDestination To sShFileOp At vtShFileOpStruct.pTo
80043>>>    End
80043>>>>
80043>>>
80043>>>    Put iOperation     To sShFileOp At vtShFileOpStruct.wFunc
80044>>>    Put lpsSource      To sShFileOp At vtShFileOpStruct.pFrom
80045>>>    Put iFlags         To sShFileOp At vtShFileOpStruct.fFlags
80046>>>
80046>>>    Move (AddressOf(sShFileOp)) to lpShFileOp
80047>>>
80047>>>    Move (vWin32_SHFileOperation(lpShFileOp)) To iRetVal
80048>>>    GetBuff From sShFileOp At vtShFileOpStruct.fAnyOperationsAborted To bUserAbort
80049>>>    If (bUserAbort <> 0) Begin
80051>>>      Move 80 To iRetVal  // file Operation Aborted by USER
80052>>>    End
80052>>>>
80052>>>    Function_Return (iRetVal)
80053>>>  End_Function // FileOperation
80054>>>
80054>>>
80054>>>  Function sfoDeleteFile String sFileName Returns Integer
80056>>>    Integer  iRetVal
80056>>>    Integer  iFlags
80056>>>
80056>>>    Get piDeleteFlags To iFlags
80057>>>    Get FileOperation sFileName "" vFO_DELETE iFlags To iRetVal
80058>>>    Function_Return iRetVal
80059>>>  End_Function // sfoDeleteFile
80060>>>
80060>>>
80060>>>  Function sfoCopyFile String sSource String sDestination Returns Integer
80062>>>    Integer  iRetVal
80062>>>    Integer  iFlags
80062>>>
80062>>>    Get piCopyFlags To iFlags
80063>>>    Get FileOperation sSource sDestination vFO_COPY iFlags To iRetVal
80064>>>    Function_Return iRetVal
80065>>>  End_Function // sfoCopyFile
80066>>>
80066>>>
80066>>>  Function sfoMoveFile String sSource String sDestination Returns Integer
80068>>>    Integer  iRetVal
80068>>>    Integer  iFlags
80068>>>
80068>>>    Get piMoveFlags To iFlags
80069>>>    Get FileOperation sSource sDestination vFO_MOVE iFlags To iRetVal
80070>>>    Function_Return iRetVal
80071>>>  End_Function // sfoMoveFile
80072>>>
80072>>>
80072>>>  // Rename a file or folder
80072>>>  // Returns a nonzero value if the operation failed.
80072>>>  Function sfoRenameFile String sSource String sDestination Returns Integer
80074>>>    Integer  iRetVal
80074>>>    Integer  iFlags
80074>>>
80074>>>    Get piRenameFlags To iFlags
80075>>>    Get FileOperation sSource sDestination vFO_RENAME iFlags To iRetVal
80076>>>    Function_Return iRetVal
80077>>>  End_Function // sfoRenameFile
80078>>>
80078>>>  // Courtesy Of Steve Walter
80078>>>  // Requires Windows 2000 and up according to msdn but it was
80078>>>  //  in fact available before that as an unpublished API call
80078>>>  //  a little google search shows that this was already available
80078>>>  //  in windows 95 and NT
80078>>>  //
80078>>>  // The format is controlled by the dialog interface.
80078>>>  // That is, the user must click the OK button To actually Begin the format
80078>>>  // the format cannot be started programmatically.
80078>>>  // An alternative to this functionality would be to use a controlpanel
80078>>>  //  http://www.vdf-guidance.com/ContribPage.asp?Page=PKGCLSDFCPLAPP&ContribRecId=93
80078>>>  //
80078>>>  // hWnd = The windows handle of the object from which the format Function
80078>>>  //        is called.
80078>>>  // To Get this,
80078>>>  //          use:  Get Window_Handle Of <object>
80078>>>  //          For instance, in this app, we're going to use the Report_Panel:
80078>>>  //                  Get Window_Handle Of (Report_Panel(Main(Self))) To hWind
80078>>>  //
80078>>>  // sDrive = The drive letter. At this moment only A and B are valid
80078>>>  //
80078>>>  // iOptions = Format options.
80078>>>  //  SHFMT_OPT_DEFAULT = Quick format
80078>>>  //  SHFMT_OPT_FULL    = Full Format
80078>>>  //  SHFMT_OPT_SYSONLY = System only
80078>>>  //  3                 = Full format with system. (unsupported)
80078>>>  //
80078>>>  // Return Values:
80078>>>  //  SHFMT_ERROR    = Error on format or no drive specified.
80078>>>  //  SHFMT_CANCEL   = Format cancelled by user.
80078>>>  //  SHFMT_NOFORMAT = Drive is not formatable.
80078>>>  //
80078>>>  //
80078>>>  // *** ATTENTION: This function has been disabled as it doesn't
80078>>>  //                seem to work, i must have made a silly mistake
80078>>>  //                somewhere.
80078>>>  //
80078>>>  Function sfoFormatDisk String sDrive Integer iOptions Returns DWORD
80080>>>    Handle   hWnd
80080>>>    Integer  iObj
80080>>>    DWORD    dwReturnVal
80080>>>    Integer iDrive
80080>>>
80080>>>    Function_Return (1) // STOP HERE
80081>>>
80081>>>    Move (Trim(sDrive)) To sDrive
80082>>>    If ( sDrive <> '' ) Begin
80084>>>      If ( sDrive contains ':' ) Begin
80086>>>        Move (Replace(':',sDrive,'')) to sDrive
80087>>>      End
80087>>>>
80087>>>      If (not( 'AB' contains sDrive )) Begin
80089>>>         Function_Return (SHFMT_NOFORMAT)
80090>>>      End
80090>>>>
80090>>>      If ( sDrive = 'A') Begin
80092>>>        Move 0 to iDrive
80093>>>      End
80093>>>>
80093>>>      Else If ( sDrive = 'B') Begin
80096>>>        Move 1 to iDrive
80097>>>      End
80097>>>>
80097>>>      // Window_Handle Of Desktop equals to 0
80097>>>
80097>>>      Get focus Of desktop To iObj
80098>>>      If (iObj>desktop) ;          Get Container_Handle Of iObj To hWnd
80101>>>      While (hWnd=0 And iObj<>Desktop)
80105>>>          Get Parent Of iObj To iObj
80106>>>          Get Container_Handle Of iObj To hWnd
80107>>>      End
80108>>>>
80108>>>
80108>>>      //Showln "hWnd = " hWnd " iDrive " iDrive " iOptions " iOptions
80108>>>      Move (vWin32_ShFormatDrive(hWnd, iDrive, SHFMT_ID_DEFAULT, iOptions)) To dwReturnVal
80109>>>    End
80109>>>>
80109>>>    Else Begin
80110>>>      Move (SHFMT_ERROR) To dwReturnVal
80111>>>    End
80111>>>>
80111>>>    Function_Return dwReturnVal
80112>>>  End_Function // sfoFormatDisk
80113>>>
80113>>>  //Example:
80113>>>  // Get sfoFormatDisk 'A' 0 To dReturnVal    // Formats drive A in QuickFormat
80113>>>  //                                          mode.
80113>>>
80113>>>End_Class // cShellFileOperations
80114>>>
80114>>>
80114>>>Object oShellFileOperations Is a cShellFileOperations
80116>>>End_Object // oShellFileOperations
80117>>>
80117>>>
80117>>>// Restore to the old way of working with the shell file operations.
80117>>>// or.. to put lay man terms, allow any of the operations vDeleteFile
80117>>>// vCopyFile/vMoveFile/vRenameFile to have an UNDO
80117>>>Procedure vWin32fhCompatibilityMode
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
80119>>>  Integer hoSFO
80119>>>  Integer iFlags
80119>>>
80119>>>  Move (vFOF_SILENT Ior vFOF_NOCONFIRMATION Ior vFOF_ALLOWUNDO) To iFlags
80120>>>  Move (oShellFileOperations(Self)) To hoSFO
80121>>>
80121>>>  Set piDeleteFlags Of hoSFO To iFlags
80122>>>  Set piCopyFlags   Of hoSFO To iFlags
80123>>>  Set piMoveFlags   Of hoSFO To iFlags
80124>>>  Set piRenameFlags Of hoSFO To iFlags
80125>>>End_Procedure // vWin32fhCompatibilityMode
80126>>>
80126>>>
80126>>>Function vDeleteFile Global String sFileName Returns Integer
80128>>>  Integer  iRetVal
80128>>>
80128>>>  Get sfoDeleteFile Of (oShellFileOperations(Self)) sFileName To iRetVal
80129>>>  Function_Return iRetVal
80130>>>End_Function // vDeleteFile
80131>>>
80131>>>
80131>>>Function vCopyFile Global String sSource String sDestination Returns Integer
80133>>>  Integer  iRetVal
80133>>>
80133>>>  Get sfoCopyFile Of (oShellFileOperations(Self)) sSource sDestination To iRetVal
80134>>>  Function_Return iRetVal
80135>>>End_Function // vCopyFile
80136>>>
80136>>>
80136>>>Function vMoveFile Global String sSource String sDestination Returns Integer
80138>>>  Integer  iRetVal
80138>>>
80138>>>  Get sfoMoveFile Of (oShellFileOperations(Self)) sSource sDestination To iRetVal
80139>>>  Function_Return iRetVal
80140>>>End_Function // vMoveFile
80141>>>
80141>>>
80141>>>// Rename a file or folder
80141>>>// Returns a nonzero value if the operation failed.
80141>>>Function vRenameFile Global String sSource String sDestination Returns Integer
80143>>>  Integer  iRetVal
80143>>>
80143>>>  Get sfoRenameFile Of (oShellFileOperations(Self)) sSource sDestination To iRetVal
80144>>>  Function_Return iRetVal
80145>>>End_Function // vRenameFile
80146>>>
80146>>>
80146>>>
80146>>>Function vGetWindowsDirectory Returns String
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
80148>>>  String  sDirectory
80148>>>  Pointer lpDirectory
80148>>>  Integer iVoid
80148>>>
80148>>>  ZeroString vMAX_PATH To sDirectory
80149>>>  Move (AddressOf(sDirectory)) to lpDirectory
80150>>>
80150>>>  Move (vWin32_GetWindowsDirectory(lpDirectory, vMAX_PATH)) To iVoid
80151>>>  Function_Return (CString(sDirectory))  // **WvA: Changed to CString()
80152>>>End_Function // vGetWindowsDirectory
80153>>>
80153>>>
80153>>>
80153>>>
80153>>>// Courtesy of Marco Kuipers
80153>>>Function vMakeTempFile Returns String
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
80155>>>    Integer iRetval
80155>>>    String  sTempPath sTempFileName sPrefixString
80155>>>    Pointer lpTempPath lpTempFileName lpPrefixString
80155>>>
80155>>>    Move (Repeat (Character (0), 255)) To sTempPath
80156>>>    Move (AddressOf(sTempPath)) to lpTempPath
80157>>>    Move (vWin32_GetTempPath (255, lpTempPath)) To iRetVal
80158>>>
80158>>>    If (sTempPath = "") Begin
80160>>>       Get_Current_Directory To sTempPath
80161>>>    End
80161>>>>
80161>>>    Move (pad(sTempPath,vMax_Path-14)) To sTempPath // *WvA: 28-04-2005 Quote from msdn: The string cannot be longer than MAX_PATH-14 characters.
80162>>>    Move (Repeat (Character (0), 255)) To sTempFileName
80163>>>    Move (AddressOf(sTempFileName)) To lpTempFileName
80164>>>    Move ("tmp"+character(0)) To sPrefixString // **WvA: 28-04-2005 Added a null
80165>>>    Move (AddressOf(sPrefixString)) To lpPrefixString
80166>>>    Move (AddressOf(sTempPath)) to lpTempPath
80167>>>    Move (vWin32_GetTempFileName (lpTempPath, lpPrefixString, 0, lpTempFileName)) To iRetval
80168>>>    If (iRetval = 0) Begin  // **WvA: 28-04-2005 Changed condition, the api call returns 0 if an error occurs
80170>>>        Move "" To sTempFileName
80171>>>    End
80171>>>>
80171>>>
80171>>>    Function_Return (Cstring(sTempFileName)) // **WvA: 28-04-2005 Cstring added
80172>>>End_Function // vMakeTempFile
80173>>>
80173>>>
80173>>>// This function creates a uniquely named temporary file in folder sPath
80173>>>// The file created will have a prefix based on the first 3 characters in sPrefix
80173>>>// Note that you will have to cleanup the tempfile yourself as the function
80173>>>// does not take care of that.
80173>>>Function vCreateTempFileInPath String sPath String sPrefix Returns String
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
80175>>>    String sTempFileName
80175>>>    Integer iRetVal
80175>>>    Pointer lpTempFileName
80175>>>    Pointer lpPath
80175>>>    Pointer lpPrefix
80175>>>
80175>>>    Move (ToAnsi(sPath)+Character(0))   To sPath
80176>>>    Move (ToAnsi(sPrefix)+Character(0)) To sPrefix
80177>>>    Move (pad("", vMAX_PATH)) To sTempFileName
80178>>>    Move (AddressOf(sTempFileName)) To lpTempFileName
80179>>>    Move (AddressOf(sPath))         To lpPath
80180>>>    Move (AddressOf(sPrefix))       to lpPrefix
80181>>>
80181>>>    Move (vWin32_GetTempFileName(lpPath, lpPrefix, 0, lpTempFileName)) To iRetVal
80182>>>    Move (Trim(Cstring(sTempFileName))) To sTempFileName
80183>>>    Function_Return sTempFileName
80184>>>End_Function // vCreateTempFileInPath
80185>>>
80185>>>//
80185>>>// Get a specific shell folder for example to get the desktop folder
80185>>>// simply call this function and pass it vCSIDL_DESKTOP
80185>>>//
80185>>>Function vSHGetFolderPath Integer eFolder Returns String
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
80187>>>  String  sFolder
80187>>>  Integer iVoid
80187>>>  Pointer lpsFolder
80187>>>  Handle  hWnd
80187>>>  Move (Window_Handle(focus(desktop))) To hWnd
80188>>>
80188>>>  Move (Repeat(Character(0), vMAX_PATH)) To sFolder
80189>>>  Move (AddressOf(sFolder)) To lpsFolder
80190>>>
80190>>>  Move (vWin32_SHGetFolderPath(hWnd,eFolder, 0, 0,lpsFolder)) To iVoid
80191>>>  Function_Return (CString(sFolder))
80192>>>End_Function // vSHGetFolderPath
80193>>>
80193>>>
80193>>>
80193>>>// Courtesy Of Vincent Oorsprong
80193>>>Function vConvertFileDateTime Global Dword dwLowDateTime Dword dwHighDateTime Returns String
80195>>>  String  sftTime sSystemTime sFormattedTime sFormattedDate
80195>>>  Pointer lpsftTime lpsSystemTime lpsFormattedTime lpsFormattedDate
80195>>>  Integer iSuccess iLenCcTime iDataLength iLenCcDate
80195>>>
80195>>>  ZeroType vFileTime  To sftTime
80196>>>  Put dwLowDateTime  To sftTime At vFileTime.dwLowDateTime
80197>>>  Put dwHighDateTime To sftTime At vFileTime.dwHighDateTime
80198>>>  Move (AddressOf(sftTime)) to lpsftTime
80199>>>
80199>>>  ZeroType vSystemTime To sSystemTime
80200>>>  Move (AddressOf(sSystemTime)) To lpsSystemTime
80201>>>
80201>>>  Move (vWin32_FileTimeToSystemTime (lpsftTime, lpsSystemTime)) To iSuccess
80202>>>  If iSuccess Eq DfTrue Begin
80204>>>    ZeroString 255 To sFormattedTime
80205>>>    Move (AddressOf(sFormattedTime)) To lpsFormattedTime
80206>>>    Length sFormattedTime To iLenCcTime
80207>>>>
80207>>>    Move (vWin32_GetTimeFormat (LOCALE_USER_DEFAULT, 0, lpsSystemTime, 0, ;                             lpsFormattedTime, iLenCcTime)) To iDataLength
80208>>>    ZeroString 255 To sFormattedDate
80209>>>    Move (AddressOf(sFormattedDate)) to lpsFormattedDate
80210>>>    Move (Length(sFormattedDate)) to iLenCcDate
80211>>>    Move (vWin32_GetDateFormat (LOCALE_USER_DEFAULT, 0, lpsSystemTime, 0, ;                             lpsFormattedDate, iLenCcDate)) To iDataLength
80212>>>    Function_Return (Cstring (sFormattedDate)  * Cstring (sFormattedTime))
80213>>>  End // iSuccess
80213>>>>
80213>>>End_Function // vConvertFileDateTime
80214>>>
80214>>>
80214>>>// **WvA Removed, See the cFileSet class for an alternative
80214>>>//Procedure DoBrowseDir String sFilePath
80214>>>//End_Procedure // DoBrowseDir
80214>>>
80214>>>// **WvA:
80214>>>// A windows replacement for the standard function FileExists.
80214>>>// This version will also return (true) for a file when it is open by an application.
80214>>>// Note that you can apply normal windows mask-signs in the filename such as * and ?
80214>>>// Example: Get vFilePathExists "C:\config.sy?"
80214>>>// This will return true if you have a file matching these conditions. (aka config.sys)
80214>>>Function vFilePathExists Global String sFilePathMask Returns Integer
80216>>>  String  sWin32FindData
80216>>>  String  sDirSep
80216>>>  Pointer lpsFilePathMask lpsWin32FindData
80216>>>  Handle  hFindFile
80216>>>  Integer iVoid
80216>>>
80216>>>  Move vINVALID_HANDLE_VALUE To hFindFile
80217>>>  Move (ToANSI(trim(sFilePathMask))) To sFilePathMask
80218>>>
80218>>>  If (length(sFilePathMask)>0) Begin
80220>>>    // 2014-09-29 NGS Remove any trailing dir separators, as they make the function fail.
80220>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
80221>>>    While (Right(sFilePathMask, 1) = sDirSep)
80225>>>      Move (Left(sFilePathMask, Length(sFilePathMask) -1)) to sFilePathMask
80226>>>    Loop
80227>>>>
80227>>>
80227>>>    Move (AddressOf(sFilePathMask)) To lpsFilePathMask
80228>>>    ZeroType vWin32_Find_Data To sWin32FindData
80229>>>    Move (AddressOf(sWin32FindData)) to lpswin32FindData
80230>>>    Move (vWin32_FindFirstFile (lpsFilePathMask, lpsWin32FindData)) To hFindFile
80231>>>    Move (vWin32_FindClose (hFindFile)) To iVoid
80232>>>  End
80232>>>>
80232>>>  Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
80233>>>End_Function // vFilePathExists
80234>>>
80234>>>
80234>>>// **WvA
80234>>>// Formats a foldername by first trimming it and after that by sticking a
80234>>>// directory separator (/\) to the end if it doesn't have one there already.
80234>>>// The folder may contain a drive letter or UNC encoding.
80234>>>Function vFolderFormat Global String sFolderName Returns String
80236>>>  String sDirSep
80236>>>  Move (sysconf(SYSCONF_DIR_SEPARATOR)) To sDirSep  // normally \ (backslash)
80237>>>  Move (Trim(sFolderName)) To sFolderName
80238>>>  If (Right(sFolderName,1)<>sDirSep) Begin
80240>>>    Move (sFolderName+sDirSep) To sFolderName
80241>>>  End
80241>>>>
80241>>>  Function_Return sFolderName
80242>>>End_Function // vFolderFormat
80243>>>//
80243>>>// Returns the amount of files in the folder (if it exists)
80243>>>// Returns -1 if folder doesn't exist.
80243>>>// The files "." and ".." are not counted.
80243>>>//
80243>>>Function vFolderFileCount Global String sFolderName Returns Integer
80245>>>  Boolean bFound
80245>>>  Handle  hFindFile
80245>>>  Integer iCount  iVoid
80245>>>  Integer iSuccess
80245>>>  Pointer lpsFolderName lpsWin32FindData
80245>>>  String  sWin32FindData
80245>>>  String  sFileName
80245>>>
80245>>>  Move -1 To iCount
80246>>>  Get vFolderFormat sFolderName To sFolderName
80247>>>  Move (sFolderName+"*") To sFolderName // match any filename in the folder
80248>>>  Move (AddressOf(sFolderName)) To lpsFolderName
80249>>>  ZeroType vWin32_Find_Data To sWin32FindData
80250>>>  Move (AddressOf(sWin32FindData)) to lpswin32FindData
80251>>>  Move (vWin32_FindFirstFile (lpsFolderName, lpsWin32FindData)) To hFindFile
80252>>>  Move (hFindFile<>vINVALID_HANDLE_VALUE) To bFound
80253>>>  If (bFound) Begin
80255>>>    Move 0 to iCount
80256>>>  End
80256>>>>
80256>>>  While (bFound)
80260>>>    Increment iCount
80261>>>    GetBuff_String From sWin32FindData At vWin32_Find_Data.cFileName To sFileName
80262>>>    If (sFileName="." or sFileName="..") Begin
80264>>>        Decrement iCount
80265>>>    End
80265>>>>
80265>>>    Move (vWin32_FindNextFile(hFindFile, lpsWin32FindData)) To iSuccess
80266>>>    Move (iSuccess<>0) To bFound
80267>>>  Loop
80268>>>>
80268>>>  Move (vWin32_FindClose (hFindFile)) To iVoid
80269>>>  Function_Return iCount
80270>>>End_Function // vFolderFileCount
80271>>>
80271>>>
80271>>>//
80271>>>// Gets the parent path of the currently supplied path
80271>>>// Returns "" when we are at the root folder.
80271>>>//
80271>>>Function vParentPath Global String sPath Returns String
80273>>>  String sStrip
80273>>>  Integer iLength
80273>>>
80273>>>  If (Right(sPath,1)="\") Begin
80275>>>    Move (Left(sPath,Length(sPath)-1)) To sPath
80276>>>  End
80276>>>>
80276>>>  If (Pos("\",sPath)) Begin
80278>>>    Move (StringFromRightOfChar(sPath,"\")) to sStrip
80279>>>    Move (Length(sStrip)) to iLength
80280>>>    Move (Left(sPath, (Length(sPath) - iLength -1))) to sPath
80281>>>//    Move (Replace(sStrip,sPath,"")) To sPath
80281>>>  End
80281>>>>
80281>>>  Else Begin
80282>>>    Move "" To sPath
80283>>>  End
80283>>>>
80283>>>  Function_Return sPath
80284>>>End_Function // vParentPath
80285>>>
80285>>>// Create the folder, including intermediate directories.
80285>>>// Don't panic if the folder already exists.
80285>>>// Michael Mullan June 2009.
80285>>>Function vshCreateDirectoryEX Global String sNewFolder Returns Integer
80287>>>  String  sFolder sSA
80287>>>  Pointer lpsFolder lpsSecurity_Attributes
80287>>>  Integer iRetval bFolderCreated bInheritHandle
80287>>>  Move (False) to bFolderCreated
80288>>>  // fill string variable with null characters
80288>>>  ZeroType vtSecurity_attributes to sSA
80289>>>  // null MAX_PATH chars into var (make space)
80289>>>  Move (Repeat(Character(0), vMAX_PATH)) to sFolder
80290>>>  If (sNewFolder <> "") Begin
80292>>>    Move dfTrue to  bInheritHandle
80293>>>    // Setting this to NULL is already done by the zerotype command
80293>>>    // Move NULL   To  lpDescriptor
80293>>>    Put (length(sSA))   to sSA At vtSecurity_attributes.nLength
80294>>>    //Put lpDescriptor To sSA at vtSecurity_attributes.lpDescriptor
80294>>>    Put bInheritHandle to sSA At vtSecurity_attributes.bInheritHandle
80295>>>    Move (AddressOf(sSA)) to lpsSecurity_Attributes
80296>>>    //
80296>>>    Move sNewFolder to sFolder
80297>>>    Move (AddressOf(sFolder)) to lpsFolder
80298>>>    Move (vWin32_SHCreateDirectoryEx(0,lpsFolder, lpsSecurity_Attributes)) to bFolderCreated
80299>>>  End
80299>>>>
80299>>>
80299>>>  If (bFolderCreated <> 0) Begin
80301>>>    Move 1 to iRetVal
80302>>>
80302>>>    If (bFolderCreated = 161 ) Begin
80304>>>        Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_BAD_PATHNAME)")
80305>>>>
80305>>>    End
80305>>>>
80305>>>    Else If (bFolderCreated = 206 ) Begin
80308>>>        Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_FILENAME_EXCED_RANGE)")
80309>>>>
80309>>>    End
80309>>>>
80309>>>    Else If (bFolderCreated = 3   ) Begin
80312>>>        Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_PATH_NOT_FOUND)")
80313>>>>
80313>>>    End
80313>>>>
80313>>>    Else If (bFolderCreated = 80  ) Begin
80316>>>        Move 0 to iRetval // "ERROR_FILE_EXISTS"     not really an error
80317>>>    End
80317>>>>
80317>>>    Else If (bFolderCreated = 183 ) Begin
80320>>>        Move 0 to iRetval //  "ERROR_ALREADY_EXISTS"     not really an error
80321>>>    End
80321>>>>
80321>>>    Else If (bFolderCreated = 1223) Begin
80324>>>        Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_CANCELLED)")
80325>>>>
80325>>>    End
80325>>>>
80325>>>    Else Begin
80326>>>        Error DFERR_OPERATOR ("Folder Creation Error # " + String(bfoldercreated) + "\n" + sNewFolder + "(FILE_CREATION_ERROR)")
80327>>>>
80327>>>    End
80327>>>>
80327>>>  End
80327>>>>
80327>>>  Function_Return iRetVal
80328>>>End_Function // vshCreateDirectoryEX
80329>>>
80329>>>
80329>>>Function vWin32_APIFileSize Global string sFileName returns integer
80331>>>     dWord dwFileSizeHigh dwFileSizeLow
80331>>>     integer iFileSize iVoid
80331>>>     handle hFindFile
80331>>>     pointer lpsFilePath lpsWin32FindData
80331>>>     string sWin32FindData
80331>>>
80331>>>     Move (AddressOf(sFileName)) to lpsFilePath
80332>>>
80332>>>     ZeroType vWin32_Find_Data to sWin32FindData
80333>>>     Move (AddressOf(sWin32FindData)) to lpsWin32FindData
80334>>>
80334>>>     move (vWin32_FindFirstFile (lpsFilePath, lpsWin32FindData)) to hFindFile
80335>>>     if (hFindFile<>vINVALID_HANDLE_VALUE) begin
80337>>>         GetBuff From sWin32FindData At vWin32_Find_Data.nFileSizeHigh To dwFileSizeHigh
80338>>>         GetBuff From sWin32FindData At vWin32_Find_Data.nFileSizeLow To dwFileSizeLow
80339>>>     end
80339>>>>
80339>>>     move (vWin32_FindClose (hFindFile)) to iVoid
80340>>>
80340>>>     Move ((dwFileSizeHigh * vMaxDword) + dwFileSizeLow) to iFileSize
80341>>>
80341>>>     function_return iFileSize
80342>>>End_Function  // vWin32_APIFileSize
80343>>>
80343>>>
80343>
80343>Object oHtmlHelp is a cHtmlHelp
80345>End_Object
80346>
80346>Object oApplication is a cApplication
80348>    Set peHelpType to htHtmlHelp
80349>    Set psCompany to "RDC Tools International"
80350>    Set psProduct to "The Database Update Framework - Create DbVersion Table"
80351>    Set psHelpFile to "DataFlex.chm"
80352>    Set psAutoOpenWorkspace to ""
80353>
80353>    Property String psFilelistName
80355>    Property String psOpenPath
80357>
80357>    Procedure OnCreate
80360>        Handle ho hoIni
80360>        String sSWSFile sWSFile sOpenPath sPath sFilelistname
80360>        Integer eOpened iPos
80360>        Boolean bExists
80360>
80360>        Get phoCommandLine to ho
80361>        Get Argument of ho 1 to sSWSFile
80362>
80362>        // Was the program started with a parameter on the command line from e.g. the Studio?
80362>        If (sSWSFile <> "") Begin
80364>            Get Create (RefClass(cIniFile)) to hoIni
80365>            Set psFileName of hoIni to sSWSFile
80366>            Get ParseFolderName sSWSFile to sPath
80367>
80367>            // Read .ws file path from the .sws file:
80367>            Get ReadString of hoIni "WorkspacePaths" "ConfigFile" "" to sWSFile
80368>            Move (Pos(".\", sWSFile)) to iPos
80369>            If (iPos <> 0) Begin
80371>                Move (Replace(".\", sWSFile, "")) to sWSFile
80372>            End
80372>            Send Destroy of hoIni
80373>            Move (sPath + sWSFile) to sWSFile
80374>            Get vFilePathExists sWSFile to bExists
80375>            If (bExists = True) Begin
80377>                Get OpenWorkspaceFile of (phoWorkspace(Self)) sWSFile to eOpened
80378>                If (eOpened = wsWorkspaceOpened) Begin
80380>                    Set psFilelistName to (psFileList(phoWorkspace(Self)))
80381>                    Procedure_Return // Workspace opened; We're done!
80382>                End
80382>            End
80382>        End
80382>
80382>        Get_Attribute DF_OPEN_PATH to sOpenPath
80385>        Set psOpenPath to sOpenPath
80386>
80386>        // Check if there is a config.ws file in the Programs folder:
80386>        Get OpenWorkspaceFile of (phoWorkspace(Self)) "config.ws" to eOpened
80387>        If (eOpened = wsWorkspaceOpened) Begin
80389>            Get psFileList of (phoWorkspace(Self)) to sFileListName
80390>            Set psFilelistName to sFileListName
80391>            Procedure_Return         // Workspace opened; We're done!
80392>        End
80392>
80392>        // If no config.ws was not found; let user select a .ws file
80392>        Get GetApplicationPath to sPath
80393>        Get vSelect_File "Workspace Files (*.ws)|*.ws|All Files (*.*)|*.*" "Please select a Workspace file (*.ws)" sPath to sWsFile
80394>        Get vFilePathExists sWsFile to bExists
80395>        If (bExists = False) Begin
80397>            Send Stop_Box "No Workspace file selected. Cannot continue!"
80398>            Send Exit_Application
80399>        End
80399>        Get OpenWorkspaceFile of (phoWorkspace(Self)) sWsFile to eOpened
80400>        If (eOpened = wsWorkspaceOpened) Begin
80402>            Get psFileList of (phoWorkspace(Self)) to sFileListName
80403>            Set psFilelistName to sFileListName
80404>            Procedure_Return
80405>        End
80405>        Else Begin
80406>            Send Stop_Box "Could not open the Workspace. Cannot continue!"
80407>            Send Exit_Application
80408>        End
80408>
80408>    End_Procedure
80409>
80409>End_Object
80410>
80410>//Use cCJSkinFramework.pkg
80410>//Object oCJSkinFramework is a cCJSkinFramework
80410>//    Set psSkinFile to "Mac_OSX_Leopard.cjstyles"
80410>//    Set psSkinIni to "NormalLeopard.ini"
80410>//End_Object
80410>
80410>Use cToolTipController.pkg
80410>Object oToolTipController is a cToolTipController
80412>    Move Self to ghoToolTipController
80413>    Set pbBalloonStyle to False
80414>    Set piIcon to TTI_INFO
80415>    Set psTitle to "Information"
80416>    Set piMaxWidth to 400
80417>    Set piDurationPopup to 14000    // 14 seconds, needed for long tooltips.
80418>End_Object
80419>
80419>Use cDbUpdateFunctionLibrary.pkg
Including file: cDbUpdateFunctionLibrary.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.pkg)
80419>>>//****************************************************************************
80419>>>// $Module type: Class
80419>>>// $Module name: cDbUpdateFunctionLibrary
80419>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
80419>>>// Web-site    : http://www.rdctools.com
80419>>>// Created     : 2014-09-05 @ 09:50 (Military date format: YY-MM-DD)
80419>>>//
80419>>>// Description : The class consists of a function library for database manipulations, aka make changes to a database.
80419>>>//               It has top level functions that uses the DataFlex db API, _but_ also specialized
80419>>>//               functions to make db changes to Sql databases with the DAW & Mertech drivers,
80419>>>//               with the help of Sql-scripts.
80419>>>//
80419>>>// $Rev History:
80419>>>//    2014-09-05  Module header created
80419>>>//
80419>>>//****************************************************************************
80419>>>Use cApplication.pkg
80419>>>Use seq_chnl.pkg
80419>>>Use GlobalFunctionsProcedures.pkg
80419>>>Use Datadict.pkg                        // Declaration of DF_FILE_SQL_TABLE_NAME
80419>>>Use DUFStatusPanel.pkg
Including file: DUFStatusPanel.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\DUFStatusPanel.pkg)
80419>>>>>// StatPnl.pkg - creates the standard status_panel object.
80419>>>>>//
80419>>>>>//
80419>>>>>// This is the default Status Panel object used by any of the Visual DataFlex classes that
80419>>>>>// invoke the standard status panel. The standard has always been that the package name
80419>>>>>// is StatPnl.pkg and the name of the object is Status_Panel. As of 12.0, there are major
80419>>>>>// changes in the way the status panel operates The Sentinel based external status panel used in
80419>>>>>// prior revisions has been replace with status panel that is part of the application.
80419>>>>>// This should work much better and faster than the old sentinel based solution.
80419>>>>>// While the way this operates has changed, the interface has not and therefore this should work
80419>>>>>// with most applications.
80419>>>>>//
80419>>>>>// As of 12.0, we have added a global handle that contains the object ID of this status panel.
80419>>>>>// This variable ghoStatusPanel can be used in place of the object name Status_Panel. This provides
80419>>>>>// a cleaner more robust interface.
80419>>>>>//
80419>>>>>//
80419>>>>>// Compatibility Note:
80419>>>>>//
80419>>>>>// When used in the standard way, this change will require no changes. A developer will only need to
80419>>>>>// change their code if they've modified the sentinel program, which was a difficult thing to do.
80419>>>>>//
80419>>>>>// If for some reason you application will not work using this as a replacement for the old status
80419>>>>>// panel, you've probably done something special with the old status-panel. If you don't want to
80419>>>>>// figure out how to use the new one and you want to continue using the old one you are going to need
80419>>>>>// to add some code to include the old status panel in your application. Add the following to your project (your src).
80419>>>>>//
80419>>>>>// Use StatPnl.pkg    // Make sure you load the new status panel object first. this is not optional!
80419>>>>>// Use OldStatPnl.pkg // load the old status panel. Status_Panel is now this old object
80419>>>>>//
80419>>>>>// If you do this, you will lose access to the new status-panel via Status_Panel. However, you
80419>>>>>// can still access the new object via the ghoStatusPanel handle.
80419>>>>>//
80419>>>>>//
80419>>>>>// Creating your own Status Panel objects
80419>>>>>//
80419>>>>>// If a developer wishes to create a custom panel, they should use this package as their template.
80419>>>>>// This panel can be visually modeled and changed any way you wish. Just save your new custom panel
80419>>>>>// with a different file and object name and direct your status panel request to the new object.
80419>>>>>//
80419>>>>>// If the new panel changes the interface and updates objects that are not currently defined, you
80419>>>>>// want to make sure you send the message ProcessEvents after you've updated the object. This allows
80419>>>>>// the object to paint when inside of a tight loop. For example, if you wanted to add a progress
80419>>>>>// bar (cProgressBar) you would want to Send ProcessEvents after you update the progress bar.
80419>>>>>// e.g.
80419>>>>>//       Procedure UpdateStatusBar
80419>>>>>//           Send DoAdvance of oProgressBar
80419>>>>>//           Send ProcessEvents
80419>>>>>//       End_Procedure
80419>>>>>//
80419>>>>>// of course, if you use the standard interfaces in status bar and your forward send these
80419>>>>>// messages this will be done for you.
80419>>>>>//
80419>>>>>// the standard Interface for status panels are:
80419>>>>>//
80419>>>>>// Send Initialize_StatusPanel - initializes values for caption, title & message
80419>>>>>// Send Start_StatusPanel      - start the status panel
80419>>>>>// Send Stop_StatusPanel       - stop the status panel
80419>>>>>// Send Update_StatusPanel     - update the status panel's action area
80419>>>>>// Get  Check_StatusPanel      - check for cancel (if cancel or pbCancel is set, close the panel)
80419>>>>>//
80419>>>>>// Get/Set Caption_Text - updates the caption bar
80419>>>>>// Get/Set Title_Text   - updates the title area
80419>>>>>// Get/Set Message_Text - updates the Message area
80419>>>>>// Get/Set Action_Text  - updates the action area
80419>>>>>// Get/Set Button_Text  - updates the button area
80419>>>>>//
80419>>>>>// Get/Set Allow_cancel_state - determines if panel can be canceled
80419>>>>>// Send EnableCancelButton - code you should provide to enable/disable cancel button
80419>>>>>//
80419>>>>>// ghoStatusPanel - global handle that points to the standard status panel.
80419>>>>>Use cProcessStatusPanel.pkg
80419>>>>>Use cCJSkinFramework.pkg
Including file: cCJSkinFramework.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJSkinFramework.pkg)
80419>>>>>>>Use windows.pkg
80419>>>>>>>Use cCJComSkinFramework.pkg
Including file: cCJComSkinFramework.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJComSkinFramework.pkg)
80419>>>>>>>>>// DataFlex COM proxy classes generated from C:\Program Files (x86)\Codejock Software\ActiveX\Xtreme SuitePro ActiveX v17.3.0\Bin\Codejock.SkinFramework.v17.3.0.ocx
80419>>>>>>>>>Use FlexCom20.pkg
80419>>>>>>>>>
80419>>>>>>>>>// Changes to Imported package
80419>>>>>>>>>//     OLEXTPxx to XTPxx
80419>>>>>>>>>//     OLExtpxx to xtpxx
80419>>>>>>>>>//     OLESkinFramework to SkinFramework
80419>>>>>>>>>//     OLESTDxxx and OLEXPxxxx to STD/XP
80419>>>>>>>>>//     cCom classes to cCJ
80419>>>>>>>>>//     cCJAutomationObject back to cComAutomationObject
80419>>>>>>>>>//     cCJActiveXControl back to cComActiveXControl
80419>>>>>>>>>//     cCJSkinFramework to cCJComSkinFramework
80419>>>>>>>>>//     Use statements as noted below (classes moved to these files)
80419>>>>>>>>>//     Set classlibrary of all cComAutomation objects to Windows (for class doc)
80419>>>>>>>>>
80419>>>>>>>>>// These have been extracted from this class and moved into seperate packages
80419>>>>>>>>>// because other Codejock classes use these.
80419>>>>>>>>>Use cCJColorManager.pkg     // cCJColorManager
80419>>>>>>>>>
80419>>>>>>>>>Define SkinFrameworkApplyOptions for Integer
80419>>>>>>>>>    Define xtpSkinApplyMetrics for 1
80419>>>>>>>>>    Define xtpSkinApplyFrame for 2
80419>>>>>>>>>    Define xtpSkinApplyColors for 4
80419>>>>>>>>>    Define xtpSkinApplyMenus for 8
80419>>>>>>>>>
80419>>>>>>>>>// CLSID: {AFA0E6A1-28D7-4F2C-87A7-7266367B4655}
80419>>>>>>>>>// Dispatch interface for SkinFramework Control
80419>>>>>>>>>Class cCJ_DSkinFramework is a Mixin
80420>>>>>>>>>
80420>>>>>>>>>    Function ComApplyOptions Returns SkinFrameworkApplyOptions
80422>>>>>>>>>        SkinFrameworkApplyOptions retVal
80422>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to retVal
80423>>>>>>>>>        Function_Return retVal
80424>>>>>>>>>    End_Function
80425>>>>>>>>>
80425>>>>>>>>>    Procedure Set ComApplyOptions SkinFrameworkApplyOptions value
80427>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to value
80428>>>>>>>>>    End_Procedure
80429>>>>>>>>>
80429>>>>>>>>>    Function ComAutoApplyNewWindows Returns Boolean
80431>>>>>>>>>        Boolean retVal
80431>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to retVal
80432>>>>>>>>>        Function_Return retVal
80433>>>>>>>>>    End_Function
80434>>>>>>>>>
80434>>>>>>>>>    Procedure Set ComAutoApplyNewWindows Boolean value
80436>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to value
80437>>>>>>>>>    End_Procedure
80438>>>>>>>>>
80438>>>>>>>>>    Function ComAutoApplyNewThreads Returns Boolean
80440>>>>>>>>>        Boolean retVal
80440>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to retVal
80441>>>>>>>>>        Function_Return retVal
80442>>>>>>>>>    End_Function
80443>>>>>>>>>
80443>>>>>>>>>    Procedure Set ComAutoApplyNewThreads Boolean value
80445>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to value
80446>>>>>>>>>    End_Procedure
80447>>>>>>>>>
80447>>>>>>>>>    Function ComLoadSkin String llResourcePath String llIniFileName Returns Boolean
80449>>>>>>>>>        Handle hDispatchDriver
80449>>>>>>>>>        Boolean retVal
80449>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80450>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
80451>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
80452>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
80453>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_BOOL to retVal
80454>>>>>>>>>        Function_Return retVal
80455>>>>>>>>>    End_Function
80456>>>>>>>>>
80456>>>>>>>>>    Procedure ComApplyWindow OLE_HANDLE llhWnd
80458>>>>>>>>>        Handle hDispatchDriver
80458>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80459>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
80460>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
80461>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 3 OLE_VT_VOID
80462>>>>>>>>>    End_Procedure
80463>>>>>>>>>
80463>>>>>>>>>    Procedure ComEnableThemeDialogTexture OLE_HANDLE llhWnd Integer llFlags
80465>>>>>>>>>        Handle hDispatchDriver
80465>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80466>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
80467>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
80468>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llFlags
80469>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 4 OLE_VT_VOID
80470>>>>>>>>>    End_Procedure
80471>>>>>>>>>
80471>>>>>>>>>    Procedure ComRemoveWindow OLE_HANDLE llhWnd
80473>>>>>>>>>        Handle hDispatchDriver
80473>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80474>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
80475>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
80476>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 6 OLE_VT_VOID
80477>>>>>>>>>    End_Procedure
80478>>>>>>>>>
80478>>>>>>>>>    Procedure ComRemoveAllWindows
80480>>>>>>>>>        Handle hDispatchDriver
80480>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80481>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 7 OLE_VT_VOID
80482>>>>>>>>>    End_Procedure
80483>>>>>>>>>
80483>>>>>>>>>    Procedure ComAddWindowClass String llClassName String llBaseClassName
80485>>>>>>>>>        Handle hDispatchDriver
80485>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80486>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
80487>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
80488>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llBaseClassName
80489>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 8 OLE_VT_VOID
80490>>>>>>>>>    End_Procedure
80491>>>>>>>>>
80491>>>>>>>>>    Procedure ComRemoveWindowClass String llClassName
80493>>>>>>>>>        Handle hDispatchDriver
80493>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80494>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
80495>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
80496>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 9 OLE_VT_VOID
80497>>>>>>>>>    End_Procedure
80498>>>>>>>>>
80498>>>>>>>>>    Function ComEnumerateSkinDirectory String llPath Boolean llRecursive Returns Variant
80500>>>>>>>>>        Handle hDispatchDriver
80500>>>>>>>>>        Variant retVal
80500>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80501>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
80502>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
80503>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BOOL llRecursive
80504>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 11 OLE_VT_DISPATCH to retVal
80505>>>>>>>>>        Function_Return retVal
80506>>>>>>>>>    End_Function
80507>>>>>>>>>
80507>>>>>>>>>    Function ComEnumerateSkinFile String llPath Returns Variant
80509>>>>>>>>>        Handle hDispatchDriver
80509>>>>>>>>>        Variant retVal
80509>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80510>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
80511>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
80512>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 12 OLE_VT_DISPATCH to retVal
80513>>>>>>>>>        Function_Return retVal
80514>>>>>>>>>    End_Function
80515>>>>>>>>>
80515>>>>>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
80517>>>>>>>>>        Handle hDispatchDriver
80517>>>>>>>>>        OLE_COLOR retVal
80517>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80518>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
80519>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
80520>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 14 OLE_VT_I4 to retVal
80521>>>>>>>>>        Function_Return retVal
80522>>>>>>>>>    End_Function
80523>>>>>>>>>
80523>>>>>>>>>    Procedure ComExcludeModule String llModuleName
80525>>>>>>>>>        Handle hDispatchDriver
80525>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80526>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
80527>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llModuleName
80528>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 15 OLE_VT_VOID
80529>>>>>>>>>    End_Procedure
80530>>>>>>>>>
80530>>>>>>>>>    Function ComCreateSchema String llResourcePath String llIniFileName Returns Variant
80532>>>>>>>>>        Handle hDispatchDriver
80532>>>>>>>>>        Variant retVal
80532>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80533>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
80534>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
80535>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
80536>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 16 OLE_VT_DISPATCH to retVal
80537>>>>>>>>>        Function_Return retVal
80538>>>>>>>>>    End_Function
80539>>>>>>>>>
80539>>>>>>>>>    Procedure ComSetWindowTheme OLE_HANDLE llhWnd Variant llSchema
80541>>>>>>>>>        Handle hDispatchDriver
80541>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80542>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
80543>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
80544>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llSchema
80545>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 17 OLE_VT_VOID
80546>>>>>>>>>    End_Procedure
80547>>>>>>>>>
80547>>>>>>>>>    Procedure ComAboutBox
80549>>>>>>>>>        Handle hDispatchDriver
80549>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80550>>>>>>>>>        Send InvokeComMethod to hDispatchDriver -552 OLE_VT_VOID
80551>>>>>>>>>    End_Procedure
80552>>>>>>>>>End_Class
80553>>>>>>>>>
80553>>>>>>>>>// CLSID: {40217CB8-4463-4030-B324-AC6A8075FEC8}
80553>>>>>>>>>// Event interface for SkinFramework Control
80553>>>>>>>>>Class cCJ_DSkinFrameworkEvents is a Mixin
80554>>>>>>>>>
80554>>>>>>>>>    Procedure RegisterComEvents
80556>>>>>>>>>    End_Procedure
80557>>>>>>>>>End_Class
80558>>>>>>>>>
80558>>>>>>>>>// CoClass
80558>>>>>>>>>// ProgID: Codejock.SkinFramework.17.3.0
80558>>>>>>>>>// CLSID: {DE67160B-9A3E-4EA6-846E-8C9A72F9F203}
80558>>>>>>>>>// SkinFramework Control
80558>>>>>>>>>Class cCJComSkinFramework is a cComActiveXControl
80559>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFramework
80560>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFrameworkEvents
80561>>>>>>>>>
80561>>>>>>>>>    Procedure Construct_Object
80563>>>>>>>>>        Forward Send Construct_Object
80565>>>>>>>>>        Set psProgID to "{DE67160B-9A3E-4EA6-846E-8C9A72F9F203}"
80566>>>>>>>>>        Set psEventId to "{40217CB8-4463-4030-B324-AC6A8075FEC8}"
80567>>>>>>>>>        Set psLicenseKey to ("Skin Framework Control Copyright (c) 1998-2016 Codejock Software"+ Character(13)+ Character(10)+;                             "PRODUCT-ID: Codejock.SkinFramework.ActiveX.v17.3"+ Character(13)+ Character(10)+;                             "VALIDATE-CODE: GGE-OLD-QQR-EJS")
80568>>>>>>>>>        Set peAutoCreate to acAutoCreate
80569>>>>>>>>>    End_Procedure
80570>>>>>>>>>End_Class
80571>>>>>>>>>
80571>>>>>>>>>// CLSID: {06E8A85B-70E4-4F71-A0FC-D1D5658C7E17}
80571>>>>>>>>>// SkinFramework Global Settings
80571>>>>>>>>>Class cCJISkinFrameworkGlobalSettings is a Mixin
80572>>>>>>>>>
80572>>>>>>>>>    Function ComLicense Returns String
80574>>>>>>>>>        String retVal
80574>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to retVal
80575>>>>>>>>>        Function_Return retVal
80576>>>>>>>>>    End_Function
80577>>>>>>>>>
80577>>>>>>>>>    Procedure Set ComLicense String value
80579>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to value
80580>>>>>>>>>    End_Procedure
80581>>>>>>>>>
80581>>>>>>>>>    Function ComTitle Returns String
80583>>>>>>>>>        String retVal
80583>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to retVal
80584>>>>>>>>>        Function_Return retVal
80585>>>>>>>>>    End_Function
80586>>>>>>>>>
80586>>>>>>>>>    Procedure Set ComTitle String value
80588>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to value
80589>>>>>>>>>    End_Procedure
80590>>>>>>>>>
80590>>>>>>>>>    Function ComVersion Returns String
80592>>>>>>>>>        Handle hDispatchDriver
80592>>>>>>>>>        String retVal
80592>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80593>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 104 OLE_VT_BSTR to retVal
80594>>>>>>>>>        Function_Return retVal
80595>>>>>>>>>    End_Function
80596>>>>>>>>>
80596>>>>>>>>>    Function ComUnicode Returns Boolean
80598>>>>>>>>>        Handle hDispatchDriver
80598>>>>>>>>>        Boolean retVal
80598>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80599>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 105 OLE_VT_BOOL to retVal
80600>>>>>>>>>        Function_Return retVal
80601>>>>>>>>>    End_Function
80602>>>>>>>>>
80602>>>>>>>>>    Function ComOcxPath Returns String
80604>>>>>>>>>        Handle hDispatchDriver
80604>>>>>>>>>        String retVal
80604>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80605>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 106 OLE_VT_BSTR to retVal
80606>>>>>>>>>        Function_Return retVal
80607>>>>>>>>>    End_Function
80608>>>>>>>>>End_Class
80609>>>>>>>>>
80609>>>>>>>>>// CoClass
80609>>>>>>>>>// ProgID: Codejock.SkinFrameworkGlobalSettings.17.3.0
80609>>>>>>>>>// CLSID: {C4136A4A-67FD-4FC1-BA62-A715B4D60808}
80609>>>>>>>>>// SkinFramework Global Settings
80609>>>>>>>>>Class cCJComSkinFrameworkGlobalSettings is a cComAutomationObject
80610>>>>>>>>>    Import_Class_Protocol cCJISkinFrameworkGlobalSettings
80611>>>>>>>>>
80611>>>>>>>>>    Procedure Construct_Object
80613>>>>>>>>>        Forward Send Construct_Object
80615>>>>>>>>>        Set psProgID to "{C4136A4A-67FD-4FC1-BA62-A715B4D60808}"
80616>>>>>>>>>        Set peAutoCreate to acNoAutoCreate
80617>>>>>>>>>    End_Procedure
80618>>>>>>>>>End_Class
80619>>>>>>>>>
80619>>>>>>>>>// CLSID: {27E4AC9B-4A2D-4FBB-A782-BD76BEFA4345}
80619>>>>>>>>>Class cCJSkinIniFile is a cComAutomationObject
80620>>>>>>>>>
80620>>>>>>>>>    Function ComColorScheme Returns String
80622>>>>>>>>>        String retVal
80622>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
80623>>>>>>>>>        Function_Return retVal
80624>>>>>>>>>    End_Function
80625>>>>>>>>>
80625>>>>>>>>>    Procedure Set ComColorScheme String value
80627>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
80628>>>>>>>>>    End_Procedure
80629>>>>>>>>>
80629>>>>>>>>>    Function ComFontSize Returns String
80631>>>>>>>>>        String retVal
80631>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
80632>>>>>>>>>        Function_Return retVal
80633>>>>>>>>>    End_Function
80634>>>>>>>>>
80634>>>>>>>>>    Procedure Set ComFontSize String value
80636>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
80637>>>>>>>>>    End_Procedure
80638>>>>>>>>>
80638>>>>>>>>>    Function ComIniFileName Returns String
80640>>>>>>>>>        String retVal
80640>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to retVal
80641>>>>>>>>>        Function_Return retVal
80642>>>>>>>>>    End_Function
80643>>>>>>>>>
80643>>>>>>>>>    Procedure Set ComIniFileName String value
80645>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to value
80646>>>>>>>>>    End_Procedure
80647>>>>>>>>>End_Class
80648>>>>>>>>>
80648>>>>>>>>>// CLSID: {5005F22B-A30E-4B12-B142-E97F62A927A6}
80648>>>>>>>>>Class cCJSkinDescription is a cComAutomationObject
80649>>>>>>>>>
80649>>>>>>>>>    Function ComName Returns String
80651>>>>>>>>>        String retVal
80651>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
80652>>>>>>>>>        Function_Return retVal
80653>>>>>>>>>    End_Function
80654>>>>>>>>>
80654>>>>>>>>>    Procedure Set ComName String value
80656>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
80657>>>>>>>>>    End_Procedure
80658>>>>>>>>>
80658>>>>>>>>>    Function ComPath Returns String
80660>>>>>>>>>        String retVal
80660>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
80661>>>>>>>>>        Function_Return retVal
80662>>>>>>>>>    End_Function
80663>>>>>>>>>
80663>>>>>>>>>    Procedure Set ComPath String value
80665>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
80666>>>>>>>>>    End_Procedure
80667>>>>>>>>>
80667>>>>>>>>>    Function ComCount Returns Integer
80669>>>>>>>>>        Handle hDispatchDriver
80669>>>>>>>>>        Integer retVal
80669>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80670>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
80671>>>>>>>>>        Function_Return retVal
80672>>>>>>>>>    End_Function
80673>>>>>>>>>
80673>>>>>>>>>    Function ComIniFile Integer llIndex Returns Variant
80675>>>>>>>>>        Handle hDispatchDriver
80675>>>>>>>>>        Variant retVal
80675>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80676>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
80677>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
80678>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
80679>>>>>>>>>        Function_Return retVal
80680>>>>>>>>>    End_Function
80681>>>>>>>>>
80681>>>>>>>>>    Function Com_NewEnum Returns Variant
80683>>>>>>>>>        Handle hDispatchDriver
80683>>>>>>>>>        Variant retVal
80683>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80684>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
80685>>>>>>>>>        Function_Return retVal
80686>>>>>>>>>    End_Function
80687>>>>>>>>>End_Class
80688>>>>>>>>>
80688>>>>>>>>>// CLSID: {C4367A33-2A7C-4CC6-BF0C-C50383B34B51}
80688>>>>>>>>>Class cCJSkinDescriptions is a cComAutomationObject
80689>>>>>>>>>
80689>>>>>>>>>    Function ComCount Returns Integer
80691>>>>>>>>>        Handle hDispatchDriver
80691>>>>>>>>>        Integer retVal
80691>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80692>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
80693>>>>>>>>>        Function_Return retVal
80694>>>>>>>>>    End_Function
80695>>>>>>>>>
80695>>>>>>>>>    Function ComSkin Integer llIndex Returns Variant
80697>>>>>>>>>        Handle hDispatchDriver
80697>>>>>>>>>        Variant retVal
80697>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80698>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
80699>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
80700>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
80701>>>>>>>>>        Function_Return retVal
80702>>>>>>>>>    End_Function
80703>>>>>>>>>
80703>>>>>>>>>    Function Com_NewEnum Returns Variant
80705>>>>>>>>>        Handle hDispatchDriver
80705>>>>>>>>>        Variant retVal
80705>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80706>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
80707>>>>>>>>>        Function_Return retVal
80708>>>>>>>>>    End_Function
80709>>>>>>>>>End_Class
80710>>>>>>>>>
80710>>>>>>>>>// CLSID: {128507E0-C56F-43C0-BCF1-8193B35FE4C4}
80710>>>>>>>>>Class cCJSkinSchema is a cComAutomationObject
80711>>>>>>>>>End_Class
80712>>>>>>>Use cApplication.pkg
80712>>>>>>>
80712>>>>>>>Struct tSkinInformation
80712>>>>>>>    String sName     // description of the skin
80712>>>>>>>    String sSkinfile // file path. Can be relative or full
80712>>>>>>>    String sSkinIni  // section name
80712>>>>>>>End_Struct
80712>>>>>>>
80712>>>>>>>
80712>>>>>>>Class cCJSkinFramework is a cCJComSkinFramework
80713>>>>>>>    
80713>>>>>>>    Procedure Construct_Object
80715>>>>>>>        Forward Send Construct_Object
80717>>>>>>>        
80717>>>>>>>        Property String psSkinFile ""
80718>>>>>>>        Property String psSkinIni ""
80719>>>>>>>        Property Boolean pbLoadPreference False
80720>>>>>>>        
80720>>>>>>>        Set peAutoCreate to acAutoCreate
80721>>>>>>>        
80721>>>>>>>        Move Self to ghoSkinFramework
80722>>>>>>>    End_Procedure
80723>>>>>>>    
80723>>>>>>>    // return the default skin path, which is the programs directory.
80723>>>>>>>    // This requires an application object.
80723>>>>>>>    // If you want to different skin path, override this.
80723>>>>>>>    Function SkinPath Returns String
80725>>>>>>>        String sPath sPaths
80725>>>>>>>        Handle hoWorkspace
80725>>>>>>>        If ghoApplication Begin
80727>>>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
80728>>>>>>>            Get psProgramPath of hoWorkspace to sPaths
80729>>>>>>>            Get PathAtIndex of hoWorkspace sPaths 1 to sPath
80730>>>>>>>        End
80730>>>>>>>>
80730>>>>>>>        Else Begin
80731>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
80732>>>>>>>>
80732>>>>>>>        End
80732>>>>>>>>
80732>>>>>>>        Function_Return sPath
80733>>>>>>>    End_Function
80734>>>>>>>    
80734>>>>>>>    // Returns the Qualified name of psSkinFile. If the file is already qualified it just
80734>>>>>>>    // returns itself. If it is not, it uses SkinPath to get the path.
80734>>>>>>>    Function SkinQFile Returns String
80736>>>>>>>        String sFile sPath sSep
80736>>>>>>>        Boolean bQualified
80736>>>>>>>        Get psSkinFile to sFile
80737>>>>>>>        If not (IsFileNameQualified(sFile)) Begin
80739>>>>>>>            Get SkinPath to sPath
80740>>>>>>>            Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
80741>>>>>>>            Move (sPath - sSep - sFile) to sFile
80742>>>>>>>        End
80742>>>>>>>>
80742>>>>>>>        Function_Return sFile
80743>>>>>>>    End_Function
80744>>>>>>>        
80744>>>>>>>    // defines the default VDF window class mapping.    
80744>>>>>>>    Procedure OnAddVDFWindowClasses
80746>>>>>>>        Send ComAddWindowClass "DFlistbox"               "ListBox"
80747>>>>>>>        Send ComAddWindowClass "DFentry"                 "Edit"
80748>>>>>>>        Send ComAddWindowClass "DFtextbox"               "Edit"
80749>>>>>>>        Send ComAddWindowClass "DFRichEditCtrl"          "Edit"
80750>>>>>>>        Send ComAddWindowClass "DFcombobox"              "ComboBox"
80751>>>>>>>        Send ComAddWindowClass "DFformlist"              "Edit"
80752>>>>>>>        Send ComAddWindowClass "DFFormListHeader"        "SysHeader32"
80753>>>>>>>        Send ComAddWindowClass "DFbutton"                "Button"
80754>>>>>>>        Send ComAddWindowClass "HPromptBtn"              "Button"
80755>>>>>>>        Send ComAddWindowClass "Hspinbtn"                "msctls_updown32"
80756>>>>>>>        Send ComAddWindowClass "DFSysTabControl32"       "SysTabControl32"
80757>>>>>>>        Send ComAddWindowClass "DFMDIClient"             "MDIClient" 
80758>>>>>>>        Send ComAddWindowClass "DFedit"                  "edit"
80759>>>>>>>        Send ComAddWindowClass "DFlistedit"              "edit"
80760>>>>>>>        Send ComAddWindowClass "DFscrollbar"             "scrollbar"
80761>>>>>>>        Send ComAddWindowClass "DFgroup"                 "Button"
80762>>>>>>>        Send ComAddWindowClass "DFComboGrid"             "ComboBox"
80763>>>>>>>        // External class
80763>>>>>>>        Send ComAddWindowClass "cVdfAnimation"           "SysAnimate32"
80764>>>>>>>        Send ComAddWindowClass "cVdfProgressBar"         "msctls_progress32"
80765>>>>>>>        Send ComAddWindowClass "cVdfStatusBar"           "msctls_statusbar32"
80766>>>>>>>        Send ComAddWindowClass "cVdfToolbar"             "ToolbarWindow32"
80767>>>>>>>        Send ComAddWindowClass "cObsoleteVdfProgressBar" "msctls_progress32"
80768>>>>>>>        Send ComAddWindowClass "cVdfTrackBar"            "msctls_trackbar32"
80769>>>>>>>        Send ComAddWindowClass "cObsoleteBasicStatusBar" "msctls_statusbar32"
80770>>>>>>>        Send ComAddWindowClass "cVdfTreeView"            "SysTreeView32"
80771>>>>>>>    End_Procedure
80772>>>>>>>    
80772>>>>>>>    // Used to support developer designed class mappings (e.g. COM controls)
80772>>>>>>>    Procedure OnAddCustomWindowClasses
80774>>>>>>>    End_Procedure
80775>>>>>>>
80775>>>>>>>    // called when object is created during end_construct_object.
80775>>>>>>>    Procedure OnCreate
80777>>>>>>>        Integer iOpts
80777>>>>>>>        Boolean bUseWindowsFont
80777>>>>>>>        Forward Send OnCreate
80779>>>>>>>        
80779>>>>>>>        // if we are using the windows fonts we will disable the apply metrics which
80779>>>>>>>        // never really looked good anyway. This test only exists or legacy purposes
80779>>>>>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
80780>>>>>>>        If bUseWindowsFont Begin
80782>>>>>>>            Get ComApplyOptions to iOpts
80783>>>>>>>            Set ComApplyOptions to (RemoveBitValue(xtpSkinApplyMetrics, iOpts))
80784>>>>>>>        End
80784>>>>>>>>
80784>>>>>>>
80784>>>>>>>        // this works around a CJ issue where skins applied to other threads causes an exception upon close down. 
80784>>>>>>>        // We saw this with our mssql driver but it could occur elsewhere. This has been reported in the CJ newsgroup
80784>>>>>>>        // and this was the suggested workaround.
80784>>>>>>>        Set ComAutoApplyNewThreads to False
80785>>>>>>>
80785>>>>>>>        Send OnAddVDFWindowClasses
80786>>>>>>>        Send OnAddCustomWindowClasses
80787>>>>>>>        
80787>>>>>>>        // if preferences are used, it will set psSkinFile and psSkinIni
80787>>>>>>>        If (pbLoadPreference(Self)) Begin
80789>>>>>>>            Send LoadSkinPreference
80790>>>>>>>        End
80790>>>>>>>>
80790>>>>>>>        // if a skin file name exists, we apply the skin.    
80790>>>>>>>        If (psSkinFile(Self)<>"") Begin
80792>>>>>>>            Send ApplySkin
80793>>>>>>>        End        
80793>>>>>>>>
80793>>>>>>>    End_Procedure
80794>>>>>>>    
80794>>>>>>>    // called by framework as part of application exit.
80794>>>>>>>    Procedure Broadcast_Notify_Exit_Application
80796>>>>>>>        Send Notify_Exit_Application
80797>>>>>>>    End_Procedure // Notify_Exit_Application
80798>>>>>>>
80798>>>>>>>    Procedure Notify_Exit_Application
80800>>>>>>>        If (pbLoadPreference(Self)) Begin
80802>>>>>>>            Send SaveSkinPreference
80803>>>>>>>        End
80803>>>>>>>>
80803>>>>>>>    End_Procedure
80804>>>>>>>
80804>>>>>>>    Procedure NotifyPreApplySkin
80806>>>>>>>        Broadcast Send OnPreApplySkin of Desktop True       
80808>>>>>>>    End_Procedure
80809>>>>>>>
80809>>>>>>>    Procedure NotifyPostApplySkin
80811>>>>>>>        Broadcast Send OnPostApplySkin of Desktop True       
80813>>>>>>>    End_Procedure
80814>>>>>>>    
80814>>>>>>>    // returns an array of all skins in the path. If path is "", use the default path.
80814>>>>>>>    // If the default path is used, returns the file names as relative names, else use full path.
80814>>>>>>>    Function EnumerateSkins String sPath Boolean bRecursive Returns tSkinInformation[]
80816>>>>>>>        tSkinInformation[] Skins
80816>>>>>>>        tSkinInformation[] Skins
80817>>>>>>>        String sSkinName sSkinFile sDefaultPath sSep
80817>>>>>>>        Variant vSkinDescriptions vSkinDescription vSkinIniFile
80817>>>>>>>        Handle hSkinDescriptions hSkinDescription hSkinIniFile
80817>>>>>>>        Integer iSkinsCount iSkinFilesCount iNumSkins iNumSkinFiles iArrayItem
80817>>>>>>>        Integer iPos iDfltLen
80817>>>>>>>        Boolean bUseRelativePath
80817>>>>>>>        
80817>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
80818>>>>>>>        
80818>>>>>>>        Get SkinPath to sDefaultPath
80819>>>>>>>        If (sPath="") Begin
80821>>>>>>>            Move sDefaultPath to sPath
80822>>>>>>>        End
80822>>>>>>>>
80822>>>>>>>        Move (Uppercase(sDefaultPath)) to sDefaultPath
80823>>>>>>>        Move (Length(sDefaultPath)) to iDfltLen
80824>>>>>>>        Move (sDefaultPath=Uppercase(sPath)) to bUseRelativePath
80825>>>>>>>
80825>>>>>>>        Get ComEnumerateSkinDirectory sPath bRecursive to vSkinDescriptions
80826>>>>>>>        If (not(IsNullComObject(vSkinDescriptions))) Begin
80828>>>>>>>
80828>>>>>>>            Get Create U_cCJSkinDescriptions to hSkinDescriptions
80829>>>>>>>            Get Create U_cCJSkinDescription to hSkinDescription
80830>>>>>>>            Get Create U_cCJSkinIniFile to hSkinIniFile
80831>>>>>>>            
80831>>>>>>>            Set pvComObject of hSkinDescriptions to vSkinDescriptions
80832>>>>>>>            Get ComCount of hSkinDescriptions to iNumSkinFiles
80833>>>>>>>            
80833>>>>>>>            For iSkinFilesCount from 0 to (iNumSkinFiles-1)
80839>>>>>>>>
80839>>>>>>>                Get ComSkin of hSkinDescriptions iSkinFilesCount to vSkinDescription
80840>>>>>>>                Set pvComObject of hSkinDescription to vSkinDescription
80841>>>>>>>
80841>>>>>>>                Get ComCount of hSkinDescription to iNumSkins
80842>>>>>>>                    
80842>>>>>>>                For iSkinsCount from 0 to (iNumSkins-1)
80848>>>>>>>>
80848>>>>>>>                    Get ComIniFile of hSkinDescription iSkinsCount to vSkinIniFile
80849>>>>>>>                    Set pvComObject of hSkinIniFile to vSkinIniFile
80850>>>>>>>
80850>>>>>>>                    Get ComName of hSkinDescription to Skins[iArrayItem].sName
80851>>>>>>>                    Get ComPath of hSkinDescription to sSkinFile
80852>>>>>>>                    If bUseRelativePath Begin
80854>>>>>>>                        Move (pos(sDefaultPath,uppercase(sSkinFile))) to iPos
80855>>>>>>>                        If iPos Begin
80857>>>>>>>                            Move (Remove(sSkinFile,iPos,iDfltLen)) to sSkinFile   
80858>>>>>>>                            While (Left(sSkinFile,1)=sSep)
80862>>>>>>>                                Move (Remove(sSkinFile,1,1)) to sSkinFile   
80863>>>>>>>                            Loop                         
80864>>>>>>>>
80864>>>>>>>                        End
80864>>>>>>>>
80864>>>>>>>                    End
80864>>>>>>>>
80864>>>>>>>                    Move sSkinFile to Skins[iArrayItem].sSkinfile
80865>>>>>>>                    Get ComIniFileName of hSkinIniFile to Skins[iArrayItem].sSkinIni
80866>>>>>>>
80866>>>>>>>                    Increment iArrayItem
80867>>>>>>>                Loop
80868>>>>>>>>
80868>>>>>>>            Loop
80869>>>>>>>>
80869>>>>>>>                            
80869>>>>>>>            Send Destroy of hSkinDescriptions
80870>>>>>>>            Send Destroy of hSkinDescription
80871>>>>>>>            Send Destroy of hSkinIniFile
80872>>>>>>>                
80872>>>>>>>        End
80872>>>>>>>>
80872>>>>>>>        Function_Return Skins
80873>>>>>>>    End_Function 
80874>>>>>>>    
80874>>>>>>>    // Save the skin preference. This requires an application object.
80874>>>>>>>    // Only do this if the application object allows it. 
80874>>>>>>>    // This is called during startup if pbLoadPreference is True
80874>>>>>>>    // Suitable for override
80874>>>>>>>    Procedure SaveSkinPreference 
80876>>>>>>>        String sSkin sIni
80876>>>>>>>        If ghoApplication Begin
80878>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
80880>>>>>>>                Get psSkinFile to sSkin
80881>>>>>>>                Get psSkinIni to sIni
80882>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinFile" sSkin
80883>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinIni" sIni
80884>>>>>>>            End
80884>>>>>>>>
80884>>>>>>>        End
80884>>>>>>>>
80884>>>>>>>        Else Begin
80885>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
80886>>>>>>>>
80886>>>>>>>        End
80886>>>>>>>>
80886>>>>>>>    End_Procedure
80887>>>>>>>
80887>>>>>>>    // Load the skin preference. This requires an application object.
80887>>>>>>>    // Only do this if the application object allows it. 
80887>>>>>>>    // This is called during startup if pbLoadPreference is True
80887>>>>>>>    // Suitable for override
80887>>>>>>>    Procedure LoadSkinPreference 
80889>>>>>>>        String sSkin sIni
80889>>>>>>>        Boolean bExists
80889>>>>>>>        If ghoApplication Begin
80891>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
80893>>>>>>>                Get ValueExists of ghoApplication "Preferences" "SkinFile" to bExists
80894>>>>>>>                If bExists Begin
80896>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinFile" "" to sSkin
80897>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinIni" "" to sIni
80898>>>>>>>                    Set psSkinFile to sSkin
80899>>>>>>>                    Set psSkinIni to sIni
80900>>>>>>>                End
80900>>>>>>>>
80900>>>>>>>            End
80900>>>>>>>>
80900>>>>>>>        End
80900>>>>>>>>
80900>>>>>>>        Else Begin
80901>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
80902>>>>>>>>
80902>>>>>>>        End
80902>>>>>>>>
80902>>>>>>>    End_Procedure
80903>>>>>>>
80903>>>>>>>    // Can be called to apply the current skin.
80903>>>>>>>    Procedure ApplySkin
80905>>>>>>>        Boolean bOk
80905>>>>>>>        String sSkin sIni
80905>>>>>>>        If (IsComObjectCreated(Self)) Begin
80907>>>>>>>            Get SkinQFile to sSkin
80908>>>>>>>            Get psSkinIni to sIni
80909>>>>>>>            
80909>>>>>>>            Send NotifyPreApplySkin
80910>>>>>>>            // when skins are used we don't want to use built in Visual Styles
80910>>>>>>>            Send EnableVisualStyles of Desktop (sSkin="")
80911>>>>>>>            Get ComLoadSkin sSkin sIni to bOK
80912>>>>>>>            If (sSkin<>"" and not(bOk)) Begin
80914>>>>>>>                // if not ok, no skin was appied. Enable visual styles
80914>>>>>>>                Send EnableVisualStyles of Desktop True
80915>>>>>>>            End
80915>>>>>>>>
80915>>>>>>>            Send NotifyPostApplySkin
80916>>>>>>>        End
80916>>>>>>>>
80916>>>>>>>    End_Procedure
80917>>>>>>>
80917>>>>>>>
80917>>>>>>>End_Class
80918>>>>>Use cProgressBar.pkg
Including file: cProgressBar.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cProgressBar.pkg)
80918>>>>>>>Use Windows.pkg
80918>>>>>>>Use cWinControl.pkg
80918>>>>>>>Use CommCtrl.pkg
80918>>>>>>>
80918>>>>>>>Type tPbRange
80918>>>>>>>    Field tPbRange.iLow  as DWord
80918>>>>>>>    Field tPbRange.iHigh as DWord
80918>>>>>>>End_Type
80918>>>>>>>
80918>>>>>>>//{ OverrideProperty=pbEnabled DesignTime=False }
80918>>>>>>>Class cProgressBar is a cWinControl
80919>>>>>>>
80919>>>>>>>    Procedure Construct_Object
80921>>>>>>>        Forward Send Construct_Object
80923>>>>>>>        Property Integer private_piMinimum
80924>>>>>>>        Property Integer private_piMaximum   100
80925>>>>>>>        Property Integer private_piAdvanceBy 10
80926>>>>>>>        Property Integer private_piPosition
80927>>>>>>>        Property Integer private_pbVertical  False
80928>>>>>>>        Property Integer private_pbSmooth    False
80929>>>>>>>        Property Integer private_piBackColor clDefault
80930>>>>>>>        Property Integer private_piBarColor  clDefault
80931>>>>>>>
80931>>>>>>>        Send Define_ToolTip_Support_Mixin
80932>>>>>>>
80932>>>>>>>        Set External_Class_Name 'cVdfProgressBar' To 'msctls_progress32'
80933>>>>>>>        Set Focus_Mode to NonFocusable
80934>>>>>>>        Set Skip_State to True
80935>>>>>>>        Set pbUseFormWindowHandle to False     // Must come after Define_ToolTip_Support_Mixin
80936>>>>>>>    End_Procedure
80937>>>>>>>
80937>>>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
80938>>>>>>>
80938>>>>>>>    Procedure Set piMinimum Integer iMin
80940>>>>>>>        Integer iMax
80940>>>>>>>
80940>>>>>>>        Set private_piMinimum to iMin
80941>>>>>>>        Get private_piMaximum To iMax
80942>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
80943>>>>>>>    End_Procedure
80944>>>>>>>    Function piMinimum Returns Integer
80946>>>>>>>        If (Window_Handle(self)) Function_Return (WindowsMessage(PBM_GETRANGE, 1, 0))
80949>>>>>>>        Else Function_Return (private_piMinimum(self))
80951>>>>>>>    End_Function
80952>>>>>>>
80952>>>>>>>    Procedure Set piMaximum Integer iMax
80954>>>>>>>        Integer iMin
80954>>>>>>>
80954>>>>>>>        Set private_piMaximum to iMax
80955>>>>>>>        Get private_piMinimum To iMin
80956>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
80957>>>>>>>    End_Procedure
80958>>>>>>>    Function piMaximum Returns Integer
80960>>>>>>>        If (Window_Handle(self)) Function_Return (WindowsMessage(PBM_GETRANGE, 0, 0))
80963>>>>>>>        Else Function_Return (private_piMaximum(self))
80965>>>>>>>    End_Function
80966>>>>>>>
80966>>>>>>>    Procedure Set piAdvanceBy Integer iAdvanceBy
80968>>>>>>>        Set private_piAdvanceBy To iAdvanceBy
80969>>>>>>>        Send Windows_Message PBM_SETSTEP iAdvanceBy 0
80970>>>>>>>    End_Procedure
80971>>>>>>>    Function piAdvanceBy Returns Integer
80973>>>>>>>        Function_Return (private_piAdvanceBy(self))
80974>>>>>>>    End_Function
80975>>>>>>>
80975>>>>>>>    Procedure Set piPosition Integer iPos
80977>>>>>>>        Set private_piPosition To iPos
80978>>>>>>>        Send Windows_Message PBM_SETPOS iPos 0
80979>>>>>>>    End_Procedure
80980>>>>>>>
80980>>>>>>>    Function piPosition Returns Integer
80982>>>>>>>        If (Window_Handle(self)) Function_Return (WindowsMessage(PBM_GETPOS, 0, 0))
80985>>>>>>>        Else Function_Return (private_piPosition(self))
80987>>>>>>>    End_Function
80988>>>>>>>
80988>>>>>>>    Procedure Set pbVertical Boolean bVertical
80990>>>>>>>        If (private_pbVertical(self) <> bVertical) Begin
80992>>>>>>>            Set private_pbVertical To bVertical
80993>>>>>>>           Send DoRecreateWindow
80994>>>>>>>        End
80994>>>>>>>>
80994>>>>>>>    End_Procedure
80995>>>>>>>
80995>>>>>>>    Function pbVertical Returns Boolean
80997>>>>>>>        Function_Return (private_pbVertical(self))
80998>>>>>>>    End_Function
80999>>>>>>>
80999>>>>>>>    Procedure Set pbSmooth Boolean bSmooth
81001>>>>>>>        If (private_pbSmooth(self) <> bSmooth) Begin
81003>>>>>>>           Set private_pbSmooth To bSmooth
81004>>>>>>>           Send DoRecreateWindow
81005>>>>>>>        End
81005>>>>>>>>
81005>>>>>>>    End_Procedure
81006>>>>>>>    Function pbSmooth Returns Boolean
81008>>>>>>>        Function_Return (private_pbSmooth(self))
81009>>>>>>>    End_Function
81010>>>>>>>
81010>>>>>>>    Procedure Set piBackColor Integer rgbColor
81012>>>>>>>        Set private_piBackColor To rgbColor
81013>>>>>>>        Send Windows_Message PBM_SETBKCOLOR 0 rgbColor
81014>>>>>>>    End_Procedure
81015>>>>>>>    Function piBackColor Returns Integer
81017>>>>>>>        Function_Return (private_piBackColor(self))
81018>>>>>>>    End_Function
81019>>>>>>>
81019>>>>>>>    Procedure Set piBarColor Integer rgbColor
81021>>>>>>>        Set private_piBarColor To rgbColor
81022>>>>>>>        Send Windows_Message PBM_SETBARCOLOR 0 rgbColor
81023>>>>>>>    End_Procedure
81024>>>>>>>    Function piBarColor Returns Integer
81026>>>>>>>        Function_Return (private_piBarColor(self))
81027>>>>>>>    End_Function
81028>>>>>>>
81028>>>>>>>    Procedure DoAdvance
81030>>>>>>>        Send Windows_Message PBM_STEPIT 0 0
81031>>>>>>>    End_procedure
81032>>>>>>>
81032>>>>>>>    Procedure DoAdvanceBy  Integer iAdvanceBy
81034>>>>>>>        Send Windows_Message PBM_DELTAPOS iAdvanceBy 0
81035>>>>>>>    End_procedure
81036>>>>>>>
81036>>>>>>>    Procedure private_DoInitWindow
81038>>>>>>>        Set piBarColor  To (private_piBarColor(self))
81039>>>>>>>        Set piBackColor To (private_piBackColor(self))
81040>>>>>>>        Set piAdvanceBy To (private_piAdvanceBy(self))
81041>>>>>>>        Set piMinimum   To (private_piMinimum(self))
81042>>>>>>>        Set piMaximum   To (private_piMaximum(self))
81043>>>>>>>        Set piPosition  To (private_piPosition(self))
81044>>>>>>>    End_Procedure
81045>>>>>>>
81045>>>>>>>    Procedure Page_Object Integer iState
81047>>>>>>>        Handle hWnd
81047>>>>>>>
81047>>>>>>>        Get Window_Handle To hWnd
81048>>>>>>>        If (hWnd=0 and iState) Begin
81050>>>>>>>            Set Window_Style To PBS_VERTICAL (private_pbVertical(self))
81051>>>>>>>            Set Window_Style To PBS_SMOOTH   (private_pbSmooth(self))
81052>>>>>>>            Forward Send Page_Object True
81054>>>>>>>        End
81054>>>>>>>>
81054>>>>>>>        Else Forward Send Page_Object iState
81057>>>>>>>     
81057>>>>>>>        // Handle tooltip support....
81057>>>>>>>        If (iState = 0) Begin
81059>>>>>>>            Send RequestDeleteToolTip
81060>>>>>>>        End 
81060>>>>>>>>
81060>>>>>>>        Else Begin
81061>>>>>>>            Send RequestAddToolTip
81062>>>>>>>        End
81062>>>>>>>>
81062>>>>>>>    End_Procedure
81063>>>>>>>
81063>>>>>>>    Procedure Page Integer iState
81065>>>>>>>        Forward Send Page iState
81067>>>>>>>        If (iState =1) Send private_DoInitWindow
81070>>>>>>>    End_Procedure
81071>>>>>>>
81071>>>>>>>    // Called by Page_Object. Handles tooltip creation. We use a dedicated
81071>>>>>>>    // method to perform AddToolTip because it is often the case that Page_Object
81071>>>>>>>    // is implemented in a mixin class.
81071>>>>>>>    Procedure RequestAddToolTip
81073>>>>>>>        Send AddToolTip
81074>>>>>>>    End_Procedure  // RequestAddToolTip
81075>>>>>>>
81075>>>>>>>
81075>>>>>>>    // Called by Page_Object. Handles tooltip removal. 
81075>>>>>>>    Procedure RequestDeleteToolTip
81077>>>>>>>        Send DeleteToolTip
81078>>>>>>>    End_Procedure // RequestDeleteToolTip
81079>>>>>>>End_Class
81080>>>>>Use Windows.pkg
81080>>>>>
81080>>>>>
81080>>>>>    Global_Variable Handle ghoProgressBar // will contain the ID of the embedded progress bar.
81080>>>>>
81080>>>>>    Global_Variable Handle ghoProgressBarOverall // will contain the ID of the embedded progress bar with overall results
81080>>>>>
81080>>>>>Object Status_Panel is a cProcessStatusPanel
81082>>>>>    Set Size to 148 222
81083>>>>>    Set Border_Style to Border_Dialog
81084>>>>>//    Set Sysmenu_Icon to False
81084>>>>>//    Set Icon to "DbUpdateFrameworkdf19.ico" 
81084>>>>>    Set Icon to "Default.ico"
81085>>>>>    Move Self to ghoStatusPanel // this can be used throughout the applicaton to access this object
81086>>>>>
81086>>>>>    Property Boolean Cancel_Button_Visible_State True
81088>>>>>
81088>>>>>    Procedure Activate
81091>>>>>        Integer iSizeBefore
81091>>>>>        Get GuiSize to iSizeBefore
81092>>>>>        Forward Send Activate
81094>>>>>        Set GuiSize to (Hi(iSizeBefore)) (Low(iSizeBefore))
81095>>>>>    End_Procedure
81096>>>>>
81096>>>>>    Procedure End_Construct_Object
81099>>>>>        Forward Send End_Construct_Object
81101>>>>>        Set Label of oTitleTxt      to ""
81102>>>>>        Set Label of oTableNameTxt  to ""
81103>>>>>        Set Label of oMessageTxt    to ""
81104>>>>>        Set Label of oActionTxt     to ""
81105>>>>>    End_Procedure
81106>>>>>
81106>>>>>    Object oTitleTxt is a TextBox
81108>>>>>        Set Location to 5 21
81109>>>>>        Set Size to 8 179
81110>>>>>        Set Auto_Size_State to False
81111>>>>>        Set Justification_Mode  to jMode_Center
81112>>>>>        Set Label to "This is the Title Text"
81113>>>>>    End_Object
81114>>>>>
81114>>>>>    Object oTableNameTxt is a TextBox
81116>>>>>        Set Size to 19 204
81117>>>>>        Set Location to 18 9
81118>>>>>        Set Auto_Size_State to False
81119>>>>>        Set Justification_Mode to JMode_Left
81120>>>>>        Set Label to "This is the TableName Text"
81121>>>>>    End_Object
81122>>>>>
81122>>>>>    Object oMessageTxt is a TextBox
81124>>>>>        Set Location to 39 9
81125>>>>>        Set Size to 19 204
81126>>>>>        Set Auto_Size_State to False
81127>>>>>        Set Justification_Mode to JMode_Left
81128>>>>>        Set Label to "This is the Message text"
81129>>>>>    End_Object
81130>>>>>
81130>>>>>    Object oActionTxt is a TextBox
81132>>>>>        Set Size to 16 204
81133>>>>>        Set Location to 60 9
81134>>>>>        Set Auto_Size_State to False
81135>>>>>        Set Justification_Mode to JMode_Left
81136>>>>>        Set Label to "This is the Action Text"
81137>>>>>    End_Object
81138>>>>>
81138>>>>>    Object oStopButton is a Button
81140>>>>>        Set Location to 120 82
81141>>>>>        Set Label to C_$Cancel
81142>>>>>
81142>>>>>        Procedure OnClick
81145>>>>>            Send Close_panel
81146>>>>>        End_Procedure
81147>>>>>
81147>>>>>    End_Object
81148>>>>>
81148>>>>>    Object oPercentage_tb is a TextBox
81150>>>>>        Set Location to 74 196
81151>>>>>        Set Size to 10 25
81152>>>>>//        Set Label to "% Done"
81152>>>>>    End_Object
81153>>>>>
81153>>>>>    Object oCopyRight is a TextBox
81155>>>>>        Set Location to 137 21
81156>>>>>        Set Size to 9 197
81157>>>>>        Set FontPointHeight to 8
81158>>>>>        Set Auto_Size_State to False
81159>>>>>        Set Justification_Mode  to jMode_Center
81160>>>>>        Set Label to "Copyright 2001-2018 RDC Tools International"
81161>>>>>    End_Object
81162>>>>>
81162>>>>>    Object oProgressBar is a cProgressBar
81164>>>>>        Set Size to 10 179
81165>>>>>        Set Location to 83 22
81166>>>>>        Set pbVisible to True // default
81167>>>>>        Move Self to ghoProgressBar // this can be used throughout your application to access the progress bar
81168>>>>>    End_Object
81169>>>>>
81169>>>>>    Procedure Set Progress_Bar_Visible_State Boolean bVisible
81172>>>>>        Set pbVisible of ghoProgressBar to bVisible
81173>>>>>    End_Procedure
81174>>>>>
81174>>>>>    Function Progress_Bar_Visible_State Returns Boolean
81177>>>>>        Boolean bVisible
81177>>>>>        Get pbVisible of ghoProgressBar to bVisible
81178>>>>>        Function_Return (bVisible)
81179>>>>>    End_Function
81180>>>>>
81180>>>>>    Object oProgressBarOverall is a cProgressBar
81182>>>>>        Set Size to 10 179
81183>>>>>        Set Location to 104 22
81184>>>>>        Set pbVisible to True // default
81185>>>>>        Move Self to ghoProgressBarOverall // this can be used throughout your application to access the progress bar
81186>>>>>    End_Object
81187>>>>>
81187>>>>>    Object oOverallProgress_tb is a TextBox
81189>>>>>        Set Size to 10 65
81190>>>>>        Set Location to 95 24
81191>>>>>        Set Label to "Overall Progress"
81192>>>>>    End_Object
81193>>>>>
81193>>>>>    Procedure Set Progress_Bar_Overall_Visible_State Boolean bVisible
81196>>>>>        Set pbVisible of ghoProgressBarOverall to bVisible
81197>>>>>    End_Procedure
81198>>>>>
81198>>>>>    Function Progress_Bar_Overall_Visible_State Returns Boolean
81201>>>>>        Boolean bVisible
81201>>>>>        Get pbVisible of ghoProgressBarOverall to bVisible
81202>>>>>        Function_Return (bVisible)
81203>>>>>    End_Function
81204>>>>>
81204>>>>>    // These messages bind the standard cProcessStatusPanel interface to the actual
81204>>>>>    // objects defined within this instance of the status panel.
81204>>>>>
81204>>>>>    // note: all of the messages that change text should be forwarded
81204>>>>>    // as the forwarded messages allows the panel to paint when in a tight loop
81204>>>>>
81204>>>>>    Procedure Set Message_Text String sText
81207>>>>>        Set Label of oMessageTxt to sText
81208>>>>>        Forward Set Message_Text to sText
81210>>>>>    End_Procedure
81211>>>>>
81211>>>>>    Function Message_Text Returns String
81214>>>>>        Function_Return (Label(oMessageTxt))
81215>>>>>    End_Function
81216>>>>>
81216>>>>>    Procedure Set Action_Text String sText
81219>>>>>        Set Label of oActionTxt to sText
81220>>>>>        Forward Set Action_Text to sText
81222>>>>>    End_Procedure
81223>>>>>
81223>>>>>    Function Action_Text Returns String
81226>>>>>        Function_Return (Label(oActionTxt))
81227>>>>>    End_Function
81228>>>>>
81228>>>>>    Procedure Set Button_Text String sText
81231>>>>>        Set Label of oStopButton to sText
81232>>>>>        Forward Set Button_Text to sText
81234>>>>>    End_Procedure
81235>>>>>
81235>>>>>    Function Button_Text Returns String
81238>>>>>        Function_Return (Label(oStopButton))
81239>>>>>    End_Function
81240>>>>>
81240>>>>>    Procedure Set Title_Text String sText
81243>>>>>        Set Label of oTitleTxt to sText
81244>>>>>        Forward Set Title_Text to sText
81246>>>>>    End_Procedure
81247>>>>>
81247>>>>>    Function Title_Text Returns String
81250>>>>>        Function_Return (Label(oTitleTxt))
81251>>>>>    End_Function
81252>>>>>
81252>>>>>    Procedure Set TableName_Text String sText
81255>>>>>        Set Label of oTableNameTxt to sText
81256>>>>>    End_Procedure
81257>>>>>
81257>>>>>    Function TableName_Text Returns String
81260>>>>>        Function_Return (Label(oTableNameTxt))
81261>>>>>    End_Function
81262>>>>>
81262>>>>>    Procedure Set License_Text String sText
81265>>>>>//        Set Label of oLicense_txt to sText
81265>>>>>    End_Procedure
81266>>>>>
81266>>>>>    // gets called when status panel is activated passing whether a button
81266>>>>>    // should appear
81266>>>>>    Procedure EnableCancelButton Boolean bEnable
81269>>>>>        Boolean bVisible
81269>>>>>        Get Cancel_Button_Visible_State to bVisible
81270>>>>>        If (bEnable = False) Begin
81272>>>>>            Set Visible_State of oStopButton to bVisible
81273>>>>>        End
81273>>>>>>
81273>>>>>        Set Enabled_State of oStopButton to bEnable
81274>>>>>    End_Procedure
81275>>>>>
81275>>>>>    Procedure Reset_StatusPanel
81278>>>>>        Set Allow_Cancel_State of ghoStatusPanel to True
81279>>>>>        Set Cancel_Button_Visible_State of ghoStatusPanel to True
81280>>>>>        Set Progress_Bar_Visible_State  of ghoStatusPanel to True
81281>>>>>        Set Progress_Bar_Overall_Visible_State of ghoProgressBarOverall to False
81282>>>>>    End_Procedure
81283>>>>>
81283>>>>>//    Object oProgressBar is a cProgressBar
81283>>>>>//        Move Self to ghoProgressBar
81283>>>>>//        Set Location to 1 25
81283>>>>>//        Set Size to 9 173
81283>>>>>//        Set piMinimum        to 0
81283>>>>>//        Set piMaximum        to 2000
81283>>>>>//        Set piAdvanceBy      to 100
81283>>>>>//        Set pbSmooth to True
81283>>>>>//
81283>>>>>//        // For some weird reason the application skin makes the coloring of the progressbar
81283>>>>>//        // to malfunction. By telling the CodeJock SkinFramework to skip this object, the
81283>>>>>//        // color will show correctly.
81283>>>>>//        Procedure Page Integer iPageObject
81283>>>>>//            Handle hWin
81283>>>>>//            Forward Send Page iPageObject
81283>>>>>//            If (ghoSkinFramework <> 0) Begin
81283>>>>>//                Get Window_Handle to hWin
81283>>>>>//                Send ComRemoveWindow of ghoSkinFramework hWin
81283>>>>>//            End
81283>>>>>//        End_Procedure
81283>>>>>//    End_Object
81283>>>>>
81283>>>>>End_Object
81284>>>>>
81284>>>Use cDbUpdateFunctionLibrary.inc        // Various constant definitions, structs etc.
Including file: cDbUpdateFunctionLibrary.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.inc)
81284>>>>>Use DUFLanguageConstants.inc
Including file: DUFLanguageConstants.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\DUFLanguageConstants.inc)
81284>>>>>>>//
81284>>>>>>>// *** The Database Update Framework Include file ***
81284>>>>>>>// Language constant declarations for all classes included in "DUF - The Database Update Framework"
81284>>>>>>>// They have all been placed in this central spot to make translations to various languages more convenient.
81284>>>>>>>//
81284>>>>>>>//
81284>>>>>>>Use LanguageText.Pkg
81284>>>>>>>
81284>>>>>>>// *** cSQLConnectionsIniFile Class Language Constants ***
81284>>>>>>>//
81284>>>>>>>    Define CS_DUF_DuplicateConnectionIDPre  for "Cannot register connection ID"
81284>>>>>>>    Define CS_DUF_DuplicateConnectionIDPost for "This ID already exists."
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>// *** cSQLConnectionsHandler Class Language Constants ***
81284>>>>>>>//
81284>>>>>>>    Define CS_DUF_SetupErrorcConnection  for "Cannot login to the database server as the cConnection hasn't been setup properly. Can't continue. Program will now exit."
81284>>>>>>>    Define CS_DUF_CannotLoginToServer    for "Could not login to the database server. Can't continue. Program will now exit."
81284>>>>>>>    Define CS_DUF_ErrorText              for "\n\nError Text:"
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>// *** cDbUpdateFunctionLibrary Class Language Constants ***
81284>>>>>>>//
81284>>>>>>>    Define CS_SQLConnectError       for "SQL error. Could not connect to the SQL database manager"
81284>>>>>>>    Define CS_SQLAttachError        for "Could not attach to the database:"
81284>>>>>>>    Define CS_SQLDeletingIndex      for "Deleting index"
81284>>>>>>>    Define CS_SQLCopyingData        for "Copying data"
81284>>>>>>>    Define CS_SQLCreatingIndex      for "Creating index"
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>// *** cDbUpdateVersion Class Language Constants ***
81284>>>>>>>//
81284>>>>>>>    Define CS_UpdateVersion     for "Updating database"
81284>>>>>>>    Define CS_UpdateFromVersion for "from version"
81284>>>>>>>    Define CS_UpdateToVersion   for "to version:"
81284>>>>>>>    Define CS_DbUpdateTableMissing for "Cannot open the 'DbVersion' table that is used when updating the database! Cannot continue!"
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>// *** cDbUpdateHandler.inc Class Language Constants ***
81284>>>>>>>//
81284>>>>>>>    Define CS_DatabaseInUseShort  for "There are others using the application/database. Are you sure you still want to update the database?"
81284>>>>>>>    Define CS_DatabaseNeedsUpdate for ("The database needs to be updated." + "\n\nATTENTION! The database may not be in use while this work is performed. Make sure that nobody else is using the application before clicking 'Yes' below.\n\n" + "Start update now?")
81284>>>>>>>    Define CS_HeaderUpdateText    for "Important!"
81284>>>>>>>    Define CS_DatabaseInUseText   for "There are others using the application/database or at least one table could NOT be opened exclusively. Please close all other applications using the database and try again. The Application will now close."
81284>>>>>>>    Define CS_WorkingHeaderText   for "Working!"
81284>>>>>>>    Define CS_WorkingUpdateText   for "The database is being updated. Please wait..."
81284>>>>>>>    Define CS_DatabaseUpdatedText for "Ready! The database was updated."
81284>>>>>>>    Define CS_DatabaseCheckedText for "Ready! The database was checked but no updates was needed."
81284>>>>>>>    Define CS_DbUpdatedErrorText  for "One or more errors occured while the database was updated. Please check the logfile.\n\nThe program will now close."
81284>>>>>>>    Define CS_UpdateInProgressTxt for ("System locked!\n\nThe database is being updated. Please try again later...\n\n" * "The program will now close.")
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>>>
81284>>>>>
81284>>>>>Register_Function paSQLQueryMessages Returns String[]
81284>>>>>Register_Procedure Set paSQLQueryMessages String[] aSQLQueryMessages
81284>>>>>
81284>>>>>// Global handle to a cDatabaseUpdateHandler object
81284>>>>>    Global_Variable Handle ghoDbUpdateHandler
81284>>>>>
81284>>>>>    Define CS_DatabaseUpdateFramework for " ***  The Database Update Framework (DUF) ***"
81284>>>>>
81284>>>>>    Define DATAFLEX_ID for "DATAFLEX"
81284>>>>>
81284>>>>>    Define CS_OEM_Txt for "OEM"
81284>>>>>
81284>>>>>    Define CS_ANSI_Txt for "ANSI"
81284>>>>>
81284>>>>>    Define CS_DFCONNID for "DFCONNID"
81284>>>>>
81284>>>>>    Define CS_SERVER for "SERVER"
81284>>>>>
81284>>>>>    Define CS_SERVER_NAME for "SERVER_NAME"
81284>>>>>
81284>>>>>    Define CS_DRIVER_NAME for "DRIVER_NAME"
81284>>>>>
81284>>>>>    Define CS_DATABASE_NAME for "DATABASE_NAME"
81284>>>>>
81284>>>>>    Define CS_SCHEMA_NAME for "SCHEMA_NAME"
81284>>>>>
81284>>>>>    Define CS_TABLE_CHARACTER_FORMAT for "TABLE_CHARACTER_FORMAT"
81284>>>>>
81284>>>>>    Define CS_USE_DUMMY_ZERO_DATE for "USE_DUMMY_ZERO_DATE"
81284>>>>>
81284>>>>>    Define CS_SYSTEM_FILE for "SYSTEM_FILE"
81284>>>>>
81284>>>>>    Define CS_RECNUM_TABLE for "RECNUM_TABLE"
81284>>>>>
81284>>>>>    Define CS_PRIMARY_INDEX for "PRIMARY_INDEX"
81284>>>>>
81284>>>>>    Define CS_INDEX_NUMBER for "INDEX_NUMBER"
81284>>>>>
81284>>>>>    Define CS_INDEX_NAME for "INDEX_NAME"
81284>>>>>
81284>>>>>    Define CS_DUFLowestAllowedDateValue for "01/01/1753"
81284>>>>>    Define CS_DUFLowestSQLDateValue     for "1753-01-01"
81284>>>>>
81284>>>>>
81284>>>>>    Global_Variable Handle ghoDbUpdateFunctionLibrary
81284>>>>>
81284>>>>>Struct tSQLScriptArray
81284>>>>>    Boolean bError
81284>>>>>    Boolean bArgumentSizeChanged
81284>>>>>    Integer iOrgArgumentSize
81284>>>>>    String[] sSQLScriptArray
81284>>>>>End_Struct
81284>>>>>
81284>>>>>Struct tSqlErrorArray
81284>>>>>    String[]  sSqlErrorArray
81284>>>>>    String[]  sSqlStatementArray
81284>>>>>    Integer[] iSqlErrorArray
81284>>>>>End_Struct
81284>>>>>
81284>>>>>Struct tSqlColumnNew
81284>>>>>    String  sBaseColumnName
81284>>>>>    String  sBaseTableName
81284>>>>>    String  sLabel
81284>>>>>    Integer iSqlType
81284>>>>>    Integer iSize
81284>>>>>    Integer iPrecision
81284>>>>>    Integer iDFType
81284>>>>>    Integer iDFNativeType
81284>>>>>End_Struct
81284>>>>>
81284>>>>>Struct tColumnType
81284>>>>>    String  sSQLType
81284>>>>>    Integer iSQLType
81284>>>>>    Boolean bCanEditSize
81284>>>>>    Integer iDefaultSize
81284>>>>>    Integer iMinSize
81284>>>>>    Number  nMaxSize
81284>>>>>    String  sDataFlexType
81284>>>>>    Integer iDataFlexType
81284>>>>>    Boolean bNativeDataType
81284>>>>>    String  sPrecision
81284>>>>>End_Struct
81284>>>>>
81284>>>>>// Used to store/retreive SQL keywords in a struct array.
81284>>>>>// Various SQL back-ends can have slightly different
81284>>>>>// keywords.
81284>>>>>Struct tSQLKeyWords
81284>>>>>    Integer iSQLWord
81284>>>>>    Integer iSQLDbType
81284>>>>>    String  sSQLPhrase // Can be more than one word.
81284>>>>>End_Struct
81284>>>>>
81284>>>>>Struct tSQLRelation
81284>>>>>    Integer iFileNumber
81284>>>>>    Integer iFieldNumber
81284>>>>>    String  sFileName
81284>>>>>    String  sFieldName
81284>>>>>End_Struct
81284>>>>>
81284>>>>>Struct tSQLLoggedInUser
81284>>>>>    String sUser
81284>>>>>    String sProgram
81284>>>>>End_Struct
81284>>>>>
81284>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
81284>>>>>Enumeration_List
81284>>>>>    Define DUF_ERROR_REPORT    // Report Error on screen
81284>>>>>    Define DUF_ERROR_NO_REPORT // Show no Error..
81284>>>>>End_Enumeration_List
81284>>>>>
81284>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
81284>>>>>// They can have slightly different SQL keywords.
81284>>>>>// Note: If a new type is added to the list,
81284>>>>>//       the struct array xxx must be adjusted
81284>>>>>//       so that it is filled with all SQL
81284>>>>>//       keywords for that new type.
81284>>>>>Enum_List
81284>>>>>    Define EN_DbTypeMSSQL
81284>>>>>    Define EN_DbTypeMySQL
81284>>>>>    Define EN_DbTypeOracle
81284>>>>>    Define EN_DbTypeDB2
81284>>>>>    Define EN_DbTypePostgre
81284>>>>>    Define EN_DbTypeDataFlex // Embedded database.
81284>>>>>End_Enum_List
81284>>>>>
81284>>>>>// We need to have our "own" constants for the standard DataFlex data types.
81284>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
81284>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
81284>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
81284>>>>>Define CS_DbTypeMySQL       for "MySQL"
81284>>>>>Define CS_DbTypeOracle      for "Oracle"
81284>>>>>Define CS_DbTypeDB2         for "IBM DB2"
81284>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
81284>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
81284>>>>>
81284>>>>>// We need to re-define the standard constants because several driver constants
81284>>>>>// have the same value and we need to be able to distinguish which data type to use when
81284>>>>>// e.g. creating a column with embedded SQL (ESQL).
81284>>>>>Enum_List
81284>>>>>    Define DF_ASCII_DUF     for -1500 // All of these are DF_xxx constant values - 1500
81284>>>>>    Define DF_BCD_DUF       for -1499
81284>>>>>    Define DF_DATE_DUF      for -1498
81284>>>>>    Define DF_TEXT_DUF      for -1495
81284>>>>>    Define DF_BINARY_DUF    for -1494
81284>>>>>    Define DF_DATETIME_DUF  for -1493
81284>>>>>End_Enum_List
81284>>>>>
81284>>>>>    Define SQL_TEXT for (DF_TEXT + 1024)
81284>>>>>
81284>>>>>Define SQL_CHARBIT          for (DF_BINARY + 1024)
81284>>>>>Define SQL_LONGVARCHARBIT   for (DF_BINARY + 1025)
81284>>>>>Define SQL_VARCHARBIT       for (DF_BINARY + 1026)
81284>>>>>
81284>>>>>// These are not defined pre DF 18:
81284>>>>>    Define SQL_VARCHARMAX for (-201)
81284>>>>>    Define SQL_TYPE_MONEY for (-204)
81284>>>>>    Define SQL_TYPE_SMALLMONEY for (-205)
81284>>>>>    Define SQL_TYPE_SMALLDATETIME for (-206)
81284>>>>>
81284>>>>>Struct tSQLIntTableInfo
81284>>>>>    String sDriverName
81284>>>>>    String sServerName
81284>>>>>    String sDatabaseName
81284>>>>>    String sSchemaName
81284>>>>>    Boolean bRecnumTable
81284>>>>>    Integer iPrimaryIndex
81284>>>>>    Integer iGenerateRecordIdMethod  // RIM_NONE, RIM_IDENTITY_COLUMN,  RIM_DISPENSER_TABLE, RIM_EXTERNAL
81284>>>>>    String sTableCharacterFormat
81284>>>>>    Boolean bUseDummyZeroDate
81284>>>>>    Integer iFileDummyUpdateColumn // Init value to -1 if not exists (value can be in range 1 - number of columns)
81284>>>>>    Integer iFileBlockSize         // Init value to -1 if not exists
81284>>>>>    Integer iFileMaxRowsFetched    // Init value to -1 if not exists
81284>>>>>    Integer iFileGetRidAfterCreate // Init value to -1. But is boolean!
81284>>>>>    Integer iFileJitBinding        // Init value to -1. But is boolean!
81284>>>>>    String sRefindAfterSave        // Yes or No (how to handle?)
81284>>>>>    String sSystemFile             // Yes or No (how to handle?)
81284>>>>>    String sFileIndexTablespace
81284>>>>>    String sFileLongTablespace
81284>>>>>    String sTableTablespace
81284>>>>>End_Struct
81284>>>>>
81284>>>>>Struct tSQLIntColumnInfo
81284>>>>>    Integer iFieldNumber
81284>>>>>    Integer iFieldIndex
81284>>>>>    Integer iFieldRelatedFile
81284>>>>>    Integer iFieldRelatedField
81284>>>>>    Integer iIndexNumber
81284>>>>>    Integer iIndexNumberSegments
81284>>>>>    Integer iIndexSegmentField1
81284>>>>>    Integer iIndexSegmentField2
81284>>>>>    Integer iIndexSegmentFieldn
81284>>>>>    String  sIndexName
81284>>>>>End_Struct
81284>>>>>
81284>>>>>Struct tAPIColumn
81284>>>>>    Integer iFieldNumber
81284>>>>>    String  sFieldName
81284>>>>>    Integer iType
81284>>>>>    String  sType
81284>>>>>    Integer iLength
81284>>>>>    Integer iPrecision
81284>>>>>    Integer iOptions
81284>>>>>    Boolean bIsSQLType
81284>>>>>    Boolean bAllowNULL 
81284>>>>>    String  sDefaultValue
81284>>>>>    Boolean bShouldChange
81284>>>>>    Boolean bCancel
81284>>>>>    Boolean bError
81284>>>>>End_Struct
81284>>>>>
81284>>>>>Struct tAPIColumnCompare
81284>>>>>    Integer iFieldNumber
81284>>>>>    // FROM database:
81284>>>>>    Boolean bExistsFrom
81284>>>>>    String  sFieldNameFrom
81284>>>>>    Integer iTypeFrom
81284>>>>>    String  sTypeFrom
81284>>>>>    Integer iLengthFrom
81284>>>>>    Integer iPrecisionFrom
81284>>>>>    Integer iOptionsFrom
81284>>>>>    Boolean bIsSQLTypeFrom
81284>>>>>    Boolean bAllowNULLFrom
81284>>>>>    String  sDefaultValueFrom
81284>>>>>    Boolean bShouldChangeFrom
81284>>>>>    Boolean bCancelFrom
81284>>>>>    Boolean bErrorFrom 
81284>>>>>    // TO database:
81284>>>>>    Boolean bExistsTo
81284>>>>>    Integer iFieldNumberTo
81284>>>>>    String  sFieldNameTo
81284>>>>>    Integer iTypeTo
81284>>>>>    String  sTypeTo
81284>>>>>    Integer iLengthTo
81284>>>>>    Integer iPrecisionTo
81284>>>>>    Integer iOptionsTo
81284>>>>>    Boolean bIsSQLTypeTo
81284>>>>>    Boolean bAllowNULLTo
81284>>>>>    String  sDefaultValueTo
81284>>>>>    Boolean bShouldChangeTo
81284>>>>>    Boolean bCancelTo
81284>>>>>    Boolean bErrorTo
81284>>>>>End_Struct
81284>>>>>
81284>>>>>Struct tAPIRelation
81284>>>>>    Handle  hTableFrom
81284>>>>>    Integer iColumnFrom
81284>>>>>    Handle  hTableTo
81284>>>>>    Integer iColumnTo
81284>>>>>    String  sLogicalNameFrom
81284>>>>>    String  sLogicalNameTo
81284>>>>>    String  sFieldNameFrom
81284>>>>>    String  sFieldNameTo
81284>>>>>    Boolean bShouldChange
81284>>>>>    Boolean bCancel
81284>>>>>    Boolean bError
81284>>>>>End_Struct
81284>>>>>
81284>>>>>Struct tAPIRelationCompare
81284>>>>>    // Common:
81284>>>>>    Handle  hTableFrom
81284>>>>>    Integer iColumnFrom
81284>>>>>    Handle  hTableTo
81284>>>>>    Integer iColumnTo
81284>>>>>    // FROM database:
81284>>>>>    Boolean bExistsFrom
81284>>>>>    String  sLogicalNameFrom_From
81284>>>>>    String  sLogicalNameTo_From
81284>>>>>    String  sFieldNameFrom_From
81284>>>>>    String  sFieldNameTo_From
81284>>>>>    Boolean bShouldChange_From
81284>>>>>    Boolean bCancel_From
81284>>>>>    Boolean bError_From
81284>>>>>    // TO database:
81284>>>>>    Boolean bExistsTo
81284>>>>>    String  sLogicalNameFrom_To
81284>>>>>    String  sLogicalNameTo_To
81284>>>>>    String  sFieldNameFrom_To
81284>>>>>    String  sFieldNameTo_To
81284>>>>>    Boolean bShouldChange_To
81284>>>>>    Boolean bCancel_To
81284>>>>>    Boolean bError_To
81284>>>>>End_Struct
81284>>>>>
81284>>>>>Struct tAPIIndexSegment
81284>>>>>    Integer iFieldNumber
81284>>>>>    String  sFieldName
81284>>>>>    Boolean bUppercase
81284>>>>>    Boolean bAscending
81284>>>>>    Boolean bShouldChange
81284>>>>>    Boolean bCancel
81284>>>>>    Boolean bError
81284>>>>>End_Struct
81284>>>>>
81284>>>>>Struct tAPIIndex
81284>>>>>    Integer iIndexNumber
81284>>>>>    Integer iPrimaryIndex
81284>>>>>    String  sSQLIndexName
81284>>>>>    Integer iSQLIndexType
81284>>>>>    Boolean bIsSQLClustered
81284>>>>>    Boolean bIsSQLPrimaryKey
81284>>>>>    tAPIIndexSegment[] IndexSegmentArray
81284>>>>>    tAPIIndexSegment[] IndexSegmentArray
81284>>>>>    Boolean bShouldChange
81284>>>>>    Boolean bCancel
81284>>>>>    Boolean bError
81284>>>>>End_Struct
81284>>>>>
81284>>>>>Struct tAPIIndexCompare
81284>>>>>    // Common:
81284>>>>>    Integer iIndexNumber
81284>>>>>    // FROM database:
81284>>>>>    Boolean bExistsFrom
81284>>>>>    Integer iPrimaryIndexFrom
81284>>>>>    String  sSQLIndexNameFrom
81284>>>>>    Integer iSQLIndexTypeFrom
81284>>>>>    Boolean bIsSQLClusteredFrom
81284>>>>>    Boolean bIsSQLPrimaryKeyFrom
81284>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
81284>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
81284>>>>>    Boolean bShouldChangeFrom
81284>>>>>    Boolean bCancelFrom
81284>>>>>    Boolean bErrorFrom
81284>>>>>    // TO database:
81284>>>>>    Boolean bExistsTo
81284>>>>>    Integer iPrimaryIndexTo
81284>>>>>    String  sSQLIndexNameTo
81284>>>>>    Integer iSQLIndexTypeTo
81284>>>>>    Boolean bIsSQLClusteredTo
81284>>>>>    Boolean bIsSQLPrimaryKeyTo
81284>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
81284>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
81284>>>>>    Boolean bShouldChangeTo
81284>>>>>    Boolean bCancelTo
81284>>>>>    Boolean bErrorTo
81284>>>>>End_Struct
81284>>>>>
81284>>>>>Struct tAPITableNameInfo
81284>>>>>    Integer iTableNumber
81284>>>>>    String  sRootName
81284>>>>>    String  sLogicalName
81284>>>>>    String  sDisplayName
81284>>>>>    String  sDriverID
81284>>>>>    Boolean bIsAlias
81284>>>>>    Boolean bIsSQL  
81284>>>>>    Boolean bIsSystemFile
81284>>>>>    Boolean bShouldChange
81284>>>>>    Boolean bCancel
81284>>>>>    Boolean bError
81284>>>>>End_Struct
81284>>>>>
81284>>>>>Struct tAPITableNameInfoCompare
81284>>>>>    Integer iTableNumber
81284>>>>>    // FROM
81284>>>>>    Boolean bExistsFrom
81284>>>>>    String  sRootNameFrom
81284>>>>>    String  sLogicalNameFrom
81284>>>>>    String  sDisplayNameFrom
81284>>>>>    String  sDriverIDFrom
81284>>>>>    Boolean bIsAliasFrom
81284>>>>>    Boolean bIsSQLFrom
81284>>>>>    Boolean bIsSystemFileFrom
81284>>>>>    // TO database:
81284>>>>>    Boolean bExistsTo
81284>>>>>    String  sRootNameTo
81284>>>>>    String  sLogicalNameTo
81284>>>>>    String  sDisplayNameTo
81284>>>>>    String  sDriverIDTo
81284>>>>>    Boolean bIsAliasTo
81284>>>>>    Boolean bIsSQLTo
81284>>>>>    Boolean bIsSystemFileTo // *** Implement!
81284>>>>>    Boolean bShouldChange
81284>>>>>    Boolean bCancel
81284>>>>>    Boolean bError
81284>>>>>End_Struct
81284>>>>>
81284>>>>>Struct tAPITable
81284>>>>>    Handle hTable
81284>>>>>    Boolean bFromTable
81284>>>>>    Boolean bToTable
81284>>>>>    tAPITableNameInfo ApiTableInfo
81284>>>>>    tAPITableNameInfo ApiTableInfo
81284>>>>>    tAPIColumn[]      aApiColumns
81284>>>>>    tAPIColumn[]      aApiColumns
81284>>>>>    tAPIIndex[]       aApiIndexes
81284>>>>>    tAPIIndex[]       aApiIndexes
81284>>>>>    tAPIRelation[]    aApiRelations
81284>>>>>    tAPIRelation[]    aApiRelations
81284>>>>>    Boolean bShouldChange
81284>>>>>    Boolean bCancel
81284>>>>>    Boolean bError
81284>>>>>End_Struct
81284>>>>>
81284>>>>>Struct tAPITableCompare
81284>>>>>    Handle hTable
81284>>>>>    // FROM database:
81284>>>>>    Boolean bExistsFrom
81284>>>>>    // TO database:
81284>>>>>    Boolean bExistsTo
81284>>>>>    // Both:
81284>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
81284>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
81284>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
81284>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
81284>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
81284>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
81284>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
81284>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
81284>>>>>    Boolean bShouldChange   // Not implemented yet (!)
81284>>>>>    Boolean bCancel         // User cancel
81284>>>>>    Boolean bError          // Error occured while collecting data
81284>>>>>End_Struct
81284>>>>>
81284>>>>>
81284>>>>>Struct tAPITableBooleans  
81284>>>>>    Boolean bApiTableUpdateAuto
81284>>>>>    Boolean bCompareDate_DateTime
81284>>>>>    Boolean bCompareIndexAscending
81284>>>>>    Boolean bCompareIndexUppercase
81284>>>>>    Boolean bCompareFilelistUppercase
81284>>>>>End_Struct
81284>>>>>
81284>>>>>Define C_tAPIColumn_None for 0
81284>>>>>Define C_tAPIColumn_Identity for 1
81284>>>>>
81284>>>>>// SQL Key-Word Constants:
81284>>>>>// Used by the _SqlFindKeyWord function to return a proper keyword depending on the backend SQL,
81284>>>>>// i.e. one of the EN_DbTypeXXX members from the Enum_list above.
81284>>>>>// E.g. the CI_SQLAlterTable is only defined once, but the _SqlFindKeyWord function can return
81284>>>>>// different wording content depending on the EN_xxx value also passed to the function.
81284>>>>>Enum_List
81284>>>>>    Define CI_SQLAlterDatabase         //for "ALTER DATABASE"          
81284>>>>>    Define CI_SQLSingle_User           //for "SINGLE_USER"
81284>>>>>    Define CI_SQLMulti_User            //for "USER_USER"
81284>>>>>    Define CI_SQLRollback              //for "ROLLBACK"
81284>>>>>    Define CI_SQLIMMEDIATE             //for "IMMEDIATE"
81284>>>>>    Define CI_SQLAlterTable            //for "ALTER TABLE"
81284>>>>>    Define CI_SQLAlterColumn           //for "ALTER COLUMN"
81284>>>>>    Define CI_SQLRenameColumn          //for "RENAME COLUMN"
81284>>>>>    Define CI_SQLColumn                //for "COLUMN"
81284>>>>>    Define CI_SQLSelect                //for "SELECT"
81284>>>>>    Define CI_SQLWhere                 //for "WHERE"
81284>>>>>    Define CI_SQLInfoSchema            //for "INFORMATION_SCHEMA.COLUMNS"
81284>>>>>    Define CI_SQLTable_Name            //for "TABLE_NAME"
81284>>>>>    Define CI_SQLTable                 //for "TABLE"
81284>>>>>    Define CI_SQLSys                   //for "SYS"
81284>>>>>    Define CI_SQLSp_Help               //for "SP_HELP"
81284>>>>>    Define CI_SQLFrom                  //for "FROM"
81284>>>>>    Define CI_SQLAdd                   //for "ADD"
81284>>>>>    Define CI_SQLDropColumn            //for "DROP"
81284>>>>>    Define CI_SQLCreateDatabase        //for "CREATE DATABASE"
81284>>>>>    Define CI_SQLDatabaseCollation     //for "COLLATE"
81284>>>>>    Define CI_SQLCreateTable           //for "CREATE TABLE"
81284>>>>>    Define CI_SQLDropTable             //for "DROP TABLE"
81284>>>>>    Define CI_SQLCreateView            //for "CREATE VIEW"
81284>>>>>    Define CI_SQLRenameTable           //for "RENAME TABLE"
81284>>>>>//    Define CI_SQLSelectFromWhereName   //for "SELECT name from [master].[dbo].[sysdatabases] where name"
81284>>>>>    Define CI_SQLDropView              //for "DROP VIEW"
81284>>>>>    Define CI_SQLSetNoCountOn          //for "SET NOCOUNT ON"
81284>>>>>    Define CI_SQLTo                    //for "TO"
81284>>>>>    Define CI_SQLGO                    //for "GO"
81284>>>>>    Define CI_SQLUse                   //for "USE"
81284>>>>>    Define CI_SQLDBO                   //for "DBO"
81284>>>>>
81284>>>>>    Define CI_SQLName                  //for "NAME"
81284>>>>>    Define CI_SQLMaster                //for "MASTER"
81284>>>>>    Define CI_SQLDatabases             //for "DATABASES"
81284>>>>>    Define CI_SQLSysIndexes            //for "SYS.INDEXES"
81284>>>>>    Define CI_SQLObjectID              //for "OBJECT_ID"
81284>>>>>    Define CI_SQLID                    //for "ID"
81284>>>>>    Define CI_SQLAND                   //for "AND"
81284>>>>>    Define CI_SQLUpdate                //for "UPDATE"
81284>>>>>    Define CI_SQLSet                   //for "SET"
81284>>>>>    Define CI_SQLWith                  //for "WITH"
81284>>>>>    Define CI_SQLNotNull               //for "NOT NULL"
81284>>>>>End_Enum_List
81284>>>>>
81284>>>Use cDbUpdateFunctionLibrary_Mixin.pkg  // Properties used by the cDbUpdateFunctionLibrary class.
Including file: cDbUpdateFunctionLibrary_Mixin.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary_Mixin.pkg)
81284>>>>>// *** Mixin Class For the cDbUpdateFunctionLibrary Class ***
81284>>>>>//
81284>>>>>// We need to create a mixin class for the library.
81284>>>>>// Why? Because we import the library to the cDbUpdateVersion class; that imports
81284>>>>>// all messages (functions & procedures) but all Properties are "lost", aka not imported by
81284>>>>>// the Import_Class_Protocol command. So we need a way to create our properties somewhere else...
81284>>>>>// Note: This class should _not_ have a construct_object defined.
81284>>>>>//
81284>>>>>Use VdfBase.pkg
81284>>>>>Use WinUuid.pkg
Including file: WinUuid.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\WinUuid.pkg)
81284>>>>>>>External_Function WinAPI_UuidCreate "UuidCreate" Rpcrt4.dll Address Uuid Returns Integer
81285>>>>>>>External_Function WinAPI_UuidToString  "UuidToStringA" Rpcrt4.dll Address aUuid Address lpUUIDString Returns Integer
81286>>>>>>>External_Function WinAPI_UuidCreateSequential "UuidCreateSequential" Rpcrt4.dll Address aUuid Returns Integer
81287>>>>>>>External_Function WinAPI_RpcStringFree "RpcStringFreeA" Rpcrt4.dll Address pStr Returns Integer
81288>>>>>>>
81288>>>>>>>// RandomHexUUID:
81288>>>>>>>
81288>>>>>>>// Returns a 'random' Universally Unique Identifier string as a 32 digit hex number.
81288>>>>>>>Function RandomHexUUID Global Returns String
81290>>>>>>>    Address pUUID pUUIDStr
81290>>>>>>>    Integer iRetval iOffset iChar
81290>>>>>>>    String sUUID sKey
81290>>>>>>>    
81290>>>>>>>    Move (Alloc(16)) to pUUID
81291>>>>>>>    
81291>>>>>>>    Move (WinAPI_UuidCreate (pUUID)) to iRetval
81292>>>>>>>    
81292>>>>>>>    If (iRetval = 0) Begin
81294>>>>>>>        Move 0 to pUUIDStr
81295>>>>>>>        
81295>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
81296>>>>>>>        If (iRetval = 0) Begin
81298>>>>>>>            Move pUUIDStr to sUUID
81299>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
81300>>>>>>> 
81300>>>>>>>            Move (Uppercase (sUUID)) to sUUID
81301>>>>>>>        End
81301>>>>>>>>
81301>>>>>>>    End
81301>>>>>>>>
81301>>>>>>>    
81301>>>>>>>    Move (Free(pUUID)) to iRetval 
81302>>>>>>>    
81302>>>>>>>    Function_Return sUUID
81303>>>>>>>End_Function
81304>>>>>>>
81304>>>>>>>
81304>>>>>>>// SeqHexUUID:
81304>>>>>>>
81304>>>>>>>// Returns a sequential Universally Unique Identifier string as a 32 digit hex number.
81304>>>>>>>Function SeqHexUUID Global Returns String    
81306>>>>>>>    Address pUUID pUUIDStr
81306>>>>>>>    Integer iRetval iOffset iChar
81306>>>>>>>    String sUUID sKey
81306>>>>>>>    
81306>>>>>>>    Move (Alloc(16)) to pUUID
81307>>>>>>>    
81307>>>>>>>    Move (WinAPI_UuidCreateSequential (pUUID)) to iRetval
81308>>>>>>>    
81308>>>>>>>    If (iRetval = 0) Begin
81310>>>>>>>        Move 0 to pUUIDStr
81311>>>>>>>        
81311>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
81312>>>>>>>        If (iRetval = 0) Begin
81314>>>>>>>            Move pUUIDStr to sUUID
81315>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
81316>>>>>>> 
81316>>>>>>>            Move (Uppercase (sUUID)) to sUUID
81317>>>>>>>        End
81317>>>>>>>>
81317>>>>>>>    End
81317>>>>>>>>
81317>>>>>>>    
81317>>>>>>>    Move (Free(pUUID)) to iRetval 
81318>>>>>>>    
81318>>>>>>>    Function_Return sUUID
81319>>>>>>>End_Function
81320>>>>>Use cli.pkg
81320>>>>>Use sql.pkg
81320>>>>>Use MSSqldrv.pkg
Including file: MSSqldrv.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\MSSqldrv.pkg)
81320>>>>>>>//*****************************************************************************
81320>>>>>>>//*** MSSQLDRV.PKG                                                          ***
81320>>>>>>>//***                                                                       ***
81320>>>>>>>//*** Author: Ben Weijers                                                   ***
81320>>>>>>>//***         Data Access Nederland                                         ***
81320>>>>>>>//***         29 June 1998                                                  ***
81320>>>>>>>//***                                                                       ***
81320>>>>>>>//***                                                                       ***
81320>>>>>>>//*** Purpose:                                                              ***
81320>>>>>>>//***   Package that declares MS SQL driver constants and functions.        ***
81320>>>>>>>//****                                                                      ***
81320>>>>>>>//***   This package can be used by developers who want to add Data Access  ***
81320>>>>>>>//***   MS SQL Client specific code to a DataFlex application.              ***
81320>>>>>>>//***   Updated:  June 4th 2012 (Current CK build: 5.1.0.96)                ***
81320>>>>>>>//***             Changed EnumerateServers function to use the highest      ***
81320>>>>>>>//***             available SQL Server client driver.                       ***
81320>>>>>>>//***             Moved SQL Server client constants from cli.pkg to         ***
81320>>>>>>>//***             mssqldrv.pkg                                              ***
81320>>>>>>>//***   Updated:  November 6th 2013 (Current CK build: 6.0.0.19)            ***
81320>>>>>>>//***             Added constants for SQL Server specific native types      ***
81320>>>>>>>//***             ( var...(max) types, money types, datetime types)         ***
81320>>>>>>>//*****************************************************************************
81320>>>>>>>
81320>>>>>>>Use Cli.pkg
81320>>>>>>>Use SQL.pkg
81320>>>>>>>
81320>>>>>>>//*** Driver Indentification
81320>>>>>>>
81320>>>>>>>//*** Error number constants
81320>>>>>>>
81320>>>>>>>
81320>>>>>>>//*** Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
81320>>>>>>>
81320>>>>>>>
81320>>>>>>>
81320>>>>>>>
81320>>>>>>>
81320>>>>>>>
81320>>>>>>>// SQL Server spcific types. 
81320>>>>>>>Define SQL_SS_TIMESTAMPOFFSET   for   (-155) //SQL server datetimeoffset type */
81320>>>>>>>Define SQL_SS_TIME2             for   (-154) //SQL server time type */
81320>>>>>>>Define SQL_SS_XML               for   (-152) //SQL server xml type */
81320>>>>>>>Define SQL_SS_VARIANT           for   (-150) //SQL server variant type */
81320>>>>>>>
81320>>>>>>>// SQL Server spcific types. 
81320>>>>>>>Define SQL_TYPE_TIMESTAMP2      for   (-200) //SQL server datetime2 type */
81320>>>>>>>Define SQL_VARCHARMAX           for   (-201) //SQL server varchar(max) type */
81320>>>>>>>Define SQL_WVARCHARMAX          for   (-202) //SQL server wvarchar(max) type */
81320>>>>>>>Define SQL_VARBINARYMAX         for   (-203) //SQL server varbinary(max) type */
81320>>>>>>>Define SQL_TYPE_MONEY           for   (-204) //SQL server money type */
81320>>>>>>>Define SQL_TYPE_SMALLMONEY      for   (-205) //SQL server smallmoney type */
81320>>>>>>>Define SQL_TYPE_SMALLDATETIME   for   (-206) //SQL server smalldatetype type */
81320>>>>>>>
81320>>>>>>>
81320>>>>>>>//*****************************************************************************
81320>>>>>>>//*** MSSQL_SetConstraint <FileNum> <ConstraintText>                        ***
81320>>>>>>>//***                                                                       ***
81320>>>>>>>//***   Setup a constraint for a file.                                      ***
81320>>>>>>>//*****************************************************************************
81320>>>>>>>
81320>>>>>>>
81320>>>>>>>
81320>>>>>>>Class cMSSQLHandler Is A cCLIHandler
81321>>>>>>>
81321>>>>>>>    Procedure Construct_Object
81323>>>>>>>        Forward Send Construct_Object
81325>>>>>>>
81325>>>>>>>        Set psDriverID To MSSQLDRV_ID
81326>>>>>>>    End_Procedure // Construct_Object
81327>>>>>>>
81327>>>>>>>
81327>>>>>>>
81327>>>>>>>    //***
81327>>>>>>>    //*** Function: ExtractList
81327>>>>>>>    //*** Purpose : Extract the list from the out connect string.
81327>>>>>>>    //***
81327>>>>>>>
81327>>>>>>>    Function ExtractList String sOutConnStr Integer hoStore Returns Integer
81329>>>>>>>        Local String  sItem
81329>>>>>>>        Local Integer iStart
81329>>>>>>>        Local Integer iEnd
81329>>>>>>>
81329>>>>>>>        If (hoStore = 0) ;            Move Current_object To hoStore
81332>>>>>>>
81332>>>>>>>        Send Delete_Data To hoStore
81333>>>>>>>        Move (Pos("{", sOutConnStr)) To iStart
81334>>>>>>>        While (iStart > 0)
81338>>>>>>>            Move (Right(sOutConnStr, Length(sOutConnStr) - iStart)) To sOutConnStr
81339>>>>>>>            If (Left(sOutConnStr, 1) = "}") ;                Move 0 To iStart
81342>>>>>>>            Else Begin
81343>>>>>>>                Move (Pos(",", sOutConnStr)) To iStart
81344>>>>>>>                Move (Pos("}", sOutConnStr)) To iEnd
81345>>>>>>>                If ((iStart = 0) Or (iEnd < iStart)) ;                    Move iEnd To iStart
81348>>>>>>>
81348>>>>>>>                If (iStart > 0) ;                    Set Value Of hoStore Item (Item_Count(Current_Object)) To (Left(sOutConnStr, iStart - 1))
81351>>>>>>>
81351>>>>>>>                If (iStart = iEnd) ;                    Move 0 To iStart
81354>>>>>>>            End
81354>>>>>>>>
81354>>>>>>>        Loop
81355>>>>>>>>
81355>>>>>>>
81355>>>>>>>        Function_Return (Item_Count(hoStore))
81356>>>>>>>    End_Procedure // ExtractList
81357>>>>>>>
81357>>>>>>>
81357>>>>>>>
81357>>>>>>>    //***
81357>>>>>>>    //*** Function: BrowseConnect
81357>>>>>>>    //*** Purpose : Call the driver's browse connect function
81357>>>>>>>    //***
81357>>>>>>>
81357>>>>>>>    Function BrowseConnect String sInConnStr Returns String
81359>>>>>>>        Local String  sDriver
81359>>>>>>>        Local String  sOutConnStr
81359>>>>>>>        Local Integer iArg
81359>>>>>>>        Local Integer iRetval
81359>>>>>>>
81359>>>>>>>        Get psDriverID To sDriver
81360>>>>>>>        If (sDriver <> "") Begin
81362>>>>>>>            Move (Repeat(" ", 8192)) To sOutConnStr
81363>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
81368>>>>>>>        End
81368>>>>>>>>
81368>>>>>>>
81368>>>>>>>        Function_Return sOutConnStr
81369>>>>>>>    End_Function// BrowseConnect
81370>>>>>>>
81370>>>>>>>
81370>>>>>>>    Function BrowseConnectLocal String sInConnStr Returns String
81372>>>>>>>        Local String  sDriver
81372>>>>>>>        Local String  sOutConnStr
81372>>>>>>>        Local Integer iArg
81372>>>>>>>        Local Integer iRetval
81372>>>>>>>        
81372>>>>>>>        Move 1 to iArg // Browses only local
81373>>>>>>>
81373>>>>>>>        Get psDriverID to sDriver
81374>>>>>>>        If (sDriver <> "") Begin
81376>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
81377>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
81382>>>>>>>        End
81382>>>>>>>>
81382>>>>>>>
81382>>>>>>>        Function_Return sOutConnStr
81383>>>>>>>    End_Function// BrowseConnect
81384>>>>>>>
81384>>>>>>>
81384>>>>>>>    Function DriverIndex String sDriver Returns Integer
81386>>>>>>>    
81386>>>>>>>        Local String  sCurrentDriver
81386>>>>>>>        Local Integer iNumberOfDrivers iDriver iCount
81386>>>>>>>    
81386>>>>>>>        Move 0 to iDriver
81387>>>>>>>    
81387>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
81390>>>>>>>        For iCount from 1 to iNumberOfDrivers
81396>>>>>>>>
81396>>>>>>>    
81396>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
81399>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriver) ) Begin
81401>>>>>>>                Move iCount to iDriver
81402>>>>>>>            End
81402>>>>>>>>
81402>>>>>>>        Loop
81403>>>>>>>>
81403>>>>>>>    
81403>>>>>>>        Function_Return iDriver
81404>>>>>>>    
81404>>>>>>>    End_Function 
81405>>>>>>>
81405>>>>>>>    Function EnumerateServersNetworkOrLocal Integer iNetworkLocal  Returns Integer
81407>>>>>>>        
81407>>>>>>>        Local String  sServerList
81407>>>>>>>        Local Integer iNumServers
81407>>>>>>>        Local Integer iDriver
81407>>>>>>>        Local Integer iClientVersion
81407>>>>>>>        Local String  sDriver
81407>>>>>>>        
81407>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
81408>>>>>>>
81408>>>>>>>        If (iDriver) Begin
81410>>>>>>>                
81410>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
81413>>>>>>>            
81413>>>>>>>            Case Begin
81413>>>>>>>    
81413>>>>>>>                Case (iClientVersion = SQLSERVER2016CLIENT)
81415>>>>>>>                    Move SQLSERVER2016DRVRSTR to sDriver
81416>>>>>>>                    Case Break
81417>>>>>>>    
81417>>>>>>>                Case (iClientVersion = SQLSERVER2014CLIENT)
81420>>>>>>>                    Move SQLSERVER2014DRVRSTR to sDriver
81421>>>>>>>                    Case Break
81422>>>>>>>            
81422>>>>>>>                Case (iClientVersion = SQLSERVER2012CLIENT)
81425>>>>>>>                    Move SQLSERVER2012DRVRSTR to sDriver
81426>>>>>>>                    Case Break
81427>>>>>>>    
81427>>>>>>>                Case (iClientVersion = SQLSERVER2008CLIENT)
81430>>>>>>>                    Move SQLSERVER2008DRVRSTR to sDriver
81431>>>>>>>                    Case Break
81432>>>>>>>    
81432>>>>>>>                Case (iClientVersion = SQLSERVER2005CLIENT)
81435>>>>>>>                    Move SQLSERVER2005DRVRSTR to sDriver
81436>>>>>>>                    Case Break
81437>>>>>>>            
81437>>>>>>>                Case (iClientVersion = SQLSERVER2000CLIENT)
81440>>>>>>>                    Move SQLSERVER2000DRVRSTR to sDriver
81441>>>>>>>                    Case Break
81442>>>>>>>            
81442>>>>>>>                Case Else
81442>>>>>>>                    Move SQLSERVER2000DRVRSTR to sDriver
81443>>>>>>>            
81443>>>>>>>            Case End
81443>>>>>>>    
81443>>>>>>>            Move ("DRIVER={" + sDriver + "};") to sDriver
81444>>>>>>>            If (iNetworkLocal = 0) Begin
81446>>>>>>>                Get BrowseConnect sDriver to sServerList
81447>>>>>>>            End
81447>>>>>>>>
81447>>>>>>>            Else Begin
81448>>>>>>>                Get BrowseConnectLocal sDriver to sServerList
81449>>>>>>>            End
81449>>>>>>>>
81449>>>>>>>            Get ExtractList sServerList Current_object to iNumServers
81450>>>>>>>        End
81450>>>>>>>>
81450>>>>>>>        
81450>>>>>>>        Function_Return iNumServers
81451>>>>>>>        
81451>>>>>>>    End_Function
81452>>>>>>>
81452>>>>>>>    //***
81452>>>>>>>    //*** Procedure: EnumerateServers
81452>>>>>>>    //*** Purpose  : Enumerate the available SQL Server database servers
81452>>>>>>>    //***            This function will return all SQL Server instances on the network. 
81452>>>>>>>    //***            This may take a long time. 
81452>>>>>>>    //***            To enumerate only local SQL Server instances use EnumerateServersLocal 
81452>>>>>>>    Function EnumerateServers Returns Integer
81454>>>>>>>
81454>>>>>>>        Local Integer iNumServers
81454>>>>>>>        Local Integer iNetworkLocal
81454>>>>>>>        
81454>>>>>>>        Move 0 to iNetworkLocal // 0 = enumerate network servers
81455>>>>>>>        
81455>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
81456>>>>>>>        
81456>>>>>>>        Function_Return iNumServers
81457>>>>>>>        
81457>>>>>>>    End_Function
81458>>>>>>>
81458>>>>>>>
81458>>>>>>>    //***
81458>>>>>>>    //*** Procedure: EnumerateServersLocal
81458>>>>>>>    //*** Purpose  : Enumerate the available SQL Server database servers
81458>>>>>>>    //***            This function will return only return SQL Server instance on the local machine
81458>>>>>>>    //***            To enumerate all SQL Server instances in a network use EnumerateServers
81458>>>>>>>    Function EnumerateServersLocal Returns Integer
81460>>>>>>>
81460>>>>>>>        Local Integer iNumServers
81460>>>>>>>        Local Integer iNetworkLocal
81460>>>>>>>        
81460>>>>>>>        Move 1 to iNetworkLocal // 1 = enumerate local servers
81461>>>>>>>        
81461>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
81462>>>>>>>        
81462>>>>>>>        Function_Return iNumServers
81463>>>>>>>        
81463>>>>>>>    End_Function
81464>>>>>>>
81464>>>>>>>    
81464>>>>>>>
81464>>>>>>>    //***
81464>>>>>>>    //*** Function: EnumerateDatabases
81464>>>>>>>    //*** Purpose : Enumerate database in a given server.
81464>>>>>>>    //***
81464>>>>>>>
81464>>>>>>>    Function EnumerateDatabases String sServer String sUser String sPassWord Returns Integer
81466>>>>>>>        Local Integer hoSQL
81466>>>>>>>        Local String  sConnect
81466>>>>>>>        Local String  sDatabase
81466>>>>>>>        Local Integer hdbc
81466>>>>>>>        Local Integer hstmt
81466>>>>>>>        Local Integer iFetchResult
81466>>>>>>>
81466>>>>>>>        If (Num_Arguments < 3) ;            Move "" To sPassWord
81469>>>>>>>        If (Num_Arguments < 2) ;            Move "" To sUser
81472>>>>>>>
81472>>>>>>>        If (sUser <> "") ;            Move ("SERVER=" + Trim(sServer) + ";UID=" + Trim(sUser) + ";PWD=" + Trim(sPassword) + ";") To sConnect
81475>>>>>>>        Else ;            Move ("SERVER=" + Trim(sServer) + ";Trusted_Connection=yes") To sConnect
81477>>>>>>>
81477>>>>>>>        Object oEnumDBSQLmanager Is A cSQLHandleManager
81479>>>>>>>            Move Current_Object To hoSQL
81480>>>>>>>        End_Object // oEnumDBSQLManager
81481>>>>>>>
81481>>>>>>>        If (hoSQL <> 0) Begin
81483>>>>>>>            Get SQLConnect Of hoSQL "MSSQLDRV" sConnect To hdbc
81484>>>>>>>            If (hdbc <> 0) Begin
81486>>>>>>>                Get SQLOpen Of hdbc To hstmt
81487>>>>>>>                If (hstmt <> 0) Begin
81489>>>>>>>                    //*** We could do a direct select on the sysdatabases table but we use
81489>>>>>>>                    //*** the stored procedure sp_database instead. SQL Server recommends this
81489>>>>>>>                    //*** approach in case meta data might change, the stored procedure will
81489>>>>>>>                    //*** stay the same.
81489>>>>>>>                    Send SQLSetProcedureName To hstmt "sp_databases"
81490>>>>>>>                    Send SQLCall To hstmt
81491>>>>>>>                    Repeat
81491>>>>>>>>
81491>>>>>>>                        Get SQLFetch Of hstmt To iFetchResult
81492>>>>>>>                        If (iFetchResult <> 0) Begin
81494>>>>>>>                            Get SQLColumnValue Of hstmt 1 To sDatabase
81495>>>>>>>                            Set Value Item (Item_Count(Current_Object)) To sDatabase
81496>>>>>>>                        End
81496>>>>>>>>
81496>>>>>>>                    Until (iFetchResult = 0)
81498>>>>>>>
81498>>>>>>>                    Send SQLClose To hstmt
81499>>>>>>>                End
81499>>>>>>>>
81499>>>>>>>                Send SQLDisconnect To hdbc
81500>>>>>>>            End
81500>>>>>>>>
81500>>>>>>>        End
81500>>>>>>>>
81500>>>>>>>        Send Destroy_Object To hoSQL
81501>>>>>>>
81501>>>>>>>        Function_return (Item_Count(Current_Object))
81502>>>>>>>    End_Function // EnumerateDatabases
81503>>>>>>>
81503>>>>>>>
81503>>>>>>>    Function SqlServerClientVersionName Integer iClientVersion  Returns String
81505>>>>>>>        
81505>>>>>>>        Local String  sSqlServerClientVersionName
81505>>>>>>>        
81505>>>>>>>            
81505>>>>>>>        Case Begin
81505>>>>>>>
81505>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
81507>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
81508>>>>>>>                Case Break
81509>>>>>>>
81509>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
81512>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
81513>>>>>>>                Case Break
81514>>>>>>>        
81514>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
81517>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
81518>>>>>>>                Case Break
81519>>>>>>>
81519>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
81522>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
81523>>>>>>>                Case Break
81524>>>>>>>
81524>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
81527>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
81528>>>>>>>                Case Break
81529>>>>>>>        
81529>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
81532>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
81533>>>>>>>                Case Break
81534>>>>>>>        
81534>>>>>>>            Case Else
81534>>>>>>>                Move SQLSERVERUNKNOWNCLIENTNAME to sSqlServerClientVersionName
81535>>>>>>>        
81535>>>>>>>        Case End
81535>>>>>>>    
81535>>>>>>>        
81535>>>>>>>        Function_Return sSqlServerClientVersionName
81536>>>>>>>        
81536>>>>>>>    End_Function
81537>>>>>>>
81537>>>>>>>
81537>>>>>>>End_Class // cMSSQLHandler
81538>>>>>>>
81538>>>>>Use db2_drv.pkg
Including file: db2_drv.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\db2_drv.pkg)
81538>>>>>>>//*****************************************************************************
81538>>>>>>>//*** DB2_DRV.PKG                                                           ***
81538>>>>>>>//***                                                                       ***
81538>>>>>>>//*** Author: Ben Weijers                                                   ***
81538>>>>>>>//***         Data Access Nederland                                         ***
81538>>>>>>>//***         30 July 1998                                                  ***
81538>>>>>>>//***                                                                       ***
81538>>>>>>>//*** Last updated: May 2, 2007                                                                      ***
81538>>>>>>>//***                                                                       ***
81538>>>>>>>//*** Purpose:                                                              ***
81538>>>>>>>//***   Package that declares DB2 driver constants and functions.           ***
81538>>>>>>>//****                                                                      ***
81538>>>>>>>//***   This package can be used by developers who want to add DB2 driver   ***
81538>>>>>>>//***   specific code to a DataFlex application.                            ***
81538>>>>>>>//*****************************************************************************
81538>>>>>>>
81538>>>>>>>Use Cli.pkg
81538>>>>>>>
81538>>>>>>>//*** Driver attributes
81538>>>>>>>
81538>>>>>>>
81538>>>>>>>//*** Driver Indentification
81538>>>>>>>
81538>>>>>>>//*** Error number constants
81538>>>>>>>
81538>>>>>>>//*** Call driver function identifiers
81538>>>>>>>
81538>>>>>>>// DB2 specific data types
81538>>>>>>>Define SQL_CLOB           for   (-99)  
81538>>>>>>>Define SQL_BLOB           for   (-98)  
81538>>>>>>>Define SQL_XML            for   (-370) 
81538>>>>>>>// DB2 Graphic types are Unicode types
81538>>>>>>>Define SQL_GRAPHIC        for   (-95)  
81538>>>>>>>Define SQL_VARGRAPHIC     for   (-96)  
81538>>>>>>>Define SQL_LONGVARGRAPHIC for   (-97)  
81538>>>>>>>Define SQL_DBCLOB         for   (-350) 
81538>>>>>>>
81538>>>>>>>
81538>>>>>>>//*** Extra DB2 commands
81538>>>>>>>
81538>>>>>>>
81538>>>>>>>//*****************************************************************************
81538>>>>>>>//*** DB2_CheckTrigger <NewState>                                           ***
81538>>>>>>>//***                                                                       ***
81538>>>>>>>//*** This command will set the trigger check at open on or off.            ***
81538>>>>>>>//*****************************************************************************
81538>>>>>>>
81538>>>>>>>
81538>>>>>>>
81538>>>>>>>//*****************************************************************************
81538>>>>>>>//*** DB2_SetConstraint <FileNum> <ConstraintText>                          ***
81538>>>>>>>//***                                                                       ***
81538>>>>>>>//***   Setup a constraint for a file.                                      ***
81538>>>>>>>//*****************************************************************************
81538>>>>>>>
81538>>>>>>>
81538>>>>>>>
81538>>>>>>>Class cDB2Handler Is A cCLIHandler
81539>>>>>>>
81539>>>>>>>    Procedure Construct_Object
81541>>>>>>>        Forward Send Construct_Object
81543>>>>>>>
81543>>>>>>>        Set psDriverID To DB2_DRV_ID
81544>>>>>>>    End_Procedure // Construct_Object
81545>>>>>>>
81545>>>>>>>
81545>>>>>>>
81545>>>>>>>    //***
81545>>>>>>>    //*** Procedure: SeedDataSources
81545>>>>>>>    //*** Purpose  : Reset the datasource list to the beginning
81545>>>>>>>    //***
81545>>>>>>>
81545>>>>>>>    Procedure SeedDataSources
81547>>>>>>>        Local String  sDriver
81547>>>>>>>        Local String  sVoid
81547>>>>>>>        Local Integer iRetval
81547>>>>>>>
81547>>>>>>>        Get psDriverID To sDriver
81548>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid SQL_FETCH_ALL Result iRetval
81555>>>>>>>    End_Procedure // SeedDataSources
81556>>>>>>>
81556>>>>>>>
81556>>>>>>>
81556>>>>>>>    //***
81556>>>>>>>    //*** Function: DataSources
81556>>>>>>>    //*** Purpose : Call the driver's data sources function
81556>>>>>>>    //***
81556>>>>>>>
81556>>>>>>>    Function DataSources Returns String
81558>>>>>>>        Local String  sDriver
81558>>>>>>>        Local String  sDataSource
81558>>>>>>>        Local String  sDescription
81558>>>>>>>        Local Integer iLength
81558>>>>>>>        Local Integer iRetval
81558>>>>>>>
81558>>>>>>>        Get psDriverID To sDriver
81559>>>>>>>        If (sDriver <> "") Begin
81561>>>>>>>            Move 8192 To iLength
81562>>>>>>>            Move (Repeat(" ", iLength)) To sDataSource
81563>>>>>>>            Move (Repeat(" ", iLength)) To sDescription
81564>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
81569>>>>>>>        End
81569>>>>>>>>
81569>>>>>>>
81569>>>>>>>        If (sDataSource <> "" Or sDescription <> "") ;            Function_Return (sDataSource + "," +  sDescription)
81572>>>>>>>        Else ;            Function_Return ""
81574>>>>>>>    End_Function// DataSources
81575>>>>>>>
81575>>>>>>>End_Class // cODBCHandler
81576>>>>>>>
81576>>>>>>>
81576>>>>>Use odbc_drv.pkg
Including file: odbc_drv.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\odbc_drv.pkg)
81576>>>>>>>//*****************************************************************************
81576>>>>>>>//*** ODBC_DRV.PKG                                                          ***
81576>>>>>>>//***                                                                       ***
81576>>>>>>>//*** Author: Ben Weijers                                                   ***
81576>>>>>>>//***         Data Access Nederland                                         ***
81576>>>>>>>//***         3 February 1998                                               ***
81576>>>>>>>//***                                                                       ***
81576>>>>>>>//*** Last updated: May 2, 2007                                                                      ***
81576>>>>>>>//***                                                                       ***
81576>>>>>>>//*** Purpose:                                                              ***
81576>>>>>>>//***   Package that declares ODBC driver constants and functions.          ***
81576>>>>>>>//****                                                                      ***
81576>>>>>>>//***   This package can be used by developers who want to add Data Access  ***
81576>>>>>>>//***   ODBC Client specific code to a DataFlex application.                ***
81576>>>>>>>//*****************************************************************************
81576>>>>>>>
81576>>>>>>>Use Cli.pkg
81576>>>>>>>
81576>>>>>>>//*** Driver Indentification
81576>>>>>>>
81576>>>>>>>//*** Error number constants
81576>>>>>>>
81576>>>>>>>//*** Call driver function identifiers
81576>>>>>>>
81576>>>>>>>//*** Extra ODBC commands
81576>>>>>>>
81576>>>>>>>
81576>>>>>>>//*****************************************************************************
81576>>>>>>>//*** ODBCManage                                                            ***
81576>>>>>>>//***                                                                       ***
81576>>>>>>>//*** Start the ODBC manager.                                               ***
81576>>>>>>>//*****************************************************************************
81576>>>>>>>
81576>>>>>>>
81576>>>>>>>
81576>>>>>>>//*****************************************************************************
81576>>>>>>>//*** ODBCNumberOfDataSources To <NumDSN>                                   ***
81576>>>>>>>//***                                                                       ***
81576>>>>>>>//*** Returns the number of data sources.                                   ***
81576>>>>>>>//*****************************************************************************
81576>>>>>>>
81576>>>>>>>
81576>>>>>>>//*****************************************************************************
81576>>>>>>>//*** ODBCDSNName <DSNNumber> To <DSNName>                                  ***
81576>>>>>>>//***                                                                       ***
81576>>>>>>>//*** Returns the name of the data source.                                  ***
81576>>>>>>>//*****************************************************************************
81576>>>>>>>
81576>>>>>>>
81576>>>>>>>//*****************************************************************************
81576>>>>>>>//*** ODBCEnumerateTables <DSNName> To <TableNum>                           ***
81576>>>>>>>//***                                                                       ***
81576>>>>>>>//*** Builds internal table array and returns the number of tables in the   ***
81576>>>>>>>//*** DSN.                                                                  ***
81576>>>>>>>//*****************************************************************************
81576>>>>>>>
81576>>>>>>>
81576>>>>>>>//*****************************************************************************
81576>>>>>>>//*** ODBCTableName <TableNum> To <TableName>                               ***
81576>>>>>>>//***                                                                       ***
81576>>>>>>>//*** Returns the name of the table.                                        ***
81576>>>>>>>//*****************************************************************************
81576>>>>>>>
81576>>>>>>>
81576>>>>>>>//*****************************************************************************
81576>>>>>>>//*** ODBCSchemaName <TableNum> To <SchemaName>                             ***
81576>>>>>>>//***                                                                       ***
81576>>>>>>>//*** Returns the schema name of the table.                                 ***
81576>>>>>>>//*****************************************************************************
81576>>>>>>>
81576>>>>>>>
81576>>>>>>>//*****************************************************************************
81576>>>>>>>//*** ODBCNumberOfFields <DSNName> <TableName> To <NumDSN>                  ***
81576>>>>>>>//***                                                                       ***
81576>>>>>>>//*** Returns the number of fields.                                         ***
81576>>>>>>>//*****************************************************************************
81576>>>>>>>
81576>>>>>>>
81576>>>>>>>//*****************************************************************************
81576>>>>>>>//*** ODBCFieldName <FieldNumber> To <FieldName>                            ***
81576>>>>>>>//***                                                                       ***
81576>>>>>>>//*** Returns the name of the field.                                  ***
81576>>>>>>>//*****************************************************************************
81576>>>>>>>
81576>>>>>>>
81576>>>>>>>
81576>>>>>>>//*****************************************************************************
81576>>>>>>>//*** ODBC_SetConstraint <FileNum> <ConstraintText>                         ***
81576>>>>>>>//***                                                                       ***
81576>>>>>>>//***   Setup a constraint for a file.                                      ***
81576>>>>>>>//*****************************************************************************
81576>>>>>>>
81576>>>>>>>
81576>>>>>>>
81576>>>>>>>Class cODBCHandler Is A cCLIHandler
81577>>>>>>>
81577>>>>>>>    Procedure Construct_Object
81579>>>>>>>        Forward Send Construct_Object
81581>>>>>>>
81581>>>>>>>        Set psDriverID To ODBC_DRV_ID
81582>>>>>>>    End_Procedure // Construct_Object
81583>>>>>>>
81583>>>>>>>
81583>>>>>>>
81583>>>>>>>    //***
81583>>>>>>>    //*** Procedure Set: DataSourceType
81583>>>>>>>    //*** Purpose      : Setup the type of data sources returned by the datasources function
81583>>>>>>>    //***
81583>>>>>>>
81583>>>>>>>    Procedure Set DataSourceType Integer iNewType
81585>>>>>>>        Local String  sDriver
81585>>>>>>>        Local String  sVoid
81585>>>>>>>        Local Integer iRetval
81585>>>>>>>
81585>>>>>>>        Get psDriverID To sDriver
81586>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid iNewType Result iRetval
81593>>>>>>>    End_Procedure // Set DataSourceType
81594>>>>>>>
81594>>>>>>>
81594>>>>>>>
81594>>>>>>>    //***
81594>>>>>>>    //*** Function: DataSources
81594>>>>>>>    //*** Purpose : Call the driver's data sources function
81594>>>>>>>    //***
81594>>>>>>>
81594>>>>>>>    Function DataSources Returns String
81596>>>>>>>        Local String  sDriver
81596>>>>>>>        Local String  sDataSource
81596>>>>>>>        Local String  sDescription
81596>>>>>>>        Local Integer iLength
81596>>>>>>>        Local Integer iRetval
81596>>>>>>>
81596>>>>>>>        Get psDriverID To sDriver
81597>>>>>>>        If (sDriver <> "") Begin
81599>>>>>>>            Move 8192 To iLength
81600>>>>>>>            Move (Repeat(" ", iLength)) To sDataSource
81601>>>>>>>            Move (Repeat(" ", iLength)) To sDescription
81602>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
81607>>>>>>>        End
81607>>>>>>>>
81607>>>>>>>
81607>>>>>>>        If (sDataSource <> "" Or sDescription <> "") ;            Function_Return (sDataSource + "," +  sDescription)
81610>>>>>>>        Else ;            Function_Return ""
81612>>>>>>>    End_Function// DataSources
81613>>>>>>>
81613>>>>>>>End_Class // cODBCHandler
81614>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (C:\Program Files (x86)\DataFlex 19.0\Pkg\DFBTRDRV.PKG)
81614>>>>>>>//****************************************************************************
81614>>>>>>>//
81614>>>>>>>// $File name  : DFBTRDRV.PKG
81614>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
81614>>>>>>>// Notice      : This package contains constants and commands, used to call
81614>>>>>>>//               specific functions in the DFBTRDRV.
81614>>>>>>>// $Author(s)  : Eddy Kleinjan
81614>>>>>>>//
81614>>>>>>>// $System     : DataFlex Connectivity Kit for Pervasive.SQL
81614>>>>>>>// Created     : 01-07-97 @ 12:00:00
81614>>>>>>>//
81614>>>>>>>// Changed     : 04-04-2001.
81614>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.145
81614>>>>>>>//
81614>>>>>>>// Changed     : June 6, 2001
81614>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.148
81614>>>>>>>//
81614>>>>>>>//               Added DFBTR_DDF_OWNER command.
81614>>>>>>>//
81614>>>>>>>// Changed     : June 12, 2001
81614>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.149
81614>>>>>>>//
81614>>>>>>>//               Added DF_FIELD_IS_NULL and DF_FIELD_NULL_ALLOWED attributes
81614>>>>>>>//
81614>>>>>>>// Changed     : August 4, 2004
81614>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 3.0.0.1
81614>>>>>>>//
81614>>>>>>>//               Added cDfbtrdrvHandler class.
81614>>>>>>>//               New functions in this class:
81614>>>>>>>//                  Function CKRevision Returns String
81614>>>>>>>//                  Function CkUsesUri Returns Integer
81614>>>>>>>//                  Function PSQLRequesterVersionInfo Integer iFileNum Returns String
81614>>>>>>>//                  Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
81614>>>>>>>//                  Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
81614>>>>>>>//
81614>>>>>>>// Changed     : September 30, 2005
81614>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 3.0.0.14
81614>>>>>>>//
81614>>>>>>>//               Bugfix: Prevent compiler errors when no (df)error.pkg is used
81614>>>>>>>//****************************************************************************
81614>>>>>>>Use Ui
81614>>>>>>>//
81614>>>>>>>// Driver Indentification
81614>>>>>>>//
81614>>>>>>>
81614>>>>>>>//*** Driver attributes
81614>>>>>>>//
81614>>>>>>>// Call_Driver functions ID's
81614>>>>>>>//
81614>>>>>>>//
81614>>>>>>>// DFBTRFN_CONVERT_FILE options
81614>>>>>>>//
81614>>>>>>>
81614>>>>>>>//
81614>>>>>>>// DFBTRFN_SET_OWNER options
81614>>>>>>>//
81614>>>>>>>
81614>>>>>>>//
81614>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
81614>>>>>>>//
81614>>>>>>>
81614>>>>>>>
81614>>>>>>>//
81614>>>>>>>// Command to create all vars which may be needed
81614>>>>>>>// in other commands.
81614>>>>>>>//
81614>>>>>>>
81614>>>>>>>
81614>>>>>>>
81614>>>>>>>//
81614>>>>>>>// Command to set the owner of a Btrieve file.
81614>>>>>>>// File must have been opened.
81614>>>>>>>// Filenumber needs to be passed.
81614>>>>>>>// To clear set the owner to "".
81614>>>>>>>// Examples:
81614>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
81614>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
81614>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
81614>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
81614>>>>>>>// To clear:
81614>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
81614>>>>>>>//
81614>>>>>>>
81614>>>>>>>
81614>>>>>>>
81614>>>>>>>//
81614>>>>>>>// Command to parse DFBTR_SET_OWNVER
81614>>>>>>>// options.
81614>>>>>>>//
81614>>>>>>>
81614>>>>>>>
81614>>>>>>>
81614>>>>>>>//
81614>>>>>>>// Command to parse for Callback
81614>>>>>>>//
81614>>>>>>>
81614>>>>>>>
81614>>>>>>>
81614>>>>>>>//
81614>>>>>>>// Command to clear the owner of a Btrieve file.
81614>>>>>>>// File must have been opened.
81614>>>>>>>// Filenumber needs to be passed.
81614>>>>>>>// Examples:
81614>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
81614>>>>>>>//
81614>>>>>>>
81614>>>>>>>
81614>>>>>>>
81614>>>>>>>//
81614>>>>>>>// Command to add a owner name to the internal list of ownernames
81614>>>>>>>// which will be tries when opening files.
81614>>>>>>>//
81614>>>>>>>
81614>>>>>>>
81614>>>>>>>
81614>>>>>>>//
81614>>>>>>>// Command to remove all owners from the internal list of ownernames
81614>>>>>>>//
81614>>>>>>>
81614>>>>>>>
81614>>>>>>>//
81614>>>>>>>// Command to set the owner name to be used when opening the DDF files.
81614>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
81614>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
81614>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
81614>>>>>>>//
81614>>>>>>>
81614>>>>>>>//
81614>>>>>>>// Command to change the transaction type.
81614>>>>>>>// Valid types are:
81614>>>>>>>//     DFBTRTT_NONE
81614>>>>>>>//     DFBTRTT_EXCLUSIVE
81614>>>>>>>//     DFBTRTT_CONCURRENT
81614>>>>>>>//
81614>>>>>>>//
81614>>>>>>>
81614>>>>>>>
81614>>>>>>>
81614>>>>>>>//
81614>>>>>>>// Command to get the current transaction type.
81614>>>>>>>//
81614>>>>>>>
81614>>>>>>>//
81614>>>>>>>// Command to set explicit_locking
81614>>>>>>>//
81614>>>>>>>
81614>>>>>>>//
81614>>>>>>>// Command to get explicit locking
81614>>>>>>>//
81614>>>>>>>
81614>>>>>>>//
81614>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
81614>>>>>>>//
81614>>>>>>>
81614>>>>>>>//
81614>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
81614>>>>>>>//
81614>>>>>>>
81614>>>>>>>//*****************************************************************************
81614>>>>>>>//*** Class  : cDfbtrdrvHandler                                                  ***
81614>>>>>>>//*** Purpose: An instance of this class can be used as a broker object to  ***
81614>>>>>>>//***          call several Dfbtrdrv releated methods.                           ***
81614>>>>>>>//*****************************************************************************
81614>>>>>>>
81614>>>>>>>Class cDFBtrDrvHandler Is An Array
81615>>>>>>>
81615>>>>>>>    Procedure Construct_Object Integer iImage
81617>>>>>>>        Forward Send Construct_object iImage
81619>>>>>>>
81619>>>>>>>        Property String  psDriverID       Public "DFBTRDRV"
81620>>>>>>>    End_Procedure // Construct_Object
81621>>>>>>>
81621>>>>>>>
81621>>>>>>>
81621>>>>>>>    //***
81621>>>>>>>    //*** Function: CKRevsion
81621>>>>>>>    //*** Purpose : The revsion of a Dfbtrdrv Connectivity Kit
81621>>>>>>>    //***
81621>>>>>>>
81621>>>>>>>    Function CKRevision Returns String
81623>>>>>>>        Local String  sDriverID
81623>>>>>>>        Local String  sRevision
81623>>>>>>>        Local String  sVoid
81623>>>>>>>        Local Integer iRetval
81623>>>>>>>
81623>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
81623>>>>>>>        // This error would otherwise be raised when we have an older
81623>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
81623>>>>>>>        Send Ignore_error To Error_object_Id 20491
81624>>>>>>>        Get psDriverID To sDriverID
81625>>>>>>>        Move (Repeat(" ", 255)) To sRevision
81626>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
81631>>>>>>>        Send Trap_Error To Error_object_Id 20491
81632>>>>>>>        If (Trim(sRevision) = "") Begin
81634>>>>>>>            // Unable to get the revision. return all zeroes.
81634>>>>>>>            Move "0.0.0.0" To sRevision
81635>>>>>>>        End
81635>>>>>>>>
81635>>>>>>>        Function_Return sRevision
81636>>>>>>>    End_Function // CKRevision
81637>>>>>>>
81637>>>>>>>    Function CkUsesUri Returns Integer
81639>>>>>>>        Local String  sDriverID
81639>>>>>>>        Local String  sVoid1
81639>>>>>>>        Local String  sVoid2
81639>>>>>>>        Local Integer iRetval
81639>>>>>>>
81639>>>>>>>        Get psDriverID To sDriverID
81640>>>>>>>
81640>>>>>>>        Move 0 To iRetval
81641>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
81641>>>>>>>        // This error would otherwise be raised when we have an older
81641>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
81641>>>>>>>        Send Ignore_error To Error_object_Id 20491
81642>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
81647>>>>>>>        Send Trap_Error To Error_object_Id 20491
81648>>>>>>>
81648>>>>>>>        Function_Return iRetval
81649>>>>>>>    End_Function // CKUsesUri
81650>>>>>>>
81650>>>>>>>
81650>>>>>>>
81650>>>>>>>    //***
81650>>>>>>>    //*** Function: ExtractPartFromRevsion
81650>>>>>>>    //*** Purpose : Extarct the Nth part of a a.b.c.d revsion string.
81650>>>>>>>    //***
81650>>>>>>>    //*** Returns : The part version number or -1 if there is no such part number.
81650>>>>>>>    //***
81650>>>>>>>
81650>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
81652>>>>>>>        Local Integer iPartRev
81652>>>>>>>        Local Integer iCurrentPart
81652>>>>>>>        Local Integer iSeparatorPos
81652>>>>>>>
81652>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
81655>>>>>>>
81655>>>>>>>        Move 0 To iCurrentPart
81656>>>>>>>        Repeat
81656>>>>>>>>
81656>>>>>>>            Move (Pos(".", sRevision)) To iSeparatorPos
81657>>>>>>>            If (iSeparatorPos > 0) Begin
81659>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) To iPartRev
81660>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) To sRevision
81661>>>>>>>                Increment iCurrentPart
81662>>>>>>>            End
81662>>>>>>>>
81662>>>>>>>            Else If (sRevision <> "") Begin
81665>>>>>>>                Move sRevision To iPartRev
81666>>>>>>>                Move "" To sRevision
81667>>>>>>>                Increment iCurrentPart
81668>>>>>>>            End
81668>>>>>>>>
81668>>>>>>>            Else ;                Move -1 To iPartRev
81670>>>>>>>        Until (iCurrentPart >= iPartNum Or iPartRev = -1)
81672>>>>>>>
81672>>>>>>>        Function_Return iPartRev
81673>>>>>>>    End_Function // EcxtractPartFromRevision
81674>>>>>>>
81674>>>>>>>
81674>>>>>>>
81674>>>>>>>    //***
81674>>>>>>>    //*** Function: CKMajorRevision
81674>>>>>>>    //*** Purpose : Returns the major revision of the CK
81674>>>>>>>    //***
81674>>>>>>>
81674>>>>>>>    Function CKMajorRevision Returns Integer
81676>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
81677>>>>>>>    End_Function // CKMajorRevision
81678>>>>>>>
81678>>>>>>>
81678>>>>>>>
81678>>>>>>>    //***
81678>>>>>>>    //*** Function: CKMinorRevision
81678>>>>>>>    //*** Purpose : Returns the minor revision of the CK
81678>>>>>>>    //***
81678>>>>>>>
81678>>>>>>>    Function CKMinorRevision Returns Integer
81680>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
81681>>>>>>>    End_Function // CKMinorRevision
81682>>>>>>>
81682>>>>>>>
81682>>>>>>>
81682>>>>>>>    //***
81682>>>>>>>    //*** Function: CKReleaseRevision
81682>>>>>>>    //*** Purpose : Returns the release revision of the CK
81682>>>>>>>    //***
81682>>>>>>>
81682>>>>>>>    Function CKReleaseRevision Returns Integer
81684>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
81685>>>>>>>    End_Function // CKReleaseRevision
81686>>>>>>>
81686>>>>>>>
81686>>>>>>>
81686>>>>>>>    //***
81686>>>>>>>    //*** Function: CKBuildRevision
81686>>>>>>>    //*** Purpose : Returns the major revision of the CK
81686>>>>>>>    //***
81686>>>>>>>
81686>>>>>>>    Function CKBuildRevision Returns Integer
81688>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
81689>>>>>>>    End_Function // CKBuildRevision
81690>>>>>>>
81690>>>>>>>
81690>>>>>>>
81690>>>>>>>    //***
81690>>>>>>>    //*** Function: IsMinimalRevision
81690>>>>>>>    //*** Purpose : Determines if the CK conforms to a passed minimal revsion.
81690>>>>>>>    //***
81690>>>>>>>
81690>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
81692>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_return (TRUE)
81695>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
81698>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_return (TRUE)
81701>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
81704>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_return (TRUE)
81707>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) And iBuild <= CKBuildRevision(Current_object)) ;                    Function_return (TRUE)
81711>>>>>>>            End
81711>>>>>>>>
81711>>>>>>>        End
81711>>>>>>>>
81711>>>>>>>
81711>>>>>>>        Function_Return (FALSE)
81712>>>>>>>    End_Function // IsMinimalRevision
81713>>>>>>>
81713>>>>>>>    //   Functions to query the Pervasive.SQL version:
81713>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
81713>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
81713>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
81713>>>>>>>    //
81713>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
81713>>>>>>>    //   in the following format:
81713>>>>>>>    //       <version>.<revision>.<type>
81713>>>>>>>    //   possible values for <type>:
81713>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
81713>>>>>>>    //         server using Workgroup authentication mode
81713>>>>>>>    //       C for client cache engine
81713>>>>>>>    //       D for DOS workstation
81713>>>>>>>    //       N for client Requester
81713>>>>>>>    //       S for NetWare server
81713>>>>>>>    //       T for 32-bit Windows server engine
81713>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
81713>>>>>>>    //
81713>>>>>>>    //   example:
81713>>>>>>>    //       8.50.T
81713>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
81713>>>>>>>    //   32-bits Windows server.
81713>>>>>>>    //
81713>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
81713>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
81713>>>>>>>    //
81713>>>>>>>    //   If the version information is not available or can not be obtained
81713>>>>>>>    //   the functions will return "0.0.0"
81713>>>>>>>
81713>>>>>>>
81713>>>>>>>    //***
81713>>>>>>>    //*** Function: PSQLRequesterVersionInfo
81713>>>>>>>    //*** Purpose : Returns the version information of the
81713>>>>>>>    //***           Pervasive.SQL Client requester.
81713>>>>>>>
81713>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
81715>>>>>>>
81715>>>>>>>        Local String  sDriverID
81715>>>>>>>        Local String  sVersion
81715>>>>>>>        Local String  sVoid
81715>>>>>>>        Local Integer iRetval
81715>>>>>>>
81715>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
81715>>>>>>>        // This error would otherwise be raised when we have an older
81715>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
81715>>>>>>>        Send Ignore_error To Error_object_Id 20491
81716>>>>>>>        Get psDriverID To sDriverID
81717>>>>>>>        Move (Repeat(" ", 255)) To sVersion
81718>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
81723>>>>>>>        Send Trap_Error To Error_object_Id 20491
81724>>>>>>>        If (Trim(sVersion) = "") Begin
81726>>>>>>>            // Unable to get the revision. return all zeroes.
81726>>>>>>>            Move "0.0.0" To sVersion
81727>>>>>>>        End
81727>>>>>>>>
81727>>>>>>>        Function_Return sVersion
81728>>>>>>>    End_Function //  PSQLRequesterVersion
81729>>>>>>>
81729>>>>>>>    //***
81729>>>>>>>    //*** Function: PSQLLocalEngineVersionInfo
81729>>>>>>>    //*** Purpose : Returns the version information of the
81729>>>>>>>    //***           Pervasive.SQL Local Engine
81729>>>>>>>
81729>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
81731>>>>>>>
81731>>>>>>>        Local String  sDriverID
81731>>>>>>>        Local String  sVersion
81731>>>>>>>        Local String  sVoid
81731>>>>>>>        Local Integer iRetval
81731>>>>>>>
81731>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
81731>>>>>>>        // This error would otherwise be raised when we have an older
81731>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
81731>>>>>>>        Send Ignore_error To Error_object_Id 20491
81732>>>>>>>        Get psDriverID To sDriverID
81733>>>>>>>        Move (Repeat(" ", 255)) To sVersion
81734>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
81739>>>>>>>        Send Trap_Error To Error_object_Id 20491
81740>>>>>>>        If (Trim(sVersion) = "") Begin
81742>>>>>>>            // Unable to get the revision. return all zeroes.
81742>>>>>>>            Move "0.0.0" To sVersion
81743>>>>>>>        End
81743>>>>>>>>
81743>>>>>>>        Function_Return sVersion
81744>>>>>>>    End_Function //  PSQLLocalEngineVersion
81745>>>>>>>
81745>>>>>>>    //***
81745>>>>>>>    //*** Function: PSQLServerEngineVersionInfo
81745>>>>>>>    //*** Purpose : Returns the version information of the
81745>>>>>>>    //***           Pervasive.SQL Server Engine
81745>>>>>>>
81745>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
81747>>>>>>>
81747>>>>>>>        Local String  sDriverID
81747>>>>>>>        Local String  sVersion
81747>>>>>>>        Local String  sVoid
81747>>>>>>>        Local Integer iRetval
81747>>>>>>>
81747>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
81747>>>>>>>        // This error would otherwise be raised when we have an older
81747>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
81747>>>>>>>        Send Ignore_error To Error_object_Id 20491
81748>>>>>>>        Get psDriverID To sDriverID
81749>>>>>>>        Move (Repeat(" ", 255)) To sVersion
81750>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
81755>>>>>>>        Send Trap_Error To Error_object_Id 20491
81756>>>>>>>        If (Trim(sVersion) = "") Begin
81758>>>>>>>            // Unable to get the revision. return all zeroes.
81758>>>>>>>            Move "0.0.0" To sVersion
81759>>>>>>>        End
81759>>>>>>>>
81759>>>>>>>        Function_Return sVersion
81760>>>>>>>    End_Function //  PSQLServerEngineVersion
81761>>>>>>>
81761>>>>>>>End_Class // cDfbtrdrvHandler
81762>>>>>>>
81762>>>>>Use cDbUpdateFunctionLibrary.inc
81762>>>>>Use cSQLConnectionIniFile.inc
Including file: cSQLConnectionIniFile.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.inc)
81762>>>>>>>//****************************************************************************
81762>>>>>>>// $Module type: Include file
81762>>>>>>>// $Module name: cSQLConnectionIniFile.inc
81762>>>>>>>//
81762>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
81762>>>>>>>// Copyright (c) 2012 RDC Tools International
81762>>>>>>>// E-mail      : support@rdctools.com
81762>>>>>>>// Web-site    : http://www.rdctools.com
81762>>>>>>>//
81762>>>>>>>// Created     : 2017-01-18 @ 13:04 (Military date format - Year-Month-Day)
81762>>>>>>>//
81762>>>>>>>// Note        : Header file with constant declarations for the cSQLConnectionIniFile class.
81762>>>>>>>//
81762>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
81762>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
81762>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
81762>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
81762>>>>>>>// in the help folder for more details.
81762>>>>>>>//
81762>>>>>>>Use Winkern.pkg
81762>>>>>>>Use cIniFile.pkg
81762>>>>>>>Use cCryptographer.pkg
Including file: cCryptographer.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCryptographer.pkg)
81762>>>>>>>>>Use VdfBase.pkg
81762>>>>>>>>>
81762>>>>>>>>>Use CryptographerConstants.pkg
Including file: CryptographerConstants.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\CryptographerConstants.pkg)
81762>>>>>>>>>>>//                                      
81762>>>>>>>>>>>// File    : CryptographerConstants.pkg
81762>>>>>>>>>>>//
81762>>>>>>>>>>>//   Author  : Ulbe Stellema
81762>>>>>>>>>>>//             Data Access Worldwide
81762>>>>>>>>>>>//
81762>>>>>>>>>>>//   Date    : October 4, 2009
81762>>>>>>>>>>>//
81762>>>>>>>>>>>
81762>>>>>>>>>>>
81762>>>>>>>>>>>
81762>>>>>>>>>>>// Algorithm classes
81762>>>>>>>>>>>Define ALG_CLASS_ANY                    for |CI$00000000 // (0)
81762>>>>>>>>>>>Define ALG_CLASS_SIGNATURE              for |CI$00002000 // (1 << 13)
81762>>>>>>>>>>>Define ALG_CLASS_MSG_ENCRYPT            for |CI$00004000 // (2 << 13)
81762>>>>>>>>>>>Define ALG_CLASS_DATA_ENCRYPT           for |CI$00006000 // (3 << 13)
81762>>>>>>>>>>>Define ALG_CLASS_HASH                   for |CI$00008000 // (4 << 13)
81762>>>>>>>>>>>Define ALG_CLASS_KEY_EXCHANGE           for |CI$0000A000 // (5 << 13)
81762>>>>>>>>>>>Define ALG_CLASS_ALL                    for |CI$0000E000 // (7 << 13)
81762>>>>>>>>>>>
81762>>>>>>>>>>>// Algorithm types
81762>>>>>>>>>>>Define ALG_TYPE_ANY                     for |CI$00000000 // (0)
81762>>>>>>>>>>>Define ALG_TYPE_DSS                     for |CI$00000200 // (1 << 9)
81762>>>>>>>>>>>Define ALG_TYPE_RSA                     for |CI$00000400 // (2 << 9)
81762>>>>>>>>>>>Define ALG_TYPE_BLOCK                   for |CI$00000600 // (3 << 9)
81762>>>>>>>>>>>Define ALG_TYPE_STREAM                  for |CI$00000800 // (4 << 9)
81762>>>>>>>>>>>Define ALG_TYPE_DH                      for |CI$00000A00 // (5 << 9)
81762>>>>>>>>>>>Define ALG_TYPE_SECURECHANNEL           for |CI$00000C00 // (6 << 9)
81762>>>>>>>>>>>
81762>>>>>>>>>>>// Generic sub-ids
81762>>>>>>>>>>>Define ALG_SID_ANY                      for |CI$00000000 // (0)
81762>>>>>>>>>>>
81762>>>>>>>>>>>// RSA sub-ids
81762>>>>>>>>>>>Define ALG_SID_RSA_ANY                  for 0
81762>>>>>>>>>>>Define ALG_SID_RSA_PKCS                 for 1
81762>>>>>>>>>>>Define ALG_SID_RSA_MSATWORK             for 2
81762>>>>>>>>>>>Define ALG_SID_RSA_ENTRUST              for 3
81762>>>>>>>>>>>Define ALG_SID_RSA_PGP                  for 4
81762>>>>>>>>>>>
81762>>>>>>>>>>>// DSS sub-ids
81762>>>>>>>>>>>Define ALG_SID_DSS_ANY                  for 0
81762>>>>>>>>>>>Define ALG_SID_DSS_PKCS                 for 1
81762>>>>>>>>>>>Define ALG_SID_DSS_DMS                  for 2
81762>>>>>>>>>>>
81762>>>>>>>>>>>// DES sub_ids
81762>>>>>>>>>>>Define ALG_SID_DES                      for 1
81762>>>>>>>>>>>Define ALG_SID_3DES                     for 3
81762>>>>>>>>>>>Define ALG_SID_DESX                     for 4
81762>>>>>>>>>>>Define ALG_SID_IDEA                     for 5
81762>>>>>>>>>>>Define ALG_SID_CAST                     for 6
81762>>>>>>>>>>>Define ALG_SID_SAFERSK64                for 7
81762>>>>>>>>>>>Define ALG_SID_SAFERSK128               for 8
81762>>>>>>>>>>>Define ALG_SID_3DES_112                 for 9
81762>>>>>>>>>>>Define ALG_SID_CYLINK_MEK               for 12
81762>>>>>>>>>>>Define ALG_SID_RC5                      for 13
81762>>>>>>>>>>>Define ALG_SID_AES_128                  for 14
81762>>>>>>>>>>>Define ALG_SID_AES_192                  for 15
81762>>>>>>>>>>>Define ALG_SID_AES_256                  for 16
81762>>>>>>>>>>>Define ALG_SID_AES                      for 17
81762>>>>>>>>>>>
81762>>>>>>>>>>>// Fortezza sub-ids
81762>>>>>>>>>>>Define ALG_SID_SKIPJACK                 for 10
81762>>>>>>>>>>>Define ALG_SID_TEK                      for 11
81762>>>>>>>>>>>
81762>>>>>>>>>>>// RC2 sub-ids
81762>>>>>>>>>>>Define ALG_SID_RC2                      for 2
81762>>>>>>>>>>>
81762>>>>>>>>>>>// Stream cipher sub-ids
81762>>>>>>>>>>>Define ALG_SID_RC4                      for 1
81762>>>>>>>>>>>Define ALG_SID_SEAL                     for 2
81762>>>>>>>>>>>
81762>>>>>>>>>>>// Diffie-Hellman sub-ids
81762>>>>>>>>>>>Define ALG_SID_DH_SANDF                 for 1
81762>>>>>>>>>>>Define ALG_SID_DH_EPHEM                 for 2
81762>>>>>>>>>>>Define ALG_SID_AGREED_KEY_ANY           for 3
81762>>>>>>>>>>>Define ALG_SID_KEA                      for 4
81762>>>>>>>>>>>
81762>>>>>>>>>>>// Hash sub ids
81762>>>>>>>>>>>Define ALG_SID_MD2                      for 1
81762>>>>>>>>>>>Define ALG_SID_MD4                      for 2
81762>>>>>>>>>>>Define ALG_SID_MD5                      for 3
81762>>>>>>>>>>>Define ALG_SID_SHA                      for 4
81762>>>>>>>>>>>Define ALG_SID_SHA1                     for 4
81762>>>>>>>>>>>Define ALG_SID_MAC                      for 5
81762>>>>>>>>>>>Define ALG_SID_RIPEMD                   for 6
81762>>>>>>>>>>>Define ALG_SID_RIPEMD160                for 7
81762>>>>>>>>>>>Define ALG_SID_SSL3SHAMD5               for 8
81762>>>>>>>>>>>Define ALG_SID_HMAC                     for 9
81762>>>>>>>>>>>Define ALG_SID_TLS1PRF                  for 10
81762>>>>>>>>>>>Define ALG_SID_HASH_REPLACE_OWF         for 11
81762>>>>>>>>>>>Define ALG_SID_SHA_256                  for 12
81762>>>>>>>>>>>Define ALG_SID_SHA_384                  for 13
81762>>>>>>>>>>>Define ALG_SID_SHA_512                  for 14
81762>>>>>>>>>>>
81762>>>>>>>>>>>// secure channel sub ids
81762>>>>>>>>>>>Define ALG_SID_SSL3_MASTER              for 1
81762>>>>>>>>>>>Define ALG_SID_SCHANNEL_MASTER_HASH     for 2
81762>>>>>>>>>>>Define ALG_SID_SCHANNEL_MAC_KEY         for 3
81762>>>>>>>>>>>Define ALG_SID_PCT1_MASTER              for 4
81762>>>>>>>>>>>Define ALG_SID_SSL2_MASTER              for 5
81762>>>>>>>>>>>Define ALG_SID_TLS1_MASTER              for 6
81762>>>>>>>>>>>Define ALG_SID_SCHANNEL_ENC_KEY         for 7
81762>>>>>>>>>>>
81762>>>>>>>>>>>// algorithm identifier definitions
81762>>>>>>>>>>>Define CALG_MD2                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD2)
81762>>>>>>>>>>>Define CALG_MD4                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD4)
81762>>>>>>>>>>>Define CALG_MD5                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD5)
81762>>>>>>>>>>>Define CALG_SHA                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA)
81762>>>>>>>>>>>Define CALG_SHA1                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA1)
81762>>>>>>>>>>>Define CALG_MAC                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MAC)
81762>>>>>>>>>>>Define CALG_RSA_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
81762>>>>>>>>>>>Define CALG_DSS_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_DSS ior ALG_SID_DSS_ANY)
81762>>>>>>>>>>>Define CALG_NO_SIGN                     for (ALG_CLASS_SIGNATURE ior ALG_TYPE_ANY ior ALG_SID_ANY)
81762>>>>>>>>>>>Define CALG_RSA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
81762>>>>>>>>>>>Define CALG_DES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DES)
81762>>>>>>>>>>>Define CALG_3DES_112                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES_112)
81762>>>>>>>>>>>Define CALG_3DES                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES)
81762>>>>>>>>>>>Define CALG_DESX                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DESX)
81762>>>>>>>>>>>Define CALG_RC2                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC2)
81762>>>>>>>>>>>Define CALG_RC4                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_RC4)
81762>>>>>>>>>>>Define CALG_SEAL                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_SEAL)
81762>>>>>>>>>>>Define CALG_DH_SF                       for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_SANDF)
81762>>>>>>>>>>>Define CALG_DH_EPHEM                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_EPHEM)
81762>>>>>>>>>>>Define CALG_AGREEDKEY_ANY               for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_AGREED_KEY_ANY)
81762>>>>>>>>>>>Define CALG_KEA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_KEA)
81762>>>>>>>>>>>Define CALG_HUGHES_MD5                  for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_ANY ior ALG_SID_MD5)
81762>>>>>>>>>>>Define CALG_SKIPJACK                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_SKIPJACK)
81762>>>>>>>>>>>Define CALG_TEK                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_TEK)
81762>>>>>>>>>>>Define CALG_CYLINK_MEK                  for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_CYLINK_MEK)
81762>>>>>>>>>>>Define CALG_SSL3_SHAMD5                 for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SSL3SHAMD5)
81762>>>>>>>>>>>Define CALG_SSL3_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL3_MASTER)
81762>>>>>>>>>>>Define CALG_SCHANNEL_MASTER_HASH        for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MASTER_HASH)
81762>>>>>>>>>>>Define CALG_SCHANNEL_MAC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MAC_KEY)
81762>>>>>>>>>>>Define CALG_SCHANNEL_ENC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_ENC_KEY)
81762>>>>>>>>>>>Define CALG_PCT1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_PCT1_MASTER)
81762>>>>>>>>>>>Define CALG_SSL2_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL2_MASTER)
81762>>>>>>>>>>>Define CALG_TLS1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_TLS1_MASTER)
81762>>>>>>>>>>>Define CALG_RC5                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC5)
81762>>>>>>>>>>>Define CALG_HMAC                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HMAC)
81762>>>>>>>>>>>Define CALG_TLS1PRF                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_TLS1PRF)
81762>>>>>>>>>>>Define CALG_HASH_REPLACE_OWF            for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HASH_REPLACE_OWF)
81762>>>>>>>>>>>Define CALG_AES_128                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_128)
81762>>>>>>>>>>>Define CALG_AES_192                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_192)
81762>>>>>>>>>>>Define CALG_AES_256                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_256)
81762>>>>>>>>>>>Define CALG_AES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES)
81762>>>>>>>>>>>Define CALG_SHA_256                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_256)
81762>>>>>>>>>>>Define CALG_SHA_384                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_384)
81762>>>>>>>>>>>Define CALG_SHA_512                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_512)
81762>>>>>>>>>>>
81762>>>>>>>>>>>// Providers
81762>>>>>>>>>>>Define MS_DEF_PROV                      for "Microsoft Base Cryptographic Provider v1.0"
81762>>>>>>>>>>>Define MS_ENHANCED_PROV                 for "Microsoft Enhanced Cryptographic Provider v1.0"
81762>>>>>>>>>>>Define MS_STRONG_PROV                   for "Microsoft Strong Cryptographic Provider"
81762>>>>>>>>>>>Define MS_DEF_RSA_SIG_PROV              for "Microsoft RSA Signature Cryptographic Provider"
81762>>>>>>>>>>>Define MS_DEF_RSA_SCHANNEL_PROV         for "Microsoft RSA SChannel Cryptographic Provider"
81762>>>>>>>>>>>Define MS_DEF_DSS_PROV                  for "Microsoft Base DSS Cryptographic Provider"
81762>>>>>>>>>>>Define MS_DEF_DSS_DH_PROV               for "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
81762>>>>>>>>>>>Define MS_ENH_DSS_DH_PROV               for "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
81762>>>>>>>>>>>Define MS_DEF_DH_SCHANNEL_PROV          for "Microsoft DH SChannel Cryptographic Provider"
81762>>>>>>>>>>>Define MS_SCARD_PROV                    for "Microsoft Base Smart Card Crypto Provider"
81762>>>>>>>>>>>Define MS_ENH_RSA_AES_PROV              for "Microsoft Enhanced RSA and AES Cryptographic Provider"
81762>>>>>>>>>>>
81762>>>>>>>>>>>// dwFlags definitions for CryptAcquireContext
81762>>>>>>>>>>>Define CRYPT_VERIFYCONTEXT              for |CI$F0000000
81762>>>>>>>>>>>Define CRYPT_NEWKEYSET                  for |CI$00000008
81762>>>>>>>>>>>Define CRYPT_DELETEKEYSET               for |CI$00000010
81762>>>>>>>>>>>Define CRYPT_MACHINE_KEYSET             for |CI$00000020
81762>>>>>>>>>>>Define CRYPT_SILENT                     for |CI$00000040
81762>>>>>>>>>>>
81762>>>>>>>>>>>// dwFlag definitions for CryptGenKey
81762>>>>>>>>>>>Define CRYPT_EXPORTABLE                 for |CI$00000001
81762>>>>>>>>>>>Define CRYPT_USER_PROTECTED             for |CI$00000002
81762>>>>>>>>>>>Define CRYPT_CREATE_SALT                for |CI$00000004
81762>>>>>>>>>>>Define CRYPT_UPDATE_KEY                 for |CI$00000008
81762>>>>>>>>>>>Define CRYPT_NO_SALT                    for |CI$00000010
81762>>>>>>>>>>>Define CRYPT_PREGEN                     for |CI$00000040
81762>>>>>>>>>>>Define CRYPT_RECIPIENT                  for |CI$00000010
81762>>>>>>>>>>>Define CRYPT_INITIATOR                  for |CI$00000040
81762>>>>>>>>>>>Define CRYPT_ONLINE                     for |CI$00000080
81762>>>>>>>>>>>Define CRYPT_SF                         for |CI$00000100
81762>>>>>>>>>>>Define CRYPT_CREATE_IV                  for |CI$00000200
81762>>>>>>>>>>>Define CRYPT_KEK                        for |CI$00000400
81762>>>>>>>>>>>Define CRYPT_DATA_KEY                   for |CI$00000800
81762>>>>>>>>>>>Define CRYPT_VOLATILE                   for |CI$00001000
81762>>>>>>>>>>>Define CRYPT_SGCKEY                     for |CI$00002000
81762>>>>>>>>>>>Define CRYPT_ARCHIVABLE                 for |CI$00004000
81762>>>>>>>>>>>
81762>>>>>>>>>>>// Provider types
81762>>>>>>>>>>>Define PROV_RSA_FULL                    for 1
81762>>>>>>>>>>>Define PROV_RSA_SIG                     for 2
81762>>>>>>>>>>>Define PROV_DSS                         for 3
81762>>>>>>>>>>>Define PROV_FORTEZZA                    for 4
81762>>>>>>>>>>>Define PROV_MS_EXCHANGE                 for 5
81762>>>>>>>>>>>Define PROV_SSL                         for 6
81762>>>>>>>>>>>Define PROV_RSA_SCHANNEL                for 12
81762>>>>>>>>>>>Define PROV_DSS_DH                      for 13
81762>>>>>>>>>>>Define PROV_EC_ECDSA_SIG                for 14
81762>>>>>>>>>>>Define PROV_EC_ECNRA_SIG                for 15
81762>>>>>>>>>>>Define PROV_EC_ECDSA_FULL               for 16
81762>>>>>>>>>>>Define PROV_EC_ECNRA_FULL               for 17
81762>>>>>>>>>>>Define PROV_DH_SCHANNEL                 for 18
81762>>>>>>>>>>>Define PROV_SPYRUS_LYNKS                for 20
81762>>>>>>>>>>>Define PROV_RNG                         for 21
81762>>>>>>>>>>>Define PROV_INTEL_SEC                   for 22
81762>>>>>>>>>>>Define PROV_REPLACE_OWF                 for 23
81762>>>>>>>>>>>Define PROV_RSA_AES                     for 24
81762>>>>>>>>>>>
81762>>>>>>>>>>>// KP_MODE
81762>>>>>>>>>>>// KP_MODE
81762>>>>>>>>>>>Define CRYPT_MODE_CBC                   for 1       // Cipher block chaining
81762>>>>>>>>>>>Define CRYPT_MODE_ECB                   for 2       // Electronic code book
81762>>>>>>>>>>>Define CRYPT_MODE_OFB                   for 3       // Output feedback mode
81762>>>>>>>>>>>Define CRYPT_MODE_CFB                   for 4       // Cipher feedback mode
81762>>>>>>>>>>>Define CRYPT_MODE_CTS                   for 5       // Ciphertext stealing mode
81762>>>>>>>>>>>Define CRYPT_MODE_CBCI                  for 6       // ANSI CBC Interleaved
81762>>>>>>>>>>>Define CRYPT_MODE_CFBP                  for 7       // ANSI CFB Pipelined
81762>>>>>>>>>>>Define CRYPT_MODE_OFBP                  for 8       // ANSI OFB Pipelined
81762>>>>>>>>>>>Define CRYPT_MODE_CBCOFM                for 9       // ANSI CBC + OF Masking
81762>>>>>>>>>>>Define CRYPT_MODE_CBCOFMI               for 10      // ANSI CBC + OFM Interleaved
81762>>>>>>>>>>>
81762>>>>>>>>>>>// dwParam definitions for CryptGetKeyParam
81762>>>>>>>>>>>Define KP_IV                            for 1       // Initialization vector
81762>>>>>>>>>>>Define KP_SALT                          for 2       // Salt value
81762>>>>>>>>>>>Define KP_PADDING                       for 3       // Padding values
81762>>>>>>>>>>>Define KP_MODE                          for 4       // Mode of the cipher
81762>>>>>>>>>>>Define KP_MODE_BITS                     for 5       // Number of bits to feedback
81762>>>>>>>>>>>Define KP_PERMISSIONS                   for 6       // Key permissions DWORD
81762>>>>>>>>>>>Define KP_ALGID                         for 7       // Key algorithm
81762>>>>>>>>>>>Define KP_BLOCKLEN                      for 8       // Block size of the cipher
81762>>>>>>>>>>>Define KP_KEYLEN                        for 9       // Length of key in bits
81762>>>>>>>>>>>Define KP_SALT_EX                       for 10      // Length of salt in bytes
81762>>>>>>>>>>>Define KP_P                             for 11      // DSS/Diffie-Hellman P value
81762>>>>>>>>>>>Define KP_G                             for 12      // DSS/Diffie-Hellman G value
81762>>>>>>>>>>>Define KP_Q                             for 13      // DSS Q value
81762>>>>>>>>>>>Define KP_X                             for 14      // Diffie-Hellman X value
81762>>>>>>>>>>>Define KP_Y                             for 15      // Y value
81762>>>>>>>>>>>Define KP_RA                            for 16      // Fortezza RA value
81762>>>>>>>>>>>Define KP_RB                            for 17      // Fortezza RB value
81762>>>>>>>>>>>Define KP_INFO                          for 18      // for putting information into an RSA envelope
81762>>>>>>>>>>>Define KP_EFFECTIVE_KEYLEN              for 19      // setting and getting RC2 effective key length
81762>>>>>>>>>>>Define KP_SCHANNEL_ALG                  for 20      // for setting the Secure Channel algorithms
81762>>>>>>>>>>>Define KP_CLIENT_RANDOM                 for 21      // for setting the Secure Channel client random data
81762>>>>>>>>>>>Define KP_SERVER_RANDOM                 for 22      // for setting the Secure Channel server random data
81762>>>>>>>>>>>Define KP_RP                            for 23
81762>>>>>>>>>>>Define KP_PRECOMP_MD5                   for 24
81762>>>>>>>>>>>Define KP_PRECOMP_SHA                   for 25
81762>>>>>>>>>>>Define KP_CERTIFICATE                   for 26      // for setting Secure Channel certificate data (PCT1)
81762>>>>>>>>>>>Define KP_CLEAR_KEY                     for 27      // for setting Secure Channel clear key data (PCT1)
81762>>>>>>>>>>>Define KP_PUB_EX_LEN                    for 28
81762>>>>>>>>>>>Define KP_PUB_EX_VAL                    for 29
81762>>>>>>>>>>>Define KP_KEYVAL                        for 30
81762>>>>>>>>>>>Define KP_ADMIN_PIN                     for 31
81762>>>>>>>>>>>Define KP_KEYEXCHANGE_PIN               for 32
81762>>>>>>>>>>>Define KP_SIGNATURE_PIN                 for 33
81762>>>>>>>>>>>Define KP_PREHASH                       for 34
81762>>>>>>>>>>>Define KP_ROUNDS                        for 35
81762>>>>>>>>>>>Define KP_OAEP_PARAMS                   for 36      // for setting OAEP params on RSA keys
81762>>>>>>>>>>>Define KP_CMS_KEY_INFO                  for 37
81762>>>>>>>>>>>Define KP_CMS_DH_KEY_INFO               for 38
81762>>>>>>>>>>>Define KP_PUB_PARAMS                    for 39      // for setting public parameters
81762>>>>>>>>>>>Define KP_VERIFY_PARAMS                 for 40      // for verifying DSA and DH parameters
81762>>>>>>>>>>>Define KP_HIGHEST_VERSION               for 41      // for TLS protocol version setting
81762>>>>>>>>>>>Define KP_GET_USE_COUNT                 for 42      // for use with PP_CRYPT_COUNT_KEY_USE contexts
81762>>>>>>>>>>>
81762>>>>>>>>>>>// dwParam definitions for CryptGetHashParam
81762>>>>>>>>>>>Define HP_ALGID                         for |CI$0001  // Hash algorithm
81762>>>>>>>>>>>Define HP_HASHVAL                       for |CI$0002  // Hash value
81762>>>>>>>>>>>Define HP_HASHSIZE                      for |CI$0004  // Hash value size
81762>>>>>>>>>>>Define HP_HMAC_INFO                     for |CI$0005  // information for creating an HMA
81762>>>>>>>>>>>
81762>>>>>>>>>>>// key BLOB types
81762>>>>>>>>>>>Define KEYSTATEBLOB                     for |CI$0C
81762>>>>>>>>>>>Define OPAQUEKEYBLOB                    for |CI$09
81762>>>>>>>>>>>Define PLAINTEXTKEYBLOB                 for |CI$08
81762>>>>>>>>>>>Define PRIVATEKEYBLOB                   for |CI$07
81762>>>>>>>>>>>Define PUBLICKEYBLOB                    for |CI$06
81762>>>>>>>>>>>Define PUBLICKEYBLOBEX                  for |CI$0A
81762>>>>>>>>>>>Define SIMPLEBLOB                       for |CI$01
81762>>>>>>>>>>>Define SYMMETRICWRAPKEYBLOB             for |CI$0B
81762>>>>>>>>>>>
81762>>>>>>>>>>>Define CUR_BLOB_VERSION                 for 2
81762>>>>>>>>>>>
81762>>>>>>>>>>>//  Structure cryptimportkey
81762>>>>>>>>>>>Struct PUBLICKEYSTRUC
81762>>>>>>>>>>>    UChar    bType
81762>>>>>>>>>>>    UChar    bVersion
81762>>>>>>>>>>>    UShort   reserved
81762>>>>>>>>>>>    UInteger aiKeyAlg
81762>>>>>>>>>>>End_Struct
81762>>>>>>>>>>>
81762>>>>>>>>>>>Struct tPLAINTEXTKEYBLOB
81762>>>>>>>>>>>    PUBLICKEYSTRUC hdr
81762>>>>>>>>>>>    PUBLICKEYSTRUC hdr
81762>>>>>>>>>>>    UInteger       dwKeySize
81762>>>>>>>>>>>//    UChar[]        rgbKeyData
81762>>>>>>>>>>>End_Struct
81762>>>>>>>>>>>
81762>>>>>>>>>>>
81762>>>>>>>>>>>
81762>>>>>>>>>>>//  Structure for specifying the inner and outer strings when calculating HMAC hash (use with CryptSetHashParam)
81762>>>>>>>>>>>Struct HMAC_INFO
81762>>>>>>>>>>>    UInteger HashAlgid
81762>>>>>>>>>>>    Pointer pbInnerString
81762>>>>>>>>>>>    DWord cbInnerString
81762>>>>>>>>>>>    Pointer pbOuterString
81762>>>>>>>>>>>    DWord cbOuterString
81762>>>>>>>>>>>End_Struct
81762>>>>>>>>>>>
81762>>>>>>>>>>>
81762>>>>>>>>>>>External_Function CryptAcquireContext "CryptAcquireContextA" advapi32.dll ;    Pointer phProv ;    Pointer szContainer ;    Pointer szProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
81763>>>>>>>>>>>
81763>>>>>>>>>>>External_Function CryptReleaseContext "CryptReleaseContext" advapi32.dll ;    Handle hProv ;    Integer dwFlags ;    Returns Boolean
81764>>>>>>>>>>>
81764>>>>>>>>>>>External_Function CryptCreateHash "CryptCreateHash" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hKey ;    Integer dwFlags ;    Pointer phHash ;    Returns Boolean
81765>>>>>>>>>>>
81765>>>>>>>>>>>External_Function CryptDestroyHash "CryptDestroyHash" advapi32.dll ;    Handle hHash ;    Returns Boolean
81766>>>>>>>>>>>
81766>>>>>>>>>>>External_Function CryptHashData "CryptHashData" advapi32.dll ;    Handle hHash ;    Pointer pbData ;    Integer dwDataLen ;    Integer dwFlags ;    Returns Boolean
81767>>>>>>>>>>>
81767>>>>>>>>>>>External_Function CryptDeriveKey "CryptDeriveKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hBaseData ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
81768>>>>>>>>>>>
81768>>>>>>>>>>>External_Function CryptGetHashParam "CryptGetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    DWord dwFlags ;    Returns Integer
81769>>>>>>>>>>>
81769>>>>>>>>>>>External_Function CryptDestroyKey "CryptDestroyKey" advapi32.dll ;    Handle hKey ;    Returns Boolean
81770>>>>>>>>>>>
81770>>>>>>>>>>>External_Function CryptImportKey "CryptImportKey" advapi32.dll ;    Handle hProv ;    Pointer pbData ;    Integer dwDataLen ;    Handle hPubKey ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
81771>>>>>>>>>>>
81771>>>>>>>>>>>External_Function CryptGetKeyParam "CryptGetKeyParam" advapi32.dll ;    Handle hKey ;    Integer dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwFlags ;    Returns Boolean
81772>>>>>>>>>>>    
81772>>>>>>>>>>>External_Function CryptSetKeyParam "CryptSetKeyParam" advapi32.dll ;    Handle   hKey ;    UInteger dwParam ;    Pointer  pbdata ;    UInteger dwFlags ;    Returns  Boolean
81773>>>>>>>>>>>
81773>>>>>>>>>>>External_Function CryptEncrypt "CryptEncrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwBufLen ;    Returns Boolean
81774>>>>>>>>>>>
81774>>>>>>>>>>>External_Function CryptDecrypt "CryptDecrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
81775>>>>>>>>>>>
81775>>>>>>>>>>>External_Function CryptGenRandom "CryptGenRandom" advapi32.dll ;    Handle hProv ;    DWord dwLen ;    Pointer pbBuffer ;    Returns Boolean
81776>>>>>>>>>>>    
81776>>>>>>>>>>>External_Function CryptSetHashParam "CryptSetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Integer dwFlags ;    Returns Boolean
81777>>>>>>>>>>>    
81777>>>>>>>>>
81777>>>>>>>>>Class cCryptographer is a cObject
81778>>>>>>>>>    
81778>>>>>>>>>    // Procedure : Construct_Object
81778>>>>>>>>>    // Purpose   : Object constructor
81778>>>>>>>>>    Procedure Construct_Object
81780>>>>>>>>>        Forward Send Construct_Object
81782>>>>>>>>>
81782>>>>>>>>>        Property String     psProvider  MS_ENHANCED_PROV
81783>>>>>>>>>        Property Integer    piProvider  PROV_RSA_FULL
81784>>>>>>>>>        Property Integer    piCipher    CALG_RC4
81785>>>>>>>>>        Property Integer    piHash      CALG_MD5
81786>>>>>>>>>        
81786>>>>>>>>>        // Private properties
81786>>>>>>>>>        Property Handle     Private_phProv
81787>>>>>>>>>    End_Procedure
81788>>>>>>>>>    
81788>>>>>>>>>    
81788>>>>>>>>>    // Function : AcquireContext
81788>>>>>>>>>    // Purpose  : Acquire key container handle
81788>>>>>>>>>    Function AcquireContext Returns Handle
81790>>>>>>>>>        Integer iProvider
81790>>>>>>>>>        String sProvider
81790>>>>>>>>>        Handle hProv
81790>>>>>>>>>        Boolean bOk
81790>>>>>>>>>        Address addrProv
81790>>>>>>>>>        
81790>>>>>>>>>        Move 0 to hProv
81791>>>>>>>>>        Get piProvider to iProvider
81792>>>>>>>>>        Get psProvider to sProvider
81793>>>>>>>>>        
81793>>>>>>>>>        //  Determine address to be passed as provider
81793>>>>>>>>>        If (Trim(sProvider) <> "") Begin
81795>>>>>>>>>            Move (AddressOf(sProvider)) to addrProv
81796>>>>>>>>>        End
81796>>>>>>>>>>
81796>>>>>>>>>        Else Begin
81797>>>>>>>>>            Move 0 to addrProv
81798>>>>>>>>>        End
81798>>>>>>>>>>
81798>>>>>>>>>        
81798>>>>>>>>>        //  Acquire Crypto Context
81798>>>>>>>>>        Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_VERIFYCONTEXT)) to bOk
81799>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
81801>>>>>>>>>            Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_NEWKEYSET ior CRYPT_VERIFYCONTEXT)) to bOk
81802>>>>>>>>>        End
81802>>>>>>>>>>
81802>>>>>>>>>        
81802>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
81804>>>>>>>>>            // Fallback to original
81804>>>>>>>>>            Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,0)) to bOk
81805>>>>>>>>>            
81805>>>>>>>>>            If (not(bOk) or hProv = 0) Begin
81807>>>>>>>>>                Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_NEWKEYSET)) to bOk
81808>>>>>>>>>            End
81808>>>>>>>>>>
81808>>>>>>>>>        End
81808>>>>>>>>>>
81808>>>>>>>>>        Set Private_phProv to hProv
81809>>>>>>>>>        
81809>>>>>>>>>        Function_Return hProv
81810>>>>>>>>>    End_Function
81811>>>>>>>>>    
81811>>>>>>>>>    // Function : ReleaseContext
81811>>>>>>>>>    // Purpose  : Releases key container handle
81811>>>>>>>>>    Function ReleaseContext Handle hProv Returns Boolean
81813>>>>>>>>>        Function_Return (CryptReleaseContext(hProv,0))
81814>>>>>>>>>    End_Function
81815>>>>>>>>>    
81815>>>>>>>>>    // Function : CreateHash
81815>>>>>>>>>    // Purpose  : Creates hash object
81815>>>>>>>>>    Function CreateHash Handle hProv Returns Handle
81817>>>>>>>>>        Integer iAlgorithm
81817>>>>>>>>>        Handle hHash
81817>>>>>>>>>        Boolean bOk
81817>>>>>>>>>        
81817>>>>>>>>>        Move 0 to hHash
81818>>>>>>>>>        Get piHash to iAlgorithm
81819>>>>>>>>>        Move (CryptCreateHash(hProv,iAlgorithm,0,0,AddressOf(hHash))) to bOk
81820>>>>>>>>>        
81820>>>>>>>>>        Function_Return hHash
81821>>>>>>>>>    End_Function
81822>>>>>>>>>    
81822>>>>>>>>>    // Function : DestroyHash
81822>>>>>>>>>    // Purpose  : Destroys the hash object
81822>>>>>>>>>    Function DestroyHash Handle hHash Returns Boolean
81824>>>>>>>>>        Function_Return (CryptDestroyHash(hHash))
81825>>>>>>>>>    End_Function
81826>>>>>>>>>    
81826>>>>>>>>>    // Function : HashData
81826>>>>>>>>>    // Purpose  : Adds data to hash object
81826>>>>>>>>>    Function HashData Handle hHash String sData Returns Boolean
81828>>>>>>>>>        Function_Return (CryptHashData(hHash,AddressOf(sData),Length(sData),0))
81829>>>>>>>>>    End_Function
81830>>>>>>>>>    
81830>>>>>>>>>    // Function : DeriveKey
81830>>>>>>>>>    // Purpose  : Generates session key
81830>>>>>>>>>    Function DeriveKey Handle hProv Handle hHash Returns Handle
81832>>>>>>>>>        Integer iAlgorithm
81832>>>>>>>>>        Handle hKey
81832>>>>>>>>>        Boolean bOk
81832>>>>>>>>>        
81832>>>>>>>>>        Move 0 to hKey
81833>>>>>>>>>        Get piCipher to iAlgorithm
81834>>>>>>>>>        Move (CryptDeriveKey(hProv,iAlgorithm,hHash,CRYPT_EXPORTABLE,AddressOf(hKey))) to bOk
81835>>>>>>>>>        
81835>>>>>>>>>        Function_Return hKey
81836>>>>>>>>>    End_Function
81837>>>>>>>>>    
81837>>>>>>>>>    // Function : ImportPlainTextKey
81837>>>>>>>>>    // Purpose  : Imports a plain text key
81837>>>>>>>>>    Function ImportPlainTextKey Handle hProv UChar[] ucaKey Returns Handle
81839>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
81839>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
81839>>>>>>>>>        Boolean   bSuccess
81839>>>>>>>>>        Handle    hKey
81839>>>>>>>>>        Integer   iHeadSize iKeySize
81839>>>>>>>>>        UChar[]   ucaKeyblob
81840>>>>>>>>>        Integer iVoid
81840>>>>>>>>>    
81840>>>>>>>>>        Move (SizeOfType(tPLAINTEXTKEYBLOB)) to iHeadSize
81841>>>>>>>>>        Move (SizeOfArray(ucaKey)) to iKeySize
81842>>>>>>>>>    
81842>>>>>>>>>        Move PLAINTEXTKEYBLOB to blobhead.hdr.bType
81843>>>>>>>>>        Move CUR_BLOB_VERSION   to blobhead.hdr.bVersion
81844>>>>>>>>>        Get piCipher            to blobhead.hdr.aiKeyAlg
81845>>>>>>>>>        Move iKeySize           to blobhead.dwKeySize
81846>>>>>>>>>    
81846>>>>>>>>>        Move (ResizeArray(ucaKeyblob, iHeadSize)) to ucaKeyblob
81847>>>>>>>>>        Move (CopyMemory(AddressOf(ucaKeyblob), AddressOf(blobhead), iHeadSize)) to iVoid
81848>>>>>>>>>        Move (AppendArray(ucaKeyblob, ucaKey)) to ucaKeyblob
81849>>>>>>>>>    
81849>>>>>>>>>        Move 0 to hKey
81850>>>>>>>>>        Move (CryptImportKey(hProv, AddressOf(ucaKeyblob), SizeOfArray(ucaKeyblob), 0, 0, AddressOf(hKey))) to bSuccess
81851>>>>>>>>>        If (not(bSuccess)) Begin 
81853>>>>>>>>>            Move (ShowLastError()) to iVoid
81854>>>>>>>>>        End
81854>>>>>>>>>>
81854>>>>>>>>>    
81854>>>>>>>>>        Function_Return hKey
81855>>>>>>>>>    End_Function
81856>>>>>>>>>
81856>>>>>>>>>    // Function : DestroyKey
81856>>>>>>>>>    // Purpose  : Destroys the key
81856>>>>>>>>>    Function DestroyKey Handle hKey Returns Boolean
81858>>>>>>>>>        Function_Return (CryptDestroyKey(hKey))
81859>>>>>>>>>    End_Function
81860>>>>>>>>>    
81860>>>>>>>>>    // Function : KeyParameter
81860>>>>>>>>>    // Purpose  : Retrieves key data
81860>>>>>>>>>    Function KeyParameter Handle hKey Integer iQuery Returns Integer
81862>>>>>>>>>        Integer iBuffer iLen
81862>>>>>>>>>        Boolean bOk
81862>>>>>>>>>        
81862>>>>>>>>>        Move (SizeOfType(Integer)) to iLen
81863>>>>>>>>>        Move (CryptGetKeyParam(hKey,iQuery,AddressOf(iBuffer),AddressOf(iLen),0)) to bOk
81864>>>>>>>>>        Function_Return iBuffer
81865>>>>>>>>>    End_Function
81866>>>>>>>>>    
81866>>>>>>>>>    // Function : HashValue
81866>>>>>>>>>    // Purpose  : Retrieves a hash value
81866>>>>>>>>>    Function HashValue Handle lhHash Returns String
81868>>>>>>>>>        Pointer lpSize
81868>>>>>>>>>        Pointer lpHash
81868>>>>>>>>>        String  lsSize
81868>>>>>>>>>        String  lsHash
81868>>>>>>>>>        Integer liResult
81868>>>>>>>>>
81868>>>>>>>>>        Move (Repeat(Character(0),4)) to lsSize
81869>>>>>>>>>        GetAddress of lsSize to lpSize
81870>>>>>>>>>
81870>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,0,lpSize,0)) to liResult
81871>>>>>>>>>        If (liResult = 0) Function_Return ""
81874>>>>>>>>>
81874>>>>>>>>>        Move (Repeat(Character(0),BytesTodWord(lsSize,1))) to lsHash
81875>>>>>>>>>        GetAddress of lsHash to lpHash
81876>>>>>>>>>
81876>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,lpHash,lpSize,0)) to liResult
81877>>>>>>>>>        If (liResult = 0) Function_Return ""
81880>>>>>>>>>
81880>>>>>>>>>        Function_Return lsHash
81881>>>>>>>>>    End_Function  // HashValue
81882>>>>>>>>>    
81882>>>>>>>>>            
81882>>>>>>>>>    // Function : Encrypt
81882>>>>>>>>>    // Purpose  : Encrypts data
81882>>>>>>>>>    Function Encrypt String sPassword String sData Returns String
81884>>>>>>>>>        Handle hProv hHash hKey
81884>>>>>>>>>        Integer iAlgorithm iDataLen iCipherLen iErr
81884>>>>>>>>>        Boolean bOk
81884>>>>>>>>>        
81884>>>>>>>>>        Get AcquireContext to hProv
81885>>>>>>>>>        If (hProv) Begin
81887>>>>>>>>>            Get CreateHash hProv to hHash
81888>>>>>>>>>            If (hHash) Begin
81890>>>>>>>>>                Get HashData hHash sPassword to bOk
81891>>>>>>>>>                If (bOk) Begin
81893>>>>>>>>>                    Get piCipher to iAlgorithm
81894>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
81895>>>>>>>>>                End // If (bOk) Begin            
81895>>>>>>>>>>
81895>>>>>>>>>                Get DestroyHash hHash to bOk
81896>>>>>>>>>            End // If (hHash) Begin
81896>>>>>>>>>>
81896>>>>>>>>>            
81896>>>>>>>>>            If (hKey) Begin
81898>>>>>>>>>                //  First call to determine resulting data size
81898>>>>>>>>>                Move (Length(sData)) to iDataLen
81899>>>>>>>>>                Move (Length(sData)) to iCipherLen
81900>>>>>>>>>                Move (CryptEncrypt(hKey, 0, True, 0, 0, AddressOf(iCipherLen), iDataLen)) to bOk
81901>>>>>>>>>                
81901>>>>>>>>>                //  Reserve space in string
81901>>>>>>>>>                If (iDataLen < iCipherLen) Begin
81903>>>>>>>>>                    Move (sData + Repeat(" ", iCipherLen - iDataLen)) to sData
81904>>>>>>>>>                End
81904>>>>>>>>>>
81904>>>>>>>>>                
81904>>>>>>>>>                //  Call to really decrypt
81904>>>>>>>>>                Move (CryptEncrypt(hKey,0,True,0,AddressOf(sData),AddressOf(iDataLen),Length(sData))) to bOk
81905>>>>>>>>>                //If (not(bOk)) Begin
81905>>>>>>>>>                    //Move "" to sData
81905>>>>>>>>>                    //Move (GetLastError()) to iErr
81905>>>>>>>>>                //End
81905>>>>>>>>>                
81905>>>>>>>>>                Get DestroyKey hKey to bOk
81906>>>>>>>>>            End // If (hKey) Begin
81906>>>>>>>>>>
81906>>>>>>>>>            Get ReleaseContext hProv to bOk
81907>>>>>>>>>        End // If (hProv) Begin
81907>>>>>>>>>>
81907>>>>>>>>>        Function_Return sData
81908>>>>>>>>>    End_Function
81909>>>>>>>>>    
81909>>>>>>>>>    // Function : Decrypt
81909>>>>>>>>>    // Purpose  : Decrypts data
81909>>>>>>>>>    Function Decrypt String sPassword String sData Returns String
81911>>>>>>>>>        Handle hProv hHash hKey
81911>>>>>>>>>        Integer iAlgorithm iDataLen
81911>>>>>>>>>        Boolean bOk
81911>>>>>>>>>        
81911>>>>>>>>>        Get AcquireContext to hProv
81912>>>>>>>>>        If (hProv) Begin
81914>>>>>>>>>            Get CreateHash hProv to hHash
81915>>>>>>>>>            If (hHash) Begin
81917>>>>>>>>>                Get HashData hHash sPassword to bOk
81918>>>>>>>>>                If (bOk) Begin
81920>>>>>>>>>                    Get piCipher to iAlgorithm
81921>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
81922>>>>>>>>>                End // If (bOk) Begin            
81922>>>>>>>>>>
81922>>>>>>>>>                Get DestroyHash hHash to bOk
81923>>>>>>>>>            End // If (hHash) Begin
81923>>>>>>>>>>
81923>>>>>>>>>            
81923>>>>>>>>>            If (hKey) Begin
81925>>>>>>>>>                Move (Length(sData)) to iDataLen
81926>>>>>>>>>                Move (CryptDecrypt(hKey,0,True,0,AddressOf(sData),AddressOf(iDataLen))) to bOk
81927>>>>>>>>>                //If (bOk = False) Move "" to sData
81927>>>>>>>>>                
81927>>>>>>>>>                //  Resulting dat can be shorter as the input string, in that case we shorten the result string
81927>>>>>>>>>                If (Length(sData) > iDataLen) Begin
81929>>>>>>>>>                    Move (Left(sData, iDataLen)) to sData
81930>>>>>>>>>                End
81930>>>>>>>>>>
81930>>>>>>>>>                
81930>>>>>>>>>                Get DestroyKey hKey to bOk
81931>>>>>>>>>            End // If (hKey) Begin
81931>>>>>>>>>>
81931>>>>>>>>>            Get ReleaseContext hProv to bOk
81932>>>>>>>>>        End // If (hProv) Begin
81932>>>>>>>>>>
81932>>>>>>>>>        Function_Return sData
81933>>>>>>>>>    End_Function
81934>>>>>>>>>    
81934>>>>>>>>>    //  Function : GenerateRandom
81934>>>>>>>>>    //  Purpose  : Generates random data.
81934>>>>>>>>>    Function GenerateRandom Integer iBytes Returns UChar[]
81936>>>>>>>>>        Handle hProv
81936>>>>>>>>>        UChar[] uaResult
81937>>>>>>>>>        Boolean bRes
81937>>>>>>>>>        
81937>>>>>>>>>        Get AcquireContext to hProv
81938>>>>>>>>>        
81938>>>>>>>>>        Move (ResizeArray(uaResult, iBytes)) to uaResult
81939>>>>>>>>>        Move (CryptGenRandom(hProv, iBytes, AddressOf(uaResult))) to bRes
81940>>>>>>>>>        
81940>>>>>>>>>        Get ReleaseContext hProv to bRes
81941>>>>>>>>>        
81941>>>>>>>>>        Function_Return uaResult
81942>>>>>>>>>    End_Function
81943>>>>>>>>>    
81943>>>>>>>>>    //  Function : GenerateRandomString
81943>>>>>>>>>    //  Purpose  : Generates random data and does a base64 encoding to properly present it as a string.
81943>>>>>>>>>    Function GenerateRandomString Integer iLenght Returns String
81945>>>>>>>>>        String sResult
81945>>>>>>>>>        UChar[] aData
81946>>>>>>>>>        Address pBase64
81946>>>>>>>>>        Integer iVoid
81946>>>>>>>>>
81946>>>>>>>>>        Get GenerateRandom iLenght to aData
81947>>>>>>>>>        
81947>>>>>>>>>        Move (Base64Encode(AddressOf(aData), iLenght)) to pBase64
81948>>>>>>>>>        Move pBase64 to sResult
81949>>>>>>>>>        Move (Free(pBase64)) to iVoid    
81950>>>>>>>>>        
81950>>>>>>>>>        Function_Return (Left(sResult, iLenght))
81951>>>>>>>>>    End_Function
81952>>>>>>>>>
81952>>>>>>>>>End_Class
81953>>>>>>>Use Base64Functions.pkg
Including file: Base64Functions.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\Base64Functions.pkg)
81953>>>>>>>>>//> This package enables base64 encoding and decoding of strings:
81953>>>>>>>>>//>
81953>>>>>>>>>//>     Get EncodeString of oBase64Functions sValue to sValue
81953>>>>>>>>>//>     Get DecodeString of oBase64Functions sValue to sValue
81953>>>>>>>>>//>
81953>>>>>>>>>//> Remember to set the "max argument size" if dealing with very large
81953>>>>>>>>>//> strings.
81953>>>>>>>>>//>
81953>>>>>>>>>//> For 17.1 and later the functionality of this package is based on two functions (Base64Encode and
81953>>>>>>>>>//> Base64Decode) that are built into the runtime.
81953>>>>>>>>>//>
81953>>>>>>>>>//> But for versions up to and including 17.0 it's based on the vdfBase64.dll file that was obtained
81953>>>>>>>>>//> from DAE that have kindly allowed me to distribute it to other DF developers. Programs including
81953>>>>>>>>>//> this package will give off an error on start-up if vdfBase64.dll is not found in the /bin folder
81953>>>>>>>>>//> if the VDF runtime. You will find the DLL in the /programs folder of the StureApsPublicLib workspace
81953>>>>>>>>>
81953>>>>>>>>>Use VdfBase.pkg
81953>>>>>>>>>
81953>>>>>>>>>// Functions in vdfBase64.dll
81953>>>>>>>>>External_Function xxBase64Encode "vdfbase64Encode" vdfBase64.dll Pointer pBuffer Returns Integer
81954>>>>>>>>>External_Function xxBase64Decode "vdfbase64Decode" vdfBase64.dll Pointer pBuffer Returns Integer
81955>>>>>>>>>External_Function xxBase64Free   "vdfbase64Free"   vdfBase64.dll Pointer pBuffer Returns Integer
81956>>>>>>>>>
81956>>>>>>>>>// Structure
81956>>>>>>>>>Struct txxfBase64Buffer
81956>>>>>>>>>    Pointer pData
81956>>>>>>>>>    Integer iLength
81956>>>>>>>>>End_Struct
81956>>>>>>>>>
81956>>>>>>>>>Global_Variable Integer oBase64Functions
81956>>>>>>>>>
81956>>>>>>>>>Object _oBase64Functions is a cObject
81958>>>>>>>>>    Move Self to oBase64Functions
81959>>>>>>>>>
81959>>>>>>>>>
81959>>>>>>>>>    Function EncodeString String sValue Returns String
81962>>>>>>>>>        Address pBase64
81962>>>>>>>>>        String sResult
81962>>>>>>>>>        Integer iVoid
81962>>>>>>>>>        Move (Base64Encode(AddressOf(sValue), Length(sValue))) to pBase64
81963>>>>>>>>>        Move pBase64 to sResult
81964>>>>>>>>>        Move (Free(pBase64)) to iVoid
81965>>>>>>>>>        Function_Return sResult
81966>>>>>>>>>    End_Function
81967>>>>>>>>>
81967>>>>>>>>>    Function DecodeString String sValue Returns String
81970>>>>>>>>>        Address pBinary
81970>>>>>>>>>        String sBinary
81970>>>>>>>>>        Integer iVoid iLen
81970>>>>>>>>>        Move (Base64Decode(AddressOf(sValue), &iLen)) to pBinary
81971>>>>>>>>>        Move (Repeat(Character(0), iLen)) to sBinary
81972>>>>>>>>>        Move (MemCopy(AddressOf(sBinary), pBinary, iLen)) to iVoid
81973>>>>>>>>>        Move (Free(pBinary)) to iVoid
81974>>>>>>>>>        Function_Return sBinary
81975>>>>>>>>>    End_Function
81976>>>>>>>>>
81976>>>>>>>>>End_Object
81977>>>>>>>Use MSSqldrv.pkg
81977>>>>>>>Use db2_drv.pkg
81977>>>>>>>Use odbc_drv.pkg
81977>>>>>>>Use vWin32fh.pkg
81977>>>>>>>
81977>>>>>>>Use DUFLanguageConstants.inc
81977>>>>>>>Use MertechDUF.pkg
Including file: MertechDUF.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\MertechDUF.pkg)
81977>>>>>>>>>//
81977>>>>>>>>>// Use of Mertech drivers:
81977>>>>>>>>>// Put the line "Define DUF_Use_Mertech_Drivers in YOUR code prior the "Use" statement for this package if using Mertech drivers!
81977>>>>>>>>>// And put the line right before the "Use cDbUpdateHandler.pkg" line.
81977>>>>>>>>>//Define DUF_Use_Mertech_Drivers
81977>>>>>>>>>//
#REM DO ~ USE MERTECH.INC
81977>>>>>>>>>// MySQL Data Types
81977>>>>>>>>>Define eMySQL_DECIMAL                               for 0
81977>>>>>>>>>Define eMySQL_TINY                                  for 1
81977>>>>>>>>>Define eMySQL_SHORT                                 for 2
81977>>>>>>>>>Define eMySQL_LONG                                  for 3
81977>>>>>>>>>Define eMySQL_FLOAT                                 for 4
81977>>>>>>>>>Define eMySQL_DOUBLE                                for 5
81977>>>>>>>>>Define eMySQL_NULL                                  for 6
81977>>>>>>>>>Define eMySQL_TIMESTAMP                             for 7
81977>>>>>>>>>Define eMySQL_LONGLONG                              for 8
81977>>>>>>>>>Define eMySQL_INT24                                 for 9
81977>>>>>>>>>Define eMySQL_DATE                                  for 10
81977>>>>>>>>>Define eMySQL_TIME                                  for 11
81977>>>>>>>>>Define eMySQL_DATETIME                              for 12
81977>>>>>>>>>Define eMySQL_YEAR                                  for 13
81977>>>>>>>>>Define eMySQL_NEWDATE                               for 14
81977>>>>>>>>>Define eMySQL_BIT                                   for 16
81977>>>>>>>>>Define eMySQL_NEWDECIMAL                            for 246
81977>>>>>>>>>Define eMySQL_ENUM                                  for 247
81977>>>>>>>>>Define eMySQL_SET                                   for 248
81977>>>>>>>>>Define eMySQL_TINY_BLOB                             for 249
81977>>>>>>>>>Define eMySQL_MEDIUM_BLOB                           for 250
81977>>>>>>>>>Define eMySQL_LONG_BLOB                             for 251
81977>>>>>>>>>Define eMySQL_BLOB                                  for 252
81977>>>>>>>>>Define eMySQL_VAR_STRING                            for 253
81977>>>>>>>>>Define eMySQL_STRING                                for 254
81977>>>>>>>>>Define eMySQL_TINY_TEXT                             for -249
81977>>>>>>>>>Define eMySQL_MEDIUM_TEXT                           for -250
81977>>>>>>>>>Define eMySQL_LONG_TEXT                             for -251
81977>>>>>>>>>Define eMySQL_TEXT                                  for -252
81977>>>>>>>>>
81977>>>>>>>>>// Oracle Data Types
81977>>>>>>>>>Define eOracle_VARCHAR2                             for   1
81977>>>>>>>>>Define eOracle_NUMBER                               for   2
81977>>>>>>>>>Define eOracle_INT                                  for   3
81977>>>>>>>>>Define eOracle_FLOAT                                for   4
81977>>>>>>>>>Define eOracle_STRING                               for   5
81977>>>>>>>>>Define eOracle_LONG                                 for   8
81977>>>>>>>>>Define eOracle_ROWID                                for  11
81977>>>>>>>>>Define eOracle_DATE                                 for  12
81977>>>>>>>>>Define eOracle_RAW                                  for  23
81977>>>>>>>>>Define eOracle_LONGRAW                              for  24
81977>>>>>>>>>Define eOracle_CHAR                                 for  96
81977>>>>>>>>>Define eOracle_MSLABEL                              for 106
81977>>>>>>>>>Define eOracle_CLOB                                 for 112
81977>>>>>>>>>Define eOracle_BLOB                                 for 113
81977>>>>>>>>>Define eOracle_TIMESTAMP                            for 187
81977>>>>>>>>>Define eOracle_TIMESTAMPTZ                          for 188
81977>>>>>>>>>Define eOracle_INTERVALYM                           for 189
81977>>>>>>>>>Define eOracle_INTERVALDS                           for 190
81977>>>>>>>>>Define eOracle_TIMESTAMPLTZ                         for 232
81977>>>>>>>>>Define eOracle_NCHAR                                for 286
81977>>>>>>>>>Define eOracle_NVARCHAR2                            for 287
81977>>>>>>>>>Define eOracle_NCLOB                                for 288
81977>>>>>>>>>
81977>>>>>>>>>// PostgreSQL Data Types
81977>>>>>>>>>Define ePgSQL_CIRCLE                                for  718
81977>>>>>>>>>Define ePgSQL_MONEY                                 for  790
81977>>>>>>>>>Define ePgSQL_BOOL                                  for   16
81977>>>>>>>>>Define ePgSQL_BYTEA                                 for   17
81977>>>>>>>>>Define ePgSQL_CHAR                                  for   18
81977>>>>>>>>>Define ePgSQL_INT2                                  for   21
81977>>>>>>>>>Define ePgSQL_INT4                                  for   23
81977>>>>>>>>>Define ePgSQL_REGPROC                               for   24
81977>>>>>>>>>Define ePgSQL_REGPROCEDURE                          for 2202
81977>>>>>>>>>Define ePgSQL_REGOPER                               for 2203
81977>>>>>>>>>Define ePgSQL_REGOPERATOR                           for 2204
81977>>>>>>>>>Define ePgSQL_REGCLASS                              for 2205
81977>>>>>>>>>Define ePgSQL_REGTYPE                               for 2206
81977>>>>>>>>>Define ePgSQL_TEXT                                  for   25
81977>>>>>>>>>Define ePgSQL_CITEXT                                for  -25
81977>>>>>>>>>Define ePgSQL_OID                                   for   26
81977>>>>>>>>>Define ePgSQL_TID                                   for   27
81977>>>>>>>>>Define ePgSQL_XID                                   for   28
81977>>>>>>>>>Define ePgSQL_CID                                   for   29
81977>>>>>>>>>Define ePgSQL_XML                                   for  142
81977>>>>>>>>>Define ePgSQL_BPCHAR                                for 1042
81977>>>>>>>>>Define ePgSQL_VARCHAR                               for 1043
81977>>>>>>>>>Define ePgSQL_INT8                                  for   20
81977>>>>>>>>>Define ePgSQL_PATH                                  for  602
81977>>>>>>>>>Define ePgSQL_FLOAT4                                for  700
81977>>>>>>>>>Define ePgSQL_FLOAT8                                for  701
81977>>>>>>>>>Define ePgSQL_ABSTIME                               for  702
81977>>>>>>>>>Define ePgSQL_RELTIME                               for  703
81977>>>>>>>>>Define ePgSQL_TINTERVAL                             for  704
81977>>>>>>>>>Define ePgSQL_POINT                                 for  600
81977>>>>>>>>>Define ePgSQL_LINE                                  for  628
81977>>>>>>>>>Define ePgSQL_LSEG                                  for  601
81977>>>>>>>>>Define ePgSQL_BOX                                   for  603
81977>>>>>>>>>Define ePgSQL_POLYGON                               for  604
81977>>>>>>>>>Define ePgSQL_ACLITEM                               for 1033
81977>>>>>>>>>Define ePgSQL_MACADDR                               for  829
81977>>>>>>>>>Define ePgSQL_INET                                  for  869
81977>>>>>>>>>Define ePgSQL_CIDR                                  for  650
81977>>>>>>>>>Define ePgSQL_TIMESTAMP                             for 1114
81977>>>>>>>>>Define ePgSQL_DATE                                  for 1082
81977>>>>>>>>>Define ePgSQL_TIME                                  for 1083
81977>>>>>>>>>Define ePgSQL_TIMESTAMPTZ                           for 1184
81977>>>>>>>>>Define ePgSQL_INTERVAL                              for 1186
81977>>>>>>>>>Define ePgSQL_NUMERIC                               for 1700
81977>>>>>>>>>Define ePgSQL_TIMETZ                                for 1266
81977>>>>>>>>>Define ePgSQL_BIT                                   for 1560
81977>>>>>>>>>Define ePgSQL_VARBIT                                for 1562
81977>>>>>>>>>Define ePgSQL_UUID                                  for 2950
81977>>>>>>>>>
81977>>>>>>>>>// SQL Server Data Types
81977>>>>>>>>>Define eSQLServer_NA                                for    0
81977>>>>>>>>>Define eSQLServer_CHAR                              for    1
81977>>>>>>>>>Define eSQLServer_NUMERIC                           for    2
81977>>>>>>>>>Define eSQLServer_DECIMAL                           for    3
81977>>>>>>>>>Define eSQLServer_INT                               for    4
81977>>>>>>>>>Define eSQLServer_SMALLINT                          for    5
81977>>>>>>>>>Define eSQLServer_FLOAT                             for    6
81977>>>>>>>>>Define eSQLServer_REAL                              for    7
81977>>>>>>>>>Define eSQLServer_DOUBLE                            for    8
81977>>>>>>>>>Define eSQLServer_DATETIME                          for   11
81977>>>>>>>>>Define eSQLServer_VARCHAR                           for   12
81977>>>>>>>>>Define eSQLServer_DATE                              for   40
81977>>>>>>>>>Define eSQLServer_TIME                              for   41
81977>>>>>>>>>Define eSQLServer_DATETIME2                         for   42
81977>>>>>>>>>Define eSQLServer_DATETIMEOFFSET                    for   43
81977>>>>>>>>>Define eSQLServer_SMALLDATETIME                     for   58
81977>>>>>>>>>Define eSQLServer_TIMESTAMP                         for   93
81977>>>>>>>>>Define eSQLServer_HIERARCHYID                       for  128
81977>>>>>>>>>Define eSQLServer_GEOMETRY                          for  129
81977>>>>>>>>>Define eSQLServer_GEOGRAPHY                         for  130
81977>>>>>>>>>Define eSQLServer_TEXT                              for   -1
81977>>>>>>>>>Define eSQLServer_BINARY                            for   -2
81977>>>>>>>>>Define eSQLServer_VARBINARY                         for   -3
81977>>>>>>>>>Define eSQLServer_IMAGE                             for   -4
81977>>>>>>>>>Define eSQLServer_BIGINT                            for   -5
81977>>>>>>>>>Define eSQLServer_TINYINT                           for   -6
81977>>>>>>>>>Define eSQLServer_BIT                               for   -7
81977>>>>>>>>>Define eSQLServer_NCHAR                             for   -8
81977>>>>>>>>>Define eSQLServer_NVARCHAR                          for   -9
81977>>>>>>>>>Define eSQLServer_NTEXT                             for  -10
81977>>>>>>>>>Define eSQLServer_GUID                              for  -11
81977>>>>>>>>>Define eSQLServer_VARBINARYMAX                      for  -98
81977>>>>>>>>>Define eSQLServer_VARCHARMAX                        for  -99
81977>>>>>>>>>Define eSQLServer_NVARCHARMAX                       for -100
81977>>>>>>>>>Define eSQLServer_SQLVARIANT                        for -150
81977>>>>>>>>>Define eSQLServer_XML                               for -370
81977>>>>>>>>>
81977>>>>>>>>>Use cDbUpdateFunctionLibrary.inc
81977>>>>>>>
81977>>>>>>>// This needs to be after Mertech drivers are defined.
81977>>>>>>>Use cDbUpdateFunctionLibrary_Mixin.pkg
81977>>>>>>>
81977>>>>>>>
81977>>>>>>>    Define SQLFLEX   for "SQL_DRV"
81977>>>>>>>
81977>>>>>>>    Define MDSPgSQL  for "MDSPGSQL"
81977>>>>>>>
81977>>>>>>>    Define MDSMySQL  for "MDSMYSQL"
81977>>>>>>>
81977>>>>>>>    Define ORAFLEX   for "ORA_DRV"
81977>>>>>>>
81977>>>>>>>
81977>>>>>>>// SQLConnection.ini constants:
81977>>>>>>>    Define CS_SQLConnectionIDText       for "DFConnectionId"
81977>>>>>>>Define CS_SQLIniFileName                for "SQLConnections.ini"
81977>>>>>>>Define CS_SQLDF19IniFileName            for "DFConnId.ini"
81977>>>>>>>Define CS_SQLIniConnectionSection       for "SQL Connections" // Obsolete!
81977>>>>>>>Define CS_SQLIniSectionName             for "Connection"
81977>>>>>>>
81977>>>>>>>// DF 19 ini-file settings:
81977>>>>>>>Define CS_SQLIniConnectionIdKeyword     for "Id"
81977>>>>>>>Define CS_SQLIniDriverKeyword           for "Driver"
81977>>>>>>>Define CS_SQLIniConnectionKeyWord       for "Connection"
81977>>>>>>>Define CS_SQLIniUIDKeyword              for "UID"
81977>>>>>>>Define CS_SQLIniPWDKeyword              for "PWD"
81977>>>>>>>Define CS_SQLIniDFPWDKeyword            for "DFPWD"
81977>>>>>>>Define CS_SQLIniServerKeyword           for "SERVER"
81977>>>>>>>Define CS_SQLIniDSNKeyword              for "DSN"
81977>>>>>>>Define CS_SQLIniDatabaseKeyword         for "DATABASE"
81977>>>>>>>Define CS_SQLIniTrustedKeyword          for "Trusted_Connection"
81977>>>>>>>
81977>>>>>>>// Database Update Framework extended settings:
81977>>>>>>>Define CS_SQLIniDbTypeKeyword           for "DbType"
81977>>>>>>>Define CS_SQLIniSchemaKeyword           for "Schema"
81977>>>>>>>Define CS_SQLIniBaseTableSpaceKeyword   for "Base Table Space"
81977>>>>>>>Define CS_SQLIniLongTableSpaceKeyword   for "Long Table Space"
81977>>>>>>>Define CS_SQLIniIndexTableSpaceKeyword  for "Index Table Space"
81977>>>>>>>Define CS_SQLIniSilentLoginKeyword      for "Silent Login"
81977>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"      // For compatability with DF19.
81977>>>>>>>
81977>>>>>>>Define CS_SQLIniConnectionPWD           for "PWD"
81977>>>>>>>Define CS_SQLIniConnectionYes           for "Yes"
81977>>>>>>>Define CS_SQLIniConnectionNo            for "No"
81977>>>>>>>
81977>>>>>>>Struct tSQLConnection
81977>>>>>>>    Boolean bEnabled                // 1. There can only be one active/enabled connection at a time.
81977>>>>>>>    String sConnectionID            // 2. The name of the connection ID.
81977>>>>>>>    Integer iDbType                 // 3. Database type; "MS-SQL Server", "DB2", "Oracle", "MySQL", "PostgreSQL"
81977>>>>>>>    String sDriverID                // 4. Name of the driver. E.g. "MSSQLDRV", "DB2_DRV" or "ODBC_DRV".
81977>>>>>>>    String sServer                  // 5. SQL Server/DSN/ODBC source name. (In DF19 this is the "sString" member of the tConnection struct.)
81977>>>>>>>    String sDatabase                // 6. SQL Database
81977>>>>>>>    String sConnectionString        // 7. Full connection string as is needed by e.g. the login command.
81977>>>>>>>    Boolean bTrusted                // 8. Trusted connection (then is UID & PWD not used)
81977>>>>>>>    String sUserID                  // 9. User ID
81977>>>>>>>    String sPassword                // 10. Password
81977>>>>>>>    String sSchema                  // 11. DB2 (and perhaps ODBC specific)
81977>>>>>>>    String sBaseTableSpace          // 12. DB2 specific
81977>>>>>>>    String sLongTableSpace          // 13. DB2 specific
81977>>>>>>>    String sIndexTableSpace         // 14. DB2 specific
81977>>>>>>>    Boolean bSilentLogin            // 15. True=Silent login. (i.e. don't show Database login dialog if database login to fails). Same as driver "Options" parameter.
81977>>>>>>>    Boolean bError                  // 16. Set to true on error.
81977>>>>>>>    Boolean bDAWConnection          // 17. True if a DFConnId.ini file (from DAW) has been used instead of a DUF SQLConnections.ini file.
81977>>>>>>>//    Boolean bDisabled               // 17. For compatability with DF19 Managed Connections only. Not used by DUF (Database Update Framework).
81977>>>>>>>//    Integer iDriverIndex            // 18. For compatability with DF19 Managed Connections only. Not used by DUF (Database Update Framework).
81977>>>>>>>End_Struct
81977>>>>>
81977>>>>>Class cDbUpdateFunctionLibrary_Mixin is a Mixin
81978>>>>>    Procedure CreateDbUpdateLibraryProperties
81980>>>>>        Handle hoSQLManagerMT
81980>>>>>
81980>>>>>        Property String Private.psUseDatabase ""
81981>>>>>
81981>>>>>//        { Visibility=Private }
81981>>>>>        // These are used by the Error routine to show the Table# & Field# if something goes wrong:
81981>>>>>        Property Handle  Private.phCurrentTable 0
81982>>>>>        Property Integer Private.piCurrentField 0
81983>>>>>
81983>>>>>        Property Handle phoCLIHandler      (Create(Self,RefClass(cCLIHandler)))
81984>>>>>        Property Handle phoSQLManager      (Create(Self,RefClass(cSQLHandleManager)))
81985>>>>>
81985>>>>>        Property Handle phoSQLManagerMT
81986>>>>>
81986>>>>>        Property Handle phoMSSQLHandler    (Create(Self,RefClass(cMSSQLHandler)))
81987>>>>>        Property Handle phoDB2SQLHandler   (Create(Self,RefClass(cDB2Handler)))
81988>>>>>        Property Handle phoODBCSQLHandler  (Create(Self,RefClass(cODBCHandler)))
81989>>>>>        Property Handle phoSQLConnectionHandler 0
81990>>>>>        Property tSQLKeyWords[] paSQLKeywordArray
81991>>>>>
81991>>>>>        Property Boolean pbHandleQueryErrors True
81992>>>>>
81992>>>>>        Property tSqlColumnNew[] paQueryColumns
81993>>>>>        Property String[] paSQLFetchResults
81994>>>>>
81994>>>>>        // Error handling     
81994>>>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT        
81995>>>>>        Property Boolean pbSqlError False
81996>>>>>        Property tSqlErrorArray paSqlErrorArray
81997>>>>>        Property Boolean pbProcessingError False
81998>>>>>
81998>>>>>        // Statistics on query
81998>>>>>        Property TimeSpan ptsTotalQueryTime
81999>>>>>        Property TimeSpan ptsQueryExec
82000>>>>>        Property TimeSpan ptsFetchResults
82001>>>>>        Property Integer piColumns 0
82002>>>>>        Property Integer piRows 0
82003>>>>>        Property Integer piRowType 0
82004>>>>>        Property String[] paQueryMessages
82005>>>>>        Property String psSQLStatementString
82006>>>>>
82006>>>>>        Property Integer[] paTableConvertExceptions
82007>>>>>
82007>>>>>        Property Integer[] paTableDateCorrectionExceptions
82008>>>>>
82008>>>>>        // Number of SQL statements (chunks) to be executed when executing a really big
82008>>>>>        // SQL file that has been compiled into the program. It is way faster to divide
82008>>>>>        // the statements in smaller chunks than to execute them all at the same time.
82008>>>>>        Property Integer piChunkMax 500
82009>>>>>
82009>>>>>        // Fill the paSQLKeywordArray array with values;
82009>>>>>        Send SetupSQLKeywordArray
82010>>>>>    End_Procedure
82011>>>>>
82011>>>>>    // Custom array find function. It compares both the iSQLWord & iSQLDbType params.
82011>>>>>    Function CompareFindSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
82013>>>>>        If (SQLKeywords1.iSQLWord = SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType = SQLKeywords2.iSQLDbType) Begin
82015>>>>>            Function_Return (EQ)
82016>>>>>        End
82016>>>>>>
82016>>>>>        Function_Return (GT)
82017>>>>>    End_Function
82018>>>>>
82018>>>>>    // Custom array sort function. It compares both the iSQLWord & iSQLDbType params.
82018>>>>>    Function CompareSortSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
82020>>>>>        If (SQLKeywords1.iSQLWord   < SQLKeywords2.iSQLWord) ;            Function_Return (LT)
82023>>>>>        If (SQLKeywords1.iSQLWord   > SQLKeywords2.iSQLWord) ;            Function_Return (GT)
82026>>>>>        If (SQLKeywords1.iSQLDbType < SQLKeywords2.iSQLDbType) ;            Function_Return (LT)
82029>>>>>        If (SQLKeywords1.iSQLDbType > SQLKeywords2.iSQLDbType) ;            Function_Return (GT)
82032>>>>>
82032>>>>>        Function_Return (EQ)
82033>>>>>    End_Function
82034>>>>>
82034>>>>>    Procedure Add_Element Integer iSQLKeywordConstant Integer iEN_dbType String sSQLKeyword
82036>>>>>        tSQLKeyWords[] SQLKeywordArray
82036>>>>>        tSQLKeyWords[] SQLKeywordArray
82037>>>>>        Integer iSize
82037>>>>>
82037>>>>>        Get paSQLKeywordArray to SQLKeywordArray
82038>>>>>        Move (SizeOfArray(SQLKeywordArray)) to iSize
82039>>>>>        Move iSQLKeywordConstant to SQLKeywordArray[iSize].iSQLWord
82040>>>>>        Move iEN_dbType          to SQLKeywordArray[iSize].iSQLDbType
82041>>>>>        Move sSQLKeyword         to SQLKeywordArray[iSize].sSQLPhrase
82042>>>>>
82042>>>>>        Set paSQLKeywordArray to SQLKeywordArray
82043>>>>>    End_Procedure
82044>>>>>
82044>>>>>    // Creates a struct array with all SQL keywords
82044>>>>>    // for all EN_xxx SQL back-ends. Various back-ends can
82044>>>>>    // have slightly different wording.
82044>>>>>    // If a new EN_dbTypexxx type is added; additions
82044>>>>>    // needs to be done for every keyword group below.
82044>>>>>    Procedure SetupSQLKeywordArray
82046>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
82046>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
82048>>>>>
82048>>>>>        // This should only be called once; but in case it is
82048>>>>>        // we delete the array first.
82048>>>>>        Set paSQLKeywordArray to SQLKeywordArray
82049>>>>>
82049>>>>>        // ToDo: *** Not all SQL Key-words has been checked for other backends than MS-SQL ***
82049>>>>>        //
82049>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMSSQL    "ALTER DATABASE"
82050>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMySQL    "ALTER DATABASE"
82051>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeOracle   "ALTER DATABASE"
82052>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeDB2      "ALTER DATABASE"
82053>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypePostgre  "ALTER DATABASE"  
82054>>>>>        
82054>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMSSQL    "SINGLE_USER"
82055>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMySQL    "SINGLE_USER"
82056>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeOracle   "SINGLE_USER"
82057>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeDB2      "SINGLE_USER"
82058>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypePostgre  "SINGLE_USER"  
82059>>>>>        
82059>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMSSQL    "MULTI_USER"
82060>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMySQL    "MULTI_USER"
82061>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeOracle   "MULTI_USER"
82062>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeDB2      "MULTI_USER"
82063>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypePostgre  "MULTI_USER"  
82064>>>>>        
82064>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMSSQL    "ROLLBACK"
82065>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMySQL    "ROLLBACK"
82066>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeOracle   "ROLLBACK"
82067>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeDB2      "ROLLBACK"
82068>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypePostgre  "ROLLBACK"  
82069>>>>>        
82069>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMSSQL    "IMMEDIATE"
82070>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMySQL    "IMMEDIATE"
82071>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeOracle   "IMMEDIATE"
82072>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeDB2      "IMMEDIATE"
82073>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypePostgre  "IMMEDIATE"  
82074>>>>>        
82074>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMSSQL    "ALTER TABLE"
82075>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMySQL    "ALTER TABLE"
82076>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeOracle   "ALTER TABLE"
82077>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeDB2      "ALTER TABLE"
82078>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypePostgre  "ALTER TABLE"
82079>>>>>
82079>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMSSQL           "ADD"
82080>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMySQL           "ADD"
82081>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeOracle          "ADD"
82082>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeDB2             "ADD"
82083>>>>>        Send Add_Element CI_SQLAdd EN_dbTypePostgre         "ADD"
82084>>>>>
82084>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMSSQL        "UPDATE"
82085>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMySQL        "UPDATE"
82086>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeOracle       "UPDATE"
82087>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeDB2          "UPDATE"
82088>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypePostgre      "UPDATE"
82089>>>>>
82089>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMSSQL       "NOT NULL"
82090>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMySQL       "NOT NULL"
82091>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeOracle      "" // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
82092>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeDB2         "DEFAULT NOT NULL"
82093>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypePostgre     "NOT NULL"
82094>>>>>
82094>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMSSQL           "SET"
82095>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMySQL           "SET"
82096>>>>>        Send Add_Element CI_SQLSet EN_dbTypeOracle          "SET"
82097>>>>>        Send Add_Element CI_SQLSet EN_dbTypeDB2             "SET"
82098>>>>>        Send Add_Element CI_SQLSet EN_dbTypePostgre         "SET"
82099>>>>>
82099>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMSSQL          "WITH"
82100>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMySQL          "WITH"
82101>>>>>        Send Add_Element CI_SQLWith EN_dbTypeOracle         "WITH"
82102>>>>>        Send Add_Element CI_SQLWith EN_dbTypeDB2            "WITH"
82103>>>>>        Send Add_Element CI_SQLWith EN_dbTypePostgre        "WITH"
82104>>>>>
82104>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMSSQL    "CREATE DATABASE"
82105>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMySQL    "CREATE DATABASE"
82106>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeOracle   "CREATE DATABASE"
82107>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeDB2      "CREATE DATABASE"
82108>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypePostgre  "CREATE DATABASE"
82109>>>>>
82109>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMSSQL    "COLLATE"
82110>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMySQL    "COLLATE"
82111>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeOracle   "COLLATE"
82112>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeDB2      "COLLATE"
82113>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypePostgre  "COLLATE"
82114>>>>>
82114>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMSSQL    "CREATE VIEW"
82115>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMySQL    "CREATE VIEW"
82116>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeOracle   "CREATE VIEW"
82117>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeDB2      "CREATE VIEW"
82118>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypePostgre  "CREATE VIEW"
82119>>>>>
82119>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMSSQL      "DROP VIEW"
82120>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMySQL      "DROP VIEW"
82121>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeOracle     "DROP VIEW"
82122>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeDB2        "DROP VIEW"
82123>>>>>        Send Add_Element CI_SQLDropView EN_dbTypePostgre    "DROP VIEW"
82124>>>>>
82124>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMSSQL   "CREATE TABLE"
82125>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMySQL   "CREATE TABLE"
82126>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeOracle  "CREATE TABLE"
82127>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeDB2     "CREATE TABLE"
82128>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypePostgre "CREATE TABLE"
82129>>>>>
82129>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMSSQL     "DROP TABLE"
82130>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMySQL     "DROP TABLE"
82131>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeOracle    "DROP TABLE"
82132>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeDB2       "DROP TABLE"
82133>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypePostgre   "DROP TABLE"
82134>>>>>
82134>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMSSQL   "EXEC sp_rename"
82135>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMySQL   "RENAME TABLE"
82136>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeOracle  "RENAME TABLE"
82137>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeDB2     "RENAME TABLE"
82138>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypePostgre "RENAME TO"
82139>>>>>
82139>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMSSQL    "DROP COLUMN"
82140>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMySQL    "DROP COLUMN"
82141>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeOracle   "DROP COLUMN"
82142>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeDB2      "DROP COLUMN"
82143>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypePostgre  "DROP COLUMN"
82144>>>>>
82144>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMSSQL        "COLUMN"
82145>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMySQL        "COLUMN"
82146>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeOracle       "COLUMN"
82147>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeDB2          "COLUMN"
82148>>>>>        Send Add_Element CI_SQLColumn EN_dbTypePostgre      "COLUMN"
82149>>>>>
82149>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMSSQL   "ALTER COLUMN"
82150>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMySQL   "MODIFY"
82151>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeOracle  "MODIFY"
82152>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeDB2     "ALTER COLUMN"
82153>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypePostgre "ALTER COLUMN"
82154>>>>>
82154>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMSSQL   "EXEC sp_RENAME"
82155>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMySQL   "CHANGE"
82156>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeOracle  "RENAME COLUMN"
82157>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeDB2     "RENAME COLUMN"
82158>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypePostgre "RENAME COLUMN"
82159>>>>>
82159>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMSSQL        "SELECT"
82160>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMySQL        "SELECT"
82161>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeOracle       "SELECT"
82162>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeDB2          "SELECT"
82163>>>>>        Send Add_Element CI_SQLSelect EN_dbTypePostgre      "SELECT"
82164>>>>>
82164>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMSSQL         "WHERE"
82165>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMySQL         "WHERE"
82166>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeOracle        "WHERE"
82167>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeDB2           "WHERE"
82168>>>>>        Send Add_Element CI_SQLWhere EN_dbTypePostgre       "WHERE"
82169>>>>>
82169>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMSSQL          "FROM"
82170>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMySQL          "FROM"
82171>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeOracle         "FROM"
82172>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeDB2            "FROM"
82173>>>>>        Send Add_Element CI_SQLFrom EN_dbTypePostgre        "FROM"
82174>>>>>
82174>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMSSQL    "INFORMATION_SCHEMA.COLUMNS"
82175>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMySQL    "INFORMATION_SCHEMA.COLUMNS"
82176>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeOracle   "INFORMATION_SCHEMA.COLUMNS"
82177>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeDB2      "INFORMATION_SCHEMA.COLUMNS"
82178>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypePostgre  "INFORMATION_SCHEMA.COLUMNS"
82179>>>>>
82179>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMSSQL    "TABLE_NAME"
82180>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMySQL    "TABLE_NAME"
82181>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeOracle   "TABLE_NAME"
82182>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeDB2      "TABLE_NAME"
82183>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypePostgre  "TABLE_NAME"
82184>>>>>
82184>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMSSQL         "TABLE"
82185>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMySQL         "TABLE"
82186>>>>>        Send Add_Element CI_SQLTable EN_dbTypeOracle        "TABLE"
82187>>>>>        Send Add_Element CI_SQLTable EN_dbTypeDB2           "TABLE"
82188>>>>>        Send Add_Element CI_SQLTable EN_dbTypePostgre       "TABLE"
82189>>>>>
82189>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMSSQL           "SYS"
82190>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMySQL           "SYS"
82191>>>>>        Send Add_Element CI_SQLSys EN_dbTypeOracle          "SYS"
82192>>>>>        Send Add_Element CI_SQLSys EN_dbTypeDB2             "SYS"
82193>>>>>        Send Add_Element CI_SQLSys EN_dbTypePostgre         "SYS"
82194>>>>>
82194>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMSSQL       "SP_HELP"
82195>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMySQL       "SP_HELP"
82196>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeOracle      "SP_HELP"
82197>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeDB2         "SP_HELP"
82198>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypePostgre     "SP_HELP"
82199>>>>>
82199>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMSSQL      "SET NOCOUNT ON"
82200>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMySQL      "SET NOCOUNT ON"
82201>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeOracle     "SET NOCOUNT ON"
82202>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeDB2        "SET NOCOUNT ON"
82203>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypePostgre    "SET NOCOUNT ON"
82204>>>>>
82204>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMSSQL            "TO"
82205>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMySQL            "TO"
82206>>>>>        Send Add_Element CI_SQLTo EN_dbTypeOracle           "TO"
82207>>>>>        Send Add_Element CI_SQLTo EN_dbTypeDB2              "TO"
82208>>>>>        Send Add_Element CI_SQLTo EN_dbTypePostgre          "TO"
82209>>>>>
82209>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMSSQL            "GO"
82210>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMySQL            "GO"
82211>>>>>        Send Add_Element CI_SQLGO EN_dbTypeOracle           "GO"
82212>>>>>        Send Add_Element CI_SQLGO EN_dbTypeDB2              "GO"
82213>>>>>        Send Add_Element CI_SQLGO EN_dbTypePostgre          "GO"
82214>>>>>
82214>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMSSQL           "USE"
82215>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMySQL           "USE"
82216>>>>>        Send Add_Element CI_SQLUse EN_dbTypeOracle          "USE"
82217>>>>>        Send Add_Element CI_SQLUse EN_dbTypeDB2             "USE"
82218>>>>>        Send Add_Element CI_SQLUse EN_dbTypePostgre         "USE"
82219>>>>>
82219>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMSSQL           "dbo"
82220>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMySQL           "dbo"
82221>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeOracle          "dbo"
82222>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeDB2             "dbo"
82223>>>>>        Send Add_Element CI_SQLDBO EN_dbTypePostgre         "dbo"
82224>>>>>
82224>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMSSQL        "MASTER"
82225>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMySQL        "MASTER"
82226>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeOracle       "MASTER"
82227>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeDB2          "MASTER"
82228>>>>>        Send Add_Element CI_SQLMaster EN_dbTypePostgre      "MASTER"
82229>>>>>
82229>>>>>        Send Add_Element CI_SQLName EN_dbTypeMSSQL          "NAME"
82230>>>>>        Send Add_Element CI_SQLName EN_dbTypeMySQL          "NAME"
82231>>>>>        Send Add_Element CI_SQLName EN_dbTypeOracle         "NAME"
82232>>>>>        Send Add_Element CI_SQLName EN_dbTypeDB2            "NAME"
82233>>>>>        Send Add_Element CI_SQLName EN_dbTypePostgre        "NAME"
82234>>>>>
82234>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMSSQL     "DATABASES"
82235>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMySQL     "DATABASES"
82236>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeOracle    "DATABASES"
82237>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeDB2       "DATABASES"
82238>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypePostgre   "DATABASES"
82239>>>>>
82239>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMSSQL    "SYS.INDEXES"
82240>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMySQL    "SYS.INDEXES"
82241>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeOracle   "SYS.INDEXES"
82242>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeDB2      "SYS.INDEXES"
82243>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypePostgre  "SYS.INDEXES"
82244>>>>>
82244>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMSSQL      "OBJECT_ID"
82245>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMySQL      "OBJECT_ID"
82246>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeOracle     "OBJECT_ID"
82247>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeDB2        "OBJECT_ID"
82248>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypePostgre    "OBJECT_ID"
82249>>>>>
82249>>>>>        Send Add_Element CI_SQLID EN_dbTypeMSSQL            "ID"
82250>>>>>        Send Add_Element CI_SQLID EN_dbTypeMySQL            "ID"
82251>>>>>        Send Add_Element CI_SQLID EN_dbTypeOracle           "ID"
82252>>>>>        Send Add_Element CI_SQLID EN_dbTypeDB2              "ID"
82253>>>>>        Send Add_Element CI_SQLID EN_dbTypePostgre          "ID"
82254>>>>>
82254>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMSSQL           "AND"
82255>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMySQL           "AND"
82256>>>>>        Send Add_Element CI_SQLAND EN_dbTypeOracle          "AND"
82257>>>>>        Send Add_Element CI_SQLAND EN_dbTypeDB2             "AND"
82258>>>>>        Send Add_Element CI_SQLAND EN_dbTypePostgre         "AND"
82259>>>>>
82259>>>>>        // In case we didn't put the above in order (and we don't need to); we sort the struct array.
82259>>>>>        Get paSQLKeywordArray to SQLKeywordArray
82260>>>>>        Move (SortArray(SQLKeywordArray, Self, (RefFunc(CompareSortSQLKeyWords)))) to SQLKeywordArraySorted
82261>>>>>        Set paSQLKeywordArray to SQLKeywordArraySorted
82262>>>>>
82262>>>>>    End_Procedure
82263>>>>>
82263>>>>>End_Class
82264>>>Use cSQLConnectionHandler.pkg
Including file: cSQLConnectionHandler.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cSQLConnectionHandler.pkg)
82264>>>>>//****************************************************************************
82264>>>>>// $Module type: Class
82264>>>>>// $Module name: cSQLConnectionHandler.pkg
82264>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
82264>>>>>// Web-site    : http://www.rdctools.com
82264>>>>>// Created     : 2015-08-11 @ 16:02 (Military date format: YY-MM-DD)
82264>>>>>//
82264>>>>>// Description : A handler class for using CLI connection ID's to login to a database server.
82264>>>>>//
82264>>>>>// $Rev History:
82264>>>>>//    2015-08-11  Module header created
82264>>>>>//    2016-09-26  Changed name of the objecthandle from ghoCreateConnectionID to ghoSQLConnectionHandler.
82264>>>>>//                Added a new structure for passing connection data back & forth.
82264>>>>>//                Added better error handling.
82264>>>>>//                Added a decompose message for the connection string.
82264>>>>>//    2017-01-09  Added support for Mertech drivers
82264>>>>>//                Big overhaul to comply better with "Managed Connections" (DF 19)
82264>>>>>//                These changes make the class compatible with DFConnId.ini (can read/write DAW connection ini-files)
82264>>>>>//    2017-02-12  Reworked the whole connection property interface.
82264>>>>>//                Now there is one struct property that is the at cencter of a connection.
82264>>>>>//****************************************************************************
82264>>>>>Use cli.pkg
82264>>>>>Use MSSqldrv.pkg
82264>>>>>Use db2_drv.pkg
82264>>>>>Use odbc_drv.pkg
82264>>>>>Use cSQLConnectionIniFile.pkg
Including file: cSQLConnectionIniFile.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.pkg)
82264>>>>>>>//****************************************************************************
82264>>>>>>>// $Module type: Class
82264>>>>>>>// $Module name: cSQLConnectionIniFile.pkg
82264>>>>>>>//
82264>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
82264>>>>>>>// Copyright (c) 2012 RDC Tools International
82264>>>>>>>// E-mail      : support@rdctools.com
82264>>>>>>>// Web-site    : http://www.rdctools.com
82264>>>>>>>//
82264>>>>>>>// Created     : 2012-09-20 @ 18:04 (Military date format - Year-Month-Day)
82264>>>>>>>//
82264>>>>>>>// Note        : The file must be USEd after declaration of the ghoApplication object, as it uses
82264>>>>>>>//               properties of that object.
82264>>>>>>>//
82264>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
82264>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
82264>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
82264>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
82264>>>>>>>// in the help folder for more details.
82264>>>>>>>//
82264>>>>>>>Use cSQLConnectionIniFile.inc
82264>>>>>>>Use cDbUpdateDatabaseDriver.pkg
Including file: cDbUpdateDatabaseDriver.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateDatabaseDriver.pkg)
82264>>>>>>>>>Use cSQLConnectionIniFile.inc
82264>>>>>>>>>
82264>>>>>>>>>Class cDbUpdateGenericDatabaseDriver is a cObject
82265>>>>>>>>>    Procedure Construct_Object
82267>>>>>>>>>        Forward Send Construct_Object
82269>>>>>>>>>        Property String psDriverID DATAFLEX_ID
82270>>>>>>>>>    End_Procedure
82271>>>>>>>>>
82271>>>>>>>>>    Function ServerKeyword Returns String
82273>>>>>>>>>        Function_Return CS_SQLIniDSNKeyword
82274>>>>>>>>>    End_Function
82275>>>>>>>>>
82275>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
82277>>>>>>>>>        String sConnect
82277>>>>>>>>>
82277>>>>>>>>>        Move (sConnect * ServerKeyword(Self) + "=" + sServer) to sConnect
82278>>>>>>>>>        If (sDatabase <> "") Begin
82280>>>>>>>>>            Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
82281>>>>>>>>>        End
82281>>>>>>>>>>
82281>>>>>>>>>        If (bTrusted = True) Begin
82283>>>>>>>>>            Move (sConnect * ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
82284>>>>>>>>>        End
82284>>>>>>>>>>
82284>>>>>>>>>        Else Begin
82285>>>>>>>>>            Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
82286>>>>>>>>>        End
82286>>>>>>>>>>
82286>>>>>>>>>        Function_Return sConnect
82287>>>>>>>>>    End_Function
82288>>>>>>>>>
82288>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
82290>>>>>>>>>        Boolean bLoginSuccessful
82290>>>>>>>>>        String sDriverID
82290>>>>>>>>>
82290>>>>>>>>>        Get psDriverID to sDriverID
82291>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
82293>>>>>>>>>            Function_Return True
82294>>>>>>>>>        End
82294>>>>>>>>>>
82294>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
82295>>>>>>>>>        If (bTrusted = False) Begin
82297>>>>>>>>>            Login sServer sUserId sPassword sDriverID
82299>>>>>>>>>        End
82299>>>>>>>>>>
82299>>>>>>>>>        Else Begin
82300>>>>>>>>>            Login sConnectionString "" "" sDriverID
82302>>>>>>>>>        End
82302>>>>>>>>>>
82302>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
82303>>>>>>>>>        Function_Return bLoginSuccessful
82304>>>>>>>>>    End_Function
82305>>>>>>>>>End_Class
82306>>>>>>>>>
82306>>>>>>>>>Class cDbUpdateMSSQLDriver is a cDbUpdateGenericDatabaseDriver
82307>>>>>>>>>    Function ServerKeyword Returns String
82309>>>>>>>>>        Function_Return CS_SQLIniServerKeyword
82310>>>>>>>>>    End_Function
82311>>>>>>>>>End_Class
82312>>>>>>>>>
82312>>>>>>>>>Class cDbUpdateODBCDriver is a cDbUpdateGenericDatabaseDriver
82313>>>>>>>>>End_Class
82314>>>>>>>>>
82314>>>>>>>>>Class cDbUpdateDB2Driver is a cDbUpdateGenericDatabaseDriver
82315>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
82317>>>>>>>>>        Boolean bLoginSuccessful
82317>>>>>>>>>        String sDriverID
82317>>>>>>>>>
82317>>>>>>>>>        Move False to Err
82318>>>>>>>>>        Get psDriverID to sDriverID
82319>>>>>>>>>        If (not(Uppercase(sServer) contains "DSN")) Begin
82321>>>>>>>>>            Move ("DSN=" + sServer) to sServer
82322>>>>>>>>>        End
82322>>>>>>>>>>
82322>>>>>>>>>        Login sServer sUserId sPassword sDriverID
82324>>>>>>>>>
82324>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
82325>>>>>>>>>        Function_Return bLoginSuccessful
82326>>>>>>>>>    End_Function
82327>>>>>>>>>End_Class
82328>>>>>>>>>
82328>>>>>>>>>Class cDbUpdateDataFlexDriver is a cDbUpdateGenericDatabaseDriver
82329>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
82331>>>>>>>>>        Function_Return ""
82332>>>>>>>>>    End_Function
82333>>>>>>>>>End_Class
82334>>>>>>>>>
82334>>>>>>>>>Class cDbUpdateSQLFLEXDriver is a cDbUpdateGenericDatabaseDriver
82335>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
82337>>>>>>>>>        Boolean bLoginSuccessful
82337>>>>>>>>>        String sDriverID
82337>>>>>>>>>
82337>>>>>>>>>        Get psDriverID to sDriverID
82338>>>>>>>>>        //For the Mertech driver, using the Err indicator is the sanctioned way
82338>>>>>>>>>        Move False to Err
82339>>>>>>>>>        If (bTrusted = False) Begin
82341>>>>>>>>>            Login sServer sUserId sPassword sDriverID
82343>>>>>>>>>        End
82343>>>>>>>>>>
82343>>>>>>>>>        Else Begin
82344>>>>>>>>>            Login sServer "" "" sDriverID
82346>>>>>>>>>        End
82346>>>>>>>>>>
82346>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
82347>>>>>>>>>
82347>>>>>>>>>        Function_Return bLoginSuccessful
82348>>>>>>>>>    End_Function
82349>>>>>>>>>End_Class
82350>>>>>>>>>
82350>>>>>>>>>Class cDbUpdateORAFLEXDriver is a cDbUpdateGenericDatabaseDriver
82351>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
82353>>>>>>>>>        Boolean bLoginSuccessful
82353>>>>>>>>>        String sDriverID
82353>>>>>>>>>        Integer iPos
82353>>>>>>>>>
82353>>>>>>>>>        Get psDriverID to sDriverID
82354>>>>>>>>>        Move (Pos("/", sServer)) to iPos
82355>>>>>>>>>        If (iPos = 0) Begin
82357>>>>>>>>>            If (sDatabase <> "") Begin
82359>>>>>>>>>                Move (sServer + "/" + sDatabase) to sServer
82360>>>>>>>>>            End
82360>>>>>>>>>>
82360>>>>>>>>>        End
82360>>>>>>>>>>
82360>>>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
82360>>>>>>>>>        Move False to Err
82361>>>>>>>>>        // For Oracle I don't believe "Trusted" doesn't exist.
82361>>>>>>>>>        Login sServer sUserId sPassword sDriverID
82363>>>>>>>>>
82363>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
82364>>>>>>>>>        Function_Return bLoginSuccessful
82365>>>>>>>>>    End_Function
82366>>>>>>>>>End_Class
82367>>>>>>>>>
82367>>>>>>>>>Class cDbUpdateMDSMySQLDriver is a cDbUpdateGenericDatabaseDriver
82368>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
82370>>>>>>>>>        Boolean bLoginSuccessful
82370>>>>>>>>>        String sDriverID
82370>>>>>>>>>
82370>>>>>>>>>        Get psDriverID to sDriverID
82371>>>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
82371>>>>>>>>>        Move False to Err
82372>>>>>>>>>        If (bTrusted = False) Begin
82374>>>>>>>>>            Login sServer sUserId sPassword sDriverID
82376>>>>>>>>>        End
82376>>>>>>>>>>
82376>>>>>>>>>        Else Begin
82377>>>>>>>>>            Login sServer "" "" sDriverID
82379>>>>>>>>>        End
82379>>>>>>>>>>
82379>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
82380>>>>>>>>>        Function_Return bLoginSuccessful
82381>>>>>>>>>    End_Function
82382>>>>>>>>>End_Class
82383>>>>>>>>>
82383>>>>>>>>>Class cDbUpdateMDSPgSQLDriver is a cDbUpdateGenericDatabaseDriver
82384>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
82386>>>>>>>>>        Boolean bLoginSuccessful
82386>>>>>>>>>        String sDriverID
82386>>>>>>>>>
82386>>>>>>>>>        Get psDriverID to sDriverID
82387>>>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
82387>>>>>>>>>        Move False to Err
82388>>>>>>>>>        If (bTrusted = False) Begin
82390>>>>>>>>>            Login sServer sUserId sPassword sDriverID
82392>>>>>>>>>        End
82392>>>>>>>>>>
82392>>>>>>>>>        Else Begin
82393>>>>>>>>>            Login sServer "" "" sDriverID
82395>>>>>>>>>        End
82395>>>>>>>>>>
82395>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
82396>>>>>>>>>        Function_Return bLoginSuccessful
82397>>>>>>>>>    End_Function
82398>>>>>>>>>End_Class
82399>>>>>>>>>
82399>>>>>>>>>Class cDbUpdateDatabaseDriver is a cObject
82400>>>>>>>>>    Procedure Construct_Object
82402>>>>>>>>>        Forward Send Construct_Object
82404>>>>>>>>>        Property String psDriverID DATAFLEX_ID
82405>>>>>>>>>        Property Handle phoDriverSpecificObject
82406>>>>>>>>>    End_Procedure
82407>>>>>>>>>
82407>>>>>>>>>    Function CreateDriver Returns Handle
82409>>>>>>>>>        String sDriverID
82409>>>>>>>>>        Handle hoDriver hcDriverClass
82409>>>>>>>>>
82409>>>>>>>>>        Get psDriverID to sDriverID
82410>>>>>>>>>        Case Begin
82410>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
82412>>>>>>>>>                Move (RefClass(cDbUpdateMSSQLDriver))    to hcDriverClass
82413>>>>>>>>>                Case Break
82414>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
82417>>>>>>>>>                Move (RefClass(cDbUpdateODBCDriver))     to hcDriverClass
82418>>>>>>>>>                Case Break
82419>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
82422>>>>>>>>>                Move (RefClass(cDbUpdateDB2Driver))      to hcDriverClass
82423>>>>>>>>>                Case Break
82424>>>>>>>>>            Case (sDriverID = SQLFLEX)
82427>>>>>>>>>                Move (RefClass(cDbUpdateSQLFLEXDriver))  to hcDriverClass
82428>>>>>>>>>                Case Break
82429>>>>>>>>>            Case (sDriverID = ORAFLEX)
82432>>>>>>>>>                Move (RefClass(cDbUpdateORAFLEXDriver))  to hcDriverClass
82433>>>>>>>>>                Case Break
82434>>>>>>>>>            Case (sDriverID = MDSPgSQL)
82437>>>>>>>>>                Move (RefClass(cDbUpdateMDSPgSQLDriver)) to hcDriverClass
82438>>>>>>>>>                Case Break
82439>>>>>>>>>            Case (sDriverID = MDSMySQL)
82442>>>>>>>>>                Move (RefClass(cDbUpdateMDSMySQLDriver)) to hcDriverClass
82443>>>>>>>>>                Case Break
82444>>>>>>>>>            // DATAFLEX_ID = Default driver
82444>>>>>>>>>            Case Else
82444>>>>>>>>>                Move (RefClass(cDbUpdateDataFlexDriver)) to hcDriverClass
82445>>>>>>>>>                Move DATAFLEX_ID to sDriverID
82446>>>>>>>>>        Case End
82446>>>>>>>>>
82446>>>>>>>>>        Get Create hcDriverClass to hoDriver
82447>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
82448>>>>>>>>>        Set phoDriverSpecificObject to hoDriver
82449>>>>>>>>>
82449>>>>>>>>>        Function_Return hoDriver
82450>>>>>>>>>    End_Procedure
82451>>>>>>>>>
82451>>>>>>>>>    Procedure DestroyDriver
82453>>>>>>>>>        If (phoDriverSpecificObject(Self)) Begin
82455>>>>>>>>>            Send Destroy of (phoDriverSpecificObject(Self))
82456>>>>>>>>>        End
82456>>>>>>>>>>
82456>>>>>>>>>    End_Procedure
82457>>>>>>>>>
82457>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
82459>>>>>>>>>        String sConnect
82459>>>>>>>>>        Handle hoDriver
82459>>>>>>>>>
82459>>>>>>>>>        Get CreateDriver to hoDriver
82460>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
82461>>>>>>>>>        Send DestroyDriver
82462>>>>>>>>>        Function_Return sConnect
82463>>>>>>>>>    End_Function
82464>>>>>>>>>
82464>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
82466>>>>>>>>>        Boolean bLoginSuccessful
82466>>>>>>>>>        Handle hoDriver
82466>>>>>>>>>
82466>>>>>>>>>        Get CreateDriver to hoDriver
82467>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
82468>>>>>>>>>        Send DestroyDriver
82469>>>>>>>>>        Function_Return bLoginSuccessful
82470>>>>>>>>>    End_Function
82471>>>>>>>>>
82471>>>>>>>>>End_Class
82472>>>>>>>
82472>>>>>>>Class cSQLConnectionIniFile is a cIniFile
82473>>>>>>>    Procedure Construct_Object
82475>>>>>>>        Forward Send Construct_Object
82477>>>>>>>
82477>>>>>>>        Property String Private_psIniFilePath
82478>>>>>>>        Property String Private_psIniFileName CS_SQLIniFileName
82479>>>>>>>        Property String psIniSectionName (CS_SQLIniSectionName + "1")
82480>>>>>>>
82480>>>>>>>//        { Visibility=Private }
82480>>>>>>>        Property Boolean pbDFConnId False
82481>>>>>>>
82481>>>>>>>        // We use Base64 coding instead of the cCryptographer class because the
82481>>>>>>>        // password will get scrambled while writing/reading to/from the ini-file.
82481>>>>>>>//        { Visibility=Public }
82481>>>>>>>//        // *** You really want to change this value! ***
82481>>>>>>>//        Property String psHashString "zx!2139(LI0+?ips7433"
82481>>>>>>>
82481>>>>>>>    End_Procedure
82482>>>>>>>
82482>>>>>>>    Procedure End_Construct_Object
82484>>>>>>>        Forward Send End_Construct_Object
82486>>>>>>>    End_Procedure
82487>>>>>>>
82487>>>>>>>    Procedure Set psIniFilePath String sPath
82489>>>>>>>        String sIniFile
82489>>>>>>>        Get vFolderFormat sPath to sPath
82490>>>>>>>        Set private_psIniFilePath to sPath
82491>>>>>>>        Get psIniFileName to sIniFile
82492>>>>>>>        Set psFileName to (sPath + sIniFile)
82493>>>>>>>    End_Procedure
82494>>>>>>>
82494>>>>>>>    Function psIniFilePath Returns String
82496>>>>>>>        Function_Return (private_psIniFilePath(Self))
82497>>>>>>>    End_Function
82498>>>>>>>
82498>>>>>>>    Procedure Set psIniFileName String sFileName
82500>>>>>>>        String sPath
82500>>>>>>>        Get psIniFilePath to sPath
82501>>>>>>>        Set psFileName to (sPath + sFileName)
82502>>>>>>>        Set private_psIniFileName to sFileName
82503>>>>>>>    End_Procedure
82504>>>>>>>
82504>>>>>>>    Function psIniFileName Returns String
82506>>>>>>>        Function_Return (private_psIniFileName(Self))
82507>>>>>>>    End_Function
82508>>>>>>>
82508>>>>>>>    // *** Generalized messages to Get & Set values of the ini file.
82508>>>>>>>    // Sets a value in the program's ini file (write)
82508>>>>>>>    // Pass a section name, the value name parameter and the value itself to be written.
82508>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
82510>>>>>>>        String sIniFile sPath
82510>>>>>>>
82510>>>>>>>        Get psIniFilePath to sPath
82511>>>>>>>        Get psIniFileName to sIniFile
82512>>>>>>>        Move (sPath + sIniFile) to sIniFile
82513>>>>>>>        Set psFileName to sIniFile
82514>>>>>>>        Send WriteString sSection sValueName sValue
82515>>>>>>>    End_Procedure
82516>>>>>>>
82516>>>>>>>    // Get a value from program's ini-file (read)
82516>>>>>>>    // Pass a section name and the name of the value parameter & a default value.
82516>>>>>>>    // Returns the value
82516>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
82518>>>>>>>        String sValue sIniFile sPath
82518>>>>>>>
82518>>>>>>>        Get psIniFilePath to sPath
82519>>>>>>>        Get psIniFileName to sIniFile
82520>>>>>>>        Move (sPath + sIniFile) to sIniFile
82521>>>>>>>        Set psFileName to sIniFile
82522>>>>>>>        Get ReadString sSection sValueName sDefaultValue to sValue
82523>>>>>>>
82523>>>>>>>        Function_Return sValue
82524>>>>>>>    End_Function
82525>>>>>>>
82525>>>>>>>    // Sort function that first sorts on bEnabled & then on the connection string.
82525>>>>>>>    Function SortActiveFirst tSQLConnection SQLConnectionRow1 tSQLConnection SQLConnectionRow2 Returns Integer
82527>>>>>>>        If (SQLConnectionRow1.bEnabled > SQLConnectionRow2.bEnabled) ;            Function_Return (LT)
82530>>>>>>>        If (SQLConnectionRow1.bEnabled < SQLConnectionRow2.bEnabled) ;            Function_Return (GT)
82533>>>>>>>
82533>>>>>>>        If (SQLConnectionRow1.sConnectionID < SQLConnectionRow2.sConnectionID) ;            Function_Return (LT)
82536>>>>>>>        If (SQLConnectionRow1.sConnectionID > SQLConnectionRow2.sConnectionID) ;            Function_Return (GT)
82539>>>>>>>
82539>>>>>>>        If (SQLConnectionRow1.iDbType < SQLConnectionRow2.iDbType) ;            Function_Return (LT)
82542>>>>>>>        If (SQLConnectionRow1.iDbType > SQLConnectionRow2.iDbType) ;            Function_Return (GT)
82545>>>>>>>
82545>>>>>>>        If (SQLConnectionRow1.sServer < SQLConnectionRow2.sServer) ;            Function_Return (LT)
82548>>>>>>>        If (SQLConnectionRow1.sServer > SQLConnectionRow2.sServer) ;            Function_Return (GT)
82551>>>>>>>
82551>>>>>>>        If (SQLConnectionRow1.sDatabase < SQLConnectionRow2.sDatabase) ;            Function_Return (LT)
82554>>>>>>>        If (SQLConnectionRow1.sDatabase > SQLConnectionRow2.sDatabase) ;            Function_Return (GT)
82557>>>>>>>
82557>>>>>>>        If (SQLConnectionRow1.sDriverID < SQLConnectionRow2.sDriverID) ;            Function_Return (LT)
82560>>>>>>>        If (SQLConnectionRow1.sDriverID > SQLConnectionRow2.sDriverID) ;            Function_Return (GT)
82563>>>>>>>
82563>>>>>>>        If (SQLConnectionRow1.sConnectionString < SQLConnectionRow2.sConnectionString) ;            Function_Return (LT)
82566>>>>>>>        If (SQLConnectionRow1.sConnectionString > SQLConnectionRow2.sConnectionString) ;            Function_Return (GT)
82569>>>>>>>
82569>>>>>>>        Function_Return (EQ)
82570>>>>>>>    End_Function
82571>>>>>>>
82571>>>>>>>    Function SQLIniFileNumberOfConnections Returns Integer
82573>>>>>>>        Handle hoSections
82573>>>>>>>        Integer iItems
82573>>>>>>>
82573>>>>>>>        Send ReadSections hoSections
82574>>>>>>>        Move (Item_Count(hoSections)) to iItems
82575>>>>>>>        Function_Return iItems
82576>>>>>>>    End_Function
82577>>>>>>>
82577>>>>>>>    // The normal connection string looks something like this;
82577>>>>>>>    // "SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
82577>>>>>>>    // ...but the full connection string looks like this;
82577>>>>>>>    // "DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
82577>>>>>>>//    Function SQLIniFileAddConnection String sFullConnectionString Returns Boolean
82577>>>>>>>//        String sSection
82577>>>>>>>//        Integer iCount
82577>>>>>>>//
82577>>>>>>>//        Move False to Err
82577>>>>>>>//        Get psIniSectionName to sSection
82577>>>>>>>//        Get SQLIniFileNumberOfConnections to iCount
82577>>>>>>>//        Increment iCount
82577>>>>>>>//        Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to sFullConnectionString
82577>>>>>>>//
82577>>>>>>>//        Function_Return (Err = False)
82577>>>>>>>//    End_Function
82577>>>>>>>
82577>>>>>>>    Function SQLIniFileDeleteAllConnections Returns Boolean
82579>>>>>>>        Integer iCount
82579>>>>>>>        Boolean bExists
82579>>>>>>>        String sSection
82579>>>>>>>
82579>>>>>>>        Move False to Err
82580>>>>>>>        Move 1 to iCount
82581>>>>>>>        Get psIniSectionName to sSection
82582>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
82583>>>>>>>        While (bExists = True)
82587>>>>>>>            Send DeleteSection (CS_SQLIniSectionName + String(iCount))
82588>>>>>>>            Increment iCount
82589>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
82590>>>>>>>        Loop
82591>>>>>>>>
82591>>>>>>>        Function_Return (Err = False)
82592>>>>>>>    End_Function
82593>>>>>>>
82593>>>>>>>    Function SQLIniFileDeleteConnection Integer iItem Returns Boolean
82595>>>>>>>        Integer iCount
82595>>>>>>>        String sSection
82595>>>>>>>        Boolean bExists
82595>>>>>>>
82595>>>>>>>        Move False to Err
82596>>>>>>>        Move 1 to iCount
82597>>>>>>>        Get psIniSectionName to sSection
82598>>>>>>>        Get KeyExists sSection CS_SQLIniConnectionIdKeyword to bExists
82599>>>>>>>        While (bExists = True)
82603>>>>>>>            If (iCount = iItem) Begin
82605>>>>>>>                Send DeleteSection sSection
82606>>>>>>>//                Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to ""
82606>>>>>>>                Move 9999 to iCount // Just some ridiculously high number to get out of the loop as we're done.
82607>>>>>>>            End
82607>>>>>>>>
82607>>>>>>>            Increment iCount
82608>>>>>>>            Get KeyExists sSection (CS_SQLIniSectionName + String(iCount)) to bExists
82609>>>>>>>        Loop
82610>>>>>>>>
82610>>>>>>>
82610>>>>>>>        Function_Return (Err = False)
82611>>>>>>>    End_Function
82612>>>>>>>
82612>>>>>>>    // Returns all connection details for the passed Connection ID as a tSQLConnection
82612>>>>>>>    // If it fails the returned struct member SQLConnection.bError = True.
82612>>>>>>>    Function SQLIniFileConnectionID String sConnectionID Returns tSQLConnection
82614>>>>>>>        tSQLConnection[] SQLConnectionsArray
82614>>>>>>>        tSQLConnection[] SQLConnectionsArray
82615>>>>>>>        tSQLConnection   SQLConnection
82615>>>>>>>        tSQLConnection   SQLConnection
82615>>>>>>>        Integer iIndex
82615>>>>>>>
82615>>>>>>>        Get SQLIniFileConnectionIDIndex sConnectionID to iIndex
82616>>>>>>>        If (iIndex = -1) Begin
82618>>>>>>>            Move True to SQLConnection.bError
82619>>>>>>>            Function_Return SQLConnection
82620>>>>>>>        End
82620>>>>>>>>
82620>>>>>>>
82620>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
82621>>>>>>>        Move SQLConnectionsArray[iIndex -1] to SQLConnection
82622>>>>>>>
82622>>>>>>>        Function_Return SQLConnection
82623>>>>>>>    End_Function
82624>>>>>>>
82624>>>>>>>    // Returns -1 if the passed connection ID was not found, else the item number.
82624>>>>>>>    Function SQLIniFileConnectionIDIndex String sConnectionID Returns Integer
82626>>>>>>>        tSQLConnection[] SQLConnectionsArray
82626>>>>>>>        tSQLConnection[] SQLConnectionsArray
82627>>>>>>>        Integer iRetval iCount iSize
82627>>>>>>>        String sValue
82627>>>>>>>        Boolean bExists
82627>>>>>>>
82627>>>>>>>        Move -1 to iRetval
82628>>>>>>>
82628>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
82629>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
82630>>>>>>>        Decrement iSize
82631>>>>>>>        For iCount from 0 to iSize
82637>>>>>>>>
82637>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
82638>>>>>>>            Move (Uppercase(sValue) = Uppercase(sConnectionID)) to bExists
82639>>>>>>>            If (bExists) Begin
82641>>>>>>>                Move (iCount + 1) to iRetval // The [ConnectionX] keys are one-based (starts at 1) but the loop starts at zero.
82642>>>>>>>                Move iSize to iCount         // We're done!
82643>>>>>>>            End
82643>>>>>>>>
82643>>>>>>>        Loop
82644>>>>>>>>
82644>>>>>>>
82644>>>>>>>        Function_Return iRetval
82645>>>>>>>    End_Function
82646>>>>>>>
82646>>>>>>>    // Checks if the passed sConnectionID exists more than once in the passed struct array.
82646>>>>>>>    // Used to check that ConnectionID's are unique.
82646>>>>>>>    Function IsConnectionIDDuplicate String sConnectionID Returns Boolean
82648>>>>>>>        Integer iCount iSize iItems
82648>>>>>>>        String sValue
82648>>>>>>>        Boolean bExists
82648>>>>>>>        tSQLConnection[] SQLConnectionsArray
82648>>>>>>>        tSQLConnection[] SQLConnectionsArray
82649>>>>>>>
82649>>>>>>>        Move 0 to iItems
82650>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
82651>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
82652>>>>>>>        Decrement iSize
82653>>>>>>>        For iCount from 0 to iSize
82659>>>>>>>>
82659>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
82660>>>>>>>            Move (sValue = sConnectionID) to bExists
82661>>>>>>>            If (bExists) Begin
82663>>>>>>>                Increment iItems
82664>>>>>>>            End
82664>>>>>>>>
82664>>>>>>>        Loop
82665>>>>>>>>
82665>>>>>>>
82665>>>>>>>        Function_Return (iItems > 1)
82666>>>>>>>    End_Function
82667>>>>>>>
82667>>>>>>>    // To update the SQLConnections.ini file with a new default Connection ID.
82667>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
82669>>>>>>>        Boolean bOK
82669>>>>>>>        Integer iSize iCount
82669>>>>>>>        tSQLConnection[] SQLConnectionsArray
82669>>>>>>>        tSQLConnection[] SQLConnectionsArray
82670>>>>>>>        tSQLConnection SQLConnection
82670>>>>>>>        tSQLConnection SQLConnection
82670>>>>>>>        String sConnectionString
82670>>>>>>>
82670>>>>>>>        Move False to Err
82671>>>>>>>        Get psConnectionString to sConnectionString
82672>>>>>>>
82672>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
82673>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
82674>>>>>>>        Decrement iSize
82675>>>>>>>        // Set all current connection to inactive.
82675>>>>>>>        For iCount from 0 to iSize
82681>>>>>>>>
82681>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
82682>>>>>>>        Loop
82683>>>>>>>>
82683>>>>>>>
82683>>>>>>>        Get SQLIniFileConnectionID sConnectionID to SQLConnection
82684>>>>>>>        Move True              to SQLConnection.bEnabled
82685>>>>>>>        Move sConnectionString to SQLConnection.sConnectionString
82686>>>>>>>        Move (InsertInArray(SQLConnectionsArray, 0, SQLConnection)) to SQLConnectionsArray
82687>>>>>>>        Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
82688>>>>>>>
82688>>>>>>>        Function_Return (bOK = True)
82689>>>>>>>    End_Function
82690>>>>>>>
82690>>>>>>>    // Used for updating an existing connection with new data.
82690>>>>>>>    // Returns True if successful.
82690>>>>>>>    Function SQLIniFileUpdateConnection tSQLConnection SQLConnection Returns Boolean
82692>>>>>>>        Boolean bOK
82692>>>>>>>        Integer iItem iSize iCount
82692>>>>>>>        tSQLConnection[] SQLConnectionsArray
82692>>>>>>>        tSQLConnection[] SQLConnectionsArray
82693>>>>>>>
82693>>>>>>>        Move False to Err
82694>>>>>>>        Move -1 to iItem
82695>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
82696>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
82697>>>>>>>        Decrement iSize
82698>>>>>>>        // Set all current connection to inactive.
82698>>>>>>>        For iCount from 0 to iSize
82704>>>>>>>>
82704>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
82705>>>>>>>            If (SQLConnectionsArray[iCount].sConnectionID = SQLConnection.sConnectionID) Begin
82707>>>>>>>                Move iCount to iItem
82708>>>>>>>            End
82708>>>>>>>>
82708>>>>>>>        Loop
82709>>>>>>>>
82709>>>>>>>
82709>>>>>>>        If (iItem <> -1) Begin
82711>>>>>>>            Move True to SQLConnection.bEnabled
82712>>>>>>>            Move SQLConnection to SQLConnectionsArray[iItem]
82713>>>>>>>            Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
82714>>>>>>>        End
82714>>>>>>>>
82714>>>>>>>
82714>>>>>>>        Function_Return (bOK = True)
82715>>>>>>>    End_Function
82716>>>>>>>
82716>>>>>>>    Function SQLIniFileReadConnections Returns tSQLConnection[]
82718>>>>>>>        tSQLConnection[] SQLConnectionsArray
82718>>>>>>>        tSQLConnection[] SQLConnectionsArray
82719>>>>>>>        String sSection sValue
82719>>>>>>>        Integer iCount
82719>>>>>>>        Boolean bExists bEnabled
82719>>>>>>>
82719>>>>>>>        Get psIniSectionName to sSection
82720>>>>>>>        Get SectionExists sSection to bExists
82721>>>>>>>        If (bExists = False) Begin
82723>>>>>>>            Function_Return SQLConnectionsArray
82724>>>>>>>        End
82724>>>>>>>>
82724>>>>>>>        Get SectionExists CS_SQLIniConnectionSection to bExists
82725>>>>>>>        If (bExists = True) Begin
82727>>>>>>>            Error DFERR_PROGRAM "Sorry, the format for the SQLConnections.ini file has been changed and this file has the old format that is no longer valid and thus cannot be read. You need to re-enter your connection(s)."
82728>>>>>>>>
82728>>>>>>>        End
82728>>>>>>>>
82728>>>>>>>
82728>>>>>>>        Move 1 to iCount // The section name "[ConnectionXX]" starts with "1"
82729>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
82730>>>>>>>
82730>>>>>>>        While (bExists = True)
82734>>>>>>>            // We always put the enabled/active connection at the top
82734>>>>>>>            Move (iCount = 1) to bEnabled
82735>>>>>>>            Move bEnabled to SQLConnectionsArray[iCount].bEnabled
82736>>>>>>>
82736>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionIdKeyword ""        to SQLConnectionsArray[iCount].sConnectionID
82737>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDriverKeyword       ""        to SQLConnectionsArray[iCount].sDriverID
82738>>>>>>>
82738>>>>>>>            // The iDbType might be missing from the ini-file. This is e.g. the case when a DAW Managed Connection "DFConnId.ini" file is read.
82738>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDbTypeKeyword       "99"      to sValue
82739>>>>>>>            If (sValue = "99") Begin
82741>>>>>>>                Get SqlUtilDbTypeFromDriver SQLConnectionsArray[iCount].sDriverID to sValue
82742>>>>>>>            End
82742>>>>>>>>
82742>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].iDbType
82743>>>>>>>
82743>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionKeyWord   ""        to SQLConnectionsArray[iCount].sConnectionString
82744>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnectionsArray[iCount].sServer
82745>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
82747>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDSNKeyword +"=")   to SQLConnectionsArray[iCount].sServer
82748>>>>>>>            End
82748>>>>>>>>
82748>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnectionsArray[iCount].sDatabase
82749>>>>>>>
82749>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniTrustedKeyword      ""        to sValue
82750>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bTrusted
82751>>>>>>>
82751>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniUIDKeyword          ""        to SQLConnectionsArray[iCount].sUserID
82752>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDFPWDKeyword        ""        to sValue
82753>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
82755>>>>>>>                Get DecryptPassword sValue to sValue
82756>>>>>>>            End
82756>>>>>>>>
82756>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].sPassword
82757>>>>>>>
82757>>>>>>>            // Here we reconstruct the connection string to be complete with all params;
82757>>>>>>>            Get ConstructConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                          SQLConnectionsArray[iCount].bTrusted SQLConnectionsArray[iCount].sUserID SQLConnectionsArray[iCount].sPassword ;                                          to SQLConnectionsArray[iCount].sConnectionString
82758>>>>>>>
82758>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSchemaKeyword          ""     to SQLConnectionsArray[iCount].sSchema
82759>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniBaseTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sBaseTableSpace
82760>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniLongTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sLongTableSpace
82761>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniIndexTableSpaceKeyword ""     to SQLConnectionsArray[iCount].sIndexTableSpace
82762>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSilentLoginKeyword     ""     to SQLConnectionsArray[iCount].bSilentLogin
82763>>>>>>>//            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDisabledKeyword        ""     to SQLConnectionsArray[iCount].bDisabled
82763>>>>>>>
82763>>>>>>>            Increment iCount
82764>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
82765>>>>>>>        Loop
82766>>>>>>>>
82766>>>>>>>
82766>>>>>>>        // Lastly, we remove the very first array item as it is empty (we started at 1 because that is the first [Connection#])
82766>>>>>>>        If (SizeOfArray(SQLConnectionsArray) > 0) Begin
82768>>>>>>>            Move (RemoveFromArray(SQLConnectionsArray, 0)) to SQLConnectionsArray
82769>>>>>>>        End
82769>>>>>>>>
82769>>>>>>>
82769>>>>>>>        Function_Return SQLConnectionsArray
82770>>>>>>>    End_Function
82771>>>>>>>
82771>>>>>>>    Function SQLIniFileWriteConnections tSQLConnection[] SQLConnectionsArray Returns Boolean
82773>>>>>>>        Integer iCount iSize
82773>>>>>>>        Boolean bOK
82773>>>>>>>        String sConnectionString sSection sValue
82773>>>>>>>
82773>>>>>>>        // First we need to _remove_ all current connections in the ini-file, we
82773>>>>>>>        // do that by setting their values to "".
82773>>>>>>>        Move 0 to iCount
82774>>>>>>>        Get SQLIniFileDeleteAllConnections to bOK
82775>>>>>>>        If (bOK = False) Begin
82777>>>>>>>            Function_Return False
82778>>>>>>>        End
82778>>>>>>>>
82778>>>>>>>
82778>>>>>>>        Move False to Err
82779>>>>>>>        Get psIniSectionName to sSection
82780>>>>>>>        // Sorting will make sure we have the active connection record as the first connection item in the ini-file.
82780>>>>>>>        Move (SortArray(SQLConnectionsArray, Self, (RefFunc(SortActiveFirst)))) to SQLConnectionsArray
82781>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
82782>>>>>>>        Decrement iSize
82783>>>>>>>
82783>>>>>>>        For iCount from 0 to iSize
82789>>>>>>>>
82789>>>>>>>            // DF 19 compatible settings:
82789>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionIdKeyword   to SQLConnectionsArray[iCount].sConnectionID
82790>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDriverKeyword         to SQLConnectionsArray[iCount].sDriverID
82791>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniUIDKeyword            to SQLConnectionsArray[iCount].sUserID
82792>>>>>>>
82792>>>>>>>            Move SQLConnectionsArray[iCount].sPassword to sValue
82793>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
82795>>>>>>>                Get EncryptPassword sValue to sValue
82796>>>>>>>            End
82796>>>>>>>>
82796>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDFPWDKeyword          to sValue
82797>>>>>>>
82797>>>>>>>            If (SQLConnectionsArray[iCount].bTrusted = True) Begin
82799>>>>>>>                Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniTrustedKeyword    to CS_SQLIniConnectionYes
82800>>>>>>>            End
82800>>>>>>>>
82800>>>>>>>
82800>>>>>>>            Get ConstructShortConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                            to SQLConnectionsArray[iCount].sConnectionString
82801>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionKeyWord     to SQLConnectionsArray[iCount].sConnectionString
82802>>>>>>>
82802>>>>>>>            // The Database Update Framework extended settings:
82802>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDbTypeKeyword          to SQLConnectionsArray[iCount].iDbType
82803>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSchemaKeyword          to SQLConnectionsArray[iCount].sSchema
82804>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniBaseTableSpaceKeyword  to SQLConnectionsArray[iCount].sBaseTableSpace
82805>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniLongTableSpaceKeyword  to SQLConnectionsArray[iCount].sLongTableSpace
82806>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniIndexTableSpaceKeyword to SQLConnectionsArray[iCount].sIndexTableSpace
82807>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSilentLoginKeyword     to SQLConnectionsArray[iCount].bSilentLogin
82808>>>>>>>        Loop
82809>>>>>>>>
82809>>>>>>>
82809>>>>>>>        Function_Return (bOK and Err = False)
82810>>>>>>>    End_Function
82811>>>>>>>
82811>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
82811>>>>>>>    //
82811>>>>>>>    // SQL utility function that returns a database type (string) constant
82811>>>>>>>    // corresponding to the passed iDbType.
82811>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
82813>>>>>>>        String sRetval
82813>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
82815>>>>>>>            Move CS_dbTypeMSSQL to sRetval
82816>>>>>>>        End
82816>>>>>>>>
82816>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
82818>>>>>>>            Move CS_dbTypeMySQL to sRetval
82819>>>>>>>        End
82819>>>>>>>>
82819>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
82821>>>>>>>            Move CS_dbTypeOracle to sRetval
82822>>>>>>>        End
82822>>>>>>>>
82822>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
82824>>>>>>>            Move CS_dbTypeDB2 to sRetval
82825>>>>>>>        End
82825>>>>>>>>
82825>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
82827>>>>>>>            Move CS_dbTypePostgre to sRetval
82828>>>>>>>        End
82828>>>>>>>>
82828>>>>>>>        Function_Return sRetval
82829>>>>>>>    End_Function
82830>>>>>>>
82830>>>>>>>    // SQL utility function that returns a database type constant (integer)
82830>>>>>>>    // corresponding to the passed sDbType string constant.
82830>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType  Returns Integer
82832>>>>>>>        Integer iRetval
82832>>>>>>>        If (sDbType = CS_dbTypeMSSQL) Begin
82834>>>>>>>            Move EN_dbTypeMSSQL to iRetval
82835>>>>>>>        End
82835>>>>>>>>
82835>>>>>>>        If (sDbType = CS_dbTypeMySQL) Begin
82837>>>>>>>            Move EN_dbTypeMySQL to iRetval
82838>>>>>>>        End
82838>>>>>>>>
82838>>>>>>>        If (sDbType = CS_dbTypeOracle) Begin
82840>>>>>>>            Move EN_dbTypeOracle to iRetval
82841>>>>>>>        End
82841>>>>>>>>
82841>>>>>>>        If (sDbType = CS_dbTypeDB2) Begin
82843>>>>>>>            Move EN_dbTypeDB2 to iRetval
82844>>>>>>>        End
82844>>>>>>>>
82844>>>>>>>        If (sDbType = CS_dbTypePostgre) Begin
82846>>>>>>>            Move EN_dbTypePostgre to iRetval
82847>>>>>>>        End
82847>>>>>>>>
82847>>>>>>>        Function_Return iRetval
82848>>>>>>>    End_Function
82849>>>>>>>
82849>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
82849>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
82849>>>>>>>    // the SQL Connection program's grid.
82849>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
82851>>>>>>>        String sRetval
82851>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
82853>>>>>>>            Move "EN_dbTypeMSSQL" to sRetval
82854>>>>>>>        End
82854>>>>>>>>
82854>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
82856>>>>>>>            Move "EN_dbTypeMySQL" to sRetval
82857>>>>>>>        End
82857>>>>>>>>
82857>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
82859>>>>>>>            Move "EN_dbTypeOracle" to sRetval
82860>>>>>>>        End
82860>>>>>>>>
82860>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
82862>>>>>>>            Move "EN_dbTypeDB2" to sRetval
82863>>>>>>>        End
82863>>>>>>>>
82863>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
82865>>>>>>>            Move "EN_dbTypePostgre" to sRetval
82866>>>>>>>        End
82866>>>>>>>>
82866>>>>>>>        Function_Return sRetval
82867>>>>>>>    End_Function
82868>>>>>>>
82868>>>>>>>    // Pass a driver id and the function will return
82868>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
82868>>>>>>>    // quite work and always returns "MS SQL Server"
82868>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
82870>>>>>>>        Integer iRetval
82870>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
82872>>>>>>>            Move EN_dbTypeMSSQL to iRetval
82873>>>>>>>        End
82873>>>>>>>>
82873>>>>>>>        If (sDriverID = SQLFLEX) Begin
82875>>>>>>>            Move EN_dbTypeMSSQL to iRetval
82876>>>>>>>        End
82876>>>>>>>>
82876>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
82878>>>>>>>            Move EN_dbTypeMSSQL to iRetval
82879>>>>>>>        End
82879>>>>>>>>
82879>>>>>>>        If (sDriverID = MDSMySQL) Begin
82881>>>>>>>            Move EN_dbTypeMySQL to iRetval
82882>>>>>>>        End
82882>>>>>>>>
82882>>>>>>>        If (sDriverID = ORAFLEX) Begin
82884>>>>>>>            Move EN_dbTypeOracle to iRetval
82885>>>>>>>        End
82885>>>>>>>>
82885>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
82887>>>>>>>            Move EN_dbTypeDB2 to iRetval
82888>>>>>>>        End
82888>>>>>>>>
82888>>>>>>>        If (sDriverID = MDSPgSQL) Begin
82890>>>>>>>            Move EN_dbTypePostgre to iRetval
82891>>>>>>>        End
82891>>>>>>>>
82891>>>>>>>        Function_Return iRetval
82892>>>>>>>    End_Function
82893>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
82893>>>>>>>>
82893>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
82895>>>>>>>>    Integer iStart iEnd
82895>>>>>>>>    String sRetval
82895>>>>>>>>
82895>>>>>>>>    Move (Trim(sConnect)) to sConnect
82896>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
82897>>>>>>>>    If (iStart = 0) Begin
82899>>>>>>>>        Function_Return ""
82900>>>>>>>>    End
82900>>>>>>>>>
82900>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
82901>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
82902>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
82904>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
82905>>>>>>>>    End
82905>>>>>>>>>
82905>>>>>>>>    Else Begin
82906>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
82907>>>>>>>>    End
82907>>>>>>>>>
82907>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
82909>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
82910>>>>>>>>        Decrement iEnd
82911>>>>>>>>    End
82911>>>>>>>>>
82911>>>>>>>>    If (iEnd <> 0) Begin
82913>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
82914>>>>>>>>    End
82914>>>>>>>>>
82914>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
82915>>>>>>>>
82915>>>>>>>>    Function_Return (Trim(sRetval))
82916>>>>>>>>End_Function
82917>>>>>>>>
82917>>>>>>>>
82917>>>>>>>
82917>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
82919>>>>>>>        String sConnect
82919>>>>>>>        Handle hoDriver
82919>>>>>>>
82919>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
82920>>>>>>>        Set psDriverID of hoDriver to sDriverID
82921>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
82922>>>>>>>        Send Destroy   of hoDriver
82923>>>>>>>
82923>>>>>>>//        Case Begin
82923>>>>>>>//            Case (sDriverID = MSSQLDRV_ID)
82923>>>>>>>//                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
82923>>>>>>>//                If (sDatabase <> "") Begin
82923>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
82923>>>>>>>//                End
82923>>>>>>>//                If (bTrusted = True) Begin
82923>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
82923>>>>>>>//                End
82923>>>>>>>//                Else Begin
82923>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
82923>>>>>>>//                End
82923>>>>>>>//                Case Break
82923>>>>>>>//
82923>>>>>>>//            Case (sDriverID = ODBC_DRV_ID)
82923>>>>>>>//                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
82923>>>>>>>//                If (sDatabase <> "") Begin
82923>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
82923>>>>>>>//                End
82923>>>>>>>//                If (bTrusted = True) Begin
82923>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
82923>>>>>>>//                End
82923>>>>>>>//                Else Begin
82923>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
82923>>>>>>>//                End
82923>>>>>>>//                Case Break
82923>>>>>>>//
82923>>>>>>>//            Case (sDriverID = DB2_DRV_ID)
82923>>>>>>>//                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
82923>>>>>>>////                If (sDatabase <> "") Begin
82923>>>>>>>////                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
82923>>>>>>>////                End
82923>>>>>>>////                If (bTrusted = True) Begin
82923>>>>>>>////                    Move (sConnect * ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
82923>>>>>>>////                End
82923>>>>>>>////                Else Begin
82923>>>>>>>//                Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
82923>>>>>>>////                End
82923>>>>>>>//                Case Break
82923>>>>>>>//
82923>>>>>>>//            Case (sDriverID = SQLFLEX)
82923>>>>>>>//                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
82923>>>>>>>//                If (sDatabase <> "") Begin
82923>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
82923>>>>>>>//                End
82923>>>>>>>//                If (bTrusted = True) Begin
82923>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
82923>>>>>>>//                End
82923>>>>>>>//                Else Begin
82923>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
82923>>>>>>>//                End
82923>>>>>>>//                Case Break
82923>>>>>>>//
82923>>>>>>>//            Case (sDriverID = ORAFLEX)
82923>>>>>>>//                If (sDatabase <> "" and (not(sServer contains "/"))) Begin
82923>>>>>>>//                    Move (sServer + "/" + sDatabase)                  to sServer
82923>>>>>>>//                End
82923>>>>>>>//                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
82923>>>>>>>//                Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
82923>>>>>>>//                Case Break
82923>>>>>>>//
82923>>>>>>>//            Case (sDriverID = MDSPgSQL)
82923>>>>>>>//                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
82923>>>>>>>//                If (sDatabase <> "") Begin
82923>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
82923>>>>>>>//                End
82923>>>>>>>//                Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
82923>>>>>>>//                Case Break
82923>>>>>>>//
82923>>>>>>>//            Case (sDriverID = MDSMySQL)
82923>>>>>>>//                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
82923>>>>>>>//                If (sDatabase <> "") Begin
82923>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
82923>>>>>>>//                End
82923>>>>>>>//                Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
82923>>>>>>>//                Case Break
82923>>>>>>>//
82923>>>>>>>//            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
82923>>>>>>>//                Break
82923>>>>>>>//
82923>>>>>>>//            Case Else
82923>>>>>>>//                Move "" to sConnect
82923>>>>>>>//        Case End
82923>>>>>>>
82923>>>>>>>        Function_Return sConnect
82924>>>>>>>    End_Function
82925>>>>>>>
82925>>>>>>>    // Short connection string used when writing to ini-file. This is to be compatible with DF19 DFConnId.ini files that uses this short format.
82925>>>>>>>    Function ConstructShortConnectionString String sDriverID String sServer String sDatabase Returns String
82927>>>>>>>        String sConnect
82927>>>>>>>
82927>>>>>>>        Case Begin
82927>>>>>>>            Case (sDriverID = MSSQLDRV_ID or sDriverID = SQLFLEX)
82929>>>>>>>                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
82930>>>>>>>                If (sDatabase <> "") Begin
82932>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
82933>>>>>>>                End
82933>>>>>>>>
82933>>>>>>>                Case Break
82934>>>>>>>
82934>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
82937>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
82938>>>>>>>                If (sDatabase <> "") Begin
82940>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
82941>>>>>>>                End
82941>>>>>>>>
82941>>>>>>>                Case Break
82942>>>>>>>
82942>>>>>>>            Case (sDriverID = DB2_DRV_ID)
82945>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
82946>>>>>>>                If (sDatabase <> "") Begin
82948>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
82949>>>>>>>                End
82949>>>>>>>>
82949>>>>>>>                Case Break
82950>>>>>>>
82950>>>>>>>            Case (sDriverID = ORAFLEX)
82953>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
82954>>>>>>>                If (sDatabase <> "") Begin
82956>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
82957>>>>>>>                End
82957>>>>>>>>
82957>>>>>>>                Case Break
82958>>>>>>>
82958>>>>>>>            Case (sDriverID = MDSPgSQL)
82961>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
82962>>>>>>>                If (sDatabase <> "") Begin
82964>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
82965>>>>>>>                End
82965>>>>>>>>
82965>>>>>>>                Case Break
82966>>>>>>>
82966>>>>>>>            Case (sDriverID = MDSMySQL)
82969>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
82970>>>>>>>                If (sDatabase <> "") Begin
82972>>>>>>>                    Move (sConnect * ";" +CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
82973>>>>>>>                End
82973>>>>>>>>
82973>>>>>>>                Case Break
82974>>>>>>>
82974>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
82977>>>>>>>                Break
82978>>>>>>>
82978>>>>>>>            Case Else
82978>>>>>>>                Move "" to sConnect
82979>>>>>>>        Case End
82979>>>>>>>
82979>>>>>>>        Function_Return sConnect
82980>>>>>>>    End_Function
82981>>>>>>>
82981>>>>>>>    // Use Base64
82981>>>>>>>    Function EncryptPassword String sPassword Returns String
82983>>>>>>>        String sRetval
82983>>>>>>>//        Handle hoCryptographer
82983>>>>>>>//
82983>>>>>>>//        Get psHashString to sHashString
82983>>>>>>>//        Get Create (RefClass(cCryptographer)) to hoCryptographer
82983>>>>>>>//        Set psProvider of hoCryptographer to MS_ENHANCED_PROV
82983>>>>>>>//        Get Encrypt of hoCryptographer sHashString sPassword to sRetval
82983>>>>>>>//
82983>>>>>>>//        Send Destroy of hoCryptographer
82983>>>>>>>          Get EncodeString of oBase64Functions sPassword to sRetval
82984>>>>>>>        Function_Return sRetval
82985>>>>>>>    End_Function
82986>>>>>>>
82986>>>>>>>    Function DecryptPassword String sPassword Returns String
82988>>>>>>>        String sRetval
82988>>>>>>>//        Handle hoCryptographer
82988>>>>>>>//
82988>>>>>>>//        Get psHashString to sHashString
82988>>>>>>>//        Get Create (RefClass(cCryptographer)) to hoCryptographer
82988>>>>>>>//        Set psProvider of hoCryptographer to MS_ENHANCED_PROV
82988>>>>>>>//        Get Decrypt of hoCryptographer sHashString sPassword to sRetval
82988>>>>>>>//
82988>>>>>>>//        Send Destroy of hoCryptographer
82988>>>>>>>          Get DecodeString of oBase64Functions sPassword to sRetval
82989>>>>>>>
82989>>>>>>>        Function_Return sRetval
82990>>>>>>>    End_Function
82991>>>>>>>
82991>>>>>>>    // Returns the full path of the Application (no trailing "\")
82991>>>>>>>    Function ApplicationPath Returns String
82993>>>>>>>        String sApplicationFileName sPath
82993>>>>>>>        Integer iNumChars iRetval
82993>>>>>>>
82993>>>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
82994>>>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
82995>>>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
82996>>>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
82997>>>>>>>        Move (CString(sApplicationFileName)) to sPath
82998>>>>>>>
82998>>>>>>>        Function_Return sPath
82999>>>>>>>    End_Function
83000>>>>>>>
83000>>>>>>>End_Class
83001>>>>>Use cDbUpdateDatabaseDriver.pkg
83001>>>>>
83001>>>>>// The cConnection class is the new SQL connections class for DF 19.
83001>>>>>// If an object of the cConnection class hasn't been instantiated we use a "dummy" class in its place.
83001>>>>>
83001>>>>>// We're making references to this object handle so we need it defined
83001>>>>>// here as well as for the cDbUpdateHandler class
83001>>>>>
83001>>>>>    Global_Variable Handle ghoSQLConnectionHandler
83001>>>>>
83001>>>>>Class cSQLConnectionHandler is a cObject
83002>>>>>
83002>>>>>    Procedure Construct_Object
83004>>>>>        Forward Send Construct_Object
83006>>>>>        Move Self to ghoSQLConnectionHandler
83007>>>>>
83007>>>>>        Property Handle phoSQLConnectionIniFile (Create(Self,RefClass(cSQLConnectionIniFile)))
83008>>>>>
83008>>>>>        // These properties are used by the cDbUpdateVersion and cDbUpdateFunctionLibrary classes,
83008>>>>>        // but put here so they can be set/get in both class objects. Those classes has "relay"
83008>>>>>        // methods to this class.
83008>>>>>        Property Boolean pbUseConnectionID True
83009>>>>>        Property Boolean pbToANSI          True
83010>>>>>        Property Boolean pbRecnum          True
83011>>>>>        Property Boolean pbCopyData        True
83012>>>>>        Property Boolean pbApiTableUpdateAuto    False
83013>>>>>        Property Boolean pbCompareDate_DateTime  False
83014>>>>>        Property Boolean pbCompareIndexAscending False
83015>>>>>        Property Boolean pbCompareIndexUppercase False
83016>>>>>
83016>>>>>        // Driver default value settings:
83016>>>>>        // Note: When the object is created the corresponding values
83016>>>>>        // from the driver .int files are read.
83016>>>>>        // Sample: Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of {driverNumber} to {StringVariable}
83016>>>>>        Property String psDriverDefaultValueASCII    ""
83017>>>>>        Property String psDriverDefaultValueBinary   ""
83018>>>>>        Property String psDriverDefaultValueDate     ""
83019>>>>>        Property String psDriverDefaultValueDateTime ""
83020>>>>>        Property String psDriverDefaultValueNumeric  ""
83021>>>>>        Property String psDriverDefaultValueText     ""
83022>>>>>
83022>>>>>        // Driver "nullability" settings:
83022>>>>>        // Note: When the object is created the corresponding values
83022>>>>>        // from the driver .int files are read.
83022>>>>>        // Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII of {driverNumber} to {BooleanVariable}
83022>>>>>        Property Boolean pbDriverDefaultNullableASCII    False
83023>>>>>        Property Boolean pbDriverDefaultNullableBinary   False
83024>>>>>        Property Boolean pbDriverDefaultNullableDate     False
83025>>>>>        Property Boolean pbDriverDefaultNullableDateTime False
83026>>>>>        Property Boolean pbDriverDefaultNullableNumeric  False
83027>>>>>        Property Boolean pbDriverDefaultNullableText     False
83028>>>>>
83028>>>>>        // *** This is the central point of connection data for the Database Update Framework ***
83028>>>>>        //     It is private because the get/set version also updates the DAW/Mertech
83028>>>>>        //     driver interfaces.
83028>>>>>        //     There are also procedure/function pairs to set/get individual data members
83028>>>>>        //     of the struct they are all routed throu this struct property.
83028>>>>>        Property tSQLConnection Private.pSQLConnection
83029>>>>>
83029>>>>>    End_Procedure
83030>>>>>
83030>>>>>    Procedure End_Construct_Object
83032>>>>>        Boolean bReadSettings
83032>>>>>        tSQLConnection SQLConnection
83032>>>>>        tSQLConnection SQLConnection
83032>>>>>
83032>>>>>        Forward Send End_Construct_Object
83034>>>>>
83034>>>>>        // Now is the time to read and apply SQL connection settings.
83034>>>>>        Get SetupSQLConnection True True to SQLConnection
83035>>>>>        Set Private.pSQLConnection to SQLConnection
83036>>>>>    End_Procedure
83037>>>>>
83037>>>>>    // *** Properties ***
83037>>>>>    // All connection related "properties" (get/set pairs) are really done by changing the
83037>>>>>    // private.pSQLConnection struct connection property. These "properties" are
83037>>>>>    // merely here for conveniance.
83037>>>>>    //
83037>>>>>    // The pSQLConnection get/set are here so we have a "central hub"
83037>>>>>    // where we update data to/from the DAW & Mertech driver interfaces and this framework.
83037>>>>>    // This struct property contains all the connection data.
83037>>>>>    //
83037>>>>>    Procedure Set pSQLConnection tSQLConnection SQLConnection
83039>>>>>        Boolean bIsDaw bOK
83039>>>>>
83039>>>>>        Set Private.pSQLConnection to SQLConnection
83040>>>>>
83040>>>>>        // When starting a program we might not have a connection id yet:
83040>>>>>        If (SQLConnection.sConnectionID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
83042>>>>>            Procedure_Return
83043>>>>>        End
83043>>>>>>
83043>>>>>
83043>>>>>        // If a DAW DFConnId.ini file was read instead of the DUF SQLConnections.ini file we should by now
83043>>>>>        // be logged in already and don't want to do it again.
83043>>>>>        If (SQLConnection.bDAWConnection = False) Begin
83045>>>>>            // After we have set the class property we need to tell the DAW/Mertech
83045>>>>>            // driver interfaces about the change & make a new login.
83045>>>>>            Get SQLLogin SQLConnection to bOK
83046>>>>>            If (bOK = False) Begin
83048>>>>>                Error DFERR_PROGRAM "Login error."
83049>>>>>>
83049>>>>>            End
83049>>>>>>
83049>>>>>        End
83049>>>>>>
83049>>>>>
83049>>>>>        // Now is the time to setup our driver default values by reading the driver .int file:
83049>>>>>        Send SetupDriverDefaults SQLConnection.sDriverID
83050>>>>>
83050>>>>>    End_Procedure
83051>>>>>
83051>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
83051>>>>>    // attempt to load the driver.
83051>>>>>    // Returns true if the passed driver is SQL based.
83051>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
83053>>>>>        Boolean bOK
83053>>>>>
83053>>>>>        Get IsDAWSQLDriver sDriverID to bOK
83054>>>>>        If (bOK = False) Begin
83056>>>>>            Get IsMertechDriver sDriverID to bOK
83057>>>>>        End
83057>>>>>>
83057>>>>>
83057>>>>>        Function_Return bOK
83058>>>>>    End_Function
83059>>>>>
83059>>>>>    // Reads the driver .int file and sets class properties of the cDbUpdateFunctionLibrary accordingly.
83059>>>>>    Procedure SetupDriverDefaults String sDriverID
83061>>>>>        String sAttributeValue
83061>>>>>        Integer iDriverID
83061>>>>>        Boolean bNULL bSQLDriver
83061>>>>>
83061>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
83062>>>>>        If (bSQLDriver = False) Begin
83064>>>>>            Procedure_Return
83065>>>>>        End
83065>>>>>>
83065>>>>>
83065>>>>>        Get DriverIndex sDriverID to iDriverID
83066>>>>>
83066>>>>>        // Driver default values for various data types:
83066>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_ASCII of iDriverID      to sAttributeValue
83069>>>>>        Set psDriverDefaultValueASCII                                   to sAttributeValue
83070>>>>>
83070>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_BINARY of iDriverID     to sAttributeValue
83073>>>>>        Set psDriverDefaultValueBinary                                  to sAttributeValue
83074>>>>>
83074>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATE of iDriverID       to sAttributeValue
83077>>>>>        Set psDriverDefaultValueDate                                    to sAttributeValue
83078>>>>>
83078>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATETIME of iDriverID   to sAttributeValue
83081>>>>>        Set psDriverDefaultValueDateTime                                to sAttributeValue
83082>>>>>
83082>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of iDriverID    to sAttributeValue
83085>>>>>        Set psDriverDefaultValueNumeric                                 to sAttributeValue
83086>>>>>
83086>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_TEXT of iDriverID       to sAttributeValue
83089>>>>>        Set psDriverDefaultValueText                                    to sAttributeValue
83090>>>>>
83090>>>>>        // The default setting for the "nullability" of newly created ASCII columns.
83090>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII      of iDriverID to bNULL
83093>>>>>        Set pbDriverDefaultNullableASCII to bNULL
83094>>>>>
83094>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_BINARY     of iDriverID to bNULL
83097>>>>>        Set pbDriverDefaultNullableBinary to bNULL
83098>>>>>
83098>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATE       of iDriverID to bNULL
83101>>>>>        Set pbDriverDefaultNullableDate to bNULL
83102>>>>>
83102>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATETIME   of iDriverID to bNULL
83105>>>>>        Set pbDriverDefaultNullableDateTime to bNULL
83106>>>>>
83106>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_NUMERIC    of iDriverID to bNULL
83109>>>>>        Set pbDriverDefaultNullableNumeric to bNULL
83110>>>>>
83110>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_TEXT       of iDriverID to bNULL
83113>>>>>        Set pbDriverDefaultNullableText to bNULL
83114>>>>>
83114>>>>>    End_Procedure
83115>>>>>
83115>>>>>    Function SQLLogin tSQLConnection SQLConnection Returns Boolean
83117>>>>>        Boolean bOK bIsDaw bIsMertech bTrusted
83117>>>>>        String sConnectionString sServer sDatabase sUserId sPassword sDriverID
83117>>>>>        Handle hoErrorObj hoDriver hoIniFile
83117>>>>>        Integer iDriverID
83117>>>>>
83117>>>>>        Move False to bOK
83118>>>>>
83118>>>>>        Get IsDAWSQLDriver SQLConnection.sDriverID to bIsDaw
83119>>>>>        If (bIsDaw = False) Begin
83121>>>>>            Get IsMertechDriver SQLConnection.sDriverID to bIsMertech
83122>>>>>            If (bIsMertech = False) Begin
83124>>>>>                Function_Return False
83125>>>>>            End
83125>>>>>>
83125>>>>>        End
83125>>>>>>
83125>>>>>
83125>>>>>        Move Error_Object_Id to hoErrorObj
83126>>>>>        Move Self to Error_Object_Id
83127>>>>>
83127>>>>>        Get phoSQLConnectionIniFile to hoIniFile
83128>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
83129>>>>>        Get DriverIndex SQLConnection.sDriverID to iDriverID
83130>>>>>        If (iDriverID = 0) Begin
83132>>>>>            Move hoErrorObj to Error_Object_Id
83133>>>>>            Function_Return False
83134>>>>>        End
83134>>>>>>
83134>>>>>
83134>>>>>        // There's a bug in Mertech drivers creating "an Exception error" in the debugger (probably will crash an application too.)
83134>>>>>        If (bIsMertech = False) Begin
83136>>>>>            Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to SQLConnection.bSilentLogin
83139>>>>>        End
83139>>>>>>
83139>>>>>
83139>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
83140>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
83141>>>>>        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
83142>>>>>        Send Destroy   of hoDriver
83143>>>>>        Move hoErrorObj to Error_Object_Id
83144>>>>>
83144>>>>>        Function_Return bOK
83145>>>>>    End_Function
83146>>>>>
83146>>>>>    Function pSQLConnection Returns tSQLConnection
83148>>>>>        tSQLConnection SQLConnection
83148>>>>>        tSQLConnection SQLConnection
83148>>>>>        Get Private.pSQLConnection to SQLConnection
83149>>>>>        Function_Return SQLConnection
83150>>>>>    End_Function
83151>>>>>
83151>>>>>    Procedure Set psConnectionID String sValue
83153>>>>>        tSQLConnection SQLConnection
83153>>>>>        tSQLConnection SQLConnection
83153>>>>>
83153>>>>>        Get Private.pSQLConnection to SQLConnection
83154>>>>>        If (SQLConnection.sConnectionID = "") Begin
83156>>>>>            Move sValue to SQLConnection.sConnectionID
83157>>>>>        End
83157>>>>>>
83157>>>>>
83157>>>>>        // Else we might want to change the current connection ID
83157>>>>>        Else If (SQLConnection.sConnectionID <> "" and SQLConnection.sConnectionID <> sValue) Begin
83160>>>>>            Move False to Err
83161>>>>>            Logout SQLConnection.sDriverID
83162>>>>>            // This will also make a login to the new server.
83162>>>>>            Get SQLIniFileConnectionID of (phoSQLConnectionIniFile(Self)) sValue to SQLConnection
83163>>>>>        End
83163>>>>>>
83163>>>>>        Set pSQLConnection to SQLConnection
83164>>>>>    End_Procedure
83165>>>>>
83165>>>>>    Function psConnectionID Returns String
83167>>>>>        tSQLConnection SQLConnection
83167>>>>>        tSQLConnection SQLConnection
83167>>>>>        Get Private.pSQLConnection to SQLConnection
83168>>>>>        Function_Return SQLConnection.sConnectionID
83169>>>>>    End_Procedure
83170>>>>>
83170>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
83170>>>>>    //       the psDriverID *must* be the first property that is changed!
83170>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
83170>>>>>    //       for a connection string has the wrong format for that driver.
83170>>>>>    Procedure Set psDriverID String sValue
83172>>>>>        tSQLConnection SQLConnection
83172>>>>>        tSQLConnection SQLConnection
83172>>>>>        Get pSQLConnection to SQLConnection
83173>>>>>        Move sValue        to SQLConnection.sDriverID
83174>>>>>        Set pSQLConnection to SQLConnection
83175>>>>>        If (sValue <> DATAFLEX_ID) Begin
83177>>>>>            Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
83178>>>>>        End
83178>>>>>>
83178>>>>>    End_Procedure
83179>>>>>
83179>>>>>    Function psDriverID Returns String
83181>>>>>        tSQLConnection SQLConnection
83181>>>>>        tSQLConnection SQLConnection
83181>>>>>        Get Private.pSQLConnection to SQLConnection
83182>>>>>        If (SQLConnection.sDriverID = "") Begin
83184>>>>>            Move DATAFLEX_ID to SQLConnection.sDriverID // Default is the DataFlex driver.
83185>>>>>        End
83185>>>>>>
83185>>>>>        Function_Return SQLConnection.sDriverID
83186>>>>>    End_Function
83187>>>>>
83187>>>>>    Procedure Set psConnectionString String sValue
83189>>>>>        tSQLConnection SQLConnection
83189>>>>>        tSQLConnection SQLConnection
83189>>>>>        Get Private.pSQLConnection to SQLConnection
83190>>>>>        Move sValue        to SQLConnection.sConnectionString
83191>>>>>        Set pSQLConnection to SQLConnection
83192>>>>>    End_Procedure
83193>>>>>
83193>>>>>    Function psConnectionString Returns String
83195>>>>>        tSQLConnection SQLConnection
83195>>>>>        tSQLConnection SQLConnection
83195>>>>>        Get Private.pSQLConnection to SQLConnection
83196>>>>>        Function_Return SQLConnection.sConnectionString
83197>>>>>    End_Function
83198>>>>>
83198>>>>>    Procedure Set psServer String sValue
83200>>>>>        tSQLConnection SQLConnection
83200>>>>>        tSQLConnection SQLConnection
83200>>>>>        Get Private.pSQLConnection to SQLConnection
83201>>>>>        Move sValue        to SQLConnection.sServer
83202>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
83203>>>>>        Set pSQLConnection to SQLConnection
83204>>>>>    End_Procedure
83205>>>>>
83205>>>>>    Function psServer Returns String
83207>>>>>        tSQLConnection SQLConnection
83207>>>>>        tSQLConnection SQLConnection
83207>>>>>        Get Private.pSQLConnection to SQLConnection
83208>>>>>        Function_Return SQLConnection.sServer
83209>>>>>    End_Function
83210>>>>>
83210>>>>>    Procedure Set psDatabase String sValue
83212>>>>>        tSQLConnection SQLConnection
83212>>>>>        tSQLConnection SQLConnection
83212>>>>>        Get Private.pSQLConnection to SQLConnection
83213>>>>>        Move sValue        to SQLConnection.sDatabase
83214>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
83215>>>>>        Set pSQLConnection to SQLConnection
83216>>>>>    End_Procedure
83217>>>>>
83217>>>>>    Function psDatabase Returns String
83219>>>>>        tSQLConnection SQLConnection
83219>>>>>        tSQLConnection SQLConnection
83219>>>>>        Get Private.pSQLConnection to SQLConnection
83220>>>>>        Function_Return SQLConnection.sDatabase
83221>>>>>    End_Function
83222>>>>>
83222>>>>>    Procedure Set psUserID String sValue
83224>>>>>        tSQLConnection SQLConnection
83224>>>>>        tSQLConnection SQLConnection
83224>>>>>        Get Private.pSQLConnection to SQLConnection
83225>>>>>        Move sValue        to SQLConnection.sUserID
83226>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
83227>>>>>        Set pSQLConnection to SQLConnection
83228>>>>>    End_Procedure
83229>>>>>
83229>>>>>    Function psUserID Returns String
83231>>>>>        tSQLConnection SQLConnection
83231>>>>>        tSQLConnection SQLConnection
83231>>>>>        Get Private.pSQLConnection to SQLConnection
83232>>>>>        Function_Return SQLConnection.sUserID
83233>>>>>    End_Function
83234>>>>>
83234>>>>>    // This is the uncrypted password
83234>>>>>    Procedure Set psPassword String sValue
83236>>>>>        tSQLConnection SQLConnection
83236>>>>>        tSQLConnection SQLConnection
83236>>>>>        Get Private.pSQLConnection to SQLConnection
83237>>>>>        Move sValue        to SQLConnection.sPassword
83238>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
83239>>>>>        Set pSQLConnection to SQLConnection
83240>>>>>    End_Procedure
83241>>>>>
83241>>>>>    Function psPassword Returns String
83243>>>>>        tSQLConnection SQLConnection
83243>>>>>        tSQLConnection SQLConnection
83243>>>>>        Get Private.pSQLConnection to SQLConnection
83244>>>>>        Function_Return SQLConnection.sPassword
83245>>>>>    End_Function
83246>>>>>
83246>>>>>    Procedure Set pbTrusted Boolean bValue
83248>>>>>        tSQLConnection SQLConnection
83248>>>>>        tSQLConnection SQLConnection
83248>>>>>        Get Private.pSQLConnection to SQLConnection
83249>>>>>        Move bValue        to SQLConnection.bTrusted
83250>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
83251>>>>>        Set pSQLConnection to SQLConnection
83252>>>>>    End_Procedure
83253>>>>>
83253>>>>>    Function pbTrusted Returns Boolean
83255>>>>>        tSQLConnection SQLConnection
83255>>>>>        tSQLConnection SQLConnection
83255>>>>>        Get Private.pSQLConnection to SQLConnection
83256>>>>>        Function_Return SQLConnection.bTrusted
83257>>>>>    End_Function
83258>>>>>
83258>>>>>    // *** All of these properties are special to the Database Update Framework ***
83258>>>>>    //     Thus they are not propagated to the DAW/Mertech classes and that is why
83258>>>>>    //     the Private.pSQLConnection property is set instead of the going throu
83258>>>>>    //     the central pSQLConnection "hub".
83258>>>>>    Procedure Set pbSilentLogin Boolean bValue
83260>>>>>        tSQLConnection SQLConnection
83260>>>>>        tSQLConnection SQLConnection
83260>>>>>        Get Private.pSQLConnection to SQLConnection
83261>>>>>        Move bValue to SQLConnection.bTrusted
83262>>>>>        Set Private.pSQLConnection to SQLConnection
83263>>>>>    End_Procedure
83264>>>>>
83264>>>>>    Function pbSilentLogin Returns Boolean
83266>>>>>        tSQLConnection SQLConnection
83266>>>>>        tSQLConnection SQLConnection
83266>>>>>        Get Private.pSQLConnection to SQLConnection
83267>>>>>        Function_Return SQLConnection.bSilentLogin
83268>>>>>    End_Function
83269>>>>>
83269>>>>>    Procedure Set piDbType Integer iValue
83271>>>>>        tSQLConnection SQLConnection
83271>>>>>        tSQLConnection SQLConnection
83271>>>>>        Get Private.pSQLConnection to SQLConnection
83272>>>>>        Move iValue to SQLConnection.iDbType
83273>>>>>        Set Private.pSQLConnection to SQLConnection
83274>>>>>    End_Procedure
83275>>>>>
83275>>>>>    Function piDbType Returns Integer
83277>>>>>        tSQLConnection SQLConnection
83277>>>>>        tSQLConnection SQLConnection
83277>>>>>        Get Private.pSQLConnection to SQLConnection
83278>>>>>        Function_Return SQLConnection.iDbType
83279>>>>>    End_Function
83280>>>>>
83280>>>>>    Procedure Set psBaseTableSpace String sValue
83282>>>>>        tSQLConnection SQLConnection
83282>>>>>        tSQLConnection SQLConnection
83282>>>>>        Get Private.pSQLConnection to SQLConnection
83283>>>>>        Move sValue to SQLConnection.sBaseTableSpace
83284>>>>>        Set Private.pSQLConnection to SQLConnection
83285>>>>>    End_Procedure
83286>>>>>
83286>>>>>    Function psBaseTableSpace Returns String
83288>>>>>        tSQLConnection SQLConnection
83288>>>>>        tSQLConnection SQLConnection
83288>>>>>        Get Private.pSQLConnection to SQLConnection
83289>>>>>        Function_Return SQLConnection.sBaseTableSpace
83290>>>>>    End_Function
83291>>>>>
83291>>>>>    Procedure Set psIndexTableSpace String sValue
83293>>>>>        tSQLConnection SQLConnection
83293>>>>>        tSQLConnection SQLConnection
83293>>>>>        Get Private.pSQLConnection to SQLConnection
83294>>>>>        Move sValue to SQLConnection.sIndexTableSpace
83295>>>>>        Set Private.pSQLConnection to SQLConnection
83296>>>>>    End_Procedure
83297>>>>>
83297>>>>>    Function psIndexTableSpace Returns String
83299>>>>>        tSQLConnection SQLConnection
83299>>>>>        tSQLConnection SQLConnection
83299>>>>>        Get Private.pSQLConnection to SQLConnection
83300>>>>>        Function_Return SQLConnection.sIndexTableSpace
83301>>>>>    End_Function
83302>>>>>
83302>>>>>    Procedure Set psLongTableSpace String sValue
83304>>>>>        tSQLConnection SQLConnection
83304>>>>>        tSQLConnection SQLConnection
83304>>>>>        Get Private.pSQLConnection to SQLConnection
83305>>>>>        Move sValue to SQLConnection.sLongTableSpace
83306>>>>>        Set Private.pSQLConnection to SQLConnection
83307>>>>>    End_Procedure
83308>>>>>
83308>>>>>    Function psLongTableSpace Returns String
83310>>>>>        tSQLConnection SQLConnection
83310>>>>>        tSQLConnection SQLConnection
83310>>>>>        Get Private.pSQLConnection to SQLConnection
83311>>>>>        Function_Return SQLConnection.sLongTableSpace
83312>>>>>    End_Function
83313>>>>>
83313>>>>>    Procedure Set psSchema String sValue
83315>>>>>        tSQLConnection SQLConnection
83315>>>>>        tSQLConnection SQLConnection
83315>>>>>        Get Private.pSQLConnection to SQLConnection
83316>>>>>        Move sValue to SQLConnection.sSchema
83317>>>>>        Set Private.pSQLConnection to SQLConnection
83318>>>>>    End_Procedure
83319>>>>>
83319>>>>>    Function psSchema Returns String
83321>>>>>        tSQLConnection SQLConnection
83321>>>>>        tSQLConnection SQLConnection
83321>>>>>        Get Private.pSQLConnection to SQLConnection
83322>>>>>        Function_Return SQLConnection.sSchema
83323>>>>>    End_Function
83324>>>>>
83324>>>>>    Procedure Set pbEnabled Boolean bValue
83326>>>>>        tSQLConnection SQLConnection
83326>>>>>        tSQLConnection SQLConnection
83326>>>>>        Get Private.pSQLConnection to SQLConnection
83327>>>>>        Move bValue to SQLConnection.bEnabled
83328>>>>>        Set Private.pSQLConnection to SQLConnection
83329>>>>>    End_Procedure
83330>>>>>
83330>>>>>    Function pbEnabled Returns Boolean
83332>>>>>        tSQLConnection SQLConnection
83332>>>>>        tSQLConnection SQLConnection
83332>>>>>        Get Private.pSQLConnection to SQLConnection
83333>>>>>        Function_Return SQLConnection.bEnabled
83334>>>>>    End_Function
83335>>>>>
83335>>>>>
83335>>>>>    // ************************************
83335>>>>>    Function SetupSQLConnection Boolean bReadDFConnSettings Boolean bReadSQLConnections Returns tSQLConnection
83337>>>>>        tSQLConnection SQLConnection
83337>>>>>        tSQLConnection SQLConnection
83337>>>>>
83337>>>>>        // If this object was created by the cDbUpdateHandler class we will
83337>>>>>        // deferr reading SQL connection values until later.
83337>>>>>        If (bReadDFConnSettings = True) Begin
83339>>>>>            // This is the new SQL login logic for DF 19 and up; "Managed Connections"
83339>>>>>            If (ghoConnection > 0) Begin
83341>>>>>                Get ReadcConnections to SQLConnection
83342>>>>>            End
83342>>>>>>
83342>>>>>
83342>>>>>            // In addition to the above; there might be other values set even if a cConnection
83342>>>>>            // object is used.
83342>>>>>            If (bReadSQLConnections = True) Begin
83344>>>>>                Get ReadSQLConnectionsIniSettings to SQLConnection
83345>>>>>            End
83345>>>>>>
83345>>>>>        End
83345>>>>>>
83345>>>>>
83345>>>>>        Function_Return SQLConnection
83346>>>>>    End_Function
83347>>>>>
83347>>>>>    // This is for the new cConnection class used by DF 19 and up (only).
83347>>>>>    Function ReadcConnections Returns tSQLConnection
83349>>>>>        tConnection Connection
83349>>>>>        tConnection Connection
83349>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
83349>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
83349>>>>>        Integer iRetval iDbType
83349>>>>>        Boolean bOK bEnabled bConnected
83349>>>>>        String sConnectionID sSchema
83349>>>>>
83349>>>>>            tConnection[] Connections
83349>>>>>            tConnection[] Connections
83350>>>>>            // - If the DF 19 cConnection class has been used in the cApplication object
83350>>>>>            // - and there are multiple connection id's defined for the same driver. This is
83350>>>>>            //   because otherwise we can't possibly know which connection id to use... So
83350>>>>>            //   we then generate an error and abort the program...
83350>>>>>            Get IsSinglecConnection (&sConnectionID) to bOK
83351>>>>>            If (bOK = False) Begin
83353>>>>>                Error DFERR_PROGRAM ("Programming error. The psConnectionID must be set in the cDbUpdateVersion object when a cConnect object is used in the cApplication object, and there are multiple connections defined. Program will now exit!")
83354>>>>>>
83354>>>>>                Abort
83355>>>>>>
83355>>>>>            End
83355>>>>>>
83355>>>>>            If (sConnectionID = "") Begin
83357>>>>>                Get ConnectionIDs of ghoConnection to Connections
83358>>>>>                If (SizeOfArray(Connections) > 0) Begin
83360>>>>>                    Move Connections[0].sId to sConnectionID
83361>>>>>                End
83361>>>>>>
83361>>>>>            End
83361>>>>>>
83361>>>>>
83361>>>>>            Move 0 to iRetval
83362>>>>>            // DAW DF19 connection info:
83362>>>>>            // We first check that the connection is OK:
83362>>>>>            Get ConnectionIdIndex of ghoConnection sConnectionID to iRetval
83363>>>>>            // It might happen that no connection has been setup although the object exists, in case we do nothing.
83363>>>>>            If (iRetval = -1) Begin
83365>>>>>                Function_Return SQLConnectionEmpty
83366>>>>>            End
83366>>>>>>
83366>>>>>
83366>>>>>            If (sConnectionID <> "") Begin
83368>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
83369>>>>>            End
83369>>>>>>
83369>>>>>            If (Connection.sId = "") Begin
83371>>>>>                Move True to SQLConnectionEmpty.bError
83372>>>>>                Function_Return SQLConnectionEmpty
83373>>>>>            End
83373>>>>>>
83373>>>>>
83373>>>>>            // DUF connection info struct property:
83373>>>>>            Get Private.pSQLConnection                       to SQLConnection
83374>>>>>
83374>>>>>            Move Connection.sId to sConnectionID
83375>>>>>            Get IsConnectionIdLoggedIn of ghoConnection sConnectionID to bConnected
83376>>>>>
83376>>>>>            If (bConnected = False) Begin
83378>>>>>                Get LoginConnectionId of ghoConnection sConnectionID to iRetval
83379>>>>>                If (iRetval <> 0) Begin
83381>>>>>                    Send UserError CS_DUF_CannotLoginToServer
83382>>>>>                    Send Exit_Application
83383>>>>>                End
83383>>>>>>
83383>>>>>                Move True                                   to SQLConnection.bDAWConnection
83384>>>>>                // We need to get the DAW connection info again as it might have
83384>>>>>                // been changed in the DAW db login dialog.
83384>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
83385>>>>>            End
83385>>>>>>
83385>>>>>
83385>>>>>            Move True                                        to SQLConnection.bEnabled
83386>>>>>            Move Connection.bTrustedConnection               to SQLConnection.bTrusted
83387>>>>>
83387>>>>>            // Not used in DUF:
83387>>>>>            // Move Connection.iDriverIndex                    to SQLConnection.iDriverIndex
83387>>>>>
83387>>>>>            Move (If(Connection.iOptions = 0, False, True))  to SQLConnection.bSilentLogin
83388>>>>>            Move Connection.sConnectionString                to SQLConnection.sConnectionString
83389>>>>>            Move Connection.sDriver                          to SQLConnection.sDriverID
83390>>>>>            Move Connection.sId                              to SQLConnection.sConnectionID
83391>>>>>            Move Connection.sUID                             to SQLConnection.sUserID
83392>>>>>            Move Connection.sPWD                             to SQLConnection.sPassword
83393>>>>>
83393>>>>>            // Not used in DUF:
83393>>>>>            // Move Connection.sSection to SQLConnection.xxx
83393>>>>>
83393>>>>>            // The rest of the properties of the SQLConnection struct should have been
83393>>>>>            // setup in the cDbUpdateHandler object, and we should be able to reach them through delegation:
83393>>>>>            If (Connection.sDriver <> ODBC_DRV_ID) Begin
83395>>>>>                Get ParseKeyWord Connection.sString CS_SQLIniServerKeyword to SQLConnection.sServer
83396>>>>>            End
83396>>>>>>
83396>>>>>            If (Connection.sDriver = ODBC_DRV_ID) Begin
83398>>>>>                Get ParseKeyWord Connection.sString CS_SQLIniDSNKeyword    to SQLConnection.sServer
83399>>>>>            End
83399>>>>>>
83399>>>>>            Get ParseKeyWord Connection.sString CS_SQLIniDatabaseKeyword   to SQLConnection.sDatabase
83400>>>>>
83400>>>>>            // The DbType is a bit special. If the piDbType has _not_ been setup in object code we try to derave
83400>>>>>            // the value from the driver id:
83400>>>>>            Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(Self)) Connection.sDriver to SQLConnection.iDbType
83401>>>>>            // ...but in case it has been explicitly set in the object we use that value.
83401>>>>>            Get piDbType                                     to iDbType
83402>>>>>            If (iDbType <> SQLConnection.iDbType) Begin
83404>>>>>                Move iDbType to SQLConnection.iDbType
83405>>>>>            End
83405>>>>>>
83405>>>>>            Get psBaseTableSpace                             to SQLConnection.sBaseTableSpace
83406>>>>>            Get psLongTableSpace                             to SQLConnection.sLongTableSpace
83407>>>>>            Get psIndexTableSpace                            to SQLConnection.sIndexTableSpace
83408>>>>>            Get psSchema                                     to SQLConnection.sSchema
83409>>>>>
83409>>>>>            // We finally set the struct property to the newly fetched values.
83409>>>>>            Set pSQLConnection to SQLConnection
83410>>>>>
83410>>>>>        Function_Return SQLConnection
83411>>>>>    End_Function
83412>>>>>
83412>>>>>    // Returns True if the psConnectionID has been set in the cDbUpateHandler object,
83412>>>>>    // or the DAW cConnect array of registered connection only contains one active/enabled
83412>>>>>    // connection id for a particular driver.
83412>>>>>    // So either the psConnectionID or the psDriverID can have been set in the cDbUpdateHandler
83412>>>>>    // object. We can then match a connection id from the DAW cConnect class array.
83412>>>>>    // Returns False if there are multiple connections that are enabled or the psConnectionID has
83412>>>>>    // been set in the cDbUpdateHandler object but it cannot be found amongst the registered
83412>>>>>    // connections of the DAW cConnect class.
83412>>>>>    Function IsSinglecConnection String ByRef sConnectionID Returns Boolean
83414>>>>>        tConnection[] ConnIdArray
83414>>>>>        tConnection[] ConnIdArray
83415>>>>>        Integer iCount iSize iConnectionIDCounter
83415>>>>>        Boolean bEnabled bFound
83415>>>>>        String sConnectionID2 sDriverID sDriverConn
83415>>>>>
83415>>>>>        Move False to bFound
83416>>>>>        If (ghoConnection > 0) Begin
83418>>>>>
83418>>>>>            // The property of the cDbUpdateHandler container object
83418>>>>>            Get psDriverID to sDriverID
83419>>>>>
83419>>>>>            Move 0 to iConnectionIDCounter
83420>>>>>            // This is the the DAW cConnect array with all registered connection id's.
83420>>>>>                Get ConnectionIDs of ghoConnection to ConnIdArray
83421>>>>>            Move (SizeOfArray(ConnIdArray)) to iSize
83422>>>>>            Decrement iSize
83423>>>>>            For iCount from 0 to iSize
83429>>>>>>
83429>>>>>                Move ConnIdArray[iCount].sDriver to sDriverConn
83430>>>>>                Move ConnIdArray[iCount].sId to sConnectionID2
83431>>>>>                Move (ConnIdArray[iCount].bDisabled = False) to bEnabled
83432>>>>>                // If no psConnectionID specified in the cDbUpdateHandler, we check if there is a driver
83432>>>>>                // connection in the DAW cConnect object _and_ that there is only one!
83432>>>>>                If (sConnectionID = "") Begin
83434>>>>>                    Move (sDriverID = sDriverConn and bEnabled = True) to bFound
83435>>>>>                End
83435>>>>>>
83435>>>>>                Else Begin
83436>>>>>                    If (Uppercase(sConnectionID) = Uppercase(sConnectionID2)) Begin
83438>>>>>                        Move iSize to iCount // Then we've found what we were looking for and we're out of here...
83439>>>>>                    End
83439>>>>>>
83439>>>>>                End
83439>>>>>>
83439>>>>>
83439>>>>>                If (bFound = True) Begin
83441>>>>>                    Increment iConnectionIDCounter
83442>>>>>                End
83442>>>>>>
83442>>>>>            Loop
83443>>>>>>
83443>>>>>            Move (iConnectionIDCounter <= 1 and sDriverConn <> "" and sConnectionID2 <> "") to bFound
83444>>>>>            If (bFound = True) Begin
83446>>>>>                Move sConnectionID2 to sConnectionID
83447>>>>>            End
83447>>>>>>
83447>>>>>        End
83447>>>>>>
83447>>>>>
83447>>>>>        // Special case; a cConnection object has been setup in the cApplication,
83447>>>>>        // but no DFConn.ini record has been created.
83447>>>>>        If (iSize = -1) Begin
83449>>>>>            Move True to bFound
83450>>>>>        End
83450>>>>>>
83450>>>>>
83450>>>>>        Function_Return bFound
83451>>>>>    End_Function
83452>>>>>
83452>>>>>    // Send on object creation to read the default connection string settings, and
83452>>>>>    // create a connection to the server.
83452>>>>>    Function ReadSQLConnectionsIniSettings Returns tSQLConnection
83454>>>>>        String sPath sFileName sPassword
83454>>>>>        Boolean bExists
83454>>>>>        tSQLConnection[] SQLConnectionArray
83454>>>>>        tSQLConnection[] SQLConnectionArray
83455>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
83455>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
83455>>>>>        Handle hoIniFile
83455>>>>>        Integer iSize iCount
83455>>>>>
83455>>>>>        Get psIniFilePath to sPath
83456>>>>>        Get phoSQLConnectionIniFile to hoIniFile
83457>>>>>        If (sPath = "") Begin
83459>>>>>            Get ApplicationPath of hoIniFile to sPath
83460>>>>>            Set psIniFilePath   of hoIniFile to sPath
83461>>>>>        End
83461>>>>>>
83461>>>>>        Get vFolderFormat sPath to sPath
83462>>>>>        Get psIniFileName to sFileName
83463>>>>>        Get vFilePathExists (sPath + sFileName) to bExists
83464>>>>>
83464>>>>>        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
83465>>>>>        Move (SizeOfArray(SQLConnectionArray)) to iSize
83466>>>>>        If (iSize = 0) Begin
83468>>>>>            // This may have been set by the "ReadcConnections" function,
83468>>>>>            // if a cConnection object has been setup for DataFlex 19 or later
83468>>>>>            // in the cApplication object.
83468>>>>>            Get pSQLConnection to SQLConnection
83469>>>>>            If (SQLConnection.sConnectionID = "") Begin
83471>>>>>                Function_Return SQLConnectionEmpty
83472>>>>>            End
83472>>>>>>
83472>>>>>            Move SQLConnection to SQLConnectionArray[0]
83473>>>>>        End
83473>>>>>>
83473>>>>>
83473>>>>>        // The first connection should be the one that is active, but just in case...
83473>>>>>        Decrement iSize
83474>>>>>        For iCount from 0 to iSize
83480>>>>>>
83480>>>>>            Move SQLConnectionArray[iCount] to SQLConnection
83481>>>>>            If (SQLConnection.bEnabled = True) Begin
83483>>>>>                Move iSize to iCount // We've found the enabled item, so we're out of here.
83484>>>>>            End
83484>>>>>>
83484>>>>>        Loop
83485>>>>>>
83485>>>>>
83485>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID ;             SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted ;             SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bSilentLogin
83486>>>>>
83486>>>>>        Set pSQLConnection to SQLConnection
83487>>>>>        Send AutoSetConnectionID
83488>>>>>
83488>>>>>        Function_Return SQLConnection
83489>>>>>    End_Function
83490>>>>>
83490>>>>>    Procedure Set psIniFilePath String sPath
83492>>>>>        Set psIniFilePath of (phoSQLConnectionIniFile(Self)) to sPath
83493>>>>>    End_Procedure
83494>>>>>
83494>>>>>    Function psIniFilePath Returns String
83496>>>>>        String sRetval
83496>>>>>        Get psIniFilePath of (phoSQLConnectionIniFile(Self)) to sRetval
83497>>>>>        Function_Return sRetval
83498>>>>>    End_Function
83499>>>>>
83499>>>>>    Procedure Set psIniFileName String sFileName
83501>>>>>        Set psIniFileName of (phoSQLConnectionIniFile(Self)) to sFileName
83502>>>>>    End_Procedure
83503>>>>>
83503>>>>>    Function psIniFileName Returns String
83505>>>>>        String sRetval
83505>>>>>        Get psIniFileName of (phoSQLConnectionIniFile(Self)) to sRetval
83506>>>>>        Function_Return sRetval
83507>>>>>    End_Function
83508>>>>>
83508>>>>>    // We use Base64 coding instead of the cCryptographer class because the
83508>>>>>    // password will get scrambled while writing/reading to/from the ini-file.
83508>>>>>//    { MethodType=Property Category="Behavior" InitialValue="zx!2139(LI0+?ips7433"}
83508>>>>>//    Procedure Set psHashString String sHashString
83508>>>>>//        Set psHashString of (phoSQLConnectionIniFile(Self)) to sHashString
83508>>>>>//    End_Procedure
83508>>>>>//
83508>>>>>//    Function psHashString Returns String
83508>>>>>//        String sRetval
83508>>>>>//        Get psHashString of (phoSQLConnectionIniFile(Self)) to sRetval
83508>>>>>//        Function_Return sRetval
83508>>>>>//    End_Function
83508>>>>>
83508>>>>>    Procedure Set psIniSectionName String sSection
83510>>>>>        Set psIniSectionName of (phoSQLConnectionIniFile(Self)) to sSection
83511>>>>>    End_Procedure
83512>>>>>
83512>>>>>    Function psIniSectionName Returns String
83514>>>>>        String sRetval
83514>>>>>        Get psIniSectionName of (phoSQLConnectionIniFile(Self)) to sRetval
83515>>>>>        Function_Return sRetval
83516>>>>>    End_Function
83517>>>>>
83517>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
83519>>>>>        Handle ho
83519>>>>>        Get phoSQLConnectionIniFile to ho
83520>>>>>        Set IniFileValue of ho to sSection sValueName sValue
83521>>>>>    End_Procedure
83522>>>>>
83522>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
83524>>>>>        Handle ho
83524>>>>>        String sRetval
83524>>>>>        Get phoSQLConnectionIniFile to ho
83525>>>>>        Get IniFileValue of ho sSection sValueName sDefaultValue to sRetval
83526>>>>>        Function_Return sRetval
83527>>>>>    End_Function
83528>>>>>
83528>>>>>    Function SectionExists String sSection Returns Boolean
83530>>>>>        Handle ho
83530>>>>>        Boolean bRetval
83530>>>>>        Get phoSQLConnectionIniFile to ho
83531>>>>>        Get SectionExists of ho sSection to bRetval
83532>>>>>        Function_Return bRetval
83533>>>>>    End_Function
83534>>>>>
83534>>>>>    Function KeyExists String sSection String sKey Returns Boolean
83536>>>>>        Handle ho
83536>>>>>        Boolean bRetval
83536>>>>>        Get phoSQLConnectionIniFile to ho
83537>>>>>        Get KeyExists of ho sSection sKey to bRetval
83538>>>>>        Function_Return bRetval
83539>>>>>    End_Function
83540>>>>>
83540>>>>>    Function EncryptPassword String sPassword Returns String
83542>>>>>        Handle ho
83542>>>>>        String sRetval
83542>>>>>        Get phoSQLConnectionIniFile to ho
83543>>>>>        Get EncryptPassword of ho sPassword to sRetval
83544>>>>>        Function_Return sRetval
83545>>>>>    End_Function
83546>>>>>
83546>>>>>    Function DecryptPassword String sPassword Returns String
83548>>>>>        Handle ho
83548>>>>>        String sRetval
83548>>>>>        Get phoSQLConnectionIniFile to ho
83549>>>>>        Get DecryptPassword of ho sPassword to sRetval
83550>>>>>        Function_Return sRetval
83551>>>>>    End_Function
83552>>>>>
83552>>>>>    // *** Main Connection Message ***
83552>>>>>    // It will create a Connection ID for the passed driver.
83552>>>>>    // It will also set the psDriverID & psConnectionID of this class.
83552>>>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent
83554>>>>>        Handle hoDriver
83554>>>>>        String sConnectionString sError
83554>>>>>        Boolean bLoginSuccessful
83554>>>>>
83554>>>>>        Get ConstructConnectionString sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnectionString
83555>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
83556>>>>>        Set psDriverID of hoDriver to sDriverID
83557>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
83558>>>>>        If (bLoginSuccessful = False) Begin
83560>>>>>            Error DFERR_PROGRAM (CS_DUF_CannotLoginToServer * CS_DUF_ErrorText * String(sError) + "\nConnectionID = " * sConnectionID + "\nConnection String = " * sConnectionString)
83561>>>>>>
83561>>>>>            Send Exit_Application
83562>>>>>        End
83562>>>>>>
83562>>>>>        Send Destroy of hoDriver
83563>>>>>
83563>>>>>    End_Procedure
83564>>>>>
83564>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
83566>>>>>        Integer iRetval
83566>>>>>        Handle hoCLI
83566>>>>>        String sDriverID
83566>>>>>
83566>>>>>        Get psDriverID to sDriverID
83567>>>>>        Get Create (Refclass(cCLIHandler)) to hoCLI
83568>>>>>        If (hoCLI <> 0) Begin
83570>>>>>            Set psDriverID of hoCLI to sDriverID
83571>>>>>            Get RedirectConnection of hoCLI sOldConnection sNewConnection to iRetval
83572>>>>>            Send Destroy of hoCLI
83573>>>>>        End
83573>>>>>>
83573>>>>>
83573>>>>>        Function_Return iRetval
83574>>>>>    End_Function
83575>>>>>
83575>>>>>    Procedure CreateConnParamsFromConnectionString String sDriverID String sConnectionString
83577>>>>>        String sServer sDatabase sUserID sPassword
83577>>>>>        tSQLConnection SQLConnection
83577>>>>>        tSQLConnection SQLConnection
83577>>>>>
83577>>>>>        Set psDriverID to sDriverID
83578>>>>>        Get DeComposeConnectionString sDriverID sConnectionString to SQLConnection
83579>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID SQLConnection.sServer;                                 SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted
83580>>>>>    End_Procedure
83581>>>>>
83581>>>>>    // This is needed when e.g. the connection id we have specified in the program code
83581>>>>>    // also exists in e.g. the MSSQLDRV.ini file (can either be local in the Data folder
83581>>>>>    // or the one in the DataFlex Bin folder.)
83581>>>>>    // We then need to delete the current one before creating a new one.
83581>>>>>    // This is because the parameters may differ between the program code and the
83581>>>>>    // MSSQLDRV.ini file in a deployed environment. Also DataFlex will generate an error
83581>>>>>    // when one tries to create a Connection ID that already exists.
83581>>>>>    Procedure RemoveExistingConnectionID String sDriverID String sConnectionID
83583>>>>>        Integer iResult iDriver iNumConn iConn
83583>>>>>        Handle hoCLI
83583>>>>>        String sID
83583>>>>>
83583>>>>>        If (sDriverID = "" or sConnectionID = "") Begin
83585>>>>>            Procedure_Return
83586>>>>>        End
83586>>>>>>
83586>>>>>
83586>>>>>        Move 0 to iResult
83587>>>>>        Get Create U_cCLIHandler to hoCLI
83588>>>>>        If (hoCLI <> 0) Begin
83590>>>>>            Set psDriverID of hoCLI to sDriverID
83591>>>>>            Get DriverIndex sDriverID to iDriver
83592>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
83595>>>>>            Decrement iNumConn
83596>>>>>            For iConn from 0 to iNumConn
83602>>>>>>
83602>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
83605>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
83607>>>>>                    Get DeleteConnectionID of hoCLI sConnectionID -1 to iResult
83608>>>>>                End
83608>>>>>>
83608>>>>>            Loop
83609>>>>>>
83609>>>>>            Send Destroy of hoCLI
83610>>>>>        End
83610>>>>>>
83610>>>>>
83610>>>>>    End_Procedure
83611>>>>>
83611>>>>>    Function ExistingConnectionSettings String sDriverID String sConnectionID Returns tSQLConnection
83613>>>>>        Integer iResult iDriver iNumConn iConn
83613>>>>>        Handle hoCLI
83613>>>>>        String sID sConnectionString sVal sDatabase
83613>>>>>        tSQLConnection SQLConnection
83613>>>>>        tSQLConnection SQLConnection
83613>>>>>        Boolean bTrusted
83613>>>>>
83613>>>>>        Move 0 to iResult
83614>>>>>        Get Create U_cCLIHandler to hoCLI
83615>>>>>        If (hoCLI <> 0) Begin
83617>>>>>            Set psDriverID of hoCLI to sDriverID
83618>>>>>            Get DriverIndex sDriverID to iDriver
83619>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
83622>>>>>            Decrement iNumConn
83623>>>>>            For iConn from 0 to iNumConn
83629>>>>>>
83629>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
83632>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
83634>>>>>                    Move sDriverID                                                      to SQLConnection.sDriverID      // For completeness only...
83635>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn              to SQLConnection.sConnectionID  // For completeness only...
83638>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iConn       to sConnectionString
83641>>>>>                    Move sConnectionString                                              to SQLConnection.sConnectionString
83642>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_OPTIONS of iDriver iConn      to SQLConnection.bSilentLogin
83645>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnection.sServer
83646>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnection.sDatabase
83647>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to SQLConnection.sUserID
83648>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to SQLConnection.sPassword
83649>>>>>
83649>>>>>                    Case Begin
83649>>>>>                        Case (sDriverID = MSSQLDRV_ID)
83651>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=") to sVal
83652>>>>>                            Move (If(Uppercase(sVal) = Uppercase(CS_SQLIniConnectionYes), True, False)) to bTrusted
83653>>>>>                            Move bTrusted                                               to SQLConnection.bTrusted
83654>>>>>                            Case Break
83655>>>>>                        Case (sDriverID = DB2_DRV_ID)
83658>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
83659>>>>>                            Case Break
83660>>>>>                        Case (sDriverID = ODBC_DRV_ID)
83663>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
83664>>>>>                            Case Break
83665>>>>>                        Case (sDriverID = SQLFLEX)
83668>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
83669>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
83670>>>>>                            If (SQLConnection.bTrusted = True) Begin
83672>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
83673>>>>>                            End
83673>>>>>>
83673>>>>>                            Else Begin
83674>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
83675>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
83676>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
83677>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
83678>>>>>                            End
83678>>>>>>
83678>>>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
83679>>>>>                            Case Break
83680>>>>>                        Case (sDriverID = MDSMySQL)
83683>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
83684>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
83685>>>>>                            If (SQLConnection.bTrusted = True) Begin
83687>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
83688>>>>>                            End
83688>>>>>>
83688>>>>>                            Else Begin
83689>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
83690>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
83691>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
83692>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
83693>>>>>                            End
83693>>>>>>
83693>>>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
83694>>>>>                            Case Break
83695>>>>>                        Case (sDriverID = MDSPgSQL)
83698>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
83699>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
83700>>>>>                            If (SQLConnection.bTrusted = True) Begin
83702>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
83703>>>>>                            End
83703>>>>>>
83703>>>>>                            Else Begin
83704>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
83705>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
83706>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
83707>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
83708>>>>>                            End
83708>>>>>>
83708>>>>>                            Move sConnectionString                                                to SQLConnection.sConnectionString
83709>>>>>                            Case Break
83710>>>>>
83710>>>>>                        Case (sDriverID = ORAFLEX)
83713>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to SQLConnection.sServer
83714>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)         to sConnectionString
83715>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
83716>>>>>                            If (sDatabase <> "" and (not(SQLConnection.sServer contains "/"))) Begin
83718>>>>>                                Move (SQLConnection.sServer + "/" + sDatabase)                  to SQLConnection.sServer
83719>>>>>                            End
83719>>>>>>
83719>>>>>                            If (SQLConnection.bTrusted = True) Begin
83721>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
83722>>>>>                            End
83722>>>>>>
83722>>>>>                            Else Begin
83723>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
83724>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
83725>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
83726>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
83727>>>>>                            End
83727>>>>>>
83727>>>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
83728>>>>>                            Case Break
83729>>>>>                        Case Else
83729>>>>>                            Error ("Wrong driver ID passed:" * sDriverID)
83730>>>>>>
83730>>>>>                            Case Break
83731>>>>>                    Case End
83731>>>>>                End
83731>>>>>>
83731>>>>>            Loop
83732>>>>>>
83732>>>>>            Send Destroy of hoCLI
83733>>>>>        End
83733>>>>>>
83733>>>>>
83733>>>>>        Function_Return SQLConnection
83734>>>>>    End_Function
83735>>>>>
83735>>>>>    Function DriverIndex String sDriverID Returns Integer
83737>>>>>        String  sCurrentDriver
83737>>>>>        Integer iNumberOfDrivers iDriver iCount
83737>>>>>
83737>>>>>        Move 0 to iDriver
83738>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
83741>>>>>        For iCount from 1 to iNumberOfDrivers
83747>>>>>>
83747>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
83750>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
83752>>>>>                Function_Return iCount
83753>>>>>            End
83753>>>>>>
83753>>>>>        Loop
83754>>>>>>
83754>>>>>
83754>>>>>        // If driver not previously loaded; attempt to do so now.
83754>>>>>        If (iDriver = 0) Begin
83756>>>>>            Move 0 to LastErr
83757>>>>>            Load_Driver sDriverID
83758>>>>>            // If driver could not be loaded.
83758>>>>>            If (LastErr = 4255) Begin
83760>>>>>                Move 0 to iCount
83761>>>>>            End
83761>>>>>>
83761>>>>>            Function_Return iCount
83762>>>>>        End
83762>>>>>>
83762>>>>>        Function_Return 0
83763>>>>>    End_Function
83764>>>>>
83764>>>>>    // This will update connection settings of the cCLIHandler object with that passed struct values.
83764>>>>>    Procedure UpdateConnectionString tSQLConnection SQLConnection
83766>>>>>        String sDriverID sConnectionID sServer sDatabase sUserID sPassword
83766>>>>>        Boolean bTrusted bSilent
83766>>>>>
83766>>>>>        Move SQLConnection.sDriverID     to sDriverID
83767>>>>>        Move SQLConnection.sConnectionID to sConnectionID
83768>>>>>        Move SQLConnection.sServer       to sServer
83769>>>>>        Move SQLConnection.sDatabase     to sDatabase
83770>>>>>        Move SQLConnection.bTrusted      to bTrusted
83771>>>>>        Move SQLConnection.sUserID       to sUserID
83772>>>>>        Move SQLConnection.sPassword     to sPassword
83773>>>>>        Move SQLConnection.bSilentLogin  to bSilent
83774>>>>>
83774>>>>>        Send CreateSQLConnection sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent
83775>>>>>        // Note that this message will first delete the current ConnectionID if it exists; which is needed by the cCLIHandler logic.
83775>>>>>        Send AutoSetConnectionID
83776>>>>>    End_Procedure
83777>>>>>
83777>>>>>    // Called when the object is constructed.
83777>>>>>    // It will check the psDriverID for a ConnectionID and save it
83777>>>>>    // as psConnectionID property. It is later used whenever a login to
83777>>>>>    // the database is needed.
83777>>>>>    Procedure AutoSetConnectionID
83779>>>>>        String sConnectionID sDriverID sConnectionString
83779>>>>>        Integer iDriver iRetval
83779>>>>>        Handle hoCLI
83779>>>>>        Boolean bOK bSilent bMertechDriver
83779>>>>>
83779>>>>>        Get pbSilentLogin      to bSilent
83780>>>>>        Get psConnectionID     to sConnectionID
83781>>>>>        Get psConnectionString to sConnectionString
83782>>>>>        // Get the driver Connection ID string & set the psConnectionString property.
83782>>>>>        Get psDriverID to sDriverID
83783>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
83784>>>>>        If (bOK = False) Begin
83786>>>>>            Procedure_Return
83787>>>>>        End
83787>>>>>>
83787>>>>>
83787>>>>>        // Mertech drivers can't use connection ID's.
83787>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
83788>>>>>        If (bMertechDriver = True) Begin
83790>>>>>            // This ensures that the correct Server & Database attributes are set both for
83790>>>>>            // embedded SQL calls and "normal" database commands like e.g. "Open".
83790>>>>>            Get _MertechSQLManagerHandle to hoCLI
83791>>>>>            Procedure_Return
83792>>>>>        End
83792>>>>>>
83792>>>>>
83792>>>>>        Get DriverIndex sDriverID          to iDriver
83793>>>>>        // If driver not loaded; load it.
83793>>>>>        If (iDriver = 0) Begin
83795>>>>>            Load_Driver sDriverID
83796>>>>>            Get DriverIndex sDriverID      to iDriver
83797>>>>>        End
83797>>>>>>
83797>>>>>        // This shouldn't be possible; unless the driver.dll file is missing or something...
83797>>>>>        If (iDriver = 0) Begin
83799>>>>>            Error DFERR_PROGRAM ("The database driver could not be loaded! Connection to database failed." * sDriverID)
83800>>>>>>
83800>>>>>            Procedure_Return
83801>>>>>        End
83801>>>>>>
83801>>>>>
83801>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
83802>>>>>        Set psDriverID of hoCLI            to sDriverID
83803>>>>>        // Delete the connection first; in case it exists
83803>>>>>        Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
83804>>>>>        Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to iRetval
83805>>>>>
83805>>>>>        Send Destroy of hoCLI
83806>>>>>    End_Procedure
83807>>>>>
83807>>>>>    // Returns the handle of the Mertech SQL handler.
83807>>>>>    // It also ensures that the correct Server & Database attributes are set both for
83807>>>>>    // embedded SQL calls and "normal" database commands like e.g. "Open".
83807>>>>>    // Note: This does _not_ return a proper CLI handler handle as it is not in this class.
83807>>>>>    //       So the return value is of no use! But we don't need the handle for this class.
83807>>>>>    Function _MertechSQLManagerHandle Returns Handle
83809>>>>>        Handle hoSQLHandler
83809>>>>>        String sDriverID sServer sDatabase
83809>>>>>
83809>>>>>        Move 0 to hoSQLHandler
83810>>>>>        Get psDriverID to sDriverID
83811>>>>>        Get psServer   to sServer
83812>>>>>        Get psDatabase to sDatabase
83813>>>>>
83813>>>>>        Function_Return hoSQLHandler
83814>>>>>    End_Function
83815>>>>>
83815>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
83817>>>>>        Boolean bOK bMertechDriver
83817>>>>>
83817>>>>>        Get IsDAWSQLDriver sDriverID to bOK
83818>>>>>
83818>>>>>        If (bOK = False) Begin
83820>>>>>            Get IsMertechDriver sDriverID to bOK
83821>>>>>        End
83821>>>>>>
83821>>>>>
83821>>>>>        If (bOK = False) Begin
83823>>>>>            Get IsMertechDriver sDriverID to bMertechDriver
83824>>>>>            If (bMertechDriver = True) Begin
83826>>>>>                Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID, ODBC_DRV_ID, SQLFLEX, ORAFLEX, MDSPgSQL or MDSMYSQL"
83827>>>>>>
83827>>>>>            End
83827>>>>>>
83827>>>>>            Else Begin
83828>>>>>                Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID or ODBC_DRV_ID"
83829>>>>>>
83829>>>>>            End
83829>>>>>>
83829>>>>>            Function_Return False
83830>>>>>        End
83830>>>>>>
83830>>>>>
83830>>>>>        Function_Return True
83831>>>>>    End_Function
83832>>>>>
83832>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
83834>>>>>        Boolean bOK
83834>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
83835>>>>>        Function_Return bOK
83836>>>>>    End_Function
83837>>>>>
83837>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
83839>>>>>        Boolean bOK
83839>>>>>        Move False to bOK
83840>>>>>        Function_Return bOK
83841>>>>>    End_Function
83842>>>>>
83842>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
83844>>>>>        Handle hoIniFile
83844>>>>>        String sConnect
83844>>>>>
83844>>>>>        Get phoSQLConnectionIniFile to hoIniFile
83845>>>>>        Get ConstructConnectionString of hoIniFile sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnect
83846>>>>>
83846>>>>>        Function_Return sConnect
83847>>>>>    End_Function
83848>>>>>
83848>>>>>    // Sample sConnString: "SERVER=(local)\SQLEXPRESS;UID=dbuser;PWD=secret;DATABASE=OrderEntry;, 0"
83848>>>>>    // Pass a complete driver connection string
83848>>>>>    // Returns the following as a struct:
83848>>>>>    //   sServer, sDatabase, sUser, sPassword & True if Trusted_Connection is used.
83848>>>>>    // Finally also returns a boolean TRUE if trusted_connection=yes, else false is returned.
83848>>>>>    //
83848>>>>>    Function DeComposeConnectionString String sDriverID String sConnectionString Returns tSQLConnection
83850>>>>>        tSQLConnection SQLConnection
83850>>>>>        tSQLConnection SQLConnection
83850>>>>>        String sValue sConnectionID sServer sDatabase sUserID sPassword
83850>>>>>        Boolean bTrusted bSilent bOK
83850>>>>>        Integer iPos
83850>>>>>
83850>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
83851>>>>>        If (bOK = False) Begin
83853>>>>>            Function_Return SQLConnection
83854>>>>>        End
83854>>>>>>
83854>>>>>
83854>>>>>        Move False to bTrusted
83855>>>>>        Move False to bSilent
83856>>>>>
83856>>>>>        Case Begin
83856>>>>>            Case (sDriverID = MSSQLDRV_ID)
83858>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
83859>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
83860>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
83861>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
83862>>>>>                If (bTrusted = False) Begin
83864>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
83865>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
83866>>>>>                End
83866>>>>>>
83866>>>>>                Case Break
83867>>>>>
83867>>>>>            Case (sDriverID = ODBC_DRV_ID)
83870>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
83871>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
83872>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
83873>>>>>                If (bTrusted = False) Begin
83875>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
83876>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
83877>>>>>                End
83877>>>>>>
83877>>>>>                Case Break
83878>>>>>
83878>>>>>            Case (sDriverID = DB2_DRV_ID)
83881>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
83882>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
83883>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
83884>>>>>                Case Break
83885>>>>>
83885>>>>>            Case (sDriverID = SQLFLEX)
83888>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
83889>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
83890>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
83891>>>>>                If (bTrusted = False) Begin
83893>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
83894>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
83895>>>>>                End
83895>>>>>>
83895>>>>>                Case Break
83896>>>>>
83896>>>>>            Case (sDriverID = ORAFLEX)
83899>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
83900>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
83901>>>>>                If (sDatabase <> "" and (not(sServer contains "/"))) Begin
83903>>>>>                    Move (sServer + "/" + sDatabase)                                to sServer
83904>>>>>                End
83904>>>>>>
83904>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
83905>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
83906>>>>>                Case Break
83907>>>>>
83907>>>>>            Case (sDriverID = MDSPgSQL)
83910>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
83911>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
83912>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
83913>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
83914>>>>>                Case Break
83915>>>>>
83915>>>>>            Case (sDriverID = MDSMySQL)
83918>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
83919>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
83920>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
83921>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
83922>>>>>                Case Break
83923>>>>>
83923>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
83926>>>>>                Break
83927>>>>>        Case End
83927>>>>>
83927>>>>>        Get ParseKeyWord sConnectionString (Uppercase(CS_SQLConnectionIDText))  to sConnectionID
83928>>>>>
83928>>>>>        // bSilent?
83928>>>>>        Move (Pos(",0", sConnectionString))                                     to iPos
83929>>>>>        If (iPos = 0) Begin
83931>>>>>            Move (Pos(",1", sConnectionString))                                 to iPos
83932>>>>>        End
83932>>>>>>
83932>>>>>        If (iPos = 0) Begin
83934>>>>>            Move "0"                                                            to sValue
83935>>>>>        End
83935>>>>>>
83935>>>>>        Else Begin
83936>>>>>            Move (Mid(sConnectionString, 1, (iPos +1)))                         to sValue
83937>>>>>        End
83937>>>>>>
83937>>>>>        Move (If(sValue = 1, True, False))                                      to bSilent
83938>>>>>
83938>>>>>        Move (Trim(sDriverID))                                                  to SQLConnection.sDriverID
83939>>>>>        Move (Trim(sConnectionID))                                              to SQLConnection.sConnectionID
83940>>>>>        Move (Trim(sConnectionString))                                          to SQLConnection.sConnectionString
83941>>>>>        Move (Trim(sServer))                                                    to SQLConnection.sServer
83942>>>>>        Move (Trim(sDatabase))                                                  to SQLConnection.sDatabase
83943>>>>>        Move bTrusted                                                           to SQLConnection.bTrusted
83944>>>>>        Move (Trim(sUserID))                                                    to SQLConnection.sUserID
83945>>>>>        Move (Trim(sPassword))                                                  to SQLConnection.sPassword
83946>>>>>        Move bSilent                                                            to SQLConnection.bSilentLogin
83947>>>>>
83947>>>>>        Function_Return SQLConnection
83948>>>>>    End_Function
83949>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
83949>>>>>>
83949>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
83951>>>>>>    Integer iStart iEnd
83951>>>>>>    String sRetval
83951>>>>>>
83951>>>>>>    Move (Trim(sConnect)) to sConnect
83952>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
83953>>>>>>    If (iStart = 0) Begin
83955>>>>>>        Function_Return ""
83956>>>>>>    End
83956>>>>>>>
83956>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
83957>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
83958>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
83960>>>>>>        Move (Pos(",", sRetval))          to iEnd
83961>>>>>>    End
83961>>>>>>>
83961>>>>>>    Else Begin
83962>>>>>>        Move (Pos(";", sRetval))          to iEnd
83963>>>>>>    End
83963>>>>>>>
83963>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
83965>>>>>>        Move (Pos(",", sRetval))          to iEnd
83966>>>>>>        Decrement iEnd
83967>>>>>>    End
83967>>>>>>>
83967>>>>>>    If (iEnd <> 0) Begin
83969>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
83970>>>>>>    End
83970>>>>>>>
83970>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
83971>>>>>>
83971>>>>>>    Function_Return (Trim(sRetval))
83972>>>>>>End_Function
83973>>>>>>
83973>>>>>>
83973>>>>>
83973>>>>>    // To update the SQLSettings.ini file with updated connection data (SQLConnection struct data).
83973>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
83975>>>>>        Handle ho
83975>>>>>        Integer iIndex
83975>>>>>        Boolean bRetval bOK
83975>>>>>        tSQLConnection SQLConnection
83975>>>>>        tSQLConnection SQLConnection
83975>>>>>
83975>>>>>        Get pSQLConnection to SQLConnection
83976>>>>>        Get phoSQLConnectionIniFile to ho
83977>>>>>        Get SQLIniFileConnectionIDIndex of ho sConnectionID to iIndex
83978>>>>>        If (iIndex = -1) Begin
83980>>>>>            Function_Return False
83981>>>>>        End
83981>>>>>>
83981>>>>>
83981>>>>>        Get SQLIniFileUpdateConnection of ho SQLConnection to bRetval
83982>>>>>        Send UpdateConnectionString of ghoSQLConnectionHandler SQLConnection
83983>>>>>        If (ghoConnection > 0) Begin
83985>>>>>            Get ConnectionIdIndex of ghoConnection SQLConnection.sConnectionID to iIndex
83986>>>>>            If (iIndex <> -1) Begin
83988>>>>>                Get RedirectConnectionId of ghoConnection SQLConnection.sConnectionID (SQLConnection.sServer + ";" + CS_SQLIniDatabaseKeyword + "=" + SQLConnection.sDatabase) SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted True to bOK
83989>>>>>            End
83989>>>>>>
83989>>>>>        End
83989>>>>>>
83989>>>>>
83989>>>>>        Function_Return bRetval
83990>>>>>    End_Function
83991>>>>>
83991>>>>>End_Class
83992>>>Use vWin32fh.pkg
83992>>>
83992>>>//
83992>>>Class cDbUpdateFunctionLibrary is a cObject
83993>>>    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
Including file: ParseKeyWord.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
83994>>>>
83994>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
83996>>>>    Integer iStart iEnd
83996>>>>    String sRetval
83996>>>>
83996>>>>    Move (Trim(sConnect)) to sConnect
83997>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
83998>>>>    If (iStart = 0) Begin
84000>>>>        Function_Return ""
84001>>>>    End
84001>>>>>
84001>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
84002>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
84003>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
84005>>>>        Move (Pos(",", sRetval))          to iEnd
84006>>>>    End
84006>>>>>
84006>>>>    Else Begin
84007>>>>        Move (Pos(";", sRetval))          to iEnd
84008>>>>    End
84008>>>>>
84008>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
84010>>>>        Move (Pos(",", sRetval))          to iEnd
84011>>>>        Decrement iEnd
84012>>>>    End
84012>>>>>
84012>>>>    If (iEnd <> 0) Begin
84014>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
84015>>>>    End
84015>>>>>
84015>>>>    Move (Replace("=", sRetval, ""))      to sRetval
84016>>>>
84016>>>>    Function_Return (Trim(sRetval))
84017>>>>End_Function
84018>>>>
84018>>>>
84018>>>
84018>>>    Procedure Construct_Object
84020>>>        Handle ho
84020>>>        Forward Send Construct_Object
84022>>>
84022>>>        Move Self to ghoDbUpdateFunctionLibrary
84023>>>
84023>>>        Send CreateDbUpdateLibraryProperties
84024>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
84024>>>        // we will create one as it is used for all ConnectionID, ConnectionString
84024>>>        // etc settings.
84024>>>        If (ghoSQLConnectionHandler = 0) Begin
84026>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
84027>>>            Set phoSQLConnectionHandler to ho
84028>>>        End
84028>>>>
84028>>>
84028>>>    End_Procedure
84029>>>
84029>>>    Procedure End_Construct_Object
84031>>>        Forward Send End_Construct_Object
84033>>>    End_Procedure
84034>>>
84034>>>    // *** SQL Messages for making changes to the SQL back-end ***
84034>>>    //
84034>>>    // * Dummy function for the Studio's Code Explorer *
84034>>>    Function SQL_DATABASE_FUNCTIONS Returns Boolean
84036>>>        Function_Return False
84037>>>    End_Function
84038>>>
84038>>>    // Function for creating a new *Database*.
84038>>>    // Note: This is for creating SQL DATABASES - not tables!
84038>>>    // Returns True if successful.
84038>>>    // ToDo: Only works for MS-SQL...
84038>>>    Function SqlDatabaseCreate String sDriverID String sDatabase Boolean bUpdateConnectionString Boolean bPermanantly Returns Boolean
84040>>>        String sSQL sSQL1 sConnectionID sConnectionString 
84040>>>        String sCreateDatabaseKeyWord sSelectFromWhereName sCollation sCollateKeyWord
84040>>>        Handle hConnection hStmt hoSQLManager
84040>>>        Integer iFetchResult iDbType
84040>>>        Boolean bOK bMertechDriver
84040>>>
84040>>>        Get piDbType to iDbType
84041>>>        If (iDbType <> EN_DbTypeMSSQL) Begin
84043>>>            Error DFERR_PROGRAM "Sorry, the SqlDatabaseCreate function is currently only supported for MS-SQL"
84044>>>>
84044>>>            Function_Return False
84045>>>        End
84045>>>>
84045>>>
84045>>>        Get IsMertechDriver sDriverID to bMertechDriver
84046>>>        If (bMertechDriver = False) Begin
84048>>>            Get phoSQLManager to hoSQLManager
84049>>>        End
84049>>>>
84049>>>        Else Begin
84050>>>            Get _MertechSQLManagerHandle to hoSQLManager
84051>>>        End
84051>>>>
84051>>>        
84051>>>        Get psConnectionID     to sConnectionID
84052>>>        Get psConnectionString to sConnectionString
84053>>>        Move 0 to LastErr
84054>>>
84054>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84055>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
84056>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84057>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
84059>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
84060>>>>
84060>>>            Function_Return False
84061>>>        End
84061>>>>
84061>>>
84061>>>        Get SqlOpen of hConnection to hStmt
84062>>>
84062>>>        If (hStmt = 0) Begin
84064>>>            Send SqlDisconnect of hoSQLManager
84065>>>            Error DFERR_PROGRAM CS_SQLConnectError
84066>>>>
84066>>>            Function_Return False
84067>>>        End
84067>>>>
84067>>>
84067>>>        Get _SqlFindKeyWord CI_SQLCreateDatabase to sCreateDatabaseKeyWord
84068>>>        Get _SqlSelectFromWhereName to sSelectFromWhereName
84069>>>        Move (sSelectFromWhereName + "='" + sDatabase + "'") to sSQL 
84070>>>        
84070>>>        // Check if database exists
84070>>>        Send SqlExecDirect of hStmt sSQL
84071>>>        Get SqlFetch of hStmt to iFetchResult
84072>>>        Send SqlClose of hStmt
84073>>>        Send SqlDisconnect of hConnection
84074>>>
84074>>>        // If database already exists we're out of here!
84074>>>        // Note that we return True as this is not an error.
84074>>>        If (iFetchResult > 0) Begin
84076>>>            Function_Return True
84077>>>        End
84077>>>>
84077>>>
84077>>>        // Database doesn't exist, create it.
84077>>>        If (iFetchResult = 0) Begin
84079>>>            Move (sCreateDatabaseKeyWord + " [" + sDatabase + "]") to sSQL1
84080>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84081>>>
84081>>>            Get psCollation to sCollation
84082>>>            If (sCollation <> "") Begin
84084>>>                Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
84085>>>                Move (sSQL1 * String(sCollateKeyWord) * String(sCollation)) to sSQL1
84086>>>            End
84086>>>>
84086>>>
84086>>>            Send SqlUtilExecuteQuery sSQL1 sDriverID
84087>>>
84087>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84088>>>            If (LastErr = CLIERR_GENERAL_ERROR) Begin
84090>>>               Function_Return False
84091>>>            End
84091>>>>
84091>>>
84091>>>            // We need to wait a short time for Sql to finish, especially Windows to write the new file to disk.
84091>>>            Sleep 1
84092>>>            Send SqlUtilExecuteQuery sSQL sDriverID
84093>>>        End
84093>>>>
84093>>>
84093>>>        // If used in e.g. the cDbUpdteHandler we want to change the login database name to
84093>>>        // the one we just created.
84093>>>        If (bUpdateConnectionString = True) Begin
84095>>>            Set psDatabase to sDatabase
84096>>>            //...and perhaps also the SQLConnections.ini file setting.
84096>>>            If (bPermanantly = True) Begin
84098>>>                If (ghoSQLConnectionHandler <> 0) Begin
84100>>>                    Get SQLIniFileSetDefaultConnection of ghoSQLConnectionHandler sConnectionID to bOK
84101>>>                End
84101>>>>
84101>>>            End
84101>>>>
84101>>>        End
84101>>>>
84101>>>
84101>>>        Function_Return (Err = False)
84102>>>    End_Function
84103>>>
84103>>>    // Backs up an SQL database to a folder of choice. If no path is passed the SQL default backup folder
84103>>>    // will be used.
84103>>>    Function SqlDatabaseBackupToDisk String sDatabase String sBackupName String sPath Boolean bShowProg Returns Boolean
84105>>>        Boolean bOK bExists bShowProgress
84105>>>        String sStatement sDriverID
84105>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84105>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84105>>>        Integer iDbType
84105>>>
84105>>>        If (sDatabase = "") Begin
84107>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
84108>>>>
84108>>>            Function_Return False
84109>>>        End
84109>>>>
84109>>>        If (sBackupName = "") Begin
84111>>>            Error DFERR_PROGRAM "The database backup name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
84112>>>>
84112>>>            Function_Return False
84113>>>        End
84113>>>>
84113>>>
84113>>>        // Create backup-folder if it doesn't exist
84113>>>        Get vFolderExists sPath to bExists
84114>>>        If (bExists = False) Begin
84116>>>            Get vCreateDirectory sPath to bOK
84117>>>            If (bOK = False) Begin
84119>>>                Error DFERR_PROGRAM ("Could not create database backup folder:" * sPath)
84120>>>>
84120>>>                Function_Return False
84121>>>            End
84121>>>>
84121>>>        End
84121>>>>
84121>>>        // Make sure the path ends with a back-slash
84121>>>        If (sPath <> "") Begin
84123>>>            Get vFolderFormat sPath to sPath
84124>>>        End
84124>>>>
84124>>>
84124>>>        Get psDriverID to sDriverID
84125>>>        Get piDbType   to iDbType
84126>>>        If (num_arguments > 3) Begin
84128>>>            Move bShowProg to bShowProgress
84129>>>        End
84129>>>>
84129>>>
84129>>>        Case Begin
84129>>>            Case (iDbType = EN_DbTypeMSSQL)
84131>>>                SQLIncludeScriptFile ..\Scripts\BackupMSSQLDatabase.sql as BackupMSSQLDatabase.sql
84131>>>                SQLIncludeScriptFile ..\Scripts\GetPercentageBackupCompletionMSSQL.sql as GetPercentageBackupCompletionMSSQL.sql
84131>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "BackupMSSQLDatabase.sql" sDriverID False to SQLScriptArray
84132>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "GetPercentageBackupCompletionMSSQL.sql" sDriverID False to SQLScriptArrayPercentReady
84133>>>
84133>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
84134>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase))   to sStatement
84135>>>                Move (Replaces("BACKUP_PATH_XXX",   sStatement, sPath))       to sStatement
84136>>>                Move (Replaces("BACKUP_NAME_XXX",   sStatement, sBackupName)) to sStatement
84137>>>                Move sStatement to SQLScriptArray.sSQLScriptArray[0]
84138>>>                Get SqlUtilExecuteEmbeddedScript of ghoDbUpdateFunctionLibrary SQLScriptArray sDriverID False "" bShowProgress to bOK
84139>>>                Case Break
84140>>>            Case Else
84140>>>                Send Info_Box ("The SqlUtilBackupDatabaseToDisk function is currently not implemented for the driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and add a little ESQL code snippet to make it work for that driver! Thanks for helping out.")
84141>>>        Case End
84141>>>
84141>>>        Function_Return bOK
84142>>>    End_Function
84143>>>
84143>>>    Function SqlDatabaseCollationQuery String sDatabase Returns String
84145>>>        Boolean bOK bExists 
84145>>>        String sStatement sDriverID sRetval sPrevious
84145>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84145>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84145>>>        Integer iDbType iRows iFetchResult iColumn
84145>>>        Handle hoSQLHandler hoSQLConnect hstmt 
84145>>>        tSQLConnection SQLConnection
84145>>>        tSQLConnection SQLConnection
84145>>>
84145>>>        If (sDatabase = "") Begin
84147>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilDatabaseCollation' function"
84148>>>>
84148>>>            Function_Return False
84149>>>        End
84149>>>>
84149>>>        
84149>>>        Move "" to sRetval
84150>>>        Get psDriverID to sDriverID
84151>>>        Get piDbType   to iDbType
84152>>>
84152>>>        Case Begin
84152>>>            Case (iDbType = EN_DbTypeMSSQL)
84154>>>                SQLIncludeScriptFile ..\Scripts\QueryMSSQLCollation.sql as QueryMSSQLCollation.sql
84154>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "QueryMSSQLCollation.sql" sDriverID False to SQLScriptArray
84155>>>
84155>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
84156>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase)) to sStatement
84157>>>                Get phoSQLManager to hoSQLHandler
84158>>>        
84158>>>                If (hoSQLHandler <> 0) Begin
84160>>>                    Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
84161>>>                    Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
84162>>>        
84162>>>                    If (hoSQLConnect <> 0) Begin
84164>>>                        Get SQLOpen of hoSQLConnect to hstmt
84165>>>                        If (hstmt <> 0) Begin
84167>>>                            Send SqlExecDirect of hstmt sStatement
84168>>>                            Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
84169>>>                            Get SQLFetch of hstmt to iFetchResult
84170>>>                            If (iFetchResult <> 0) Begin
84172>>>                                Get SQLColumnValue of hstmt 2 to sRetval // Column 1 = Database Name, 2 = Collation Name.
84173>>>                            End
84173>>>>
84173>>>                            Send SQLClose of hstmt
84174>>>                        End
84174>>>>
84174>>>                        Send SQLDisconnect of hoSQLConnect
84175>>>                    End
84175>>>>
84175>>>                End
84175>>>>
84175>>>                Case Break
84176>>>            Case Else
84176>>>                Send Info_Box ("The SqlDatabaseCollationQuery function is currently not implemented for the driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and add a little ESQL code snippet to make it work for that driver! Thanks for helping out.")
84177>>>        Case End
84177>>>
84177>>>        Function_Return sRetval
84178>>>    End_Function
84179>>>
84179>>>    Function SqlDatabaseCollationChange String sDatabase String sSQLCollation Returns Boolean
84181>>>        Boolean bOK bExists bMertechDriver
84181>>>        String sDriverID sSQL sSQL1 sConnectionID sConnectionString sSet sWith
84181>>>        String sAlterDatabaseKeyWord sCollateKeyWord sSQLCollationCheck sSingle_User sMulti_User sRollback sImmediate
84181>>>        Handle hConnection hStmt hoSQLManager
84181>>>        Integer iFetchResult iDbType
84181>>>
84181>>>        If (sDatabase = "") Begin
84183>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
84184>>>>
84184>>>            Function_Return False
84185>>>        End
84185>>>>
84185>>>        
84185>>>        If (sSQLCollation = "") Begin
84187>>>            Error DFERR_PROGRAM "The SQL Collation name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
84188>>>>
84188>>>            Function_Return False
84189>>>        End
84189>>>>
84189>>>        
84189>>>        Get psDriverID to sDriverID
84190>>>        Get piDbType   to iDbType
84191>>>
84191>>>        Get IsMertechDriver sDriverID to bMertechDriver
84192>>>        If (bMertechDriver = False) Begin
84194>>>            Get phoSQLManager to hoSQLManager
84195>>>        End
84195>>>>
84195>>>        Else Begin
84196>>>            Get _MertechSQLManagerHandle to hoSQLManager
84197>>>        End
84197>>>>
84197>>>        
84197>>>        Get psConnectionID     to sConnectionID
84198>>>        Get psConnectionString to sConnectionString
84199>>>        Move 0 to LastErr
84200>>>
84200>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84201>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
84202>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84203>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
84205>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
84206>>>>
84206>>>            Function_Return False
84207>>>        End
84207>>>>
84207>>>
84207>>>        Get SqlOpen of hConnection to hStmt
84208>>>
84208>>>        If (hStmt = 0) Begin
84210>>>            Send SqlDisconnect of hoSQLManager
84211>>>            Error DFERR_PROGRAM CS_SQLConnectError
84212>>>>
84212>>>            Function_Return False
84213>>>        End
84213>>>>
84213>>>        
84213>>>        // Check if collation already exists   
84213>>>        Get SqlDatabaseCollationQuery sDatabase to sSQLCollationCheck
84214>>>        // If the current collate is the same as the new; do nothing.
84214>>>        If (sSQLCollation = sSQLCollationCheck) Begin
84216>>>            Function_Return True
84217>>>        End
84217>>>>
84217>>>            
84217>>>        Get _SqlFindKeyWord CI_SQLSet               to sSet
84218>>>        Get _SqlFindKeyWord CI_SQLWith              to sWith
84219>>>        Get _SqlFindKeyWord CI_SQLSingle_User       to sSingle_User
84220>>>        Get _SqlFindKeyWord CI_SQLMulti_User        to sMulti_User
84221>>>        Get _SqlFindKeyWord CI_SQLRollback          to sRollback
84222>>>        Get _SqlFindKeyWord CI_SQLIMMEDIATE         to sImmediate
84223>>>        Get _SqlFindKeyWord CI_SQLAlterDatabase     to sAlterDatabaseKeyWord
84224>>>        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
84225>>>        
84225>>>        // MS-SQL Syntax:
84225>>>        // ALTER DATABASE [database] SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
84225>>>        // ALTER DATABASE [database] COLLATE SQL_1xCompat_CP850_CI_AS;
84225>>>        // ALTER DATABASE [database] SET MULTI_USER;
84225>>>        Move (              sAlterDatabaseKeyWord  * String(sDatabase) * String(sSet) * String(sSingle_User) * String(sWith) * String(sRollback) * String(sImmediate)) to sSQL
84226>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
84227>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sSet) * String(sMulti_User)) to sSQL
84228>>>//        Move (sAlterDatabaseKeyWord * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL 
84228>>>        
84228>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84229>>>        Send SqlUtilExecuteQuery sSQL sDriverID False
84230>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84231>>>        If (LastErr = CLIERR_GENERAL_ERROR) Begin
84233>>>           Function_Return False
84234>>>        End
84234>>>>
84234>>>
84234>>>        Function_Return (Err = False)
84235>>>    End_Function
84236>>>
84236>>>    // * Dummy function for the Studio's Code Explorer *
84236>>>    Function SQL_TABLE_FUNCTIONS Returns Boolean
84238>>>        Function_Return False
84239>>>    End_Function
84240>>>    // Converts from SQL to Embedded (DataFlex .dat files).
84240>>>    // To convert from SQL -> SQL (e.g. from Oracle - > MS SQL)
84240>>>    //   first use SQLTableConvertToEmbedded in one cDbUpdateVersion object,
84240>>>    //   and then use the ApiTableConvertToSQL method in a second cDbUpdateVersion object.
84240>>>    // Note: To convert an embedded table to SQL use ApiTableConvertToSQL.
84240>>>    Function SqlTableConvertToEmbedded Handle hTable Boolean bCpyDat Returns Boolean
84242>>>        Handle hToTable
84242>>>        Boolean bOK bExists bOpened bMertechDriver bCopyData
84242>>>        String sDriverID sPhysicalName sRootName sDisplayName
84242>>>        tSQLConnection SQLConnection
84242>>>        tSQLConnection SQLConnection
84242>>>        Integer iPos iMaxRecords
84242>>>
84242>>>        Get psDriverID to sDriverID
84243>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
84244>>>        If (bExists = False) Begin
84246>>>            Function_Return False
84247>>>        End
84247>>>>
84247>>>
84247>>>        If (num_arguments > 1) Begin
84249>>>            Move bCpyDat to bCopyData
84250>>>        End
84250>>>>
84250>>>        Else Begin
84251>>>            Move False to bCopyData
84252>>>        End
84252>>>>
84252>>>
84252>>>        Open hTable
84254>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
84257>>>        If (bOpened = False) Begin
84259>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
84260>>>>
84260>>>            Function_Return False
84261>>>        End
84261>>>>
84261>>>        Move 0 to hToTable
84262>>>
84262>>>        Move 16711679 to iMaxRecords
84263>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
84266>>>        Move (Pos(".", sDisplayName)) to iPos
84267>>>        If (iPos > 0) Begin
84269>>>            Move (Mid(sDisplayName, 200, (iPos +1))) to sDisplayName
84270>>>        End
84270>>>>
84270>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
84273>>>        Get _TableNameOnly sRootName                 to sRootName
84274>>>        Move (sRootName + ".dat")                    to sPhysicalName
84275>>>
84275>>>        If (ghoProgressBar <> 0) Begin
84277>>>            Send DoAdvance of ghoProgressBar
84278>>>            Set TableName_Text of ghoStatusPanel to ("Converting to Embedded - Table:" * String(sRootName) * "Number:" * String(hTable))
84279>>>        End
84279>>>>
84279>>>
84279>>>        Move False to Err
84280>>>
84280>>>        Structure_Start hToTable DATAFLEX_ID
84281>>>            Structure_Copy hTable to hToTable
84282>>>
84282>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
84285>>>            Set_Attribute DF_FILE_REUSE_DELETED of hToTable to DF_FILE_DELETED_REUSE
84288>>>            Set_Attribute DF_FILE_MULTIUSER     of hToTable to DF_FILE_USER_MULTI
84291>>>            Set_Attribute DF_FILE_TRANSACTION   of hToTable to DF_FILE_TRANSACTION_CLIENT_ATOMIC
84294>>>            Set_Attribute DF_FILE_MAX_RECORDS   of hToTable to iMaxRecords
84297>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
84298>>>
84298>>>        Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
84300>>>
84300>>>        Set Action_Text of ghoStatusPanel to ""
84301>>>        Move (not(Err)) to bOK
84302>>>        If (bOK = True and bCopyData = True) Begin
84304>>>            Get ApiTableCopyData hTable sPhysicalName sRootName DATAFLEX_ID to bOK
84305>>>        End
84305>>>>
84305>>>
84305>>>        Get IsMertechDriver sDriverID to bMertechDriver
84306>>>        If (bMertechDriver = True) Begin
84308>>>            Open hTable
84310>>>        End
84310>>>>
84310>>>
84310>>>        // This must be after copying data...
84310>>>        If (Err = False) Begin
84312>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
84315>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
84318>>>        End
84318>>>>
84318>>>        Move (not(Err)) to bOK
84319>>>
84319>>>        Function_Return (bOK = True)
84320>>>    End_Function
84321>>>
84321>>>    // Creates an SQL Table at the SQL end by its filelist number;
84321>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
84321>>>    Function SqlTableCreate Integer hTable Returns Boolean
84323>>>        String sTableName sSQLString sPath sCreateTable sDriverID
84323>>>        Integer iDbType
84323>>>        Boolean bExists
84323>>>
84323>>>        Get psDriverID to sDriverID
84324>>>        Get UtilTableHandleToString hTable to sTableName
84325>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
84326>>>        If (bExists = True) Begin
84328>>>            Function_Return False
84329>>>        End
84329>>>>
84329>>>
84329>>>        Get psDataPathFirstPart to sPath
84330>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
84331>>>
84331>>>        Get piDbType to iDbType
84332>>>        Get _SqlProperTableName sTableName to sTableName
84333>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
84334>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
84335>>>
84335>>>        Move False to Err
84336>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84337>>>
84337>>>        Function_Return (Err = False)
84338>>>    End_Function
84339>>>
84339>>>    // Same as SqlTableCreate but creates an SQL Table at the SQL end by a table name;
84339>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
84339>>>    Function SqlTableCreateByTableName String sTableName  Returns Boolean
84341>>>        String sSQLString sPath sCreateTable sDriverID
84341>>>        Integer iDbType
84341>>>        Boolean bExists
84341>>>
84341>>>        Get psDriverID to sDriverID
84342>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
84343>>>        If (bExists = True) Begin
84345>>>            Function_Return False
84346>>>        End
84346>>>>
84346>>>
84346>>>        Get psDataPathFirstPart to sPath
84347>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
84348>>>        If (bExists = True) Begin
84350>>>            // ToDo: What should we do if an .int file already exists?
84350>>>        End
84350>>>>
84350>>>
84350>>>        Get piDbType to iDbType
84351>>>        Get _SqlProperTableName sTableName to sTableName
84352>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
84353>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
84354>>>
84354>>>        Move False to Err
84355>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84356>>>
84356>>>        Function_Return (Err = False)
84357>>>    End_Function
84358>>>
84358>>>    // First deletes the data cache file and then drops the passed SQL table.
84358>>>    // Note: The table needs to exist in filelist.cfg, and it must be possible to open it,
84358>>>    //       else try using the SqlTableRemoveByTableName message.
84358>>>    Function SqlTableRemove Integer hTable Returns Boolean
84360>>>        String sSQLString sPath sDropTable sTableName sDriverID
84360>>>        Integer iRetval iDbType
84360>>>        Boolean bExists bMertechDriver bOK
84360>>>
84360>>>        Get psDriverID to sDriverID
84361>>>        Get IsMertechDriver sDriverID to bMertechDriver
84362>>>        Get UtilTableHandleToString hTable to sTableName
84363>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
84364>>>        If (bExists = False) Begin
84366>>>            Function_Return False
84367>>>        End
84367>>>>
84367>>>
84367>>>        Get psDataPathFirstPart to sPath
84368>>>        Get UtilDeleteCacheFile sTableName to iRetval
84369>>>
84369>>>        Get piDbType to iDbType
84370>>>        Get _SqlProperTableName sTableName to sTableName
84371>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
84372>>>        Move (sDropTable * String(sTableName)) to sSQLString
84373>>>
84373>>>        Move False to Err
84374>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84375>>>
84375>>>        // We also need to remove the cache-file since the table has been changed
84375>>>        Get UtilDeleteCacheFile sTableName to bOK
84376>>>
84376>>>        Function_Return (Err = False)
84377>>>    End_Function
84378>>>
84378>>>    // First deletes the data cache file and then drops the passed data table.
84378>>>    Function SqlTableRemoveByTableName String sTableName Returns Boolean
84380>>>        String sSQLString sPath sDropTable sVal sSchema sDriverID
84380>>>        Integer iRetval iDbType
84380>>>        Boolean bMertechDriver bOK
84380>>>
84380>>>        Get psDriverID to sDriverID
84381>>>        Get IsMertechDriver sDriverID to bMertechDriver
84382>>>        Get psDataPathFirstPart to sPath
84383>>>        Get UtilDeleteCacheFile sTableName to iRetval
84384>>>
84384>>>        Get piDbType to iDbType
84385>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
84386>>>        Get psSchema to sSchema
84387>>>        If (sSchema = "") Begin
84389>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
84390>>>        End
84390>>>>
84390>>>        Move (Uppercase(sTableName)) to sVal
84391>>>        If (not(sVal contains (sSchema + "."))) Begin
84393>>>            Move (Lowercase(sSchema) + "." + sTableName) to sTableName
84394>>>        End
84394>>>>
84394>>>        Move (sDropTable * String(sTableName)) to sSQLString
84395>>>
84395>>>        Move False to Err
84396>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84397>>>
84397>>>        // We also need to remove the cache-file since the table has been changed
84397>>>        Get UtilDeleteCacheFile sTableName to bOK
84398>>>
84398>>>        Function_Return (Err = False)
84399>>>    End_Function
84400>>>
84400>>>    // *** Sql View Messages ***
84400>>>
84400>>>    // First deletes the data cache file and then drops the passed Sql data view.
84400>>>    Function SqlViewRemove String sDataView Returns Boolean
84402>>>        String sDriverID sSQLString sDropViewKeyWord
84402>>>        Integer iRetval
84402>>>        Boolean bMertechDriver bOK
84402>>>
84402>>>        Get psDriverID to sDriverID
84403>>>        Get IsMertechDriver sDriverID to bMertechDriver
84404>>>        Get UtilDeleteCacheFile sDataView to iRetval
84405>>>
84405>>>        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
84406>>>        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
84407>>>        Set psSQLStatementString to sSQLString
84408>>>
84408>>>        // As we don't check if the view exist or not, it might happen
84408>>>        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
84408>>>        Move False to Err
84409>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84410>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84411>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84412>>>        Move 0 to LastErr
84413>>>
84413>>>        // We also need to remove the cache-file since the table has been changed
84413>>>        Get UtilDeleteCacheFile sDataView to bOK
84414>>>
84414>>>        Function_Return (Err = False)
84415>>>    End_Function
84416>>>
84416>>>    Function SqlTableRename Handle hTable String sCurrentTableName String sNewtTableName Returns Boolean
84418>>>        Boolean bOK
84418>>>        Integer iDbType
84418>>>        String sDriverID sAlterTable sRenameTable sSQLTo sSQLString
84418>>>
84418>>>        Get psDriverID to sDriverID
84419>>>        Get piDbType   to iDbType
84420>>>
84420>>>        Case Begin
84420>>>            Case (iDbType = EN_DbTypeDB2)
84422>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84423>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84424>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * sNewtTableName) to sSQLString
84425>>>            Break
84426>>>
84426>>>            Case (iDbType = EN_DbTypeMSSQL)
84429>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84430>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84431>>>                Move (sRenameTable * "'" - sCurrentTableName - "', '" - sNewtTableName - "'") to sSQLString
84432>>>            Break
84433>>>
84433>>>            Case (iDbType = EN_DbTypeOracle)
84436>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84437>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84438>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * sNewtTableName) to sSQLString
84439>>>            Break
84440>>>
84440>>>            Case (iDbType = EN_DbTypePostgre)
84443>>>                Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
84444>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84445>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84446>>>                Move (sAlterTable * sCurrentTableName * sRenameTable * sSQLTo * sNewtTableName) to sSQLString
84447>>>            Break
84448>>>
84448>>>            Case (iDbType = EN_DbTypeMySQL)
84451>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84452>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84453>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * sNewtTableName) to sSQLString
84454>>>            Break
84455>>>        Case End
84455>>>
84455>>>        Move False to Err
84456>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84457>>>        Move (Err = False) to bOK
84458>>>
84458>>>        Function_Return bOK
84459>>>    End_Function
84460>>>
84460>>>    // * Dummy function for the Studio's Code Explorer *
84460>>>    Function SQL_COLUMN_FUNCTIONS Returns Boolean
84462>>>        Function_Return False
84463>>>    End_Function
84464>>>
84464>>>    // Sample: Get SqlColumnAdd MyTable.File_Number "NewColumnName" True "InitValue" DF_ASCII_DUF 35
84464>>>    Function SqlColumnAdd Integer hTable String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
84466>>>        Integer iLength iDecimals
84466>>>        String sColumnValue
84466>>>        String sTableName sDriverID
84466>>>        Boolean bOK bInitializeValue
84466>>>
84466>>>        Get psDriverID to sDriverID
84467>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84468>>>        If (bOK = False) Begin
84470>>>            Function_Return False
84471>>>        End
84471>>>>
84471>>>
84471>>>        Get UtilTableHandleToString hTable to sTableName
84472>>>        If (sTableName = "") Begin
84474>>>            Function_Return False
84475>>>        End
84475>>>>
84475>>>
84475>>>        If (num_arguments > 3) Begin
84477>>>            Move iLen     to iLength
84478>>>            Move iDec     to iDecimals
84479>>>            Move bInitVal to bInitializeValue
84480>>>            Move sColVal  to sColumnValue
84481>>>        End
84481>>>>
84481>>>
84481>>>        Get SqlColumnAddByTableName sTableName sColumnName iDataType iLen iDecimals bInitializeValue sColumnValue to bOK
84482>>>
84482>>>        Function_Return (bOK = True)
84483>>>    End_Function
84484>>>
84484>>>    // Sample: Get SqlColumnAddByTableName "MyTable" "NewColumnName" DF_ASCII_DUF 35 0 True "InitValue"
84484>>>    Function SqlColumnAddByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
84486>>>        Integer iDbType iLength iDecimals iDriver
84486>>>        String sStmt sAlterTable sAddColumn sVal sDataType sLengthAndDecimals sColumnValue
84486>>>        String sDriverID sNotNull
84486>>>        Boolean bOK bInitializeValue bRetval bFixed bDriverIgnoreErrorState
84486>>>        Handle hTable
84486>>>
84486>>>        Get psDriverID to sDriverID
84487>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84488>>>        If (bOK = False) Begin
84490>>>            Function_Return False
84491>>>        End
84491>>>>
84491>>>
84491>>>        Get UtilTableNameToHandle sTableName to hTable
84492>>>        If (hTable = 0) Begin
84494>>>            Get NextFreeFilelistSlot to hTable
84495>>>        End
84495>>>>
84495>>>
84495>>>        Get piDbType to iDbType
84496>>>        // If a field/column already exists; we just ignore the request to not add unneccesary errors to the log.
84496>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
84497>>>        If (Uppercase(sVal) = Uppercase(sColumnName)) Begin
84499>>>            Function_Return False
84500>>>        End
84500>>>>
84500>>>
84500>>>        Get DriverIndex sDriverID to iDriver
84501>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84504>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
84507>>>
84507>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
84508>>>        If (num_arguments > 3) Begin
84510>>>            Move iLen     to iLength
84511>>>            Move iDec     to iDecimals
84512>>>            Move bInitVal to bInitializeValue
84513>>>            Move sColVal  to sColumnValue
84514>>>        End
84514>>>>
84514>>>
84514>>>        Get _SqlProperTableName sTableName   to sTableName
84515>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
84516>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
84517>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
84518>>>
84518>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
84519>>>        If (bFixed = False) Begin
84521>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
84522>>>        End
84522>>>>
84522>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
84523>>>
84523>>>        Move False to Err
84524>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84525>>>
84525>>>        If (bInitializeValue = True and Err = False) Begin
84527>>>            Get SQLColumnUpdateValue hTable sColumnName sColumnValue to bRetval
84528>>>        End
84528>>>>
84528>>>
84528>>>        If (Err = False) Begin
84530>>>            Get SqlUtilAdjustAuxFiles hTable sTableName sColumnName to bOK
84531>>>        End
84531>>>>
84531>>>
84531>>>        Move (not(Err)) to bRetval
84532>>>
84532>>>        // We also need to remove the cache-file since the table has been changed
84532>>>        Get UtilDeleteCacheFile sTableName to bOK
84533>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84536>>>
84536>>>        Function_Return bRetval
84537>>>    End_Function
84538>>>
84538>>>    // To update all current rows for a table column with a common value.
84538>>>    Function SqlColumnUpdateValue Handle hTable String sColumnName String sColumnValue Returns Boolean
84540>>>        String sDriverID sTableName sUpdate sSet sNoCountOn sStmt
84540>>>        Boolean bRetval bSQLDriver
84540>>>        Integer iCurrErr
84540>>>
84540>>>        Move False to bRetval
84541>>>        Get psDriverID to sDriverID
84542>>>        Get IsSQLDriver sDriverID to bSQLDriver
84543>>>        If (bSQLDriver = False) Begin
84545>>>            Function_Return bRetval
84546>>>        End
84546>>>>
84546>>>        Get UtilTableHandleToString hTable to sTableName
84547>>>
84547>>>        Move Err to iCurrErr
84548>>>        Move False to Err
84549>>>        Get _SqlFindKeyWord CI_SQLUpdate       to sUpdate
84550>>>        Get _SqlFindKeyWord CI_SQLSet          to sSet
84551>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountOn
84552>>>        Move (sNoCountOn * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
84553>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84554>>>        Move (Err = False) to bRetval
84555>>>        Move iCurrErr to Err
84556>>>
84556>>>        Function_Return bRetval
84557>>>    End_Function
84558>>>
84558>>>    // The fourth & fifth arguments are optional, depending on the iDataType
84558>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
84558>>>    Function SqlColumnChange Handle hTable String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
84560>>>        String sDriverID sTableName
84560>>>        Boolean bOK
84560>>>
84560>>>        Get psDriverID to sDriverID
84561>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84562>>>        If (bOK = False) Begin
84564>>>            Function_Return False
84565>>>        End
84565>>>>
84565>>>
84565>>>        Get UtilTableHandleToString hTable to sTableName
84566>>>        Get SqlColumnChangeByTableName sTableName sColumnName iDataType iLen iDec to bOK
84567>>>
84567>>>        Function_Return (Err = False)
84568>>>    End_Function
84569>>>
84569>>>    // Same as SqlColumnChange but instead of passing a filelist number; pass the table name as a string.
84569>>>    // The fourth & fifth arguments are optional, depending on the iDataType
84569>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
84569>>>    Function SqlColumnChangeByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
84571>>>        Integer iDbType iLength iDecimals
84571>>>        String sDriverID sStmt sAlterTable sAlterColumn sDataType sLengthAndDecimals sNotNull
84571>>>        Boolean bExists bOK bFixed
84571>>>        Handle hTable
84571>>>
84571>>>        Get psDriverID to sDriverID
84572>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84573>>>        If (bOK = False) Begin
84575>>>            Function_Return False
84576>>>        End
84576>>>>
84576>>>
84576>>>        Get UtilTableNameToHandle sTableName to hTable
84577>>>        If (hTable = 0) Begin
84579>>>            Get NextFreeFilelistSlot to hTable
84580>>>        End
84580>>>>
84580>>>        Get SQLUtilColumnExists sTableName sColumnName to bExists
84581>>>        If (bExists = True) Begin
84583>>>            Function_Return False
84584>>>        End
84584>>>>
84584>>>
84584>>>        If (num_arguments > 3) Begin
84586>>>            Move iLen to iLength
84587>>>        End
84587>>>>
84587>>>        If (num_arguments > 4) Begin
84589>>>            Move iDec to iDecimals
84590>>>        End
84590>>>>
84590>>>
84590>>>        Get piDbType to iDbType
84591>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
84592>>>
84592>>>        Move False to Err
84593>>>        Get _SqlProperTableName sTableName    to sTableName
84594>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
84595>>>        Get _SqlFindKeyWord CI_SQLAlterColumn to sAlterColumn
84596>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
84597>>>
84597>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
84598>>>        If (bFixed = False) Begin
84600>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
84601>>>        End
84601>>>>
84601>>>
84601>>>        Move (sAlterTable * sTableName * sAlterColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
84602>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84603>>>
84603>>>        // We also need to remove the cache-file since the table has been changed
84603>>>        Get UtilDeleteCacheFile sTableName to bOK
84604>>>
84604>>>        Function_Return (Err = False)
84605>>>    End_Function
84606>>>
84606>>>    Function SqlColumnDefaultValue Handle hTable Integer iColumn String sValue Returns Boolean
84608>>>        Boolean bOK bErr bIsSQLDriver
84608>>>        String sDriverID  
84608>>>        Integer iDataType
84608>>>
84608>>>        Get psDriverID to sDriverID
84609>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
84610>>>        If (bIsSQLDriver = False) Begin
84612>>>            Function_Return False
84613>>>        End
84613>>>>
84613>>>
84613>>>        Move Err to bErr
84614>>>        Move False to bErr
84615>>>
84615>>>        // There seems to be a problem with the ODBC_DRV driver that sometimes
84615>>>        // inserts randomly character(10) and spaces, so we correct from that here:
84615>>>        Move (Replaces(Character(10), Trim(sValue), "")) to sValue
84616>>>        Get_Attribute DF_FIELD_TYPE of hTable iColumn to iDataType 
84619>>>        If (iDataType = DF_BCD and Left(sValue, 1 <> "[")) Begin
84621>>>            Move ("[" + String(sValue) + "]") to sValue
84622>>>        End
84622>>>>
84622>>>        
84622>>>        Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sValue
84625>>>        Move (not(Err)) to bOK
84626>>>        Move bErr to Err
84627>>>
84627>>>        Function_Return bOK
84628>>>    End_Function
84629>>>
84629>>>    Function SqlColumnNullable Handle hTable Integer iColumn Boolean bNullable Returns Boolean
84631>>>        Boolean bOK bErr bCurrentState bOpen bIsSQLDriver
84631>>>        String sDriverID
84631>>>
84631>>>        Get psDriverID to sDriverID
84632>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
84633>>>        If (bIsSQLDriver = False) Begin
84635>>>            Function_Return False
84636>>>        End
84636>>>>
84636>>>
84636>>>        Move Err to bErr
84637>>>        Move False to bErr
84638>>>        Get_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bCurrentState
84641>>>        If (bNullable = bCurrentState) Begin
84643>>>            Function_Return True
84644>>>        End
84644>>>>
84644>>>
84644>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
84647>>>        If (bOpen = False) Begin
84649>>>            Get AutoConnectionIDLogin to bOK
84650>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
84651>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
84652>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84653>>>            Open hTable
84655>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
84656>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
84657>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84658>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
84661>>>        End
84661>>>>
84661>>>        If (bOpen = True) Begin
84663>>>            Structure_Start hTable sDriverID
84664>>>                Set_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bNullable
84667>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
84668>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
84670>>>            Set Action_Text of ghoStatusPanel to ""
84671>>>        End
84671>>>>
84671>>>
84671>>>        Move (not(Err)) to bOK
84672>>>        Move bErr to Err
84673>>>
84673>>>        Function_Return bOK
84674>>>    End_Function
84675>>>
84675>>>    // Drop column by its table handle
84675>>>    Function SqlColumnRemove Handle hTable String sColumnName Returns Boolean
84677>>>        String sDriverID sTableName
84677>>>        Boolean bOK
84677>>>
84677>>>        Get psDriverID to sDriverID
84678>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84679>>>        If (bOK = False) Begin
84681>>>            Function_Return False
84682>>>        End
84682>>>>
84682>>>
84682>>>        Get UtilTableHandleToString hTable to sTableName
84683>>>        If (sTableName = "") Begin
84685>>>            Function_Return False
84686>>>        End
84686>>>>
84686>>>
84686>>>        Get SqlColumnRemoveByTableName sTableName sColumnName to bOK
84687>>>
84687>>>        Function_Return (bOK = True)
84688>>>    End_Function
84689>>>
84689>>>    // Drop column by its table name as a string.
84689>>>    Function SqlColumnRemoveByTableName String sTableName String sColumnName Returns Boolean
84691>>>        Integer iDbType iDriver
84691>>>        String sDriverID sStmt sAlterTable sDropColumn
84691>>>        Boolean bExists bOK bRetval bDriverIgnoreErrorState
84691>>>        Handle hTable
84691>>>
84691>>>        Get psDriverID to sDriverID
84692>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84693>>>        If (bOK = False) Begin
84695>>>            Function_Return False
84696>>>        End
84696>>>>
84696>>>
84696>>>        Get DriverIndex sDriverID to iDriver
84697>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84700>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
84703>>>
84703>>>        Get UtilTableNameToHandle sTableName to hTable
84704>>>        If (hTable <> 0) Begin
84706>>>            Get SQLUtilColumnExists sTableName sColumnName to bExists
84707>>>            If (bExists = False) Begin
84709>>>                Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84712>>>                Function_Return False
84713>>>            End
84713>>>>
84713>>>        End
84713>>>>
84713>>>
84713>>>        Get piDbType to iDbType
84714>>>        If (iDbType = EN_DbTypeMSSQL) Begin
84716>>>            Get _SqlUtilRemoveTableColumnMSSQL sTableName sColumnName to bOK
84717>>>            Get UtilDeleteCacheFile sTableName to bOK
84718>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84721>>>            Function_Return bOK
84722>>>        End
84722>>>>
84722>>>
84722>>>        Move False to Err
84723>>>        Get _SqlProperTableName sTableName    to sTableName
84724>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
84725>>>        Get _SqlFindKeyWord CI_SQLDropColumn  to sDropColumn
84726>>>
84726>>>        Move (sAlterTable * sTableName * sDropColumn * sColumnName) to sStmt
84727>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84728>>>        Move (not(Err)) to bRetval
84729>>>
84729>>>        // We also need to remove the cache-file since the table has been changed
84729>>>        Get UtilDeleteCacheFile sTableName to bOK
84730>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84733>>>
84733>>>        Function_Return bRetval
84734>>>    End_Function
84735>>>
84735>>>    // Rename a field/column by table handle (filelist number)
84735>>>    Function SqlColumnRename Integer hTable String sColumnName String sNewColumnName Returns Boolean
84737>>>        String sDriverID sTableName
84737>>>        Boolean bOK
84737>>>
84737>>>        Get psDriverID to sDriverID
84738>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84739>>>        If (bOK = False) Begin
84741>>>            Function_Return False
84742>>>        End
84742>>>>
84742>>>
84742>>>        Get UtilTableHandleToString hTable to sTableName
84743>>>        Get SqlColumnRenameByTableName sTableName sColumnName sNewColumnName to bOK
84744>>>
84744>>>        Function_Return (Err = False)
84745>>>    End_Function
84746>>>
84746>>>    // Rename a field/column by table name.
84746>>>    Function SqlColumnRenameByTableName String sTableName String sColumnName String sNewColumnName Returns Boolean
84748>>>        Integer iDbType iDataType
84748>>>        String sDriverID sStmt sAlterTable sRenameColumn sVal sColumnKeyWord sOrgTableName sDatabase sDataType
84748>>>        Boolean bOK bRetval
84748>>>        Handle hTable
84748>>>
84748>>>        Move sTableName to sOrgTableName
84749>>>        Get psDriverID to sDriverID
84750>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84751>>>        If (bOK = False) Begin
84753>>>            Function_Return False
84754>>>        End
84754>>>>
84754>>>
84754>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
84755>>>        If (sVal = "") Begin
84757>>>            Function_Return False
84758>>>        End
84758>>>>
84758>>>
84758>>>        Get piDbType to iDbType
84759>>>        Get _SqlFindKeyWord CI_SQLColumn       to sColumnKeyWord
84760>>>        Get _SqlProperTableName sTableName     to sTableName
84761>>>        Get _SqlFindKeyWord CI_SQLAlterTable   to sAlterTable
84762>>>        Get _SqlFindKeyWord CI_SQLRenameColumn to sRenameColumn
84763>>>
84763>>>        Case Begin
84763>>>            Case (iDbType = EN_dbTypeMSSQL)
84765>>>                Move (sRenameColumn * "'" + sTableName + "." + sColumnName + "'," * "'" + sNewColumnName + "'," * "'" + sColumnKeyWord + "'") to sStmt
84766>>>                Case Break
84767>>>            // Alter table "SYS"."Customer" rename column "Comments" to "NewColumnName"
84767>>>            Case (iDbType = EN_dbTypeOracle)
84770>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
84771>>>                Case Break
84772>>>            // ALTER TABLE Schema.TableName RENAME COLUMN "deptnumb" TO "deptnum"
84772>>>            Case (iDbType = EN_dbTypeDB2)
84775>>>                Move (sAlterTable *  sTableName * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
84776>>>                Case Break
84777>>>            // ALTER TABLE "Customer" RENAME COLUMN "Comments" TO "NewColumnName"
84777>>>            Case (iDbType = EN_dbTypePostgre)
84780>>>                Move sOrgTableName to sTableName
84781>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
84782>>>                Case Break
84783>>>            Case (iDbType = EN_dbTypeMySQL)
84786>>>                // ALTER TABLE orderentry.customer CHANGE Comments NewColumnName text // Note: The last token is the column type!
84786>>>                Move sOrgTableName to sTableName
84787>>>                Get psDatabase to sDatabase
84788>>>                Get UtilTableNameToHandle sTableName to hTable
84789>>>                If (hTable = 0) Begin
84791>>>                    Get UtilTableOpen hTable sTableName DF_SHARE to bOK
84792>>>                    If (bOK = False) Begin
84794>>>                        Function_Return False
84795>>>                    End
84795>>>>
84795>>>                    Get NextFreeFilelistSlot to hTable
84796>>>                End
84796>>>>
84796>>>                Else Begin
84797>>>                    Open hTable
84799>>>                End
84799>>>>
84799>>>                Get SQLColumnType sDriverID hTable sTableName sColumnName to iDataType
84800>>>                Get UtilColumnTypeToString sDriverID iDbType iDataType    to sDataType
84801>>>                Move (sAlterTable * sDatabase + "." + sTableName * sRenameColumn * sColumnName * sNewColumnName * sDataType) to sStmt
84802>>>                Case Break
84803>>>            Case Else
84803>>>                Move (sAlterTable * "'" + sTableName + "'" * sRenameColumn * "'" + sTableName + "." + sColumnName + "'" * "TO" * "'" + sNewColumnName + "'") to sStmt
84804>>>        Case End
84804>>>
84804>>>        Move False to Err
84805>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84806>>>        Move (Err = False) to bRetval
84807>>>        // We also need to remove the cache-file since the table has been changed
84807>>>        Get UtilDeleteCacheFile sTableName to bOK
84808>>>
84808>>>        Function_Return bRetval
84809>>>    End_Function
84810>>>
84810>>>    Function SqlColumnType String sDriverID Handle hTable String sTableName String sColumnName Returns Integer
84812>>>        Handle hoSQLHandler hSQLConnect hStmt
84812>>>        Boolean bMertechDriver
84812>>>        Integer iNumCols iCount iDataType
84812>>>        String sValue
84812>>>
84812>>>        Get IsMertechDriver sDriverID to bMertechDriver
84813>>>        If (bMertechDriver = False) Begin
84815>>>            Get phoSQLManager to hoSQLHandler
84816>>>        End
84816>>>>
84816>>>        Else Begin
84817>>>            Get _MertechSQLManagerHandle to hoSQLHandler
84818>>>        End
84818>>>>
84818>>>
84818>>>        Get SQLFileConnect of hoSQLHandler hTable to hSQLConnect
84819>>>        If (hSQLConnect <> 0) Begin
84821>>>            Get SQLOpen of hSQLConnect to hStmt
84822>>>            If (hStmt <> 0) Begin
84824>>>                Send SQLExecDirect of hStmt ("select * from" * sTableName)
84825>>>
84825>>>                Get SQLStmtAttribute of hStmt SQLSTMTATTRIB_COLUMNCOUNT to iNumCols
84826>>>                For iCount from 1 to iNumCols
84832>>>>
84832>>>                    Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_LABEL to sValue
84833>>>                    If (Lowercase(sValue) = Lowercase(sColumnName)) Begin
84835>>>                        Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_SQLTYPE to iDataType
84836>>>                        Move iNumCols to iCount // We're out of here
84837>>>                    End
84837>>>>
84837>>>                Loop
84838>>>>
84838>>>
84838>>>                Send SQLClose of hStmt
84839>>>            End
84839>>>>
84839>>>            Send SQLDisconnect of hSQLConnect
84840>>>        End
84840>>>>
84840>>>
84840>>>        Function_Return iDataType
84841>>>    End_Function
84842>>>
84842>>>    // * Dummy function for the Studio's Code Explorer *
84842>>>    Function SQL_EXECUTE_FUNCTIONS Returns Boolean
84844>>>        Function_Return False
84845>>>    End_Function
84846>>>
84846>>>    Procedure SqlUtilExecuteQuery String sStmt String sDriverID Boolean bShowProgr
84848>>>        String sConnectionString sMessage
84848>>>        Handle hoSqlHandler hoSQLConnect hoStmt hoError
84848>>>        Integer i iMsgs iFetchResult iRowType iRows iErr iMessage iLastErr
84848>>>        String[] sMsg aSQLQueryMessages aSQLFetchResults
84851>>>        DateTime dtQueryExecStart dtQueryExecEnd dtFetchStart dtFetchEnd
84851>>>        TimeSpan tsQuery tsFetch
84851>>>        tSqlErrorArray aSqlErrorArray
84851>>>        tSqlErrorArray aSqlErrorArray
84851>>>        Boolean bOK bMertechDriver bShowProgress
84851>>>        tSQLConnection SQLConnection
84851>>>        tSQLConnection SQLConnection
84851>>>
84851>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84852>>>        If (bOK = False) Begin
84854>>>            Procedure_Return
84855>>>        End
84855>>>>
84855>>>
84855>>>        If (num_arguments > 2) Begin
84857>>>            Move bShowProgr to bShowProgress
84858>>>        End
84858>>>>
84858>>>
84858>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
84859>>>
84859>>>        Get IsMertechDriver sDriverID to bMertechDriver
84860>>>        If (bMertechDriver = True) Begin
84862>>>            Get _MertechSQLConnect sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
84863>>>        End
84863>>>>
84863>>>        If (bMertechDriver = False) Begin
84865>>>            Get phoSQLManager to hoSqlHandler
84866>>>            Send SqlSetConnect of hoSqlHandler sDriverID SQLConnection.sConnectionString
84867>>>            Get SqlConnect     of hoSqlHandler "" "" to hoSQLConnect
84868>>>        End
84868>>>>
84868>>>
84868>>>        If (hoSQLConnect <> 0) Begin
84870>>>            Get SqlOpen of hoSQLConnect to hoStmt
84871>>>            If (hoStmt <> 0) Begin
84873>>>                // record starting date/time stamp
84873>>>                Move (CurrentDateTime()) to dtQueryExecStart
84874>>>                // turn on error handling if enabled
84874>>>                If (pbHandleQueryErrors(Self)) Begin
84876>>>                    Set pbSqlError to False
84877>>>                    Set paSqlErrorArray to aSqlErrorArray
84878>>>                    Move Error_Object_Id to hoError 
84879>>>                    If (ghoDbUpdateHandler <> 0) Begin
84881>>>                        Move ghoDbUpdateHandler to Error_Object_Id
84882>>>                    End                                           
84882>>>>
84882>>>                    Else Begin
84883>>>                        Move Self to Error_Object_Id
84884>>>                    End
84884>>>>
84884>>>                End
84884>>>>
84884>>>
84884>>>                // Before we execute the statement; save it so we can display the faulty statement in the error log.
84884>>>                Set psSQLStatementString to sStmt 
84885>>>                Send Cursor_Wait of Cursor_Control
84886>>>                Send SqlExecDirect of hoStmt sStmt
84887>>>                Send Cursor_Ready of Cursor_Control
84888>>>
84888>>>                If (pbHandleQueryErrors(Self)) Begin
84890>>>                    Move hoError to Error_Object_Id
84891>>>                End
84891>>>>
84891>>>
84891>>>                Move 0 to iMsgs
84892>>>                // ToDo: There seems to be some issues with this code and Mertech drivers that makes
84892>>>                // the debugger crash in some cases like an error in the ESQL statement; so we exclude it for now.
84892>>>                If (bMertechDriver = False) Begin
84894>>>                    Move Err to iErr
84895>>>                    Move LastErr to iLastErr
84896>>>                    Get SqlStmtAttribute of hoStmt SQLSTMTATTRIB_NUMMESSAGES   to iMsgs
84897>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT      to iRows
84898>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
84899>>>                    Send _SqlColumnInfo hoStmt
84900>>>                    Send Ignore_Error of Error_Object_Id 12289
84901>>>                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84902>>>                    Repeat
84902>>>>
84902>>>                        Get SqlFetch of hoStmt to iFetchResult
84903>>>                        If (iFetchResult <> 0) Begin
84905>>>                            Get SQLColumnValue of hoStmt 1 to aSQLFetchResults[SizeOfArray(aSQLFetchResults)]
84906>>>                        End
84906>>>>
84906>>>                    Until (iFetchResult = 0)
84908>>>                    Send Trap_Error of Error_Object_Id 12289
84909>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
84910>>>                    Move iErr to Err
84911>>>                    Move iLastErr to LastErr
84912>>>                    Set paSQLFetchResults to aSQLFetchResults
84913>>>                End
84913>>>>
84913>>>
84913>>>                Set piRows    to iRows
84914>>>                Set piRowType to iRowType
84915>>>                Move (CurrentDateTime()) to dtQueryExecEnd
84916>>>                Move (CurrentDateTime()) to dtFetchStart
84917>>>
84917>>>                If (iMsgs <> 0) Begin
84919>>>                    If (ghoDbUpdateHandler > 0) Begin
84921>>>                        Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
84922>>>                    End
84922>>>>
84922>>>                    For i from 1 to iMsgs
84928>>>>
84928>>>                        Get SqlGetMessage of hoStmt i to sMessage
84929>>>                        Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
84930>>>                        If (bShowProgress = True) Begin
84932>>>                            If (Active_State(ghoStatusPanel)) Begin
84934>>>                                Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
84935>>>                            End
84935>>>>
84935>>>                            Else Begin
84936>>>                                Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
84938>>>                            End
84938>>>>
84938>>>                        End
84938>>>>
84938>>>                        Move sMessage to sMsg[SizeOfArray(sMsg)]
84939>>>                        Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
84940>>>                    Loop
84941>>>>
84941>>>                    If (ghoDbUpdateHandler > 0) Begin
84943>>>                        Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
84944>>>                    End
84944>>>>
84944>>>                    Set paQueryMessages to sMsg
84945>>>                End 
84945>>>>
84945>>>                Else Begin
84946>>>                    If (bShowProgress = True) Begin
84948>>>                        Get paSqlErrorArray to aSqlErrorArray
84949>>>                        If (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) Begin
84951>>>                            Move (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) to iMsgs
84952>>>                            Decrement iMsgs
84953>>>                            For i from 0 to iMsgs
84959>>>>
84959>>>                                Showln "Embedded SQL Statement: " aSqlErrorArray.sSqlStatementArray[i]
84962>>>                                Showln "SQL Error Message     : " aSqlErrorArray.sSqlErrorArray[i]
84965>>>                            Loop
84966>>>>
84966>>>                        End
84966>>>>
84966>>>                    End
84966>>>>
84966>>>                End
84966>>>>
84966>>>                Move (CurrentDateTime()) to dtFetchEnd
84967>>>            End
84967>>>>
84967>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
84968>>>            Move (dtFetchStart - dtFetchEnd) to tsFetch
84969>>>            Set ptsQueryExec to tsQuery
84970>>>            Set ptsFetchResults to tsFetch
84971>>>            Send SqlClose of hoStmt
84972>>>        End
84972>>>>
84972>>>
84972>>>        Send SqlDisconnect of hoSQLConnect
84973>>>    End_Procedure
84974>>>
84974>>>    // *** Main message for executing an SQL script that has been compiled into the program as a resource ***
84974>>>    // Use the SQLIncludeScriptFile command to include an SQL script into the program.
84974>>>    // Returns False if no error occured.
84974>>>    Function SqlUtilExecuteResource String sMemFileName String sDriverID Boolean bCreateScriptFile Boolean bShowProgr Returns Boolean
84976>>>        Boolean bOK bShowProgress
84976>>>        tSQLScriptArray SQLScriptArray
84976>>>        tSQLScriptArray SQLScriptArray
84976>>>        DateTime dtTotalQueryStart dtTotalQueryEnd
84976>>>        TimeSpan tsTotalTime
84976>>>
84976>>>        Move (CurrentDateTime()) to dtTotalQueryStart
84977>>>        Get SqlUtilReadResource sMemFileName to SQLScriptArray
84978>>>        If (SQLScriptArray.bError = True) Begin
84980>>>            Function_Return False
84981>>>        End
84981>>>>
84981>>>
84981>>>        If (num_arguments > 3) Begin
84983>>>            Move bShowProgr to bShowProgress
84984>>>        End
84984>>>>
84984>>>
84984>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84985>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID bCreateScriptFile sMemFileName bShowProgress to bOK
84986>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84987>>>
84987>>>        If (SQLScriptArray.bArgumentSizeChanged = True) Begin
84989>>>            Set_Argument_Size SQLScriptArray.iOrgArgumentSize
84990>>>>
84990>>>        End
84990>>>>
84990>>>
84990>>>        Move (CurrentDateTime()) to dtTotalQueryEnd
84991>>>        Move (dtTotalQueryEnd - dtTotalQueryStart) to tsTotalTime
84992>>>        Set ptsTotalQueryTime to tsTotalTime
84993>>>
84993>>>        Function_Return bOK
84994>>>    End_Procedure
84995>>>
84995>>>    // Reads a SQL script file that has been compiled into the .exe program as a resource.
84995>>>    // Pass: The memory resource reference and a boolean True if you want to create the file on disk (in the Home folder).
84995>>>    // Returns: A tSQLScriptArray Struct with the Sql script as an uChar Array will be returned along with the a bError boolean.
84995>>>    Function SqlUtilReadResource String sMemFileName Returns tSQLScriptArray
84997>>>        Integer iChannel iArgumentSize iCount
84997>>>        Number nByteCount
84997>>>        String sSQLScript
84997>>>        tSQLScriptArray SqlScriptArray
84997>>>        tSQLScriptArray SqlScriptArray
84997>>>        UChar[] uCharData
84998>>>
84998>>>        Move False to Err
84999>>>        Get Seq_New_Channel to iChannel
85000>>>        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
85002>>>            Error DFERR_PROGRAM 'No channel available...'
85003>>>>
85003>>>            Move True to SqlScriptArray.bError
85004>>>            Function_Return SqlScriptArray
85005>>>        End
85005>>>>
85005>>>
85005>>>        // First decide the size of the script
85005>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
85007>>>        Read_Block channel iChannel uCharData -1 // -1 means that all data should be read.
85009>>>        Close_Input channel iChannel
85011>>>
85011>>>        Move (SizeOfArray(uCharData)) to nByteCount
85012>>>        If (nByteCount  < 1) Begin
85014>>>            Send Seq_Release_Channel iChannel
85015>>>            Move True to SqlScriptArray.bError
85016>>>            Function_Return SqlScriptArray
85017>>>        End
85017>>>>
85017>>>
85017>>>        // If necessary change the string argument_size
85017>>>        Get_Argument_Size to iArgumentSize
85018>>>        If (nByteCount >= iArgumentSize) Begin
85020>>>            Move (nByteCount + 2048) to nByteCount
85021>>>            Set_Argument_Size nByteCount // Set new argument size just a bit higher than "needed" for overhead margin.
85022>>>>
85022>>>            Move True          to SqlScriptArray.bArgumentSizeChanged
85023>>>            Move iArgumentSize to SqlScriptArray.iOrgArgumentSize
85024>>>        End
85024>>>>
85024>>>        Else Begin
85025>>>            Move False to SqlScriptArray.bArgumentSizeChanged
85026>>>        End
85026>>>>
85026>>>
85026>>>        // Read the script file from memory line-by-line
85026>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
85028>>>            Move 0 to iCount
85029>>>            Repeat
85029>>>>
85029>>>                Readln channel iChannel sSQLScript
85031>>>                Move sSQLScript to SqlScriptArray.sSQLScriptArray[iCount]
85032>>>                Increment iCount
85033>>>            Until (SeqEof = True)
85035>>>        Close_Input channel iChannel
85037>>>        Send Seq_Release_Channel iChannel
85038>>>
85038>>>        // Finally "sanitize" the script by removing all comments.
85038>>>        Get _SqlUtilSanitizeScript SqlScriptArray to SqlScriptArray
85039>>>
85039>>>        Function_Return SqlScriptArray
85040>>>    End_Function
85041>>>
85041>>>    Function SqlUtilExecuteEmbeddedScript tSQLScriptArray SQLScriptArray String sDriverID Boolean bCreateScriptFile String sMemFileName Boolean bShowProgr Returns Boolean
85043>>>        String sSQLVal sStmt sCR sGOKeyWord sNoCountKeyWord sMessage sExportFile
85043>>>        Handle hoSql hoSQLConnect hoStmt hoError
85043>>>        Integer i iMsgs iRows iRowType iCount iChunkCounter iChunkMax iOut iNextSet iMessage
85043>>>        String[] sMsg aSQLQueryMessages
85045>>>        DateTime dtQueryExecStart dtQueryExecEnd
85045>>>        TimeSpan tsQuery
85045>>>        tSqlErrorArray aSqlErrorArray
85045>>>        tSqlErrorArray aSqlErrorArray
85045>>>        tSQLConnection SQLConnection
85045>>>        tSQLConnection SQLConnection
85045>>>        Boolean bMertechDriver bShowProgress
85045>>>
85045>>>        If (num_arguments > 4) Begin
85047>>>            Move bShowProgr to bShowProgress
85048>>>        End
85048>>>>
85048>>>        Get IsMertechDriver sDriverID to bMertechDriver
85049>>>        If (bMertechDriver = False) Begin
85051>>>            Get phoSQLManager to hoSql
85052>>>        End
85052>>>>
85052>>>        Else Begin
85053>>>            Get _MertechSQLManagerHandle to hoSql
85054>>>        End
85054>>>>
85054>>>
85054>>>        Get _SqlFindKeyWord CI_SQLGO to sGOKeyWord
85055>>>        // There seems to be a problem to pass strings when their value gets really big, aka
85055>>>        // above the argument_size level. It isn't clear when these problems starts but sooner
85055>>>        // or later SqlExecDirect stops working correctly with no error messages!
85055>>>        // To guard from this we set a max number of lines (iChunkMax) that can be processed
85055>>>        // at a time. Testing with the Create Chinook Database script; 500 seems like a number that works fine.
85055>>>        // A bonus of this is that it turns out that it is actually faster to run in chunks!
85055>>>        Get piChunkMax to iChunkMax
85056>>>        Move 0 to iChunkCounter
85057>>>        Move "" to sStmt
85058>>>
85058>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
85059>>>        Move (Character(13) + Character(10)) to sCR
85060>>>
85060>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85061>>>
85061>>>        If (bMertechDriver = True) Begin
85063>>>            Get _MertechSQLConnect sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
85064>>>        End
85064>>>>
85064>>>        If (bMertechDriver = False) Begin
85066>>>            Get phoSQLManager  to hoSQL
85067>>>            Send SqlSetConnect of hoSQL sDriverID SQLConnection.sConnectionString
85068>>>            Get SqlConnect     of hoSQL "" "" to hoSQLConnect
85069>>>        End
85069>>>>
85069>>>
85069>>>        If (hoSQLConnect <> 0) Begin
85071>>>            Move False to Err
85072>>>            Get SqlOpen of hoSQLConnect to hoStmt
85073>>>            If (hoStmt <> 0) Begin
85075>>>
85075>>>                // If the embedded resource should be written as a script file to disk:
85075>>>                If (bCreateScriptFile = True) Begin
85077>>>                    Get psHome of (phoWorkspace(ghoApplication)) to sExportFile
85078>>>                    Get vFolderFormat sExportFile to sExportFile
85079>>>                    Move (sExportFile + sMemFileName) to sExportFile
85080>>>                    Get Seq_New_Channel to iOut
85081>>>                    If (iOut <> DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
85083>>>                        Direct_Output channel iOut sExportFile
85085>>>                    End
85085>>>>
85085>>>                End
85085>>>>
85085>>>
85085>>>                // Record starting date/time stamp
85085>>>                Move (CurrentDateTime()) to dtQueryExecStart
85086>>>                // Turn on error handling if enabled
85086>>>                If (pbHandleQueryErrors(Self)) Begin
85088>>>                    Set pbSqlError to False
85089>>>                    Set paSqlErrorArray to aSqlErrorArray
85090>>>                    Move Error_Object_Id to hoError
85091>>>                    Move Self to Error_Object_Id
85092>>>                End
85092>>>>
85092>>>
85092>>>                Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iRows
85093>>>                Decrement iRows
85094>>>                Move (sNoCountKeyWord + sCR) to sStmt
85095>>>
85095>>>                For iCount from 0 to iRows
85101>>>>
85101>>>                    Move (SQLScriptArray.sSQLScriptArray[iCount]) to sSQLVal
85102>>>
85102>>>                    If (Uppercase(sSQLVal) <> sGOKeyWord) Begin
85104>>>                        If (sSQLVal <> "") Begin
85106>>>                            Move (sSQLVal + sCR) to sSQLVal
85107>>>                        End
85107>>>>
85107>>>                        Move (Append(sStmt, (sSQLVal))) to sStmt
85108>>>                    End
85108>>>>
85108>>>
85108>>>                    // - Each time we encounter a "GO" statement we execute it,
85108>>>                    // or if at the very end of the script.
85108>>>                    If (Uppercase(sSQLVal) = sGOKeyWord or iChunkCounter >= iChunkMax or iCount = iRows) Begin
85110>>>
85110>>>                        // - It turns out it can be at least 10 times faster to execute SQL statements in chunks,
85110>>>                        // instead of all in one go.
85110>>>                        Send SqlExecDirect of hoStmt sStmt
85111>>>
85111>>>                        If (bCreateScriptFile = True) Begin
85113>>>                            Write channel iOut sStmt
85115>>>                        End
85115>>>>
85115>>>                        Move "" to sStmt
85116>>>                        Move 0 to iChunkCounter
85117>>>                    End
85117>>>>
85117>>>                    Increment iChunkCounter
85118>>>                Loop
85119>>>>
85119>>>
85119>>>                Repeat
85119>>>>
85119>>>                    If (pbHandleQueryErrors(Self)) Begin
85121>>>                        Move hoError to Error_Object_Id
85122>>>                    End
85122>>>>
85122>>>                    Move (CurrentDateTime()) to dtQueryExecEnd
85123>>>
85123>>>                    Send _SqlColumnInfo hoStmt
85124>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT to iRows
85125>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
85126>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_NUMMESSAGES to iMsgs
85127>>>                    Set piRows    to iRows
85128>>>                    Set piRowType to iRowType
85129>>>
85129>>>                    If (iMsgs <> 0) Begin
85131>>>                        If (ghoDbUpdateHandler > 0) Begin
85133>>>                            Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
85134>>>                        End
85134>>>>
85134>>>                        For i from 1 to iMsgs
85140>>>>
85140>>>                            Get SqlGetMessage of hoStmt i to sMessage
85141>>>                            Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
85142>>>                            If (bShowProgress = True) Begin
85144>>>                                If (Active_State(ghoStatusPanel)) Begin
85146>>>                                    Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
85147>>>                                End
85147>>>>
85147>>>                                Else Begin
85148>>>                                    Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
85150>>>                                End
85150>>>>
85150>>>                            End
85150>>>>
85150>>>                            Move sMessage to sMsg[SizeOfArray(sMsg)]
85151>>>                            Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
85152>>>                        Loop
85153>>>>
85153>>>
85153>>>
85153>>>                        If (ghoDbUpdateHandler > 0) Begin
85155>>>                            Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
85156>>>                        End
85156>>>>
85156>>>                        Set paQueryMessages to sMsg
85157>>>                    End
85157>>>>
85157>>>
85157>>>                    Get SQLNextResultSet of hoStmt to iNextSet
85158>>>                Until (iNextSet = 0)
85160>>>
85160>>>                Move (CurrentDateTime()) to dtQueryExecEnd
85161>>>            End
85161>>>>
85161>>>
85161>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
85162>>>            Set ptsQueryExec to tsQuery
85163>>>            Send SqlClose of hoStmt
85164>>>
85164>>>            If (bCreateScriptFile = True) Begin
85166>>>                Close_Output channel iOut
85168>>>                Send Seq_Release_Channel iOut
85169>>>            End
85169>>>>
85169>>>        End
85169>>>>
85169>>>        Send SqlDisconnect of hoSQLConnect
85170>>>
85170>>>        Function_Return (hoSQLConnect <> 0 and Err = False)
85171>>>    End_Function
85172>>>
85172>>>    // * Dummy function for the Studio's Code Explorer *
85172>>>    Function SQL_UTILITY_FUNCTIONS Returns Boolean
85174>>>        Function_Return False
85175>>>    End_Function
85176>>>
85176>>>    // Does three things with auxilirary files;
85176>>>    // 1) Deletes the cache file in the first Data folder of the psDataPath property as the table at the SQL end has been changed.
85176>>>    // 2) Adds the sColumnName to the TableName.tag file in the first Data folder of the psDataPath property
85176>>>    // 3) Creates a new TableName.fd file if the DdSrc folder is available (if this is a development environment)
85176>>>    Function SqlUtilAdjustAuxFiles Handle hTable String sTableName String sColumnName Returns Boolean
85178>>>        String sDataPath sDDSrcPath sDriverID
85178>>>        Boolean bOK bExists bMertechDriver
85178>>>        Integer iCount iCh iPos
85178>>>
85178>>>        // If table name equals e.g. "dbo.MyTable" we need to remove the prefix.
85178>>>        If (sTableName contains ".") Begin
85180>>>            Move (Pos(".", sTableName)) to iPos
85181>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
85182>>>        End
85182>>>>
85182>>>
85182>>>        Get psDriverID to sDriverID
85183>>>        Get psDataPathFirstPart to sDataPath
85184>>>        Get vFolderExists sDataPath to bOK
85185>>>        If (bOK = False) Begin
85187>>>            Error DFERR_PROGRAM "Function SqlUtilAdjustAuxFiles; psDataPath not found!"
85188>>>>
85188>>>            Function_Return False
85189>>>        End
85189>>>>
85189>>>
85189>>>        Get IsMertechDriver sDriverID to bMertechDriver
85190>>>        // First delete the cache file:
85190>>>        Get UtilDeleteCacheFile sTableName to bOK
85191>>>
85191>>>        Get Seq_New_Channel to iCh
85192>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
85194>>>            Function_Return False
85195>>>        End
85195>>>>
85195>>>
85195>>>        Get vFilePathExists (sDataPath + sTableName + ".tag") to bExists
85196>>>        If (bExists = False) Begin
85198>>>            Function_Return False
85199>>>        End
85199>>>>
85199>>>
85199>>>        // Add the new column name to the .tag file:
85199>>>        Append_Output channel iCh (sDataPath + sTableName + ".tag")
85201>>>            Writeln channel iCh sColumnName
85204>>>        Close_Output
85205>>>
85205>>>        // If in development environment; output new .fd file:
85205>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
85206>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
85207>>>        If (iCount > 1) Begin
85209>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
85210>>>        End
85210>>>>
85210>>>        Get vFolderExists sDDSrcPath to bExists
85211>>>        If (bExists = True) Begin
85213>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
85214>>>            Move False to Err
85215>>>            Get AutoConnectionIDLogin to bOK
85216>>>            If (hTable <> 0) Begin
85218>>>                Open hTable
85220>>>            End
85220>>>>
85220>>>            Else Begin
85221>>>                Get UtilTableOpen hTable sTableName DF_SHARE to bOK
85222>>>            End
85222>>>>
85222>>>
85222>>>            Get_Attribute DF_FILE_OPENED of hTable to bOK
85225>>>            If (bOK = True) Begin
85227>>>                Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
85229>>>            End
85229>>>>
85229>>>            If (Err = True) Begin
85231>>>                Move False to bOK
85232>>>            End
85232>>>>
85232>>>        End
85232>>>>
85232>>>
85232>>>        Function_Return (bOK = True)
85233>>>    End_Function
85234>>>
85234>>>    // Message for changing .int files to use connection ID's
85234>>>    //
85234>>>    // Changes all ".int" files for the passed sDataPath to use a sConnectionID,
85234>>>    // OR changes an existing connection id to a new id.
85234>>>    // Pass the full path to the data folder and the name of the connection id (string value).
85234>>>    // Pass a True for the bShowResult parameter to show work in progress (showln's).
85234>>>    Procedure SqlUtilChangeIntFilesToConnectionIDs String sDataPath String sConnectionID Boolean bShowResult
85236>>>        String sFileName sDriverID sDriverFile sConnectionString
85236>>>        String[] sFilesData
85237>>>        Boolean bOK bCancel
85237>>>        Integer iSize iCount
85237>>>
85237>>>        Get SqlUtilEnumerateIntFiles sDataPath to sFilesData
85238>>>        Move (SizeOfArray(sFilesData))    to iSize
85239>>>        If (iSize = 0) Begin
85241>>>            If (ghoStatusPanel <> 0) Begin
85243>>>                If (Active_State(ghoStatusPanel)) Begin
85245>>>                    Send Stop_StatusPanel of ghoStatusPanel
85246>>>                End
85246>>>>
85246>>>            End
85246>>>>
85246>>>            Send Info_Box "No .int files found! Nothing was changed."
85247>>>            Procedure_Return
85248>>>        End
85248>>>>
85248>>>
85248>>>        Move (Trim(sConnectionID)) to sConnectionID
85249>>>        Get vFolderFormat sDataPath to sDataPath
85250>>>        Decrement iSize
85251>>>        For iCount from 0 to iSize
85257>>>>
85257>>>            Move sFilesData[iCount] to sFileName
85258>>>            // This makes sure that we also can change an existing connection id to something new:
85258>>>            Get UtilChangeSourceCodeLine (sDataPath + sFileName) CS_SERVER_NAME (CS_SERVER_NAME * CS_DFCONNID + "=" + sConnectionID) bShowResult to bOK
85259>>>            If (ghoStatusPanel <> 0) Begin
85261>>>                If (Active_State(ghoStatusPanel)) Begin
85263>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
85264>>>                    If (bCancel = True) Begin
85266>>>                        Send Deactivate of ghoStatusPanel
85267>>>                        Procedure_Return
85268>>>                    End
85268>>>>
85268>>>                End
85268>>>>
85268>>>            End
85268>>>>
85268>>>        Loop
85269>>>>
85269>>>
85269>>>        Get psDriverID to sDriverID
85270>>>
85270>>>         // Finally also change the driver file e.g. MSSQLDRV.int file in the Data folder in case it has a "DFconnectionID xxxxID,SERVER..."
85270>>>        Move "" to sFileName
85271>>>        If (sDriverID = MSSQLDRV_ID) Begin
85273>>>            Move "MSSQLDrv.int" to sFileName
85274>>>        End
85274>>>>
85274>>>        If (sDriverID = DB2_DRV_ID) Begin
85276>>>            Move "DB2_Drv.int" to sFileName
85277>>>        End
85277>>>>
85277>>>        If (sDriverID = ODBC_DRV_ID) Begin
85279>>>            Move "ODBC_Drv.int" to sFileName
85280>>>        End
85280>>>>
85280>>>        If (sFileName <> "") Begin
85282>>>            Move "" to sDriverFile
85283>>>            Get_File_Path sFileName to sDriverFile
85284>>>            If (sDriverFile <> "") Begin
85286>>>                Get psConnectionString to sConnectionString
85287>>>                Get UtilChangeSourceCodeLine sDriverFile CS_SQLConnectionIDText (CS_SQLConnectionIDText * String(sConnectionID) + "," * String(sConnectionString) * String(",0")) bShowResult to bOK
85288>>>            End
85288>>>>
85288>>>        End
85288>>>>
85288>>>    End_Procedure
85289>>>
85289>>>    // Checks if the database exists in SQL. Returns = True if it does.
85289>>>    Function SqlUtilCheckIfDatabaseExists String sDatabase Returns Boolean
85291>>>        String[] sDatabaseArray
85292>>>        String sVal sServer sDriverID
85292>>>        Integer iCount iSize iPos
85292>>>        Boolean bExists
85292>>>        tSQLConnection SQLConnection
85292>>>        tSQLConnection SQLConnection
85292>>>
85292>>>        Move False to bExists
85293>>>        Get psDriverID to sDriverID
85294>>>        // DB2 doesn't need to have a "Database" name, so we always return True.
85294>>>        If (sDriverID = DB2_DRV_ID) Begin
85296>>>            Function_Return bExists
85297>>>        End
85297>>>>
85297>>>
85297>>>        Get SqlUtilEnumerateDatabases sDriverID to sDatabaseArray
85298>>>        If (SizeOfArray(sDatabaseArray) = 0) Begin
85300>>>            Function_Return False
85301>>>        End
85301>>>>
85301>>>
85301>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85302>>>        Get ParseKeyWord SQLConnection.sConnectionString (CS_SQLIniDSNKeyword + "=") to sServer
85303>>>        If (sServer contains "/") Begin
85305>>>            Move (Pos("/", sServer)) to iPos
85306>>>            Move (Mid(sServer, 999, (iPos +1)))                        to sDatabase
85307>>>        End
85307>>>>
85307>>>
85307>>>        Move (SizeOfArray(sDatabaseArray)) to iSize
85308>>>        Decrement iSize
85309>>>        For iCount from 0 to iSize
85315>>>>
85315>>>            Move sDatabaseArray[iCount] to sVal
85316>>>            If (Uppercase(sVal) = Uppercase(sDatabase)) Begin
85318>>>                Move True to bExists
85319>>>            End
85319>>>>
85319>>>        Loop
85320>>>>
85320>>>
85320>>>        Function_Return bExists
85321>>>    End_Function
85322>>>
85322>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
85322>>>    Function SqlUtilCheckIfTableHandleExists Handle hTable String sDriverID Returns Boolean
85324>>>        String sTableName sVal
85324>>>        Boolean bExists
85324>>>        String[] sTablesArray
85325>>>        Integer iSize iCount
85325>>>
85325>>>        Move False to bExists
85326>>>        Get UtilTableHandleToString hTable to sTableName
85327>>>        Get SqlUtilEnumerateTables sDriverID to sTablesArray
85328>>>        Move (SizeOfArray(sTablesArray)) to iSize
85329>>>        Decrement iSize
85330>>>        For iCount from 0 to iSize
85336>>>>
85336>>>            Move sTablesArray[iCount] to sVal
85337>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
85339>>>                Move True to bExists
85340>>>                Move iSize to iCount // We're done!
85341>>>            End
85341>>>>
85341>>>        Loop
85342>>>>
85342>>>
85342>>>        Function_Return bExists
85343>>>    End_Function
85344>>>
85344>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
85344>>>    Function SqlUtilCheckIfTableNameExists String sTableName String sDriverID Returns Boolean
85346>>>        String sVal
85346>>>        Boolean bExists
85346>>>        String[] sTablesArray
85347>>>        Integer iSize iCount
85347>>>
85347>>>        Move False to bExists
85348>>>        Get SqlUtilEnumerateTables sDriverID to sTablesArray
85349>>>        Move (SizeOfArray(sTablesArray)) to iSize
85350>>>        Decrement iSize
85351>>>        For iCount from 0 to iSize
85357>>>>
85357>>>            Move sTablesArray[iCount] to sVal
85358>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
85360>>>                Move True to bExists
85361>>>                Move iSize to iCount // We're done!
85362>>>            End
85362>>>>
85362>>>        Loop
85363>>>>
85363>>>
85363>>>        Function_Return bExists
85364>>>    End_Function
85365>>>
85365>>>    // ToDo: This index name function needs to be finished...
85365>>>    Function SqlUtilCheckIfIndexNameExists Handle hTable String sIndexName Returns Boolean
85367>>>        String sSchema sTableName sDriverID
85367>>>        Boolean bExists
85367>>>
85367>>>        Get psDriverID to sDriverID
85368>>>        Get psSchema to sSchema
85369>>>        Get UtilTableHandleToString hTable to sTableName
85370>>>
85370>>>        Function_Return bExists
85371>>>    End_Function
85372>>>
85372>>>    // Checks if a column/field name exists in a SQL table definition
85372>>>    // Returns True if it does
85372>>>    // Sample:
85372>>>    //   Get SQLUtilColumnExists "MySQLTable" "MyColumnName" to bExists
85372>>>    Function SqlUtilColumnExists String sTableName String sFieldName Returns Boolean
85374>>>        Integer iNumColumns iColumn
85374>>>        String sColumn sDriverID
85374>>>        String[] sColumnsArray
85375>>>        Boolean bExists bOK
85375>>>
85375>>>        Move False to bExists
85376>>>        Get AutoConnectionIDLogin to bOK
85377>>>        Get psDriverID to sDriverID
85378>>>
85378>>>        Get SqlUtilEnumerateColumns sDriverID sTableName to sColumnsArray
85379>>>        Move (SizeOfArray(sColumnsArray)) to iNumColumns
85380>>>        Decrement iNumColumns
85381>>>        For iColumn from 0 to iNumColumns
85387>>>>
85387>>>            Move sColumnsArray[iColumn] to sColumn
85388>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
85390>>>                Move True to bExists
85391>>>                Move iNumColumns to iColumn // We're out of here
85392>>>            End
85392>>>>
85392>>>        Loop
85393>>>>
85393>>>
85393>>>        Function_Return bExists
85394>>>    End_Function
85395>>>
85395>>>    Function SqlUtilConvertColumnTypesToSQL2008 Handle hTable Returns Boolean
85397>>>        Integer iNumColumns iColumn iDFType iNativeType
85397>>>        Boolean bOpened bOK
85397>>>        String sColumnName sNativeTypeName
85397>>>
85397>>>        Get AutoConnectionIDLogin to bOK
85398>>>        Get OpenTableExclusive hTable to bOK
85399>>>        If (bOK = False) Begin
85401>>>            Function_Return False
85402>>>        End
85402>>>>
85402>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
85405>>>        If (bOpened = False) Begin
85407>>>            Error DFERR_PROGRAM ("Function SQLUtilConvertColumnTypesToSQL2008; Could not open table" * String(hTable))
85408>>>>
85408>>>            Function_Return False
85409>>>        End
85409>>>>
85409>>>
85409>>>        Move False to Err
85410>>>
85410>>>        Structure_Start hTable
85411>>>            Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
85414>>>
85414>>>            For iColumn from 1 to iNumColumns
85420>>>>
85420>>>                Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iDfType
85423>>>                Get_Attribute DF_FIELD_NAME             of hTable iColumn to sColumnName
85426>>>                Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iNativeType
85429>>>                Get_Attribute DF_FIELD_NATIVE_TYPE_Name of hTable iColumn to sNativeTypeName
85432>>>
85432>>>                Case Begin
85432>>>                    Case (iDFType = DF_DATE)
85434>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
85436>>>                            // Convert datetime to date
85436>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_DATE
85439>>>                        End
85439>>>>
85439>>>                        Case Break
85440>>>                    Case (iDFType = DF_DATETIME)
85443>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
85445>>>                            // Convert datetime to datetime2
85445>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_TIMESTAMP2
85448>>>                        End
85448>>>>
85448>>>                        Case Break
85449>>>                    Case (iDFType = DF_ASCII)
85452>>>                        If (iNativeType = SQL_CHAR) Begin
85454>>>                            // Convert char to varchar
85454>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
85457>>>                        End
85457>>>>
85457>>>                        Case Break
85458>>>                    Case (iDFType = DF_TEXT)
85461>>>                        If (iNativeType = SQL_LONGVARCHAR) Begin
85463>>>                            // Convert text to varchar(max)
85463>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
85466>>>                        End
85466>>>>
85466>>>                        Case Break
85467>>>                    Case (iDFType = DF_BINARY)
85470>>>                        If (iNativeType = SQL_LONGVARBINARY) Begin
85472>>>                            // Convert image to varbinary(max)
85472>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARBINARY
85475>>>                        End
85475>>>>
85475>>>                        Case Break
85476>>>                Case End
85476>>>            Loop
85477>>>>
85477>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
85478>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85480>>>
85480>>>        Set Action_Text of ghoStatusPanel to ""
85481>>>        Function_Return (Err = False)
85482>>>    End_Function
85483>>>
85483>>>
85483>>>    // Will create an SQL table with the passed sTableName & sColumnName as Numeric 4.2 to keep
85483>>>    // the DbUpdateVersion database revision in.
85483>>>    // Also pass the file number of the current (embedded?) table number used in development.
85483>>>    // It will first create the SQL Table & column, then create the .int file and change Filelist.cfg
85483>>>    Function SqlUtilCreateDbVersionTable Handle hTable String sColumnName String sDriverID Returns Boolean
85485>>>        Boolean bOK bOpened
85485>>>        String sTableName sDataType sAlterTable sAddColumn sLengthAndDecimals sStmt
85485>>>
85485>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
85488>>>        Get _TableNameOnly sTableName to sTableName
85489>>>        If (sTableName = "") Begin
85491>>>            Function_Return False
85492>>>        End
85492>>>>
85492>>>
85492>>>        // This just creates the table and a "dummy" column.
85492>>>        Get SqlTableCreate hTable sDriverID to bOK
85493>>>        If (bOK = False) Begin
85495>>>            Function_Return False
85496>>>        End
85496>>>>
85496>>>
85496>>>        Close hTable
85497>>>        Move False to Err
85498>>>
85498>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
85499>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
85500>>>        Move "Decimal" to sDataType
85501>>>        Get _SqlFormatLengthAndDecimalAsString 4 2 to sLengthAndDecimals
85502>>>
85502>>>        // Adds the "sColumnName" passed to the function
85502>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals) to sStmt
85503>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85504>>>
85504>>>        // Now we can delete the dummy column:
85504>>>        Get SqlColumnRemoveByTableName sTableName "Dummy" to bOK
85505>>>
85505>>>        // Finally, we attach to the newly created table.
85505>>>        If (Err = False) Begin
85507>>>            Get ApiTableAttachToSQL hTable True to bOK
85508>>>        End
85508>>>>
85508>>>        Open hTable
85510>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
85513>>>
85513>>>        Function_Return (Err = False and bOK = True and bOpened = True)
85514>>>    End_Function
85515>>>
85515>>>    // The table must already exist in the filelist for this function to work.
85515>>>    // It creates a rudimentary .int file in the first Data folder of the psDataPath property.
85515>>>    Function SqlUtilCreateIntFile Handle hTable String sDriverID String sConnectionID Boolean bAnsi Boolean bSysFile Returns Boolean
85517>>>        Boolean bOK bExists bUseConnectionID bMertech
85517>>>        String sDataPath sRootName sLogicalName sPhysicalFileName sConnectionString sDatabaseName sSchemaName sANSI_OEM
85517>>>        String[] sIndexArray
85518>>>        Integer iCount iCh iSize
85518>>>
85518>>>        Move (Trim(sConnectionID) <> "") to bUseConnectionID
85519>>>        Get psConnectionString to sConnectionString
85520>>>
85520>>>        Move CS_ANSI_Txt to sANSI_OEM
85521>>>        If (bANSI = False) Begin
85523>>>            Move CS_OEM_Txt to sANSI_OEM
85524>>>        End
85524>>>>
85524>>>
85524>>>        Get psDataPathFirstPart to sDataPath
85525>>>        Get vFolderExists sDataPath to bOK
85526>>>        If (bOK = False) Begin
85528>>>            Error DFERR_PROGRAM "Function SqlUtilCreateIntFile; psDataPath not found!"
85529>>>>
85529>>>            Function_Return False
85530>>>        End
85530>>>>
85530>>>        Get vFolderFormat sDataPath to sDataPath
85531>>>
85531>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85534>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
85537>>>        Get _TableNameOnly sRootName to sDatabaseName
85538>>>        Move sLogicalName  to sPhysicalFileName
85539>>>        Move (sPhysicalFileName + ".int") to sPhysicalFileName
85540>>>
85540>>>        Get IsMertechDriver sDriverID to bMertech
85541>>>        If (bMertech = True) Begin
85543>>>            // This should not be called here. Instead it is called by the SqlUtilUpdateIntFile!
85543>>>            // Else it will create an error in the error log (although it won't do anything...)
85543>>>            // Get _MertechSqlUtilCreateIntFile hTable sDataPath sPhysicalFileName to bOK
85543>>>            Function_Return (bOK = True)
85544>>>        End
85544>>>>
85544>>>
85544>>>        Get psSchema hTable to sSchemaName
85545>>>        If (sSchemaName = "") Begin
85547>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchemaName
85548>>>        End
85548>>>>
85548>>>
85548>>>        // If the .int file already exists; we rename it to "FileName" + ".bak"
85548>>>        Get vFilePathExists (sDataPath + sPhysicalFileName) to bExists
85549>>>        If (bExists = True) Begin
85551>>>            Get vRenameFile (sDataPath + sPhysicalFileName) (sDataPath + sPhysicalFileName + ".bak") to bOK
85552>>>        End
85552>>>>
85552>>>
85552>>>        Get UtilDeleteCacheFile sRootName to bOK
85553>>>        Get SqlUtilEnumerateIndexes sRootName sDriverID to sIndexArray
85554>>>
85554>>>        Get Seq_Open_Output_Channel (sDataPath + sPhysicalFileName) to iCh
85555>>>            Writeln channel iCh CS_DRIVER_NAME     " " sDriverID
85560>>>            If (bUseConnectionID = True) Begin
85562>>>                Writeln channel iCh CS_SERVER_NAME " " CS_DFCONNID "=" sConnectionID
85569>>>            End
85569>>>>
85569>>>            Else Begin
85570>>>                Writeln channel iCh CS_SERVER_NAME " " CS_SERVER "=" sConnectionString
85577>>>            End
85577>>>>
85577>>>            Writeln channel iCh CS_DATABASE_NAME          " " sDatabaseName
85582>>>            Writeln channel iCh CS_SCHEMA_NAME            " " (Lowercase(sSchemaName))
85587>>>            // There seems to be a new order how these are set from DF19.
85587>>>            If (bSysFile = True) Begin
85589>>>                Writeln channel iCh CS_RECNUM_TABLE       " " "NO"
85594>>>            End
85594>>>>
85594>>>            Writeln channel iCh CS_TABLE_CHARACTER_FORMAT " " sANSI_OEM
85599>>>            Writeln channel iCh CS_USE_DUMMY_ZERO_DATE    " " "YES" // ToDo: We maybe need to paramerize this setting?
85604>>>            If (bSysFile = True) Begin
85606>>>                Writeln channel iCh CS_SYSTEM_FILE        " " "YES"
85611>>>            End
85611>>>>
85611>>>
85611>>>            If (bSysFile = False) Begin
85613>>>                Move (SizeOfArray(sIndexArray)) to iSize
85614>>>                Move (SortArray(sIndexArray)) to sIndexArray
85615>>>                If (iSize > 0) Begin
85617>>>                    Writeln channel iCh (CS_PRIMARY_INDEX * String("0"))
85620>>>                    Writeln channel iCh // Just an empty line
85622>>>                End
85622>>>>
85622>>>                Decrement iSize
85623>>>                For iCount from 0 to iSize
85629>>>>
85629>>>                    Writeln channel iCh (CS_INDEX_NUMBER * String(iCount))
85632>>>                    Writeln channel iCh (CS_INDEX_NAME   * String(sIndexArray[iCount]))
85635>>>                    Writeln channel iCh
85637>>>                Loop
85638>>>>
85638>>>            End
85638>>>>
85638>>>        Send Seq_Close_Channel iCh
85639>>>
85639>>>        // Wait a sec for Windows to finish writing the file:
85639>>>        Sleep 1
85640>>>
85640>>>        Function_Return (bOK = True)
85641>>>    End_Function
85642>>>
85642>>>    // Returns a handle to the SQL server associated with the passed driver ID.
85642>>>    // Pass e.g. the psServer property to determine the current connection server.
85642>>>    // Returns a handle to the database connection, or a zero (0) if it fails.
85642>>>    // This handle can be used to obtain attributes about the server, such as default
85642>>>    // column types.
85642>>>    Function SqlUtilDatabaseHandle String sDriverID String sServer Returns Handle
85644>>>        Handle hDatabase
85644>>>        Integer iDriver iServers iCount
85644>>>        String sValue
85644>>>
85644>>>        If (sServer = "") Begin
85646>>>            Function_Return 0
85647>>>        End
85647>>>>
85647>>>
85647>>>        Get DriverIndex sDriverID to iDriver
85648>>>        If (iDriver = 0) Begin
85650>>>            Function_Return 0
85651>>>        End
85651>>>>
85651>>>
85651>>>        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iServers
85654>>>        For iCount from 1 to iServers
85660>>>>
85660>>>            Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
85663>>>            If (Uppercase(sValue) contains Uppercase(sServer)) Begin
85665>>>                Get_Attribute DF_DATABASE_ID of iDriver iCount to hDatabase
85668>>>            End
85668>>>>
85668>>>        Loop
85669>>>>
85669>>>
85669>>>        Function_Return hDatabase
85670>>>    End_Function
85671>>>
85671>>>//    Function UtilIsFilelistEntryDriverBased Integer hTable String sDriverID Returns Boolean
85671>>>//        String sRootName
85671>>>//        Boolean bOK
85671>>>//
85671>>>//        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
85671>>>//        Move (sRootName contains sDriverID) to bOK
85671>>>//
85671>>>//        Function_Return bOK
85671>>>//    End_Function
85671>>>
85671>>>//    Function UtilFilelistAddDriverInfo Integer hTable Returns Boolean
85671>>>//        String sDriverID sRootName sDisplayName sSchema sVal
85671>>>//        Integer iDbType
85671>>>//        Boolean bOK
85671>>>//
85671>>>//        Get UtilIsFilelistEntryDriverBased to bOK
85671>>>//        If (bOK = True) Begin
85671>>>//            Function_Return False
85671>>>//        End
85671>>>//
85671>>>//        Get psDriverID to sDriverID
85671>>>//        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85671>>>//        Move (sDriverID + ":" + sRootName)           to sRootName
85671>>>//        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85671>>>//
85671>>>//        Get psDriverID to sDriverID
85671>>>//        Get piDbType   to iDbType
85671>>>//        Get psSchema   to sSchema
85671>>>//        If (sSchema = "") Begin
85671>>>//            Get _SqlFindKeyWord CI_SQLDBO to sSchema
85671>>>//        End
85671>>>//
85671>>>//        Move (Uppercase(sDisplayName)) to sVal
85671>>>//        If (not(sVal contains (sSchema + "."))) Begin
85671>>>//            If (iDbType = EN_dbTypeDB2) Begin
85671>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
85671>>>//            End
85671>>>//            Else Begin
85671>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
85671>>>//            End
85671>>>//        End
85671>>>//
85671>>>//        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85671>>>//        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85671>>>//
85671>>>//        Function_Return True
85671>>>//    End_Function
85671>>>
85671>>>    // Removes all driver identifications (e.g. "MSSQLDRV;MyTable" or "MyTable.MSSQLDRV"
85671>>>    // from the passed filelist.
85671>>>    // Returns the number of tables affected.
85671>>>    Function SqlUtilFilelistRemoveDriverInfo String sFilelist Returns Integer
85673>>>        String sCurrentFileList sRootName sDisplayName sLogicalName sVal
85673>>>        Integer iRetval
85673>>>        Handle hTable
85673>>>
85673>>>        // We first save the current filelist as the passed filelist name
85673>>>        // may come from another workspace, to restore it when we're ready.
85673>>>        Get_Attribute DF_FILELIST_NAME to sCurrentFileList
85676>>>        Set_Attribute DF_FILELIST_NAME to sFilelist
85679>>>        Move 0 to hTable
85680>>>        Move 0 to iRetval
85681>>>
85681>>>        Repeat
85681>>>>
85681>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
85684>>>            If (hTable <> 0) Begin
85686>>>                Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85689>>>                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85692>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
85695>>>                Move (Uppercase(sRootName)) to sVal
85696>>>                If (sVal contains MSSQLDRV_ID or sVal contains DB2_DRV_ID or sVal contains ODBC_DRV_ID) Begin
85698>>>                    // Prefixes:
85698>>>                    Move (Replace((MSSQLDRV_ID + ":"), sRootName, "")) to sRootName
85699>>>                    Move (Replace((DB2_DRV_ID  + ":"), sRootName, "")) to sRootName
85700>>>                    Move (Replace((ODBC_DRV_ID + ":"), sRootName, "")) to sRootName
85701>>>                    // Suffixes:
85701>>>                    Move (Replace(("." + MSSQLDRV_ID), sRootName, "")) to sRootName
85702>>>                    Move (Replace(("." + DB2_DRV_ID),  sRootName, "")) to sRootName
85703>>>                    Move (Replace(("." + ODBC_DRV_ID), sRootName, "")) to sRootName
85704>>>
85704>>>                    // Change Filelist entry:
85704>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable          to sRootName
85707>>>
85707>>>                    Move (Lowercase(sDisplayName)) to sVal
85708>>>                    If (sVal contains "dbo.") Begin
85710>>>                        Move (Replace("dbo.", sDisplayName, ""))       to sDisplayName
85711>>>
85711>>>                        // Change Filelist entry:
85711>>>                        Set_Attribute DF_FILE_DISPLAY_NAME of hTable   to sDisplayName
85714>>>                    End
85714>>>>
85714>>>                    Increment iRetval
85715>>>                End
85715>>>>
85715>>>            End
85715>>>>
85715>>>        Until (hTable = 0)
85717>>>
85717>>>        Set_Attribute DF_FILELIST_NAME to sCurrentFileList
85720>>>
85720>>>        Function_Return iRetval
85721>>>    End_Function
85722>>>
85722>>>    // To open all Sql based tables in Filelist.cfg
85722>>>    Procedure SqlUtilOpenAllTables
85724>>>        Handle hTable
85724>>>        String sRoot sDriverID
85724>>>        Boolean bOK
85724>>>
85724>>>        Move 0 to hTable
85725>>>        Move "" to sDriverID
85726>>>        Get AutoConnectionIDLogin to bOK
85727>>>
85727>>>        Repeat
85727>>>>
85727>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
85730>>>            If (hTable > 0) Begin
85732>>>                Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
85735>>>                If (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) Begin
85737>>>                    Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
85740>>>                    If (Uppercase(sRoot) contains ".INT" or Uppercase(sRoot) contains MSSQLDRV_ID or Uppercase(sRoot) contains DB2_DRV_ID or Uppercase(sRoot) contains ODBC_DRV_ID) Begin
85742>>>                        Open hTable
85744>>>                    End
85744>>>>
85744>>>                End
85744>>>>
85744>>>            End
85744>>>>
85744>>>
85744>>>        Until (hTable = 0)
85746>>>    End_Procedure
85747>>>
85747>>>//    Function SqlUtilSchemaName Handle hTable Returns String
85747>>>//        String sRetval sDriverID
85747>>>//        String sTableName
85747>>>//        Integer iDbType iIndex
85747>>>//        Boolean bOK
85747>>>//
85747>>>//        Get psDriverID to sDriverID
85747>>>//        Get _SqlCheckCurrentDriver sDriverID to bOK
85747>>>//        If (hTable = 0 or bOK = False) Begin
85747>>>//            Function_Return ""
85747>>>//        End
85747>>>//
85747>>>//        Move False to Err
85747>>>//        Get UtilTableHandleToString hTable to sTableName
85747>>>//        Get piDbType to iDbType
85747>>>//        Get _SqlUtilEnumerateTableIndex sTableName sDriverID to iIndex
85747>>>//        If (iIndex = -1) Begin
85747>>>//            Function_Return ""
85747>>>//        End
85747>>>//
85747>>>//        Function_Return sRetval
85747>>>//    End_Function
85747>>>
85747>>>    // Checks if the passed Table;
85747>>>    // 1) Already has a Filelist entry that points to SQL and
85747>>>    // 2) It has an .int file.
85747>>>    // If both is True it should already be connected to SQL
85747>>>    Function SqlUtilTableIsAttached String sDriverID Handle hTable Returns Boolean
85749>>>        Boolean bExists bRootName
85749>>>        String sRootName sDataPath
85749>>>
85749>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
85752>>>        Move (sRootName contains sDriverID) to bRootName
85753>>>
85753>>>        Get psDataPathFirstPart to sDataPath
85754>>>        Get vFolderExists sDataPath to bExists
85755>>>        If (bExists = False) Begin
85757>>>            // If the path doesn't exist it cannot have an .int file and we're done, although it shouldn't happen.
85757>>>            Function_Return False
85758>>>        End
85758>>>>
85758>>>
85758>>>        Get vFolderFormat sDataPath to sDataPath
85759>>>        Get _TableNameOnly sRootName to sRootName
85760>>>        Get vFilePathExists (sDataPath + sRootName + ".int") to bExists
85761>>>
85761>>>        Function_Return (bRootName = True and bExists = True)
85762>>>    End_Function
85763>>>
85763>>>    Function SqlUtilTableIsViewType String sDriverID Handle hTable Returns Boolean
85765>>>        Boolean bViewTableType bOpen bOK
85765>>>        Integer iTableCount iNumTables
85765>>>        String sTableName sOwner sTableType sEnumTableName sEnumSchemaName
85765>>>        Handle hoCliHandler
85765>>>        tSQLConnection SQLConnection
85765>>>        tSQLConnection SQLConnection
85765>>>
85765>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
85768>>>        If (bOpen = False) Begin
85770>>>            Get AutoConnectionIDLogin to bOK
85771>>>            Open hTable
85773>>>        End
85773>>>>
85773>>>
85773>>>        Get pSQLConnection to SQLConnection
85774>>>        Get phoCLIHandler to hoCliHandler
85775>>>        Set psDriverID of hoCliHandler to sDriverID
85776>>>
85776>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
85779>>>        Get _TableNameOnly sTableName to sTableName
85780>>>        Get_Attribute DF_FILE_OWNER     of hTable to sOwner
85783>>>        Get EnumerateTables of hoCliHandler SQLConnection.sConnectionString to iNumTables
85784>>>
85784>>>        For iTableCount from 1 to iNumTables
85790>>>>
85790>>>            Get TableName  of hoCliHandler iTableCount to sEnumTableName
85791>>>            Get SchemaName of hoCliHandler iTableCount to sEnumSchemaName
85792>>>            If ((Uppercase(sEnumTableName)  = Uppercase(sTableName)) and (Uppercase(sEnumSchemaName) = Uppercase(sOwner))) Begin
85794>>>                Get TableType of hoCliHandler iTableCount to sTableType
85795>>>                Move iNumTables to iTableCount // We're done.
85796>>>            End
85796>>>>
85796>>>        Loop
85797>>>>
85797>>>
85797>>>        Move (sTableType = "VIEW") to bViewTableType
85798>>>        If (bOpen = False) Begin
85800>>>            Close hTable
85801>>>        End
85801>>>>
85801>>>
85801>>>        Function_Return bViewTableType
85802>>>    End_Function
85803>>>
85803>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
85803>>>    //
85803>>>    // SQL utility function that returns a database type (string) constant
85803>>>    // corresponding to the passed iDbType.
85803>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
85805>>>        String sRetval
85805>>>        Get SqlUtilDbTypeToString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
85806>>>        Function_Return sRetval
85807>>>    End_Function
85808>>>
85808>>>    // SQL utility function that returns a database type constant (integer)
85808>>>    // corresponding to the passed sDbType string constant.
85808>>>    Function SqlUtilDbTypeToInteger String sDbType Returns Integer
85810>>>        Integer iRetval
85810>>>        Get SqlUtilDbTypeToInteger of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDbType to iRetval
85811>>>        Function_Return iRetval
85812>>>    End_Function
85813>>>
85813>>>    // Pass an integer DbType and function returns the database type integer as a string value.
85813>>>    // Used e.g. when reading a connection ini-file to display the database type in
85813>>>    // the SQL Connection program's grid.
85813>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
85815>>>        String sRetval
85815>>>        Get SqlUtilDbTypeIntegerToStringConstant of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
85816>>>        Function_Return sRetval
85817>>>    End_Function
85818>>>
85818>>>    // Pass a driver name as a string and the function will return
85818>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
85818>>>    // quite work and always returns "MS SQL Server"
85818>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
85820>>>        Integer iRetval
85820>>>        Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverID to iRetval
85821>>>        Function_Return iRetval
85822>>>    End_Function
85823>>>
85823>>>    // Returns a temp table name that consists of the RootName, an underscore and as much of a GUID
85823>>>    // that "fits" in the max allowed length for table names.
85823>>>    // Max number of characters allowed for table names;
85823>>>    // IBM DB2      = 128
85823>>>    // MS-SQL       = 128
85823>>>    // Oracle       = 128 (Version 12.2 and later. 30 characters for earlier versions)
85823>>>    // MySQL        = 64
85823>>>    // PostgreSQL   = 64
85823>>>    Function SqlUtilGUIDTempTableName String sRootName Returns String
85825>>>        String sGUIDName
85825>>>        Integer iDbType iLength
85825>>>
85825>>>        Get piDbType to iDbType
85826>>>        Move (RandomHexUUID()) to sGUIDName
85827>>>        Move (sRootName + "_" + sGUIDName) to sGUIDName
85828>>>        Move (Length(sGUIDName)) to iLength
85829>>>
85829>>>        Case Begin
85829>>>            Case (iDbType = EN_DbTypeDB2)
85831>>>            If (iLength > 128) Begin
85833>>>                Move (Left(sGUIDName, 128)) to sGUIDName
85834>>>            End
85834>>>>
85834>>>            Case Break
85835>>>
85835>>>            Case (iDbType = EN_DbTypeMSSQL)
85838>>>            If (iLength > 128) Begin
85840>>>                Move (Left(sGUIDName, 128)) to sGUIDName
85841>>>            End
85841>>>>
85841>>>            Case Break
85842>>>
85842>>>            Case (iDbType = EN_DbTypeOracle) // Note: We assume an Oracle version of 12.2 or later.
85845>>>            If (iLength > 128) Begin
85847>>>                Move (Left(sGUIDName, 128)) to sGUIDName
85848>>>            End
85848>>>>
85848>>>            Case Break
85849>>>
85849>>>            Case (iDbType = EN_DbTypeMySQL)
85852>>>            If (iLength > 64) Begin
85854>>>                Move (Left(sGUIDName, 64)) to sGUIDName
85855>>>            End
85855>>>>
85855>>>            Case Break
85856>>>
85856>>>            Case (iDbType = EN_DbTypePostgre)
85859>>>            If (iLength > 64) Begin
85861>>>                Move (Left(sGUIDName, 64)) to sGUIDName
85862>>>            End
85862>>>>
85862>>>        Case End
85862>>>
85862>>>        Function_Return sGUIDName
85863>>>    End_Function
85864>>>
85864>>>    // Reads a resource that has been embedded by the compiler and writes it to disk.
85864>>>    // Pass the memory resource file reference and the filename to be created,
85864>>>    // including full path.
85864>>>    Procedure SqlUtilCreateFileFromMemory String sMemFileName String sFileName
85866>>>        String sText
85866>>>        Integer iCh iSize iArgSize
85866>>>
85866>>>        Move ("Resource:" + sMemFileName) to sMemFileName
85867>>>        Get Seq_Open_Input_Channel sMemFileName to iCh
85868>>>            Get_Channel_Size iCh to iSize
85869>>>            Get_Argument_Size to iArgSize
85870>>>            If (iSize > iArgSize) Begin
85872>>>                Set_Argument_Size iSize
85873>>>>
85873>>>            End
85873>>>>
85873>>>            Read_Block channel iCh sText iSize
85875>>>        Send Seq_Close_Channel iCh
85876>>>
85876>>>        Get Seq_Open_Output_Channel sFileName to iCh
85877>>>            Write channel iCh sText
85879>>>        Send Seq_Close_Channel iCh
85880>>>
85880>>>        If (iSize <> iArgSize) Begin
85882>>>            Set_Argument_Size iArgSize
85883>>>>
85883>>>        End
85883>>>>
85883>>>
85883>>>        // Wait for file to be written to disk.
85883>>>        Sleep 2
85884>>>    End_Procedure
85885>>>
85885>>>    Function SqlUtilDefaultNullValue String sDriverID Integer iDbType Integer iDataType Returns String
85887>>>        String sNotNull sRetval sDefaultValue
85887>>>        Boolean bOK
85887>>>
85887>>>        Get IsSQLDriver sDriverID to bOK
85888>>>        If (bOK = False) Begin
85890>>>            Function_Return ""
85891>>>        End
85891>>>>
85891>>>
85891>>>        Get UtilDataTypeDefaultValue sDriverID iDbType iDataType to sDefaultValue
85892>>>        Get _SqlFindKeyWord CI_SQLNotNull to sNotNull
85893>>>
85893>>>        Case Begin
85893>>>            Case (iDbType = EN_dbTypeMSSQL)
85895>>>                Move ("DEFAULT" * String(sDefaultValue) * String(sNotNull)) to sRetval
85896>>>                Case Break
85897>>>            Case (iDbType = EN_dbTypeMySQL)
85900>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
85901>>>                Case Break
85902>>>            Case (iDbType = EN_dbTypePostgre)
85905>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
85906>>>                Case Break
85907>>>            Case (iDbType = EN_dbTypeDB2)
85910>>>                Move (String(sNotNull))                                     to sRetval
85911>>>                Case Break
85912>>>
85912>>>            // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
85912>>>            // ToDo: We need to look deeper into how Oracle handles NULL
85912>>>            Case (iDbType = EN_dbTypeOracle)
85915>>>                Move  ""                                                    to sRetval
85916>>>                Case Break
85917>>>
85917>>>            Case Else
85917>>>                Move  ""                                                    to sRetval
85918>>>        Case End
85918>>>
85918>>>        Function_Return sRetval
85919>>>    End_Function
85920>>>
85920>>>    Function SqlUtilUpdateIntFile Integer hTable Returns Boolean
85922>>>        String sOrgFormat sNewFormat sRootName sDatabaseName sPhysicalFileName sDriverID sDataPath
85922>>>        Boolean bOpened bOK bMertech
85922>>>
85922>>>        // For some reason this .int file update screws up of CodeMast & CodeType .int files
85922>>>        // which makes the program unable to run because they can't be opened.
85922>>>        // ToDo: This needs further investigation but for now we just skip CodeMast & CodeType .int files update...
85922>>>        // Also note that there is another helper function "UtilTableCreateCodeMastCodeTypeIntFiles" to create
85922>>>        // proper .int files for the two tables.
85922>>>        If (Uppercase(sDatabaseName) = "CODETYPE" or Uppercase(sDatabaseName) = "CODEMAST") Begin
85924>>>            Function_Return True
85925>>>        End
85925>>>>
85925>>>
85925>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
85928>>>        Get _TableNameOnly sRootName to sDatabaseName
85929>>>        Move CS_OEM_Txt  to sOrgFormat
85930>>>        Move CS_ANSI_Txt to sNewFormat
85931>>>        Get AutoConnectionIDLogin to bOK
85932>>>
85932>>>        // It seems this can be called to quickly; causing a 13001 error "Cannot open cache file for write"
85932>>>        Sleep 2
85933>>>        Get OpenTableExclusive hTable to bOpened
85934>>>        If (bOpened = False) Begin
85936>>>            Function_Return False
85937>>>        End
85937>>>>
85937>>>
85937>>>        Get psDriverID to sDriverID
85938>>>        Get IsMertechDriver sDriverID to bMertech
85939>>>        If (bMertech = True) Begin
85941>>>            Get psDataPathFirstPart to sDataPath
85942>>>            Get vFolderExists sDataPath to bOK
85943>>>            If (bOK = False) Begin
85945>>>                Error DFERR_PROGRAM "Function SqlUtilUpdateIntFile; psDataPath not found!"
85946>>>>
85946>>>                Function_Return False
85947>>>            End
85947>>>>
85947>>>            Get vFolderFormat sDataPath to sDataPath
85948>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
85951>>>            Get _TableNameOnly sRootName to sDatabaseName
85952>>>            Move sDatabaseName to sPhysicalFileName
85953>>>            Move (sPhysicalFileName + ".int") to sPhysicalFileName
85954>>>            Get _MertechSqlUtilCreateIntFile hTable sDataPath sPhysicalFileName to bOK
85955>>>            Function_Return (bOK = True)
85956>>>        End
85956>>>>
85956>>>
85956>>>        Move False to Err
85957>>>        Get_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
85960>>>        Move (Uppercase(sOrgFormat)) to sOrgFormat
85961>>>        // Lets swap the OEM/ANSI format, just to make a change in Structure_Start below (and back),
85961>>>        // to "touch" the table so the driver feels there has been a change and updates the .int file.
85961>>>        Move (If(sOrgFormat = CS_OEM_Txt, CS_ANSI_Txt, CS_OEM_Txt)) to sNewFormat
85962>>>
85962>>>        If (hTable > 0) Begin
85964>>>            Structure_Start hTable
85965>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
85968>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
85971>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85973>>>        End
85973>>>>
85973>>>        Else Begin
85974>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
85977>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
85980>>>        End
85980>>>>
85980>>>        Function_Return (Err = False)
85981>>>    End_Function
85982>>>
85982>>>    Function SqlProcedureArrayMertech String sStmt String sArgument Returns String[]
85984>>>        String[] sReturnArray
85985>>>        String sValue sUserID sPassword
85985>>>        Handle hoSQLHandler hoSQLConnect hStmt
85985>>>        Integer iFetchResult iRetval
85985>>>        tSQLConnection SQLConnection
85985>>>        tSQLConnection SQLConnection
85985>>>
85985>>>        Get _MertechSQLManagerHandle to hoSQLHandler
85986>>>        If (hoSQLHandler <> 0) Begin
85988>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85989>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
85990>>>            If (hoSQLConnect <> 0) Begin
85992>>>                Get SQLOpen of hoSQLConnect to hStmt
85993>>>                If (hStmt <> 0) Begin
85995>>>                    Send SQLSetProcedureName of hStmt sStmt
85996>>>                    If (sArgument <> "") Begin
85998>>>                        Send SqlSetArgument  of hStmt 1 sArgument
85999>>>                    End
85999>>>>
85999>>>                    Send SQLCall of hStmt
86000>>>
86000>>>                    Get SqlReturnValue       of hStmt to iRetval
86001>>>                    If (iRetval = 0) Begin
86003>>>                        Repeat
86003>>>>
86003>>>                            Get SQLFetch of hStmt to iFetchResult
86004>>>                            If (iFetchResult <> 0) Begin
86006>>>                                Get SQLColumnValue of hStmt 1 to sValue
86007>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
86008>>>                            End
86008>>>>
86008>>>                        Until (iFetchResult = 0)
86010>>>                        Send SQLClose of hStmt
86011>>>                    End
86011>>>>
86011>>>                End
86011>>>>
86011>>>                Send SQLDisconnect of hoSQLConnect
86012>>>            End
86012>>>>
86012>>>        End
86012>>>>
86012>>>
86012>>>        Function_Return sReturnArray
86013>>>    End_Function
86014>>>
86014>>>    // * Dummy function for the Studio's Code Explorer *
86014>>>    Function SQL_ENUMERATION_FUNCTIONS Returns Boolean
86016>>>        Function_Return False
86017>>>    End_Function
86018>>>
86018>>>    // Enumerate SQL Servers.
86018>>>    // Pass a driver id. Returns a string array.
86018>>>    // The iDataSourceType (iDatSrcType) parameter is optional and is for the ODBC driver only.
86018>>>    // Note: Returns servers for MSSQLDRV; else data-sources on the machine.
86018>>>    Function SqlUtilEnumerateServers String sDriverID Integer iDatSrcType Returns String[]
86020>>>        String[] sReturnArray
86021>>>        Handle hoSQLHandler
86021>>>        String sServer
86021>>>        Integer iCount iNumItems iDataSourceType
86021>>>
86021>>>        If (num_arguments > 1) Begin
86023>>>            Move iDatSrcType to iDataSourceType
86024>>>        End
86024>>>>
86024>>>
86024>>>        Case Begin
86024>>>            Case (sDriverID = MSSQLDRV_ID)
86026>>>                Get phoMSSQLHandler to hoSQLHandler
86027>>>                // Not sure why, but this doesn't seem to work with the updated DAW MSSQLDRV driver.
86027>>>//                #IFNDEF get_ComparetConnectionById
86027>>>//                    Get EnumerateServers of hoSQLHandler to iNumItems
86027>>>//                #ELSE
86027>>>//                    Get EnumerateServersLocal of hoSQLHandler to iNumItems
86027>>>//                    If (iNumItems = 0) Begin
86027>>>                        Get EnumerateServers of hoSQLHandler to iNumItems
86028>>>//                    End
86028>>>//                #ENDIF
86028>>>                For iCount from 0 to (iNumItems - 1)
86034>>>>
86034>>>                    Get String_Value of hoSQLHandler item iCount to sServer
86035>>>                    Move (Trim(sServer)) to sReturnArray[iCount]
86036>>>                Loop
86037>>>>
86037>>>                Case Break
86038>>>
86038>>>            Case (sDriverID = DB2_DRV_ID)
86041>>>                Get phoDB2SQLHandler to hoSQLHandler
86042>>>                Send SeedDataSources of hoSQLHandler
86043>>>                Move 0 to iCount
86044>>>                Repeat
86044>>>>
86044>>>                    Get DataSources of hoSQLHandler to sServer
86045>>>                    If (sServer <> "") Begin
86047>>>                        Move (Replace(",", sServer, "")) to sServer
86048>>>                        Move sServer to sReturnArray[iCount]
86049>>>                    End
86049>>>>
86049>>>                    Increment iCount
86050>>>                Until (sServer = "")
86052>>>                Case Break
86053>>>
86053>>>            Case (sDriverID = ODBC_DRV_ID)
86056>>>                Get phoODBCSQLHandler to hoSQLHandler
86057>>>                Set DataSourceType of hoSQLHandler to iDataSourceType
86058>>>                Move 0 to iCount
86059>>>                Repeat
86059>>>>
86059>>>                    Get DataSources of hoSQLHandler to sServer
86060>>>                    If (sServer <> "") Begin
86062>>>                        Move (Replace(",", sServer, ", ")) to sServer
86063>>>                        Move sServer to sReturnArray[iCount]
86064>>>                    End
86064>>>>
86064>>>                    Increment iCount
86065>>>                Until (sServer = "")
86067>>>                Case Break
86068>>>
86068>>>            Case (sDriverID = SQLFLEX)
86071>>>                Get _MertechEnumerateSQLFlexServers to sReturnArray
86072>>>                Case Break
86073>>>
86073>>>            Case (sDriverID = ORAFLEX)
86076>>>                Get _MertechEnumerateORAFLEXServers to sReturnArray
86077>>>                Case Break
86078>>>
86078>>>            // There appearantly is no way to enumerate servers for this backend.
86078>>>            Case (sDriverID = MDSPgSQL)
86081>>>                Move "localhost" to sReturnArray[0]
86082>>>                Case Break
86083>>>
86083>>>            // There appearantly is no way to enumerate servers for this backend.
86083>>>            Case (sDriverID = MDSMySQL)
86086>>>                Move "localhost" to sReturnArray[0]
86087>>>                Case Break
86088>>>
86088>>>            Case Else
86088>>>                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateServers function"
86089>>>>
86089>>>        Case End
86089>>>
86089>>>        Function_Return sReturnArray
86090>>>    End_Function
86091>>>
86091>>>    // Returns all databases as a string array for the passed driver id.
86091>>>    Function SqlUtilEnumerateDatabases String sDriverID Returns String[]
86093>>>        String[] sReturnArray
86094>>>        Boolean bOK
86094>>>
86094>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
86095>>>        If (bOK = False) Begin
86097>>>            Function_Return sReturnArray
86098>>>        End
86098>>>>
86098>>>
86098>>>        Case Begin
86098>>>            Case (sDriverID = MSSQLDRV_ID)
86100>>>                Get _SqlDatabasesArrayMSSQL to sReturnArray
86101>>>                Case Break
86102>>>            Case (sDriverID = DB2_DRV_ID)
86105>>>                Get _SqlDatabasesArrayDB2 to sReturnArray
86106>>>                Case Break
86107>>>
86107>>>            // Enumeration of ODBC databases should be irrelevant as the database
86107>>>            // should have been specified when the ODBC source was setup with the ODBC manager.
86107>>>            Case (sDriverID = ODBC_DRV_ID)
86110>>>                Case Break
86111>>>
86111>>>            Case (sDriverID = SQLFLEX)
86114>>>                Get SqlProcedureArrayMertech "sp_databases" "" to sReturnArray
86115>>>                Case Break
86116>>>
86116>>>            Case (sDriverID = MDSPgSQL)
86119>>>                Get SqlEnumerateEsqlMertech "SELECT datname FROM pg_database" to sReturnArray
86120>>>                Case Break
86121>>>
86121>>>            Case (sDriverID = MDSMySQL)
86124>>>                Get SqlEnumerateEsqlMertech "show databases" to sReturnArray
86125>>>                Case Break
86126>>>
86126>>>            Case (sDriverID = ORAFLEX)
86129>>>                Get SqlEnumerateEsqlMertech "SELECT NAME FROM v$database" to sReturnArray
86130>>>                Case Break
86131>>>
86131>>>            Case Else
86131>>>                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateDatabases function"
86132>>>>
86132>>>        Case End
86132>>>
86132>>>        Function_Return sReturnArray
86133>>>    End_Function
86134>>>
86134>>>    // Returns all table spaces as a string array for the passed driver id.
86134>>>    Function SqlUtilEnumerateTableSpaces String sDriverID Returns String[]
86136>>>        String[] sReturnArray
86137>>>        Boolean bOK
86137>>>
86137>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
86138>>>        If (bOK = False) Begin
86140>>>            Function_Return sReturnArray
86141>>>        End
86141>>>>
86141>>>
86141>>>        Case Begin
86141>>>            Case (sDriverID = DB2_DRV_ID)
86143>>>                Get SqlEnumerateEsqlDAW "select tablespace_name from dba_tablespaces" 1 to sReturnArray
86144>>>                Case Break
86145>>>
86145>>>            Case (sDriverID = MDSPgSQL)
86148>>>                Get SqlEnumerateEsqlMertech "SELECT spcname FROM pg_tablespace" 1 to sReturnArray
86149>>>                Case Break
86150>>>
86150>>>            Case (sDriverID = ORAFLEX)
86153>>>                Get SqlEnumerateEsqlMertech "SELECT TABLESPACE_NAME FROM USER_TABLESPACES" 1 to sReturnArray
86154>>>                Case Break
86155>>>
86155>>>            Case Else
86155>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateTableSpaces function."
86156>>>>
86156>>>                Case Break
86157>>>        Case End
86157>>>
86157>>>        Function_Return sReturnArray
86158>>>    End_Function
86159>>>
86159>>>    // Returns all schemas as a string array for the passed driver id.
86159>>>    Function SqlUtilEnumerateSchemas String sDriverID Returns String[]
86161>>>        String[] sReturnArray
86162>>>        Boolean bOK
86162>>>
86162>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
86163>>>        If (bOK = False) Begin
86165>>>            Function_Return sReturnArray
86166>>>        End
86166>>>>
86166>>>
86166>>>        Case Begin
86166>>>            Case (sDriverID = DB2_DRV_ID)
86168>>>                Get SqlEnumerateEsqlDAW "select schemaname from syscat.schemata" 1 to sReturnArray
86169>>>                Case Break
86170>>>
86170>>>            Case (sDriverID = MDSPgSQL)
86173>>>                Get SqlEnumerateEsqlMertech "select schema_name from information_schema.schemata" 1 to sReturnArray
86174>>>                Case Break
86175>>>
86175>>>            Case (sDriverID = ORAFLEX)
86178>>>                Get SqlEnumerateEsqlMertech "SELECT username from dba_users WHERE default_tablespace not in ('SYSTEM','SYSAUX')" 1 to sReturnArray
86179>>>                Case Break
86180>>>
86180>>>            Case Else
86180>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateSchemas function."
86181>>>>
86181>>>                Case Break
86182>>>        Case End
86182>>>
86182>>>        Function_Return sReturnArray
86183>>>    End_Function
86184>>>
86184>>>    // Returns a string array with all tables for the current database.
86184>>>    Function SqlUtilEnumerateTables String sDriverID Returns String[]
86186>>>        String[] sReturnArray sArray
86188>>>        String sDatabase sConnectionString sSelect sSchema
86188>>>        Integer iSize iCount
86188>>>        Boolean bOK
86188>>>
86188>>>        If (sDriverID = DATAFLEX_ID) Begin
86190>>>            Function_Return sArray
86191>>>        End
86191>>>>
86191>>>
86191>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
86192>>>        If (bOK = False) Begin
86194>>>            Function_Return sReturnArray
86195>>>        End
86195>>>>
86195>>>
86195>>>        Get psConnectionString to sConnectionString
86196>>>        Get psDatabase to sDatabase
86197>>>        Get psSchema   to sSchema
86198>>>
86198>>>        Case Begin
86198>>>            Case (sDriverID = MSSQLDRV_ID)
86200>>>                Get _SqlTableArrayDAW to sReturnArray
86201>>>                Case Break
86202>>>
86202>>>            Case (sDriverID = DB2_DRV_ID)
86205>>>                Get _SqlTableArrayDAW to sReturnArray
86206>>>                Case Break
86207>>>
86207>>>            Case (sDriverID = ODBC_DRV_ID)
86210>>>                Get _SqlTableArrayDAW to sReturnArray
86211>>>                Case Break
86212>>>
86212>>>            Case (sDriverID = SQLFLEX)
86215>>>                Move ("SELECT TABLE_NAME FROM" * sDatabase + ".INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE != 'VIEW'") to sSelect
86216>>>                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
86217>>>                Case Break
86218>>>
86218>>>            Case (sDriverID = MDSMySQL)
86221>>>                Move ("SELECT TABLE_NAME from INFORMATION_SCHEMA.TABLES where TABLE_SCHEMA = '" + sDatabase + "' and TABLE_TYPE = 'BASE TABLE' order by TABLE_NAME") to sSelect
86222>>>                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
86223>>>                Case Break
86224>>>
86224>>>            Case (sDriverID = MDSPgSQL)
86227>>>                Move "select tablename, schemaname from pg_catalog.pg_tables order by tablename"  to sSelect
86228>>>                Get SqlEnumerateEsqlMertech sSelect "" to sReturnArray
86229>>>                Case Break
86230>>>
86230>>>            Case (sDriverID = ORAFLEX)
86233>>>                Move "SELECT table_name from user_tables" to sSelect
86234>>>                Get SqlEnumerateEsqlMertech sSelect to sArray
86235>>>                Move (SizeOfArray(sArray)) to iSize
86236>>>                Decrement iSize
86237>>>                For iCount from 0 to iSize
86243>>>>
86243>>>                    If (not(sArray[iCount] contains "$")) Begin
86245>>>                        Move sArray[iCount] to sReturnArray[SizeOfArray(sReturnArray)]
86246>>>                    End
86246>>>>
86246>>>                Loop
86247>>>>
86247>>>                Case Break
86248>>>
86248>>>            Case Else
86248>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateTables function."
86249>>>>
86249>>>                Case Break
86250>>>        Case End
86250>>>
86250>>>        Function_Return sReturnArray
86251>>>    End_Function
86252>>>
86252>>>    // Returns a string array with all table columns/fields for the passed table handle and driver id.
86252>>>    Function SqlUtilEnumerateColumns String sDriverID String sTableName Returns String[]
86254>>>        String[] sReturnArray
86255>>>        String sConnectionString sSelect sSchema
86255>>>        Boolean bOK
86255>>>
86255>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
86256>>>        If (bOK = False) Begin
86258>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
86259>>>>
86259>>>            Function_Return sReturnArray
86260>>>        End
86260>>>>
86260>>>
86260>>>        Get psConnectionString to sConnectionString
86261>>>        Get psSchema to sSchema
86262>>>
86262>>>        Case Begin
86262>>>            Case (sDriverID = MSSQLDRV_ID)
86264>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
86265>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
86266>>>                Case Break
86267>>>
86267>>>            Case (sDriverID = DB2_DRV_ID)
86270>>>                Move ("SELECT colname from syscat.columns WHERE tabschema = '" + sSchema + "'" * "AND tabname = '" + sTableName + "'") to sSelect
86271>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
86272>>>                Case Break
86273>>>
86273>>>            Case (sDriverID = SQLFLEX)
86276>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
86277>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
86278>>>                Case Break
86279>>>
86279>>>            Case (sDriverID = MDSMySQL)
86282>>>                Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
86283>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
86284>>>                Case Break
86285>>>
86285>>>            Case (sDriverID = MDSPgSQL)
86288>>>                Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
86289>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
86290>>>                Case Break
86291>>>
86291>>>            Case (sDriverID = ORAFLEX)
86294>>>                Move ("SELECT column_name from user_tab_cols WHERE table_name = '" + sTableName + "'") to sSelect
86295>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
86296>>>                Case Break
86297>>>
86297>>>            Case Else
86297>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateColumns function."
86298>>>>
86298>>>                Case Break
86299>>>        Case End
86299>>>
86299>>>        Function_Return sReturnArray
86300>>>    End_Function
86301>>>
86301>>>
86301>>>    // Returns a string array with all table indexes for the passed table handle and driver id.
86301>>>    Function SqlUtilEnumerateIndexes String sTableName String sDriverID Returns String[]
86303>>>        String[] sReturnArray sReturnArray2
86305>>>        String sConnectionString sSelect sSchema
86305>>>        Boolean bOK
86305>>>        Integer iCount iSize
86305>>>
86305>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
86306>>>        If (bOK = False) Begin
86308>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
86309>>>>
86309>>>            Function_Return sReturnArray
86310>>>        End
86310>>>>
86310>>>
86310>>>        Get psConnectionString to sConnectionString
86311>>>        Get psSchema to sSchema
86312>>>
86312>>>        Case Begin
86312>>>            Case (sDriverID = MSSQLDRV_ID)
86314>>>                Move ("select * from sys.indexes where object_id = (select object_id from sys.objects where name = '" + sTableName + "')") to sSelect
86315>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
86316>>>                Case Break
86317>>>
86317>>>            Case (sDriverID = DB2_DRV_ID)
86320>>>                Error "Not implemented yet! The select statement has not been finalized."
86321>>>>
86321>>>//                Move () to sSelect
86321>>>//                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
86321>>>                Case Break
86322>>>
86322>>>            Case (sDriverID = SQLFLEX)
86325>>>                Error "Not implemented yet! The select statement has not been finalized."
86326>>>>
86326>>>//                Move () to sSelect
86326>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
86326>>>                Case Break
86327>>>
86327>>>            Case (sDriverID = MDSMySQL)
86330>>>                Error "Not implemented yet! The select statement has not been finalized."
86331>>>>
86331>>>//                Move () to sSelect
86331>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
86331>>>                Case Break
86332>>>
86332>>>            Case (sDriverID = MDSPgSQL)
86335>>>                Error "Not implemented yet! The select statement has not been finalized."
86336>>>>
86336>>>//                Move () to sSelect
86336>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
86336>>>                Case Break
86337>>>
86337>>>            Case (sDriverID = ORAFLEX)
86340>>>                Error "Not implemented yet! The select statement has not been finalized."
86341>>>>
86341>>>//                Move () to sSelect
86341>>>//                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
86341>>>                Case Break
86342>>>
86342>>>            Case Else
86342>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateIndexes function."
86343>>>>
86343>>>                Case Break
86344>>>        Case End
86344>>>
86344>>>        Move (SizeOfArray(sReturnArray)) to iSize
86345>>>        Decrement iSize
86346>>>        For iCount from 0 to iSize
86352>>>>
86352>>>            If (Trim(sReturnArray[iCount]) <> "") Begin
86354>>>                Move sReturnArray[iCount] to sReturnArray2[SizeOfArray(sReturnArray2)]
86355>>>            End
86355>>>>
86355>>>        Loop
86356>>>>
86356>>>
86356>>>        Function_Return sReturnArray2
86357>>>    End_Function
86358>>>
86358>>>    // Returns a string array with all table names the passed table handle has relation ships with.
86358>>>    // The format of the array is "TableName.FieldName"
86358>>>    Function SqlUtilEnumerateRelations String sTableName String sDriverID Returns tSQLRelation[]
86360>>>        String[] sFileNameArray sFieldNameArray
86362>>>        tSQLRelation[] sRelationsArray
86362>>>        tSQLRelation[] sRelationsArray
86363>>>        String sConnectionString sSelect sSchema sFileName sFieldName
86363>>>        Boolean bOK
86363>>>        Integer iCount iSize iLength
86363>>>
86363>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
86364>>>        If (bOK = False) Begin
86366>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
86367>>>>
86367>>>            Function_Return sRelationsArray
86368>>>        End
86368>>>>
86368>>>
86368>>>        Get psConnectionString to sConnectionString
86369>>>        Get psSchema to sSchema
86370>>>
86370>>>        Case Begin
86370>>>            Case (sDriverID = MSSQLDRV_ID)
86372>>>                Move ("SELECT object_name(parent_object_id), object_name(referenced_object_id), name from sys.foreign_keys WHERE parent_object_id = object_id( '" + sTableName + "')") to sSelect
86373>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sFileNameArray
86374>>>                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
86375>>>                Case Break
86376>>>
86376>>>            Case (sDriverID = DB2_DRV_ID)
86379>>>                Error "Not implemented yet! The select statement has not been finalized."
86380>>>>
86380>>>//                Move () to sSelect
86380>>>//                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
86380>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
86380>>>                Case Break
86381>>>
86381>>>            Case (sDriverID = SQLFLEX)
86384>>>                Error "Not implemented yet! The select statement has not been finalized."
86385>>>>
86385>>>//                Move () to sSelect
86385>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
86385>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
86385>>>                Case Break
86386>>>
86386>>>            Case (sDriverID = MDSMySQL)
86389>>>                Error "Not implemented yet! The select statement has not been finalized."
86390>>>>
86390>>>//                Move () to sSelect
86390>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
86390>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
86390>>>                Case Break
86391>>>
86391>>>            Case (sDriverID = MDSPgSQL)
86394>>>                Error "Not implemented yet! The select statement has not been finalized."
86395>>>>
86395>>>//                Move () to sSelect
86395>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
86395>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
86395>>>                Case Break
86396>>>
86396>>>            Case (sDriverID = ORAFLEX)
86399>>>                Error "Not implemented yet! The select statement has not been finalized."
86400>>>>
86400>>>//                Move () to sSelect
86400>>>//                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
86400>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
86400>>>                Case Break
86401>>>
86401>>>            Case Else
86401>>>                Error DFERR_PROGRAM "Unsupported driver passed to the SqlUtilEnumerateRelations function."
86402>>>>
86402>>>                Case Break
86403>>>        Case End
86403>>>
86403>>>        Move (Length(sTableName)) to iLength
86404>>>        Move (iLength + 4)        to iLength // The related to field key has the format "FK_TableName + FieldName"
86405>>>        Move (SizeOfArray(sFileNameArray)) to iSize
86406>>>        Decrement iSize
86407>>>        For iCount from 0 to iSize
86413>>>>
86413>>>            If (Trim(sFileNameArray[iCount]) <> "") Begin
86415>>>                Move sFileNameArray[iCount]         to sFileName
86416>>>                Move sFieldNameArray[iCount]        to sFieldName
86417>>>                Move (Mid(sFieldName, 99, iLength)) to sFieldName
86418>>>                Move sFileName  to sRelationsArray[iCount].sFileName
86419>>>                Move sFieldName to sRelationsArray[iCount].sFieldName
86420>>>            End
86420>>>>
86420>>>        Loop
86421>>>>
86421>>>
86421>>>        Function_Return sRelationsArray
86422>>>    End_Function
86423>>>
86423>>>    Function SqlUtilEnumerateLoggedInUsers String sDriverID String sDatabase Returns tSQLLoggedInUser[]
86425>>>        tSQLLoggedInUser[] SQLLoggedInUser
86425>>>        tSQLLoggedInUser[] SQLLoggedInUser
86426>>>        String[] sUsers sPrograms
86428>>>        String sSelect
86428>>>        Integer iSize iCount
86428>>>
86428>>>        Case Begin
86428>>>            Case (sDriverID = MSSQLDRV_ID)
86430>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
86431>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sUsers
86432>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sPrograms
86433>>>                Case Break
86434>>>            Case (sDriverID = SQLFLEX)
86437>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
86438>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sUsers
86439>>>                Get SqlEnumerateEsqlMertech sSelect 2 to sPrograms
86440>>>                Case Break
86441>>>            Case Else
86441>>>                Error DFERR_PROGRAM ("Not implemented yet for this driver (" + sDriverID + ")")
86442>>>>
86442>>>        Case End
86442>>>
86442>>>        Move (SizeOfArray(sUsers)) to iSize
86443>>>        Decrement iSize
86444>>>        For iCount from 0 to iSize
86450>>>>
86450>>>            Move sUsers[iCount]    to SQLLoggedInUser[iCount].sUser
86451>>>            Move sPrograms[iCount] to SQLLoggedInUser[iCount].sProgram
86452>>>        Loop
86453>>>>
86453>>>
86453>>>        Function_Return SQLLoggedInUser
86454>>>    End_Function
86455>>>
86455>>>    // Returns an array with all ".int" files for the passed sDataPath, _except_ for the driver .int files;
86455>>>    // "MSSQLDRV.int", "DB2_DRV.int" & "ODBC_DRV.int".
86455>>>    Function SqlUtilEnumerateIntFiles String sDataPath Returns String[]
86457>>>        String[] sFilesData
86458>>>        Boolean bExists
86458>>>        Integer iCh
86458>>>        String sFileName sExt
86458>>>
86458>>>        Get vFolderExists sDataPath to bExists
86459>>>        If (bExists = True) Begin
86461>>>            Move (ToANSI(Trim(sDataPath))) to sDataPath
86462>>>            Move ("dir:" + sDataPath)      to sDataPath
86463>>>            Get Seq_New_Channel to iCh  // get free channel for input
86464>>>            Direct_Input channel iCh sDataPath
86466>>>                Repeat
86466>>>>
86466>>>                    Readln channel iCh sFileName
86468>>>                    Get ParseFileExtension sFileName to sExt
86469>>>                    If (Uppercase(sExt) = "INT") Begin
86471>>>                        If (not(Uppercase(sFileName) contains "MSSQLDRV" and Uppercase(sFileName) contains "DB2_DRV" and Uppercase(sFileName) contains "ODBC_DRV")) Begin
86473>>>                            Move sFileName to sFilesData[SizeOfArray(sFilesData)]
86474>>>                        End
86474>>>>
86474>>>                    End
86474>>>>
86474>>>                Until (SeqEof = True)
86476>>>            Close_Input channel iCh
86478>>>        End
86478>>>>
86478>>>        Function_Return sFilesData
86479>>>    End_Function
86480>>>
86480>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
86480>>>    // for DAW drivers.
86480>>>    // Returns: A string array.
86480>>>    Function SqlEnumerateEsqlDAW String sStmt Integer iColumn Returns String[]
86482>>>        String[] sReturnArray
86483>>>        String sValue sPrevious
86483>>>        Handle hoSQLHandler hoSQLConnect hstmt
86483>>>        Integer iFetchResult iRows
86483>>>        tSQLConnection SQLConnection
86483>>>        tSQLConnection SQLConnection
86483>>>
86483>>>        Get phoSQLManager to hoSQLHandler
86484>>>
86484>>>        If (hoSQLHandler <> 0) Begin
86486>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86487>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
86488>>>
86488>>>            If (hoSQLConnect <> 0) Begin
86490>>>                Get SQLOpen of hoSQLConnect to hstmt
86491>>>                If (hstmt <> 0) Begin
86493>>>                    Send SqlExecDirect of hstmt sStmt
86494>>>                    Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
86495>>>                    Repeat
86495>>>>
86495>>>                        Get SQLFetch of hstmt to iFetchResult
86496>>>                        If (iFetchResult <> 0) Begin
86498>>>                            Get SQLColumnValue of hstmt iColumn to sValue
86499>>>                            If (sValue <> sPrevious) Begin
86501>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
86502>>>                            End
86502>>>>
86502>>>                            Move sValue to sPrevious
86503>>>                        End
86503>>>>
86503>>>                    Until (iFetchResult = 0)
86505>>>                    Send SQLClose of hstmt
86506>>>                End
86506>>>>
86506>>>                Send SQLDisconnect of hoSQLConnect
86507>>>            End
86507>>>>
86507>>>        End
86507>>>>
86507>>>
86507>>>        Function_Return sReturnArray
86508>>>    End_Function
86509>>>
86509>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
86509>>>    // for Mertech drivers.
86509>>>    // Returns: A string array.
86509>>>    Function SqlEnumerateEsqlMertech String sStmt Returns String[]
86511>>>        String[] sReturnArray
86512>>>        String sValue sUserID sPassword
86512>>>        Handle hoSQLHandler hoSQLConnect hStmt
86512>>>        Integer iFetchResult iRows
86512>>>        tSQLConnection SQLConnection
86512>>>        tSQLConnection SQLConnection
86512>>>
86512>>>        Get _MertechSQLManagerHandle to hoSQLHandler
86513>>>
86513>>>        If (hoSQLHandler <> 0) Begin
86515>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86516>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
86517>>>
86517>>>            If (hoSQLConnect <> 0) Begin
86519>>>                Get SQLOpen of hoSQLConnect to hStmt
86520>>>                If (hStmt <> 0) Begin
86522>>>                    Send SqlExecDirect of hStmt sStmt
86523>>>                    Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_ROWCOUNT to iRows
86524>>>                    Repeat
86524>>>>
86524>>>                        Get SQLFetch of hStmt to iFetchResult
86525>>>                        If (iFetchResult <> 0) Begin
86527>>>                            Get SQLColumnValue of hStmt 1 to sValue
86528>>>                            Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
86529>>>                        End
86529>>>>
86529>>>                    Until (iFetchResult = 0)
86531>>>                    Send SQLClose of hStmt
86532>>>                End
86532>>>>
86532>>>                Send SQLDisconnect of hoSQLConnect
86533>>>            End
86533>>>>
86533>>>        End
86533>>>>
86533>>>
86533>>>        Function_Return sReturnArray
86534>>>    End_Function
86535>>>
86535>>>    // * Dummy function for the Studio's Code Explorer *
86535>>>    Function PRIVATE_SQL_SUB_FUNCTIONS Returns Boolean
86537>>>        Function_Return False
86538>>>    End_Function
86539>>>
86539>>>    // Returns the index for the passed sTableName
86539>>>    // Returns >= 0 if successful. It is e.g. needed to get the SchemaName for a table.
86539>>>    Function _SqlUtilEnumerateTableIndex String sTableName String sDriverID Returns Integer
86541>>>        Integer iIndex iSize iCount
86541>>>        String[] sTablesArray
86542>>>        String sVal sConnectionString
86542>>>
86542>>>        Move -1 to iIndex
86543>>>        Get psConnectionString to sConnectionString
86544>>>        Get SqlUtilEnumerateTables sDriverID to sTablesArray
86545>>>        Move (SizeOfArray(sTablesArray)) to iSize
86546>>>        Decrement iSize
86547>>>        For iCount from 0 to iSize
86553>>>>
86553>>>            Move sTablesArray[iCount] to sVal
86554>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
86556>>>                Move iCount to iIndex // We found it!
86557>>>                Move iSize to iCount  // End the loop
86558>>>            End
86558>>>>
86558>>>        Loop
86559>>>>
86559>>>
86559>>>        Function_Return iIndex
86560>>>    End_Function
86561>>>
86561>>>    // Helper function that builds a string like;
86561>>>    // "SELECT name from [Master].[sys].[databases] where name"
86561>>>    Function _SqlSelectFromWhereName Returns String
86563>>>        String sRetval sSelect sName sFrom sMaster sSys sDatabases sWhere sDBO
86563>>>
86563>>>        Get _SqlFindKeyWord CI_SQLSelect       to sSelect
86564>>>        Get _SqlFindKeyWord CI_SQLName         to sName
86565>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBO
86566>>>        Get _SqlFindKeyWord CI_SQLFrom         to sFrom
86567>>>        Get _SqlFindKeyWord CI_SQLMaster       to sMaster
86568>>>        Get _SqlFindKeyWord CI_SQLSys          to sSys
86569>>>        Get _SqlFindKeyWord CI_SQLDatabases    to sDatabases
86570>>>        Get _SqlFindKeyWord CI_SQLWhere        to sWhere
86571>>>        Move (sSelect * sName * sFrom * "[" + sMaster + "].[" + sDBO + "].[" + sSys + sDatabases + "]" * sWhere * sName) to sRetval
86572>>>        Function_Return sRetval
86573>>>    End_Function
86574>>>
86574>>>    // Helper function to create a SQL statement like;
86574>>>    // "SELECT * FROM SYS.INDEXES WHERE NAME = MyIndexName AND OBJECT_ID = OBJECT_ID([MySchmaName].[MyTableName])"
86574>>>    // Used for checking if an index exists.
86574>>>    Function _SqlQueryIfIndexExists String sSchemaName String sTableName String sIndexName Returns String
86576>>>        String sRetval sSelect sFrom sSysIndexes sWhere sObjectID sAnd sName
86576>>>
86576>>>        Get _SqlFindKeyWord CI_SQLSelect to sSelect
86577>>>        Get _SqlFindKeyWord CI_SQLFrom to sFrom
86578>>>        Get _SqlFindKeyWord CI_SQLSysIndexes to sSysIndexes
86579>>>        Get _SqlFindKeyWord CI_SQLWhere to sWhere
86580>>>        Get _SqlFindKeyWord CI_SQLObjectID to sObjectID
86581>>>        Get _SqlFindKeyWord CI_SQLAND to sAnd
86582>>>        Get _SqlFindKeyWord CI_SQLName to sName
86583>>>
86583>>>        Move (sSelect * String("*") * sFrom * sSysIndexes * sWhere * sName * "=" * sIndexName * sAnd * sObjectID * "=([" + sSchemaName + "].[" + sTableName + "])") to sRetval
86584>>>
86584>>>        Function_Return sRetval
86585>>>    End_Function
86586>>>
86586>>>    // Formats a columns iLenght & iDecimal parameters as SQL expects them in a string.
86586>>>    // E.g. (4,2), where 4 is the iLength and 2 the iDecimals param.
86586>>>    Function _SqlFormatLengthAndDecimalAsString Integer iLength Integer iDecimals Returns String
86588>>>        String sRetval
86588>>>        If (iLength <> 0) Begin
86590>>>            Move ("(" + String(iLength)) to sRetval
86591>>>            If (iDecimals <> 0) Begin
86593>>>                Move (sRetval + "," + String(iDecimals)) to sRetval
86594>>>            End
86594>>>>
86594>>>            Move (sRetval + ")") to sRetval
86595>>>        End
86595>>>>
86595>>>        Function_Return sRetval
86596>>>    End_Function
86597>>>
86597>>>    Procedure _SqlColumnInfo Handle hoStmt
86599>>>        Integer i iCols iItem
86599>>>        tSqlColumnNew[] aQueryColumns
86599>>>        tSqlColumnNew[] aQueryColumns
86600>>>
86600>>>        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
86601>>>        For i from 1 to iCols
86607>>>>
86607>>>            Move (SizeOfArray(aQueryColumns)) to iItem
86608>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASECOLUMNNAME to aQueryColumns[iItem].sBaseColumnName
86609>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASETABLENAME  to aQueryColumns[iItem].sBaseTableName
86610>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_LABEL          to aQueryColumns[iItem].sLabel
86611>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SQLTYPE        to aQueryColumns[iItem].iSqlType
86612>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_DFTYPE         to aQueryColumns[iItem].iDFType
86613>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SIZE           to aQueryColumns[iItem].iSize
86614>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_PRECISION      to aQueryColumns[iItem].iPrecision
86615>>>        Loop
86616>>>>
86616>>>        Set piColumns to iCols
86617>>>        Set paQueryColumns to aQueryColumns
86618>>>    End_Procedure
86619>>>
86619>>>    // Checks that the passed sDriverID is defined.
86619>>>    // Also checks if the driver has been loaded; else it gets loaded.
86619>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
86621>>>        Boolean bOK
86621>>>        Integer iDriver
86621>>>
86621>>>        If (sDriverID = DATAFLEX_ID) Begin
86623>>>            Function_Return False
86624>>>        End
86624>>>>
86624>>>
86624>>>        Get IsDAWSQLDriver sDriverID to bOK
86625>>>
86625>>>        If (bOK = False) Begin
86627>>>            Get IsMertechDriver sDriverID to bOK
86628>>>        End
86628>>>>
86628>>>
86628>>>        If (bOK = False) Begin
86630>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV, DB2_DRV, ODBC_DRV, SQLFLEX, ORAFLEX, MDSPgSQL or MDSMySQL"
86631>>>>
86631>>>            Function_Return False
86632>>>        End
86632>>>>
86632>>>
86632>>>        Get DriverIndex sDriverID to iDriver
86633>>>        If (iDriver = 0) Begin
86635>>>            Load_Driver sDriverID
86636>>>        End
86636>>>>
86636>>>
86636>>>        Function_Return True
86637>>>    End_Function
86638>>>
86638>>>    // Checks that the length parameter has been passed correctly.
86638>>>    // This is only of concern for certain SQL data types.
86638>>>    Function _SqlCheckLengthParamForDataType Integer iDataType Integer iLen Returns Boolean
86640>>>        Integer iLength
86640>>>        Boolean bOK bCheckTypeLength
86640>>>
86640>>>        If (num_arguments > 1) Begin
86642>>>            Move iLen to iLength
86643>>>        End
86643>>>>
86643>>>        Move (iDataType = SQL_DECIMAL   or iDataType = SQL_NUMERIC or iDataType = SQL_FLOAT   or iDataType = SQL_INTEGER or;              iDataType = SQL_VARBINARY or iDataType = SQL_BINARY  or iDataType = SQL_VARCHAR or iDataType = SQL_CHAR or;              iDataType = SQL_BIGINT    or iDataType = SQL_REAL) to bCheckTypeLength
86644>>>
86644>>>        If (bCheckTypeLength = True) Begin
86646>>>            Move (iLength > 0) to bOK
86647>>>        End
86647>>>>
86647>>>
86647>>>        Function_Return (bOK = True)
86648>>>    End_Function
86649>>>
86649>>>    Function _SqlProperTableName String sTableName Returns String
86651>>>        String sVal sSchema sDriverID
86651>>>        Integer iDbType
86651>>>
86651>>>        If (Trim(sTableName) = "") Begin
86653>>>            Function_Return ""
86654>>>        End
86654>>>>
86654>>>
86654>>>        Get psDriverID to sDriverID
86655>>>        Get piDbType   to iDbType
86656>>>        If (iDbType = EN_dbTypeOracle) Begin
86658>>>            Get psUserID to sSchema
86659>>>            // Not sure about this uppercasing but it seems like Oracle wants that?
86659>>>            Move (Uppercase(sSchema)) to sSchema
86660>>>            Move ('"' + sSchema + '"."' + sTableName + '"') to sTableName
86661>>>            Function_Return sTableName
86662>>>        End
86662>>>>
86662>>>        If (iDbType = EN_DbTypeMySQL) Begin
86664>>>            Get psDatabase to sVal
86665>>>            Move (sVal + "." + sTableName) to sTableName
86666>>>            Function_Return sTableName
86667>>>        End
86667>>>>
86667>>>        If (iDbType = EN_DbTypePostgre) Begin
86669>>>            Move ('"' + sTableName + '"') to sTableName
86670>>>            Function_Return sTableName
86671>>>        End
86671>>>>
86671>>>
86671>>>        Get psSchema to sSchema
86672>>>        If (sSchema = "") Begin
86674>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
86675>>>        End
86675>>>>
86675>>>
86675>>>        Move (Uppercase(sTableName)) to sVal
86676>>>        If (not(sVal contains (sSchema + "."))) Begin
86678>>>            If (iDbType = EN_dbTypeDB2) Begin
86680>>>                Move (Lowercase(sSchema) + "." + sTableName) to sTableName
86681>>>            End
86681>>>>
86681>>>            Else Begin
86682>>>                Move (sSchema + "." + sTableName) to sTableName
86683>>>            End
86683>>>>
86683>>>        End
86683>>>>
86683>>>
86683>>>        Function_Return sTableName
86684>>>    End_Function
86685>>>
86685>>>    // SQL column names can be case-sensitive. This function is used to check that
86685>>>    // the passed sFieldName has the correct spelling.
86685>>>    // Used with Embedded SQL statement calls.
86685>>>    // If the spelling or fieldname doesn't exist, the return value is "" (blank).
86685>>>    Function _SqlFindColumnName String sTableName String sColumnName Returns String
86687>>>        String sRetval sValue sDriverID
86687>>>        String[] sColumnNamesArray
86688>>>        Integer iCount iColumns
86688>>>
86688>>>        Move "" to sRetval
86689>>>        Get psDriverID to sDriverID
86690>>>        Get SqlUtilEnumerateColumns sDriverID sTableName to sColumnNamesArray
86691>>>        Move (SizeOfArray(sColumnNamesArray)) to iColumns
86692>>>        Decrement iColumns
86693>>>
86693>>>        For iCount from 0 to iColumns
86699>>>>
86699>>>            Move sColumnNamesArray[iCount] to sValue
86700>>>            If (Uppercase(sColumnName) = Uppercase(sValue)) Begin
86702>>>                Move sValue to sRetval
86703>>>                Move iColumns to iCount // We're done.
86704>>>            End
86704>>>>
86704>>>        Loop
86705>>>>
86705>>>
86705>>>        Function_Return sRetval
86706>>>    End_Function
86707>>>
86707>>>    Function _SqlDatabasesArrayMSSQL Returns String[]
86709>>>        String[] sReturnArray
86710>>>        Handle hoSQLHandler
86710>>>        Integer iCount iSize iItem
86710>>>        String sServer sUser sPassword
86710>>>        tSQLConnection SQLConnection
86710>>>        tSQLConnection SQLConnection
86710>>>
86710>>>        Get phoMSSQLHandler to hoSQLHandler
86711>>>        Send Delete_Data    of hoSQLHandler
86712>>>        Get pSQLConnection  of ghoSQLConnectionHandler to SQLConnection
86713>>>
86713>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
86714>>>        Get EnumerateDatabases of hoSQLHandler SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to iSize
86715>>>        Decrement iSize
86716>>>
86716>>>        For iCount from 0 to iSize
86722>>>>
86722>>>            Get String_Value of hoSQLHandler item iCount to sServer
86723>>>            Move (Trim(sServer)) to sReturnArray[iItem]
86724>>>            Increment iItem
86725>>>        Loop
86726>>>>
86726>>>
86726>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
86727>>>
86727>>>        Function_Return sReturnArray
86728>>>    End_Function
86729>>>
86729>>>    Function _SqlTableArrayDAW Returns String[]
86731>>>        String[] sReturnArray
86732>>>        String sTable sTableType sSchema sDefSchema sComment sTableKeyWord sSysKeyWord
86732>>>        Handle hoSQLHandler
86732>>>        Integer iCount iSize iItem
86732>>>        Boolean bOK
86732>>>        tSQLConnection SQLConnection
86732>>>        tSQLConnection SQLConnection
86732>>>
86732>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86733>>>        If (SQLConnection.sConnectionString = "") Begin
86735>>>            Function_Return sReturnArray
86736>>>        End
86736>>>>
86736>>>
86736>>>        Move SQLConnection.sSchema      to sDefSchema
86737>>>        Move (Uppercase(sDefSchema))    to sDefSchema
86738>>>        Get _SqlFindKeyWord CI_SQLTable to sTableKeyWord
86739>>>        Get _SqlFindKeyWord CI_SQLSys   to sSysKeyWord
86740>>>
86740>>>        Get phoCLIHandler to hoSQLHandler
86741>>>        Set psDriverID    of hoSQLHandler to SQLConnection.sDriverID
86742>>>        Send Delete_Data  of hoSQLHandler
86743>>>
86743>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
86744>>>        Get EnumerateTables of hoSQLHandler SQLConnection.sConnectionString to iSize
86745>>>        Move False to Err
86746>>>        Decrement iSize
86747>>>
86747>>>        For iCount from 0 to iSize
86753>>>>
86753>>>            Get TableName    of hoSQLHandler iCount to sTable
86754>>>            Get TableType    of hoSQLHandler iCount to sTableType
86755>>>            Get SchemaName   of hoSQLHandler iCount to sSchema
86756>>>            Get TableComment of hoSQLHandler iCount to sComment
86757>>>            Move (Trim(sTable)) to sTable
86758>>>            If (SQLConnection.sDriverID = DB2_DRV_ID) Begin
86760>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) = sDefSchema) to bOK
86761>>>            End
86761>>>>
86761>>>            Else Begin
86762>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) <> sSysKeyWord and Uppercase(sSchema) <> "SYSTOOLS") to bOK
86763>>>            End
86763>>>>
86763>>>            If (bOK = True) Begin
86765>>>                Move sTable to sReturnArray[iItem]
86766>>>                Increment iItem
86767>>>            End
86767>>>>
86767>>>        Loop
86768>>>>
86768>>>
86768>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
86769>>>
86769>>>        Function_Return sReturnArray
86770>>>    End_Function
86771>>>
86771>>>    Function _SqlProcedureArrayDAW String sStmt String sArgument Returns String[]
86773>>>        String[] sReturnArray
86774>>>        String sValue
86774>>>        Handle hoSQLHandler hoSQLConnect hStmt
86774>>>        Integer iRetval iCols iFetchResult
86774>>>        tSQLConnection SQLConnection
86774>>>        tSQLConnection SQLConnection
86774>>>
86774>>>        Get phoSQLManager to hoSQLHandler
86775>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86776>>>        Get SqlConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
86777>>>
86777>>>        If (hoSQLConnect <> 0) Begin
86779>>>            Get SqlOpen of hoSQLConnect to hStmt
86780>>>            If (hStmt <> 0) Begin
86782>>>                Send SqlSetProcedurename of hStmt sStmt
86783>>>                If (sArgument <> "") Begin
86785>>>                    Send SqlSetArgument  of hStmt 1 sArgument
86786>>>                End
86786>>>>
86786>>>
86786>>>                Send SqlCall             of hStmt
86787>>>                Get SqlReturnValue       of hStmt to iRetval
86788>>>                If (iRetval = 0) Begin
86790>>>                    Repeat
86790>>>>
86790>>>                        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
86791>>>                        If (iCols > 0) Begin
86793>>>                            Repeat
86793>>>>
86793>>>                                Get SqlFetch of hStmt to iFetchResult
86794>>>                                If (iFetchResult <> 0) Begin
86796>>>                                    Get SqlColumnValue of hStmt 1 to sValue
86797>>>                                    Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)]
86798>>>                                End
86798>>>>
86798>>>                            Until (iFetchResult = 0)
86800>>>                        End
86800>>>>
86800>>>                        Get SqlNextResultSet of hStmt to iRetval
86801>>>                    Until (iRetval = 0)
86803>>>                    Send SqlClose of hStmt
86804>>>                End
86804>>>>
86804>>>            End
86804>>>>
86804>>>            Send SqlDisconnect of hoSQLConnect
86805>>>        End
86805>>>>
86805>>>        Function_Return sReturnArray
86806>>>    End_Function
86807>>>
86807>>>    Function _SqlDatabasesArrayDB2 Returns String[]
86809>>>        String[] sReturnArray
86810>>>        String sDataSource
86810>>>        Handle hoSQLHandler
86810>>>        Integer iItem
86810>>>
86810>>>        Get phoDB2SQLHandler to hoSQLHandler
86811>>>        Send SeedDataSources of hoSQLHandler
86812>>>
86812>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
86813>>>
86813>>>        Repeat
86813>>>>
86813>>>            Get DataSources of hoSQLHandler to sDataSource
86814>>>            Move (Replaces(",", sDataSource, "")) to sDataSource
86815>>>            Move (Trim(sDataSource)) to sReturnArray[iItem]
86816>>>            Increment iItem
86817>>>        Until (sDataSource = "")
86819>>>
86819>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
86820>>>
86820>>>        Function_Return sReturnArray
86821>>>    End_Function
86822>>>
86822>>>    Function _SqlDatabasesArrayODBC Returns String[]
86824>>>        String[] sReturnArray
86825>>>        String sDataSource
86825>>>        Handle hoSQLHandler
86825>>>        Integer iItem
86825>>>
86825>>>        Get phoODBCSQLHandler to hoSQLHandler
86826>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
86827>>>
86827>>>        Send SeedDataSources of hoSQLHandler
86828>>>
86828>>>        Repeat
86828>>>>
86828>>>            Get DataSources of hoSQLHandler to sDataSource
86829>>>            If (Trim(sDataSource) <> "" and not(sDataSource contains "*.")) Begin
86831>>>                Move (Trim(sDataSource)) to sReturnArray[iItem]
86832>>>                Increment iItem
86833>>>            End
86833>>>>
86833>>>        Until (sDataSource = "")
86835>>>
86835>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
86836>>>
86836>>>        Function_Return sReturnArray
86837>>>    End_Function
86838>>>
86838>>>    // We might have a split Sql script where the info about which database to use is
86838>>>    // put on top of the Sql script, we then need to save it to be able to retrieve it later and
86838>>>    // insert it for scriplets to come after the first one.
86838>>>    Function _SqlFormatStatement String sStmt Returns String
86840>>>        String sUseDatabase sTmp sUseKeyWord sCreateViewKeyWord sDBOKeyWord sNoCountKeyWord sDriverID
86840>>>        Integer iStart iEnd iDbType
86840>>>        Boolean bOK
86840>>>
86840>>>        Get piDbType to iDbType
86841>>>        Get psDriverID to sDriverID
86842>>>        Get _SqlFindKeyWord CI_SQLUse          to sUseKeyWord
86843>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
86844>>>        Get _SqlFindKeyWord CI_SQLCreateView   to sCreateViewKeyWord
86845>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBOKeyWord
86846>>>        Move (Replaces(" ", sStmt, "")) to sTmp
86847>>>        If (Uppercase(sTmp) contains (sUseKeyWord +"[")) Begin
86849>>>            Move (Pos("[", (Uppercase(sTmp)))) to iStart
86850>>>            Move (Pos("]", sTmp)) to iEnd
86851>>>            Move (Mid(sTmp, (iEnd -iStart +1), iStart)) to sUseDatabase
86852>>>            Move (sUseKeyWord * sUseDatabase + " ") to sUseDatabase
86853>>>            Set Private.psUseDatabase to sUseDatabase
86854>>>        End
86854>>>>
86854>>>        Else Begin
86855>>>            Move (Uppercase(sStmt)) to sTmp
86856>>>
86856>>>            // A "Create View" statement _must_ be the very first words in a Sql statement.
86856>>>            If (not(sTmp contains sCreateViewKeyWord)) Begin
86858>>>                Get Private.psUseDatabase to sUseDatabase
86859>>>                Move (Insert(sUseDatabase, sStmt, 1)) to sStmt
86860>>>            End
86860>>>>
86860>>>
86860>>>            // This is a bit special to place here but was done so because it was easier that way.
86860>>>            // We will get an error when trying to create a view if it already exists.
86860>>>            // So to avoid such errors; we first remove it & then recreate it.
86860>>>            Else If (sTmp contains sCreateViewKeyWord) Begin
86863>>>                // Make sure we only have one space between statements/words.
86863>>>                Move (Replaces("  ", sTmp, " ")) to sTmp
86864>>>                Move (Replace(sCreateViewKeyWord, sTmp, "")) to sTmp
86865>>>                Move (Trim(sTmp)) to sTmp
86866>>>                Move (Pos(" ", sTmp)) to iEnd
86867>>>                Move (Left(sTmp, iEnd)) to sTmp
86868>>>                If ((not(sTmp contains ("[" + sDBOKeyWord + "]."))) and (not(sTmp contains (sDBOKeyWord + ".")))) Begin
86870>>>                    Move (sDBOKeyWord + "." + Trim(sTmp)) to sTmp
86871>>>                End
86871>>>>
86871>>>                Move (Trim(sTmp)) to sTmp
86872>>>                // Remove data view as it already exists!
86872>>>                Get SqlViewRemove sDriverID sTmp to bOK
86873>>>            End
86873>>>>
86873>>>        End
86873>>>>
86873>>>
86873>>>        Function_Return sStmt
86874>>>    End_Function
86875>>>
86875>>>    // Returns the proper Sql language key word(s) for the passed SQL key-word constant
86875>>>    Function _SqlFindKeyWord Integer iSQLKeywordConstant Returns String
86877>>>        String sRetval
86877>>>        Integer iDbType iIndex
86877>>>        tSQLKeyWords[] SQLKeywordArray
86877>>>        tSQLKeyWords[] SQLKeywordArray
86878>>>        tSQLKeyWords   SQLKeyWords
86878>>>        tSQLKeyWords   SQLKeyWords
86878>>>
86878>>>        // Sql back-end type. E.g. MS-SQL, MySQL, Oracle, DB2...
86878>>>        Get piDbType to iDbType
86879>>>        Move iDbType             to SQLKeyWords.iSQLDbType
86880>>>        Move iSQLKeywordConstant to SQLKeyWords.iSQLWord
86881>>>
86881>>>        Get paSQLKeywordArray to SQLKeywordArray
86882>>>        Move (SearchArray(SQLKeyWords, SQLKeywordArray, Self, RefFunc(CompareFindSQLKeyWords))) to iIndex
86883>>>        Move SQLKeywordArray[iIndex].sSQLPhrase to sRetval
86884>>>
86884>>>        Function_Return sRetval
86885>>>    End_Function
86886>>>
86886>>>    // Function will "clean/sanitize" the script by removing all comments and blank lines.
86886>>>    Function _SqlUtilSanitizeScript tSQLScriptArray SqlScriptArray Returns tSQLScriptArray[]
86888>>>        String[] sSQLScriptArray
86889>>>        String sText sLine sTmp sCommentStart sCommentEnd sDashComment
86889>>>        Integer iSize iCount
86889>>>        Boolean bCommentStart bCommentEnd bDashComment
86889>>>
86889>>>        Move False to bCommentStart
86890>>>        Move False to bCommentEnd
86891>>>        Move False to bDashComment
86892>>>        Move "/*"  to sCommentStart   // These are the standard comment start & stop tokens...
86893>>>        Move "*/"  to sCommentEnd
86894>>>        Move "--"  to sDashComment    // ...but a comment can also start with two dashes "--".
86895>>>
86895>>>        Move (SizeOfArray(SqlScriptArray.sSQLScriptArray)) to iSize
86896>>>        Decrement iSize
86897>>>        Move "" to sText
86898>>>
86898>>>        For iCount from 0 to iSize
86904>>>>
86904>>>            Move SqlScriptArray.sSQLScriptArray[iCount] to sLine
86905>>>            Move (Trim(sLine)) to sTmp
86906>>>            If (sTmp <> "") Begin
86908>>>                Move (Left(sTmp, 2) = sDashComment) to bDashComment
86909>>>                If (bCommentStart = False) Begin
86911>>>                    Move (Left(sTmp, 2) = sCommentStart) to bCommentStart
86912>>>                    If (bCommentStart = False) Begin
86914>>>                    End
86914>>>>
86914>>>                End
86914>>>>
86914>>>                Move (sTmp contains sCommentEnd) to bCommentEnd
86915>>>                If (bCommentEnd = True) Begin
86917>>>                    Move False to bCommentStart
86918>>>                End
86918>>>>
86918>>>                If (bDashComment = False and bCommentStart = False and bCommentEnd = False) Begin
86920>>>                    Move sLine to sSQLScriptArray[SizeOfArray(sSQLScriptArray)]
86921>>>                End
86921>>>>
86921>>>            End
86921>>>>
86921>>>        Loop
86922>>>>
86922>>>
86922>>>        // Update the retval struct array:
86922>>>        Move sSQLScriptArray to SqlScriptArray.sSQLScriptArray
86923>>>        Function_Return SqlScriptArray
86924>>>    End_Function
86925>>>
86925>>>
86925>>>    // *** Database API Functions: ***
86925>>>    // Instead of using Sql Scripts (ESQL), we can opt to use the DataFlex Database API's to
86925>>>    // make changes/updates to the database.
86925>>>
86925>>>    // * Dummy function for the Studio's Code Explorer *
86925>>>    Function API_TABLE_FUNCTIONS Returns Boolean
86927>>>        Function_Return False
86928>>>    End_Function
86929>>>
86929>>>    // This might not do what you think - Here's what it does:
86929>>>    // It checks that the passed hTable TableName in filelist.cfg is exactly the same as at the SQL back-end.
86929>>>    // If that is True; it creates an .int file for it and changes Filelist.cfg to point
86929>>>    // to the SQL table.
86929>>>    // Typical usage for this function is when an entry exists in the Filelist for a table and the table
86929>>>    // already exists in SQL.
86929>>>    // This is a bit fiddly as the DF_FILE_PHYSICAL_NAME attribute can only be set inside a
86929>>>    // Structure_Start ... Structure_End operation when creating a NEW table. Thus it cannot be set when
86929>>>    // restructuring an existing table.
86929>>>    Function ApiTableAttachToSql Handle hTable Boolean bUseConnID Returns Boolean
86931>>>        Boolean bExists bOpened bOK bSystemFile bMertechDriver bUseConnectionID bIsAlias
86931>>>        String sDriverID sConnectionID sConnectionString sDisplayName sRootName sLogicalName sPhysicalName sSchema
86931>>>        Handle hToTable
86931>>>        Integer iPos
86931>>>
86931>>>        Move True to bUseConnectionID
86932>>>        If (num_arguments > 1) Begin
86934>>>            Move bUseConnID to bUseConnectionID
86935>>>        End
86935>>>>
86935>>>
86935>>>        Get psDriverID to sDriverID
86936>>>        // If the table doesn't exist on the SQL back-end we do nothing.
86936>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
86937>>>        If (bExists = False) Begin
86939>>>            Function_Return False
86940>>>        End
86940>>>>
86940>>>
86940>>>        Get UtilTableIsAlias hTable to bIsAlias
86941>>>
86941>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
86942>>>        If (bOK = False) Begin
86944>>>            Function_Return False
86945>>>        End
86945>>>>
86945>>>
86945>>>        // Then we need to check that the function hasn't been called before; which in case
86945>>>        // we do nothing
86945>>>        Get SQLUtilTableIsAttached sDriverID hTable to bExists
86946>>>        If (bExists = True) Begin
86948>>>            Function_Return False
86949>>>        End
86949>>>>
86949>>>
86949>>>        Get psConnectionID     to sConnectionID
86950>>>        Get psConnectionString to sConnectionString
86951>>>        If (sConnectionID = "" or sConnectionString = "") Begin
86953>>>            Error DFERR_PROGRAM ("An SQL connection has NOT been setup correctly. Could not attach table:" * String(hTable) * "to SQL")
86954>>>>
86954>>>            Function_Return False
86955>>>        End
86955>>>>
86955>>>
86955>>>        Set Private.phCurrentTable to hTable
86956>>>        Get psSchema to sSchema
86957>>>        If (sSchema = "") Begin
86959>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
86960>>>        End
86960>>>>
86960>>>
86960>>>        Get IsMertechDriver sDriverID to bMertechDriver
86961>>>
86961>>>        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
86961>>>        // was a programmer's error and we adjust for it here.
86961>>>        If (bMertechDriver = True) Begin
86963>>>            Move False to bUseConnectionID
86964>>>        End
86964>>>>
86964>>>
86964>>>        // If we should use a connection id we need to check it exists;
86964>>>        // else we create it before attempting creating the table
86964>>>        If (bUseConnectionID = True) Begin
86966>>>            Get AutoConnectionIDLogin to bOK
86967>>>            If (bOk = False) Begin
86969>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
86970>>>>
86970>>>                Function_Return False
86971>>>            End
86971>>>>
86971>>>        End
86971>>>>
86971>>>
86971>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86974>>>        Get _TableNameOnly sRootName to sRootName
86975>>>        If (sRootName = "") Begin
86977>>>            Function_Return False
86978>>>        End
86978>>>>
86978>>>        Move (sRootName + ".int")                    to sPhysicalName
86979>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86982>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86985>>>
86985>>>        // We don't want to change the display name if it starts with an ampersand ("@"),
86985>>>        // because then the table should not be visible to users.
86985>>>        Move (Pos("@", sDisplayName)) to iPos
86986>>>        If (iPos <> 1) Begin
86988>>>            If (sDisplayName contains ".") Begin
86990>>>                Move (Pos(".", sDisplayName)) to iPos
86991>>>                Move (Mid(sDisplayName, 200 ,(iPos + 1))) to sDisplayName
86992>>>                Move (sSchema + "." + sDisplayName)       to sDisplayName
86993>>>            End
86993>>>>
86993>>>            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
86995>>>                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
86996>>>            End
86996>>>>
86996>>>        End
86996>>>>
86996>>>
86996>>>        If (bIsAlias = False) Begin
86998>>>            Get OpenTableExclusive hTable to bOpened
86999>>>            If (bOpened = False) Begin
87001>>>                Error DFERR_PROGRAM ("Function ApiTableAttachToSQL - Could not open table number:" * String(hTable) * sLogicalName)
87002>>>>
87002>>>                Function_Return False
87003>>>            End
87003>>>>
87003>>>        End
87003>>>>
87003>>>
87003>>>        If (ghoProgressBar <> 0) Begin
87005>>>            Send DoAdvance of ghoProgressBar
87006>>>            Set TableName_Text of ghoStatusPanel to ("Attaching to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable) * "to SQL")
87007>>>        End
87007>>>>
87007>>>        // Note: The hToTable will get changed by the Structure_xxx command...
87007>>>        Move hTable to hToTable
87008>>>        Move False to Err
87009>>>
87009>>>        // We now create a stub .int file and after Structure_end and also change the Filelist.cfg,
87009>>>        // then we do a pseudo .int file change with the "SqlUtilUpdateIntFile" function. After that we have
87009>>>        // a proper and updated .int file.
87009>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemFile
87012>>>        Get SqlUtilCreateIntFile hTable sDriverID sConnectionID True bSystemFile to bOK
87013>>>
87013>>>        If (bIsAlias = False) Begin
87015>>>            Structure_Start hToTable sDriverID
87016>>>                Set Private.phCurrentTable to hTable
87017>>>                If (bUseConnectionID = True) Begin
87019>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to (CS_DFCONNID + "=" + sConnectionID)
87022>>>                End
87022>>>>
87022>>>                Else Begin
87023>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to sConnectionString
87026>>>                End
87026>>>>
87026>>>                Set_Attribute DF_FILE_OWNER         of hToTable to (Lowercase(sSchema))
87029>>>                // For unknown reason the above sometimes triggers an error and it doesn't help to try to trap the error; so we cheat...
87029>>>                Move False to Err
87030>>>                Move 0 to LastErr
87031>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
87032>>>            Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87034>>>            Set Action_Text of ghoStatusPanel to ""
87035>>>        End
87035>>>>
87035>>>
87035>>>        Move (not(Err)) to bOK
87036>>>        If (bOK = True) Begin
87038>>>            // The attributes set above will always trigger an error
87038>>>            // We also adjust the Filelist entries
87038>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to (sDriverID + ":" + sRootName)
87041>>>            Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
87044>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
87047>>>
87047>>>            // This updates the .int file to make it up-to-date with the SQL back-end.
87047>>>            Get SqlUtilUpdateIntFile hTable to bOK
87048>>>        End
87048>>>>
87048>>>
87048>>>        Function_Return (bOK = True)
87049>>>    End_Function
87050>>>
87050>>>    // Sample usage:
87050>>>    //    Get ApiTableChangeAttribute SysInfo.File_Number DF_FILE_IS_SYSTEM_FILE True to bOK
87050>>>    //    Get ApiTableChangeAttribute OrderHea.File_Number DF_FILE_REUSE_DELETED DF_FILE_DELETED_NOREUSE to bOK
87050>>>    Function ApiTableChangeAttribute Handle hTable Integer iAttribute Integer iValue Returns Boolean
87052>>>        Boolean bOK bIsSQLTable
87052>>>
87052>>>        Get AutoConnectionIDLogin to bOK
87053>>>        Move False to Err
87054>>>        Get OpenTableExclusive hTable to bOK
87055>>>        If (bOK = False) Begin
87057>>>            Function_Return False
87058>>>        End 
87058>>>>
87058>>>        
87058>>>        // ToDo: Add to all table change functions!
87058>>>            Get UtilTableIsSQL hTable to bIsSQLTable
87059>>>            If (bIsSQLTable = True) Begin
87061>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
87064>>>            End
87064>>>>
87064>>>        
87064>>>        Set Private.phCurrentTable to hTable
87065>>>        Structure_Start hTable
87066>>>            Set_Attribute iAttribute of hTable to iValue
87069>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87070>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87072>>>
87072>>>        Set Action_Text of ghoStatusPanel to ""
87073>>>        Function_Return (Err = False)
87074>>>    End_Function
87075>>>
87075>>>    // To use a filelist slot for the passed FileName, TableName & DisplayName,
87075>>>    // or to change the filelist slot names.
87075>>>    Function ApiTableChangeFileListSlot String sRootName String sLogicalName String sDisplayName Handle hTable String sDriverID Returns Boolean
87077>>>        Boolean bExists
87077>>>
87077>>>        Move False to Err
87078>>>        Get UtilTableNumberIsInUse hTable to bExists
87079>>>        If (bExists = False) Begin
87081>>>            Function_Return False
87082>>>        End
87082>>>>
87082>>>
87082>>>        If (ghoProgressBar <> 0) Begin
87084>>>            Send DoAdvance of ghoProgressBar
87085>>>            Set TableName_Text of ghoStatusPanel to ("Changing Filelist slot for Table:" * String(sLogicalName) * "Number:" * String(hTable))
87086>>>        End
87086>>>>
87086>>>        // If all strings are empty it means that we should remove this entry from filelist.
87086>>>        If (sRootName = "" and sLogicalName = "" and sDisplayName = "") Begin
87088>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
87091>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
87094>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
87097>>>            Function_Return (Err = False) // And we're done.
87098>>>        End
87098>>>>
87098>>>
87098>>>        If (sDriverID <> DATAFLEX_ID) Begin
87100>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
87103>>>        End
87103>>>>
87103>>>        Else Begin
87104>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
87107>>>        End
87107>>>>
87107>>>
87107>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
87110>>>
87110>>>        If (sDriverID <> DATAFLEX_ID and not(Uppercase(sDisplayName) contains "DBO.")) Begin
87112>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ("dbo." + sDisplayName)
87115>>>        End
87115>>>>
87115>>>        Else Begin
87116>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
87119>>>        End
87119>>>>
87119>>>
87119>>>        Function_Return (Err = False)
87120>>>    End_Function
87121>>>
87121>>>    Function ApiTableChangeRecordLength Handle hTable Integer iRecordLength Returns Boolean
87123>>>        Boolean bOK
87123>>>
87123>>>        Get AutoConnectionIDLogin to bOK
87124>>>        Move False to Err
87125>>>        Get OpenTableExclusive hTable to bOK
87126>>>        If (bOK = False) Begin
87128>>>            Function_Return False
87129>>>        End
87129>>>>
87129>>>
87129>>>        Set Private.phCurrentTable to hTable
87130>>>        Structure_Start hTable
87131>>>            Set_Attribute DF_FILE_RECORD_LENGTH of hTable to iRecordLength
87134>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87135>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87137>>>
87137>>>        Set Action_Text of ghoStatusPanel to ""
87138>>>        Function_Return (Err = False)
87139>>>    End_Function
87140>>>
87140>>>    Function ApiTableChangeRelation Handle hTable Handle hToTable Integer iFromField Integer iToField Returns Boolean
87142>>>        Boolean bOK
87142>>>
87142>>>        Move False to Err
87143>>>        Get AutoConnectionIDLogin to bOK
87144>>>        Open hToTable
87146>>>        Get OpenTableExclusive hTable to bOK
87147>>>        If (bOK = False) Begin
87149>>>            Function_Return False
87150>>>        End
87150>>>>
87150>>>
87150>>>        Set Private.phCurrentTable to hTable
87151>>>        Structure_Start hTable
87152>>>            Set_Attribute DF_FIELD_RELATED_FILE  of hTable iFromField to hToTable
87155>>>            Set_Attribute DF_FIELD_RELATED_FIELD of hTable iFromField to iToField
87158>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87159>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87161>>>
87161>>>        Set Action_Text of ghoStatusPanel to ""
87162>>>        Function_Return (Err = False)
87163>>>    End_Function
87164>>>
87164>>>    Procedure ApiTableConvertAllAddException Integer hTable
87166>>>        Integer[] aTableConvertExceptions
87167>>>        Get paTableConvertExceptions to aTableConvertExceptions
87168>>>        Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
87169>>>        Set paTableConvertExceptions to aTableConvertExceptions
87170>>>    End_Procedure
87171>>>
87171>>>    Procedure ApiTableDateCorrectionAddException Integer hTable
87173>>>        Integer[] aTableDateCorrectionExceptions
87174>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
87175>>>        Move hTable to aTableDateCorrectionExceptions[SizeOfArray(aTableDateCorrectionExceptions)]
87176>>>        Set paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
87177>>>    End_Procedure
87178>>>
87178>>>    Procedure ApiTableConvertALLToSql
87180>>>        Integer[] iTablesArray
87181>>>        Integer iSize iCount
87181>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
87181>>>        String sDriverID
87181>>>
87181>>>        Get psDriverID to sDriverID
87182>>>        Get pbUseConnectionID to bUseConnectionID
87183>>>        Get pbToANSI          to bToANSI
87184>>>        Get pbRecnum          to bRecnum
87185>>>        Get pbCopyData        to bCopyData
87186>>>        If (ghoDbUpdateHandler > 0) Begin
87188>>>            Get pbContinueOnError to bContinueOnError
87189>>>        End
87189>>>>
87189>>>
87189>>>        Get _AllTablesToConvert to iTablesArray
87190>>>        Move (SizeOfArray(iTablesArray)) to iSize
87191>>>        Set pbVisible   of ghoProgressBarOverall to True
87192>>>        Set piPosition  of ghoProgressBarOverall to 0
87193>>>        Set piAdvanceBy of ghoProgressBarOverall to 1
87194>>>        Set piMaximum   of ghoProgressBarOverall to iSize
87195>>>
87195>>>        Decrement iSize
87196>>>        For iCount from 0 to iSize
87202>>>>
87202>>>            Set piPosition of ghoProgressBarOverall to iCount
87203>>>            Get ApiTableConvertToSQL_Ex iTablesArray[iCount] sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
87204>>>            // Probably the right logic here is to just continue trying to convert every table even
87204>>>            // if there was an error converting one table...
87204>>>            //If (bContinueOnError = False and bOK = False) Break
87204>>>        Loop
87205>>>>
87205>>>
87205>>>    End_Procedure
87206>>>
87206>>>    Procedure ApiTableAttachALLToSql
87208>>>        Integer[] iTablesArray
87209>>>        Integer iSize iCount
87209>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
87209>>>        String sDriverID
87209>>>
87209>>>        Get psDriverID to sDriverID
87210>>>        Get pbUseConnectionID to bUseConnectionID
87211>>>        Get pbToANSI          to bToANSI
87212>>>        Get pbRecnum          to bRecnum
87213>>>        Get pbCopyData        to bCopyData
87214>>>        If (ghoDbUpdateHandler > 0) Begin
87216>>>            Get pbContinueOnError to bContinueOnError
87217>>>        End
87217>>>>
87217>>>
87217>>>        Get _AllTablesToConvert to iTablesArray
87218>>>        Move (SizeOfArray(iTablesArray)) to iSize
87219>>>        Decrement iSize
87220>>>        For iCount from 0 to iSize
87226>>>>
87226>>>            Get ApiTableAttachToSQL iTablesArray[iCount] bUseConnectionID to bOK
87227>>>        Loop
87228>>>>
87228>>>
87228>>>    End_Procedure      
87229>>>    
87229>>>    // Subfunction to the ApiTableUpdate function (et al)
87229>>>    Function _UtilTableCheckChangeFilelistNames tAPITableNameInfo APITableNameInfoFrom Boolean bIsSQLTableTo Returns Boolean
87231>>>        Handle hTable 
87231>>>        String sRootNameTo sLogicalNameTo sDisplayNameTo sConnectionID
87231>>>        Boolean bIsSQLTableFrom bTableExists bSameTableNames bANSI bOK
87231>>>        
87231>>>        Get ApiTableFilelistNamesCompare True APITableNameInfoFrom to bSameTableNames
87232>>>        If (bSameTableNames = True) Begin
87234>>>            Function_Return True
87235>>>        End 
87235>>>>
87235>>>        
87235>>>        Move True to bOK
87236>>>        Move APITableNameInfoFrom.iTableNumber  to hTable  
87237>>>        Set Private.phCurrentTable              to hTable
87238>>>        Set_Attribute DF_FILE_ROOT_NAME         of hTable to APITableNameInfoFrom.sRootName
87241>>>        Set_Attribute DF_FILE_LOGICAL_NAME      of hTable to APITableNameInfoFrom.sLogicalName
87244>>>        Set_Attribute DF_FILE_DISPLAY_NAME      of hTable to APITableNameInfoFrom.sDisplayName
87247>>>        
87247>>>        If (APITableNameInfoFrom.bIsSQL = True) Begin
87249>>>            Get psConnectionID to sConnectionID
87250>>>            Get UtilTableExists hTable to bTableExists
87251>>>            If (bTableExists = True) Begin  
87253>>>                Get SqlUtilUpdateIntFile hTable to bOK
87254>>>            End
87254>>>>
87254>>>            Else Begin
87255>>>                Get pbToANSI to bANSI 
87256>>>                Get SqlUtilCreateIntFile hTable APITableNameInfoFrom.sDriverID sConnectionID bANSI False to bOK
87257>>>            End
87257>>>>
87257>>>        End
87257>>>>
87257>>>
87257>>>        Function_Return bOK
87258>>>    End_Function
87259>>>
87259>>>    Function ApiTableConvertToSql_Ex Handle hTable String sDriverID Boolean bUseConnectionID Boolean bToAnsi Boolean bRecnum Boolean bCopyData Returns Boolean
87261>>>        Handle hToTable hoLogFile
87261>>>        Boolean bOK bExists bOpened bMertechDriver bDAWDriver bContinueOnError bIsAlias
87261>>>        String sPhysicalName sRootName sLogicalName sDisplayName sConnectionID sConnectionString
87261>>>        String sANSI_OEM sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace sDatabase sGUIDName sWarning
87261>>>        tSQLConnection SQLConnection
87261>>>        tSQLConnection SQLConnection
87261>>>        
87261>>>        Get UtilTableIsAlias hTable to bIsAlias
87262>>>        // If this is an Alias file there is nothing to convert to SQL.
87262>>>        // Instead we change the Filelist.cfg by adding the driver id to the rootname and create an .int file
87262>>>        If (bIsAlias = True) Begin
87264>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
87267>>>            If (sDriverID <> DATAFLEX_ID and not(sRootName contains ":")) Begin
87269>>>                Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
87272>>>                Get psConnectionID to sConnectionID
87273>>>                Get SqlUtilCreateIntFile hTable sDriverID sConnectionID True False to bOK
87274>>>            End
87274>>>>
87274>>>            Function_Return True
87275>>>        End
87275>>>>
87275>>>
87275>>>        Set Private.phCurrentTable to hTable
87276>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
87279>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
87282>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
87285>>>
87285>>>        If (ghoProgressBar <> 0) Begin
87287>>>            Send DoAdvance of ghoProgressBar
87288>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(sLogicalName))
87289>>>        End
87289>>>>
87289>>>
87289>>>        // Marco Kuipers suggestion;
87289>>>        // If Filelist.cfg points to an embedded .dat table and the table already exists as
87289>>>        // an SQL table; rename the SQL table by adding a GUID at the end, then convert the
87289>>>        // table again.
87289>>>        Get UtilTableIsSQL hTable to bOK
87290>>>        If (bOK = False) Begin
87292>>>            Get SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
87293>>>            If (bExists = True) Begin
87295>>>                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
87296>>>                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
87297>>>                Get phoLogFile to hoLogFile
87298>>>                If (hoLogFile <> 0) Begin
87300>>>                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The existing SQL table was renamed to:" * String(sGUIDName) * "and then converted again.") to sWarning
87301>>>                    Send LogError sWarning False
87302>>>                End
87302>>>>
87302>>>                Else Begin
87303>>>                    Error DFERR_PROGRAM sWarning
87304>>>>
87304>>>                End
87304>>>>
87304>>>            End
87304>>>>
87304>>>        End
87304>>>>
87304>>>
87304>>>        // Does the rootname contain a driver?
87304>>>        If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
87306>>>            // Does the table already exist as an SQL table?
87306>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
87307>>>            // It can happen that the table is missing from Filelist.cfg but still
87307>>>            // exist on the SQL side, in case we want to search for the table by its name.
87307>>>            If (bExists = False) Begin
87309>>>                Get SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
87310>>>            End
87310>>>>
87310>>>            If (bExists = True) Begin
87312>>>                Set TableName_Text of ghoStatusPanel to ""
87313>>>                Function_Return False
87314>>>            End
87314>>>>
87314>>>        End
87314>>>>
87314>>>        Move (If(bToAnsi = True, CS_ANSI_Txt, CS_OEM_Txt)) to sANSI_OEM
87315>>>
87315>>>        Get IsDAWSQLDriver sDriverID to bDAWDriver
87316>>>        // Mertech drivers don't use Connection ID's; so if bUseConnectionID was
87316>>>        // passed as True, we adjust for that here.
87316>>>        Get IsMertechDriver sDriverID to bMertechDriver
87317>>>        If (bMertechDriver = True and bUseConnectionID = True) Begin
87319>>>            Move False to bUseConnectionID
87320>>>        End
87320>>>>
87320>>>
87320>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
87321>>>        Move SQLConnection.sSchema           to sSchema
87322>>>        If (sSchema = "") Begin
87324>>>            Get _SqlFindKeyWord CI_SQLDBO    to sSchema
87325>>>            Move (Lowercase(sSchema))        to sSchema
87326>>>        End
87326>>>>
87326>>>
87326>>>        If (sDriverID = ORAFLEX) Begin
87328>>>            Move SQLConnection.sUserID       to sSchema
87329>>>        End
87329>>>>
87329>>>
87329>>>        Move SQLConnection.sDatabase         to sDatabase
87330>>>        Move SQLConnection.sConnectionID     to sConnectionID
87331>>>        Move SQLConnection.sConnectionString to sConnectionString
87332>>>        If (sConnectionID = "" or sConnectionString = "") Begin
87334>>>            Error DFERR_PROGRAM ("The SQL connection info has NOT been setup. Could not convert table:" * String(hTable) * "to SQL")
87335>>>>
87335>>>            Function_Return False
87336>>>        End
87336>>>>
87336>>>
87336>>>        Get AutoConnectionIDLogin to bOK
87337>>>        Open hTable
87339>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
87342>>>        If (bOpened = False) Begin
87344>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
87345>>>>
87345>>>            Function_Return False
87346>>>        End
87346>>>>
87346>>>
87346>>>        If (ghoProgressBar <> 0) Begin
87348>>>            Send DoAdvance of ghoProgressBar
87349>>>            Set TableName_Text of ghoStatusPanel to ("Converting to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable))
87350>>>        End
87350>>>>
87350>>>
87350>>>        Move 0 to hToTable
87351>>>        Get _TableNameOnly sRootName                 to sRootName
87352>>>        Move (sRootName + ".int")                    to sPhysicalName
87353>>>
87353>>>        Case Begin
87353>>>            Case (sDriverID = MSSQLDRV_ID)
87355>>>                Case Break
87356>>>            Case (sDriverID = ODBC_DRV_ID)
87359>>>                Case Break
87360>>>            Case (sDriverID = DB2_DRV_ID)
87363>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
87364>>>                Move SQLConnection.sLongTableSpace  to sLongTableSpace
87365>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
87366>>>                Case Break
87367>>>            Case (sDriverID = ORAFLEX)
87370>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
87371>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
87372>>>                Case Break
87373>>>            Case (sDriverID = MDSMySQL)
87376>>>                Case Break
87377>>>            Case (sDriverID = MDSPgSQL)
87380>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
87381>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
87382>>>                Case Break
87383>>>            Case (sDriverID = DATAFLEX_ID)
87386>>>                Case Break
87387>>>            Case Else
87387>>>                Error DFERR_PROGRAM "Wrong database driver passed to the 'ApiTableConvertToSQL_Ex' function."
87388>>>>
87388>>>                Case Break
87389>>>        Case End
87389>>>
87389>>>        Move False to Err
87390>>>
87390>>>        If (bIsAlias = False) Begin
87392>>>
87392>>>            If (bMertechDriver = True) Begin
87394>>>                // Note: This function also sets the Err flag.
87394>>>                Get _MertechApiTableConvertToSQL hTable sRootName sDatabase sDriverID sBaseTableSpace sIndexTableSpace bCopyData to bOK
87395>>>            End
87395>>>>
87395>>>
87395>>>            If (bMertechDriver = False) Begin
87397>>>                Structure_Start hToTable sDriverID
87398>>>                    Structure_Copy hTable to hToTable
87399>>>
87399>>>                    Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
87402>>>
87402>>>                    If (sDriverID <> DATAFLEX_ID) Begin
87404>>>                        If (bUseConnectionID = True) Begin
87406>>>                            Set_Attribute DF_FILE_LOGIN     of hToTable to (CS_DFCONNID + "=" + sConnectionID)
87409>>>                        End
87409>>>>
87409>>>                        Else Begin
87410>>>                            Set_Attribute DF_FILE_LOGIN     of hToTable to sConnectionString
87413>>>                        End
87413>>>>
87413>>>
87413>>>                        Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT   of hToTable to sANSI_OEM
87416>>>                        Set_Attribute DF_FILE_RECNUM_TABLE             of hToTable to bRecnum
87419>>>
87419>>>                        If (sSchema <> "") Begin
87421>>>                            Set_Attribute DF_FILE_OWNER                of hToTable to sSchema
87424>>>                        End
87424>>>>
87424>>>
87424>>>                        If (sDriverID = DB2_DRV_ID) Begin
87426>>>                            If (sLongTableSpace <> "") Begin
87428>>>                                Set_Attribute DF_FILE_LONG_TABLESPACE  of hToTable to sLongTableSpace
87431>>>                            End
87431>>>>
87431>>>                            If (sBaseTableSpace <> "") Begin
87433>>>                                Set_Attribute DF_FILE_TABLE_TABLESPACE of hToTable to sBaseTableSpace
87436>>>                            End
87436>>>>
87436>>>                            If (sIndexTableSpace <> "") Begin
87438>>>                                Set_Attribute DF_FILE_INDEX_TABLESPACE of hToTable to sIndexTableSpace
87441>>>                            End
87441>>>>
87441>>>                        End
87441>>>>
87441>>>                    End
87441>>>>
87441>>>
87441>>>                    Set Action_Text of ghoStatusPanel to "Restructures table..."
87442>>>                Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87444>>>                Set Action_Text of ghoStatusPanel to ""
87445>>>            End
87445>>>>
87445>>>
87445>>>            Move (not(Err)) to bOK
87446>>>            If (bOK = True and bCopyData = True and bMertechDriver = False) Begin
87448>>>                If (bIsAlias = False) Begin
87450>>>                    Get ApiTableCopyData hTable sPhysicalName sRootName sDriverID to bOK
87451>>>                    If (ghoDbUpdateHandler > 0) Begin
87453>>>                        Get pbContinueOnError to bContinueOnError
87454>>>                    End
87454>>>>
87454>>>                    // If the data copy failed we will keep the newly created SQL table but
87454>>>                    // rename it by adding a GUID at the end of the table name
87454>>>                    // - or as much as "fit" because different SQL back-ends have
87454>>>                    // different rules how long a table name can be.
87454>>>                    // The new table will probably contain data but something went
87454>>>                    // wrong while converting the data from embedded to SQL.
87454>>>                    If (bOK = False and bContinueOnError = False) Begin
87456>>>                        Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
87457>>>                        Get SqlTableRename hTable sLogicalName sGUIDName to bOK
87458>>>                        Error DFERR_PROGRAM ("Copying of data failed. The SQL table:" * sLogicalName * "was renamed to:" * String(sGUIDName))
87459>>>>
87459>>>                    End
87459>>>>
87459>>>                End
87459>>>>
87459>>>            End
87459>>>>
87459>>>        End
87459>>>>
87459>>>
87459>>>        If (bMertechDriver = True) Begin
87461>>>            Open hTable
87463>>>        End
87463>>>>
87463>>>
87463>>>        // This must be after copying data...
87463>>>        If (Err = False) Begin
87465>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
87468>>>            // We also adjust the display name by prefixing it by the schema name;
87468>>>            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
87470>>>                // The max length for the display_name is 31 characters...
87470>>>                If (Length(sSchema + "." + sDisplayName) < 31) Begin
87472>>>                    Set_Attribute DF_FILE_DISPLAY_NAME of hTable to (Lowercase(sSchema) + "." + sDisplayName)
87475>>>                End
87475>>>>
87475>>>            End
87475>>>>
87475>>>        End
87475>>>>
87475>>>
87475>>>        Close hTable
87476>>>        Move (not(Err)) to bOK
87477>>>        Function_Return (bOK = True)
87478>>>    End_Function
87479>>>
87479>>>    // Calls a driver function directly to copy data from one table to another (table structures needs to be the same).
87479>>>    // It will first drop all indicies, copy the data and then recreate indicies.
87479>>>    // An error log file with the sRootname + ".err" will be created in the Data folder.
87479>>>    Function ApiTableCopyData Integer hFromTable String sPhysicalName String sRootName String sDriverID Returns Boolean
87481>>>        Boolean bOpened bOK
87481>>>        Integer hToTable iIndex iRetval iVoid iOrgFreq
87481>>>        String sErrorFile sEmpty sPath
87481>>>
87481>>>        Get_Attribute DF_FILE_NEXT_EMPTY of 0 to hToTable
87484>>>        Get AutoConnectionIDLogin to bOK
87485>>>        If (sDriverID = DATAFLEX_ID) Begin
87487>>>            Send IncreaseSortBufferSize
87488>>>//            Send SetAllIndexesToBatch hToTable
87488>>>        End
87488>>>>
87488>>>
87488>>>        Move False to Err
87489>>>        Open sPhysicalName as hToTable
87491>>>        Get_Attribute DF_FILE_OPENED of hToTable to bOpened
87494>>>        If (bOpened = False) Begin
87496>>>            Function_Return False
87497>>>        End
87497>>>>
87497>>>
87497>>>        If (ghoStatusPanel <> 0) Begin
87499>>>            Set TableName_Text of ghoStatusPanel to ("Copying Data for Table:" * sRootName * "Number:" * String(hFromTable))
87500>>>            Set piMinimum of ghoProgressBar to 0 
87501>>>            Set piMaximum of ghoProgressBar to 100 // 100%
87502>>>        End
87502>>>>
87502>>>
87502>>>        Move "" to sEmpty
87503>>>        Move False to Err
87504>>>        Move True to bOK
87505>>>        Set Private.phCurrentTable to hToTable
87506>>>
87506>>>        // No need to get the record identifier
87506>>>        Set_Attribute DF_FILE_GET_RID_AFTER_CREATE of hToTable to False        
87509>>>        Get_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
87512>>>        If (sDriverID <> DATAFLEX_ID) Begin
87514>>>            // Remove all indices to speed up copying of data:
87514>>>            Call_Driver hToTable sDriverID Function CLI_DROPINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
87519>>>            If (iRetval <> 0) Begin
87521>>>                Error DFERR_PROGRAM ("Failed dropping indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
87522>>>>
87522>>>                Function_Return False
87523>>>            End
87523>>>>
87523>>>        End
87523>>>>
87523>>>
87523>>>        Move (sRootName + ".err") to sErrorFile
87524>>>        Move 0 to iIndex
87525>>>        Move False to Err
87526>>>        
87526>>>        If (sDriverID = MSSQLDRV_ID) Begin
87528>>>            Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to 10
87531>>>            Call_Driver hToTable sDriverID Function CLI_BCP CallBack ghoDbUpdateHandler Passing iIndex sEmpty hFromTable Result iRetval
87536>>>            If (iRetval <> 0) Begin
87538>>>                Error DFERR_PROGRAM ("Failed copying data for table Number:" * String(hToTable) * "Name:" * String(sRootName))
87539>>>>
87539>>>                Function_Return False
87540>>>            End
87540>>>>
87540>>>        End 
87540>>>>
87540>>>        Else Begin
87541>>>            Copy_Records hFromTable to hToTable using 0 Callback ghoDbUpdateHandler
87544>>>        End
87544>>>>
87544>>>
87544>>>        If (Err = False) Begin
87546>>>            Get psHome of (phoWorkspace(ghoApplication)) to sPath
87547>>>            Get vDeleteFile (sPath + sErrorFile) to iRetval
87548>>>        End
87548>>>>
87548>>>
87548>>>        If (sDriverID <> DATAFLEX_ID) Begin
87550>>>            // Recreate indices:
87550>>>            Call_Driver hToTable sDriverID Function CLI_CREATEINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
87555>>>            If (iRetval <> 0) Begin
87557>>>                Error DFERR_PROGRAM ("Failed creating indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
87558>>>>
87558>>>                Function_Return False
87559>>>            End
87559>>>>
87559>>>        End
87559>>>>
87559>>>
87559>>>        Close hToTable
87560>>>        Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
87563>>>
87563>>>        If (bOK = True) Begin
87565>>>            Move (not(Err)) to bOK
87566>>>        End
87566>>>>
87566>>>
87566>>>        If (ghoStatusPanel <> 0) Begin
87568>>>            Set TableName_Text of ghoStatusPanel to ""
87569>>>            Set Message_Text   of ghoStatusPanel to ""
87570>>>            Set Action_Text    of ghoStatusPanel to ""
87571>>>        End
87571>>>>
87571>>>
87571>>>        Function_Return (bOK = True)
87572>>>    End_Function
87573>>>
87573>>>    // The bANSI parameter's default value = True, meaning a table in ANSI format will be created.
87573>>>    // i.e. DF_FILE_TABLE_CHARACTER_FORMAT {"OEM"|"ANSI"}
87573>>>    Function ApiTableCreate Handle hTable String sRootName String sDisplayName String sLogicalName Boolean bUseConnectionID Boolean bANSI Boolean bRecnum tAPIColumn[] aColumnIn Returns Boolean
87575>>>        Handle hFile
87575>>>        String sConnectionID sPhysicalFile sANSI_OEM sVal sSchema sOriginalDriverID sDriverID sTableName
87575>>>        Integer iColumn iIdentityType iDataType iDbType iCount iSize
87575>>>        Boolean bOk bExists bSqlDriver bMertechDriver bDeleteDummy bExistsInFilelist bSysFile
87575>>>        tSQLConnection SQLConnection
87575>>>        tSQLConnection SQLConnection
87575>>>        tAPIColumn[] aColumns
87575>>>        tAPIColumn[] aColumns
87576>>>        tColumnType ColumnType
87576>>>        tColumnType ColumnType
87576>>>
87576>>>        // First check if the passed filenumber already exists; in case we do nothing
87576>>>        Get UtilTableExists hTable to bOk
87577>>>        If (bOk = True) Begin
87579>>>            Function_Return False
87580>>>        End
87580>>>>
87580>>>
87580>>>        Set Private.phCurrentTable to hTable
87581>>>        Move sLogicalName to sTableName
87582>>>        If (ghoProgressBar <> 0) Begin
87584>>>            Send DoAdvance of ghoProgressBar
87585>>>            Set TableName_Text of ghoStatusPanel to ("Creating Table:" * String(sTableName) * "Number:" * String(hTable) * String(sLogicalName))
87586>>>        End
87586>>>>
87586>>>
87586>>>        Get UtilTableLogicalNameIsInUse sTableName to bExistsInFilelist
87587>>>        Get psDriverID to sDriverID
87588>>>        Get IsSQLDriver sDriverID to bSqlDriver
87589>>>        Get piDbType to iDbType
87590>>>
87590>>>        // If no columns passed in, we need to create a "dummy" column
87590>>>        Move False to bDeleteDummy
87591>>>        If (Num_Arguments = 8) Begin
87593>>>            Move aColumnIn to aColumns
87594>>>        End
87594>>>>
87594>>>        If ((SizeOfArray(aColumns)) = 0) Begin
87596>>>            Get UtilDFDataTypeToSqlTypeMapping sDriverID iDbType DF_BCD to ColumnType
87597>>>            Move ColumnType.iSQLType to iDataType
87598>>>            If (bRecnum = False) Begin
87600>>>                Move C_tAPIColumn_Identity to iIdentityType
87601>>>            End
87601>>>>
87601>>>            Else Begin
87602>>>                Move C_tAPIColumn_None     to iIdentityType
87603>>>            End
87603>>>>
87603>>>            Get _AppendAPIColumn aColumns "temp" iDataType 10 0 iIdentityType to aColumns
87604>>>            Move True to bDeleteDummy
87605>>>        End
87605>>>>
87605>>>
87605>>>        // If columns have been passed as an array we need to check if an identity column
87605>>>        // has been specified (aColumns[iCounter].iOptions = C_tAPIColumn_Identity), and
87605>>>        // if so auto-set the bRecnum to FALSE. This is because else there would be
87605>>>        // two identity columns and SQL doesn't like that and throws an error.
87605>>>        If (bRecnum = True and (SizeOfArray(aColumns)) <> 0) Begin
87607>>>            Move (SizeOfArray(aColumns)) to iSize
87608>>>            Decrement iSize
87609>>>            for iCount from 0 to iSize
87615>>>>
87615>>>                If (aColumns[iCount].iOptions = C_tAPIColumn_Identity) Begin
87617>>>                    Move False to bRecnum
87618>>>                    Move iSize to iCount
87619>>>                End
87619>>>>
87619>>>            Loop
87620>>>>
87620>>>        End
87620>>>>
87620>>>
87620>>>        // If this is a SQL based driver we also check if the table exists
87620>>>        // in the SQL back end; in case we do nothing.
87620>>>        If (bSqlDriver = True) Begin
87622>>>            // Get all connection properties
87622>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
87623>>>            Move SQLConnection.sSchema to sSchema
87624>>>            If (sSchema = "") Begin
87626>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
87627>>>            End
87627>>>>
87627>>>
87627>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
87628>>>            // It can happen that the table is missing from Filelist.cfg but still
87628>>>            // exist on the SQL side, in case we want to search for the table by its name.
87628>>>            If (bExists = False) Begin
87630>>>                Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
87631>>>            End
87631>>>>
87631>>>            // If the table exists on the SQL back-end but not in Filelist.cfg,
87631>>>            // we will just add it to Filelist.cfg
87631>>>            If (bExists = True) Begin
87633>>>                If (bExistsInFilelist = False) Begin
87635>>>                    If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
87637>>>                        Move (sDriverID + ":" + sRootName) to sRootName
87638>>>                    End
87638>>>>
87638>>>                    Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
87641>>>                    Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
87644>>>                    Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
87647>>>                    Move False to bSysFile
87648>>>                    Get SqlUtilCreateIntFile hTable sDriverID SQLConnection.sConnectionID bANSI bSysFile to bOK
87649>>>                End
87649>>>>
87649>>>                Function_Return False
87650>>>            End
87650>>>>
87650>>>        End
87650>>>>
87650>>>
87650>>>        Move CS_ANSI_Txt to sANSI_OEM
87651>>>        If (num_arguments > 6) Begin
87653>>>            If (bANSI = False) Begin
87655>>>                Move CS_OEM_Txt to sANSI_OEM
87656>>>            End
87656>>>>
87656>>>        End
87656>>>>
87656>>>
87656>>>        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
87656>>>        // is a programmer's error and we auto-correct for it here.
87656>>>        // This is also a bit messy. If a Mertech driver is used and we want to create a new table,
87656>>>        // we first need to create it as embedded (DataFlex) and then convert it to SQL (!)
87656>>>        // So we set the driver ID temporarily to "DataFlex" to get the table created as embedded and later
87656>>>        // set it back and use a Mertech function to convert it to SQL.
87656>>>        Get IsMertechDriver sDriverID to bMertechDriver
87657>>>        If (bMertechDriver = True) Begin
87659>>>            If (bUseConnectionID = True) Begin
87661>>>                Move False to bUseConnectionID
87662>>>            End
87662>>>>
87662>>>            Move sDriverID to sOriginalDriverID
87663>>>            Move DATAFLEX_ID to sDriverID
87664>>>        End
87664>>>>
87664>>>
87664>>>        Move False to Err
87665>>>        If (sDriverID = DATAFLEX_ID) Begin
87667>>>            Move sRootName to sPhysicalFile
87668>>>        End
87668>>>>
87668>>>
87668>>>        If (sDriverID <> DATAFLEX_ID) Begin
87670>>>            Move SQLConnection.sConnectionID to sConnectionID
87671>>>
87671>>>            // If DAW driver and we should use a connection id we need to
87671>>>            // check if the connection ID exists; else we create it before attempting creating the table
87671>>>            If (bMertechDriver = False and bUseConnectionID = True) Begin
87673>>>                Get IsConnectionID sConnectionID sDriverID to bExists
87674>>>                If (bExists = False) Begin
87676>>>                    Get UtilCreateConnectionID sConnectionID to bOk
87677>>>                    If (bOk = False) Begin
87679>>>                        Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
87680>>>>
87680>>>                        Function_Return False
87681>>>                    End
87681>>>>
87681>>>                End
87681>>>>
87681>>>            End
87681>>>>
87681>>>
87681>>>            If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
87683>>>                Move (sTableName + ".int") to sPhysicalFile
87684>>>            End
87684>>>>
87684>>>            Else Begin
87685>>>                Move (sRootName + ".int") to sPhysicalFile
87686>>>            End
87686>>>>
87686>>>            Move (Uppercase(sDisplayName)) to sVal
87687>>>            If (not(sVal contains (sSchema + "."))) Begin
87689>>>                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
87690>>>            End
87690>>>>
87690>>>        End
87690>>>>
87690>>>        Move False to Err
87691>>>        Move 0 to hFile
87692>>>
87692>>>        Structure_Start hFile sDriverID
87693>>>            If (sDriverID <> DATAFLEX_ID) Begin
87695>>>                If (bUseConnectionID = True) Begin
87697>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to (CS_DFCONNID + "=" + sConnectionID)
87700>>>                End
87700>>>>
87700>>>                Else Begin
87701>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to SQLConnection.sConnectionString
87704>>>                End
87704>>>>
87704>>>                Set_Attribute DF_FILE_TABLE_NAME               of hFile to sTableName
87707>>>                Set_Attribute DF_FILE_USE_DUMMY_ZERO_DATE      of hFile to True
87710>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT   of hFile to sANSI_OEM
87713>>>                Set_Attribute DF_FILE_RECNUM_TABLE             of hFile to bRecnum
87716>>>
87716>>>                If (sSchema <> "") Begin
87718>>>                    Set_Attribute DF_FILE_OWNER                of hFile to sSchema
87721>>>                End
87721>>>>
87721>>>
87721>>>                If (sDriverID = DB2_DRV_ID) Begin
87723>>>                    If (SQLConnection.sLongTableSpace <> "") Begin
87725>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hFile to SQLConnection.sLongTableSpace
87728>>>                    End
87728>>>>
87728>>>                End
87728>>>>
87728>>>                If (sDriverID = DB2_DRV_ID or sDriverID = ORAFLEX or sDriverID = MDSPgSQL) Begin
87730>>>                    If (SQLConnection.sBaseTableSpace <> "") Begin
87732>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hFile to SQLConnection.sBaseTableSpace
87735>>>                    End
87735>>>>
87735>>>                    If (SQLConnection.sIndexTableSpace <> "") Begin
87737>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hFile to SQLConnection.sIndexTableSpace
87740>>>                    End
87740>>>>
87740>>>                End
87740>>>>
87740>>>            End
87740>>>>
87740>>>
87740>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hFile to sPhysicalFile
87743>>>            Get ApiColumnsAddToTable hFile aColumns True to bOk
87744>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87745>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87747>>>        Set Action_Text of ghoStatusPanel to ""
87748>>>
87748>>>        // If Mertech driver we convert the newly created embedded table (DataFlex) to SQL
87748>>>        If (bMertechDriver = True) Begin
87750>>>            Move sOriginalDriverID to sDriverID
87751>>>            If (not(sVal contains (sSchema + "."))) Begin
87753>>>                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
87754>>>            End
87754>>>>
87754>>>            // Note: This function also sets the Err flag.
87754>>>            Get _MertechApiTableConvertToSQL hTable sRootName SQLConnection.sDatabase sDriverID SQLConnection.sBaseTableSpace SQLConnection.sIndexTableSpace False to bOK
87755>>>        End
87755>>>>
87755>>>
87755>>>        Move (not(Err)) to bOK
87756>>>        If (bOk = True) Begin
87758>>>            If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
87760>>>                Move (sDriverID + ":" + sRootName) to sRootName
87761>>>            End
87761>>>>
87761>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
87764>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
87767>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
87770>>>
87770>>>            // Lastly we remove the temporary column we created above, if all went well.
87770>>>            If (bDeleteDummy) Begin
87772>>>                Get ApiColumnRemove hTable "temp" to bOk
87773>>>            End
87773>>>>
87773>>>        End
87773>>>>
87773>>>
87773>>>        Close hTable
87774>>>        Function_Return (bOK = True)
87775>>>    End_Function
87776>>>
87776>>>    Function ApiTableCreateAlias String sFileName String sDisplayName String sAliasName Integer iFilelistSlot Returns Boolean
87778>>>        Move False to Err
87779>>>        Set_Attribute DF_FILE_ROOT_NAME     of iFilelistSlot to sFileName
87782>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of iFilelistSlot to sDisplayName
87785>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of iFilelistSlot to sAliasName
87788>>>
87788>>>        Function_Return (Err = False)
87789>>>    End_Function
87790>>>
87790>>>    // ToDo: Needs to be revised
87790>>>    Procedure ApiTableCreateFromDEF String sPath String sFileName String sTableName String sDisplayName Integer iFilelistSlot
87792>>>        Handle hTable
87792>>>        String sDEFName sDataPath
87792>>>        Boolean bExists
87792>>>
87792>>>        // Do nothing if MSSQL Driver.
87792>>>//        Get IsMSSQLDriver to bExists
87792>>>//        If (bExists = True) Begin
87792>>>//            Procedure_Return
87792>>>//        End
87792>>>
87792>>>        Get psDataPathFirstPart to sDataPath
87793>>>        Get vFilePathExists (sDataPath + sFileName + ".dat") to bExists
87794>>>        If (bExists = True) Begin
87796>>>            // We also needs to check if it is an Alias file, in case the sFileName.dat exists, but it may
87796>>>            // still be missing from the filelist and needs to be added.
87796>>>            Get UtilTableNumberIsInUse iFilelistSlot to bExists
87797>>>            If (bExists = True) Begin
87799>>>                Procedure_Return
87800>>>            End
87800>>>>
87800>>>            // Do _not_ use the DEF file if an alias, it will overwrite the base table data.
87800>>>            Else Begin
87801>>>                Set_Attribute DF_FILE_ROOT_NAME    of iFilelistSlot to sFileName
87804>>>                Set_Attribute DF_FILE_LOGICAL_NAME of iFilelistSlot to sTableName
87807>>>                Set_Attribute DF_FILE_DISPLAY_NAME of iFilelistSlot to sDisplayName
87810>>>                Procedure_Return
87811>>>            End
87811>>>>
87811>>>        End
87811>>>>
87811>>>
87811>>>        Move (sPath + sFileName + ".def") to sDEFName
87812>>>        Move 0 to hTable
87813>>>        Move False to Err
87814>>>
87814>>>        Structure_Start hTable DATAFLEX_ID
87815>>>            Load_Def sDEFName Onto hTable
87816>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hTable to sFileName
87819>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87820>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87822>>>        Set Action_Text of ghoStatusPanel to ""
87823>>>
87823>>>        Move iFilelistSlot to hTable
87824>>>        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sFileName
87827>>>        Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
87830>>>        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
87833>>>
87833>>>    End_Procedure
87834>>>
87834>>>    Function ApiTableMoveToFileSlot Integer iFromFileSlot Integer iToFileSlot String sDriverID Returns Boolean
87836>>>        Boolean bTmp bErr bOK
87836>>>        String sTableName sDisplayName sFileName
87836>>>
87836>>>        // We preserve the value of the Err flag, by saving its current state and resetting it before end of function.
87836>>>        Move Err to bTmp
87837>>>        Move False to Err
87838>>>
87838>>>        Get AutoConnectionIDLogin to bOK
87839>>>        // First get the info for the current filelist slot:
87839>>>        Open iFromFileSlot
87841>>>        Get_Attribute DF_FILE_OPENED of iFromFileSlot to bOK
87844>>>        If (bOK = True) Begin
87846>>>            Get_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to sFileName
87849>>>            Get_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to sTableName
87852>>>            Get_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to sDisplayName
87855>>>
87855>>>            //...then move it.
87855>>>            Set_Attribute DF_FILE_ROOT_NAME    of iToFileSlot to sFileName
87858>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iToFileSlot to sTableName
87861>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iToFileSlot to sDisplayName
87864>>>
87864>>>            //...and finally remove the old filelist values.
87864>>>            Set_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to ""
87867>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to ""
87870>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to ""
87873>>>        End
87873>>>>
87873>>>        Close iFromFileSlot
87874>>>
87874>>>        Move Err to bErr
87875>>>        Move bTmp to Err
87876>>>        Function_Return (bErr = False)
87877>>>    End_Function
87878>>>
87878>>>    Function ApiTableRelate Handle hTableFrom Handle hTableTo Integer iColumnFrom Integer iColumnTo Returns Boolean
87880>>>        Handle hTable
87880>>>        Boolean bOK
87880>>>        String sDriverID
87880>>>
87880>>>        Get AutoConnectionIDLogin to bOK
87881>>>        Move False to Err
87882>>>        Open hTableFrom Mode DF_EXCLUSIVE
87884>>>        If (hTableTo > 0) Begin
87886>>>            Open hTableTo
87888>>>        End
87888>>>>
87888>>>        Move hTableFrom to hTable
87889>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
87892>>>        Set Private.phCurrentTable to hTable
87893>>>
87893>>>        Structure_Start hTable sDriverID            
87894>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumnFrom to hTableTo
87897>>>            If (iColumnTo <> 0) Begin
87899>>>                Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumnFrom to iColumnTo
87902>>>            End
87902>>>>
87902>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87903>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87905>>>        Set Action_Text of ghoStatusPanel to ""
87906>>>
87906>>>        If (hTableTo > 0) Begin
87908>>>            Close hTableTo
87909>>>        End
87909>>>>
87909>>>
87909>>>        Function_Return (Err = False)
87910>>>    End_Function
87911>>>
87911>>>    // Removes the passed table name completely from disk, filelist (& Sql Server if an Sql-driver)
87911>>>    Function ApiTableRemove Handle hTable Returns Boolean
87913>>>        String sTableName sDriverID
87913>>>        Boolean bOk
87913>>>        String sDataPath
87913>>>
87913>>>        Get AutoConnectionIDLogin to bOK
87914>>>        Move False to Err
87915>>>        Get psDriverID to sDriverID
87916>>>        Get UtilTableHandleToString hTable sDriverID to sTableName
87917>>>        If (sTableName = "") Begin
87919>>>            Function_Return False
87920>>>        End
87920>>>>
87920>>>
87920>>>        Set Private.phCurrentTable to hTable
87921>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
87922>>>        Delete_db sTableName
87923>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
87924>>>
87924>>>        If (sDriverID <> DATAFLEX_ID) Begin
87926>>>            Get SqlTableRemoveByTableName sDriverID sTableName to bOk
87927>>>            Get psDataPathFirstPart to sDataPath
87928>>>            Get vDeleteFile (sDataPath + sTableName + ".int") to bOk
87929>>>        End
87929>>>>
87929>>>        // Also remove table from filelist.cfg in case the physical file didn't exist.
87929>>>        If (hTable <> 0) Begin
87931>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
87934>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
87937>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
87940>>>        End
87940>>>>
87940>>>
87940>>>        Close hTable
87941>>>        Function_Return (hTable <> 0)
87942>>>    End_Function
87943>>>
87943>>>    Function ApiTableRemoveRelation Handle hTableTo Integer iColumn Returns Boolean
87945>>>        Handle hTable
87945>>>        Boolean bOK
87945>>>
87945>>>        Get AutoConnectionIDLogin to bOK
87946>>>        Move False to Err
87947>>>        Open hTableTo Mode DF_EXCLUSIVE
87949>>>        Move hTableTo to hTable
87950>>>
87950>>>        Structure_Start hTable
87951>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to 0
87954>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87955>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87957>>>        Set Action_Text of ghoStatusPanel to ""
87958>>>
87958>>>        Close hTableTo
87959>>>        Function_Return (Err = False)
87960>>>    End_Function
87961>>>
87961>>>    Function ApiTableRename Integer hTable String sRootName String sDisplayName String sLogicalName Returns Boolean
87963>>>        String sPhysicalName sRootNameTo sLogicalNameTo sDataPath sDriverID sSchema sPhysicalNameTo
87963>>>        Boolean bOK bExists bOpened     
87963>>>        tAPITableNameInfo APITableNameInfo
87963>>>        tAPITableNameInfo APITableNameInfo
87963>>>        
87963>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
87966>>>        If (bOpened = False) Begin
87968>>>            Get OpenTableExclusive hTable to bOpened
87969>>>            If (bOpened = False) Begin
87971>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
87972>>>                Function_Return False
87973>>>            End
87973>>>>
87973>>>        End
87973>>>>
87973>>>
87973>>>        Set Private.phCurrentTable to hTable
87974>>>        Move hTable         to APITableNameInfo.iTableNumber
87975>>>        Move sRootName      to APITableNameInfo.sRootName
87976>>>        Move sLogicalName   to APITableNameInfo.sLogicalName
87977>>>        Move sDisplayName   to APITableNameInfo.sDisplayName
87978>>>        Get ApiTableFilelistNamesCompare True APITableNameInfo to bExists
87979>>>        If (bExists = True) Begin
87981>>>            Function_Return True
87982>>>        End
87982>>>>
87982>>>        
87982>>>        Set Private.phCurrentTable to hTable
87983>>>        Move False to Err  
87984>>>        Get psDataPathFirstPart to sDataPath
87985>>>        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName
87988>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
87991>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
87994>>>
87994>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
87997>>>        Close hTable
87998>>>        If (sDriverID = DATAFLEX_ID) Begin
88000>>>            Get vFilePathExists (sDataPath + sRootNameTo + ".dat") to bExists
88001>>>            If (bExists = True) Begin
88003>>>                If (Uppercase(sRootName) <> Uppercase(sRootNameTo)) Begin
88005>>>                    Copy_db (sDataPath + sRootNameTo) to (sDataPath + sRootName)
88008>>>                    // We need a short break here before attempting to delete the physical old files or Windows
88008>>>                    // might report "File in use..." and the deletion will fail.
88008>>>                    Sleep 2
88009>>>                    Get vDeleteFile (sDataPath + sRootNameTo + ".*") to bOK
88010>>>                End
88010>>>>
88010>>>            End
88010>>>>
88010>>>        End
88010>>>>
88010>>>
88010>>>        If (sDriverID <> DATAFLEX_ID) Begin           
88012>>>            If (not(sPhysicalName contains ".")) Begin
88014>>>                Move (sPhysicalName + String(".int")) to sPhysicalName
88015>>>            End
88015>>>>
88015>>>            
88015>>>            // Change the table name in the .int file to the new table new:
88015>>>            Get UtilChangeSourceCodeLine (sDataPath + sPhysicalName) (CS_DATABASE_NAME * String(sLogicalNameTo)) (CS_DATABASE_NAME * String(sLogicalName)) False to bOK
88016>>>            If (bOK = False) Begin
88018>>>                Function_Return False
88019>>>            End
88019>>>>
88019>>>            
88019>>>            // Change table name at the SQL side:
88019>>>            Get psSchema to sSchema
88020>>>            Get SqlTableRename hTable sLogicalNameTo sLogicalName to bOK 
88021>>>            
88021>>>            Get _TableNameOnly sRootName to sPhysicalNameTo
88022>>>            // Remove cache file and Rename the physical file names:
88022>>>            Get vDeleteFile (sDataPath + sPhysicalNameTo + ".cch")                                  to bOK 
88023>>>            Get vRenameFile (sDataPath + sPhysicalName)            (sDataPath + sRootName + ".int") to bOK
88024>>>            Get vRenameFile (sDataPath + sPhysicalNameTo + ".tag") (sDataPath + sRootName + ".tag") to bOK
88025>>>            Move (sDriverID + ":" + sRootName) to sRootName         
88026>>>            If (not(sDisplayName contains ".")) Begin
88028>>>                Move (sSchema + "." + sDisplayName) to sDisplayName
88029>>>            End
88029>>>>
88029>>>        End
88029>>>>
88029>>>
88029>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
88032>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
88035>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
88038>>>
88038>>>        Function_Return (Err = False)
88039>>>    End_Function
88040>>>
88040>>>    Function ApiTableRenameAlias Integer hTable String sDisplayName String sLogicalName Returns Boolean
88042>>>        Move False to Err
88043>>>        Set Private.phCurrentTable to hTable
88044>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
88047>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
88050>>>
88050>>>        Function_Return (Err = False)
88051>>>    End_Function
88052>>>
88052>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
88052>>>    // Note that it first removes any driver prefixes in the rootname.
88052>>>    Function ApiTableFilelistNamesCompare Boolean bCompareFilelistUppercase tAPITableNameInfo APITableInfo Returns Boolean
88054>>>        String sRootNameFrom sRootNameTo sDisplayNameTo sLogicalNameTo
88054>>>        Handle hTable
88054>>>        Boolean bIsSame
88054>>>
88054>>>        Move APITableInfo.iTableNumber      to hTable
88055>>>        Get _TableNameOnly APITableInfo.sRootName     to sRootNameFrom
88056>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
88059>>>        Get _TableNoPrefix sRootNameTo                to sRootNameTo
88060>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
88063>>>        Get_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayNameTo
88066>>>        Get _TableNoPrefix sDisplayNameTo             to sDisplayNameTo
88067>>>
88067>>>        If (bCompareFilelistUppercase = True) Begin
88069>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(APITableInfo.sLogicalName) = Uppercase(sLogicalNameTo) and ;                  Uppercase(APITableInfo.sDisplayName) = Uppercase(sDisplayNameTo)) to bIsSame
88070>>>        End
88070>>>>
88070>>>        Else Begin
88071>>>            Move (sRootNameFrom = sRootNameTo and APITableInfo.sLogicalName = sLogicalNameTo and APITableInfo.sDisplayName = sDisplayNameTo) to bIsSame
88072>>>        End
88072>>>>
88072>>>
88072>>>        Function_Return bIsSame
88073>>>    End_Function
88074>>>    
88074>>>    // Note: This table update function does _not_ convert an embedded table to SQL. Use function ApiTableConvertToSQL first for that.
88074>>>    Function ApiTableUpdate tAPITableNameInfo APITableNameInfoFrom tAPIColumn[] aColumnsFrom tAPIIndex[] aIndexesFrom tAPIRelation[] aRelationsFrom Returns Boolean
88076>>>        Handle hFile hTable
88076>>>        String sTableName sLogicalName sDisplayName
88076>>>        String sConnectionID sVal sSchema sOriginalDriverID sDriverIDFrom sDriverIDTo sRootName
88076>>>        Integer iColumn iDbType
88076>>>        Boolean bOk bExists bMertechDriver bExistsInFilelist bOpened bApiTableUpdateAuto
88076>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase bTableExists
88076>>>        Boolean bIsSame bSameTableNames bFilelistError bIsAliasFrom bIsAliasTo bIsSQLTableFrom bIsSQLTableTo
88076>>>        tSQLConnection SQLConnection
88076>>>        tSQLConnection SQLConnection
88076>>>        tAPITable      APITableFrom APITableTo
88076>>>        tAPITable      APITableFrom APITableTo
88076>>>        tColumnType    ColumnType
88076>>>        tColumnType    ColumnType
88076>>>        tAPIColumnCompare[]   aAPIColumnCompare
88076>>>        tAPIColumnCompare[]   aAPIColumnCompare
88077>>>        tAPIIndexCompare[]    aAPIIndexCompare
88077>>>        tAPIIndexCompare[]    aAPIIndexCompare
88078>>>        tAPIRelationCompare[] aAPIRelationCompare
88078>>>        tAPIRelationCompare[] aAPIRelationCompare
88079>>>
88079>>>        // We don't allow update of the framework's DbVersion table.
88079>>>        If (Lowercase(sTableName) = "dbversion") Begin
88081>>>            Function_Return False
88082>>>        End
88082>>>>
88082>>>        
88082>>>        Move APITableNameInfoFrom.sDriverID     to sDriverIDFrom
88083>>>        Get piDbType                            to iDbType
88084>>>        Get pbRecnum                            to bRecnum
88085>>>        Get pbToANSI                            to bToANSI
88086>>>        Get pbCopyData                          to bCopyData
88087>>>        Get pbApiTableUpdateAuto                to bApiTableUpdateAuto
88088>>>        Get pbCompareDate_DateTime              to bCompareDate_DateTime
88089>>>        Get pbCompareIndexAscending             to bCompareIndexAscending
88090>>>        Get pbCompareIndexUppercase             to bCompareIndexUppercase   
88091>>>        Get IsMertechDriver sDriverIDFrom       to bMertechDriver
88092>>>        Get pbUseConnectionID                   to bUseConnectionID
88093>>>        If (bMertechDriver = True and bUseConnectionID = True) Begin
88095>>>            Move False                          to bUseConnectionID
88096>>>        End
88096>>>>
88096>>>
88096>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
88097>>>        Set Private.phCurrentTable              to hTable
88098>>>        Get UtilTableExists  hTable             to bTableExists     
88099>>>        
88099>>>        If (ghoProgressBar <> 0) Begin
88101>>>            Send DoAdvance of ghoProgressBar
88102>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
88103>>>        End
88103>>>>
88103>>>
88103>>>        Move APITableNameInfoFrom.bIsAlias      to bIsAliasFrom
88104>>>        Move APITableNameInfoFrom.bIsSQL        to bIsSQLTableFrom
88105>>>        Get UtilDriverFromTableNumber hTable    to sDriverIDTo
88106>>>        Get UtilTableIsSQL   hTable             to bIsSQLTableTo
88107>>>        Move True                               to APITableFrom.bFromTable
88108>>>        Move hTable                             to APITableFrom.hTable
88109>>>        Move APITableNameInfoFrom               to APITableFrom.ApiTableInfo
88110>>>        Move aColumnsFrom                       to APITableFrom.aApiColumns
88111>>>        Move aIndexesFrom                       to APITableFrom.aApiIndexes
88112>>>        Move aRelationsFrom                     to APITableFrom.aApiRelations
88113>>>        
88113>>>        If (bTableExists = True) Begin
88115>>>            Get OpenTableExclusive hTable to bOpened
88116>>>            If (bOpened = False) Begin
88118>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
88119>>>                Function_Return False
88120>>>            End
88120>>>>
88120>>>            Get UtilTableStructFill hTable False                                                        to APITableTo
88121>>>            Get UtilColumnCombineFromAndToArrays APITableFrom.aApiColumns     APITableTo.aApiColumns    to aAPIColumnCompare
88122>>>            Get UtilIndexCombineFromAndToArrays  APITableFrom.aApiIndexes     APITableTo.aApiIndexes    to aAPIIndexCompare
88123>>>            Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations  to aAPIRelationCompare
88124>>>        End
88124>>>>
88124>>>        
88124>>>        Move False to Err
88125>>>        Case Begin
88125>>>            // Alias table:
88125>>>            Case (bIsAliasFrom = True)
88127>>>                Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
88128>>>                Case Break
88129>>>            
88129>>>            // New Table:
88129>>>            Case (bTableExists = False)
88132>>>                Get ApiTableCreate      hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName bUseConnectionID bToANSI bRecnum aColumnsFrom to bOk
88133>>>                Get UtilIndexesUpdate   hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
88134>>>                Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
88135>>>                Case Break
88136>>>    
88136>>>            // Update table:    
88136>>>            Case (bTableExists = True)
88139>>>                Get UtilTableCompare APITableFrom APITableTo False (&bFilelistError) to bIsSame
88140>>>                If (bIsSame = True) Begin
88142>>>                    Case Break
88143>>>                End
88143>>>>
88143>>>                If (bFilelistError = True) Begin
88145>>>                    Get ApiTableRename hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName to bOk
88146>>>                    If (bOk = False) Begin
88148>>>                        Case Break
88149>>>                    End
88149>>>>
88149>>>                End
88149>>>>
88149>>>
88149>>>                If (ghoProgressBar <> 0) Begin
88151>>>                    Send DoAdvance of ghoProgressBar
88152>>>                    Set TableName_Text of ghoStatusPanel to ("Updating Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
88153>>>                End
88153>>>>
88153>>>        
88153>>>                // Columns:            
88153>>>                Move True to bOk
88154>>>                Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
88155>>>                If (bIsSame = False) Begin
88157>>>                    Get ApiColumnsUpdate sDriverIDFrom hTable bIsSQLTableFrom APITableFrom.aApiColumns APITableTo.aApiColumns bCompareDate_DateTime to bOk
88158>>>                End
88158>>>>
88158>>>                If (bOk = False) Begin
88160>>>                    Case Break
88161>>>                End
88161>>>>
88161>>>
88161>>>                // Indexes:
88161>>>                Get UtilIndexesCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
88162>>>                If (bIsSame = False) Begin
88164>>>                    Get UtilIndexesUpdate hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
88165>>>                End
88165>>>>
88165>>>                
88165>>>                // Relations:
88165>>>                Get UtilRelationsCompare hTable aAPIRelationCompare to bIsSame
88166>>>                If (bIsSame = False) Begin
88168>>>                    Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
88169>>>                    If (bOk = False) Begin
88171>>>                        Case Break
88172>>>                    End
88172>>>>
88172>>>                End                                                               
88172>>>>
88172>>>                
88172>>>                // Filelist Names:
88172>>>                Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
88173>>>                Case Break
88174>>>
88174>>>            Case Else
88174>>>                Error DFERR_PROGRAM "Unknown Case structure exit in Function ApiTableUpdate"
88175>>>>
88175>>>                Move False to bOk
88176>>>        Case End                     
88176>>>
88176>>>        Close hTable
88177>>>        Set TableName_Text of ghoStatusPanel to ""
88178>>>
88178>>>        Function_Return (bOK = True)
88179>>>    End_Function
88180>>>    
88180>>>    // Replaces all date values with CS_DUFLowestAllowedDateValue for all tables in Filelist.cfg,
88180>>>    // _except_ those tables that has been excluded with the "ApiTableDateCorrectionAddException" message.
88180>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.               
88180>>>    // This is for prepairing embedded tables (*.dat) before an SQL conversion.
88180>>>    //
88180>>>    // The root of the problem is the following:
88180>>>    // The data type Date in SQL has a range of accepted values from 01-01-0001 through 12-31-9999
88180>>>    // while the data type DateTime has a range of accepted values from 01-01-1753 through 12-31-9999
88180>>>    // So if you happen to have a Date from before 1753, or an empty / NULL value - this will be outside 
88180>>>    // the range that DateTime can handle and if you then try to change a Date column to a DateTime,
88180>>>    // an SQL error will be thrown;
88180>>>    // "The conversion of a date data type to a datetime data type resulted in an out-of-range value".
88180>>>    Function ApiTableFixAllDateBogusValues Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
88182>>>        Boolean bOK bIsAlias bIsSQL
88182>>>        Integer iCount iSize iDateSize iItems
88182>>>        Handle hTable                        
88182>>>        String sLogicalName
88182>>>        Integer[] aTablesToCheck aDateFields
88184>>>        
88184>>>        Get _AllTablesDateCorrections to aTablesToCheck
88185>>>        Move (SizeOfArray(aTablesToCheck)) to iSize
88186>>>        Set pbVisible    of ghoProgressBarOverall to True
88187>>>        Set piPosition   of ghoProgressBarOverall to 0
88188>>>        Set piMaximum    of ghoProgressBarOverall to iSize
88189>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
88190>>>
88190>>>        Move True to bOK
88191>>>        Decrement iSize
88192>>>        for iCount from 0 to iSize
88198>>>>
88198>>>            Move aTablesToCheck[iCount] to hTable 
88199>>>            Set piPosition of ghoProgressBarOverall to iCount
88200>>>            Get UtilTableIsAlias hTable to bIsAlias
88201>>>            Get UtilTableIsSql   hTable to bIsSQL
88202>>>            
88202>>>            Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
88205>>>            Set TableName_Text of ghoStatusPanel to ("Processing Table Number:" * String(hTable) * "Name:" * String(sLogicalName))
88206>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
88207>>>
88207>>>            If (bIsAlias = False and bIsSQL = False) Begin
88209>>>                Get UtilCheckForDateFields hTable to aDateFields
88210>>>                Move (SizeOfArray(aDateFields)) to iDateSize
88211>>>                If (iDateSize > 0) Begin
88213>>>                    Get UtilTableCorrectBogusDateValues hTable aDateFields bFixZeroDates bResetIndexesToOnLine to bOK
88214>>>                    Close hTable                                     
88215>>>                End
88215>>>>
88215>>>            End  
88215>>>>
88215>>>        Loop
88216>>>>
88216>>>        
88216>>>        Close DF_ALL
88217>>>        Function_Return bOK
88218>>>    End_Function
88219>>>    
88219>>>    // Returns all fields of type Date or DateTime in an integer array with the field numbers.
88219>>>    Function UtilCheckForDateFields Handle hTable Returns Integer[]
88221>>>        Integer[] aDateFields aDateFieldsEmpty
88223>>>        Integer iField iSize iCount iType
88223>>>        Boolean bOpen
88223>>>        
88223>>>        Open hTable
88225>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
88228>>>        If (bOpen = False) Begin  
88230>>>            Error ("Table could not be opened." * String(hTable))
88231>>>>
88231>>>            Function_Return aDateFieldsEmpty
88232>>>        End                                 
88232>>>>
88232>>>        
88232>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iSize
88235>>>        for iCount from 1 to iSize
88241>>>>
88241>>>            Get_Attribute DF_FIELD_TYPE of hTable iCount to iType
88244>>>            If (iType = DF_DATE or iType = DF_DATETIME) Begin
88246>>>                Move iCount to aDateFields[SizeOfArray(aDateFields)]
88247>>>            End
88247>>>>
88247>>>        Loop
88248>>>>
88248>>>        
88248>>>        Function_Return aDateFields
88249>>>    End_Function         
88250>>>        
88250>>>    // Loops through all records for the passed hTable, and checks that all Date values
88250>>>    // for the passed aDateFields array are OK. Else the Data value is set to CS_DUFLowestAllowedDateValue
88250>>>    // and the record is saved  
88250>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed. 
88250>>>    // Note: It first sets all indexes to BATCH and reset them at the end.
88250>>>    Function UtilTableCorrectBogusDateValues Handle hTable Integer[] aDateFields Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
88252>>>        Integer iSize iCount iField iRecord iRetval iTotalRecords iDateFormat
88252>>>        String sValue    
88252>>>        Boolean bCancel bFound bOK bChange bOpened bSaveChanges
88252>>>        Date dDate dDateMin 
88252>>>        Integer[] iaChangeField
88253>>>        
88253>>>        // The CS_DUFLowestAllowedDateValue is defined as "01/01/1753", so we first set the 
88253>>>        // date format to "USA" = "MM/DD/YYYY"
88253>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
88256>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_USA
88259>>>        
88259>>>        Send SetAllIndexesToBatch hTable True
88260>>>        Open hTable                               
88262>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
88265>>>        If (bOpened = False) Begin
88267>>>            Function_Return False
88268>>>        End                      
88268>>>>
88268>>>        
88268>>>        Set Private.phCurrentTable to hTable
88269>>>        Move 0 to iRecord
88270>>>        Move (SizeOfArray(aDateFields)) to iSize
88271>>>        Decrement iSize
88272>>>        
88272>>>        Get_Attribute DF_FILE_RECORDS_USED of hTable to iTotalRecords
88275>>>        Set piPosition   of ghoProgressBar to 0
88276>>>        Set piAdvanceBy  of ghoProgressBar to 100
88277>>>        Set piMaximum    of ghoProgressBar to iTotalRecords
88278>>>        Move CS_DUFLowestAllowedDateValue  to dDateMin
88279>>>        Move False to Err
88280>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88281>>>        
88281>>>        Clear hTable     
88282>>>        Repeat
88282>>>>
88282>>>            Vfind hTable 0 GT
88284>>>            Move Found to bFound
88285>>>            If (bFound = True) Begin    
88287>>>                Move False to bSaveChanges   
88288>>>                Move (ResizeArray(iaChangeField, 0)) to iaChangeField 
88289>>>                Move (SizeOfArray(aDateFields)) to iSize
88290>>>                Decrement iSize
88291>>>                for iCount from 0 to iSize   
88297>>>>
88297>>>                    Move aDateFields[iCount] to iField
88298>>>                    Get_Field_Value hTable iField to dDate
88301>>>                    If (bFixZeroDates = True) Begin
88303>>>                        Move (dDate = 0 or dDate < dDateMin) to bChange
88304>>>                    End 
88304>>>>
88304>>>                    Else Begin
88305>>>                        Move (dDate <> 0 and dDate < dDateMin) to bChange
88306>>>                    End
88306>>>>
88306>>>                    If (bChange = True) Begin      
88308>>>                        Move iField to iaChangeField[SizeOfArray(iaChangeField)]            
88309>>>                    End
88309>>>>
88309>>>                Loop       
88310>>>>
88310>>>                
88310>>>                // Only change Date fields that needs to be changed.
88310>>>                If (SizeOfArray(iaChangeField)) Begin
88312>>>                    Reread hTable 
88316>>>                        Move (SizeOfArray(iaChangeField)) to iSize
88317>>>                        Decrement iSize      
88318>>>                        for iCount from 0 to iSize
88324>>>>
88324>>>                            Move iaChangeField[iCount] to iField
88325>>>                            Set Private.piCurrentField to iField
88326>>>                            Set_Field_Value hTable iField to dDateMin  
88329>>>                        Loop
88330>>>>
88330>>>                        Move False to Err
88331>>>                        SaveRecord hTable
88332>>>                    Unlock
88333>>>>
88333>>>                End
88333>>>>
88333>>>                
88333>>>                Increment iRecord
88334>>>                // Increment the StatusPanel counter and check the
88334>>>                // cancel status every 100 records rather than every
88334>>>                // record, it's way faster.
88334>>>                If (Mod(iRecord, 100) = 0) Begin
88336>>>                    Send DoAdvance of ghoProgressBar
88337>>>                    Set Action_Text of ghoStatusPanel to ("Record:" * String(iRecord))
88338>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
88339>>>                End 
88339>>>>
88339>>>            End
88339>>>>
88339>>>        Until (bFound = False)
88341>>>                
88341>>>        Set_Attribute DF_DATE_FORMAT to iDateFormat   
88344>>>        If (bResetIndexesToOnLine = True) Begin
88346>>>            Send SetAllIndexesToBatch hTable False
88347>>>        End
88347>>>>
88347>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88348>>>        
88348>>>        Function_Return (Err = False)
88349>>>    End_Function 
88350>>>        
88350>>>
88350>>>    // * Dummy function for the Studio's Code Explorer *
88350>>>    Function API_COLUMN_FUNCTIONS Returns Boolean
88352>>>        Function_Return False
88353>>>    End_Function
88354>>>
88354>>>    // Adds a column name to the passed table number.
88354>>>    Function ApiColumnAdd Handle hTable String sFieldName Integer iType Integer iLength Integer iPrec Boolean bInitVal String sColVal Returns Boolean
88356>>>        Integer iColumn iCount iFile iPrecision
88356>>>        Boolean bExists bOK bInitializeValue bRetval
88356>>>        String sDdSrcPath sTableName sColumnValue
88356>>>
88356>>>        Get UtilColumnExists hTable sFieldName to bExists
88357>>>        Move False to Err
88358>>>        If (bExists = True) Begin
88360>>>            Function_Return False
88361>>>        End
88361>>>>
88361>>>        If (num_arguments > 4) Begin
88363>>>            Move iPrec to iPrecision
88364>>>        End
88364>>>>
88364>>>        If (num_arguments > 6) Begin
88366>>>            Move bInitVal to bInitializeValue
88367>>>            Move sColVal  to sColumnValue
88368>>>        End
88368>>>>
88368>>>        If (iType < -1490) Begin
88370>>>            Move (iType + 1500) to iType
88371>>>        End
88371>>>>
88371>>>
88371>>>        Get AutoConnectionIDLogin to bOK
88372>>>        Move False to Err
88373>>>        // Structure_start will change the value of hTable...
88373>>>        Move hTable to iFile
88374>>>        Open iFile Mode DF_EXCLUSIVE
88376>>>
88376>>>        Set Private.phCurrentTable to hTable
88377>>>        Structure_Start iFile
88378>>>            Move 0 to iColumn
88379>>>            Set Private.piCurrentField to iColumn
88380>>>            Create_Field hTable At iColumn
88381>>>            Set_Attribute DF_FIELD_NAME      of iFile iColumn to sFieldName
88384>>>            Set_Attribute DF_FIELD_TYPE      of iFile iColumn to iType
88387>>>            Set_Attribute DF_FIELD_LENGTH    of iFile iColumn to (iLength + iPrecision)
88390>>>            Set_Attribute DF_FIELD_PRECISION of iFile iColumn to iPrecision
88393>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88394>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88396>>>        Set Action_Text of ghoStatusPanel to ""
88397>>>
88397>>>        // If in development environment; create .fd file:
88397>>>        Open hTable
88399>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
88400>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
88401>>>        If (iCount > 1) Begin
88403>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
88404>>>        End
88404>>>>
88404>>>        Get vFolderExists sDDSrcPath to bExists
88405>>>        If (bExists = True) Begin
88407>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
88408>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
88411>>>            Get _TableNameOnly sTableName to sTableName
88412>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
88414>>>        End
88414>>>>
88414>>>
88414>>>        // Check for a default value
88414>>>        If (bInitializeValue = True and sColumnValue <> "" and Err = False) Begin
88416>>>            Get ApiColumnUpdateValue hTable sFieldName sColumnValue to bRetval
88417>>>        End
88417>>>>
88417>>>        Close hTable
88418>>>
88418>>>        Function_Return (Err = False)
88419>>>    End_Function
88420>>>
88420>>>    // Adds a column name to the passed table number.
88420>>>    Function ApiColumnInsert Handle hTable Integer iColumn String sFieldName Integer iType Integer iLength Integer iPrec Boolean bIsSQLType Returns Boolean
88422>>>        Integer iCount iFile iPrecision iNumberOfFields
88422>>>        Boolean bExists bOK bInitializeValue bRetval bIsDateType
88422>>>        String sDdSrcPath sTableName sColumnValue
88422>>>
88422>>>        Get UtilColumnExists hTable sFieldName to bExists
88423>>>        Move False to Err
88424>>>        If (bExists = True) Begin
88426>>>            Function_Return False
88427>>>        End
88427>>>>
88427>>>        If (num_arguments > 4) Begin
88429>>>            Move iPrec to iPrecision
88430>>>        End
88430>>>>
88430>>>        If (iType < -1490) Begin
88432>>>            Move (iType + 1500) to iType
88433>>>        End
88433>>>>
88433>>>
88433>>>        Get AutoConnectionIDLogin to bOK
88434>>>        Move False to Err
88435>>>        // Structure_start will change the value of hTable...
88435>>>        Move hTable to iFile
88436>>>        Get OpenTableExclusive iFile to bOK
88437>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iNumberOfFields
88440>>>        
88440>>>        // If the passed column number is higher than the current number of fields
88440>>>        // in the table, this means we should _not_ insert a field but rather add
88440>>>        // a new field to the end:
88440>>>        If (iColumn > iNumberOfFields) Begin
88442>>>            Move 0 to iColumn
88443>>>        End
88443>>>>
88443>>>
88443>>>        Set Private.phCurrentTable to hTable
88444>>>        Set Private.piCurrentField to iColumn
88445>>>
88445>>>        Structure_Start iFile
88446>>>            Create_Field iFile At iColumn
88447>>>            Set_Attribute DF_FIELD_NAME            of iFile iColumn to sFieldName
88450>>>            If (bIsSQLType = False) Begin
88452>>>                Set_Attribute DF_FIELD_TYPE        of iFile iColumn to iType
88455>>>            End 
88455>>>>
88455>>>            Else Begin
88456>>>                Set_Attribute DF_FIELD_NATIVE_TYPE of iFile iColumn to iType
88459>>>            End
88459>>>>
88459>>>            Get UtilColumnIsDateType iType False to bIsDateType
88460>>>            If (bIsDateType = False) Begin
88462>>>                Set_Attribute DF_FIELD_LENGTH       of iFile iColumn to (iLength + iPrecision)
88465>>>                Set_Attribute DF_FIELD_PRECISION    of iFile iColumn to iPrecision
88468>>>            End
88468>>>>
88468>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88469>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88471>>>
88471>>>        Set Action_Text of ghoStatusPanel to ""
88472>>>        // If in development environment; create .fd file:
88472>>>        Open hTable
88474>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
88475>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
88476>>>        If (iCount > 1) Begin
88478>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
88479>>>        End
88479>>>>
88479>>>        Get vFolderExists sDDSrcPath to bExists
88480>>>        If (bExists = True) Begin
88482>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
88483>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
88486>>>            Get _TableNameOnly sTableName to sTableName
88487>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
88489>>>        End
88489>>>>
88489>>>
88489>>>        // Check for a default value
88489>>>        Close hTable
88490>>>
88490>>>        Function_Return (Err = False)
88491>>>    End_Function
88492>>>
88492>>>//    Function ApiColumnAddMultiple Handle hTable tAPIColumn[] aColumns Returns Boolean
88492>>>//        Integer iColumn iCount iFile
88492>>>//        Boolean bExists bOK
88492>>>//        String sDdSrcPath sTableName
88492>>>//
88492>>>//        Get AutoConnectionIDLogin to bOK
88492>>>//        Move False to Err
88492>>>//
88492>>>//        // Structure_start will change the value of hTable...
88492>>>//        Move hTable to iFile
88492>>>//        Open iFile Mode DF_EXCLUSIVE
88492>>>//
88492>>>//        Structure_Start iFile
88492>>>//            Send ApiColumnsAddToTable iFile aColumns False
88492>>>//        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88492>>>//
88492>>>//        // If in development environment; create .fd file:
88492>>>//        Open hTable
88492>>>//        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
88492>>>//        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
88492>>>//        If (iCount > 1) Begin
88492>>>//            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
88492>>>//        End
88492>>>//        Get vFolderExists sDDSrcPath to bExists
88492>>>//        If (bExists = True) Begin
88492>>>//            Get vFolderFormat sDDSrcPath to sDDSrcPath
88492>>>//            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
88492>>>//            Get _TableNameOnly sTableName to sTableName
88492>>>//            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
88492>>>//        End
88492>>>//        Close hTable
88492>>>//
88492>>>//        Function_Return (Err = False)
88492>>>//    End_Function
88492>>>
88492>>>    // To update all records for a table column with a fixed value.
88492>>>    Function ApiColumnUpdateValue Handle hTable String sFieldName String sColumnValue Returns Boolean
88494>>>        Integer iRecs iCurrErr iField iRecord
88494>>>        Boolean bRetval bOpen
88494>>>
88494>>>        Move 0 to iRecs
88495>>>        Move False to bRetval
88496>>>        Move Err to iCurrErr
88497>>>        Move False to Err
88498>>>
88498>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
88501>>>        If (bOpen = False) Begin
88503>>>            Open hTable
88505>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
88508>>>            If (bOpen = False) Begin
88510>>>                Function_Return bRetval
88511>>>            End
88511>>>>
88511>>>        End
88511>>>>
88511>>>
88511>>>        Field_Map hTable sFieldName to iField
88513>>>        If (iField <> 0) Begin
88515>>>            Set Private.phCurrentTable to hTable
88516>>>            Set Private.piCurrentField to iField
88517>>>            Clear hTable
88518>>>            Repeat
88518>>>>
88518>>>                Vfind hTable 0 GT
88520>>>                If (Found) Begin
88522>>>                    If (ghoStatusPanel <> 0) Begin
88524>>>                        Get_Field_Value hTable 0 to iRecord
88527>>>                        Send Update_StatusPanel of ghoStatusPanel (CS_UpdateVersion * String(iRecord))
88528>>>                    End
88528>>>>
88528>>>                    Reread hTable
88532>>>                        Set_Field_Value hTable iField to sColumnValue
88535>>>                        SaveRecord hTable
88536>>>                    Unlock
88537>>>>
88537>>>                End
88537>>>>
88537>>>           Until (not(Found))
88539>>>        End
88539>>>>
88539>>>
88539>>>        Move (Err = False) to bRetval
88540>>>        Move iCurrErr to Err
88541>>>
88541>>>        Function_Return bRetval
88542>>>    End_Function
88543>>>    
88543>>>    // Note: This can only be used from within a Structure_Start/End construct.
88543>>>    Function ApiColumnsAddToTable Handle hTable tAPIColumn[] aColumns Boolean bCreating Returns Boolean
88545>>>        Integer iCount iSize iColumn iType iDataFlexType iIndex iDbType
88545>>>        Boolean bFieldExists bNativeType bIsSQLDriver bIsDAWSqlDriver bIsSqlTable bRecnumTable bIsOpen bIsDateType
88545>>>        String sFieldName sDriverID sTableName sDefaultValue
88545>>>
88545>>>//        Set Private.phCurrentTable to hTable
88545>>>        Get psDriverID to sDriverID
88546>>>        Get piDbType to iDbType
88547>>>        Get UtilTableHandleToString hTable to sTableName
88548>>>        Get IsSQLDriver    sDriverID to bIsSQLDriver
88549>>>        Get IsDAWSQLDriver sDriverID to bIsDAWSqlDriver
88550>>>        Get UtilTableIsSQL hTable to bIsSqlTable
88551>>>        If (bIsSqlTable = False and bCreating = True and bIsSQLDriver = True) Begin
88553>>>            Move True to bIsSqlTable
88554>>>        End
88554>>>>
88554>>>        Move False to bIsOpen
88555>>>        If (hTable > 0) Begin
88557>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
88560>>>        End
88560>>>>
88560>>>        If (bIsOpen = True) Begin
88562>>>            Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
88565>>>        End
88565>>>>
88565>>>        Else Begin        
88566>>>            Get pbRecnum to bRecnumTable
88567>>>        End
88567>>>>
88567>>>        
88567>>>        Move False to Err
88568>>>        Move (SizeOfArray(aColumns)) to iSize
88569>>>        Decrement iSize
88570>>>        for iCount from 0 to iSize
88576>>>>
88576>>>            Move aColumns[iCount].sFieldName to sFieldName
88577>>>            If (hTable > 0) Begin
88579>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88580>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88581>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn to sFieldName
88584>>>                Move (Trim(sFieldName) <> "") to bFieldExists
88585>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
88586>>>                Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88587>>>            End
88587>>>>
88587>>>            Else Begin
88588>>>                Move False to bFieldExists
88589>>>            End
88589>>>>
88589>>>
88589>>>            If (bFieldExists = False) Begin
88591>>>                Move 0 to iColumn
88592>>>                Create_Field hTable At iColumn
88593>>>            End
88593>>>>
88593>>>            Else Begin
88594>>>                Move iCount to iColumn
88595>>>            End
88595>>>>
88595>>>
88595>>>            Set Private.piCurrentField to iColumn
88596>>>
88596>>>            Move                                        iColumn to aColumns[iCount].iFieldNumber
88597>>>            Set_Attribute DF_FIELD_NAME       of hTable iColumn to aColumns[iCount].sFieldName
88600>>>
88600>>>            Move aColumns[iCount].iType to iType
88601>>>            Move (not(iType < -1490)) to bNativeType
88602>>>            If (iType < -1490) Begin
88604>>>                Move (iType + 1500) to iType
88605>>>            End
88605>>>>
88605>>>
88605>>>            If (bIsSqlTable = True) Begin
88607>>>                If (aColumns[iCount].bIsSQLType = True) Begin
88609>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iDataFlexType
88610>>>                    Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iDataFlexType
88613>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iType  
88616>>>                    Set_Attribute DF_FIELD_NULL_ALLOWED  of hTable iColumn to aColumns[iCount].bAllowNULL
88619>>>                    
88619>>>                    Move aColumns[iCount].sDefaultValue                    to sDefaultValue
88620>>>                    If (iDataFlexType = DF_BCD and Left(sDefaultValue, 1 <> "[")) Begin
88622>>>                        Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
88623>>>                    End
88623>>>>
88623>>>                    Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sDefaultValue 
88626>>>                
88626>>>                End
88626>>>>
88626>>>                Else Begin
88627>>>                    Set_Attribute DF_FIELD_TYPE        of hTable iColumn to iType
88630>>>                End
88630>>>>
88630>>>            End
88630>>>>
88630>>>            Else Begin
88631>>>                If (bCreating = False) Begin
88633>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iType
88634>>>                End
88634>>>>
88634>>>                Set_Attribute DF_FIELD_TYPE of hTable iColumn to iType
88637>>>            End
88637>>>>
88637>>>            
88637>>>            Get UtilColumnIsDateType iType bIsSqlTable to bIsDateType
88638>>>            If (bIsDateType = False) Begin
88640>>>                Set_Attribute DF_FIELD_LENGTH     of hTable iColumn to aColumns[iCount].iLength
88643>>>                Set_Attribute DF_FIELD_PRECISION  of hTable iColumn to aColumns[iCount].iPrecision
88646>>>            End
88646>>>>
88646>>>
88646>>>            If (aColumns[iCount].iOptions iand C_tAPIColumn_Identity) Begin
88648>>>                Move 0 to iIndex
88649>>>                Create_Index hTable at iIndex
88650>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to 1
88653>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD   of hTable iIndex 1 to iColumn
88656>>>                Set_Attribute DF_FILE_PRIMARY_INDEX    of hTable iIndex to 1
88659>>>
88659>>>                // If we have an identity table - we must create a primary_key table.
88659>>>                If (bIsSqlTable = True) Begin
88661>>>                    Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to True
88664>>>                    Set_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to True
88667>>>                End
88667>>>>
88667>>>            End
88667>>>>
88667>>>        Loop             
88668>>>>
88668>>>        
88668>>>        Function_Return (Err = False)
88669>>>    End_Function
88670>>>
88670>>>    // Changes a field type, length and precision for the passed table number and field name
88670>>>    Function ApiColumnChange Handle hTable String sFieldNameFrom Integer iTypeFrom Integer iLengthFrom Integer iPrec Returns Boolean
88672>>>        Integer iColumn iPrecFrom iTypeTo iLengthTo iPrecTo
88672>>>        Boolean bOK bIsSqlTable
88672>>>        String sFieldNameTo
88672>>>
88672>>>        If (num_arguments > 4) Begin
88674>>>            Move iPrec to iPrecFrom
88675>>>        End
88675>>>>
88675>>>        If (iTypeFrom < -1490) Begin
88677>>>            Move (iTypeFrom + 1500) to iTypeFrom
88678>>>        End
88678>>>>
88678>>>
88678>>>        Get AutoConnectionIDLogin to bOK
88679>>>        Move False to Err
88680>>>        Get OpenTableExclusive hTable to bOK
88681>>>        If (bOK = False) Begin
88683>>>            Function_Return False
88684>>>        End
88684>>>>
88684>>>
88684>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88685>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88686>>>        Field_Map hTable sFieldNameFrom to iColumn
88688>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88689>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88690>>>        If (Err = True) Begin
88692>>>            Function_Return False
88693>>>        End
88693>>>>
88693>>>
88693>>>        Get_Attribute DF_FIELD_NAME                  of hTable iColumn to sFieldNameTo
88696>>>        Get UtilTableIsSQL hTable to bIsSqlTable
88697>>>        If (bIsSqlTable = False) Begin
88699>>>            Get_Attribute DF_FIELD_TYPE              of hTable iColumn to iTypeTo
88702>>>        End
88702>>>>
88702>>>        Else Begin
88703>>>            Get_Attribute DF_FIELD_NATIVE_TYPE       of hTable iColumn to iTypeTo
88706>>>        End
88706>>>>
88706>>>        // Let the driver decide the other values;
88706>>>        Get_Attribute DF_FIELD_LENGTH                of hTable iColumn to iLengthTo
88709>>>        Get_Attribute DF_FIELD_PRECISION             of hTable iColumn to iPrecTo
88712>>>
88712>>>        If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo) Begin
88714>>>            Function_Return False
88715>>>        End
88715>>>>
88715>>>
88715>>>        Set Private.phCurrentTable to hTable
88716>>>        Set Private.piCurrentField to iColumn
88717>>>
88717>>>        Structure_Start hTable
88718>>>            Set_Attribute DF_FIELD_NAME              of hTable iColumn to sFieldNameFrom
88721>>>            If (bIsSqlTable = False) Begin
88723>>>                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
88726>>>            End
88726>>>>
88726>>>            Else Begin
88727>>>                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
88730>>>                Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iTypeFrom
88733>>>            End
88733>>>>
88733>>>            Set_Attribute DF_FIELD_LENGTH            of hTable iColumn to iLengthFrom
88736>>>            Set_Attribute DF_FIELD_PRECISION         of hTable iColumn to iPrecFrom
88739>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88740>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88742>>>
88742>>>        Set Action_Text of ghoStatusPanel to ""
88743>>>        Function_Return (Err = False)
88744>>>    End_Function
88745>>>
88745>>>    // Changes a field type, length and precision for the passed table number and field name
88745>>>    Function ApiColumnChangeByColumnNumber String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo String sFieldNameFrom Integer iColumn Integer iTypeFrom Integer iLengthFrom Integer iPrec Integer iOpt Returns Boolean
88747>>>        Integer iPrecFrom iTypeTo iLengthTo iPrecTo iDbType iOptionFrom iOptionTo iDataFlexType iIndex
88747>>>        Boolean bOK bCompareDate_DateTime bSkip bRecnumTable bIsSameDataType
88747>>>        String sFieldNameTo sDriverIDTo
88747>>>        tColumnType ColumnType
88747>>>        tColumnType ColumnType
88747>>>        
88747>>>        Get pbCompareDate_DateTime to bCompareDate_DateTime
88748>>>        Get piDbType to iDbType
88749>>>        If (num_arguments > 4) Begin
88751>>>            Move iPrec to iPrecFrom
88752>>>            Move iOpt  to iOptionFrom
88753>>>        End
88753>>>>
88753>>>        If (iTypeFrom < -1490) Begin
88755>>>            Move (iTypeFrom + 1500) to iTypeFrom
88756>>>        End
88756>>>>
88756>>>
88756>>>        Get AutoConnectionIDLogin to bOK
88757>>>        Move False to Err   
88758>>>        Close hTable
88759>>>        Get OpenTableExclusive hTable to bOK
88760>>>        If (bOK = False) Begin
88762>>>            Function_Return False
88763>>>        End 
88763>>>>
88763>>>
88763>>>        Get_Attribute DF_FILE_DRIVER                of hTable         to sDriverIDTo
88766>>>        Get_Attribute DF_FILE_RECNUM_TABLE          of hTable         to bRecnumTable
88769>>>        Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iTypeTo iLengthTo to iDataFlexType
88770>>>        Get_Attribute DF_FIELD_NAME                 of hTable iColumn to sFieldNameTo 
88773>>>
88773>>>        If (bIsSQLTableTo = True) Begin
88775>>>            Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iTypeTo
88778>>>        End
88778>>>>
88778>>>        Else Begin
88779>>>            Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iTypeTo
88782>>>        End
88782>>>>
88782>>>
88782>>>        Get_Attribute DF_FIELD_LENGTH               of hTable iColumn to iLengthTo
88785>>>        Get_Attribute DF_FIELD_PRECISION            of hTable iColumn to iPrecTo
88788>>>            Get_Attribute DF_FIELD_IS_IDENTITY      of hTable iColumn to iOptionTo 
88791>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
88791>>>        // data types between Embedded and SQL, else we can't compare the data types.
88791>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
88793>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeFrom
88794>>>        End
88794>>>>
88794>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
88797>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeTo
88798>>>        End
88798>>>>
88798>>>        Move (iTypeFrom = iTypeTo) to bIsSameDataType
88799>>>
88799>>>        If (bCompareDate_DateTime = False) Begin
88801>>>            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkip
88802>>>            If (bSkip = True) Begin
88804>>>                If (sFieldNameFrom = sFieldNameTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
88806>>>                    Function_Return True
88807>>>                End
88807>>>>
88807>>>            End
88807>>>>
88807>>>        End
88807>>>>
88807>>>        Else If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
88810>>>            Function_Return True
88811>>>        End
88811>>>>
88811>>>
88811>>>        Set Private.phCurrentTable to hTable
88812>>>        Set Private.piCurrentField to iColumn
88813>>>       
88813>>>        Structure_Start hTable                                               
88814>>>            If (sFieldNameFrom <> sFieldNameTo) Begin
88816>>>                Set_Attribute DF_FIELD_NAME             of hTable iColumn to sFieldNameFrom
88819>>>            End
88819>>>>
88819>>>            
88819>>>            If (bIsSameDataType = False) Begin
88821>>>                Set_Attribute DF_FIELD_TYPE             of hTable iColumn to iDataFlexType
88824>>>                If (bIsSQLTableTo = True) Begin
88826>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE  of hTable iColumn to iTypeFrom
88829>>>                End
88829>>>>
88829>>>            End                                         
88829>>>>
88829>>>            
88829>>>            If (iLengthFrom <> iLengthTo) Begin
88831>>>                Set_Attribute DF_FIELD_LENGTH           of hTable iColumn to iLengthFrom
88834>>>            End
88834>>>>
88834>>>            If (iPrecFrom <> iPrecTo) Begin
88836>>>                Set_Attribute DF_FIELD_PRECISION        of hTable iColumn to iPrecFrom
88839>>>            End
88839>>>>
88839>>>
88839>>>            If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
88841>>>                // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
88841>>>                If (bRecnumTable = True) Begin
88843>>>                    Set_Attribute DF_FILE_RECNUM_TABLE  of hTable to False
88846>>>                End
88846>>>>
88846>>>
88846>>>                // We might need to create an index here.
88846>>>                // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
88846>>>                // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
88846>>>                // index update checking logic.
88846>>>                Get_Attribute DF_FIELD_INDEX               of hTable iColumn to iIndex
88849>>>                If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
88851>>>                    Create_Index hTable At iIndex
88852>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex   to 1
88855>>>                End
88855>>>>
88855>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD       of hTable iIndex 1 to iColumn
88858>>>                Set_Attribute DF_FILE_PRIMARY_INDEX        of hTable          to iIndex
88861>>>                    Set_Attribute DF_FIELD_IS_IDENTITY     of hTable iColumn  to True
88864>>>                If (bIsSQLTableTo = True) Begin
88866>>>                    Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex   to True
88869>>>                End
88869>>>>
88869>>>            End
88869>>>>
88869>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88870>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88872>>>
88872>>>        Set Action_Text of ghoStatusPanel to ""
88873>>>        Function_Return (Err = False)
88874>>>    End_Function
88875>>>
88875>>>    Function ApiColumnChangeMainIndex Handle hTable Integer iIndex Integer iColumn Returns Boolean
88877>>>        Boolean bOK
88877>>>
88877>>>        Get AutoConnectionIDLogin to bOK
88878>>>        Move False to Err
88879>>>        Get OpenTableExclusive hTable to bOK
88880>>>        If (bOK = False) Begin
88882>>>            Function_Return False
88883>>>        End
88883>>>>
88883>>>
88883>>>        Structure_Start hTable
88884>>>            Set_Attribute DF_FIELD_INDEX of hTable iColumn to iIndex
88887>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88888>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88890>>>
88890>>>        Set Action_Text of ghoStatusPanel to ""
88891>>>        Function_Return (Err = False)
88892>>>    End_Function
88893>>>
88893>>>    // To move an existing field to another position in a table.
88893>>>    Function ApiColumnMove Handle hTable Integer iOld Integer iNew Boolean bIsSQLType Returns Boolean
88895>>>        String sColumn sDriverID
88895>>>        Integer iType iSQLType iLength iPrecision iDbType
88895>>>        Boolean bOK bIsDate
88895>>>        
88895>>>        Close hTable
88896>>>        Get AutoConnectionIDLogin to bOK
88897>>>        Get OpenTableExclusive hTable to bOK
88898>>>        If (bOK = False) Begin
88900>>>            Function_Return False
88901>>>        End
88901>>>>
88901>>>        
88901>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88904>>>        If (sDriverID = DFBTRDRV_ID) Begin
88906>>>            Error DFERR_PROGRAM "Function 'ColumnMove' is not supported for the Pervasive database."
88907>>>>
88907>>>            Function_Return False
88908>>>        End
88908>>>>
88908>>>        
88908>>>        Get_Attribute DF_FIELD_NAME of hTable iOld to sColumn
88911>>>        Get_Attribute DF_FIELD_TYPE of hTable iOld to iType
88914>>>
88914>>>        Set Private.phCurrentTable to hTable
88915>>>        Set Private.piCurrentField to iOld
88916>>>
88916>>>        Get UtilColumnIsDateType iType bIsSQLType to bIsDate
88917>>>        If (bIsDate = False) Begin
88919>>>            Get_Attribute DF_FIELD_LENGTH    of hTable iOld to iLength
88922>>>            Get_Attribute DF_FIELD_PRECISION of hTable iOld to iPrecision
88925>>>        End  
88925>>>>
88925>>>        Else Begin
88926>>>            Move 6 to iLength 
88927>>>            Move 0 to iPrecision
88928>>>        End
88928>>>>
88928>>>
88928>>>        Move False to Err
88929>>>
88929>>>        Structure_Start hTable
88930>>>            Delete_Field hTable iOld
88931>>>            Create_Field hTable At iNew
88932>>>            Set_Attribute DF_FIELD_NAME of hTable iNew to sColumn 
88935>>>            
88935>>>            If (bIsSQLType = False) Begin
88937>>>                Set_Attribute DF_FIELD_TYPE        of hTable iNew to iType
88940>>>            End 
88940>>>>
88940>>>            Else Begin
88941>>>                Set_Attribute DF_FIELD_TYPE        of hTable iNew to iType
88944>>>//                Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iNew to iSQLType  
88944>>>            End
88944>>>>
88944>>>            
88944>>>            If (bIsDate = False) Begin
88946>>>                Set_Attribute DF_FIELD_LENGTH    of hTable iNew to iLength
88949>>>                Set_Attribute DF_FIELD_PRECISION of hTable iNew to iPrecision
88952>>>            End
88952>>>>
88952>>>
88952>>>            Set_Attribute DF_FIELD_OLD_NUMBER of hTable iNew to iOld
88955>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88956>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88958>>>
88958>>>        Set Action_Text of ghoStatusPanel to ""
88959>>>        Function_Return (Err = False)
88960>>>    End_Function
88961>>>
88961>>>    // Deletes a column name for the passed table number (and column number).
88961>>>    Function ApiColumnRemove Handle hTable String sFieldName Returns Boolean
88963>>>        Integer iColumn
88963>>>        Boolean bOK
88963>>>
88963>>>        Get AutoConnectionIDLogin to bOK
88964>>>        Move False to Err
88965>>>        Close hTable
88966>>>        Get OpenTableExclusive hTable to bOK
88967>>>        If (bOK = False) Begin
88969>>>            Function_Return False
88970>>>        End
88970>>>>
88970>>>
88970>>>        If (not(Err)) Begin 
88972>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88973>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88974>>>            Field_Map hTable sFieldName to iColumn
88976>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
88977>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88978>>>            If (Err = True) Begin
88980>>>                Function_Return False
88981>>>            End
88981>>>>
88981>>>            Move False to Err
88982>>>
88982>>>            Set Private.phCurrentTable to hTable
88983>>>            Set Private.piCurrentField to iColumn
88984>>>        
88984>>>            Structure_Start hTable
88985>>>                Delete_Field hTable iColumn
88986>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
88987>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88989>>>            Set Action_Text of ghoStatusPanel to ""
88990>>>        End
88990>>>>
88990>>>        Else Begin
88991>>>            Error DFERR_PROGRAM ("The table number:" * String(hTable) * "could not be opened exclusiv. This indicates the table is in use!")
88992>>>>
88992>>>        End
88992>>>>
88992>>>
88992>>>        Function_Return (Err = False)
88993>>>    End_Function
88994>>>
88994>>>    // Renames a field for the passed table number & old field name & new field name
88994>>>    // Returns True if no errors occured.
88994>>>    // Sample usage:
88994>>>    //   Get ColumnRename Quote.File_Number "ID#" "ID" to bOK
88994>>>    Function ApiColumnRename Integer hTable String sOldFieldName String sNewFieldName Returns Boolean
88996>>>        Integer iField
88996>>>        Boolean bOK bExists bIsOpen
88996>>>
88996>>>        Get UtilColumnExists hTable sNewFieldName to bExists
88997>>>        If (bExists = True) Begin
88999>>>            Function_Return False
89000>>>        End
89000>>>>
89000>>>        
89000>>>        // Note: The Field_Map command does _not_ work if the table has been
89000>>>        //       opened exclusively, so we first open it in normal mode.
89000>>>        Close hTable
89001>>>        Open hTable                
89003>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89006>>>        If (bIsOpen = False) Begin
89008>>>            Function_Return False
89009>>>        End
89009>>>>
89009>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89010>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
89011>>>        Field_Map hTable sOldFieldName to iField   
89013>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
89014>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89015>>>        
89015>>>        Get AutoConnectionIDLogin to bOK
89016>>>        Get OpenTableExclusive hTable to bOK
89017>>>        If (bOK = False) Begin
89019>>>            Function_Return False
89020>>>        End
89020>>>>
89020>>>
89020>>>        Move False to Err
89021>>>        Send Ignore_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
89022>>>        Set Private.phCurrentTable to hTable
89023>>>        Set Private.piCurrentField to iField
89024>>>
89024>>>        If (iField > 0) Begin
89026>>>            Structure_Start hTable
89027>>>                Set_Attribute DF_FIELD_NAME of hTable iField to sNewFieldName
89030>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
89031>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89033>>>        End
89033>>>>
89033>>>        Else Begin
89034>>>            Move 0 to LastErr
89035>>>            Move False to Err
89036>>>        End
89036>>>>
89036>>>
89036>>>        Set Action_Text of ghoStatusPanel to ""
89037>>>        Send Trap_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
89038>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89039>>>
89039>>>        Function_Return (Err = False)
89040>>>    End_Function  
89041>>>    
89041>>>    Function UtilColumnsCheckForInserts Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[] 
89043>>>        tAPIColumnCompare[] aAPIColumnsToInsert
89043>>>        tAPIColumnCompare[] aAPIColumnsToInsert
89044>>>        Integer iSize iCount iItem iFieldTo iNumberOfFieldsTo
89044>>>        Boolean bRenameField bExists
89044>>>        
89044>>>        Open hTable
89046>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89047>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
89048>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize       
89049>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumberOfFieldsTo  
89052>>>        Move (iSize min iNumberOfFieldsTo) to iSize
89053>>>        Decrement iSize
89054>>>        for iCount from 0 to iSize    
89060>>>>
89060>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
89062>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89063>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
89064>>>
89064>>>                Field_Map hTable aAPIColumnCompare[iCount].sFieldNameFrom to iFieldTo
89066>>>                If (iFieldTo = 0) Begin 
89068>>>                    Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount] to bRenameField
89069>>>                    Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to bExists
89070>>>                    If (bRenameField = False and bExists = False) Begin
89072>>>                        Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToInsert[iItem].iFieldNumber 
89073>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToInsert[iItem].sFieldNameFrom
89074>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to aAPIColumnsToInsert[iItem].iTypeFrom 
89075>>>                        Move aAPIColumnCompare[iCount].sTypeFrom        to aAPIColumnsToInsert[iItem].sTypeFrom
89076>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to aAPIColumnsToInsert[iItem].iLengthFrom
89077>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to aAPIColumnsToInsert[iItem].iPrecisionFrom
89078>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeFrom   to aAPIColumnsToInsert[iItem].bIsSQLTypeFrom
89079>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeTo     to aAPIColumnsToInsert[iItem].bIsSQLTypeTo
89080>>>                        Move True                                       to aAPIColumnsToInsert[iItem].bExistsFrom
89081>>>                        Move False                                      to aAPIColumnsToInsert[iItem].bExistsTo
89082>>>                        Increment iItem
89083>>>                    End
89083>>>>
89083>>>                End
89083>>>>
89083>>>            End
89083>>>>
89083>>>        Loop
89084>>>>
89084>>>        
89084>>>        Move False to Err
89085>>>        Move 0 to LastErr
89086>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89087>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
89088>>>        Function_Return aAPIColumnsToInsert
89089>>>    End_Function   
89090>>>    
89090>>>    Function UtilColumnsInsert Handle hTable tAPIColumnCompare[] aAPIColumnsToInsert Returns Boolean
89092>>>        Integer iSize iCount
89092>>>        Boolean bOK                             
89092>>>        tAPIColumn[] aColumnsTo 
89092>>>        tAPIColumn[] aColumnsTo 
89093>>>        tAPIColumnCompare[] aAPIColumnCompare
89093>>>        tAPIColumnCompare[] aAPIColumnCompare
89094>>>
89094>>>        Move (SizeOfArray(aAPIColumnsToInsert)) to iSize
89095>>>        If (iSize = 0) Begin
89097>>>            Function_Return True
89098>>>        End                     
89098>>>>
89098>>>        
89098>>>        Move False to Err
89099>>>        Decrement iSize
89100>>>        for iCount from 0 to iSize
89106>>>>
89106>>>            Get ApiColumnInsert hTable aAPIColumnsToInsert[iCount].iFieldNumber aAPIColumnsToInsert[iCount].sFieldNameFrom aAPIColumnsToInsert[iCount].iTypeFrom aAPIColumnsToInsert[iCount].iLengthFrom aAPIColumnsToInsert[iCount].iPrecisionFrom aAPIColumnsToInsert[iCount].bIsSQLTypeFrom to bOK
89107>>>        Loop
89108>>>>
89108>>>        
89108>>>        Function_Return bOK
89109>>>    End_Function
89110>>>    
89110>>>    // Returns a struct array with fields that has the same names but different field numbers.
89110>>>    Function UtilColumnsCheckForMoves Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[] 
89112>>>        tAPIColumnCompare[] aAPIColumnsToMove
89112>>>        tAPIColumnCompare[] aAPIColumnsToMove
89113>>>        Integer iSize iCount iItem iFieldTo
89113>>>        
89113>>>        Open hTable
89115>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89116>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
89117>>>
89117>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize       
89118>>>        Decrement iSize
89119>>>        for iCount from 0 to iSize    
89125>>>>
89125>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
89127>>>                Field_Map hTable aAPIColumnCompare[iCount].sFieldNameFrom to iFieldTo
89129>>>                If (iFieldTo > 0) Begin
89131>>>                    Move aAPIColumnCompare[iCount].iFieldNumber to aAPIColumnsToMove[iItem].iFieldNumber 
89132>>>                    Move iFieldTo                               to aAPIColumnsToMove[iItem].iFieldNumberTo 
89133>>>                    Increment iItem
89134>>>                End
89134>>>>
89134>>>            End
89134>>>>
89134>>>        Loop
89135>>>>
89135>>>        
89135>>>        Move False to Err
89136>>>        Move 0 to LastErr
89137>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89138>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
89139>>>        Function_Return aAPIColumnsToMove
89140>>>    End_Function   
89141>>>    
89141>>>    Function UtilColumnsMove Handle hTable tAPIColumnCompare[] aAPIColumnsToMove Returns Boolean
89143>>>        Integer iSize iCount
89143>>>        Boolean bOK                             
89143>>>        tAPIColumn[] aColumnsTo 
89143>>>        tAPIColumn[] aColumnsTo 
89144>>>        tAPIColumnCompare[] aAPIColumnCompare
89144>>>        tAPIColumnCompare[] aAPIColumnCompare
89145>>>
89145>>>        Move (SizeOfArray(aAPIColumnsToMove)) to iSize
89146>>>        If (iSize = 0) Begin
89148>>>            Function_Return True
89149>>>        End                     
89149>>>>
89149>>>        
89149>>>        Move False to Err
89150>>>        Decrement iSize
89151>>>        for iCount from 0 to iSize
89157>>>>
89157>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89158>>>            If (aAPIColumnsToMove[iCount].bExistsFrom = True and aAPIColumnsToMove[iCount].bExistsTo = True) Begin
89160>>>                Get ApiColumnMove hTable aAPIColumnsToMove[iCount].iFieldNumberTo aAPIColumnsToMove[iCount].iFieldNumber aAPIColumnsToMove[iCount].bIsSQLTypeFrom to bOK
89161>>>            End
89161>>>>
89161>>>        Loop
89162>>>>
89162>>>        
89162>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89163>>>        Function_Return bOK
89164>>>    End_Function
89165>>>
89165>>>    // Checks if the "FROM" and "TO" database field is the same _except_ for the field name.
89165>>>    // We then assume this field should be renamed.
89165>>>//    Function UtilColumCheckRename Handle hTable tAPIColumnCompare aAPIColumnCompare Returns Boolean
89165>>>//        Boolean bDifferentFieldNames bShouldBeRenamed        
89165>>>//        
89165>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89165>>>//        Move (Uppercase(aAPIColumnCompare.sFieldNameFrom) <> Uppercase(aAPIColumnCompare.sFieldNameTo)) to bDifferentFieldNames
89165>>>//        
89165>>>//        If (bDifferentFieldNames = True) Begin
89165>>>//            Move (aAPIColumnCompare.iFieldNumber = aAPIColumnCompare.iFieldNumberTo) to bShouldBeRenamed
89165>>>//            If (bShouldBeRenamed = False) Begin
89165>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
89165>>>//                Function_Return False
89165>>>//            End
89165>>>//        
89165>>>//            Move (aAPIColumnCompare.iTypeFrom = aAPIColumnCompare.iTypeTo) to bShouldBeRenamed
89165>>>//            If (bShouldBeRenamed = False) Begin
89165>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
89165>>>//                Function_Return False
89165>>>//            End
89165>>>//        
89165>>>//            Move (aAPIColumnCompare.iLengthFrom = aAPIColumnCompare.iLengthTo) to bShouldBeRenamed
89165>>>//            If (bShouldBeRenamed = False) Begin
89165>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
89165>>>//                Function_Return False
89165>>>//            End
89165>>>//        
89165>>>//            Move (aAPIColumnCompare.iPrecisionFrom = aAPIColumnCompare.iPrecisionTo) to bShouldBeRenamed
89165>>>//            If (bShouldBeRenamed = False) Begin
89165>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
89165>>>//                Function_Return False
89165>>>//            End
89165>>>//        End
89165>>>//    
89165>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
89165>>>//        Function_Return True
89165>>>//    End_Function                   
89165>>>    
89165>>>    // Takes a tAPIColumnCompare struct as parameter and returns True if;
89165>>>    // - Field Numbers, Data Types, Lengths and Precisions are all equal.
89165>>>    // - The "FROM" field name is <> "TO" field name
89165>>>    // - The "FROM" field name also exists in the "TO" table; or the "TO" is part
89165>>>    //   of the "FROM" field name. E.g. "FROM" = LATEST_REPL_COST_DATE, "TO" = Latest_Repl_Cos would results in a TRUE.
89165>>>    Function UtilColumnShouldBeRenamed tAPIColumnCompare aAPIColumnCompare Returns Boolean
89167>>>        Boolean bExists bShouldRename
89167>>>        String sFieldNameFrom sFieldNameTo
89167>>>        
89167>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameFrom)) to sFieldNameFrom
89168>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameTo))   to sFieldNameTo  
89169>>>        If (sFieldNameFrom = sFieldNameTo) Begin
89171>>>            Function_Return False
89172>>>        End
89172>>>>
89172>>>        
89172>>>        Move (aAPIColumnCompare.bExistsFrom    = aAPIColumnCompare.bExistsTo      and ;              aAPIColumnCompare.iFieldNumber   = aAPIColumnCompare.iFieldNumberTo and ;              aAPIColumnCompare.iTypeFrom      = aAPIColumnCompare.iTypeTo        and ;              aAPIColumnCompare.iLengthFrom    = aAPIColumnCompare.iLengthTo      and ;              aAPIColumnCompare.iPrecisionFrom = aAPIColumnCompare.iPrecisionTo   and ;              aAPIColumnCompare.iOptionsFrom   = aAPIColumnCompare.iOptionsTo) to bShouldRename
89173>>>        If (bShouldRename = False) Begin
89175>>>            Function_Return False
89176>>>        End                      
89176>>>>
89176>>>        
89176>>>        If (sFieldNameFrom contains sFieldNameTo) Begin
89178>>>            Function_Return True
89179>>>        End
89179>>>>
89179>>>        
89179>>>        Function_Return bShouldRename
89180>>>    End_Function
89181>>>    
89181>>>    Function UtilColumnExistsWithOtherNumber tAPIColumnCompare[] aAPIColumnCompare Integer iColumn Returns Boolean
89183>>>        Boolean bExists
89183>>>        Integer iCount iSize
89183>>>        String sFieldNameFrom
89183>>>        
89183>>>        Move (Uppercase(aAPIColumnCompare[iColumn].sFieldNameFrom)) to sFieldNameFrom
89184>>>        
89184>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
89185>>>        Decrement iSize
89186>>>        for iCount from 0 to iSize
89192>>>>
89192>>>            // We're only interested in fields other than the passed field/column number:
89192>>>            If ((iCount +1) <> iColumn) Begin
89194>>>                If (Uppercase(aAPIColumnCompare[iCount].sFieldNameTo) = sFieldNameFrom) Begin
89196>>>                    Move True to bExists 
89197>>>                End  
89197>>>>
89197>>>                Else If (sFieldNameFrom contains Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
89200>>>                    Move True to bExists 
89201>>>                End
89201>>>>
89201>>>            End
89201>>>>
89201>>>        Loop
89202>>>>
89202>>>        
89202>>>        Function_Return bExists 
89203>>>    End_Function
89204>>>    
89204>>>    Function UtilColumnsCheckForRenames Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[] 
89206>>>        tAPIColumnCompare[] aAPIColumnsToRename
89206>>>        tAPIColumnCompare[] aAPIColumnsToRename
89207>>>        Integer iSize iCount iItem iFieldTo iNumberOfFieldsTo
89207>>>        Boolean bRenameField
89207>>>        
89207>>>        Open hTable
89209>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumberOfFieldsTo
89212>>>        Move 0 to iItem
89213>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize                    
89214>>>        Move (iSize min iNumberOfFieldsTo)    to iSize
89215>>>        Decrement iSize
89216>>>        for iCount from 0 to iSize    
89222>>>>
89222>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
89224>>>                Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount] to bRenameField
89225>>>                If (bRenameField = True) Begin
89227>>>                    Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToRename[iItem].iFieldNumber 
89228>>>                    Move iFieldTo                                   to aAPIColumnsToRename[iItem].iFieldNumberTo 
89229>>>                    Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToRename[iItem].sFieldNameFrom
89230>>>                    Move aAPIColumnCompare[iCount].sFieldNameTo     to aAPIColumnsToRename[iItem].sFieldNameTo
89231>>>                    Increment iItem
89232>>>                End
89232>>>>
89232>>>            End
89232>>>>
89232>>>        Loop
89233>>>>
89233>>>        
89233>>>        Move False to Err
89234>>>        Move 0 to LastErr
89235>>>        Function_Return aAPIColumnsToRename
89236>>>    End_Function   
89237>>>    
89237>>>    Function UtilColumnsRename Handle hTable tAPIColumnCompare[] aAPIColumnsToRename Returns Boolean
89239>>>        Integer iSize iCount
89239>>>        Boolean bOK                             
89239>>>        tAPIColumn[] aColumnsTo 
89239>>>        tAPIColumn[] aColumnsTo 
89240>>>        tAPIColumnCompare[] aAPIColumnCompare
89240>>>        tAPIColumnCompare[] aAPIColumnCompare
89241>>>
89241>>>        Move (SizeOfArray(aAPIColumnsToRename)) to iSize
89242>>>        If (iSize = 0) Begin
89244>>>            Function_Return True
89245>>>        End                     
89245>>>>
89245>>>        
89245>>>        Move False to Err
89246>>>        Decrement iSize
89247>>>        For iCount from 0 to iSize
89253>>>>
89253>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89254>>>            Get ApiColumnRename hTable aAPIColumnsToRename[iCount].sFieldNameTo aAPIColumnsToRename[iCount].sFieldNameFrom to bOK 
89255>>>        Loop
89256>>>>
89256>>>        
89256>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89257>>>        Function_Return bOK
89258>>>    End_Function
89259>>>
89259>>>    Function UtilColumnIsDateType Integer iType Boolean bIsSQLTableTo Returns Boolean
89261>>>        Boolean bDateType
89261>>>        
89261>>>        If (bIsSQLTableTo = True) Begin
89263>>>            Move (iType = SQL_TYPE_DATE or iType = SQL_TYPE_TIMESTAMP or iType = SQL_TYPE_TIMESTAMP2) to bDateType
89264>>>        End 
89264>>>>
89264>>>        Else Begin
89265>>>            Move (iType = DF_DATE or iType = DF_DATETIME) to bDateType
89266>>>        End
89266>>>>
89266>>>    
89266>>>        Function_Return bDateType
89267>>>    End_Function
89268>>>    
89268>>>    Function ApiColumnsUpdate String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo Boolean bCompareDate_DateTime Returns Boolean
89270>>>        Integer iCount iSize iColumn iTypeFrom iTypeTo iDataFlexType iIndex iLengthFrom iLengthTo iPrecisionFrom iPrecisionTo iOptionFrom iOptionTo iDbType
89270>>>        Handle hFile
89270>>>        Boolean bFieldExistsFrom bFieldExistsTo bShouldMove bIsSQLDriver bIsSame bOK bSkip
89270>>>        Boolean bRecnum bIsSQLTableTo bOpened bRecnumTable bIsOpen bSkipTypeChange bIsDateType
89270>>>        String sFieldNameFrom sFieldNameTo sDriverIDTo sDefaultValue
89270>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns
89270>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns
89274>>>        tColumnType ColumnType
89274>>>        tColumnType ColumnType
89274>>>
89274>>>        Move False to Err
89275>>>        Close hTable
89276>>>        Get OpenTableExclusive hTable to bIsOpen
89277>>>        If (bIsOpen = False) Begin
89279>>>            Error DFERR_PROGRAM ("Function 'ApiColumnsUpdate'. Can't open table number:" * String(hTable))
89280>>>>
89280>>>            Function_Return False
89281>>>        End
89281>>>>
89281>>>
89281>>>        Get piDbType to iDbType
89282>>>        Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
89285>>>        Get IsSQLDriver sDriverIDFrom to bIsSQLDriver
89286>>>        Get UtilTableIsSQL hTable     to bIsSQLTableTo
89287>>>        If (bIsSQLTableTo = False) Begin
89289>>>            Move DATAFLEX_ID to sDriverIDTo
89290>>>        End
89290>>>>
89290>>>        Else Begin          
89291>>>            Get_Attribute DF_FILE_DRIVER of hTable to sDriverIDTo
89294>>>        End
89294>>>>
89294>>>        
89294>>>        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
89295>>>        
89295>>>        // Before we start to change the table we need to do three things;
89295>>>        // 1) Insert any new fields
89295>>>        Get UtilColumnsCheckForInserts hTable aAPIColumnCompare to aApiInsertColumns
89296>>>        If (SizeOfArray(aApiInsertColumns)) Begin
89298>>>            Get UtilColumnsInsert hTable aApiInsertColumns to bOK
89299>>>            If (bOK = False) Begin
89301>>>                Function_Return False
89302>>>            End                  
89302>>>>
89302>>>            // Update info with changes made.
89302>>>            Get UtilColumnsStructFill hTable to aColumnsTo
89303>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
89304>>>        End
89304>>>>
89304>>>        
89304>>>        // 2) Rename fields
89304>>>        Get UtilColumnsCheckForRenames hTable aAPIColumnCompare to aAPIRenameColumns
89305>>>        If (SizeOfArray(aAPIRenameColumns)) Begin
89307>>>            Get UtilColumnsRename hTable aAPIRenameColumns to bOK
89308>>>            If (bOK = False) Begin
89310>>>                Function_Return False
89311>>>            End
89311>>>>
89311>>>            Get UtilColumnsStructFill hTable to aColumnsTo
89312>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
89313>>>        End
89313>>>>
89313>>>
89313>>>        // 3) Move fields with same names
89313>>>        Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIMoveColumns
89314>>>        If (SizeOfArray(aAPIMoveColumns)) Begin
89316>>>            Get UtilColumnsMove hTable aAPIMoveColumns to bOK
89317>>>            If (bOK = False) Begin
89319>>>                Function_Return False
89320>>>            End
89320>>>>
89320>>>            Get UtilColumnsStructFill hTable to aColumnsTo
89321>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
89322>>>        End
89322>>>>
89322>>>        
89322>>>        // If any of the fields were changed by "Insert", "Rename" or "Move", we need to compare the fields again: 
89322>>>        If (SizeOfArray(aApiInsertColumns) or SizeOfArray(aAPIRenameColumns) or SizeOfArray(aAPIMoveColumns)) Begin
89324>>>            Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
89325>>>            If (bIsSame = True) Begin
89327>>>                Function_Return True
89328>>>            End
89328>>>>
89328>>>        End
89328>>>>
89328>>>        
89328>>>        // We can now continue to make standard field changes:
89328>>>        Get OpenTableExclusive hTable to bIsOpen
89329>>>        Set Private.phCurrentTable to hTable
89330>>>        Move hTable to hFile
89331>>>        Structure_Start hFile sDriverIDTo
89332>>>
89332>>>            Move (SizeOfArray(aAPIColumnCompare)) to iSize
89333>>>            Decrement iSize
89334>>>            For iCount from 0 to iSize
89340>>>>
89340>>>                Send DoAdvance of ghoProgressBar
89341>>>                                
89341>>>                Move aAPIColumnCompare[iCount].bExistsFrom          to bFieldExistsFrom
89342>>>                If (bFieldExistsFrom = True) Begin
89344>>>                    Move aAPIColumnCompare[iCount].bExistsTo        to bFieldExistsTo
89345>>>                    Move aAPIColumnCompare[iCount].sFieldNameFrom   to sFieldNameFrom
89346>>>                    Move aAPIColumnCompare[iCount].iFieldNumber     to iColumn              
89347>>>                    Set Private.piCurrentField                      to iColumn
89348>>>                    Move aAPIColumnCompare[iCount].iLengthFrom      to iLengthFrom                                   
89349>>>                    Move aAPIColumnCompare[iCount].iPrecisionFrom   to iPrecisionFrom
89350>>>                    Move aAPIColumnCompare[iCount].iOptionsFrom     to iOptionFrom
89351>>>                    
89351>>>                    Move aAPIColumnCompare[iCount].iTypeFrom        to iTypeFrom
89352>>>//                    Get UtilDFDataTypeToSqlTypeMapping sDriverIDFrom iDbType iTypeFrom to ColumnType
89352>>>//                    Move ColumnType.iDataFlexType                   to iDataFlexType
89352>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iDataFlexType
89353>>>                    If (iTypeFrom < -1490) Begin
89355>>>                        Move (iTypeFrom + 1500)                     to iTypeFrom
89356>>>                    End
89356>>>>
89356>>>    
89356>>>                    // If one of the two tables are SQL and the other Embedded we need to "translate"
89356>>>                    // data types between Embedded and SQL, else we can't compare the data types.
89356>>>                    If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
89358>>>                        Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeFrom
89359>>>                    End
89359>>>>
89359>>>                    Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
89362>>>                        Get UtilSqlColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeTo
89363>>>                    End
89363>>>>
89363>>>                    
89363>>>                    Move aAPIColumnCompare[iCount].sFieldNameTo to sFieldNameTo
89364>>>                    Move aAPIColumnCompare[iCount].iLengthTo    to iLengthTo
89365>>>                    Move aAPIColumnCompare[iCount].iPrecisionTo to iPrecisionTo
89366>>>                    Move aAPIColumnCompare[iCount].iOptionsTo   to iOptionTo
89367>>>                    Move aAPIColumnCompare[iCount].iTypeTo      to iTypeTo
89368>>>                    
89368>>>                    Move False to bSkipTypeChange
89369>>>                    If (bCompareDate_DateTime = False) Begin
89371>>>                        Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkipTypeChange
89372>>>                    End
89372>>>>
89372>>>                    
89372>>>                    If (bFieldExistsTo = False) Begin 
89374>>>                        Move 0 to iColumn
89375>>>                        Create_Field hFile At iColumn
89376>>>                        Set Private.piCurrentField to iColumn
89377>>>                    End
89377>>>>
89377>>>                    
89377>>>                    If (sFieldNameFrom <> sFieldNameTo) Begin
89379>>>                        Set_Attribute DF_FIELD_NAME of hFile iColumn to sFieldNameFrom
89382>>>                    End                   
89382>>>>
89382>>>                    
89382>>>                    If (bIsSQLTableFrom = True and aAPIColumnCompare[iCount].iOptionsFrom <> C_tAPIColumn_Identity) Begin
89384>>>                        Set_Attribute DF_FIELD_NULL_ALLOWED  of hFile iColumn to aAPIColumnCompare[iCount].bAllowNULLFrom
89387>>>                        Move aAPIColumnCompare[iCount].sDefaultValueFrom to sDefaultValue
89388>>>                        If (iDataFlexType = DF_BCD and Left(sDefaultValue, 1 <> "[")) Begin
89390>>>                            Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
89391>>>                        End
89391>>>>
89391>>>                        Set_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefaultValue
89394>>>                    End
89394>>>>
89394>>>                    
89394>>>                    If (bSkipTypeChange = False) Begin
89396>>>                        If (iTypeFrom <> iTypeTo) Begin 
89398>>>                            If (bIsSQLTableTo = True) Begin
89400>>>                                Set_Attribute DF_FIELD_NATIVE_TYPE   of hFile iColumn to iTypeFrom
89403>>>                            End
89403>>>>
89403>>>                            Else Begin
89404>>>                                Set_Attribute DF_FIELD_TYPE          of hFile iColumn to iDataFlexType
89407>>>                            End
89407>>>>
89407>>>                        End
89407>>>>
89407>>>                    End
89407>>>>
89407>>>                    
89407>>>                    Get UtilColumnIsDateType iTypeFrom bIsSQLTableTo to bIsDateType   
89408>>>                    // We can't set the length or precision for Date type columns (they are fixed).
89408>>>                    If (bIsDateType = False) Begin
89410>>>                        If (iLengthFrom <> iLengthTo) Begin
89412>>>                            Set_Attribute DF_FIELD_LENGTH of hFile iColumn to iLengthFrom
89415>>>                        End
89415>>>>
89415>>>                        If (iPrecisionFrom <> iPrecisionTo) Begin
89417>>>                            Set_Attribute DF_FIELD_PRECISION of hFile iColumn to iPrecisionFrom
89420>>>                        End
89420>>>>
89420>>>                    End
89420>>>>
89420>>>    
89420>>>                    If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
89422>>>                        // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
89422>>>                        If (bRecnumTable = True) Begin
89424>>>                            Set_Attribute DF_FILE_RECNUM_TABLE of hTable to False
89427>>>                        End
89427>>>>
89427>>>    
89427>>>                        // We might need to create an index here.
89427>>>                        // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
89427>>>                        // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
89427>>>                        // index update checking logic.
89427>>>                        Get_Attribute DF_FIELD_INDEX           of hFile iColumn to iIndex
89430>>>                        If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
89432>>>                            Create_Index hFile at iIndex
89433>>>                            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hFile iIndex to 1
89436>>>                        End
89436>>>>
89436>>>
89436>>>                        Set_Attribute DF_INDEX_SEGMENT_FIELD   of hFile iIndex 1 to iColumn
89439>>>                        Set_Attribute DF_FILE_PRIMARY_INDEX    of hFile          to iIndex
89442>>>                            // Note: The order of these two are crucial!
89442>>>                            Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hFile iIndex to True
89445>>>                            Set_Attribute DF_FIELD_IS_IDENTITY of hFile iColumn    to True
89448>>>                    End
89448>>>>
89448>>>                End
89448>>>>
89448>>>            Loop 
89449>>>>
89449>>>        
89449>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89450>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89452>>>
89452>>>        Set Action_Text of ghoStatusPanel to ""
89453>>>        Function_Return (Err = False)
89454>>>    End_Function
89455>>>
89455>>>    // * Dummy function for the Studio's Code Explorer *
89455>>>    Function API_INDEX_FUNCTIONS Returns Boolean
89457>>>        Function_Return False
89458>>>    End_Function
89459>>>
89459>>>    // Get ApiIndexCreate Customers.File_Number 1 2 0 1 -1 -1 -1 -1 -1 -1 -1 -1 to bOK
89459>>>    // Note: the "-1" can be left out as this function is overloaded to make it easier to call.
89459>>>    // Note: This doesn't set Descending attributes - Use function IndexChangeDirection to do that.
89459>>>    Function ApiIndexCreate Handle hTable Integer iIndex Integer iSegments Integer iSgmnt1 Integer iSgmnt2 Integer iSgmnt3 Integer iSgmnt4 Integer iSgmnt5 Integer iSgmnt6 Integer iSgmnt7 Integer iSgmnt8 Integer iSgmnt9 Integer iSgmnt10 Returns Boolean
89461>>>        Integer iTableNo iSegment1 iSegment2 iSegment3 iSegment4 iSegment5 iSegment6 iSegment7 iSegment8 iSegment9 iSegment10
89461>>>        String sDriverID
89461>>>        Boolean bOK
89461>>>
89461>>>        Get AutoConnectionIDLogin to bOK
89462>>>        Move -1 to iSegment1
89463>>>        Move -1 to iSegment2
89464>>>        Move -1 to iSegment3
89465>>>        Move -1 to iSegment4
89466>>>        Move -1 to iSegment5
89467>>>        Move -1 to iSegment6
89468>>>        Move -1 to iSegment7
89469>>>        Move -1 to iSegment8
89470>>>        Move -1 to iSegment9
89471>>>        Move -1 to iSegment10
89472>>>
89472>>>        If (num_arguments > 3) Begin
89474>>>            Move iSgmnt1 to iSegment1
89475>>>        End
89475>>>>
89475>>>        If (num_arguments > 4) Begin
89477>>>            Move iSgmnt2 to iSegment2
89478>>>        End
89478>>>>
89478>>>        If (num_arguments > 5) Begin
89480>>>            Move iSgmnt3 to iSegment3
89481>>>        End
89481>>>>
89481>>>        If (num_arguments > 6) Begin
89483>>>            Move iSgmnt4 to iSegment4
89484>>>        End
89484>>>>
89484>>>        If (num_arguments > 7) Begin
89486>>>            Move iSgmnt5 to iSegment5
89487>>>        End
89487>>>>
89487>>>        If (num_arguments > 8) Begin
89489>>>            Move iSgmnt6 to iSegment6
89490>>>        End
89490>>>>
89490>>>        If (num_arguments > 9) Begin
89492>>>            Move iSgmnt7 to iSegment7
89493>>>        End
89493>>>>
89493>>>        If (num_arguments > 10) Begin
89495>>>            Move iSgmnt8 to iSegment8
89496>>>        End
89496>>>>
89496>>>        If (num_arguments > 11) Begin
89498>>>            Move iSgmnt9 to iSegment9
89499>>>        End
89499>>>>
89499>>>        If (num_arguments > 12) Begin
89501>>>            Move iSgmnt10 to iSegment10
89502>>>        End
89502>>>>
89502>>>
89502>>>        Move False to Err
89503>>>        Move hTable to iTableNo
89504>>>        Get OpenTableExclusive hTable to bOK
89505>>>        If (bOK = False) Begin
89507>>>            Function_Return False
89508>>>        End
89508>>>>
89508>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89511>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89512>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
89513>>>        Send Ignore_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
89514>>>
89514>>>        // We start by deleting the index
89514>>>        Structure_Start hTable sDriverID
89515>>>            Delete_Index iTableNo iIndex
89516>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89517>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89519>>>
89519>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89520>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
89521>>>        Send Trap_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
89522>>>        Set Action_Text of ghoStatusPanel to ""
89523>>>        Move False to Err 
89524>>>        Move 0 to LastErr
89525>>>        Move iTableNo to hTable
89526>>>        Get OpenTableExclusive hTable to bOK
89527>>>        If (bOK = False) Begin
89529>>>            Function_Return False
89530>>>        End
89530>>>>
89530>>>
89530>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
89531>>>        Structure_Start hTable sDriverID
89532>>>            Create_Index hTable At iIndex
89533>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iSegments
89536>>>
89536>>>            If (iSgmnt1 <> -1) Begin
89538>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 1 to iSegment1
89541>>>            End
89541>>>>
89541>>>            If (iSegment2 <> -1) Begin
89543>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 2 to iSegment2
89546>>>            End
89546>>>>
89546>>>            If (iSegment3 <> -1) Begin
89548>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 3 to iSegment3
89551>>>            End
89551>>>>
89551>>>            If (iSegment4 <> -1) Begin
89553>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 4 to iSegment4
89556>>>            End
89556>>>>
89556>>>            If (iSegment5 <> -1) Begin
89558>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 5 to iSegment5
89561>>>            End
89561>>>>
89561>>>            If (iSegment6 <> -1) Begin
89563>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 6 to iSegment6
89566>>>            End
89566>>>>
89566>>>            If (iSegment7 <> -1) Begin
89568>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 7 to iSegment7
89571>>>            End
89571>>>>
89571>>>            If (iSegment8 <> -1) Begin
89573>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 8 to iSegment8
89576>>>            End
89576>>>>
89576>>>            If (iSegment9 <> -1) Begin
89578>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 9 to iSegment9
89581>>>            End
89581>>>>
89581>>>            If (iSegment10 <> -1) Begin
89583>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 10 to iSegment10
89586>>>            End
89586>>>>
89586>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89587>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89589>>>
89589>>>        Set Action_Text of ghoStatusPanel to ""
89590>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
89591>>>
89591>>>        Function_Return (Err = False)
89592>>>    End_Function
89593>>>
89593>>>    Function APIIndexCreateByFieldNames Handle hTable tAPIIndex APIIndex tAPIIndex[] APIIndexTo tAPIIndexSegment[] aIndexSegments Returns Boolean
89595>>>        String[] aFields
89596>>>        Integer iCount iSegmentsFrom iFieldFrom iFieldTo iSegmentsTo iSQLIndexType iLastIndex iTableNo iSQLIndexTo
89596>>>        String sDriverID sSQLIndexName sTableName
89596>>>        Boolean bOK bIsSQLTable bIsOpen bIsSQLPrimaryKey bIsSQLClustered bIsSQLTemporaryIndex bExists
89596>>>
89596>>>        Move (SizeOfArray(aIndexSegments)) to iSegmentsFrom
89597>>>        If (iSegmentsFrom = 0) Begin
89599>>>            Function_Return False
89600>>>        End
89600>>>>
89600>>>
89600>>>        Get AutoConnectionIDLogin to bOK
89601>>>        Move False to Err
89602>>>        Get OpenTableExclusive hTable to bIsOpen
89603>>>        If (bIsOpen = False) Begin
89605>>>            Function_Return False
89606>>>        End
89606>>>>
89606>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89609>>>        Get UtilTableIsSql hTable to bIsSQLTable   
89610>>>        
89610>>>        Move 0     to iSegmentsTo    
89611>>>        Move 0     to iSQLIndexType 
89612>>>        Move ""    to sSQLIndexName
89613>>>        Move False to bIsSQLTemporaryIndex 
89614>>>        Move False to bIsSQLPrimaryKey
89615>>>        Move False to bIsSQLClustered
89616>>>        
89616>>>//        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable                               to iLastIndex
89616>>>//        If (APIIndex.iIndexNumber <= iLastIndex) Begin
89616>>>//            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber      to iSegmentsTo
89616>>>//            If (bIsSQLTable = True) Begin
89616>>>//                Get_Attribute DF_INDEX_NAME of hTable APIIndex.iIndexNumber             to sSQLIndexName
89616>>>//                #IF (Required_RT_Version > 17)                                    
89616>>>//                Get_Attribute DF_INDEX_SQL_TYPE of hTable APIIndex.iIndexNumber         to iSQLIndexType
89616>>>//                Move (iSQLIndexType = DF_INDEX_TEMPORARY)                               to bIsSQLTemporaryIndex
89616>>>//                Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber  to bIsSQLPrimaryKey
89616>>>//                Get_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber  to bIsSQLClustered
89616>>>//                #ENDIF
89616>>>//            End
89616>>>//        End
89616>>>        
89616>>>        Move hTable to iTableNo 
89617>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber to bExists
89620>>>        If (bExists = True) Begin
89622>>>            Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber to bIsSQLPrimaryKey
89625>>>            If (bIsSQLPrimaryKey = False) Begin
89627>>>                // We start by deleting the index, if it exists
89627>>>                Structure_Start iTableNo sDriverID
89628>>>                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89629>>>                    Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
89630>>>                    Delete_Index iTableNo APIIndex.iIndexNumber
89631>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
89632>>>                    Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
89633>>>                    Set Action_Text of ghoStatusPanel to "Restructures table..."
89634>>>                Structure_End iTableNo DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89636>>>                Set Action_Text of ghoStatusPanel to ""
89637>>>                
89637>>>                Get OpenTableExclusive hTable to bOK
89638>>>                If (bOK = False) Begin
89640>>>                    Function_Return False
89641>>>                End
89641>>>>
89641>>>            End
89641>>>>
89641>>>        End
89641>>>>
89641>>>        
89641>>>        Move hTable to iTableNo
89642>>>        Move False to Err
89643>>>        Move 0 to LastErr 
89644>>>
89644>>>        // Note: If the SQL index type = DF_INDEX_TEMPORARY, we _must_ set the DF_INDEX_SQL_TYPE 
89644>>>        //       _outside_ the Structure_Start/End construct.
89644>>>//        Move False to bIsSQLTemporaryIndex
89644>>>//        #IF (Required_RT_Version > 17)                                    
89644>>>//            If (bIsSQLTemporaryIndex = True and APIIndex.iIndexNumber <= iLastIndex) Begin
89644>>>//                If (APIIndex.iSQLIndexType <> iSQLIndexType) Begin
89644>>>//                    Set_Attribute DF_INDEX_SQL_TYPE of hTable APIIndex.iIndexNumber to APIIndex.iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
89644>>>//                End
89644>>>//            End
89644>>>//        #ENDIF
89644>>>        
89644>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89645>>>        Structure_Start hTable sDriverID
89646>>>            If (bIsSQLPrimaryKey = False) Begin
89648>>>                Create_Index hTable At APIIndex.iIndexNumber
89649>>>            End
89649>>>>
89649>>>
89649>>>//            If (bIsSQLTable = True) Begin                                                         
89649>>>//                // In case the SQL Index name already exists for another index number; we temporarily rename that index name;
89649>>>//                Get UtilIndexSQLIndexNameExists iTableNo APIIndex.iIndexNumber APIIndex.sSQLIndexName APIIndexTo to iSQLIndexTo
89649>>>//                If (iSQLIndexTo > 0) Begin   
89649>>>//                    Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
89649>>>//                    Set_Attribute DF_INDEX_NAME of hTable iSQLIndexTo to (sTableName + String("001") + String(iSQLIndexTo))
89649>>>//                End
89649>>>//                Set_Attribute DF_INDEX_NAME of hTable APIIndex.iIndexNumber to APIIndex.sSQLIndexName
89649>>>//            End
89649>>>            
89649>>>            If (bIsSQLTable = True) Begin // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
89651>>>                Set_Attribute DF_INDEX_SQL_TYPE        of hTable APIIndex.iIndexNumber to APIIndex.iSQLIndexType 
89654>>>                Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLPrimaryKey
89657>>>                Set_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLClustered
89660>>>            End
89660>>>>
89660>>>                
89660>>>                If (iSegmentsFrom <> iSegmentsTo) Begin
89662>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber to iSegmentsFrom
89665>>>            End
89665>>>>
89665>>>            
89665>>>            for iCount from 0 to (iSegmentsFrom -1)
89671>>>>
89671>>>                Move aIndexSegments[iCount].iFieldNumber to iFieldFrom   
89672>>>                If (iFieldFrom <> -1 ) Begin
89674>>>                        Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable APIIndex.iIndexNumber (iCount +1) to iFieldFrom
89677>>>                End
89677>>>>
89677>>>            Loop                         
89678>>>>
89678>>>                
89678>>>            // If more segments existed; remove them
89678>>>//            If (iSegmentsTo > iSegmentsFrom) Begin
89678>>>//                for iCount from iSegmentsFrom to iSegmentsTo
89678>>>//                          Get ApiIndexDeleteSegment hTable APIIndex.iIndexNumber iCount to bOK
89678>>>//                Loop
89678>>>//                  Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber to iSegmentsFrom
89678>>>//            End
89678>>>                
89678>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89679>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89681>>>
89681>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89682>>>        Set Action_Text of ghoStatusPanel to ""
89683>>>        
89683>>>        Function_Return (Err = False)
89684>>>    End_Function 
89685>>>    
89685>>>    // Checks if an SQL Index name for the "FROM" database already exists in the TO database,
89685>>>    // but with another Index number. We can then not rename the SQL index name for the TO database table.
89685>>>    Function UtilIndexSQLIndexNameExists Handle hTable Integer iIndexNumberFrom String sSQLIndexNameFrom tAPIIndex[] APIIndexTo Returns Integer
89687>>>        Integer iSize iCount iIndexNumberTo
89687>>>        String sSQLIndexNameTo
89687>>>        Integer iRetVal
89687>>>        
89687>>>        Move 0 to iRetVal     
89688>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndexNumberFrom to iRetVal
89691>>>        If (iRetVal = 0) Begin
89693>>>            Function_Return 0
89694>>>        End
89694>>>>
89694>>>        Move (SizeOfArray(APIIndexTo)) to iSize
89695>>>        Decrement iSize
89696>>>        for iCount from 0 to iSize
89702>>>>
89702>>>            If (Uppercase(sSQLIndexNameFrom) = Uppercase(APIIndexTo[iCount].sSQLIndexName)) Begin
89704>>>                If (iIndexNumberFrom <> APIIndexTo[iCount].iIndexNumber) Begin
89706>>>                    Move APIIndexTo[iCount].iIndexNumber to iRetVal
89707>>>                End
89707>>>>
89707>>>            End
89707>>>>
89707>>>        Loop
89708>>>>
89708>>>        
89708>>>        Function_Return iRetVal
89709>>>    End_Function   
89710>>>    
89710>>>    Function ApiIndexDeleteSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
89712>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
89712>>>    
89712>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89715>>>        If (iSegment = iNumSegments) Begin
89717>>>//            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89717>>>        End
89717>>>>
89717>>>    
89717>>>        Else If (iSegment > 0 and iSegment < iNumSegments) Begin
89720>>>            for iCurSegment from iSegment to (iNumSegments - 1)
89726>>>>
89726>>>                //*** Move index segment attributes
89726>>>                Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
89729>>>                Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
89732>>>                Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
89735>>>    
89735>>>                Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment to iSegmentCase
89738>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment to iSegmentDirection
89741>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment to iSegmentColumn
89744>>>            Loop
89745>>>>
89745>>>    
89745>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89748>>>        End
89748>>>>
89748>>>    
89748>>>    End_Procedure
89749>>>
89749>>>    Function APIIndexRemoveAllIndexes Handle hTable tAPIIndex[] APIIndex Returns Boolean
89751>>>        String[] aFields
89752>>>        Integer iCount iSize iIndex 
89752>>>        String sDriverID
89752>>>        Boolean bOK bIsSQLTable bIsOpen bIsSQLPrimaryKey
89752>>>
89752>>>        Move (SizeOfArray(APIIndex)) to iSize
89753>>>        If (iSize = 0) Begin
89755>>>            Function_Return True
89756>>>        End
89756>>>>
89756>>>
89756>>>        Get AutoConnectionIDLogin to bOK
89757>>>        Move False to Err
89758>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89761>>>        If (bIsOpen = False) Begin
89763>>>            Get OpenTableExclusive hTable to bIsOpen
89764>>>            If (bIsOpen = False) Begin
89766>>>                Function_Return False
89767>>>            End
89767>>>>
89767>>>        End    
89767>>>>
89767>>>        
89767>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89770>>>        Get UtilTableIsSql hTable to bIsSQLTable
89771>>>
89771>>>        Move False to Err
89772>>>        Move 0 to LastErr             
89773>>>        Decrement iSize
89774>>>
89774>>>        Structure_Start hTable sDriverID
89775>>>            for iCount from 0 to iSize
89781>>>>
89781>>>//                Move False to bIsSQLPrimaryKey
89781>>>//                #IF ((Required_RT_Version * 10 + Required_RT_Revision) > 180)   // DF 18.1 and up
89781>>>//                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89781>>>//                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex[iCount].iIndexNumber to bIsSQLPrimaryKey
89781>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
89781>>>//                #ENDIF
89781>>>                // We can't delete if this is a primary key index:
89781>>>//                If (bIsSQLPrimaryKey = False) Begin
89781>>>                    Move APIIndex[iCount].iIndexNumber to iIndex
89782>>>                    Delete_Index hTable iIndex
89783>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
89783>>>//                End
89783>>>            Loop
89784>>>>
89784>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89785>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89787>>>//        Move False to Err
89787>>>        Move 0 to LastErr
89788>>>
89788>>>        Set Action_Text of ghoStatusPanel to ""
89789>>>        Function_Return (Err = False)
89790>>>    End_Function
89791>>>
89791>>>    Function ApiIndexChangeDirection Handle hTable Integer iIndex Integer iSegment Integer iDirection Returns Boolean
89793>>>        Boolean bOK
89793>>>
89793>>>        Get AutoConnectionIDLogin to bOK
89794>>>        Move False to Err
89795>>>        Get OpenTableExclusive hTable to bOK
89796>>>        If (bOK = False) Begin
89798>>>            Function_Return False
89799>>>        End
89799>>>>
89799>>>        Structure_Start hTable
89800>>>            Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to iDirection
89803>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89804>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89806>>>
89806>>>        Set Action_Text of ghoStatusPanel to ""
89807>>>        Function_Return (Err = False)
89808>>>    End_Function
89809>>>
89809>>>    Function ApiIndexChangeUppercase Handle hTable Integer iIndex Integer iSegment Boolean bUppercase Returns Boolean
89811>>>        Integer iCase
89811>>>        Boolean bOK
89811>>>
89811>>>        If (bUppercase = True) Begin
89813>>>            Move DF_CASE_IGNORED to iCase
89814>>>        End
89814>>>>
89814>>>        Else Begin
89815>>>            Move DF_CASE_USED to iCase
89816>>>        End
89816>>>>
89816>>>
89816>>>        Get AutoConnectionIDLogin to bOK
89817>>>        Move False to Err
89818>>>        Get OpenTableExclusive hTable to bOK
89819>>>        If (bOK = False) Begin
89821>>>            Function_Return False
89822>>>        End
89822>>>>
89822>>>        Structure_Start hTable
89823>>>            Set_Attribute DF_INDEX_SEGMENT_CASE of hTable iIndex iSegment to iCase
89826>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89827>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89829>>>
89829>>>        Set Action_Text of ghoStatusPanel to ""
89830>>>        Function_Return (Err = False)
89831>>>    End_Function
89832>>>
89832>>>    // To delete an index
89832>>>    Function ApiIndexRemove Handle hTable Integer iIndex Returns Boolean
89834>>>        Integer iTableNo iNumSegments
89834>>>        String sDriverID
89834>>>        Boolean bOK
89834>>>
89834>>>        Get AutoConnectionIDLogin to bOK
89835>>>        Move False to Err
89836>>>        Move hTable to iTableNo
89837>>>        Get OpenTableExclusive hTable to bOK
89838>>>        If (bOK = False) Begin
89840>>>            Function_Return False
89841>>>        End
89841>>>>
89841>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89844>>>
89844>>>        // Check to see if the index exists or not...
89844>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89847>>>        If (iNumSegments = 0) Begin
89849>>>            Function_Return False
89850>>>        End
89850>>>>
89850>>>
89850>>>        Structure_Start hTable sDriverID
89851>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
89852>>>            Delete_Index iTableNo iIndex
89853>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
89854>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89855>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89857>>>
89857>>>        Set Action_Text of ghoStatusPanel to ""
89858>>>        Function_Return (Err = False)
89859>>>    End_Function
89860>>>
89860>>>    // Delete an Index Segment
89860>>>    Function ApiIndexRemoveSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
89862>>>        Boolean bOK bSQLDriver bIndexTemporary
89862>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
89862>>>        Integer iIndexType
89862>>>        String sDriverID
89862>>>
89862>>>        Get AutoConnectionIDLogin to bOK
89863>>>        Move False to Err
89864>>>
89864>>>        Get OpenTableExclusive hTable to bOK
89865>>>        If (bOK = False) Begin
89867>>>            Function_Return False
89868>>>        End
89868>>>>
89868>>>
89868>>>        // Check to see if the index exists or not...
89868>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89871>>>        If (iNumSegments = 0) Begin
89873>>>            Function_Return False
89874>>>        End
89874>>>>
89874>>>
89874>>>        Move False to bIndexTemporary
89875>>>        Get psDriverID to sDriverID
89876>>>        Get IsSQLDriver sDriverID to bSQLDriver
89877>>>        If (bSQLDriver) Begin
89879>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
89882>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
89885>>>                Move True to bIndexTemporary
89886>>>        End
89886>>>>
89886>>>
89886>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
89886>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
89888>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89891>>>            If (iSegment = iNumSegments) Begin
89893>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89896>>>            End
89896>>>>
89896>>>            Else If (iSegment > 0 and iSegment < iNumSegments) Begin
89899>>>                For iCurSegment from iSegment to (iNumSegments - 1)
89905>>>>
89905>>>                    //*** Move index segment attributes
89905>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
89908>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
89911>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
89914>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
89917>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
89920>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
89923>>>                Loop
89924>>>>
89924>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89927>>>            End
89927>>>>
89927>>>        End
89927>>>>
89927>>>
89927>>>        Else Begin
89928>>>           Structure_Start hTable
89929>>>               Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89932>>>               If (iSegment = iNumSegments) Begin
89934>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89937>>>               End
89937>>>>
89937>>>               Else If (iSegment > 0 and iSegment < iNumSegments) Begin
89940>>>                   for iCurSegment from iSegment to (iNumSegments - 1)
89946>>>>
89946>>>                       //*** Move index segment attributes
89946>>>                       Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
89949>>>                       Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
89952>>>                       Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
89955>>>                       Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
89958>>>                       Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
89961>>>                       Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
89964>>>                   Loop
89965>>>>
89965>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89968>>>               End
89968>>>>
89968>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
89969>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89971>>>            Set Action_Text of ghoStatusPanel to ""
89972>>>        End
89972>>>>
89972>>>
89972>>>        Function_Return (Err = False)
89973>>>    End_Function
89974>>>
89974>>>    // Add/Insert an Index Segment
89974>>>    Function ApiIndexInsertSegment Handle hTable Integer iIndex Integer iSegment Integer iSegmentColumn Integer iSegmentCase Integer iSegmentDirection Returns Boolean
89976>>>        Boolean bOK bSQLDriver bIndexTemporary
89976>>>        Integer iNumSegments iCurSegment iCurSegmentColumn iCurSegmentCase iCurSegmentDirection
89976>>>        Integer iIndexType
89976>>>        String sDriverId
89976>>>
89976>>>        Get AutoConnectionIDLogin to bOK
89977>>>        Move False to Err
89978>>>
89978>>>        Get OpenTableExclusive hTable to bOK
89979>>>        If (bOK = False) Begin
89981>>>            Function_Return False
89982>>>        End
89982>>>>
89982>>>
89982>>>        Move False to bIndexTemporary
89983>>>        // Check to see if the index exists or not...
89983>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89986>>>        If (iNumSegments = 0) Begin
89988>>>            Function_Return False
89989>>>        End
89989>>>>
89989>>>
89989>>>        Get psDriverID to sDriverID
89990>>>        Get IsSQLDriver sDriverID to bSQLDriver
89991>>>        If (bSQLDriver) Begin
89993>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
89996>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
89999>>>                Move True to bIndexTemporary
90000>>>        End
90000>>>>
90000>>>
90000>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
90000>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
90002>>>           Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
90005>>>
90005>>>           If (iSegment > iNumSegments) Begin
90007>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
90010>>>               Move (iNumSegments + 1) to iCurSegment
90011>>>           End
90011>>>>
90011>>>           Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
90014>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
90017>>>               Move iNumSegments to iCurSegment
90018>>>
90018>>>               While (iCurSegment > iSegment)
90022>>>                   //*** Move index segment attributes
90022>>>                   Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iCurSegmentCase
90025>>>                   Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iCurSegmentDirection
90028>>>                   Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
90031>>>                   Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iCurSegmentCase
90034>>>                   Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iCurSegmentDirection
90037>>>                   Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iCurSegmentColumn
90040>>>                   Decrement iCurSegment
90041>>>               End
90042>>>>
90042>>>
90042>>>               //*** Now set new segment attributes
90042>>>               Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
90045>>>               Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
90048>>>               Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
90051>>>           End
90051>>>>
90051>>>        End
90051>>>>
90051>>>
90051>>>        Else Begin
90052>>>           Structure_Start hTable
90053>>>              Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
90056>>>
90056>>>              If (iSegment > iNumSegments) Begin
90058>>>                  Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
90061>>>                  Move (iNumSegments + 1) to iCurSegment
90062>>>              End
90062>>>>
90062>>>              Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
90065>>>                  Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
90068>>>                  Move iNumSegments to iCurSegment
90069>>>
90069>>>                  While (iCurSegment > iSegment)
90073>>>                      //*** Move index segment attributes
90073>>>                      Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iSegmentCase
90076>>>                      Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iSegmentDirection
90079>>>                      Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
90082>>>                      Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
90085>>>                      Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
90088>>>                      Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
90091>>>                      Decrement iCurSegment
90092>>>                  End
90093>>>>
90093>>>
90093>>>                  //*** Now set new segment attributes
90093>>>                  Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
90096>>>                  Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
90099>>>                  Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
90102>>>              End
90102>>>>
90102>>>              Set Action_Text of ghoStatusPanel to "Restructures table..."
90103>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
90105>>>            Set Action_Text of ghoStatusPanel to ""
90106>>>        End
90106>>>>
90106>>>
90106>>>        Function_Return (Err = False)
90107>>>    End_Function
90108>>>
90108>>>    Function API_TABLE_UTILITY_FUNCTIONS Returns Boolean
90110>>>        Function_Return False
90111>>>    End_Function
90112>>>
90112>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
90112>>>    // Note that it first removes any driver prefixes in the rootname.
90112>>>    Function UtilTableInfoCompare Boolean bCompareFilelistUppercase tAPITableNameInfoCompare APITableInfoCompare Returns Boolean
90114>>>        Boolean bIsSame
90114>>>        String sRootNameFrom sRootNameTo sLogicalNameFrom sLogicalNameTo sDisplayNameFrom sDisplayNameTo
90114>>>
90114>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameFrom    to sRootNameFrom
90115>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameTo      to sRootNameTo
90116>>>        Move APITableInfoCompare.sLogicalNameFrom               to sLogicalNameFrom
90117>>>        Move APITableInfoCompare.sLogicalNameTo                 to sLogicalNameTo
90118>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameFrom to sDisplayNameFrom
90119>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameTo   to sDisplayNameTo
90120>>>
90120>>>        If (bCompareFilelistUppercase = True) Begin
90122>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(sLogicalNameFrom) = Uppercase(sLogicalNameTo)) to bIsSame
90123>>>        End
90123>>>>
90123>>>        Else Begin
90124>>>            Move (sRootNameFrom = sRootNameTo and sLogicalNameFrom = sLogicalNameTo and sDisplayNameFrom = sDisplayNameTo) to bIsSame
90125>>>        End  
90125>>>>
90125>>>        If (bIsSame = False) Begin
90127>>>            Function_Return False
90128>>>        End 
90128>>>>
90128>>>
90128>>>        Move (APITableInfoCompare.bIsAliasFrom = APITableInfoCompare.bIsAliasTo) to bIsSame
90129>>>        If (bIsSame = False) Begin
90131>>>            Function_Return False
90132>>>        End 
90132>>>>
90132>>>
90132>>>        Move (APITableInfoCompare.bIsSQLFrom = APITableInfoCompare.bIsSQLTo) to bIsSame
90133>>>        If (bIsSame = False) Begin
90135>>>            Function_Return False
90136>>>        End 
90136>>>>
90136>>>
90136>>>        Move (APITableInfoCompare.bIsSystemFileFrom = APITableInfoCompare.bIsSystemFileTo) to bIsSame
90137>>>        If (bIsSame = False) Begin
90139>>>            Function_Return False
90140>>>        End 
90140>>>>
90140>>>
90140>>>        Function_Return bIsSame
90141>>>    End_Function
90142>>>
90142>>>    Function UtilTableCompare tAPITable APITableFrom tAPITable APITableTo Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
90144>>>        Handle hTableFrom hTableTo
90144>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
90144>>>        Boolean bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase
90144>>>        String sRootName sDriverIDFrom sDriverIDTo
90144>>>        tAPIColumnCompare[]   aAPIColumnCompare
90144>>>        tAPIColumnCompare[]   aAPIColumnCompare
90145>>>        tAPIIndexCompare[]    aAPIIndexCompare
90145>>>        tAPIIndexCompare[]    aAPIIndexCompare
90146>>>        tAPIRelationCompare[] aAPIRelationCompare
90146>>>        tAPIRelationCompare[] aAPIRelationCompare
90147>>>
90147>>>        Move (IsSameStruct(APITableFrom, APITableTo)) to bIsSame
90148>>>        If (bIsSame = True) Begin
90150>>>            Function_Return True
90151>>>        End
90151>>>>
90151>>>
90151>>>        Move False to bFilelistError
90152>>>        Move True to bIsSame
90153>>>        Get pbCompareDate_DateTime  to bCompareDate_DateTime
90154>>>        Get pbCompareIndexAscending to bCompareIndexAscending
90155>>>        Get pbCompareIndexUppercase to bCompareIndexUppercase
90156>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
90157>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
90158>>>
90158>>>        Move APITableFrom.ApiTableInfo.sRootName to sRootName
90159>>>        Get _TableNameOnly sRootName             to sRootName
90160>>>        Move sRootName to APITableTo.ApiTableInfo.sRootName
90161>>>
90161>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg is the same).
90161>>>        // bCodeGenerateMode = True = Code Generation mode.
90161>>>        If (bCodeGenerateMode = True) Begin
90163>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
90163>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
90165>>>                Function_Return False
90166>>>            End
90166>>>>
90166>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
90167>>>            If (bIsSame = False) Begin
90169>>>                Send UserError ("Yikes! There is a serious problem with the Filelist.cfg slot number:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * ".\nThis needs to be fixed before you can generate code for this table number.")
90170>>>                Move True to bFilelistError
90171>>>                Function_Return False
90172>>>            End
90172>>>>
90172>>>        End
90172>>>>
90172>>>
90172>>>        If (bCodeGenerateMode = False) Begin
90174>>>            // Then we want to create this table
90174>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
90176>>>                Function_Return False
90177>>>            End
90177>>>>
90177>>>
90177>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
90178>>>            If (bIsSame = False) Begin
90180>>>                Error DFERR_PROGRAM ("'UtilTableCompare function' problem in Filelist.cfg! Table No:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * "No changes was made for this entry.")
90181>>>>
90181>>>                Move True to bFilelistError
90182>>>                Function_Return False
90183>>>            End
90183>>>>
90183>>>        End
90183>>>>
90183>>>
90183>>>        // Check columns:
90183>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
90184>>>        Move APITableFrom.ApiTableInfo.bIsSQL       to bIsSQLFrom
90185>>>        Move APITableFrom.ApiTableInfo.sDriverID    to sDriverIDFrom
90186>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
90187>>>        Move APITableTo.ApiTableInfo.bIsSQL         to bIsSQLTo
90188>>>        Move APITableTo.ApiTableInfo.sDriverID      to sDriverIDTo
90189>>>        Get UtilColumnsStructFill hTableTo          to APITableTo.aApiColumns
90190>>>        Get UtilColumnCombineFromAndToArrays APITableFrom.aApiColumns APITableTo.aApiColumns to aAPIColumnCompare
90191>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
90192>>>        If (bIsSame = False) Begin
90194>>>            Function_Return False
90195>>>        End
90195>>>>
90195>>>
90195>>>        // ...then check indexes:
90195>>>        Get UtilIndexesStructFill hTableFrom to APITableTo.aApiIndexes
90196>>>        Get UtilIndexCombineFromAndToArrays APITableFrom.aApiIndexes APITableTo.aApiIndexes to aAPIIndexCompare
90197>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
90198>>>        If (bIsSame = False) Begin
90200>>>            Function_Return False
90201>>>        End
90201>>>>
90201>>>
90201>>>        // ...and finally relationships:
90201>>>        Get UtilRelationsStructFill hTableFrom to APITableTo.aApiRelations
90202>>>        Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations to aAPIRelationCompare
90203>>>        Move (IsSameArray(APITableFrom.aApiRelations, APITableTo.aApiRelations)) to bIsSame
90204>>>        Get UtilRelationsCompare hTableFrom aAPIRelationCompare to bIsSame
90205>>>
90205>>>        Function_Return (bIsSame = True)
90206>>>    End_Function
90207>>>
90207>>>    // Similar to UtilTableCompare, but takes a tAPITableCompare struct array and a tAPITableBooleans struct as params.
90207>>>    Function UtilTableCompare_Ex tAPITableCompare APITableCompare tAPITableBooleans CompareTableBooleans Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
90209>>>        Handle hTable
90209>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
90209>>>        String sRootName sDriverIDFrom sDriverIDTo
90209>>>
90209>>>        If (APITableCompare.APITableNameInfoCompare.bExistsFrom = False and APITableCompare.APITableNameInfoCompare.bExistsTo = False) Begin
90211>>>            Move True to bFilelistError
90212>>>            Function_Return False
90213>>>        End
90213>>>>
90213>>>
90213>>>        Move APITableCompare.hTable to hTable
90214>>>        Move True  to bIsSame
90215>>>        Move False to bFilelistError
90216>>>
90216>>>        If (APITableCompare.bExistsFrom = True) Begin
90218>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameFrom to sRootName
90219>>>        End
90219>>>>
90219>>>        Else Begin
90220>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameTo   to sRootName
90221>>>        End
90221>>>>
90221>>>        Get _TableNameOnly sRootName                                   to sRootName
90222>>>
90222>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDFrom     to sDriverIDFrom
90223>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDTo       to sDriverIDTo
90224>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLFrom        to bIsSQLFrom
90225>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLTo          to bIsSQLTo
90226>>>
90226>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg are the same).
90226>>>        // bCodeGenerateMode = True = Code Generation mode.
90226>>>        If (bCodeGenerateMode = True) Begin
90228>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
90228>>>            If (APITableCompare.bExistsTo = False) Begin
90230>>>                Function_Return False
90231>>>            End
90231>>>>
90231>>>            Move (Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) = Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameTo)) to bIsSame
90232>>>            If (bIsSame = False) Begin
90234>>>                Send UserError ("Yikes! There is a problem with the Filelist.cfg slot number:" * String(hTable) + ;                    ".\nThe FROM table logical name is:" * String(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) * "\nwhile the TO table logical name is:" * ;                    String(APITableCompare.APITableNameInfoCompare.sLogicalNameTo) * ".\nThis needs to be fixed before you can generate code for this table number.")
90235>>>                Move True to bFilelistError
90236>>>                Function_Return False
90237>>>            End
90237>>>>
90237>>>        End
90237>>>>
90237>>>
90237>>>        If (bCodeGenerateMode = False) Begin
90239>>>            If (APITableCompare.bExistsTo = False) Begin
90241>>>                // Then we might want to create this table
90241>>>                Function_Return False
90242>>>            End
90242>>>>
90242>>>
90242>>>            Move (APITableCompare.APITableNameInfoCompare.bIsAliasFrom = APITableCompare.APITableNameInfoCompare.bIsAliasTo) to bIsSame
90243>>>            If (bIsSame = False) Begin
90245>>>                Function_Return False
90246>>>            End 
90246>>>>
90246>>>    
90246>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSQLFrom = APITableCompare.APITableNameInfoCompare.bIsSQLTo) to bIsSame
90247>>>            If (bIsSame = False) Begin
90249>>>                Function_Return False
90250>>>            End 
90250>>>>
90250>>>    
90250>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSystemFileFrom = APITableCompare.APITableNameInfoCompare.bIsSystemFileTo) to bIsSame
90251>>>            If (bIsSame = False) Begin
90253>>>                Function_Return False
90254>>>            End 
90254>>>>
90254>>>
90254>>>            // Check table names et al.
90254>>>            Get UtilTableInfoCompare CompareTableBooleans.bCompareFilelistUppercase APITableCompare.APITableNameInfoCompare to bIsSame
90255>>>            If (bIsSame = False) Begin
90257>>>                Function_Return False
90258>>>            End
90258>>>>
90258>>>        End
90258>>>>
90258>>>
90258>>>        // Check Columns:
90258>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo APITableCompare.aAPIColumnsCompare CompareTableBooleans.bCompareDate_DateTime to bIsSame
90259>>>        If (bIsSame = False) Begin
90261>>>            Function_Return False
90262>>>        End
90262>>>>
90262>>>
90262>>>        // ...then check Indexes:
90262>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo APITableCompare.aAPIIndexesCompare CompareTableBooleans.bCompareIndexUppercase CompareTableBooleans.bCompareIndexAscending to bIsSame
90263>>>        If (bIsSame = False) Begin
90265>>>            Function_Return False
90266>>>        End
90266>>>>
90266>>>
90266>>>        // ...and finally Relationships:
90266>>>        Get UtilRelationsCompare hTable APITableCompare.aAPIRelationsCompare to bIsSame
90267>>>
90267>>>        Function_Return (bIsSame = True)
90268>>>    End_Function
90269>>>
90269>>>    // To fill a complete Table array structure (tAPITable[]) with data.
90269>>>    // The data + filelist.cfg path, login et al must have been setup properly first.
90269>>>    // Pass a True as first parameter if the ghoStatusPanel is active and progress info should be shown.
90269>>>    // Pass a second True if this is a comparison and the text should either reflect "FROM" or "TO" database.
90269>>>    Function UtilTablesStructArrayFill Boolean bStatusPanel Boolean bCompareUtil Boolean bFromTables Returns tAPITable[]
90271>>>        tAPITableNameInfo ApiTableNameInfo
90271>>>        tAPITableNameInfo ApiTableNameInfo
90271>>>        tAPITable[]     aApiTables aApiTablesEmpty
90271>>>        tAPITable[]     aApiTables aApiTablesEmpty
90273>>>        tAPIColumn[]    aApiColumns
90273>>>        tAPIColumn[]    aApiColumns
90274>>>        tAPIIndex[]     aApiIndexes
90274>>>        tAPIIndex[]     aApiIndexes
90275>>>        tAPIRelation[]  aApiRelations
90275>>>        tAPIRelation[]  aApiRelations
90276>>>        Handle hTable
90276>>>        Integer iCount iPos
90276>>>        Boolean bIsAlias bUserCancel bIsSQL bIsOpen
90276>>>        String sLogicalName sMessageText
90276>>>
90276>>>        Move 0 to hTable
90277>>>        If (bFromTables = True) Begin
90279>>>            Move "Reading 'FROM' Table Structure:" to sMessageText
90280>>>            If (bCompareUtil = True) Begin
90282>>>                Move (sMessageText * "(1 of 3)") to sMessageText
90283>>>            End
90283>>>>
90283>>>        End
90283>>>>
90283>>>        Else Begin
90284>>>            Move "Reading 'TO' Table Structure:" to sMessageText
90285>>>            If (bCompareUtil = True) Begin
90287>>>                Move (sMessageText * "(2 of 3)") to sMessageText
90288>>>            End
90288>>>>
90288>>>        End
90288>>>>
90288>>>        Set Message_Text of ghoStatusPanel to sMessageText
90289>>>
90289>>>        Get UtilFilelistNoOfTables to iCount
90290>>>        Set piMaximum of ghoProgressBar to iCount
90291>>>        Move 0 to iCount
90292>>>
90292>>>        Repeat
90292>>>>
90292>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90295>>>            If (hTable > 0 and hTable <> 50) Begin
90297>>>            
90297>>>                Open hTable
90299>>>                Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90302>>>                If (bIsOpen = False) Begin
90304>>>                    Move True to aApiTablesEmpty[0].bError
90305>>>                    Move hTable to aApiTablesEmpty[0].ApiTableInfo.iTableNumber
90306>>>                    Function_Return aApiTablesEmpty
90307>>>                End
90307>>>>
90307>>>
90307>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName 
90310>>>                Set piPosition of ghoProgressBar to iCount
90311>>>                Send DoAdvance of ghoProgressBarOverall
90312>>>                Set Action_Text of ghoStatusPanel to ("Number:" * String(hTable) * String(sLogicalName))
90313>>>
90313>>>                Get UtilTableStructFill hTable bFromTables to aApiTables[iCount]
90314>>>//                // Table Name Info
90314>>>//                Get UtilTableNameInfoStructFill hTable to ApiTableNameInfo
90314>>>//                
90314>>>//                // Fill columns
90314>>>//                Get UtilColumnsStructFill hTable to aApiColumns
90314>>>//                If (aApiColumns[0].bCancel = True) Begin
90314>>>//                    Move True to aApiTablesEmpty[0].bError
90314>>>//                    Move hTable to aApiTablesEmpty[0].ApiTableInfo.iTableNumber
90314>>>//                    Function_Return aApiTablesEmpty
90314>>>//                End
90314>>>//
90314>>>//                // Fill indexes
90314>>>//                Get UtilIndexesStructFill hTable to aApiIndexes
90314>>>//                If (aApiIndexes[0].bCancel = True) Begin
90314>>>//                    Move True to aApiTablesEmpty[0].bError
90314>>>//                    Move hTable to aApiTablesEmpty[0].ApiTableInfo.iTableNumber
90314>>>//                    Function_Return aApiTablesEmpty
90314>>>//                End
90314>>>//
90314>>>//                // Fill relationships
90314>>>//                Get UtilRelationsStructFill hTable to aApiRelations
90314>>>//                If (aApiRelations[0].bCancel = True) Begin
90314>>>//                    Move True to aApiTablesEmpty[0].bError
90314>>>//                    Move hTable to aApiTablesEmpty[0].ApiTableInfo.iTableNumber
90314>>>//                    Function_Return aApiTablesEmpty
90314>>>//                End
90314>>>
90314>>>                Close hTable DF_PERMANENT
90316>>>
90316>>>//                Move hTable             to aApiTables[iCount].hTable
90316>>>//                Move bFromTables        to aApiTables[iCount].bFromTable
90316>>>//                Move (not(bFromTables)) to aApiTables[iCount].bToTable   
90316>>>//                Move ApiTableNameInfo   to aApiTables[iCount].ApiTableInfo
90316>>>//                Move aApiColumns        to aApiTables[iCount].aApiColumns
90316>>>//                Move aApiIndexes        to aApiTables[iCount].aApiIndexes
90316>>>//                Move aApiRelations      to aApiTables[iCount].aApiRelations
90316>>>                Increment iCount
90317>>>            End
90317>>>>
90317>>>
90317>>>            If (bStatusPanel = True) Begin
90319>>>                Get Check_StatusPanel of ghoStatusPanel to bUserCancel
90320>>>                If (bUserCancel = True) Begin
90322>>>                    Move True to aApiTablesEmpty[0].bCancel
90323>>>                    Function_Return aApiTablesEmpty
90324>>>                End
90324>>>>
90324>>>            End
90324>>>>
90324>>>
90324>>>        Until (hTable = 0)
90326>>>
90326>>>        Function_Return aApiTables
90327>>>    End_Function
90328>>>    
90328>>>    // Returns a 'single' table APITable struct.
90328>>>    Function UtilTableStructFill Handle hTable Boolean bFromTables Returns tAPITable
90330>>>        tAPITableNameInfo ApiTableNameInfo
90330>>>        tAPITableNameInfo ApiTableNameInfo
90330>>>        tAPITable         ApiTable ApiTableEmpty
90330>>>        tAPITable         ApiTable ApiTableEmpty
90330>>>        tAPIColumn[]     aApiColumns
90330>>>        tAPIColumn[]     aApiColumns
90331>>>        tAPIIndex[]      aApiIndexes
90331>>>        tAPIIndex[]      aApiIndexes
90332>>>        tAPIRelation[]   aApiRelations
90332>>>        tAPIRelation[]   aApiRelations
90333>>>        Integer iCount iPos
90333>>>        Boolean bIsAlias bUserCancel bIsSQL bIsOpen
90333>>>        String sLogicalName sRootName sDisplayName sTableName sDriverID sMessageText
90333>>>
90333>>>        Open hTable
90335>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90338>>>        If (bIsOpen = False) Begin
90340>>>            Move True to ApiTableEmpty.bError
90341>>>            Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
90342>>>            Function_Return ApiTableEmpty
90343>>>        End
90343>>>>
90343>>>        
90343>>>        // Fill Table Name Info
90343>>>        Get UtilTableNameInfoStructFill hTable to ApiTableNameInfo
90344>>>                
90344>>>        // Fill columns
90344>>>        Get UtilColumnsStructFill hTable to aApiColumns
90345>>>        If (SizeOfArray(aApiColumns)) Begin
90347>>>            If (aApiColumns[0].bCancel = True) Begin
90349>>>                Move True to ApiTableEmpty.bError
90350>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
90351>>>                Function_Return ApiTableEmpty
90352>>>            End
90352>>>>
90352>>>        End
90352>>>>
90352>>>        
90352>>>        // Fill indexes
90352>>>        Get UtilIndexesStructFill hTable to aApiIndexes
90353>>>        If (SizeOfArray(aApiIndexes)) Begin
90355>>>            If (aApiIndexes[0].bCancel = True) Begin
90357>>>                Move True to ApiTableEmpty.bError
90358>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
90359>>>                Function_Return ApiTableEmpty
90360>>>            End
90360>>>>
90360>>>        End
90360>>>>
90360>>>        
90360>>>
90360>>>        // Fill relationships
90360>>>        Get UtilRelationsStructFill hTable to aApiRelations
90361>>>        If (SizeOfArray(aApiRelations)) Begin
90363>>>            If (aApiRelations[0].bCancel = True) Begin
90365>>>                Move True to ApiTableEmpty.bError
90366>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
90367>>>                Function_Return ApiTableEmpty
90368>>>            End
90368>>>>
90368>>>        End
90368>>>>
90368>>>        
90368>>>        Move hTable             to ApiTable.hTable
90369>>>        Move bFromTables        to ApiTable.bFromTable
90370>>>        Move (not(bFromTables)) to ApiTable.bToTable   
90371>>>
90371>>>        Move ApiTableNameInfo   to ApiTable.ApiTableInfo
90372>>>        Move aApiColumns        to ApiTable.aApiColumns
90373>>>        Move aApiIndexes        to ApiTable.aApiIndexes
90374>>>        Move aApiRelations      to ApiTable.aApiRelations
90375>>>
90375>>>        Function_Return ApiTable
90376>>>    End_Function
90377>>>
90377>>>
90377>>>    Function UtilTableNameInfoStructFill Handle hTable Returns tAPITableNameInfo
90379>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty                                      
90379>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty                                      
90379>>>        Boolean bIsOpen
90379>>>        
90379>>>        Open hTable
90381>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90384>>>        If (bIsOpen = False) Begin
90386>>>            Move True   to APITableNameInfoEmpty.bError
90387>>>            Move hTable to APITableNameInfoEmpty.iTableNumber
90388>>>            Function_Return APITableNameInfoEmpty
90389>>>        End
90389>>>>
90389>>>
90389>>>        Move hTable                                  to APITableNameInfo.iTableNumber
90390>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to APITableNameInfo.sRootName
90393>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to APITableNameInfo.sLogicalName
90396>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to APITableNameInfo.sDisplayName
90399>>>        Get_Attribute DF_FILE_DRIVER       of hTable to APITableNameInfo.sDriverID
90402>>>        
90402>>>        Get UtilTableIsAlias                  hTable to APITableNameInfo.bIsAlias
90403>>>        Get UtilTableIsSQL                    hTable to APITableNameInfo.bIsSQL
90404>>>
90404>>>        Close hTable
90405>>>
90405>>>        Function_Return APITableNameInfo
90406>>>    End_Function 
90407>>>    
90407>>>    Function UtilFindTableArrayItem tAPITable[] ByRef aTableStructure String sLogicalTableName Returns Integer
90409>>>        Integer iSize iCount iTable iItem
90409>>>        tAPITableNameInfo ApiTableNameInfo
90409>>>        tAPITableNameInfo ApiTableNameInfo
90409>>>
90409>>>        Move -1 to iItem
90410>>>        Move (SizeOfArray(aTableStructure)) to iSize
90411>>>        Decrement iSize
90412>>>        for iCount from 0 to iSize
90418>>>>
90418>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
90419>>>            If (Uppercase(ApiTableNameInfo.sLogicalName) = Uppercase(sLogicalTableName)) Begin
90421>>>                Move iCount to iItem
90422>>>                Move iSize  to iCount // We're done.
90423>>>            End
90423>>>>
90423>>>        Loop
90424>>>>
90424>>>
90424>>>        Function_Return iItem
90425>>>    End_Function
90426>>>
90426>>>    Function UtilTableArrayCompare tAPITable APITableFrom tAPITable APITableTo Returns Integer
90428>>>        If (APITableFrom.hTable  > APITableTo.hTable) ;            Function_Return (GT)
90431>>>        If (APITableFrom.hTable  < APITableTo.hTable) ;            Function_Return (LT)
90434>>>
90434>>>        If (APITableFrom.bFromTable = True)  ;            Function_Return (LT)
90437>>>        If (APITableFrom.bFromTable = False) ;            Function_Return (GT)
90440>>>
90440>>>        Function_Return (EQ)
90441>>>    End_Function
90442>>>
90442>>>    Function UtilTableCombineFromAndToArrays tAPITable[] aAPITableFrom tAPITable[] aAPITableTo Returns tAPITableCompare[]
90444>>>        Integer iCount iSize iSizeFrom iSizeTo iItemFrom iItemTo iItem
90444>>>        Handle hTable
90444>>>        tAPITable[] aAPITableFromAndTo aAPITableEmpty
90444>>>        tAPITable[] aAPITableFromAndTo aAPITableEmpty
90446>>>        tAPITable   APITableFrom APITableTo
90446>>>        tAPITable   APITableFrom APITableTo
90446>>>        tAPITableNameInfoCompare APITableNameInfoCompare
90446>>>        tAPITableNameInfoCompare APITableNameInfoCompare
90446>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
90446>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
90447>>>        tAPIColumnCompare[]   aAPIColumnCompare
90447>>>        tAPIColumnCompare[]   aAPIColumnCompare
90448>>>        tAPIIndexCompare[]    aAPIIndexCompare
90448>>>        tAPIIndexCompare[]    aAPIIndexCompare
90449>>>        tAPIRelationCompare[] aAPIRelationCompare
90449>>>        tAPIRelationCompare[] aAPIRelationCompare
90450>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
90450>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
90450>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
90450>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
90453>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
90453>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
90456>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
90456>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
90459>>>
90459>>>        Move (SizeOfArray(aAPITableFrom)) to iSizeFrom
90460>>>        Move (SizeOfArray(aAPITableTo))   to iSizeTo
90461>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
90463>>>            Function_Return aAPITableCompare
90464>>>        End
90464>>>>
90464>>>
90464>>>        Move (AppendArray(aAPITableFrom, aAPITableTo)) to aAPITableFromAndTo
90465>>>        Move (SortArray(aAPITableFromAndTo, Self, RefFunc(UtilTableArrayCompare))) to aAPITableFromAndTo
90466>>>
90466>>>        Move 0 to iItem
90467>>>        Move (SizeOfArray(aAPITableFromAndTo)) to iSize
90468>>>        Decrement iSize
90469>>>        for iCount from 0 to iSize
90475>>>>
90475>>>
90475>>>            Move iCount to iItemFrom
90476>>>            Move iCount to iItemTo
90477>>>            Move aAPITableEmpty to APITableFrom
90478>>>            Move aAPITableEmpty to APITableTo
90479>>>
90479>>>            If (aAPITableFromAndTo[iCount].bFromTable = True) Begin
90481>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
90482>>>            End
90482>>>>
90482>>>            If (aAPITableFromAndTo[iCount].bToTable = True) Begin
90484>>>                Move aAPITableFromAndTo[iCount]     to APITableTo
90485>>>            End
90485>>>>
90485>>>            If (aAPITableFromAndTo[iCount].hTable = aAPITableFromAndTo[iCount + 1].hTable) Begin
90487>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
90488>>>                Move (iCount + 1) to iItemTo
90489>>>                Move aAPITableFromAndTo[iItemTo]    to APITableTo
90490>>>            End
90490>>>>
90490>>>
90490>>>            Move APITableFrom.ApiTableInfo  to ApiTableInfoFrom
90491>>>            Move APITableFrom.aApiColumns   to aApiColumnsFrom
90492>>>            Move APITableFrom.aApiIndexes   to aApiIndexFrom
90493>>>            Move APITableFrom.aApiRelations to aApiRelationFrom
90494>>>
90494>>>            Move APITableTo.ApiTableInfo    to ApiTableInfoTo
90495>>>            Move APITableTo.aApiColumns     to aApiColumnsTo
90496>>>            Move APITableTo.aApiIndexes     to aApiIndexTo
90497>>>            Move APITableTo.aApiRelations   to aApiRelationTo
90498>>>
90498>>>            Move aAPITableFromAndTo[iCount].hTable to hTable
90499>>>
90499>>>            If (hTable > 0) Begin
90501>>>
90501>>>                // Table info:
90501>>>                Get UtilTableINFOCombineFromAndToArrays ApiTableInfoFrom ApiTableInfoTo to APITableNameInfoCompare
90502>>>                Move APITableNameInfoCompare.iTableNumber                               to aAPITableCompare[iItem].hTable
90503>>>                Move APITableNameInfoCompare.bExistsFrom                                to aAPITableCompare[iItem].bExistsFrom
90504>>>                Move APITableNameInfoCompare.bExistsTo                                  to aAPITableCompare[iItem].bExistsTo
90505>>>                Move APITableNameInfoCompare                                            to aAPITableCompare[iItem].APITableNameInfoCompare
90506>>>
90506>>>                // Column info:
90506>>>                Get UtilColumnCombineFromAndToArrays aApiColumnsFrom aApiColumnsTo      to aAPIColumnCompare
90507>>>                Move aAPIColumnCompare                                                  to aAPITableCompare[iItem].aAPIColumnsCompare
90508>>>
90508>>>                // Index info:
90508>>>                Get UtilIndexCombineFromAndToArrays aApiIndexFrom aApiIndexTo           to aAPIIndexCompare
90509>>>                Move aAPIIndexCompare                                                   to aAPITableCompare[iItem].aAPIIndexesCompare
90510>>>
90510>>>                // Relation info:
90510>>>                Get UtilRelationCombineFromAndToArrays aApiRelationFrom aApiRelationTo  to aAPIRelationCompare
90511>>>                Move aAPIRelationCompare                                                to aAPITableCompare[iItem].aAPIRelationsCompare
90512>>>
90512>>>                Move False                                                              to aAPITableCompare[iItem].bShouldChange
90513>>>                Move False                                                              to aAPITableCompare[iItem].bCancel
90514>>>                Move False                                                              to aAPITableCompare[iItem].bError
90515>>>                If (iItemTo > iItemFrom) Begin
90517>>>                    Increment iCount
90518>>>                End
90518>>>>
90518>>>                Increment iItem
90519>>>            End
90519>>>>
90519>>>
90519>>>        Loop
90520>>>>
90520>>>
90520>>>        Function_Return aAPITableCompare
90521>>>    End_Function
90522>>>
90522>>>    Function UtilTableInfoCombineFromAndToArrays tAPITableNameInfo APITableNameInfoFrom tAPITableNameInfo APITableNameInfoTo Returns tAPITableNameInfoCompare
90524>>>        tAPITableNameInfoCompare APITableNameInfoCompare
90524>>>        tAPITableNameInfoCompare APITableNameInfoCompare
90524>>>
90524>>>        // FROM database info:
90524>>>        If (APITableNameInfoFrom.iTableNumber > 0) Begin
90526>>>            Move APITableNameInfoFrom.iTableNumber  to APITableNameInfoCompare.iTableNumber
90527>>>            Move APITableNameInfoFrom.sRootName     to APITableNameInfoCompare.sRootNameFrom
90528>>>            Move APITableNameInfoFrom.sLogicalName  to APITableNameInfoCompare.sLogicalNameFrom
90529>>>            Move APITableNameInfoFrom.sDisplayName  to APITableNameInfoCompare.sDisplayNameFrom
90530>>>            Move APITableNameInfoFrom.sDriverID     to APITableNameInfoCompare.sDriverIDFrom
90531>>>            Move APITableNameInfoFrom.bIsAlias      to APITableNameInfoCompare.bIsAliasFrom
90532>>>            Move APITableNameInfoFrom.bIsSQL        to APITableNameInfoCompare.bIsSQLFrom
90533>>>            Move True                               to APITableNameInfoCompare.bExistsFrom
90534>>>        End
90534>>>>
90534>>>
90534>>>        // TO database info:
90534>>>        If (APITableNameInfoTo.iTableNumber > 0) Begin
90536>>>            Move APITableNameInfoTo.iTableNumber    to APITableNameInfoCompare.iTableNumber
90537>>>            Move APITableNameInfoTo.sRootName       to APITableNameInfoCompare.sRootNameTo
90538>>>            Move APITableNameInfoTo.sLogicalName    to APITableNameInfoCompare.sLogicalNameTo
90539>>>            Move APITableNameInfoTo.sDisplayName    to APITableNameInfoCompare.sDisplayNameTo
90540>>>            Move APITableNameInfoTo.sDriverID       to APITableNameInfoCompare.sDriverIDTo
90541>>>            Move APITableNameInfoTo.bIsAlias        to APITableNameInfoCompare.bIsAliasTo
90542>>>            Move APITableNameInfoTo.bIsSQL          to APITableNameInfoCompare.bIsSQLTo
90543>>>            Move True                               to APITableNameInfoCompare.bExistsTo
90544>>>        End
90544>>>>
90544>>>
90544>>>        Function_Return APITableNameInfoCompare
90545>>>    End_Function
90546>>>
90546>>>    // Note:
90546>>>    // The DF_FILE_TABLE_NAME attribute holds the name of the table at the back end. Depending on the back end, table
90546>>>    // names may be case sensitive, contain spaces or other special characters. This attribute is used to determine a table's
90546>>>    // back end name when using Embedded SQL. Since Embedded SQL works on the back end directly, the back end's name must be used.
90546>>>    // In most cases the back end name will be the same as the table name used in DataFlex.
90546>>>    // To do the opposite; To get the file handle from a table name string use the UtilTableNameToHandle function.
90546>>>    Function UtilTableHandleToString Handle hTable Returns String
90548>>>        String sTableName
90548>>>        Boolean bOpen bExists bOK
90548>>>
90548>>>        Get UtilTableNumberIsInUse hTable to bExists
90549>>>        If (bExists = False) Begin
90551>>>            Function_Return ""
90552>>>        End
90552>>>>
90552>>>
90552>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90553>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
90556>>>        If (bOpen = False) Begin
90558>>>            Get AutoConnectionIDLogin to bOK
90559>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90560>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
90561>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
90562>>>            Open hTable
90564>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90565>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
90566>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
90567>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
90570>>>        End
90570>>>>
90570>>>        If (bOpen = True) Begin
90572>>>            Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90573>>>            Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName
90576>>>            // If blank it is an embedded table:
90576>>>            If (sTableName = "") Begin
90578>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
90581>>>                Move 0 to LastErr
90582>>>                Move False to Err
90583>>>            End
90583>>>>
90583>>>            Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90584>>>        End
90584>>>>
90584>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90585>>>
90585>>>        Function_Return sTableName
90586>>>    End_Function
90587>>>
90587>>>    // Returns the filenumber for the passed Table name from Filelist.cfg.
90587>>>    // Returns 0 if unsuccessful.
90587>>>    // To do the opposite; To get the string value from a table handle string use the UtilTableHandleToString function.
90587>>>    Function UtilTableNameToHandle String sTableName Returns Integer
90589>>>        String sValue sPrefixTableName sDriverID
90589>>>        Handle hTable hRetval
90589>>>
90589>>>        Get psDriverID to sDriverID
90590>>>        If (sDriverID <> DATAFLEX_ID and not(sTableName contains ":")) Begin
90592>>>            Move (sDriverID + ":" + sTableName) to sPrefixTableName
90593>>>        End
90593>>>>
90593>>>        Move 0 to hTable
90594>>>        Move 0 to hRetval
90595>>>        Repeat
90595>>>>
90595>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90598>>>            If (hTable <> 0) Begin
90600>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sValue
90603>>>                If (Uppercase(sValue) = Uppercase(sTableName) or Uppercase(sValue) = Uppercase(sPrefixTableName)) Begin
90605>>>                    Move hTable to hRetval
90606>>>                    Move 0 to hTable
90607>>>                End
90607>>>>
90607>>>            End
90607>>>>
90607>>>        Until (hTable = 0)
90609>>>
90609>>>        Function_Return hRetval
90610>>>    End_Function
90611>>>
90611>>>    // * Dummy function for the Studio's Code Explorer *
90611>>>    Function API_COLUMN_UTILITY_FUNCTIONS Returns Boolean
90613>>>        Function_Return False
90614>>>    End_Function
90615>>>
90615>>>    // Compare multiple columns. (For 'FROM' & 'TO' tables)
90615>>>    Function UtilColumnsCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare[] aAPIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
90617>>>        Boolean bIsSame
90617>>>        Integer iCount iSize iColumn
90617>>>
90617>>>        Move True to bIsSame
90618>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
90619>>>        Set piMaximum of ghoProgressBar  to iSize
90620>>>
90620>>>        Decrement iSize
90621>>>        for iCount from 0 to iSize
90627>>>>
90627>>>            Set piPosition of ghoProgressBar to iCount
90628>>>            Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare[iCount] bCompareDate_DataTime to bIsSame
90629>>>            If (bIsSame = False) Begin
90631>>>                Function_Return False
90632>>>            End
90632>>>>
90632>>>        Loop
90633>>>>
90633>>>
90633>>>        Function_Return (bIsSame = True)
90634>>>    End_Function
90635>>>
90635>>>    // Compares a single column (For 'FROM' & 'TO' tables)
90635>>>    Function UtilColumnCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare APIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
90637>>>        Integer iFromType iToType iDbType
90637>>>        tColumnType ColumnType 
90637>>>        tColumnType ColumnType 
90637>>>        Boolean bIsDateTypeFrom bIsDateTypeTo
90637>>>        
90637>>>        If (APIColumnCompare.bCancelFrom = True or APIColumnCompare.bCancelTo = True) Begin
90639>>>            Function_Return False
90640>>>        End
90640>>>>
90640>>>        If (APIColumnCompare.bExistsFrom = False or APIColumnCompare.bExistsTo = False) Begin
90642>>>            Function_Return False
90643>>>        End
90643>>>>
90643>>>        If (Uppercase(APIColumnCompare.sFieldNameFrom) <> Uppercase(APIColumnCompare.sFieldNameTo)) Begin
90645>>>            Function_Return False
90646>>>        End  
90646>>>>
90646>>>        If (APIColumnCompare.bAllowNULLFrom <> APIColumnCompare.bAllowNULLTo) Begin
90648>>>            Function_Return False
90649>>>        End                      
90649>>>>
90649>>>        If (APIColumnCompare.sDefaultValueFrom <> APIColumnCompare.sDefaultValueTo) Begin
90651>>>            Function_Return False
90652>>>        End                      
90652>>>>
90652>>>
90652>>>        Get piDbType                       to iDbType
90653>>>        Move APIColumnCompare.iTypeFrom    to iFromType
90654>>>        Move APIColumnCompare.iTypeTo      to iToType 
90655>>>
90655>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
90655>>>        // data types between Embedded and SQL.
90655>>>        If (bIsSQLFrom = True and bIsSQLTo = False) Begin
90657>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iFromType APIColumnCompare.iLengthFrom to iFromType
90658>>>        End
90658>>>>
90658>>>        If (bIsSQLFrom = False and bIsSQLTo = True) Begin
90660>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iToType APIColumnCompare.iLengthTo to iToType
90661>>>        End
90661>>>>
90661>>>
90661>>>        Get UtilColumnIsDateType iFromType bIsSQLFrom to bIsDateTypeFrom
90662>>>        Get UtilColumnIsDateType iToType   bIsSQLTo   to bIsDateTypeTo
90663>>>
90663>>>        // Make Date and DateTime comparison?
90663>>>        If (bCompareDate_DataTime = True) Begin
90665>>>            If (iFromType <> iToType) Begin
90667>>>                Function_Return False
90668>>>            End
90668>>>>
90668>>>        End
90668>>>>
90668>>>
90668>>>        // This is when not checking for Date/DateTime differences but all other other field types...
90668>>>        If (bCompareDate_DataTime = False and bIsDateTypeFrom = False) Begin
90670>>>            If (iFromType <> iToType) Begin
90672>>>                Function_Return False
90673>>>            End
90673>>>>
90673>>>        End
90673>>>>
90673>>>
90673>>>        // Only if the field is not a Date type (any of them) we compare length & precision.
90673>>>        If (bIsDateTypeFrom = False) Begin
90675>>>            If (APIColumnCompare.iLengthFrom <> APIColumnCompare.iLengthTo) Begin
90677>>>                Function_Return False
90678>>>            End
90678>>>>
90678>>>            If (APIColumnCompare.iPrecisionFrom <> APIColumnCompare.iPrecisionTo) Begin
90680>>>                Function_Return False
90681>>>            End
90681>>>>
90681>>>        End
90681>>>>
90681>>>
90681>>>        If (APIColumnCompare.iOptionsFrom <> APIColumnCompare.iOptionsTo) Begin
90683>>>            Function_Return False
90684>>>        End
90684>>>>
90684>>>
90684>>>        Function_Return True
90685>>>    End_Function
90686>>>
90686>>>    Function UtilColumnsStructFill Handle hTable Returns tAPIColumn[]
90688>>>        Integer iNumColumns iColumn iCount iOptions iDbType iType iLength iPrecision iCheckFieldNumber
90688>>>        Boolean bIdentityKey bDawSqlDriver bSqlDriver bIsOpen bExists bIsSqlTable bUserCancel bState
90688>>>        tAPIColumn[] APIColumns APIColumnsEmpty
90688>>>        tAPIColumn[] APIColumns APIColumnsEmpty
90690>>>        String sDriverID sFieldName sRootName sLogicalName sValue
90690>>>
90690>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90691>>>        Get piDbType to iDbType
90692>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
90695>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
90698>>>
90698>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90701>>>        If (bIsOpen = False) Begin
90703>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90704>>>            Open hTable
90706>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90707>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90710>>>            If (bIsOpen = False) Begin
90712>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
90713>>>                Move True to APIColumnsEmpty[0].bError
90714>>>                Function_Return APIColumnsEmpty
90715>>>            End
90715>>>>
90715>>>        End
90715>>>>
90715>>>
90715>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
90718>>>        Get IsSQLDriver    sDriverID to bSqlDriver
90719>>>        Get IsDAWSQLDriver sDriverID to bDawSqlDriver
90720>>>
90720>>>        Get UtilTableIsSQLByRootName sRootName to bIsSqlTable
90721>>>        If (bIsSqlTable = True) Begin
90723>>>            Get UtilTableExists hTable to bExists
90724>>>            If (bExists = False) Begin
90726>>>                Move True to APIColumnsEmpty[0].bError
90727>>>                Function_Return APIColumnsEmpty
90728>>>            End
90728>>>>
90728>>>        End
90728>>>>
90728>>>
90728>>>        Move 0 to iCount
90729>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90732>>>        Set piMaximum of ghoProgressBar to iNumColumns
90733>>>
90733>>>        for iColumn from 1 to iNumColumns
90739>>>>
90739>>>            Move 0 to iOptions
90740>>>            Move False to bIdentityKey
90741>>>            Move False to Err
90742>>>            Move 0     to LastErr
90743>>>            Move bIsSqlTable to APIColumns[iCount].bIsSQLType
90744>>>            Set piPosition of ghoProgressBar to iColumn
90745>>>            If (bDawSqlDriver = True) Begin
90747>>>                Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90748>>>                If (bIsSqlTable = True) Begin
90750>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iType
90753>>>                    Move iType                                                to APIColumns[iCount].iType
90754>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE_NAME of hTable iColumn to APIColumns[iCount].sType
90757>>>                    Get_Attribute DF_FIELD_NULL_ALLOWED     of hTable iColumn to APIColumns[iCount].bAllowNULL
90760>>>                    Get_Attribute DF_FIELD_DEFAULT_VALUE    of hTable iColumn to APIColumns[iCount].sDefaultValue 
90763>>>                End
90763>>>>
90763>>>                Else Begin
90764>>>                    Get_Attribute DF_FIELD_TYPE             of hTable iColumn to APIColumns[iCount].iType
90767>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
90768>>>                End
90768>>>>
90768>>>
90768>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
90768>>>                Get_Attribute DF_Field_Number of hTable iColumn to iCheckFieldNumber
90771>>>                Move (iCheckFieldNumber >= 0) to bExists
90772>>>                If (bExists = False) Begin
90774>>>                    Move 0 to APIColumns[iCount].iType
90775>>>                End
90775>>>>
90775>>>                If (bExists = True) Begin
90777>>>                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
90780>>>                End
90780>>>>
90780>>>                Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90781>>>                If (bIdentityKey = True) Begin
90783>>>                    Move C_tAPIColumn_Identity to APIColumns[iCount].iOptions
90784>>>                End
90784>>>>
90784>>>            End
90784>>>>
90784>>>            Else Begin
90785>>>                Move False to Err
90786>>>                Move 0     to LastErr
90787>>>                If (bIsSqlTable = True) Begin
90789>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to APIColumns[iCount].iType
90792>>>                End
90792>>>>
90792>>>                Else Begin
90793>>>                    Get_Attribute DF_FIELD_TYPE        of hTable iColumn to APIColumns[iCount].iType
90796>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
90797>>>                End
90797>>>>
90797>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
90797>>>                Move (LastErr <> DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) to bExists
90798>>>                If (bExists = False) Begin
90800>>>                    Move 0 to APIColumns[iCount].iType
90801>>>                End
90801>>>>
90801>>>            End
90801>>>>
90801>>>
90801>>>            If (bExists = True) Begin
90803>>>                Move iColumn to APIColumns[iCount].iFieldNumber
90804>>>                Get_Attribute DF_FIELD_NAME        of hTable iColumn to APIColumns[iCount].sFieldName
90807>>>                // ToDo: Can't use native_size as it can get way to big and causes "out of memory" problems.
90807>>>//                If (bIsSqlTable = True) Begin
90807>>>//                    Get_Attribute DF_FIELD_NATIVE_SIZE of hTable iColumn to APIColumns[iCount].iLength
90807>>>//                    Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
90807>>>//                End
90807>>>                Get_Attribute DF_FIELD_LENGTH      of hTable iColumn to APIColumns[iCount].iLength
90810>>>                Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
90813>>>
90813>>>                // If the length was zero we might have an Overlap(!) field.
90813>>>                // We then need check the DF_FIELD_TYPE if it really is and reset data for this array item.
90813>>>                If (APIColumns[iCount].iLength = 0) Begin
90815>>>                    Get_Attribute DF_FIELD_TYPE    of hTable iColumn to iType
90818>>>                    If (iType = DF_OVERLAP) Begin
90820>>>                        Move 0 to APIColumns[iCount].iFieldNumber
90821>>>                        Move 0 to APIColumns[iCount].iLength
90822>>>                        Move 0 to APIColumns[iCount].iOptions
90823>>>                        Move 0 to APIColumns[iCount].iPrecision
90824>>>                        Move DF_OVERLAP to APIColumns[iCount].iType
90825>>>                        Move "" to APIColumns[iCount].sFieldName
90826>>>                        Decrement iCount
90827>>>                    End
90827>>>>
90827>>>                End
90827>>>>
90827>>>            End
90827>>>>
90827>>>            Get Check_StatusPanel of ghoStatusPanel to bUserCancel
90828>>>            If (bUserCancel = True) Begin
90830>>>                Move True to APIColumnsEmpty[0].bCancel
90831>>>                Function_Return APIColumnsEmpty
90832>>>            End
90832>>>>
90832>>>            Increment iCount
90833>>>        Loop
90834>>>>
90834>>>
90834>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90835>>>        Function_Return APIColumns
90836>>>    End_Function
90837>>>
90837>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
90837>>>    // The combined data will be sorted on the first struct member: iIndexNumber
90837>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
90837>>>    // have "holes" in the series of index numbers.
90837>>>    Function UtilColumnCombineFromAndToArrays tAPIColumn[] APIColumnFrom tAPIColumn[] APIColumnTo Returns tAPIIndexCompare[]
90839>>>        tAPIColumnCompare[] aAPIColumnCompare
90839>>>        tAPIColumnCompare[] aAPIColumnCompare
90840>>>        tAPIColumnCompare   APIColumnCompare
90840>>>        tAPIColumnCompare   APIColumnCompare
90840>>>        Integer iSizeFrom iSizeTo iSize iCount iItem iColumnFrom iColumnTo
90840>>>
90840>>>        Move (SizeOfArray(APIColumnFrom)) to iSizeFrom
90841>>>        Decrement iSizeFrom
90842>>>        for iCount from 0 to iSizeFrom
90848>>>>
90848>>>            Move APIColumnFrom[iCount].iFieldNumber     to aAPIColumnCompare[iCount].iFieldNumber
90849>>>            Move APIColumnFrom[iCount].sFieldName       to aAPIColumnCompare[iCount].sFieldNameFrom
90850>>>            Move APIColumnFrom[iCount].iType            to aAPIColumnCompare[iCount].iTypeFrom
90851>>>            Move APIColumnFrom[iCount].sType            to aAPIColumnCompare[iCount].sTypeFrom
90852>>>            Move APIColumnFrom[iCount].iLength          to aAPIColumnCompare[iCount].iLengthFrom
90853>>>            Move APIColumnFrom[iCount].iPrecision       to aAPIColumnCompare[iCount].iPrecisionFrom
90854>>>            Move APIColumnFrom[iCount].iOptions         to aAPIColumnCompare[iCount].iOptionsFrom
90855>>>            Move APIColumnFrom[iCount].bIsSQLType       to aAPIColumnCompare[iCount].bIsSQLTypeFrom  
90856>>>            Move APIColumnFrom[iCount].bAllowNULL       to aAPIColumnCompare[iCount].bAllowNULLFrom
90857>>>            Move APIColumnFrom[iCount].sDefaultValue    to aAPIColumnCompare[iCount].sDefaultValueFrom
90858>>>            Move APIColumnFrom[iCount].bShouldChange    to aAPIColumnCompare[iCount].bShouldChangeFrom
90859>>>            Move APIColumnFrom[iCount].bCancel          to aAPIColumnCompare[iCount].bCancelFrom
90860>>>            Move APIColumnFrom[iCount].bError           to aAPIColumnCompare[iCount].bErrorFrom
90861>>>            Move True                                   to aAPIColumnCompare[iCount].bExistsFrom
90862>>>        Loop
90863>>>>
90863>>>
90863>>>        Move (SizeOfArray(APIColumnTo)) to iSizeTo
90864>>>        Decrement iSizeTo
90865>>>        for iCount from 0 to iSizeTo
90871>>>>
90871>>>            Move APIColumnTo[iCount].iFieldNumber       to APIColumnCompare.iFieldNumber
90872>>>            // Search if the field number already exists in the array; else add it.
90872>>>            Move (SearchArray(APIColumnCompare, aAPIColumnCompare)) to iItem
90873>>>            If (iItem = -1) Begin
90875>>>                Move (SizeOfArray(aAPIColumnCompare))   to iItem
90876>>>            End
90876>>>>
90876>>>
90876>>>            Move APIColumnCompare.iFieldNumber          to aAPIColumnCompare[iItem].iFieldNumber
90877>>>            Move APIColumnTo[iCount].iFieldNumber       to aAPIColumnCompare[iItem].iFieldNumberTo
90878>>>            Move APIColumnTo[iCount].sFieldName         to aAPIColumnCompare[iItem].sFieldNameTo
90879>>>            Move APIColumnTo[iCount].iType              to aAPIColumnCompare[iItem].iTypeTo
90880>>>            Move APIColumnTo[iCount].sType              to aAPIColumnCompare[iItem].sTypeTo
90881>>>            Move APIColumnTo[iCount].iLength            to aAPIColumnCompare[iItem].iLengthTo
90882>>>            Move APIColumnTo[iCount].iPrecision         to aAPIColumnCompare[iItem].iPrecisionTo
90883>>>            Move APIColumnTo[iCount].iOptions           to aAPIColumnCompare[iItem].iOptionsTo
90884>>>            Move APIColumnTo[iCount].bIsSQLType         to aAPIColumnCompare[iItem].bIsSQLTypeTo
90885>>>            Move APIColumnTo[iCount].bAllowNULL         to aAPIColumnCompare[iItem].bAllowNULLTo
90886>>>            Move APIColumnTo[iCount].sDefaultValue      to aAPIColumnCompare[iItem].sDefaultValueTo
90887>>>            Move APIColumnTo[iCount].bShouldChange      to aAPIColumnCompare[iItem].bShouldChangeTo
90888>>>            Move APIColumnTo[iCount].bCancel            to aAPIColumnCompare[iItem].bCancelTo
90889>>>            Move APIColumnTo[iCount].bError             to aAPIColumnCompare[iItem].bErrorTo
90890>>>            Move True                                   to aAPIColumnCompare[iItem].bExistsTo
90891>>>        Loop
90892>>>>
90892>>>
90892>>>        Move (SortArray(aAPIColumnCompare)) to aAPIColumnCompare
90893>>>
90893>>>        Function_Return aAPIColumnCompare
90894>>>    End_Function
90895>>>
90895>>>    // Checks if a field name exists in a table definition
90895>>>    // Returns True if it does
90895>>>    // Sample:
90895>>>    //   Get UtilColumnExists MyTable.File_Number "MyColumnName" to iExists
90895>>>    Function UtilColumnExists Handle hTable String sFieldName Returns Boolean
90897>>>        Integer iNumColumns iColumn
90897>>>        String sColumn
90897>>>        Boolean bExists bOK bOpen
90897>>>
90897>>>        Get AutoConnectionIDLogin to bOK
90898>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90899>>>        Open hTable
90901>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90902>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
90905>>>        If (bOpen = False) Begin
90907>>>            Function_Return False
90908>>>        End
90908>>>>
90908>>>
90908>>>        Move False to bExists
90909>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90912>>>        for iColumn from 1 to iNumColumns
90918>>>>
90918>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
90921>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
90923>>>                Move iNumColumns to iColumn
90924>>>                Move True to bExists
90925>>>            End
90925>>>>
90925>>>        Loop
90926>>>>
90926>>>        Close hTable
90927>>>
90927>>>        Function_Return bExists
90928>>>    End_Function
90929>>>
90929>>>    // Returns the field/column number for the passed FieldName as an integer.
90929>>>    Function UtilColumnNameToColumnNumber Handle hTable String sFieldName Returns Integer
90931>>>        Integer iNumColumns iColumn iRetval
90931>>>        String sColumn
90931>>>        Boolean bOK bOpen
90931>>>
90931>>>        Get AutoConnectionIDLogin to bOK
90932>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90933>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90934>>>        Open hTable
90936>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90937>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
90940>>>        If (bOpen = False) Begin
90942>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
90943>>>            Function_Return False
90944>>>        End
90944>>>>
90944>>>
90944>>>        Move 0 to iColumn
90945>>>        Move 0 to iRetval
90946>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90949>>>        for iColumn from 1 to iNumColumns
90955>>>>
90955>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
90958>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
90960>>>                Move iColumn to iRetval
90961>>>                Move iNumColumns to iColumn
90962>>>            End
90962>>>>
90962>>>        Loop
90963>>>>
90963>>>        Close hTable
90964>>>
90964>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90965>>>        Function_Return iRetval
90966>>>    End_Function
90967>>>
90967>>>    // To convert between a data type string name and its integer constant declaration. E.g."VarChar" -> SQL_VarChar
90967>>>    // The reciprocal function is UtilColumnTypeToInteger.
90967>>>    Function UtilColumnTypeToInteger String sDriverID Integer iDbType String sDataType Returns Integer
90969>>>        tColumnType RetvalType
90969>>>        tColumnType RetvalType
90969>>>
90969>>>        Get _UtilColumnType sDriverID iDbType 0 sDataType False to RetvalType
90970>>>        Function_Return RetvalType.iSQLType
90971>>>    End_Function
90972>>>
90972>>>    // To convert between an integer data type constant and its string value. E.g. SQL_VarChar -> "VarChar".
90972>>>    // The reciprocal function is UtilColumnTypeToString.
90972>>>    Function UtilColumnTypeToString String sDriverID Integer iDbType Integer iDataType Returns String
90974>>>        tColumnType RetvalType
90974>>>        tColumnType RetvalType
90974>>>
90974>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90975>>>        Function_Return RetvalType.sSQLType
90976>>>    End_Function
90977>>>
90977>>>    Function UtilColumnTypePrecision String sDriverID Integer iDbType Integer iDataType Returns String
90979>>>        tColumnType RetvalType
90979>>>        tColumnType RetvalType
90979>>>
90979>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90980>>>        Function_Return RetvalType.sPrecision
90981>>>    End_Function
90982>>>
90982>>>    Function UtilColumnTypeFixed String sDriverID Integer iDbType Integer iDataType Returns Boolean
90984>>>        tColumnType RetvalType
90984>>>        tColumnType RetvalType
90984>>>
90984>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90985>>>        Function_Return RetvalType.bCanEditSize
90986>>>    End_Function
90987>>>
90987>>>    Function UtilColumnTypePrecisionSize String sDriverID Integer iDbType Integer iDataType Returns Integer
90989>>>        tColumnType RetvalType
90989>>>        tColumnType RetvalType
90989>>>        String sValue
90989>>>        Integer iRetval iPos
90989>>>
90989>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90990>>>        Move RetvalType.sPrecision to sValue
90991>>>        Move (Pos(".", sValue)) to iPos
90992>>>        If (iPos <> 0) Begin
90994>>>            Move (Left(sValue, (iPos -1))) to iRetval
90995>>>        End
90995>>>>
90995>>>        Else Begin
90996>>>            Move sValue to iRetval
90997>>>        End
90997>>>>
90997>>>        Function_Return iRetval
90998>>>    End_Function
90999>>>
90999>>>    Function UtilColumnTypePrecisionDec String sDriverID Integer iDbType Integer iDataType Returns Integer
91001>>>        tColumnType RetvalType
91001>>>        tColumnType RetvalType
91001>>>        String sValue
91001>>>        Integer iRetval iPos
91001>>>
91001>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91002>>>        Move RetvalType.sPrecision to sValue
91003>>>        Move (Pos(".", sValue)) to iPos
91004>>>        If (iPos = 0) Begin
91006>>>            Function_Return 0
91007>>>        End
91007>>>>
91007>>>        Move (Mid(sValue, 99, (iPos + 1))) to iRetval
91008>>>
91008>>>        Function_Return iRetval
91009>>>    End_Function
91010>>>
91010>>>    // * Dummy function for the Studio's Code Explorer *
91010>>>    Function API_INDEX_UTILITY_FUNCTIONS Returns Boolean
91012>>>        Function_Return False
91013>>>    End_Function
91014>>>
91014>>>    // Compares multiple indexes for a 'FROM' and a 'TO' table.
91014>>>    Function UtilIndexesCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare[] aAPIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
91016>>>        Boolean bIsSame
91016>>>        Integer iCount iSize
91016>>>
91016>>>        Move True to bIsSame
91017>>>        Move (SizeOfArray(aAPIIndexCompare)) to iSize
91018>>>        Decrement iSize
91019>>>        For iCount from 0 to iSize
91025>>>>
91025>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91026>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
91027>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
91028>>>            If (bIsSame = False) Begin
91030>>>                Function_Return False
91031>>>            End
91031>>>>
91031>>>        Loop
91032>>>>
91032>>>
91032>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91033>>>        Function_Return bIsSame
91034>>>    End_Function
91035>>>
91035>>>    // Compares a single index for a 'FROM' and a 'TO' table.
91035>>>    // ToDo: ReDo; remove table handles! And add bIsSQLtablefrom/to
91035>>>    Function UtilIndexCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare APIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
91037>>>        Boolean bIsSame
91037>>>        Integer iSegment
91037>>>
91037>>>        Move (APIIndexCompare.bExistsFrom = APIIndexCompare.bExistsTo) to bIsSame
91038>>>        If (bIsSame = False) Begin
91040>>>            Function_Return False
91041>>>        End
91041>>>>
91041>>>        Move (APIIndexCompare.iPrimaryIndexFrom = APIIndexCompare.iPrimaryIndexTo) to bIsSame
91042>>>        If (bIsSame = False) Begin
91044>>>            Function_Return False
91045>>>        End
91045>>>>
91045>>>
91045>>>        If (bIsSqlTableFrom = True and bIsSqlTableTo = True) Begin
91047>>>            // * We should probably not compare SQL index names?
91047>>>            // Move (Uppercase(aIndexFrom.sSQLIndexName) = Uppercase(aIndexTo.sSQLIndexName)) to bIsSame
91047>>>            // If (bIsSame = False) Begin   DF_INDEX_SERVER_ONLY
91047>>>            //     Function_Return False
91047>>>            // End
91047>>>            Move (APIIndexCompare.bIsSQLPrimaryKeyFrom = APIIndexCompare.bIsSQLPrimaryKeyTo) to bIsSame
91048>>>            If (bIsSame = False) Begin
91050>>>                Function_Return False
91051>>>            End
91051>>>>
91051>>>            Move (APIIndexCompare.bIsSQLClusteredFrom = APIIndexCompare.bIsSQLClusteredTo) to bIsSame
91052>>>            If (bIsSame = False) Begin
91054>>>                Function_Return False
91055>>>            End
91055>>>>
91055>>>            Move (APIIndexCompare.iSQLIndexTypeFrom = APIIndexCompare.iSQLIndexTypeTo) to bIsSame
91056>>>            If (bIsSame = False) Begin
91058>>>                Function_Return False
91059>>>            End
91059>>>>
91059>>>        End
91059>>>>
91059>>>
91059>>>        Get UtilIndexSegmentsCompare APIIndexCompare.IndexSegmentArrayFrom APIIndexCompare.IndexSegmentArrayTo bCompareIndexUppercase bCompareIndexAscending to iSegment
91060>>>        Move (iSegment = -1) to bIsSame
91061>>>
91061>>>        Function_Return (bIsSame = True)
91062>>>    End_Function
91063>>>
91063>>>    // Compares each segment for the passed index.
91063>>>    // Returns -1 if same; else returns the index segment that differs.
91063>>>    Function UtilIndexSegmentsCompare tAPIIndexSegment[] aIndexSegmentFrom tAPIIndexSegment[] aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
91065>>>        Integer iNumSegmentsFrom iNumSegmentsTo iNumSegments iSegment
91065>>>        Boolean bIsSame
91065>>>
91065>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91066>>>        Move (SizeOfArray(aIndexSegmentFrom))      to iNumSegmentsFrom
91067>>>        Move (SizeOfArray(aIndexSegmentTo))        to iNumSegmentsTo
91068>>>        Move (iNumSegmentsFrom max iNumSegmentsTo) to iNumSegments
91069>>>
91069>>>        Decrement iNumSegments
91070>>>        for iSegment from 0 to iNumSegments
91076>>>>
91076>>>            Move False to bIsSame
91077>>>            If (iSegment <= iNumSegmentsFrom and iSegment <= iNumSegmentsTo) Begin
91079>>>                Get UtilIndexSegmentCompare aIndexSegmentFrom[iSegment] aIndexSegmentTo[iSegment] bCompareIndexUppercase bCompareIndexAscending to bIsSame
91080>>>            End
91080>>>>
91080>>>            If (bIsSame = False) Begin
91082>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
91083>>>                Function_Return iSegment
91084>>>            End
91084>>>>
91084>>>        Loop
91085>>>>
91085>>>
91085>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91086>>>        Function_Return -1 // This means bIsSame = True
91087>>>    End_Function
91088>>>
91088>>>    Function UtilIndexSegmentCompare tAPIIndexSegment aIndexSegmentFrom tAPIIndexSegment aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
91090>>>        Boolean bIsSame
91090>>>
91090>>>        Move (aIndexSegmentFrom.iFieldNumber = aIndexSegmentTo.iFieldNumber) to bIsSame
91091>>>        If (bIsSame = False) Begin
91093>>>            Function_Return False
91094>>>        End
91094>>>>
91094>>>        If (bCompareIndexUppercase = True) Begin
91096>>>            Move (aIndexSegmentFrom.bUppercase = aIndexSegmentTo.bUppercase) to bIsSame
91097>>>            If (bIsSame = False) Begin
91099>>>                Function_Return False
91100>>>            End
91100>>>>
91100>>>        End
91100>>>>
91100>>>        If (bCompareIndexAscending = True) Begin
91102>>>            Move (aIndexSegmentFrom.bAscending = aIndexSegmentTo.bAscending) to bIsSame
91103>>>            If (bIsSame = False) Begin
91105>>>                Function_Return False
91106>>>            End
91106>>>>
91106>>>        End
91106>>>>
91106>>>
91106>>>        Function_Return True
91107>>>    End_Function
91108>>>
91108>>>    Function UtilIndexesUpdate Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndex[] aIndexesFrom tAPIIndex[] aIndexesTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
91110>>>        Boolean bIsSame bOK bExists
91110>>>        Integer iSize iSizeFrom iSizeTo iCount iIndexSegment               
91110>>>        tAPIIndexCompare[] aAPIIndexCompare
91110>>>        tAPIIndexCompare[] aAPIIndexCompare
91111>>>
91111>>>        Move (SizeOfArray(aIndexesFrom)) to iSize
91112>>>        If (iSize = 0) Begin
91114>>>            Function_Return True
91115>>>        End                     
91115>>>>
91115>>>        Move (SizeOfArray(aIndexesTo)) to iSizeTo  
91116>>>        Get UtilTableIsSql hTable to bIsSQLTableTo
91117>>>        Get UtilIndexCombineFromAndToArrays aIndexesFrom aIndexesTo to aAPIIndexCompare
91118>>>        
91118>>>        for iCount from 0 to (iSize - 1) 
91124>>>>
91124>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
91125>>>            If (bIsSame = False) Begin
91127>>>                Get APIIndexCreateByFieldNames hTable aIndexesFrom[iCount] aIndexesTo aIndexesFrom[iCount].IndexSegmentArray to bOK
91128>>>            End
91128>>>>
91128>>>        Loop  
91129>>>>
91129>>>        
91129>>>        // We probably should delete other indexes if they exists.
91129>>>        for iCount from (iSize +1) to iSizeTo
91135>>>>
91135>>>            Get ApiIndexRemove hTable iCount to bOK
91136>>>        Loop
91137>>>>
91137>>>
91137>>>        Function_Return bOK
91138>>>    End_Function
91139>>>
91139>>>//    Function UtilIsSameColumnDefinitions Handle hTable tAPIColumn[] aColumns Returns Boolean
91139>>>//        Boolean bEqual bIdentityKey bSqlDriver bDawSqlDriver bIsOpen
91139>>>//        Integer iCount iColumn iSize iOptions iLength iPrecision iType
91139>>>//        String sFieldName sDriverID
91139>>>//
91139>>>//        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
91139>>>//        If (bIsOpen = False) Begin
91139>>>//            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91139>>>//            Open hTable
91139>>>//            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91139>>>//            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
91139>>>//            If (bIsOpen = False) Begin
91139>>>//                Function_Return False
91139>>>//            End
91139>>>//        End
91139>>>//
91139>>>//        Move True to bEqual
91139>>>//        Get psDriverID to sDriverID
91139>>>//        Get IsSQLDriver    sDriverID to bSqlDriver
91139>>>//        Get IsDAWSQLDriver sDriverID to bDawSqlDriver
91139>>>//        Move (SizeOfArray(aColumns)) to iSize
91139>>>//        Decrement iSize
91139>>>//
91139>>>//        For iCount from 0 to iSize
91139>>>//            Move 0 to iOptions
91139>>>//            Move False to bIdentityKey
91139>>>//            Move aColumns[iCount].sFieldName to sFieldName
91139>>>//
91139>>>//            // We need to use the column name - not the column integer as
91139>>>//            // the order does not need to be the same, and the logic should still work.
91139>>>//            Get UtilColumnNameToColumnNumber hTable sFieldName to iColumn
91139>>>//            If (iColumn > 0) Begin
91139>>>//                If (bDawSqlDriver = True) Begin
91139>>>//                    Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
91139>>>//                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iType
91139>>>//                    If (iType <> aColumns[iCount].iSQLType) Begin
91139>>>//                        Move False to bEqual
91139>>>//                    End
91139>>>//                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
91139>>>//                    If (bIdentityKey = True) Begin
91139>>>//                        Move C_tAPIColumn_Identity to iOptions
91139>>>//                    End
91139>>>//                    If (iOptions <> aColumns[iCount].iOptions) Begin
91139>>>//                        Move False to bEqual
91139>>>//                    End
91139>>>//                    Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
91139>>>//                End
91139>>>//                Else Begin
91139>>>//                    Get_Attribute DF_FIELD_TYPE     of hTable iColumn to iType
91139>>>//                    If (iType <> aColumns[iCount].iSQLType) Begin
91139>>>//                        Move False to bEqual
91139>>>//                    End
91139>>>//                End
91139>>>//                Get_Attribute DF_FIELD_LENGTH       of hTable iColumn to iLength
91139>>>//                If (iLength <> aColumns[iCount].iLength) Begin
91139>>>//                    Move False to bEqual
91139>>>//                End
91139>>>//                Get_Attribute DF_FIELD_PRECISION    of hTable iColumn to iPrecision
91139>>>//                If (iPrecision <> aColumns[iCount].iPrecision) Begin
91139>>>//                    Move False to bEqual
91139>>>//                End
91139>>>//                If (bEqual = False) Begin
91139>>>//                    Function_Return False
91139>>>//                End
91139>>>//            End
91139>>>//
91139>>>//            Else Begin
91139>>>//                Function_Return False
91139>>>//            End
91139>>>//        Loop
91139>>>//
91139>>>//        Function_Return bEqual
91139>>>//    End_Function
91139>>>
91139>>>    Function UtilIndexesStructFill Handle hTable Returns tAPIIndex[]
91141>>>        tAPIIndex[] APIIndexes
91141>>>        tAPIIndex[] APIIndexes
91142>>>        Integer iCount iIndex iIndexes iSegment iSegmentCount iNumSegments iColumn
91142>>>        String sDriverID
91142>>>        Boolean bDAWSQLDriver bIsOpen bIsSQLTable bIsSQLPrimaryKey
91142>>>
91142>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91143>>>        Get psDriverID to sDriverID
91144>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
91145>>>        Get UtilTableIsSQL hTable to bIsSQLTable
91146>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
91149>>>        If (bIsOpen = False) Begin
91151>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91152>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91153>>>            Open hTable
91155>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
91156>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91157>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
91160>>>            If (bIsOpen = False) Begin
91162>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
91163>>>                Move True to APIIndexes[0].bError
91164>>>                Function_Return APIIndexes
91165>>>            End
91165>>>>
91165>>>        End
91165>>>>
91165>>>
91165>>>        Move 0 to iCount
91166>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iIndexes
91169>>>        for iIndex from 1 to iIndexes
91175>>>>
91175>>>            // This is a test that the index exists as there might be "holes" aka the index
91175>>>            // numbers doesn't not need to be consequitive:
91175>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
91178>>>            If (iNumSegments > 0) Begin
91180>>>
91180>>>                Move iIndex                                                     to APIIndexes[iCount].iIndexNumber
91181>>>                Get_Attribute DF_FILE_PRIMARY_INDEX of hTable                   to APIIndexes[iCount].iPrimaryIndex
91184>>>                If (bIsSQLTable = True) Begin
91186>>>                    Get_Attribute DF_INDEX_NAME         of hTable iIndex        to APIIndexes[iCount].sSQLIndexName
91189>>>                        Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to APIIndexes[iCount].bIsSQLPrimaryKey
91192>>>                        Get_Attribute DF_INDEX_CLUSTERED of hTable iIndex       to APIIndexes[iCount].bIsSQLClustered
91195>>>                        Get_Attribute DF_INDEX_SQL_TYPE of hTable iIndex        to APIIndexes[iCount].iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
91198>>>                End
91198>>>>
91198>>>
91198>>>                Move 0 to iSegmentCount
91199>>>                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
91202>>>                For iSegment from 1 to iNumSegments
91208>>>>
91208>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iSegment to iColumn
91211>>>                    Move iColumn                                                       to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].iFieldNumber
91212>>>                    Get_Attribute DF_FIELD_NAME              of hTable iColumn         to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].sFieldName
91215>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bUppercase
91218>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bAscending
91221>>>                    Increment iSegmentCount
91222>>>                Loop
91223>>>>
91223>>>                Increment iCount
91224>>>            End
91224>>>>
91224>>>        Loop
91225>>>>
91225>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91226>>>
91226>>>        Function_Return APIIndexes
91227>>>    End_Function
91228>>>
91228>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
91228>>>    // The combined data will be sorted on the first struct member: iIndexNumber
91228>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
91228>>>    // have "holes" in the series of index numbers.
91228>>>    Function UtilIndexCombineFromAndToArrays tAPIIndex[] APIIndexFrom tAPIIndex[] APIIndexTo Returns tAPIIndexCompare[]
91230>>>        tAPIIndexCompare[] aAPIIndexCompare
91230>>>        tAPIIndexCompare[] aAPIIndexCompare
91231>>>        tAPIIndexCompare   APIIndexCompare
91231>>>        tAPIIndexCompare   APIIndexCompare
91231>>>        Integer iSizeFrom iSizeTo iSize iCount iItem iIndexFrom iIndexTo
91231>>>
91231>>>        Move (SizeOfArray(APIIndexFrom)) to iSizeFrom
91232>>>        Move (SizeOfArray(APIIndexTo)) to iSizeTo
91233>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
91235>>>            Function_Return aAPIIndexCompare
91236>>>        End
91236>>>>
91236>>>
91236>>>        Decrement iSizeFrom
91237>>>        for iCount from 0 to iSizeFrom
91243>>>>
91243>>>            Move APIIndexFrom[iCount].iIndexNumber      to aAPIIndexCompare[iCount].iIndexNumber
91244>>>            Move APIIndexFrom[iCount].iPrimaryIndex     to aAPIIndexCompare[iCount].iPrimaryIndexFrom
91245>>>            Move APIIndexFrom[iCount].sSQLIndexName     to aAPIIndexCompare[iCount].sSQLIndexNameFrom
91246>>>            Move APIIndexFrom[iCount].iSQLIndexType     to aAPIIndexCompare[iCount].iSQLIndexTypeFrom
91247>>>            Move APIIndexFrom[iCount].bIsSQLClustered   to aAPIIndexCompare[iCount].bIsSQLClusteredFrom
91248>>>            Move APIIndexFrom[iCount].bIsSQLPrimaryKey  to aAPIIndexCompare[iCount].bIsSQLPrimaryKeyFrom
91249>>>            Move APIIndexFrom[iCount].IndexSegmentArray to aAPIIndexCompare[iCount].IndexSegmentArrayFrom
91250>>>            Move APIIndexFrom[iCount].bShouldChange     to aAPIIndexCompare[iCount].bShouldChangeFrom
91251>>>            Move APIIndexFrom[iCount].bCancel           to aAPIIndexCompare[iCount].bCancelFrom
91252>>>            Move APIIndexFrom[iCount].bError            to aAPIIndexCompare[iCount].bErrorFrom
91253>>>            Move True                                   to aAPIIndexCompare[iCount].bExistsFrom
91254>>>        Loop
91255>>>>
91255>>>
91255>>>        Decrement iSizeTo
91256>>>        for iCount from 0 to iSizeTo
91262>>>>
91262>>>            Move APIIndexTo[iCount].iIndexNumber        to APIIndexCompare.iIndexNumber
91263>>>            // Search if the Index number already exists in the array; else add it.
91263>>>            Move (SearchArray(APIIndexCompare, aAPIIndexCompare)) to iItem
91264>>>            If (iItem = -1) Begin
91266>>>                Move (SizeOfArray(aAPIIndexCompare))    to iItem
91267>>>            End
91267>>>>
91267>>>
91267>>>            Move APIIndexCompare.iIndexNumber           to aAPIIndexCompare[iItem].iIndexNumber
91268>>>            Move APIIndexTo[iCount].iPrimaryIndex       to aAPIIndexCompare[iItem].iPrimaryIndexTo
91269>>>            Move APIIndexTo[iCount].sSQLIndexName       to aAPIIndexCompare[iItem].sSQLIndexNameTo
91270>>>            Move APIIndexTo[iCount].iSQLIndexType       to aAPIIndexCompare[iItem].iSQLIndexTypeTo
91271>>>            Move APIIndexTo[iCount].bIsSQLClustered     to aAPIIndexCompare[iItem].bIsSQLClusteredTo
91272>>>            Move APIIndexTo[iCount].bIsSQLPrimaryKey    to aAPIIndexCompare[iItem].bIsSQLPrimaryKeyTo
91273>>>            Move APIIndexTo[iCount].IndexSegmentArray   to aAPIIndexCompare[iItem].IndexSegmentArrayTo
91274>>>            Move APIIndexTo[iCount].bShouldChange       to aAPIIndexCompare[iItem].bShouldChangeTo
91275>>>            Move APIIndexTo[iCount].bCancel             to aAPIIndexCompare[iItem].bCancelTo
91276>>>            Move APIIndexTo[iCount].bError              to aAPIIndexCompare[iItem].bErrorTo
91277>>>            Move True                                   to aAPIIndexCompare[iItem].bExistsTo
91278>>>        Loop
91279>>>>
91279>>>
91279>>>        Move (SortArray(aAPIIndexCompare)) to aAPIIndexCompare
91280>>>
91280>>>        Function_Return aAPIIndexCompare
91281>>>    End_Function
91282>>>
91282>>>    // This is the same as the UtilIndexCompare function but it takes tAPIIndex structs as params.
91282>>>    Function UtilIndexTypeNumberCompare Handle hTable tAPIIndex aIndexFrom tAPIIndex aIndexTo Returns Boolean
91284>>>        Boolean bIsSame bDAWSQLDriver bIsSqlTable
91284>>>        String sDriverID
91284>>>        Integer iSegment
91284>>>        
91284>>>        Get psDriverID to sDriverID
91285>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
91286>>>        Get IsSQLDriver sDriverID to bIsSqlTable
91287>>>        If (bIsSqlTable = True) Begin
91289>>>            Get UtilTableIsSQL hTable to bIsSqlTable
91290>>>        End
91290>>>>
91290>>>
91290>>>        Move (aIndexFrom.iIndexNumber = aIndexTo.iIndexNumber) to bIsSame
91291>>>        If (bIsSame = False) Begin
91293>>>            Function_Return False
91294>>>        End
91294>>>>
91294>>>
91294>>>        If (bDAWSQLDriver = True and bIsSqlTable = True) Begin
91296>>>            // Don't think we should do this. Or should we?
91296>>>            // Move (aIndexesFrom[iCount].sSQLIndexName = aIndexesTo[iCount].sSQLIndexName) to bIsSame
91296>>>
91296>>>            Move (aIndexFrom.iSQLIndexType = aIndexTo.iSQLIndexType) to bIsSame
91297>>>            If (bIsSame = False) Begin
91299>>>                Function_Return False
91300>>>            End    
91300>>>>
91300>>>            Move (aIndexFrom.iPrimaryIndex = aIndexTo.iPrimaryIndex) to bIsSame
91301>>>            If (bIsSame = False) Begin
91303>>>                Function_Return False
91304>>>            End
91304>>>>
91304>>>            Move (aIndexFrom.bIsSQLPrimaryKey = aIndexTo.bIsSQLPrimaryKey) to bIsSame
91305>>>            If (bIsSame = False) Begin
91307>>>                Function_Return False
91308>>>            End                      
91308>>>>
91308>>>            Move (aIndexFrom.bIsSQLClustered = aIndexTo.bIsSQLClustered) to bIsSame
91309>>>            If (bIsSame = False) Begin
91311>>>                Function_Return False
91312>>>            End                      
91312>>>>
91312>>>        End
91312>>>>
91312>>>        
91312>>>        Function_Return bIsSame
91313>>>    End_Function
91314>>>
91314>>>    // DF_INDEX_SQL_TYPE values
91314>>>    // Pass one of the DF_INDEX_XXX integer constants and the function
91314>>>    // returns a string with the name.
91314>>>    Function UtilIndexTypeToString Integer iIndexType Returns String
91316>>>        String sRetval
91316>>>        Case Begin
91316>>>            Case (iIndexType = DF_INDEX_CLIENT)
91318>>>                Move "DF_INDEX_CLIENT" to sRetval
91319>>>                Case Break
91320>>>            Case (iIndexType = DF_INDEX_SERVER)
91323>>>                Move "DF_INDEX_SERVER" to sRetval
91324>>>                Case Break
91325>>>            Case (iIndexType = DF_INDEX_SERVER_ONLY)
91328>>>                Move "DF_INDEX_SERVER_ONLY" to sRetval
91329>>>                Case Break
91330>>>            Case (iIndexType = DF_INDEX_TEMPORARY)
91333>>>                Move "DF_INDEX_TEMPORARY" to sRetval
91334>>>                Case Break
91335>>>            Case Else
91335>>>                Move "UNKNOWN INDEX TYPE" to sRetval
91336>>>        Case End
91336>>>        Function_Return sRetval
91337>>>    End_Function
91338>>>
91338>>>    // * Dummy function for the Studio's Code Explorer *
91338>>>    Function API_RELATION_UTILITY_FUNCTIONS Returns Boolean
91340>>>        Function_Return False
91341>>>    End_Function
91342>>>
91342>>>    // Compares multiple relationships for a 'FROM' and a 'TO' databases
91342>>>    Function UtilRelationsCompare Handle hTable tAPIRelationCompare[] aAPIRelationCompare Returns Boolean
91344>>>        Boolean bIsSame
91344>>>        Integer iSize iCount
91344>>>
91344>>>        Move True to bIsSame
91345>>>        Move (SizeOfArray(aAPIRelationCompare)) to iSize
91346>>>        Decrement iSize
91347>>>        For iCount from 0 to iSize
91353>>>>
91353>>>            Get UtilRelationCompare hTable aAPIRelationCompare[iCount] to bIsSame
91354>>>            If (bIsSame = False) Begin
91356>>>                Function_Return False
91357>>>            End
91357>>>>
91357>>>        Loop
91358>>>>
91358>>>
91358>>>        Function_Return bIsSame
91359>>>    End_Function
91360>>>
91360>>>    // Compares a single relationship for a 'FROM' and a 'TO' table
91360>>>    Function UtilRelationCompare Handle hTable tAPIRelationCompare APIRelationCompare Returns Boolean
91362>>>        Boolean bIsSame
91362>>>
91362>>>        Move True to bIsSame
91363>>>        If (APIRelationCompare.bExistsFrom <> APIRelationCompare.bExistsTo) Begin
91365>>>            Function_Return False
91366>>>        End
91366>>>>
91366>>>        If (APIRelationCompare.hTableFrom = 0 or APIRelationCompare.hTableTo = 0) Begin
91368>>>            Function_Return False
91369>>>        End
91369>>>>
91369>>>
91369>>>        // We could also compare field names, but I don't think that is necessary...
91369>>>
91369>>>        Function_Return bIsSame
91370>>>    End_Function
91371>>>
91371>>>    // This message is different from ApiTableCreate in that it will not do a function_return if the table
91371>>>    // already exists. 
91371>>>    Function UtilRelationsUpdate Handle hTable tAPIRelation[] aRelationsFrom tAPIRelation[] aRelationsTo Returns Boolean
91373>>>        Boolean bIsSame bOK
91373>>>        Integer iSizeTo iSize iCount iColumn
91373>>>        String sDriverID
91373>>>        
91373>>>        Move True to bOK                                                                                
91374>>>        Move (SizeOfArray(aRelationsTo))   to iSizeTo
91375>>>        If (iSizeTo > 0) Begin
91377>>>            Get AutoConnectionIDLogin to bOK
91378>>>            Move False to Err
91379>>>            Open hTable Mode DF_EXCLUSIVE
91381>>>            Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
91384>>>            Decrement iSizeTo
91385>>>
91385>>>            // We should probably not make any comparison between "FROM" and "TO" database; instead just create all "FROM" relations
91385>>>            // for the "TO" database. But start by deleting all current "TO" relations:
91385>>>            Structure_Start hTable sDriverID            
91386>>>                for iCount from 0 to iSizeTo                                                
91392>>>>
91392>>>                    Move aRelationsTo[iCount].iColumnFrom to iColumn
91393>>>                    Set_Attribute DF_FIELD_RELATED_FILE  of hTable iColumn to 0
91396>>>                    Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn to 0
91399>>>                End
91400>>>>
91400>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
91401>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
91403>>>            Set Action_Text of ghoStatusPanel to ""
91404>>>        End
91404>>>>
91404>>>
91404>>>        Move (SizeOfArray(aRelationsFrom)) to iSize
91405>>>        Decrement iSize
91406>>>        for iCount from 0 to iSize
91412>>>>
91412>>>            Get ApiTableRelate aRelationsFrom[iCount].hTableFrom aRelationsFrom[iCount].hTableTo aRelationsFrom[iCount].iColumnFrom aRelationsFrom[iCount].iColumnTo aRelationsTo to bOK
91413>>>        Loop
91414>>>>
91414>>>
91414>>>        Function_Return bOK
91415>>>    End_Function
91416>>>
91416>>>    Function UtilRelationsStructFill Handle hTable Returns tAPIRelation[]
91418>>>        tAPIRelation[] APIRelations
91418>>>        tAPIRelation[] APIRelations
91419>>>        Integer iColumn iColumnTo iNumColumns iCount
91419>>>        Handle hParent
91419>>>        Boolean bIsOpen
91419>>>
91419>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91420>>>        Move 0 to iCount
91421>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
91424>>>        If (bIsOpen = False) Begin
91426>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91427>>>            Open hTable
91429>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91430>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
91433>>>            If (bIsOpen = False) Begin
91435>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
91436>>>                Move True to APIRelations[0].bError
91437>>>                Function_Return APIRelations
91438>>>            End
91438>>>>
91438>>>        End
91438>>>>
91438>>>
91438>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
91441>>>        For iColumn from 1 to iNumColumns
91447>>>>
91447>>>            Get_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to hParent
91450>>>            If (hParent <> 0) Begin
91452>>>                Open hParent
91454>>>                Move hTable                                             to APIRelations[iCount].hTableFrom
91455>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable            to APIRelations[iCount].sLogicalNameFrom
91458>>>                Move iColumn                                            to APIRelations[iCount].iColumnFrom
91459>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn           to APIRelations[iCount].sFieldNameFrom
91462>>>
91462>>>                Move hParent                                            to APIRelations[iCount].hTableTo
91463>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hParent           to APIRelations[iCount].sLogicalNameTo
91466>>>                Get_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn  to iColumnTo
91469>>>                Move iColumnTo                                          to APIRelations[iCount].iColumnTo
91470>>>                Get_Attribute DF_FIELD_NAME of hParent iColumnTo        to APIRelations[iCount].sFieldNameTo
91473>>>                Move False                                              to APIRelations[iCount].bShouldChange
91474>>>                Move False                                              to APIRelations[iCount].bCancel
91475>>>                Move False                                              to APIRelations[iCount].bError
91476>>>                Close hParent
91477>>>                Increment iCount
91478>>>            End
91478>>>>
91478>>>        Loop
91479>>>>
91479>>>
91479>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91480>>>        Function_Return APIRelations
91481>>>    End_Function
91482>>>
91482>>>    Function UtilRelationArrayCompare tAPIRelation RelationCurrent tAPIRelation RelationNew Returns Integer
91484>>>        If (RelationCurrent.hTableFrom  = RelationNew.hTableFrom and ;            RelationCurrent.iColumnFrom = RelationNew.iColumnFrom and ;            RelationCurrent.hTableTo    = RelationNew.hTableTo and ;            RelationCurrent.iColumnTo   = RelationNew.iColumnTo) Begin
91486>>>            Function_Return (EQ)
91487>>>        End
91487>>>>
91487>>>
91487>>>        Function_Return (GT)
91488>>>    End_Function
91489>>>
91489>>>    Function SearchRelationCompare tAPIRelationCompare RelationCompareCurrent tAPIRelationCompare RelationCompareNew Returns Integer
91491>>>        If (RelationCompareCurrent.hTableFrom  = RelationCompareNew.hTableFrom and ;            RelationCompareCurrent.iColumnFrom = RelationCompareNew.iColumnFrom and ;            RelationCompareCurrent.hTableTo    = RelationCompareNew.hTableTo and ;            RelationCompareCurrent.iColumnTo   = RelationCompareNew.iColumnTo) ;            Function_Return (EQ)
91494>>>
91494>>>        Function_Return (GT)
91495>>>    End_Function
91496>>>
91496>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
91496>>>    // The combined data will be sorted on the first 4 struct members: hTableFrom, iColumnFrom, hTableTo and iColumnTo
91496>>>    Function UtilRelationCombineFromAndToArrays tAPIRelation[] aAPIRelationFrom tAPIRelation[] aAPIRelationTo Returns tAPIIndexCompare[]
91498>>>        tAPIRelation[] aAPIRelationFromAndTo
91498>>>        tAPIRelation[] aAPIRelationFromAndTo
91499>>>        tAPIRelationCompare[] aAPIRelationCompare
91499>>>        tAPIRelationCompare[] aAPIRelationCompare
91500>>>        tAPIRelationCompare   APIRelationCompare
91500>>>        tAPIRelationCompare   APIRelationCompare
91500>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
91500>>>
91500>>>        Move (SizeOfArray(aAPIRelationFrom)) to iSizeFrom
91501>>>        Move (SizeOfArray(aAPIRelationTo))   to iSizeTo
91502>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
91504>>>            Function_Return aAPIRelationCompare
91505>>>        End
91505>>>>
91505>>>
91505>>>        Move (AppendArray(aAPIRelationFrom, aAPIRelationTo)) to aAPIRelationFromAndTo
91506>>>        Move (SortArray(aAPIRelationFromAndTo, Self, RefFunc(UtilRelationArrayCompare))) to aAPIRelationFromAndTo
91507>>>
91507>>>        Decrement iSizeFrom
91508>>>        for iCount from 0 to iSizeFrom
91514>>>>
91514>>>            Move aAPIRelationFrom[iCount].hTableFrom        to aAPIRelationCompare[iCount].hTableFrom
91515>>>            Move aAPIRelationFrom[iCount].iColumnFrom       to aAPIRelationCompare[iCount].iColumnFrom
91516>>>            Move aAPIRelationFrom[iCount].hTableTo          to aAPIRelationCompare[iCount].hTableTo
91517>>>            Move aAPIRelationFrom[iCount].iColumnTo         to aAPIRelationCompare[iCount].iColumnTo
91518>>>            Move aAPIRelationFrom[iCount].sLogicalNameFrom  to aAPIRelationCompare[iCount].sLogicalNameFrom_From
91519>>>            Move aAPIRelationFrom[iCount].sLogicalNameTo    to aAPIRelationCompare[iCount].sLogicalNameTo_From
91520>>>            Move aAPIRelationFrom[iCount].sFieldNameFrom    to aAPIRelationCompare[iCount].sFieldNameFrom_From
91521>>>            Move aAPIRelationFrom[iCount].sFieldNameTo      to aAPIRelationCompare[iCount].sFieldNameTo_From
91522>>>            Move aAPIRelationFrom[iCount].bShouldChange     to aAPIRelationCompare[iCount].bShouldChange_From
91523>>>            Move aAPIRelationFrom[iCount].bCancel           to aAPIRelationCompare[iCount].bCancel_From
91524>>>            Move aAPIRelationFrom[iCount].bError            to aAPIRelationCompare[iCount].bError_From
91525>>>            Move True                                       to aAPIRelationCompare[iCount].bExistsFrom
91526>>>        Loop
91527>>>>
91527>>>
91527>>>        Decrement iSizeTo
91528>>>        for iCount from 0 to iSizeTo
91534>>>>
91534>>>            Move aAPIRelationTo[iCount].hTableFrom          to APIRelationCompare.hTableFrom
91535>>>            Move aAPIRelationTo[iCount].iColumnFrom         to APIRelationCompare.iColumnFrom
91536>>>            Move aAPIRelationTo[iCount].hTableTo            to APIRelationCompare.hTableTo
91537>>>            Move aAPIRelationTo[iCount].iColumnTo           to APIRelationCompare.iColumnTo
91538>>>
91538>>>            // Search if the relation already exists in the array; else add it.
91538>>>            Move (SearchArray(APIRelationCompare, aAPIRelationCompare, Self, RefFunc(SearchRelationCompare))) to iItem
91539>>>            If (iItem = -1) Begin
91541>>>                Move (SizeOfArray(aAPIRelationCompare))     to iItem
91542>>>            End
91542>>>>
91542>>>
91542>>>            Move APIRelationCompare.hTableFrom              to aAPIRelationCompare[iItem].hTableFrom
91543>>>            Move APIRelationCompare.iColumnFrom             to aAPIRelationCompare[iItem].iColumnFrom
91544>>>            Move APIRelationCompare.hTableTo                to aAPIRelationCompare[iItem].hTableTo
91545>>>            Move APIRelationCompare.iColumnTo               to aAPIRelationCompare[iItem].iColumnTo
91546>>>            Move aAPIRelationTo[iCount].sLogicalNameFrom    to aAPIRelationCompare[iItem].sLogicalNameFrom_To
91547>>>            Move aAPIRelationTo[iCount].sLogicalNameTo      to aAPIRelationCompare[iItem].sLogicalNameTo_To
91548>>>            Move aAPIRelationTo[iCount].sFieldNameFrom      to aAPIRelationCompare[iItem].sFieldNameFrom_To
91549>>>            Move aAPIRelationTo[iCount].sFieldNameTo        to aAPIRelationCompare[iItem].sFieldNameTo_To
91550>>>            Move aAPIRelationTo[iCount].bShouldChange       to aAPIRelationCompare[iItem].bShouldChange_To
91551>>>            Move aAPIRelationTo[iCount].bCancel             to aAPIRelationCompare[iItem].bCancel_To
91552>>>            Move aAPIRelationTo[iCount].bError              to aAPIRelationCompare[iItem].bError_To
91553>>>            Move True                                       to aAPIRelationCompare[iItem].bExistsTo
91554>>>        Loop
91555>>>>
91555>>>
91555>>>        Move (SortArray(aAPIRelationCompare, Self, RefFunc(SearchRelationCompare))) to aAPIRelationCompare
91556>>>
91556>>>        Function_Return aAPIRelationCompare
91557>>>    End_Function
91558>>>
91558>>>    // * Dummy function for the Studio's Code Explorer *
91558>>>    Function CODEMAST_UTILITY_FUNCTIONS Returns Boolean
91560>>>        Function_Return False
91561>>>    End_Function
91562>>>
91562>>>    // To add a value to the CodeMast & CodeType tables. Pass; a) bCodeType if it is CodeType that should be updated.
91562>>>    // Else it is CodeMast. b) sTypeValue; either to be added If bCodeType = True, or it will be used to find the correct
91562>>>    // CodeType record. c) sValue1 and d) sValue2 is the CodeType Description & Comment, or CodeMast Type and Code values.
91562>>>    Function UtilCodeMasterAddValue Boolean bCodeType String sTypeValue String sValue2 String sValue3 Returns Boolean
91564>>>        Boolean bFound
91564>>>
91564>>>        Move False to Err
91565>>>        Open CodeMast
91567>>>        Open CodeType
91569>>>
91569>>>        If (bCodeType = True) Begin
91571>>>            Clear CodeType
91572>>>            Move sTypeValue to CODETYPE.Type
91573>>>            Find eq CODETYPE.Type
91574>>>>
91574>>>            Move (Found = True) to bFound
91575>>>            If (bFound = True) Begin
91577>>>                Reread CodeType
91581>>>            End
91581>>>>
91581>>>            If (bFound = False) Begin
91583>>>                Clear CodeType
91584>>>            End
91584>>>>
91584>>>                Move sTypeValue to CODETYPE.Type
91585>>>                Move sValue2    to CODETYPE.Description
91586>>>                Move sValue3    to CODETYPE.Comment
91587>>>                SaveRecord CODETYPE
91588>>>            If (bFound = True) Begin
91590>>>                Unlock
91591>>>>
91591>>>            End
91591>>>>
91591>>>        End
91591>>>>
91591>>>
91591>>>        If (bCodeType = False) Begin
91593>>>            Clear CODEMAST
91594>>>            Move sTypeValue to CODEMAST.Type
91595>>>            Move sValue2    to CODEMAST.Code
91596>>>            Find eq CODEMAST.Code
91597>>>>
91597>>>            Move (Found = True) to bFound
91598>>>            If (bFound = True) Begin
91600>>>                Reread CODEMAST
91604>>>            End
91604>>>>
91604>>>            If (bFound = False) Begin
91606>>>                Clear CODEMAST
91607>>>            End
91607>>>>
91607>>>                Move sTypeValue to CODEMAST.Type
91608>>>                Move sValue2    to CODEMAST.Code
91609>>>                Move sValue3    to CODEMAST.Description
91610>>>                SaveRecord CODEMAST
91611>>>            If (bFound = True) Begin
91613>>>            Unlock
91614>>>>
91614>>>            End
91614>>>>
91614>>>        End
91614>>>>
91614>>>
91614>>>        Close CodeMast
91615>>>        Close CodeType
91616>>>
91616>>>        Function_Return (Err = False)
91617>>>    End_Function
91618>>>
91618>>>    // Changes values in CodeType & CodeMast - From type value To type value. It first changes the type value in
91618>>>    // CodeType and then spins through all CodeMast records to change all related records.
91618>>>    Function UtilCodeMasterChangeValue String sFromValue String sToValue Returns Boolean
91620>>>        Boolean bFound
91620>>>
91620>>>        Move False to Err
91621>>>        Open CodeMast
91623>>>        Open CodeType
91625>>>
91625>>>        Clear CodeType
91626>>>        Move sFromValue to CODETYPE.Type
91627>>>        Find eq CODETYPE.Type
91628>>>>
91628>>>        If (Found = True) Begin
91630>>>            Reread CODETYPE
91634>>>                Move sToValue to CODETYPE.Type
91635>>>                SaveRecord CODETYPE
91636>>>            Unlock
91637>>>>
91637>>>        End
91637>>>>
91637>>>
91637>>>        Clear CODEMAST
91638>>>        Find gt CODEMAST by Recnum
91639>>>>
91639>>>        While (Found = True)
91643>>>            Move (Trim(Uppercase(CODEMAST.Type) = Trim(Uppercase(sFromValue)))) to bFound
91644>>>            If (bFound = True) Begin
91646>>>                Reread CODEMAST
91650>>>                    Move sToValue to CODEMAST.Type
91651>>>                    SaveRecord CODEMAST
91652>>>                Unlock
91653>>>>
91653>>>            End
91653>>>>
91653>>>            Find gt CODEMAST by Recnum
91654>>>>
91654>>>        Loop
91655>>>>
91655>>>
91655>>>        Close CodeMast
91656>>>        Close CodeType
91657>>>
91657>>>        Function_Return (Err = False)
91658>>>    End_Function
91659>>>
91659>>>    // Removes a value from CodeMast. Pass the sTypeValue and the sValue2 to remove.
91659>>>    Function UtilCodeMasterRemoveValue String sTypeValue String sValue2 Returns Boolean
91661>>>        Boolean bFound
91661>>>
91661>>>        Move False to Err
91662>>>        Open CodeMast
91664>>>
91664>>>        Clear CODEMAST
91665>>>        Move sTypeValue to CODEMAST.Type
91666>>>        Move sValue2    to CODEMAST.Code
91667>>>        Find eq CODEMAST.Code
91668>>>>
91668>>>        Move (Found = True) to bFound
91669>>>        If (bFound = True) Begin
91671>>>            Delete CODEMAST
91672>>>        End
91672>>>>
91672>>>
91672>>>        Close CodeMast
91673>>>
91673>>>        Function_Return (Err = False)
91674>>>    End_Function
91675>>>
91675>>>    Function UtilTableCreateCodeMastCodeTypeIntFiles String sDataPath Returns Boolean
91677>>>        Boolean bRecnum bToAnsi
91677>>>        Integer iCh
91677>>>        String sFileName sDriverID sConnectionID sSchemaName sANSI_OEM
91677>>>
91677>>>        If (Trim(sDataPath) = "") Begin
91679>>>            Function_Return False
91680>>>        End
91680>>>>
91680>>>
91680>>>        Move False to Err
91681>>>        Get psDriverID     to sDriverID
91682>>>        Get psConnectionID to sConnectionID
91683>>>        Get psSchema       to sSchemaName
91684>>>        Get True           to bRecnum
91685>>>        Get pbToANSI       to bToAnsi
91686>>>        Move CS_ANSI_Txt to sANSI_OEM
91687>>>        If (bToAnsi = False) Begin
91689>>>            Move CS_OEM_Txt to sANSI_OEM
91690>>>        End
91690>>>>
91690>>>
91690>>>        Get vFolderFormat sDataPath to sDataPath
91691>>>        Move "CodeMast.int"         to sFileName
91692>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
91693>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
91696>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
91699>>>            Writeln channel iCh ("DATABASE_NAME CODEMAST")
91702>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
91705>>>            Writeln channel iCh ("")
91708>>>            Writeln channel iCh ("RECNUM_TABLE YES")
91711>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
91714>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
91717>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
91720>>>            Writeln channel iCh ("")
91723>>>            Writeln channel iCh ("INDEX_NUMBER 1")
91726>>>            Writeln channel iCh ("INDEX_NAME CODEMAST001_PK")
91729>>>            Writeln channel iCh ("")
91732>>>        Send Seq_Close_Channel iCh
91733>>>
91733>>>        Get vFolderFormat sDataPath to sDataPath
91734>>>        Move "CodeType.int"         to sFileName
91735>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
91736>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
91739>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
91742>>>            Writeln channel iCh ("DATABASE_NAME CODETYPE")
91745>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
91748>>>            Writeln channel iCh ("")
91751>>>            Writeln channel iCh ("RECNUM_TABLE YES")
91754>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
91757>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
91760>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
91763>>>            Writeln channel iCh ("")
91766>>>            Writeln channel iCh ("INDEX_NUMBER 0")
91769>>>            Writeln channel iCh ("INDEX_NAME CODETYPE000")
91772>>>            Writeln channel iCh ("")
91775>>>            Writeln channel iCh ("INDEX_NUMBER 1")
91778>>>            Writeln channel iCh ("INDEX_NAME CODETYPE001_PK")
91781>>>            Writeln channel iCh ("")
91784>>>        Send Seq_Close_Channel iCh
91785>>>
91785>>>        Function_Return (Err = False)
91786>>>    End_Function
91787>>>
91787>>>    // * Dummy function for the Studio's Code Explorer *
91787>>>    Function OTHER_UTILITY_FUNCTIONS Returns Boolean
91789>>>        Function_Return False
91790>>>    End_Function
91791>>>
91791>>>    // Check if the file exists in the Data folder,
91791>>>    // else creates it from memory as it has been compiled into the program as a resource:
91791>>>    Function UtilCheckCreateIfFileExists String sFileName String sResourceName Boolean bDataFile Returns Boolean
91793>>>        String sPath sDataPath
91793>>>        Boolean bExists
91793>>>
91793>>>        Get psDataPathFirstPart to sPath
91794>>>        Move (sPath + sFileName) to sFileName
91795>>>        Get vFilePathExists sFileName to bExists
91796>>>
91796>>>        If (bExists = False) Begin
91798>>>            // Read from memory & create file on disk.
91798>>>            Send SqlUtilCreateFileFromMemory sResourceName sFileName
91799>>>            Get vFilePathExists sFileName to bExists
91800>>>        End
91800>>>>
91800>>>        Function_Return bExists
91801>>>    End_Function
91802>>>
91802>>>    Function UtilSqlColumnTypeToDataFlexType String sDriverID Integer iDbType Integer iDataType Integer iLength Returns Integer
91804>>>        tColumnType RetvalType
91804>>>        tColumnType RetvalType
91804>>>        Integer iRetval
91804>>>
91804>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91805>>>        Move RetvalType.iDataFlexType to iRetval
91806>>>        If (RetvalType.iDataFlexType = DF_TEXT) Begin
91808>>>            If (iLength <= 255) Begin
91810>>>                Move DF_ASCII to iRetval
91811>>>            End
91811>>>>
91811>>>        End
91811>>>>
91811>>>        Function_Return iRetval
91812>>>    End_Function       
91813>>>    
91813>>>    Function UtilDataFlexDataTypeToString Integer iDataType Returns String
91815>>>        String sRetval 
91815>>>
91815>>>        Case Begin
91815>>>            Case (iDataType = DF_ASCII)
91817>>>                Move "DF_ASCII" to sRetval
91818>>>                Case Break
91819>>>            Case (iDataType = DF_BCD)
91822>>>                Move "DF_BCD" to sRetval
91823>>>                Case Break
91824>>>            Case (iDataType = DF_BINARY)
91827>>>                Move "DF_BINARY" to sRetval
91828>>>                Case Break
91829>>>            Case (iDataType = DF_DATE)
91832>>>                Move "DF_DATE" to sRetval
91833>>>                Case Break
91834>>>            Case (iDataType = DF_DATETIME)
91837>>>                Move "DF_DATETIME" to sRetval
91838>>>                Case Break
91839>>>            Case (iDataType = DF_TEXT)
91842>>>                Move "DF_TEXT" to sRetval
91843>>>                Case Break
91844>>>            Case Else
91844>>>                Move "" to sRetval
91845>>>        Case End
91845>>>
91845>>>        Function_Return sRetval
91846>>>    End_Function
91847>>>
91847>>>    // The default value used for a datatype as specified in the driver int file.
91847>>>    Function UtilDataTypeDefaultValue String sDriverID Integer iDbType Integer iDataType Returns String
91849>>>        String sRetval sServer
91849>>>        tColumnType RetvalType
91849>>>        tColumnType RetvalType
91849>>>        Integer iDriver iDataFlexType
91849>>>        Handle hDatabase
91849>>>
91849>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91850>>>        Move RetvalType.iDataFlexType to iDataFlexType
91851>>>        Get DriverIndex sDriverID to iDriver
91852>>>        Get psServer to sServer
91853>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
91854>>>        If (hDatabase = 0) Begin
91856>>>            Function_Return ""
91857>>>        End
91857>>>>
91857>>>
91857>>>        Case Begin
91857>>>            Case (iDataFlexType = DF_ASCII)
91859>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_ASCII     of iDriver hDatabase to sRetval
91862>>>                Case Break
91863>>>            Case (iDataFlexType = DF_BCD)
91866>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_NUMERIC   of iDriver hDatabase to sRetval
91869>>>                Case Break
91870>>>            Case (iDataFlexType = DF_BINARY)
91873>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_BINARY    of iDriver hDatabase to sRetval
91876>>>                Case Break
91877>>>            Case (iDataFlexType = DF_DATE)
91880>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE      of iDriver hDatabase to sRetval
91883>>>                Case Break
91884>>>            Case (iDataFlexType = DF_DATETIME)
91887>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME  of iDriver hDatabase to sRetval
91890>>>                Case Break
91891>>>            Case (iDataFlexType = DF_TEXT)
91894>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_TEXT      of iDriver hDatabase to sRetval
91897>>>                Case Break
91898>>>            Case Else
91898>>>                Move "" to sRetval
91899>>>        Case End
91899>>>
91899>>>        Function_Return sRetval
91900>>>    End_Function
91901>>>
91901>>>    Procedure Set Df_Database_Default_Default_Date_DUF String sDateValue
91903>>>        String sDriverID sServer
91903>>>        tColumnType RetvalType
91903>>>        tColumnType RetvalType
91903>>>        Integer iDbType iDriver
91903>>>        Handle hDatabase
91903>>>
91903>>>        Get psDriverID to sDriverID
91904>>>        Get piDbType   to iDbType
91905>>>        Get DriverIndex sDriverID to iDriver
91906>>>        Get psServer to sServer
91907>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
91908>>>        If (hDatabase = 0) Begin
91910>>>            Error DFERR_PROGRAM "Could not change the Default Date Value. Could not get a handle to the database."
91911>>>>
91911>>>            Procedure_Return
91912>>>        End
91912>>>>
91912>>>
91912>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE of iDriver hDatabase to sDateValue
91915>>>
91915>>>    End_Procedure
91916>>>
91916>>>    Procedure Set Df_Database_Default_Default_Datetime_DUF String sDateValue
91918>>>        String sDriverID sServer
91918>>>        tColumnType RetvalType
91918>>>        tColumnType RetvalType
91918>>>        Integer iDbType iDriver
91918>>>        Handle hDatabase
91918>>>
91918>>>        Get psDriverID to sDriverID
91919>>>        Get piDbType   to iDbType
91920>>>        Get DriverIndex sDriverID to iDriver
91921>>>        Get psServer to sServer
91922>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
91923>>>        If (hDatabase = 0) Begin
91925>>>            Error DFERR_PROGRAM "Could not change the Default DateTime Value. Could not get a handle to the database."
91926>>>>
91926>>>            Procedure_Return
91927>>>        End
91927>>>>
91927>>>
91927>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME of iDriver hDatabase to sDateValue
91930>>>
91930>>>    End_Procedure
91931>>>
91931>>>    // Returns a struct array with the default column types for the SQL back-end and how they
91931>>>    // are mapped to the standard DataFlex data types.
91931>>>    // The DataFlex data types are: "ASCII", "BINARY", "DATE", "DATETIME", "NUMERIC" and "TEXT".
91931>>>    Function UtilDefaultSqlTypeMappings String sDriverID Integer iDbType Returns tColumnType[]
91933>>>        tColumnType[] ColumnTypeArray EmptyArray
91933>>>        tColumnType[] ColumnTypeArray EmptyArray
91935>>>        String sDataType
91935>>>        Integer iDataType iDriverID iCount
91935>>>        Boolean bSQLDriver
91935>>>
91935>>>        Move 0 to iCount
91936>>>        Get DriverIndex sDriverID to iDriverID
91937>>>        Get IsSQLDriver sDriverID to bSQLDriver
91938>>>        If (bSQLDriver = False) Begin
91940>>>            Function_Return EmptyArray
91941>>>        End
91941>>>>
91941>>>
91941>>>        // DF_ASCII
91941>>>        If (sDriverID = ODBC_DRV_ID) Begin
91943>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
91946>>>        End
91946>>>>
91946>>>        Else Begin
91947>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
91950>>>        End
91950>>>>
91950>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91951>>>        Move DF_ASCII    to ColumnTypeArray[iCount].iDataFlexType
91952>>>        Move "ASCII"     to ColumnTypeArray[iCount].sDataFlexType
91953>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91954>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91955>>>        Increment iCount
91956>>>
91956>>>        // DF_BINARY
91956>>>        If (sDriverID = ODBC_DRV_ID) Begin
91958>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
91961>>>        End
91961>>>>
91961>>>        Else Begin
91962>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
91965>>>        End
91965>>>>
91965>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91966>>>        Move DF_BINARY   to ColumnTypeArray[iCount].iDataFlexType
91967>>>        Move "Binary"    to ColumnTypeArray[iCount].sDataFlexType
91968>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91969>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91970>>>        Increment iCount
91971>>>
91971>>>        // DF_DATE
91971>>>        If (sDriverID = ODBC_DRV_ID) Begin
91973>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
91976>>>        End
91976>>>>
91976>>>        Else Begin
91977>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
91980>>>        End
91980>>>>
91980>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91981>>>        Move DF_DATE     to ColumnTypeArray[iCount].iDataFlexType
91982>>>        Move "Date"      to ColumnTypeArray[iCount].sDataFlexType
91983>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91984>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91985>>>        Increment iCount
91986>>>
91986>>>        // DF_DATETIME
91986>>>        If (sDriverID = ODBC_DRV_ID) Begin
91988>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
91991>>>        End
91991>>>>
91991>>>        Else Begin
91992>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
91995>>>        End
91995>>>>
91995>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91996>>>        Move DF_DATETIME to ColumnTypeArray[iCount].iDataFlexType
91997>>>        Move "DateTime"  to ColumnTypeArray[iCount].sDataFlexType
91998>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91999>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
92000>>>        Increment iCount
92001>>>
92001>>>        // DF_NUMERIC
92001>>>        // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
92001>>>        // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
92001>>>        // we make them here all "Numeric"...
92001>>>        Case Begin
92001>>>            Case (sDriverID = MSSQLDRV_ID)
92003>>>                Move SQL_NUMERIC to iDataType
92004>>>                Move "numeric"   to sDataType
92005>>>                Case Break
92006>>>            Case (sDriverID = DB2_DRV_ID)
92009>>>                Move SQL_NUMERIC to iDataType
92010>>>                Move "NUMERIC"   to sDataType
92011>>>                Case Break
92012>>>            Case (sDriverID = SQLFLEX)
92015>>>                Move eSQLServer_NUMERIC to iDataType
92016>>>                Move "numeric"   to sDataType
92017>>>                Case Break
92018>>>            Case (sDriverID = MDSMySQL)
92021>>>                Move eMySQL_DECIMAL to iDataType
92022>>>                Move "decimal"   to sDataType
92023>>>                Case Break
92024>>>            Case (sDriverID = ORAFLEX)
92027>>>                Move eOracle_NUMBER to iDataType
92028>>>                Move "NUMBER"   to sDataType
92029>>>                Case Break
92030>>>            Case (sDriverID = MDSPgSQL)
92033>>>                Move ePgSQL_FLOAT4 to iDataType
92034>>>                Move "decimal"   to sDataType
92035>>>                Case Break
92036>>>            Case Else
92036>>>                Move DF_BCD      to iDataType
92037>>>                Move "Numeric"   to sDataType
92038>>>        Case End
92038>>>        Move DF_BCD      to ColumnTypeArray[iCount].iDataFlexType
92039>>>        Move "Numeric"   to ColumnTypeArray[iCount].sDataFlexType
92040>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
92041>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
92042>>>        Increment iCount
92043>>>
92043>>>        // DF_TEXT
92043>>>        If (sDriverID = ODBC_DRV_ID) Begin
92045>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
92048>>>        End
92048>>>>
92048>>>        Else Begin
92049>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
92052>>>        End
92052>>>>
92052>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
92053>>>        Move DF_TEXT     to ColumnTypeArray[iCount].iDataFlexType
92054>>>        Move "Text"      to ColumnTypeArray[iCount].sDataFlexType
92055>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
92056>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
92057>>>
92057>>>        Function_Return ColumnTypeArray
92058>>>    End_Function
92059>>>
92059>>>    Function UtilDFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
92061>>>        tColumnType[] ColumnTypeArray
92061>>>        tColumnType[] ColumnTypeArray
92062>>>        tColumnType   ColumnType
92062>>>        tColumnType   ColumnType
92062>>>        Integer iCount iSize
92062>>>
92062>>>        Get UtilDefaultSqlTypeMappings sDriverID iDbType iType to ColumnTypeArray
92063>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
92064>>>        Decrement iSize
92065>>>
92065>>>        for iCount from 0 to iSize
92071>>>>
92071>>>            If (iType = ColumnTypeArray[iCount].iDataFlexType) Begin
92073>>>                Move ColumnTypeArray[iCount].bCanEditSize   to ColumnType.bCanEditSize
92074>>>                Move ColumnTypeArray[iCount].iDataFlexType  to ColumnType.iDataFlexType
92075>>>                Move ColumnTypeArray[iCount].iSQLType       to ColumnType.iSQLType
92076>>>                Move ColumnTypeArray[iCount].sDataFlexType  to ColumnType.sDataFlexType
92077>>>                Move ColumnTypeArray[iCount].sPrecision     to ColumnType.sPrecision
92078>>>                Move ColumnTypeArray[iCount].sSQLType       to ColumnType.sSQLType
92079>>>                Move iSize to iCount
92080>>>            End
92080>>>>
92080>>>        Loop
92081>>>>
92081>>>
92081>>>        Function_Return ColumnType
92082>>>    End_Function
92083>>>
92083>>>    // Returns a struct with the default column types for the SQL back-end and how they
92083>>>    // are mapped to a DUF data type.
92083>>>    Function UtilDUFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
92085>>>        tColumnType ColumnType
92085>>>        tColumnType ColumnType
92085>>>        String sDataType
92085>>>        Integer iDriverID iCount
92085>>>
92085>>>        Move 0 to iCount
92086>>>        Get DriverIndex sDriverID to iDriverID
92087>>>
92087>>>        Case Begin
92087>>>            // DF_ASCII
92087>>>            Case (iType = DF_ASCII_DUF)
92089>>>                If (sDriverID = ODBC_DRV_ID) Begin
92091>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
92094>>>                End
92094>>>>
92094>>>                Else Begin
92095>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
92098>>>                End
92098>>>>
92098>>>                Move DF_ASCII    to ColumnType.iDataFlexType
92099>>>                Move "ASCII"     to ColumnType.sDataFlexType
92100>>>                Move sDataType   to ColumnType.sSQLType
92101>>>                Move DF_ASCII    to ColumnType.iSQLType
92102>>>                Move False       to ColumnType.bCanEditSize
92103>>>                Case Break
92104>>>
92104>>>            // DF_BINARY
92104>>>            Case (iType = DF_BINARY_DUF)
92107>>>                If (sDriverID = ODBC_DRV_ID) Begin
92109>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
92112>>>                End
92112>>>>
92112>>>                Else Begin
92113>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
92116>>>                End
92116>>>>
92116>>>                Move DF_BINARY   to ColumnType.iDataFlexType
92117>>>                Move "Binary"    to ColumnType.sDataFlexType
92118>>>                Move sDataType   to ColumnType.sSQLType
92119>>>                Move DF_BINARY   to ColumnType.iSQLType
92120>>>                Move False       to ColumnType.bCanEditSize
92121>>>                Case Break
92122>>>
92122>>>            // DF_DATE
92122>>>            Case (iType = DF_DATE_DUF)
92125>>>                If (sDriverID = ODBC_DRV_ID) Begin
92127>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
92130>>>                End
92130>>>>
92130>>>                Else Begin
92131>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
92134>>>                End
92134>>>>
92134>>>                Move DF_DATE     to ColumnType.iDataFlexType
92135>>>                Move "Date"      to ColumnType.sDataFlexType
92136>>>                Move sDataType   to ColumnType.sSQLType
92137>>>                Move DF_DATE     to ColumnType.iSQLType
92138>>>                Move True        to ColumnType.bCanEditSize
92139>>>                Case Break
92140>>>
92140>>>            // DF_DATETIME
92140>>>            Case (iType = DF_DATETIME_DUF)
92143>>>                If (sDriverID = ODBC_DRV_ID) Begin
92145>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
92148>>>                End
92148>>>>
92148>>>                Else Begin
92149>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
92152>>>                End
92152>>>>
92152>>>                Move DF_DATETIME to ColumnType.iDataFlexType
92153>>>                Move "DateTime"  to ColumnType.sDataFlexType
92154>>>                Move sDataType   to ColumnType.sSQLType
92155>>>                Move DF_DATETIME to ColumnType.iSQLType
92156>>>                Move True        to ColumnType.bCanEditSize
92157>>>                Case Break
92158>>>
92158>>>            // DF_NUMERIC
92158>>>            // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
92158>>>            // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
92158>>>            // we make them here all "Numeric"...
92158>>>            // If (sDriverID = ODBC_DRV_ID) Begin
92158>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
92158>>>            // End
92158>>>            // Else Begin
92158>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
92158>>>            // End
92158>>>            // ToDo: How should we find the best "Numeric" data type here?
92158>>>            Case (iType = DF_BCD_DUF)
92161>>>                Move DF_BCD      to ColumnType.iDataFlexType
92162>>>                Move "Numeric"   to ColumnType.sDataFlexType
92163>>>                Move "Numeric"   to ColumnType.sSQLType
92164>>>                Move SQL_NUMERIC to ColumnType.iSQLType
92165>>>                Move False       to ColumnType.bCanEditSize
92166>>>                Case Break
92167>>>
92167>>>            // DF_TEXT
92167>>>            Case (iType = DF_TEXT_DUF)
92170>>>                If (sDriverID = ODBC_DRV_ID) Begin
92172>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
92175>>>                End
92175>>>>
92175>>>                Else Begin
92176>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
92179>>>                End
92179>>>>
92179>>>                Move DF_TEXT     to ColumnType.iDataFlexType
92180>>>                Move "Text"      to ColumnType.sDataFlexType
92181>>>                Move sDataType   to ColumnType.sSQLType
92182>>>                Move DF_TEXT     to ColumnType.iSQLType
92183>>>                Move False       to ColumnType.bCanEditSize
92184>>>                Case Break
92185>>>
92185>>>            Case Else
92185>>>                Move -1999       to ColumnType.iDataFlexType
92186>>>                Move "Undefined" to ColumnType.sDataFlexType
92187>>>                Move "Undefined" to ColumnType.sSQLType
92188>>>                Move -1999       to ColumnType.iSQLType
92189>>>                Move True        to ColumnType.bCanEditSize
92190>>>
92190>>>        Case End
92190>>>
92190>>>        Function_Return ColumnType
92191>>>    End_Function
92192>>>
92192>>>    Function UtilDeleteCacheFile String sTableName Returns Boolean
92194>>>        String sDataPath sDriverID
92194>>>        Boolean bMertechDriver bOK
92194>>>        Integer iPos
92194>>>
92194>>>        If (sTableName contains ".") Begin
92196>>>            Move (Pos(".", sTableName)) to iPos
92197>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
92198>>>        End
92198>>>>
92198>>>
92198>>>        Get psDriverID to sDriverID
92199>>>        Get psDataPathFirstPart to sDataPath
92200>>>        Get IsMertechDriver sDriverID to bMertechDriver
92201>>>        // First delete the cache file:
92201>>>        If (bMertechDriver = False) Begin
92203>>>            Get vDeleteFile (sDataPath + sTableName + ".cch") to bOK
92204>>>        End
92204>>>>
92204>>>        Else Begin
92205>>>            Get _MertechDeleteTDFile sTableName to bOK
92206>>>        End
92206>>>>
92206>>>
92206>>>        Function_Return bOK
92207>>>    End_Function
92208>>>
92208>>>    // Changes source code files.
92208>>>    // Pass a file name with full path and a value to search for, together with the value
92208>>>    // to change to. Can e.g. be used for changing all .int files from using a fixed server name,
92208>>>    // to use a Connection ID.
92208>>>    // Sample: Get UtilChangeSourceCodeLine "C:\DataFlex 18.2 Examples\Order Entry\Data\Order.int" "SERVER_NAME SERVER=(local)\SQLEXPRESS1" "SERVER_NAME DFCONNID=ChinookDb"
92208>>>    // Pass "True" for the bShowResult if you want to see the result while it works. Showln will then be used for output
92208>>>    // Returns True if no errors occured.
92208>>>    Function UtilChangeSourceCodeLine String sFileName String sChangeFrom String sChangeTo Boolean bShowResult Returns Boolean
92210>>>        Integer iCh iRow iItems iCount
92210>>>        String sValue sRow
92210>>>        String[] sFileArray
92211>>>        Boolean bExists bIsActive
92211>>>
92211>>>        Move False to Err
92212>>>        Move 0 to iRow
92213>>>
92213>>>        If (ghoStatusPanel <> 0) Begin
92215>>>            Get Active_state of ghoStatusPanel to bIsActive
92216>>>        End
92216>>>>
92216>>>
92216>>>        Get vFilePathExists sFileName to bExists
92217>>>        If (bExists = False) Begin
92219>>>            If (bShowResult = True) Begin
92221>>>                If (bIsActive = True) Begin
92223>>>                    Send Update_StatusPanel of ghoStatusPanel ("File does not exist:" * String(sFileName))
92224>>>                End
92224>>>>
92224>>>                Else Begin
92225>>>                    Showln "File does not exist: " sFileName
92228>>>                End
92228>>>>
92228>>>            End
92228>>>>
92228>>>            Function_Return False
92229>>>        End
92229>>>>
92229>>>
92229>>>        Get Seq_Open_Input_Channel sFileName to iCh
92230>>>        If (iCh < 1) Begin
92232>>>            Function_Return False
92233>>>        End
92233>>>>
92233>>>
92233>>>        If (bShowResult = True) Begin
92235>>>            If (ghoStatusPanel <> 0) Begin
92237>>>                Get Active_state of ghoStatusPanel to bIsActive
92238>>>                If (bIsActive = True) Begin
92240>>>                    Set Message_Text of ghoStatusPanel to sFileName
92241>>>                    Send Update_StatusPanel of ghoStatusPanel ("sChangeFrom =" * String(sChangeFrom) * "sChangeTo =" * String(sChangeTo))
92242>>>                    Send DoAdvance of ghoProgressBar
92243>>>                End
92243>>>>
92243>>>            End
92243>>>>
92243>>>            Else Begin
92244>>>                Showln ""
92246>>>                Showln "sFileName = " sFileName
92249>>>                Showln "sChangeFrom = " sChangeFrom " sChangeTo = " sChangeTo
92254>>>            End
92254>>>>
92254>>>        End
92254>>>>
92254>>>
92254>>>        While (not(SeqEof))
92258>>>            Readln channel iCh sRow
92260>>>            If (Uppercase(sRow) contains Uppercase(sChangeFrom)) Begin
92262>>>//                If (bShowResult = True) Begin
92262>>>//                    If (bIsActive = True) Begin
92262>>>//                        Send Update_StatusPanel of ghoStatusPanel ("Changed from:" * String(sRow) * "to:" * String(sChangeTo))
92262>>>//                    End
92262>>>//                    Else Begin
92262>>>//                        Showln "Changed from: " sRow " to: " sChangeTo
92262>>>//                    End
92262>>>//                End
92262>>>                // Change the whole line to the new connection id:
92262>>>                Move sChangeTo to sRow
92263>>>                // Move (Replaces(sChangeFrom, sRow, sChangeTo)) to sValue
92263>>>            End
92263>>>>
92263>>>            Move sRow to sFileArray[iRow]
92264>>>            Increment iRow
92265>>>        End
92266>>>>
92266>>>        Send Seq_Close_Channel iCh
92267>>>
92267>>>        Sleep 1 // Wait for Windows to close the file
92268>>>
92268>>>        Get Seq_Open_Output_Channel sFileName to iCh
92269>>>        If (iCh < 1) Begin
92271>>>            Function_Return False
92272>>>        End
92272>>>>
92272>>>        Move (SizeOfArray(sFileArray)) to iItems
92273>>>        Decrement iItems
92274>>>
92274>>>        For iCount from 0 to iItems
92280>>>>
92280>>>            Move sFileArray[iCount] to sValue
92281>>>            Writeln channel iCh sValue
92284>>>        Loop
92285>>>>
92285>>>        Send Seq_Close_Channel iCh
92286>>>
92286>>>        Function_Return (Err = False)
92287>>>    End_Function
92288>>>
92288>>>    // This might be needed by API-methods when a connection id is to be used and
92288>>>    // the connection ID hasn't been established with the driver's CLI interface.
92288>>>    // NOTE: Only applicable for DAW drivers, as Mertech drivers doesn't use connection ID's.
92288>>>    Function UtilCreateConnectionID String sConnectionID Returns Boolean
92290>>>        String sConnectionString sDriverID
92290>>>        Boolean bOK bSilent bDawDriver
92290>>>        Handle hoCLI
92290>>>
92290>>>        Move False to bOK
92291>>>        Get psDriverID to sDriverID
92292>>>        Get IsDAWSQLDriver sDriverID to bDawDriver
92293>>>        If (bDawDriver = False) Begin
92295>>>            Error DFERR_PROGRAM "The UtilCreateConnectionID function is only available for DAW drivers. (Not Mertech)."
92296>>>>
92296>>>            Function_Return False
92297>>>        End
92297>>>>
92297>>>
92297>>>        Get psConnectionString to sConnectionString
92298>>>        Get pbSilentLogin      to bSilent
92299>>>
92299>>>        Get phoCLIHandler to hoCLI
92300>>>        If (hoCLI <> 0) Begin
92302>>>            Set psDriverID of hoCLI to sDriverID
92303>>>            Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to bOK
92304>>>        End
92304>>>>
92304>>>
92304>>>        Function_Return (bOK = False)
92305>>>    End_Function
92306>>>
92306>>>    // This message creates an error log in the "Home" folder named "SQLErrorLog.txt",
92306>>>    // and opens it in "notepad.exe".
92306>>>    // Note: This is _not_ used by the cDbUpdateHandler & cDbUpdateVersion classes!
92306>>>    //       Instead the cDbUpdateLogFile's WriteErrorLog & ShowErrorLog are used.
92306>>>    Procedure UtilShowErrorList
92308>>>        tSqlErrorArray aSqlErrorArray
92308>>>        tSqlErrorArray aSqlErrorArray
92308>>>        Integer iRows iCount iCh iErrorNum
92308>>>        String sPath sFileName sErrorTxt sStatement
92308>>>
92308>>>        Get psHome of (phoWorkspace(ghoApplication)) to sPath
92309>>>        Get vFolderFormat sPath to sPath
92310>>>        Move "SQLErrorLog.txt"  to sFileName
92311>>>        Get Seq_Open_Output_Channel (sPath + sFileName) to iCh
92312>>>            Get paSqlErrorArray to aSqlErrorArray
92313>>>            Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iRows
92314>>>            If (iRows > 0) Begin
92316>>>                Decrement iRows
92317>>>                for iCount from 0 to iRows
92323>>>>
92323>>>                    Move aSqlErrorArray.sSqlErrorArray[iCount]      to sErrorTxt
92324>>>                    Move aSqlErrorArray.sSqlStatementArray[iCount]  to sStatement
92325>>>                    Move aSqlErrorArray.iSqlErrorArray[iCount]      to iErrorNum
92326>>>                    Writeln channel iCh "Error No: " iErrorNum " Error Text: " sErrorTxt
92332>>>                    Writeln channel iCh "SQL Statement: " sStatement
92336>>>                Loop
92337>>>>
92337>>>            End
92337>>>>
92337>>>        Send Seq_Close_Channel iCh
92338>>>
92338>>>        If (iRows > 0) Begin
92340>>>            Runprogram Shell Background (sPath + sFileName)
92341>>>        End
92341>>>>
92341>>>    End_Procedure
92342>>>
92342>>>    // For this to be returning a True value, the table number needs to be in the Filelist.cfg,
92342>>>    // and the table needs to exist as an SQL table.
92342>>>    Function UtilTableIsSql Handle hTable Returns Boolean
92344>>>        String sRootName sDriverID
92344>>>        Boolean bIsSQL
92344>>>
92344>>>        Move False to bIsSQL
92345>>>        If (hTable > 0) Begin
92347>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
92350>>>            Move (sRootName contains ":") to bIsSQL
92351>>>            If (bIsSQL = True) Begin
92353>>>                Get psDriverID to sDriverID
92354>>>                Get _TableNameOnly sRootName to sRootName
92355>>>                Get SqlUtilCheckIfTableNameExists sRootName sDriverID to bIsSQL
92356>>>            End
92356>>>>
92356>>>        End
92356>>>>
92356>>>
92356>>>        Function_Return bIsSQL
92357>>>    End_Function
92358>>>
92358>>>    Function UtilTableIsSqlByRootName String sRootName Returns Boolean
92360>>>        Boolean bIsSQL
92360>>>        Move (sRootName contains ":") to bIsSQL
92361>>>        Function_Return bIsSQL
92362>>>    End_Function
92363>>>
92363>>>
92363>>>    // Returns True if the passed hTable (filelist slot number) is an Alias table.
92363>>>    // An Alias file/table is a filelist number that share the same Physical filename
92363>>>    // but the Logical name is different.
92363>>>    // Note: If the table cannot be opened; the table is not considered to be an Alias.
92363>>>//    Function UtilTableIsAlias Handle hTable Returns Boolean
92363>>>//        String sPhysicalName sPhysicalNameCompare
92363>>>//        Boolean bWasOpen bOpened bOK
92363>>>//        Integer iCount
92363>>>//
92363>>>//        Move 0 to iCount
92363>>>//        Get_Attribute DF_FILE_OPENED of hTable to bWasOpen
92363>>>//        If (bWasOpen = False) Begin
92363>>>//            Open hTable
92363>>>//            Get_Attribute DF_FILE_OPENED of hTable to bOpened
92363>>>//            If (bOpened = False) Begin
92363>>>//                Function_Return False
92363>>>//            End
92363>>>//        End
92363>>>//
92363>>>//        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName
92363>>>//        Get _TableNameOnly sPhysicalName to sPhysicalName
92363>>>//        If (bWasOpen = False and bOpened = True) Begin
92363>>>//            Close hTable
92363>>>//        End
92363>>>//
92363>>>//        Move 0 to hTable
92363>>>//        Repeat
92363>>>//            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92363>>>//            If (hTable > 0 and hTable <> 50) Begin
92363>>>//                Open hTable
92363>>>//                Get_Attribute DF_FILE_OPENED of hTable to bOpened
92363>>>//                If (bOpened = True) Begin
92363>>>//                    Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalNameCompare
92363>>>//                    Close hTable
92363>>>//                    Get _TableNameOnly sPhysicalNameCompare to sPhysicalNameCompare
92363>>>//                    If (Uppercase(sPhysicalName) = Uppercase(sPhysicalNameCompare)) Begin
92363>>>//                        Increment iCount
92363>>>//                    End
92363>>>//                End
92363>>>//            End
92363>>>//        Until (hTable = 0)
92363>>>//
92363>>>//        If (iCount > 1) Begin
92363>>>//            Function_Return True
92363>>>//        End
92363>>>//
92363>>>//        Function_Return False
92363>>>//    End_Function
92363>>>
92363>>>    Function UtilTableIsAlias Handle hTable Returns Boolean
92365>>>        String sPhysicalName sPhysicalNameCompare
92365>>>        Integer iCount iMaster iAlias iInTable
92365>>>
92365>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sPhysicalName
92368>>>        Get _TableNameOnly sPhysicalName to sPhysicalName
92369>>>        Move hTable to iInTable
92370>>>        Move 0 to hTable
92371>>>        Move 0 to iCount
92372>>>
92372>>>        Repeat
92372>>>>
92372>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92375>>>            If (hTable > 0 and hTable <> 50) Begin
92377>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sPhysicalNameCompare
92380>>>                Get _TableNameOnly sPhysicalNameCompare to sPhysicalNameCompare
92381>>>                If (Uppercase(sPhysicalName) = Uppercase(sPhysicalNameCompare)) Begin
92383>>>
92383>>>                    If (iCount = 0) Begin
92385>>>                        Move hTable to iMaster
92386>>>                    End
92386>>>>
92386>>>                    If (iCount > 0) Begin
92388>>>                        Move hTable to iAlias
92389>>>                    End
92389>>>>
92389>>>                    Increment iCount
92390>>>                End
92390>>>>
92390>>>            End
92390>>>>
92390>>>        Until (hTable = 0)
92392>>>
92392>>>        If (iCount > 1) Begin
92394>>>            Function_Return (iInTable >= iAlias and iAlias > iMaster)
92395>>>        End
92395>>>>
92395>>>
92395>>>        Function_Return False
92396>>>    End_Function
92397>>>
92397>>>//    Function UtilTableIsAliasFdFile Handle hTable Returns Boolean
92397>>>//        String sDDSrcPath sDataPath sLogicalName
92397>>>//        Boolean bOK bExists
92397>>>//
92397>>>//        Get psDataPath  of (phoWorkspace(ghoApplication)) to sDataPath
92397>>>//        If (Right(sDataPath, 1) = "\") Begin
92397>>>//            Move (Left(sDataPath, (Length(sDataPath) -1))) to sDataPath
92397>>>//        End
92397>>>//        Move (StringFromRightOfChar(sDataPath, "\")) to sDDSrcPath
92397>>>//        Move (Replace(sDDSrcPath, sDataPath, ""))    to sDDSrcPath
92397>>>//        Move (sDDSrcPath + "DDSrc")                  to sDDSrcPath
92397>>>//        Get vFolderFormat sDDSrcPath                 to sDDSrcPath
92397>>>//
92397>>>//        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
92397>>>//        Get vFilePathExists (sDDSrcPath + sLogicalName + ".fd") to bExists
92397>>>//
92397>>>//        Function_Return bExists
92397>>>//    End_Function
92397>>>
92397>>>    // To Open a table with any driver.
92397>>>    // Note: If the driver is <> DATAFLEX_ID  - login credentials are used; it is then assumed
92397>>>    //       that the proper login properties has been setup properly with the cSQLConnections object.
92397>>>    //
92397>>>    // If the open command fails the Err flag will be reset to false, at the end of the function!
92397>>>    // The found flag is still used to indicate if the open was successful or not. The function
92397>>>    // returns a True if successful (table could be opened).
92397>>>    //
92397>>>    // Using the "Open As" syntax with drivers means that we don't need to rely on .int file settings.
92397>>>    // This is good because with DFConnectionID's those credentials doesn't need to be available in
92397>>>    // the .int file (and probably aren't). As long as the login properties of this object have been
92397>>>    // set properly we can open the table.
92397>>>    //
92397>>>    // DAW Driver Syntax:
92397>>>    //  <CKId>:<Schema>#<Table>@<ConnectString>|<Filename>.int
92397>>>    //  Now the @<ConnectString> can be followed by a pipe character '|' followed by the name of the INT file.
92397>>>    //  Doing so, the driver will apply the information from the .INT file to the passed direct Open String.
92397>>>    //  Note that when an INT file has been passed, it will skip the keyword DRIVER_NAME, SERVER_NAME,
92397>>>    //  DATABASE_NAME and SCHEMA_NAME from the INT file because those are supposed to be supplied in the String already.
92397>>>    //  Open mode; iMode = DF_SHARE or DF_EXCLUSIVE.
92397>>>    //
92397>>>    // DAW Driver Sample:
92397>>>    //   Open "MSSQLDRV:dbo#MyFile@SERVER=(local)\SQLEXPRESS;Trusted_Connection=yes;DATABASE=OrderEntry|options|intfile=MyFile.int"
92397>>>    //
92397>>>    // Mertech Driver Samples:
92397>>>    //   SQLFlex:   Open "sql_drv:\\<serverName>\<database>*<owner>*<tableName>=<numberFieds>" as table
92397>>>    //   MySQLFlex: Open "mdsmysql:\\<serverName>\<database>*<tableName>=<numberFieds>" as table
92397>>>    //   PgFlex:    Open "mdspgsql:\\<serverName>\<database>*<schema>*<tableName>=<numberFieds>" as table
92397>>>    //   ORAFlex:   Open "ora_drv:\\<serverName>\<owner>*<tableName>=<numberFieds>" as table
92397>>>    Function UtilTableOpen Integer hTable String sTableName Integer iMode Returns Boolean
92399>>>        String sDriverID sConnection sSchema sExt sTableNameShort sTableNameOrg
92399>>>        Boolean bOpen bMertechDriver bOK
92399>>>        tSQLConnection SQLConnection
92399>>>        tSQLConnection SQLConnection
92399>>>
92399>>>        Move sTableName to sTableNameOrg
92400>>>        If (hTable > 0) Begin
92402>>>            Send Ignore_Error of Error_Object_Id 20529
92403>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
92404>>>            Send Ignore_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
92405>>>            Open hTable
92407>>>            Send Trap_Error of Error_Object_Id 20529
92408>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
92409>>>            Send Trap_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
92410>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
92413>>>            If (bOpen = True) Begin
92415>>>                Function_Return True
92416>>>            End
92416>>>>
92416>>>        End
92416>>>>
92416>>>
92416>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
92417>>>        Move SQLConnection.sDriverID to sDriverID
92418>>>        Get IsMertechDriver sDriverID to bMertechDriver
92419>>>        Move SQLConnection.sConnectionString to sConnection
92420>>>        Move SQLConnection.sSchema to sSchema
92421>>>        If (sSchema = "") Begin
92423>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
92424>>>        End
92424>>>>
92424>>>
92424>>>        // We need to remove the ".int" part of the table name because
92424>>>        // the table name after the "#" in the connection syntax below wants the
92424>>>        // "bare" table name without any extension.
92424>>>        If (sDriverID <> DATAFLEX_ID) Begin
92426>>>            If (Lowercase(sTableName) contains ".int") Begin
92428>>>                Get ParseFileExtension sTableName to sExt
92429>>>                Move (Replace(("." + sExt), sTableName, "")) to sTableNameShort
92430>>>            End
92430>>>>
92430>>>            Else Begin
92431>>>                Move sTableName to sTableNameShort
92432>>>                Move (Append(sTableName, ".int")) to sTableName
92433>>>            End
92433>>>>
92433>>>            If (bMertechDriver = False) Begin
92435>>>                Move (sDriverID + ":" + sSchema + "#" + sTableNameShort + "@" + sConnection + "|options|intfile=" + sTableName) to sConnection
92436>>>                Move sConnection to sTableName
92437>>>            End
92437>>>>
92437>>>        End
92437>>>>
92437>>>
92437>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
92438>>>        Send Ignore_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
92439>>>        If (hTable = 0) Begin
92441>>>            Get NextFreeFilelistSlot to hTable
92442>>>        End
92442>>>>
92442>>>
92442>>>        Case Begin
92442>>>            Case (sDriverID = MSSQLDRV_ID)
92444>>>                // If not df_exclusive mode, we use the "Open As" syntax.
92444>>>                If (iMode <> DF_EXCLUSIVE) Begin
92446>>>                    Open sTableName as hTable
92448>>>                End
92448>>>>
92448>>>                Else Begin
92449>>>                    Get OpenTableExclusive hTable to bOK
92450>>>                    If (bOK = False) Begin
92452>>>                        Function_Return False
92453>>>                    End
92453>>>>
92453>>>                End
92453>>>>
92453>>>                Case Break
92454>>>
92454>>>            Case (sDriverID = DB2_DRV_ID)
92457>>>                // If not df_exclusive mode, we use the "Open As" syntax.
92457>>>                If (iMode <> DF_EXCLUSIVE) Begin
92459>>>                    Open sTableName as hTable
92461>>>                End
92461>>>>
92461>>>                Else Begin
92462>>>                    Get OpenTableExclusive hTable to bOK
92463>>>                    If (bOK = False) Begin
92465>>>                        Function_Return False
92466>>>                    End
92466>>>>
92466>>>                End
92466>>>>
92466>>>                Case Break
92467>>>
92467>>>            Case (sDriverID = ODBC_DRV_ID)
92470>>>                // If not df_exclusive mode, we use the "Open As" syntax.
92470>>>                If (iMode <> DF_EXCLUSIVE) Begin
92472>>>                    Open sTableName as hTable
92474>>>                End
92474>>>>
92474>>>                Else Begin
92475>>>                    Get OpenTableExclusive hTable to bOK
92476>>>                    If (bOK = False) Begin
92478>>>                        Function_Return False
92479>>>                    End
92479>>>>
92479>>>                End
92479>>>>
92479>>>                Case Break
92480>>>
92480>>>            Case (sDriverID = SQLFLEX)
92483>>>                // ToDo: What is the <owner>? Same as Schema?
92483>>>                // SQLFlex:   Open "sql_drv:\\<serverName>\<database>*<owner>*<tableName>=<numberFieds>" as table
92483>>>                Move (SQLFLEX + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + SQLConnection.sSchema + "*" + sTableNameOrg) to sTableName
92484>>>                // If not df_exclusive mode, we use the "Open As" syntax.
92484>>>                If (iMode <> DF_EXCLUSIVE) Begin
92486>>>                    Open sTableName as hTable
92488>>>                End
92488>>>>
92488>>>                Else Begin
92489>>>                    Get OpenTableExclusive hTable to bOK
92490>>>                    If (bOK = False) Begin
92492>>>                        Function_Return False
92493>>>                    End
92493>>>>
92493>>>                End
92493>>>>
92493>>>                Case Break
92494>>>
92494>>>            Case (sDriverID = MDSMySQL)
92497>>>                // MySQLFlex: Open "mdsmysql:\\<serverName>\<database>*<tableName>=<numberFieds>" as table
92497>>>                Move (MDSMySQL + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + "*" + sTableNameOrg) to sTableName
92498>>>                // If not df_exclusive mode, we use the "Open As" syntax.
92498>>>                If (iMode <> DF_EXCLUSIVE) Begin
92500>>>                    Open sTableName as hTable
92502>>>                End
92502>>>>
92502>>>                Else Begin
92503>>>                    Get OpenTableExclusive hTable to bOK
92504>>>                    If (bOK = False) Begin
92506>>>                        Function_Return False
92507>>>                    End
92507>>>>
92507>>>                End
92507>>>>
92507>>>                Case Break
92508>>>
92508>>>            Case (sDriverID = MDSPgSQL)
92511>>>                // PgFlex: Open "mdspgsql:\\<serverName>\<database>*<schema>*<tableName>=<numberFieds>" as table
92511>>>                Move (MDSPgSQL + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + "*" + SQLConnection.sSchema + "*" + sTableNameOrg) to sTableName
92512>>>                // If not df_exclusive mode, we use the "Open As" syntax.
92512>>>                If (iMode <> DF_EXCLUSIVE) Begin
92514>>>                    Open sTableName as hTable
92516>>>                End
92516>>>>
92516>>>                Else Begin
92517>>>                    Get OpenTableExclusive hTable to bOK
92518>>>                    If (bOK = False) Begin
92520>>>                        Function_Return False
92521>>>                    End
92521>>>>
92521>>>                End
92521>>>>
92521>>>                Case Break
92522>>>
92522>>>            Case (sDriverID = ORAFLEX)
92525>>>                // ToDo: What is the <owner>? Same as Schema?
92525>>>                // ORAFlex: Open "ora_drv:\\<serverName>\<owner>*<tableName>=<numberFieds>" as table
92525>>>                Move (ORAFLEX + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sSchema + "*" + sTableName) to sTableName
92526>>>                // If not df_exclusive mode, we use the "Open As" syntax.
92526>>>                If (iMode <> DF_EXCLUSIVE) Begin
92528>>>                    Open sTableName as hTable
92530>>>                End
92530>>>>
92530>>>                Else Begin
92531>>>                    Get OpenTableExclusive hTable to bOK
92532>>>                    If (bOK = False) Begin
92534>>>                        Function_Return False
92535>>>                    End
92535>>>>
92535>>>                End
92535>>>>
92535>>>                Case Break
92536>>>
92536>>>            Case (sDriverID = DATAFLEX_ID)
92539>>>                If (sTableName <> "" and iMode <> DF_EXCLUSIVE) Begin
92541>>>                    Open sTableName as hTable
92543>>>                End
92543>>>>
92543>>>                Else If (iMode = DF_EXCLUSIVE) Begin
92546>>>                    Get OpenTableExclusive hTable to bOK
92547>>>                    If (bOK = False) Begin
92549>>>                        Function_Return False
92550>>>                    End
92550>>>>
92550>>>                End
92550>>>>
92550>>>                Else Begin
92551>>>                    Open hTable
92553>>>                End
92553>>>>
92553>>>                Case Break
92554>>>
92554>>>            // ToDo: Logic needs to be expanded for Mertech drivers!
92554>>>
92554>>>            Case Else
92554>>>                Error DFERR_PROGRAM ("Invalid driver:" * sDriverID)
92555>>>>
92555>>>        Case End
92555>>>
92555>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
92556>>>        Send Trap_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
92557>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
92559>>>            Move False to Found
92560>>>        End
92560>>>>
92560>>>        // If open failed, the Err is set to true,
92560>>>        // but we don't want that because it could end our loop.
92560>>>        Move False to Err
92561>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
92564>>>
92564>>>        Function_Return bOpen
92565>>>    End_Function
92566>>>
92566>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
92566>>>    // that the embedded .dat file exists on disk _or_ that the SQL table exists
92566>>>    // if it is an SQL table
92566>>>    Function UtilTableExists Handle hTable Returns Boolean
92568>>>        Boolean bExists bIsSQLTable
92568>>>        String sDataPath sRootName
92568>>>
92568>>>        Get UtilTableNumberIsInUse hTable to bExists
92569>>>        If (bExists = False) Begin
92571>>>            Function_Return False
92572>>>        End
92572>>>>
92572>>>
92572>>>        Move False to bIsSQLTable
92573>>>        If (hTable > 0) Begin
92575>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
92578>>>            Move (sRootName contains ":") to bIsSQLTable
92579>>>        End
92579>>>>
92579>>>        If (bIsSQLTable = True) Begin
92581>>>            Get UtilTableIsSQL hTable to bExists
92582>>>            Function_Return bExists
92583>>>        End
92583>>>>
92583>>>        Else Begin
92584>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
92585>>>            Get vFolderFormat sDataPath to sDataPath
92586>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
92587>>>        End
92587>>>>
92587>>>
92587>>>        Function_Return bExists
92588>>>    End_Function
92589>>>
92589>>>    // Pass a table handle
92589>>>    // Returns True if the table exists in filelist.cfg.
92589>>>    Function UtilTableNumberIsInUse Handle hCheckTable Returns Boolean
92591>>>        Handle hTable
92591>>>        Boolean bFound
92591>>>
92591>>>        Move False to bFound
92592>>>        Move 0 to hTable
92593>>>        Repeat
92593>>>>
92593>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92596>>>            If (hTable > 0) Begin
92598>>>                If (hTable = hCheckTable) Begin
92600>>>                    Move True to bFound
92601>>>                End
92601>>>>
92601>>>            End
92601>>>>
92601>>>            If (bFound = True) ;                Break
92604>>>        Until (hTable = 0)
92606>>>
92606>>>        Function_Return (bFound = True)
92607>>>    End_Function
92608>>>
92608>>>    Function UtilDriverFromTableNumber Handle hTable Returns String
92610>>>        Boolean bOK bExists                              
92610>>>        String sDriverID
92610>>>        
92610>>>        Get UtilTableExists hTable to bExists
92611>>>        If (bExists = False) Begin
92613>>>            Function_Return ""
92614>>>        End
92614>>>>
92614>>>        Get OpenTableExclusive hTable to bOK
92615>>>        If (bOK = False) Begin
92617>>>            Function_Return ""
92618>>>        End 
92618>>>>
92618>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
92621>>>        
92621>>>        Function_Return sDriverID
92622>>>    End_Function        
92623>>>    
92623>>>    // Number of tables in Filelist.cfg. Returns integger
92623>>>    Function UtilFilelistNoOfTables Returns Integer
92625>>>        Handle hTable
92625>>>        Integer iRetval
92625>>>
92625>>>        Move 0 to hTable
92626>>>        Move 0 to iRetval
92627>>>
92627>>>        Repeat
92627>>>>
92627>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92630>>>            If (hTable > 0) Begin
92632>>>                Increment iRetval
92633>>>            End
92633>>>>
92633>>>        Until (hTable = 0)
92635>>>
92635>>>        Function_Return iRetval
92636>>>    End_Function
92637>>>
92637>>>    Function UtilFilelistIsDataFlexTablesOnly Returns Boolean
92639>>>        String sRootName
92639>>>        Boolean bIsSQL
92639>>>        Handle hTable
92639>>>
92639>>>        Move False to bIsSQL
92640>>>        Move 0 to hTable
92641>>>        Repeat
92641>>>>
92641>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92644>>>            If (hTable > 0) Begin
92646>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
92649>>>                Move (sRootName contains ":") to bIsSQL
92650>>>                If (bIsSQL = True) Begin
92652>>>                    Move 0 to hTable
92653>>>                End
92653>>>>
92653>>>            End
92653>>>>
92653>>>        Until (hTable = 0)
92655>>>
92655>>>        Function_Return (bIsSQL = False)
92656>>>    End_Function
92657>>>
92657>>>    // Pass a table's logical name
92657>>>    // Returns True if the table exists in filelist.cfg.
92657>>>    Function UtilTableLogicalNameIsInUse String sCheckTable Returns Boolean
92659>>>        Handle hTable
92659>>>        Boolean bFound
92659>>>        String sCompareTable
92659>>>
92659>>>        Move False to bFound
92660>>>        Move 0 to hTable
92661>>>        Repeat
92661>>>>
92661>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92664>>>            If (hTable > 0) Begin
92666>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sCompareTable
92669>>>                If (Uppercase(sCompareTable) = Uppercase(sCheckTable)) Begin
92671>>>                    Move True to bFound
92672>>>                End
92672>>>>
92672>>>            End
92672>>>>
92672>>>            If (bFound = True) ;                Break
92675>>>        Until (hTable = 0)
92677>>>
92677>>>        Function_Return (bFound = True)
92678>>>    End_Function
92679>>>
92679>>>    // * Dummy function for the Studio's Code Explorer *
92679>>>    Function UTIL_ENUMERATION_FUNCTIONS Returns Boolean
92681>>>        Function_Return False
92682>>>    End_Function
92683>>>
92683>>>    Function UtilEnumerateOverlapFields Integer hTable Integer iField Returns String[]
92685>>>        String  sRetval
92685>>>        String[] sOverlapFieldsArray
92686>>>        Integer iType iColumn iColumns
92686>>>        Boolean bOpen bOverlap
92686>>>
92686>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
92689>>>        If (bOpen = False) Begin
92691>>>            Open hTable
92693>>>        End
92693>>>>
92693>>>
92693>>>        Move "" to sRetval
92694>>>
92694>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iColumns
92697>>>
92697>>>        for iColumn from 0 to iColumns
92703>>>>
92703>>>            Get_Attribute DF_FIELD_TYPE of hTable iColumn to iType
92706>>>            If (iField <> iColumn and iType <> DF_OVERLAP) Begin
92708>>>                Get_Attribute DF_FIELD_OVERLAP of hTable iField iColumn to bOverlap
92711>>>                If (bOverlap) Begin
92713>>>                    If (sRetval <> "") Begin
92715>>>                        Append sRetval ","
92716>>>                    End
92716>>>>
92716>>>                    Append sRetval iColumn
92717>>>                End
92717>>>>
92717>>>            End
92717>>>>
92717>>>        Loop
92718>>>>
92718>>>
92718>>>        If (bOpen = False) Begin
92720>>>            Close hTable
92721>>>        End
92721>>>>
92721>>>
92721>>>        Get StrSplitToArray sRetval "," to sOverlapFieldsArray
92722>>>
92722>>>        Function_Return sOverlapFieldsArray
92723>>>    End_Function
92724>>>
92724>>>    // Returns a struct array with all data types for the passed driver & dbtype.
92724>>>    Function UtilEnumerateColumnTypes String sDriverID Integer iDbType Returns tColumnType[]
92726>>>        tColumnType[] ColumnType
92726>>>        tColumnType[] ColumnType
92727>>>
92727>>>        Case Begin
92727>>>            Case (iDbType = EN_dbTypeDataFlex)
92729>>>                Get _UtilEnumerateDataFlexTypes to ColumnType
92730>>>                Case Break
92731>>>
92731>>>            Case (iDbType = EN_DbTypeDB2)
92734>>>                Get _UtilEnumerateDB2Types to ColumnType
92735>>>                Case Break
92736>>>
92736>>>            Case (iDbType = EN_DbTypeMSSQL)
92739>>>                Get _UtilEnumerateMSSQLTypes sDriverID to ColumnType
92740>>>                Case Break
92741>>>
92741>>>            Case (sDriverID = MDSMySQL)
92744>>>                Get _UtilEnumerateMySQLTypes to ColumnType
92745>>>                Case Break
92746>>>
92746>>>            Case (sDriverID = ORAFLEX)
92749>>>                Get _UtilEnumerateOracleTypes to ColumnType
92750>>>                Case Break
92751>>>
92751>>>            Case (sDriverID = MDSPgSQL)
92754>>>                Get _UtilEnumeratePostgreSQLTypes to ColumnType
92755>>>                Case Break
92756>>>        Case End
92756>>>
92756>>>        Function_Return ColumnType
92757>>>    End_Function
92758>>>
92758>>>    Function UtilEnumerateMSSQLODBCDrivers Returns String
92760>>>        Handle hoRegistry hoODBCDriverNames
92760>>>        Boolean bExists bKeyOpened
92760>>>        String sKey
92760>>>        String[] sDrivers
92761>>>        Integer iDriverNames iDriverName
92761>>>
92761>>>        Get Create (RefClass (cRegistry)) to hoRegistry
92762>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
92763>>>        Set pfAccessRights of hoRegistry to Key_Read
92764>>>        Move "SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers" to sKey
92765>>>        Get KeyExists of hoRegistry sKey to bExists
92766>>>        If (bExists) Begin
92768>>>            Get OpenKey of hoRegistry sKey to bKeyOpened
92769>>>            If (bKeyOpened) Begin
92771>>>                Get Create (RefClass (Array)) to hoODBCDriverNames
92772>>>                Get GetValues of hoRegistry hoODBCDriverNames to iDriverNames
92773>>>                If (iDriverNames > 0) Begin
92775>>>                    Move (ResizeArray (sDrivers, iDriverNames)) to sDrivers
92776>>>                    Decrement iDriverNames
92777>>>                    for iDriverName from 0 to iDriverNames
92783>>>>
92783>>>                        Get Value of hoODBCDriverNames iDriverName to sDrivers[iDriverName]
92784>>>                      Loop
92785>>>>
92785>>>                End
92785>>>>
92785>>>                Send CloseKey of hoRegistry
92786>>>            End
92786>>>>
92786>>>        End
92786>>>>
92786>>>        Send Destroy of hoRegistry
92787>>>
92787>>>        Function_Return sDrivers
92788>>>    End_Function
92789>>>
92789>>>    // DataFlex Embedded Database Data Types:
92789>>>    // Helper function for UtilEnumerateColumnTypes
92789>>>    Function _UtilEnumerateDataFlexTypes Returns tColumnType[]
92791>>>        tColumnType[] ColumnType
92791>>>        tColumnType[] ColumnType
92792>>>        Integer i
92792>>>
92792>>>        Move DF_ASCII           to ColumnType[i].iSQLType
92793>>>        Move "ASCII"            to ColumnType[i].sSQLType
92794>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
92795>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
92796>>>        Move "254"              to ColumnType[i].sPrecision
92797>>>        Increment i
92798>>>
92798>>>        Move DF_BCD             to ColumnType[i].iSQLType
92799>>>        Move "Numeric"          to ColumnType[i].sSQLType
92800>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
92801>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
92802>>>        Move "14.8"             to ColumnType[i].sPrecision
92803>>>        Increment i
92804>>>
92804>>>        Move DF_DATE            to ColumnType[i].iSQLType
92805>>>        Move "Date"             to ColumnType[i].sSQLType
92806>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
92807>>>        Move "Date"             to ColumnType[i].sDataFlexType
92808>>>        Move "6.0"              to ColumnType[i].sPrecision
92809>>>        Move True               to ColumnType[i].bCanEditSize
92810>>>        Increment i
92811>>>
92811>>>        Move DF_TEXT            to ColumnType[i].iSQLType
92812>>>        Move "Text"             to ColumnType[i].sSQLType
92813>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
92814>>>        Move "Text"             to ColumnType[i].sDataFlexType
92815>>>        Move "16384"            to ColumnType[i].sPrecision
92816>>>        Increment i
92817>>>
92817>>>        Move DF_BINARY          to ColumnType[i].iSQLType
92818>>>        Move "Binary"           to ColumnType[i].sSQLType
92819>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
92820>>>        Move "Binary"           to ColumnType[i].sDataFlexType
92821>>>        Move "16384"            to ColumnType[i].sPrecision
92822>>>        Increment i
92823>>>
92823>>>        Move DF_DATETIME        to ColumnType[i].iSQLType
92824>>>        Move "DateTime"         to ColumnType[i].sSQLType
92825>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
92826>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
92827>>>        Move "23"               to ColumnType[i].sPrecision
92828>>>        Move True               to ColumnType[i].bCanEditSize
92829>>>        Increment i
92830>>>
92830>>>        Move DF_OVERLAP         to ColumnType[i].iSQLType
92831>>>        Move "Overlap"          to ColumnType[i].sSQLType
92832>>>        Move DF_OVERLAP         to ColumnType[i].iDataFlexType
92833>>>        Move "Overlap"          to ColumnType[i].sDataFlexType
92834>>>        Move "0.0"              to ColumnType[i].sPrecision
92835>>>
92835>>>        Function_Return ColumnType
92836>>>    End_Function
92837>>>
92837>>>    Function _UtilEnumerateDB2Types Returns tColumnType[]
92839>>>        tColumnType[] aColumnType
92839>>>        tColumnType[] aColumnType
92840>>>        Integer i
92840>>>
Including file: DB2_DRV_DriverDef.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\DB2_DRV_DriverDef.inc)
92840>>>>// Generated By The Database Update Framework
92840>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\DB2_DRV_DriverDef.xml
92840>>>>// Driver COLUMN DATA TYPES
92840>>>>//
92840>>>>// Created: 2018-03-14 23:46:34.033
92840>>>>
92840>>>>            Move "bigint"                                to aColumnType[i].sSQLType
92841>>>>            Move -5                                      to aColumnType[i].iSQLType
92842>>>>            Move True                                    to aColumnType[i].bCanEditSize
92843>>>>            Move True                                    to aColumnType[i].bNativeDataType
92844>>>>            Move 14                                      to aColumnType[i].iDefaultSize
92845>>>>            Move 1                                       to aColumnType[i].iMinSize
92846>>>>            Move 14                                      to aColumnType[i].nMaxSize
92847>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
92848>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
92849>>>>            Move 14                                      to aColumnType[i].sPrecision
92850>>>>            Increment i
92851>>>>
92851>>>>            Move "blob"                                  to aColumnType[i].sSQLType
92852>>>>            Move -98                                     to aColumnType[i].iSQLType
92853>>>>            Move True                                    to aColumnType[i].bCanEditSize
92854>>>>            Move True                                    to aColumnType[i].bNativeDataType
92855>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
92856>>>>            Move 1                                       to aColumnType[i].iMinSize
92857>>>>            Move 2147483647                              to aColumnType[i].nMaxSize
92858>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
92859>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
92860>>>>            Move 2147483647                              to aColumnType[i].sPrecision
92861>>>>            Increment i
92862>>>>
92862>>>>            Move "char"                                  to aColumnType[i].sSQLType
92863>>>>            Move 1                                       to aColumnType[i].iSQLType
92864>>>>            Move True                                    to aColumnType[i].bCanEditSize
92865>>>>            Move True                                    to aColumnType[i].bNativeDataType
92866>>>>            Move -1                                      to aColumnType[i].iDefaultSize
92867>>>>            Move 1                                       to aColumnType[i].iMinSize
92868>>>>            Move 254                                     to aColumnType[i].nMaxSize
92869>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92870>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92871>>>>            Move 254                                     to aColumnType[i].sPrecision
92872>>>>            Increment i
92873>>>>
92873>>>>            Move "char for bit data"                     to aColumnType[i].sSQLType
92874>>>>            Move -2                                      to aColumnType[i].iSQLType
92875>>>>            Move True                                    to aColumnType[i].bCanEditSize
92876>>>>            Move True                                    to aColumnType[i].bNativeDataType
92877>>>>            Move -1                                      to aColumnType[i].iDefaultSize
92878>>>>            Move 1                                       to aColumnType[i].iMinSize
92879>>>>            Move 254                                     to aColumnType[i].nMaxSize
92880>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92881>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92882>>>>            Move 254                                     to aColumnType[i].sPrecision
92883>>>>            Increment i
92884>>>>
92884>>>>            Move "clob"                                  to aColumnType[i].sSQLType
92885>>>>            Move -99                                     to aColumnType[i].iSQLType
92886>>>>            Move True                                    to aColumnType[i].bCanEditSize
92887>>>>            Move True                                    to aColumnType[i].bNativeDataType
92888>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
92889>>>>            Move 1                                       to aColumnType[i].iMinSize
92890>>>>            Move 2147483647                              to aColumnType[i].nMaxSize
92891>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
92892>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
92893>>>>            Move 2147483647                              to aColumnType[i].sPrecision
92894>>>>            Increment i
92895>>>>
92895>>>>            Move "date"                                  to aColumnType[i].sSQLType
92896>>>>            Move 91                                      to aColumnType[i].iSQLType
92897>>>>            Move False                                   to aColumnType[i].bCanEditSize
92898>>>>            Move True                                    to aColumnType[i].bNativeDataType
92899>>>>            Move 0                                       to aColumnType[i].iDefaultSize
92900>>>>            Move 0                                       to aColumnType[i].iMinSize
92901>>>>            Move 0                                       to aColumnType[i].nMaxSize
92902>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92903>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92904>>>>            Move 1                                       to aColumnType[i].sPrecision
92905>>>>            Increment i
92906>>>>
92906>>>>            Move "dbclob"                                to aColumnType[i].sSQLType
92907>>>>            Move -350                                    to aColumnType[i].iSQLType
92908>>>>            Move True                                    to aColumnType[i].bCanEditSize
92909>>>>            Move True                                    to aColumnType[i].bNativeDataType
92910>>>>            Move -1                                      to aColumnType[i].iDefaultSize
92911>>>>            Move 1                                       to aColumnType[i].iMinSize
92912>>>>            Move 1073741823                              to aColumnType[i].nMaxSize
92913>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92914>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92915>>>>            Move 1073741823                              to aColumnType[i].sPrecision
92916>>>>            Increment i
92917>>>>
92917>>>>            Move "decimal"                               to aColumnType[i].sSQLType
92918>>>>            Move 3                                       to aColumnType[i].iSQLType
92919>>>>            Move True                                    to aColumnType[i].bCanEditSize
92920>>>>            Move True                                    to aColumnType[i].bNativeDataType
92921>>>>            Move -1                                      to aColumnType[i].iDefaultSize
92922>>>>            Move 1                                       to aColumnType[i].iMinSize
92923>>>>            Move 14                                      to aColumnType[i].nMaxSize
92924>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
92925>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
92926>>>>            Move 14                                      to aColumnType[i].sPrecision
92927>>>>            Increment i
92928>>>>
92928>>>>            Move "double"                                to aColumnType[i].sSQLType
92929>>>>            Move 8                                       to aColumnType[i].iSQLType
92930>>>>            Move True                                    to aColumnType[i].bCanEditSize
92931>>>>            Move True                                    to aColumnType[i].bNativeDataType
92932>>>>            Move 14                                      to aColumnType[i].iDefaultSize
92933>>>>            Move 1                                       to aColumnType[i].iMinSize
92934>>>>            Move 14                                      to aColumnType[i].nMaxSize
92935>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
92936>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
92937>>>>            Move 14                                      to aColumnType[i].sPrecision
92938>>>>            Increment i
92939>>>>
92939>>>>            Move "graphic"                               to aColumnType[i].sSQLType
92940>>>>            Move -95                                     to aColumnType[i].iSQLType
92941>>>>            Move True                                    to aColumnType[i].bCanEditSize
92942>>>>            Move True                                    to aColumnType[i].bNativeDataType
92943>>>>            Move -1                                      to aColumnType[i].iDefaultSize
92944>>>>            Move 1                                       to aColumnType[i].iMinSize
92945>>>>            Move 127                                     to aColumnType[i].nMaxSize
92946>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92947>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92948>>>>            Move 127                                     to aColumnType[i].sPrecision
92949>>>>            Increment i
92950>>>>
92950>>>>            Move "integer"                               to aColumnType[i].sSQLType
92951>>>>            Move 4                                       to aColumnType[i].iSQLType
92952>>>>            Move True                                    to aColumnType[i].bCanEditSize
92953>>>>            Move True                                    to aColumnType[i].bNativeDataType
92954>>>>            Move 14                                      to aColumnType[i].iDefaultSize
92955>>>>            Move 1                                       to aColumnType[i].iMinSize
92956>>>>            Move 14                                      to aColumnType[i].nMaxSize
92957>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
92958>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
92959>>>>            Move 14                                      to aColumnType[i].sPrecision
92960>>>>            Increment i
92961>>>>
92961>>>>            Move "long varchar"                          to aColumnType[i].sSQLType
92962>>>>            Move -1                                      to aColumnType[i].iSQLType
92963>>>>            Move True                                    to aColumnType[i].bCanEditSize
92964>>>>            Move True                                    to aColumnType[i].bNativeDataType
92965>>>>            Move -1                                      to aColumnType[i].iDefaultSize
92966>>>>            Move 1                                       to aColumnType[i].iMinSize
92967>>>>            Move 32000                                   to aColumnType[i].nMaxSize
92968>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92969>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92970>>>>            Move 32000                                   to aColumnType[i].sPrecision
92971>>>>            Increment i
92972>>>>
92972>>>>            Move "long varchar for bit data"             to aColumnType[i].sSQLType
92973>>>>            Move -4                                      to aColumnType[i].iSQLType
92974>>>>            Move True                                    to aColumnType[i].bCanEditSize
92975>>>>            Move True                                    to aColumnType[i].bNativeDataType
92976>>>>            Move -1                                      to aColumnType[i].iDefaultSize
92977>>>>            Move 1                                       to aColumnType[i].iMinSize
92978>>>>            Move 32700                                   to aColumnType[i].nMaxSize
92979>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92980>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92981>>>>            Move 32700                                   to aColumnType[i].sPrecision
92982>>>>            Increment i
92983>>>>
92983>>>>            Move "long vargraphic"                       to aColumnType[i].sSQLType
92984>>>>            Move -97                                     to aColumnType[i].iSQLType
92985>>>>            Move True                                    to aColumnType[i].bCanEditSize
92986>>>>            Move True                                    to aColumnType[i].bNativeDataType
92987>>>>            Move -1                                      to aColumnType[i].iDefaultSize
92988>>>>            Move 1                                       to aColumnType[i].iMinSize
92989>>>>            Move 16350                                   to aColumnType[i].nMaxSize
92990>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92991>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92992>>>>            Move 16350                                   to aColumnType[i].sPrecision
92993>>>>            Increment i
92994>>>>
92994>>>>            Move "real"                                  to aColumnType[i].sSQLType
92995>>>>            Move 7                                       to aColumnType[i].iSQLType
92996>>>>            Move True                                    to aColumnType[i].bCanEditSize
92997>>>>            Move True                                    to aColumnType[i].bNativeDataType
92998>>>>            Move 14                                      to aColumnType[i].iDefaultSize
92999>>>>            Move 1                                       to aColumnType[i].iMinSize
93000>>>>            Move 14                                      to aColumnType[i].nMaxSize
93001>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93002>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93003>>>>            Move 14                                      to aColumnType[i].sPrecision
93004>>>>            Increment i
93005>>>>
93005>>>>            Move "smallint"                              to aColumnType[i].sSQLType
93006>>>>            Move 5                                       to aColumnType[i].iSQLType
93007>>>>            Move True                                    to aColumnType[i].bCanEditSize
93008>>>>            Move True                                    to aColumnType[i].bNativeDataType
93009>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93010>>>>            Move 1                                       to aColumnType[i].iMinSize
93011>>>>            Move 14                                      to aColumnType[i].nMaxSize
93012>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93013>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93014>>>>            Move 14                                      to aColumnType[i].sPrecision
93015>>>>            Increment i
93016>>>>
93016>>>>            Move "time"                                  to aColumnType[i].sSQLType
93017>>>>            Move 92                                      to aColumnType[i].iSQLType
93018>>>>            Move False                                   to aColumnType[i].bCanEditSize
93019>>>>            Move True                                    to aColumnType[i].bNativeDataType
93020>>>>            Move 0                                       to aColumnType[i].iDefaultSize
93021>>>>            Move 0                                       to aColumnType[i].iMinSize
93022>>>>            Move 0                                       to aColumnType[i].nMaxSize
93023>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93024>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93025>>>>            Move 1                                       to aColumnType[i].sPrecision
93026>>>>            Increment i
93027>>>>
93027>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
93028>>>>            Move 93                                      to aColumnType[i].iSQLType
93029>>>>            Move False                                   to aColumnType[i].bCanEditSize
93030>>>>            Move True                                    to aColumnType[i].bNativeDataType
93031>>>>            Move 0                                       to aColumnType[i].iDefaultSize
93032>>>>            Move 0                                       to aColumnType[i].iMinSize
93033>>>>            Move 0                                       to aColumnType[i].nMaxSize
93034>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93035>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93036>>>>            Move 1                                       to aColumnType[i].sPrecision
93037>>>>            Increment i
93038>>>>
93038>>>>            Move "varchar"                               to aColumnType[i].sSQLType
93039>>>>            Move 12                                      to aColumnType[i].iSQLType
93040>>>>            Move True                                    to aColumnType[i].bCanEditSize
93041>>>>            Move True                                    to aColumnType[i].bNativeDataType
93042>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93043>>>>            Move 1                                       to aColumnType[i].iMinSize
93044>>>>            Move 32672                                   to aColumnType[i].nMaxSize
93045>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93046>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93047>>>>            Move 32672                                   to aColumnType[i].sPrecision
93048>>>>            Increment i
93049>>>>
93049>>>>            Move "varchar for bit data"                  to aColumnType[i].sSQLType
93050>>>>            Move -3                                      to aColumnType[i].iSQLType
93051>>>>            Move True                                    to aColumnType[i].bCanEditSize
93052>>>>            Move True                                    to aColumnType[i].bNativeDataType
93053>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93054>>>>            Move 1                                       to aColumnType[i].iMinSize
93055>>>>            Move 32672                                   to aColumnType[i].nMaxSize
93056>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93057>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93058>>>>            Move 32672                                   to aColumnType[i].sPrecision
93059>>>>            Increment i
93060>>>>
93060>>>>            Move "vargraphic"                            to aColumnType[i].sSQLType
93061>>>>            Move -96                                     to aColumnType[i].iSQLType
93062>>>>            Move True                                    to aColumnType[i].bCanEditSize
93063>>>>            Move True                                    to aColumnType[i].bNativeDataType
93064>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93065>>>>            Move 1                                       to aColumnType[i].iMinSize
93066>>>>            Move 16336                                   to aColumnType[i].nMaxSize
93067>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93068>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93069>>>>            Move 16336                                   to aColumnType[i].sPrecision
93070>>>>            Increment i
93071>>>>
93071>>>>            Move "xml"                                   to aColumnType[i].sSQLType
93072>>>>            Move -370                                    to aColumnType[i].iSQLType
93073>>>>            Move True                                    to aColumnType[i].bCanEditSize
93074>>>>            Move True                                    to aColumnType[i].bNativeDataType
93075>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
93076>>>>            Move 1                                       to aColumnType[i].iMinSize
93077>>>>            Move 2147483647                              to aColumnType[i].nMaxSize
93078>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
93079>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
93080>>>>            Move 2147483647                              to aColumnType[i].sPrecision
93081>>>>            Increment i
93082>>>>
93082>>>>
93082>>>//        Move SQL_DBCLOB         to ColumnType[i].iSQLType
93082>>>//        Move "DBCLOB"           to ColumnType[i].sSQLType
93082>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
93082>>>//        Move "Text"             to ColumnType[i].sDataFlexType
93082>>>//        Move "16384"            to ColumnType[i].sPrecision
93082>>>//        Increment i
93082>>>//
93082>>>//        Move SQL_BIGINT         to ColumnType[i].iSQLType
93082>>>//        Move "BIGINT"           to ColumnType[i].sSQLType
93082>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
93082>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
93082>>>//        Move "14.0"             to ColumnType[i].sPrecision
93082>>>//        Increment i
93082>>>//
93082>>>//        Move SQL_BLOB           to ColumnType[i].iSQLType
93082>>>//        Move "BLOB"             to ColumnType[i].sSQLType
93082>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
93082>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
93082>>>//        Move "16384"            to ColumnType[i].sPrecision
93082>>>//        Increment i
93082>>>//
93082>>>//        Move SQL_CHAR           to ColumnType[i].iSQLType
93082>>>//        Move "CHAR"             to ColumnType[i].sSQLType
93082>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
93082>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
93082>>>//        Move "254"              to ColumnType[i].sPrecision
93082>>>//        Increment i
93082>>>//
93082>>>//        // ToDo: We need to change the sType when using this!
93082>>>//        Move SQL_CHARBIT            to ColumnType[i].iSQLType
93082>>>//        Move "CHAR FOR BIT DATA"    to ColumnType[i].sSQLType
93082>>>//        Move DF_BINARY              to ColumnType[i].iDataFlexType
93082>>>//        Move "Binary"               to ColumnType[i].sDataFlexType
93082>>>//        Move "254"                  to ColumnType[i].sPrecision
93082>>>//        Increment i
93082>>>//
93082>>>//        Move SQL_DATE           to ColumnType[i].iSQLType
93082>>>//        Move "DATE"             to ColumnType[i].sSQLType
93082>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
93082>>>//        Move "Date"             to ColumnType[i].sDataFlexType
93082>>>//        Move "6.0"              to ColumnType[i].sPrecision
93082>>>//        Move True               to ColumnType[i].bCanEditSize
93082>>>//        Increment i
93082>>>//
93082>>>//        Move SQL_CLOB           to ColumnType[i].iSQLType
93082>>>//        Move "CLOB"             to ColumnType[i].sSQLType
93082>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
93082>>>//        Move "Text"             to ColumnType[i].sDataFlexType
93082>>>//        Move "16384"            to ColumnType[i].sPrecision
93082>>>//        Increment i
93082>>>//
93082>>>//        Move SQL_DECIMAL        to ColumnType[i].iSQLType
93082>>>//        Move "DECIMAL"          to ColumnType[i].sSQLType
93082>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
93082>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
93082>>>//        Move "14.8"             to ColumnType[i].sPrecision
93082>>>//        Increment i
93082>>>//
93082>>>//        Move SQL_DOUBLE         to ColumnType[i].iSQLType
93082>>>//        Move "DOUBLE"           to ColumnType[i].sSQLType
93082>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
93082>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
93082>>>//        Move "14.8"             to ColumnType[i].sPrecision
93082>>>//        Increment i
93082>>>//
93082>>>//        Move SQL_FLOAT          to ColumnType[i].iSQLType
93082>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
93082>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
93082>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
93082>>>//        Move "14.8"             to ColumnType[i].sPrecision
93082>>>//        Increment i
93082>>>//
93082>>>//        Move SQL_GRAPHIC        to ColumnType[i].iSQLType
93082>>>//        Move "GRAPHIC"          to ColumnType[i].sSQLType
93082>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
93082>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
93082>>>//        Move "255"              to ColumnType[i].sPrecision
93082>>>//        Increment i
93082>>>//
93082>>>//        Move SQL_INTEGER        to ColumnType[i].iSQLType
93082>>>//        Move "INTEGER"          to ColumnType[i].sSQLType
93082>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
93082>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
93082>>>//        Move "9.0"              to ColumnType[i].sPrecision
93082>>>//        Increment i
93082>>>//
93082>>>//        Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
93082>>>//        Move "LONG VARCHAR"     to ColumnType[i].sSQLType
93082>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
93082>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
93082>>>//        Move "32000"            to ColumnType[i].sPrecision
93082>>>//        Increment i
93082>>>//
93082>>>//        Move SQL_LONGVARCHARBIT to ColumnType[i].iSQLType
93082>>>//        Move "LONG VARCHAR BIT" to ColumnType[i].sSQLType
93082>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
93082>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
93082>>>//        Move "32000"            to ColumnType[i].sPrecision
93082>>>//        Increment i
93082>>>//
93082>>>//        Move SQL_LONGVARGRAPHIC to ColumnType[i].iSQLType
93082>>>//        Move "LONG VARGRAPHIC"  to ColumnType[i].sSQLType
93082>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
93082>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
93082>>>//        Move "32000"            to ColumnType[i].sPrecision
93082>>>//        Increment i
93082>>>//
93082>>>//        Move SQL_NUMERIC        to ColumnType[i].iSQLType
93082>>>//        Move "NUMERIC"          to ColumnType[i].sSQLType
93082>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
93082>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
93082>>>//        Move "14.8"             to ColumnType[i].sPrecision
93082>>>//        Increment i
93082>>>//
93082>>>//        Move SQL_REAL           to ColumnType[i].iSQLType
93082>>>//        Move "REAL"             to ColumnType[i].sSQLType
93082>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
93082>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
93082>>>//        Move "14.8"             to ColumnType[i].sPrecision
93082>>>//        Increment i
93082>>>//
93082>>>//        Move SQL_SMALLINT       to ColumnType[i].iSQLType
93082>>>//        Move "SMALLINT"         to ColumnType[i].sSQLType
93082>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
93082>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
93082>>>//        Move "5.0"              to ColumnType[i].sPrecision
93082>>>//        Increment i
93082>>>//
93082>>>//        Move SQL_TIME           to ColumnType[i].iSQLType
93082>>>//        Move "TIME"             to ColumnType[i].sSQLType
93082>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
93082>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
93082>>>//        Move "19.0"             to ColumnType[i].sPrecision
93082>>>//        Move True               to ColumnType[i].bCanEditSize
93082>>>//        Increment i
93082>>>//
93082>>>//        Move SQL_TIMESTAMP      to ColumnType[i].iSQLType
93082>>>//        Move "TIMESTAMP"        to ColumnType[i].sSQLType
93082>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
93082>>>//        Move "DATETIME"         to ColumnType[i].sDataFlexType
93082>>>//        Move "23.6"             to ColumnType[i].sPrecision
93082>>>//        Move True               to ColumnType[i].bCanEditSize
93082>>>//        Increment i
93082>>>//
93082>>>//        Move SQL_VARCHAR        to ColumnType[i].iSQLType
93082>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
93082>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
93082>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
93082>>>//        Move "16384"            to ColumnType[i].sPrecision
93082>>>//        Increment i
93082>>>//
93082>>>//        // ToDo: We need to change the sType when using this!
93082>>>//        Move SQL_VARCHARBIT         to ColumnType[i].iSQLType
93082>>>//        Move "VARCHAR FOR BIT DATA" to ColumnType[i].sSQLType
93082>>>//        Move DF_TEXT                to ColumnType[i].iDataFlexType
93082>>>//        Move "TEXT"                 to ColumnType[i].sDataFlexType
93082>>>//        Move "16384"                to ColumnType[i].sPrecision
93082>>>//        Increment i
93082>>>//
93082>>>//        Move SQL_VARGRAPHIC     to ColumnType[i].iSQLType
93082>>>//        Move "VARGRAPHIC"       to ColumnType[i].sSQLType
93082>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
93082>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
93082>>>//        Move "16384"            to ColumnType[i].sPrecision
93082>>>//
93082>>>//        Move SQL_XML            to ColumnType[i].iSQLType
93082>>>//        Move "XML"              to ColumnType[i].sSQLType
93082>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
93082>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
93082>>>//        Move "16384"            to ColumnType[i].sPrecision
93082>>>
93082>>>        Function_Return aColumnType
93083>>>    End_Function
93084>>>
93084>>>    // Microsoft SQL Server Database Data Types:
93084>>>    // Helper function for UtilEnumerateColumnTypes
93084>>>    Function _UtilEnumerateMSSQLTypes String sDriverID Returns tColumnType[]
93086>>>        tColumnType[] aColumnType
93086>>>        tColumnType[] aColumnType
93087>>>        Integer i
93087>>>
93087>>>        If (sDriverID = MSSQLDRV_ID) Begin
Including file: MSSQLDRV_DriverDef.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\MSSQLDRV_DriverDef.inc)
93089>>>>// Generated By The Database Update Framework
93089>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\bin\MSSQLDRV_DriverDef.xml
93089>>>>// Driver COLUMN DATA TYPES
93089>>>>//
93089>>>>// Created: 2018-03-15 00:00:57.024
93089>>>>
93089>>>>            Move "bigint"                                to aColumnType[i].sSQLType
93090>>>>            Move -5                                      to aColumnType[i].iSQLType
93091>>>>            Move True                                    to aColumnType[i].bCanEditSize
93092>>>>            Move True                                    to aColumnType[i].bNativeDataType
93093>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93094>>>>            Move 1                                       to aColumnType[i].iMinSize
93095>>>>            Move 14                                      to aColumnType[i].nMaxSize
93096>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93097>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93098>>>>            Move 14                                      to aColumnType[i].sPrecision
93099>>>>            Increment i
93100>>>>
93100>>>>            Move "binary"                                to aColumnType[i].sSQLType
93101>>>>            Move -2                                      to aColumnType[i].iSQLType
93102>>>>            Move True                                    to aColumnType[i].bCanEditSize
93103>>>>            Move True                                    to aColumnType[i].bNativeDataType
93104>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93105>>>>            Move 1                                       to aColumnType[i].iMinSize
93106>>>>            Move 8000                                    to aColumnType[i].nMaxSize
93107>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
93108>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
93109>>>>            Move 8000                                    to aColumnType[i].sPrecision
93110>>>>            Increment i
93111>>>>
93111>>>>            Move "bit"                                   to aColumnType[i].sSQLType
93112>>>>            Move -7                                      to aColumnType[i].iSQLType
93113>>>>            Move False                                   to aColumnType[i].bCanEditSize
93114>>>>            Move True                                    to aColumnType[i].bNativeDataType
93115>>>>            Move 0                                       to aColumnType[i].iDefaultSize
93116>>>>            Move 0                                       to aColumnType[i].iMinSize
93117>>>>            Move 0                                       to aColumnType[i].nMaxSize
93118>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93119>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93120>>>>            Move 1                                       to aColumnType[i].sPrecision
93121>>>>            Increment i
93122>>>>
93122>>>>            Move "char"                                  to aColumnType[i].sSQLType
93123>>>>            Move 1                                       to aColumnType[i].iSQLType
93124>>>>            Move True                                    to aColumnType[i].bCanEditSize
93125>>>>            Move True                                    to aColumnType[i].bNativeDataType
93126>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93127>>>>            Move 1                                       to aColumnType[i].iMinSize
93128>>>>            Move 8000                                    to aColumnType[i].nMaxSize
93129>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93130>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93131>>>>            Move 8000                                    to aColumnType[i].sPrecision
93132>>>>            Increment i
93133>>>>
93133>>>>            Move "date"                                  to aColumnType[i].sSQLType
93134>>>>            Move 91                                      to aColumnType[i].iSQLType
93135>>>>            Move False                                   to aColumnType[i].bCanEditSize
93136>>>>            Move True                                    to aColumnType[i].bNativeDataType
93137>>>>            Move 0                                       to aColumnType[i].iDefaultSize
93138>>>>            Move 0                                       to aColumnType[i].iMinSize
93139>>>>            Move 0                                       to aColumnType[i].nMaxSize
93140>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
93141>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
93142>>>>            Move 6                                       to aColumnType[i].sPrecision
93143>>>>            Increment i
93144>>>>
93144>>>>            Move "datetime"                              to aColumnType[i].sSQLType
93145>>>>            Move 93                                      to aColumnType[i].iSQLType
93146>>>>            Move False                                   to aColumnType[i].bCanEditSize
93147>>>>            Move True                                    to aColumnType[i].bNativeDataType
93148>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93149>>>>            Move -1                                      to aColumnType[i].iMinSize
93150>>>>            Move -1                                      to aColumnType[i].nMaxSize
93151>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
93152>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
93153>>>>            Move 23                                      to aColumnType[i].sPrecision
93154>>>>            Increment i
93155>>>>
93155>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
93156>>>>            Move -200                                    to aColumnType[i].iSQLType
93157>>>>            Move True                                    to aColumnType[i].bCanEditSize
93158>>>>            Move True                                    to aColumnType[i].bNativeDataType
93159>>>>            Move 23                                      to aColumnType[i].iDefaultSize
93160>>>>            Move 23                                      to aColumnType[i].iMinSize
93161>>>>            Move 23                                      to aColumnType[i].nMaxSize
93162>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
93163>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
93164>>>>            Move 23                                      to aColumnType[i].sPrecision
93165>>>>            Increment i
93166>>>>
93166>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
93167>>>>            Move -155                                    to aColumnType[i].iSQLType
93168>>>>            Move True                                    to aColumnType[i].bCanEditSize
93169>>>>            Move True                                    to aColumnType[i].bNativeDataType
93170>>>>            Move 34                                      to aColumnType[i].iDefaultSize
93171>>>>            Move 34                                      to aColumnType[i].iMinSize
93172>>>>            Move 34                                      to aColumnType[i].nMaxSize
93173>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
93174>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
93175>>>>            Move 34                                      to aColumnType[i].sPrecision
93176>>>>            Increment i
93177>>>>
93177>>>>            Move "decimal"                               to aColumnType[i].sSQLType
93178>>>>            Move 3                                       to aColumnType[i].iSQLType
93179>>>>            Move True                                    to aColumnType[i].bCanEditSize
93180>>>>            Move True                                    to aColumnType[i].bNativeDataType
93181>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93182>>>>            Move 1                                       to aColumnType[i].iMinSize
93183>>>>            Move 14                                      to aColumnType[i].nMaxSize
93184>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93185>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93186>>>>            Move 14                                      to aColumnType[i].sPrecision
93187>>>>            Increment i
93188>>>>
93188>>>>            Move "float"                                 to aColumnType[i].sSQLType
93189>>>>            Move 6                                       to aColumnType[i].iSQLType
93190>>>>            Move True                                    to aColumnType[i].bCanEditSize
93191>>>>            Move True                                    to aColumnType[i].bNativeDataType
93192>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93193>>>>            Move 1                                       to aColumnType[i].iMinSize
93194>>>>            Move 14                                      to aColumnType[i].nMaxSize
93195>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93196>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93197>>>>            Move 14                                      to aColumnType[i].sPrecision
93198>>>>            Increment i
93199>>>>
93199>>>>            Move "image"                                 to aColumnType[i].sSQLType
93200>>>>            Move -4                                      to aColumnType[i].iSQLType
93201>>>>            Move True                                    to aColumnType[i].bCanEditSize
93202>>>>            Move True                                    to aColumnType[i].bNativeDataType
93203>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
93204>>>>            Move 1                                       to aColumnType[i].iMinSize
93205>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
93206>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
93207>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
93208>>>>            Move 2000000000                              to aColumnType[i].sPrecision
93209>>>>            Increment i
93210>>>>
93210>>>>            Move "int"                                   to aColumnType[i].sSQLType
93211>>>>            Move 4                                       to aColumnType[i].iSQLType
93212>>>>            Move True                                    to aColumnType[i].bCanEditSize
93213>>>>            Move True                                    to aColumnType[i].bNativeDataType
93214>>>>            Move 10                                      to aColumnType[i].iDefaultSize
93215>>>>            Move 1                                       to aColumnType[i].iMinSize
93216>>>>            Move 10                                      to aColumnType[i].nMaxSize
93217>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93218>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93219>>>>            Move 10                                      to aColumnType[i].sPrecision
93220>>>>            Increment i
93221>>>>
93221>>>>            Move "money"                                 to aColumnType[i].sSQLType
93222>>>>            Move -204                                    to aColumnType[i].iSQLType
93223>>>>            Move False                                   to aColumnType[i].bCanEditSize
93224>>>>            Move True                                    to aColumnType[i].bNativeDataType
93225>>>>            Move 0                                       to aColumnType[i].iDefaultSize
93226>>>>            Move 0                                       to aColumnType[i].iMinSize
93227>>>>            Move 0                                       to aColumnType[i].nMaxSize
93228>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93229>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93230>>>>            Move 1                                       to aColumnType[i].sPrecision
93231>>>>            Increment i
93232>>>>
93232>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
93233>>>>            Move -8                                      to aColumnType[i].iSQLType
93234>>>>            Move True                                    to aColumnType[i].bCanEditSize
93235>>>>            Move True                                    to aColumnType[i].bNativeDataType
93236>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93237>>>>            Move 1                                       to aColumnType[i].iMinSize
93238>>>>            Move 4000                                    to aColumnType[i].nMaxSize
93239>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93240>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93241>>>>            Move 4000                                    to aColumnType[i].sPrecision
93242>>>>            Increment i
93243>>>>
93243>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
93244>>>>            Move -10                                     to aColumnType[i].iSQLType
93245>>>>            Move True                                    to aColumnType[i].bCanEditSize
93246>>>>            Move True                                    to aColumnType[i].bNativeDataType
93247>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
93248>>>>            Move 1                                       to aColumnType[i].iMinSize
93249>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
93250>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
93251>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
93252>>>>            Move 2000000000                              to aColumnType[i].sPrecision
93253>>>>            Increment i
93254>>>>
93254>>>>            Move "numeric"                               to aColumnType[i].sSQLType
93255>>>>            Move 2                                       to aColumnType[i].iSQLType
93256>>>>            Move True                                    to aColumnType[i].bCanEditSize
93257>>>>            Move True                                    to aColumnType[i].bNativeDataType
93258>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93259>>>>            Move 1                                       to aColumnType[i].iMinSize
93260>>>>            Move 14                                      to aColumnType[i].nMaxSize
93261>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93262>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93263>>>>            Move 14                                      to aColumnType[i].sPrecision
93264>>>>            Increment i
93265>>>>
93265>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
93266>>>>            Move -9                                      to aColumnType[i].iSQLType
93267>>>>            Move True                                    to aColumnType[i].bCanEditSize
93268>>>>            Move True                                    to aColumnType[i].bNativeDataType
93269>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93270>>>>            Move 1                                       to aColumnType[i].iMinSize
93271>>>>            Move 4000                                    to aColumnType[i].nMaxSize
93272>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93273>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93274>>>>            Move 4000                                    to aColumnType[i].sPrecision
93275>>>>            Increment i
93276>>>>
93276>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
93277>>>>            Move -202                                    to aColumnType[i].iSQLType
93278>>>>            Move True                                    to aColumnType[i].bCanEditSize
93279>>>>            Move True                                    to aColumnType[i].bNativeDataType
93280>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
93281>>>>            Move 1                                       to aColumnType[i].iMinSize
93282>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
93283>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93284>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93285>>>>            Move 2000000000                              to aColumnType[i].sPrecision
93286>>>>            Increment i
93287>>>>
93287>>>>            Move "real"                                  to aColumnType[i].sSQLType
93288>>>>            Move 7                                       to aColumnType[i].iSQLType
93289>>>>            Move True                                    to aColumnType[i].bCanEditSize
93290>>>>            Move True                                    to aColumnType[i].bNativeDataType
93291>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93292>>>>            Move 1                                       to aColumnType[i].iMinSize
93293>>>>            Move 14                                      to aColumnType[i].nMaxSize
93294>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93295>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93296>>>>            Move 14                                      to aColumnType[i].sPrecision
93297>>>>            Increment i
93298>>>>
93298>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
93299>>>>            Move -206                                    to aColumnType[i].iSQLType
93300>>>>            Move False                                   to aColumnType[i].bCanEditSize
93301>>>>            Move True                                    to aColumnType[i].bNativeDataType
93302>>>>            Move 0                                       to aColumnType[i].iDefaultSize
93303>>>>            Move 0                                       to aColumnType[i].iMinSize
93304>>>>            Move 0                                       to aColumnType[i].nMaxSize
93305>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
93306>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
93307>>>>            Move 1                                       to aColumnType[i].sPrecision
93308>>>>            Increment i
93309>>>>
93309>>>>            Move "smallint"                              to aColumnType[i].sSQLType
93310>>>>            Move 5                                       to aColumnType[i].iSQLType
93311>>>>            Move True                                    to aColumnType[i].bCanEditSize
93312>>>>            Move True                                    to aColumnType[i].bNativeDataType
93313>>>>            Move 5                                       to aColumnType[i].iDefaultSize
93314>>>>            Move 1                                       to aColumnType[i].iMinSize
93315>>>>            Move 5                                       to aColumnType[i].nMaxSize
93316>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93317>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93318>>>>            Move 5                                       to aColumnType[i].sPrecision
93319>>>>            Increment i
93320>>>>
93320>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
93321>>>>            Move -205                                    to aColumnType[i].iSQLType
93322>>>>            Move False                                   to aColumnType[i].bCanEditSize
93323>>>>            Move True                                    to aColumnType[i].bNativeDataType
93324>>>>            Move 0                                       to aColumnType[i].iDefaultSize
93325>>>>            Move 0                                       to aColumnType[i].iMinSize
93326>>>>            Move 0                                       to aColumnType[i].nMaxSize
93327>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93328>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93329>>>>            Move 1                                       to aColumnType[i].sPrecision
93330>>>>            Increment i
93331>>>>
93331>>>>            Move "text"                                  to aColumnType[i].sSQLType
93332>>>>            Move -1                                      to aColumnType[i].iSQLType
93333>>>>            Move True                                    to aColumnType[i].bCanEditSize
93334>>>>            Move True                                    to aColumnType[i].bNativeDataType
93335>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
93336>>>>            Move 1                                       to aColumnType[i].iMinSize
93337>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
93338>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
93339>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
93340>>>>            Move 2000000000                              to aColumnType[i].sPrecision
93341>>>>            Increment i
93342>>>>
93342>>>>            Move "time"                                  to aColumnType[i].sSQLType
93343>>>>            Move -154                                    to aColumnType[i].iSQLType
93344>>>>            Move True                                    to aColumnType[i].bCanEditSize
93345>>>>            Move True                                    to aColumnType[i].bNativeDataType
93346>>>>            Move 10                                      to aColumnType[i].iDefaultSize
93347>>>>            Move 10                                      to aColumnType[i].iMinSize
93348>>>>            Move 19                                      to aColumnType[i].nMaxSize
93349>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93350>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93351>>>>            Move 19                                      to aColumnType[i].sPrecision
93352>>>>            Increment i
93353>>>>
93353>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
93354>>>>            Move -6                                      to aColumnType[i].iSQLType
93355>>>>            Move True                                    to aColumnType[i].bCanEditSize
93356>>>>            Move True                                    to aColumnType[i].bNativeDataType
93357>>>>            Move 3                                       to aColumnType[i].iDefaultSize
93358>>>>            Move 1                                       to aColumnType[i].iMinSize
93359>>>>            Move 3                                       to aColumnType[i].nMaxSize
93360>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93361>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93362>>>>            Move 3                                       to aColumnType[i].sPrecision
93363>>>>            Increment i
93364>>>>
93364>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
93365>>>>            Move -11                                     to aColumnType[i].iSQLType
93366>>>>            Move False                                   to aColumnType[i].bCanEditSize
93367>>>>            Move True                                    to aColumnType[i].bNativeDataType
93368>>>>            Move 0                                       to aColumnType[i].iDefaultSize
93369>>>>            Move 0                                       to aColumnType[i].iMinSize
93370>>>>            Move 0                                       to aColumnType[i].nMaxSize
93371>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93372>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93373>>>>            Move 1                                       to aColumnType[i].sPrecision
93374>>>>            Increment i
93375>>>>
93375>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
93376>>>>            Move -3                                      to aColumnType[i].iSQLType
93377>>>>            Move True                                    to aColumnType[i].bCanEditSize
93378>>>>            Move True                                    to aColumnType[i].bNativeDataType
93379>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
93380>>>>            Move 1                                       to aColumnType[i].iMinSize
93381>>>>            Move 8000                                    to aColumnType[i].nMaxSize
93382>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
93383>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
93384>>>>            Move 8000                                    to aColumnType[i].sPrecision
93385>>>>            Increment i
93386>>>>
93386>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
93387>>>>            Move -203                                    to aColumnType[i].iSQLType
93388>>>>            Move True                                    to aColumnType[i].bCanEditSize
93389>>>>            Move True                                    to aColumnType[i].bNativeDataType
93390>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
93391>>>>            Move 1                                       to aColumnType[i].iMinSize
93392>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
93393>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93394>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93395>>>>            Move 2000000000                              to aColumnType[i].sPrecision
93396>>>>            Increment i
93397>>>>
93397>>>>            Move "varchar"                               to aColumnType[i].sSQLType
93398>>>>            Move 12                                      to aColumnType[i].iSQLType
93399>>>>            Move True                                    to aColumnType[i].bCanEditSize
93400>>>>            Move True                                    to aColumnType[i].bNativeDataType
93401>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93402>>>>            Move 1                                       to aColumnType[i].iMinSize
93403>>>>            Move 8000                                    to aColumnType[i].nMaxSize
93404>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93405>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93406>>>>            Move 8000                                    to aColumnType[i].sPrecision
93407>>>>            Increment i
93408>>>>
93408>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
93409>>>>            Move -201                                    to aColumnType[i].iSQLType
93410>>>>            Move True                                    to aColumnType[i].bCanEditSize
93411>>>>            Move True                                    to aColumnType[i].bNativeDataType
93412>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
93413>>>>            Move 1                                       to aColumnType[i].iMinSize
93414>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
93415>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
93416>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
93417>>>>            Move 2000000000                              to aColumnType[i].sPrecision
93418>>>>            Increment i
93419>>>>
93419>>>>            Move "xml"                                   to aColumnType[i].sSQLType
93420>>>>            Move -152                                    to aColumnType[i].iSQLType
93421>>>>            Move True                                    to aColumnType[i].bCanEditSize
93422>>>>            Move True                                    to aColumnType[i].bNativeDataType
93423>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
93424>>>>            Move 1                                       to aColumnType[i].iMinSize
93425>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
93426>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
93427>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
93428>>>>            Move 2000000000                              to aColumnType[i].sPrecision
93429>>>>            Increment i
93430>>>>
93430>>>>
93430>>>            
93430>>>//            Move SQL_BIGINT         to ColumnType[i].iSQLType
93430>>>//            Move "bigint"           to ColumnType[i].sSQLType
93430>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93430>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
93430>>>//            Move "14.0"             to ColumnType[i].sPrecision
93430>>>//            Move True               to ColumnType[i].bCanEditSize
93430>>>//            Increment i
93430>>>//
93430>>>//            Move SQL_BINARY         to ColumnType[i].iSQLType
93430>>>//            Move "binary"           to ColumnType[i].sSQLType
93430>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
93430>>>//            Move "Binary"           to ColumnType[i].sDataFlexType
93430>>>//            Move "8000"             to ColumnType[i].sPrecision
93430>>>//            Increment i
93430>>>//
93430>>>//            Move SQL_BIT            to ColumnType[i].iSQLType
93430>>>//            Move "bit"              to ColumnType[i].sSQLType
93430>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
93430>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
93430>>>//            Move "1.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
93430>>>//            Move True               to ColumnType[i].bCanEditSize
93430>>>//            Increment i
93430>>>//
93430>>>//            Move SQL_CHAR           to ColumnType[i].iSQLType
93430>>>//            Move "char"             to ColumnType[i].sSQLType
93430>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
93430>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
93430>>>//            Move "8000"             to ColumnType[i].sPrecision
93430>>>//            Increment i
93430>>>//
93430>>>//            Move SQL_DATE           to ColumnType[i].iSQLType
93430>>>//            Move "date"             to ColumnType[i].sSQLType
93430>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
93430>>>//            Move "Date"             to ColumnType[i].sDataFlexType
93430>>>//            Move "6.0"              to ColumnType[i].sPrecision
93430>>>//            Move True               to ColumnType[i].bCanEditSize
93430>>>//            Increment i
93430>>>//
93430>>>//            Move SQL_DATETIME       to ColumnType[i].iSQLType
93430>>>//            Move "datetime"         to ColumnType[i].sSQLType
93430>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
93430>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
93430>>>//            Move "23.3"             to ColumnType[i].sPrecision
93430>>>//            Move True               to ColumnType[i].bCanEditSize
93430>>>//            Increment i
93430>>>//
93430>>>//            Move SQL_TYPE_TIMESTAMP2 to ColumnType[i].iSQLType
93430>>>//            Move "datetime2"         to ColumnType[i].sSQLType
93430>>>//            Move DF_DATETIME         to ColumnType[i].iDataFlexType
93430>>>//            Move "DateTime"          to ColumnType[i].sDataFlexType
93430>>>//            Move "23.6"              to ColumnType[i].sPrecision
93430>>>//            Move True                to ColumnType[i].bCanEditSize
93430>>>//            Increment i
93430>>>//
93430>>>//            Move SQL_SS_TIMESTAMPOFFSET to ColumnType[i].iSQLType
93430>>>//            Move "datetimeoffset"       to ColumnType[i].sSQLType
93430>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
93430>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
93430>>>//            Move "34.0"                 to ColumnType[i].sPrecision
93430>>>//            Move True                   to ColumnType[i].bCanEditSize
93430>>>//            Increment i
93430>>>//
93430>>>//            Move SQL_DECIMAL        to ColumnType[i].iSQLType
93430>>>//            Move "decimal"          to ColumnType[i].sSQLType
93430>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93430>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
93430>>>//            Move "14.8"             to ColumnType[i].sPrecision
93430>>>//            Increment i
93430>>>//
93430>>>//            Move SQL_FLOAT          to ColumnType[i].iSQLType
93430>>>//            Move "float"            to ColumnType[i].sSQLType
93430>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93430>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
93430>>>//            Move "14.8"             to ColumnType[i].sPrecision
93430>>>//            Increment i
93430>>>//
93430>>>//            Move SQL_INTEGER        to ColumnType[i].iSQLType
93430>>>//            Move "int"              to ColumnType[i].sSQLType
93430>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93430>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
93430>>>//            Move "8.0"              to ColumnType[i].sPrecision
93430>>>//            Move True               to ColumnType[i].bCanEditSize
93430>>>//            Increment i
93430>>>//
93430>>>//            Move SQL_TYPE_MONEY     to ColumnType[i].iSQLType
93430>>>//            Move "money"            to ColumnType[i].sSQLType
93430>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93430>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
93430>>>//            Move "15.4"             to ColumnType[i].sPrecision // Studio 18.0 (!)
93430>>>//            Increment i
93430>>>//
93430>>>//            Move SQL_WCHAR          to ColumnType[i].iSQLType
93430>>>//            Move "nchar"            to ColumnType[i].sSQLType
93430>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
93430>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
93430>>>//            Move "4000"             to ColumnType[i].sPrecision
93430>>>//            Increment i
93430>>>//
93430>>>//            Move SQL_WLONGVARCHAR   to ColumnType[i].iSQLType
93430>>>//            Move "ntext"            to ColumnType[i].sSQLType
93430>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
93430>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
93430>>>//            Move "16384"            to ColumnType[i].sPrecision
93430>>>//            Increment i
93430>>>//
93430>>>//            Move SQL_NUMERIC        to ColumnType[i].iSQLType
93430>>>//            Move "numeric"          to ColumnType[i].sSQLType
93430>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93430>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
93430>>>//            Move "14.8"             to ColumnType[i].sPrecision
93430>>>//            Increment i
93430>>>//
93430>>>//            Move SQL_WVARCHAR       to ColumnType[i].iSQLType
93430>>>//            Move "nvarchar"         to ColumnType[i].sSQLType
93430>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
93430>>>//            Move "Text"             to ColumnType[i].sDataFlexType
93430>>>//            Move "4000"             to ColumnType[i].sPrecision
93430>>>//            Increment i
93430>>>//
93430>>>//            Move SQL_VARCHARMAX     to ColumnType[i].iSQLType
93430>>>//            Move "nvarchar(max)"    to ColumnType[i].sSQLType
93430>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
93430>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
93430>>>//            Move "16384"            to ColumnType[i].sPrecision
93430>>>//            Move True               to ColumnType[i].bCanEditSize
93430>>>//            Increment i
93430>>>//
93430>>>//            Move SQL_REAL           to ColumnType[i].iSQLType
93430>>>//            Move "real"             to ColumnType[i].sSQLType
93430>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93430>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
93430>>>//            Move "14.8"             to ColumnType[i].sPrecision
93430>>>//            Increment i
93430>>>//
93430>>>//            Move SQL_TYPE_SMALLDATETIME to ColumnType[i].iSQLType
93430>>>//            Move "smalldatetime"        to ColumnType[i].sSQLType
93430>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
93430>>>//            Move "DATETIME"             to ColumnType[i].sDataFlexType
93430>>>//            Move "23.0"                 to ColumnType[i].sPrecision
93430>>>//            Move True                   to ColumnType[i].bCanEditSize
93430>>>//            Increment i
93430>>>//
93430>>>//            Move SQL_SMALLINT       to ColumnType[i].iSQLType
93430>>>//            Move "smallint"         to ColumnType[i].sSQLType
93430>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93430>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
93430>>>//            Move "4.0"              to ColumnType[i].sPrecision
93430>>>//            Move True               to ColumnType[i].bCanEditSize
93430>>>//            Increment i
93430>>>//
93430>>>//            Move SQL_TYPE_SMALLMONEY to ColumnType[i].iSQLType
93430>>>//            Move "smallmoney"        to ColumnType[i].sSQLType
93430>>>//            Move DF_BCD              to ColumnType[i].iDataFlexType
93430>>>//            Move "NUMERIC"           to ColumnType[i].sDataFlexType
93430>>>//            Move "10.0"              to ColumnType[i].sPrecision
93430>>>//            Increment i
93430>>>//
93430>>>//            Move SQL_TEXT           to ColumnType[i].iSQLType
93430>>>//            Move "text"             to ColumnType[i].sSQLType
93430>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
93430>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
93430>>>//            Move "8000"             to ColumnType[i].sPrecision
93430>>>//            Move True               to ColumnType[i].bCanEditSize
93430>>>//            Increment i
93430>>>//
93430>>>//            Move SQL_TIME           to ColumnType[i].iSQLType
93430>>>//            Move "time"             to ColumnType[i].sSQLType
93430>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
93430>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
93430>>>//            Move "19.0"             to ColumnType[i].sPrecision
93430>>>//            Move True               to ColumnType[i].bCanEditSize
93430>>>//            Increment i
93430>>>//
93430>>>//            Move SQL_TINYINT        to ColumnType[i].iSQLType
93430>>>//            Move "tinyint"          to ColumnType[i].sSQLType
93430>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93430>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
93430>>>//            Move "2.0"              to ColumnType[i].sPrecision
93430>>>//            Move True               to ColumnType[i].bCanEditSize
93430>>>//            Increment i
93430>>>//
93430>>>//            Move SQL_GUID           to ColumnType[i].iSQLType
93430>>>//            Move "uniqueidentifier" to ColumnType[i].sSQLType
93430>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
93430>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
93430>>>//            Move "36"               to ColumnType[i].sPrecision
93430>>>//            Move True               to ColumnType[i].bCanEditSize
93430>>>//            Increment i
93430>>>//
93430>>>//            Move SQL_VARBINARY      to ColumnType[i].iSQLType
93430>>>//            Move "varbinary"        to ColumnType[i].sSQLType
93430>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
93430>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
93430>>>//            Move "16384"            to ColumnType[i].sPrecision
93430>>>//            Increment i
93430>>>//
93430>>>//            Move SQL_LONGVARBINARY  to ColumnType[i].iSQLType
93430>>>//            Move "varbinary(max)"   to ColumnType[i].sSQLType
93430>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
93430>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
93430>>>//            Move "16384"            to ColumnType[i].sPrecision
93430>>>//            Move True               to ColumnType[i].bCanEditSize
93430>>>//            Increment i
93430>>>//
93430>>>//            Move SQL_VARCHAR        to ColumnType[i].iSQLType
93430>>>//            Move "varchar"          to ColumnType[i].sSQLType
93430>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
93430>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
93430>>>//            Move "8000"             to ColumnType[i].sPrecision
93430>>>//            Increment i
93430>>>//
93430>>>//            Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
93430>>>//            Move "varchar(max)"     to ColumnType[i].sSQLType
93430>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
93430>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
93430>>>//            Move "16384"            to ColumnType[i].sPrecision
93430>>>//            Move True               to ColumnType[i].bCanEditSize
93430>>>//            Increment i
93430>>>//
93430>>>//            Move SQL_SS_XML         to ColumnType[i].iSQLType
93430>>>//            Move "xml"              to ColumnType[i].sSQLType
93430>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
93430>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
93430>>>//            Move "16384"            to ColumnType[i].sPrecision
93430>>>//            Increment i
93430>>>//
93430>>>//            Move SQL_TYPE_DATE      to ColumnType[i].iSQLType
93430>>>//            Move "DATE"             to ColumnType[i].sSQLType
93430>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
93430>>>//            Move "date"             to ColumnType[i].sDataFlexType
93430>>>//            Move "6.0"              to ColumnType[i].sPrecision
93430>>>//            Move True               to ColumnType[i].bCanEditSize
93430>>>//            Increment i
93430>>>//
93430>>>//            Move SQL_TYPE_TIME      to ColumnType[i].iSQLType
93430>>>//            Move "time"             to ColumnType[i].sSQLType
93430>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
93430>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
93430>>>//            Move "8.7"              to ColumnType[i].sPrecision
93430>>>//            Move True               to ColumnType[i].bCanEditSize
93430>>>//            Increment i
93430>>>//
93430>>>//            Move SQL_TYPE_TIMESTAMP to ColumnType[i].iSQLType
93430>>>//            Move "datetime"         to ColumnType[i].sSQLType
93430>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
93430>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
93430>>>//            Move "23.6"             to ColumnType[i].sPrecision
93430>>>//            Move True               to ColumnType[i].bCanEditSize
93430>>>//            Increment i
93430>>>
93430>>>        End
93430>>>>
93430>>>
93430>>>        // Mertech SQLFlex driver
93430>>>        If (sDriverID = SQLFLEX) Begin
93432>>>
Including file: sql_drv_DriverDef.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\sql_drv_DriverDef.inc)
93432>>>>// Generated By The Database Update Framework
93432>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\sql_drv_DriverDef.xml
93432>>>>// Driver COLUMN DATA TYPES
93432>>>>//
93432>>>>// Created: 2018-03-14 23:47:46.885
93432>>>>
93432>>>>            Move "bigint"                                to aColumnType[i].sSQLType
93433>>>>            Move -5                                      to aColumnType[i].iSQLType
93434>>>>            Move True                                    to aColumnType[i].bCanEditSize
93435>>>>            Move True                                    to aColumnType[i].bNativeDataType
93436>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93437>>>>            Move 1                                       to aColumnType[i].iMinSize
93438>>>>            Move 14                                      to aColumnType[i].nMaxSize
93439>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93440>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93441>>>>            Move 14                                      to aColumnType[i].sPrecision
93442>>>>            Increment i
93443>>>>
93443>>>>            Move "binary"                                to aColumnType[i].sSQLType
93444>>>>            Move -2                                      to aColumnType[i].iSQLType
93445>>>>            Move True                                    to aColumnType[i].bCanEditSize
93446>>>>            Move True                                    to aColumnType[i].bNativeDataType
93447>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93448>>>>            Move 1                                       to aColumnType[i].iMinSize
93449>>>>            Move 8000                                    to aColumnType[i].nMaxSize
93450>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
93451>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
93452>>>>            Move 8000                                    to aColumnType[i].sPrecision
93453>>>>            Increment i
93454>>>>
93454>>>>            Move "bit"                                   to aColumnType[i].sSQLType
93455>>>>            Move -7                                      to aColumnType[i].iSQLType
93456>>>>            Move False                                   to aColumnType[i].bCanEditSize
93457>>>>            Move True                                    to aColumnType[i].bNativeDataType
93458>>>>            Move 1                                       to aColumnType[i].iDefaultSize
93459>>>>            Move -1                                      to aColumnType[i].iMinSize
93460>>>>            Move -1                                      to aColumnType[i].nMaxSize
93461>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93462>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93463>>>>            Move -1                                      to aColumnType[i].sPrecision
93464>>>>            Increment i
93465>>>>
93465>>>>            Move "char"                                  to aColumnType[i].sSQLType
93466>>>>            Move 1                                       to aColumnType[i].iSQLType
93467>>>>            Move True                                    to aColumnType[i].bCanEditSize
93468>>>>            Move True                                    to aColumnType[i].bNativeDataType
93469>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93470>>>>            Move 1                                       to aColumnType[i].iMinSize
93471>>>>            Move 8000                                    to aColumnType[i].nMaxSize
93472>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93473>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93474>>>>            Move 8000                                    to aColumnType[i].sPrecision
93475>>>>            Increment i
93476>>>>
93476>>>>            Move "date"                                  to aColumnType[i].sSQLType
93477>>>>            Move 40                                      to aColumnType[i].iSQLType
93478>>>>            Move False                                   to aColumnType[i].bCanEditSize
93479>>>>            Move True                                    to aColumnType[i].bNativeDataType
93480>>>>            Move 12                                      to aColumnType[i].iDefaultSize
93481>>>>            Move -1                                      to aColumnType[i].iMinSize
93482>>>>            Move -1                                      to aColumnType[i].nMaxSize
93483>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93484>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93485>>>>            Move -1                                      to aColumnType[i].sPrecision
93486>>>>            Increment i
93487>>>>
93487>>>>            Move "datetime"                              to aColumnType[i].sSQLType
93488>>>>            Move 11                                      to aColumnType[i].iSQLType
93489>>>>            Move True                                    to aColumnType[i].bCanEditSize
93490>>>>            Move True                                    to aColumnType[i].bNativeDataType
93491>>>>            Move 6                                       to aColumnType[i].iDefaultSize
93492>>>>            Move 6                                       to aColumnType[i].iMinSize
93493>>>>            Move 23                                      to aColumnType[i].nMaxSize
93494>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93495>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93496>>>>            Move 23                                      to aColumnType[i].sPrecision
93497>>>>            Increment i
93498>>>>
93498>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
93499>>>>            Move 42                                      to aColumnType[i].iSQLType
93500>>>>            Move True                                    to aColumnType[i].bCanEditSize
93501>>>>            Move True                                    to aColumnType[i].bNativeDataType
93502>>>>            Move 6                                       to aColumnType[i].iDefaultSize
93503>>>>            Move 6                                       to aColumnType[i].iMinSize
93504>>>>            Move 23                                      to aColumnType[i].nMaxSize
93505>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93506>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93507>>>>            Move 23                                      to aColumnType[i].sPrecision
93508>>>>            Increment i
93509>>>>
93509>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
93510>>>>            Move 43                                      to aColumnType[i].iSQLType
93511>>>>            Move True                                    to aColumnType[i].bCanEditSize
93512>>>>            Move True                                    to aColumnType[i].bNativeDataType
93513>>>>            Move 12                                      to aColumnType[i].iDefaultSize
93514>>>>            Move 12                                      to aColumnType[i].iMinSize
93515>>>>            Move 23                                      to aColumnType[i].nMaxSize
93516>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93517>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93518>>>>            Move 23                                      to aColumnType[i].sPrecision
93519>>>>            Increment i
93520>>>>
93520>>>>            Move "decimal"                               to aColumnType[i].sSQLType
93521>>>>            Move 3                                       to aColumnType[i].iSQLType
93522>>>>            Move True                                    to aColumnType[i].bCanEditSize
93523>>>>            Move True                                    to aColumnType[i].bNativeDataType
93524>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93525>>>>            Move 1                                       to aColumnType[i].iMinSize
93526>>>>            Move 14                                      to aColumnType[i].nMaxSize
93527>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93528>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93529>>>>            Move 14                                      to aColumnType[i].sPrecision
93530>>>>            Increment i
93531>>>>
93531>>>>            Move "float"                                 to aColumnType[i].sSQLType
93532>>>>            Move 6                                       to aColumnType[i].iSQLType
93533>>>>            Move True                                    to aColumnType[i].bCanEditSize
93534>>>>            Move True                                    to aColumnType[i].bNativeDataType
93535>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93536>>>>            Move 1                                       to aColumnType[i].iMinSize
93537>>>>            Move 14                                      to aColumnType[i].nMaxSize
93538>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93539>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93540>>>>            Move 14                                      to aColumnType[i].sPrecision
93541>>>>            Increment i
93542>>>>
93542>>>>            Move "geography"                             to aColumnType[i].sSQLType
93543>>>>            Move 130                                     to aColumnType[i].iSQLType
93544>>>>            Move False                                   to aColumnType[i].bCanEditSize
93545>>>>            Move True                                    to aColumnType[i].bNativeDataType
93546>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93547>>>>            Move -1                                      to aColumnType[i].iMinSize
93548>>>>            Move -1                                      to aColumnType[i].nMaxSize
93549>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93550>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93551>>>>            Move -1                                      to aColumnType[i].sPrecision
93552>>>>            Increment i
93553>>>>
93553>>>>            Move "geometry"                              to aColumnType[i].sSQLType
93554>>>>            Move 129                                     to aColumnType[i].iSQLType
93555>>>>            Move False                                   to aColumnType[i].bCanEditSize
93556>>>>            Move True                                    to aColumnType[i].bNativeDataType
93557>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93558>>>>            Move -1                                      to aColumnType[i].iMinSize
93559>>>>            Move -1                                      to aColumnType[i].nMaxSize
93560>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93561>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93562>>>>            Move -1                                      to aColumnType[i].sPrecision
93563>>>>            Increment i
93564>>>>
93564>>>>            Move "hierarchyid"                           to aColumnType[i].sSQLType
93565>>>>            Move 128                                     to aColumnType[i].iSQLType
93566>>>>            Move False                                   to aColumnType[i].bCanEditSize
93567>>>>            Move True                                    to aColumnType[i].bNativeDataType
93568>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93569>>>>            Move -1                                      to aColumnType[i].iMinSize
93570>>>>            Move -1                                      to aColumnType[i].nMaxSize
93571>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93572>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93573>>>>            Move -1                                      to aColumnType[i].sPrecision
93574>>>>            Increment i
93575>>>>
93575>>>>            Move "image"                                 to aColumnType[i].sSQLType
93576>>>>            Move -4                                      to aColumnType[i].iSQLType
93577>>>>            Move True                                    to aColumnType[i].bCanEditSize
93578>>>>            Move True                                    to aColumnType[i].bNativeDataType
93579>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93580>>>>            Move 1                                       to aColumnType[i].iMinSize
93581>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93582>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
93583>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
93584>>>>            Move 16384                                   to aColumnType[i].sPrecision
93585>>>>            Increment i
93586>>>>
93586>>>>            Move "int"                                   to aColumnType[i].sSQLType
93587>>>>            Move 4                                       to aColumnType[i].iSQLType
93588>>>>            Move True                                    to aColumnType[i].bCanEditSize
93589>>>>            Move True                                    to aColumnType[i].bNativeDataType
93590>>>>            Move 11                                      to aColumnType[i].iDefaultSize
93591>>>>            Move 1                                       to aColumnType[i].iMinSize
93592>>>>            Move 11                                      to aColumnType[i].nMaxSize
93593>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93594>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93595>>>>            Move 11                                      to aColumnType[i].sPrecision
93596>>>>            Increment i
93597>>>>
93597>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
93598>>>>            Move -8                                      to aColumnType[i].iSQLType
93599>>>>            Move True                                    to aColumnType[i].bCanEditSize
93600>>>>            Move True                                    to aColumnType[i].bNativeDataType
93601>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93602>>>>            Move 1                                       to aColumnType[i].iMinSize
93603>>>>            Move 4000                                    to aColumnType[i].nMaxSize
93604>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93605>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93606>>>>            Move 4000                                    to aColumnType[i].sPrecision
93607>>>>            Increment i
93608>>>>
93608>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
93609>>>>            Move -10                                     to aColumnType[i].iSQLType
93610>>>>            Move True                                    to aColumnType[i].bCanEditSize
93611>>>>            Move True                                    to aColumnType[i].bNativeDataType
93612>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93613>>>>            Move 1                                       to aColumnType[i].iMinSize
93614>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93615>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
93616>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
93617>>>>            Move 16384                                   to aColumnType[i].sPrecision
93618>>>>            Increment i
93619>>>>
93619>>>>            Move "numeric"                               to aColumnType[i].sSQLType
93620>>>>            Move 2                                       to aColumnType[i].iSQLType
93621>>>>            Move True                                    to aColumnType[i].bCanEditSize
93622>>>>            Move True                                    to aColumnType[i].bNativeDataType
93623>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93624>>>>            Move 1                                       to aColumnType[i].iMinSize
93625>>>>            Move 14                                      to aColumnType[i].nMaxSize
93626>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93627>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93628>>>>            Move 14                                      to aColumnType[i].sPrecision
93629>>>>            Increment i
93630>>>>
93630>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
93631>>>>            Move -9                                      to aColumnType[i].iSQLType
93632>>>>            Move True                                    to aColumnType[i].bCanEditSize
93633>>>>            Move True                                    to aColumnType[i].bNativeDataType
93634>>>>            Move 1                                       to aColumnType[i].iDefaultSize
93635>>>>            Move 1                                       to aColumnType[i].iMinSize
93636>>>>            Move 4000                                    to aColumnType[i].nMaxSize
93637>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93638>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93639>>>>            Move 4000                                    to aColumnType[i].sPrecision
93640>>>>            Increment i
93641>>>>
93641>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
93642>>>>            Move -100                                    to aColumnType[i].iSQLType
93643>>>>            Move True                                    to aColumnType[i].bCanEditSize
93644>>>>            Move True                                    to aColumnType[i].bNativeDataType
93645>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93646>>>>            Move 1                                       to aColumnType[i].iMinSize
93647>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93648>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93649>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93650>>>>            Move 16384                                   to aColumnType[i].sPrecision
93651>>>>            Increment i
93652>>>>
93652>>>>            Move "real"                                  to aColumnType[i].sSQLType
93653>>>>            Move 7                                       to aColumnType[i].iSQLType
93654>>>>            Move True                                    to aColumnType[i].bCanEditSize
93655>>>>            Move True                                    to aColumnType[i].bNativeDataType
93656>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93657>>>>            Move 1                                       to aColumnType[i].iMinSize
93658>>>>            Move 14                                      to aColumnType[i].nMaxSize
93659>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93660>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93661>>>>            Move 14                                      to aColumnType[i].sPrecision
93662>>>>            Increment i
93663>>>>
93663>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
93664>>>>            Move 58                                      to aColumnType[i].iSQLType
93665>>>>            Move True                                    to aColumnType[i].bCanEditSize
93666>>>>            Move True                                    to aColumnType[i].bNativeDataType
93667>>>>            Move 12                                      to aColumnType[i].iDefaultSize
93668>>>>            Move 12                                      to aColumnType[i].iMinSize
93669>>>>            Move 23                                      to aColumnType[i].nMaxSize
93670>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93671>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93672>>>>            Move 23                                      to aColumnType[i].sPrecision
93673>>>>            Increment i
93674>>>>
93674>>>>            Move "smallint"                              to aColumnType[i].sSQLType
93675>>>>            Move 5                                       to aColumnType[i].iSQLType
93676>>>>            Move True                                    to aColumnType[i].bCanEditSize
93677>>>>            Move True                                    to aColumnType[i].bNativeDataType
93678>>>>            Move 6                                       to aColumnType[i].iDefaultSize
93679>>>>            Move -1                                      to aColumnType[i].iMinSize
93680>>>>            Move 6                                       to aColumnType[i].nMaxSize
93681>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93682>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93683>>>>            Move 6                                       to aColumnType[i].sPrecision
93684>>>>            Increment i
93685>>>>
93685>>>>            Move "sql_variant"                           to aColumnType[i].sSQLType
93686>>>>            Move -150                                    to aColumnType[i].iSQLType
93687>>>>            Move False                                   to aColumnType[i].bCanEditSize
93688>>>>            Move True                                    to aColumnType[i].bNativeDataType
93689>>>>            Move 8016                                    to aColumnType[i].iDefaultSize
93690>>>>            Move -1                                      to aColumnType[i].iMinSize
93691>>>>            Move -1                                      to aColumnType[i].nMaxSize
93692>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93693>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93694>>>>            Move -1                                      to aColumnType[i].sPrecision
93695>>>>            Increment i
93696>>>>
93696>>>>            Move "text"                                  to aColumnType[i].sSQLType
93697>>>>            Move -1                                      to aColumnType[i].iSQLType
93698>>>>            Move True                                    to aColumnType[i].bCanEditSize
93699>>>>            Move True                                    to aColumnType[i].bNativeDataType
93700>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93701>>>>            Move 1                                       to aColumnType[i].iMinSize
93702>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93703>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
93704>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
93705>>>>            Move 16384                                   to aColumnType[i].sPrecision
93706>>>>            Increment i
93707>>>>
93707>>>>            Move "time"                                  to aColumnType[i].sSQLType
93708>>>>            Move 41                                      to aColumnType[i].iSQLType
93709>>>>            Move True                                    to aColumnType[i].bCanEditSize
93710>>>>            Move True                                    to aColumnType[i].bNativeDataType
93711>>>>            Move 8                                       to aColumnType[i].iDefaultSize
93712>>>>            Move 8                                       to aColumnType[i].iMinSize
93713>>>>            Move 16                                      to aColumnType[i].nMaxSize
93714>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93715>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93716>>>>            Move 16                                      to aColumnType[i].sPrecision
93717>>>>            Increment i
93718>>>>
93718>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
93719>>>>            Move 93                                      to aColumnType[i].iSQLType
93720>>>>            Move False                                   to aColumnType[i].bCanEditSize
93721>>>>            Move True                                    to aColumnType[i].bNativeDataType
93722>>>>            Move 8                                       to aColumnType[i].iDefaultSize
93723>>>>            Move -1                                      to aColumnType[i].iMinSize
93724>>>>            Move -1                                      to aColumnType[i].nMaxSize
93725>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
93726>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
93727>>>>            Move -1                                      to aColumnType[i].sPrecision
93728>>>>            Increment i
93729>>>>
93729>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
93730>>>>            Move -6                                      to aColumnType[i].iSQLType
93731>>>>            Move True                                    to aColumnType[i].bCanEditSize
93732>>>>            Move True                                    to aColumnType[i].bNativeDataType
93733>>>>            Move 3                                       to aColumnType[i].iDefaultSize
93734>>>>            Move -1                                      to aColumnType[i].iMinSize
93735>>>>            Move 3                                       to aColumnType[i].nMaxSize
93736>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93737>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93738>>>>            Move 3                                       to aColumnType[i].sPrecision
93739>>>>            Increment i
93740>>>>
93740>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
93741>>>>            Move -11                                     to aColumnType[i].iSQLType
93742>>>>            Move False                                   to aColumnType[i].bCanEditSize
93743>>>>            Move True                                    to aColumnType[i].bNativeDataType
93744>>>>            Move 38                                      to aColumnType[i].iDefaultSize
93745>>>>            Move -1                                      to aColumnType[i].iMinSize
93746>>>>            Move -1                                      to aColumnType[i].nMaxSize
93747>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93748>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93749>>>>            Move -1                                      to aColumnType[i].sPrecision
93750>>>>            Increment i
93751>>>>
93751>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
93752>>>>            Move -3                                      to aColumnType[i].iSQLType
93753>>>>            Move True                                    to aColumnType[i].bCanEditSize
93754>>>>            Move True                                    to aColumnType[i].bNativeDataType
93755>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
93756>>>>            Move 1                                       to aColumnType[i].iMinSize
93757>>>>            Move 8000                                    to aColumnType[i].nMaxSize
93758>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
93759>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
93760>>>>            Move 8000                                    to aColumnType[i].sPrecision
93761>>>>            Increment i
93762>>>>
93762>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
93763>>>>            Move -98                                     to aColumnType[i].iSQLType
93764>>>>            Move True                                    to aColumnType[i].bCanEditSize
93765>>>>            Move True                                    to aColumnType[i].bNativeDataType
93766>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93767>>>>            Move 1                                       to aColumnType[i].iMinSize
93768>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93769>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93770>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93771>>>>            Move 16384                                   to aColumnType[i].sPrecision
93772>>>>            Increment i
93773>>>>
93773>>>>            Move "varchar"                               to aColumnType[i].sSQLType
93774>>>>            Move 12                                      to aColumnType[i].iSQLType
93775>>>>            Move True                                    to aColumnType[i].bCanEditSize
93776>>>>            Move True                                    to aColumnType[i].bNativeDataType
93777>>>>            Move 1                                       to aColumnType[i].iDefaultSize
93778>>>>            Move 1                                       to aColumnType[i].iMinSize
93779>>>>            Move 8000                                    to aColumnType[i].nMaxSize
93780>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93781>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93782>>>>            Move 8000                                    to aColumnType[i].sPrecision
93783>>>>            Increment i
93784>>>>
93784>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
93785>>>>            Move -99                                     to aColumnType[i].iSQLType
93786>>>>            Move True                                    to aColumnType[i].bCanEditSize
93787>>>>            Move True                                    to aColumnType[i].bNativeDataType
93788>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93789>>>>            Move 1                                       to aColumnType[i].iMinSize
93790>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93791>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93792>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93793>>>>            Move 16384                                   to aColumnType[i].sPrecision
93794>>>>            Increment i
93795>>>>
93795>>>>            Move "xml"                                   to aColumnType[i].sSQLType
93796>>>>            Move -370                                    to aColumnType[i].iSQLType
93797>>>>            Move True                                    to aColumnType[i].bCanEditSize
93798>>>>            Move True                                    to aColumnType[i].bNativeDataType
93799>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93800>>>>            Move 1                                       to aColumnType[i].iMinSize
93801>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93802>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93803>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93804>>>>            Move 16384                                   to aColumnType[i].sPrecision
93805>>>>            Increment i
93806>>>>
93806>>>>
93806>>>            
93806>>>//            Move eSQLServer_BIGINT  to ColumnType[i].iSQLType
93806>>>//            Move "BigInt"           to ColumnType[i].sSQLType
93806>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93806>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
93806>>>//            Move "14.0"             to ColumnType[i].sPrecision
93806>>>//            Move True               to ColumnType[i].bCanEditSize
93806>>>//            Increment i
93806>>>//
93806>>>//            Move eSQLServer_BINARY  to ColumnType[i].iSQLType
93806>>>//            Move "Binary"           to ColumnType[i].sSQLType
93806>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
93806>>>//            Move "Binary"           to ColumnType[i].sDataFlexType
93806>>>//            Move "8000"             to ColumnType[i].sPrecision
93806>>>//            Increment i
93806>>>//
93806>>>//            Move eSQLServer_BIT     to ColumnType[i].iSQLType
93806>>>//            Move "Bit"              to ColumnType[i].sSQLType
93806>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
93806>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
93806>>>//            Move "1.0"              to ColumnType[i].sPrecision
93806>>>//            Move True               to ColumnType[i].bCanEditSize // In SQL allows 1, 0, or "NULL"
93806>>>//            Increment i
93806>>>//
93806>>>//            Move eSQLServer_CHAR    to ColumnType[i].iSQLType
93806>>>//            Move "Char"             to ColumnType[i].sSQLType
93806>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
93806>>>//            Move "Text"             to ColumnType[i].sDataFlexType
93806>>>//            Move "8000"             to ColumnType[i].sPrecision
93806>>>//            Increment i
93806>>>//
93806>>>//            Move eSQLServer_DATE    to ColumnType[i].iSQLType
93806>>>//            Move "Date"             to ColumnType[i].sSQLType
93806>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
93806>>>//            Move "Date"             to ColumnType[i].sDataFlexType
93806>>>//            Move "6.0"              to ColumnType[i].sPrecision
93806>>>//            Move True               to ColumnType[i].bCanEditSize
93806>>>//            Increment i
93806>>>//
93806>>>//            Move eSQLServer_DATETIME    to ColumnType[i].iSQLType
93806>>>//            Move "DateTime"             to ColumnType[i].sSQLType
93806>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
93806>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
93806>>>//            Move "23.3"                 to ColumnType[i].sPrecision
93806>>>//            Move True                   to ColumnType[i].bCanEditSize
93806>>>//            Increment i
93806>>>//
93806>>>//            Move eSQLServer_DATETIME2   to ColumnType[i].iSQLType
93806>>>//            Move "DateTime2"            to ColumnType[i].sSQLType
93806>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
93806>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
93806>>>//            Move "23.6"                 to ColumnType[i].sPrecision
93806>>>//            Move True                   to ColumnType[i].bCanEditSize
93806>>>//            Increment i
93806>>>//
93806>>>//            Move eSQLServer_DATETIMEOFFSET  to ColumnType[i].iSQLType
93806>>>//            Move "DateTimeOffest"           to ColumnType[i].sSQLType
93806>>>//            Move DF_DATETIME                to ColumnType[i].iDataFlexType
93806>>>//            Move "DateTime"                 to ColumnType[i].sDataFlexType
93806>>>//            Move "23.0"                     to ColumnType[i].sPrecision
93806>>>//            Move True                       to ColumnType[i].bCanEditSize
93806>>>//            Increment i
93806>>>//
93806>>>//            Move eSQLServer_DECIMAL to ColumnType[i].iSQLType
93806>>>//            Move "Decimal"          to ColumnType[i].sSQLType
93806>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93806>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
93806>>>//            Move "14.8"             to ColumnType[i].sPrecision
93806>>>//            Increment i
93806>>>//
93806>>>//            Move eSQLServer_DOUBLE  to ColumnType[i].iSQLType
93806>>>//            Move "Double"           to ColumnType[i].sSQLType
93806>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93806>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
93806>>>//            Move "14.8"             to ColumnType[i].sPrecision
93806>>>//            Increment i
93806>>>//
93806>>>//            Move eSQLServer_FLOAT   to ColumnType[i].iSQLType
93806>>>//            Move "Float"            to ColumnType[i].sSQLType
93806>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93806>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
93806>>>//            Move "14.8"             to ColumnType[i].sPrecision
93806>>>//            Increment i
93806>>>//
93806>>>//            Move eSQLServer_INT     to ColumnType[i].iSQLType
93806>>>//            Move "Int"              to ColumnType[i].sSQLType
93806>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93806>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
93806>>>//            Move "11.0"             to ColumnType[i].sPrecision
93806>>>//            Increment i
93806>>>//
93806>>>//            Move eSQLServer_NCHAR   to ColumnType[i].iSQLType
93806>>>//            Move "Nchar"            to ColumnType[i].sSQLType
93806>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
93806>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
93806>>>//            Move "4000"             to ColumnType[i].sPrecision
93806>>>//            Increment i
93806>>>//
93806>>>//            Move eSQLServer_NTEXT   to ColumnType[i].iSQLType
93806>>>//            Move "Ntext"            to ColumnType[i].sSQLType
93806>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
93806>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
93806>>>//            Move "16384"            to ColumnType[i].sPrecision
93806>>>//            Increment i
93806>>>//
93806>>>//            Move eSQLServer_NUMERIC to ColumnType[i].iSQLType
93806>>>//            Move "Numeric"          to ColumnType[i].sSQLType
93806>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93806>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
93806>>>//            Move "14.8"             to ColumnType[i].sPrecision
93806>>>//            Increment i
93806>>>//
93806>>>//            Move eSQLServer_NVARCHAR    to ColumnType[i].iSQLType
93806>>>//            Move "NvarChar"             to ColumnType[i].sSQLType
93806>>>//            Move DF_TEXT                to ColumnType[i].iDataFlexType
93806>>>//            Move "Text"                 to ColumnType[i].sDataFlexType
93806>>>//            Move "4000"                 to ColumnType[i].sPrecision
93806>>>//            Increment i
93806>>>//
93806>>>//            Move eSQLServer_NVARCHARMAX to ColumnType[i].iSQLType
93806>>>//            Move "NvarCharMax"          to ColumnType[i].sSQLType
93806>>>//            Move DF_TEXT                to ColumnType[i].iDataFlexType
93806>>>//            Move "Text"                 to ColumnType[i].sDataFlexType
93806>>>//            Move "16384"                to ColumnType[i].sPrecision
93806>>>//            Move True                   to ColumnType[i].bCanEditSize
93806>>>//            Increment i
93806>>>//
93806>>>//            Move eSQLServer_REAL    to ColumnType[i].iSQLType
93806>>>//            Move "Real"             to ColumnType[i].sSQLType
93806>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93806>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
93806>>>//            Move "14.8"             to ColumnType[i].sPrecision
93806>>>//            Increment i
93806>>>//
93806>>>//            Move eSQLServer_SMALLDATETIME   to ColumnType[i].iSQLType
93806>>>//            Move "SmallDateTime"            to ColumnType[i].sSQLType
93806>>>//            Move DF_DATETIME                to ColumnType[i].iDataFlexType
93806>>>//            Move "DATETIME"                 to ColumnType[i].sDataFlexType
93806>>>//            Move "23.0"                     to ColumnType[i].sPrecision
93806>>>//            Move True                       to ColumnType[i].bCanEditSize
93806>>>//            Increment i
93806>>>//
93806>>>//            Move eSQLServer_SMALLINT    to ColumnType[i].iSQLType
93806>>>//            Move "SmallInt"             to ColumnType[i].sSQLType
93806>>>//            Move DF_BCD                 to ColumnType[i].iDataFlexType
93806>>>//            Move "NUMERIC"              to ColumnType[i].sDataFlexType
93806>>>//            Move "6.0"                  to ColumnType[i].sPrecision
93806>>>//            Increment i
93806>>>//
93806>>>//            Move eSQLServer_TEXT    to ColumnType[i].iSQLType
93806>>>//            Move "Text"             to ColumnType[i].sSQLType
93806>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
93806>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
93806>>>//            Move "8000"             to ColumnType[i].sPrecision
93806>>>//            Move True               to ColumnType[i].bCanEditSize
93806>>>//            Increment i
93806>>>//
93806>>>//            Move eSQLServer_TIME    to ColumnType[i].iSQLType
93806>>>//            Move "Time"             to ColumnType[i].sSQLType
93806>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
93806>>>//            Move "Date"             to ColumnType[i].sDataFlexType
93806>>>//            Move "16.0"             to ColumnType[i].sPrecision
93806>>>//            Move True               to ColumnType[i].bCanEditSize
93806>>>//            Increment i
93806>>>//
93806>>>//            Move eSQLServer_TIMESTAMP   to ColumnType[i].iSQLType
93806>>>//            Move "TimeStamp"            to ColumnType[i].sSQLType
93806>>>//            Move DF_ASCII               to ColumnType[i].iDataFlexType
93806>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
93806>>>//            Move "8.0"                  to ColumnType[i].sPrecision
93806>>>//            Move True                   to ColumnType[i].bCanEditSize
93806>>>//            Increment i
93806>>>//
93806>>>//            Move eSQLServer_TINYINT to ColumnType[i].iSQLType
93806>>>//            Move "TinyInt"          to ColumnType[i].sSQLType
93806>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93806>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
93806>>>//            Move "3.0"              to ColumnType[i].sPrecision
93806>>>//            Increment i
93806>>>//
93806>>>//            Move eSQLServer_GUID    to ColumnType[i].iSQLType
93806>>>//            Move "UniqueIdentifier" to ColumnType[i].sSQLType
93806>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
93806>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
93806>>>//            Move "38"               to ColumnType[i].sPrecision
93806>>>//            Move True               to ColumnType[i].bCanEditSize
93806>>>//            Increment i
93806>>>//
93806>>>//            Move eSQLServer_VARBINARY   to ColumnType[i].iSQLType
93806>>>//            Move "VarBinary"            to ColumnType[i].sSQLType
93806>>>//            Move DF_BINARY              to ColumnType[i].iDataFlexType
93806>>>//            Move "BINARY"               to ColumnType[i].sDataFlexType
93806>>>//            Move "8000"                 to ColumnType[i].sPrecision
93806>>>//            Increment i
93806>>>//
93806>>>//            Move eSQLServer_VARBINARYMAX to ColumnType[i].iSQLType
93806>>>//            Move "VarBinary(Max)"        to ColumnType[i].sSQLType
93806>>>//            Move DF_BINARY               to ColumnType[i].iDataFlexType
93806>>>//            Move "BINARY"                to ColumnType[i].sDataFlexType
93806>>>//            Move "16384"                 to ColumnType[i].sPrecision
93806>>>//            Move True                    to ColumnType[i].bCanEditSize
93806>>>//            Increment i
93806>>>//
93806>>>//            Move eSQLServer_VARCHAR to ColumnType[i].iSQLType
93806>>>//            Move "VarChar"          to ColumnType[i].sSQLType
93806>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
93806>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
93806>>>//            Move "8000"             to ColumnType[i].sPrecision
93806>>>//            Increment i
93806>>>//
93806>>>//            Move eSQLServer_VARCHARMAX  to ColumnType[i].iSQLType
93806>>>//            Move "VarChar(Max)"         to ColumnType[i].sSQLType
93806>>>//            Move DF_TEXT                to ColumnType[i].iDataFlexType
93806>>>//            Move "TEXT"                 to ColumnType[i].sDataFlexType
93806>>>//            Move "16384"                to ColumnType[i].sPrecision
93806>>>//            Move True                   to ColumnType[i].bCanEditSize
93806>>>//            Increment i
93806>>>//
93806>>>//            Move eSQLServer_SQLVARIANT  to ColumnType[i].iSQLType
93806>>>//            Move "SQL_Variant"          to ColumnType[i].sSQLType
93806>>>//            Move DF_BINARY              to ColumnType[i].iDataFlexType
93806>>>//            Move "Binary"               to ColumnType[i].sDataFlexType
93806>>>//            Move "8016"                 to ColumnType[i].sPrecision
93806>>>//            Move True                   to ColumnType[i].bCanEditSize
93806>>>//            Increment i
93806>>>//
93806>>>//            Move eSQLServer_XML     to ColumnType[i].iSQLType
93806>>>//            Move "XML"              to ColumnType[i].sSQLType
93806>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
93806>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
93806>>>//            Move "16384"            to ColumnType[i].sPrecision
93806>>>        End
93806>>>>
93806>>>
93806>>>        Function_Return aColumnType
93807>>>    End_Function
93808>>>
93808>>>    // MySQL Data Types
93808>>>    Function _UtilEnumerateMySQLTypes Returns tColumnType[]
93810>>>        tColumnType[] aColumnType
93810>>>        tColumnType[] aColumnType
93811>>>        Integer i
93811>>>        
Including file: mdsmysql_DriverDef.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\mdsmysql_DriverDef.inc)
93811>>>>// Generated By The Database Update Framework
93811>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdsmysql_DriverDef.xml
93811>>>>// Driver COLUMN DATA TYPES
93811>>>>//
93811>>>>// Created: 2018-03-14 23:46:49.593
93811>>>>
93811>>>>            Move "bigint"                                to aColumnType[i].sSQLType
93812>>>>            Move 8                                       to aColumnType[i].iSQLType
93813>>>>            Move True                                    to aColumnType[i].bCanEditSize
93814>>>>            Move True                                    to aColumnType[i].bNativeDataType
93815>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93816>>>>            Move 1                                       to aColumnType[i].iMinSize
93817>>>>            Move 14                                      to aColumnType[i].nMaxSize
93818>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93819>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93820>>>>            Move 14                                      to aColumnType[i].sPrecision
93821>>>>            Increment i
93822>>>>
93822>>>>            Move "bit"                                   to aColumnType[i].sSQLType
93823>>>>            Move 16                                      to aColumnType[i].iSQLType
93824>>>>            Move True                                    to aColumnType[i].bCanEditSize
93825>>>>            Move True                                    to aColumnType[i].bNativeDataType
93826>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93827>>>>            Move -1                                      to aColumnType[i].iMinSize
93828>>>>            Move 64                                      to aColumnType[i].nMaxSize
93829>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93830>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93831>>>>            Move 64                                      to aColumnType[i].sPrecision
93832>>>>            Increment i
93833>>>>
93833>>>>            Move "blob"                                  to aColumnType[i].sSQLType
93834>>>>            Move 252                                     to aColumnType[i].iSQLType
93835>>>>            Move True                                    to aColumnType[i].bCanEditSize
93836>>>>            Move True                                    to aColumnType[i].bNativeDataType
93837>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93838>>>>            Move 1                                       to aColumnType[i].iMinSize
93839>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93840>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
93841>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
93842>>>>            Move 16384                                   to aColumnType[i].sPrecision
93843>>>>            Increment i
93844>>>>
93844>>>>            Move "char"                                  to aColumnType[i].sSQLType
93845>>>>            Move 254                                     to aColumnType[i].iSQLType
93846>>>>            Move True                                    to aColumnType[i].bCanEditSize
93847>>>>            Move True                                    to aColumnType[i].bNativeDataType
93848>>>>            Move 1                                       to aColumnType[i].iDefaultSize
93849>>>>            Move 1                                       to aColumnType[i].iMinSize
93850>>>>            Move 255                                     to aColumnType[i].nMaxSize
93851>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93852>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93853>>>>            Move 255                                     to aColumnType[i].sPrecision
93854>>>>            Increment i
93855>>>>
93855>>>>            Move "date"                                  to aColumnType[i].sSQLType
93856>>>>            Move 10                                      to aColumnType[i].iSQLType
93857>>>>            Move False                                   to aColumnType[i].bCanEditSize
93858>>>>            Move True                                    to aColumnType[i].bNativeDataType
93859>>>>            Move 6                                       to aColumnType[i].iDefaultSize
93860>>>>            Move -1                                      to aColumnType[i].iMinSize
93861>>>>            Move -1                                      to aColumnType[i].nMaxSize
93862>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
93863>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
93864>>>>            Move 6                                       to aColumnType[i].sPrecision
93865>>>>            Increment i
93866>>>>
93866>>>>            Move "datetime"                              to aColumnType[i].sSQLType
93867>>>>            Move 12                                      to aColumnType[i].iSQLType
93868>>>>            Move True                                    to aColumnType[i].bCanEditSize
93869>>>>            Move True                                    to aColumnType[i].bNativeDataType
93870>>>>            Move 23                                      to aColumnType[i].iDefaultSize
93871>>>>            Move 6                                       to aColumnType[i].iMinSize
93872>>>>            Move 23                                      to aColumnType[i].nMaxSize
93873>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
93874>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
93875>>>>            Move 23                                      to aColumnType[i].sPrecision
93876>>>>            Increment i
93877>>>>
93877>>>>            Move "decimal"                               to aColumnType[i].sSQLType
93878>>>>            Move 246                                     to aColumnType[i].iSQLType
93879>>>>            Move True                                    to aColumnType[i].bCanEditSize
93880>>>>            Move True                                    to aColumnType[i].bNativeDataType
93881>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93882>>>>            Move -1                                      to aColumnType[i].iMinSize
93883>>>>            Move 14                                      to aColumnType[i].nMaxSize
93884>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93885>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93886>>>>            Move 14                                      to aColumnType[i].sPrecision
93887>>>>            Increment i
93888>>>>
93888>>>>            Move "decimal-MySQL4"                        to aColumnType[i].sSQLType
93889>>>>            Move 0                                       to aColumnType[i].iSQLType
93890>>>>            Move True                                    to aColumnType[i].bCanEditSize
93891>>>>            Move True                                    to aColumnType[i].bNativeDataType
93892>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93893>>>>            Move -1                                      to aColumnType[i].iMinSize
93894>>>>            Move 14                                      to aColumnType[i].nMaxSize
93895>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93896>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93897>>>>            Move 14                                      to aColumnType[i].sPrecision
93898>>>>            Increment i
93899>>>>
93899>>>>            Move "double"                                to aColumnType[i].sSQLType
93900>>>>            Move 5                                       to aColumnType[i].iSQLType
93901>>>>            Move True                                    to aColumnType[i].bCanEditSize
93902>>>>            Move True                                    to aColumnType[i].bNativeDataType
93903>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93904>>>>            Move -1                                      to aColumnType[i].iMinSize
93905>>>>            Move 14                                      to aColumnType[i].nMaxSize
93906>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93907>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93908>>>>            Move 14                                      to aColumnType[i].sPrecision
93909>>>>            Increment i
93910>>>>
93910>>>>            Move "enum"                                  to aColumnType[i].sSQLType
93911>>>>            Move 247                                     to aColumnType[i].iSQLType
93912>>>>            Move True                                    to aColumnType[i].bCanEditSize
93913>>>>            Move True                                    to aColumnType[i].bNativeDataType
93914>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93915>>>>            Move -1                                      to aColumnType[i].iMinSize
93916>>>>            Move 255                                     to aColumnType[i].nMaxSize
93917>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93918>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93919>>>>            Move 255                                     to aColumnType[i].sPrecision
93920>>>>            Increment i
93921>>>>
93921>>>>            Move "float"                                 to aColumnType[i].sSQLType
93922>>>>            Move 4                                       to aColumnType[i].iSQLType
93923>>>>            Move True                                    to aColumnType[i].bCanEditSize
93924>>>>            Move True                                    to aColumnType[i].bNativeDataType
93925>>>>            Move 4                                       to aColumnType[i].iDefaultSize
93926>>>>            Move -1                                      to aColumnType[i].iMinSize
93927>>>>            Move 14                                      to aColumnType[i].nMaxSize
93928>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93929>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93930>>>>            Move 14                                      to aColumnType[i].sPrecision
93931>>>>            Increment i
93932>>>>
93932>>>>            Move "int"                                   to aColumnType[i].sSQLType
93933>>>>            Move 3                                       to aColumnType[i].iSQLType
93934>>>>            Move True                                    to aColumnType[i].bCanEditSize
93935>>>>            Move True                                    to aColumnType[i].bNativeDataType
93936>>>>            Move 10                                      to aColumnType[i].iDefaultSize
93937>>>>            Move -1                                      to aColumnType[i].iMinSize
93938>>>>            Move 11                                      to aColumnType[i].nMaxSize
93939>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93940>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93941>>>>            Move 11                                      to aColumnType[i].sPrecision
93942>>>>            Increment i
93943>>>>
93943>>>>            Move "longblob"                              to aColumnType[i].sSQLType
93944>>>>            Move 251                                     to aColumnType[i].iSQLType
93945>>>>            Move True                                    to aColumnType[i].bCanEditSize
93946>>>>            Move True                                    to aColumnType[i].bNativeDataType
93947>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93948>>>>            Move 1                                       to aColumnType[i].iMinSize
93949>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93950>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
93951>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
93952>>>>            Move 16384                                   to aColumnType[i].sPrecision
93953>>>>            Increment i
93954>>>>
93954>>>>            Move "longtext"                              to aColumnType[i].sSQLType
93955>>>>            Move -251                                    to aColumnType[i].iSQLType
93956>>>>            Move True                                    to aColumnType[i].bCanEditSize
93957>>>>            Move True                                    to aColumnType[i].bNativeDataType
93958>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93959>>>>            Move 1                                       to aColumnType[i].iMinSize
93960>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93961>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
93962>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
93963>>>>            Move 16384                                   to aColumnType[i].sPrecision
93964>>>>            Increment i
93965>>>>
93965>>>>            Move "mediumblob"                            to aColumnType[i].sSQLType
93966>>>>            Move 250                                     to aColumnType[i].iSQLType
93967>>>>            Move True                                    to aColumnType[i].bCanEditSize
93968>>>>            Move True                                    to aColumnType[i].bNativeDataType
93969>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93970>>>>            Move 1                                       to aColumnType[i].iMinSize
93971>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93972>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
93973>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
93974>>>>            Move 16384                                   to aColumnType[i].sPrecision
93975>>>>            Increment i
93976>>>>
93976>>>>            Move "mediumint"                             to aColumnType[i].sSQLType
93977>>>>            Move 9                                       to aColumnType[i].iSQLType
93978>>>>            Move True                                    to aColumnType[i].bCanEditSize
93979>>>>            Move True                                    to aColumnType[i].bNativeDataType
93980>>>>            Move 8                                       to aColumnType[i].iDefaultSize
93981>>>>            Move 1                                       to aColumnType[i].iMinSize
93982>>>>            Move 9                                       to aColumnType[i].nMaxSize
93983>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93984>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93985>>>>            Move 9                                       to aColumnType[i].sPrecision
93986>>>>            Increment i
93987>>>>
93987>>>>            Move "mediumtext"                            to aColumnType[i].sSQLType
93988>>>>            Move -250                                    to aColumnType[i].iSQLType
93989>>>>            Move True                                    to aColumnType[i].bCanEditSize
93990>>>>            Move True                                    to aColumnType[i].bNativeDataType
93991>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93992>>>>            Move 1                                       to aColumnType[i].iMinSize
93993>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93994>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
93995>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
93996>>>>            Move 16384                                   to aColumnType[i].sPrecision
93997>>>>            Increment i
93998>>>>
93998>>>>            Move "set"                                   to aColumnType[i].sSQLType
93999>>>>            Move 248                                     to aColumnType[i].iSQLType
94000>>>>            Move True                                    to aColumnType[i].bCanEditSize
94001>>>>            Move True                                    to aColumnType[i].bNativeDataType
94002>>>>            Move -1                                      to aColumnType[i].iDefaultSize
94003>>>>            Move -1                                      to aColumnType[i].iMinSize
94004>>>>            Move 255                                     to aColumnType[i].nMaxSize
94005>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94006>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94007>>>>            Move 255                                     to aColumnType[i].sPrecision
94008>>>>            Increment i
94009>>>>
94009>>>>            Move "smallint"                              to aColumnType[i].sSQLType
94010>>>>            Move 2                                       to aColumnType[i].iSQLType
94011>>>>            Move True                                    to aColumnType[i].bCanEditSize
94012>>>>            Move True                                    to aColumnType[i].bNativeDataType
94013>>>>            Move 5                                       to aColumnType[i].iDefaultSize
94014>>>>            Move 1                                       to aColumnType[i].iMinSize
94015>>>>            Move 6                                       to aColumnType[i].nMaxSize
94016>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
94017>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
94018>>>>            Move 6                                       to aColumnType[i].sPrecision
94019>>>>            Increment i
94020>>>>
94020>>>>            Move "text"                                  to aColumnType[i].sSQLType
94021>>>>            Move -252                                    to aColumnType[i].iSQLType
94022>>>>            Move True                                    to aColumnType[i].bCanEditSize
94023>>>>            Move True                                    to aColumnType[i].bNativeDataType
94024>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
94025>>>>            Move 1                                       to aColumnType[i].iMinSize
94026>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94027>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
94028>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
94029>>>>            Move 16384                                   to aColumnType[i].sPrecision
94030>>>>            Increment i
94031>>>>
94031>>>>            Move "time"                                  to aColumnType[i].sSQLType
94032>>>>            Move 11                                      to aColumnType[i].iSQLType
94033>>>>            Move False                                   to aColumnType[i].bCanEditSize
94034>>>>            Move True                                    to aColumnType[i].bNativeDataType
94035>>>>            Move 10                                      to aColumnType[i].iDefaultSize
94036>>>>            Move -1                                      to aColumnType[i].iMinSize
94037>>>>            Move -1                                      to aColumnType[i].nMaxSize
94038>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94039>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94040>>>>            Move -1                                      to aColumnType[i].sPrecision
94041>>>>            Increment i
94042>>>>
94042>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
94043>>>>            Move 7                                       to aColumnType[i].iSQLType
94044>>>>            Move True                                    to aColumnType[i].bCanEditSize
94045>>>>            Move True                                    to aColumnType[i].bNativeDataType
94046>>>>            Move 6                                       to aColumnType[i].iDefaultSize
94047>>>>            Move 6                                       to aColumnType[i].iMinSize
94048>>>>            Move 23                                      to aColumnType[i].nMaxSize
94049>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
94050>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
94051>>>>            Move 23                                      to aColumnType[i].sPrecision
94052>>>>            Increment i
94053>>>>
94053>>>>            Move "tinyblob"                              to aColumnType[i].sSQLType
94054>>>>            Move 249                                     to aColumnType[i].iSQLType
94055>>>>            Move True                                    to aColumnType[i].bCanEditSize
94056>>>>            Move True                                    to aColumnType[i].bNativeDataType
94057>>>>            Move 255                                     to aColumnType[i].iDefaultSize
94058>>>>            Move 1                                       to aColumnType[i].iMinSize
94059>>>>            Move 255                                     to aColumnType[i].nMaxSize
94060>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
94061>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
94062>>>>            Move 255                                     to aColumnType[i].sPrecision
94063>>>>            Increment i
94064>>>>
94064>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
94065>>>>            Move 1                                       to aColumnType[i].iSQLType
94066>>>>            Move True                                    to aColumnType[i].bCanEditSize
94067>>>>            Move True                                    to aColumnType[i].bNativeDataType
94068>>>>            Move 4                                       to aColumnType[i].iDefaultSize
94069>>>>            Move 1                                       to aColumnType[i].iMinSize
94070>>>>            Move 4                                       to aColumnType[i].nMaxSize
94071>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
94072>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
94073>>>>            Move 4                                       to aColumnType[i].sPrecision
94074>>>>            Increment i
94075>>>>
94075>>>>            Move "tinytext"                              to aColumnType[i].sSQLType
94076>>>>            Move -249                                    to aColumnType[i].iSQLType
94077>>>>            Move True                                    to aColumnType[i].bCanEditSize
94078>>>>            Move True                                    to aColumnType[i].bNativeDataType
94079>>>>            Move 255                                     to aColumnType[i].iDefaultSize
94080>>>>            Move 1                                       to aColumnType[i].iMinSize
94081>>>>            Move 255                                     to aColumnType[i].nMaxSize
94082>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94083>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94084>>>>            Move 255                                     to aColumnType[i].sPrecision
94085>>>>            Increment i
94086>>>>
94086>>>>            Move "varchar"                               to aColumnType[i].sSQLType
94087>>>>            Move 253                                     to aColumnType[i].iSQLType
94088>>>>            Move True                                    to aColumnType[i].bCanEditSize
94089>>>>            Move True                                    to aColumnType[i].bNativeDataType
94090>>>>            Move -1                                      to aColumnType[i].iDefaultSize
94091>>>>            Move -1                                      to aColumnType[i].iMinSize
94092>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94093>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94094>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94095>>>>            Move 16384                                   to aColumnType[i].sPrecision
94096>>>>            Increment i
94097>>>>
94097>>>>            Move "year"                                  to aColumnType[i].sSQLType
94098>>>>            Move 13                                      to aColumnType[i].iSQLType
94099>>>>            Move False                                   to aColumnType[i].bCanEditSize
94100>>>>            Move True                                    to aColumnType[i].bNativeDataType
94101>>>>            Move 4                                       to aColumnType[i].iDefaultSize
94102>>>>            Move -1                                      to aColumnType[i].iMinSize
94103>>>>            Move -1                                      to aColumnType[i].nMaxSize
94104>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
94105>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
94106>>>>            Move -1                                      to aColumnType[i].sPrecision
94107>>>>            Increment i
94108>>>>
94108>>>>
94108>>>        
94108>>>//        Move eMySQL_LONGLONG    to ColumnType[i].iSQLType
94108>>>//        Move "bigint"           to ColumnType[i].sSQLType
94108>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94108>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
94108>>>//        Move "14.0"             to ColumnType[i].sPrecision
94108>>>//        Increment i
94108>>>//
94108>>>//        Move eMySQL_BIT         to ColumnType[i].iSQLType
94108>>>//        Move "bit"              to ColumnType[i].sSQLType
94108>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
94108>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
94108>>>//        Move "4.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
94108>>>//        Move True               to ColumnType[i].bCanEditSize
94108>>>//        Increment i
94108>>>//
94108>>>//        Move eMySQL_BLOB        to ColumnType[i].iSQLType
94108>>>//        Move "blob"             to ColumnType[i].sSQLType
94108>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
94108>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
94108>>>//        Move "16384"            to ColumnType[i].sPrecision
94108>>>//        Increment i
94108>>>//
94108>>>//        Move eMySQL_STRING      to ColumnType[i].iSQLType
94108>>>//        Move "char"             to ColumnType[i].sSQLType
94108>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
94108>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
94108>>>//        Move "254"              to ColumnType[i].sPrecision
94108>>>//        Increment i
94108>>>//
94108>>>//        Move eMySQL_DATE        to ColumnType[i].iSQLType
94108>>>//        Move "date"             to ColumnType[i].sSQLType
94108>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
94108>>>//        Move "Date"             to ColumnType[i].sDataFlexType
94108>>>//        Move "6.0"              to ColumnType[i].sPrecision
94108>>>//        Move True               to ColumnType[i].bCanEditSize
94108>>>//        Increment i
94108>>>//
94108>>>//        Move eMySQL_DATETIME    to ColumnType[i].iSQLType
94108>>>//        Move "datetime"         to ColumnType[i].sSQLType
94108>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
94108>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
94108>>>//        Move "23.0"             to ColumnType[i].sPrecision
94108>>>//        Move True               to ColumnType[i].bCanEditSize
94108>>>//        Increment i
94108>>>//
94108>>>//        Move eMySQL_DECIMAL     to ColumnType[i].iSQLType
94108>>>//        Move "decimal"          to ColumnType[i].sSQLType
94108>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94108>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
94108>>>//        Move "14.8"             to ColumnType[i].sPrecision
94108>>>//        Increment i
94108>>>//
94108>>>//        Move eMySQL_DOUBLE      to ColumnType[i].iSQLType
94108>>>//        Move "double"           to ColumnType[i].sSQLType
94108>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94108>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
94108>>>//        Move "14.8"             to ColumnType[i].sPrecision
94108>>>//        Increment i
94108>>>//
94108>>>//        Move eMySQL_ENUM        to ColumnType[i].iSQLType
94108>>>//        Move "enum"             to ColumnType[i].sSQLType
94108>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
94108>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
94108>>>//        Move "254"              to ColumnType[i].sPrecision
94108>>>//        Increment i
94108>>>//
94108>>>//        Move eMySQL_FLOAT       to ColumnType[i].iSQLType
94108>>>//        Move "float"            to ColumnType[i].sSQLType
94108>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94108>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
94108>>>//        Move "14.8"             to ColumnType[i].sPrecision
94108>>>//        Increment i
94108>>>//
94108>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
94108>>>//        Move "int"              to ColumnType[i].sSQLType
94108>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94108>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
94108>>>//        Move "11.0"             to ColumnType[i].sPrecision
94108>>>//        Increment i
94108>>>//
94108>>>//        Move eMySQL_LONG_BLOB   to ColumnType[i].iSQLType
94108>>>//        Move "longblob"         to ColumnType[i].sSQLType
94108>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
94108>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
94108>>>//        Move "16384"            to ColumnType[i].sPrecision
94108>>>//        Increment i
94108>>>//
94108>>>//        Move eMySQL_LONG_TEXT   to ColumnType[i].iSQLType
94108>>>//        Move "longtext"         to ColumnType[i].sSQLType
94108>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
94108>>>//        Move "Text"             to ColumnType[i].sDataFlexType
94108>>>//        Move "16384"            to ColumnType[i].sPrecision
94108>>>//        Increment i
94108>>>//
94108>>>//        Move eMySQL_MEDIUM_BLOB to ColumnType[i].iSQLType
94108>>>//        Move "mediumblob"       to ColumnType[i].sSQLType
94108>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
94108>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
94108>>>//        Move "16384"            to ColumnType[i].sPrecision
94108>>>//        Increment i
94108>>>//
94108>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
94108>>>//        Move "mediumint"        to ColumnType[i].sSQLType
94108>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94108>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
94108>>>//        Move "9.0"              to ColumnType[i].sPrecision
94108>>>//
94108>>>//        Move eMySQL_MEDIUM_TEXT to ColumnType[i].iSQLType
94108>>>//        Move "mediumtext"       to ColumnType[i].sSQLType
94108>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
94108>>>//        Move "Text"             to ColumnType[i].sDataFlexType
94108>>>//        Move "16384"            to ColumnType[i].sPrecision
94108>>>//        Increment i
94108>>>//
94108>>>//        Move eMySQL_SET         to ColumnType[i].iSQLType
94108>>>//        Move "set"              to ColumnType[i].sSQLType
94108>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
94108>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
94108>>>//        Move "254"              to ColumnType[i].sPrecision
94108>>>//        Increment i
94108>>>//
94108>>>//        Move eMySQL_SHORT       to ColumnType[i].iSQLType
94108>>>//        Move "smallint"         to ColumnType[i].sSQLType
94108>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94108>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
94108>>>//        Move "6.0"              to ColumnType[i].sPrecision
94108>>>//        Increment i
94108>>>//
94108>>>//        Move eMySQL_TEXT        to ColumnType[i].iSQLType
94108>>>//        Move "text"             to ColumnType[i].sSQLType
94108>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
94108>>>//        Move "Text"             to ColumnType[i].sDataFlexType
94108>>>//        Move "16384"            to ColumnType[i].sPrecision
94108>>>//        Increment i
94108>>>//
94108>>>//        Move eMySQL_TIME        to ColumnType[i].iSQLType
94108>>>//        Move "time"             to ColumnType[i].sSQLType
94108>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
94108>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
94108>>>//        Move "10.0"             to ColumnType[i].sPrecision
94108>>>//        Move True               to ColumnType[i].bCanEditSize
94108>>>//        Increment i
94108>>>//
94108>>>//        Move eMySQL_TIMESTAMP   to ColumnType[i].iSQLType
94108>>>//        Move "timestamp"        to ColumnType[i].sSQLType
94108>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
94108>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
94108>>>//        Move "23.0"             to ColumnType[i].sPrecision
94108>>>//        Move True               to ColumnType[i].bCanEditSize
94108>>>//        Increment i
94108>>>//
94108>>>//        Move eMySQL_TINY_BLOB   to ColumnType[i].iSQLType
94108>>>//        Move "tinyblob"         to ColumnType[i].sSQLType
94108>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
94108>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
94108>>>//        Move "254"              to ColumnType[i].sPrecision
94108>>>//        Increment i
94108>>>//
94108>>>//        Move eMySQL_TINY        to ColumnType[i].iSQLType
94108>>>//        Move "tinyint"          to ColumnType[i].sSQLType
94108>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94108>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
94108>>>//        Move "4.0"              to ColumnType[i].sPrecision
94108>>>//        Increment i
94108>>>//
94108>>>//        Move eMySQL_TINY_TEXT   to ColumnType[i].iSQLType
94108>>>//        Move "tinytext"         to ColumnType[i].sSQLType
94108>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
94108>>>//        Move "Text"             to ColumnType[i].sDataFlexType
94108>>>//        Move "254"              to ColumnType[i].sPrecision
94108>>>//        Increment i
94108>>>//
94108>>>//        Move eMySQL_VAR_STRING  to ColumnType[i].iSQLType
94108>>>//        Move "varchar"          to ColumnType[i].sSQLType
94108>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
94108>>>//        Move "Text"             to ColumnType[i].sDataFlexType
94108>>>//        Move "16384"            to ColumnType[i].sPrecision
94108>>>//        Increment i
94108>>>//
94108>>>//        Move eMySQL_YEAR        to ColumnType[i].iSQLType
94108>>>//        Move "year"             to ColumnType[i].sSQLType
94108>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94108>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
94108>>>//        Move "4.0"              to ColumnType[i].sPrecision
94108>>>//        Move True               to ColumnType[i].bCanEditSize
94108>>>//        Increment i
94108>>>
94108>>>        Function_Return aColumnType
94109>>>    End_Function
94110>>>
94110>>>    // Oracle Data Types
94110>>>    Function _UtilEnumerateOracleTypes Returns tColumnType[]
94112>>>        tColumnType[] aColumnType
94112>>>        tColumnType[] aColumnType
94113>>>        Integer i
94113>>>        
Including file: ora_drv_DriverDef.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\ora_drv_DriverDef.inc)
94113>>>>// Generated By The Database Update Framework
94113>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\ora_drv_DriverDef.xml
94113>>>>// Driver COLUMN DATA TYPES
94113>>>>//
94113>>>>// Created: 2018-03-14 23:47:34.82
94113>>>>
94113>>>>            Move "blob"                                  to aColumnType[i].sSQLType
94114>>>>            Move 113                                     to aColumnType[i].iSQLType
94115>>>>            Move True                                    to aColumnType[i].bCanEditSize
94116>>>>            Move True                                    to aColumnType[i].bNativeDataType
94117>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
94118>>>>            Move 1                                       to aColumnType[i].iMinSize
94119>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94120>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
94121>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
94122>>>>            Move 16384                                   to aColumnType[i].sPrecision
94123>>>>            Increment i
94124>>>>
94124>>>>            Move "char"                                  to aColumnType[i].sSQLType
94125>>>>            Move 96                                      to aColumnType[i].iSQLType
94126>>>>            Move True                                    to aColumnType[i].bCanEditSize
94127>>>>            Move True                                    to aColumnType[i].bNativeDataType
94128>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94129>>>>            Move 1                                       to aColumnType[i].iMinSize
94130>>>>            Move 2000                                    to aColumnType[i].nMaxSize
94131>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94132>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94133>>>>            Move 2000                                    to aColumnType[i].sPrecision
94134>>>>            Increment i
94135>>>>
94135>>>>            Move "clob"                                  to aColumnType[i].sSQLType
94136>>>>            Move 112                                     to aColumnType[i].iSQLType
94137>>>>            Move True                                    to aColumnType[i].bCanEditSize
94138>>>>            Move True                                    to aColumnType[i].bNativeDataType
94139>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
94140>>>>            Move 1                                       to aColumnType[i].iMinSize
94141>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94142>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
94143>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
94144>>>>            Move 16384                                   to aColumnType[i].sPrecision
94145>>>>            Increment i
94146>>>>
94146>>>>            Move "date"                                  to aColumnType[i].sSQLType
94147>>>>            Move 12                                      to aColumnType[i].iSQLType
94148>>>>            Move True                                    to aColumnType[i].bCanEditSize
94149>>>>            Move True                                    to aColumnType[i].bNativeDataType
94150>>>>            Move 6                                       to aColumnType[i].iDefaultSize
94151>>>>            Move 6                                       to aColumnType[i].iMinSize
94152>>>>            Move 23                                      to aColumnType[i].nMaxSize
94153>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
94154>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
94155>>>>            Move 6                                       to aColumnType[i].sPrecision
94156>>>>            Increment i
94157>>>>
94157>>>>            Move "float"                                 to aColumnType[i].sSQLType
94158>>>>            Move 4                                       to aColumnType[i].iSQLType
94159>>>>            Move True                                    to aColumnType[i].bCanEditSize
94160>>>>            Move True                                    to aColumnType[i].bNativeDataType
94161>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94162>>>>            Move 1                                       to aColumnType[i].iMinSize
94163>>>>            Move 14                                      to aColumnType[i].nMaxSize
94164>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
94165>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
94166>>>>            Move 14                                      to aColumnType[i].sPrecision
94167>>>>            Increment i
94168>>>>
94168>>>>            Move "int"                                   to aColumnType[i].sSQLType
94169>>>>            Move 3                                       to aColumnType[i].iSQLType
94170>>>>            Move True                                    to aColumnType[i].bCanEditSize
94171>>>>            Move True                                    to aColumnType[i].bNativeDataType
94172>>>>            Move 14                                      to aColumnType[i].iDefaultSize
94173>>>>            Move 1                                       to aColumnType[i].iMinSize
94174>>>>            Move 14                                      to aColumnType[i].nMaxSize
94175>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
94176>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
94177>>>>            Move 14                                      to aColumnType[i].sPrecision
94178>>>>            Increment i
94179>>>>
94179>>>>            Move "intervalds"                            to aColumnType[i].sSQLType
94180>>>>            Move 190                                     to aColumnType[i].iSQLType
94181>>>>            Move False                                   to aColumnType[i].bCanEditSize
94182>>>>            Move True                                    to aColumnType[i].bNativeDataType
94183>>>>            Move 23                                      to aColumnType[i].iDefaultSize
94184>>>>            Move -1                                      to aColumnType[i].iMinSize
94185>>>>            Move -1                                      to aColumnType[i].nMaxSize
94186>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
94187>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
94188>>>>            Move -1                                      to aColumnType[i].sPrecision
94189>>>>            Increment i
94190>>>>
94190>>>>            Move "intervalym"                            to aColumnType[i].sSQLType
94191>>>>            Move 189                                     to aColumnType[i].iSQLType
94192>>>>            Move False                                   to aColumnType[i].bCanEditSize
94193>>>>            Move True                                    to aColumnType[i].bNativeDataType
94194>>>>            Move 23                                      to aColumnType[i].iDefaultSize
94195>>>>            Move -1                                      to aColumnType[i].iMinSize
94196>>>>            Move -1                                      to aColumnType[i].nMaxSize
94197>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
94198>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
94199>>>>            Move -1                                      to aColumnType[i].sPrecision
94200>>>>            Increment i
94201>>>>
94201>>>>            Move "long"                                  to aColumnType[i].sSQLType
94202>>>>            Move 8                                       to aColumnType[i].iSQLType
94203>>>>            Move True                                    to aColumnType[i].bCanEditSize
94204>>>>            Move True                                    to aColumnType[i].bNativeDataType
94205>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
94206>>>>            Move 1                                       to aColumnType[i].iMinSize
94207>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94208>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94209>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94210>>>>            Move 16384                                   to aColumnType[i].sPrecision
94211>>>>            Increment i
94212>>>>
94212>>>>            Move "longraw"                               to aColumnType[i].sSQLType
94213>>>>            Move 24                                      to aColumnType[i].iSQLType
94214>>>>            Move True                                    to aColumnType[i].bCanEditSize
94215>>>>            Move True                                    to aColumnType[i].bNativeDataType
94216>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
94217>>>>            Move 1                                       to aColumnType[i].iMinSize
94218>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94219>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
94220>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
94221>>>>            Move 16384                                   to aColumnType[i].sPrecision
94222>>>>            Increment i
94223>>>>
94223>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
94224>>>>            Move 286                                     to aColumnType[i].iSQLType
94225>>>>            Move True                                    to aColumnType[i].bCanEditSize
94226>>>>            Move True                                    to aColumnType[i].bNativeDataType
94227>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94228>>>>            Move 1                                       to aColumnType[i].iMinSize
94229>>>>            Move 2000                                    to aColumnType[i].nMaxSize
94230>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94231>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94232>>>>            Move 2000                                    to aColumnType[i].sPrecision
94233>>>>            Increment i
94234>>>>
94234>>>>            Move "nclob"                                 to aColumnType[i].sSQLType
94235>>>>            Move 288                                     to aColumnType[i].iSQLType
94236>>>>            Move True                                    to aColumnType[i].bCanEditSize
94237>>>>            Move True                                    to aColumnType[i].bNativeDataType
94238>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
94239>>>>            Move 1                                       to aColumnType[i].iMinSize
94240>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94241>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
94242>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
94243>>>>            Move 16384                                   to aColumnType[i].sPrecision
94244>>>>            Increment i
94245>>>>
94245>>>>            Move "number"                                to aColumnType[i].sSQLType
94246>>>>            Move 2                                       to aColumnType[i].iSQLType
94247>>>>            Move True                                    to aColumnType[i].bCanEditSize
94248>>>>            Move True                                    to aColumnType[i].bNativeDataType
94249>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94250>>>>            Move 1                                       to aColumnType[i].iMinSize
94251>>>>            Move 14                                      to aColumnType[i].nMaxSize
94252>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
94253>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
94254>>>>            Move 14                                      to aColumnType[i].sPrecision
94255>>>>            Increment i
94256>>>>
94256>>>>            Move "nvarchar2"                             to aColumnType[i].sSQLType
94257>>>>            Move 287                                     to aColumnType[i].iSQLType
94258>>>>            Move True                                    to aColumnType[i].bCanEditSize
94259>>>>            Move True                                    to aColumnType[i].bNativeDataType
94260>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94261>>>>            Move 1                                       to aColumnType[i].iMinSize
94262>>>>            Move 4000                                    to aColumnType[i].nMaxSize
94263>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94264>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94265>>>>            Move 4000                                    to aColumnType[i].sPrecision
94266>>>>            Increment i
94267>>>>
94267>>>>            Move "raw"                                   to aColumnType[i].sSQLType
94268>>>>            Move 23                                      to aColumnType[i].iSQLType
94269>>>>            Move True                                    to aColumnType[i].bCanEditSize
94270>>>>            Move True                                    to aColumnType[i].bNativeDataType
94271>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94272>>>>            Move 1                                       to aColumnType[i].iMinSize
94273>>>>            Move 2000                                    to aColumnType[i].nMaxSize
94274>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
94275>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
94276>>>>            Move 2000                                    to aColumnType[i].sPrecision
94277>>>>            Increment i
94278>>>>
94278>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
94279>>>>            Move 187                                     to aColumnType[i].iSQLType
94280>>>>            Move False                                   to aColumnType[i].bCanEditSize
94281>>>>            Move True                                    to aColumnType[i].bNativeDataType
94282>>>>            Move 23                                      to aColumnType[i].iDefaultSize
94283>>>>            Move -1                                      to aColumnType[i].iMinSize
94284>>>>            Move -1                                      to aColumnType[i].nMaxSize
94285>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
94286>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
94287>>>>            Move -1                                      to aColumnType[i].sPrecision
94288>>>>            Increment i
94289>>>>
94289>>>>            Move "timestampltz"                          to aColumnType[i].sSQLType
94290>>>>            Move 232                                     to aColumnType[i].iSQLType
94291>>>>            Move False                                   to aColumnType[i].bCanEditSize
94292>>>>            Move True                                    to aColumnType[i].bNativeDataType
94293>>>>            Move 23                                      to aColumnType[i].iDefaultSize
94294>>>>            Move -1                                      to aColumnType[i].iMinSize
94295>>>>            Move -1                                      to aColumnType[i].nMaxSize
94296>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
94297>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
94298>>>>            Move -1                                      to aColumnType[i].sPrecision
94299>>>>            Increment i
94300>>>>
94300>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
94301>>>>            Move 188                                     to aColumnType[i].iSQLType
94302>>>>            Move False                                   to aColumnType[i].bCanEditSize
94303>>>>            Move True                                    to aColumnType[i].bNativeDataType
94304>>>>            Move 23                                      to aColumnType[i].iDefaultSize
94305>>>>            Move -1                                      to aColumnType[i].iMinSize
94306>>>>            Move -1                                      to aColumnType[i].nMaxSize
94307>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
94308>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
94309>>>>            Move -1                                      to aColumnType[i].sPrecision
94310>>>>            Increment i
94311>>>>
94311>>>>            Move "varchar2"                              to aColumnType[i].sSQLType
94312>>>>            Move 1                                       to aColumnType[i].iSQLType
94313>>>>            Move True                                    to aColumnType[i].bCanEditSize
94314>>>>            Move True                                    to aColumnType[i].bNativeDataType
94315>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94316>>>>            Move 1                                       to aColumnType[i].iMinSize
94317>>>>            Move 4000                                    to aColumnType[i].nMaxSize
94318>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94319>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94320>>>>            Move 4000                                    to aColumnType[i].sPrecision
94321>>>>            Increment i
94322>>>>
94322>>>>
94322>>>        
94322>>>//        Move eOracle_BLOB       to ColumnType[i].iSQLType
94322>>>//        Move "BLOB"             to ColumnType[i].sSQLType
94322>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
94322>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
94322>>>//        Move "16384"            to ColumnType[i].sPrecision
94322>>>//        Increment i
94322>>>//
94322>>>//        Move eOracle_CHAR       to ColumnType[i].iSQLType
94322>>>//        Move "CHAR"             to ColumnType[i].sSQLType
94322>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
94322>>>//        Move "Text"             to ColumnType[i].sDataFlexType
94322>>>//        Move "2000"             to ColumnType[i].sPrecision
94322>>>//        Increment i
94322>>>//
94322>>>//        Move eOracle_CLOB       to ColumnType[i].iSQLType
94322>>>//        Move "CLOB"             to ColumnType[i].sSQLType
94322>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
94322>>>//        Move "Text"             to ColumnType[i].sDataFlexType
94322>>>//        Move "16384"            to ColumnType[i].sPrecision
94322>>>//        Increment i
94322>>>//
94322>>>//        Move eOracle_DATE       to ColumnType[i].iSQLType
94322>>>//        Move "DATE"             to ColumnType[i].sSQLType
94322>>>//        Move DF_Date            to ColumnType[i].iDataFlexType
94322>>>//        Move "Date"             to ColumnType[i].sDataFlexType
94322>>>//        Move "6.0"              to ColumnType[i].sPrecision
94322>>>//        Move True               to ColumnType[i].bCanEditSize
94322>>>//        Increment i
94322>>>//
94322>>>//        Move eOracle_FLOAT      to ColumnType[i].iSQLType
94322>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
94322>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94322>>>//        Move "Number"           to ColumnType[i].sDataFlexType
94322>>>//        Move "14.8"             to ColumnType[i].sPrecision
94322>>>//        Increment i
94322>>>//
94322>>>//        Move eOracle_INT        to ColumnType[i].iSQLType
94322>>>//        Move "INT"              to ColumnType[i].sSQLType
94322>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94322>>>//        Move "Number"           to ColumnType[i].sDataFlexType
94322>>>//        Move "14.0"             to ColumnType[i].sPrecision
94322>>>//        Increment i
94322>>>//
94322>>>//        Move eOracle_INTERVALDS to ColumnType[i].iSQLType
94322>>>//        Move "INTERVALDAYTOSEC" to ColumnType[i].sSQLType
94322>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
94322>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
94322>>>//        Move "23.0"             to ColumnType[i].sPrecision
94322>>>//        Move True               to ColumnType[i].bCanEditSize
94322>>>//        Increment i
94322>>>//
94322>>>//        Move eOracle_INTERVALYM  to ColumnType[i].iSQLType
94322>>>//        Move "INTERVALYEARTOMON" to ColumnType[i].sSQLType
94322>>>//        Move DF_DATETIME         to ColumnType[i].iDataFlexType
94322>>>//        Move "DateTime"          to ColumnType[i].sDataFlexType
94322>>>//        Move "23.0"              to ColumnType[i].sPrecision
94322>>>//        Move True                to ColumnType[i].bCanEditSize
94322>>>//        Increment i
94322>>>//
94322>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
94322>>>//        Move "LONG"             to ColumnType[i].sSQLType
94322>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
94322>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
94322>>>//        Move "16384"            to ColumnType[i].sPrecision
94322>>>//        Increment i
94322>>>//
94322>>>//        Move eOracle_LONGRAW    to ColumnType[i].iSQLType
94322>>>//        Move "LONG RAW"         to ColumnType[i].sSQLType
94322>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
94322>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
94322>>>//        Move "16384"            to ColumnType[i].sPrecision
94322>>>//        Increment i
94322>>>//
94322>>>//        Move eOracle_NCHAR      to ColumnType[i].iSQLType
94322>>>//        Move "NCHAR"            to ColumnType[i].sSQLType
94322>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
94322>>>//        Move "Text"             to ColumnType[i].sDataFlexType
94322>>>//        Move "2000"             to ColumnType[i].sPrecision
94322>>>//        Increment i
94322>>>//
94322>>>//        Move eOracle_NCLOB      to ColumnType[i].iSQLType
94322>>>//        Move "NCLOB"            to ColumnType[i].sSQLType
94322>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
94322>>>//        Move "Text"             to ColumnType[i].sDataFlexType
94322>>>//        Move "16384"            to ColumnType[i].sPrecision
94322>>>//        Increment i
94322>>>//
94322>>>//        Move eOracle_NUMBER     to ColumnType[i].iSQLType
94322>>>//        Move "NUMBER"           to ColumnType[i].sSQLType
94322>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94322>>>//        Move "Number"           to ColumnType[i].sDataFlexType
94322>>>//        Move "14.8"             to ColumnType[i].sPrecision
94322>>>//        Increment i
94322>>>//
94322>>>//        Move eOracle_NVARCHAR2  to ColumnType[i].iSQLType
94322>>>//        Move "NVARCHAR2"        to ColumnType[i].sSQLType
94322>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
94322>>>//        Move "Text"             to ColumnType[i].sDataFlexType
94322>>>//        Move "4000"             to ColumnType[i].sPrecision
94322>>>//        Increment i
94322>>>//
94322>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
94322>>>//        Move "RAW"              to ColumnType[i].sSQLType
94322>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
94322>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
94322>>>//        Move "2000"             to ColumnType[i].sPrecision
94322>>>//        Increment i
94322>>>//
94322>>>//        Move eOracle_ROWID      to ColumnType[i].iSQLType
94322>>>//        Move "ROWID"            to ColumnType[i].sSQLType
94322>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
94322>>>//        Move "Text"             to ColumnType[i].sDataFlexType
94322>>>//        Move "16384"            to ColumnType[i].sPrecision
94322>>>//        Increment i
94322>>>//
94322>>>//        Move eOracle_TIMESTAMP  to ColumnType[i].iSQLType
94322>>>//        Move "TimeStamp"        to ColumnType[i].sSQLType
94322>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
94322>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
94322>>>//        Move "11.0"             to ColumnType[i].sPrecision
94322>>>//        Move True               to ColumnType[i].bCanEditSize
94322>>>//        Increment i
94322>>>//
94322>>>//        Move eOracle_TIMESTAMPLTZ   to ColumnType[i].iSQLType
94322>>>//        Move "TIMESTAMPLOCALTZ"     to ColumnType[i].sSQLType
94322>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
94322>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
94322>>>//        Move "13.0"                 to ColumnType[i].sPrecision
94322>>>//        Move True                   to ColumnType[i].bCanEditSize
94322>>>//        Increment i
94322>>>//
94322>>>//        Move eOracle_TIMESTAMPTZ    to ColumnType[i].iSQLType
94322>>>//        Move "TIMEZONETIMEZONE"     to ColumnType[i].sSQLType
94322>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
94322>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
94322>>>//        Move "11.0"                 to ColumnType[i].sPrecision
94322>>>//        Move True                   to ColumnType[i].bCanEditSize
94322>>>//        Increment i
94322>>>//
94322>>>//        Move eOracle_VARCHAR2   to ColumnType[i].iSQLType
94322>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
94322>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
94322>>>//        Move "Text"             to ColumnType[i].sDataFlexType
94322>>>//        Move "16384"            to ColumnType[i].sPrecision
94322>>>
94322>>>        Function_Return aColumnType
94323>>>    End_Function
94324>>>
94324>>>    // PostgreSQL Data Types
94324>>>    Function _UtilEnumeratePostgreSQLTypes Returns tColumnType[]
94326>>>        tColumnType[] aColumnType
94326>>>        tColumnType[] aColumnType
94327>>>        Integer i
94327>>>        
Including file: mdspgsql_DriverDef.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\mdspgsql_DriverDef.inc)
94327>>>>// Generated By The Database Update Framework
94327>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdspgsql_DriverDef.xml
94327>>>>// Driver COLUMN DATA TYPES
94327>>>>//
94327>>>>// Created: 2018-03-14 23:47:02.984
94327>>>>
94327>>>>            Move "bigint"                                to aColumnType[i].sSQLType
94328>>>>            Move 20                                      to aColumnType[i].iSQLType
94329>>>>            Move True                                    to aColumnType[i].bCanEditSize
94330>>>>            Move True                                    to aColumnType[i].bNativeDataType
94331>>>>            Move 14                                      to aColumnType[i].iDefaultSize
94332>>>>            Move 1                                       to aColumnType[i].iMinSize
94333>>>>            Move 14                                      to aColumnType[i].nMaxSize
94334>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
94335>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
94336>>>>            Move 14                                      to aColumnType[i].sPrecision
94337>>>>            Increment i
94338>>>>
94338>>>>            Move "bit"                                   to aColumnType[i].sSQLType
94339>>>>            Move 1560                                    to aColumnType[i].iSQLType
94340>>>>            Move True                                    to aColumnType[i].bCanEditSize
94341>>>>            Move True                                    to aColumnType[i].bNativeDataType
94342>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94343>>>>            Move 1                                       to aColumnType[i].iMinSize
94344>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94345>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
94346>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
94347>>>>            Move 16384                                   to aColumnType[i].sPrecision
94348>>>>            Increment i
94349>>>>
94349>>>>            Move "boolean"                               to aColumnType[i].sSQLType
94350>>>>            Move 16                                      to aColumnType[i].iSQLType
94351>>>>            Move False                                   to aColumnType[i].bCanEditSize
94352>>>>            Move True                                    to aColumnType[i].bNativeDataType
94353>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94354>>>>            Move -1                                      to aColumnType[i].iMinSize
94355>>>>            Move -1                                      to aColumnType[i].nMaxSize
94356>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94357>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94358>>>>            Move -1                                      to aColumnType[i].sPrecision
94359>>>>            Increment i
94360>>>>
94360>>>>            Move "bytea"                                 to aColumnType[i].sSQLType
94361>>>>            Move 17                                      to aColumnType[i].iSQLType
94362>>>>            Move True                                    to aColumnType[i].bCanEditSize
94363>>>>            Move True                                    to aColumnType[i].bNativeDataType
94364>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94365>>>>            Move 1                                       to aColumnType[i].iMinSize
94366>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94367>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
94368>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
94369>>>>            Move 16384                                   to aColumnType[i].sPrecision
94370>>>>            Increment i
94371>>>>
94371>>>>            Move "char"                                  to aColumnType[i].sSQLType
94372>>>>            Move 18                                      to aColumnType[i].iSQLType
94373>>>>            Move True                                    to aColumnType[i].bCanEditSize
94374>>>>            Move True                                    to aColumnType[i].bNativeDataType
94375>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94376>>>>            Move 1                                       to aColumnType[i].iMinSize
94377>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94378>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94379>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94380>>>>            Move 16384                                   to aColumnType[i].sPrecision
94381>>>>            Increment i
94382>>>>
94382>>>>            Move "citext"                                to aColumnType[i].sSQLType
94383>>>>            Move -25                                     to aColumnType[i].iSQLType
94384>>>>            Move True                                    to aColumnType[i].bCanEditSize
94385>>>>            Move True                                    to aColumnType[i].bNativeDataType
94386>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94387>>>>            Move 1                                       to aColumnType[i].iMinSize
94388>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94389>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94390>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94391>>>>            Move 16384                                   to aColumnType[i].sPrecision
94392>>>>            Increment i
94393>>>>
94393>>>>            Move "date"                                  to aColumnType[i].sSQLType
94394>>>>            Move 1082                                    to aColumnType[i].iSQLType
94395>>>>            Move False                                   to aColumnType[i].bCanEditSize
94396>>>>            Move True                                    to aColumnType[i].bNativeDataType
94397>>>>            Move 6                                       to aColumnType[i].iDefaultSize
94398>>>>            Move -1                                      to aColumnType[i].iMinSize
94399>>>>            Move -1                                      to aColumnType[i].nMaxSize
94400>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
94401>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
94402>>>>            Move 6                                       to aColumnType[i].sPrecision
94403>>>>            Increment i
94404>>>>
94404>>>>            Move "double"                                to aColumnType[i].sSQLType
94405>>>>            Move 701                                     to aColumnType[i].iSQLType
94406>>>>            Move True                                    to aColumnType[i].bCanEditSize
94407>>>>            Move True                                    to aColumnType[i].bNativeDataType
94408>>>>            Move 14                                      to aColumnType[i].iDefaultSize
94409>>>>            Move 1                                       to aColumnType[i].iMinSize
94410>>>>            Move 14                                      to aColumnType[i].nMaxSize
94411>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94412>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94413>>>>            Move 14                                      to aColumnType[i].sPrecision
94414>>>>            Increment i
94415>>>>
94415>>>>            Move "integer"                               to aColumnType[i].sSQLType
94416>>>>            Move 23                                      to aColumnType[i].iSQLType
94417>>>>            Move True                                    to aColumnType[i].bCanEditSize
94418>>>>            Move True                                    to aColumnType[i].bNativeDataType
94419>>>>            Move 11                                      to aColumnType[i].iDefaultSize
94420>>>>            Move 1                                       to aColumnType[i].iMinSize
94421>>>>            Move 11                                      to aColumnType[i].nMaxSize
94422>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
94423>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
94424>>>>            Move 11                                      to aColumnType[i].sPrecision
94425>>>>            Increment i
94426>>>>
94426>>>>            Move "money"                                 to aColumnType[i].sSQLType
94427>>>>            Move 790                                     to aColumnType[i].iSQLType
94428>>>>            Move True                                    to aColumnType[i].bCanEditSize
94429>>>>            Move True                                    to aColumnType[i].bNativeDataType
94430>>>>            Move 30                                      to aColumnType[i].iDefaultSize
94431>>>>            Move 1                                       to aColumnType[i].iMinSize
94432>>>>            Move 30                                      to aColumnType[i].nMaxSize
94433>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
94434>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
94435>>>>            Move 30                                      to aColumnType[i].sPrecision
94436>>>>            Increment i
94437>>>>
94437>>>>            Move "numeric"                               to aColumnType[i].sSQLType
94438>>>>            Move 1700                                    to aColumnType[i].iSQLType
94439>>>>            Move True                                    to aColumnType[i].bCanEditSize
94440>>>>            Move True                                    to aColumnType[i].bNativeDataType
94441>>>>            Move 14                                      to aColumnType[i].iDefaultSize
94442>>>>            Move 1                                       to aColumnType[i].iMinSize
94443>>>>            Move 14                                      to aColumnType[i].nMaxSize
94444>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94445>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94446>>>>            Move 14                                      to aColumnType[i].sPrecision
94447>>>>            Increment i
94448>>>>
94448>>>>            Move "oid"                                   to aColumnType[i].sSQLType
94449>>>>            Move 26                                      to aColumnType[i].iSQLType
94450>>>>            Move False                                   to aColumnType[i].bCanEditSize
94451>>>>            Move True                                    to aColumnType[i].bNativeDataType
94452>>>>            Move 20                                      to aColumnType[i].iDefaultSize
94453>>>>            Move -1                                      to aColumnType[i].iMinSize
94454>>>>            Move -1                                      to aColumnType[i].nMaxSize
94455>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
94456>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
94457>>>>            Move -1                                      to aColumnType[i].sPrecision
94458>>>>            Increment i
94459>>>>
94459>>>>            Move "real"                                  to aColumnType[i].sSQLType
94460>>>>            Move 700                                     to aColumnType[i].iSQLType
94461>>>>            Move True                                    to aColumnType[i].bCanEditSize
94462>>>>            Move True                                    to aColumnType[i].bNativeDataType
94463>>>>            Move 6                                       to aColumnType[i].iDefaultSize
94464>>>>            Move 1                                       to aColumnType[i].iMinSize
94465>>>>            Move 6                                       to aColumnType[i].nMaxSize
94466>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
94467>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
94468>>>>            Move 6                                       to aColumnType[i].sPrecision
94469>>>>            Increment i
94470>>>>
94470>>>>            Move "regproc"                               to aColumnType[i].sSQLType
94471>>>>            Move 24                                      to aColumnType[i].iSQLType
94472>>>>            Move False                                   to aColumnType[i].bCanEditSize
94473>>>>            Move True                                    to aColumnType[i].bNativeDataType
94474>>>>            Move 64                                      to aColumnType[i].iDefaultSize
94475>>>>            Move -1                                      to aColumnType[i].iMinSize
94476>>>>            Move -1                                      to aColumnType[i].nMaxSize
94477>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94478>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94479>>>>            Move -1                                      to aColumnType[i].sPrecision
94480>>>>            Increment i
94481>>>>
94481>>>>            Move "smallint"                              to aColumnType[i].sSQLType
94482>>>>            Move 21                                      to aColumnType[i].iSQLType
94483>>>>            Move True                                    to aColumnType[i].bCanEditSize
94484>>>>            Move True                                    to aColumnType[i].bNativeDataType
94485>>>>            Move 6                                       to aColumnType[i].iDefaultSize
94486>>>>            Move 1                                       to aColumnType[i].iMinSize
94487>>>>            Move 6                                       to aColumnType[i].nMaxSize
94488>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
94489>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
94490>>>>            Move 6                                       to aColumnType[i].sPrecision
94491>>>>            Increment i
94492>>>>
94492>>>>            Move "text"                                  to aColumnType[i].sSQLType
94493>>>>            Move 25                                      to aColumnType[i].iSQLType
94494>>>>            Move True                                    to aColumnType[i].bCanEditSize
94495>>>>            Move True                                    to aColumnType[i].bNativeDataType
94496>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94497>>>>            Move 1                                       to aColumnType[i].iMinSize
94498>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94499>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94500>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94501>>>>            Move 16384                                   to aColumnType[i].sPrecision
94502>>>>            Increment i
94503>>>>
94503>>>>            Move "time"                                  to aColumnType[i].sSQLType
94504>>>>            Move 1083                                    to aColumnType[i].iSQLType
94505>>>>            Move True                                    to aColumnType[i].bCanEditSize
94506>>>>            Move True                                    to aColumnType[i].bNativeDataType
94507>>>>            Move 8                                       to aColumnType[i].iDefaultSize
94508>>>>            Move 8                                       to aColumnType[i].iMinSize
94509>>>>            Move 15                                      to aColumnType[i].nMaxSize
94510>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94511>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94512>>>>            Move 15                                      to aColumnType[i].sPrecision
94513>>>>            Increment i
94514>>>>
94514>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
94515>>>>            Move 1114                                    to aColumnType[i].iSQLType
94516>>>>            Move False                                   to aColumnType[i].bCanEditSize
94517>>>>            Move True                                    to aColumnType[i].bNativeDataType
94518>>>>            Move 23                                      to aColumnType[i].iDefaultSize
94519>>>>            Move -1                                      to aColumnType[i].iMinSize
94520>>>>            Move -1                                      to aColumnType[i].nMaxSize
94521>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
94522>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
94523>>>>            Move -1                                      to aColumnType[i].sPrecision
94524>>>>            Increment i
94525>>>>
94525>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
94526>>>>            Move 1184                                    to aColumnType[i].iSQLType
94527>>>>            Move False                                   to aColumnType[i].bCanEditSize
94528>>>>            Move True                                    to aColumnType[i].bNativeDataType
94529>>>>            Move 23                                      to aColumnType[i].iDefaultSize
94530>>>>            Move -1                                      to aColumnType[i].iMinSize
94531>>>>            Move -1                                      to aColumnType[i].nMaxSize
94532>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94533>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94534>>>>            Move -1                                      to aColumnType[i].sPrecision
94535>>>>            Increment i
94536>>>>
94536>>>>            Move "uuid"                                  to aColumnType[i].sSQLType
94537>>>>            Move 2950                                    to aColumnType[i].iSQLType
94538>>>>            Move False                                   to aColumnType[i].bCanEditSize
94539>>>>            Move True                                    to aColumnType[i].bNativeDataType
94540>>>>            Move 40                                      to aColumnType[i].iDefaultSize
94541>>>>            Move -1                                      to aColumnType[i].iMinSize
94542>>>>            Move -1                                      to aColumnType[i].nMaxSize
94543>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94544>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94545>>>>            Move -1                                      to aColumnType[i].sPrecision
94546>>>>            Increment i
94547>>>>
94547>>>>            Move "varbit"                                to aColumnType[i].sSQLType
94548>>>>            Move 1562                                    to aColumnType[i].iSQLType
94549>>>>            Move True                                    to aColumnType[i].bCanEditSize
94550>>>>            Move True                                    to aColumnType[i].bNativeDataType
94551>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94552>>>>            Move 1                                       to aColumnType[i].iMinSize
94553>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94554>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94555>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94556>>>>            Move 16384                                   to aColumnType[i].sPrecision
94557>>>>            Increment i
94558>>>>
94558>>>>            Move "varchar"                               to aColumnType[i].sSQLType
94559>>>>            Move 1043                                    to aColumnType[i].iSQLType
94560>>>>            Move True                                    to aColumnType[i].bCanEditSize
94561>>>>            Move True                                    to aColumnType[i].bNativeDataType
94562>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94563>>>>            Move 1                                       to aColumnType[i].iMinSize
94564>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94565>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94566>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94567>>>>            Move 16384                                   to aColumnType[i].sPrecision
94568>>>>            Increment i
94569>>>>
94569>>>>
94569>>>        
94569>>>//        Move ePgSQL_INT8        to ColumnType[i].iSQLType
94569>>>//        Move "bigint"           to ColumnType[i].sSQLType
94569>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94569>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
94569>>>//        Move "14.0"             to ColumnType[i].sPrecision
94569>>>//        Move True               to ColumnType[i].bCanEditSize
94569>>>//        Increment i
94569>>>//
94569>>>//        Move ePgSQL_BIT         to ColumnType[i].iSQLType
94569>>>//        Move "bit"              to ColumnType[i].sSQLType
94569>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
94569>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
94569>>>//        Move "16384"            to ColumnType[i].sPrecision
94569>>>//        Increment i
94569>>>//
94569>>>//        Move ePgSQL_BOOL        to ColumnType[i].iSQLType
94569>>>//        Move "boolean"          to ColumnType[i].sSQLType
94569>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
94569>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
94569>>>//        Move "1"                to ColumnType[i].sPrecision
94569>>>//        Increment i
94569>>>//
94569>>>//        Move ePgSQL_BYTEA       to ColumnType[i].iSQLType
94569>>>//        Move "bytea"            to ColumnType[i].sSQLType
94569>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
94569>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
94569>>>//        Move "16384"            to ColumnType[i].sPrecision
94569>>>//        Increment i
94569>>>//
94569>>>//        Move ePgSQL_CHAR        to ColumnType[i].iSQLType
94569>>>//        Move "char"             to ColumnType[i].sSQLType
94569>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
94569>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
94569>>>//        Move "2000"             to ColumnType[i].sPrecision
94569>>>//        Increment i
94569>>>//
94569>>>//        Move ePgSQL_CITEXT      to ColumnType[i].iSQLType
94569>>>//        Move "citext"           to ColumnType[i].sSQLType
94569>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
94569>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
94569>>>//        Move "254"              to ColumnType[i].sPrecision
94569>>>//        Increment i
94569>>>//
94569>>>//        Move ePgSQL_DATE        to ColumnType[i].iSQLType
94569>>>//        Move "date"             to ColumnType[i].sSQLType
94569>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
94569>>>//        Move "Date"             to ColumnType[i].sDataFlexType
94569>>>//        Move "6.0"              to ColumnType[i].sPrecision
94569>>>//        Move True               to ColumnType[i].bCanEditSize
94569>>>//        Increment i
94569>>>//
94569>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
94569>>>//        Move "decimal"          to ColumnType[i].sSQLType
94569>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94569>>>//        Move "Decimal"          to ColumnType[i].sDataFlexType
94569>>>//        Move "14.8"             to ColumnType[i].sPrecision
94569>>>//        Increment i
94569>>>//
94569>>>//        Move ePgSQL_FLOAT8      to ColumnType[i].iSQLType
94569>>>//        Move "double"           to ColumnType[i].sSQLType
94569>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
94569>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
94569>>>//        Move "22"               to ColumnType[i].sPrecision
94569>>>//        Increment i
94569>>>//
94569>>>//        Move ePgSQL_INT4        to ColumnType[i].iSQLType
94569>>>//        Move "integer"          to ColumnType[i].sSQLType
94569>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94569>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
94569>>>//        Move "8.0"              to ColumnType[i].sPrecision
94569>>>//        Increment i
94569>>>//
94569>>>//        Move ePgSQL_MONEY       to ColumnType[i].iSQLType
94569>>>//        Move "money"            to ColumnType[i].sSQLType
94569>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94569>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
94569>>>//        Move "8.0"              to ColumnType[i].sPrecision
94569>>>//        Increment i
94569>>>//
94569>>>//        Move ePgSQL_OID         to ColumnType[i].iSQLType
94569>>>//        Move "oid"              to ColumnType[i].sSQLType
94569>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
94569>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
94569>>>//        Move "16384"            to ColumnType[i].sPrecision
94569>>>//        Increment i
94569>>>//
94569>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
94569>>>//        Move "real"             to ColumnType[i].sSQLType
94569>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94569>>>//        Move "Real"             to ColumnType[i].sDataFlexType
94569>>>//        Move "6.6"              to ColumnType[i].sPrecision
94569>>>//        Increment i
94569>>>//
94569>>>//        Move ePgSQL_REGPROC     to ColumnType[i].iSQLType
94569>>>//        Move "regproc"          to ColumnType[i].sSQLType
94569>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
94569>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
94569>>>//        Move "64"               to ColumnType[i].sPrecision
94569>>>//        Increment i
94569>>>//
94569>>>//        Move ePgSQL_INT2        to ColumnType[i].iSQLType
94569>>>//        Move "smallint"         to ColumnType[i].sSQLType
94569>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94569>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
94569>>>//        Move "6.0"              to ColumnType[i].sPrecision
94569>>>//        Increment i
94569>>>//
94569>>>//        Move ePgSQL_TEXT        to ColumnType[i].iSQLType
94569>>>//        Move "text"             to ColumnType[i].sSQLType
94569>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
94569>>>//        Move "Text"             to ColumnType[i].sDataFlexType
94569>>>//        Move "16384"            to ColumnType[i].sPrecision
94569>>>//        Increment i
94569>>>//
94569>>>//        Move ePgSQL_TIME        to ColumnType[i].iSQLType
94569>>>//        Move "time"             to ColumnType[i].sSQLType
94569>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
94569>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
94569>>>//        Move "15.0"             to ColumnType[i].sPrecision
94569>>>//        Increment i
94569>>>//
94569>>>//        Move ePgSQL_TIMESTAMP   to ColumnType[i].iSQLType
94569>>>//        Move "timestamp"        to ColumnType[i].sSQLType
94569>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
94569>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
94569>>>//        Move "23.0"             to ColumnType[i].sPrecision
94569>>>//        Move True               to ColumnType[i].bCanEditSize
94569>>>//        Increment i
94569>>>//
94569>>>//        Move ePgSQL_UUID        to ColumnType[i].iSQLType
94569>>>//        Move "uuid"             to ColumnType[i].sSQLType
94569>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
94569>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
94569>>>//        Move "40"               to ColumnType[i].sPrecision
94569>>>//        Move True               to ColumnType[i].bCanEditSize
94569>>>//        Increment i
94569>>>//
94569>>>//        Move ePgSQL_VARCHAR     to ColumnType[i].iSQLType
94569>>>//        Move "varchar"          to ColumnType[i].sSQLType
94569>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
94569>>>//        Move "DF_TEXT"          to ColumnType[i].sDataFlexType
94569>>>//        Move "16384"            to ColumnType[i].sPrecision
94569>>>//        Increment i
94569>>>
94569>>>        Function_Return aColumnType
94570>>>    End_Function
94571>>>
94571>>>    // Internal usage. Use the UtilColumnTypeXXX functions instead.
94571>>>    Function _UtilColumnType String sDriverID Integer iDbType Integer iType String sType Boolean bIntegerInputType Returns tColumnType
94573>>>        Integer iValue iSize iCount iStart
94573>>>        tColumnType[] ColumnTypeArray
94573>>>        tColumnType[] ColumnTypeArray
94574>>>        tColumnType RetvalType
94574>>>        tColumnType RetvalType
94574>>>        String sValue
94574>>>        Boolean bFrameworkDataFlexType
94574>>>
94574>>>        Move "Undefined" to RetvalType.sSQLType
94575>>>        Move -1999       to RetvalType.iSQLType
94576>>>
94576>>>        Move 0 to iStart
94577>>>        Move (Uppercase(sType)) to sType
94578>>>        Move (iType <= -1490) to bFrameworkDataFlexType
94579>>>        If (bFrameworkDataFlexType = True) Begin
94581>>>            Get UtilDUFDataTypeToSqlTypeMapping sDriverID iDbType iType to RetvalType
94582>>>            Function_Return RetvalType
94583>>>        End
94583>>>>
94583>>>
94583>>>        Get UtilEnumerateColumnTypes sDriverID iDbType to ColumnTypeArray
94584>>>
94584>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
94585>>>        Decrement iSize
94586>>>
94586>>>        for iCount from iStart to iSize
94592>>>>
94592>>>            Move ColumnTypeArray[iCount].iSQLType to iValue
94593>>>            Move ColumnTypeArray[iCount].sSQLType to sValue
94594>>>            If (bIntegerInputType = True) Begin
94596>>>                If (iValue = iType) Begin
94598>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
94599>>>                    Move iType                                  to RetvalType.iSQLType
94600>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
94601>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
94602>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
94603>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
94604>>>                    Move iSize to iCount // We're done!
94605>>>                End
94605>>>>
94605>>>            End
94605>>>>
94605>>>            Else Begin
94606>>>                Move (Uppercase(sValue)) to sValue
94607>>>                If (sValue = sType) Begin
94609>>>                    Move sType                                  to RetvalType.sSQLType
94610>>>                    Move ColumnTypeArray[iCount].iSQLType       to RetvalType.iSQLType
94611>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
94612>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
94613>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
94614>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
94615>>>                    Move iSize to iCount // We're done!
94616>>>                End
94616>>>>
94616>>>            End
94616>>>>
94616>>>        Loop
94617>>>>
94617>>>
94617>>>        // If no match was found it was probably because it was a DataFlex standard type that was passed.
94617>>>        // In which case we search for a match in DataFlex standard types:
94617>>>        If (RetvalType.sSQLType = "Undefined") Begin
94619>>>            Get _UtilEnumerateDataFlexTypes to ColumnTypeArray
94620>>>            Move (SizeOfArray(ColumnTypeArray)) to iSize
94621>>>            Decrement iSize
94622>>>
94622>>>            for iCount from iStart to iSize
94628>>>>
94628>>>                Move ColumnTypeArray[iCount].iSQLType to iValue
94629>>>                Move ColumnTypeArray[iCount].sSQLType to sValue
94630>>>                If (iValue = iType) Begin
94632>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
94633>>>                    Move iType                                  to RetvalType.iSQLType
94634>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
94635>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
94636>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
94637>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
94638>>>                    Move iSize to iCount // We're done!
94639>>>                End
94639>>>>
94639>>>            Loop
94640>>>>
94640>>>        End
94640>>>>
94640>>>
94640>>>        Function_Return RetvalType
94641>>>    End_Function
94642>>>
94642>>>    Function _AllTablesToConvert Returns Integer[]
94644>>>        Integer[] aTableConvertExceptions iTablesArray
94646>>>        Handle hTable
94646>>>        Integer iIndex
94646>>>        String sTableName
94646>>>        Boolean bFlexErrs
94646>>>
94646>>>        // a) Get the exception table array the developer has specified
94646>>>        Get paTableConvertExceptions to aTableConvertExceptions
94647>>>
94647>>>        // b) Add CodeMast, CodeType & DbVersion to exceptions
94647>>>        Repeat
94647>>>>
94647>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
94650>>>            If (hTable <> 0) Begin
94652>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
94655>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
94656>>>                If (bFlexErrs = False) Begin
94658>>>                    If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "DBVERSION") Begin
94660>>>                        Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
94661>>>                        If (iIndex = -1) Begin
94663>>>                            Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
94664>>>                        End
94664>>>>
94664>>>                    End
94664>>>>
94664>>>                End
94664>>>>
94664>>>            End
94664>>>>
94664>>>        Until (hTable = 0)
94666>>>
94666>>>        Move 0 to hTable
94667>>>
94667>>>        // c) Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
94667>>>        Repeat
94667>>>>
94667>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
94670>>>            If (hTable > 0) Begin
94672>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
94675>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
94676>>>                If (bFlexErrs = False) Begin
94678>>>                    Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
94679>>>                    If (iIndex = -1) Begin
94681>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
94682>>>                    End
94682>>>>
94682>>>                End
94682>>>>
94682>>>            End
94682>>>>
94682>>>        Until (hTable = 0)
94684>>>
94684>>>        Function_Return iTablesArray
94685>>>    End_Function
94686>>>
94686>>>    Function _AllTablesDateCorrections Returns Integer[]
94688>>>        Integer[] aTableDateCorrectionExceptions iTablesArray
94690>>>        Handle hTable
94690>>>        Integer iIndex
94690>>>        String sTableName
94690>>>        Boolean bFlexErrs
94690>>>
94690>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
94691>>>        Move 0 to hTable
94692>>>
94692>>>        // Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
94692>>>        Repeat
94692>>>>
94692>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
94695>>>            If (hTable > 0) Begin
94697>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
94700>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
94701>>>                If (bFlexErrs = False) Begin
94703>>>                    Move (SearchArray(hTable, aTableDateCorrectionExceptions)) to iIndex
94704>>>                    If (iIndex = -1) Begin
94706>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
94707>>>                    End
94707>>>>
94707>>>                End
94707>>>>
94707>>>            End
94707>>>>
94707>>>        Until (hTable = 0)
94709>>>
94709>>>        Function_Return iTablesArray
94710>>>    End_Function
94711>>>
94711>>>    Function _AppendAPIColumn tAPIColumn[] aCurrent String sFieldName Integer iType Integer iLength Integer iPrecision Integer iOptions Returns tAPIColumn[]
94713>>>        tAPIColumn NewAPIColumn
94713>>>        tAPIColumn NewAPIColumn
94713>>>
94713>>>        Move sFieldName to NewAPIColumn.sFieldName
94714>>>        Move iType      to NewAPIColumn.iType
94715>>>        Move iLength    to NewAPIColumn.iLength
94716>>>        Move iPrecision to NewAPIColumn.iPrecision
94717>>>        Move iOptions   to NewAPIColumn.iOptions
94718>>>
94718>>>        Move NewAPIColumn to aCurrent[SizeOfArray(aCurrent)]
94719>>>
94719>>>        Function_Return aCurrent
94720>>>    End_Function
94721>>>
94721>>>    Function _UtilIndexAppendSegmentFieldNames tAPIIndexSegment[] APIIndexSegment Returns String
94723>>>        String sRetval sFieldName
94723>>>        Integer iCount iSize
94723>>>
94723>>>        Move (SizeOfArray(APIIndexSegment)) to iSize
94724>>>        Decrement iSize
94725>>>        for iCount from 0 to iSize
94731>>>>
94731>>>            Move APIIndexSegment[iCount].sFieldName to sFieldName
94732>>>            Move (sRetval * (String(sFieldName))) to sRetval
94733>>>        Loop
94734>>>>
94734>>>        Move (Trim(sRetval)) to sRetval
94735>>>
94735>>>        Function_Return sRetval
94736>>>    End_Function
94737>>>
94737>>>    // *** Miscellaneous other functions ***
94737>>>    // Some of which can be used by both "Sqlxxx" and "Apixxx" functions.
94737>>>    //
94737>>>
94737>>>    // Callback functionality used when e.g. calling driver functions directly.
94737>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
94739>>>        Integer iPerc
94739>>>        Number nReady nTotal
94739>>>
94739>>>        Send DoAdvance of ghoProgressBar
94740>>>
94740>>>        If (sCallback_Text contains "Copy records") Begin
94742>>>            Move CS_SQLCopyingData to sCallback_Text
94743>>>        End
94743>>>>
94743>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
94745>>>            Move (Replace("Dropping index", sCallback_Text, CS_SQLDeletingIndex)) to sCallback_Text
94746>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_SQLDeletingIndex)) to sCallback_Text
94747>>>        End
94747>>>>
94747>>>        If (sCallback_Text contains "Creating index") Begin
94749>>>            Move (Replace("Creating index", sCallback_Text, CS_SQLCreatingIndex)) to sCallback_Text
94750>>>        End
94750>>>>
94750>>>
94750>>>        Case Begin
94750>>>            Case (iCallback_Type = DF_Message_Text)
94752>>>//                Set Message_Text of ghoStatusPanel to sCallback_Text
94752>>>                Set Action_Text  of ghoStatusPanel to ""
94753>>>                Case Break
94754>>>            Case (iCallback_Type = DF_Message_Heading_1)
94757>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94758>>>                Set Action_Text  of ghoStatusPanel to ""
94759>>>                Case Break
94760>>>            Case (iCallback_Type = DF_Message_Heading_2)
94763>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94764>>>                Set Action_Text  of ghoStatusPanel to ""
94765>>>                Case Break
94766>>>            Case (iCallback_Type = DF_Message_Heading_3)
94769>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94770>>>                Set Action_Text  of ghoStatusPanel to ""
94771>>>                Case Break
94772>>>            Case (iCallback_Type = DF_Message_Heading_4)
94775>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94776>>>                Set Action_Text  of ghoStatusPanel to ""
94777>>>                Case Break
94778>>>            Case (iCallback_Type = DF_Message_Heading_5)
94781>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94782>>>                Set Action_Text  of ghoStatusPanel to ""
94783>>>                Case Break
94784>>>            Case (iCallback_Type = DF_Message_Warning)
94787>>>                Send None
94788>>>                Case Break
94789>>>            Case (iCallback_Type = DF_Message_Progress_Title)
94792>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94793>>>                Set Action_Text  of ghoStatusPanel to ""
94794>>>                Case Break
94795>>>            Case (iCallback_Type = DF_Message_Progress_Value)
94798>>>                //*** Interpret numbers
94798>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
94799>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
94800>>>                Move ((nReady / nTotal) * 100)                                                    to iPerc
94801>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% Done (Total Number of Records:") * String(nTotal) + ")")
94802>>>                Case Break
94803>>>            Case Else
94803>>>                Set Message_Text to ""
94804>>>                Set Action_Text  to ""
94805>>>        Case End
94805>>>
94805>>>        Send ProcessEvents of ghoStatusPanel
94806>>>        Function_Return False
94807>>>    End_Function
94808>>>
94808>>>    Procedure IncreaseSortBufferSize
94810>>>        String sNull
94810>>>        Integer iSortBufferSize
94810>>>        Boolean bBufferSet
94810>>>
94810>>>        Move "" to sNull
94811>>>        Move (1024 * 128) to iSortBufferSize
94812>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_SET_MAX_SORT_BUFFER Callback ghoDbUpdateHandler Passing sNull sNull iSortBufferSize Result bBufferSet
94817>>>
94817>>>    End_Procedure
94818>>>
94818>>>    Procedure SetAllIndexesToBatch Handle hTable Boolean bSetToBatch
94820>>>        Integer iLastIndex iIndex iNumSegments
94820>>>        Boolean bOK    
94820>>>        String sDriverID
94820>>>
94820>>>        If (hTable > 0) Begin
94822>>>            Get UtilDriverFromTableNumber hTable to sDriverID
94823>>>            Close hTable
94824>>>            Get OpenTableExclusive hTable to bOK
94825>>>            If (bOK = False) Begin
94827>>>                Function_Return False
94828>>>            End
94828>>>>
94828>>>            Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex   
94831>>>            Structure_Start hTable sDriverID
94832>>>                for iIndex from 1 to iLastIndex
94838>>>>
94838>>>                    Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
94841>>>                    If (iNumSegments > 0) Begin                     
94843>>>                        If (bSetToBatch = True) Begin
94845>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_BATCH
94848>>>                        End                 
94848>>>>
94848>>>                        Else Begin
94849>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_ONLINE
94852>>>                        End
94852>>>>
94852>>>                    End
94852>>>>
94852>>>                Loop
94853>>>>
94853>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
94855>>>        End
94855>>>>
94855>>>    End_Procedure
94856>>>
94856>>>    Function NextFreeFilelistSlot Returns Handle
94858>>>        Handle hTable
94858>>>
94858>>>        Move 0 to hTable
94859>>>        Get_Attribute DF_FILE_NEXT_EMPTY of hTable to hTable
94862>>>
94862>>>        Function_Return hTable
94863>>>    End_Function
94864>>>
94864>>>    // For debugging purposes. To print Sql statements as they are build...
94864>>>    Procedure DebugPrint String sStmt String sFileName
94866>>>        Integer iCh
94866>>>        Get Seq_Append_Output_Channel sFileName to iCh
94867>>>            Write channel iCh sStmt
94869>>>        Send Seq_Close_Channel iCh
94870>>>    End_Procedure
94871>>>
94871>>>    // Returns the integer number for the passed Driver ID that is
94871>>>    // needed by some database API calls.
94871>>>    Function DriverIndex String sDriverID Returns Integer
94873>>>        String  sCurrentDriver
94873>>>        Integer iNumberOfDrivers iDriver iCount
94873>>>
94873>>>        Move 0 to iDriver
94874>>>
94874>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
94877>>>        for iCount from 1 to iNumberOfDrivers
94883>>>>
94883>>>
94883>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
94886>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
94888>>>                Move iCount to iDriver
94889>>>            End
94889>>>>
94889>>>        Loop
94890>>>>
94890>>>
94890>>>        // In case it was not found, it wasn't loaded so we do that now.
94890>>>        If (iDriver = 0) Begin
94892>>>            Move False to Err
94893>>>            Load_Driver sDriverID
94894>>>            If (Err = False) Begin
94896>>>                Move 1 to iDriver
94897>>>            End
94897>>>>
94897>>>        End
94897>>>>
94897>>>
94897>>>        Function_Return iDriver
94898>>>    End_Function
94899>>>
94899>>>    // Returns TRUE if table is opened exclusive, otherwise FALSE
94899>>>    // Note: If run from the Studio, CodeMast & CodeType _is_ open by the Studio,
94899>>>    //       so in that case we "cheat" and report those tables were opened OK.
94899>>>    Function OpenTableExclusive Handle hTable Returns Boolean
94901>>>        Integer iMode
94901>>>        Boolean bOpened
94901>>>        String sTableName
94901>>>
94901>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
94902>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
94905>>>        If (bOpened) Begin
94907>>>            If (IsDebuggerPresent()) Begin
94909>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
94912>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
94914>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
94915>>>                    Function_Return True
94916>>>                End
94916>>>>
94916>>>            End
94916>>>>
94916>>>            Get_Attribute DF_FILE_OPEN_MODE of hTable to iMode
94919>>>            If (iMode=DF_EXCLUSIVE) Begin
94921>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
94922>>>                Function_Return True
94923>>>            End
94923>>>>
94923>>>            Close hTable
94924>>>        End
94924>>>>
94924>>>        Else Begin
94925>>>            Open hTable
94927>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
94930>>>            If (bOpened and IsDebuggerPresent()) Begin
94932>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
94935>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
94937>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
94938>>>                    Function_Return True
94939>>>                End
94939>>>>
94939>>>            End
94939>>>>
94939>>>
94939>>>        End
94939>>>>
94939>>>        
94939>>>        Close hTable
94940>>>        Open hTable Mode DF_EXCLUSIVE
94942>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
94945>>>
94945>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
94946>>>        Function_Return bOpened
94947>>>    End_Function
94948>>>
94948>>>    Function AutoConnectionIDLogin Returns Boolean
94950>>>        String sConnectionID sConnectionString sDriverID
94950>>>        Boolean bExists bOK bSQLDriver
94950>>>        Handle hoCLI hoDriver
94950>>>        Integer iRetval
94950>>>        tSQLConnection SQLConnection
94950>>>        tSQLConnection SQLConnection
94950>>>
94950>>>        Get psDriverID to sDriverID
94951>>>        Get IsSQLDriver sDriverID to bSQLDriver
94952>>>        If (bSQLDriver = False) Begin
94954>>>            Function_Return True
94955>>>        End
94955>>>>
94955>>>
94955>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
94956>>>        Move SQLConnection.sDriverID                  to sDriverID
94957>>>        Move SQLConnection.sConnectionString          to sConnectionString
94958>>>        Get IsDAWSQLDriver sDriverID to bOK
94959>>>        If (bOK = True) Begin
94961>>>//            Get SQLLogin of ghoSQLConnectionHandler SQLConnection to bOK
94961>>>        End
94961>>>>
94961>>>        If (bOK = False) Begin
94963>>>            Get _MertechSQLManagerHandle to hoCLI
94964>>>            Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
94965>>>            Set psDriverID of hoDriver to SQLConnection.sDriverID
94966>>>            If (SQLConnection.sDriverID <> DATAFLEX_ID) Begin
94968>>>                Get DbLogin  of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
94969>>>                Send Destroy of hoDriver
94970>>>            End
94970>>>>
94970>>>            Function_Return False
94971>>>        End
94971>>>>
94971>>>
94971>>>        Move SQLConnection.sConnectionID to sConnectionID
94972>>>
94972>>>        Get IsConnectionID sConnectionID sDriverID to bExists
94973>>>        If (bExists = False) Begin
94975>>>            // We always start by deleting the current connection - if any - because the
94975>>>            // login details my have changed.
94975>>>            Get phoCLIHandler to hoCLI
94976>>>            Set psDriverID    of hoCLI to sDriverID
94977>>>            Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
94978>>>            Get UtilCreateConnectionID sConnectionID to bOk
94979>>>            If (bOk = False) Begin
94981>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be changed.")
94982>>>>
94982>>>                Function_Return False
94983>>>            End
94983>>>>
94983>>>            Move bOK to bExists
94984>>>        End
94984>>>>
94984>>>
94984>>>        Function_Return (bExists = True)
94985>>>    End_Function
94986>>>
94986>>>    // Scans to see if all tables can be opened exclusivly. I.e. that nobody else is running the application.
94986>>>    // Returns: False if nobody else is running
94986>>>    //          True if at least one table is open by another process (e.g. another user is running the application)
94986>>>    // N.B! Only works for Embedded DataFlex Tables! It will _not_ work for Sql tables because; these
94986>>>    //      tables are not locked as DataFlex tables are.
94986>>>    Function IsDatabaseInUse Returns Boolean
94988>>>        Handle  hTable
94988>>>        String  sRootName
94988>>>        Boolean bOpen bErr bAlias bOK bIsSQLTable bFlexErrs
94988>>>        Integer iCount iTables
94988>>>        
94988>>>        Move 0 to iTables
94989>>>        Set Action_Text of ghoStatusPanel to "Database in use check..."
94990>>>        Get AutoConnectionIDLogin to bOK
94991>>>        Get UtilFilelistNoOfTables to iTables
94992>>>        Set piPosition   of ghoProgressBar to 0
94993>>>        Set piAdvanceBy  of ghoProgressBar to 1      
94994>>>        Set piMaximum    of ghoProgressBar to iTables
94995>>>        Move 0 to hTable
94996>>>        Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
94999>>>        Move False to bErr
95000>>>        Send Ignore_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
95001>>>
95001>>>        Repeat
95001>>>>
95001>>>            Set piPosition of ghoProgressBar to iCount
95002>>>            Increment iCount
95003>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
95006>>>            Move (Uppercase(sRootName) = "FLEXERRS")  to bFlexErrs
95007>>>
95007>>>            // This test is only applicable for DataFlex embedded tables; so skip test if driver based table.
95007>>>            Get UtilTableIsSQLByRootName sRootName to bIsSQLTable
95008>>>            Move False to bOpen
95009>>>
95009>>>            // Don't bother about FlexErrs (Normally table 50)
95009>>>            If (bIsSQLTable = False and hTable <> 0 and bFlexErrs = False) Begin
95011>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
95012>>>                Open hTable
95014>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
95017>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
95018>>>                If (bOpen = True) Begin
95020>>>                    // We cannot open an Alias file exclusive as it will generate an error (4177 - "File in use")
95020>>>                    Get UtilTableIsAlias hTable to bAlias
95021>>>                    If (bAlias = False) Begin
95023>>>                        Close hTable
95024>>>                        Get OpenTableExclusive hTable to bOpen
95025>>>                        If (bOpen = False) Begin
95027>>>                            Move True to bErr
95028>>>                        End
95028>>>>
95028>>>                    End
95028>>>>
95028>>>                End
95028>>>>
95028>>>                Close hTable
95029>>>            End
95029>>>>
95029>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
95032>>>            If (bErr = True ) ;                Break
95035>>>        Until (not(hTable))
95037>>>
95037>>>        Set Action_Text of ghoStatusPanel to ""
95038>>>        Send Trap_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
95039>>>        Move False to Err
95040>>>
95040>>>        Function_Return bErr
95041>>>    End_Function
95042>>>
95042>>>    // Checks if the passed connection id exists in the CLI interface.
95042>>>    // This might be needed by API-methods when a connection id is to be used and
95042>>>    // the connection id hasn't been established with the driver's CLI interface.
95042>>>    // NOTE: Only applicable for DAW drivers.
95042>>>    Function IsConnectionID String sConnectionID String sDriverID Returns Boolean
95044>>>        String sID sConnString
95044>>>        Integer iDriver iNumConn iCount
95044>>>        Handle hoCLI
95044>>>        Boolean bOK
95044>>>
95044>>>        Get IsDAWSQLDriver sDriverID to bOK
95045>>>        If (bOK = False) Begin
95047>>>            Error DFERR_PROGRAM "Connection ID's can only be used with DAW drivers (not Mertech)."
95048>>>>
95048>>>            Function_Return False
95049>>>        End
95049>>>>
95049>>>
95049>>>        Move False to bOK
95050>>>        Get phoCLIHandler to hoCLI
95051>>>        If (hoCLI <> 0) Begin
95053>>>            Set psDriverID of hoCLI to sDriverID
95054>>>            Get DriverIndex of hoCLI sDriverID to iDriver
95055>>>
95055>>>            // If driver not loaded; load it.
95055>>>            If (iDriver = 0) Begin
95057>>>                Load_Driver sDriverID
95058>>>                Get DriverIndex sDriverID to iDriver
95059>>>            End
95059>>>>
95059>>>            If (iDriver <> 0) Begin
95061>>>                Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
95064>>>                Decrement iNumConn
95065>>>                for iCount from 0 to iNumConn
95071>>>>
95071>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iCount to sConnString
95074>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iCount to sID
95077>>>                    If (sID = sConnectionID) Begin
95079>>>                        Move True to bOK
95080>>>                    End
95080>>>>
95080>>>                Loop
95081>>>>
95081>>>            End
95081>>>>
95081>>>        End
95081>>>>
95081>>>
95081>>>        Function_Return bOK
95082>>>    End_Function
95083>>>
95083>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
95085>>>        Boolean bOK
95085>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
95086>>>        Function_Return bOK
95087>>>    End_Function
95088>>>
95088>>>    Function IsMertechDriver String sDriverID Returns Boolean
95090>>>        Boolean bOK
95090>>>        Move False to bOK
95091>>>        Move (sDriverID = SQLFLEX or sDriverID = ORAFLEX or sDriverID = MDSPgSQL or sDriverID = MDSMySQL) to bOK
95092>>>        Function_Return bOK
95093>>>    End_Function
95094>>>
95094>>>    Function IsMSSQLDriver Returns Boolean
95096>>>        Integer iDriverIndex
95096>>>
95096>>>        Get DriverIndex MSSQLDRV_ID to iDriverIndex
95097>>>
95097>>>        Function_Return (iDriverIndex <> 0)
95098>>>    End_Function
95099>>>
95099>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
95099>>>    // attempt to load the driver.
95099>>>    // Returns true if the passed driver is SQL based.
95099>>>    Function IsSQLDriver String sDriverID Returns Boolean
95101>>>        Boolean bOK
95101>>>
95101>>>        Get IsDAWSQLDriver sDriverID to bOK
95102>>>
95102>>>        If (bOK = False) Begin
95104>>>            Get IsMertechDriver sDriverID to bOK
95105>>>        End
95105>>>>
95105>>>
95105>>>        Function_Return bOK
95106>>>    End_Function
95107>>>
95107>>>    // *** Error Handler ***
95107>>>    //
95107>>>    // Note: If the cDbUpdateHandler & cDbUpdateVersion classes are used this error handler is _not_
95107>>>    //       used. Instead the Error_Report in the cDbUpdateHandler i used.
95107>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
95109>>>        Integer iSize iErrorMode
95109>>>        tSqlErrorArray aSqlErrorArray
95109>>>        tSqlErrorArray aSqlErrorArray
95109>>>
95109>>>        If (pbProcessingError(Self)) Begin
95111>>>            Procedure_Return
95112>>>        End
95112>>>>
95112>>>
95112>>>        Get Error_Report_Mode to iErrorMode
95113>>>        If (iErrorMode = DUF_ERROR_NO_REPORT) Begin
95115>>>            Procedure_Return
95116>>>        End
95116>>>>
95116>>>
95116>>>        Set pbProcessingError to True
95117>>>        Set pbSqlError to True
95118>>>        Get paSqlErrorArray      to aSqlErrorArray
95119>>>        Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iSize
95120>>>        Move sErrorText          to aSqlErrorArray.sSqlErrorArray[iSize]
95121>>>        Get psSQLStatementString to aSqlErrorArray.sSqlStatementArray[iSize]
95122>>>        Move iErrorNumber        to aSqlErrorArray.iSqlErrorArray[iSize]
95123>>>        Set paSqlErrorArray      to aSqlErrorArray
95124>>>        Set pbProcessingError to False
95125>>>    End_Procedure
95126>>>
95126>>>    // *** Miscellanous Helper Functions ***
95126>>>    //
95126>>>    // Helper function. Takes a DF_FILE_XXXX_NAME value as parameter and
95126>>>    // returns the table name only; stripped of any path or filename extension.
95126>>>    Function _TableNameOnly String sName Returns String
95128>>>        String sPath sExt
95128>>>
95128>>>        Get ParseFolderName sName to sPath
95129>>>        If (sPath <> "") Begin
95131>>>            Move (Replace(sPath, sName, "")) to sName
95132>>>        End
95132>>>>
95132>>>        Get ParseFileExtension sName to sExt
95133>>>        If (sExt <> "") Begin
95135>>>            Move (Replace(("." + sExt), sName, "")) to sName
95136>>>        End
95136>>>>
95136>>>
95136>>>        Function_Return sName
95137>>>    End_Function
95138>>>
95138>>>    // Removes any prefix to a table name.
95138>>>    // Example mssqldrv:mytable returns mytable
95138>>>    //         dbo.mytable returns mytable
95138>>>    Function _TableNoPrefix String sName Returns String
95140>>>        Integer iPos
95140>>>
95140>>>        Move (Pos(":", sName)) to iPos
95141>>>        If (iPos <> 0) Begin
95143>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
95144>>>        End
95144>>>>
95144>>>        Move (Pos(".", sName)) to iPos
95145>>>        If (iPos <> 0) Begin
95147>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
95148>>>        End
95148>>>>
95148>>>
95148>>>        Function_Return sName
95149>>>    End_Function
95150>>>
95150>>>    // Returns the first datapath found in the psDataPath property.
95150>>>    // The returned path always ends with a "\"
95150>>>    Function psDataPathFirstPart Returns String
95152>>>        String sDataPath
95152>>>        Integer iCount
95152>>>
95152>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
95153>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
95154>>>        If (iCount > 1) Begin
95156>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
95157>>>        End
95157>>>>
95157>>>        If (sDataPath <> "") Begin
95159>>>            Get vFolderFormat sDataPath to sDataPath
95160>>>        End
95160>>>>
95160>>>
95160>>>        Function_Return sDataPath
95161>>>    End_Function
95162>>>
95162>>>    Function psLogTextFileWithPath Returns String
95164>>>        String sFileName 
95164>>>        Handle hoLogFile
95164>>>        Get phoLogFile to hoLogFile
95165>>>        Get psLogTextFileWithPath of hoLogFile to sFileName
95166>>>        Function_Return sFileName
95167>>>    End_Function                     
95168>>>    
95168>>>    // *** Property Messages ***
95168>>>    //
95168>>>    // These "properties" are settings for the cSQLConnectionHandler class, but have been
95168>>>    // "duplicated" here so connection properties can be relayed to the ghoSQLConnectionHandler object
95168>>>    //
95168>>>
95168>>>    Function pSQLConnection Returns tSQLConnection
95170>>>        tSQLConnection SQLConnection
95170>>>        tSQLConnection SQLConnection
95170>>>        If (ghoSQLConnectionHandler = 0) Begin
95172>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
95172>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95173>>>>
95173>>>            Function_Return
95174>>>        End
95174>>>>
95174>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
95175>>>        Function_Return SQLConnection
95176>>>    End_Function
95177>>>
95177>>>    // * Dummy function for the Studio's Code Explorer *
95177>>>    Function OTHER_CLASS_PROPERTIES Returns Boolean
95179>>>        Function_Return False
95180>>>    End_Function
95181>>>
95181>>>    Procedure Set psServer String sValue
95183>>>        If (ghoSQLConnectionHandler = 0) Begin
95185>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
95185>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95186>>>>
95186>>>            Procedure_Return
95187>>>        End
95187>>>>
95187>>>        Set psServer of ghoSQLConnectionHandler to sValue
95188>>>    End_Procedure
95189>>>
95189>>>    Function psServer Returns String
95191>>>        String sValue
95191>>>        If (ghoSQLConnectionHandler = 0) Begin
95193>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95194>>>>
95194>>>            Function_Return
95195>>>        End
95195>>>>
95195>>>        Get psServer of ghoSQLConnectionHandler to sValue
95196>>>        Function_Return sValue
95197>>>    End_Function
95198>>>
95198>>>    Procedure Set psDatabase String sValue
95200>>>        If (ghoSQLConnectionHandler = 0) Begin
95202>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95203>>>>
95203>>>            Procedure_Return
95204>>>        End
95204>>>>
95204>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
95205>>>    End_Procedure
95206>>>
95206>>>    Function psDatabase Returns String
95208>>>        String sValue
95208>>>        If (ghoSQLConnectionHandler = 0) Begin
95210>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95211>>>>
95211>>>            Function_Return
95212>>>        End
95212>>>>
95212>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
95213>>>        Function_Return sValue
95214>>>    End_Function
95215>>>
95215>>>    Procedure Set psUserID String sValue
95217>>>        If (ghoSQLConnectionHandler = 0) Begin
95219>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95220>>>>
95220>>>            Function_Return
95221>>>        End
95221>>>>
95221>>>        Set psUserID of ghoSQLConnectionHandler to sValue
95222>>>    End_Procedure
95223>>>
95223>>>    Function psUserID Returns String
95225>>>        String sValue
95225>>>        If (ghoSQLConnectionHandler = 0) Begin
95227>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95228>>>>
95228>>>            Function_Return
95229>>>        End
95229>>>>
95229>>>        Get psUserID of ghoSQLConnectionHandler to sValue
95230>>>        Function_Return sValue
95231>>>    End_Function
95232>>>
95232>>>    Procedure Set psPassword String sValue
95234>>>        If (ghoSQLConnectionHandler = 0) Begin
95236>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95237>>>>
95237>>>            Procedure_Return
95238>>>        End
95238>>>>
95238>>>        Set psPassword of ghoSQLConnectionHandler to sValue
95239>>>    End_Procedure
95240>>>
95240>>>    Function psPassword Returns String
95242>>>        String sValue
95242>>>        If (ghoSQLConnectionHandler = 0) Begin
95244>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95245>>>>
95245>>>            Function_Return
95246>>>        End
95246>>>>
95246>>>        Get psPassword of ghoSQLConnectionHandler to sValue
95247>>>        Function_Return sValue
95248>>>    End_Function
95249>>>
95249>>>    Procedure Set pbTrusted Boolean bValue
95251>>>        If (ghoSQLConnectionHandler = 0) Begin
95253>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95254>>>>
95254>>>            Procedure_Return
95255>>>        End
95255>>>>
95255>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
95256>>>    End_Procedure
95257>>>
95257>>>    Function pbTrusted Returns Boolean
95259>>>        Boolean bValue
95259>>>        If (ghoSQLConnectionHandler = 0) Begin
95261>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95262>>>>
95262>>>            Function_Return
95263>>>        End
95263>>>>
95263>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
95264>>>        Function_Return bValue
95265>>>    End_Function
95266>>>
95266>>>    Procedure Set pbSilentLogin Boolean bValue
95268>>>        If (ghoSQLConnectionHandler = 0) Begin
95270>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95271>>>>
95271>>>            Procedure_Return
95272>>>        End
95272>>>>
95272>>>        Set pbSilentLogin of ghoSQLConnectionHandler to bValue
95273>>>    End_Procedure
95274>>>
95274>>>    Function pbSilentLogin Returns Boolean
95276>>>        Boolean bValue
95276>>>        If (ghoSQLConnectionHandler = 0) Begin
95278>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95279>>>>
95279>>>            Function_Return
95280>>>        End
95280>>>>
95280>>>        Get pbSilentLogin of ghoSQLConnectionHandler to bValue
95281>>>        Function_Return bValue
95282>>>    End_Function
95283>>>
95283>>>    Procedure Set psConnectionID String sValue
95285>>>        If (ghoSQLConnectionHandler = 0) Begin
95287>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95288>>>>
95288>>>            Procedure_Return
95289>>>        End
95289>>>>
95289>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
95290>>>    End_Procedure
95291>>>
95291>>>    Function psConnectionID Returns String
95293>>>        String sValue
95293>>>        If (ghoSQLConnectionHandler = 0) Begin
95295>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95296>>>>
95296>>>            Function_Return
95297>>>        End
95297>>>>
95297>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
95298>>>        Function_Return sValue
95299>>>    End_Function
95300>>>
95300>>>    Procedure Set psConnectionString String sValue
95302>>>        If (ghoSQLConnectionHandler = 0) Begin
95304>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95305>>>>
95305>>>            Procedure_Return
95306>>>        End
95306>>>>
95306>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
95307>>>    End_Procedure
95308>>>
95308>>>    Function psConnectionString Returns String
95310>>>        String sValue
95310>>>        If (ghoSQLConnectionHandler = 0) Begin
95312>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95313>>>>
95313>>>            Function_Return
95314>>>        End
95314>>>>
95314>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
95315>>>        Function_Return sValue
95316>>>    End_Function
95317>>>
95317>>>    // The normal connection string looks something like this;
95317>>>    // SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
95317>>>    // ...and the full connection string looks like this;
95317>>>    // DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
95317>>>    Function psFullConnectionString Returns String
95319>>>        String sConnectionID sConnectionString
95319>>>        If (ghoSQLConnectionHandler = 0) Begin
95321>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95322>>>>
95322>>>            Function_Return
95323>>>        End
95323>>>>
95323>>>        Get psConnectionID     of ghoSQLConnectionHandler to sConnectionID
95324>>>        Move (Trim(sConnectionID)) to sConnectionID
95325>>>        Get psConnectionString of ghoSQLConnectionHandler to sConnectionString
95326>>>        Function_Return (CS_SQLConnectionIDText * sConnectionID + "," * String(sConnectionString))
95327>>>    End_Function
95328>>>
95328>>>    Function piConnectionOptions Returns Integer
95330>>>        Integer iValue
95330>>>        If (ghoSQLConnectionHandler = 0) Begin
95332>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95333>>>>
95333>>>            Function_Return
95334>>>        End
95334>>>>
95334>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
95335>>>        Function_Return iValue
95336>>>    End_Function
95337>>>
95337>>>    Procedure Set psSchema String sValue
95339>>>        tSQLConnection SQLConnection
95339>>>        tSQLConnection SQLConnection
95339>>>        If (ghoSQLConnectionHandler = 0) Begin
95341>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95342>>>>
95342>>>            Procedure_Return
95343>>>        End
95343>>>>
95343>>>        Set psSchema of ghoSQLConnectionHandler to sValue
95344>>>    End_Procedure
95345>>>
95345>>>    Function psSchema Returns String
95347>>>        String sRetval
95347>>>        If (ghoSQLConnectionHandler = 0) Begin
95349>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95350>>>>
95350>>>            Function_Return
95351>>>        End
95351>>>>
95351>>>        Get psSchema of ghoSQLConnectionHandler to sRetval
95352>>>        Function_Return sRetval
95353>>>    End_Function
95354>>>
95354>>>    Procedure Set psBaseTableSpace String sValue
95356>>>        If (ghoSQLConnectionHandler = 0) Begin
95358>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95359>>>>
95359>>>            Procedure_Return
95360>>>        End
95360>>>>
95360>>>        Set psBaseTableSpace of ghoSQLConnectionHandler to sValue
95361>>>    End_Procedure
95362>>>
95362>>>    Function psBaseTableSpace Returns String
95364>>>        String sRetval
95364>>>        If (ghoSQLConnectionHandler = 0) Begin
95366>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95367>>>>
95367>>>            Function_Return
95368>>>        End
95368>>>>
95368>>>        Get psBaseTableSpace of ghoSQLConnectionHandler to sRetval
95369>>>        Function_Return sRetval
95370>>>    End_Function
95371>>>
95371>>>    Procedure Set psLongTableSpace String sValue
95373>>>        If (ghoSQLConnectionHandler = 0) Begin
95375>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95376>>>>
95376>>>            Procedure_Return
95377>>>        End
95377>>>>
95377>>>        Set psLongTableSpace of ghoSQLConnectionHandler to sValue
95378>>>    End_Procedure
95379>>>
95379>>>    Function psLongTableSpace Returns String
95381>>>        String sRetval
95381>>>        If (ghoSQLConnectionHandler = 0) Begin
95383>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95384>>>>
95384>>>            Function_Return
95385>>>        End
95385>>>>
95385>>>        Get psLongTableSpace of ghoSQLConnectionHandler to sRetval
95386>>>        Function_Return sRetval
95387>>>    End_Function
95388>>>
95388>>>    Procedure Set psIndexTableSpace String sValue
95390>>>        If (ghoSQLConnectionHandler = 0) Begin
95392>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95393>>>>
95393>>>            Procedure_Return
95394>>>        End
95394>>>>
95394>>>        Set psIndexTableSpace of ghoSQLConnectionHandler to sValue
95395>>>    End_Procedure
95396>>>
95396>>>    Function psIndexTableSpace Returns String
95398>>>        String sRetval
95398>>>        If (ghoSQLConnectionHandler = 0) Begin
95400>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95401>>>>
95401>>>            Function_Return
95402>>>        End
95402>>>>
95402>>>        Get psIndexTableSpace of ghoSQLConnectionHandler to sRetval
95403>>>        Function_Return sRetval
95404>>>    End_Function
95405>>>
95405>>>    Procedure Set pbUseConnectionID Boolean bState
95407>>>        If (ghoSQLConnectionHandler = 0) Begin
95409>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95410>>>>
95410>>>            Procedure_Return
95411>>>        End
95411>>>>
95411>>>        Set pbUseConnectionID of ghoSQLConnectionHandler to bState
95412>>>    End_Procedure
95413>>>
95413>>>    Function pbUseConnectionID Returns Boolean
95415>>>        Boolean bState
95415>>>        If (ghoSQLConnectionHandler = 0) Begin
95417>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95418>>>>
95418>>>            Function_Return
95419>>>        End
95419>>>>
95419>>>        Get pbUseConnectionID of ghoSQLConnectionHandler to bState
95420>>>        Function_Return bState
95421>>>    End_Function
95422>>>
95422>>>    Procedure Set pbToANSI Boolean bState
95424>>>        If (ghoSQLConnectionHandler = 0) Begin
95426>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95427>>>>
95427>>>            Procedure_Return
95428>>>        End
95428>>>>
95428>>>        Set pbToANSI of ghoSQLConnectionHandler to bState
95429>>>    End_Procedure
95430>>>
95430>>>    Function pbToANSI Returns Boolean
95432>>>        Boolean bState
95432>>>        If (ghoSQLConnectionHandler = 0) Begin
95434>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95435>>>>
95435>>>            Function_Return
95436>>>        End
95436>>>>
95436>>>        Get pbToANSI of ghoSQLConnectionHandler to bState
95437>>>        Function_Return bState
95438>>>    End_Function
95439>>>
95439>>>    Procedure Set pbRecnum Boolean bState
95441>>>        If (ghoSQLConnectionHandler = 0) Begin
95443>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95444>>>>
95444>>>            Procedure_Return
95445>>>        End
95445>>>>
95445>>>        Set pbRecnum of ghoSQLConnectionHandler to bState
95446>>>    End_Procedure
95447>>>
95447>>>    Function pbRecnum Returns Boolean
95449>>>        Boolean bState
95449>>>        If (ghoSQLConnectionHandler = 0) Begin
95451>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95452>>>>
95452>>>            Function_Return
95453>>>        End
95453>>>>
95453>>>        Get pbRecnum of ghoSQLConnectionHandler to bState
95454>>>        Function_Return bState
95455>>>    End_Function
95456>>>
95456>>>    Procedure Set pbCopyData Boolean bState
95458>>>        If (ghoSQLConnectionHandler = 0) Begin
95460>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95461>>>>
95461>>>            Procedure_Return
95462>>>        End
95462>>>>
95462>>>        Set pbCopyData of ghoSQLConnectionHandler to bState
95463>>>    End_Procedure
95464>>>
95464>>>    Function pbCopyData Returns Boolean
95466>>>        Boolean bState
95466>>>        If (ghoSQLConnectionHandler = 0) Begin
95468>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95469>>>>
95469>>>            Function_Return
95470>>>        End
95470>>>>
95470>>>        Get pbCopyData of ghoSQLConnectionHandler to bState
95471>>>        Function_Return bState
95472>>>    End_Function
95473>>>
95473>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
95475>>>        If (ghoSQLConnectionHandler = 0) Begin
95477>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95478>>>>
95478>>>            Procedure_Return
95479>>>        End
95479>>>>
95479>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
95480>>>    End_Procedure
95481>>>
95481>>>    Function pbApiTableUpdateAuto Returns Boolean
95483>>>        Boolean bState
95483>>>        If (ghoSQLConnectionHandler = 0) Begin
95485>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95486>>>>
95486>>>            Function_Return
95487>>>        End
95487>>>>
95487>>>        Get pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
95488>>>        Function_Return bState
95489>>>    End_Function
95490>>>
95490>>>    Procedure Set pbCompareDate_DateTime Boolean bState
95492>>>        If (ghoSQLConnectionHandler = 0) Begin
95494>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95495>>>>
95495>>>            Procedure_Return
95496>>>        End
95496>>>>
95496>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
95497>>>    End_Procedure
95498>>>
95498>>>    Function pbCompareDate_DateTime Returns Boolean
95500>>>        Boolean bState
95500>>>        If (ghoSQLConnectionHandler = 0) Begin
95502>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95503>>>>
95503>>>            Function_Return
95504>>>        End
95504>>>>
95504>>>        Get pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
95505>>>        Function_Return bState
95506>>>    End_Function
95507>>>
95507>>>    Procedure Set pbCompareIndexAscending Boolean bState
95509>>>        If (ghoSQLConnectionHandler = 0) Begin
95511>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95512>>>>
95512>>>            Procedure_Return
95513>>>        End
95513>>>>
95513>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
95514>>>    End_Procedure
95515>>>
95515>>>    Function pbCompareIndexAscending Returns Boolean
95517>>>        Boolean bState
95517>>>        If (ghoSQLConnectionHandler = 0) Begin
95519>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95520>>>>
95520>>>            Function_Return
95521>>>        End
95521>>>>
95521>>>        Get pbCompareIndexAscending of ghoSQLConnectionHandler to bState
95522>>>        Function_Return bState
95523>>>    End_Function
95524>>>
95524>>>    Procedure Set pbCompareIndexUppercase Boolean bState
95526>>>        If (ghoSQLConnectionHandler = 0) Begin
95528>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95529>>>>
95529>>>            Procedure_Return
95530>>>        End
95530>>>>
95530>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
95531>>>    End_Procedure
95532>>>
95532>>>    Function pbCompareIndexUppercase Returns Boolean
95534>>>        Boolean bState
95534>>>        If (ghoSQLConnectionHandler = 0) Begin
95536>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95537>>>>
95537>>>            Function_Return
95538>>>        End
95538>>>>
95538>>>        Get pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
95539>>>        Function_Return bState
95540>>>    End_Function
95541>>>
95541>>>    Procedure Set psDriverDefaultValueASCII String sValue
95543>>>        If (ghoSQLConnectionHandler = 0) Begin
95545>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95546>>>>
95546>>>            Procedure_Return
95547>>>        End
95547>>>>
95547>>>        Set psDriverDefaultValueASCII of ghoSQLConnectionHandler to sValue
95548>>>    End_Procedure
95549>>>
95549>>>    Function psDriverDefaultValueASCII Returns String
95551>>>        String sRetval
95551>>>        If (ghoSQLConnectionHandler = 0) Begin
95553>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95554>>>>
95554>>>            Function_Return
95555>>>        End
95555>>>>
95555>>>        Get psDriverDefaultValueASCII of ghoSQLConnectionHandler to sRetval
95556>>>        Function_Return sRetval
95557>>>    End_Function
95558>>>
95558>>>    Procedure Set psDriverDefaultValueBinary String sValue
95560>>>        If (ghoSQLConnectionHandler = 0) Begin
95562>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95563>>>>
95563>>>            Procedure_Return
95564>>>        End
95564>>>>
95564>>>        Set psDriverDefaultValueBinary of ghoSQLConnectionHandler to sValue
95565>>>    End_Procedure
95566>>>
95566>>>    Function psDriverDefaultValueBinary Returns String
95568>>>        String sRetval
95568>>>        If (ghoSQLConnectionHandler = 0) Begin
95570>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95571>>>>
95571>>>            Function_Return
95572>>>        End
95572>>>>
95572>>>        Get psDriverDefaultValueBinary of ghoSQLConnectionHandler to sRetval
95573>>>        Function_Return sRetval
95574>>>    End_Function
95575>>>
95575>>>    Procedure Set psDriverDefaultValueDate String sValue
95577>>>        If (ghoSQLConnectionHandler = 0) Begin
95579>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95580>>>>
95580>>>            Procedure_Return
95581>>>        End
95581>>>>
95581>>>        Set psDriverDefaultValueDate of ghoSQLConnectionHandler to sValue
95582>>>    End_Procedure
95583>>>
95583>>>    Function psDriverDefaultValueDate Returns String
95585>>>        String sRetval
95585>>>        If (ghoSQLConnectionHandler = 0) Begin
95587>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95588>>>>
95588>>>            Function_Return
95589>>>        End
95589>>>>
95589>>>        Get psDriverDefaultValueDate of ghoSQLConnectionHandler to sRetval
95590>>>        Function_Return sRetval
95591>>>    End_Function
95592>>>
95592>>>    Procedure Set psDriverDefaultValueDateTime String sValue
95594>>>        If (ghoSQLConnectionHandler = 0) Begin
95596>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95597>>>>
95597>>>            Procedure_Return
95598>>>        End
95598>>>>
95598>>>        Set psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sValue
95599>>>    End_Procedure
95600>>>
95600>>>    Function psDriverDefaultValueDateTime Returns String
95602>>>        String sRetval
95602>>>        If (ghoSQLConnectionHandler = 0) Begin
95604>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95605>>>>
95605>>>            Function_Return
95606>>>        End
95606>>>>
95606>>>        Get psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sRetval
95607>>>        Function_Return sRetval
95608>>>    End_Function
95609>>>
95609>>>    Procedure Set psDriverDefaultValueNumeric String sValue
95611>>>        If (ghoSQLConnectionHandler = 0) Begin
95613>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95614>>>>
95614>>>            Procedure_Return
95615>>>        End
95615>>>>
95615>>>        Set psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sValue
95616>>>    End_Procedure
95617>>>
95617>>>    Function psDriverDefaultValueNumeric Returns String
95619>>>        String sRetval
95619>>>        If (ghoSQLConnectionHandler = 0) Begin
95621>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95622>>>>
95622>>>            Function_Return
95623>>>        End
95623>>>>
95623>>>        Get psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sRetval
95624>>>        Function_Return sRetval
95625>>>    End_Function
95626>>>
95626>>>    Procedure Set psDriverDefaultValueText String sValue
95628>>>        If (ghoSQLConnectionHandler = 0) Begin
95630>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95631>>>>
95631>>>            Procedure_Return
95632>>>        End
95632>>>>
95632>>>        Set psDriverDefaultValueText of ghoSQLConnectionHandler to sValue
95633>>>    End_Procedure
95634>>>
95634>>>    Function psDriverDefaultValueText Returns String
95636>>>        String sRetval
95636>>>        If (ghoSQLConnectionHandler = 0) Begin
95638>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95639>>>>
95639>>>            Function_Return
95640>>>        End
95640>>>>
95640>>>        Get psDriverDefaultValueText of ghoSQLConnectionHandler to sRetval
95641>>>        Function_Return sRetval
95642>>>    End_Function
95643>>>
95643>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
95645>>>        If (ghoSQLConnectionHandler = 0) Begin
95647>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95648>>>>
95648>>>            Procedure_Return
95649>>>        End
95649>>>>
95649>>>        Set pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
95650>>>    End_Procedure
95651>>>
95651>>>    Function pbDriverDefaultNullableASCII Returns Boolean
95653>>>        Boolean bState
95653>>>        If (ghoSQLConnectionHandler = 0) Begin
95655>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95656>>>>
95656>>>            Function_Return
95657>>>        End
95657>>>>
95657>>>        Get pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
95658>>>        Function_Return bState
95659>>>    End_Function
95660>>>
95660>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
95662>>>        If (ghoSQLConnectionHandler = 0) Begin
95664>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95665>>>>
95665>>>            Procedure_Return
95666>>>        End
95666>>>>
95666>>>        Set pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
95667>>>    End_Procedure
95668>>>
95668>>>    Function pbDriverDefaultNullableBinary Returns Boolean
95670>>>        Boolean bState
95670>>>        If (ghoSQLConnectionHandler = 0) Begin
95672>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95673>>>>
95673>>>            Function_Return
95674>>>        End
95674>>>>
95674>>>        Get pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
95675>>>        Function_Return bState
95676>>>    End_Function
95677>>>
95677>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
95679>>>        If (ghoSQLConnectionHandler = 0) Begin
95681>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95682>>>>
95682>>>            Procedure_Return
95683>>>        End
95683>>>>
95683>>>        Set pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
95684>>>    End_Procedure
95685>>>
95685>>>    Function pbDriverDefaultNullableDate Returns Boolean
95687>>>        Boolean bState
95687>>>        If (ghoSQLConnectionHandler = 0) Begin
95689>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95690>>>>
95690>>>            Function_Return
95691>>>        End
95691>>>>
95691>>>        Get pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
95692>>>        Function_Return bState
95693>>>    End_Function
95694>>>
95694>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
95696>>>        If (ghoSQLConnectionHandler = 0) Begin
95698>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95699>>>>
95699>>>            Procedure_Return
95700>>>        End
95700>>>>
95700>>>        Set pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
95701>>>    End_Procedure
95702>>>
95702>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
95704>>>        Boolean bState
95704>>>        If (ghoSQLConnectionHandler = 0) Begin
95706>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95707>>>>
95707>>>            Function_Return
95708>>>        End
95708>>>>
95708>>>        Get pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
95709>>>        Function_Return bState
95710>>>    End_Function
95711>>>
95711>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
95713>>>        If (ghoSQLConnectionHandler = 0) Begin
95715>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95716>>>>
95716>>>            Procedure_Return
95717>>>        End
95717>>>>
95717>>>        Set pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
95718>>>    End_Procedure
95719>>>
95719>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
95721>>>        Boolean bState
95721>>>        If (ghoSQLConnectionHandler = 0) Begin
95723>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95724>>>>
95724>>>            Function_Return
95725>>>        End
95725>>>>
95725>>>        Get pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
95726>>>        Function_Return bState
95727>>>    End_Function
95728>>>
95728>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
95730>>>        If (ghoSQLConnectionHandler = 0) Begin
95732>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95733>>>>
95733>>>            Procedure_Return
95734>>>        End
95734>>>>
95734>>>        Set pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
95735>>>    End_Procedure
95736>>>
95736>>>    Function pbDriverDefaultNullableText Returns Boolean
95738>>>        Boolean bState
95738>>>        If (ghoSQLConnectionHandler = 0) Begin
95740>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95741>>>>
95741>>>            Function_Return
95742>>>        End
95742>>>>
95742>>>        Get pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
95743>>>        Function_Return bState
95744>>>    End_Function
95745>>>
95745>>>    // Note: If the psDriverID + other connection properties are to be changed,
95745>>>    //       the psDriverID *must* be the first property that gets changed!
95745>>>    //       Otherwise errors might be raised by the driver when e.g. the format
95745>>>    //       for a connection string has the wrong format for that driver.
95745>>>    Procedure Set psDriverID String sValue
95747>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
95748>>>        Delegate Set psDriverID to sValue
95750>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
95751>>>        Set psDriverID of ghoSQLConnectionHandler to sValue
95752>>>    End_Procedure
95753>>>
95753>>>    Function psDriverID Returns String
95755>>>        String sDriverID
95755>>>
95755>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
95756>>>        // This should get it from the parent object (when using the cDbUpdateHandler class)
95756>>>        Delegate Get psDriverID to sDriverID
95758>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
95759>>>        Move False to Err
95760>>>
95760>>>        // ...and in case it didn't use property of this class. Then the library is
95760>>>        // probably used as "utilites" from a special made program and
95760>>>        // the ghoSQLConnectionHandler must have been setup
95760>>>        If (sDriverID = "") Begin
95762>>>            Get psDriverID of ghoSQLConnectionHandler to sDriverID
95763>>>        End
95763>>>>
95763>>>        Function_Return sDriverID
95764>>>    End_Function
95765>>>
95765>>>    Procedure Set piDbType Integer iValue
95767>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
95768>>>        Delegate Set piDbType to iValue
95770>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
95771>>>        Set piDbType of ghoSQLConnectionHandler to iValue
95772>>>    End_Procedure
95773>>>
95773>>>    Function piDbType Returns String
95775>>>        Integer iRetval
95775>>>
95775>>>//        Move False to Err
95775>>>//        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
95775>>>        // This should get it from the parent object (when using the cDbUpdateHandler class)
95775>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
95775>>>//        Delegate Get piDbType to iRetval
95775>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
95775>>>//        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
95775>>>
95775>>>        // ...and in case it didn't use property of this class. Then the library is
95775>>>        // probably used as "utilites" from a special made program and
95775>>>        // the ghoSQLConnectionHandler must have been setup
95775>>>//        If (Err = True) Begin
95775>>>            Get piDbType of ghoSQLConnectionHandler to iRetval
95776>>>//        End
95776>>>
95776>>>//        Move False to Err
95776>>>        Function_Return iRetval
95777>>>    End_Function
95778>>>
95778>>>    Function phoLogFile Returns Handle
95780>>>        Handle hoLogFile
95780>>>
95780>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
95781>>>        Delegate Get phoLogFile to hoLogFile
95783>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
95784>>>
95784>>>        Function_Return hoLogFile
95785>>>    End_Function
95786>>>
95786>>>    Function pnCurrentVersionUpdate Returns Number
95788>>>        Number nCurrentVersionUpdate
95788>>>
95788>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
95789>>>        Delegate Get pnCurrentVersionUpdate to nCurrentVersionUpdate
95791>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
95792>>>
95792>>>        Function_Return nCurrentVersionUpdate
95793>>>    End_Function
95794>>>
95794>>>    Procedure LogError String sText Boolean bError
95796>>>        Handle hoLogFile
95796>>>        Number nCurrentVersionUpdate
95796>>>
95796>>>        Get phoLogFile to hoLogFile
95797>>>        If (hoLogFile = 0) Begin
95799>>>            Procedure_Return
95800>>>        End
95800>>>>
95800>>>        Get pnCurrentVersionUpdate to nCurrentVersionUpdate
95801>>>
95801>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
95802>>>        Send LogError of hoLogFile nCurrentVersionUpdate 0 sText 0 bError
95803>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
95804>>>    End_Procedure
95805>>>
95805>>>    Function pbContinueOnError Returns Boolean
95807>>>        Boolean bContinueOnError
95807>>>        If (ghoDbUpdateHandler > 0) Begin
95809>>>            Get pbContinueOnError of ghoDbUpdateHandler to bContinueOnError
95810>>>        End
95810>>>>
95810>>>        Function_Return bContinueOnError
95811>>>    End_Function
95812>>>
95812>>>    Function psCollation Returns String
95814>>>        String sCollation
95814>>>        If (ghoDbUpdateHandler > 0) Begin
95816>>>            Get psCollation of ghoDbUpdateHandler to sCollation
95817>>>        End
95817>>>>
95817>>>        Function_Return sCollation
95818>>>    End_Function
95819>>>
95819>>>
95819>>>    Function StrToFieldNumber Integer iFile String sField Returns Integer
95821>>>        Integer iMax iPos
95821>>>        String sName
95821>>>
95821>>>        Move (Lowercase(sField)) to sField
95822>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iMax
95825>>>        for iPos from 0 to iMax
95831>>>>
95831>>>            Get_Attribute DF_FIELD_NAME of iFile iPos to sName
95834>>>            Move (Lowercase(sName)) to sName
95835>>>            If (sName = sField) Begin
95837>>>                Function_Return iPos
95838>>>            End
95838>>>>
95838>>>        Loop
95839>>>>
95839>>>        Function_Return -1
95840>>>    End_Function
95841>>>
95841>>>
95841>>>    // * Dummy function for the Studio's Code Explorer *
95841>>>    Function PRIVATE_SUB_FUNCTIONS Returns Boolean
95843>>>        Function_Return False
95844>>>    End_Function
95845>>>
95845>>>    // When dropping columns on some SQL back-ends they doesn't reclaim the space taken up by the columns dropped.
95845>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
95845>>>    // the new rows added after the alter statement. to get around this you need to create a clustered
95845>>>    // index on the table _or_ rebuild the clustered Index if it already has one. Rebuilding the index
95845>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
95845>>>    //   ALTER TABLE MyTable
95845>>>    //       REBUILD
95845>>>    Function _SqlUtilRemoveTableColumnMSSQL String sTableName String sColumnName Returns Boolean
95847>>>        Boolean bOK
95847>>>
95847>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
95849>>>            Function_Return False
95850>>>        End
95850>>>>
95850>>>
95850>>>        SQLIncludeScriptFile ..\Scripts\DropConstraintAndColumnNameMSSQL.sql as DropConstraintAndColumnNameMSSQL.sql
95850>>>        Get _SqlUtilRemoveTableColumnByScript "DropConstraintAndColumnNameMSSQL.sql" sTableName sColumnName to bOK
95851>>>
95851>>>        Function_Return (bOK = True)
95852>>>    End_Function
95853>>>
95853>>>
95853>>>    // *** Helper functions with compiled sql script code ***
95853>>>    //
95853>>>    // When dropping columns SQL Sever does not reclaim the space taken up by the columns dropped.
95853>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
95853>>>    // the new rows added after the alter statement. To get around this you need to create a clustered
95853>>>    // index on the table or rebuild the clustered Index if it already has one. Rebuilding the index
95853>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
95853>>>    //   ALTER TABLE MyTable
95853>>>    //       REBUILD
95853>>>    Function _SqlUtilRemoveTableColumnByScript String sMemScriptFile String sTableName String sColumnName Returns Boolean
95855>>>        tSQLScriptArray SQLScriptArray
95855>>>        tSQLScriptArray SQLScriptArray
95855>>>        String sDriverID
95855>>>        Boolean bOK
95855>>>        Integer iSize iCount
95855>>>
95855>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
95857>>>            Function_Return False
95858>>>        End
95858>>>>
95858>>>
95858>>>        Get psDriverID to sDriverID
95859>>>        Get SqlUtilReadResource sMemScriptFile to SQLScriptArray
95860>>>        If (SQLScriptArray.bError = True) Begin
95862>>>            Function_Return False
95863>>>        End
95863>>>>
95863>>>
95863>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
95864>>>        Decrement iSize
95865>>>
95865>>>        for iCount from 0 to iSize
95871>>>>
95871>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "TABLE_NAME_XXX") Begin
95873>>>                Move (Replaces("TABLE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sTableName))) to SQLScriptArray.sSQLScriptArray[iCount]
95874>>>            End
95874>>>>
95874>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLUMN_NAME_XXX") Begin
95876>>>                Move (Replaces("COLUMN_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sColumnName))) to SQLScriptArray.sSQLScriptArray[iCount]
95877>>>            End
95877>>>>
95877>>>        Loop
95878>>>>
95878>>>
95878>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
95879>>>
95879>>>        Function_Return (bOK = True)
95880>>>    End_Function
95881>>>
95881>>>    // *** Helper functions for Mertech Drivers ***
95881>>>    // Created to not clutter up the standard function code with lots of #IFDEF's
95881>>>    // and commands that the Studio editor knows nothing about.
95881>>>    Function _MertechDeleteTDFile String sTableName Returns Integer
95883>>>        Integer iRetval
95883>>>        String sPath
95883>>>
95883>>>        If (sPath = "" or sTableName = "") Begin
95885>>>            Function_Return 0
95886>>>        End
95886>>>>
95886>>>
95886>>>        Get vFolderFormat sPath to sPath
95887>>>        Get vDeleteFile (sPath + String(sTableName) + ".td") to iRetval
95888>>>        Function_Return iRetval
95889>>>    End_Function
95890>>>
95890>>>    Function _MertechSqlUtilCreateIntFile Handle hTable String sDataPath String sPhysicalFileName Returns Boolean
95892>>>        Move False to Err
95893>>>        Function_Return (Err = False)
95894>>>    End_Function
95895>>>
95895>>>    Function _MertechEnumerateSQLFlexServers Returns String[]
95897>>>        Integer iNumItems iCount
95897>>>        String[] sReturnArray
95898>>>        String sServer
95898>>>
95898>>>
95898>>>        Function_Return sReturnArray
95899>>>    End_Function
95900>>>
95900>>>    Function _MertechEnumerateORAFLEXServers Returns String[]
95902>>>        String[] sReturnArray
95903>>>        String sServer
95903>>>
95903>>>
95903>>>        Function_Return sReturnArray
95904>>>    End_Function
95905>>>
95905>>>    Function _MertechSQLConnect String sDriverID String sServer String sUserID String sPassword Returns Handle
95907>>>        Handle hoSQLHandler hoSQLConnect
95907>>>
95907>>>        Move 0 to hoSQLConnect
95908>>>
95908>>>        Function_Return hoSQLConnect
95909>>>    End_Function
95910>>>
95910>>>    // Returns the handle of the Mertech SQL handler.
95910>>>    // It also ensures that the correct Server & Database attributes are set both for
95910>>>    // embedded SQL calls and "normal" database commands like e.g. "Open".
95910>>>    Function _MertechSQLManagerHandle Returns Handle
95912>>>        Handle hoSQLHandler
95912>>>        String sDriverID sServer sDatabase
95912>>>
95912>>>        Move 0 to hoSQLHandler
95913>>>        Get psDriverID to sDriverID
95914>>>        Get psServer   to sServer
95915>>>        Get psDatabase to sDatabase
95916>>>
95916>>>        Function_Return hoSQLHandler
95917>>>    End_Function
95918>>>
95918>>>    // For Mertech drivers we cannot use Structure_Start/End. Instead we must use
95918>>>    // macro-commands <sigh!>
95918>>>    // Note: The function sets the Err flag.
95918>>>    Function _MertechApiTableConvertToSQL Handle hTable String sRootName String sDatabase String sDriverID String sBaseTableSpace String sIndexTableSpace Boolean bCopyData Returns Boolean
95920>>>        Move False to Err
95921>>>
95921>>>
95921>>>        Function_Return (Err = False)
95922>>>    End_Function
95923>>>
95923>>>End_Class
95924>Use AddToStudio.dg
Including file: AddToStudio.dg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\AddToStudio.dg)
95924>>>Use Windows.pkg
95924>>>Use Dfspnfrm.pkg
95924>>>Use cRegistry.pkg
95924>>>Use vWin32fh.pkg
95924>>>
95924>>>Enum_List
95924>>>    Define cx_RegKeyAlreadyExist
95924>>>    Define cx_RegKeyCreated
95924>>>    Define cx_RegkeyFailed
95924>>>    Define cx_RegKeyVDFKeyDoesNotExist
95924>>>    Define CX_InstalledOkVdfUnder16
95924>>>End_Enum_List
95924>>>
95924>>>// Note: The "Visual" part will automatically be removed if
95924>>>// the current DataFlex version is above 17.
95924>>>Define CS_StudioPath        for "Software\Data Access Worldwide\Visual DataFlex Tools\"
95924>>>Define CS_StudioTools       for "\Studio\Tools"
95924>>>Define CS_RegApplication    for "<application>"
95924>>>Define CS_RegWorkspace      for "<workspace>"
95924>>>Define CS_CommandLine       for "CommandLine"
95924>>>Define CS_Name              for "Name"
95924>>>Define CS_Separator         for "Separator"
95924>>>Define CS_Command           for "Command"
95924>>>
95924>>>
95924>>>Object oAddToStudio_dg is a ModalPanel
95926>>>    Set Size to 81 330
95927>>>    Set Label to "Add Program To DataFlex Studio's Tools Menu"
95928>>>    Set piMinSize to 79 211
95929>>>    Set Location to 5 4
95930>>>    Set Locate_Mode to Center_On_Parent
95931>>>
95931>>>    Property String psTag CS_RegApplication
95933>>>
95933>>>    Object oStudioIntegration_grp is a Group
95935>>>        Set Size to 45 299
95936>>>        Set Location to 8 15
95937>>>        Set Label to "DataFlex Studio Integration"
95938>>>
95938>>>        Object oStudioMajorVersion_sf is a SpinForm
95940>>>            Set Size to 12 27
95941>>>            Set Location to 18 168
95942>>>            Set Maximum_Position to 30
95943>>>            Set Minimum_Position to 14
95944>>>            Set Label_Col_Offset to 2
95945>>>            Set Label_Justification_Mode to JMode_Right
95946>>>            Set Label to "Add to Studio's Tools Menu:     Major Version"
95947>>>            Set Status_Help to "DataFlex main version - e.g. '18'"
95948>>>            Set Value to FMAC_VERSION
95949>>>            Set peAnchors to anNone
95950>>>        End_Object
95951>>>
95951>>>        Object oStudioMinorVersion_sf is a SpinForm
95953>>>            Set Size to 12 27
95954>>>            Set Location to 18 254
95955>>>            Set Label_Col_Offset to 2
95956>>>            Set Label to "Minor Version"
95957>>>            Set Status_Help to "DataFlex minor version - e.g. '0'"
95958>>>            Set Maximum_Position to 9
95959>>>            Set Minimum_Position to 0
95960>>>            Set Value to FMAC_REVISION
95961>>>            Set Label_Justification_Mode to JMode_Right
95962>>>            Set peAnchors to anNone
95963>>>        End_Object
95964>>>
95964>>>    End_Object
95965>>>
95965>>>    Object oOK_btn is a Button
95967>>>        Set Size to 14 50
95968>>>        Set Location to 59 207
95969>>>        Set Label to "Add Now"
95970>>>        Set Status_Help to "Add to DataFlex Studios 'Tools' menu. The Studio version can be selected with the two spinforms. The COMManifestStudio program gets added to the Studios Tools menu. When selected from the Studio it will pass the current project name on the command line so that the current program's manifest file is automatically loaded by the COMManifestStudio program."
95971>>>        Set peAnchors to anTopRight
95972>>>
95972>>>        Procedure OnClick
95975>>>            Integer iRetval iMajorVersion iMinorVersion
95975>>>            String sText sStudioVersion
95975>>>            Get Value of oStudioMajorVersion_sf to iMajorVersion
95976>>>            Get Value of oStudioMinorVersion_sf to iMinorVersion
95977>>>            Move (String(iMajorVersion) + "." + String(iMinorVersion)) to sStudioVersion
95978>>>            Get AddProgramToStudioToolsMenu sStudioVersion to iRetval
95979>>>            Case Begin
95979>>>                Case (iRetval = cx_RegKeyAlreadyExist)
95981>>>                    Move ("The program already exists in the" * sStudioVersion * "DataFlex Studios Tools menu.") to sText
95982>>>                    Break
95983>>>                Case (iRetval = cx_RegKeyCreated)
95986>>>                    Move ("Success. The tool was added to the" * sStudioVersion *  "DataFlex Studios Tools menu.") to sText
95987>>>                    Break
95988>>>                Case (iRetval = cx_RegkeyFailed)
95991>>>                    Move "Failed. Could not create the registry key for adding the program to the DataFlex Studio's Tools menu." to sText
95992>>>                    Break
95993>>>                Case (iRetval = cx_RegKeyVDFKeyDoesNotExist)
95996>>>                    Move ("Could not find the Studio registry key. Is DataFlex Studio version" * sStudioVersion * "really installed on this machine?") to sText
95997>>>                    Break
95998>>>                Case (iRetval = CX_InstalledOkVdfUnder16)
96001>>>                    Move ("The program was added to the" * sStudioVersion * "Studios Tools menu successfully, but because you installed for an earlier version of the Studio than 16.0 you need to compile the program under that same VDF version, else the Studio can't start the program properly. (Sorry, just a 'feature' of earlier versions of the Studio)") to sText
96002>>>                    Break
96003>>>            Case End
96003>>>
96003>>>            Send Info_Box sText
96004>>>        End_Procedure
96005>>>    End_Object
96006>>>
96006>>>    Object oCancel_Btn is a Button
96008>>>        Set Label to "&Close"
96009>>>        Set Location to 59 264
96010>>>        Set peAnchors to anBottomRight
96011>>>
96011>>>        Procedure OnClick
96014>>>            Send Close_Panel
96015>>>        End_Procedure
96016>>>
96016>>>    End_Object
96017>>>
96017>>>    Function AddProgramToStudioToolsMenu String sStudioVersion Returns Integer
96020>>>        Boolean bOk bExists bOpen
96020>>>        String sKey sValue sProgramPath sProgram sProduct sStudioPath
96020>>>        Handle hoReg hoArray
96020>>>        Integer i iItems iCreated iRetval
96020>>>
96020>>>        Move False to bOk
96021>>>        Move (CS_StudioPath + (Trim(sStudioVersion)))  to sStudioPath
96022>>>        If (sStudioVersion > "17.1") Begin
96024>>>            Move (Replace("Visual ", sStudioPath, "")) to sStudioPath
96025>>>        End
96025>>>>
96025>>>
96025>>>        Get psProgramPath of (phoWorkspace(ghoApplication)) to sProgramPath
96026>>>        Get PathAtIndex of (phoWorkspace(ghoApplication)) sProgramPath 1 to sProgramPath
96027>>>        Get vFolderFormat sProgramPath to sProgramPath
96028>>>        Get Module_Name to sProgram
96029>>>//        Get psProduct     of (phoWorkspace(ghoApplication)) to sProduct
96029>>>        Move sProgram to sProduct
96030>>>        Get Create U_cRegistry to hoReg
96031>>>        Set phRootKey of hoReg to HKEY_CURRENT_USER
96032>>>
96032>>>        // First check if the DataFlex version is installed
96032>>>        Get KeyExists of hoReg sStudioPath to bExists
96033>>>        If (bExists = False) Begin
96035>>>            Send Destroy of hoReg
96036>>>            Function_Return cx_RegKeyVDFKeyDoesNotExist
96037>>>        End
96037>>>>
96037>>>
96037>>>        // Then check if any tools have been installed in the Tools Menu.
96037>>>        // If no tools created yet, create the Tools registry key.
96037>>>        Move (sStudioPath + CS_StudioTools) to sStudioPath
96038>>>        Get KeyExists of hoReg sStudioPath to bExists
96039>>>        If (bExists = False) Begin
96041>>>            Set pfAccessRights of hoReg to KEY_ALL_ACCESS
96042>>>            Get CreateKey of hoReg sStudioPath to iCreated
96043>>>            If (iCreated <> 0) Begin
96045>>>                Move cx_RegkeyFailed to iRetval
96046>>>            End
96046>>>>
96046>>>            Else Begin
96047>>>                Move True to bExists
96048>>>            End
96048>>>>
96048>>>        End
96048>>>>
96048>>>
96048>>>        If (bExists = True) Begin
96050>>>            Get OpenKey of hoReg sStudioPath to bOk
96051>>>            If (bOk = True) Begin
96053>>>                Get Create U_Array to hoArray
96054>>>                Get GetSubkeys of hoReg hoArray to iItems
96055>>>                Decrement iItems
96056>>>                Move False to bExists
96057>>>                Set pfAccessRights of hoReg to KEY_READ
96058>>>                // Check if the key already exists:
96058>>>                For i from 0 to iItems
96064>>>>
96064>>>                    Get Value of hoArray item i to sKey
96065>>>                    Move (sStudioPath + "\" + sKey) to sKey
96066>>>                    Get OpenKey of hoReg sKey to bOpen
96067>>>                    If (bOpen = True) Begin
96069>>>                        Get ReadString of hoReg CS_Name to sValue
96070>>>                        If (sValue = sProduct) Begin
96072>>>                            Move True to bExists
96073>>>                        End
96073>>>>
96073>>>                    End
96073>>>>
96073>>>                Loop
96074>>>>
96074>>>                Send Destroy of hoArray
96075>>>                If (bExists = False) Begin
96077>>>                    Set pfAccessRights of hoReg to KEY_ALL_ACCESS
96078>>>                    // We need to create the next key number:
96078>>>                    // The studio expect tools menu items to be numbered 1,2,3...n
96078>>>                    Increment iItems
96079>>>                    Increment iItems
96080>>>                    Get CreateKey of hoReg (sStudioPath + "\" + String(iItems)) to iCreated
96081>>>                    If (iCreated = 0) Begin
96083>>>                        Send WriteString of hoReg CS_Name sProduct
96084>>>                        // From DataFlex 16 and up the params for the Studio's Tools menu changed slightly:
96084>>>                        If (sStudioVersion >= "16.0") Begin
96086>>>                            Send WriteString of hoReg CS_Command (sProgramPath + sProgram)
96087>>>                            Send WriteString of hoReg CS_CommandLine (psTag(Self))
96088>>>                        End
96088>>>>
96088>>>                        Else Begin
96089>>>                            Send WriteString of hoReg CS_CommandLine ('"' + sProgramPath + sProgram + ".exe" + '"' * psTag(Self))
96090>>>                            Move CX_InstalledOkVdfUnder16 to iRetval
96091>>>                        End
96091>>>>
96091>>>                        Send WriteDword  of hoReg CS_Separator 1
96092>>>                        Move cx_RegKeyCreated to iRetval
96093>>>                    End
96093>>>>
96093>>>                    Else Begin
96094>>>                        Move cx_RegkeyFailed to iRetval
96095>>>                    End
96095>>>>
96095>>>                End
96095>>>>
96095>>>                Else Begin
96096>>>                    Move cx_RegKeyAlreadyExist to iRetval
96097>>>                End
96097>>>>
96097>>>                Send CloseKey of hoReg
96098>>>            End
96098>>>>
96098>>>        End
96098>>>>
96098>>>
96098>>>        Send Destroy of hoReg
96099>>>        Function_Return iRetval
96100>>>    End_Function
96101>>>
96101>>>    Procedure Page Integer iPageObject
96104>>>        Forward Send Page iPageObject
96106>>>        Set Icon to "ActionAdd.ico"
96107>>>    End_Procedure
96108>>>
96108>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
96109>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
96110>>>    On_Key kCancel       Send KeyAction of oCancel_Btn
96111>>>End_Object
96112>Set psTag of (oAddToStudio_dg(Self)) to CS_RegWorkspace
96113>
96113>Object oCreateDbVersionTable_pnl is a BasicPanel
96115>    Set Location to 1 0
96116>    Set Size to 204 398
96117>    Set Locate_Mode to Center_On_Screen
96118>    Set Label to (psProduct(ghoApplication))
96119>    Set Icon to "DbUpdate.ico"
96120>    Set pbAcceptDropFiles to True
96121>    Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
96122>    Set Maximize_Icon to False
96123>
96123>    Property Handle phoDialogCommandbar
96125>
96125>    Object oDbUpdateFunctionLibrary is a cDbUpdateFunctionLibrary
96127>    End_Object
96128>
96128>    Object oGeneralInfo_tb is a TextBox
96130>        Set Auto_Size_State to False
96131>        Set Size to 33 342
96132>        Set Location to 18 27
96133>        Set Label to "Utility to create a system table and a column to keep the database update version to be used for the Entry_Item in the cDbUpdateHandler object. There is also a function 'SQLUtilCreateDbVersionTable' for creating it as a SQL table at customer site."
96134>        Set Justification_Mode to JMode_Left
96135>        Set FontItalics to True
96136>    End_Object
96137>
96137>    Object oLineControl is a LineControl
96139>        Set Size to 2 374
96140>        Set Location to 63 12
96141>        Set peAnchors to anTopLeftRight
96142>    End_Object
96143>
96143>    Object oFileList_fm is a Form
96145>        Set Size to 13 246
96146>        Set Location to 89 27
96147>        Set Label to "Filelist.cfg:     (You can drop a Filelist.cfg here)"
96148>        Set Label_Col_Offset to 0
96149>        Set Label_Justification_Mode to JMode_Top
96150>        Set peAnchors to anTopLeftRight
96151>        Set Enabled_State to False
96152>        Set Label_Row_Offset to 1
96153>        Set FontWeight to fw_Bold
96154>
96154>        Procedure Prompt
96157>            String sValue sPath sFilelistName sFileMask
96157>            Get Value to sValue
96158>
96158>            Move (Trim(sValue)) to sValue
96159>            If (sValue <> "") Begin
96161>                Get ParseFolderName sValue to sPath
96162>            End
96162>
96162>            Move "Filelist.cfg files (*.cfg)|*.cfg" to sFileMask
96163>            Get vSelect_File sFileMask "Please select a Filelist.cfg file" sPath to sFilelistName
96164>            If (sFilelistName <> "") Begin
96166>                Set Value to sFilelistName
96167>            End
96167>        End_Procedure
96168>
96168>        Procedure OnChange
96171>            String sFilelistName sPath sOpenPath sDataPath sDdSrcPath sHomeFolder
96171>            Handle hTable
96171>            Boolean bExists
96171>
96171>            Get psOpenPath of ghoApplication to sOpenPath
96172>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
96173>            If (sOpenPath contains sDataPath) Begin
96175>                Move (Replace((sDataPath + "\;"), sOpenPath, "")) to sOpenPath
96176>            End
96176>
96176>            Get Value to sFilelistName
96177>            // This might be true if there was no .ws file on startup.
96177>            If (sFilelistName = "") Begin
96179>                Send Prompt
96180>                Procedure_Return
96181>            End
96181>            Get ParseFolderName sFilelistName to sPath
96182>            If (Right(sPath, 1) ="\") Begin
96184>                Move (Left(sPath, Length(sPath) -1)) to sPath
96185>            End
96185>            If (sPath = "") Begin
96187>                Procedure_Return
96188>            End
96188>            Set_Directory sPath
96189>
96189>            Set_Attribute DF_OPEN_PATH to (sPath + ";" + sOpenPath)
96192>            Set_Attribute DF_FILELIST_NAME to sFilelistName
96195>            // Change output folder so files are written to the correct Data folder.
96195>            // For some reason the psDataPath isn't used by default by the Structure_End command.
96195>
96195>            Set psDataPath of (phoWorkspace(ghoApplication))  to sPath
96196>            Set psFileList of (phoWorkspace(ghoApplication))  to sFilelistName
96197>
96197>            // We also need to output the .fd file if in development environment.
96197>            Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDdSrcPath
96198>            If (not(sOpenPath contains sDdSrcPath)) Begin
96200>                Get ExtractFilePath of (phoWorkspace(ghoApplication)) sPath to sHomeFolder
96201>                Move (Append(sHomeFolder, "DdSrc")) to sDdSrcPath
96202>                Get vFolderExists sDdSrcPath to bExists
96203>                If (bExists = True) Begin
96205>                    Set psDdSrcPath of (phoWorkspace(ghoApplication)) to sDdSrcPath
96206>                End
96206>            End
96206>            Move 0 to hTable
96207>            Get_Attribute DF_FILE_NEXT_EMPTY of hTable to hTable
96210>            Set Value of oTableNo_sf to hTable
96211>        End_Procedure
96212>
96212>        Procedure Activating
96215>            String sFilelistName
96215>            Forward Send Activating
96217>            Get psFilelistName of ghoApplication to sFilelistName
96218>            Set Value to sFilelistName
96219>        End_Procedure
96220>
96220>    End_Object
96221>
96221>    Object oSelect_btn is a Button
96223>        Set Size to 13 61
96224>        Set Location to 89 309
96225>        Set Label to "Select..."
96226>        Set psToolTip to "Select a Filelist.cfg from a Data folder where an embedded DbVersion table should be created."
96227>        Set peAnchors to anTopRight
96228>
96228>        Procedure OnClick
96231>            Send Prompt of oFileList_fm
96232>        End_Procedure
96233>
96233>    End_Object
96234>
96234>    Object oTableName_fm is a Form
96236>        Set Size to 13 100
96237>        Set Location to 125 27
96238>        Set Label to "Table Name:"
96239>        Set Label_Col_Offset to 0
96240>        Set Label_Row_Offset to 1
96241>        Set Label_Justification_Mode to JMode_Top
96242>        Set Enabled_State to False
96243>        Set Value to "DbVersion"
96244>    End_Object
96245>
96245>    Object oColumnName_fm is a Form
96247>        Set Size to 13 84
96248>        Set Location to 125 133
96249>        Set Label to "Column Name:"
96250>        Set Label_Col_Offset to 0
96251>        Set Label_Row_Offset to 1
96252>        Set Label_Justification_Mode to JMode_Top
96253>        Set Enabled_State to False
96254>        Set Value to "DatabaseVersion"
96255>    End_Object
96256>
96256>    Object oDataType_cf is a ComboForm
96258>        Set Size to 11 63
96259>        Set Location to 125 225
96260>        Set Label to "Data Type:"
96261>        Set Label_Col_Offset to 0
96262>        Set Label_Row_Offset to 1
96263>        Set Label_Justification_Mode to JMode_Top
96264>        Set Entry_State to False
96265>        Set Enabled_State to False
96266>
96266>        Procedure Combo_Fill_List
96269>            tColumnType[] ColumnTypeArray
96269>            tColumnType[] ColumnTypeArray
96270>            Integer iSize iCount
96270>
96270>            Send Delete_Data
96271>            Get UtilEnumerateColumnTypes of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex to ColumnTypeArray
96272>            Move (SizeOfArray(ColumnTypeArray)) to iSize
96273>            Decrement iSize
96274>            For iCount from 0 to iSize
96280>                Send Combo_Add_Item ColumnTypeArray[iCount].sSQLType
96281>            Loop
96282>            Set Value to "NUMERIC"
96283>            Set Enabled_State of oLength_sf to False
96284>            Set Enabled_State of oDecimals_sf to False
96285>            Set Value of oLength_sf   to 4
96286>            Set Value of oDecimals_sf to 2
96287>        End_Procedure
96288>
96288>        Procedure OnChange
96291>            Integer iDataType iSize iDec
96291>            Boolean bFixed
96291>
96291>            Get SelectedType to iDataType
96292>            Get UtilColumnTypePrecisionSize of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iDataType to iSize
96293>            Get UtilColumnTypePrecisionDec  of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iDataType to iDec
96294>            Get UtilColumnTypeFixed         of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iDataType to bFixed
96295>            Set Enabled_State of oLength_sf   to (bFixed = False)
96296>            Set Enabled_State of oDecimals_sf to (bFixed = False)
96297>            Set Value of oLength_sf to iSize
96298>            If (iDec = 0) Begin
96300>                Set Value of oDecimals_sf to ""
96301>            End
96301>            Else Begin
96302>                Set Value of oDecimals_sf to iDec
96303>            End
96303>            If (bFixed = False) Begin
96305>                Set Enabled_State of oDecimals_sf to (iDec <> 0)
96306>            End
96306>        End_Procedure
96307>
96307>        Function SelectedType Returns Integer
96310>            String sDataType
96310>            Integer iDataType
96310>
96310>            Get Value to sDataType
96311>            Get UtilColumnTypeToInteger of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex sDataType to iDataType
96312>
96312>            Function_Return iDataType
96313>        End_Function
96314>
96314>    End_Object
96315>
96315>    Object oLength_sf is a SpinForm
96317>        Set Label to "Length:"
96318>        Set Size to 13 38
96319>        Set Location to 125 297
96320>        Set Label_Col_Offset to 0
96321>        Set Label_Justification_Mode to JMode_Top
96322>        Set Label_Row_Offset to 1
96323>        Set Value to "4"
96324>        Set Maximum_Position to 50
96325>        Set Minimum_Position to 1
96326>        Set Enabled_State to False
96327>    End_Object
96328>
96328>    Object oDecimals_sf is a SpinForm
96330>        Set Label to "Decimals:"
96331>        Set Size to 13 33
96332>        Set Location to 125 344
96333>        Set Label_Col_Offset to 0
96334>        Set Label_Justification_Mode to JMode_Top
96335>        Set Label_Row_Offset to 1
96336>        Set Value to "2"
96337>        Set Maximum_Position to 8
96338>        Set Minimum_Position to 1
96339>        Set Enabled_State to False
96340>    End_Object
96341>
96341>    Object oTableNo_sf is a SpinForm
96343>        Set Label to "Filelist No:"
96344>        Set psToolTip to "When a new Filelist.cfg is selected, the first free slot number will be shown here."
96345>        Set Size to 13 32
96346>        Set Location to 155 27
96347>        Set Label_Col_Offset to 0
96348>        Set Label_Justification_Mode to JMode_Top
96349>        Set Label_Row_Offset to 1
96350>        Set Value to "2"
96351>        Set Maximum_Position to 4095
96352>        Set Minimum_Position to 1
96353>    End_Object
96354>
96354>    Object oFilelistInfo_tb is a TextBox
96356>        Set Size to 9 138
96357>        Set Location to 157 64
96358>        Set Label to "Default is to use the first free Filelist.cfg slot"
96359>    End_Object
96360>
96360>    Object oUseDefaults_cb is a CheckBox
96362>        Set Size to 10 50
96363>        Set Location to 157 225
96364>        Set Label to "Change Defaults"
96365>        Set psToolTip to "You REALLY have to know what you're doing if you want to change the defaults! Leave them as is if you are not 100% sure."
96366>
96366>        Procedure OnChange
96369>            Boolean bChecked
96369>
96369>            Get Checked_State to bChecked
96370>            Set Enabled_State of oTableName_fm  to (bChecked = True)
96371>            Set Enabled_State of oColumnName_fm to (bChecked = True)
96372>            Set Enabled_State of oDataType_cf   to (bChecked = True)
96373>            Set Enabled_State of oLength_sf     to (bChecked = True)
96374>            Set Enabled_State of oDecimals_sf   to (bChecked = True)
96375>        End_Procedure
96376>
96376>    End_Object
96377>
96377>    Object oCreateTable_btn is a Button
96379>        Set Size to 14 54
96380>        Set Location to 155 309
96381>        Set Label to "Create Table"
96382>        Set FontWeight to fw_Bold
96383>        Property String psToolTip1 "This will create a table & column for the Embedded database, to be used with the DataFlex Update Framework."
96385>        Property String psToolTip2 "There is also a 'SQLUtilCreateDbVersionTable' function that can be used to create/move the Table at customer site to SQL."
96387>        Set psToolTip to (psToolTip1(Self) + psToolTip2(Self))
96388>
96388>        Procedure OnClick
96391>            String sTableName sColumnName sInfoTxt1 sInfoTxt2 sDataType sFileList sDataPath
96391>            Integer iLength iDecimals iDataType iRetval iMin iMax
96391>            Boolean bOK
96391>            Handle hTable
96391>
96391>            Get Value of oFileList_fm  to sFileList
96392>            Get Value of oTableName_fm to sTableName
96393>            Move (Trim(sTableName))    to sTableName
96394>            If (sTableName = "") Begin
96396>                Send Info_Box "You first need to enter a table name."
96397>                Procedure_Return
96398>            End
96398>
96398>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
96399>            Get vFolderFormat sDataPath to sDataPath
96400>            Set psDriverID                      of ghoDbUpdateFunctionLibrary to DATAFLEX_ID
96401>            Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to iRetval
96402>            If (iRetval <> 0) Begin
96404>                Send Info_Box ("Sorry, a table named: '" + sTableName + "' already exists in" * sFileList + "!")
96405>                Procedure_Return
96406>            End
96406>
96406>            Get Value of oColumnName_fm      to sColumnName
96407>            Move (Trim(sColumnName))         to sColumnName
96408>            If (sColumnName = "") Begin
96410>                Send Info_Box "You need to enter a column name."
96411>                Procedure_Return
96412>            End
96412>
96412>            Get Value        of oDataType_cf to sDataType
96413>            Get SelectedType of oDataType_cf to iDataType
96414>            Get Value        of oLength_sf   to iLength
96415>            If (iLength < 1) Begin
96417>                Send Info_Box "You need to enter a proper length for the column"
96418>                Procedure_Return
96419>            End
96419>            Get Value of oDecimals_sf to iDecimals
96420>
96420>            Get Value of oTableNo_sf  to hTable
96421>            Get Maximum_Position of oTableNo_sf to iMax
96422>            Get Minimum_Position of oTableNo_sf to iMin
96423>            If (hTable < iMin or hTable > iMax) Begin
96425>                Send Info_Box "The selected Filelist number must be in the range: 1-4095"
96426>                Procedure_Return
96427>            End
96427>            Get UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bOK
96428>            If (bOK = True) Begin
96430>                Send Info_Box "The selected Filelist number exists and cannot be used to create a new table!"
96431>                Procedure_Return
96432>            End
96432>
96432>            // Reserved filelist numbers 48-50, 250-300
96432>            Move (hTable <> 48 and hTable <> 49 and hTable <> 50 and (hTable < 250 or hTable > 300)) to bOK
96433>            If (bOK = False) Begin
96435>                Send Info_Box "The selected Filelist number is in the range of reserved filelist numbers; 48-50 and 250-300"
96436>                Procedure_Return
96437>            End
96437>
96437>            Get psToolTip1 to sInfoTxt1
96438>            Get psToolTip2 to sInfoTxt2
96439>            Get YesNo_Box (sInfoTxt1 + "\n\n" + sInfoTxt2 + "\n\nContinue?") to iRetval
96440>            If (iRetval <> MBR_Yes) Begin
96442>                Procedure_Return
96443>            End
96443>
96443>            Send Cursor_Wait of Cursor_Control
96444>
96444>            Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName False True True to bOk
96445>            If (bOk = False) Begin
96447>                Send Info_Box "Sorry, it didn't work to create the table."
96448>                Procedure_Return
96449>            End
96449>
96449>            Get ApiTableChangeAttribute of ghoDbUpdateFunctionLibrary hTable DF_FILE_IS_SYSTEM_FILE True to bOK
96450>            Get ApiColumnAdd            of ghoDbUpdateFunctionLibrary hTable sColumnName iDataType iLength iDecimals to bOk
96451>            If (bOK = True) Begin
96453>                Move ("The table was created and Column '" + sColumnName + "'" * sDataType * String(iLength) + ", was successfully added to '" + sTableName + "'" * "(at filelist slot:" * String(hTable) + ")") to sInfoTxt1
96454>            End
96454>            Else Begin
96455>                Move ("The column could NOT be added. Either column" * sColumnName * "already exists or the Table name is incorrect?") to sInfoTxt1
96456>            End
96456>            Send Cursor_Ready of Cursor_Control
96457>            Send Info_Box sInfoTxt1
96458>        End_Procedure
96459>
96459>    End_Object
96460>
96460>    Procedure OnFileDropped String sFilename Boolean bLast
96463>        String sFilelistName
96463>
96463>        Forward Send OnFileDropped sFilename bLast
96465>
96465>        Move (Trim(sFilename)) to sFilename
96466>        Get ExtractFileName sFilename   to sFilelistName
96467>        Move (Uppercase(sFilelistName)) to sFilelistName
96468>        If (bLast = True and sFilelistName = "FILELIST.CFG") Begin
96470>            Set Value     of oFileList_fm to sFilename
96471>            Send OnChange of oFileList_fm
96472>        End
96472>    End_Procedure
96473>
96473>    // Put a status bar at the bottom of the panel, which makes
96473>    // status_help work and puts a gripper in the lower right corner.
96473>    Procedure End_Construct_Object
96476>        Integer iStyle iSize iOffset
96476>
96476>        Forward Send End_Construct_Object
96478>
96478>        Get Border_Style to iStyle
96479>        Move 8 to iOffset
96480>        If (iStyle = Border_Thick) Begin
96482>            Object oDialogCommandbar is a cCJCommandBarSystem
96484>                Object oStatusBar is a cCJStatusBar
96486>                    Set phoDialogCommandbar to Self
96487>                    Object oStatusIdle is a cCJStatusBarPane
96489>                        Set piId to sbpIDIdlePane
96490>                        Set pbStyleStretch to True
96491>                    End_Object
96492>                End_Object
96493>            End_Object
96494>            Get Size to iSize
96495>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
96496>            Set piMinSize to (Hi(iSize) + iOffset) (Low(iSize))
96497>        End
96497>
96497>    End_Procedure
96498>
96498>    Procedure Popup
96501>        Set Statusbar_Id to (phoDialogCommandbar(Self))
96502>        Forward Send Popup
96504>    End_Procedure
96505>
96505>    Procedure Page Integer iPageObject
96508>        Integer hWnd
96508>        Forward Send Page iPageObject
96510>
96510>        Get Window_Handle to hWnd
96511>
96511>        If ((ghoSkinFramework<>0) and (hWnd<>0)) Begin
96513>            Send ComRemoveWindow to ghoSkinFramework hWnd
96514>            Send ComApplyWindow  to ghoSkinFramework hWnd
96515>        End
96515>    End_Procedure
96516>
96516>    Object oAddToStudio_btn is a Button
96518>        Set Size to 14 52
96519>        Set Location to 179 82
96520>        Set Label to "Add to Studio"
96521>        Set peAnchors to anNone
96522>        Set psToolTip to "Dialog that adds this program to the Studio's 'Tools' menu."
96523>
96523>        Procedure OnClick
96526>            Send Popup of oAddToStudio_dg
96527>        End_Procedure
96528>
96528>    End_Object
96529>
96529>    Use StdAbout.pkg
Including file: StdAbout.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\StdAbout.pkg)
96529>>>//************************************************************************
96529>>>// Confidential Trade Secret.
96529>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
96529>>>// as an unpublished work.  All rights reserved.
96529>>>// DataFlex is a registered trademark of Data Access Corporation.
96529>>>//
96529>>>//************************************************************************
96529>>>//************************************************************************
96529>>>//
96529>>>// $File name  : StdAbout.pkg
96529>>>// $File title : Standard about object package for VDF
96529>>>// Notice      :
96529>>>// $Author(s)  : John Tuohy
96529>>>//
96529>>>// $Rev History
96529>>>//
96529>>>// JT 06/27/97   File created
96529>>>//************************************************************************
96529>>>
96529>>>// This provides a quick and simple way to create an about package for a program.
96529>>>// You need to create a message inside you client area called Activate_About.
96529>>>// Within this message you should send the message DoAbout passing needed
96529>>>// string information.
96529>>>//
96529>>>//       Procedure Activate_About
96529>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
96529>>>//       End_Procedure
96529>>>//    where: sTitle =     Name of application. If none provided, uses caption
96529>>>//                        bar title
96529>>>//           sVersion   = Version Line. If none provided, will be blank
96529>>>//           sCopyRight = Copyright Line. If none provided, will be blank
96529>>>//           sAuthor    = Author name, blank if none provided
96529>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
96529>>>//                        is used.
96529>>>// It is expected that you will place this in your own object package. For
96529>>>// example an order about package may look like this:
96529>>>//
96529>>>//   // OrderAbout.pkg
96529>>>//   Use StdAbout.pkg
96529>>>//   Procedure Activate_About
96529>>>//      String sTitle sCopyright sVersion sAuthor
96529>>>//      Move "My Order Entry System" to sTitle
96529>>>//      Move "Version 2.1" to sVersion
96529>>>//      Move "Copyright 1997, Super Software Inc." to sCopyright
96529>>>//      Move "John Smith"  to sAuthor
96529>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
96529>>>//   end_procedure
96529>>>//   // end of file.
96529>>>
96529>>>Use DfAbout.pkg
Including file: DfAbout.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\DfAbout.pkg)
96529>>>>>//************************************************************************
96529>>>>>// Confidential Trade Secret.
96529>>>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
96529>>>>>// as an unpublished work.  All rights reserved.
96529>>>>>// DataFlex Is A registered trademark Of Data Access Corporation.
96529>>>>>//
96529>>>>>//************************************************************************
96529>>>>>//************************************************************************
96529>>>>>//
96529>>>>>// $File name  : DfAbout.pkg
96529>>>>>// $File title : About class support
96529>>>>>// Notice      :
96529>>>>>// $Author(s)  : Vincent Oorsprong, Ken Ross
96529>>>>>//
96529>>>>>// $Rev History
96529>>>>>//
96529>>>>>// NGS 08/16/2013 Improved by using a cRichEdit object were the params gets added to.
96529>>>>>//                The objects that previously were popupated with values from the params,
96529>>>>>//                and their corresponding "Procedure Set..." messages, were removed as
96529>>>>>//                the edit object is used instead.
96529>>>>>//                The number of params to the DoAbout procedure was increased to ten, so
96529>>>>>//                it is easier to add whatever extra text strings needed/wanted.
96529>>>>>//                The StdAbout.pkg was also changed for this to work. It allows for an extra
96529>>>>>//                five new params to be passed, but these new params are all optional.
96529>>>>>//                So the interface will work exactly as before - if no extra parameters are passed.
96529>>>>>//                Also added an extra bitmap object to show the "Powered By Visual DataFlex" logo, in
96529>>>>>//                the lower left corner of the About object, beneath the "main" About bitmap.
96529>>>>>//                Note: It is assumed that the bitmap "PoweredByVisualDataFlex.bmp" exists.
96529>>>>>//                The background was changed to clWhite for easier usage of bitmaps. Just set the background
96529>>>>>//                color of your bitmap to white and the bitmap will not look jagged.
96529>>>>>//                If an Internet address is passed as one of the params, it will be underlined and clickable.
96529>>>>>//                An e-mail address can also be passed; e.g. "E-mail: mailto:mail@myemailaccount.com" and will
96529>>>>>//                also be clickable.
96529>>>>>// VOO 02/22/2012 Replaced obsolete code, improved Network_User_Name by asking
96529>>>>>//                Windows for the size first.
96529>>>>>// VOO 07/25/2003 Removed OnResize procedure for sysinfo dialog. Replaced logic
96529>>>>>//                with anchor technique. Removed unnessary property in the
96529>>>>>//                sysinfo dialog. Changed the size Of the about & sysinfo dialog
96529>>>>>//                object To better look in Windows XP. Repositioned the close
96529>>>>>//                button in the sysinfo dialog To line up with the display area
96529>>>>>//                Replaced obsolete code and techniques. Removed dead code.
96529>>>>>// JJT 10/23/2001 removed all ghoworkspace support. Uses app object or nothing
96529>>>>>// SWB 07/19/01   Added support Of the Application object in preference to
96529>>>>>//                the global Workspace object, if it is present
96529>>>>>// JJT 11/05/98   Added version information
96529>>>>>// VOO 29/10/98   Replaced the GetFreeSystemResources for the Win32 variant
96529>>>>>// JJT 7/31/97    Registered Enumerate Workspace so dfabout can exist without
96529>>>>>//                workspace package.
96529>>>>>// JJT 6/27/97    Turned the sysinfo objects into classes so the AboutDialog
96529>>>>>//                class can create this object.
96529>>>>>//                Cleaned up the interface (used correct classes and messages)
96529>>>>>//                Added workspace reporting support To sys-info.
96529>>>>>//                Turned off wrapping in the sys-info editor.
96529>>>>>// KR  ??/??/96   File created
96529>>>>>//************************************************************************
96529>>>>>Use LanguageText.pkg
96529>>>>>Use Windows.pkg
96529>>>>>Use DFbitmap.pkg
96529>>>>>Use GlobalFunctionsProcedures.pkg
96529>>>>>Use cRichEdit.pkg
Including file: cRichEdit.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cRichEdit.pkg)
96529>>>>>>>use Windows.pkg
96529>>>>>>>Use cEdit_Mixin.pkg
96529>>>>>>>
96529>>>>>>>// DFO: cRichEdit.Dfo
96529>>>>>>>// DFC: cRichEdit.Dfc
96529>>>>>>>
96529>>>>>>>// constants used for RichEdit Properties
96529>>>>>>>// peAlignment 
96529>>>>>>>Enum_List 
96529>>>>>>>    Define alLeft   for 1 
96529>>>>>>>    Define alRight  for 2 
96529>>>>>>>    Define alCenter for 3 
96529>>>>>>>End_Enum_List 
96529>>>>>>>
96529>>>>>>>// peBullets 
96529>>>>>>>Enum_List 
96529>>>>>>>    Define buNone 
96529>>>>>>>    Define buBullets 
96529>>>>>>>    Define buArabicNumbers 
96529>>>>>>>    Define buLowerLetters 
96529>>>>>>>    Define buUpperLetters 
96529>>>>>>>    Define buLowerRomans 
96529>>>>>>>    Define buUpperRomans 
96529>>>>>>>End_Enum_List 
96529>>>>>>>
96529>>>>>>>// peBulletStyle 
96529>>>>>>>Enum_List 
96529>>>>>>>    Define busRightParen   for 0 
96529>>>>>>>    Define busEncloseParen for 256 
96529>>>>>>>    Define busPeriod       for 512 
96529>>>>>>>    Define busNumberOnly   for 768 
96529>>>>>>>    Define busNoDisplay    for 1024 
96529>>>>>>>End_Enum_List
96529>>>>>>>    
96529>>>>>>>// peLineSpacingType
96529>>>>>>>Enum_List 
96529>>>>>>>    Define lstSingle
96529>>>>>>>    Define lstSingleAndOneHalf
96529>>>>>>>    Define lstDouble
96529>>>>>>>End_Enum_List
96529>>>>>>>
96529>>>>>>>Class cRichEdit Is A DFBaseRichEdit
96530>>>>>>>
96530>>>>>>>    Procedure Construct_Object
96532>>>>>>>        Forward Send Construct_Object
96534>>>>>>>        Send Define_cEdit_Mixin
96535>>>>>>>
96535>>>>>>>        On_key Key_Ctrl+Key_B send ToggleBold
96536>>>>>>>        On_key Key_Ctrl+Key_I send ToggleItalics
96537>>>>>>>        On_key Key_Ctrl+Key_U send ToggleUnderline
96538>>>>>>>
96538>>>>>>>    End_Procedure // Construct_Object
96539>>>>>>>
96539>>>>>>>    Import_Class_Protocol cEdit_Mixin
96540>>>>>>>    
96540>>>>>>>    Procedure ToggleBold
96542>>>>>>>        Set pbBold to (not(pbBold(self))) 
96543>>>>>>>    end_procedure
96544>>>>>>>    
96544>>>>>>>    Procedure ToggleItalics
96546>>>>>>>        Set pbItalics to (not(pbItalics(self))) 
96547>>>>>>>    end_procedure
96548>>>>>>>    
96548>>>>>>>    Procedure ToggleUnderline
96550>>>>>>>       Set pbUnderLine to (not(pbUnderLine(self))) 
96551>>>>>>>    end_procedure
96552>>>>>>>
96552>>>>>>>End_Class
96553>>>>>>>
96553>>>>>Use cTextEdit.pkg
96553>>>>>Use gFormatNumbers.pkg
Including file: gFormatNumbers.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\gFormatNumbers.pkg)
96553>>>>>>>//****************************************************************************//
96553>>>>>>>//                                                                            //
96553>>>>>>>// $File name  : gFormatNumbers.pkg                                           //
96553>>>>>>>// $File title : Globals for formating numbers and currency                   //
96553>>>>>>>// Notice      :                                                              //
96553>>>>>>>// $Author(s)  : John Tuohy                                                   //
96553>>>>>>>//                                                                            //
96553>>>>>>>// Confidential Trade Secret.                                                 //
96553>>>>>>>// Copyright 1999 Data Access Corporation, Miami FL, USA                      //
96553>>>>>>>// All Rights reserved                                                        //
96553>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.             //
96553>>>>>>>// $Rev History                                                               //
96553>>>>>>>//                                                                            //
96553>>>>>>>// 25.08.99 Created                                                           //
96553>>>>>>>//****************************************************************************//
96553>>>>>>>
96553>>>>>>>Use cFormatter.pkg
Including file: cFormatter.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cFormatter.pkg)
96553>>>>>>>>>//****************************************************************************//
96553>>>>>>>>>//                                                                            //
96553>>>>>>>>>// $File name  : cFormatter.pkg                                               //
96553>>>>>>>>>// $File title : cFormatter class (private class)                             //
96553>>>>>>>>>// $Author(s)  : John Tuohy                                                   //
96553>>>>>>>>>//                                                                            //
96553>>>>>>>>>// Confidential Trade Secret.                                                 //
96553>>>>>>>>>// Copyright 1999 Data Access Corporation, Miami FL, USA                      //
96553>>>>>>>>>// All Rights reserved                                                        //
96553>>>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.             //
96553>>>>>>>>>//                                                                            //
96553>>>>>>>>>// $Rev History                                                               //
96553>>>>>>>>>//                                                                            //
96553>>>>>>>>>// 25.08.99 Created                                                           //
96553>>>>>>>>>//****************************************************************************//
96553>>>>>>>>>use VDFBase.pkg
96553>>>>>>>>>
96553>>>>>>>>>Class cFormatter is an cObject
96554>>>>>>>>>
96554>>>>>>>>>    Procedure Construct_object
96556>>>>>>>>>        Integer iCh
96556>>>>>>>>>        forward send construct_object
96558>>>>>>>>>        Property String  psCurrencySymbol
96559>>>>>>>>>        Set psCurrencySymbol to (Default_Currency_Symbol())
96560>>>>>>>>>
96560>>>>>>>>>        Property string  psLeft
96561>>>>>>>>>        Property string  psright
96562>>>>>>>>>        Property integer pbThousandsSep
96563>>>>>>>>>        Property integer piPoints
96564>>>>>>>>>
96564>>>>>>>>>        Property string  psCurPosLeft
96565>>>>>>>>>        Property string  psCurPosright
96566>>>>>>>>>        Property integer pbCurPosThousandsSep
96567>>>>>>>>>        Property integer piCurPosPoints
96568>>>>>>>>>
96568>>>>>>>>>        Property string  psCurNegLeft
96569>>>>>>>>>        Property string  psCurNegright
96570>>>>>>>>>        Property integer pbCurNegThousandsSep
96571>>>>>>>>>        Property integer piCurNegPoints
96572>>>>>>>>>
96572>>>>>>>>>        Property string  psNumPosLeft
96573>>>>>>>>>        Property string  psNumPosright
96574>>>>>>>>>        Property integer pbNumPosThousandsSep
96575>>>>>>>>>        Property integer piNumPosPoints
96576>>>>>>>>>
96576>>>>>>>>>        Property string  psNumNegLeft
96577>>>>>>>>>        Property string  psNumNegright
96578>>>>>>>>>        Property integer pbNumNegThousandsSep
96579>>>>>>>>>        Property integer piNumNegPoints
96580>>>>>>>>>
96580>>>>>>>>>        Send SetFormat "$,#.##;($,#.##)" true  // currency
96581>>>>>>>>>        Send SetFormat  ",#.*"           false // numeric
96582>>>>>>>>>
96582>>>>>>>>>    end_procedure
96583>>>>>>>>>
96583>>>>>>>>>    // internal
96583>>>>>>>>>    // parse passed format string and set temporary properties with result
96583>>>>>>>>>    //
96583>>>>>>>>>    Procedure ParseFormat string sFmt
96585>>>>>>>>>
96585>>>>>>>>>        string sLeft sRight sDigit
96585>>>>>>>>>        integer bSep iPos i iDigits
96585>>>>>>>>>
96585>>>>>>>>>        // replace any literals. A "/" followed by anything.
96585>>>>>>>>>        // some literals are special. $ . , / #
96585>>>>>>>>>        Move (Replaces("/$",sFmt,Character(1)))    to sFmt
96586>>>>>>>>>        Move (Replaces("/.",sFmt,Character(2)))    to sFmt
96587>>>>>>>>>        Move (Replaces("/,",sFmt,Character(3)))    to sFmt
96588>>>>>>>>>        Move (Replaces("/"+"/",sFmt,Character(4))) to sFmt
96589>>>>>>>>>        Move (Replaces("/#",sFmt,Character(5)))    to sFmt
96590>>>>>>>>>        Move (Character(9)) to sDigit
96591>>>>>>>>>        Move (Replaces("#",sFmt,sDigit))           to sFmt
96592>>>>>>>>>        Move (Replaces("/",sFmt,""))               to sFmt // replace all others
96593>>>>>>>>>
96593>>>>>>>>>        Move (Pos(",",sFmt))                 to bSep // if we have any , we use thousand seps
96594>>>>>>>>>        If bSep Move (Replaces(",",sFmt,"")) to sFmt // remove all ,
96597>>>>>>>>>
96597>>>>>>>>>        Move (Replaces("$",sFmt,psCurrencySymbol(self))) to sFmt // replace any $ with currency symbol
96598>>>>>>>>>
96598>>>>>>>>>        Move (Pos(".",sFmt)) to iPos                 // position of decimal
96599>>>>>>>>>
96599>>>>>>>>>        // Move all the special literals back into place before parsing
96599>>>>>>>>>        Move (Replaces(Character(1),sFmt,"$")) to sFmt
96600>>>>>>>>>        Move (Replaces(Character(2),sFmt,".")) to sFmt
96601>>>>>>>>>        Move (Replaces(Character(3),sFmt,",")) to sFmt
96602>>>>>>>>>        Move (Replaces(Character(4),sFmt,"/")) to sFmt
96603>>>>>>>>>        Move (Replaces(Character(5),sFmt,"#")) to sFmt
96604>>>>>>>>>
96604>>>>>>>>>        If (iPos>0) Begin                      // if we have a decimanl point
96606>>>>>>>>>            Move 1 to i                        // look for first non # to right and count the #s
96607>>>>>>>>>            If (mid(sFmt,1,iPos+i)="*") Begin  // the "*" is special. It means as many as you want
96609>>>>>>>>>               Move -2 to iDigits
96610>>>>>>>>>               increment i
96611>>>>>>>>>            end
96611>>>>>>>>>>
96611>>>>>>>>>            While (mid(sFmt,1,iPos+i)=sDigit)
96615>>>>>>>>>                 Increment i
96616>>>>>>>>>            end
96617>>>>>>>>>>
96617>>>>>>>>>            Move (Mid(sFmt,255,iPos+i)) to sRight // everything to the right of the last # is format stuff
96618>>>>>>>>>            If (iDigits=0) Move (i-1) to iDigits
96621>>>>>>>>>            //
96621>>>>>>>>>            Move 1 to i                           // find the first non-# to the left of the point
96622>>>>>>>>>            While (mid(sFmt,1,iPos-i)=sDigit)     // everything to the left is format stuff
96626>>>>>>>>>                 increment i
96627>>>>>>>>>            end
96628>>>>>>>>>>
96628>>>>>>>>>            Move (left(sFmt,iPos-i)) to sLeft
96629>>>>>>>>>        end
96629>>>>>>>>>>
96629>>>>>>>>>        else begin                             // we have no decinal
96630>>>>>>>>>            Move 0 to iDigits                  // so points is none
96631>>>>>>>>>            Move (Pos(sDigit,sFmt)) to iPos    // find first #.
96632>>>>>>>>>            If (iPos=0) Begin                  // if none, entire string is left format stuff..wierd!
96634>>>>>>>>>                Move sFmt to sLeft
96635>>>>>>>>>                Move ""   to sRight
96636>>>>>>>>>            end
96636>>>>>>>>>>
96636>>>>>>>>>            else begin
96637>>>>>>>>>                Move (left(sFmt,iPos-1)) to sLeft // all char to left of first # is left format stuff
96638>>>>>>>>>                Move 1 to i
96639>>>>>>>>>                While (mid(sFmt,1,iPos+i)=sDigit) // find last #, all char to right is right format
96643>>>>>>>>>                    Increment i
96644>>>>>>>>>                end
96645>>>>>>>>>>
96645>>>>>>>>>                Move (Mid(sFmt,255,i+iPos)) to sRight
96646>>>>>>>>>            end
96646>>>>>>>>>>
96646>>>>>>>>>        end
96646>>>>>>>>>>
96646>>>>>>>>>        // set temporary format properties and exit
96646>>>>>>>>>        Set pbThousandsSep to bSep
96647>>>>>>>>>        set psLeft         to sLeft
96648>>>>>>>>>        set psRight        to sRight
96649>>>>>>>>>        Set piPoints       to iDigits
96650>>>>>>>>>     End_procedure
96651>>>>>>>>>
96651>>>>>>>>>    // Public: Sets a format string. Pass full format for Positve and negative in sFmt. Pass
96651>>>>>>>>>    //         bCurrency true is this is a currency format, false if a numeric format
96651>>>>>>>>>    //
96651>>>>>>>>>    //  e.g. Send SetFormat "$,#.##;($,#.##)" True
96651>>>>>>>>>    //
96651>>>>>>>>>    Procedure SetFormat string sFmt integer bCurrency
96653>>>>>>>>>        string sPos sNeg
96653>>>>>>>>>        integer iPos
96653>>>>>>>>>
96653>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
96654>>>>>>>>>        If iPos begin
96656>>>>>>>>>            Move (left(sFmt,iPos-1))    to sPos
96657>>>>>>>>>            Move (mid(sFmt,255,iPos+1)) to sNeg
96658>>>>>>>>>        end
96658>>>>>>>>>>
96658>>>>>>>>>        else Begin
96659>>>>>>>>>            Move sFmt         to sPos
96660>>>>>>>>>            Move ("-" + sFmt) to sNeg
96661>>>>>>>>>        end
96661>>>>>>>>>>
96661>>>>>>>>>        Send ParseFormat sPos
96662>>>>>>>>>        If bCurrency begin
96664>>>>>>>>>            Set pbCurPosThousandsSep to (pbThousandsSep(self))
96665>>>>>>>>>            set psCurPosLeft         to (psLeft(self))
96666>>>>>>>>>            set psCurPosRight        to (psRight(self))
96667>>>>>>>>>            Set piCurPosPoints       to (piPoints(self))
96668>>>>>>>>>        End
96668>>>>>>>>>>
96668>>>>>>>>>        else Begin
96669>>>>>>>>>            Set pbNumPosThousandsSep to (pbThousandsSep(self))
96670>>>>>>>>>            set psNumPosLeft         to (psLeft(self))
96671>>>>>>>>>            set psNumPosRight        to (psRight(self))
96672>>>>>>>>>            Set piNumPosPoints       to (piPoints(self))
96673>>>>>>>>>        end
96673>>>>>>>>>>
96673>>>>>>>>>
96673>>>>>>>>>        Send ParseFormat sNeg
96674>>>>>>>>>        If bCurrency begin
96676>>>>>>>>>            Set pbCurNegThousandsSep to (pbThousandsSep(self))
96677>>>>>>>>>            set psCurNegLeft         to (psLeft(self))
96678>>>>>>>>>            set psCurNegRight        to (psRight(self))
96679>>>>>>>>>            Set piCurNegPoints       to (piPoints(self))
96680>>>>>>>>>        End
96680>>>>>>>>>>
96680>>>>>>>>>        else Begin
96681>>>>>>>>>            Set pbNumNegThousandsSep to (pbThousandsSep(self))
96682>>>>>>>>>            set psNumNegLeft         to (psLeft(self))
96683>>>>>>>>>            set psNumNegRight        to (psRight(self))
96684>>>>>>>>>            Set piNumNegPoints       to (piPoints(self))
96685>>>>>>>>>        end
96685>>>>>>>>>>
96685>>>>>>>>>    End_procedure
96686>>>>>>>>>
96686>>>>>>>>>    // low level formatting. Pass parameters
96686>>>>>>>>>    Function Format_Num number nNumber integer iPoints integer bSep ;                       string sPrefix string sSuffix returns string
96688>>>>>>>>>        string  sLeft sRight sNumber sSep sDec
96688>>>>>>>>>        integer bIsNegative iDec iLen iCh
96688>>>>>>>>>
96688>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iCh
96691>>>>>>>>>        Move (Character(iCh)) to sDec
96692>>>>>>>>>
96692>>>>>>>>>        Move (abs(nNumber)) to sNumber
96693>>>>>>>>>        Move (Pos(sDec,sNumber)) to iDec
96694>>>>>>>>>        Move (If(iDec=0, sNumber, left(sNumber,iDec-1))) to sLeft
96695>>>>>>>>>        Move (If(iDec=0, "", mid(sNumber,255,iDec+1)))   to sRight
96696>>>>>>>>>        // format for decimal separator
96696>>>>>>>>>        If (iPoints>=0) ; // if -2, leave it alone, it should not be -1            Move (left(sRight+repeat("0",iPoints),iPoints)) to sRight
96699>>>>>>>>>
96699>>>>>>>>>        // format for thousand sep.
96699>>>>>>>>>        If bSep Begin
96701>>>>>>>>>            Get_Attribute DF_THOUSANDS_SEPARATOR to iCh
96704>>>>>>>>>            Move (Character(iCh)) to sSep
96705>>>>>>>>>            Move (Length(sLeft)) to iLen
96706>>>>>>>>>            While (iLen>3)
96710>>>>>>>>>                Move (insert(sSep,sLeft,iLen-2)) to sLeft
96711>>>>>>>>>                Move (iLen-3) to iLen
96712>>>>>>>>>            End
96713>>>>>>>>>>
96713>>>>>>>>>        End
96713>>>>>>>>>>
96713>>>>>>>>>        // if decimal points or -2 (allow anything) and there are points to show
96713>>>>>>>>>        If (iPoints>0 OR (iPoints=-2 AND sRight<>"")) ;            Move (sLeft + sDec + sright) to sLeft
96716>>>>>>>>>        Function_return (sPrefix + sLeft+ sSuffix)
96717>>>>>>>>>    End_Function
96718>>>>>>>>>
96718>>>>>>>>>    // Public: Format for currency
96718>>>>>>>>>    //
96718>>>>>>>>>    Function FormatCur number nNumber integer iPoints returns string
96720>>>>>>>>>        string  sLeft sRight
96720>>>>>>>>>        integer bSep
96720>>>>>>>>>        If (nNumber<0) Begin
96722>>>>>>>>>            get pbCurNegThousandsSep to bSep
96723>>>>>>>>>            get psCurNegLeft         to sLeft
96724>>>>>>>>>            get psCurNegRight        to sRight
96725>>>>>>>>>            If (iPoints=-1) get piCurNegPoints       to iPoints
96728>>>>>>>>>        end
96728>>>>>>>>>>
96728>>>>>>>>>        Else Begin
96729>>>>>>>>>            get pbCurPosThousandsSep to bSep
96730>>>>>>>>>            get psCurPosLeft         to sLeft
96731>>>>>>>>>            get psCurPosRight        to sRight
96732>>>>>>>>>            If (iPoints=-1) get piCurPosPoints       to iPoints
96735>>>>>>>>>        end
96735>>>>>>>>>>
96735>>>>>>>>>        Function_return (Format_Num(self, nNumber,iPoints,bSep,sLeft,sRight))
96736>>>>>>>>>    End_function
96737>>>>>>>>>
96737>>>>>>>>>    // Public: Format for numeric
96737>>>>>>>>>    //
96737>>>>>>>>>    Function FormatNum number nNumber integer iPoints returns string
96739>>>>>>>>>        string  sLeft sRight
96739>>>>>>>>>        integer bSep
96739>>>>>>>>>        If (nNumber<0) Begin
96741>>>>>>>>>            get pbNumNegThousandsSep to bSep
96742>>>>>>>>>            get psNumNegLeft         to sLeft
96743>>>>>>>>>            get psNumNegRight        to sRight
96744>>>>>>>>>            If (iPoints=-1) get piNumNegPoints       to iPoints
96747>>>>>>>>>        end
96747>>>>>>>>>>
96747>>>>>>>>>        Else Begin
96748>>>>>>>>>            get pbNumPosThousandsSep to bSep
96749>>>>>>>>>            get psNumPosLeft         to sLeft
96750>>>>>>>>>            get psNumPosRight        to sRight
96751>>>>>>>>>            If (iPoints=-1) get piNumPosPoints       to iPoints
96754>>>>>>>>>        end
96754>>>>>>>>>>
96754>>>>>>>>>        Function_return (Format_Num(self, nNumber,iPoints,bSep,sLeft,sRight))
96755>>>>>>>>>    End_function
96756>>>>>>>>>
96756>>>>>>>>>
96756>>>>>>>>>    // Public: Format passing format string
96756>>>>>>>>>    //
96756>>>>>>>>>    Function FormatVal number nNumber string sFmt returns string
96758>>>>>>>>>        integer iPos bIsNeg
96758>>>>>>>>>        string  sLeft sRight
96758>>>>>>>>>        integer iPoints bSep
96758>>>>>>>>>        Move (nNumber<0) to bIsNeg
96759>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
96760>>>>>>>>>        Case Begin
96760>>>>>>>>>            Case (iPos and Not(bIsNeg))      Move (left(sFmt,iPos-1))    to sFmt
96763>>>>>>>>>            Case (iPos and bIsNeg)           Move (mid(sFmt,255,iPos+1)) to sFmt
96767>>>>>>>>>            Case (not(iPos) and not(bIsNeg)) Move sFmt                   to sFmt
96771>>>>>>>>>            Case else                        Move ("-" + sFmt)           to sFmt
96773>>>>>>>>>        case end
96773>>>>>>>>>        Send ParseFormat sFmt
96774>>>>>>>>>        get pbThousandsSep to bSep
96775>>>>>>>>>        get psLeft         to sLeft
96776>>>>>>>>>        get psRight        to sRight
96777>>>>>>>>>        get piPoints       to iPoints
96778>>>>>>>>>        Function_return (Format_Num(self, nNumber,iPoints,bSep,sLeft,sRight))
96779>>>>>>>>>    end_function
96780>>>>>>>>>
96780>>>>>>>>>End_Class
96781>>>>>>>
96781>>>>>>>// for now, this object is private. All access is through the following
96781>>>>>>>// global functions
96781>>>>>>>
96781>>>>>>>//Object oFmt is a cFormatter
96781>>>>>>>//end_object
96781>>>>>>>
96781>>>>>>>Global_variable handle ghoFormatter
96781>>>>>>>Get Create of desktop U_cFormatter to ghoFormatter
96782>>>>>>>
96782>>>>>>>Function FormatNumber Global number nNum integer iPoints returns string
96784>>>>>>>    Function_return (FormatNum(ghoFormatter, nNum,iPoints))
96785>>>>>>>end_function
96786>>>>>>>
96786>>>>>>>Function FormatCurrency Global number nNum integer iPoints returns string
96788>>>>>>>    Function_return (FormatCur(ghoFormatter, nNum,iPoints))
96789>>>>>>>end_function
96790>>>>>>>
96790>>>>>>>Function FormatValue Global number nNum string sFmt returns string
96792>>>>>>>    Function_return (FormatVal(ghoFormatter, nNum,sFmt))
96793>>>>>>>end_function
96794>>>>>>>
96794>>>>>>>Procedure SetCurrencyFormat Global string sFmt
96796>>>>>>>    Send SetFormat of ghoFormatter sFmt True
96797>>>>>>>end_function
96798>>>>>>>
96798>>>>>>>Procedure SetNumberFormat Global string sFmt
96800>>>>>>>    Send SetFormat of ghoFormatter sFmt False
96801>>>>>>>end_function
96802>>>>>>>
96802>>>>>Use MapiDllCalls.Pkg
Including file: MapiDllCalls.Pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\MapiDllCalls.Pkg)
96802>>>>>>>Use MapiConstants.Pkg
Including file: MapiConstants.Pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\MapiConstants.Pkg)
96802>>>>>>>>>Type MapiSession
96802>>>>>>>>>   Field MapiSession.SessionID As Integer
96802>>>>>>>>>End_type // MapiSession
96802>>>>>>>>>
96802>>>>>>>>>Type MapiMessagePointer
96802>>>>>>>>>   Field MapiMessagePointer.lppMessage As Pointer
96802>>>>>>>>>End_Type // MapiMessagePointer
96802>>>>>>>>>
96802>>>>>>>>>Type MapiRecipPointer
96802>>>>>>>>>   Field MapiRecipPointer.lppRecip As Pointer
96802>>>>>>>>>End_Type // MapiRecipPointer
96802>>>>>>>>>
96802>>>>>>>>>Type MapiNewRecipsPointer
96802>>>>>>>>>   Field MapiNewRecipsPointer.lppNewRecips As Pointer
96802>>>>>>>>>End_Type // MapiNewRecipsPointer
96802>>>>>>>>>
96802>>>>>>>>>Type MapiNewRecipsCounter
96802>>>>>>>>>   Field MapiNewRecipsCounter.lpnNewRecips As Integer
96802>>>>>>>>>End_Type // MapiNewRecipsCounter
96802>>>>>>>>>
96802>>>>>>>>>Type MapiFileDesc
96802>>>>>>>>>   Field MapiFileDesc.ulReserved As Integer      // Reserved for future use (must be 0)
96802>>>>>>>>>   Field MapiFileDesc.flFlags As Integer         // Flags
96802>>>>>>>>>   Field MapiFileDesc.nPosition As Integer       // character in text to be replaced by attachment
96802>>>>>>>>>   Field MapiFileDesc.lpszPathName As Pointer    // Full path name of attachment file
96802>>>>>>>>>   Field MapiFileDesc.lpszFileName As Pointer    // Original file name (optional)
96802>>>>>>>>>   Field MapiFileDesc.lpFileType As Pointer     // Attachment file type (can be lpMapiFileTagExt)
96802>>>>>>>>>End_Type // MapiFileDesc
96802>>>>>>>>>
96802>>>>>>>>>Define MAPI_OLE        For |CI$00000001
96802>>>>>>>>>Define MAPI_OLE_STATIC For |CI$00000002
96802>>>>>>>>>
96802>>>>>>>>>Define MAPI_NOATTACHMENT_POSITION For |CI$FFFFFFFF
96802>>>>>>>>>
96802>>>>>>>>>Type MapiFileTagExt
96802>>>>>>>>>   Field MapiFileTagExt.ulReserved As Integer  // Reserved, must be zero.
96802>>>>>>>>>   Field MapiFileTagExt.cbTag As Integer       // Size (in bytes) of
96802>>>>>>>>>   Field MapiFileTagExt.lpTag As Pointer       // X.400 OID for this attachment type
96802>>>>>>>>>   Field MapiFileTagExt.cbEncoding As Integer  // Size (in bytes) of
96802>>>>>>>>>   Field MapiFileTagExt.lpEncoding As Pointer  // X.400 OID for this attachment's encoding
96802>>>>>>>>>End_Type // MapiFileTagExt
96802>>>>>>>>>
96802>>>>>>>>>Type MapiRecipDesc
96802>>>>>>>>>   Field MapiRecipDesc.ulReserved As Integer   // Reserved for future use
96802>>>>>>>>>   Field MapiRecipDesc.ulRecipClass As Integer // Recipient class
96802>>>>>>>>>                                               // MAPI_TO, MAPI_CC, MAPI_BCC, MAPI_ORIG
96802>>>>>>>>>   Field MapiRecipDesc.lpszName As Pointer     // Recipient name
96802>>>>>>>>>   Field MapiRecipDesc.lpszAddress As Pointer  // Recipient address (optional)
96802>>>>>>>>>   Field MapiRecipDesc.ulEIDSize As Pointer    // Count in bytes of size of pEntryID
96802>>>>>>>>>   Field MapiRecipDesc.lpEntryID As Pointer    // System-specific recipient reference
96802>>>>>>>>>End_Type // MapiRecipDesc
96802>>>>>>>>>
96802>>>>>>>>>Define MAPI_ORIG   For 0 // Recipient is message originator
96802>>>>>>>>>Define MAPI_TO     For 1 // Recipient is a primary recipient
96802>>>>>>>>>Define MAPI_CC     For 2 // Recipient is a copy recipient
96802>>>>>>>>>Define MAPI_BCC    For 3 // Recipient is blind copy recipient
96802>>>>>>>>>
96802>>>>>>>>>Type MapiMessage
96802>>>>>>>>>   Field MapiMessage.ulReserved As Integer                   // Reserved for future use (M.B. 0)
96802>>>>>>>>>   Field MapiMessage.lpszSubject As Pointer                  // Message Subject
96802>>>>>>>>>   Field MapiMessage.lpszNoteText As Pointer                 // Message Text
96802>>>>>>>>>   Field MapiMessage.lpszMessageType As Pointer              // Message Class
96802>>>>>>>>>   Field MapiMessage.lpszDateReceived As Pointer             // in YYYY/MM/DD HH:MM format
96802>>>>>>>>>   Field MapiMessage.lpszConversationID As Pointer           // conversation thread ID
96802>>>>>>>>>   Field MapiMessage.flFlags As Integer                      // unread,return receipt
96802>>>>>>>>>   Field MapiMessage.lpOriginator As Pointer                 // Originator descriptor
96802>>>>>>>>>   Field MapiMessage.nRecipCount As Integer                  // Number of recipients
96802>>>>>>>>>   Field MapiMessage.lpRecips As Pointer                     // Recipient descriptors
96802>>>>>>>>>   Field MapiMessage.nFileCount As Integer                   // # of file attachments
96802>>>>>>>>>   Field MapiMessage.lpFiles As Pointer                      // Attachment descriptors
96802>>>>>>>>>End_Type // MapiMessage
96802>>>>>>>>>
96802>>>>>>>>>Define MAPI_UNREAD            For |CI$00000001
96802>>>>>>>>>Define MAPI_RECEIPT_REQUESTED For |CI$00000002
96802>>>>>>>>>Define MAPI_SENT              For |CI$00000004
96802>>>>>>>>>
96802>>>>>>>>>// MAPILogon() flags.
96802>>>>>>>>>Define MAPI_LOGON_UI         For |CI$00000001 // Display logon UI
96802>>>>>>>>>Define MAPI_PASSWORD_UI      For |CI$00020000 // prompt for password only
96802>>>>>>>>>Define MAPI_NEW_SESSION      For |CI$00000002 // Don't use shared session
96802>>>>>>>>>Define MAPI_FORCE_DOWNLOAD   For |CI$00001000 // Get new mail before return
96802>>>>>>>>>Define MAPI_ALLOW_OTHERS     For |CI$00000008 // Make this a shared session
96802>>>>>>>>>Define MAPI_EXPLICIT_PROFILE For |CI$00000010 // Don't use default profile
96802>>>>>>>>>Define MAPI_EXTENDED         For |CI$00000020 // Extended MAPI Logon
96802>>>>>>>>>Define MAPI_USE_DEFAULT      For |CI$00000040 // Use default profile in logon
96802>>>>>>>>>
96802>>>>>>>>>Define MAPI_SIMPLE_DEFAULT  For (MAPI_LOGON_UI + MAPI_FORCE_DOWNLOAD + MAPI_ALLOW_OTHERS)
96802>>>>>>>>>Define MAPI_SIMPLE_EXPLICIT For (MAPI_NEW_SESSION + MAPI_FORCE_DOWNLOAD + MAPI_EXPLICIT_PROFILE)
96802>>>>>>>>>
96802>>>>>>>>>// MAPILogoff() flags.
96802>>>>>>>>>Define MAPI_LOGOFF_SHARED For |CI$00000001 // Close all shared sessions
96802>>>>>>>>>Define MAPI_LOGOFF_UI     For |CI$00000002 // It's OK to present UI
96802>>>>>>>>>
96802>>>>>>>>>// MAPISendMail() flags.
96802>>>>>>>>>Define MAPI_LOGON_UI    For |CI$00000001 // Display logon UI
96802>>>>>>>>>Define MAPI_NEW_SESSION For |CI$00000002 // Don't use shared session
96802>>>>>>>>>
96802>>>>>>>>>Define MAPI_DIALOG      For |CI$00000008 // Display a send note UI
96802>>>>>>>>>Define MAPI_USE_DEFAULT For |CI$00000040 // Use default profile in logon
96802>>>>>>>>>
96802>>>>>>>>>// MAPIFindNext() flags.
96802>>>>>>>>>Define MAPI_UNREAD_ONLY    For |CI$00000020 // Only unread messages
96802>>>>>>>>>Define MAPI_GUARANTEE_FIFO For |CI$00000100 // use date order
96802>>>>>>>>>Define MAPI_LONG_MSGID     For |CI$00004000 // allow 512 char returned ID
96802>>>>>>>>>
96802>>>>>>>>>// MAPIReadMail() flags.
96802>>>>>>>>>Define MAPI_PEEK            For |CI$00000080 // Do not mark as read.
96802>>>>>>>>>Define MAPI_SUPPRESS_ATTACH For |CI$00000800 // header + body, no files
96802>>>>>>>>>Define MAPI_ENVELOPE_ONLY   For |CI$00000040 // Only header information
96802>>>>>>>>>Define MAPI_BODY_AS_FILE    For |CI$00000200
96802>>>>>>>>>
96802>>>>>>>>>// MAPISaveMail() flags.
96802>>>>>>>>>Define MAPI_LOGON_UI    For |CI$00000001 // Display logon UI
96802>>>>>>>>>Define MAPI_NEW_SESSION For |CI$00000002 // Don't use shared session
96802>>>>>>>>>Define MAPI_LONG_MSGID  For |CI$00004000 // allow 512 char returned ID
96802>>>>>>>>>
96802>>>>>>>>>// MAPIAddress() flags.
96802>>>>>>>>>Define MAPI_LOGON_UI    For |CI$00000001 // Display logon UI
96802>>>>>>>>>Define MAPI_NEW_SESSION For |CI$00000002 // Don't use shared session
96802>>>>>>>>>
96802>>>>>>>>>// MAPIDetails() flags.
96802>>>>>>>>>Define MAPI_LOGON_UI    For |CI$00000001 // Display logon UI
96802>>>>>>>>>Define MAPI_NEW_SESSION For |CI$00000002 // Don't use shared session
96802>>>>>>>>>Define MAPI_AB_NOMODIFY For |CI$00000400 // Don't allow mods of AB entries
96802>>>>>>>>>
96802>>>>>>>>>// MAPIResolveName() flags.
96802>>>>>>>>>Define MAPI_LOGON_UI    For |CI$00000001 // Display logon UI
96802>>>>>>>>>Define MAPI_NEW_SESSION For |CI$00000002 // Don't use shared session
96802>>>>>>>>>Define MAPI_DIALOG      For |CI$00000008 // Prompt for choices if ambiguous
96802>>>>>>>>>Define MAPI_AB_NOMODIFY For |CI$00000400 // Don't allow mods of AB entries
96802>>>>>>>>>
96802>>>>>>>>>Define SUCCESS_SUCCESS                 For 0
96802>>>>>>>>>Define MAPI_USER_ABORT                 For 1
96802>>>>>>>>>Define MAPI_E_USER_ABORT               For MAPI_USER_ABORT
96802>>>>>>>>>Define MAPI_E_FAILURE                  For 2
96802>>>>>>>>>Define MAPI_E_LOGON_FAILURE            For 3
96802>>>>>>>>>Define MAPI_E_LOGIN_FAILURE            For MAPI_E_LOGON_FAILURE
96802>>>>>>>>>Define MAPI_E_DISK_FULL                For 4
96802>>>>>>>>>Define MAPI_E_INSUFFICIENT_MEMORY      For 5
96802>>>>>>>>>Define MAPI_E_ACCESS_DENIED            For 6
96802>>>>>>>>>Define MAPI_E_TOO_MANY_SESSIONS        For 8
96802>>>>>>>>>Define MAPI_E_TOO_MANY_FILES           For 9
96802>>>>>>>>>Define MAPI_E_TOO_MANY_RECIPIENTS      For 10
96802>>>>>>>>>Define MAPI_E_ATTACHMENT_NOT_FOUND     For 11
96802>>>>>>>>>Define MAPI_E_ATTACHMENT_OPEN_FAILURE  For 12
96802>>>>>>>>>Define MAPI_E_ATTACHMENT_WRITE_FAILURE For 13
96802>>>>>>>>>Define MAPI_E_UNKNOWN_RECIPIENT        For 14
96802>>>>>>>>>Define MAPI_E_BAD_RECIPTYPE            For 15
96802>>>>>>>>>Define MAPI_E_NO_MESSAGES              For 16
96802>>>>>>>>>Define MAPI_E_INVALID_MESSAGE          For 17
96802>>>>>>>>>Define MAPI_E_TEXT_TOO_LARGE           For 18
96802>>>>>>>>>Define MAPI_E_INVALID_SESSION          For 19
96802>>>>>>>>>Define MAPI_E_TYPE_NOT_SUPPORTED       For 20
96802>>>>>>>>>Define MAPI_E_AMBIGUOUS_RECIPIENT      For 21
96802>>>>>>>>>Define MAPI_E_AMBIG_RECIP              For MAPI_E_AMBIGUOUS_RECIPIENT
96802>>>>>>>>>Define MAPI_E_MESSAGE_IN_USE           For 22
96802>>>>>>>>>Define MAPI_E_NETWORK_FAILURE          For 23
96802>>>>>>>>>Define MAPI_E_INVALID_EDITFIELDS       For 24
96802>>>>>>>>>Define MAPI_E_INVALID_RECIPS           For 25
96802>>>>>>>>>Define MAPI_E_NOT_SUPPORTED            For 26
96802>>>>>>>Use WinKern.pkg
96802>>>>>>>
96802>>>>>>>External_Function MAPILogon "MAPILogon" Mapi32.Dll ;   Integer ulUIParam ;   Pointer lpszProfileName ;   Pointer lpszPassword ;   Integer flFlags ;   Integer ulReserved ;   Pointer lplhSession ;   Returns Integer
96803>>>>>>>External_Function MAPILogoff "MAPILogoff" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Integer flFlags ;   Integer ulReserved ;   Returns Integer
96804>>>>>>>External_Function MAPIFindNext "MAPIFindNext" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpszMessageType ;   Pointer lpszSeedMessageID ;   Integer flFlags ;   Integer ulReserved ;   Pointer lpszMessageID ;   Returns Integer
96805>>>>>>>External_Function MAPIFreeBuffer "MAPIFreeBuffer" Mapi32.Dll ;   Pointer pv ;   Returns Integer
96806>>>>>>>External_Function MAPIReadMail "MAPIReadMail" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpszMessageID ;   Integer flFlags ;   Integer ulReserved ;   Pointer lppMessage ;   Returns Integer
96807>>>>>>>External_Function MAPIAddress "MAPIAddress" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpszCaption ;   Integer nEditFields ;   Pointer lpszLabels ;   Integer nRecips ;   Pointer lpRecips ;   Integer flFlags ;   Integer ulReserved ;   Pointer lpnNewRecips ;   Pointer lppNewRecips ;   Returns Integer
96808>>>>>>>External_Function MAPIResolveName "MAPIResolveName" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpszName ;   Integer flFlags ;   Integer ulReserved ;   Pointer lppRecip ;   Returns Integer
96809>>>>>>>External_Function MAPISendMail "MAPISendMail" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpMessage ;   Integer flFlags ;   Integer ulReserved ;   Returns Integer
96810>>>>>>>External_Function MAPISaveMail "MAPISaveMail" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpMessage ;   Integer flFlags ;   Integer ulReserved ;   Pointer lpszMessageID ;   Returns Integer
96811>>>>>>>External_Function MAPIDeleteMail "MAPIDeleteMail" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpszMessageID ;   Integer flFlags ;   Integer ulReserved ;   Returns Integer
96812>>>>>>>External_Function MAPISendDocuments "MAPISendDocuments" Mapi32.Dll ;   Integer ulUIParam ;   Pointer lpszDelimChar ;   Pointer lpszFullPaths ;   Pointer lpszFileNames ;   Integer ulReserved ;   Returns Integer
96813>>>>>>>External_Function MAPIDetails "MAPIDetails" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpRecip ;   Integer flFlags ;   Integer ulReserved ;   Returns Integer
96814>>>>>>>
96814>>>>>>>External_Function ShellExecute "ShellExecuteA" Shell32.Dll ;   Handle hwnd ;   String sOperation ;   String sFile ;   String sParameters ;   String sDirectory ;   Integer nShowCmd ;   Returns VOID_TYPE
96815>>>>>Use DFBTRDRV.PKG
96815>>>>>Use MSSqldrv.pkg
96815>>>>>Use db2_drv.pkg
96815>>>>>Use odbc_drv.pkg
96815>>>>>Use seq_chnl.pkg
96815>>>>>//Use Std_help.pkg
96815>>>>>
96815>>>>>Register_Function phoWorkspace Returns Handle
96815>>>>>Register_Function Help_filename Returns String
96815>>>>>Register_Function GetHelpFile Returns String
96815>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
96815>>>>>
96815>>>>>// Use of Mertech drivers:
96815>>>>>// Ad the line "Define DUF_Use_Mertech_Drivers" prior "Use" of this package to your source code if using Mertech drivers!
96815>>>>>
96815>>>>>
96815>>>>>
96815>>>>>
96815>>>>>
96815>>>>>// *** Constant Declarations: ***
96815>>>>>//
96815>>>>>
96815>>>>>// NOTE: These text constants should be added to the various "Language_xxx.inc" files:
96815>>>>>
96815>>>>>
96815>>>>>
96815>>>>>
96815>>>>>
96815>>>>>// 2016-12-12, Samuel:  Added section for Portuguese
96815>>>>>
96815>>>>>
96815>>>>>
96815>>>>>
96815>>>>>
96815>>>>>
96815>>>>>
96815>>>>>
96815>>>>>
96815>>>>>// System icon menu constants. If the upper left hand
96815>>>>>// icon in dialogs is clicked, shadow all menu items except Move & Close.
96815>>>>>    Define SC_RESTORE  for |CI$F120
96815>>>>>    Define SC_MOVE     for |CI$F010
96815>>>>>    Define SC_SIZE     for |CI$F000
96815>>>>>    Define SC_MINIMIZE for |CI$F020
96815>>>>>    Define SC_MAXIMIZE for |CI$F030
96815>>>>>    Define SC_CLOSE    for |CI$F060
96815>>>>>    Define SC_KEYMENU  for |CI$F100
96815>>>>>    Define SC_NEXTWINDOW for |CI$F040
96815>>>>>    Define SC_PREVWINDOW for |CI$F050
96815>>>>>
96815>>>>>// *** Struct Declarations: ***
96815>>>>>//#IF (Required_RT_Version > 18) // Temp! Should be "19". Fix after 19.1 beta phase1
96815>>>>>//#ELSE
96815>>>>>Struct tWinMemoryStatusEx
96815>>>>>    UInteger dwLength
96815>>>>>    UInteger dwMemoryLoad
96815>>>>>    UBigInt ullTotalPhys
96815>>>>>    UBigInt ullAvailPhys
96815>>>>>    UBigInt ullTotalPageFile
96815>>>>>    UBigInt ullAvailPageFile
96815>>>>>    UBigInt ullTotalVirtual
96815>>>>>    UBigInt ullAvailVirtual
96815>>>>>    UBigInt ullAvailExtendedVirtual
96815>>>>>End_Struct
96815>>>>>//#ENDIF
96815>>>>>
96815>>>>>// OBSOLETE STRUCTURE AND WINDOWS API CALL. KEPT FOR BACKWARDS COMPATIBILITY
96815>>>>>//Type MEMORYSTATUS
96815>>>>>//   Field MEMORYSTATUS.dwLength         as DWord // sizeof(MEMORYSTATUS)
96815>>>>>//   Field MEMORYSTATUS.dwMemoryLoad     as DWord // percent Of memory in use
96815>>>>>//   Field MEMORYSTATUS.dwTotalPhys      as DWord // bytes Of physical memory
96815>>>>>//   Field MEMORYSTATUS.dwAvailPhys      as DWord // free physical memory bytes
96815>>>>>//   Field MEMORYSTATUS.dwTotalPageFile  as DWord // bytes Of paging file
96815>>>>>//   Field MEMORYSTATUS.dwAvailPageFile  as DWord // free bytes Of paging file
96815>>>>>//   Field MEMORYSTATUS.dwTotalVirtual   as DWord // user bytes Of address space
96815>>>>>//   Field MEMORYSTATUS.dwAvailVirtual   as DWord // free user bytes
96815>>>>>//End_Type
96815>>>>>
96815>>>>>// *** External Function calls: ***
96815>>>>>//
96815>>>>>    External_Function GetSystemMenu "GetSystemMenu" User32.dll Handle hWnd Boolean bRevert Returns Handle
96816>>>>>
96816>>>>>    External_Function GetRemoveMenu "RemoveMenu" user32.dll Handle hWnd UInteger uPosition UInteger uFlags Returns Handle
96817>>>>>
96817>>>>>    External_Function WNetGetUser "WNetGetUserA" MPR.DLL Pointer lpName Pointer lpUser_Name Pointer lpLength Returns DWord
96818>>>>>
96818>>>>>    External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
96819>>>>>
96819>>>>>    External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
96820>>>>>
96820>>>>>// *** Global/Desktop Function Declarations: ***
96820>>>>>
96820>>>>>Function ComputerName for Desktop Returns String
96822>>>>>    String sName
96822>>>>>    Get_Environment "COMPUTERNAME" to sName
96823>>>>>>
96823>>>>>    Function_Return sName
96824>>>>>End_Function
96825>>>>>
96825>>>>>Function Network_User_Name for cDesktop Returns String
96827>>>>>    String sName
96827>>>>>    Get_Environment "USERNAME" to sName
96828>>>>>>
96828>>>>>    Function_Return sName
96829>>>>>End_Function
96830>>>>>
96830>>>>>// *** Class Declarations: ***
96830>>>>>//
96830>>>>>Class cBitmapContainerVDFLink is a BitmapContainer
96831>>>>>    Procedure Mouse_Click Integer iWindowNumber Integer iPosition
96833>>>>>        Send Mouse_Up iWindowNumber iPosition
96834>>>>>    End_Procedure
96835>>>>>    Procedure Mouse_Up Integer iWindowNumber Integer iPosition
96837>>>>>        Forward Send Mouse_Up iWindowNumber iPosition
96839>>>>>        Send Show_HomePage "http://www.dataaccess.com/"
96840>>>>>    End_Procedure
96841>>>>>End_Class
96842>>>>>
96842>>>>>Class cCopyEditorContentButton is a Button
96843>>>>>    Procedure Construct_Object
96845>>>>>        Forward Send Construct_Object
96847>>>>>        Property Handle phoEditorHandle
96848>>>>>        Set psToolTip to C_$DescCopy
96849>>>>>    End_Procedure
96850>>>>>
96850>>>>>    Procedure CopyToWindowsClipboard
96852>>>>>        String sValue
96852>>>>>        Handle hoEditor
96852>>>>>        Boolean bCanCopy
96852>>>>>        Address aEditorAddress
96852>>>>>
96852>>>>>        Get phoEditorHandle to hoEditor
96853>>>>>        Send Select_All of hoEditor
96854>>>>>        Get CanCopy of hoEditor to bCanCopy
96855>>>>>        If (bCanCopy = True) Begin
96857>>>>>            Get paValue of hoEditor to aEditorAddress
96858>>>>>            Move aEditorAddress to sValue
96859>>>>>            Send Copy   of hoEditor
96860>>>>>            // Remove the selection after text is copied to the clipboard.
96860>>>>>            Send Beginning_of_Data of hoEditor
96861>>>>>            Send Info_Box C_$CopyToClipboard_Text
96862>>>>>        End
96862>>>>>>
96862>>>>>    End_Procedure
96863>>>>>End_Class
96864>>>>>
96864>>>>>Class SysinfoDisplay is a cTextEdit
96865>>>>>    Procedure Construct_Object
96867>>>>>        Forward Send Construct_Object
96869>>>>>
96869>>>>>        Set Size to 104 247
96870>>>>>        Set Location to 4 6
96871>>>>>        Set Border_Style to Border_None
96872>>>>>        Set peAnchors to anAll
96873>>>>>        Set Read_Only_State to True
96874>>>>>        Set pbWrap to True
96875>>>>>    End_Procedure
96876>>>>>
96876>>>>>    // Augmented class message to adjust certain text strings that are wrong...
96876>>>>>
96876>>>>>    Procedure AppendTextLn String sText
96878>>>>>        String sWorkspaceWSFile
96878>>>>>
96878>>>>>        // Only works for English:
96878>>>>>        If (ghoApplication > 0) Begin
96880>>>>>            If (sText contains "Workspace Name") Begin
96882>>>>>                Move "Workspace Config Filename:" to sText
96883>>>>>                Get psWorkspaceWSFile of (phoWorkspace(ghoApplication)) to sWorkspaceWSFile
96884>>>>>                Move (sText * sWorkspaceWSFile) to sText
96885>>>>>            End
96885>>>>>>
96885>>>>>        End
96885>>>>>>
96885>>>>>        Send AppendText sText
96886>>>>>        Send AppendText (character(10))
96887>>>>>    End_Procedure
96888>>>>>
96888>>>>>    //****************************************************************************
96888>>>>>    // $Module type: PROCEDURE
96888>>>>>    // $Module name: Show_Current_Directory
96888>>>>>    // $Author     : VOO
96888>>>>>    // Created     : 06-10-96 @ 15:24
96888>>>>>    //
96888>>>>>    // Description
96888>>>>>    //    This method will show the name Of the current directory in the system
96888>>>>>    //    information box
96888>>>>>    //
96888>>>>>    // $Rev History
96888>>>>>    //    06-10-96  Module header created
96888>>>>>    //****************************************************************************
96888>>>>>    Procedure Show_Current_Directory
96890>>>>>        String sDir
96890>>>>>
96890>>>>>        Get_Current_Directory To sDir
96891>>>>>
96891>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
96892>>>>>    End_Procedure
96893>>>>>
96893>>>>>    Procedure Show_Windows_Directory
96895>>>>>        String sWindir
96895>>>>>
96895>>>>>        Get_Windows_Directory To sWindir
96896>>>>>
96896>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
96897>>>>>    End_Procedure
96898>>>>>
96898>>>>>    Procedure Show_Current_User
96900>>>>>        Send AppendTextLn (SFormat (C_$Computer_Name, ComputerName (Self)))
96901>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
96902>>>>>    End_Procedure
96903>>>>>
96903>>>>>    Procedure Show_Number_Format
96905>>>>>        Integer iFormat
96905>>>>>        String sFormatText
96905>>>>>
96905>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
96908>>>>>        Move (Character (iFormat)) To sFormatText
96909>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
96910>>>>>
96910>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
96913>>>>>        Move (Character (iFormat)) to sFormatText
96914>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
96915>>>>>    End_Procedure
96916>>>>>
96916>>>>>    Procedure Show_Filelist_Name
96918>>>>>        String sFilename
96918>>>>>
96918>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
96921>>>>>
96921>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
96922>>>>>    End_Procedure
96923>>>>>
96923>>>>>    Procedure Show_Lock_Delay
96925>>>>>        Integer iLockdelay
96925>>>>>
96925>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
96928>>>>>
96928>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
96929>>>>>    End_Procedure
96930>>>>>
96930>>>>>    Procedure Show_Lock_Timeout
96932>>>>>        Integer iLockTimeout
96932>>>>>
96932>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
96935>>>>>
96935>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
96936>>>>>    End_Procedure
96937>>>>>
96937>>>>>    Procedure Show_Screen_Size
96939>>>>>        Integer iYscreensize iXscreensize
96939>>>>>
96939>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) To iXscreensize
96940>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) To iYscreensize
96941>>>>>
96941>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
96942>>>>>    End_Procedure
96943>>>>>
96943>>>>>    Procedure Show_Page_Size
96945>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
96946>>>>>    End_procedure
96947>>>>>
96947>>>>>    Procedure Show_Date
96949>>>>>        Date dToday
96949>>>>>
96949>>>>>        Sysdate dToday
96950>>>>>
96950>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
96951>>>>>    End_procedure
96952>>>>>
96952>>>>>    Procedure Show_Date_Format
96954>>>>>        Integer iDateFormat
96954>>>>>        String sDateFormat
96954>>>>>
96954>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
96957>>>>>        Case Begin
96957>>>>>            Case (iDateFormat = DF_DATE_USA)
96959>>>>>                Move C_$USA To sDateFormat
96960>>>>>                Case Break
96961>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
96964>>>>>                Move C_$European To sDateFormat
96965>>>>>                Case Break
96966>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
96969>>>>>                Move C_$Military To sDateFormat
96970>>>>>                Case Break
96971>>>>>            Case Else
96971>>>>>                Move C_$UnknownDateType To sDateFormat
96972>>>>>                Case Break
96973>>>>>        Case End
96973>>>>>
96973>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
96974>>>>>    End_Procedure
96975>>>>>
96975>>>>>    // 2013-08-14 NGS
96975>>>>>    // Unformatted numeric values shown doesn't look good. These looks much better.
96975>>>>>    Procedure Show_Systemresources
96977>>>>>        tWinMemoryStatusEx MemoryStatusInfo
96977>>>>>        tWinMemoryStatusEx MemoryStatusInfo
96977>>>>>        Integer iRetval
96977>>>>>        Number nValue
96977>>>>>        String sValue
96977>>>>>
96977>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
96978>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
96979>>>>>        If (iRetval = 0) Begin
96981>>>>>            Move (ShowLastError ()) to iRetval
96982>>>>>            Procedure_Return
96983>>>>>        End
96983>>>>>>
96983>>>>>
96983>>>>>        Send AppendTextLn ""
96984>>>>>        Move MemoryStatusInfo.ullTotalPhys to nValue
96985>>>>>
96985>>>>>        // Show memory in Gigabytes:
96985>>>>>        Move (nValue/1024/1024/1024) to nValue
96986>>>>>        Move (Round(nValue)) to nValue
96987>>>>>        Get FormatNumber nValue 2 to sValue
96988>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, (sValue * "GB")))
96989>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, String(MemoryStatusInfo.dwMemoryLoad) * "%"))
96990>>>>>
96990>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0))
96990>>>>>        Move (Real(MemoryStatusInfo.ullAvailPhys) / Real(MemoryStatusInfo.ullTotalPhys) * 100.0) to nValue
96991>>>>>        Move (Round(nValue)) to nValue
96992>>>>>        Get FormatNumber nValue 0 to sValue
96993>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, (sValue * "%")))
96994>>>>>
96994>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0))
96994>>>>>        Move (Real(MemoryStatusInfo.ullAvailPageFile) / Real(MemoryStatusInfo.ullTotalPageFile) * 100.0) to nValue
96995>>>>>        Move (Round(nValue)) to nValue
96996>>>>>        Get FormatNumber nValue 0 to sValue
96997>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, (sValue * "%")))
96998>>>>>
96998>>>>>//        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0))
96998>>>>>        Move (Real(MemoryStatusInfo.ullAvailVirtual) / Real(MemoryStatusInfo.ullTotalVirtual) * 100.0) to nValue
96999>>>>>        Move (Round(nValue)) to nValue
97000>>>>>        Get FormatNumber nValue 0 to sValue
97001>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, (sValue * "%")))
97002>>>>>
97002>>>>>        // Add an empty row after the memory information:
97002>>>>>        Send AppendTextLn ""
97003>>>>>    End_Procedure
97004>>>>>
97004>>>>>    Procedure Show_Registration
97006>>>>>        String sRegName
97006>>>>>        Integer iSN iUsersMax iUserCount
97006>>>>>
97006>>>>>        Registration sRegName iSN
97007>>>>>>
97007>>>>>        Get_Licensed_Max_Users to iUsersMax
97008>>>>>        Get_Current_User_Count to iUserCount
97009>>>>>
97009>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
97010>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
97011>>>>>        Send AppendTextLn (SFormat (C_$Current_User_Count, iUserCount))
97012>>>>>        Send AppendTextLn (SFormat (C_$Max_Licensed_User_Count, iUsersMax))
97013>>>>>    End_Procedure
97014>>>>>
97014>>>>>    //****************************************************************************
97014>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
97014>>>>>    // To the workspace object passing the an object and message To send back
97014>>>>>    // To this object. It is expected that the workspace object will send this
97014>>>>>    // message for every line Of information it wants displayed (passing the
97014>>>>>    // information To be displayed
97014>>>>>    //****************************************************************************
97014>>>>>    Register_Procedure EnumerateWorkspaceData Integer hObjId Integer hmMessId
97014>>>>>
97014>>>>>    Procedure Show_ServicePack
97016>>>>>        String sKey sVersion sDataFlex
97016>>>>>        Handle hoRegistry
97016>>>>>        Boolean bExists bOpened
97016>>>>>
97016>>>>>        Move "DataFlex"        to sDataFlex
97017>>>>>
97017>>>>>        Get Create U_cRegistry to hoRegistry
97018>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
97019>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
97020>>>>>        Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
97021>>>>>
97021>>>>>        If (bExists) Begin
97023>>>>>            Move ("SOFTWARE\Wow6432Node\Data Access Worldwide\" + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
97024>>>>>        End
97024>>>>>>
97024>>>>>        Else Begin
97025>>>>>            Move ("SOFTWARE\Data Access Worldwide\"             + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
97026>>>>>        End
97026>>>>>>
97026>>>>>        Get KeyExists of hoRegistry sKey to bExists
97027>>>>>        If (bExists) Begin
97029>>>>>            Get OpenKey of hoRegistry sKey to bOpened
97030>>>>>            If (bOpened) Begin
97032>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
97033>>>>>                If (bExists) Begin
97035>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersion
97036>>>>>                End
97036>>>>>>
97036>>>>>                Send CloseKey of hoRegistry
97037>>>>>            End
97037>>>>>>
97037>>>>>        End
97037>>>>>>
97037>>>>>        Send Destroy of hoRegistry
97038>>>>>
97038>>>>>        If (sVersion <> "") Begin
97040>>>>>           Send AppendTextLn sVersion
97041>>>>>           Send AppendTextLn ""
97042>>>>>        End
97042>>>>>>
97042>>>>>    End_Procedure
97043>>>>>
97043>>>>>    Procedure Show_WorkspaceInformation
97045>>>>>        Integer hoWorkspace
97045>>>>>
97045>>>>>        If (ghoApplication <> 0) Begin
97047>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
97048>>>>>            If (hoWorkspace <> 0) Begin
97050>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self msg_AppendTextLn
97051>>>>>            End
97051>>>>>>
97051>>>>>        End
97051>>>>>>
97051>>>>>    End_Procedure
97052>>>>>
97052>>>>>    //****************************************************************************
97052>>>>>    // If connection ids are used, we will send the message EnumerateConnections
97052>>>>>    // to the connection manager object passing the an object and message to send
97052>>>>>    // back to this object. It is expected that the connection manager object will
97052>>>>>    // send this message for every line Of information it wants displayed (passing
97052>>>>>    // the information To be displayed
97052>>>>>    //****************************************************************************
97052>>>>>    Register_Procedure EnumerateConnections Integer hObjId Integer hmMessId
97052>>>>>
97052>>>>>    Procedure Show_ConnectionIdInformation
97054>>>>>        If (ghoConnection > 0) Begin
97056>>>>>            Send EnumerateConnections of ghoConnection Self (RefProc(AppendTextLn))
97057>>>>>            Send AppendTextLn ""
97058>>>>>        End
97058>>>>>>
97058>>>>>    End_Procedure
97059>>>>>
97059>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
97061>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
97062>>>>>    End_Function
97063>>>>>
97063>>>>>    Procedure Show_Versions
97065>>>>>        Integer iVersion iRevision iBuild
97065>>>>>
97065>>>>>        Version_information iVersion iRevision iBuild
97067>>>>>
97067>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(self,iVersion,iRevision,iBuild) ))
97068>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
97069>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
97070>>>>>    End_Procedure
97071>>>>>
97071>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
97073>>>>>        Boolean bOK
97073>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
97074>>>>>        Function_Return bOK
97075>>>>>    End_Function
97076>>>>>
97076>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
97078>>>>>        Boolean bOK
97078>>>>>        Function_Return bOK
97079>>>>>    End_Function
97080>>>>>
97080>>>>>    //***
97080>>>>>    //*** BW
97080>>>>>    //*** Procedure: Show_Drivers
97080>>>>>    //*** Purpose  : Show loaded database drivers
97080>>>>>    //***
97080>>>>>
97080>>>>>    Procedure Show_Drivers
97082>>>>>        String sDriverID sVersion sClient sValue
97082>>>>>        Integer iNumberOfDrivers iDriver iClient iUsersMax iSerialNo iNumServers iCount
97082>>>>>        Handle hoCLIHandler hoBtrvHandler
97082>>>>>        Boolean bStudioLicense bIsDAWDriver bIsMertechDriver
97082>>>>>
97082>>>>>        Move False to bStudioLicense
97083>>>>>
97083>>>>>        Get Create U_cCLIHandler      to hoCLIHandler
97084>>>>>        Get Create U_cDFBtrDrvHandler to hoBtrvHandler
97085>>>>>
97085>>>>>        // For testing purposes:
97085>>>>>//        Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
97085>>>>>//        Load_Driver MSSQLDRV_ID
97085>>>>>//        Load_Driver ODBC_DRV_ID
97085>>>>>//        Load_Driver DB2_DRV_ID
97085>>>>>//        Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
97085>>>>>//
97085>>>>>//        #IFDEF DUF_Use_Mertech_Drivers
97085>>>>>//            Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
97085>>>>>//            Load_Driver SQLFLEX
97085>>>>>//            Load_Driver MDSPgSQL
97085>>>>>//            Load_Driver MDSMySQL
97085>>>>>//            Load_Driver ORAFLEX
97085>>>>>//            Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
97085>>>>>//        #ENDIF
97085>>>>>        Move False to Err
97086>>>>>
97086>>>>>        // Loop through all loaded drivers.
97086>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
97089>>>>>        If (iNumberOfDrivers > 1) Begin
97091>>>>>            Send AppendTextLn ""
97092>>>>>        End
97092>>>>>>
97092>>>>>        For iDriver from 1 to iNumberOfDrivers
97098>>>>>>
97098>>>>>            // For some weird reason it can happen that - when using Mertech drivers - that the driver index
97098>>>>>            // was increased in the CLI array, but it has no value. In that case a "Bad parameter..." error
97098>>>>>            // would be thrown, so we safeguard from that here.
97098>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
97099>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
97102>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
97103>>>>>            Get IsDAWSQLDriver sDriverID to bIsDAWDriver
97104>>>>>            Get IsMertechDriver sDriverID to bIsMertechDriver
97105>>>>>
97105>>>>>            If (sDriverID = DFBTRDRV_ID or bIsDAWDriver = True or bIsMertechDriver = True) Begin
97107>>>>>
97107>>>>>                // Pervasive/Btrieve database
97107>>>>>                If (sDriverID = DFBTRDRV_ID) Begin
97109>>>>>                    Get CKRevision of hoBtrvHandler to sVersion
97110>>>>>                    Get PSQLLocalEngineVersionInfo of hoBtrvHandler 0 to sClient
97111>>>>>                    If (sClient <> "0.0.0") Begin
97113>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Local_Engine_Version, sClient))
97114>>>>>                    End
97114>>>>>>
97114>>>>>                    Get PSQLServerEngineVersionInfo of hoBtrvHandler 0 to sClient
97115>>>>>                    If (sClient <> "0.0.0") Begin
97117>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Server_Engine_Version, sClient))
97118>>>>>                    End
97118>>>>>>
97118>>>>>                End
97118>>>>>>
97118>>>>>
97118>>>>>                Else Begin
97119>>>>>                    Set psDriverID of hoCLIHandler to sDriverID
97120>>>>>                    Move 0 to iNumServers
97121>>>>>                    If (sDriverID <> DATAFLEX_ID) Begin
97123>>>>>                        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iNumServers
97126>>>>>                    End
97126>>>>>>
97126>>>>>
97126>>>>>                    If (bIsDAWDriver = True) Begin
97128>>>>>                        If (sDriverID = MSSQLDRV_ID) Begin
97130>>>>>                            // This info is only available for the MS SQL driver:
97130>>>>>                            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClient
97133>>>>>                            If (iClient = 13) Begin
97135>>>>>                                Move C_$SQLSERVER2016DRVRSTR              to sClient
97136>>>>>                            End
97136>>>>>>
97136>>>>>                            If (iClient = 12) Begin
97138>>>>>                                Move C_$SQLSERVER2014DRVRSTR              to sClient
97139>>>>>                            End
97139>>>>>>
97139>>>>>                            If (iClient = 11) Begin
97141>>>>>                                Move C_$SQL_Server_Native_Client_11_0     to sClient
97142>>>>>                            End
97142>>>>>>
97142>>>>>                            If (iClient = 10) Begin
97144>>>>>                                Move C_$SQL_Server_Native_Client_10_0     to sClient
97145>>>>>                            End
97145>>>>>>
97145>>>>>                            If (iClient = 9) Begin
97147>>>>>                                Move C_$SQL_Native_Client                 to sClient
97148>>>>>                            End
97148>>>>>>
97148>>>>>                            If (iClient = 8) Begin
97150>>>>>                                Move C_$SQL_Server_SQL_Server_2000_client to sClient
97151>>>>>                            End
97151>>>>>>
97151>>>>>                            If (sClient <> "") Begin
97153>>>>>                                Move ("    " + sClient) to sClient
97154>>>>>                            End
97154>>>>>>
97154>>>>>                        End
97154>>>>>>
97154>>>>>
97154>>>>>                        Get CKRevision of hoCLIHandler to sVersion
97155>>>>>                    End
97155>>>>>>
97155>>>>>
97155>>>>>                    If (bIsMertechDriver = True) Begin
97157>>>>>                    End
97157>>>>>>
97157>>>>>
97157>>>>>                    // If the serialnumber is = 0, it means that the
97157>>>>>                    // Studio licens is in use and there is no
97157>>>>>                    // number of max users defined because the driver is
97157>>>>>                    // relying on the info from the VDF license.
97157>>>>>                    If (bStudioLicense = False) Begin
97159>>>>>                        Get SerialNumber of hoCLIHandler to iSerialNo
97160>>>>>                        Move (iSerialNo = 0) to bStudioLicense
97161>>>>>                    End
97161>>>>>>
97161>>>>>                End
97161>>>>>>
97161>>>>>                Send AppendTextLn (SFormat (C_$DatabaseDriver, (sDriverID * "-" * (C_$Version + ": " + sVersion))))
97162>>>>>                If (iNumServers <> 0) Begin
97164>>>>>                    For iCount from 1 to iNumServers
97170>>>>>>
97170>>>>>                        Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
97173>>>>>                        Send AppendTextLn ("    " + "Server/DSN:" * sValue)
97174>>>>>                    Loop
97175>>>>>>
97175>>>>>                End
97175>>>>>>
97175>>>>>                If (sClient <> "" and sDriverID = MSSQLDRV_ID) Begin
97177>>>>>                    Send AppendTextLn sClient
97178>>>>>                End
97178>>>>>>
97178>>>>>            End
97178>>>>>>
97178>>>>>        Loop
97179>>>>>>
97179>>>>>
97179>>>>>        Send AppendTextLn ""
97180>>>>>        If (bStudioLicense = False) Begin
97182>>>>>            Get MaxUsers of hoCLIHandler to iUsersMax
97183>>>>>            Send AppendTextLn (SFormat (C_$Max_DbDriver_Licensed_User_Count, iUsersMax))
97184>>>>>        End
97184>>>>>>
97184>>>>>        Else Begin
97185>>>>>            Send AppendTextLn C_$VDF_Studio_License_Text
97186>>>>>        End
97186>>>>>>
97186>>>>>        Send Destroy of hoCLIHandler
97187>>>>>        Send Destroy of hoBtrvHandler
97188>>>>>    End_Procedure
97189>>>>>
97189>>>>>    Procedure Show_HelpFile
97191>>>>>        String sHelpFile
97191>>>>>        Integer eHelpType
97191>>>>>
97191>>>>>        If (ghoApplication <> 0) Begin
97193>>>>>            Get peHelpType Of ghoApplication To eHelpType
97194>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
97196>>>>>                Get GetHelpFile Of ghoHtmlHelp To sHelpFile
97197>>>>>            End
97197>>>>>>
97197>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
97200>>>>>                Get Help_filename Of Help_object_id To sHelpFile
97201>>>>>            End
97201>>>>>>
97201>>>>>            Else Begin
97202>>>>>                Move C_$ThereIsNoHelpfileDefined To sHelpFile
97203>>>>>            End
97203>>>>>>
97203>>>>>
97203>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
97204>>>>>        End
97204>>>>>>
97204>>>>>    End_Procedure
97205>>>>>
97205>>>>>    Procedure Show_EnterAsTab
97207>>>>>        Boolean bEnterKeyAsTabKey
97207>>>>>        String sText
97207>>>>>
97207>>>>>        If (ghoApplication <> 0) Begin
97209>>>>>            Get pbEnterKeyAsTabKey Of ghoApplication To bEnterKeyAsTabKey
97210>>>>>            If (bEnterKeyAsTabKey) Begin
97212>>>>>                Move "True" To sText
97213>>>>>            End
97213>>>>>>
97213>>>>>            Else Begin
97214>>>>>                Move "False" To sText
97215>>>>>            End
97215>>>>>>
97215>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
97216>>>>>        End
97216>>>>>>
97216>>>>>    End_Procedure
97217>>>>>
97217>>>>>    //****************************************************************************
97217>>>>>    // $Module type: PROCEDURE
97217>>>>>    // $Module name: Add_Focus
97217>>>>>    // $Author     : VOO
97217>>>>>    // Created     : 24-09-96 @ 19:43
97217>>>>>    //
97217>>>>>    // Description
97217>>>>>    //    During activation we will remove the old information and add the newly
97217>>>>>    //    found systeminformation
97217>>>>>    //
97217>>>>>    // $Rev History
97217>>>>>    //    24-09-96  Module header created
97217>>>>>    //****************************************************************************
97217>>>>>    Procedure Add_Focus Integer hoRoot
97219>>>>>        Forward Send Add_Focus hoRoot
97221>>>>>
97221>>>>>        Send Delete_Data
97222>>>>>
97222>>>>>        Set Changed_State To False
97223>>>>>        Set Read_Only_State To True
97224>>>>>
97224>>>>>        Send Show_Registration
97225>>>>>        Send Show_Drivers
97226>>>>>        Send AppendTextLn ""
97227>>>>>
97227>>>>>        Send Show_ServicePack
97228>>>>>        If (ghoApplication <> 0) Begin
97230>>>>>            Send Show_WorkSpaceInformation
97231>>>>>            Send Show_HelpFile
97232>>>>>            Send AppendTextLn ""
97233>>>>>        End
97233>>>>>>
97233>>>>>        Else Begin
97234>>>>>            Send AppendTextLn ""
97235>>>>>        End
97235>>>>>>
97235>>>>>
97235>>>>>        If (ghoConnection <> 0) Begin
97237>>>>>            Send Show_ConnectionIdInformation
97238>>>>>        End
97238>>>>>>
97238>>>>>
97238>>>>>        Send Show_Current_User
97239>>>>>        Send Show_Windows_Directory
97240>>>>>        Send Show_Current_Directory
97241>>>>>
97241>>>>>        // This is already shown in the workspace details,
97241>>>>>        // unless no workspace object is present:
97241>>>>>        If (ghoApplication = 0) Begin
97243>>>>>            Send Show_Filelist_Name
97244>>>>>        End
97244>>>>>>
97244>>>>>
97244>>>>>        If (ghoApplication <> 0) Begin
97246>>>>>            Send AppendTextLn ""
97247>>>>>            Send Show_EnterAsTab
97248>>>>>        End
97248>>>>>>
97248>>>>>
97248>>>>>        Send Show_Versions
97249>>>>>        Send Show_Screen_Size
97250>>>>>        Send Show_Page_Size
97251>>>>>        Send Show_Number_Format
97252>>>>>        Send Show_Date_Format
97253>>>>>        Send Show_Lock_Delay
97254>>>>>        Send Show_Lock_Timeout
97255>>>>>        Send Show_Date
97256>>>>>        Send Show_Systemresources
97257>>>>>        Send Beginning_of_Data
97258>>>>>
97258>>>>>        Set Icon to 'default.ico'
97259>>>>>    End_Procedure
97260>>>>>End_Class
97261>>>>>
97261>>>>>//****************************************************************************
97261>>>>>// $Module type: OBJECT
97261>>>>>// $Module name: Sysinfo_Dialog
97261>>>>>// $Author     : VOO
97261>>>>>// Created     : 24-09-96 @ 18:47
97261>>>>>//
97261>>>>>// Description
97261>>>>>//    This object shows the systeminformation on the screen
97261>>>>>//
97261>>>>>// $Rev History
97261>>>>>//    24-09-96  Module header created
97261>>>>>//****************************************************************************
97261>>>>>Class SysInfoDialog is a ModalPanel
97262>>>>>    Procedure Construct_Object
97264>>>>>        Forward Send Construct_Object
97266>>>>>
97266>>>>>        Set Label to C_$SystemInformation
97267>>>>>        Set Size to 140 267
97268>>>>>        Set Locate_Mode to CENTER_ON_PARENT
97269>>>>>        Set Border_Style to Border_Thick
97270>>>>>        Set Sysmenu_Icon to False
97271>>>>>
97271>>>>>        // "+1" will make the panel to paint correctly.
97271>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)) +1)
97272>>>>>
97272>>>>>        // 2014-09-14 NGS
97272>>>>>        // Added a container object around the cTexteditor
97272>>>>>        // object to get a border around the text.
97272>>>>>        Object oSysinfoDisplayContainer is a Container3d
97274>>>>>            Set Location to 2 4
97275>>>>>            Set Size to 110 255
97276>>>>>            Set Border_Style to Border_ClientEdge
97277>>>>>            Set Color to clWhite
97278>>>>>            Set peAnchors to anAll
97279>>>>>
97279>>>>>            Object oSysinfoDisplay is a SysInfoDisplay
97281>>>>>            End_Object
97282>>>>>
97282>>>>>        End_Object
97283>>>>>
97283>>>>>        Object oCloseButton is a Button
97285>>>>>            Set Label to C_$Close
97286>>>>>            Set Location to 120 210
97287>>>>>            Set Message item 0 to msg_Close_Panel
97288>>>>>            Set Default_State To True
97289>>>>>            // In case someone likes to make the AboutDialog's Border_Style to thick,
97289>>>>>            // and changes its peAnchors, we might as well prepare this object
97289>>>>>            // for that situation.
97289>>>>>            Set peAnchors to anBottomRight
97290>>>>>        End_Object
97291>>>>>
97291>>>>>        Object oCopyButton is a cCopyEditorContentButton
97293>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
97294>>>>>            Set Size to 14 50
97295>>>>>            Set Location to 120 158
97296>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
97296>>>>>            // we might as well prepare the object for it.
97296>>>>>            Set peAnchors to anBottomRight
97297>>>>>            Set phoEditorHandle to (oSysinfoDisplay(Self))
97298>>>>>        End_Object
97299>>>>>
97299>>>>>        On_Key kCancel Send Close_Panel
97300>>>>>    End_Procedure
97301>>>>>
97301>>>>>    Procedure Page Integer iPageObject
97303>>>>>        Handle hMenu
97303>>>>>        Integer iPrevState
97303>>>>>
97303>>>>>        Forward Send Page iPageObject
97305>>>>>
97305>>>>>        // Ok, this seems to have been fixed in VDF 17.1!
97305>>>>>        //
97305>>>>>    End_Procedure
97306>>>>>
97306>>>>>End_Class
97307>>>>>
97307>>>>>Class cAboutEdit is an cRichEdit
97308>>>>>    Procedure Construct_Object
97310>>>>>        Forward Send Construct_Object
97312>>>>>
97312>>>>>        Set Size to 57 153
97313>>>>>        Set Location to 8 60
97314>>>>>
97314>>>>>        Set Read_Only_State to True
97315>>>>>        Set Skip_State to True
97316>>>>>        // Font size is calculated in "Twips", which are 1/1440 of an inch,
97316>>>>>        // or 1/20 of a printer's point.
97316>>>>>//        Set piFontSize    to (9 * 20)
97316>>>>>        Set piRightMargin to (0.1 * 1440)
97317>>>>>        Set Border_Style  to Border_None
97318>>>>>    End_Procedure
97319>>>>>
97319>>>>>    // Adds a line of text to the edit object
97319>>>>>    Procedure Add_Line String sVal
97321>>>>>        String sText
97321>>>>>        Address aAddress
97321>>>>>        Get paValue to aAddress
97322>>>>>        Move aAddress to sText
97323>>>>>        Move (sText + String(sVal)) to sVal
97324>>>>>        Move (AddressOf(sVal)) to aAddress
97325>>>>>        Set paValue to aAddress
97326>>>>>    End_Procedure
97327>>>>>
97327>>>>>    // Compared to Add_Line above, this adds an extra empty line after the passed value.
97327>>>>>    // Note that we use the paValue interface,
97327>>>>>    // because the object isn't paged yet when we add the
97327>>>>>    // values and the COM edit object needs to be paged
97327>>>>>    // for the "Set Value" interface to be used.
97327>>>>>    Procedure Add_LineLn String sVal
97329>>>>>        String sText
97329>>>>>        Address aAddress
97329>>>>>        Get paValue to aAddress
97330>>>>>        Move aAddress to sText
97331>>>>>        Move (sText + String(sVal) + Character(10) + Character(13)) to sVal
97332>>>>>        Move (AddressOf(sVal)) to aAddress
97333>>>>>        Set paValue to aAddress
97334>>>>>    End_Procedure
97335>>>>>
97335>>>>>    Procedure OnLinkClicked Integer iPositionStart Integer iPositionEnd
97337>>>>>        String sLinkText
97337>>>>>        Get TextRange iPositionStart iPositionEnd to sLinkText
97338>>>>>        Send Show_HomePage sLinkText
97339>>>>>    End_Procedure
97340>>>>>
97340>>>>>End_Class
97341>>>>>
97341>>>>>// Purpose:
97341>>>>>//
97341>>>>>// Ken Ross 12/17/96 5:16PM
97341>>>>>//
97341>>>>>Class AboutDialog is a ModalPanel
97342>>>>>    Procedure Construct_Object
97344>>>>>
97344>>>>>        Forward Send Construct_Object
97346>>>>>
97346>>>>>        Set Label to C_$About
97347>>>>>        Set Size to 96 230
97348>>>>>        Set Locate_Mode To CENTER_ON_PARENT
97349>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
97350>>>>>//        Set Sysmenu_Icon to True
97350>>>>>
97350>>>>>        Object oSysInfoDialog is a SysInfoDialog
97352>>>>>        End_Object
97353>>>>>
97353>>>>>        Object oBox is a Container3d
97355>>>>>            Set Border_Style to Border_Normal
97356>>>>>            Set Size to 70 220
97357>>>>>            Set Location to 4 5
97358>>>>>            Set Color to clWhite
97359>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
97359>>>>>            // we might as well prepare the object for it.
97359>>>>>            Set peAnchors to anAll
97360>>>>>
97360>>>>>            Object oAboutGraphic is a BitmapContainer
97362>>>>>                Set Border_Style To Border_None
97363>>>>>                Set Bitmap_Style to Bitmap_Center
97364>>>>>                Set Color to clWhite
97365>>>>>                Set Size to 45 50
97366>>>>>                Set Location to 0 3
97367>>>>>            End_Object
97368>>>>>
97368>>>>>            Object oPoweredByVDFGraphic is a cBitmapContainerVDFLink
97370>>>>>                Set Border_Style to Border_None
97371>>>>>                Set Bitmap_Style to Bitmap_Center
97372>>>>>                Set Color to clWhite
97373>>>>>                Set Size to 30 55 //28 50
97374>>>>>                Set Location to 44 3
97375>>>>>            End_Object
97376>>>>>
97376>>>>>            Object oInfoList_Editor is an cAboutEdit
97378>>>>>                // In case someone wants to set the AboutDialog's Border_Style to thick,
97378>>>>>                // we might as well prepare the object for it.
97378>>>>>                Set peAnchors to anAll
97379>>>>>            End_Object
97380>>>>>
97380>>>>>            // These objects are here for backwards compatability only.
97380>>>>>            // They are not used.
97380>>>>>            Object oProductName is a TextBox
97382>>>>>                Set Label To C_$ProductName
97383>>>>>                Set Size To 10 45
97384>>>>>                Set Location To 8 53
97385>>>>>                Set Visible_State to False
97386>>>>>                Set Focus_Mode to NonFocusable
97387>>>>>            End_Object
97388>>>>>
97388>>>>>            Object oVersion is a TextBox
97390>>>>>                Set Label To C_$Version
97391>>>>>                Set Size To 10 25
97392>>>>>                Set Location To 21 53
97393>>>>>                Set Visible_State to False
97394>>>>>                Set Focus_Mode to NonFocusable
97395>>>>>            End_Object
97396>>>>>
97396>>>>>            Object oCopyright is a TextBox
97398>>>>>                Set Label To C_$Copyright
97399>>>>>                Set Size To 10 31
97400>>>>>                Set Location To 34 53
97401>>>>>                Set Visible_State to False
97402>>>>>                Set Focus_Mode to NonFocusable
97403>>>>>            End_Object
97404>>>>>
97404>>>>>            Object oAuthor is a TextBox
97406>>>>>                Set Label To C_$Author
97407>>>>>                Set Size To 10 22
97408>>>>>                Set Location To 46 53
97409>>>>>                Set Visible_State to False
97410>>>>>                Set Focus_Mode to NonFocusable
97411>>>>>            End_Object
97412>>>>>
97412>>>>>        End_Object
97413>>>>>
97413>>>>>        Object oOKButton Is A Button
97415>>>>>            On_Item C_$Close Send Close_Panel
97416>>>>>            Set Location to 78 176
97417>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
97417>>>>>            // we might as well prepare the object for it.
97417>>>>>            Set peAnchors to anBottomRight
97418>>>>>        End_Object
97419>>>>>
97419>>>>>        Object oSysInfoButton Is A Button
97421>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
97422>>>>>            Set Location to 78 123
97423>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
97423>>>>>            // we might as well prepare the object for it.
97423>>>>>            Set peAnchors to anBottomRight
97424>>>>>        End_Object
97425>>>>>
97425>>>>>        Object oCopyButton is a cCopyEditorContentButton
97427>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
97428>>>>>            Set Size to 14 50
97429>>>>>            Set Location to 78 70
97430>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
97430>>>>>            // we might as well prepare the object for it.
97430>>>>>            Set peAnchors to anBottomRight
97431>>>>>            Set phoEditorHandle to (oInfoList_Editor(Self))
97432>>>>>        End_Object
97433>>>>>
97433>>>>>        On_Key Kcancel Send KeyAction of oOKButton
97434>>>>>        Set Logo    to "DacAbout.bmp"  // Square bitmaps of 80x80 work best
97435>>>>>//        Set LogoVDF to "PoweredByDataFlex.bmp"
97435>>>>>        Set LogoVDF to "PoweredByOrange.bmp"
97436>>>>>    End_Procedure
97437>>>>>
97437>>>>>    Procedure Page Integer iPageObject
97439>>>>>        Handle hMenu
97439>>>>>        Integer iPrevState
97439>>>>>
97439>>>>>        Forward Send Page iPageObject
97441>>>>>        // Due to a bug in the ModalPanel class, we need to set the icon here:
97441>>>>>//        Set Icon to "ActionAbout.ico"
97441>>>>>
97441>>>>>        // Shadow upper left corner menu items: (icon menu items)
97441>>>>>        Move (GetSystemMenu(Window_Handle(Self), False)) to hMenu
97442>>>>>        Move (EnableMenuItem(hMenu, SC_RESTORE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
97443>>>>>        // The "Move" menu command may come in handy to have.
97443>>>>>        // Move (EnableMenuItem(hMenu, SC_MOVE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
97443>>>>>        Move (EnableMenuItem(hMenu, SC_SIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
97444>>>>>        Move (EnableMenuItem(hMenu, SC_MINIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
97445>>>>>        Move (EnableMenuItem(hMenu, SC_MAXIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
97446>>>>>        // The "Close" menu command may be good to have.
97446>>>>>        // Move (EnableMenuItem(hMenu, SC_CLOSE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
97446>>>>>    End_Procedure
97447>>>>>
97447>>>>>    Procedure Set ProductName String sText
97449>>>>>        Set Value of oProductName to sText
97450>>>>>    End_Procedure
97451>>>>>
97451>>>>>    Procedure Set Copyright String sText
97453>>>>>        Set Value of oCopyright to sText
97454>>>>>    End_Procedure
97455>>>>>
97455>>>>>    Procedure Set Author String sText
97457>>>>>        Set Value of oAuthor to sText
97458>>>>>    End_Procedure
97459>>>>>
97459>>>>>    Procedure Set Version String sVersion
97461>>>>>        Handle hoVersionInfo
97461>>>>>        Boolean bIncluded
97461>>>>>        Integer iMajor iMinor iRelease iBuild
97461>>>>>        Date dCompileDate
97461>>>>>
97461>>>>>        If (sVersion = "") Begin
97463>>>>>            // This automatically shows the program version of the program, if available.
97463>>>>>            // It will be displayed as the second item in the edit object.
97463>>>>>            If (ghoApplication <> 0) Begin
97465>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
97466>>>>>                If (hoVersionInfo <> 0) Begin
97468>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
97469>>>>>                    If (bIncluded) Begin
97471>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
97472>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
97473>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
97474>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
97475>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sVersion
97476>>>>>                    End
97476>>>>>>
97476>>>>>                End
97476>>>>>>
97476>>>>>            End
97476>>>>>>
97476>>>>>        End
97476>>>>>>
97476>>>>>
97476>>>>>        // Display the compiled date as the next row in the edit object, after the program version.
97476>>>>>        Get GetCompileDate to dCompileDate
97477>>>>>        If (sVersion <> "") Begin
97479>>>>>            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(dCompileDate))
97480>>>>>        End
97480>>>>>>
97480>>>>>    End_Procedure
97481>>>>>
97481>>>>>    Function GetCompileDate Returns Date
97483>>>>>        Date dCompileDate
97483>>>>>        String sAppFilename sData sCompileDate
97483>>>>>        Integer iChannel iPos iDateFormat
97483>>>>>
97483>>>>>        // Get full path to the current running executable
97483>>>>>        Get GetApplicationFileName of ghoApplication to sAppFilename
97484>>>>>
97484>>>>>        //Read the current file  up to where the data we're interesting in is (this was hand calced and so could vary)
97484>>>>>        Get Seq_Open_Input_Channel ("binary:" * sAppFilename) to iChannel
97485>>>>>        Read_Block channel iChannel sData (8 * 1024)    // First 8K is .exe header skip it
97487>>>>>        Read_Block channel iChannel sData 75            // The compile information we're interested in
97489>>>>>        Send Seq_Close_Channel iChannel
97490>>>>>
97490>>>>>        // The data is padded with Character(0)s. Strip them out
97490>>>>>        Move (CString(sData)) to sData
97491>>>>>
97491>>>>>        // The compile date is after the first ", ", so string parsing is required
97491>>>>>        Move (Pos(", ", sData)) to iPos
97492>>>>>        Move (Mid(sData, 10, (iPos + 2) ))  to sCompileDate // In US format
97493>>>>>        // If the current date format is non US, we need to temporary
97493>>>>>        // change the format and then move the string to the date variable.
97493>>>>>        Get_Attribute DF_DATE_FORMAT        to iDateFormat
97496>>>>>        Set_Attribute DF_DATE_FORMAT        to DF_DATE_USA
97499>>>>>        Move (Date(sCompileDate))           to dCompileDate
97500>>>>>        Set_Attribute DF_DATE_FORMAT        to iDateFormat // Reset date format
97503>>>>>
97503>>>>>        Function_Return dCompileDate
97504>>>>>    End_Function
97505>>>>>
97505>>>>>    Procedure Add_LineLn String sValue
97507>>>>>        Send Add_LineLn of oInfoList_Editor sValue
97508>>>>>    End_Procedure
97509>>>>>
97509>>>>>    Procedure Add_Line String sValue
97511>>>>>        Send Add_Line of oInfoList_Editor sValue
97512>>>>>    End_Procedure
97513>>>>>
97513>>>>>    Procedure Set Logo string sLogo
97515>>>>>        // Square bitmaps of 80x80 work best
97515>>>>>        Set Bitmap of oAboutGraphic to sLogo
97516>>>>>    End_Procedure
97517>>>>>
97517>>>>>    Procedure Set LogoVDF String sLogo
97519>>>>>        Set Bitmap of oPoweredByVDFGraphic to sLogo
97520>>>>>    End_Procedure
97521>>>>>
97521>>>>>    Procedure Show_Sysinfo
97523>>>>>        Send Popup_Modal of oSysinfoDialog
97524>>>>>    End_Procedure
97525>>>>>
97525>>>>>    Procedure Show_HomePage String sWebpage
97527>>>>>        Handle hWnd hInstance
97527>>>>>        Get Window_Handle to hWnd
97528>>>>>        Move (ShellExecute(hWnd, "open", (Trim(sWebpage)), "", "", 1)) to hInstance
97529>>>>>    End_Procedure
97530>>>>>
97530>>>>>//    Procedure End_Construct_Object
97530>>>>>//        Handle hoVersionInfo
97530>>>>>//        Boolean bIncluded
97530>>>>>//        Integer iMajor iMinor iRelease iBuild
97530>>>>>//        String sLabel sVersion
97530>>>>>//
97530>>>>>//        If (sVersion = "") Begin
97530>>>>>//            // This automatically shows the program version of the program, if available.
97530>>>>>//            // It will be displayed as the last item in the edit object.
97530>>>>>//            If (ghoApplication <> 0) Begin
97530>>>>>//                Get phoVersionInfo of ghoApplication to hoVersionInfo
97530>>>>>//                If (hoVersionInfo <> 0) Begin
97530>>>>>//                    Get pbIncluded of hoVersionInfo to bIncluded
97530>>>>>//                    If (bIncluded) Begin
97530>>>>>//                        Get piVersionMajor of hoVersionInfo to iMajor
97530>>>>>//                        Get piVersionMinor of hoVersionInfo to iMinor
97530>>>>>//                        Get piVersionRelease of hoVersionInfo to iRelease
97530>>>>>//                        Get piVersionBuild of hoVersionInfo to iBuild
97530>>>>>//                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sLabel
97530>>>>>//                        Set Version to sLabel
97530>>>>>//                    End
97530>>>>>//                End
97530>>>>>//            End
97530>>>>>//        End
97530>>>>>//
97530>>>>>//        Forward Send End_Construct_Object
97530>>>>>//    End_Procedure
97530>>>>>
97530>>>>>End_Class
97531>>>
97531>>>// *************************************************************************
97531>>>//  Public message. This is the default message. It is expected that you will
97531>>>//   create your own message to override this
97531>>>// *************************************************************************
97531>>>
97531>>>Procedure Activate_About
97534>>>   Send DoAbout "" "" "" "" ""
97535>>>End_Procedure
97536>>>
97536>>>// *************************************************************************
97536>>>//  Public message. It is expected that you will send this message (most
97536>>>//  likely from Activate_About. This creates an about object, activates it
97536>>>//  and destroys it when done. It is not exepected that you will augment this.
97536>>>// *************************************************************************
97536>>>// Sample usage:
97536>>>//   The first two params will automatically be filled from the application settings if not provided.
97536>>>//   Send DoAbout "" "" ("Copyright: 2013" * psCompany(ghoApplication)) "Created by: Your Name" "YourAppBitmap.bmp" "Internet: http://www.YourWebAddress.com" "E-mail: mailto:support@YourEmailAddress.com" "Some other description of choice" "9th param" "and last param"
97536>>>
97536>>>Procedure DoAbout String sTitle String sVersion String sCopyRight String sAuthor String sBitmap ;                  String sParam6 String sParam7 String sParam8 String sParam9 String sParam10
97539>>>        Integer hoObj hoMain iArgs
97539>>>        String sValue
97539>>>
97539>>>        // Create object
97539>>>        Object About is an AboutDialog
97541>>>            // Uncomment these two lines if you would like to have a resizable About object.
97541>>>//            Set Border_Style to Border_Thick
97541>>>//            Set peAnchors to anAll
97541>>>
97541>>>            // Add checking for the number of arguments passed to avoid runtime errors
97541>>>            // if one of them is not passed. This makes the interface
97541>>>            // more flexible.
97541>>>            Move num_arguments to iArgs
97542>>>
97542>>>            // If no title is passed use the label of the main panel (if a main panel exists).
97542>>>            If (iArgs > 0 and sTitle = "") Begin
97544>>>                Get Main_Window of Desktop to hoMain
97545>>>                If hoMain Begin
97547>>>                    Get Label of hoMain to sValue
97548>>>                End
97548>>>>
97548>>>            End
97548>>>>
97548>>>            Else If (iArgs > 0 and sTitle <> "") Begin
97551>>>                Move sTitle to sValue
97552>>>            End
97552>>>>
97552>>>            Else If (iArgs = 0) Begin
97555>>>                Get Main_Window of Desktop to hoMain
97556>>>                If hoMain Begin
97558>>>                    Get Label of hoMain to sValue
97559>>>                End
97559>>>>
97559>>>            End
97559>>>>
97559>>>
97559>>>            If (sValue <> "") Begin
97561>>>                Send Add_LineLn sValue
97562>>>            End
97562>>>>
97562>>>            Move "" to sValue
97563>>>
97563>>>            // If the passed sVersion value is blank, the info will be retrieved from the cApplication object.
97563>>>            // For this to work the Project Properties Version must have been set in the Studio.
97563>>>            If (iArgs < 2) Begin
97565>>>                Move "" to sValue
97566>>>            End
97566>>>>
97566>>>            Else Begin
97567>>>                Move sVersion to sValue
97568>>>            End
97568>>>>
97568>>>            Set Version to sValue
97569>>>
97569>>>            If (iArgs > 2 and sCopyRight <> "") Begin
97571>>>                Send Add_LineLn sCopyRight
97572>>>            End
97572>>>>
97572>>>
97572>>>            // If only the five "standard" params were passed we don't add an extra linefeed;
97572>>>            // else we do.
97572>>>            If (iArgs > 3 and iArgs < 6 and sAuthor <> "") Begin
97574>>>                Send Add_Line sAuthor
97575>>>            End
97575>>>>
97575>>>            Else If (iArgs > 5 and sAuthor <> "") Begin
97578>>>                Send Add_LineLn sAuthor
97579>>>            End
97579>>>>
97579>>>
97579>>>            // Square bitmaps of 80x80 works best
97579>>>            If (iArgs > 4 and sBitmap <> "") Begin
97581>>>               Set Logo to sBitMap
97582>>>            End
97582>>>>
97582>>>
97582>>>            // Here starts handling of the five optional params:
97582>>>            If (iArgs = 6 and sParam6  <> "") Begin
97584>>>                Send Add_Line sParam6
97585>>>            End
97585>>>>
97585>>>            Else If (iArgs > 6 and sParam6  <> "") Begin
97588>>>                Send Add_LineLn sParam6
97589>>>            End
97589>>>>
97589>>>
97589>>>            If (iArgs = 7 and sParam7  <> "") Begin
97591>>>                Send Add_Line sParam7
97592>>>            End
97592>>>>
97592>>>            Else If (iArgs > 7 and sParam7  <> "") Begin
97595>>>                Send Add_LineLn sParam7
97596>>>            End
97596>>>>
97596>>>
97596>>>            If (iArgs = 8 and sParam8  <> "") Begin
97598>>>                Send Add_Line sParam8
97599>>>            End
97599>>>>
97599>>>            Else If (iArgs > 8 and sParam8  <> "") Begin
97602>>>                Send Add_LineLn sParam8
97603>>>            End
97603>>>>
97603>>>
97603>>>            If (iArgs = 9 and sParam9  <> "") Begin
97605>>>                Send Add_Line sParam9
97606>>>            End
97606>>>>
97606>>>            Else If (iArgs > 9 and sParam9  <> "") Begin
97609>>>                Send Add_LineLn sParam9
97610>>>            End
97610>>>>
97610>>>
97610>>>            If (iArgs = 10 and sParam10 <> "") Begin
97612>>>                Send Add_Line sParam10
97613>>>            End
97613>>>>
97613>>>
97613>>>            Move Self to hoObj
97614>>>        End_Object
97615>>>
97615>>>        Send Popup   of hoObj // Popup the about object
97616>>>        Send Destroy of hoObj // When done, it will be destroyed
97617>>>End_Procedure
97618>    Procedure Activate_About
97621>        Send DoAbout "" "" ("Copyright 2016-2018" * psCompany(ghoApplication)) "Author: Nils Svedmyr" "DbUpdate.bmp" "E-mail: mailto:support@rdctools.com" "Web-site: www.rdctools.com"
97622>    End_Procedure
97623>
97623>    Object oAbout_btn is a Button
97625>        Set Location to 179 27
97626>        Set Label to "About"
97627>        Set peAnchors to anNone
97628>
97628>        Procedure OnClick
97631>            Send Activate_About
97632>        End_Procedure
97633>
97633>    End_Object
97634>
97634>    Procedure ShowProgramHelp
97637>        Send DoDisplayKeyword of ghoHtmlHelp "CreateDbVersionTable Tool"
97638>    End_Procedure
97639>
97639>    On_Key Key_F1 Send ShowProgramHelp
97640>End_Object
97641>
97641>Send Activate of oCreateDbVersionTable_pnl
97642>Start_UI
97643>
Including Resources...
Summary
Memory Available: 2147483646
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 52872
Total Resources: 4
Total Commands : 97642
Total Windows  : 1
Total Pages    : 1
Static Data    : 734439
Message area   : 618162
Total Blocks   : 34952
