Compiling Program: C:\Projects\DF18\DbUpdateFramework\AppSrc\DUFTestProgram.src
Memory Available: 2147483646
1>//  TestProject for Windows application
1>Use DFAllEnt.pkg
Using pre-compiled package DFALLENT.PKG
Including file: dfallent.pkd    (C:\Program Files (x86)\DataFlex 19.0\Pkg\dfallent.pkd)
79228>Use cCJStandardCommandBarSystem.pkg
Including file: cCJStandardCommandBarSystem.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJStandardCommandBarSystem.pkg)
79228>>>// these are all the packages used in a standard MDI menubar/toolbar system
79228>>>
79228>>>Use cCJCommandBarSystem.pkg
79228>>>Use cCJStandardMenuItemClasses.pkg
Including file: cCJStandardMenuItemClasses.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJStandardMenuItemClasses.pkg)
79228>>>>>Use Dfpanel.pkg
79228>>>>>Use cCJCommandBarSystem.pkg
79228>>>>>Use LanguageText.pkg
79228>>>>>
79228>>>>>
79228>>>>>Class cCJUndoMenuItem is a cCJMenuItem
79229>>>>>    
79229>>>>>    Procedure Construct_Object
79231>>>>>        Forward Send Construct_Object
79233>>>>>        Set psCaption   to C_$CaptionUndo
79234>>>>>        Set psToolTip to C_$ToolTipUndo
79235>>>>>        Set psDescription to C_$DescUndo
79236>>>>>        Set psImage to "ActionUndo.ico"
79237>>>>>        Set pbActiveUpdate to True
79238>>>>>        Set psCategory to C_$CategoryEdit
79239>>>>>        Set psShortcut to C_$Key_Ctrl_Z
79240>>>>>    End_Procedure
79241>>>>>
79241>>>>>    Procedure OnExecute Variant vCommandBarControl
79243>>>>>        Send Undo of (focus(Self))
79244>>>>>    End_Procedure
79245>>>>>    
79245>>>>>    Function IsEnabled Returns Boolean
79247>>>>>        Boolean bEnabled
79247>>>>>        Get CanUndo of (Focus(Self)) to bEnabled
79248>>>>>        Function_Return bEnabled
79249>>>>>    End_Function
79250>>>>>         
79250>>>>>End_Class
79251>>>>>
79251>>>>>
79251>>>>>Class cCJDeleteEditMenuItem is a cCJMenuItem
79252>>>>>    
79252>>>>>    Procedure Construct_Object
79254>>>>>        Forward Send Construct_Object
79256>>>>>        Set psCaption   to C_$CaptionDelete
79257>>>>>        Set psToolTip to C_$ToolTipDelete
79258>>>>>        Set psDescription to C_$DescDelete
79259>>>>>        Set psImage to "actionDelete.ico"
79260>>>>>        Set psShortcut to C_$Key_Delete
79261>>>>>        Set pbActiveUpdate to True
79262>>>>>        Set psCategory to C_$CategoryEdit
79263>>>>>    End_Procedure
79264>>>>>
79264>>>>>
79264>>>>>    Procedure OnExecute Variant vCommandBarControl
79266>>>>>        Send Delete of (focus(Self))
79267>>>>>    End_Procedure
79268>>>>>    
79268>>>>>    Function IsEnabled Returns Boolean
79270>>>>>        Boolean bEnabled
79270>>>>>        Get CanDelete of (Focus(Self)) to bEnabled
79271>>>>>        Function_Return bEnabled
79272>>>>>    End_Function
79273>>>>>         
79273>>>>>End_Class
79274>>>>>
79274>>>>>
79274>>>>>Class cCJCutMenuItem is a cCJMenuItem
79275>>>>>    
79275>>>>>    Procedure Construct_Object
79277>>>>>        Forward Send Construct_Object
79279>>>>>        Set psCaption   to C_$CaptionCut
79280>>>>>        Set psToolTip to C_$TooltipCut
79281>>>>>        Set psDescription to C_$DescCut
79282>>>>>        Set psImage to "actionCut.ico"
79283>>>>>        Set psShortcut to C_$Key_Ctrl_X
79284>>>>>        Set pbActiveUpdate to True
79285>>>>>        Set psCategory to C_$CategoryEdit
79286>>>>>    End_Procedure
79287>>>>>
79287>>>>>
79287>>>>>    Procedure OnExecute Variant vCommandBarControl
79289>>>>>        Send Cut of (focus(Self))
79290>>>>>    End_Procedure
79291>>>>>    
79291>>>>>    Function IsEnabled Returns Boolean
79293>>>>>        Boolean bEnabled
79293>>>>>        Get CanCut of (Focus(Self)) to bEnabled
79294>>>>>        Function_Return bEnabled
79295>>>>>    End_Function
79296>>>>>         
79296>>>>>End_Class
79297>>>>>
79297>>>>>
79297>>>>>Class cCJCopyMenuItem is a cCJMenuItem
79298>>>>>    
79298>>>>>    Procedure Construct_Object
79300>>>>>        Forward Send Construct_Object
79302>>>>>        Set psCaption   to C_$CaptionCopy
79303>>>>>        Set psToolTip to C_$ToolTipCopy
79304>>>>>        Set psDescription to C_$DescCopy
79305>>>>>        Set psImage to "actionCopy.ico"
79306>>>>>        Set psShortcut to C_$Key_Ctrl_C
79307>>>>>        Set pbActiveUpdate to True
79308>>>>>        Set psCategory to C_$CategoryEdit
79309>>>>>    End_Procedure
79310>>>>>
79310>>>>>
79310>>>>>    Procedure OnExecute Variant vCommandBarControl
79312>>>>>        Send Copy of (focus(Self))
79313>>>>>    End_Procedure
79314>>>>>    
79314>>>>>    Function IsEnabled Returns Boolean
79316>>>>>        Boolean bEnabled
79316>>>>>        Get CanCopy of (Focus(Self)) to bEnabled
79317>>>>>        Function_Return bEnabled
79318>>>>>    End_Function
79319>>>>>         
79319>>>>>End_Class
79320>>>>>
79320>>>>>
79320>>>>>Class cCJPasteMenuItem is a cCJMenuItem
79321>>>>>    
79321>>>>>    Procedure Construct_Object
79323>>>>>        Forward Send Construct_Object
79325>>>>>        Set psCaption   to C_$CaptionPaste
79326>>>>>        Set psToolTip to C_$ToolTipPaste
79327>>>>>        Set psDescription to C_$DescPaste
79328>>>>>        Set psImage to "actionPaste.ico"
79329>>>>>        Set pbActiveUpdate to True
79330>>>>>        Set psShortcut to C_$Key_Ctrl_V
79331>>>>>        Set psCategory to C_$CategoryEdit
79332>>>>>    End_Procedure
79333>>>>>
79333>>>>>
79333>>>>>    Procedure OnExecute Variant vCommandBarControl
79335>>>>>        Send Paste of (focus(Self))
79336>>>>>    End_Procedure
79337>>>>>    
79337>>>>>    Function IsEnabled Returns Boolean
79339>>>>>        Boolean bEnabled
79339>>>>>        Get CanPaste of (Focus(Self)) to bEnabled
79340>>>>>        Function_Return bEnabled
79341>>>>>    End_Function
79342>>>>>         
79342>>>>>End_Class
79343>>>>>
79343>>>>>Class cCJSelectAllMenuItem is a cCJMenuItem
79344>>>>>    
79344>>>>>    Procedure Construct_Object
79346>>>>>        Forward Send Construct_Object
79348>>>>>        Set psCaption   to C_$CaptionSelectAll
79349>>>>>        Set psToolTip to C_$ToolTipSelectAll
79350>>>>>        Set psDescription to C_$DescSelectAll
79351>>>>>        Set pbActiveUpdate to True
79352>>>>>        Set psShortcut to C_$Key_Ctrl_A
79353>>>>>        Set psCategory to C_$CategoryEdit
79354>>>>>    End_Procedure
79355>>>>>
79355>>>>>
79355>>>>>    Procedure OnExecute Variant vCommandBarControl
79357>>>>>        Send Select_All of (focus(Self))
79358>>>>>    End_Procedure
79359>>>>>    
79359>>>>>    Function IsEnabled Returns Boolean
79361>>>>>        Boolean bEnabled
79361>>>>>        Get CanSelect of (Focus(Self)) to bEnabled
79362>>>>>        Function_Return bEnabled
79363>>>>>    End_Function
79364>>>>>         
79364>>>>>End_Class
79365>>>>>
79365>>>>> 
79365>>>>>Class cCJExitMenuItem is a cCJMenuItem
79366>>>>>
79366>>>>>    Procedure Construct_Object
79368>>>>>        Forward Send Construct_Object
79370>>>>>        Set psCaption to C_$CaptionExit
79371>>>>>        Set psToolTip to C_$ToolTipExit
79372>>>>>        Set psDescription to C_$ToolTipExit
79373>>>>>        Set psShortcut to C_$Key_Alt_F4
79374>>>>>        Set psCategory to C_$CategoryFile
79375>>>>>    End_Procedure
79376>>>>>
79376>>>>>    Procedure OnExecute Variant vCommandBarControl
79378>>>>>        Send Exit_Application of Desktop
79379>>>>>    End_Procedure
79380>>>>>
79380>>>>>End_Class           
79381>>>>>
79381>>>>>Class cCJHelpMenuItem is a cCJMenuItem    
79382>>>>>
79382>>>>>    Procedure Construct_Object
79384>>>>>        Forward Send Construct_Object
79386>>>>>        Set psCaption to C_$CaptionHelp
79387>>>>>        Set psDescription to C_$ToolTipHelp
79388>>>>>        Set psToolTip to C_$DescHelp
79389>>>>>        Set psImage to "ActionHelp.ico"
79390>>>>>        Set psShortcut to "F1"
79391>>>>>        Set psCategory to C_$CategoryHelp
79392>>>>>    End_Procedure
79393>>>>>    
79393>>>>>    Procedure OnExecute Variant vCommandBarControl
79395>>>>>        Send Help of (Focus(Self))
79396>>>>>    End_Procedure
79397>>>>>
79397>>>>>End_Class
79398>>>>>
79398>>>>>Class cCJStatusbarMenuItem is a cCJMenuItem
79399>>>>>
79399>>>>>    Procedure Construct_Object
79401>>>>>        Forward Send Construct_Object
79403>>>>>        Set psCaption to C_$CaptionAddStatusbar
79404>>>>>        Set psToolTip to C_$ToolTipAddStatusbar
79405>>>>>        Set psDescription to  C_$DescAddStatusbar
79406>>>>>        Set psCategory to C_$CategoryWindow
79407>>>>>    End_Procedure
79408>>>>>
79408>>>>>    Procedure OnExecute Variant vCommandBarControl
79410>>>>>        Handle hoCommandBars hoClientArea
79410>>>>>        Get CommandBarSystemObject to hoCommandBars
79411>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79412>>>>>        If hoClientArea Begin
79414>>>>>            // the clientarea's parent panel has message
79414>>>>>            Send Toggle_StatusBar of (Parent(hoClientArea))
79415>>>>>        End
79415>>>>>>
79415>>>>>    End_Procedure
79416>>>>>
79416>>>>>     Function IsChecked Returns Boolean
79418>>>>>        Boolean bOn
79418>>>>>        Handle hoCommandBars hoClientArea
79418>>>>>        Get CommandBarSystemObject to hoCommandBars
79419>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79420>>>>>        If hoClientArea Begin
79422>>>>>            // the clientarea's parent panel has message
79422>>>>>            Get StatusBar_State of (Parent(hoClientArea)) to bOn
79423>>>>>        End
79423>>>>>>
79423>>>>>        Function_Return bOn
79424>>>>>     End_Function
79425>>>>>End_Class
79426>>>>>
79426>>>>>Class cCJAutoArrangeIconsMenuItem is a cCJMenuItem
79427>>>>>
79427>>>>>    Procedure Construct_Object
79429>>>>>        Forward Send Construct_Object
79431>>>>>        Set psCaption to C_$CaptionAutoArrangeIcons
79432>>>>>        Set psToolTip to C_$ToolTipAutoArrangeIcons
79433>>>>>        Set psDescription to C_$DescAutoArrangeIcons
79434>>>>>        Set psCategory to C_$CategoryWindow
79435>>>>>    End_Procedure
79436>>>>>
79436>>>>>    Procedure OnExecute Variant vCommandBarControl
79438>>>>>        Handle hoCommandBars hoClientArea
79438>>>>>        Get CommandBarSystemObject to hoCommandBars
79439>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79440>>>>>        If hoClientArea Begin
79442>>>>>            // the clientarea's parent panel has message
79442>>>>>            Send Toggle_Auto_Arrange_Icons of (Parent(hoClientArea))
79443>>>>>        End
79443>>>>>>
79443>>>>>    End_Procedure
79444>>>>>    
79444>>>>>     Function IsChecked Returns Boolean
79446>>>>>        Boolean bOn
79446>>>>>        Handle hoCommandBars hoClientArea
79446>>>>>        Get CommandBarSystemObject to hoCommandBars
79447>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79448>>>>>        If hoClientArea Begin
79450>>>>>            // the clientarea's parent panel has message
79450>>>>>            Get Auto_Arrange_Icons_State of (Parent(hoClientArea)) to bOn
79451>>>>>        End
79451>>>>>>
79451>>>>>        Function_Return bOn
79452>>>>>     End_Function
79453>>>>>End_Class
79454>>>>>
79454>>>>>Class cCJRestoreMenusMenuItem is a cCJMenuItem
79455>>>>>
79455>>>>>    Procedure Construct_Object
79457>>>>>        Forward Send Construct_Object
79459>>>>>        Set psCaption to C_$CaptionRestoreMenus
79460>>>>>        Set psToolTip to C_$ToolTipRestoreMenus
79461>>>>>        Set psDescription to C_$DescRestoreMenus
79462>>>>>        Set psCategory to C_$CategoryWindow
79463>>>>>    End_Procedure
79464>>>>>
79464>>>>>    Procedure OnExecute Variant vCommandBarControl
79466>>>>>        Handle hoCommandBars
79466>>>>>        Get CommandBarSystemObject to hoCommandBars
79467>>>>>        Send RestoreLayout of hoCommandBars
79468>>>>>    End_Procedure
79469>>>>>    
79469>>>>>End_Class
79470>>>>>
79470>>>>>Class cCJCascadeMenuItem is a cCJMenuItem
79471>>>>>
79471>>>>>    Procedure Construct_Object
79473>>>>>        Forward Send Construct_Object
79475>>>>>        Set psCaption to C_$CaptionCascade
79476>>>>>        Set psToolTip to C_$ToolTipCascade
79477>>>>>        Set psDescription to  C_$DescCascade
79478>>>>>        Set psImage to "ActionCascade.ico"
79479>>>>>        Set psCategory to C_$CategoryWindow
79480>>>>>    End_Procedure
79481>>>>>    
79481>>>>>    Procedure OnExecute Variant vCommandBarControl
79483>>>>>        Handle hoCommandBars hoClientArea
79483>>>>>        Get CommandBarSystemObject to hoCommandBars
79484>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79485>>>>>        If hoClientArea Begin
79487>>>>>            Send Cascade_Windows of hoClientArea
79488>>>>>        End
79488>>>>>>
79488>>>>>    End_Procedure
79489>>>>>End_Class
79490>>>>>
79490>>>>>Class cCJTileHorizontally is a cCJMenuItem
79491>>>>>
79491>>>>>    Procedure Construct_Object
79493>>>>>        Forward Send Construct_Object
79495>>>>>        Set psCaption to C_$CaptionTileHorizontally 
79496>>>>>        Set psToolTip to C_$ToolTipTileHorizontally  
79497>>>>>        Set psDescription to  C_$DescTileHorizontally
79498>>>>>        Set psImage to "ActionTileHorizontally.ico"
79499>>>>>        Set psCategory to C_$CategoryWindow
79500>>>>>    End_Procedure
79501>>>>>
79501>>>>>    Procedure OnExecute Variant vCommandBarControl
79503>>>>>        Handle hoCommandBars hoClientArea
79503>>>>>        Get CommandBarSystemObject to hoCommandBars
79504>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79505>>>>>        If hoClientArea Begin
79507>>>>>            Send Tile_Windows_Horizontal of hoClientArea
79508>>>>>        End
79508>>>>>>
79508>>>>>    End_Procedure
79509>>>>>End_Class
79510>>>>>
79510>>>>>Class cCJTileVertically is a cCJMenuItem
79511>>>>>
79511>>>>>    Procedure Construct_Object
79513>>>>>        Forward Send Construct_Object
79515>>>>>        Set psCaption to C_$CaptionTileVertically  
79516>>>>>        Set psToolTip to C_$ToolTipTileVertically
79517>>>>>        Set psDescription to  C_$DescTileVertically
79518>>>>>        Set psImage to "ActionTileVertically.ico"
79519>>>>>        Set psCategory to C_$CategoryWindow
79520>>>>>    End_Procedure
79521>>>>>
79521>>>>>    Procedure OnExecute Variant vCommandBarControl
79523>>>>>        Handle hoCommandBars hoClientArea
79523>>>>>        Get CommandBarSystemObject to hoCommandBars
79524>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79525>>>>>        If hoClientArea Begin
79527>>>>>            Send Tile_Windows_Vertical of hoClientArea
79528>>>>>        End
79528>>>>>>
79528>>>>>    End_Procedure
79529>>>>>End_Class
79530>>>>>
79530>>>>>Class cCJMinimizeWindowsMenuItem is a cCJMenuItem
79531>>>>>
79531>>>>>    Procedure Construct_Object
79533>>>>>        Forward Send Construct_Object
79535>>>>>        Set psCaption to C_$CaptionMinimizeWindows 
79536>>>>>        Set psToolTip to C_$ToolTipMinimizeWindows
79537>>>>>        Set psDescription to  C_$DescMinimizeWindows
79538>>>>>        Set psCategory to C_$CategoryWindow
79539>>>>>    End_Procedure
79540>>>>>
79540>>>>>    Procedure OnExecute Variant vCommandBarControl
79542>>>>>        Handle hoCommandBars hoClientArea
79542>>>>>        Get CommandBarSystemObject to hoCommandBars
79543>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79544>>>>>        If hoClientArea Begin
79546>>>>>            // the clientarea's parent panel has message
79546>>>>>            Send Minimize_all_Windows of (Parent(hoClientArea))
79547>>>>>        End
79547>>>>>>
79547>>>>>    End_Procedure
79548>>>>>End_Class
79549>>>>>
79549>>>>>
79549>>>>>Class cCJRestoreWindowsMenuItem is a cCJMenuItem
79550>>>>>
79550>>>>>    Procedure Construct_Object
79552>>>>>        Forward Send Construct_Object
79554>>>>>        Set psCaption to C_$CaptionRestoreWindows
79555>>>>>        Set psToolTip to C_$ToolTipRestoreWindows
79556>>>>>        Set psDescription to  C_$DescRestoreWindows
79557>>>>>        Set psCategory to C_$CategoryWindow
79558>>>>>    End_Procedure
79559>>>>>
79559>>>>>    Procedure OnExecute Variant vCommandBarControl
79561>>>>>        Handle hoCommandBars hoClientArea
79561>>>>>        Get CommandBarSystemObject to hoCommandBars
79562>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79563>>>>>        If hoClientArea Begin
79565>>>>>            // the clientarea's parent panel has message
79565>>>>>            Send Restore_all_Windows of (Parent(hoClientArea))
79566>>>>>        End
79566>>>>>>
79566>>>>>    End_Procedure
79567>>>>>End_Class
79568>>>>>
79568>>>>>Class cCJArrangeIconsMenuItem is a cCJMenuItem
79569>>>>>
79569>>>>>    Procedure Construct_Object
79571>>>>>        Forward Send Construct_Object
79573>>>>>        Set psCaption to C_$CaptionArrangeIcons  
79574>>>>>        Set psToolTip to C_$ToolTipArrangeIcons
79575>>>>>        Set psDescription to  C_$DescArrangeIcons
79576>>>>>        Set psCategory to C_$CategoryWindow
79577>>>>>    End_Procedure
79578>>>>>
79578>>>>>    Procedure OnExecute Variant vCommandBarControl
79580>>>>>        Handle hoCommandBars hoClientArea
79580>>>>>        Get CommandBarSystemObject to hoCommandBars
79581>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79582>>>>>        If hoClientArea Begin
79584>>>>>            Send Arrange_Icons of hoClientArea
79585>>>>>        End
79585>>>>>>
79585>>>>>    End_Procedure
79586>>>>>
79586>>>>>End_Class
79587>>>>>    
79587>>>Use cCJAboutMenuItem.pkg
Including file: cCJAboutMenuItem.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJAboutMenuItem.pkg)
79587>>>>>Use cCJCommandBarSystem.pkg
79587>>>>>Use LanguageText.pkg
79587>>>>>
79587>>>>>// It is expected that if you use this class that you provide an about object that is
79587>>>>>// activated via activate_about such as DfAbout.pkg. We don't use this for you automatically
79587>>>>>// because you may wish to create your own custom about package.
79587>>>>>
79587>>>>>Class cCJAboutMenuItem is a cCJMenuItem    
79588>>>>>
79588>>>>>    Procedure Construct_Object
79590>>>>>        Forward Send Construct_Object
79592>>>>>        Set psCaption to C_$CaptionAbout
79593>>>>>        Set psDescription to C_$ToolTipAbout
79594>>>>>        Set psToolTip to C_$DescAbout
79595>>>>>        Set psImage to "ActionAbout.ico"
79596>>>>>        Set psCategory to C_$CategoryHelp
79597>>>>>    End_Procedure
79598>>>>>    
79598>>>>>    Procedure OnExecute Variant vCommandBarControl
79600>>>>>        Handle hoCommandBars hoClientArea
79600>>>>>        Get CommandBarSystemObject to hoCommandBars
79601>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79602>>>>>        If hoClientArea Begin
79604>>>>>            Send Activate_About of hoClientArea
79605>>>>>        End
79605>>>>>>
79605>>>>>    End_Procedure
79606>>>>>
79606>>>>>End_Class
79607>>>>>
79607>>>>>
79607>>>Use cCJDeoMenuItemClasses.pkg
79607>>>Use cCJMDIWindowsMenuItem.pkg
Including file: cCJMDIWindowsMenuItem.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJMDIWindowsMenuItem.pkg)
79607>>>>>Use cCJCommandBarSystem.pkg
79607>>>>>
79607>>>>>Register_Function Client_ID Returns Integer
79607>>>>>
79607>>>>>// only used by cCJMDIWIndowsMenuItem
79607>>>>>Class cCJMDIWindowItem is a cCJMenuItem
79608>>>>>
79608>>>>>    Procedure Construct_Object
79610>>>>>        Forward Send Construct_Object
79612>>>>>        Property Handle phWindow 0 // object id of view
79613>>>>>        Set pbControlFlagNoMovable to True
79614>>>>>        Set pbActiveUpdate to True
79615>>>>>    End_Procedure
79616>>>>>    
79616>>>>>    Procedure OnExecute Variant vCommandBarControl
79618>>>>>        Handle hWindow
79618>>>>>        Get phWindow to hWindow
79619>>>>>        Send Activate_View of hWindow
79620>>>>>    End_Procedure
79621>>>>>    
79621>>>>>End_Class                
79622>>>>>
79622>>>>>
79622>>>>>Class cCJMDIWindowsMenuItem is a cCJMenuItem
79623>>>>>    
79623>>>>>    Procedure Construct_Object
79625>>>>>        Forward Send Construct_Object
79627>>>>>        Property Handle[] phArrayOfWindows
79628>>>>>        Set peControlType to xtpControlPopup
79629>>>>>        Set psCategory to C_$CategoryWindow
79630>>>>>    End_Procedure
79631>>>>>    
79631>>>>>     // This adds MDI windows to the existing menu items.
79631>>>>>     // This removes any existing windows menus and always adds a new set to the end
79631>>>>>
79631>>>>>     Procedure OnPopupInit Variant vCommandBarControl Handle hCommandBarControls
79633>>>>>        Handle  hClientArea hView
79633>>>>>        String  sLabel
79633>>>>>        Integer i iWindows
79633>>>>>        Handle[] hArrayOfWindows
79634>>>>>        Variant vItem
79634>>>>>        
79634>>>>>        // delete all windows actions and menu items. Assume we have an array of DF action objects for the windows
79634>>>>>        // also assume that destroying an action removes all menu instances of that action
79634>>>>>        Get phArrayOfWindows to hArrayOfWindows
79635>>>>>        Move (SizeOfArray(hArrayOfWindows)) to iWindows
79636>>>>>        For i from 0 to (iWindows-1)
79642>>>>>>
79642>>>>>            Send Destroy of hArrayOfWindows[i] // assume this removes all menu items of this action
79643>>>>>        Loop
79644>>>>>>
79644>>>>>        Move (ResizeArray(hArrayOfWindows,0)) to hArrayOfWindows
79645>>>>>
79645>>>>>        // Add all views to this menu. Create the action and add the item
79645>>>>>        Move 0 to i
79646>>>>>        Get Client_Id to hClientArea // object id of client area
79647>>>>>        If (hClientArea > 0) Begin
79649>>>>>            Get Next_Mdi_Dialog of hClientArea True to hView // find first view
79650>>>>>            While (hView <> 0)
79654>>>>>                If (Active_State(hView)) Begin
79656>>>>>                    // create the action
79656>>>>>                    Get Create U_cCJMDIWindowItem to hArrayOfWindows[i]
79657>>>>>                    Get Label of hView to sLabel // caption bar (name) of view
79658>>>>>                    Set psCaption of hArrayOfWindows[i] to sLabel
79659>>>>>                    Set psDescription of hArrayOfWindows[i] to ("Make this view (" - trim(sLabel) - ") the active window.")
79660>>>>>                    If (current_scope(desktop)=hView and View_mode(hView)<>VIEWMODE_ICONIZE) Begin
79662>>>>>                        Set pbChecked of hArrayOfWindows[i] to True
79663>>>>>                    End
79663>>>>>>
79663>>>>>                    Set phWindow of hArrayOfWindows[i] to hView // used by custom OnExecute
79664>>>>>                    If (i=0) Begin
79666>>>>>                        Set pbControlBeginGroup of hArrayOfWindows[i] to True
79667>>>>>                    End
79667>>>>>>
79667>>>>>                    // Create a menu item for this action
79667>>>>>                    Get AddDynamicControl of hArrayOfWindows[i] hCommandBarControls to vItem
79668>>>>>                    Increment i
79669>>>>>                End
79669>>>>>>
79669>>>>>                Get Next_Mdi_Dialog of hClientArea False to hView // find next
79670>>>>>            Loop
79671>>>>>>
79671>>>>>        End
79671>>>>>>
79671>>>>>
79671>>>>>        Set phArrayOfWindows to hArrayOfWindows
79672>>>>>
79672>>>>>     End_Procedure
79673>>>>>     
79673>>>>>End_Class
79674>>>>>
79674>Use cCJCommandBarSystem.pkg
79674>Use cCJSkinFramework.pkg
Including file: cCJSkinFramework.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJSkinFramework.pkg)
79674>>>Use windows.pkg
79674>>>Use cCJComSkinFramework.pkg
Including file: cCJComSkinFramework.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJComSkinFramework.pkg)
79674>>>>>// DataFlex COM proxy classes generated from C:\Program Files (x86)\Codejock Software\ActiveX\Xtreme SuitePro ActiveX v17.3.0\Bin\Codejock.SkinFramework.v17.3.0.ocx
79674>>>>>Use FlexCom20.pkg
79674>>>>>
79674>>>>>// Changes to Imported package
79674>>>>>//     OLEXTPxx to XTPxx
79674>>>>>//     OLExtpxx to xtpxx
79674>>>>>//     OLESkinFramework to SkinFramework
79674>>>>>//     OLESTDxxx and OLEXPxxxx to STD/XP
79674>>>>>//     cCom classes to cCJ
79674>>>>>//     cCJAutomationObject back to cComAutomationObject
79674>>>>>//     cCJActiveXControl back to cComActiveXControl
79674>>>>>//     cCJSkinFramework to cCJComSkinFramework
79674>>>>>//     Use statements as noted below (classes moved to these files)
79674>>>>>//     Set classlibrary of all cComAutomation objects to Windows (for class doc)
79674>>>>>
79674>>>>>// These have been extracted from this class and moved into seperate packages
79674>>>>>// because other Codejock classes use these.
79674>>>>>Use cCJColorManager.pkg     // cCJColorManager
79674>>>>>
79674>>>>>Define SkinFrameworkApplyOptions for Integer
79674>>>>>    Define xtpSkinApplyMetrics for 1
79674>>>>>    Define xtpSkinApplyFrame for 2
79674>>>>>    Define xtpSkinApplyColors for 4
79674>>>>>    Define xtpSkinApplyMenus for 8
79674>>>>>
79674>>>>>// CLSID: {AFA0E6A1-28D7-4F2C-87A7-7266367B4655}
79674>>>>>// Dispatch interface for SkinFramework Control
79674>>>>>Class cCJ_DSkinFramework is a Mixin
79675>>>>>
79675>>>>>    Function ComApplyOptions Returns SkinFrameworkApplyOptions
79677>>>>>        SkinFrameworkApplyOptions retVal
79677>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to retVal
79678>>>>>        Function_Return retVal
79679>>>>>    End_Function
79680>>>>>
79680>>>>>    Procedure Set ComApplyOptions SkinFrameworkApplyOptions value
79682>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to value
79683>>>>>    End_Procedure
79684>>>>>
79684>>>>>    Function ComAutoApplyNewWindows Returns Boolean
79686>>>>>        Boolean retVal
79686>>>>>        Get ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to retVal
79687>>>>>        Function_Return retVal
79688>>>>>    End_Function
79689>>>>>
79689>>>>>    Procedure Set ComAutoApplyNewWindows Boolean value
79691>>>>>        Set ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to value
79692>>>>>    End_Procedure
79693>>>>>
79693>>>>>    Function ComAutoApplyNewThreads Returns Boolean
79695>>>>>        Boolean retVal
79695>>>>>        Get ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to retVal
79696>>>>>        Function_Return retVal
79697>>>>>    End_Function
79698>>>>>
79698>>>>>    Procedure Set ComAutoApplyNewThreads Boolean value
79700>>>>>        Set ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to value
79701>>>>>    End_Procedure
79702>>>>>
79702>>>>>    Function ComLoadSkin String llResourcePath String llIniFileName Returns Boolean
79704>>>>>        Handle hDispatchDriver
79704>>>>>        Boolean retVal
79704>>>>>        Get phDispatchDriver to hDispatchDriver
79705>>>>>        Send PrepareParams to hDispatchDriver 2
79706>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
79707>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
79708>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_BOOL to retVal
79709>>>>>        Function_Return retVal
79710>>>>>    End_Function
79711>>>>>
79711>>>>>    Procedure ComApplyWindow OLE_HANDLE llhWnd
79713>>>>>        Handle hDispatchDriver
79713>>>>>        Get phDispatchDriver to hDispatchDriver
79714>>>>>        Send PrepareParams to hDispatchDriver 1
79715>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
79716>>>>>        Send InvokeComMethod to hDispatchDriver 3 OLE_VT_VOID
79717>>>>>    End_Procedure
79718>>>>>
79718>>>>>    Procedure ComEnableThemeDialogTexture OLE_HANDLE llhWnd Integer llFlags
79720>>>>>        Handle hDispatchDriver
79720>>>>>        Get phDispatchDriver to hDispatchDriver
79721>>>>>        Send PrepareParams to hDispatchDriver 2
79722>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
79723>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llFlags
79724>>>>>        Send InvokeComMethod to hDispatchDriver 4 OLE_VT_VOID
79725>>>>>    End_Procedure
79726>>>>>
79726>>>>>    Procedure ComRemoveWindow OLE_HANDLE llhWnd
79728>>>>>        Handle hDispatchDriver
79728>>>>>        Get phDispatchDriver to hDispatchDriver
79729>>>>>        Send PrepareParams to hDispatchDriver 1
79730>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
79731>>>>>        Send InvokeComMethod to hDispatchDriver 6 OLE_VT_VOID
79732>>>>>    End_Procedure
79733>>>>>
79733>>>>>    Procedure ComRemoveAllWindows
79735>>>>>        Handle hDispatchDriver
79735>>>>>        Get phDispatchDriver to hDispatchDriver
79736>>>>>        Send InvokeComMethod to hDispatchDriver 7 OLE_VT_VOID
79737>>>>>    End_Procedure
79738>>>>>
79738>>>>>    Procedure ComAddWindowClass String llClassName String llBaseClassName
79740>>>>>        Handle hDispatchDriver
79740>>>>>        Get phDispatchDriver to hDispatchDriver
79741>>>>>        Send PrepareParams to hDispatchDriver 2
79742>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
79743>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llBaseClassName
79744>>>>>        Send InvokeComMethod to hDispatchDriver 8 OLE_VT_VOID
79745>>>>>    End_Procedure
79746>>>>>
79746>>>>>    Procedure ComRemoveWindowClass String llClassName
79748>>>>>        Handle hDispatchDriver
79748>>>>>        Get phDispatchDriver to hDispatchDriver
79749>>>>>        Send PrepareParams to hDispatchDriver 1
79750>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
79751>>>>>        Send InvokeComMethod to hDispatchDriver 9 OLE_VT_VOID
79752>>>>>    End_Procedure
79753>>>>>
79753>>>>>    Function ComEnumerateSkinDirectory String llPath Boolean llRecursive Returns Variant
79755>>>>>        Handle hDispatchDriver
79755>>>>>        Variant retVal
79755>>>>>        Get phDispatchDriver to hDispatchDriver
79756>>>>>        Send PrepareParams to hDispatchDriver 2
79757>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
79758>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BOOL llRecursive
79759>>>>>        Get InvokeComMethod of hDispatchDriver 11 OLE_VT_DISPATCH to retVal
79760>>>>>        Function_Return retVal
79761>>>>>    End_Function
79762>>>>>
79762>>>>>    Function ComEnumerateSkinFile String llPath Returns Variant
79764>>>>>        Handle hDispatchDriver
79764>>>>>        Variant retVal
79764>>>>>        Get phDispatchDriver to hDispatchDriver
79765>>>>>        Send PrepareParams to hDispatchDriver 1
79766>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
79767>>>>>        Get InvokeComMethod of hDispatchDriver 12 OLE_VT_DISPATCH to retVal
79768>>>>>        Function_Return retVal
79769>>>>>    End_Function
79770>>>>>
79770>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
79772>>>>>        Handle hDispatchDriver
79772>>>>>        OLE_COLOR retVal
79772>>>>>        Get phDispatchDriver to hDispatchDriver
79773>>>>>        Send PrepareParams to hDispatchDriver 1
79774>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
79775>>>>>        Get InvokeComMethod of hDispatchDriver 14 OLE_VT_I4 to retVal
79776>>>>>        Function_Return retVal
79777>>>>>    End_Function
79778>>>>>
79778>>>>>    Procedure ComExcludeModule String llModuleName
79780>>>>>        Handle hDispatchDriver
79780>>>>>        Get phDispatchDriver to hDispatchDriver
79781>>>>>        Send PrepareParams to hDispatchDriver 1
79782>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llModuleName
79783>>>>>        Send InvokeComMethod to hDispatchDriver 15 OLE_VT_VOID
79784>>>>>    End_Procedure
79785>>>>>
79785>>>>>    Function ComCreateSchema String llResourcePath String llIniFileName Returns Variant
79787>>>>>        Handle hDispatchDriver
79787>>>>>        Variant retVal
79787>>>>>        Get phDispatchDriver to hDispatchDriver
79788>>>>>        Send PrepareParams to hDispatchDriver 2
79789>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
79790>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
79791>>>>>        Get InvokeComMethod of hDispatchDriver 16 OLE_VT_DISPATCH to retVal
79792>>>>>        Function_Return retVal
79793>>>>>    End_Function
79794>>>>>
79794>>>>>    Procedure ComSetWindowTheme OLE_HANDLE llhWnd Variant llSchema
79796>>>>>        Handle hDispatchDriver
79796>>>>>        Get phDispatchDriver to hDispatchDriver
79797>>>>>        Send PrepareParams to hDispatchDriver 2
79798>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
79799>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llSchema
79800>>>>>        Send InvokeComMethod to hDispatchDriver 17 OLE_VT_VOID
79801>>>>>    End_Procedure
79802>>>>>
79802>>>>>    Procedure ComAboutBox
79804>>>>>        Handle hDispatchDriver
79804>>>>>        Get phDispatchDriver to hDispatchDriver
79805>>>>>        Send InvokeComMethod to hDispatchDriver -552 OLE_VT_VOID
79806>>>>>    End_Procedure
79807>>>>>End_Class
79808>>>>>
79808>>>>>// CLSID: {40217CB8-4463-4030-B324-AC6A8075FEC8}
79808>>>>>// Event interface for SkinFramework Control
79808>>>>>Class cCJ_DSkinFrameworkEvents is a Mixin
79809>>>>>
79809>>>>>    Procedure RegisterComEvents
79811>>>>>    End_Procedure
79812>>>>>End_Class
79813>>>>>
79813>>>>>// CoClass
79813>>>>>// ProgID: Codejock.SkinFramework.17.3.0
79813>>>>>// CLSID: {DE67160B-9A3E-4EA6-846E-8C9A72F9F203}
79813>>>>>// SkinFramework Control
79813>>>>>Class cCJComSkinFramework is a cComActiveXControl
79814>>>>>    Import_Class_Protocol cCJ_DSkinFramework
79815>>>>>    Import_Class_Protocol cCJ_DSkinFrameworkEvents
79816>>>>>
79816>>>>>    Procedure Construct_Object
79818>>>>>        Forward Send Construct_Object
79820>>>>>        Set psProgID to "{DE67160B-9A3E-4EA6-846E-8C9A72F9F203}"
79821>>>>>        Set psEventId to "{40217CB8-4463-4030-B324-AC6A8075FEC8}"
79822>>>>>        Set psLicenseKey to ("Skin Framework Control Copyright (c) 1998-2016 Codejock Software"+ Character(13)+ Character(10)+;                             "PRODUCT-ID: Codejock.SkinFramework.ActiveX.v17.3"+ Character(13)+ Character(10)+;                             "VALIDATE-CODE: GGE-OLD-QQR-EJS")
79823>>>>>        Set peAutoCreate to acAutoCreate
79824>>>>>    End_Procedure
79825>>>>>End_Class
79826>>>>>
79826>>>>>// CLSID: {06E8A85B-70E4-4F71-A0FC-D1D5658C7E17}
79826>>>>>// SkinFramework Global Settings
79826>>>>>Class cCJISkinFrameworkGlobalSettings is a Mixin
79827>>>>>
79827>>>>>    Function ComLicense Returns String
79829>>>>>        String retVal
79829>>>>>        Get ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to retVal
79830>>>>>        Function_Return retVal
79831>>>>>    End_Function
79832>>>>>
79832>>>>>    Procedure Set ComLicense String value
79834>>>>>        Set ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to value
79835>>>>>    End_Procedure
79836>>>>>
79836>>>>>    Function ComTitle Returns String
79838>>>>>        String retVal
79838>>>>>        Get ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to retVal
79839>>>>>        Function_Return retVal
79840>>>>>    End_Function
79841>>>>>
79841>>>>>    Procedure Set ComTitle String value
79843>>>>>        Set ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to value
79844>>>>>    End_Procedure
79845>>>>>
79845>>>>>    Function ComVersion Returns String
79847>>>>>        Handle hDispatchDriver
79847>>>>>        String retVal
79847>>>>>        Get phDispatchDriver to hDispatchDriver
79848>>>>>        Get InvokeComMethod of hDispatchDriver 104 OLE_VT_BSTR to retVal
79849>>>>>        Function_Return retVal
79850>>>>>    End_Function
79851>>>>>
79851>>>>>    Function ComUnicode Returns Boolean
79853>>>>>        Handle hDispatchDriver
79853>>>>>        Boolean retVal
79853>>>>>        Get phDispatchDriver to hDispatchDriver
79854>>>>>        Get InvokeComMethod of hDispatchDriver 105 OLE_VT_BOOL to retVal
79855>>>>>        Function_Return retVal
79856>>>>>    End_Function
79857>>>>>
79857>>>>>    Function ComOcxPath Returns String
79859>>>>>        Handle hDispatchDriver
79859>>>>>        String retVal
79859>>>>>        Get phDispatchDriver to hDispatchDriver
79860>>>>>        Get InvokeComMethod of hDispatchDriver 106 OLE_VT_BSTR to retVal
79861>>>>>        Function_Return retVal
79862>>>>>    End_Function
79863>>>>>End_Class
79864>>>>>
79864>>>>>// CoClass
79864>>>>>// ProgID: Codejock.SkinFrameworkGlobalSettings.17.3.0
79864>>>>>// CLSID: {C4136A4A-67FD-4FC1-BA62-A715B4D60808}
79864>>>>>// SkinFramework Global Settings
79864>>>>>Class cCJComSkinFrameworkGlobalSettings is a cComAutomationObject
79865>>>>>    Import_Class_Protocol cCJISkinFrameworkGlobalSettings
79866>>>>>
79866>>>>>    Procedure Construct_Object
79868>>>>>        Forward Send Construct_Object
79870>>>>>        Set psProgID to "{C4136A4A-67FD-4FC1-BA62-A715B4D60808}"
79871>>>>>        Set peAutoCreate to acNoAutoCreate
79872>>>>>    End_Procedure
79873>>>>>End_Class
79874>>>>>
79874>>>>>// CLSID: {27E4AC9B-4A2D-4FBB-A782-BD76BEFA4345}
79874>>>>>Class cCJSkinIniFile is a cComAutomationObject
79875>>>>>
79875>>>>>    Function ComColorScheme Returns String
79877>>>>>        String retVal
79877>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
79878>>>>>        Function_Return retVal
79879>>>>>    End_Function
79880>>>>>
79880>>>>>    Procedure Set ComColorScheme String value
79882>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
79883>>>>>    End_Procedure
79884>>>>>
79884>>>>>    Function ComFontSize Returns String
79886>>>>>        String retVal
79886>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
79887>>>>>        Function_Return retVal
79888>>>>>    End_Function
79889>>>>>
79889>>>>>    Procedure Set ComFontSize String value
79891>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
79892>>>>>    End_Procedure
79893>>>>>
79893>>>>>    Function ComIniFileName Returns String
79895>>>>>        String retVal
79895>>>>>        Get ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to retVal
79896>>>>>        Function_Return retVal
79897>>>>>    End_Function
79898>>>>>
79898>>>>>    Procedure Set ComIniFileName String value
79900>>>>>        Set ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to value
79901>>>>>    End_Procedure
79902>>>>>End_Class
79903>>>>>
79903>>>>>// CLSID: {5005F22B-A30E-4B12-B142-E97F62A927A6}
79903>>>>>Class cCJSkinDescription is a cComAutomationObject
79904>>>>>
79904>>>>>    Function ComName Returns String
79906>>>>>        String retVal
79906>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
79907>>>>>        Function_Return retVal
79908>>>>>    End_Function
79909>>>>>
79909>>>>>    Procedure Set ComName String value
79911>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
79912>>>>>    End_Procedure
79913>>>>>
79913>>>>>    Function ComPath Returns String
79915>>>>>        String retVal
79915>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
79916>>>>>        Function_Return retVal
79917>>>>>    End_Function
79918>>>>>
79918>>>>>    Procedure Set ComPath String value
79920>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
79921>>>>>    End_Procedure
79922>>>>>
79922>>>>>    Function ComCount Returns Integer
79924>>>>>        Handle hDispatchDriver
79924>>>>>        Integer retVal
79924>>>>>        Get phDispatchDriver to hDispatchDriver
79925>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
79926>>>>>        Function_Return retVal
79927>>>>>    End_Function
79928>>>>>
79928>>>>>    Function ComIniFile Integer llIndex Returns Variant
79930>>>>>        Handle hDispatchDriver
79930>>>>>        Variant retVal
79930>>>>>        Get phDispatchDriver to hDispatchDriver
79931>>>>>        Send PrepareParams to hDispatchDriver 1
79932>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
79933>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
79934>>>>>        Function_Return retVal
79935>>>>>    End_Function
79936>>>>>
79936>>>>>    Function Com_NewEnum Returns Variant
79938>>>>>        Handle hDispatchDriver
79938>>>>>        Variant retVal
79938>>>>>        Get phDispatchDriver to hDispatchDriver
79939>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
79940>>>>>        Function_Return retVal
79941>>>>>    End_Function
79942>>>>>End_Class
79943>>>>>
79943>>>>>// CLSID: {C4367A33-2A7C-4CC6-BF0C-C50383B34B51}
79943>>>>>Class cCJSkinDescriptions is a cComAutomationObject
79944>>>>>
79944>>>>>    Function ComCount Returns Integer
79946>>>>>        Handle hDispatchDriver
79946>>>>>        Integer retVal
79946>>>>>        Get phDispatchDriver to hDispatchDriver
79947>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
79948>>>>>        Function_Return retVal
79949>>>>>    End_Function
79950>>>>>
79950>>>>>    Function ComSkin Integer llIndex Returns Variant
79952>>>>>        Handle hDispatchDriver
79952>>>>>        Variant retVal
79952>>>>>        Get phDispatchDriver to hDispatchDriver
79953>>>>>        Send PrepareParams to hDispatchDriver 1
79954>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
79955>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
79956>>>>>        Function_Return retVal
79957>>>>>    End_Function
79958>>>>>
79958>>>>>    Function Com_NewEnum Returns Variant
79960>>>>>        Handle hDispatchDriver
79960>>>>>        Variant retVal
79960>>>>>        Get phDispatchDriver to hDispatchDriver
79961>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
79962>>>>>        Function_Return retVal
79963>>>>>    End_Function
79964>>>>>End_Class
79965>>>>>
79965>>>>>// CLSID: {128507E0-C56F-43C0-BCF1-8193B35FE4C4}
79965>>>>>Class cCJSkinSchema is a cComAutomationObject
79966>>>>>End_Class
79967>>>Use cApplication.pkg
79967>>>
79967>>>Struct tSkinInformation
79967>>>    String sName     // description of the skin
79967>>>    String sSkinfile // file path. Can be relative or full
79967>>>    String sSkinIni  // section name
79967>>>End_Struct
79967>>>
79967>>>
79967>>>Class cCJSkinFramework is a cCJComSkinFramework
79968>>>    
79968>>>    Procedure Construct_Object
79970>>>        Forward Send Construct_Object
79972>>>        
79972>>>        Property String psSkinFile ""
79973>>>        Property String psSkinIni ""
79974>>>        Property Boolean pbLoadPreference False
79975>>>        
79975>>>        Set peAutoCreate to acAutoCreate
79976>>>        
79976>>>        Move Self to ghoSkinFramework
79977>>>    End_Procedure
79978>>>    
79978>>>    // return the default skin path, which is the programs directory.
79978>>>    // This requires an application object.
79978>>>    // If you want to different skin path, override this.
79978>>>    Function SkinPath Returns String
79980>>>        String sPath sPaths
79980>>>        Handle hoWorkspace
79980>>>        If ghoApplication Begin
79982>>>            Get phoWorkspace of ghoApplication to hoWorkspace
79983>>>            Get psProgramPath of hoWorkspace to sPaths
79984>>>            Get PathAtIndex of hoWorkspace sPaths 1 to sPath
79985>>>        End
79985>>>>
79985>>>        Else Begin
79986>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
79987>>>>
79987>>>        End
79987>>>>
79987>>>        Function_Return sPath
79988>>>    End_Function
79989>>>    
79989>>>    // Returns the Qualified name of psSkinFile. If the file is already qualified it just
79989>>>    // returns itself. If it is not, it uses SkinPath to get the path.
79989>>>    Function SkinQFile Returns String
79991>>>        String sFile sPath sSep
79991>>>        Boolean bQualified
79991>>>        Get psSkinFile to sFile
79992>>>        If not (IsFileNameQualified(sFile)) Begin
79994>>>            Get SkinPath to sPath
79995>>>            Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
79996>>>            Move (sPath - sSep - sFile) to sFile
79997>>>        End
79997>>>>
79997>>>        Function_Return sFile
79998>>>    End_Function
79999>>>        
79999>>>    // defines the default VDF window class mapping.    
79999>>>    Procedure OnAddVDFWindowClasses
80001>>>        Send ComAddWindowClass "DFlistbox"               "ListBox"
80002>>>        Send ComAddWindowClass "DFentry"                 "Edit"
80003>>>        Send ComAddWindowClass "DFtextbox"               "Edit"
80004>>>        Send ComAddWindowClass "DFRichEditCtrl"          "Edit"
80005>>>        Send ComAddWindowClass "DFcombobox"              "ComboBox"
80006>>>        Send ComAddWindowClass "DFformlist"              "Edit"
80007>>>        Send ComAddWindowClass "DFFormListHeader"        "SysHeader32"
80008>>>        Send ComAddWindowClass "DFbutton"                "Button"
80009>>>        Send ComAddWindowClass "HPromptBtn"              "Button"
80010>>>        Send ComAddWindowClass "Hspinbtn"                "msctls_updown32"
80011>>>        Send ComAddWindowClass "DFSysTabControl32"       "SysTabControl32"
80012>>>        Send ComAddWindowClass "DFMDIClient"             "MDIClient" 
80013>>>        Send ComAddWindowClass "DFedit"                  "edit"
80014>>>        Send ComAddWindowClass "DFlistedit"              "edit"
80015>>>        Send ComAddWindowClass "DFscrollbar"             "scrollbar"
80016>>>        Send ComAddWindowClass "DFgroup"                 "Button"
80017>>>        Send ComAddWindowClass "DFComboGrid"             "ComboBox"
80018>>>        // External class
80018>>>        Send ComAddWindowClass "cVdfAnimation"           "SysAnimate32"
80019>>>        Send ComAddWindowClass "cVdfProgressBar"         "msctls_progress32"
80020>>>        Send ComAddWindowClass "cVdfStatusBar"           "msctls_statusbar32"
80021>>>        Send ComAddWindowClass "cVdfToolbar"             "ToolbarWindow32"
80022>>>        Send ComAddWindowClass "cObsoleteVdfProgressBar" "msctls_progress32"
80023>>>        Send ComAddWindowClass "cVdfTrackBar"            "msctls_trackbar32"
80024>>>        Send ComAddWindowClass "cObsoleteBasicStatusBar" "msctls_statusbar32"
80025>>>        Send ComAddWindowClass "cVdfTreeView"            "SysTreeView32"
80026>>>    End_Procedure
80027>>>    
80027>>>    // Used to support developer designed class mappings (e.g. COM controls)
80027>>>    Procedure OnAddCustomWindowClasses
80029>>>    End_Procedure
80030>>>
80030>>>    // called when object is created during end_construct_object.
80030>>>    Procedure OnCreate
80032>>>        Integer iOpts
80032>>>        Boolean bUseWindowsFont
80032>>>        Forward Send OnCreate
80034>>>        
80034>>>        // if we are using the windows fonts we will disable the apply metrics which
80034>>>        // never really looked good anyway. This test only exists or legacy purposes
80034>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
80035>>>        If bUseWindowsFont Begin
80037>>>            Get ComApplyOptions to iOpts
80038>>>            Set ComApplyOptions to (RemoveBitValue(xtpSkinApplyMetrics, iOpts))
80039>>>        End
80039>>>>
80039>>>
80039>>>        // this works around a CJ issue where skins applied to other threads causes an exception upon close down. 
80039>>>        // We saw this with our mssql driver but it could occur elsewhere. This has been reported in the CJ newsgroup
80039>>>        // and this was the suggested workaround.
80039>>>        Set ComAutoApplyNewThreads to False
80040>>>
80040>>>        Send OnAddVDFWindowClasses
80041>>>        Send OnAddCustomWindowClasses
80042>>>        
80042>>>        // if preferences are used, it will set psSkinFile and psSkinIni
80042>>>        If (pbLoadPreference(Self)) Begin
80044>>>            Send LoadSkinPreference
80045>>>        End
80045>>>>
80045>>>        // if a skin file name exists, we apply the skin.    
80045>>>        If (psSkinFile(Self)<>"") Begin
80047>>>            Send ApplySkin
80048>>>        End        
80048>>>>
80048>>>    End_Procedure
80049>>>    
80049>>>    // called by framework as part of application exit.
80049>>>    Procedure Broadcast_Notify_Exit_Application
80051>>>        Send Notify_Exit_Application
80052>>>    End_Procedure // Notify_Exit_Application
80053>>>
80053>>>    Procedure Notify_Exit_Application
80055>>>        If (pbLoadPreference(Self)) Begin
80057>>>            Send SaveSkinPreference
80058>>>        End
80058>>>>
80058>>>    End_Procedure
80059>>>
80059>>>    Procedure NotifyPreApplySkin
80061>>>        Broadcast Send OnPreApplySkin of Desktop True       
80063>>>    End_Procedure
80064>>>
80064>>>    Procedure NotifyPostApplySkin
80066>>>        Broadcast Send OnPostApplySkin of Desktop True       
80068>>>    End_Procedure
80069>>>    
80069>>>    // returns an array of all skins in the path. If path is "", use the default path.
80069>>>    // If the default path is used, returns the file names as relative names, else use full path.
80069>>>    Function EnumerateSkins String sPath Boolean bRecursive Returns tSkinInformation[]
80071>>>        tSkinInformation[] Skins
80071>>>        tSkinInformation[] Skins
80072>>>        String sSkinName sSkinFile sDefaultPath sSep
80072>>>        Variant vSkinDescriptions vSkinDescription vSkinIniFile
80072>>>        Handle hSkinDescriptions hSkinDescription hSkinIniFile
80072>>>        Integer iSkinsCount iSkinFilesCount iNumSkins iNumSkinFiles iArrayItem
80072>>>        Integer iPos iDfltLen
80072>>>        Boolean bUseRelativePath
80072>>>        
80072>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
80073>>>        
80073>>>        Get SkinPath to sDefaultPath
80074>>>        If (sPath="") Begin
80076>>>            Move sDefaultPath to sPath
80077>>>        End
80077>>>>
80077>>>        Move (Uppercase(sDefaultPath)) to sDefaultPath
80078>>>        Move (Length(sDefaultPath)) to iDfltLen
80079>>>        Move (sDefaultPath=Uppercase(sPath)) to bUseRelativePath
80080>>>
80080>>>        Get ComEnumerateSkinDirectory sPath bRecursive to vSkinDescriptions
80081>>>        If (not(IsNullComObject(vSkinDescriptions))) Begin
80083>>>
80083>>>            Get Create U_cCJSkinDescriptions to hSkinDescriptions
80084>>>            Get Create U_cCJSkinDescription to hSkinDescription
80085>>>            Get Create U_cCJSkinIniFile to hSkinIniFile
80086>>>            
80086>>>            Set pvComObject of hSkinDescriptions to vSkinDescriptions
80087>>>            Get ComCount of hSkinDescriptions to iNumSkinFiles
80088>>>            
80088>>>            For iSkinFilesCount from 0 to (iNumSkinFiles-1)
80094>>>>
80094>>>                Get ComSkin of hSkinDescriptions iSkinFilesCount to vSkinDescription
80095>>>                Set pvComObject of hSkinDescription to vSkinDescription
80096>>>
80096>>>                Get ComCount of hSkinDescription to iNumSkins
80097>>>                    
80097>>>                For iSkinsCount from 0 to (iNumSkins-1)
80103>>>>
80103>>>                    Get ComIniFile of hSkinDescription iSkinsCount to vSkinIniFile
80104>>>                    Set pvComObject of hSkinIniFile to vSkinIniFile
80105>>>
80105>>>                    Get ComName of hSkinDescription to Skins[iArrayItem].sName
80106>>>                    Get ComPath of hSkinDescription to sSkinFile
80107>>>                    If bUseRelativePath Begin
80109>>>                        Move (pos(sDefaultPath,uppercase(sSkinFile))) to iPos
80110>>>                        If iPos Begin
80112>>>                            Move (Remove(sSkinFile,iPos,iDfltLen)) to sSkinFile   
80113>>>                            While (Left(sSkinFile,1)=sSep)
80117>>>                                Move (Remove(sSkinFile,1,1)) to sSkinFile   
80118>>>                            Loop                         
80119>>>>
80119>>>                        End
80119>>>>
80119>>>                    End
80119>>>>
80119>>>                    Move sSkinFile to Skins[iArrayItem].sSkinfile
80120>>>                    Get ComIniFileName of hSkinIniFile to Skins[iArrayItem].sSkinIni
80121>>>
80121>>>                    Increment iArrayItem
80122>>>                Loop
80123>>>>
80123>>>            Loop
80124>>>>
80124>>>                            
80124>>>            Send Destroy of hSkinDescriptions
80125>>>            Send Destroy of hSkinDescription
80126>>>            Send Destroy of hSkinIniFile
80127>>>                
80127>>>        End
80127>>>>
80127>>>        Function_Return Skins
80128>>>    End_Function 
80129>>>    
80129>>>    // Save the skin preference. This requires an application object.
80129>>>    // Only do this if the application object allows it. 
80129>>>    // This is called during startup if pbLoadPreference is True
80129>>>    // Suitable for override
80129>>>    Procedure SaveSkinPreference 
80131>>>        String sSkin sIni
80131>>>        If ghoApplication Begin
80133>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
80135>>>                Get psSkinFile to sSkin
80136>>>                Get psSkinIni to sIni
80137>>>                Send WriteString of ghoApplication "Preferences" "SkinFile" sSkin
80138>>>                Send WriteString of ghoApplication "Preferences" "SkinIni" sIni
80139>>>            End
80139>>>>
80139>>>        End
80139>>>>
80139>>>        Else Begin
80140>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
80141>>>>
80141>>>        End
80141>>>>
80141>>>    End_Procedure
80142>>>
80142>>>    // Load the skin preference. This requires an application object.
80142>>>    // Only do this if the application object allows it. 
80142>>>    // This is called during startup if pbLoadPreference is True
80142>>>    // Suitable for override
80142>>>    Procedure LoadSkinPreference 
80144>>>        String sSkin sIni
80144>>>        Boolean bExists
80144>>>        If ghoApplication Begin
80146>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
80148>>>                Get ValueExists of ghoApplication "Preferences" "SkinFile" to bExists
80149>>>                If bExists Begin
80151>>>                    Get ReadString of ghoApplication "Preferences" "SkinFile" "" to sSkin
80152>>>                    Get ReadString of ghoApplication "Preferences" "SkinIni" "" to sIni
80153>>>                    Set psSkinFile to sSkin
80154>>>                    Set psSkinIni to sIni
80155>>>                End
80155>>>>
80155>>>            End
80155>>>>
80155>>>        End
80155>>>>
80155>>>        Else Begin
80156>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
80157>>>>
80157>>>        End
80157>>>>
80157>>>    End_Procedure
80158>>>
80158>>>    // Can be called to apply the current skin.
80158>>>    Procedure ApplySkin
80160>>>        Boolean bOk
80160>>>        String sSkin sIni
80160>>>        If (IsComObjectCreated(Self)) Begin
80162>>>            Get SkinQFile to sSkin
80163>>>            Get psSkinIni to sIni
80164>>>            
80164>>>            Send NotifyPreApplySkin
80165>>>            // when skins are used we don't want to use built in Visual Styles
80165>>>            Send EnableVisualStyles of Desktop (sSkin="")
80166>>>            Get ComLoadSkin sSkin sIni to bOK
80167>>>            If (sSkin<>"" and not(bOk)) Begin
80169>>>                // if not ok, no skin was appied. Enable visual styles
80169>>>                Send EnableVisualStyles of Desktop True
80170>>>            End
80170>>>>
80170>>>            Send NotifyPostApplySkin
80171>>>        End
80171>>>>
80171>>>    End_Procedure
80172>>>
80172>>>
80172>>>End_Class
80173>
80173>Object oHtmlHelp is a cHtmlHelp
80175>    Set pbAlwaysOnTop to False
80176>
80176>    // Overriden class message to also handle internet HTML Help links;
80176>    // which in which case we should not try to find the path to the help file.
80176>    Function GetHelpFile Returns String
80179>        String sHelpFile
80179>
80179>        Get psHelpFile of ghoApplication to sHelpFile
80180>        If (sHelpFile <> "" and not(sHelpFile contains "http:")) Begin
80182>            Get_File_Path sHelpFile to sHelpFile
80183>        End
80183>        Function_Return sHelpFile
80184>    End_Function
80185>
80185>End_Object
80186>
80186>Object oApplication is a cApplication
80188>    Set peHelpType to htHtmlHelp
80189>
80189>    // Note: These help file settings gets changed by the Help toolbar button(s).
80189>    Set psHelpFile to "DataFlex.chm"  //"Developer5.chm"
80190>//    Set psHelpFile to "http://www.rdctools.com/HTMLHelp/Developer5.htm"
80190>
80190>    Set pbPreserveEnvironment to True
80191>    Set psProduct to "Database Update Framework Lab"
80192>    Set psCompany to "RDC Tools International"
80193>
80193>    // DF 19 and up.
80193>
80193>End_Object
80194>
80194>// Unmark the following line if using Mertech drivers!
80194>Define DUF_Use_Mertech_Drivers
80194>
80194>Object oCJSkinFramework is a cCJSkinFramework
80196>    Set pbLoadPreference to True
80197>End_Object
80198>
80198>Object oToolTipController is a cToolTipController
80200>    Set piDurationPopup to 10000
80201>    Set piMaxWidth to 500
80202>    Move Self to ghoToolTipController
80203>End_Object
80204>
80204>Use oEditContextMenu.pkg
Including file: oEditContextMenu.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\oEditContextMenu.pkg)
80204>>>Use cCJStandardMenuItemClasses.pkg
80204>>>
80204>>>Object oEditContextMenu is a cCJContextMenu
80206>>>    
80206>>>    Move Self to Default_Form_Floating_Menu_ID
80207>>>    
80207>>>    Object oUndoMenuItem is a cCJUndoMenuItem
80209>>>    End_Object
80210>>>    
80210>>>    Object oCutMenuItem is a cCJCutMenuItem
80212>>>        Set pbControlBeginGroup to True
80213>>>    End_Object
80214>>>    
80214>>>    Object oCopyMenuItem is a cCJCopyMenuItem
80216>>>    End_Object
80217>>>
80217>>>    Object oPasteMenuItem is a cCJPasteMenuItem
80219>>>    End_Object
80220>>>
80220>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
80222>>>    End_Object
80223>>>
80223>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
80225>>>        Set pbControlBeginGroup to True
80226>>>    End_Object
80227>>>
80227>>>End_Object
80228>>>
80228>Use oDEOEditContextMenu17.pkg
Including file: oDEOEditContextMenu17.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\oDEOEditContextMenu17.pkg)
80228>>>Use Windows.pkg
80228>>>Use cCJStandardMenuItemClasses.pkg
80228>>>Use cCJDeoMenuItemClasses.pkg
80228>>>
80228>>>
80228>>>Object oDEOEditContextMenu17 is a cCJContextMenu
80230>>>    
80230>>>    Move Self to Default_dbFloating_Menu_ID
80231>>>    
80231>>>    Object oUndoMenuItem is a cCJUndoMenuItem
80233>>>    End_Object
80234>>>    
80234>>>    Object oCutMenuItem is a cCJCutMenuItem
80236>>>        Set pbControlBeginGroup to True
80237>>>    End_Object
80238>>>    
80238>>>    Object oCopyMenuItem is a cCJCopyMenuItem
80240>>>    End_Object
80241>>>
80241>>>    Object oPasteMenuItem is a cCJPasteMenuItem
80243>>>    End_Object
80244>>>
80244>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
80246>>>    End_Object
80247>>>
80247>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
80249>>>        Set pbControlBeginGroup to True
80250>>>    End_Object
80251>>>
80251>>>    Object oPromptMenuItem is a cCJPromptMenuItem
80253>>>        Set pbControlBeginGroup to True
80254>>>    End_Object
80255>>>
80255>>>    Object oFindNextMenu is a cCJFindNextMenuItem
80257>>>        Set pbControlBeginGroup to True
80258>>>    End_Object
80259>>>
80259>>>    Object oFindPreviousMenu is a cCJFindPreviousMenuItem
80261>>>    End_Object
80262>>>
80262>>>    Object oClearMenuItem is a cCJClearMenuItem
80264>>>        Set pbControlBeginGroup to True
80265>>>    End_Object
80266>>>
80266>>>    Object oClearAllMenu is a cCJClearAllMenuItem
80268>>>    End_Object
80269>>>
80269>>>    Object oSaveMenu is a cCJSaveMenuItem
80271>>>    End_Object
80272>>>    
80272>>>    Object oDeleteMenu is a cCJDeleteMenuItem
80274>>>    End_Object
80275>>>
80275>>>    Object oRememberitem is a cCJRememberFieldMenuItem
80277>>>        Set pbControlBeginGroup to True
80278>>>    End_Object
80279>>>
80279>>>    Object oRetainItem is a cCJRememberLastFieldMenuItem
80281>>>    End_Object
80282>>>
80282>>>    Object oUnRememberitem is a cCJUnRememberFieldMenuItem
80284>>>    End_Object
80285>>>
80285>>>    Object oCJClearAllDynamicDefaults is a cCJUnRememberFieldAllMenuItem
80287>>>    End_Object
80288>>>
80288>>>End_Object
80289>Use cSkinComboBoxCJMenuItem.pkg
Including file: cSkinComboBoxCJMenuItem.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cSkinComboBoxCJMenuItem.pkg)
80289>>>Use cCJCommandBarSystem.pkg
80289>>>Use cCJSkinFramework.pkg
80289>>>Use Wingdi.pkg
80289>>>
80289>>>
80289>>>Define CS_NoSkinShort for "-None"
80289>>>Define CS_NoSkinLong  for "Do not use a skin"
80289>>>
80289>>>Class cSkinComboBoxCJMenuItem is a cCJMenuItem
80290>>>
80290>>>    Procedure Construct_Object
80292>>>        Forward Send Construct_Object
80294>>>
80294>>>        Set peControlType to xtpControlComboBox
80295>>>
80295>>>        Property tSkinInformation[] pSkins
80296>>>
80296>>>    End_Procedure
80297>>>
80297>>>    Procedure End_Construct_Object
80299>>>        Forward Send End_Construct_Object
80301>>>    End_Procedure
80302>>>
80302>>>    // Custom array sort for the tSkinInformation struct array.
80302>>>    // Used by LoadSkins message to sort the skin array alphabetically after it has been loaded.
80302>>>    // Why?
80302>>>    // First of all, structs can't be used with the standard SortArray function, that is why we need to
80302>>>    // create a custom sort algorithm.
80302>>>    // Secondly the list of skins would else be sorted in the alphabetical order by the file names.
80302>>>    // However, it is not always the case that the skin description (sName) is the same as the file name.
80302>>>    // If it isn't (which is almost always the case if you have many skin files) the list will look
80302>>>    // randomly ordered. This custom sort method will take care of that.
80302>>>    Function SkinSort tSkinInformation sDescription tSkinInformation sSearchDescription Returns Integer
80304>>>        If ((sDescription.sName * sDescription.sSkinIni) > (sSearchDescription.sName * sSearchDescription.sSkinIni)) Function_Return (GT)
80307>>>        If ((sDescription.sName * sDescription.sSkinIni) < (sSearchDescription.sName * sSearchDescription.sSkinIni)) Function_Return (LT)
80310>>>        Function_Return (EQ)
80311>>>    End_Function
80312>>>
80312>>>    Procedure OnCreateControl Handle hoObj
80314>>>        Forward Send OnCreateControl hoObj
80316>>>
80316>>>        Set ComDropDownWidth of hoObj to 150
80317>>>        Set ComWidth         of hoObj to 150
80318>>>        Send LoadSkins
80319>>>        Send FillComboList hoObj
80320>>>    End_Procedure
80321>>>
80321>>>    // Load all skins. We will only look for skins in expected
80321>>>    // directory which is the Programs folder.
80321>>>    // Important: When loading skins they will be sorted alphabetically. (See Skinsort function above).
80321>>>    // This is not the case with the 'standard' VDF behaviour.
80321>>>    Procedure LoadSkins
80323>>>        Integer iCount iItems iSize
80323>>>        Boolean bFound
80323>>>        String sFile sIni sSkin
80323>>>        tSkinInformation[] SkinsArray SkinsArrayNoLarge
80323>>>        tSkinInformation[] SkinsArray SkinsArrayNoLarge
80325>>>        tSkinInformation NoneRow
80325>>>        tSkinInformation NoneRow
80325>>>
80325>>>        If (ghoSkinFramework > 0) Begin
80327>>>            Get EnumerateSkins of ghoSkinFramework "" True   to SkinsArray
80328>>>
80328>>>            Move (SortArray(SkinsArray, Self, get_SkinSort)) to SkinsArray
80329>>>            Move CS_NoSkinShort to NoneRow.sName
80330>>>            Move CS_NoSkinLong  to NoneRow.sSkinfile
80331>>>            Move CS_NoSkinLong  to NoneRow.sSkinIni
80332>>>            Move (InsertInArray(SkinsArray, 0, NoneRow))     to SkinsArray
80333>>>
80333>>>            // Get the currently loaded skin.
80333>>>            Get psSkinFile of ghoSkinFramework to sFile
80334>>>            Get psSkinIni  of ghoSkinFramework to sIni
80335>>>
80335>>>            // Remove all Extra Large and Large skins from the array.
80335>>>            Move (SizeOfArray(SkinsArray)) to iItems
80336>>>            Decrement iItems
80337>>>            For iCount from 0 to iItems
80343>>>>
80343>>>                Move SkinsArray[iCount].sSkinIni to sSkin
80344>>>                Move (Uppercase(sSkin) contains " LARGE") to bFound
80345>>>                If (bFound = False) Begin
80347>>>                    Move (SizeOfArray(SkinsArrayNoLarge)) to iSize
80348>>>                    Move SkinsArray[iCount].sName         to SkinsArrayNoLarge[iSize].sName
80349>>>                    Move SkinsArray[iCount].sSkinfile     to SkinsArrayNoLarge[iSize].sSkinfile
80350>>>                    Move SkinsArray[iCount].sSkinIni      to SkinsArrayNoLarge[iSize].sSkinIni
80351>>>                End
80351>>>>
80351>>>            Loop
80352>>>>
80352>>>            Set pSkins to SkinsArrayNoLarge
80353>>>        End
80353>>>>
80353>>>    End_Procedure
80354>>>
80354>>>    // Fills the CodeJock combobox with all skins from the current Programs folder.
80354>>>    Procedure FillComboList Handle hoCombo
80356>>>        Integer iCount iItems iCurrent iTxtEntentSize
80356>>>        String  sFile sIni sCurrSkin
80356>>>        String  sSkin sSkinText
80356>>>        tSkinInformation[] SkinsArray
80356>>>        tSkinInformation[] SkinsArray
80357>>>        Integer iSize
80357>>>
80357>>>        If (ghoSkinFramework < 1) Procedure_Return
80360>>>
80360>>>        // Get the currently loaded skin.
80360>>>        Get psSkinFile of ghoSkinFramework to sFile
80361>>>        Get psSkinIni  of ghoSkinFramework to sIni
80362>>>        Get pSkins to SkinsArray
80363>>>        Move (SizeOfArray(SkinsArray)) to iItems
80364>>>        Decrement iItems
80365>>>        Send ComClear of hoCombo
80366>>>
80366>>>        For iCount from 0 to iItems
80372>>>>
80372>>>            Move SkinsArray[iCount].sSkinIni  to sSkin
80373>>>            Move (Replace(".ini", sSkin, "")) to sSkin
80374>>>            Move (SkinsArray[iCount].sName * "-" * sSkin) to sSkinText
80375>>>            Send ComAddItem of hoCombo sSkinText (iCount +1)
80376>>>            Get Text_Extent sSkinText to iSize
80377>>>            If (iSize > iTxtEntentSize) Begin
80379>>>                Move iSize to iTxtEntentSize
80380>>>            End
80380>>>>
80380>>>            Move (SkinsArray[iCount].sSkinFile * "-" * SkinsArray[iCount].sSkinIni) to sCurrSkin
80381>>>            If (sCurrSkin = (sFile * "-" * sIni)) Begin
80383>>>                Move iCount to iCurrent
80384>>>            End
80384>>>>
80384>>>        Loop
80385>>>>
80385>>>
80385>>>        Move (Low(iTxtEntentSize) + 30)  to iSize
80386>>>        Set ComDropDownWidth of hoCombo  to iSize
80387>>>        Set ComWidth         of hoCombo  to iSize
80388>>>        Set ComListIndex     of hoCombo  to (iCurrent +1)
80389>>>    End_Procedure
80390>>>
80390>>>    // Event for when an item is selected from the comboform
80390>>>    Procedure OnExecute Variant vCommandBarControl
80392>>>        Handle  hoCombo
80392>>>        Integer iSelection
80392>>>        String  sSkinFile sSkinIni
80392>>>        tSkinInformation[] SkinsArray
80392>>>        tSkinInformation[] SkinsArray
80393>>>
80393>>>        // Create and bind proxy control
80393>>>        Get CreateProxyControl vCommandBarControl to hoCombo
80394>>>        // Get the current selection
80394>>>        Get ComListIndex of hoCombo to iSelection
80395>>>        Decrement iSelection
80396>>>        Get pSkins to SkinsArray
80397>>>        Move SkinsArray[iSelection].sSkinfile to sSkinFile
80398>>>        Move SkinsArray[iSelection].sSkinIni  to sSkinIni
80399>>>
80399>>>        Send DoChangeSkin sSkinFile sSkinIni
80400>>>
80400>>>        // Dispose of the proxy control
80400>>>        Send Destroy of hoCombo
80401>>>    End_Procedure
80402>>>
80402>>>    // Send this message to change the current skin.
80402>>>    Procedure DoChangeSkin String sSkinFile String sSkinIni
80404>>>        Handle hoClient
80404>>>
80404>>>        Set psSkinFile of ghoSkinFramework to sSkinFile
80405>>>        Set psSkinIni  of ghoSkinFramework to sSkinIni
80406>>>        Send ApplySkin of ghoSkinFramework
80407>>>
80407>>>        // Note: The following line is essential for the resizing logic
80407>>>        // to function properly when changing a skin and a view is maximized.
80407>>>        Move (Client_Id(phoMainPanel(ghoApplication))) to hoClient
80408>>>        Set Size of hoClient to (Hi(Size(hoClient))) (Low(Size(hoClient) +2))
80409>>>        Set Size of hoClient to (Hi(Size(hoClient))) (Low(Size(hoClient) -2))
80410>>>    End_Procedure
80411>>>
80411>>>    // Returns: DPI setting as an integer.
80411>>>    //  Normal DPI setting: iDPI=96  is "Normal setting" 100%
80411>>>    //                      iDPI=120 is "Medium setting" 125%
80411>>>    //                      iDPI= 144 is "Large setting" 150%
80411>>>    Function GetCurrentDPI Returns Integer
80413>>>        Handle hDC
80413>>>        Integer iPixelsX
80413>>>        Move (GetDC(0)) to hDC
80414>>>        Move (GetDeviceCaps(hDC, LOGPIXELSX)) to iPixelsX
80415>>>        Move (ReleaseDC(0, hDC)) to hDC
80416>>>        Function_Return iPixelsX
80417>>>    End_Function
80418>>>
80418>>>End_Class
80419>
80419>Object oMain is a Panel
80421>    Set Label to "Test Program - The Database Update Framework"
80422>    Set Location to 2 2
80423>    Set Size to 356 493
80424>    Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
80425>    Set Icon to "DbUpdateFrameworkDF19.ico"
80426>
80426>    Property Handle phoViewMenu 0
80428>    Property Handle phoReportMenu 0
80430>
80430>    Object oCommandBarSystem is a cCJCommandBarSystem
80432>        Set pbTimerUpdate to True
80433>            Set pbAutoResizeIcons to True
80434>            Set pbTabbedWorkspaces to True // Switch on for DF 19 to see the new tabbed-view look.
80435>            Set peVisualTheme to xtpThemeVisualStudio2008
80436>
80436>        Procedure OnCreateCommandBars
80439>            Forward Send OnCreateCommandBars
80441>        End_Procedure
80442>
80442>
80442>        Procedure OnCreateTabbedWorkspace Handle hoTabWorkspace Handle hoTabPaintManager
80445>            Set ComShowIcons of hoTabPaintManager to True
80446>            Send ComSetIconSize of hoTabPaintManager 24 24
80447>
80447>            // This will truncate the middle part of long items
80447>            Set ComDrawTextPathEllipsis of hoTabPaintManager to True
80448>        End_Procedure
80449>
80449>        // This is needed to get the "Key_Shift+Key_Tab" key combination to activate
80449>        // the previous tab workspace view.
80449>        Object oPreviousTabAction is a cCJAction
80451>            Set piShortCutKey to (xtpKey_Shift + xtpKey_Ctrl) VK_TAB
80452>            Procedure OnExecute Variant vCommandBarControl
80455>                Handle hoCommandBars hoClientArea
80455>                Forward Send OnExecute vCommandBarControl
80457>                Get CommandBarSystemObject to hoCommandBars
80458>                Get ClientAreaObject of hoCommandBars to hoClientArea
80459>                If hoClientArea Begin
80461>                    Send Switch_Next_View of hoClientArea
80462>                End
80462>            End_Procedure
80463>        End_Object
80464>
80464>        Object oToolBar is a cCJToolbar
80466>            Set psTitle to "Edit Toolbar"
80467>            Set pbGripper to False
80468>            Set peStretched to stStretch
80469>
80469>            Object oCutToolbarItem is a cCJCutMenuItem
80471>            End_Object
80472>
80472>            Object oCopyToolbarItem is a cCJCopyMenuItem
80474>            End_Object
80475>
80475>            Object oPasteToolbarItem is a cCJPasteMenuItem
80477>            End_Object
80478>
80478>            Object oDeleteEditToolbarItem is a cCJDeleteEditMenuItem
80480>                Set pbControlBeginGroup to True
80481>            End_Object
80482>
80482>            Object oTheme_tb is a cCJMenuItem
80484>                Set peControlType to xtpControlLabel
80485>                Set psCaption to "Theme:"
80486>                Set pbControlBeginGroup to True
80487>            End_Object
80488>
80488>            Object oThemeItem is a cCJMenuItem
80490>                Set peControlType to xtpControlComboBox
80491>                Set psToolTip to "Select a theme to change the appearance of menu- and toolbars."
80492>
80492>                Procedure OnCreateControl Handle hoObj
80495>                    Integer iItem eTheme
80495>                    Set ComWidth of hoObj to 250
80496>                    Send FillComboList hoObj
80497>                    Get peVisualTheme to eTheme
80498>                    Get FindDataItem hoObj eTheme to iItem
80499>                    Set ComListIndex of hoObj to (If(iItem,iItem,1))
80500>                End_Procedure
80501>
80501>                Function FindDataItem Handle hoCombo Integer eVal Returns Integer
80504>                    Integer iCount i eTheme
80504>                    Get ComListCount of hoCombo to iCount
80505>                    For i from 1 to iCount
80511>                        Get ComItemData of hoCombo i to eTheme
80512>                        If (eTheme=eVal) Begin
80514>                            Send SetTheTheme eTheme
80515>                            Function_Return i
80516>                        End
80516>                    Loop
80517>                    Function_Return 0
80518>                End_Function
80519>
80519>                Procedure AddTheme Handle hoCombo String sText Integer eTheme
80522>                    Integer iCount
80522>                    Get ComListCount of hoCombo to iCount
80523>                    Increment iCount
80524>                    Send ComAddItem  of hoCombo sText iCount
80525>                    Set ComItemData  of hoCombo iCount to  eTheme
80526>                End_Procedure
80527>
80527>                Procedure FillComboList Handle hoCombo
80530>                    Send ComClear     of hoCombo
80531>
80531>                    Send AddTheme hoCombo "xtpThemeOffice2013Word" xtpThemeOffice2013Word
80532>                    Send AddTheme hoCombo "xtpThemeOffice2013Outlook" xtpThemeOffice2013Outlook
80533>                    Send AddTheme hoCombo "xtpThemeOffice2013Excel" xtpThemeOffice2013Excel
80534>                    Send AddTheme hoCombo "xtpThemeOffice2013PowerPoint" xtpThemeOffice2013PowerPoint
80535>                    Send AddTheme hoCombo "xtpThemeOffice2013Publisher" xtpThemeOffice2013Publisher
80536>                    Send AddTheme hoCombo "xtpThemeOffice2013OneNote" xtpThemeOffice2013OneNote
80537>                    Send AddTheme hoCombo "xtpThemeOffice2013Access" xtpThemeOffice2013Access
80538>                    Send AddTheme hoCombo "xtpThemeOffice2003" xtpThemeOffice2003
80539>                    Send AddTheme hoCombo "xtpThemeOffice2000" xtpThemeOffice2000
80540>                    Send AddTheme hoCombo "xtpThemeOfficeXP" xtpThemeOfficeXP
80541>
80541>                    Send AddTheme hoCombo "xtpThemeOffice2010Blue" xtpThemeOffice2010Blue
80542>                    Send AddTheme hoCombo "xtpThemeOffice2010Black" xtpThemeOffice2010Black
80543>                    Send AddTheme hoCombo "xtpThemeOffice2010Silver" xtpThemeOffice2010Silver
80544>
80544>                    Send AddTheme hoCombo "xtpThemeOffice2007Aqua" xtpThemeOffice2007Aqua
80545>                    Send AddTheme hoCombo "xtpThemeOffice2007Black" xtpThemeOffice2007Black
80546>                    Send AddTheme hoCombo "xtpThemeOffice2007Blue" xtpThemeOffice2007Blue
80547>                    Send AddTheme hoCombo "xtpThemeOffice2007Silver" xtpThemeOffice2007Silver
80548>
80548>                    Send AddTheme hoCombo "xtpThemeVisualStudio2015Blue" xtpThemeVisualStudio2015Blue
80549>                    Send AddTheme hoCombo "xtpThemeVisualStudio2015Light" xtpThemeVisualStudio2015Light
80550>                    Send AddTheme hoCombo "xtpThemeVisualStudio2015Dark" xtpThemeVisualStudio2015Dark
80551>
80551>                    Send AddTheme hoCombo "xtpThemeVisualStudio2012Light" xtpThemeVisualStudio2012Light
80552>                    Send AddTheme hoCombo "xtpThemeVisualStudio2012Dark" xtpThemeVisualStudio2012Dark
80553>
80553>                    Send AddTheme hoCombo "xtpThemeVisualStudio2008" xtpThemeVisualStudio2008
80554>                    Send AddTheme hoCombo "xtpThemeVisualStudio6" xtpThemeVisualStudio6
80555>
80555>                    Send AddTheme hoCombo "xtpThemeWindows7" xtpThemeWindows7
80556>
80556>                    Send AddTheme hoCombo "xtpThemeWhidbey" xtpThemeWhidbey
80557>
80557>                    Send AddTheme hoCombo "xtpThemeNativeWinXP" xtpThemeNativeWinXP
80558>                End_Procedure
80559>
80559>                Function CurrentTheme Handle vCommandBarControl Returns Integer
80562>                    Handle hMessage hoCombo
80562>                    Integer iIndex
80562>                    // create and bind  proxy control
80562>                    Get CreateProxyControl vCommandBarControl to hoCombo
80563>                    // get the current selection
80563>                    Get ComListIndex of hoCombo to iIndex
80564>                    // note the index selections are 1 based
80564>                    If (iIndex > 0) Begin
80566>                        // get the ItemData for the selected item and send that message
80566>                        Get ComItemData of hoCombo iIndex to hMessage
80567>                        Function_Return hMessage
80568>                    End
80568>                    // dispose of the proxy control
80568>                    Send Destroy of hoCombo
80569>                End_Function
80570>
80570>                Procedure OnExecute Variant vCommandBarControl
80573>                    Integer eTheme
80573>                    Integer iColor
80573>                    Get CurrentTheme vCommandBarControl to eTheme
80574>                    Set peVisualTheme of ghoCommandBars to eTheme
80575>                    Send ComRecalcLayout of ghoCommandBars
80576>                    Get ComGetSpecialColor of ghoCommandBars XPCOLOR_TOOLBAR_FACE to iColor
80577>                    Broadcast Recursive Set Color of (Client_Id(phoMainPanel(ghoApplication))) to iColor
80579>                End_Procedure
80580>
80580>                Procedure SetTheTheme Integer eTheme
80583>                    Integer iColor
80583>                    Set peVisualTheme of ghoCommandBars to eTheme
80584>                    Send ComRecalcLayout of ghoCommandBars
80585>                    Get ComGetSpecialColor of ghoCommandBars XPCOLOR_TOOLBAR_FACE to iColor
80586>                    Broadcast Recursive Set Color of (Client_Id(phoMainPanel(ghoApplication))) to iColor
80588>                End_Procedure
80589>
80589>                Function ConvertSystemColor Integer iColor Returns Integer
80592>                    Integer iSysColor
80592>                    If (iColor = clDefault or iColor = clNone) Begin    // If default color then use -1
80594>                        Move clNone to iColor
80595>                    End
80595>                    Else If (iColor < 0) Begin    // If it is a system color (<0) then convert this into an RGB value
80598>                        Move (iColor iand |CI$7FFFFFFF) to iSysColor    // extract the system color constant
80599>                        Move (GetSysColor(iSysColor)) to iColor
80600>                    End
80600>                    Function_Return iColor
80601>                End_Function
80602>
80602>            End_Object
80603>
80603>            Object oSkin_tb is a cCJMenuItem
80605>                Set peControlType to xtpControlLabel
80606>                Set psCaption to "Skin:"
80607>                Set pbControlBeginGroup to True
80608>            End_Object
80609>
80609>            Object oSkinSelector_cf is a cSkinComboBoxCJMenuItem
80611>                Set psToolTip to "Select a skin to change the appearance of the application. Either select a Theme OR a Skin, not both."
80612>            End_Object
80613>
80613>
80613>            Object oAbout_MenuItem is a cCJMenuItem
80615>                Set psCaption to "About"
80616>                Set psToolTip to "About Info"
80617>                Set psDescription to "About the program"
80618>                Set psImage to "ActionAbout.ico"
80619>                Set pbControlBeginGroup to True
80620>                Procedure OnExecute Variant vCommandBarControl
80623>                    Forward Send OnExecute vCommandBarControl
80625>                    Send Activate_About of (Client_Id(ghoCommandBars))
80626>                End_Procedure
80627>            End_Object
80628>
80628>            Object oHelpMenuItem is a cCJHelpMenuItem
80630>                Set peControlType to xtpControlSplitButtonPopup
80631>
80631>                Procedure OnExecute Variant vCommandBarControl
80634>                    Forward Send OnExecute vCommandBarControl
80636>                    Set psHelpFile of ghoApplication to "DataFlex.chm"
80637>                    Send ShowProgramHelp
80638>                End_Procedure
80639>
80639>                Object oHelpMenuItemLocal is a cCJMenuItem
80641>                    Set psCaption to "Local HTML Help"
80642>                    Set psImage to "ActionHelp.ico"
80643>                    Procedure OnExecute Variant vCommandBarControl
80646>                        Set psHelpFile of ghoApplication to "DataFlex.chm"
80647>                        Send ShowProgramHelp
80648>                    End_Procedure
80649>                End_Object
80650>
80650>                Object oHelpMenuItemInternetBrowser is a cCJMenuItem
80652>                    Set psCaption to "Internet Online HTML Help"
80653>                    Set psImage to "ActionHelp.ico"
80654>                    Procedure OnExecute Variant vCommandBarControl
80657>                        Send vShellExecute "open" "http://www.rdctools.com/HTMLHelp/Developer5.htm" "" ""
80658>                    End_Procedure
80659>
80659>                End_Object
80660>            End_Object
80661>
80661>            Object oExitMenuItem is a cCJExitMenuItem
80663>                Set psImage to "ActionExitApp.ico"
80664>                Set psToolTip to "Exit application"
80665>                Set psDescription to "Exit the program (Alt+F4)"
80666>                Set pbControlBeginGroup to True
80667>            End_Object
80668>        End_Object
80669>
80669>        Object oSpacerBar is a cCJToolbar
80671>            Set pbDockNextTo to False
80672>            Set pbShowExpandButton to False
80673>            Set pbGripper to False
80674>            Set peStretched to stStretch
80675>            Set pbCustomizable to False
80676>            Set pbCloseable to False
80677>            Set pbEnableDocking to False
80678>            Set pbHideWrap to True
80679>
80679>            Object oFiller is a cCJMenuItem
80681>            End_Object
80682>
80682>        End_Object
80683>
80683>        Object oStatusBar is a cCJStatusBar
80685>
80685>            Object oStatusPane1 is a cCJStatusBarPane
80687>                Set piID to sbpIDIdlePane
80688>                Set pbStyleStretch to True
80689>            End_Object
80690>            Object oStatusPane2 is a cCJStatusBarPane
80692>                Set phoViewPane to Self
80693>                Set pbStyleStretch to True
80694>            End_Object
80695>
80695>        End_Object
80696>
80696>    End_Object
80697>
80697>    Object oClientArea is a ClientArea
80699>
80699>        Use Dd_debug.dg // This Provides access to dd debugger by pressing ctrl+d within any view. Good for debugging
Including file: Dd_debug.dg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\Dd_debug.dg)
80699>>>// dd_debug.dg - DDO debugger/inspector
80699>>>//
80699>>>// Copyright Data Access WorldWide 2003
80699>>>// John Tuohy
80699>>>//
80699>>>// By adding this to any Windows view or application (with a "use DD_Debug.dg") you can
80699>>>// inspect your DDOs and make sure they are doing what you think. To invoke this panel you
80699>>>// need to press ctrl/d (or send DebugDDs).
80699>>>//
80699>>>// As of 9.1, this also tests for sending reentrant messages to the DDO when the DDO is busy.
80699>>>// Normally, these messages are ignored - now you get an error message (so you can fix it).
80699>>>// Also, you can set a limit for number of filtered records so you can see if you are using
80699>>>// optimized and non-optimized indexes the way you think you are.
80699>>>//
80699>>>// NOTE: This package should NEVER appear in a deployed application. It is just for your
80699>>>//       own development and testing.
80699>>>
80699>>>
80699>>>
80699>>>Validate_Packages 18 0 1
80699>>>
80699>>>Define CR_LF for (Character(13)+Character(10))
80699>>>
80699>>>// This provides support for DDO Rentancy checking and for testing for
80699>>>// non-optimal finding.
80699>>>Use DD_OperationChecker.pkg
Including file: dd_OperationChecker.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\dd_OperationChecker.pkg)
80699>>>>>// dd_OperationChecker.pkg for VDF10.0
80699>>>>>//
80699>>>>>// Copyright Data Access WorldWide 2003
80699>>>>>// John Tuohy
80699>>>>>//
80699>>>>>//
80699>>>>>// One of the harder DDO errors to see is the issue of reentrancy. A number of the DDO operations are not
80699>>>>>// reentrant. When a message such as Request_Save, Request_find or Clear is sent to a DDO all DDOs are considered
80699>>>>>// to be "busy" until the operationis complete. While DDOs are busy you can not send messages to ANY other DDO in
80699>>>>>// ANY other part of your application. The file structure of DDOs and the the C structure of DDOs do not allow this.
80699>>>>>// If you do send a reentrant message while the DDOs are busy the reentrant message is ignored. Here lies the problem.
80699>>>>>// You are trying to perform some kind of DDO customization and some of these customized behaviors are ignored without
80699>>>>>// any kind of warning or error.
80699>>>>>//
80699>>>>>// The following DDO messages are non re-entrant. While any of these methods are being processed you cannot send any of these
80699>>>>>// messages to any DDOs.
80699>>>>>//
80699>>>>>//     Clear
80699>>>>>//     Clear_All
80699>>>>>//     Request_save
80699>>>>>//     Request_delete
80699>>>>>//     Request_assign
80699>>>>>//     Request_find
80699>>>>>//     Request_Superfind
80699>>>>>//     Find_by_recnum
80699>>>>>//
80699>>>>>//
80699>>>>>// This package provides diagnostic code that checks these messages and makes sure that are not trying to call them in a busy state.
80699>>>>>// Instead of the busy operation being ignored, an error will be reported. Once you see the error, you can fix it.
80699>>>>>//
80699>>>>>// In addition, there is a check built in here for non-optimal finding operations. You can set the value of giNonOptimalFindCount
80699>>>>>// to a non zero value and when a find operation filters that many recods, you will get an error.
80699>>>>>//
80699>>>>>// IMPORTANT: This is a debug package and should never be used in deployed applications. It should be used by the developer
80699>>>>>// to test their application. Once tested, the code should be removed.
80699>>>>>//
80699>>>>>// To Use
80699>>>>>// ------
80699>>>>>//
80699>>>>>// This is used as part of DD_Debug.dg. While this could be used stand-alone you really don't want to do this.
80699>>>>>//
80699>>>>>// NOTE: This can only be used with VDF9.1 or above. If you try to use this with older packages this will not compile!
80699>>>>>
80699>>>>>Validate_Packages 9 1 0
80699>>>>>Use Data_set.pkg
80699>>>>>
80699>>>>>// This variable determines of the rentrancy tests should be performed. dd_debug will use and set this
80699>>>>>Global_variable Integer gbTestRentrancy
80699>>>>>Move 1 to gbTestRentrancy
80700>>>>>
80700>>>>>// This determines how many failed finds is considered to be non-optimal. When 0, there is no check.
80700>>>>>Global_variable Integer giNonOptimalFindCount
80700>>>>>Move 0 to giNonOptimalFindCount
80701>>>>>
80701>>>>>Procedure CheckRentrancy for DataSet handle hoDD string sMessage
80703>>>>>    String sMess sVal
80703>>>>>    
80703>>>>>    If (gbTestRentrancy=0 or operation_mode=mode_waiting) Procedure_Return
80706>>>>>    
80706>>>>>    If (OPERATION_MODE=MODE_VALIDATING and Lowercase(sMessage)<>"request_save") Begin
80708>>>>>        // mode_validating is not really a non-reentrant DD function from the runtime's point of view. The DDs
80708>>>>>        // keep track of this mode. Therefore, we will let a re-entrant DD message pass through for all cases, except
80708>>>>>        // request_save because trying to perform a save while inside of a validate is most likely wrong.
80708>>>>>        Procedure_Return
80709>>>>>    End
80709>>>>>>
80709>>>>>    
80709>>>>>    Move ("DDO re-entrant operation attempted.\n\n"+;          "Message = " - sMessage - ".  Object =" - name(hoDD) -".\n"+ ;          "\nCurrent Operation_mode is " + string(operation_mode) +;          "\nCurrent Operation_origin is " + string(operation_origin) * name(operation_origin) ) to sMess
80710>>>>>    Error DFERR_PROGRAM sMess
80711>>>>>>
80711>>>>>end_procedure
80712>>>>>
80712>>>>>Procedure NonOptimalTest for DataSet  Handle hoDD string sMessage integer iOldDif integer iFile integer iIndex
80714>>>>>    string sMess
80714>>>>>    Integer iNewDif
80714>>>>>
80714>>>>>    Move (constrain_tests_count - Constrain_found_count) to iNewDif
80715>>>>>    If (iNewDif-iOldDif>giNonOptimalFindCount) Begin
80717>>>>>        Move ("Constrained Find may not be Optimized.\n\n"+;              "Message =" - sMessage - ".  Object = " - name(hoDD) -".\n"+ ;              "Test finds exceeds the limit of" * string(giNonOptimalFindCount) * "filtered records.\n" +;              "Number of records searched = " + string(iNewDif-iOldDif) + ".") to sMess
80718>>>>>        If (iFile>0) Begin
80720>>>>>            // if iFile is zero we don't don't which file is being found (i.e. Locate_next)
80720>>>>>            Move (sMess + "\nFile = " + string(iFile) + ". Index = "+ string(iIndex) + ".") to sMess
80721>>>>>        End
80721>>>>>>
80721>>>>>        Error DFERR_PROGRAM sMess
80722>>>>>>
80722>>>>>    end
80722>>>>>>
80722>>>>>end_procedure
80723>>>>>
80723>>>>>
80723>>>>>Procedure Clear for DataSet
80725>>>>>    Send CheckRentrancy self "clear"
80726>>>>>    forward send clear
80728>>>>>end_procedure
80729>>>>>
80729>>>>>Procedure Clear_All for DataSet
80731>>>>>    Send CheckRentrancy self "clear_all"
80732>>>>>    forward send clear_all
80734>>>>>end_procedure
80735>>>>>
80735>>>>>Procedure Request_Save for DataSet
80737>>>>>    Send CheckRentrancy self "request_save"
80738>>>>>    forward send request_save
80740>>>>>end_procedure
80741>>>>>
80741>>>>>Procedure Request_Delete for DataSet
80743>>>>>    Send CheckRentrancy self "request_delete"
80744>>>>>    forward send request_delete
80746>>>>>end_procedure
80747>>>>>
80747>>>>>Procedure Request_Assign for DataSet integer iFile
80749>>>>>    Send CheckRentrancy self "request_assign"
80750>>>>>    If (num_arguments=0) ;        forward send request_assign
80754>>>>>    else ;        forward send request_assign iFile
80757>>>>>end_procedure
80758>>>>>
80758>>>>>Procedure Find_By_Recnum for DataSet integer iFile integer iRecord
80760>>>>>    Send CheckRentrancy self "Find_by_recnum"
80761>>>>>    forward send Find_by_recnum iFile iRecord
80763>>>>>end_procedure
80764>>>>>
80764>>>>>Procedure Request_Find for DataSet integer iMode integer iFile integer iIndex
80766>>>>>    Integer iOldDif
80766>>>>>    Send CheckRentrancy self "request_find"
80767>>>>>    Move (constrain_tests_count - Constrain_found_count) to iOldDif
80768>>>>>    forward send request_find iMode iFile iIndex
80770>>>>>    If (giNonOptimalFindCount>0) Begin
80772>>>>>        Send NonOptimalTest self "request_find" iOldDif iFile iIndex
80773>>>>>    End
80773>>>>>>
80773>>>>>end_procedure
80774>>>>>
80774>>>>>Procedure Request_Read for DataSet integer iMode integer iFile integer iIndex
80776>>>>>    Integer iOldDif
80776>>>>>    Move (constrain_tests_count - Constrain_found_count) to iOldDif
80777>>>>>    forward send request_Read iMode iFile iIndex
80779>>>>>    If (giNonOptimalFindCount>0) Begin
80781>>>>>        Send NonOptimalTest  self "request_read" iOldDif iFile iIndex
80782>>>>>    End
80782>>>>>>
80782>>>>>end_procedure
80783>>>>>
80783>>>>>
80783>>>>>Procedure Request_Superfind for DataSet integer iMode integer iFile integer iField
80785>>>>>    Integer iOldDif
80785>>>>>    Send CheckRentrancy self "request_Superfind"
80786>>>>>    Move (constrain_tests_count - Constrain_found_count) to iOldDif
80787>>>>>    forward send Request_Superfind iMode iFile iField
80789>>>>>    If (giNonOptimalFindCount>0) Begin
80791>>>>>        Send NonOptimalTest  self "request_Superfind" iOldDif 0 0 // we don't have a file or an index
80792>>>>>    End
80792>>>>>>
80792>>>>>end_procedure
80793>>>>>
80793>>>
80793>>>Procedure EnumerateDDs for DataDictionary integer iMsg integer hId
80795>>>    Send iMsg of hID Self
80796>>>End_Procedure
80797>>>
80797>>>
80797>>>
80797>>>Use Windows.pkg
80797>>>Use dfCmbFrm.pkg
Including file: Dfcmbfrm.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\Dfcmbfrm.pkg)
80797>>>>>Use windows.pkg // this now lives here. (you don't need to ever use this). 
80797>>>Use dfTabDg.pkg
Including file: Dftabdg.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\Dftabdg.pkg)
80797>>>>>Use windows.pkg // this now lives here. (you don't need to ever use this). 
80797>>>Use DataDict.pkg
80797>>>Use cTextEdit.pkg
80797>>>
80797>>>Class cDDDebugResults is a cTextEdit
80798>>>    Procedure Construct_Object
80800>>>        Forward Send Construct_Object
80802>>>        
80802>>>        Set peAnchors to anAll
80803>>>        Set pbWrap to False
80804>>>        Set Read_Only_State to True
80805>>>        Set psTypeface to "Courier New"
80806>>>        Set FontPointHeight to 9
80807>>>        
80807>>>        Property String psEditValue ''
80808>>>    End_Procedure
80809>>>    
80809>>>    Procedure Delete_Data
80811>>>        Forward Send Delete_Data
80813>>>        
80813>>>        Set psEditValue to ''
80814>>>    End_Procedure
80815>>>    
80815>>>    Procedure Page Integer iPageObject
80817>>>        String sEditValue
80817>>>        
80817>>>        Forward Send Page iPageObject
80819>>>        If (iPageObject > 0) Begin
80821>>>            Get psEditValue to sEditValue
80822>>>            Set Value to sEditValue
80823>>>        End
80823>>>>
80823>>>    End_Procedure
80824>>>
80824>>>    Procedure Insert String sVal
80826>>>        Handle hWnd
80826>>>        String sEditValue
80826>>>        
80826>>>        Get Window_Handle to hWnd
80827>>>        If (hWnd <> 0) Begin
80829>>>            Send AppendText sVal
80830>>>        End
80830>>>>
80830>>>        Else Begin
80831>>>            Get psEditValue to sEditValue
80832>>>            Move (sEditValue + sVal) to sEditValue
80833>>>            Set psEditValue to sEditValue
80834>>>        End
80834>>>>
80834>>>    End_Procedure
80835>>>End_Class
80836>>>
80836>>>Object oDD_Debug is a ModalPanel
80838>>>
80838>>>    Property handle phoInvokingView    0
80840>>>    Property handle phoCurrentDD       0
80842>>>    Property handle phoFieldsEditId    0
80844>>>    Property Handle phoMiscEditId      0
80846>>>    Property Handle phoConstraintsEditId      0
80848>>>
80848>>>    Set Locate_mode to Center_on_screen
80849>>>    Set Border_Style to Border_Thick
80850>>>
80850>>>    On_key kCancel Send Close_Panel
80851>>>
80851>>>    Function IsRecnumTable integer iFile Returns boolean
80854>>>        Boolean bRecnumTable
80854>>>        Get_Attribute DF_FILE_RECNUM_TABLE of iFIle to bRecnumTable
80857>>>        Function_Return bRecnumTable
80858>>>    End_Function
80859>>>
80859>>>
80859>>>
80859>>>
80859>>>    Set Minimize_Icon to FALSE
80860>>>    Set Label to "Data Dictionary Inspector"
80861>>>    Set Location to 4 3
80862>>>    Set Size to 263 410
80863>>>
80863>>>
80863>>>
80863>>>
80863>>>    Object oDDCombo is a ComboForm
80865>>>
80865>>>        Set Label to "DD:"
80866>>>        Set Size to 13 103
80867>>>        Set Location to 6 19
80868>>>        Set Form_Border to 0
80869>>>        Set Label_Col_Offset to 2
80870>>>        Set Label_Justification_Mode to jMode_Right
80871>>>
80871>>>        set entry_state 0 to False
80872>>>        set combo_sort_state to false
80873>>>        Set peAnchors to anNone
80874>>>
80874>>>        Procedure AddDDs integer hDD
80877>>>            Integer iCnt
80877>>>            String sName
80877>>>            Get Combo_Item_Count to iCnt
80878>>>            Get Object_label of hDD to sName
80879>>>            Send Combo_Add_Item sName
80880>>>            Set Aux_Value of (combo_data_object(self)) iCnt to hDD
80881>>>            If (hDD=phoCurrentDD(self)) Set Value 0 to sName
80884>>>        End_procedure
80885>>>
80885>>>        Procedure Fill_List
80888>>>            Integer hVw
80888>>>            Get phoInvokingView to hVw
80889>>>            Send Combo_Delete_Data
80890>>>            Broadcast Send EnumerateDDs to hVw msg_AddDDs Self
80892>>>            //Set Value 0 to (Combo_value(self,0))
80892>>>            Send onChange
80893>>>        End_Procedure
80894>>>
80894>>>
80894>>>        Procedure onChange
80897>>>            Integer iItem hDD
80897>>>            Get combo_item_matching (value(self,0)) to iItem
80898>>>            if (iItem>=0) begin
80900>>>               Get Aux_Value of (combo_data_object(self)) iItem to hDD
80901>>>               Delegate Set phoCurrentDD to hDD
80903>>>               Delegate Send RefreshNewDD
80905>>>            end
80905>>>>
80905>>>        End_procedure
80906>>>
80906>>>    End_Object    // oDDCombo
80907>>>
80907>>>    Object oCurRec is a Form
80909>>>
80909>>>        Set Label to "Current Rec"
80910>>>        Set Size to 13 37
80911>>>        Set Location to 6 165
80912>>>        Set Label_Col_Offset to 2
80913>>>        Set Label_Justification_Mode to jMode_Right
80914>>>
80914>>>        Set numeric_mask 0 to 8 0
80915>>>        Set peAnchors to anNone
80916>>>
80916>>>        Procedure NewRec // note that this is never used.
80919>>>            Integer iRec iFile hDD
80919>>>            Get phoCurrentDD to hDD
80920>>>            if hDD Begin
80922>>>               get value 0 to iRec
80923>>>               Get Main_file of hDD to iFile
80924>>>               Set_Field_Value iFile 0 to iRec  // compatibility w/ recnum
80927>>>               send Find of hDD EQ 0
80928>>>               Send refreshAll
80929>>>            end
80929>>>>
80929>>>        End_procedure
80930>>>
80930>>>    End_Object    // oCurRec
80931>>>
80931>>>    Object oFindCurRec is a Button
80933>>>
80933>>>        Set Label to "Find"
80934>>>        Set Size to 13 20
80935>>>        Set Location to 6 205
80936>>>        Set peAnchors to anNone
80937>>>
80937>>>        Procedure OnClick
80940>>>            Integer iRec iFile hDD
80940>>>            Get phoCurrentDD to hDD
80941>>>            if hDD Begin
80943>>>               Get Main_file of hDD to iFile
80944>>>               If (IsRecnumTable(self,iFile)) begin
80946>>>                  Get value of oCurRec 0 to iRec
80947>>>                  Set_Field_Value iFile 0 to iRec // compatibility w/ recnum
80950>>>                  send Find of hDD EQ 0
80951>>>                  Send refreshAll
80952>>>               End
80952>>>>
80952>>>            end
80952>>>>
80952>>>        End_procedure
80953>>>
80953>>>    End_Object    // oFindCurRec
80954>>>
80954>>>    Object oDDRelatesTo is a ComboForm
80956>>>
80956>>>
80956>>>        Set Label to "Related To File:"
80957>>>        Set Size to 13 117
80958>>>        Set Location to 6 281
80959>>>        Set Form_Border to 0
80960>>>        Set Label_Col_Offset to 2
80961>>>        Set Label_Justification_Mode to jMode_Right
80962>>>
80962>>>        set entry_state 0 to False
80963>>>        set combo_sort_state to false
80964>>>        Set peAnchors to anNone
80965>>>
80965>>>        Procedure Fill_List
80968>>>            Integer hDD iCnt iLmt iFile hCDO iCFile
80968>>>            String sName
80968>>>            Send Combo_Delete_Data
80969>>>            Get phoCurrentDD to hDD
80970>>>            If hDD eq 0 Procedure_Return
80973>>>            Get Constrain_file of hDD to iCFile
80974>>>            Get Combo_data_object to hCDO
80975>>>            Move (server_file_count(hDD)-1) to iLmt
80976>>>            Send Combo_add_item "None"
80977>>>            Set Aux_Value of hCDO 0 to iFile
80978>>>            If iCFile eq 0 set Value 0 to "None"
80981>>>            For iCnt from 0 to iLmt
80987>>>>
80987>>>                Get Server_File of hDD iCnt to iFile
80988>>>                Get_Attribute DF_FILE_LOGICAL_NAME of iFile to sName
80991>>>                Send Combo_add_item sName
80992>>>                Set Aux_Value of hCDO (iCnt+1) to iFile
80993>>>                If iFile eq iCFile set Value 0 to sName
80996>>>            Loop
80997>>>>
80997>>>
80997>>>        End_Procedure
80998>>>
80998>>>
80998>>>        Procedure onChange
81001>>>            Integer iItem iFile hDD
81001>>>            Get phoCurrentDD to hDD
81002>>>            If (hDD=0) Procedure_Return
81005>>>            Get combo_item_matching (value(self,0)) to iItem
81006>>>            if (iItem>=0) begin
81008>>>               Get Aux_Value of (combo_data_object(self)) iItem to iFile
81009>>>               Set constrain_file of hDD to iFile
81010>>>               Send RebuildAllConstraints of hDD 
81011>>>//               Send rebuild_constraints of hDD
81011>>>               Delegate Send RefreshAll
81013>>>            end
81013>>>>
81013>>>        End_procedure
81014>>>
81014>>>    End_Object    // oDDRelatesTo
81015>>>
81015>>>    Object oShouldSave is a CheckBox
81017>>>
81017>>>        set enabled_state to False
81018>>>
81018>>>
81018>>>        Set Label to "Should Save"
81019>>>        Set Size to 10 55
81020>>>        Set Location to 22 5
81021>>>        Set peAnchors to anNone
81022>>>
81022>>>
81022>>>
81022>>>    End_Object    // oShouldSave
81023>>>
81023>>>    Object oChangedState is a CheckBox
81025>>>
81025>>>        set enabled_state to False
81026>>>
81026>>>
81026>>>        Set Label to "Changed State"
81027>>>        Set Size to 10 60
81028>>>        Set Location to 22 64
81029>>>        Set peAnchors to anNone
81030>>>
81030>>>
81030>>>
81030>>>    End_Object    // oChangedState
81031>>>
81031>>>    Object oAutoFill is a CheckBox
81033>>>        Set Label to "Auto-Fill"
81034>>>        Set Size to 10 41
81035>>>        Set Location to 22 128
81036>>>        Set peAnchors to anNone
81037>>>
81037>>>        Procedure Select_Toggling integer iItm integer bState
81040>>>            forward send select_toggling iItm bState
81042>>>            Set auto_fill_state of (phoCurrentDD(self)) to (checked_state(self))
81043>>>        End_Procedure
81044>>>
81044>>>    End_Object    // oAutoFill
81045>>>
81045>>>    Object oFillFromTop is a CheckBox
81047>>>        Set Label to "First-Rec Auto-fill"
81048>>>        Set Size to 10 71
81049>>>        Set Location to 22 172
81050>>>        Set peAnchors to anNone
81051>>>
81051>>>        Procedure Select_Toggling integer iItm integer bState
81054>>>            forward send select_toggling iItm bState
81056>>>            Set pbAutoFillFromFirst of (phoCurrentDD(self)) to (checked_state(self))
81057>>>        End_Procedure
81058>>>
81058>>>    End_Object    // oFillFromTop
81059>>>
81059>>>    Object oDDOrdering is a ComboForm
81061>>>        Set Label to "Ordering"
81062>>>        Set Size to 13 117
81063>>>        Set Location to 20 281
81064>>>        Set Form_Border to 0
81065>>>        Set Label_Col_Offset to 2
81066>>>        Set Label_Justification_Mode to jMode_Right
81067>>>
81067>>>        Set entry_state 0 to False
81068>>>        Set combo_sort_state to false
81069>>>        Set peAnchors to anNone
81070>>>
81070>>>        Procedure RefreshNewDD
81073>>>            Integer hDD iFile iSegs iNdxs i
81073>>>            Send Combo_Delete_Data
81074>>>            Get phoCurrentDD to hDD
81075>>>            If hDD Begin
81077>>>               Send Combo_Add_Item "Best.-1"
81078>>>               Send Combo_Add_Item "Index.0"
81079>>>               Get Main_file of hDD to iFile
81080>>>               Get_Attribute DF_FILE_LAST_INDEX_NUMBER of iFile to iNdxs
81083>>>               For i from 1 to iNdxs
81089>>>>
81089>>>                  Get_Attribute DF_INDEX_NUMBER_SEGMENTS of iFile i to iSegs
81092>>>                  If iSegs Send Combo_Add_Item ("Index."-string(i))
81095>>>               Loop
81096>>>>
81096>>>            End
81096>>>>
81096>>>        End_procedure
81097>>>
81097>>>        Procedure Set Ordering integer iOrdr
81100>>>           If iOrdr eq -1 Set Value 0 to "Best.-1"
81103>>>           else Set Value 0 to ("Index."-string(iOrdr))
81105>>>        end_procedure
81106>>>
81106>>>        Procedure OnChange
81109>>>            Integer hDD
81109>>>            String sVal
81109>>>            Get value 0 to sVal
81110>>>            get phoCurrentDD to hDD
81111>>>            If hDD set Ordering of hDD to (mid(sVal, 10, pos(".",sVal)+1))
81114>>>        End_procedure
81115>>>
81115>>>    End_Object    // oDDOrdering
81116>>>
81116>>>
81116>>>    Object oTD is a TabDialog
81118>>>        Set Size to 149 389
81119>>>        Set Location to 33 11
81120>>>        Set Rotate_Mode to RM_Rotate
81121>>>        Set peAnchors to anAll
81122>>>
81122>>>        Object oTP_Constraints is a TabPage
81124>>>            Set Label to "Constraints"
81125>>>            Set Tab_ToolTip_Value to "DD Constraints and Filters"
81126>>>            Delegate Set phoConstraintsEditId to Self
81128>>>            
81128>>>            Object oConstraintsEdit is a cDDDebugResults
81130>>>                Function FormatFileFieldName Integer iFile Integer iField Returns String
81133>>>                    String sFile sField sRet
81133>>>                    Boolean bOpen
81133>>>                    Get_Attribute DF_FILE_OPENED of iFile to bOpen
81136>>>                    If (bOpen) Begin
81138>>>                        Get_Attribute DF_FILE_LOGICAL_NAME of iFile to sFile
81141>>>                        Get_Attribute DF_FIELD_NAME of iFile iField to sField
81144>>>                        Function_Return (sFile+"."+sField)    
81145>>>                    End
81145>>>>
81145>>>                    Else Begin
81146>>>                        Function_Return "file not open"
81147>>>                    End
81147>>>>
81147>>>                End_Function
81148>>>
81148>>>                 Procedure ShowDDOConstraints Handle hoDD
81151>>>                    Integer i j iMain iCurrentDDFile
81151>>>                    tConstraintDef[] Constraints
81151>>>                    tConstraintDef[] Constraints
81152>>>                    String sFilter 
81152>>>                    Handle hoDDOther
81152>>>                    
81152>>>                    Get Main_File of hoDD to iMain
81153>>>                    Get DDOConstraints of  hoDD to Constraints
81154>>>                    
81154>>>                    Send Insert "Current DDO Constraints"
81155>>>                    Send Insert CR_LF
81156>>>                    Send Insert ("  Number of Constraints = " + String(SizeOfArray(Constraints)))
81157>>>                    Send Insert CR_LF
81158>>>
81158>>>                    For i from 0 to (SizeOfArray(Constraints)-1)
81164>>>>
81164>>>                        If (iCurrentDDFile<>Constraints[i].iFile) Begin
81166>>>                            Send Insert CR_LF
81167>>>                            Move Constraints[i].iFile to iCurrentDDFile
81168>>>                            If (Constraints[i].iFile<>iMain) Begin
81170>>>                                Get Which_Data_Set of hoDD Constraints[i].iFile to hoDDOther
81171>>>                            End
81171>>>>
81171>>>                            Else Begin
81172>>>                                Move hoDD to hoDDOther
81173>>>                            End
81173>>>>
81173>>>                            Send Insert  ("Constraints from ")
81174>>>                            
81174>>>                            If (hoDDOther) Begin
81176>>>                                Send Insert  (Object_Label(hoDDOther))
81177>>>                            End
81177>>>>
81177>>>                            Else Begin
81178>>>                                // not sure this could ever happen
81178>>>                                Send Insert  ("unknown. No DDO for file "+String(Constraints[i].iFile))
81179>>>                            End
81179>>>>
81179>>>                            
81179>>>                            If (hoDD<>hoDDOther) Begin
81181>>>                                Send Insert " (inherited)"
81182>>>                            End
81182>>>>
81182>>>                            
81182>>>                            Send Insert CR_LF
81183>>>                        End
81183>>>>
81183>>>                        
81183>>>                        
81183>>>                        Send Insert ("  " +String(i+1) + " Type=")
81184>>>                        Case Begin
81184>>>                            Case (Constraints[i].eType=CONST_VALUE) Send Insert "CONST_VALUE"
81187>>>                            Case (Constraints[i].eType=CONST_CHILD) Send Insert "CONST_CHILD"
81191>>>                            Case (Constraints[i].eType=CONST_FIELD) Send Insert "CONST_FIELD"
81195>>>                            Case (Constraints[i].eType=CONST_EXP) Send Insert "CONST_EXP"
81199>>>                            Case (Constraints[i].eType=CONST_RELATES) Send Insert "CONST_RELATES"
81203>>>                        Case End
81203>>>                        
81203>>>                        If (Constraints[i].eType=CONST_VALUE or Constraints[i].eType=CONST_FIELD) Begin
81205>>>                            Send Insert " mode="
81206>>>                            Case Begin
81206>>>                                Case (Constraints[i].eMODE=CONST_LT) Send Insert "LT"
81209>>>                                Case (Constraints[i].eMODE=CONST_LE) Send Insert "LE"
81213>>>                                Case (Constraints[i].eMODE=CONST_EQ) Send Insert "EQ"
81217>>>                                Case (Constraints[i].eMODE=CONST_GE) Send Insert "GE"
81221>>>                                Case (Constraints[i].eMODE=CONST_GT) Send Insert "GT"
81225>>>                                Case (Constraints[i].eMODE=CONST_NE) Send Insert "NE"
81229>>>                                Case (Constraints[i].eMODE=CONST_Matches) Send Insert "matches"
81233>>>                                Case (Constraints[i].eMODE=CONST_Contains) Send Insert "contains"
81237>>>                                Case (Constraints[i].eMODE=CONST_MatchesJumpIn) Send Insert "matches_JumpIn"
81241>>>                            Case End
81241>>>                        End
81241>>>>
81241>>>                        If (Constraints[i].eType<>CONST_EXP) Begin
81243>>>                            Send Insert (" File.Field=" + String(Constraints[i].iFile))
81244>>>                            Send Insert ("."  + String(Constraints[i].iField))
81245>>>                            Send Insert (" (" + FormatFileFieldName(Self,Constraints[i].iFile,Constraints[i].iField)+")")
81246>>>                        End
81246>>>>
81246>>>                        If (Constraints[i].eType=CONST_CHILD or Constraints[i].eType=CONST_FIELD) Begin
81248>>>                            Send Insert (" Other File.Field="  + String(Constraints[i].iOtherFile))
81249>>>                            Send Insert ("."  + String(Constraints[i].iOtherField))
81250>>>                            Send Insert (" (" + FormatFileFieldName(Self,Constraints[i].iOtherFile,Constraints[i].iOtherField)+")")
81251>>>                        End
81251>>>>
81251>>>                        Else If (Constraints[i].eType=CONST_VALUE) Begin
81254>>>                            Send Insert  (" Value=" + String(Constraints[i].sValue))
81255>>>                        End
81255>>>>
81255>>>                        Send Insert CR_LF
81256>>>                    Loop
81257>>>>
81257>>>                    
81257>>>                    Send Insert CR_LF
81258>>>                    
81258>>>                    Send ShowIndices hoDD
81259>>>                    
81259>>>                    
81259>>>                 End_Procedure
81260>>>                 
81260>>>                Procedure ShowIndices Handle hoDD
81263>>>                
81263>>>                    Integer iLastIndex
81263>>>                    Integer iIndex i
81263>>>                    Integer iNumSegments
81263>>>                    Integer hTable
81263>>>                    tDDOConstraintFindMeta FindMeta
81263>>>                    tDDOConstraintFindMeta FindMeta
81263>>>                    Get Main_File of hoDD to hTable
81264>>>                    
81264>>>                    Send Insert CR_LF
81265>>>                    Send Insert "Indexes and Constraints"
81266>>>                    Send Insert CR_LF
81267>>>                
81267>>>                    Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
81270>>>                    For iIndex from 1 to iLastIndex
81276>>>>
81276>>>                        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
81279>>>                        If (iNumSegments > 0) Begin
81281>>>                            
81281>>>                            Get DDOConstraintFindMeta of hoDD (GE) iIndex to FindMeta 
81282>>>
81282>>>                            Send Insert ("    Index " + String(iIndex)+": ")
81283>>>                            If (FindMeta.iJumpInSegments>0 or FindMeta.bJumpOut or FindMeta.bPreRelate or FindMeta.bPostRelate) Begin
81285>>>                                Send Insert ( "Jumpin "+String(FindMeta.iJumpInSegments)+" of "+String(iNumSegments)+". " )
81286>>>                                Send Insert ( (If(FindMeta.bJumpOut,"JumpOut. ", "")) + (If(FindMeta.bPreRelate,"Pre-Relate. ", "")) + (If(FindMeta.bPostRelate,"Post-Relate. ", "")) )
81287>>>                            End
81287>>>>
81287>>>                            Else Begin
81288>>>                                Send Insert "No Constraints"
81289>>>                            End
81289>>>>
81289>>>                            Send Insert CR_LF
81290>>>                        End
81290>>>>
81290>>>                    Loop
81291>>>>
81291>>>                End_Procedure // ShowIndices
81292>>>
81292>>>                Procedure RefreshAll
81295>>>                    Handle hDD
81295>>>                    Get phoCurrentDD to hDD
81296>>>                    Set Dynamic_update_state to False
81297>>>                    Send Delete_Data
81298>>>                    If (hDD) Begin
81300>>>                        Send ShowDDOConstraints hDD
81301>>>                    End
81301>>>>
81301>>>                    Send Beginning_Of_Data
81302>>>                    Set Dynamic_update_state to True
81303>>>                End_Procedure
81304>>>
81304>>>
81304>>>
81304>>>                Set Size to 100 375
81305>>>                Set Location to 4 4
81306>>>
81306>>>
81306>>>
81306>>>            End_Object
81307>>>            
81307>>>            Object oSQLFilterCkBox is a CheckBox
81309>>>                Set Size to 10 50
81310>>>                Set Location to 122 4
81311>>>                Set Label to "Use SQL Filter"
81312>>>                Set peAnchors to anBottom
81313>>>            
81313>>>                Procedure Select_Toggling Integer iItm Integer bState
81316>>>                    Handle hoDDO
81316>>>                    Boolean bFilter
81316>>>                    Get phoCurrentDD to hoDDO
81317>>>                    Forward Send select_toggling iItm bState
81319>>>                    Get Checked_State to bFilter
81320>>>                    Set pbUseDDSQLFilters of hoDDO to bFilter
81321>>>                    Send ApplySQLFilterInfo
81322>>>                End_Procedure
81323>>>            
81323>>>            End_Object
81324>>>
81324>>>            Object oInherit is a CheckBox
81326>>>                Set Label to "Inherit Constraints"
81327>>>                Set Size to 10 69
81328>>>                Set Location to 107 4
81329>>>                Set peAnchors to anBottomLeft
81330>>>        
81330>>>                Procedure Select_Toggling Integer iItm Integer bState
81333>>>                    Integer hDD
81333>>>                    Get phoCurrentDD to hDD
81334>>>                    Forward Send select_toggling iItm bState
81336>>>                    Set pbInheritConstraints of hDD to (checked_state(Self))
81337>>>                    If (hDD>0) Begin
81339>>>                        Send RebuildAllConstraints of hDD 
81340>>>//                        Send rebuild_constraints to hDD
81340>>>                        Send RefreshAll
81341>>>                    End
81341>>>>
81341>>>                End_Procedure
81342>>>        
81342>>>            End_Object    // oInherit
81343>>>
81343>>>            Object oSQLFilter is a Form
81345>>>                Set Size to 13 316
81346>>>                Set Location to 119 63
81347>>>                Set peAnchors to anBottomLeftRight
81348>>>                Procedure OnChange
81351>>>                    Handle hoDDO
81351>>>                    String sValue
81351>>>                    Get phoCurrentDD to hoDDO
81352>>>                    Get Value to sValue
81353>>>                    Set psSQLFilter of hoDDO to sValue
81354>>>                End_Procedure
81355>>>            End_Object
81356>>>            
81356>>>            Procedure ApplySQLFilterInfo
81359>>>                Integer iValue
81359>>>                Boolean bFilter bAllowed
81359>>>                Handle hoDDO
81359>>>                String sFilter
81359>>>                
81359>>>                Get phoCurrentDD to hoDDO
81360>>>                Get SupportsSQLFilters of hoDDO to bAllowed
81361>>>                Set Enabled_state of oSQLFilterCkBox to bAllowed
81362>>>                Get pbUseDDSQLFilters of hoDDO to bFilter
81363>>>                Get psSQLFilter of hoDDO to sFilter
81364>>>                Set Checked_State of oSQLFilterCkBox to bFilter
81365>>>                Set Enabled_state of oSQLFilter to bFilter
81366>>>                Set Value of oSQLFilter to sFilter
81367>>>            End_Procedure
81368>>>
81368>>>            Procedure RefreshAll
81371>>>                Send RefreshAll of oConstraintsEdit
81372>>>                Send ApplySQLFilterInfo
81373>>>            End_Procedure
81374>>>        End_Object
81375>>>        Object oTP_Field_Values is a TabPage
81377>>>            Set Label to "Field Values"
81378>>>            Set Tab_ToolTip_Value to "DD Field Values"
81379>>>            Object oFieldsEdit is a cDDDebugResults
81381>>>                delegate set phoFieldsEditId to self
81383>>>
81383>>>                Set Size to 127 375
81384>>>                Set Location to 4 4
81385>>>
81385>>>                Procedure RefreshAll
81388>>>                    Integer hDD hRB iMax iItem iFile
81388>>>                    Integer iOldErrorReport hOldErr
81388>>>                    String sLine sFieldName sChanged sVld sFrnVld sVal
81388>>>
81388>>>                    get phoCurrentDD to hDD
81389>>>                    get Record_Buffer of hDD to hRB
81390>>>                    Get main_file of hDD to iFile
81391>>>                    Set Dynamic_update_state to false
81392>>>                    Send Delete_Data
81393>>>
81393>>>                    Get Error_Report_Mode of hDD to iOldErrorReport
81394>>>                    Set Error_Report_Mode of hDD to DD_ERROR_NO_REPORT
81395>>>                    Move Error_Object_id to hOldErr
81396>>>                    Move hDD to Error_Object_id
81397>>>
81397>>>                    // Write the Header
81397>>>                    Send Insert "Field                           Chg Vld FrnVld Value"
81398>>>                    Send Insert CR_LF
81399>>>                    Send Insert "-----------------------------------------------------------------------------------------------------------"
81400>>>                    Send Insert CR_LF
81401>>>
81401>>>                    // Write the bodies for the fields
81401>>>                    Get Item_Count of hRB to iMax
81402>>>                    Decrement iMax
81403>>>                    For iItem From 0 to iMax
81409>>>>
81409>>>                        Get_Attribute DF_FIELD_NAME of iFile iItem to sFieldName
81412>>>                        Move (Pad(sFieldName,32)) to sFieldName
81413>>>                        Move (string(Item_Changed_State(hRB, iItem))) to sChanged
81414>>>                        // this will test it as a standard validation
81414>>>                        Move hDD to Operation_Origin
81415>>>                        Move (If(Validate_Field(hDD,iItem),"N","Y")) to sVld
81416>>>                        // this will test it as a foreign validation
81416>>>                        Move 0 to Operation_Origin
81417>>>                        Move (If(Validate_Field(hDD,iItem),"N","Y")) to sFrnVld
81418>>>                        //              Print (Item_Entry_MSG(hRB, iItem))
81418>>>                        //              Print (Item_Exit_MSG(hRB, iItem))
81418>>>                        //              Print (Item_Validate_MSG(hRB, iItem))
81418>>>                        Move (Field_Current_Value(hDD, iItem)) to sVal
81419>>>                        Move (sFormat("%1 %2   %3   %4     %5", sFieldName, sChanged, sVld, sFrnVld, sVal)) to sLine
81420>>>                        Send Insert sLine
81421>>>                        Send Insert CR_LF
81422>>>                    Loop
81423>>>>
81423>>>                    Send Insert CR_LF
81424>>>                    Send Insert "Existing_Key_Value = "
81425>>>                    Send Insert (Existing_Key_Value(hDD))
81426>>>                    Send Insert CR_LF
81427>>>
81427>>>                    Send Beginning_of_Data
81428>>>                    Set Dynamic_update_state to true
81429>>>                    Set Error_Report_Mode of hDD to iOldErrorReport
81430>>>                    Move hOldErr to Error_Object_id
81431>>>                End_procedure
81432>>>
81432>>>
81432>>>            End_Object    // oFieldsEdit
81433>>>
81433>>>        End_Object    // oTP_Field_Values
81434>>>        
81434>>>
81434>>>        Object oTP_Misc is a TabPage
81436>>>            Set Label to "Misc"
81437>>>            Set Tab_ToolTip_Value to "Other DD static values"
81438>>>            Object oMiscEdit is a cDDDebugResults
81440>>>                delegate set phoMiscEditId to self
81442>>>
81442>>>                Procedure RefreshAll
81445>>>                    Integer hDD hRB iMax iItem iFile iFIl iObj iOldSt
81445>>>                    Integer iCnt hVw iBase iType iFAObj iOldErrorReport hOldErr iMaster
81445>>>                    String sDummy sView sName sDummy2 sFieldName sType sLine
81445>>>                    Handle hoMaster
81445>>>
81445>>>                    Get phoInvokingView to hVw
81446>>>                    Get Name of hVw to sView
81447>>>
81447>>>                    get phoCurrentDD to hDD
81448>>>                    get Record_Buffer    of hDD to hRB
81449>>>                    get Field_Attributes of hDD to iFAObj
81450>>>                    Get main_file of hDD to iFile
81451>>>                    Set Dynamic_update_state to False
81452>>>                    Send Delete_Data
81453>>>
81453>>>                    Send Insert "Current DDO = "
81454>>>                    Send Insert (String(hDD) * "-" * Object_Label(hDD))
81455>>>                    Send Insert CR_LF
81456>>>                    
81456>>>                    Send Insert "Main File = "
81457>>>                    Get_Attribute DF_FILE_LOGICAL_NAME of iFile to sName
81460>>>                    Send Insert (String(iFile) * "-" * sName)
81461>>>                    Send Insert CR_LF
81462>>>                    
81462>>>                    
81462>>>                    
81462>>>                    Send Insert "Driver File = "
81463>>>                    Get_Attribute DF_FILE_DRIVER of iFile to sName
81466>>>                    Send Insert sName
81467>>>                    Send Insert CR_LF
81468>>>                    Send Insert CR_LF
81469>>>
81469>>>                    // see if this has a master table (i.e., if this DDO is an alias)
81469>>>                    Get MasterForAlias of hDD to iMaster
81470>>>                    If (iMaster<>0) Begin
81472>>>                        Get Data_Set of hDD iMaster to hoMaster
81473>>>                        Get_Attribute DF_FILE_LOGICAL_NAME of iMaster to sName
81476>>>                        Send Insert "Alias Table Information"
81477>>>                        Send Insert CR_LF
81478>>>                        Send Insert ("    Master Table: " + String(iMaster) * "-" * sName)
81479>>>                        Send Insert CR_LF
81480>>>                        // it is possible the master is not in this DDO structure. If so
81480>>>                        // this will be treated as a regular table.
81480>>>                        If (hoMaster) Begin
81482>>>                            Send Insert "    Master DDO = "
81483>>>                            Send Insert (String(hoMaster) * "-" * Object_Label(hoMaster))
81484>>>                        End
81484>>>>
81484>>>                        Else Begin
81485>>>                            Send Insert "    ** The master table is not part of the DDO structure"
81486>>>                            Send Insert CR_LF
81487>>>                            Send Insert "       therefore this DDO will be locked as a regular non-alias table."
81488>>>                        End
81488>>>>
81488>>>                        Send Insert CR_LF
81489>>>                        Send Insert CR_LF
81490>>>                    End
81490>>>>
81490>>>                    
81490>>>                    
81490>>>
81490>>>                    Send Insert "Current DDO Container = "
81491>>>                    Send Insert (String(hVw) * "-" * Object_Label(hVw) * "(" - sView - ")")
81492>>>                    Send Insert CR_LF
81493>>>                    Send Insert CR_LF
81494>>>
81494>>>                    //Send Insert "Keys_Fields = "
81494>>>                    //Send Insert (Key_Fields(hDD))
81494>>>                    //Send Insert CR_LF
81494>>>
81494>>>                    Send Insert "Protect_Key_State = "
81495>>>                    Send Insert (If(Protect_Key_State(hDD),"True","False"))
81496>>>                    Send Insert CR_LF
81497>>>
81497>>>                    Send Insert "Cascade_Delete_State = "
81498>>>                    Send Insert (If(Cascade_Delete_State(hDD),"True","False"))
81499>>>                    Send Insert CR_LF
81500>>>                    Send Insert CR_LF
81501>>>
81501>>>                    Send Insert "Required Server Files = "
81502>>>                    Send Insert (Server_File_Count(hDD))
81503>>>                    Send Insert CR_LF
81504>>>                    For iCnt from 0 to (Server_File_Count(hDD)-1)
81510>>>>
81510>>>                        Get Server_File of hDD iCnt to iFil
81511>>>                        Send Insert ("     " +string(iFil)+" - ")
81512>>>                        Get_Attribute DF_FILE_LOGICAL_NAME of iFil to sDummy
81515>>>                        Send Insert sDummy
81516>>>                        Send Insert CR_LF
81517>>>                    Loop
81518>>>>
81518>>>                    Send Insert  CR_LF
81519>>>
81519>>>                    Send Insert "Required Client Files = "
81520>>>                    Send Insert (Client_File_Count(hDD))
81521>>>                    Send Insert CR_LF
81522>>>                    For iCnt from 0 to (Client_File_Count(hDD)-1)
81528>>>>
81528>>>                        Get Client_File of hDD iCnt to iFil
81529>>>                        Send Insert ("     " +string(iFil)+" - ")
81530>>>                        Get_Attribute DF_FILE_LOGICAL_NAME of iFil to sDummy
81533>>>                        Send Insert sDummy
81534>>>                        Send Insert CR_LF
81535>>>                    Loop
81536>>>>
81536>>>                    Send Insert  CR_LF
81537>>>
81537>>>                    Send Insert "Required Other Files = "
81538>>>                    Send Insert (System_File_Count(hDD))
81539>>>                    Send Insert CR_LF
81540>>>                    For iCnt from 0 to (System_File_Count(hDD)-1)
81546>>>>
81546>>>                        Get System_File_Number of hDD iCnt to iFil
81547>>>                        Send Insert ("     " +string(iFil)+" - ")
81548>>>                        Get_Attribute DF_FILE_LOGICAL_NAME of iFil to sDummy
81551>>>                        Send Insert sDummy
81552>>>                        Get System_File_Lock_Mode of hDD iCnt to iFil
81553>>>                        Case Begin
81553>>>                            case (iFil=DD_Lock_on_All)             Move " - Lock on all" to sDummy
81556>>>                            case (iFil=DD_Lock_on_Delete)          Move " - Lock on Delete" to sDummy
81560>>>                            case (iFil=DD_Lock_on_new_Save_delete) Move " - Lock on new save/delete" to sDummy
81564>>>                            case (iFil=DD_Lock_on_Save)            Move " - Lock on save" to sDummy
81568>>>                            case (iFil=DD_Lock_on_new_Save)        Move " - Lock on new save" to sDummy
81572>>>                            case else                              Move " - No Lock" to sDummy
81574>>>                        case end
81574>>>                        Send Insert sDummy
81575>>>                        Send Insert CR_LF
81576>>>                    Loop
81577>>>>
81577>>>                    Send Insert  CR_LF
81578>>>
81578>>>                    Send Insert "Attached DDO Server DDO = "
81579>>>                    Send Insert (Data_set_server_Count(hDD))
81580>>>                    Send Insert CR_LF
81581>>>                    For iCnt from 0 to (Data_set_server_Count(hDD)-1)
81587>>>>
81587>>>                        Get Data_Set_Server of hDD iCnt to iObj
81588>>>                        Get Main_file of iObj to iFil
81589>>>                        Move (replace(sView+".",Name(iObj),"")) to sName
81590>>>                        Send Insert ("     " +string(iObj)+" - "+sname)
81591>>>                        Send Insert ("     " +string(iFil)+" - ")
81592>>>                        Get_Attribute DF_FILE_LOGICAL_NAME of iFil to sDummy
81595>>>                        Send Insert sDummy
81596>>>                        Send Insert CR_LF
81597>>>                    Loop
81598>>>>
81598>>>                    Send Insert  CR_LF
81599>>>
81599>>>                    Send Insert "Attached DDO CLient DDOs = "
81600>>>                    Send Insert  (Data_set_Client_Count(hDD))
81601>>>                    Send Insert  CR_LF
81602>>>                    For iCnt from 0 to (Data_set_Client_Count(hDD)-1)
81608>>>>
81608>>>                        Get Data_Set_Client of hDD iCnt to iObj
81609>>>                        Get Main_file of iObj to iFil
81610>>>                        Move (replace(sView+".",Name(iObj),"")) to sName
81611>>>                        Send Insert ("     " +string(iObj)+" - "+sname)
81612>>>                        Send Insert ("     " +string(iFil)+" - ")
81613>>>                        Get_Attribute DF_FILE_LOGICAL_NAME of iFil to sDummy
81616>>>                        Send Insert sDummy
81617>>>                        Send Insert CR_LF
81618>>>                    Loop
81619>>>>
81619>>>                    Send Insert CR_LF
81620>>>
81620>>>                    Send Insert  "Valid Save Structure = "
81621>>>                    Send Insert  (if(Validate_Save_Structure(hDD,1),"No","Yes"))
81622>>>                    Send Insert  CR_LF
81623>>>
81623>>>                    Get Cascade_delete_State of hDD to ioldst
81624>>>                    Set Cascade_delete_State of hDD to TRUE
81625>>>                    Send Insert  "Valid Cascade Delete Structure = "
81626>>>                    Send Insert  (if(Validate_Delete_Structure(hDD,1),"No","Yes"))
81627>>>                    Send Insert  CR_LF
81628>>>
81628>>>                    Set Cascade_delete_State of hDD to False
81629>>>                    Send Insert  "Valid No Cascade Delete Structure = "
81630>>>                    Send Insert  (if(Validate_Delete_Structure(hDD,1),"No","Yes"))
81631>>>                    Send Insert  CR_LF
81632>>>                    Set Cascade_delete_State of hDD to ioldst
81633>>>
81633>>>                    Send Insert  CR_LF
81634>>>                    Send Insert  "Attached DEOs = "
81635>>>                    Send Insert  (Data_set_user_Interface_Count(hDD))
81636>>>                    Send Insert  CR_LF
81637>>>                    For iCnt from 0 to (Data_set_User_Interface_Count(hDD)-1)
81643>>>>
81643>>>                        Get Data_Set_User_Interface of hDD iCnt to iObj
81644>>>                        Move (replace(sView+".",Object_Label(iObj),"")) to sName
81645>>>                        Send Insert ("     " +string(iObj)+" - "+sname)
81646>>>                        If Not (Extended_deo_State(iObj)) Send Insert  ("  (**Not XDEO)")
81649>>>                        else If (Data_File(iObj,0)<>iFile) Send Insert  ("    (foreign)")
81653>>>
81653>>>                        Send Insert  CR_LF
81654>>>                    Loop
81655>>>>
81655>>>                    Send Insert  CR_LF
81656>>>
81656>>>                    // Write the bodies for the fields
81656>>>                    // Write the Header
81656>>>                    Send Insert "              Extended Field Attributes"
81657>>>                    Send Insert CR_LF
81658>>>                    Send Insert "Field                            Type             Valid Values"
81659>>>                    Send Insert CR_LF
81660>>>                    Send Insert "-----------------------------------------------------------------------------------------------------------"
81661>>>                    Send Insert CR_LF
81662>>>
81662>>>                    Get Error_Report_Mode of hDD to iOldErrorReport
81663>>>                    Set Error_Report_Mode of hDD to DD_ERROR_NO_REPORT
81664>>>                    Move Error_Object_id to hOldErr
81665>>>                    Move hDD to Error_Object_id
81666>>>                    Get Item_Count of hRB to iMax
81667>>>                    Decrement iMax
81668>>>                    For iItem From 0 to iMax
81674>>>>
81674>>>                        Move (iItem * FA_COUNT) to iBase
81675>>>                        Get_Attribute DF_FIELD_NAME of iFile iItem to sFieldName
81678>>>                        Move (pad(sFieldName,32)) to sFieldName
81679>>>                        Get Field_Validation_Type of hDD iItem to iType
81680>>>                        Case Begin
81680>>>                            Case (iType=FA_VALIDATION_TYPE_RANGE)
81682>>>                                Move "Range" to sDummy
81683>>>                                Move ("Min="+Value(iFAObj,iBase+FA_MIN_VALUE) * ;                                    "Max="+Value(iFAObj,iBase+FA_MAX_VALUE)) ;                                        to sDummy2
81684>>>                                Case Break
81685>>>                            Case (iType=FA_VALIDATION_TYPE_CHECK)
81688>>>                                Move "Check" to sDummy
81689>>>                                Move ("Values =" * Value(iFAObj,iBase+FA_CHECK_VALUE)) to sDummy2
81690>>>                                Case Break
81691>>>                            Case (iType=FA_VALIDATION_TYPE_CHECKBOX)
81694>>>                                Move "CheckBox" to sDummy
81695>>>                                Move ("True="+ Value(iFAObj,iBase+FA_CHECKBOX_TRUE) * ;                                    "False="+ Value(iFAObj,iBase+FA_CHECKBOX_FALSE)) ;                                        to sDummy2
81696>>>                                Case Break
81697>>>                            Case (iType=FA_VALIDATION_TYPE_TABLE)
81700>>>                                Move "Table" to sDummy
81701>>>                                Move ("Id="+ Value(iFAObj,iBase+FA_TABLE_OBJECT) * ;                                      Name( Value(iFAObj,iBase+FA_TABLE_OBJECT) )) ;                                        to sDummy2
81702>>>                                Case Break
81703>>>                            Case Else
81703>>>                                Move "None" to sDummy
81704>>>                                Move "" to sDummy2
81705>>>                        Case end
81705>>>                        Move (Pad(sDummy,14)) to sDummy
81706>>>                        Move (SFormat("%1 %2 %3 %4", sFieldName, sType, sDummy, sDummy2)) to sLine
81707>>>                        Send Insert sLine
81708>>>                        Send Insert  CR_LF
81709>>>                    Loop
81710>>>>
81710>>>
81710>>>                    Send Beginning_Of_Data
81711>>>                    Set Dynamic_update_state to True
81712>>>                    Set Error_Report_Mode of hDD to iOldErrorReport
81713>>>                    Move hOldErr to Error_Object_id
81714>>>                end_procedure
81715>>>
81715>>>
81715>>>
81715>>>                Set Size to 127 375
81716>>>                Set Location to 4 4
81717>>>
81717>>>
81717>>>
81717>>>            End_Object    // oMiscEdit
81718>>>
81718>>>        End_Object    // oTP_Misc
81719>>>
81719>>>    End_Object    // oTD
81720>>>
81720>>>    Object oFindCounts is a Group
81722>>>        Set Size to 40 390
81723>>>        Set Location to 182 10
81724>>>        Set Label to "Constraint Find Counts"
81725>>>        Set peAnchors to anBottomLeft
81726>>>        Object oTestsCount is a Form
81728>>>
81728>>>            Set enabled_state to false
81729>>>
81729>>>            Set Label to "Tests_Count"
81730>>>            Set Size to 13 37
81731>>>            Set Location to 10 47
81732>>>            Set Label_Col_Offset to 2
81733>>>            Set Label_Justification_Mode to jMode_Right
81734>>>
81734>>>            Set Numeric_mask 0 to 8 0
81735>>>
81735>>>        End_Object    // oTestsCount
81736>>>
81736>>>        Object oFoundCount is a Form
81738>>>
81738>>>            Set enabled_state to false
81739>>>
81739>>>            Set Label to "Found_Count"
81740>>>            Set Size to 13 37
81741>>>            Set Location to 10 137
81742>>>            Set Label_Col_Offset to 2
81743>>>            Set Label_Justification_Mode to jMode_Right
81744>>>
81744>>>            Set Numeric_mask 0 to 8 0
81745>>>
81745>>>        End_Object    // oFoundCount
81746>>>
81746>>>        Object oDifference is a Form
81748>>>
81748>>>            Set enabled_state to false
81749>>>
81749>>>            Set Label to "Difference"
81750>>>            Set Size to 13 37
81751>>>            Set Location to 10 213
81752>>>            Set Label_Col_Offset to 2
81753>>>            Set Label_Justification_Mode to jMode_Right
81754>>>
81754>>>            Set Numeric_mask 0 to 8 0
81755>>>
81755>>>        End_Object    // oDifference
81756>>>
81756>>>        Object oClearCounts is a Button
81758>>>
81758>>>
81758>>>
81758>>>            Set Label to "Clear Count"
81759>>>            Set Size to 13 50
81760>>>            Set Location to 10 260
81761>>>
81761>>>            Procedure OnClick
81764>>>                Send ClearCounts
81765>>>            End_procedure
81766>>>
81766>>>
81766>>>        End_Object    // oClearCounts
81767>>>
81767>>>        Object oNonOptimalWarnings is a CheckBox
81769>>>            Set Label to "Report errors if more than"
81770>>>            Set Size to 10 93
81771>>>            Set Location to 24 6
81772>>>
81772>>>            Procedure OnChange
81775>>>                Delegate Send SetNonOptimalWarnings
81777>>>            End_Procedure // OnChange
81778>>>
81778>>>        End_Object    // oNonOptimalWarnings
81779>>>
81779>>>        Object oNonOptFinds is a Form
81781>>>
81781>>>            Set Numeric_mask 0 to 6 0
81782>>>
81782>>>            Set Size to 13 25
81783>>>            Set Location to 24 104
81784>>>
81784>>>
81784>>>            Set Value 0 to 50
81785>>>
81785>>>            Procedure OnChange
81788>>>                Delegate Send SetNonOptimalWarnings
81790>>>            End_Procedure // OnChange
81791>>>
81791>>>        End_Object    // oNonOptFinds
81792>>>
81792>>>        Object oNonOptTb is a Textbox
81794>>>            Set Label to "records are filtered."
81795>>>            Set Location to 25 132
81796>>>            Set Size to 10 61
81797>>>        End_Object    // oNonOptTb
81798>>>
81798>>>
81798>>>        Procedure ClearCounts
81801>>>            Move 0 to Constrain_tests_count
81802>>>            Move 0 to Constrain_found_Count
81803>>>            Send RefreshCounts
81804>>>        End_procedure
81805>>>
81805>>>        procedure RefreshCounts
81808>>>            Set Value of oTestsCount to constrain_tests_count
81809>>>            Set Value of oFoundCount to constrain_Found_count
81810>>>            Set Value of oDifference to (constrain_tests_count - Constrain_found_count)
81811>>>        end_procedure
81812>>>
81812>>>
81812>>>    End_Object    // oFindCounts
81813>>>
81813>>>    Object oFindGp is a Group
81815>>>
81815>>>
81815>>>
81815>>>        Set Size to 30 185
81816>>>        Set Location to 225 10
81817>>>        Set Label to "Find Record"
81818>>>        Set peAnchors to anBottomLeft
81819>>>        Object oFindBgn is a Button
81821>>>            Set Size to 14 18
81822>>>            Set Location to 10 9
81823>>>            Set peImageAlign to Button_ImageList_Align_Center
81824>>>            Set psImage to "ActionFirst.ico"
81825>>>
81825>>>            Procedure OnClick
81828>>>                Delegate Send FindRec FIRST_RECORD
81830>>>            End_procedure
81831>>>
81831>>>
81831>>>        End_Object    // oFindBgn
81832>>>
81832>>>        Object oFindPrev is a Button
81834>>>            Set Size to 14 18
81835>>>            Set Location to 10 31
81836>>>            Set peImageAlign to Button_ImageList_Align_Center
81837>>>            Set psImage to "ActionPrevious.ico"
81838>>>
81838>>>            Procedure OnClick
81841>>>                Delegate Send FindRec LT
81843>>>            End_procedure
81844>>>
81844>>>
81844>>>        End_Object    // oFindPrev
81845>>>
81845>>>        Object oFindNext is a Button
81847>>>
81847>>>            Set Size to 14 18
81848>>>            Set Location to 10 53
81849>>>            Set peImageAlign to Button_ImageList_Align_Center
81850>>>            Set psImage to "ActionNext.ico"
81851>>>
81851>>>            Procedure OnClick
81854>>>                Delegate Send FindRec Gt
81856>>>            End_procedure
81857>>>
81857>>>
81857>>>        End_Object    // oFindNext
81858>>>
81858>>>        Object oFindEnd is a Button
81860>>>
81860>>>            Set Size to 14 18
81861>>>            Set Location to 10 75
81862>>>            Set peImageAlign to Button_ImageList_Align_Center
81863>>>            Set psImage to "ActionLast.ico"
81864>>>
81864>>>            Procedure OnClick
81867>>>                Delegate Send FindRec LAST_RECORD
81869>>>            End_procedure
81870>>>
81870>>>
81870>>>        End_Object    // oFindEnd
81871>>>
81871>>>        Object oFindIndex is a ComboForm
81873>>>
81873>>>
81873>>>
81873>>>            Set Size to 13 85
81874>>>            Set Location to 11 97
81875>>>            Set Form_Border to 0
81876>>>            Set Label_Col_Offset to 2
81877>>>            Set Label_Justification_Mode to jMode_Right
81878>>>
81878>>>            Procedure Fill_list
81881>>>                Integer hDD iFile iSegs iNdxs i
81881>>>                Send Combo_Delete_Data
81882>>>                Get phoCurrentDD to hDD
81883>>>                If hDD Begin
81885>>>                    Send Combo_Add_Item "Index.0"
81886>>>                    Get Main_file of hDD to iFile
81887>>>                    Get_Attribute DF_FILE_LAST_INDEX_NUMBER of iFile to iNdxs
81890>>>                    For i from 1 to iNdxs
81896>>>>
81896>>>                        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of iFile i to iSegs
81899>>>                        If iSegs Send Combo_Add_Item ("Index."-string(i))
81902>>>                    Loop
81903>>>>
81903>>>                End
81903>>>>
81903>>>                Set Value 0 to (combo_value(self,0))
81904>>>            End_procedure
81905>>>
81905>>>            Function Ordering returns integer
81908>>>                String sVal
81908>>>                Get Value 0 to sVal
81909>>>                Function_return (integer(mid(sVal, 10, pos(".",sVal)+1)))
81910>>>            end_function
81911>>>
81911>>>        End_Object    // oFindIndex
81912>>>
81912>>>
81912>>>        Procedure FindRec integer iMode
81915>>>            Integer hDD iNdx
81915>>>            Get Ordering of oFindIndex to iNdx
81916>>>            Get phoCurrentDD to hDD
81917>>>            If hDD Begin
81919>>>                Send Find of hDD iMode iNdx
81920>>>                Send RefreshAll
81921>>>            End
81921>>>>
81921>>>        End_procedure
81922>>>
81922>>>         Procedure RefreshNewDD
81925>>>             Send Fill_List of oFindIndex
81926>>>         End_procedure
81927>>>
81927>>>    End_Object    // oFindGp
81928>>>
81928>>>    Object oCheckRentrancy is a CheckBox
81930>>>        Set Label to "Report DD Rentrancy Errors"
81931>>>        Set Size to 10 105
81932>>>        Set Location to 224 294
81933>>>        Set peAnchors to anBottomLeft
81934>>>
81934>>>        Procedure OnChange
81937>>>            Get Checked_State To gbTestRentrancy
81938>>>        End_Procedure // OnChange
81939>>>
81939>>>    End_Object    // oCheckRentrancy
81940>>>
81940>>>    Object oClearAll_bn is a Button
81942>>>
81942>>>
81942>>>
81942>>>        Set Label to "Clear& All"
81943>>>        Set Location to 241 242
81944>>>        Set peAnchors to anBottomLeft
81945>>>
81945>>>        Procedure OnClick
81948>>>            Integer hDD
81948>>>            get phoCurrentDD to hDD
81949>>>            if hDD Send clear_all to hdd
81952>>>            Send RefreshALL
81953>>>        end_procedure
81954>>>
81954>>>    End_Object    // oClearAll_bn
81955>>>
81955>>>    Object oClear_bn is a Button
81957>>>
81957>>>
81957>>>
81957>>>        Set Label to "&Clear"
81958>>>        Set Location to 241 295
81959>>>        Set peAnchors to anBottomLeft
81960>>>
81960>>>        Procedure OnClick
81963>>>            Integer hDD
81963>>>            get phoCurrentDD to hDD
81964>>>            if hDD Send clear to hdd
81967>>>            Send RefreshALL
81968>>>        end_procedure
81969>>>
81969>>>
81969>>>    End_Object    // oClear_bn
81970>>>
81970>>>    Object oClose_bn is a Button
81972>>>
81972>>>
81972>>>
81972>>>        Set Label to "&Close"
81973>>>        Set Location to 241 350
81974>>>        Set peAnchors to anBottomLeft
81975>>>
81975>>>        Procedure OnClick
81978>>>            Send Close_Panel
81979>>>        end_procedure
81980>>>
81980>>>
81980>>>    End_Object    // oClose_bn
81981>>>
81981>>>    Procedure RefreshAll
81984>>>        Integer hDD
81984>>>        Boolean bIsRecnumTable
81984>>>        get phoCurrentDD to hDD
81985>>>        Get IsRecnumTable (main_file(hDD)) to bIsRecnumTable
81986>>>        Set Value          of oCurRec 0 to (If(bIsRecnumTable, current_record(hDD), 0))
81987>>>        Set checked_state  of oChangedState to (Changed_State(hDD))
81988>>>        set checked_state  of oShouldSave   to (Should_save(hDD))
81989>>>        Send RefreshAll    of (phoFieldsEditId(self))
81990>>>        Send RefreshCounts of oFindCounts
81991>>>    End_procedure
81992>>>
81992>>>    Procedure SetNonOptimalWarnings
81995>>>        Integer iValue
81995>>>        Boolean bChecked
81995>>>        Get Checked_State of oNonOptimalWarnings to bChecked
81996>>>        Get Value of oNonOptFinds to iValue
81997>>>        Move (if(bChecked,iValue,0)) to giNonOptimalFindCount
81998>>>        Set Enabled_state of oNonOptFinds to bChecked
81999>>>    End_procedure
82000>>>
82000>>>    Procedure RefreshNewDD
82003>>>        Integer hDD
82003>>>        get phoCurrentDD to hDD
82004>>>        Send Fill_list of oDDRelatesTo
82005>>>        set checked_state of oAutoFill to (Auto_Fill_State(hDD)<>0)
82006>>>        set checked_state of oInherit  to (pbInheritConstraints(hDD))
82007>>>        set checked_state of oFillFromTop to (pbAutoFillFromFirst(hDD))
82008>>>        Send RefreshAll   to (phoMiscEditId(self))
82009>>>        Send RefreshAll   to (phoConstraintsEditId(Self))
82010>>>        Send RefreshAll
82011>>>
82011>>>        Send RefreshNewDD of oDDOrdering
82012>>>        Send RefreshNewDD of oFindGP
82013>>>        Set  Ordering     of oDDOrdering to (ordering(hDD))
82014>>>    End_procedure
82015>>>
82015>>>
82015>>>    Procedure refresh
82018>>>        Send Fill_list of oDDCombo
82019>>>        Send SetNonOptimalWarnings
82020>>>        set checked_state of oCheckRentrancy to gbTestRentrancy
82021>>>    end_procedure
82022>>>
82022>>>    Procedure ShowDDs Integer hoDD
82025>>>        Integer hoVw
82025>>>        Get parent of hoDD  to hoVw
82026>>>        Set phoCurrentDD    to hoDD
82027>>>        Set phoInvokingView to hoVw
82028>>>        Send Refresh
82029>>>        Send Popup
82030>>>    End_Procedure
82031>>>
82031>>>
82031>>>
82031>>>End_Object    // oDD_Debug
82032>>>
82032>>>
82032>>>
82032>>>Procedure DebugDDs FOR cObject
82034>>>   Integer hDD
82034>>>   get Server to hDD
82035>>>   if hDD Send ShowDDs of oDD_Debug hDD
82038>>>End_Procedure
82039>>>
82039>>>On_key key_Ctrl+Key_D Send DebugDDs
82040>>>
82040>
82040>        Use StdAbout.pkg
Including file: StdAbout.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\StdAbout.pkg)
82040>>>//************************************************************************
82040>>>// Confidential Trade Secret.
82040>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
82040>>>// as an unpublished work.  All rights reserved.
82040>>>// DataFlex is a registered trademark of Data Access Corporation.
82040>>>//
82040>>>//************************************************************************
82040>>>//************************************************************************
82040>>>//
82040>>>// $File name  : StdAbout.pkg
82040>>>// $File title : Standard about object package for VDF
82040>>>// Notice      :
82040>>>// $Author(s)  : John Tuohy
82040>>>//
82040>>>// $Rev History
82040>>>//
82040>>>// JT 06/27/97   File created
82040>>>//************************************************************************
82040>>>
82040>>>// This provides a quick and simple way to create an about package for a program.
82040>>>// You need to create a message inside you client area called Activate_About.
82040>>>// Within this message you should send the message DoAbout passing needed
82040>>>// string information.
82040>>>//
82040>>>//       Procedure Activate_About
82040>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
82040>>>//       End_Procedure
82040>>>//    where: sTitle =     Name of application. If none provided, uses caption
82040>>>//                        bar title
82040>>>//           sVersion   = Version Line. If none provided, will be blank
82040>>>//           sCopyRight = Copyright Line. If none provided, will be blank
82040>>>//           sAuthor    = Author name, blank if none provided
82040>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
82040>>>//                        is used.
82040>>>// It is expected that you will place this in your own object package. For
82040>>>// example an order about package may look like this:
82040>>>//
82040>>>//   // OrderAbout.pkg
82040>>>//   Use StdAbout.pkg
82040>>>//   Procedure Activate_About
82040>>>//      String sTitle sCopyright sVersion sAuthor
82040>>>//      Move "My Order Entry System" to sTitle
82040>>>//      Move "Version 2.1" to sVersion
82040>>>//      Move "Copyright 1997, Super Software Inc." to sCopyright
82040>>>//      Move "John Smith"  to sAuthor
82040>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
82040>>>//   end_procedure
82040>>>//   // end of file.
82040>>>
82040>>>Use DfAbout.pkg
Including file: DfAbout.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\DfAbout.pkg)
82040>>>>>//************************************************************************
82040>>>>>// Confidential Trade Secret.
82040>>>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
82040>>>>>// as an unpublished work.  All rights reserved.
82040>>>>>// DataFlex Is A registered trademark Of Data Access Corporation.
82040>>>>>//
82040>>>>>//************************************************************************
82040>>>>>//************************************************************************
82040>>>>>//
82040>>>>>// $File name  : DfAbout.pkg
82040>>>>>// $File title : About class support
82040>>>>>// Notice      :
82040>>>>>// $Author(s)  : Vincent Oorsprong, Ken Ross
82040>>>>>//
82040>>>>>// $Rev History
82040>>>>>//
82040>>>>>// NGS 08/16/2013 Improved by using a cRichEdit object were the params gets added to.
82040>>>>>//                The objects that previously were popupated with values from the params,
82040>>>>>//                and their corresponding "Procedure Set..." messages, were removed as
82040>>>>>//                the edit object is used instead.
82040>>>>>//                The number of params to the DoAbout procedure was increased to ten, so
82040>>>>>//                it is easier to add whatever extra text strings needed/wanted.
82040>>>>>//                The StdAbout.pkg was also changed for this to work. It allows for an extra
82040>>>>>//                five new params to be passed, but these new params are all optional.
82040>>>>>//                So the interface will work exactly as before - if no extra parameters are passed.
82040>>>>>//                Also added an extra bitmap object to show the "Powered By Visual DataFlex" logo, in
82040>>>>>//                the lower left corner of the About object, beneath the "main" About bitmap.
82040>>>>>//                Note: It is assumed that the bitmap "PoweredByVisualDataFlex.bmp" exists.
82040>>>>>//                The background was changed to clWhite for easier usage of bitmaps. Just set the background
82040>>>>>//                color of your bitmap to white and the bitmap will not look jagged.
82040>>>>>//                If an Internet address is passed as one of the params, it will be underlined and clickable.
82040>>>>>//                An e-mail address can also be passed; e.g. "E-mail: mailto:mail@myemailaccount.com" and will
82040>>>>>//                also be clickable.
82040>>>>>// VOO 02/22/2012 Replaced obsolete code, improved Network_User_Name by asking
82040>>>>>//                Windows for the size first.
82040>>>>>// VOO 07/25/2003 Removed OnResize procedure for sysinfo dialog. Replaced logic
82040>>>>>//                with anchor technique. Removed unnessary property in the
82040>>>>>//                sysinfo dialog. Changed the size Of the about & sysinfo dialog
82040>>>>>//                object To better look in Windows XP. Repositioned the close
82040>>>>>//                button in the sysinfo dialog To line up with the display area
82040>>>>>//                Replaced obsolete code and techniques. Removed dead code.
82040>>>>>// JJT 10/23/2001 removed all ghoworkspace support. Uses app object or nothing
82040>>>>>// SWB 07/19/01   Added support Of the Application object in preference to
82040>>>>>//                the global Workspace object, if it is present
82040>>>>>// JJT 11/05/98   Added version information
82040>>>>>// VOO 29/10/98   Replaced the GetFreeSystemResources for the Win32 variant
82040>>>>>// JJT 7/31/97    Registered Enumerate Workspace so dfabout can exist without
82040>>>>>//                workspace package.
82040>>>>>// JJT 6/27/97    Turned the sysinfo objects into classes so the AboutDialog
82040>>>>>//                class can create this object.
82040>>>>>//                Cleaned up the interface (used correct classes and messages)
82040>>>>>//                Added workspace reporting support To sys-info.
82040>>>>>//                Turned off wrapping in the sys-info editor.
82040>>>>>// KR  ??/??/96   File created
82040>>>>>//************************************************************************
82040>>>>>Use LanguageText.pkg
82040>>>>>Use Windows.pkg
82040>>>>>Use DFbitmap.pkg
82040>>>>>Use GlobalFunctionsProcedures.pkg
82040>>>>>Use cRichEdit.pkg
Including file: cRichEdit.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cRichEdit.pkg)
82040>>>>>>>use Windows.pkg
82040>>>>>>>Use cEdit_Mixin.pkg
82040>>>>>>>
82040>>>>>>>// DFO: cRichEdit.Dfo
82040>>>>>>>// DFC: cRichEdit.Dfc
82040>>>>>>>
82040>>>>>>>// constants used for RichEdit Properties
82040>>>>>>>// peAlignment 
82040>>>>>>>Enum_List 
82040>>>>>>>    Define alLeft   for 1 
82040>>>>>>>    Define alRight  for 2 
82040>>>>>>>    Define alCenter for 3 
82040>>>>>>>End_Enum_List 
82040>>>>>>>
82040>>>>>>>// peBullets 
82040>>>>>>>Enum_List 
82040>>>>>>>    Define buNone 
82040>>>>>>>    Define buBullets 
82040>>>>>>>    Define buArabicNumbers 
82040>>>>>>>    Define buLowerLetters 
82040>>>>>>>    Define buUpperLetters 
82040>>>>>>>    Define buLowerRomans 
82040>>>>>>>    Define buUpperRomans 
82040>>>>>>>End_Enum_List 
82040>>>>>>>
82040>>>>>>>// peBulletStyle 
82040>>>>>>>Enum_List 
82040>>>>>>>    Define busRightParen   for 0 
82040>>>>>>>    Define busEncloseParen for 256 
82040>>>>>>>    Define busPeriod       for 512 
82040>>>>>>>    Define busNumberOnly   for 768 
82040>>>>>>>    Define busNoDisplay    for 1024 
82040>>>>>>>End_Enum_List
82040>>>>>>>    
82040>>>>>>>// peLineSpacingType
82040>>>>>>>Enum_List 
82040>>>>>>>    Define lstSingle
82040>>>>>>>    Define lstSingleAndOneHalf
82040>>>>>>>    Define lstDouble
82040>>>>>>>End_Enum_List
82040>>>>>>>
82040>>>>>>>Class cRichEdit Is A DFBaseRichEdit
82041>>>>>>>
82041>>>>>>>    Procedure Construct_Object
82043>>>>>>>        Forward Send Construct_Object
82045>>>>>>>        Send Define_cEdit_Mixin
82046>>>>>>>
82046>>>>>>>        On_key Key_Ctrl+Key_B send ToggleBold
82047>>>>>>>        On_key Key_Ctrl+Key_I send ToggleItalics
82048>>>>>>>        On_key Key_Ctrl+Key_U send ToggleUnderline
82049>>>>>>>
82049>>>>>>>    End_Procedure // Construct_Object
82050>>>>>>>
82050>>>>>>>    Import_Class_Protocol cEdit_Mixin
82051>>>>>>>    
82051>>>>>>>    Procedure ToggleBold
82053>>>>>>>        Set pbBold to (not(pbBold(self))) 
82054>>>>>>>    end_procedure
82055>>>>>>>    
82055>>>>>>>    Procedure ToggleItalics
82057>>>>>>>        Set pbItalics to (not(pbItalics(self))) 
82058>>>>>>>    end_procedure
82059>>>>>>>    
82059>>>>>>>    Procedure ToggleUnderline
82061>>>>>>>       Set pbUnderLine to (not(pbUnderLine(self))) 
82062>>>>>>>    end_procedure
82063>>>>>>>
82063>>>>>>>End_Class
82064>>>>>>>
82064>>>>>Use cTextEdit.pkg
82064>>>>>Use gFormatNumbers.pkg
Including file: gFormatNumbers.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\gFormatNumbers.pkg)
82064>>>>>>>//****************************************************************************//
82064>>>>>>>//                                                                            //
82064>>>>>>>// $File name  : gFormatNumbers.pkg                                           //
82064>>>>>>>// $File title : Globals for formating numbers and currency                   //
82064>>>>>>>// Notice      :                                                              //
82064>>>>>>>// $Author(s)  : John Tuohy                                                   //
82064>>>>>>>//                                                                            //
82064>>>>>>>// Confidential Trade Secret.                                                 //
82064>>>>>>>// Copyright 1999 Data Access Corporation, Miami FL, USA                      //
82064>>>>>>>// All Rights reserved                                                        //
82064>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.             //
82064>>>>>>>// $Rev History                                                               //
82064>>>>>>>//                                                                            //
82064>>>>>>>// 25.08.99 Created                                                           //
82064>>>>>>>//****************************************************************************//
82064>>>>>>>
82064>>>>>>>Use cFormatter.pkg
Including file: cFormatter.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cFormatter.pkg)
82064>>>>>>>>>//****************************************************************************//
82064>>>>>>>>>//                                                                            //
82064>>>>>>>>>// $File name  : cFormatter.pkg                                               //
82064>>>>>>>>>// $File title : cFormatter class (private class)                             //
82064>>>>>>>>>// $Author(s)  : John Tuohy                                                   //
82064>>>>>>>>>//                                                                            //
82064>>>>>>>>>// Confidential Trade Secret.                                                 //
82064>>>>>>>>>// Copyright 1999 Data Access Corporation, Miami FL, USA                      //
82064>>>>>>>>>// All Rights reserved                                                        //
82064>>>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.             //
82064>>>>>>>>>//                                                                            //
82064>>>>>>>>>// $Rev History                                                               //
82064>>>>>>>>>//                                                                            //
82064>>>>>>>>>// 25.08.99 Created                                                           //
82064>>>>>>>>>//****************************************************************************//
82064>>>>>>>>>use VDFBase.pkg
82064>>>>>>>>>
82064>>>>>>>>>Class cFormatter is an cObject
82065>>>>>>>>>
82065>>>>>>>>>    Procedure Construct_object
82067>>>>>>>>>        Integer iCh
82067>>>>>>>>>        forward send construct_object
82069>>>>>>>>>        Property String  psCurrencySymbol
82070>>>>>>>>>        Set psCurrencySymbol to (Default_Currency_Symbol())
82071>>>>>>>>>
82071>>>>>>>>>        Property string  psLeft
82072>>>>>>>>>        Property string  psright
82073>>>>>>>>>        Property integer pbThousandsSep
82074>>>>>>>>>        Property integer piPoints
82075>>>>>>>>>
82075>>>>>>>>>        Property string  psCurPosLeft
82076>>>>>>>>>        Property string  psCurPosright
82077>>>>>>>>>        Property integer pbCurPosThousandsSep
82078>>>>>>>>>        Property integer piCurPosPoints
82079>>>>>>>>>
82079>>>>>>>>>        Property string  psCurNegLeft
82080>>>>>>>>>        Property string  psCurNegright
82081>>>>>>>>>        Property integer pbCurNegThousandsSep
82082>>>>>>>>>        Property integer piCurNegPoints
82083>>>>>>>>>
82083>>>>>>>>>        Property string  psNumPosLeft
82084>>>>>>>>>        Property string  psNumPosright
82085>>>>>>>>>        Property integer pbNumPosThousandsSep
82086>>>>>>>>>        Property integer piNumPosPoints
82087>>>>>>>>>
82087>>>>>>>>>        Property string  psNumNegLeft
82088>>>>>>>>>        Property string  psNumNegright
82089>>>>>>>>>        Property integer pbNumNegThousandsSep
82090>>>>>>>>>        Property integer piNumNegPoints
82091>>>>>>>>>
82091>>>>>>>>>        Send SetFormat "$,#.##;($,#.##)" true  // currency
82092>>>>>>>>>        Send SetFormat  ",#.*"           false // numeric
82093>>>>>>>>>
82093>>>>>>>>>    end_procedure
82094>>>>>>>>>
82094>>>>>>>>>    // internal
82094>>>>>>>>>    // parse passed format string and set temporary properties with result
82094>>>>>>>>>    //
82094>>>>>>>>>    Procedure ParseFormat string sFmt
82096>>>>>>>>>
82096>>>>>>>>>        string sLeft sRight sDigit
82096>>>>>>>>>        integer bSep iPos i iDigits
82096>>>>>>>>>
82096>>>>>>>>>        // replace any literals. A "/" followed by anything.
82096>>>>>>>>>        // some literals are special. $ . , / #
82096>>>>>>>>>        Move (Replaces("/$",sFmt,Character(1)))    to sFmt
82097>>>>>>>>>        Move (Replaces("/.",sFmt,Character(2)))    to sFmt
82098>>>>>>>>>        Move (Replaces("/,",sFmt,Character(3)))    to sFmt
82099>>>>>>>>>        Move (Replaces("/"+"/",sFmt,Character(4))) to sFmt
82100>>>>>>>>>        Move (Replaces("/#",sFmt,Character(5)))    to sFmt
82101>>>>>>>>>        Move (Character(9)) to sDigit
82102>>>>>>>>>        Move (Replaces("#",sFmt,sDigit))           to sFmt
82103>>>>>>>>>        Move (Replaces("/",sFmt,""))               to sFmt // replace all others
82104>>>>>>>>>
82104>>>>>>>>>        Move (Pos(",",sFmt))                 to bSep // if we have any , we use thousand seps
82105>>>>>>>>>        If bSep Move (Replaces(",",sFmt,"")) to sFmt // remove all ,
82108>>>>>>>>>
82108>>>>>>>>>        Move (Replaces("$",sFmt,psCurrencySymbol(self))) to sFmt // replace any $ with currency symbol
82109>>>>>>>>>
82109>>>>>>>>>        Move (Pos(".",sFmt)) to iPos                 // position of decimal
82110>>>>>>>>>
82110>>>>>>>>>        // Move all the special literals back into place before parsing
82110>>>>>>>>>        Move (Replaces(Character(1),sFmt,"$")) to sFmt
82111>>>>>>>>>        Move (Replaces(Character(2),sFmt,".")) to sFmt
82112>>>>>>>>>        Move (Replaces(Character(3),sFmt,",")) to sFmt
82113>>>>>>>>>        Move (Replaces(Character(4),sFmt,"/")) to sFmt
82114>>>>>>>>>        Move (Replaces(Character(5),sFmt,"#")) to sFmt
82115>>>>>>>>>
82115>>>>>>>>>        If (iPos>0) Begin                      // if we have a decimanl point
82117>>>>>>>>>            Move 1 to i                        // look for first non # to right and count the #s
82118>>>>>>>>>            If (mid(sFmt,1,iPos+i)="*") Begin  // the "*" is special. It means as many as you want
82120>>>>>>>>>               Move -2 to iDigits
82121>>>>>>>>>               increment i
82122>>>>>>>>>            end
82122>>>>>>>>>>
82122>>>>>>>>>            While (mid(sFmt,1,iPos+i)=sDigit)
82126>>>>>>>>>                 Increment i
82127>>>>>>>>>            end
82128>>>>>>>>>>
82128>>>>>>>>>            Move (Mid(sFmt,255,iPos+i)) to sRight // everything to the right of the last # is format stuff
82129>>>>>>>>>            If (iDigits=0) Move (i-1) to iDigits
82132>>>>>>>>>            //
82132>>>>>>>>>            Move 1 to i                           // find the first non-# to the left of the point
82133>>>>>>>>>            While (mid(sFmt,1,iPos-i)=sDigit)     // everything to the left is format stuff
82137>>>>>>>>>                 increment i
82138>>>>>>>>>            end
82139>>>>>>>>>>
82139>>>>>>>>>            Move (left(sFmt,iPos-i)) to sLeft
82140>>>>>>>>>        end
82140>>>>>>>>>>
82140>>>>>>>>>        else begin                             // we have no decinal
82141>>>>>>>>>            Move 0 to iDigits                  // so points is none
82142>>>>>>>>>            Move (Pos(sDigit,sFmt)) to iPos    // find first #.
82143>>>>>>>>>            If (iPos=0) Begin                  // if none, entire string is left format stuff..wierd!
82145>>>>>>>>>                Move sFmt to sLeft
82146>>>>>>>>>                Move ""   to sRight
82147>>>>>>>>>            end
82147>>>>>>>>>>
82147>>>>>>>>>            else begin
82148>>>>>>>>>                Move (left(sFmt,iPos-1)) to sLeft // all char to left of first # is left format stuff
82149>>>>>>>>>                Move 1 to i
82150>>>>>>>>>                While (mid(sFmt,1,iPos+i)=sDigit) // find last #, all char to right is right format
82154>>>>>>>>>                    Increment i
82155>>>>>>>>>                end
82156>>>>>>>>>>
82156>>>>>>>>>                Move (Mid(sFmt,255,i+iPos)) to sRight
82157>>>>>>>>>            end
82157>>>>>>>>>>
82157>>>>>>>>>        end
82157>>>>>>>>>>
82157>>>>>>>>>        // set temporary format properties and exit
82157>>>>>>>>>        Set pbThousandsSep to bSep
82158>>>>>>>>>        set psLeft         to sLeft
82159>>>>>>>>>        set psRight        to sRight
82160>>>>>>>>>        Set piPoints       to iDigits
82161>>>>>>>>>     End_procedure
82162>>>>>>>>>
82162>>>>>>>>>    // Public: Sets a format string. Pass full format for Positve and negative in sFmt. Pass
82162>>>>>>>>>    //         bCurrency true is this is a currency format, false if a numeric format
82162>>>>>>>>>    //
82162>>>>>>>>>    //  e.g. Send SetFormat "$,#.##;($,#.##)" True
82162>>>>>>>>>    //
82162>>>>>>>>>    Procedure SetFormat string sFmt integer bCurrency
82164>>>>>>>>>        string sPos sNeg
82164>>>>>>>>>        integer iPos
82164>>>>>>>>>
82164>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
82165>>>>>>>>>        If iPos begin
82167>>>>>>>>>            Move (left(sFmt,iPos-1))    to sPos
82168>>>>>>>>>            Move (mid(sFmt,255,iPos+1)) to sNeg
82169>>>>>>>>>        end
82169>>>>>>>>>>
82169>>>>>>>>>        else Begin
82170>>>>>>>>>            Move sFmt         to sPos
82171>>>>>>>>>            Move ("-" + sFmt) to sNeg
82172>>>>>>>>>        end
82172>>>>>>>>>>
82172>>>>>>>>>        Send ParseFormat sPos
82173>>>>>>>>>        If bCurrency begin
82175>>>>>>>>>            Set pbCurPosThousandsSep to (pbThousandsSep(self))
82176>>>>>>>>>            set psCurPosLeft         to (psLeft(self))
82177>>>>>>>>>            set psCurPosRight        to (psRight(self))
82178>>>>>>>>>            Set piCurPosPoints       to (piPoints(self))
82179>>>>>>>>>        End
82179>>>>>>>>>>
82179>>>>>>>>>        else Begin
82180>>>>>>>>>            Set pbNumPosThousandsSep to (pbThousandsSep(self))
82181>>>>>>>>>            set psNumPosLeft         to (psLeft(self))
82182>>>>>>>>>            set psNumPosRight        to (psRight(self))
82183>>>>>>>>>            Set piNumPosPoints       to (piPoints(self))
82184>>>>>>>>>        end
82184>>>>>>>>>>
82184>>>>>>>>>
82184>>>>>>>>>        Send ParseFormat sNeg
82185>>>>>>>>>        If bCurrency begin
82187>>>>>>>>>            Set pbCurNegThousandsSep to (pbThousandsSep(self))
82188>>>>>>>>>            set psCurNegLeft         to (psLeft(self))
82189>>>>>>>>>            set psCurNegRight        to (psRight(self))
82190>>>>>>>>>            Set piCurNegPoints       to (piPoints(self))
82191>>>>>>>>>        End
82191>>>>>>>>>>
82191>>>>>>>>>        else Begin
82192>>>>>>>>>            Set pbNumNegThousandsSep to (pbThousandsSep(self))
82193>>>>>>>>>            set psNumNegLeft         to (psLeft(self))
82194>>>>>>>>>            set psNumNegRight        to (psRight(self))
82195>>>>>>>>>            Set piNumNegPoints       to (piPoints(self))
82196>>>>>>>>>        end
82196>>>>>>>>>>
82196>>>>>>>>>    End_procedure
82197>>>>>>>>>
82197>>>>>>>>>    // low level formatting. Pass parameters
82197>>>>>>>>>    Function Format_Num number nNumber integer iPoints integer bSep ;                       string sPrefix string sSuffix returns string
82199>>>>>>>>>        string  sLeft sRight sNumber sSep sDec
82199>>>>>>>>>        integer bIsNegative iDec iLen iCh
82199>>>>>>>>>
82199>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iCh
82202>>>>>>>>>        Move (Character(iCh)) to sDec
82203>>>>>>>>>
82203>>>>>>>>>        Move (abs(nNumber)) to sNumber
82204>>>>>>>>>        Move (Pos(sDec,sNumber)) to iDec
82205>>>>>>>>>        Move (If(iDec=0, sNumber, left(sNumber,iDec-1))) to sLeft
82206>>>>>>>>>        Move (If(iDec=0, "", mid(sNumber,255,iDec+1)))   to sRight
82207>>>>>>>>>        // format for decimal separator
82207>>>>>>>>>        If (iPoints>=0) ; // if -2, leave it alone, it should not be -1            Move (left(sRight+repeat("0",iPoints),iPoints)) to sRight
82210>>>>>>>>>
82210>>>>>>>>>        // format for thousand sep.
82210>>>>>>>>>        If bSep Begin
82212>>>>>>>>>            Get_Attribute DF_THOUSANDS_SEPARATOR to iCh
82215>>>>>>>>>            Move (Character(iCh)) to sSep
82216>>>>>>>>>            Move (Length(sLeft)) to iLen
82217>>>>>>>>>            While (iLen>3)
82221>>>>>>>>>                Move (insert(sSep,sLeft,iLen-2)) to sLeft
82222>>>>>>>>>                Move (iLen-3) to iLen
82223>>>>>>>>>            End
82224>>>>>>>>>>
82224>>>>>>>>>        End
82224>>>>>>>>>>
82224>>>>>>>>>        // if decimal points or -2 (allow anything) and there are points to show
82224>>>>>>>>>        If (iPoints>0 OR (iPoints=-2 AND sRight<>"")) ;            Move (sLeft + sDec + sright) to sLeft
82227>>>>>>>>>        Function_return (sPrefix + sLeft+ sSuffix)
82228>>>>>>>>>    End_Function
82229>>>>>>>>>
82229>>>>>>>>>    // Public: Format for currency
82229>>>>>>>>>    //
82229>>>>>>>>>    Function FormatCur number nNumber integer iPoints returns string
82231>>>>>>>>>        string  sLeft sRight
82231>>>>>>>>>        integer bSep
82231>>>>>>>>>        If (nNumber<0) Begin
82233>>>>>>>>>            get pbCurNegThousandsSep to bSep
82234>>>>>>>>>            get psCurNegLeft         to sLeft
82235>>>>>>>>>            get psCurNegRight        to sRight
82236>>>>>>>>>            If (iPoints=-1) get piCurNegPoints       to iPoints
82239>>>>>>>>>        end
82239>>>>>>>>>>
82239>>>>>>>>>        Else Begin
82240>>>>>>>>>            get pbCurPosThousandsSep to bSep
82241>>>>>>>>>            get psCurPosLeft         to sLeft
82242>>>>>>>>>            get psCurPosRight        to sRight
82243>>>>>>>>>            If (iPoints=-1) get piCurPosPoints       to iPoints
82246>>>>>>>>>        end
82246>>>>>>>>>>
82246>>>>>>>>>        Function_return (Format_Num(self, nNumber,iPoints,bSep,sLeft,sRight))
82247>>>>>>>>>    End_function
82248>>>>>>>>>
82248>>>>>>>>>    // Public: Format for numeric
82248>>>>>>>>>    //
82248>>>>>>>>>    Function FormatNum number nNumber integer iPoints returns string
82250>>>>>>>>>        string  sLeft sRight
82250>>>>>>>>>        integer bSep
82250>>>>>>>>>        If (nNumber<0) Begin
82252>>>>>>>>>            get pbNumNegThousandsSep to bSep
82253>>>>>>>>>            get psNumNegLeft         to sLeft
82254>>>>>>>>>            get psNumNegRight        to sRight
82255>>>>>>>>>            If (iPoints=-1) get piNumNegPoints       to iPoints
82258>>>>>>>>>        end
82258>>>>>>>>>>
82258>>>>>>>>>        Else Begin
82259>>>>>>>>>            get pbNumPosThousandsSep to bSep
82260>>>>>>>>>            get psNumPosLeft         to sLeft
82261>>>>>>>>>            get psNumPosRight        to sRight
82262>>>>>>>>>            If (iPoints=-1) get piNumPosPoints       to iPoints
82265>>>>>>>>>        end
82265>>>>>>>>>>
82265>>>>>>>>>        Function_return (Format_Num(self, nNumber,iPoints,bSep,sLeft,sRight))
82266>>>>>>>>>    End_function
82267>>>>>>>>>
82267>>>>>>>>>
82267>>>>>>>>>    // Public: Format passing format string
82267>>>>>>>>>    //
82267>>>>>>>>>    Function FormatVal number nNumber string sFmt returns string
82269>>>>>>>>>        integer iPos bIsNeg
82269>>>>>>>>>        string  sLeft sRight
82269>>>>>>>>>        integer iPoints bSep
82269>>>>>>>>>        Move (nNumber<0) to bIsNeg
82270>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
82271>>>>>>>>>        Case Begin
82271>>>>>>>>>            Case (iPos and Not(bIsNeg))      Move (left(sFmt,iPos-1))    to sFmt
82274>>>>>>>>>            Case (iPos and bIsNeg)           Move (mid(sFmt,255,iPos+1)) to sFmt
82278>>>>>>>>>            Case (not(iPos) and not(bIsNeg)) Move sFmt                   to sFmt
82282>>>>>>>>>            Case else                        Move ("-" + sFmt)           to sFmt
82284>>>>>>>>>        case end
82284>>>>>>>>>        Send ParseFormat sFmt
82285>>>>>>>>>        get pbThousandsSep to bSep
82286>>>>>>>>>        get psLeft         to sLeft
82287>>>>>>>>>        get psRight        to sRight
82288>>>>>>>>>        get piPoints       to iPoints
82289>>>>>>>>>        Function_return (Format_Num(self, nNumber,iPoints,bSep,sLeft,sRight))
82290>>>>>>>>>    end_function
82291>>>>>>>>>
82291>>>>>>>>>End_Class
82292>>>>>>>
82292>>>>>>>// for now, this object is private. All access is through the following
82292>>>>>>>// global functions
82292>>>>>>>
82292>>>>>>>//Object oFmt is a cFormatter
82292>>>>>>>//end_object
82292>>>>>>>
82292>>>>>>>Global_variable handle ghoFormatter
82292>>>>>>>Get Create of desktop U_cFormatter to ghoFormatter
82293>>>>>>>
82293>>>>>>>Function FormatNumber Global number nNum integer iPoints returns string
82295>>>>>>>    Function_return (FormatNum(ghoFormatter, nNum,iPoints))
82296>>>>>>>end_function
82297>>>>>>>
82297>>>>>>>Function FormatCurrency Global number nNum integer iPoints returns string
82299>>>>>>>    Function_return (FormatCur(ghoFormatter, nNum,iPoints))
82300>>>>>>>end_function
82301>>>>>>>
82301>>>>>>>Function FormatValue Global number nNum string sFmt returns string
82303>>>>>>>    Function_return (FormatVal(ghoFormatter, nNum,sFmt))
82304>>>>>>>end_function
82305>>>>>>>
82305>>>>>>>Procedure SetCurrencyFormat Global string sFmt
82307>>>>>>>    Send SetFormat of ghoFormatter sFmt True
82308>>>>>>>end_function
82309>>>>>>>
82309>>>>>>>Procedure SetNumberFormat Global string sFmt
82311>>>>>>>    Send SetFormat of ghoFormatter sFmt False
82312>>>>>>>end_function
82313>>>>>>>
82313>>>>>Use MapiDllCalls.Pkg
Including file: MapiDllCalls.Pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\MapiDllCalls.Pkg)
82313>>>>>>>Use MapiConstants.Pkg
Including file: MapiConstants.Pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\MapiConstants.Pkg)
82313>>>>>>>>>Type MapiSession
82313>>>>>>>>>   Field MapiSession.SessionID As Integer
82313>>>>>>>>>End_type // MapiSession
82313>>>>>>>>>
82313>>>>>>>>>Type MapiMessagePointer
82313>>>>>>>>>   Field MapiMessagePointer.lppMessage As Pointer
82313>>>>>>>>>End_Type // MapiMessagePointer
82313>>>>>>>>>
82313>>>>>>>>>Type MapiRecipPointer
82313>>>>>>>>>   Field MapiRecipPointer.lppRecip As Pointer
82313>>>>>>>>>End_Type // MapiRecipPointer
82313>>>>>>>>>
82313>>>>>>>>>Type MapiNewRecipsPointer
82313>>>>>>>>>   Field MapiNewRecipsPointer.lppNewRecips As Pointer
82313>>>>>>>>>End_Type // MapiNewRecipsPointer
82313>>>>>>>>>
82313>>>>>>>>>Type MapiNewRecipsCounter
82313>>>>>>>>>   Field MapiNewRecipsCounter.lpnNewRecips As Integer
82313>>>>>>>>>End_Type // MapiNewRecipsCounter
82313>>>>>>>>>
82313>>>>>>>>>Type MapiFileDesc
82313>>>>>>>>>   Field MapiFileDesc.ulReserved As Integer      // Reserved for future use (must be 0)
82313>>>>>>>>>   Field MapiFileDesc.flFlags As Integer         // Flags
82313>>>>>>>>>   Field MapiFileDesc.nPosition As Integer       // character in text to be replaced by attachment
82313>>>>>>>>>   Field MapiFileDesc.lpszPathName As Pointer    // Full path name of attachment file
82313>>>>>>>>>   Field MapiFileDesc.lpszFileName As Pointer    // Original file name (optional)
82313>>>>>>>>>   Field MapiFileDesc.lpFileType As Pointer     // Attachment file type (can be lpMapiFileTagExt)
82313>>>>>>>>>End_Type // MapiFileDesc
82313>>>>>>>>>
82313>>>>>>>>>Define MAPI_OLE        For |CI$00000001
82313>>>>>>>>>Define MAPI_OLE_STATIC For |CI$00000002
82313>>>>>>>>>
82313>>>>>>>>>Define MAPI_NOATTACHMENT_POSITION For |CI$FFFFFFFF
82313>>>>>>>>>
82313>>>>>>>>>Type MapiFileTagExt
82313>>>>>>>>>   Field MapiFileTagExt.ulReserved As Integer  // Reserved, must be zero.
82313>>>>>>>>>   Field MapiFileTagExt.cbTag As Integer       // Size (in bytes) of
82313>>>>>>>>>   Field MapiFileTagExt.lpTag As Pointer       // X.400 OID for this attachment type
82313>>>>>>>>>   Field MapiFileTagExt.cbEncoding As Integer  // Size (in bytes) of
82313>>>>>>>>>   Field MapiFileTagExt.lpEncoding As Pointer  // X.400 OID for this attachment's encoding
82313>>>>>>>>>End_Type // MapiFileTagExt
82313>>>>>>>>>
82313>>>>>>>>>Type MapiRecipDesc
82313>>>>>>>>>   Field MapiRecipDesc.ulReserved As Integer   // Reserved for future use
82313>>>>>>>>>   Field MapiRecipDesc.ulRecipClass As Integer // Recipient class
82313>>>>>>>>>                                               // MAPI_TO, MAPI_CC, MAPI_BCC, MAPI_ORIG
82313>>>>>>>>>   Field MapiRecipDesc.lpszName As Pointer     // Recipient name
82313>>>>>>>>>   Field MapiRecipDesc.lpszAddress As Pointer  // Recipient address (optional)
82313>>>>>>>>>   Field MapiRecipDesc.ulEIDSize As Pointer    // Count in bytes of size of pEntryID
82313>>>>>>>>>   Field MapiRecipDesc.lpEntryID As Pointer    // System-specific recipient reference
82313>>>>>>>>>End_Type // MapiRecipDesc
82313>>>>>>>>>
82313>>>>>>>>>Define MAPI_ORIG   For 0 // Recipient is message originator
82313>>>>>>>>>Define MAPI_TO     For 1 // Recipient is a primary recipient
82313>>>>>>>>>Define MAPI_CC     For 2 // Recipient is a copy recipient
82313>>>>>>>>>Define MAPI_BCC    For 3 // Recipient is blind copy recipient
82313>>>>>>>>>
82313>>>>>>>>>Type MapiMessage
82313>>>>>>>>>   Field MapiMessage.ulReserved As Integer                   // Reserved for future use (M.B. 0)
82313>>>>>>>>>   Field MapiMessage.lpszSubject As Pointer                  // Message Subject
82313>>>>>>>>>   Field MapiMessage.lpszNoteText As Pointer                 // Message Text
82313>>>>>>>>>   Field MapiMessage.lpszMessageType As Pointer              // Message Class
82313>>>>>>>>>   Field MapiMessage.lpszDateReceived As Pointer             // in YYYY/MM/DD HH:MM format
82313>>>>>>>>>   Field MapiMessage.lpszConversationID As Pointer           // conversation thread ID
82313>>>>>>>>>   Field MapiMessage.flFlags As Integer                      // unread,return receipt
82313>>>>>>>>>   Field MapiMessage.lpOriginator As Pointer                 // Originator descriptor
82313>>>>>>>>>   Field MapiMessage.nRecipCount As Integer                  // Number of recipients
82313>>>>>>>>>   Field MapiMessage.lpRecips As Pointer                     // Recipient descriptors
82313>>>>>>>>>   Field MapiMessage.nFileCount As Integer                   // # of file attachments
82313>>>>>>>>>   Field MapiMessage.lpFiles As Pointer                      // Attachment descriptors
82313>>>>>>>>>End_Type // MapiMessage
82313>>>>>>>>>
82313>>>>>>>>>Define MAPI_UNREAD            For |CI$00000001
82313>>>>>>>>>Define MAPI_RECEIPT_REQUESTED For |CI$00000002
82313>>>>>>>>>Define MAPI_SENT              For |CI$00000004
82313>>>>>>>>>
82313>>>>>>>>>// MAPILogon() flags.
82313>>>>>>>>>Define MAPI_LOGON_UI         For |CI$00000001 // Display logon UI
82313>>>>>>>>>Define MAPI_PASSWORD_UI      For |CI$00020000 // prompt for password only
82313>>>>>>>>>Define MAPI_NEW_SESSION      For |CI$00000002 // Don't use shared session
82313>>>>>>>>>Define MAPI_FORCE_DOWNLOAD   For |CI$00001000 // Get new mail before return
82313>>>>>>>>>Define MAPI_ALLOW_OTHERS     For |CI$00000008 // Make this a shared session
82313>>>>>>>>>Define MAPI_EXPLICIT_PROFILE For |CI$00000010 // Don't use default profile
82313>>>>>>>>>Define MAPI_EXTENDED         For |CI$00000020 // Extended MAPI Logon
82313>>>>>>>>>Define MAPI_USE_DEFAULT      For |CI$00000040 // Use default profile in logon
82313>>>>>>>>>
82313>>>>>>>>>Define MAPI_SIMPLE_DEFAULT  For (MAPI_LOGON_UI + MAPI_FORCE_DOWNLOAD + MAPI_ALLOW_OTHERS)
82313>>>>>>>>>Define MAPI_SIMPLE_EXPLICIT For (MAPI_NEW_SESSION + MAPI_FORCE_DOWNLOAD + MAPI_EXPLICIT_PROFILE)
82313>>>>>>>>>
82313>>>>>>>>>// MAPILogoff() flags.
82313>>>>>>>>>Define MAPI_LOGOFF_SHARED For |CI$00000001 // Close all shared sessions
82313>>>>>>>>>Define MAPI_LOGOFF_UI     For |CI$00000002 // It's OK to present UI
82313>>>>>>>>>
82313>>>>>>>>>// MAPISendMail() flags.
82313>>>>>>>>>Define MAPI_LOGON_UI    For |CI$00000001 // Display logon UI
82313>>>>>>>>>Define MAPI_NEW_SESSION For |CI$00000002 // Don't use shared session
82313>>>>>>>>>
82313>>>>>>>>>Define MAPI_DIALOG      For |CI$00000008 // Display a send note UI
82313>>>>>>>>>Define MAPI_USE_DEFAULT For |CI$00000040 // Use default profile in logon
82313>>>>>>>>>
82313>>>>>>>>>// MAPIFindNext() flags.
82313>>>>>>>>>Define MAPI_UNREAD_ONLY    For |CI$00000020 // Only unread messages
82313>>>>>>>>>Define MAPI_GUARANTEE_FIFO For |CI$00000100 // use date order
82313>>>>>>>>>Define MAPI_LONG_MSGID     For |CI$00004000 // allow 512 char returned ID
82313>>>>>>>>>
82313>>>>>>>>>// MAPIReadMail() flags.
82313>>>>>>>>>Define MAPI_PEEK            For |CI$00000080 // Do not mark as read.
82313>>>>>>>>>Define MAPI_SUPPRESS_ATTACH For |CI$00000800 // header + body, no files
82313>>>>>>>>>Define MAPI_ENVELOPE_ONLY   For |CI$00000040 // Only header information
82313>>>>>>>>>Define MAPI_BODY_AS_FILE    For |CI$00000200
82313>>>>>>>>>
82313>>>>>>>>>// MAPISaveMail() flags.
82313>>>>>>>>>Define MAPI_LOGON_UI    For |CI$00000001 // Display logon UI
82313>>>>>>>>>Define MAPI_NEW_SESSION For |CI$00000002 // Don't use shared session
82313>>>>>>>>>Define MAPI_LONG_MSGID  For |CI$00004000 // allow 512 char returned ID
82313>>>>>>>>>
82313>>>>>>>>>// MAPIAddress() flags.
82313>>>>>>>>>Define MAPI_LOGON_UI    For |CI$00000001 // Display logon UI
82313>>>>>>>>>Define MAPI_NEW_SESSION For |CI$00000002 // Don't use shared session
82313>>>>>>>>>
82313>>>>>>>>>// MAPIDetails() flags.
82313>>>>>>>>>Define MAPI_LOGON_UI    For |CI$00000001 // Display logon UI
82313>>>>>>>>>Define MAPI_NEW_SESSION For |CI$00000002 // Don't use shared session
82313>>>>>>>>>Define MAPI_AB_NOMODIFY For |CI$00000400 // Don't allow mods of AB entries
82313>>>>>>>>>
82313>>>>>>>>>// MAPIResolveName() flags.
82313>>>>>>>>>Define MAPI_LOGON_UI    For |CI$00000001 // Display logon UI
82313>>>>>>>>>Define MAPI_NEW_SESSION For |CI$00000002 // Don't use shared session
82313>>>>>>>>>Define MAPI_DIALOG      For |CI$00000008 // Prompt for choices if ambiguous
82313>>>>>>>>>Define MAPI_AB_NOMODIFY For |CI$00000400 // Don't allow mods of AB entries
82313>>>>>>>>>
82313>>>>>>>>>Define SUCCESS_SUCCESS                 For 0
82313>>>>>>>>>Define MAPI_USER_ABORT                 For 1
82313>>>>>>>>>Define MAPI_E_USER_ABORT               For MAPI_USER_ABORT
82313>>>>>>>>>Define MAPI_E_FAILURE                  For 2
82313>>>>>>>>>Define MAPI_E_LOGON_FAILURE            For 3
82313>>>>>>>>>Define MAPI_E_LOGIN_FAILURE            For MAPI_E_LOGON_FAILURE
82313>>>>>>>>>Define MAPI_E_DISK_FULL                For 4
82313>>>>>>>>>Define MAPI_E_INSUFFICIENT_MEMORY      For 5
82313>>>>>>>>>Define MAPI_E_ACCESS_DENIED            For 6
82313>>>>>>>>>Define MAPI_E_TOO_MANY_SESSIONS        For 8
82313>>>>>>>>>Define MAPI_E_TOO_MANY_FILES           For 9
82313>>>>>>>>>Define MAPI_E_TOO_MANY_RECIPIENTS      For 10
82313>>>>>>>>>Define MAPI_E_ATTACHMENT_NOT_FOUND     For 11
82313>>>>>>>>>Define MAPI_E_ATTACHMENT_OPEN_FAILURE  For 12
82313>>>>>>>>>Define MAPI_E_ATTACHMENT_WRITE_FAILURE For 13
82313>>>>>>>>>Define MAPI_E_UNKNOWN_RECIPIENT        For 14
82313>>>>>>>>>Define MAPI_E_BAD_RECIPTYPE            For 15
82313>>>>>>>>>Define MAPI_E_NO_MESSAGES              For 16
82313>>>>>>>>>Define MAPI_E_INVALID_MESSAGE          For 17
82313>>>>>>>>>Define MAPI_E_TEXT_TOO_LARGE           For 18
82313>>>>>>>>>Define MAPI_E_INVALID_SESSION          For 19
82313>>>>>>>>>Define MAPI_E_TYPE_NOT_SUPPORTED       For 20
82313>>>>>>>>>Define MAPI_E_AMBIGUOUS_RECIPIENT      For 21
82313>>>>>>>>>Define MAPI_E_AMBIG_RECIP              For MAPI_E_AMBIGUOUS_RECIPIENT
82313>>>>>>>>>Define MAPI_E_MESSAGE_IN_USE           For 22
82313>>>>>>>>>Define MAPI_E_NETWORK_FAILURE          For 23
82313>>>>>>>>>Define MAPI_E_INVALID_EDITFIELDS       For 24
82313>>>>>>>>>Define MAPI_E_INVALID_RECIPS           For 25
82313>>>>>>>>>Define MAPI_E_NOT_SUPPORTED            For 26
82313>>>>>>>Use WinKern.pkg
82313>>>>>>>
82313>>>>>>>External_Function MAPILogon "MAPILogon" Mapi32.Dll ;   Integer ulUIParam ;   Pointer lpszProfileName ;   Pointer lpszPassword ;   Integer flFlags ;   Integer ulReserved ;   Pointer lplhSession ;   Returns Integer
82314>>>>>>>External_Function MAPILogoff "MAPILogoff" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Integer flFlags ;   Integer ulReserved ;   Returns Integer
82315>>>>>>>External_Function MAPIFindNext "MAPIFindNext" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpszMessageType ;   Pointer lpszSeedMessageID ;   Integer flFlags ;   Integer ulReserved ;   Pointer lpszMessageID ;   Returns Integer
82316>>>>>>>External_Function MAPIFreeBuffer "MAPIFreeBuffer" Mapi32.Dll ;   Pointer pv ;   Returns Integer
82317>>>>>>>External_Function MAPIReadMail "MAPIReadMail" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpszMessageID ;   Integer flFlags ;   Integer ulReserved ;   Pointer lppMessage ;   Returns Integer
82318>>>>>>>External_Function MAPIAddress "MAPIAddress" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpszCaption ;   Integer nEditFields ;   Pointer lpszLabels ;   Integer nRecips ;   Pointer lpRecips ;   Integer flFlags ;   Integer ulReserved ;   Pointer lpnNewRecips ;   Pointer lppNewRecips ;   Returns Integer
82319>>>>>>>External_Function MAPIResolveName "MAPIResolveName" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpszName ;   Integer flFlags ;   Integer ulReserved ;   Pointer lppRecip ;   Returns Integer
82320>>>>>>>External_Function MAPISendMail "MAPISendMail" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpMessage ;   Integer flFlags ;   Integer ulReserved ;   Returns Integer
82321>>>>>>>External_Function MAPISaveMail "MAPISaveMail" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpMessage ;   Integer flFlags ;   Integer ulReserved ;   Pointer lpszMessageID ;   Returns Integer
82322>>>>>>>External_Function MAPIDeleteMail "MAPIDeleteMail" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpszMessageID ;   Integer flFlags ;   Integer ulReserved ;   Returns Integer
82323>>>>>>>External_Function MAPISendDocuments "MAPISendDocuments" Mapi32.Dll ;   Integer ulUIParam ;   Pointer lpszDelimChar ;   Pointer lpszFullPaths ;   Pointer lpszFileNames ;   Integer ulReserved ;   Returns Integer
82324>>>>>>>External_Function MAPIDetails "MAPIDetails" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpRecip ;   Integer flFlags ;   Integer ulReserved ;   Returns Integer
82325>>>>>>>
82325>>>>>>>External_Function ShellExecute "ShellExecuteA" Shell32.Dll ;   Handle hwnd ;   String sOperation ;   String sFile ;   String sParameters ;   String sDirectory ;   Integer nShowCmd ;   Returns VOID_TYPE
82326>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (C:\Program Files (x86)\DataFlex 19.0\Pkg\DFBTRDRV.PKG)
82326>>>>>>>//****************************************************************************
82326>>>>>>>//
82326>>>>>>>// $File name  : DFBTRDRV.PKG
82326>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
82326>>>>>>>// Notice      : This package contains constants and commands, used to call
82326>>>>>>>//               specific functions in the DFBTRDRV.
82326>>>>>>>// $Author(s)  : Eddy Kleinjan
82326>>>>>>>//
82326>>>>>>>// $System     : DataFlex Connectivity Kit for Pervasive.SQL
82326>>>>>>>// Created     : 01-07-97 @ 12:00:00
82326>>>>>>>//
82326>>>>>>>// Changed     : 04-04-2001.
82326>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.145
82326>>>>>>>//
82326>>>>>>>// Changed     : June 6, 2001
82326>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.148
82326>>>>>>>//
82326>>>>>>>//               Added DFBTR_DDF_OWNER command.
82326>>>>>>>//
82326>>>>>>>// Changed     : June 12, 2001
82326>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.149
82326>>>>>>>//
82326>>>>>>>//               Added DF_FIELD_IS_NULL and DF_FIELD_NULL_ALLOWED attributes
82326>>>>>>>//
82326>>>>>>>// Changed     : August 4, 2004
82326>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 3.0.0.1
82326>>>>>>>//
82326>>>>>>>//               Added cDfbtrdrvHandler class.
82326>>>>>>>//               New functions in this class:
82326>>>>>>>//                  Function CKRevision Returns String
82326>>>>>>>//                  Function CkUsesUri Returns Integer
82326>>>>>>>//                  Function PSQLRequesterVersionInfo Integer iFileNum Returns String
82326>>>>>>>//                  Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
82326>>>>>>>//                  Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
82326>>>>>>>//
82326>>>>>>>// Changed     : September 30, 2005
82326>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 3.0.0.14
82326>>>>>>>//
82326>>>>>>>//               Bugfix: Prevent compiler errors when no (df)error.pkg is used
82326>>>>>>>//****************************************************************************
82326>>>>>>>Use Ui
82326>>>>>>>//
82326>>>>>>>// Driver Indentification
82326>>>>>>>//
82326>>>>>>>
82326>>>>>>>//*** Driver attributes
82326>>>>>>>//
82326>>>>>>>// Call_Driver functions ID's
82326>>>>>>>//
82326>>>>>>>//
82326>>>>>>>// DFBTRFN_CONVERT_FILE options
82326>>>>>>>//
82326>>>>>>>
82326>>>>>>>//
82326>>>>>>>// DFBTRFN_SET_OWNER options
82326>>>>>>>//
82326>>>>>>>
82326>>>>>>>//
82326>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
82326>>>>>>>//
82326>>>>>>>
82326>>>>>>>
82326>>>>>>>//
82326>>>>>>>// Command to create all vars which may be needed
82326>>>>>>>// in other commands.
82326>>>>>>>//
82326>>>>>>>
82326>>>>>>>
82326>>>>>>>
82326>>>>>>>//
82326>>>>>>>// Command to set the owner of a Btrieve file.
82326>>>>>>>// File must have been opened.
82326>>>>>>>// Filenumber needs to be passed.
82326>>>>>>>// To clear set the owner to "".
82326>>>>>>>// Examples:
82326>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
82326>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
82326>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
82326>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
82326>>>>>>>// To clear:
82326>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
82326>>>>>>>//
82326>>>>>>>
82326>>>>>>>
82326>>>>>>>
82326>>>>>>>//
82326>>>>>>>// Command to parse DFBTR_SET_OWNVER
82326>>>>>>>// options.
82326>>>>>>>//
82326>>>>>>>
82326>>>>>>>
82326>>>>>>>
82326>>>>>>>//
82326>>>>>>>// Command to parse for Callback
82326>>>>>>>//
82326>>>>>>>
82326>>>>>>>
82326>>>>>>>
82326>>>>>>>//
82326>>>>>>>// Command to clear the owner of a Btrieve file.
82326>>>>>>>// File must have been opened.
82326>>>>>>>// Filenumber needs to be passed.
82326>>>>>>>// Examples:
82326>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
82326>>>>>>>//
82326>>>>>>>
82326>>>>>>>
82326>>>>>>>
82326>>>>>>>//
82326>>>>>>>// Command to add a owner name to the internal list of ownernames
82326>>>>>>>// which will be tries when opening files.
82326>>>>>>>//
82326>>>>>>>
82326>>>>>>>
82326>>>>>>>
82326>>>>>>>//
82326>>>>>>>// Command to remove all owners from the internal list of ownernames
82326>>>>>>>//
82326>>>>>>>
82326>>>>>>>
82326>>>>>>>//
82326>>>>>>>// Command to set the owner name to be used when opening the DDF files.
82326>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
82326>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
82326>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
82326>>>>>>>//
82326>>>>>>>
82326>>>>>>>//
82326>>>>>>>// Command to change the transaction type.
82326>>>>>>>// Valid types are:
82326>>>>>>>//     DFBTRTT_NONE
82326>>>>>>>//     DFBTRTT_EXCLUSIVE
82326>>>>>>>//     DFBTRTT_CONCURRENT
82326>>>>>>>//
82326>>>>>>>//
82326>>>>>>>
82326>>>>>>>
82326>>>>>>>
82326>>>>>>>//
82326>>>>>>>// Command to get the current transaction type.
82326>>>>>>>//
82326>>>>>>>
82326>>>>>>>//
82326>>>>>>>// Command to set explicit_locking
82326>>>>>>>//
82326>>>>>>>
82326>>>>>>>//
82326>>>>>>>// Command to get explicit locking
82326>>>>>>>//
82326>>>>>>>
82326>>>>>>>//
82326>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
82326>>>>>>>//
82326>>>>>>>
82326>>>>>>>//
82326>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
82326>>>>>>>//
82326>>>>>>>
82326>>>>>>>//*****************************************************************************
82326>>>>>>>//*** Class  : cDfbtrdrvHandler                                                  ***
82326>>>>>>>//*** Purpose: An instance of this class can be used as a broker object to  ***
82326>>>>>>>//***          call several Dfbtrdrv releated methods.                           ***
82326>>>>>>>//*****************************************************************************
82326>>>>>>>
82326>>>>>>>Class cDFBtrDrvHandler Is An Array
82327>>>>>>>
82327>>>>>>>    Procedure Construct_Object Integer iImage
82329>>>>>>>        Forward Send Construct_object iImage
82331>>>>>>>
82331>>>>>>>        Property String  psDriverID       Public "DFBTRDRV"
82332>>>>>>>    End_Procedure // Construct_Object
82333>>>>>>>
82333>>>>>>>
82333>>>>>>>
82333>>>>>>>    //***
82333>>>>>>>    //*** Function: CKRevsion
82333>>>>>>>    //*** Purpose : The revsion of a Dfbtrdrv Connectivity Kit
82333>>>>>>>    //***
82333>>>>>>>
82333>>>>>>>    Function CKRevision Returns String
82335>>>>>>>        Local String  sDriverID
82335>>>>>>>        Local String  sRevision
82335>>>>>>>        Local String  sVoid
82335>>>>>>>        Local Integer iRetval
82335>>>>>>>
82335>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
82335>>>>>>>        // This error would otherwise be raised when we have an older
82335>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
82335>>>>>>>        Send Ignore_error To Error_object_Id 20491
82336>>>>>>>        Get psDriverID To sDriverID
82337>>>>>>>        Move (Repeat(" ", 255)) To sRevision
82338>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
82343>>>>>>>        Send Trap_Error To Error_object_Id 20491
82344>>>>>>>        If (Trim(sRevision) = "") Begin
82346>>>>>>>            // Unable to get the revision. return all zeroes.
82346>>>>>>>            Move "0.0.0.0" To sRevision
82347>>>>>>>        End
82347>>>>>>>>
82347>>>>>>>        Function_Return sRevision
82348>>>>>>>    End_Function // CKRevision
82349>>>>>>>
82349>>>>>>>    Function CkUsesUri Returns Integer
82351>>>>>>>        Local String  sDriverID
82351>>>>>>>        Local String  sVoid1
82351>>>>>>>        Local String  sVoid2
82351>>>>>>>        Local Integer iRetval
82351>>>>>>>
82351>>>>>>>        Get psDriverID To sDriverID
82352>>>>>>>
82352>>>>>>>        Move 0 To iRetval
82353>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
82353>>>>>>>        // This error would otherwise be raised when we have an older
82353>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
82353>>>>>>>        Send Ignore_error To Error_object_Id 20491
82354>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
82359>>>>>>>        Send Trap_Error To Error_object_Id 20491
82360>>>>>>>
82360>>>>>>>        Function_Return iRetval
82361>>>>>>>    End_Function // CKUsesUri
82362>>>>>>>
82362>>>>>>>
82362>>>>>>>
82362>>>>>>>    //***
82362>>>>>>>    //*** Function: ExtractPartFromRevsion
82362>>>>>>>    //*** Purpose : Extarct the Nth part of a a.b.c.d revsion string.
82362>>>>>>>    //***
82362>>>>>>>    //*** Returns : The part version number or -1 if there is no such part number.
82362>>>>>>>    //***
82362>>>>>>>
82362>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
82364>>>>>>>        Local Integer iPartRev
82364>>>>>>>        Local Integer iCurrentPart
82364>>>>>>>        Local Integer iSeparatorPos
82364>>>>>>>
82364>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
82367>>>>>>>
82367>>>>>>>        Move 0 To iCurrentPart
82368>>>>>>>        Repeat
82368>>>>>>>>
82368>>>>>>>            Move (Pos(".", sRevision)) To iSeparatorPos
82369>>>>>>>            If (iSeparatorPos > 0) Begin
82371>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) To iPartRev
82372>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) To sRevision
82373>>>>>>>                Increment iCurrentPart
82374>>>>>>>            End
82374>>>>>>>>
82374>>>>>>>            Else If (sRevision <> "") Begin
82377>>>>>>>                Move sRevision To iPartRev
82378>>>>>>>                Move "" To sRevision
82379>>>>>>>                Increment iCurrentPart
82380>>>>>>>            End
82380>>>>>>>>
82380>>>>>>>            Else ;                Move -1 To iPartRev
82382>>>>>>>        Until (iCurrentPart >= iPartNum Or iPartRev = -1)
82384>>>>>>>
82384>>>>>>>        Function_Return iPartRev
82385>>>>>>>    End_Function // EcxtractPartFromRevision
82386>>>>>>>
82386>>>>>>>
82386>>>>>>>
82386>>>>>>>    //***
82386>>>>>>>    //*** Function: CKMajorRevision
82386>>>>>>>    //*** Purpose : Returns the major revision of the CK
82386>>>>>>>    //***
82386>>>>>>>
82386>>>>>>>    Function CKMajorRevision Returns Integer
82388>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
82389>>>>>>>    End_Function // CKMajorRevision
82390>>>>>>>
82390>>>>>>>
82390>>>>>>>
82390>>>>>>>    //***
82390>>>>>>>    //*** Function: CKMinorRevision
82390>>>>>>>    //*** Purpose : Returns the minor revision of the CK
82390>>>>>>>    //***
82390>>>>>>>
82390>>>>>>>    Function CKMinorRevision Returns Integer
82392>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
82393>>>>>>>    End_Function // CKMinorRevision
82394>>>>>>>
82394>>>>>>>
82394>>>>>>>
82394>>>>>>>    //***
82394>>>>>>>    //*** Function: CKReleaseRevision
82394>>>>>>>    //*** Purpose : Returns the release revision of the CK
82394>>>>>>>    //***
82394>>>>>>>
82394>>>>>>>    Function CKReleaseRevision Returns Integer
82396>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
82397>>>>>>>    End_Function // CKReleaseRevision
82398>>>>>>>
82398>>>>>>>
82398>>>>>>>
82398>>>>>>>    //***
82398>>>>>>>    //*** Function: CKBuildRevision
82398>>>>>>>    //*** Purpose : Returns the major revision of the CK
82398>>>>>>>    //***
82398>>>>>>>
82398>>>>>>>    Function CKBuildRevision Returns Integer
82400>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
82401>>>>>>>    End_Function // CKBuildRevision
82402>>>>>>>
82402>>>>>>>
82402>>>>>>>
82402>>>>>>>    //***
82402>>>>>>>    //*** Function: IsMinimalRevision
82402>>>>>>>    //*** Purpose : Determines if the CK conforms to a passed minimal revsion.
82402>>>>>>>    //***
82402>>>>>>>
82402>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
82404>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_return (TRUE)
82407>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
82410>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_return (TRUE)
82413>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
82416>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_return (TRUE)
82419>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) And iBuild <= CKBuildRevision(Current_object)) ;                    Function_return (TRUE)
82423>>>>>>>            End
82423>>>>>>>>
82423>>>>>>>        End
82423>>>>>>>>
82423>>>>>>>
82423>>>>>>>        Function_Return (FALSE)
82424>>>>>>>    End_Function // IsMinimalRevision
82425>>>>>>>
82425>>>>>>>    //   Functions to query the Pervasive.SQL version:
82425>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
82425>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
82425>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
82425>>>>>>>    //
82425>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
82425>>>>>>>    //   in the following format:
82425>>>>>>>    //       <version>.<revision>.<type>
82425>>>>>>>    //   possible values for <type>:
82425>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
82425>>>>>>>    //         server using Workgroup authentication mode
82425>>>>>>>    //       C for client cache engine
82425>>>>>>>    //       D for DOS workstation
82425>>>>>>>    //       N for client Requester
82425>>>>>>>    //       S for NetWare server
82425>>>>>>>    //       T for 32-bit Windows server engine
82425>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
82425>>>>>>>    //
82425>>>>>>>    //   example:
82425>>>>>>>    //       8.50.T
82425>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
82425>>>>>>>    //   32-bits Windows server.
82425>>>>>>>    //
82425>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
82425>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
82425>>>>>>>    //
82425>>>>>>>    //   If the version information is not available or can not be obtained
82425>>>>>>>    //   the functions will return "0.0.0"
82425>>>>>>>
82425>>>>>>>
82425>>>>>>>    //***
82425>>>>>>>    //*** Function: PSQLRequesterVersionInfo
82425>>>>>>>    //*** Purpose : Returns the version information of the
82425>>>>>>>    //***           Pervasive.SQL Client requester.
82425>>>>>>>
82425>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
82427>>>>>>>
82427>>>>>>>        Local String  sDriverID
82427>>>>>>>        Local String  sVersion
82427>>>>>>>        Local String  sVoid
82427>>>>>>>        Local Integer iRetval
82427>>>>>>>
82427>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
82427>>>>>>>        // This error would otherwise be raised when we have an older
82427>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
82427>>>>>>>        Send Ignore_error To Error_object_Id 20491
82428>>>>>>>        Get psDriverID To sDriverID
82429>>>>>>>        Move (Repeat(" ", 255)) To sVersion
82430>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
82435>>>>>>>        Send Trap_Error To Error_object_Id 20491
82436>>>>>>>        If (Trim(sVersion) = "") Begin
82438>>>>>>>            // Unable to get the revision. return all zeroes.
82438>>>>>>>            Move "0.0.0" To sVersion
82439>>>>>>>        End
82439>>>>>>>>
82439>>>>>>>        Function_Return sVersion
82440>>>>>>>    End_Function //  PSQLRequesterVersion
82441>>>>>>>
82441>>>>>>>    //***
82441>>>>>>>    //*** Function: PSQLLocalEngineVersionInfo
82441>>>>>>>    //*** Purpose : Returns the version information of the
82441>>>>>>>    //***           Pervasive.SQL Local Engine
82441>>>>>>>
82441>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
82443>>>>>>>
82443>>>>>>>        Local String  sDriverID
82443>>>>>>>        Local String  sVersion
82443>>>>>>>        Local String  sVoid
82443>>>>>>>        Local Integer iRetval
82443>>>>>>>
82443>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
82443>>>>>>>        // This error would otherwise be raised when we have an older
82443>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
82443>>>>>>>        Send Ignore_error To Error_object_Id 20491
82444>>>>>>>        Get psDriverID To sDriverID
82445>>>>>>>        Move (Repeat(" ", 255)) To sVersion
82446>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
82451>>>>>>>        Send Trap_Error To Error_object_Id 20491
82452>>>>>>>        If (Trim(sVersion) = "") Begin
82454>>>>>>>            // Unable to get the revision. return all zeroes.
82454>>>>>>>            Move "0.0.0" To sVersion
82455>>>>>>>        End
82455>>>>>>>>
82455>>>>>>>        Function_Return sVersion
82456>>>>>>>    End_Function //  PSQLLocalEngineVersion
82457>>>>>>>
82457>>>>>>>    //***
82457>>>>>>>    //*** Function: PSQLServerEngineVersionInfo
82457>>>>>>>    //*** Purpose : Returns the version information of the
82457>>>>>>>    //***           Pervasive.SQL Server Engine
82457>>>>>>>
82457>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
82459>>>>>>>
82459>>>>>>>        Local String  sDriverID
82459>>>>>>>        Local String  sVersion
82459>>>>>>>        Local String  sVoid
82459>>>>>>>        Local Integer iRetval
82459>>>>>>>
82459>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
82459>>>>>>>        // This error would otherwise be raised when we have an older
82459>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
82459>>>>>>>        Send Ignore_error To Error_object_Id 20491
82460>>>>>>>        Get psDriverID To sDriverID
82461>>>>>>>        Move (Repeat(" ", 255)) To sVersion
82462>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
82467>>>>>>>        Send Trap_Error To Error_object_Id 20491
82468>>>>>>>        If (Trim(sVersion) = "") Begin
82470>>>>>>>            // Unable to get the revision. return all zeroes.
82470>>>>>>>            Move "0.0.0" To sVersion
82471>>>>>>>        End
82471>>>>>>>>
82471>>>>>>>        Function_Return sVersion
82472>>>>>>>    End_Function //  PSQLServerEngineVersion
82473>>>>>>>
82473>>>>>>>End_Class // cDfbtrdrvHandler
82474>>>>>>>
82474>>>>>Use MSSqldrv.pkg
Including file: MSSqldrv.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\MSSqldrv.pkg)
82474>>>>>>>//*****************************************************************************
82474>>>>>>>//*** MSSQLDRV.PKG                                                          ***
82474>>>>>>>//***                                                                       ***
82474>>>>>>>//*** Author: Ben Weijers                                                   ***
82474>>>>>>>//***         Data Access Nederland                                         ***
82474>>>>>>>//***         29 June 1998                                                  ***
82474>>>>>>>//***                                                                       ***
82474>>>>>>>//***                                                                       ***
82474>>>>>>>//*** Purpose:                                                              ***
82474>>>>>>>//***   Package that declares MS SQL driver constants and functions.        ***
82474>>>>>>>//****                                                                      ***
82474>>>>>>>//***   This package can be used by developers who want to add Data Access  ***
82474>>>>>>>//***   MS SQL Client specific code to a DataFlex application.              ***
82474>>>>>>>//***   Updated:  June 4th 2012 (Current CK build: 5.1.0.96)                ***
82474>>>>>>>//***             Changed EnumerateServers function to use the highest      ***
82474>>>>>>>//***             available SQL Server client driver.                       ***
82474>>>>>>>//***             Moved SQL Server client constants from cli.pkg to         ***
82474>>>>>>>//***             mssqldrv.pkg                                              ***
82474>>>>>>>//***   Updated:  November 6th 2013 (Current CK build: 6.0.0.19)            ***
82474>>>>>>>//***             Added constants for SQL Server specific native types      ***
82474>>>>>>>//***             ( var...(max) types, money types, datetime types)         ***
82474>>>>>>>//*****************************************************************************
82474>>>>>>>
82474>>>>>>>Use Cli.pkg
82474>>>>>>>Use SQL.pkg
82474>>>>>>>
82474>>>>>>>//*** Driver Indentification
82474>>>>>>>
82474>>>>>>>//*** Error number constants
82474>>>>>>>
82474>>>>>>>
82474>>>>>>>//*** Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
82474>>>>>>>
82474>>>>>>>
82474>>>>>>>
82474>>>>>>>
82474>>>>>>>
82474>>>>>>>
82474>>>>>>>// SQL Server spcific types. 
82474>>>>>>>Define SQL_SS_TIMESTAMPOFFSET   for   (-155) //SQL server datetimeoffset type */
82474>>>>>>>Define SQL_SS_TIME2             for   (-154) //SQL server time type */
82474>>>>>>>Define SQL_SS_XML               for   (-152) //SQL server xml type */
82474>>>>>>>Define SQL_SS_VARIANT           for   (-150) //SQL server variant type */
82474>>>>>>>
82474>>>>>>>// SQL Server spcific types. 
82474>>>>>>>Define SQL_TYPE_TIMESTAMP2      for   (-200) //SQL server datetime2 type */
82474>>>>>>>Define SQL_VARCHARMAX           for   (-201) //SQL server varchar(max) type */
82474>>>>>>>Define SQL_WVARCHARMAX          for   (-202) //SQL server wvarchar(max) type */
82474>>>>>>>Define SQL_VARBINARYMAX         for   (-203) //SQL server varbinary(max) type */
82474>>>>>>>Define SQL_TYPE_MONEY           for   (-204) //SQL server money type */
82474>>>>>>>Define SQL_TYPE_SMALLMONEY      for   (-205) //SQL server smallmoney type */
82474>>>>>>>Define SQL_TYPE_SMALLDATETIME   for   (-206) //SQL server smalldatetype type */
82474>>>>>>>
82474>>>>>>>
82474>>>>>>>//*****************************************************************************
82474>>>>>>>//*** MSSQL_SetConstraint <FileNum> <ConstraintText>                        ***
82474>>>>>>>//***                                                                       ***
82474>>>>>>>//***   Setup a constraint for a file.                                      ***
82474>>>>>>>//*****************************************************************************
82474>>>>>>>
82474>>>>>>>
82474>>>>>>>
82474>>>>>>>Class cMSSQLHandler Is A cCLIHandler
82475>>>>>>>
82475>>>>>>>    Procedure Construct_Object
82477>>>>>>>        Forward Send Construct_Object
82479>>>>>>>
82479>>>>>>>        Set psDriverID To MSSQLDRV_ID
82480>>>>>>>    End_Procedure // Construct_Object
82481>>>>>>>
82481>>>>>>>
82481>>>>>>>
82481>>>>>>>    //***
82481>>>>>>>    //*** Function: ExtractList
82481>>>>>>>    //*** Purpose : Extract the list from the out connect string.
82481>>>>>>>    //***
82481>>>>>>>
82481>>>>>>>    Function ExtractList String sOutConnStr Integer hoStore Returns Integer
82483>>>>>>>        Local String  sItem
82483>>>>>>>        Local Integer iStart
82483>>>>>>>        Local Integer iEnd
82483>>>>>>>
82483>>>>>>>        If (hoStore = 0) ;            Move Current_object To hoStore
82486>>>>>>>
82486>>>>>>>        Send Delete_Data To hoStore
82487>>>>>>>        Move (Pos("{", sOutConnStr)) To iStart
82488>>>>>>>        While (iStart > 0)
82492>>>>>>>            Move (Right(sOutConnStr, Length(sOutConnStr) - iStart)) To sOutConnStr
82493>>>>>>>            If (Left(sOutConnStr, 1) = "}") ;                Move 0 To iStart
82496>>>>>>>            Else Begin
82497>>>>>>>                Move (Pos(",", sOutConnStr)) To iStart
82498>>>>>>>                Move (Pos("}", sOutConnStr)) To iEnd
82499>>>>>>>                If ((iStart = 0) Or (iEnd < iStart)) ;                    Move iEnd To iStart
82502>>>>>>>
82502>>>>>>>                If (iStart > 0) ;                    Set Value Of hoStore Item (Item_Count(Current_Object)) To (Left(sOutConnStr, iStart - 1))
82505>>>>>>>
82505>>>>>>>                If (iStart = iEnd) ;                    Move 0 To iStart
82508>>>>>>>            End
82508>>>>>>>>
82508>>>>>>>        Loop
82509>>>>>>>>
82509>>>>>>>
82509>>>>>>>        Function_Return (Item_Count(hoStore))
82510>>>>>>>    End_Procedure // ExtractList
82511>>>>>>>
82511>>>>>>>
82511>>>>>>>
82511>>>>>>>    //***
82511>>>>>>>    //*** Function: BrowseConnect
82511>>>>>>>    //*** Purpose : Call the driver's browse connect function
82511>>>>>>>    //***
82511>>>>>>>
82511>>>>>>>    Function BrowseConnect String sInConnStr Returns String
82513>>>>>>>        Local String  sDriver
82513>>>>>>>        Local String  sOutConnStr
82513>>>>>>>        Local Integer iArg
82513>>>>>>>        Local Integer iRetval
82513>>>>>>>
82513>>>>>>>        Get psDriverID To sDriver
82514>>>>>>>        If (sDriver <> "") Begin
82516>>>>>>>            Move (Repeat(" ", 8192)) To sOutConnStr
82517>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
82522>>>>>>>        End
82522>>>>>>>>
82522>>>>>>>
82522>>>>>>>        Function_Return sOutConnStr
82523>>>>>>>    End_Function// BrowseConnect
82524>>>>>>>
82524>>>>>>>
82524>>>>>>>    Function BrowseConnectLocal String sInConnStr Returns String
82526>>>>>>>        Local String  sDriver
82526>>>>>>>        Local String  sOutConnStr
82526>>>>>>>        Local Integer iArg
82526>>>>>>>        Local Integer iRetval
82526>>>>>>>        
82526>>>>>>>        Move 1 to iArg // Browses only local
82527>>>>>>>
82527>>>>>>>        Get psDriverID to sDriver
82528>>>>>>>        If (sDriver <> "") Begin
82530>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
82531>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
82536>>>>>>>        End
82536>>>>>>>>
82536>>>>>>>
82536>>>>>>>        Function_Return sOutConnStr
82537>>>>>>>    End_Function// BrowseConnect
82538>>>>>>>
82538>>>>>>>
82538>>>>>>>    Function DriverIndex String sDriver Returns Integer
82540>>>>>>>    
82540>>>>>>>        Local String  sCurrentDriver
82540>>>>>>>        Local Integer iNumberOfDrivers iDriver iCount
82540>>>>>>>    
82540>>>>>>>        Move 0 to iDriver
82541>>>>>>>    
82541>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
82544>>>>>>>        For iCount from 1 to iNumberOfDrivers
82550>>>>>>>>
82550>>>>>>>    
82550>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
82553>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriver) ) Begin
82555>>>>>>>                Move iCount to iDriver
82556>>>>>>>            End
82556>>>>>>>>
82556>>>>>>>        Loop
82557>>>>>>>>
82557>>>>>>>    
82557>>>>>>>        Function_Return iDriver
82558>>>>>>>    
82558>>>>>>>    End_Function 
82559>>>>>>>
82559>>>>>>>    Function EnumerateServersNetworkOrLocal Integer iNetworkLocal  Returns Integer
82561>>>>>>>        
82561>>>>>>>        Local String  sServerList
82561>>>>>>>        Local Integer iNumServers
82561>>>>>>>        Local Integer iDriver
82561>>>>>>>        Local Integer iClientVersion
82561>>>>>>>        Local String  sDriver
82561>>>>>>>        
82561>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
82562>>>>>>>
82562>>>>>>>        If (iDriver) Begin
82564>>>>>>>                
82564>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
82567>>>>>>>            
82567>>>>>>>            Case Begin
82567>>>>>>>    
82567>>>>>>>                Case (iClientVersion = SQLSERVER2016CLIENT)
82569>>>>>>>                    Move SQLSERVER2016DRVRSTR to sDriver
82570>>>>>>>                    Case Break
82571>>>>>>>    
82571>>>>>>>                Case (iClientVersion = SQLSERVER2014CLIENT)
82574>>>>>>>                    Move SQLSERVER2014DRVRSTR to sDriver
82575>>>>>>>                    Case Break
82576>>>>>>>            
82576>>>>>>>                Case (iClientVersion = SQLSERVER2012CLIENT)
82579>>>>>>>                    Move SQLSERVER2012DRVRSTR to sDriver
82580>>>>>>>                    Case Break
82581>>>>>>>    
82581>>>>>>>                Case (iClientVersion = SQLSERVER2008CLIENT)
82584>>>>>>>                    Move SQLSERVER2008DRVRSTR to sDriver
82585>>>>>>>                    Case Break
82586>>>>>>>    
82586>>>>>>>                Case (iClientVersion = SQLSERVER2005CLIENT)
82589>>>>>>>                    Move SQLSERVER2005DRVRSTR to sDriver
82590>>>>>>>                    Case Break
82591>>>>>>>            
82591>>>>>>>                Case (iClientVersion = SQLSERVER2000CLIENT)
82594>>>>>>>                    Move SQLSERVER2000DRVRSTR to sDriver
82595>>>>>>>                    Case Break
82596>>>>>>>            
82596>>>>>>>                Case Else
82596>>>>>>>                    Move SQLSERVER2000DRVRSTR to sDriver
82597>>>>>>>            
82597>>>>>>>            Case End
82597>>>>>>>    
82597>>>>>>>            Move ("DRIVER={" + sDriver + "};") to sDriver
82598>>>>>>>            If (iNetworkLocal = 0) Begin
82600>>>>>>>                Get BrowseConnect sDriver to sServerList
82601>>>>>>>            End
82601>>>>>>>>
82601>>>>>>>            Else Begin
82602>>>>>>>                Get BrowseConnectLocal sDriver to sServerList
82603>>>>>>>            End
82603>>>>>>>>
82603>>>>>>>            Get ExtractList sServerList Current_object to iNumServers
82604>>>>>>>        End
82604>>>>>>>>
82604>>>>>>>        
82604>>>>>>>        Function_Return iNumServers
82605>>>>>>>        
82605>>>>>>>    End_Function
82606>>>>>>>
82606>>>>>>>    //***
82606>>>>>>>    //*** Procedure: EnumerateServers
82606>>>>>>>    //*** Purpose  : Enumerate the available SQL Server database servers
82606>>>>>>>    //***            This function will return all SQL Server instances on the network. 
82606>>>>>>>    //***            This may take a long time. 
82606>>>>>>>    //***            To enumerate only local SQL Server instances use EnumerateServersLocal 
82606>>>>>>>    Function EnumerateServers Returns Integer
82608>>>>>>>
82608>>>>>>>        Local Integer iNumServers
82608>>>>>>>        Local Integer iNetworkLocal
82608>>>>>>>        
82608>>>>>>>        Move 0 to iNetworkLocal // 0 = enumerate network servers
82609>>>>>>>        
82609>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
82610>>>>>>>        
82610>>>>>>>        Function_Return iNumServers
82611>>>>>>>        
82611>>>>>>>    End_Function
82612>>>>>>>
82612>>>>>>>
82612>>>>>>>    //***
82612>>>>>>>    //*** Procedure: EnumerateServersLocal
82612>>>>>>>    //*** Purpose  : Enumerate the available SQL Server database servers
82612>>>>>>>    //***            This function will return only return SQL Server instance on the local machine
82612>>>>>>>    //***            To enumerate all SQL Server instances in a network use EnumerateServers
82612>>>>>>>    Function EnumerateServersLocal Returns Integer
82614>>>>>>>
82614>>>>>>>        Local Integer iNumServers
82614>>>>>>>        Local Integer iNetworkLocal
82614>>>>>>>        
82614>>>>>>>        Move 1 to iNetworkLocal // 1 = enumerate local servers
82615>>>>>>>        
82615>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
82616>>>>>>>        
82616>>>>>>>        Function_Return iNumServers
82617>>>>>>>        
82617>>>>>>>    End_Function
82618>>>>>>>
82618>>>>>>>    
82618>>>>>>>
82618>>>>>>>    //***
82618>>>>>>>    //*** Function: EnumerateDatabases
82618>>>>>>>    //*** Purpose : Enumerate database in a given server.
82618>>>>>>>    //***
82618>>>>>>>
82618>>>>>>>    Function EnumerateDatabases String sServer String sUser String sPassWord Returns Integer
82620>>>>>>>        Local Integer hoSQL
82620>>>>>>>        Local String  sConnect
82620>>>>>>>        Local String  sDatabase
82620>>>>>>>        Local Integer hdbc
82620>>>>>>>        Local Integer hstmt
82620>>>>>>>        Local Integer iFetchResult
82620>>>>>>>
82620>>>>>>>        If (Num_Arguments < 3) ;            Move "" To sPassWord
82623>>>>>>>        If (Num_Arguments < 2) ;            Move "" To sUser
82626>>>>>>>
82626>>>>>>>        If (sUser <> "") ;            Move ("SERVER=" + Trim(sServer) + ";UID=" + Trim(sUser) + ";PWD=" + Trim(sPassword) + ";") To sConnect
82629>>>>>>>        Else ;            Move ("SERVER=" + Trim(sServer) + ";Trusted_Connection=yes") To sConnect
82631>>>>>>>
82631>>>>>>>        Object oEnumDBSQLmanager Is A cSQLHandleManager
82633>>>>>>>            Move Current_Object To hoSQL
82634>>>>>>>        End_Object // oEnumDBSQLManager
82635>>>>>>>
82635>>>>>>>        If (hoSQL <> 0) Begin
82637>>>>>>>            Get SQLConnect Of hoSQL "MSSQLDRV" sConnect To hdbc
82638>>>>>>>            If (hdbc <> 0) Begin
82640>>>>>>>                Get SQLOpen Of hdbc To hstmt
82641>>>>>>>                If (hstmt <> 0) Begin
82643>>>>>>>                    //*** We could do a direct select on the sysdatabases table but we use
82643>>>>>>>                    //*** the stored procedure sp_database instead. SQL Server recommends this
82643>>>>>>>                    //*** approach in case meta data might change, the stored procedure will
82643>>>>>>>                    //*** stay the same.
82643>>>>>>>                    Send SQLSetProcedureName To hstmt "sp_databases"
82644>>>>>>>                    Send SQLCall To hstmt
82645>>>>>>>                    Repeat
82645>>>>>>>>
82645>>>>>>>                        Get SQLFetch Of hstmt To iFetchResult
82646>>>>>>>                        If (iFetchResult <> 0) Begin
82648>>>>>>>                            Get SQLColumnValue Of hstmt 1 To sDatabase
82649>>>>>>>                            Set Value Item (Item_Count(Current_Object)) To sDatabase
82650>>>>>>>                        End
82650>>>>>>>>
82650>>>>>>>                    Until (iFetchResult = 0)
82652>>>>>>>
82652>>>>>>>                    Send SQLClose To hstmt
82653>>>>>>>                End
82653>>>>>>>>
82653>>>>>>>                Send SQLDisconnect To hdbc
82654>>>>>>>            End
82654>>>>>>>>
82654>>>>>>>        End
82654>>>>>>>>
82654>>>>>>>        Send Destroy_Object To hoSQL
82655>>>>>>>
82655>>>>>>>        Function_return (Item_Count(Current_Object))
82656>>>>>>>    End_Function // EnumerateDatabases
82657>>>>>>>
82657>>>>>>>
82657>>>>>>>    Function SqlServerClientVersionName Integer iClientVersion  Returns String
82659>>>>>>>        
82659>>>>>>>        Local String  sSqlServerClientVersionName
82659>>>>>>>        
82659>>>>>>>            
82659>>>>>>>        Case Begin
82659>>>>>>>
82659>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
82661>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
82662>>>>>>>                Case Break
82663>>>>>>>
82663>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
82666>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
82667>>>>>>>                Case Break
82668>>>>>>>        
82668>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
82671>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
82672>>>>>>>                Case Break
82673>>>>>>>
82673>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
82676>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
82677>>>>>>>                Case Break
82678>>>>>>>
82678>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
82681>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
82682>>>>>>>                Case Break
82683>>>>>>>        
82683>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
82686>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
82687>>>>>>>                Case Break
82688>>>>>>>        
82688>>>>>>>            Case Else
82688>>>>>>>                Move SQLSERVERUNKNOWNCLIENTNAME to sSqlServerClientVersionName
82689>>>>>>>        
82689>>>>>>>        Case End
82689>>>>>>>    
82689>>>>>>>        
82689>>>>>>>        Function_Return sSqlServerClientVersionName
82690>>>>>>>        
82690>>>>>>>    End_Function
82691>>>>>>>
82691>>>>>>>
82691>>>>>>>End_Class // cMSSQLHandler
82692>>>>>>>
82692>>>>>Use db2_drv.pkg
Including file: db2_drv.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\db2_drv.pkg)
82692>>>>>>>//*****************************************************************************
82692>>>>>>>//*** DB2_DRV.PKG                                                           ***
82692>>>>>>>//***                                                                       ***
82692>>>>>>>//*** Author: Ben Weijers                                                   ***
82692>>>>>>>//***         Data Access Nederland                                         ***
82692>>>>>>>//***         30 July 1998                                                  ***
82692>>>>>>>//***                                                                       ***
82692>>>>>>>//*** Last updated: May 2, 2007                                                                      ***
82692>>>>>>>//***                                                                       ***
82692>>>>>>>//*** Purpose:                                                              ***
82692>>>>>>>//***   Package that declares DB2 driver constants and functions.           ***
82692>>>>>>>//****                                                                      ***
82692>>>>>>>//***   This package can be used by developers who want to add DB2 driver   ***
82692>>>>>>>//***   specific code to a DataFlex application.                            ***
82692>>>>>>>//*****************************************************************************
82692>>>>>>>
82692>>>>>>>Use Cli.pkg
82692>>>>>>>
82692>>>>>>>//*** Driver attributes
82692>>>>>>>
82692>>>>>>>
82692>>>>>>>//*** Driver Indentification
82692>>>>>>>
82692>>>>>>>//*** Error number constants
82692>>>>>>>
82692>>>>>>>//*** Call driver function identifiers
82692>>>>>>>
82692>>>>>>>// DB2 specific data types
82692>>>>>>>Define SQL_CLOB           for   (-99)  
82692>>>>>>>Define SQL_BLOB           for   (-98)  
82692>>>>>>>Define SQL_XML            for   (-370) 
82692>>>>>>>// DB2 Graphic types are Unicode types
82692>>>>>>>Define SQL_GRAPHIC        for   (-95)  
82692>>>>>>>Define SQL_VARGRAPHIC     for   (-96)  
82692>>>>>>>Define SQL_LONGVARGRAPHIC for   (-97)  
82692>>>>>>>Define SQL_DBCLOB         for   (-350) 
82692>>>>>>>
82692>>>>>>>
82692>>>>>>>//*** Extra DB2 commands
82692>>>>>>>
82692>>>>>>>
82692>>>>>>>//*****************************************************************************
82692>>>>>>>//*** DB2_CheckTrigger <NewState>                                           ***
82692>>>>>>>//***                                                                       ***
82692>>>>>>>//*** This command will set the trigger check at open on or off.            ***
82692>>>>>>>//*****************************************************************************
82692>>>>>>>
82692>>>>>>>
82692>>>>>>>
82692>>>>>>>//*****************************************************************************
82692>>>>>>>//*** DB2_SetConstraint <FileNum> <ConstraintText>                          ***
82692>>>>>>>//***                                                                       ***
82692>>>>>>>//***   Setup a constraint for a file.                                      ***
82692>>>>>>>//*****************************************************************************
82692>>>>>>>
82692>>>>>>>
82692>>>>>>>
82692>>>>>>>Class cDB2Handler Is A cCLIHandler
82693>>>>>>>
82693>>>>>>>    Procedure Construct_Object
82695>>>>>>>        Forward Send Construct_Object
82697>>>>>>>
82697>>>>>>>        Set psDriverID To DB2_DRV_ID
82698>>>>>>>    End_Procedure // Construct_Object
82699>>>>>>>
82699>>>>>>>
82699>>>>>>>
82699>>>>>>>    //***
82699>>>>>>>    //*** Procedure: SeedDataSources
82699>>>>>>>    //*** Purpose  : Reset the datasource list to the beginning
82699>>>>>>>    //***
82699>>>>>>>
82699>>>>>>>    Procedure SeedDataSources
82701>>>>>>>        Local String  sDriver
82701>>>>>>>        Local String  sVoid
82701>>>>>>>        Local Integer iRetval
82701>>>>>>>
82701>>>>>>>        Get psDriverID To sDriver
82702>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid SQL_FETCH_ALL Result iRetval
82709>>>>>>>    End_Procedure // SeedDataSources
82710>>>>>>>
82710>>>>>>>
82710>>>>>>>
82710>>>>>>>    //***
82710>>>>>>>    //*** Function: DataSources
82710>>>>>>>    //*** Purpose : Call the driver's data sources function
82710>>>>>>>    //***
82710>>>>>>>
82710>>>>>>>    Function DataSources Returns String
82712>>>>>>>        Local String  sDriver
82712>>>>>>>        Local String  sDataSource
82712>>>>>>>        Local String  sDescription
82712>>>>>>>        Local Integer iLength
82712>>>>>>>        Local Integer iRetval
82712>>>>>>>
82712>>>>>>>        Get psDriverID To sDriver
82713>>>>>>>        If (sDriver <> "") Begin
82715>>>>>>>            Move 8192 To iLength
82716>>>>>>>            Move (Repeat(" ", iLength)) To sDataSource
82717>>>>>>>            Move (Repeat(" ", iLength)) To sDescription
82718>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
82723>>>>>>>        End
82723>>>>>>>>
82723>>>>>>>
82723>>>>>>>        If (sDataSource <> "" Or sDescription <> "") ;            Function_Return (sDataSource + "," +  sDescription)
82726>>>>>>>        Else ;            Function_Return ""
82728>>>>>>>    End_Function// DataSources
82729>>>>>>>
82729>>>>>>>End_Class // cODBCHandler
82730>>>>>>>
82730>>>>>>>
82730>>>>>Use odbc_drv.pkg
Including file: odbc_drv.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\odbc_drv.pkg)
82730>>>>>>>//*****************************************************************************
82730>>>>>>>//*** ODBC_DRV.PKG                                                          ***
82730>>>>>>>//***                                                                       ***
82730>>>>>>>//*** Author: Ben Weijers                                                   ***
82730>>>>>>>//***         Data Access Nederland                                         ***
82730>>>>>>>//***         3 February 1998                                               ***
82730>>>>>>>//***                                                                       ***
82730>>>>>>>//*** Last updated: May 2, 2007                                                                      ***
82730>>>>>>>//***                                                                       ***
82730>>>>>>>//*** Purpose:                                                              ***
82730>>>>>>>//***   Package that declares ODBC driver constants and functions.          ***
82730>>>>>>>//****                                                                      ***
82730>>>>>>>//***   This package can be used by developers who want to add Data Access  ***
82730>>>>>>>//***   ODBC Client specific code to a DataFlex application.                ***
82730>>>>>>>//*****************************************************************************
82730>>>>>>>
82730>>>>>>>Use Cli.pkg
82730>>>>>>>
82730>>>>>>>//*** Driver Indentification
82730>>>>>>>
82730>>>>>>>//*** Error number constants
82730>>>>>>>
82730>>>>>>>//*** Call driver function identifiers
82730>>>>>>>
82730>>>>>>>//*** Extra ODBC commands
82730>>>>>>>
82730>>>>>>>
82730>>>>>>>//*****************************************************************************
82730>>>>>>>//*** ODBCManage                                                            ***
82730>>>>>>>//***                                                                       ***
82730>>>>>>>//*** Start the ODBC manager.                                               ***
82730>>>>>>>//*****************************************************************************
82730>>>>>>>
82730>>>>>>>
82730>>>>>>>
82730>>>>>>>//*****************************************************************************
82730>>>>>>>//*** ODBCNumberOfDataSources To <NumDSN>                                   ***
82730>>>>>>>//***                                                                       ***
82730>>>>>>>//*** Returns the number of data sources.                                   ***
82730>>>>>>>//*****************************************************************************
82730>>>>>>>
82730>>>>>>>
82730>>>>>>>//*****************************************************************************
82730>>>>>>>//*** ODBCDSNName <DSNNumber> To <DSNName>                                  ***
82730>>>>>>>//***                                                                       ***
82730>>>>>>>//*** Returns the name of the data source.                                  ***
82730>>>>>>>//*****************************************************************************
82730>>>>>>>
82730>>>>>>>
82730>>>>>>>//*****************************************************************************
82730>>>>>>>//*** ODBCEnumerateTables <DSNName> To <TableNum>                           ***
82730>>>>>>>//***                                                                       ***
82730>>>>>>>//*** Builds internal table array and returns the number of tables in the   ***
82730>>>>>>>//*** DSN.                                                                  ***
82730>>>>>>>//*****************************************************************************
82730>>>>>>>
82730>>>>>>>
82730>>>>>>>//*****************************************************************************
82730>>>>>>>//*** ODBCTableName <TableNum> To <TableName>                               ***
82730>>>>>>>//***                                                                       ***
82730>>>>>>>//*** Returns the name of the table.                                        ***
82730>>>>>>>//*****************************************************************************
82730>>>>>>>
82730>>>>>>>
82730>>>>>>>//*****************************************************************************
82730>>>>>>>//*** ODBCSchemaName <TableNum> To <SchemaName>                             ***
82730>>>>>>>//***                                                                       ***
82730>>>>>>>//*** Returns the schema name of the table.                                 ***
82730>>>>>>>//*****************************************************************************
82730>>>>>>>
82730>>>>>>>
82730>>>>>>>//*****************************************************************************
82730>>>>>>>//*** ODBCNumberOfFields <DSNName> <TableName> To <NumDSN>                  ***
82730>>>>>>>//***                                                                       ***
82730>>>>>>>//*** Returns the number of fields.                                         ***
82730>>>>>>>//*****************************************************************************
82730>>>>>>>
82730>>>>>>>
82730>>>>>>>//*****************************************************************************
82730>>>>>>>//*** ODBCFieldName <FieldNumber> To <FieldName>                            ***
82730>>>>>>>//***                                                                       ***
82730>>>>>>>//*** Returns the name of the field.                                  ***
82730>>>>>>>//*****************************************************************************
82730>>>>>>>
82730>>>>>>>
82730>>>>>>>
82730>>>>>>>//*****************************************************************************
82730>>>>>>>//*** ODBC_SetConstraint <FileNum> <ConstraintText>                         ***
82730>>>>>>>//***                                                                       ***
82730>>>>>>>//***   Setup a constraint for a file.                                      ***
82730>>>>>>>//*****************************************************************************
82730>>>>>>>
82730>>>>>>>
82730>>>>>>>
82730>>>>>>>Class cODBCHandler Is A cCLIHandler
82731>>>>>>>
82731>>>>>>>    Procedure Construct_Object
82733>>>>>>>        Forward Send Construct_Object
82735>>>>>>>
82735>>>>>>>        Set psDriverID To ODBC_DRV_ID
82736>>>>>>>    End_Procedure // Construct_Object
82737>>>>>>>
82737>>>>>>>
82737>>>>>>>
82737>>>>>>>    //***
82737>>>>>>>    //*** Procedure Set: DataSourceType
82737>>>>>>>    //*** Purpose      : Setup the type of data sources returned by the datasources function
82737>>>>>>>    //***
82737>>>>>>>
82737>>>>>>>    Procedure Set DataSourceType Integer iNewType
82739>>>>>>>        Local String  sDriver
82739>>>>>>>        Local String  sVoid
82739>>>>>>>        Local Integer iRetval
82739>>>>>>>
82739>>>>>>>        Get psDriverID To sDriver
82740>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid iNewType Result iRetval
82747>>>>>>>    End_Procedure // Set DataSourceType
82748>>>>>>>
82748>>>>>>>
82748>>>>>>>
82748>>>>>>>    //***
82748>>>>>>>    //*** Function: DataSources
82748>>>>>>>    //*** Purpose : Call the driver's data sources function
82748>>>>>>>    //***
82748>>>>>>>
82748>>>>>>>    Function DataSources Returns String
82750>>>>>>>        Local String  sDriver
82750>>>>>>>        Local String  sDataSource
82750>>>>>>>        Local String  sDescription
82750>>>>>>>        Local Integer iLength
82750>>>>>>>        Local Integer iRetval
82750>>>>>>>
82750>>>>>>>        Get psDriverID To sDriver
82751>>>>>>>        If (sDriver <> "") Begin
82753>>>>>>>            Move 8192 To iLength
82754>>>>>>>            Move (Repeat(" ", iLength)) To sDataSource
82755>>>>>>>            Move (Repeat(" ", iLength)) To sDescription
82756>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
82761>>>>>>>        End
82761>>>>>>>>
82761>>>>>>>
82761>>>>>>>        If (sDataSource <> "" Or sDescription <> "") ;            Function_Return (sDataSource + "," +  sDescription)
82764>>>>>>>        Else ;            Function_Return ""
82766>>>>>>>    End_Function// DataSources
82767>>>>>>>
82767>>>>>>>End_Class // cODBCHandler
82768>>>>>Use seq_chnl.pkg
82768>>>>>//Use Std_help.pkg
82768>>>>>
82768>>>>>Register_Function phoWorkspace Returns Handle
82768>>>>>Register_Function Help_filename Returns String
82768>>>>>Register_Function GetHelpFile Returns String
82768>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
82768>>>>>
82768>>>>>// Use of Mertech drivers:
82768>>>>>// Ad the line "Define DUF_Use_Mertech_Drivers" prior "Use" of this package to your source code if using Mertech drivers!
82768>>>>>    Use mertech.inc
Including file: mertech.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\mertech.inc)
82768>>>>>>>//*************************************************************************
82768>>>>>>>//*                                                                       *
82768>>>>>>>//*  Confidential Trade Secret.                                           *
82768>>>>>>>//*  Copyright (c) 1997-2014 Mertech Data Systems Inc, Miami Florida      *
82768>>>>>>>//*  All rights reserved.                                                 *
82768>>>>>>>//*  DataFlex is a registered trademark of Data Access Corporation.       *
82768>>>>>>>//*                                                                       *
82768>>>>>>>//*************************************************************************
82768>>>>>>>Use UI
82768>>>>>>>Use SEQ_CHNL.PKG
82768>>>>>>>
#REM -----------------------------------------------
#REM MERTECH DATA SYSTEMS INC. - WWW.MERTECHDATA.COM
#REM MERTECH.INC VERSION 3.1.1
#REM -----------------------------------------------
82768>>>>>>>
82768>>>>>>>//=============================================================================
82768>>>>>>>// #DEFINE's
82768>>>>>>>//=============================================================================
82768>>>>>>>
82768>>>>>>>//Currently Unsupported Attribute
82768>>>>>>>Define DF_FILE_PRIMARY_KEY                          For (DF_FILE_RECORD_REREAD+1)
82768>>>>>>>
82768>>>>>>>// TODO: This is probably deprecated. Investigate.
82768>>>>>>>Define DF_FILE_NUMBER_INVERSE_KEYS                  For (DF_FILE_RECORD_REREAD+3)
82768>>>>>>>
82768>>>>>>>//=============================================================================
82768>>>>>>>/// @Name        DF_FILE_SET_MODE
82768>>>>>>>/// @Description Allows switching between set-oriented and record oriented fetch modes.
82768>>>>>>>///
82768>>>>>>>/// If DF_FILE_SET_MODE is set to True, the driver will fetch a set of records
82768>>>>>>>/// for each find. If DF_FILE_SET_MODE is False, the driver will fetch only one
82768>>>>>>>/// record at a time. This attribute can also be specified in the .INT file during
82768>>>>>>>/// migration through Flex2SQL. This settings is normally used alongside
82768>>>>>>>/// DF_FILE_MAX_ROWS to set the number of rows to return and DF_FILE_CACHE_MODE
82768>>>>>>>/// to turn on local caching.
82768>>>>>>>///
82768>>>>>>>/// Note: Turning off set-mode can have a detrimental impact on performance. Unless
82768>>>>>>>/// there is a specific reason to do otherwise, this option should be left on.
82768>>>>>>>///
82768>>>>>>>/// Default value: True
82768>>>>>>>///
82768>>>>>>>/// @Assumptions
82768>>>>>>>/// @Status      Public
82768>>>>>>>/// @Drivers     All
82768>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
82768>>>>>>>/// @See DF_FILE_MAX_ROWS DF_FILE_CACHE_MODE
82768>>>>>>>/// @INTOPT OPTIMIZE {FOR_SET | ONE_ROW}
82768>>>>>>>///
82768>>>>>>>/// @Syntax Set_Attribute DF_FILE_SET_MODE of {FileNumber} to {variable}
82768>>>>>>>/// @Syntax Get_Attribute DF_FILE_SET_MODE of {FileNumber} to {variable}
82768>>>>>>>/// @Param  FileNumber            Number of the file
82768>>>>>>>/// @Param  variable              Mode for the FileNumber. True for set-mode, False for one-row mode.
82768>>>>>>>/// @Example
82768>>>>>>>/// Open Orderhea
82768>>>>>>>/// Set_Attribute DF_FILE_SET_MODE of Orderhea.File_Number to True
82768>>>>>>>/// Get_Attribute DF_FILE_SET_MODE of Orderhea.File_Number to boolVar
82768>>>>>>>///
82768>>>>>>>Define DF_FILE_SET_MODE                             For (DF_FILE_RECORD_REREAD+5)
82768>>>>>>>
82768>>>>>>>//=============================================================================
82768>>>>>>>/// @Name        DF_FILE_DATABASENAME
82768>>>>>>>/// @Description Returns a string containing the name of the database where the
82768>>>>>>>/// table referenced by the passed File Number resides. This is a READ ONLY
82768>>>>>>>/// attribute. Note that because Oracle doesn't support the concept of multiple
82768>>>>>>>/// databases on one server, this attribute is not valid for Oracle.
82768>>>>>>>///
82768>>>>>>>/// @Assumptions
82768>>>>>>>/// @Status      Public
82768>>>>>>>/// @Drivers     SQLFlex, MySQLFlex, PGFlex
82768>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
82768>>>>>>>/// @See
82768>>>>>>>///
82768>>>>>>>/// @Syntax Get_Attribute DF_FILE_DATABASENAME of {FileNumber} to {variable}
82768>>>>>>>/// @Param  FileNumber            Number of the file
82768>>>>>>>/// @Param  variable              Name of the Database
82768>>>>>>>/// @Example
82768>>>>>>>/// Open Orderhea
82768>>>>>>>/// Get_Attribute DF_FILE_DATABASENAME of Orderhea.File_Number to strVal
82768>>>>>>>Define DF_FILE_DATABASENAME                         For (DF_FILE_RECORD_REREAD+6)
82768>>>>>>>
82768>>>>>>>//=============================================================================
82768>>>>>>>/// @Name        DF_FILE_MAX_ROWS
82768>>>>>>>/// @Description Controls the maximum number of rows retrieved by a Find GT/LT
82768>>>>>>>/// operation. The driver will automatically retrieve and cache this many rows
82768>>>>>>>/// for future find GT/LT operations. Setting this property to a very high
82768>>>>>>>/// value can be inefficient from a UI perspective but may be advisable for
82768>>>>>>>/// local processing of rows (such as in a batch process).
82768>>>>>>>///
82768>>>>>>>/// Default value: 10
82768>>>>>>>///
82768>>>>>>>/// @Assumptions
82768>>>>>>>/// @Status      Public
82768>>>>>>>/// @Drivers     All
82768>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
82768>>>>>>>/// @See DF_FILE_SET_MODE DF_FILE_CACHE_MODE
82768>>>>>>>/// @INTOPT MAX_ROWS_TO_QUERY {integer}
82768>>>>>>>///
82768>>>>>>>/// @Syntax Set_Attribute DF_FILE_DATABASENAME of {FileNumber} to {variable}
82768>>>>>>>/// @Param  FileNumber            Number of the file
82768>>>>>>>/// @Param  variable              Attribute Value
82768>>>>>>>/// @Example
82768>>>>>>>/// Open Orderhea
82768>>>>>>>/// Set_Attribute DF_FILE_MAX_ROWS of Orderhea.File_Number to 10
82768>>>>>>>/// Get_Attribute DF_FILE_MAX_ROWS of Orderhea.File_Number to intVal
82768>>>>>>>Define DF_FILE_MAX_ROWS                             For (DF_FILE_RECORD_REREAD+7)
82768>>>>>>>
82768>>>>>>>//=============================================================================
82768>>>>>>>/// @Name        DF_FILE_TABLE_NAME
82768>>>>>>>/// @Description Use this attribute to set or get the name of the SQL table
82768>>>>>>>/// corresponding to the specified file number. In a restructure operation
82768>>>>>>>/// this attribute may be used to permanently change the table that a filelist
82768>>>>>>>/// entry is pointing to.
82768>>>>>>>///
82768>>>>>>>/// @Assumptions
82768>>>>>>>/// @Status      Public
82768>>>>>>>/// @Drivers     All
82768>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
82768>>>>>>>/// @See
82768>>>>>>>/// @INTOPT DATABASE_NAME {string}
82768>>>>>>>///
82768>>>>>>>/// @Syntax Get_Attribute DF_FILE_TABLE_NAME of {FileNumber} to {variable}
82768>>>>>>>/// @Syntax Set_Attribute DF_FILE_TABLE_NAME of {FileNumber} to {variable}
82768>>>>>>>/// @Param  FileNumber            Number of the file
82768>>>>>>>/// @Param  variable              Name of the SQL Table.
82768>>>>>>>/// @Example
82768>>>>>>>/// Open Orderhea
82768>>>>>>>/// Get_Attribute DF_FILE_TABLE_NAME of Orderhea.File_Number to strVal
82768>>>>>>>Define DF_FILE_TABLE_NAME                           For (DF_FILE_RECORD_REREAD+8)
82768>>>>>>>
82768>>>>>>>//=============================================================================
82768>>>>>>>/// @Name        DF_FILE_CACHE_MODE
82768>>>>>>>/// @Description Activates or deactivates the local cache for set-oriented searches.
82768>>>>>>>///
82768>>>>>>>/// Through the DF_FILE_CACHE_MODE attribute, we can activate or deactivate the
82768>>>>>>>/// local cache. When the cache is active in a set-oriented search, a fixed
82768>>>>>>>/// number of records are pre-fetched and kept in the local cache. If a record
82768>>>>>>>/// is not found in the local cache, a new set is fetched. The number of records
82768>>>>>>>/// fetched is controlled via the DF_FILE_MAX_ROWS attribute. Set-mode vs. one-row
82768>>>>>>>/// mode is controlled via the DF_FILE_SET_MODE attribute.
82768>>>>>>>///
82768>>>>>>>/// Note: Turning off the cache can have significant detrimental effects on performance.
82768>>>>>>>///
82768>>>>>>>/// Default value: True
82768>>>>>>>///
82768>>>>>>>/// @Assumptions
82768>>>>>>>/// @Status      Public
82768>>>>>>>/// @Drivers     All
82768>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
82768>>>>>>>/// @See         DF_FILE_MAX_ROWS DF_FILE_SET_MODE
82768>>>>>>>///
82768>>>>>>>/// @Syntax Set_Attribute DF_FILE_CACHE_MODE of {FileNumber} to {variable}
82768>>>>>>>/// @Syntax Get_Attribute DF_FILE_CACHE_MODE of {FileNumber} to {variable}
82768>>>>>>>/// @Param  FileNumber            Number of the file
82768>>>>>>>/// @Param  variable              Mode for FileNumber. True for active. False for inactive.
82768>>>>>>>/// @Example
82768>>>>>>>/// Open Orderhea
82768>>>>>>>/// Set_Attribute DF_FILE_CACHE_MODE of Orderhea.File_Number to True
82768>>>>>>>/// Get_Attribute DF_FILE_CACHE_MODE of Orderhea.File_Number to boolVal
82768>>>>>>>Define DF_FILE_CACHE_MODE                           For (DF_FILE_RECORD_REREAD+9)
82768>>>>>>>
82768>>>>>>>//Currently Unsupported Attribute
82768>>>>>>>Define DF_FILE_STORAGE_BASE                         For (DF_FILE_RECORD_REREAD+10)
82768>>>>>>>
82768>>>>>>>//=============================================================================
82768>>>>>>>/// @Name        DF_FILE_STATIC
82768>>>>>>>/// @Description Activates or deactivates a special table mode where all rows
82768>>>>>>>/// from the table are loaded into a local cache. When active, all searches are
82768>>>>>>>/// done in memory and the actual table is not accessed.  The driver does not allow
82768>>>>>>>/// editing of a table in static mode.  This is a very useful feature especially
82768>>>>>>>/// when a table contains configuration or static information used in
82768>>>>>>>/// calculations, (i.e., Tax Rate tables, etc.) By keeping this table locally
82768>>>>>>>/// in memory, network round trips are saved resulting in significant
82768>>>>>>>/// performance improvements. This attribute is also useful for batch
82768>>>>>>>/// processes that make extensive table IO requests for reading static information.
82768>>>>>>>///
82768>>>>>>>/// Note: Because the entire table is loaded into memory, it is inadvisable to use
82768>>>>>>>/// this on very large tables.
82768>>>>>>>///
82768>>>>>>>/// Default value: False
82768>>>>>>>///
82768>>>>>>>/// @Assumptions
82768>>>>>>>/// @Status      Public
82768>>>>>>>/// @Drivers     All
82768>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
82768>>>>>>>/// @See
82768>>>>>>>///
82768>>>>>>>/// @Syntax Set_Attribute DF_FILE_STATIC of {FileNumber} to {variable}
82768>>>>>>>/// @Param  FileNumber            Number of the file
82768>>>>>>>/// @Param  variable              Static Mode for FileNumber. True for static. False for dynamic.
82768>>>>>>>/// @Example
82768>>>>>>>/// Open Orderhea
82768>>>>>>>/// Set_Attribute DF_FILE_STATIC of Orderhea.File_Number to True
82768>>>>>>>/// Get_Attribute DF_FILE_STATIC of Orderhea.File_Number to boolVal
82768>>>>>>>Define DF_FILE_STATIC                               For (DF_FILE_RECORD_REREAD+11)
82768>>>>>>>
82768>>>>>>>//=============================================================================
82768>>>>>>>/// @Name        DF_FILE_SERVER_NAME
82768>>>>>>>/// @Description Use this attribute to set or get the name of the database server
82768>>>>>>>/// corresponding to the specified file number. In a restructure operation
82768>>>>>>>/// this attribute may be used to permanently change the server that a filelist
82768>>>>>>>/// entry is pointing to.
82768>>>>>>>///
82768>>>>>>>/// @Assumptions
82768>>>>>>>/// @Status      Public
82768>>>>>>>/// @Drivers     All
82768>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
82768>>>>>>>/// @See
82768>>>>>>>/// @INTOPT SERVER_NAME {string}
82768>>>>>>>///
82768>>>>>>>/// @Syntax Get_Attribute DF_FILE_SERVER_NAME of {FileNumber} to {variable}
82768>>>>>>>/// @Syntax Set_Attribute DF_FILE_SERVER_NAME of {FileNumber} to {variable}
82768>>>>>>>/// @Param  FileNumber            Number of the file
82768>>>>>>>/// @Param  variable              Name of the database server.
82768>>>>>>>/// @Example
82768>>>>>>>/// Open Orderhea
82768>>>>>>>/// Set_Attribute DF_FILE_SERVER_NAME of Orderhea.File_Number to "(localdb)\v11.0"
82768>>>>>>>/// Get_Attribute DF_FILE_SERVER_NAME of Orderhea.File_Number to strVal
82768>>>>>>>Define DF_FILE_SERVER_NAME                          For (DF_FILE_RECORD_REREAD+12)
82768>>>>>>>
82768>>>>>>>//=============================================================================
82768>>>>>>>/// @Name        DF_FETCH_FIELD_COUNT
82768>>>>>>>/// @Description This attribute is used to get the number of fields or columns
82768>>>>>>>/// in the given table. Note that this is referring to the columns in the SQL
82768>>>>>>>/// backend and may not necessarily reflect the number of columns in DataFlex.
82768>>>>>>>///
82768>>>>>>>/// This is a readonly attribute.
82768>>>>>>>///
82768>>>>>>>/// @Assumptions
82768>>>>>>>/// @Status      Public
82768>>>>>>>/// @Drivers     MsSQLFlex MySQLFlex
82768>>>>>>>/// @VersionNote Last Revised: 2013-08-14 by Aaron Gulack
82768>>>>>>>/// @See
82768>>>>>>>/// @INTOPT
82768>>>>>>>///
82768>>>>>>>/// @Syntax Get_Attribute DF_FETCH_FIELD_COUNT of {FileNumber} to {variable}
82768>>>>>>>/// @Param  FileNumber            Number of the file
82768>>>>>>>/// @Param  variable              Name of the Tablespace.
82768>>>>>>>/// @Example
82768>>>>>>>
82768>>>>>>>/// Get_Attribute DF_FETCH_FIELD_COUNT of hFile To "INDXS"
82768>>>>>>>Define DF_FETCH_FIELD_COUNT                         For (DF_FILE_RECORD_REREAD+13)
82768>>>>>>>
82768>>>>>>>//=============================================================================
82768>>>>>>>/// @Name        DF_FILE_TABLESPACE_NAME
82768>>>>>>>/// @Description A tablespace is a container of segments (objects that have an
82768>>>>>>>/// allotted amount of space), i.e. tables and indexes. This attribute is
82768>>>>>>>/// used to get or set the name of the tablespace being used for the data tables.
82768>>>>>>>/// To set or get the tablespace name for indexes, use the DF_FILE_INDEXTABLESPACE_NAME
82768>>>>>>>/// attribute. Setting the tablespace name can only be done during a Structure_Start
82768>>>>>>>/// (during table creation).  Getting the name, however can be done at
82768>>>>>>>/// anytime.  Note that when setting the tablespace name, it must be set to an
82768>>>>>>>/// already existing tablespace, this attribute does not create the tablespace itself.
82768>>>>>>>/// Even though MYSQL uses tablespaces, this this attribute is only supported
82768>>>>>>>/// in Oracle and PostgreSQL.
82768>>>>>>>///
82768>>>>>>>/// @Assumptions
82768>>>>>>>/// @Status      Public
82768>>>>>>>/// @Drivers     ORAFlex PGFlex
82768>>>>>>>/// @VersionNote Last Revised: 2013-07-25 by Aaron Gulack
82768>>>>>>>/// @See         DF_FILE_INDEXTABLESPACE_NAME
82768>>>>>>>/// @INTOPT
82768>>>>>>>///
82768>>>>>>>/// @Syntax Get_Attribute DF_FILE_TABLESPACE_NAME of {FileNumber} to {variable}
82768>>>>>>>/// @Syntax Set_Attribute DF_FILE_TABLESPACE_NAME of {FileNumber} to {variable}
82768>>>>>>>/// @Param  FileNumber            Number of the file
82768>>>>>>>/// @Param  variable              Name of the Tablespace.
82768>>>>>>>/// @Example
82768>>>>>>>/// Handle hFile
82768>>>>>>>/// move 0 to hFile
82768>>>>>>>/// Structure_Start hFile "ORA_DRV"
82768>>>>>>>///     Set_Attribute DF_FILE_TABLESPACE_NAME      of hFile To "USERS"
82768>>>>>>>///     Set_Attribute DF_FILE_INDEXTABLESPACE_NAME of hFile To "INDXS"
82768>>>>>>>///
82768>>>>>>>///             // More table creation here
82768>>>>>>>///
82768>>>>>>>/// Structure_End hFile DF_STRUCTEND_OPT_NONE "." 0
82768>>>>>>>Define DF_FILE_TABLESPACE_NAME                      For (DF_FILE_RECORD_REREAD+14)
82768>>>>>>>
82768>>>>>>>// TODO: This is probably deprecated. Investigate.
82768>>>>>>>Define DF_FETCH_FIELDNUMBER                         For (DF_FILE_RECORD_REREAD+15)
82768>>>>>>>
82768>>>>>>>//=============================================================================
82768>>>>>>>/// @Name        DF_FILE_INDEXTABLESPACE_NAME
82768>>>>>>>/// @Description This attribute is used to get or set the name of the tablespace
82768>>>>>>>/// being used for the index segment of a database. For a description of tablespaces,
82768>>>>>>>/// see the description above for DF_FILE_TABLESPACE_NAME. Similar to the Tablespace
82768>>>>>>>/// name attribute, setting the index tablespace name can only be done during creation
82768>>>>>>>/// and must use an already existing tablespace as the variable. This attribute is
82768>>>>>>>/// only available for Oracle and Postgre.
82768>>>>>>>///
82768>>>>>>>/// @Assumptions
82768>>>>>>>/// @Status      Public
82768>>>>>>>/// @Drivers     ORAFlex PGFlex
82768>>>>>>>/// @VersionNote Last Revised: 2013-07-25 by Aaron Gulack
82768>>>>>>>/// @See         DF_FILE_TABLESPACE_NAME
82768>>>>>>>/// @INTOPT
82768>>>>>>>///
82768>>>>>>>/// @Syntax Get_Attribute DF_FILE_INDEXTABLESPACE_NAME of {File Number} to {variable}
82768>>>>>>>/// @Syntax Set_Attribute DF_FILE_INDEXTABLESPACE_NAME of {File Number} to {variable}
82768>>>>>>>/// @Param  FileNumber            Number of the file
82768>>>>>>>/// @Param  variable              Name of the Tablespace
82768>>>>>>>/// @Example
82768>>>>>>>/// Handle hFile
82768>>>>>>>/// move 0 to hFile
82768>>>>>>>/// Structure_Start hFile "ORA_DRV"
82768>>>>>>>///     Set_Attribute DF_FILE_TABLESPACE_NAME      of hFile To "USERS"
82768>>>>>>>///     Set_Attribute DF_FILE_INDEXTABLESPACE_NAME of hFile To "INDXS"
82768>>>>>>>///
82768>>>>>>>///             // More table creation here
82768>>>>>>>///             //
82768>>>>>>>/// Structure_End hFile DF_STRUCTEND_OPT_NONE "." 0
82768>>>>>>>Define DF_FILE_INDEXTABLESPACE_NAME                 For (DF_FILE_RECORD_REREAD+16)
82768>>>>>>>
82768>>>>>>>//=============================================================================
82768>>>>>>>/// @Name        DF_FILE_RETRIEVE_RECNUM
82768>>>>>>>/// @Description When creating records on a table with RECNUM support, the
82768>>>>>>>/// record number is returned after creation. When this attribute is false, the newly
82768>>>>>>>/// created record's RECNUM is not returned from the server. This could result in a
82768>>>>>>>/// slight performance improvement when many records are being created in a loop.
82768>>>>>>>/// The optimization, however, is negligible.  Having this attribute set to false can
82768>>>>>>>/// have detrimental effects if used improperly; i.e. DD-based saves or UI-based
82768>>>>>>>/// operations. Thus, this should almost always be set to true unless there is a
82768>>>>>>>/// compelling reason to do otherwise.
82768>>>>>>>///
82768>>>>>>>/// Default Value: True
82768>>>>>>>///
82768>>>>>>>/// @Assumptions
82768>>>>>>>/// @Status      Public
82768>>>>>>>/// @Drivers     All
82768>>>>>>>/// @VersionNote Last Revised: 2013-07-31 by Aaron Gulack
82768>>>>>>>/// @See
82768>>>>>>>/// @INTOPT
82768>>>>>>>///
82768>>>>>>>/// @Syntax Get_Attribute DF_FILE_RETRIEVE_RECNUM of {FileNumber} to {variable}
82768>>>>>>>/// @Syntax Set_Attribute DF_FILE_RETRIEVE_RECNUM of {FileNumber} to {variable}
82768>>>>>>>/// @Param  FileNumber            Number of the file
82768>>>>>>>/// @Param  variable              Boolean variable. false to not retrieve record number, true otherwise.
82768>>>>>>>
82768>>>>>>>/// @Example
82768>>>>>>>/// open ORDERHEA
82768>>>>>>>/// Handle  hFile
82768>>>>>>>/// Boolean bRetrieve
82768>>>>>>>///
82768>>>>>>>/// Set_Attribute DF_FILE_RETRIEVE_RECNUM of hFile to false
82768>>>>>>>/// Get_Attribute DF_FILE_RETRIEVE_RECNUM of hFile To bRetrieve
82768>>>>>>>Define DF_FILE_RETRIEVE_RECNUM                      For (DF_FILE_RECORD_REREAD+17)
82768>>>>>>>
82768>>>>>>>//=============================================================================
82768>>>>>>>/// @Name        DF_FILE_NAME_SPACE
82768>>>>>>>/// @Description In Postgres, schemas are objects where all the tables,views and indexes
82768>>>>>>>/// are stored. Separate schemas are used to specify relational data. This attribute is
82768>>>>>>>/// used to set the name of the schema where a table is created. Schema's do not account
82768>>>>>>>/// for any physical space but are merely used as theory to explain the order of a database.
82768>>>>>>>///
82768>>>>>>>/// @Assumptions
82768>>>>>>>/// @Status      Public
82768>>>>>>>/// @Drivers     PGFlex
82768>>>>>>>/// @VersionNote Last Revised: 2013-07-25 by Aaron Gulack
82768>>>>>>>/// @See
82768>>>>>>>/// @INTOPT
82768>>>>>>>///
82768>>>>>>>/// @Syntax Get_Attribute DF_FILE_NAME_SPACE of {FileNumber} to {variable}
82768>>>>>>>/// @Syntax Set_Attribute DF_FILE_NAME_SPACE of {FileNumber} to {variable}
82768>>>>>>>/// @Param  FileNumber            Number of the file
82768>>>>>>>/// @Param  variable              Name of the Schema
82768>>>>>>>/// @Example
82768>>>>>>>/// open ORDERHEA
82768>>>>>>>/// Handle hFile
82768>>>>>>>/// String sSchemaName
82768>>>>>>>///
82768>>>>>>>/// Set_Attribute DF_FILE_NAME_SPACE of hFile to "ORDERHEA"
82768>>>>>>>/// Get_Attribute DF_FILE_NAME_SPACE of hFile To sSchemaName
82768>>>>>>>Define DF_FILE_NAME_SPACE                           For (DF_FILE_RECORD_REREAD+18)
82768>>>>>>>
82768>>>>>>>// Currently does not serve any function. May be included in future versions.
82768>>>>>>>Define DF_FILE_STORAGE_PCTFREE                      For (DF_FILE_RECORD_REREAD+19)
82768>>>>>>>
82768>>>>>>>// Currently does not serve any function. May be included in future versions.
82768>>>>>>>Define DF_FILE_STORAGE_PCTUSED                      For (DF_FILE_RECORD_REREAD+21)
82768>>>>>>>
82768>>>>>>>// Currently does not serve any function. May be included in future versions.
82768>>>>>>>Define DF_FILE_STORAGE_INITIAL                      For (DF_FILE_RECORD_REREAD+23)
82768>>>>>>>
82768>>>>>>>// Currently does not serve any function. May be included in future versions.
82768>>>>>>>Define DF_FILE_STORAGE_NEXT                         For (DF_FILE_RECORD_REREAD+25)
82768>>>>>>>
82768>>>>>>>// Currently does not serve any function. May be included in future versions.
82768>>>>>>>Define DF_FILE_ALLOW_NULL                           For (DF_FILE_RECORD_REREAD+27)
82768>>>>>>>
82768>>>>>>>//=============================================================================
82768>>>>>>>/// @Name        DF_FILE_GET_SERVERNAME_FROM_LOGIN
82768>>>>>>>/// @Description Use this attribute to specify whether the SERVER_NAME option will
82768>>>>>>>/// be included in the INT file.  If set to True, the SERVER_NAME option will not
82768>>>>>>>/// be included in the INT file, if set to false, the SERVER_NAME option will be
82768>>>>>>>/// included in the INT file. This has two uses. The first is during a Structure_Start
82768>>>>>>>/// i.e. table creation/modification. The other is when using the OUTPUT_INT_FILE
82768>>>>>>>/// command. Set this attribute before the OUTPUT_INT_FILE to indicate how the INT
82768>>>>>>>/// file will be written. This name indicates a backwards logic so take note that
82768>>>>>>>/// setting it to true will NOT include the SERVER_NAME in the INT file.
82768>>>>>>>///
82768>>>>>>>/// Default Value: False
82768>>>>>>>///
82768>>>>>>>/// @Assumptions
82768>>>>>>>/// @Status      Deprecated
82768>>>>>>>/// @Drivers     All
82768>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
82768>>>>>>>/// @See         DF_FILE_SUPPRESS_SERVERNAME_OUTPUT
82768>>>>>>>/// @INTOPT              SERVER_NAME
82768>>>>>>>///
82768>>>>>>>/// @Syntax Get_Attribute DF_FILE_GET_SERVERNAME_FROM_LOGIN of {FileNumber} to {variable}
82768>>>>>>>/// @Syntax Set_Attribute DF_FILE_GET_SERVERNAME_FROM_LOGIN of {FileNumber} to {variable}
82768>>>>>>>/// @Param  FileNumber            Number of the file
82768>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
82768>>>>>>>/// @Example
82768>>>>>>>/// Open Customer
82768>>>>>>>///
82768>>>>>>>///     Set_Attribute DF_FILE_GET_SERVERNAME_FROM_LOGIN of Customer.File_Number to True
82768>>>>>>>///
82768>>>>>>>///     OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
82768>>>>>>>///
82768>>>>>>>/// Close Customer
82768>>>>>>>Define DF_FILE_GET_SERVERNAME_FROM_LOGIN            For (DF_FILE_RECORD_REREAD+29)
82768>>>>>>>
82768>>>>>>>//=============================================================================
82768>>>>>>>/// @Name        DF_FILE_SUPPRESS_SERVERNAME_OUTPUT
82768>>>>>>>/// @Description Use this attribute to specify whether the SERVER_NAME option will be included
82768>>>>>>>/// in the INT file.  If set to True, the server name will not be included in the INT file,
82768>>>>>>>/// if set to false, the server name will be included in the INT file. This has two uses.
82768>>>>>>>/// The first is during a Structure_Start i.e. table creation/modification. The other is
82768>>>>>>>/// when using the OUTPUT_INT_FILE command. Set this attribute before the OUTPUT_INT_FILE
82768>>>>>>>/// to indicate how the INT file will be written.
82768>>>>>>>///
82768>>>>>>>/// Default Value: False
82768>>>>>>>///
82768>>>>>>>/// @Assumptions
82768>>>>>>>/// @Status      Public
82768>>>>>>>/// @Drivers     All
82768>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
82768>>>>>>>/// @See         DF_FILE_SUPPRESS_DATABASENAME_OUTPUT DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT
82768>>>>>>>/// @INTOPT              SERVER_NAME
82768>>>>>>>///
82768>>>>>>>/// @Syntax Get_Attribute DF_FILE_SUPPRESS_SERVERNAME_OUTPUT of {FileNumber} to {variable}
82768>>>>>>>/// @Syntax Set_Attribute DF_FILE_SUPPRESS_SERVERNAME_OUTPUT of {FileNumber} to {variable}
82768>>>>>>>/// @Param  FileNumber            Number of the file
82768>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
82768>>>>>>>/// @Example
82768>>>>>>>/// Open Customer
82768>>>>>>>///
82768>>>>>>>///   Set_Attribute DF_FILE_SUPPRESS_SERVERNAME_OUTPUT of Customer.File_Number to True
82768>>>>>>>///
82768>>>>>>>///   OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
82768>>>>>>>///
82768>>>>>>>/// Close Customer
82768>>>>>>>Define DF_FILE_SUPPRESS_SERVERNAME_OUTPUT                       For DF_FILE_GET_SERVERNAME_FROM_LOGIN
82768>>>>>>>
82768>>>>>>>//=============================================================================
82768>>>>>>>/// @Name        DF_FILE_GET_DATABASENAME_FROM_LOGIN
82768>>>>>>>/// @Description Use this attribute to specify whether the DATABASE_NAME option will
82768>>>>>>>/// be included in the INT file.  If set to True, the DATABASE_NAME option will not
82768>>>>>>>/// be included in the INT file, if set to false, the DATABASE_NAME option will be
82768>>>>>>>/// included in the INT file. This has two uses. The first is during a Structure_Start
82768>>>>>>>/// i.e. table creation/modification. The other is when using the OUTPUT_INT_FILE
82768>>>>>>>/// command. Set this attribute before the OUTPUT_INT_FILE to indicate how the INT
82768>>>>>>>/// file will be written. This name indicates a backwards logic so take note that
82768>>>>>>>/// setting it to true will NOT include the DATABASE_NAME in the INT file.
82768>>>>>>>///
82768>>>>>>>/// Default Value: False
82768>>>>>>>///
82768>>>>>>>/// @Assumptions
82768>>>>>>>/// @Status      Deprecated
82768>>>>>>>/// @Drivers     PGFlex SQLFlex MySQLFlex
82768>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
82768>>>>>>>/// @See         DF_FILE_SUPPRESS_DATABASENAME_OUTPUT
82768>>>>>>>/// @INTOPT              DATABASE_NAME
82768>>>>>>>///
82768>>>>>>>/// @Syntax Get_Attribute DF_FILE_GET_DATABASENAME_FROM_LOGIN of {FileNumber} to {variable}
82768>>>>>>>/// @Syntax Set_Attribute DF_FILE_GET_DATABASENAME_FROM_LOGIN of {FileNumber} to {variable}
82768>>>>>>>/// @Param  FileNumber            Number of the file
82768>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
82768>>>>>>>/// @Example
82768>>>>>>>/// Open Customer
82768>>>>>>>///
82768>>>>>>>///     Set_Attribute DF_FILE_GET_DATABASENAME_FROM_LOGIN of Customer.File_Number to True
82768>>>>>>>///
82768>>>>>>>///     OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
82768>>>>>>>///
82768>>>>>>>/// Close Customer
82768>>>>>>>Define DF_FILE_GET_DATABASENAME_FROM_LOGIN          For (DF_FILE_RECORD_REREAD+31)
82768>>>>>>>
82768>>>>>>>//=============================================================================
82768>>>>>>>/// @Name        DF_FILE_SUPPRESS_DATABASENAME_OUTPUT
82768>>>>>>>/// @Description Use this attribute to specify whether the DATABASE_NAME option will
82768>>>>>>>/// be included in the INT file.  If set to True, the DATABASE_NAME option will not
82768>>>>>>>/// be included in the INT file, if set to false, the DATABASE_NAME option will be
82768>>>>>>>/// included in the INT file. This has two uses. The first is during a Structure_Start
82768>>>>>>>/// i.e. table creation/modification. The other is when using the OUTPUT_INT_FILE
82768>>>>>>>/// command. Set this attribute before the OUTPUT_INT_FILE to indicate how the INT
82768>>>>>>>/// file will be written. This name indicates a backwards logic so take note that
82768>>>>>>>/// setting it to true will NOT include the DATABASE_NAME in the INT file.
82768>>>>>>>///
82768>>>>>>>/// Default Value: False
82768>>>>>>>///
82768>>>>>>>/// @Assumptions
82768>>>>>>>/// @Status      Public
82768>>>>>>>/// @Drivers     PGFlex SQLFlex MySQLFlex
82768>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
82768>>>>>>>/// @See         DF_FILE_SUPPRESS_SERVERNAME_OUTPUT DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT
82768>>>>>>>/// @INTOPT              DATABASE_NAME
82768>>>>>>>///
82768>>>>>>>/// @Syntax Get_Attribute DF_FILE_SUPPRESS_DATABASENAME_OUTPUT of {FileNumber} to {variable}
82768>>>>>>>/// @Syntax Set_Attribute DF_FILE_SUPPRESS_DATABASENAME_OUTPUT of {FileNumber} to {variable}
82768>>>>>>>/// @Param  FileNumber            Number of the file
82768>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
82768>>>>>>>/// @Example
82768>>>>>>>/// Open Customer
82768>>>>>>>///
82768>>>>>>>///     Set_Attribute DF_FILE_SUPPRESS_DATABASENAME_OUTPUT of Customer.File_Number to True
82768>>>>>>>///
82768>>>>>>>///     OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
82768>>>>>>>///
82768>>>>>>>/// Close Customer
82768>>>>>>>Define DF_FILE_SUPPRESS_DATABASENAME_OUTPUT                     For DF_FILE_GET_DATABASENAME_FROM_LOGIN
82768>>>>>>>
82768>>>>>>>//=============================================================================
82768>>>>>>>/// @Name        DF_FILE_GET_SCHEMANAME_FROM_LOGIN
82768>>>>>>>/// @Description Use this attribute to specify whether the SCHEMA_NAME option will
82768>>>>>>>/// be included in the INT file.  If set to True, the SCHEMA_NAME option will not
82768>>>>>>>/// be included in the INT file, if set to false, the SCHEMA_NAME option will be
82768>>>>>>>/// included in the INT file. This has two uses. The first is during a Structure_Start
82768>>>>>>>/// i.e. table creation/modification. The other is when using the OUTPUT_INT_FILE
82768>>>>>>>/// command. Set this attribute before the OUTPUT_INT_FILE to indicate how the INT
82768>>>>>>>/// file will be written. This name indicates a backwards logic so take note that
82768>>>>>>>/// setting it to true will NOT include the SCHEMA_NAME in the INT file.
82768>>>>>>>///
82768>>>>>>>/// Default Value: False
82768>>>>>>>///
82768>>>>>>>/// @Assumptions
82768>>>>>>>/// @Status      Deprecated
82768>>>>>>>/// @Drivers     All
82768>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
82768>>>>>>>/// @See         DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT
82768>>>>>>>/// @INTOPT              SCHEMA_NAME
82768>>>>>>>///
82768>>>>>>>/// @Syntax Get_Attribute DF_FILE_GET_SCHEMANAME_FROM_LOGIN of {FileNumber} to {variable}
82768>>>>>>>/// @Syntax Set_Attribute DF_FILE_GET_SCHEMANAME_FROM_LOGIN of {FileNumber} to {variable}
82768>>>>>>>/// @Param  FileNumber            Number of the file
82768>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
82768>>>>>>>/// @Example
82768>>>>>>>/// Open Customer
82768>>>>>>>///
82768>>>>>>>///     Set_Attribute DF_FILE_GET_SCHEMANAME_FROM_LOGIN of Customer.File_Number to True
82768>>>>>>>///
82768>>>>>>>///     OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
82768>>>>>>>///
82768>>>>>>>/// Close Customer
82768>>>>>>>Define DF_FILE_GET_SCHEMANAME_FROM_LOGIN            For (DF_FILE_RECORD_REREAD+33)
82768>>>>>>>
82768>>>>>>>//=============================================================================
82768>>>>>>>/// @Name        DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT
82768>>>>>>>/// @Description Use this attribute to specify whether the SCHEMA_NAME option will
82768>>>>>>>/// be included in the INT file.  If set to True, the SCHEMA_NAME option will not
82768>>>>>>>/// be included in the INT file, if set to false, the SCHEMA_NAME option will be
82768>>>>>>>/// included in the INT file. This has two uses. The first is during a Structure_Start
82768>>>>>>>/// i.e. table creation/modification. The other is when using the OUTPUT_INT_FILE
82768>>>>>>>/// command. Set this attribute before the OUTPUT_INT_FILE to indicate how the INT
82768>>>>>>>/// file will be written. This name indicates a backwards logic so take note that
82768>>>>>>>/// setting it to true will NOT include the SCHEMA_NAME in the INT file.
82768>>>>>>>///
82768>>>>>>>/// Default Value: False
82768>>>>>>>///
82768>>>>>>>/// @Assumptions
82768>>>>>>>/// @Status      Public
82768>>>>>>>/// @Drivers     All
82768>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
82768>>>>>>>/// @See         DF_FILE_SUPPRESS_DATABASENAME_OUTPUT DF_FILE_SUPPRESS_SERVERNAME_OUTPUT
82768>>>>>>>/// @INTOPT              SCHEMA_NAME
82768>>>>>>>///
82768>>>>>>>/// @Syntax Get_Attribute DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT of {FileNumber} to {variable}
82768>>>>>>>/// @Syntax Set_Attribute DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT of {FileNumber} to {variable}
82768>>>>>>>/// @Param  FileNumber            Number of the file
82768>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
82768>>>>>>>/// @Example
82768>>>>>>>/// Open Customer
82768>>>>>>>///
82768>>>>>>>///     Set_Attribute DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT of Customer.File_Number to True
82768>>>>>>>///
82768>>>>>>>///     OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
82768>>>>>>>///
82768>>>>>>>/// Close Customer
82768>>>>>>>Define DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT           For DF_FILE_GET_SCHEMANAME_FROM_LOGIN
82768>>>>>>>
82768>>>>>>>//TODO
82768>>>>>>>Define DF_FILE_PRESERVE_RECNUM                      For 184
82768>>>>>>>
82768>>>>>>>// Currently Unsupported Attribute
82768>>>>>>>Define DF_FILE_NATIVE_RECORD_LENGTH                 For 194
82768>>>>>>>
82768>>>>>>>//=============================================================================
82768>>>>>>>/// @Name        DF_FILE_OEM_TRANSLATION
82768>>>>>>>/// @Description There are two sets of code pages used in windows, ANSI and
82768>>>>>>>/// OEM. ANSI is what is commonly used now, but some data still uses the OEM
82768>>>>>>>/// code pages. When migrating data, this attribute is used to determine whether
82768>>>>>>>/// the OEM data will be translated to ANSI during the migration. For example,
82768>>>>>>>/// migrating passwords with special characters may call for different code pages.
82768>>>>>>>/// Setting this attribute to true will convert the OEM data to ANSI, setting it
82768>>>>>>>/// to false will not.
82768>>>>>>>///
82768>>>>>>>/// @Assumptions
82768>>>>>>>/// @Status      Public
82768>>>>>>>/// @Drivers     All
82768>>>>>>>/// @VersionNote Last Revised: 2013-08-15 by Aaron Gulack
82768>>>>>>>/// @See
82768>>>>>>>/// @INTOPT
82768>>>>>>>///
82768>>>>>>>/// @Syntax Set_Attribute DF_FILE_OEM_TRANSLATION of {FileNumber} to {variable}
82768>>>>>>>/// @Syntax Get_Attribute DF_FILE_OEM_TRANSLATION of {FileNumber} to {variable}
82768>>>>>>>/// @Param  FileNumber            Number of the file
82768>>>>>>>/// @Param  variable              Indicates if OEM data will be converted to ANSI. True converts it, false does not.
82768>>>>>>>/// @Example
82768>>>>>>>/// open Customer
82768>>>>>>>///
82768>>>>>>>/// Handle hFile
82768>>>>>>>/// Boolean bTranslate
82768>>>>>>>///
82768>>>>>>>/// Move Customer.File_Number to hFile
82768>>>>>>>///
82768>>>>>>>/// Structure_Start hFile
82768>>>>>>>///     Set_Attribute DF_FILE_OEM_TRANSLATION of hFile to True
82768>>>>>>>///     Get_Attribute DF_FILE_OEM_TRANSLATION of hFile to bTranslate
82768>>>>>>>/// Structure_End hFile
82768>>>>>>>Define DF_FILE_OEM_TRANSLATION                      For (DF_FILE_RECORD_REREAD+51)
82768>>>>>>>
82768>>>>>>>//=============================================================================
82768>>>>>>>/// @Name        DF_FILE_EPOCH_YEAR
82768>>>>>>>/// @Description When dealing with two-digit years, an epoch year must be used
82768>>>>>>>/// to determine which century the date is referring to. For example if the
82768>>>>>>>/// epoch year is set to 30, then any two digit year greater than 30 will be
82768>>>>>>>/// considered in the 20th Century, anything less than or equal to 30 will be
82768>>>>>>>/// considered in the 21st Century.  This attribute is used to turn on or off
82768>>>>>>>/// this feature. To use this feature, set this attribute to whatever the epoch
82768>>>>>>>/// year is expected to be. To disable this feature, set this attribute to 0
82768>>>>>>>/// or false. Note that setting this attribute must be done at table creation
82768>>>>>>>/// or inside of a Structure_Start.
82768>>>>>>>///
82768>>>>>>>/// @Assumptions
82768>>>>>>>/// @Status      Public
82768>>>>>>>/// @Drivers     All
82768>>>>>>>/// @VersionNote Last Revised: 2013-08-15 by Aaron Gulack
82768>>>>>>>/// @See
82768>>>>>>>/// @INTOPT      EPOCH_YEAR
82768>>>>>>>///
82768>>>>>>>/// @Syntax Set_Attribute DF_FILE_EPOCH_YEAR of {FileNumber} to {variable}
82768>>>>>>>/// @Syntax Get_Attribute DF_FILE_EPOCH_YEAR of {FileNumber} to {variable}
82768>>>>>>>/// @Param  FileNumber            Number of the file
82768>>>>>>>/// @Param  variable              Indicates what the epoch year is. 0 to disable
82768>>>>>>>/// @Example
82768>>>>>>>/// open Customer
82768>>>>>>>///
82768>>>>>>>/// Handle hFile
82768>>>>>>>/// Boolean bEpoch
82768>>>>>>>///
82768>>>>>>>/// Move Customer.File_Number to hFile
82768>>>>>>>///
82768>>>>>>>/// Structure_Start hFile
82768>>>>>>>///     Set_Attribute DF_FILE_EPOCH_YEAR of hFile to 30
82768>>>>>>>///     Get_Attribute DF_FILE_EPOCH_YEAR of hFile to bEpoch
82768>>>>>>>/// Structure_End hFile
82768>>>>>>>Define DF_FILE_EPOCH_YEAR                           For (DF_FILE_RECORD_REREAD+53)
82768>>>>>>>
82768>>>>>>>Define DF_FILE_USE_ROWCOUNT_IN_TRANSACTIONS         For 628
82768>>>>>>>Define DF_FILE_ICF_STATUS                           For 630
82768>>>>>>>
82768>>>>>>>//=============================================================================
82768>>>>>>>/// @Name        DF_FILE_LOCK_RECORD_STATUS
82768>>>>>>>/// @Description Table locking is done during transactions to maintain atomicity.
82768>>>>>>>/// In DataFlex, this is usually done with the REREAD/UNLOCK commands. This
82768>>>>>>>/// attribute is used to get the status of a table lock. If a table is currently
82768>>>>>>>/// in a REREAD, or locked, then the attribute will return true. Otherwise, it
82768>>>>>>>/// returns false. It is a read-only attribute so no setting can be done.
82768>>>>>>>///
82768>>>>>>>/// @Assumptions
82768>>>>>>>/// @Status      Public
82768>>>>>>>/// @Drivers     All
82768>>>>>>>/// @VersionNote Last Revised: 2013-08-06 by Aaron Gulack
82768>>>>>>>/// @See
82768>>>>>>>/// @INTOPT
82768>>>>>>>///
82768>>>>>>>/// @Syntax Get_Attribute DF_FILE_LOCK_RECORD_STATUS of {FileNumber} to {variable}
82768>>>>>>>/// @Param  FileNumber            Number of the file
82768>>>>>>>/// @Param  variable              Indicates the status of the file lock
82768>>>>>>>/// @Example
82768>>>>>>>/// open Customer
82768>>>>>>>/// Handle hFile
82768>>>>>>>/// Integer bLocked
82768>>>>>>>///
82768>>>>>>>/// Move Customer.File_Number to hFile
82768>>>>>>>///
82768>>>>>>>/// Get_Attribute DF_FILE_LOCK_RECORD_STATUS of hFile to bLocked
82768>>>>>>>Define DF_FILE_LOCK_RECORD_STATUS                   For 632
82768>>>>>>>
82768>>>>>>>//=============================================================================
82768>>>>>>>/// @Name        DF_FILE_CASING
82768>>>>>>>/// @Description Controls the filename and column name casing.
82768>>>>>>>/// You can set this to either keep the file case, force to lower case or force
82768>>>>>>>/// to uppercase.
82768>>>>>>>///
82768>>>>>>>///
82768>>>>>>>/// @Assumptions
82768>>>>>>>/// @Status      Public
82768>>>>>>>/// @Drivers     All
82768>>>>>>>/// @VersionNote Last Revised: 2014-04-28 by Wil van Antwerpen
82768>>>>>>>/// @See
82768>>>>>>>/// @INTOPT
82768>>>>>>>///
82768>>>>>>>/// @Syntax Set_Attribute DF_FILE_CASING of {FileNumber} to {FILE_CASING_KEEP|FILE_CASING_LOWER|FILE_CASING_UPPER}
82768>>>>>>>/// @Syntax Get_Attribute DF_FILE_CASING of {FileNumber} to {variable}
82768>>>>>>>/// @Param  FileNumber          Number of the file
82768>>>>>>>/// @Param  variable              integer set to one of the above values.
82768>>>>>>>/// @Example
82768>>>>>>>/// open Customer
82768>>>>>>>/// Handle hFile
82768>>>>>>>/// Integer eCasing
82768>>>>>>>///
82768>>>>>>>/// Move Customer.File_Number to hFile
82768>>>>>>>///
82768>>>>>>>/// Structure_Start hFile "ORA_DRV"
82768>>>>>>>///    Set_Attribute DF_FILE_CASING of hFile to FILE_CASING_KEEP
82768>>>>>>>/// Structure_End hFile
82768>>>>>>>///
82768>>>>>>>///
82768>>>>>>>/// Get_Attribute DF_FILE_CASING of hFile to eCasing
82768>>>>>>>
82768>>>>>>>
82768>>>>>>>Define DF_FILE_CASING                               For 634
82768>>>>>>>
82768>>>>>>>Define DF_FIELD_INVERSE_KEY_NAME                    For (DF_FIELD_NATIVE_LENGTH+1)
82768>>>>>>>Define DF_FIELD_INVERSE_KEY_TYPE                    For (DF_FIELD_NATIVE_LENGTH+2)
82768>>>>>>>
82768>>>>>>>//TODO
82768>>>>>>>Define DF_FIELD_TEXT_SEGMENT_NAME                   For (DF_FIELD_NATIVE_LENGTH+3)
82768>>>>>>>
82768>>>>>>>//TODO
82768>>>>>>>Define DF_FIELD_TEXT_NUM_SEGMENTS                   For (DF_FIELD_NATIVE_LENGTH+4)
82768>>>>>>>
82768>>>>>>>//=============================================================================
82768>>>>>>>/// @Name        DF_FIELD_DEFAULT_VALUE
82768>>>>>>>/// @Description Use this attribute to get or set the default value for a given column.
82768>>>>>>>/// Setting the default value can only be done during a structure_start or during table
82768>>>>>>>/// creation. If this attribute is not set, it is defaulted to the driver default.
82768>>>>>>>/// See Mertech.cfg
82768>>>>>>>/// @Assumptions
82768>>>>>>>/// @Status      Public
82768>>>>>>>/// @Drivers     All
82768>>>>>>>/// @VersionNote Last Revised: 2013-08-06 by Aaron Gulack
82768>>>>>>>/// @See
82768>>>>>>>/// @INTOPT
82768>>>>>>>///
82768>>>>>>>/// @Syntax Set_Attribute DF_FIELD_DEFAULT_VALUE of {FileNumber} {FieldNumber} to {variable}
82768>>>>>>>/// @Syntax Get_Attribute DF_FIELD_DEFAULT_VALUE of {FileNumber} {FieldNumber} to {variable}
82768>>>>>>>/// @Param  FileNumber            Number of the file
82768>>>>>>>/// @Param  FieldNumber           Number of the field
82768>>>>>>>/// @Param  variable              Variable for the default value of the field
82768>>>>>>>/// @Example
82768>>>>>>>/// open Customer
82768>>>>>>>/// String sDefault
82768>>>>>>>/// Handle hFile
82768>>>>>>>/// Integer iColumn
82768>>>>>>>///
82768>>>>>>>/// Move "California" to sDefault
82768>>>>>>>/// Move Customer.File_Number to hFile
82768>>>>>>>/// Move 3 to iColumn
82768>>>>>>>///
82768>>>>>>>/// Structure_Start hFile "ORA_DRV"
82768>>>>>>>///    Set_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefault
82768>>>>>>>/// Structure_End hFile
82768>>>>>>>///
82768>>>>>>>/// Get_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefault
82768>>>>>>>Define DF_FIELD_DEFAULT_VALUE                       For (DF_FIELD_NATIVE_LENGTH+5)
82768>>>>>>>
82768>>>>>>>// Currently Unsupported Attribute
82768>>>>>>>Define DF_FIELD_TEXT_LENGTH_SEGMENT                 For (DF_FIELD_NATIVE_LENGTH+6)
82768>>>>>>>
82768>>>>>>>//TODO
82768>>>>>>>//=============================================================================
82768>>>>>>>/// @Name        DF_FIELD_TIME_ON
82768>>>>>>>/// @Description Assign a field to retrieve Time Stamp value from a DATETIME
82768>>>>>>>/// column in a table.
82768>>>>>>>///
82768>>>>>>>/// This option was implemented because some versions of DataFlex do not support
82768>>>>>>>/// DATETIME fields normally supported by SQL databases.
82768>>>>>>>///
82768>>>>>>>/// To use this: Change the type of a date field in your FD to string type,
82768>>>>>>>/// Set the attribute DF_FIELD_TIME_ON of this field to TRUE and
82768>>>>>>>/// recompile your program.
82768>>>>>>>/// @Assumptions
82768>>>>>>>/// @Status      Public
82768>>>>>>>/// @Drivers     All
82768>>>>>>>/// @VersionNote
82768>>>>>>>/// @See
82768>>>>>>>///
82768>>>>>>>/// @Syntax Set_Attribute DF_FIELD_TIME_ON of <FileNumber|FileName FieldNumber> to DFTRUE | DFFALSE
82768>>>>>>>/// @Param  FileNumber            Number of the file
82768>>>>>>>/// @Param  FileName              Name of the file
82768>>>>>>>/// @Param  FieldNumber           Number of the field
82768>>>>>>>/// @Example
82768>>>>>>>/// #INCLUDE MERTECH.INC
82768>>>>>>>/// string sDateTime sDatabaseName
82768>>>>>>>/// open ORDERHEA
82768>>>>>>>/// Set_Attribute DF_FIELD_TIME_ON of 30 3 to dfTrue
82768>>>>>>>/// find GE ORDERHEA by recnum
82768>>>>>>>/// move ORDERHEA.ORDER_DATE to sDateTime
82768>>>>>>>/// showln "sDateTime: " sDateTime
82768>>>>>>>Define DF_FIELD_TIME_ON                             For (DF_FIELD_NATIVE_LENGTH+8)
82768>>>>>>>
82768>>>>>>>//=============================================================================
82768>>>>>>>/// @Name        DF_FIELD_NATIVE_NAME
82768>>>>>>>/// @Description This attribute is used to get the name of the desired column
82768>>>>>>>/// on the SQL backend. Currently this attribute is ReadOnly and so setting
82768>>>>>>>/// or modifying a column name cannot be done using this attribute.  In most
82768>>>>>>>/// cases, the field name on the SQL backend will be the same as the Dataflex name.
82768>>>>>>>///
82768>>>>>>>/// This is a ReadOnly attribute.
82768>>>>>>>///
82768>>>>>>>/// @Assumptions
82768>>>>>>>/// @Status      Public
82768>>>>>>>/// @Drivers     All
82768>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
82768>>>>>>>/// @See
82768>>>>>>>/// @INTOPT
82768>>>>>>>///
82768>>>>>>>/// @Syntax Get_Attribute DF_FIELD_NATIVE_NAME of {FileNumber} {FieldNumber} to {variable}
82768>>>>>>>/// @Param  FileNumber          Number of the file
82768>>>>>>>/// @Param  FieldNumber                 Number of the Field
82768>>>>>>>/// @Param  variable                    String containing the name of the field
82768>>>>>>>/// @Example
82768>>>>>>>/// Open Customer
82768>>>>>>>///
82768>>>>>>>/// String sName
82768>>>>>>>///
82768>>>>>>>/// Get_Attribute DF_FIELD_NATIVE_NAME of Customer.File_Number 3 to sName
82768>>>>>>>Define DF_FIELD_NATIVE_NAME                         For (DF_FIELD_NATIVE_LENGTH+9)
82768>>>>>>>
82768>>>>>>>//=============================================================================
82768>>>>>>>/// @Name        DF_FIELD_NULL
82768>>>>>>>/// @Description Use this attribute to get or set whether a column in a table will
82768>>>>>>>/// allow null values. When set to true, the column accepts null values. Setting
82768>>>>>>>/// this attribute to false will keep it from accepting null values. Although,
82768>>>>>>>/// getting the value of this attribute can be done at anytime, setting it must
82768>>>>>>>/// be done in a Structure_Start or during table creation.
82768>>>>>>>///
82768>>>>>>>/// @Assumptions
82768>>>>>>>/// @Status      Public
82768>>>>>>>/// @Drivers     All
82768>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
82768>>>>>>>/// @See
82768>>>>>>>/// @INTOPT
82768>>>>>>>///
82768>>>>>>>/// @Syntax Get_Attribute DF_FIELD_NULL of {FileNumber} {FieldNumber} to {variable}
82768>>>>>>>/// @Syntax Set_Attribute DF_FIELD_NULL of {FileNumber} {FieldNumber} to {variable}
82768>>>>>>>/// @Param  FileNumber          Number of the file
82768>>>>>>>/// @Param  FieldNumber                 Number of the Field
82768>>>>>>>/// @Param  variable                    Boolean variable
82768>>>>>>>/// @Example
82768>>>>>>>/// Open Customer
82768>>>>>>>/// Handle hFile
82768>>>>>>>/// Integer iColumn
82768>>>>>>>/// Boolean bAllowNull
82768>>>>>>>///
82768>>>>>>>/// Move Customer.File_Number to hFile
82768>>>>>>>/// Move 3 to iColumn
82768>>>>>>>///
82768>>>>>>>/// Structure_Start hFile "ORA_DRV"
82768>>>>>>>///    Set_Attribute DF_FIELD_NULL of hFile iColumn to True
82768>>>>>>>/// Structure_End hFile
82768>>>>>>>///
82768>>>>>>>/// Get_Attribute DF_FIELD_NULL of hFile iColumn to bAllowNull
82768>>>>>>>Define DF_FIELD_NULL                                For (DF_FIELD_NATIVE_LENGTH+10)
82768>>>>>>>
82768>>>>>>>
82768>>>>>>>//=============================================================================
82768>>>>>>>/// @Name        DF_FIELD_NATIVE_TYPE
82768>>>>>>>/// @Description Use this attribute to get or set the Native type for a specific
82768>>>>>>>/// field in a table.  The native type refers to the data type of the field on the
82768>>>>>>>/// SQL backend. Setting this attribute can only be done during table creation or
82768>>>>>>>/// inside of a Structure_Start. When setting this attribute, it is good practice
82768>>>>>>>/// to use the constants mentioned below instead of the integers. For a list of
82768>>>>>>>/// these constants, refer to the sections: "Oracle Data Types", "MySQL Data Types",
82768>>>>>>>/// "PostgreSQL Data Types", and "SQL Server Data Types" included in this document.
82768>>>>>>>/// Note that when getting the value for this attribute, an integer will be returned
82768>>>>>>>/// so these lists of constants can again prove useful.
82768>>>>>>>///
82768>>>>>>>/// @Assumptions
82768>>>>>>>/// @Status      Public
82768>>>>>>>/// @Drivers     All
82768>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
82768>>>>>>>/// @See
82768>>>>>>>/// @INTOPT      FIELD_TYPE
82768>>>>>>>///
82768>>>>>>>/// @Syntax Set_Attribute DF_FIELD_NATIVE_TYPE of {FileNumber} {FieldNumber} to {variable}
82768>>>>>>>/// @Syntax Get_Attribute DF_FIELD_NATIVE_TYPE of {FileNumber} {FieldNumber} to {variable}
82768>>>>>>>/// @Param  FileNumber          Number of the file
82768>>>>>>>/// @Param  FieldNumber         Number of the field
82768>>>>>>>/// @Param  variable                    variable for the native data type
82768>>>>>>>/// @Example
82768>>>>>>>/// open Customer
82768>>>>>>>///
82768>>>>>>>/// Integer iColumn iType
82768>>>>>>>/// Handle hFile
82768>>>>>>>///
82768>>>>>>>/// Move Customer.File_Number to hFile
82768>>>>>>>/// Structure_Start hFile
82768>>>>>>>///     Set_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to "eSQLServer_DATE"
82768>>>>>>>///     Get_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to iType
82768>>>>>>>///     Structure_End hFile
82768>>>>>>>Define DF_FIELD_NATIVE_TYPE                         For (DF_FIELD_NATIVE_LENGTH+12)
82768>>>>>>>
82768>>>>>>>// Currently Unsupported Attribute (readOnly used by DataFlex 18.0 Studio)
82768>>>>>>>Define DF_FIELD_NATIVE_TYPE_NAME                    For 711
82768>>>>>>>
82768>>>>>>>// Currently Unsupported Attribute
82768>>>>>>>Define DF_FIELD_NATIVE_OFFSET                       For (DF_FIELD_NATIVE_LENGTH+14)
82768>>>>>>>
82768>>>>>>>//=============================================================================
82768>>>>>>>/// @Name        DF_FIELD_AUTO_INCREMENT
82768>>>>>>>/// @Description Auto incrementing is a technique used in Dataflex usually for
82768>>>>>>>/// fields that are set as the unique identifier. Instead of generating a value
82768>>>>>>>/// or manually inserting data into the column, when a field auto increments,
82768>>>>>>>/// the value of the field increases by one (usually) with each record.  This
82768>>>>>>>/// field is used to get or set whether the field uses this technique or not.
82768>>>>>>>/// The attribute, however, can only be set inside of a Structure_Start or during
82768>>>>>>>/// table creation. Getting the attribute's value can be done at anytime. The
82768>>>>>>>/// value is stored as a boolean, either true or false.
82768>>>>>>>///
82768>>>>>>>/// @Assumptions
82768>>>>>>>/// @Status      Public
82768>>>>>>>/// @Drivers     All
82768>>>>>>>/// @VersionNote Last Revised: 2013-08-12 by Aaron Gulack
82768>>>>>>>/// @See
82768>>>>>>>/// @INTOPT      FIELD_AUTOINCREMENT_TYPE
82768>>>>>>>///
82768>>>>>>>/// @Syntax Set_Attribute DF_FIELD_AUTO_INCREMENT of {FileNumber} {FieldNumber} to {variable}
82768>>>>>>>/// @Syntax Get_Attribute DF_FIELD_AUTO_INCREMENT of {FileNumber} {FieldNumber} to {variable}
82768>>>>>>>/// @Param  FileNumber          Number of the file
82768>>>>>>>/// @Param  FieldNumber         Number of the field
82768>>>>>>>/// @Param  variable                    Boolean variable indicating if the field auto increments.
82768>>>>>>>/// @Example
82768>>>>>>>/// open Customer
82768>>>>>>>///
82768>>>>>>>/// Integer iColumn
82768>>>>>>>/// Boolean bIncrement
82768>>>>>>>/// Handle hFile
82768>>>>>>>///
82768>>>>>>>/// Move Customer.File_Number to hFile
82768>>>>>>>///
82768>>>>>>>/// Structure_Start hFile
82768>>>>>>>///     Set_Attribute DF_FIELD_AUTO_INCREMENT of hFile iColumn to True
82768>>>>>>>///     Get_Attribute DF_FIELD_AUTO_INCREMENT of hFile iColumn to bIncrement
82768>>>>>>>///     Structure_End hFile
82768>>>>>>>Define DF_FIELD_AUTO_INCREMENT                      For (DF_FIELD_NATIVE_LENGTH+16)
82768>>>>>>>
82768>>>>>>>//Currently Unsupported Attribute
82768>>>>>>>Define DF_FIELD_GENERATE_ALWAYS                     For (DF_FIELD_NATIVE_LENGTH+18)
82768>>>>>>>
82768>>>>>>>// Currently Unsupported Attribute
82768>>>>>>>Define DF_FIELD_SEND_LONG_DATA                      For 702
82768>>>>>>>
82768>>>>>>>//=============================================================================
82768>>>>>>>/// @Name        DF_INDEX_NATIVE_CREATED
82768>>>>>>>/// @Description Use this attribute to verify if the index that maps to the DataFlex
82768>>>>>>>/// index was created correctly at the SQL backend
82768>>>>>>>///
82768>>>>>>>/// This is a ReadOnly attribute
82768>>>>>>>///
82768>>>>>>>/// @Assumptions
82768>>>>>>>/// @Status      Public
82768>>>>>>>/// @Drivers     All
82768>>>>>>>/// @VersionNote Last Revised: 2014-04-30 by Wil van Antwerpen
82768>>>>>>>/// @See
82768>>>>>>>/// @INTOPT
82768>>>>>>>///
82768>>>>>>>/// @Syntax Get_Attribute DF_INDEX_NATIVE_CREATED of {FileNumber} {IndexNumber} to variable
82768>>>>>>>/// @Param  FileNumber            Number of the file
82768>>>>>>>/// @Param  IndexNumber           Number of the index
82768>>>>>>>/// @Param  variable              True if created, false if not
82768>>>>>>>/// @Example
82768>>>>>>>/// Open Customer
82768>>>>>>>///
82768>>>>>>>/// Handle  hFile
82768>>>>>>>/// Integer iIndex
82768>>>>>>>/// Boolean bCreated
82768>>>>>>>///
82768>>>>>>>/// Move Customer.File_Number to hFile
82768>>>>>>>/// Move 1 To iIndex
82768>>>>>>>/// Get_Attribute DF_INDEX_NATIVE_CREATED of hFile iIndex to bCreated
82768>>>>>>>Define DF_INDEX_NATIVE_CREATED                      For (DF_INDEX_KEY_LENGTH+1)
82768>>>>>>>
82768>>>>>>>//=============================================================================
82768>>>>>>>/// @Name        DF_INDEX_NAME
82768>>>>>>>/// @Description Use this attribute to get the name of the index on the SQL backend
82768>>>>>>>/// that maps to the numbered index in Dataflex.  This is because, unlike Dataflex,
82768>>>>>>>/// all indexes in SQL are stored as names, not numbers. Since this attribute is
82768>>>>>>>/// currently only a ReadOnly attribute, it can not be used to set or modify a named
82768>>>>>>>/// index.
82768>>>>>>>///
82768>>>>>>>/// This is a ReadOnly attribute
82768>>>>>>>///
82768>>>>>>>/// @Assumptions
82768>>>>>>>/// @Status      Public
82768>>>>>>>/// @Drivers     All
82768>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
82768>>>>>>>/// @See
82768>>>>>>>/// @INTOPT
82768>>>>>>>///
82768>>>>>>>/// @Syntax Get_Attribute DF_INDEX_NAME of {FileNumber} {IndexNumber} to variable
82768>>>>>>>/// @Param  FileNumber            Number of the file
82768>>>>>>>/// @Param  IndexNumber           Number of the index
82768>>>>>>>/// @Param  variable              Name of the index
82768>>>>>>>/// @Example
82768>>>>>>>///
82768>>>>>>>/// Integer iFile iIndex iIndexes
82768>>>>>>>///
82768>>>>>>>/// Open Orderhea
82768>>>>>>>/// Move Orderhea.File_Number to iFile
82768>>>>>>>/// Get_Attribute DF_FILE_LAST_INDEX_NUMBER of iFile to iIndexes
82768>>>>>>>///
82768>>>>>>>/// For iIndex From 0 to iIndexes
82768>>>>>>>///     Get_Attribute DF_INDEX_NAME of iFile iIndex to sIndexName
82768>>>>>>>///     Showln "Orderhea.Index." iIndex " : " sIndexName
82768>>>>>>>/// Loop
82768>>>>>>>Define DF_INDEX_NAME                                For (DF_INDEX_KEY_LENGTH+2)
82768>>>>>>>
82768>>>>>>>//=============================================================================
82768>>>>>>>/// @Name        DF_PRIMARY_KEY
82768>>>>>>>/// @Description This attribute is used to get or set the index number
82768>>>>>>>/// being used for the primary key. Getting the index number can be
82768>>>>>>>/// done at any time, but setting the index must be during a
82768>>>>>>>/// Structure_Start or during table creation.
82768>>>>>>>///
82768>>>>>>>/// @Assumptions
82768>>>>>>>/// @Status      Deprecated
82768>>>>>>>/// @Drivers     All
82768>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
82768>>>>>>>/// @See                 DF_INDEX_PRIMARY_KEY
82768>>>>>>>/// @INTOPT
82768>>>>>>>///
82768>>>>>>>/// @Syntax Get_Attribute DF_PRIMARY_KEY of {FileNumber} to {variable}
82768>>>>>>>/// @Syntax Set_Attribute DF_PRIMARY_KEY of {FileNumber} to {variable}
82768>>>>>>>/// @Param  FileNumber            Number of the file
82768>>>>>>>/// @Param  variable              Index number being used with primary key
82768>>>>>>>/// @Example
82768>>>>>>>/// Open Customer
82768>>>>>>>///
82768>>>>>>>/// Integer iKey
82768>>>>>>>/// Handle hFile
82768>>>>>>>///
82768>>>>>>>/// Move Customer.File_Number to hFile
82768>>>>>>>///
82768>>>>>>>/// Structure_Start hFile
82768>>>>>>>///     Set_Attribute DF_PRIMARY_KEY of hFile to 2
82768>>>>>>>///     Get_Attribute DF_PRIMARY_KEY of hFile to iKey
82768>>>>>>>/// Structure_End hFile
82768>>>>>>>Define DF_PRIMARY_KEY                               For (DF_INDEX_KEY_LENGTH+3)
82768>>>>>>>
82768>>>>>>>//=============================================================================
82768>>>>>>>/// @Name        DF_INDEX_PRIMARY_KEY
82768>>>>>>>/// @Description This attribute is used to get or set the index number
82768>>>>>>>/// being used for the primary key. Getting the index number can be
82768>>>>>>>/// done at any time, but setting the index must be during a
82768>>>>>>>/// Structure_Start or during table creation.
82768>>>>>>>///
82768>>>>>>>/// @Assumptions
82768>>>>>>>/// @Status      Public
82768>>>>>>>/// @Drivers     All
82768>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
82768>>>>>>>/// @See
82768>>>>>>>/// @INTOPT              PRIMARY_KEY
82768>>>>>>>///
82768>>>>>>>/// @Syntax Get_Attribute DF_INDEX_PRIMARY_KEY of {FileNumber} to {variable}
82768>>>>>>>/// @Syntax Set_Attribute DF_INDEX_PRIMARY_KEY of {FileNumber} to {variable}
82768>>>>>>>/// @Param  FileNumber            Number of the file
82768>>>>>>>/// @Param  variable              Index number being used with primary key
82768>>>>>>>/// @Example
82768>>>>>>>/// Open Customer
82768>>>>>>>///
82768>>>>>>>/// Integer iKey
82768>>>>>>>/// Handle hFile
82768>>>>>>>///
82768>>>>>>>/// Move Customer.File_Number to hFile
82768>>>>>>>///
82768>>>>>>>/// Structure_Start hFile
82768>>>>>>>///     Set_Attribute DF_INDEX_PRIMARY_KEY of hFile to 2
82768>>>>>>>///     Get_Attribute DF_INDEX_PRIMARY_KEY of hFile to iKey
82768>>>>>>>/// Structure_End hFile
82768>>>>>>>Define DF_INDEX_PRIMARY_KEY                         For (DF_INDEX_KEY_LENGTH+3)
82768>>>>>>>
82768>>>>>>>//=============================================================================
82768>>>>>>>/// @Name        DF_INDEX_STATUS
82768>>>>>>>/// @Description Oracle has an attribute for indexes called "STATUS" which indicates
82768>>>>>>>/// whether or not an index is valid for use. This attribute can only be used to get
82768>>>>>>>/// the value of the "STATUS" property in Oracle. It currently does not support setting
82768>>>>>>>/// the attribute. The two values for this attribute are "VALID" or "UNUSABLE".
82768>>>>>>>///
82768>>>>>>>/// This is a ReadOnly attribute
82768>>>>>>>///
82768>>>>>>>/// @Assumptions
82768>>>>>>>/// @Status      Public
82768>>>>>>>/// @Drivers     ORAFlex
82768>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
82768>>>>>>>/// @See
82768>>>>>>>/// @INTOPT
82768>>>>>>>///
82768>>>>>>>/// @Syntax Get_Attribute DF_INDEX_STATUS of {FileNumber} {IndexNumber} to {variable}
82768>>>>>>>/// @Param  FileNumber            Number of the file
82768>>>>>>>/// @Param  FieldNumber           Number of the index
82768>>>>>>>/// @Param  variable              String indicating validity
82768>>>>>>>/// @Example
82768>>>>>>>/// Open Customer
82768>>>>>>>///
82768>>>>>>>/// String sIndexStatus
82768>>>>>>>///
82768>>>>>>>/// Get_Attribute DF_INDEX_STATUS of Customer.File_Number 1 to sIndexStatus
82768>>>>>>>Define DF_INDEX_STATUS                              For (DF_INDEX_KEY_LENGTH+4)
82768>>>>>>>
82768>>>>>>>//Currently Unsupported Attribute
82768>>>>>>>Define DF_INDEX_STORAGE_PCTFREE                     For (DF_INDEX_KEY_LENGTH+5)
82768>>>>>>>
82768>>>>>>>//=============================================================================
82768>>>>>>>/// @Name        DF_INDEX_UNIQUE
82768>>>>>>>/// @Description An index on a column that is unique is considered so if it
82768>>>>>>>/// does not have two equal values in that column in two different rows. This
82768>>>>>>>/// attribute is used to find out whether or not the specified index is unique.
82768>>>>>>>/// If it is, this attribute will return "U" indicating that it is indeed unique.
82768>>>>>>>/// This is important to note because when getting the value of this attribute,
82768>>>>>>>/// a string variable must be used. Since this is a ReadOnly attribute, setting
82768>>>>>>>/// an idex to unique cannot be done with this attribute.
82768>>>>>>>///
82768>>>>>>>///
82768>>>>>>>/// @Assumptions
82768>>>>>>>/// @Status      Public
82768>>>>>>>/// @Drivers     All
82768>>>>>>>/// @VersionNote Last Revised: 2013-08-14 by Aaron Gulack
82768>>>>>>>/// @See
82768>>>>>>>/// @INTOPT
82768>>>>>>>///
82768>>>>>>>/// @Syntax Get_Attribute DF_INDEX_UNIQUE of {FileNumber} {IndexNumber} to {variable}
82768>>>>>>>/// @Param  FileNumber            Number of the file
82768>>>>>>>/// @Param  FieldNumber           Number of the index
82768>>>>>>>/// @Param  variable              String indicating if unique
82768>>>>>>>/// @Example
82768>>>>>>>/// Open Customer
82768>>>>>>>///
82768>>>>>>>/// String sIndexUnique
82768>>>>>>>///
82768>>>>>>>/// Get_Attribute DF_INDEX_UNIQUE of Customer.File_Number 1 to sIndexUnique
82768>>>>>>>Define DF_INDEX_UNIQUE                              For (DF_INDEX_KEY_LENGTH+6)
82768>>>>>>>
82768>>>>>>>//Currently Unsupported Attribute
82768>>>>>>>Define DF_INDEX_STORAGE_BASE                        For (DF_INDEX_KEY_LENGTH+7)
82768>>>>>>>
82768>>>>>>>//Currently Unsupported Attribute
82768>>>>>>>Define DF_INDEX_STORAGE_INITIAL                     For (DF_INDEX_KEY_LENGTH+8)
82768>>>>>>>
82768>>>>>>>//Currently Unsupported Attribute
82768>>>>>>>Define DF_INDEX_STORAGE_NEXT                        For (DF_INDEX_KEY_LENGTH+10)
82768>>>>>>>
82768>>>>>>>//Currently Unsupported Attribute
82768>>>>>>>Define DF_INDEX_NATIVE_TYPE                         For (DF_INDEX_KEY_LENGTH+13)
82768>>>>>>>
82768>>>>>>>//TODO
82768>>>>>>>Define DF_INDEX_TABLESPACE                          For (DF_INDEX_KEY_LENGTH+14)
82768>>>>>>>
82768>>>>>>>//TODO
82768>>>>>>>Define DF_FIELD_PROGRAMMATIC_DEFAULT                For 701
82768>>>>>>>Define DF_FIELD_TIME                                For 703
82768>>>>>>>Define DF_FIELD_IS_NULL                             For 704
82768>>>>>>>
82768>>>>>>>//=============================================================================
82768>>>>>>>/// @Name        DF_FIELD_IS_LOB
82768>>>>>>>/// @Description In databases a LOB data type is any type that is considered
82768>>>>>>>/// a "Large Object" i.e. XML types, Binary types etc.  This attribute is a
82768>>>>>>>/// ReadOnly attribute used to indicate whether the given field is considered
82768>>>>>>>/// a LOB data type. Since it is ReadOnly, this attribute cannot set a field
82768>>>>>>>/// to a LOB data type.
82768>>>>>>>///
82768>>>>>>>/// @Assumptions
82768>>>>>>>/// @Status      Public
82768>>>>>>>/// @Drivers     All
82768>>>>>>>/// @VersionNote Last Revised: 2013-08-13 by Aaron Gulack
82768>>>>>>>/// @See
82768>>>>>>>/// @INTOPT
82768>>>>>>>///
82768>>>>>>>/// @Syntax Get_Attribute DF_FIELD_IS_LOB of {FileNumber} {FieldNumber} to {variable}
82768>>>>>>>/// @Param  FileNumber            Number of the file
82768>>>>>>>/// @Param      FieldNumber                       Number of the field
82768>>>>>>>/// @Param  variable              Boolean variable indicating if LOB
82768>>>>>>>/// @Example
82768>>>>>>>/// Open Customer
82768>>>>>>>///
82768>>>>>>>/// Boolean bIsLOB
82768>>>>>>>///
82768>>>>>>>/// Get_Attribute DF_FIELD_IS_LOB of Customer.File_Number 6 to bIsLOB
82768>>>>>>>Define DF_FIELD_IS_LOB                              For 706
82768>>>>>>>Define DF_FIELD_DEFAULT_FUNCTION                    For 707
82768>>>>>>>
82768>>>>>>>//Currently Unsupported Attribute
82768>>>>>>>Define DF_FIELD_HANDLE_AS_LOB                       For 708
82768>>>>>>>
82768>>>>>>>//TODO
82768>>>>>>>Define DF_FIELD_PARTIAL_OVERLAP                     For 710
82768>>>>>>>
82768>>>>>>>//=============================================================================
82768>>>>>>>/// @Name        DF_FILE_NUMBER_SQL_RELATIONS
82768>>>>>>>/// @Description This attribute is used to get the number of foreign keys
82768>>>>>>>/// for a given table on the SQL backend. Foreign keys are used to specify
82768>>>>>>>/// relationships between tables. Since this attribute is ReadOnly, it cannot
82768>>>>>>>/// be used to set the number of foreign keys in a table.  Note that this
82768>>>>>>>/// attribute returns only the number of foreign keys, no other information
82768>>>>>>>/// is provided with this attribute.
82768>>>>>>>///
82768>>>>>>>/// This is a ReadOnly attribute
82768>>>>>>>///
82768>>>>>>>/// @Assumptions
82768>>>>>>>/// @Status      Public
82768>>>>>>>/// @Drivers     All
82768>>>>>>>/// @VersionNote Last Revised: 2013-08-13 by Aaron Gulack
82768>>>>>>>/// @See
82768>>>>>>>/// @INTOPT
82768>>>>>>>///
82768>>>>>>>/// @Syntax Get_Attribute DF_FILE_NUMBER_SQL_RELATIONS of {FileNumber} to {variable}
82768>>>>>>>/// @Param  FileNumber            Number of the file
82768>>>>>>>/// @Param  variable              Integer variable showing number of relationships
82768>>>>>>>/// @Example
82768>>>>>>>/// Open Customer
82768>>>>>>>///
82768>>>>>>>/// Integer iRelations
82768>>>>>>>///
82768>>>>>>>/// Get_Attribute DF_FILE_NUMBER_SQL_RELATIONS of Customer.File_Number to iRelations
82768>>>>>>>Define DF_FILE_NUMBER_SQL_RELATIONS                 For 626
82768>>>>>>>
82768>>>>>>>//TODO
82768>>>>>>>Define DF_SQL_RELATION_COLUMN                       For 716
82768>>>>>>>Define DF_SQL_RELATION_RELATED_SCHEMA               For 717
82768>>>>>>>Define DF_SQL_RELATION_RELATED_TABLE                For 719
82768>>>>>>>Define DF_SQL_RELATION_RELATED_COLUMN               For 721
82768>>>>>>>Define DF_SQL_RELATION_NAME                         For 723
82768>>>>>>>Define DF_SQL_RELATION_STATUS                       For 724
82768>>>>>>>Define DF_SQL_RELATION_DELETE_REF_ACTION            For 726
82768>>>>>>>
82768>>>>>>>//Currently Unsupported Attribute
82768>>>>>>>Define DF_FIELD_OVERLAP_START                       For 728
82768>>>>>>>
82768>>>>>>>//Currently Unsupported Attribute
82768>>>>>>>Define DF_FIELD_OVERLAP_END                         For 730
82768>>>>>>>
82768>>>>>>>//Currently Unsupported Attribute
82768>>>>>>>Define DF_FIELD_OVERLAP_OFFSET_START                For 732
82768>>>>>>>
82768>>>>>>>//Currently Unsupported Attribute
82768>>>>>>>Define DF_FIELD_OVERLAP_OFFSET_END                  For 734
82768>>>>>>>
82768>>>>>>>//=============================================================================
82768>>>>>>>/// @Name        DF_FILE_RECNUM_TABLE
82768>>>>>>>/// @Description Dataflex's embedded database, by default, uses a Recnum column
82768>>>>>>>/// as the unique identifier for a table instead of a primary key. A table can
82768>>>>>>>/// easily be changed to use another column though and this attribute gets or
82768>>>>>>>/// sets whether the Recnum is being used for a table. Getting the value of this
82768>>>>>>>/// attribute can be done at any time for any driver. The setting of this attribute,
82768>>>>>>>/// however, can only be done in certain situations. Only if an alternative primary
82768>>>>>>>/// key is set up already can this attribute be set to false and only during a
82768>>>>>>>/// Structure_Start. Also, the attribute can only be turned off (set to false),
82768>>>>>>>/// it can not be turned back on (set to True).
82768>>>>>>>///
82768>>>>>>>/// Note: In Postgres, this attribute is a ReadOnly attribute and can not be set.
82768>>>>>>>///
82768>>>>>>>/// @Assumptions
82768>>>>>>>/// @Status      Public (PGFlex ReadOnly)
82768>>>>>>>/// @Drivers     All
82768>>>>>>>/// @VersionNote Last Revised: 2013-08-12 by Aaron Gulack
82768>>>>>>>/// @See                 DF_FILE_RECNUM_NAME DF_FILE_PRIMARY_INDEX
82768>>>>>>>/// @INTOPT
82768>>>>>>>///
82768>>>>>>>/// @Syntax Get_Attribute DF_FILE_RECNUM_TABLE of {FileNumber} to {variable}
82768>>>>>>>/// @Syntax Set_Attribute DF_FILE_RECNUM_TABLE of {FileNumber} to {variable}
82768>>>>>>>/// @Param  FileNumber            Number of the file
82768>>>>>>>/// @Param  variable              Boolean variable indicating if recnum is used
82768>>>>>>>/// @Example
82768>>>>>>>/// Open Customer
82768>>>>>>>///
82768>>>>>>>/// Boolean bRecnum
82768>>>>>>>/// Handle hFile
82768>>>>>>>///
82768>>>>>>>/// Move Customer.File_Number to hFile
82768>>>>>>>///
82768>>>>>>>/// Structure_Start hFile
82768>>>>>>>///     Set_Attribute DF_FILE_RECNUM_TABLE of Customer.File_Number to False
82768>>>>>>>///     Get_Attribute DF_FILE_RECNUM_TABLE of Customer.File_Number to bRecnum
82768>>>>>>>/// Structure_End hFile
82768>>>>>>>Define DF_FILE_RECNUM_TABLE                         For 1401
82768>>>>>>>
82768>>>>>>>//=============================================================================
82768>>>>>>>/// @Name        DF_FILE_PRIMARY_INDEX
82768>>>>>>>/// @Description This attribute gets or sets the index which is used as the
82768>>>>>>>/// primary key for a table. The variable used for this attribute is an integer
82768>>>>>>>/// containing the numbered index used. Getting the value of this attribute can
82768>>>>>>>/// be done at any time, whereas setting can only be done at table creation or
82768>>>>>>>/// during a Structure_Start. If a RECNUM is used as the unique identifier then
82768>>>>>>>/// 0 is returned.
82768>>>>>>>///
82768>>>>>>>/// Note: In Postgres this attribute is ReadOnly, so it can only be used to get
82768>>>>>>>/// the index used as the primary key.
82768>>>>>>>///
82768>>>>>>>/// @Assumptions
82768>>>>>>>/// @Status      Public (PGFlex ReadOnly)
82768>>>>>>>/// @Drivers     All
82768>>>>>>>/// @VersionNote Last Revised: 2013-08-12 by Aaron Gulack
82768>>>>>>>/// @See                 DF_FILE_RECNUM_NAME
82768>>>>>>>/// @INTOPT
82768>>>>>>>///
82768>>>>>>>/// @Syntax Get_Attribute DF_FILE_PRIMARY_INDEX of {FileNumber} to {variable}
82768>>>>>>>/// @Syntax Set_Attribute DF_FILE_PRIMARY_INDEX of {FileNumber} to {variable}
82768>>>>>>>/// @Param  FileNumber            Number of the file
82768>>>>>>>/// @Param  variable              Boolean variable indicating if a primary key is used
82768>>>>>>>/// @Example
82768>>>>>>>/// Open Customer
82768>>>>>>>///
82768>>>>>>>/// Boolean bPrimary
82768>>>>>>>/// Handle hFile
82768>>>>>>>///
82768>>>>>>>/// Move Customer.File_Number to hFile
82768>>>>>>>///
82768>>>>>>>/// Structure_Start hFile
82768>>>>>>>///     Set_Attribute DF_FILE_PRIMARY_INDEX of Customer.File_Number to False
82768>>>>>>>///     Get_Attribute DF_FILE_PRIMARY_INDEX of Customer.File_Number to bPrimary
82768>>>>>>>/// Structure_End hFile
82768>>>>>>>Define DF_FILE_PRIMARY_INDEX                        For 1402
82768>>>>>>>
82768>>>>>>>//=============================================================================
82768>>>>>>>/// @Name        DF_FILE_RECNUM_NAME
82768>>>>>>>/// @Description This attribute is used to get the name of the Recnum field
82768>>>>>>>/// in the table, if one exists. It is a ReadOnly attribute so it can only
82768>>>>>>>/// be used in getting the name of the recnum field to a string variable.
82768>>>>>>>///
82768>>>>>>>/// @Assumptions
82768>>>>>>>/// @Status      Public
82768>>>>>>>/// @Drivers     All
82768>>>>>>>/// @VersionNote Last Revised: 2013-08-12 by Aaron Gulack
82768>>>>>>>/// @See                 DF_FILE_RECNUM_TABLE
82768>>>>>>>/// @INTOPT
82768>>>>>>>///
82768>>>>>>>/// @Syntax Get_Attribute DF_FILE_RECNUM_NAME of {FileNumber} to {variable}
82768>>>>>>>/// @Param  FileNumber            Number of the file
82768>>>>>>>/// @Param  variable              String name of recnum field
82768>>>>>>>/// @Example
82768>>>>>>>/// Open Customer
82768>>>>>>>///
82768>>>>>>>/// String sRecnum
82768>>>>>>>///
82768>>>>>>>/// Get_Attribute DF_FILE_RECNUM_NAME of Customer.File_Number to sRecnum
82768>>>>>>>Define DF_FILE_RECNUM_NAME                          For 1403
82768>>>>>>>
82768>>>>>>>Define DF_FETCH_ALL                                 For -1
82768>>>>>>>Define DF_FETCH_TRUE                                For "TRUE"
82768>>>>>>>Define DF_FETCH_FALSE                               For "FALSE"
82768>>>>>>>Define DF_BIND_ALL_COLUMNS                          For -1
82768>>>>>>>
82768>>>>>>>// SQLFlex Lock Type
82768>>>>>>>Define DF_LOCK_TYPE_PAGE                            For 3
82768>>>>>>>
82768>>>>>>>// Extended Callback Types
82768>>>>>>>Define DF_MESSAGE_ERROR                             For 9
82768>>>>>>>Define DF_MESSAGE_PROGRESS_STATUS                   For 20
82768>>>>>>>Define DF_MESSAGE_PROGRESS_CONTINUE                 For 21
82768>>>>>>>
82768>>>>>>>//Drivers
82768>>>>>>>Define ORAFLEX                                      For "ORA_DRV"
82768>>>>>>>Define SQLFLEX                                      For "SQL_DRV"
82768>>>>>>>Define MDSDB2                                       For "MDS_DB2"
82768>>>>>>>Define MDSPgSQL                                     For "MDSPGSQL"
82768>>>>>>>Define PgFlex                                       For "MDSPGSQL"
82768>>>>>>>Define MDSMySQL                                     For "MDSMYSQL"
82768>>>>>>>Define MySQLFlex                                    For "MDSMYSQL"
82768>>>>>>>
82768>>>>>>>// Delimiter for SQL ID objects
82768>>>>>>>Define DB2_ID_DELIM                                 For '"'
82768>>>>>>>Define MYSQL_ID_DELIM                               For "`"
82768>>>>>>>Define ORACLE_ID_DELIM                              For '"'
82768>>>>>>>Define PGSQL_ID_DELIM                               For '"'
82768>>>>>>>Define SQLSERVER_ID_DELIM                           For '"'
82768>>>>>>>
82768>>>>>>>// dfStructureEnd Option bits
82768>>>>>>>Define DF_STRUCTEND_OPT_INDEX_ONLY                  For 16    // Internal Use Only
82768>>>>>>>Define DF_STRUCTEND_OPT_FORCE_INVK                  For 32
82768>>>>>>>Define DF_STRUCTEND_OPT_OLD_INVK_NAME               For 64
82768>>>>>>>Define DF_STRUCTEND_OPT_FORCE_NOT_NULL              For 128
82768>>>>>>>Define DF_STRUCTEND_OPT_CREATE_ROWID_TABLE          For 256
82768>>>>>>>
82768>>>>>>>//Additional Data Types
82768>>>>>>>Define DF_DATETIME                                  For 7
82768>>>>>>>
82768>>>>>>>//Call_Driver Functions
82768>>>>>>>Define CALLDRV_LICENSE_ENVIRONMENT_SET              For 0
82768>>>>>>>Define CALLDRV_ORA_CURRENT_SQL_SERVER               For 6
82768>>>>>>>Define CALLDRV_SQL_ERROR_MESSAGE                    For 14
82768>>>>>>>Define CALLDRV_CURRENT_SQL_SERVER                   for 19
82768>>>>>>>Define CALLDRV_SQL_NEXT_RESULTSET                                       for 22
82768>>>>>>>Define CALLDRV_BIND_PARAMETER                       for 23
82768>>>>>>>Define CALLDRV_SQL_MAX_CURSORS                      For 26
82768>>>>>>>Define CALLDRV_SQLLOADER_FIELDS_TERM                For 30
82768>>>>>>>Define CALLDRV_CREATE_TABLE_FROM_DAT                For 30
82768>>>>>>>Define CALLDRV_SQLLOADER_DECIMAL_SEP                For 31
82768>>>>>>>Define CALLDRV_CONVERT_DAT_FILE                     For 32
82768>>>>>>>Define CALLDRV_SQLFLEX_MAX_CURSORS                  For 37
82768>>>>>>>Define CALLDRV_NATIVE_OPTIMIZATION                  For 38
82768>>>>>>>Define CALLDRV_GET_RETURNED_COLUMNS                 For 39
82768>>>>>>>Define CALLDRV_GET_RETURNED_ROWS                    For 40
82768>>>>>>>Define CALLDRV_GET_COLUMN_ATTRIBUTE                 For 41
82768>>>>>>>Define CALLDRV_START_TXTGEN_AFTER_RECNUM            For 42
82768>>>>>>>Define CALLDRV_FINISH_TXTGEN_AFTER_RECNUM           For 43
82768>>>>>>>Define CALLDRV_SET_ISOLATION_LEVEL                  For 44
82768>>>>>>>Define CALLDRV_GET_SERVER_CFG                       For 45
82768>>>>>>>Define CALLDRV_SET_SQL_LOCK_TIMEOUT                 For 46
82768>>>>>>>Define CALLDRV_GET_SQL_LOCK_TIMEOUT                 For 47
82768>>>>>>>Define CALLDRV_GET_RESULTS                          For 48
82768>>>>>>>Define CALLDRV_GET_MORE_RESULTS                     For 49
82768>>>>>>>Define CALLDRV_GET_CURRENT_USER_NAME                For 50
82768>>>>>>>Define CALLDRV_OPEN_EMBEDDED_CURSOR                 For 51
82768>>>>>>>Define CALLDRV_CLOSE_EMBEDDED_CURSOR                For 52
82768>>>>>>>Define CALLDRV_SET_CURRENT_EMBEDDED_CURSOR          For 53
82768>>>>>>>Define CALLDRV_GET_CURRENT_EMBEDDED_CURSOR          For 54
82768>>>>>>>Define CALLDRV_SET_MAX_EMBEDDED_CURSOR              For 55
82768>>>>>>>Define CALLDRV_GET_MAX_EMBEDDED_CURSOR              For 56
82768>>>>>>>Define CALLDRV_SQL_TRANSACTION                      For 57
82768>>>>>>>Define CALLDRV_LOCAL_TD_PATH                        For 58
82768>>>>>>>Define CALLDRV_CREATE_DB                            For 59
82768>>>>>>>Define CALLDRV_ESCAPE_STRING                        For 60
82768>>>>>>>Define CALLDRV_SET_PROC_ATTRIBUTE_TYPE              For 61
82768>>>>>>>Define CALLDRV_SQL_REFRESH_CACHE                    For 62
82768>>>>>>>Define CALLDRV_GET_SQL_STMT                         For 63
82768>>>>>>>Define CALLDRV_DIRECT_PATH_LOAD                     For 64
82768>>>>>>>
82768>>>>>>>Define CALLDRV_READ_LOB                             For 65
82768>>>>>>>Define CALLDRV_WRITE_LOB                            For 66
82768>>>>>>>Define CALLDRV_APPEND_LOB                           For 67
82768>>>>>>>Define CALLDRV_LENGTH_LOB                           For 68
82768>>>>>>>Define CALLDRV_LOADFROMFILE_LOB                     For 69
82768>>>>>>>Define CALLDRV_ERASE_LOB                            For 70
82768>>>>>>>Define CALLDRV_TRUNCATE_LOB                         For 71
82768>>>>>>>Define CALLDRV_INITIALIZE_SEQUENCE                  For 72
82768>>>>>>>Define CALLDRV_CLIENT_CFG                           For 73
82768>>>>>>>Define CALLDRV_END_SAVERECORD                       For 74
82768>>>>>>>Define CALLDRV_ENABLE_RECONNECT                     For 75
82768>>>>>>>Define CALLDRV_ENUMERATE_SERVER                     For 76
82768>>>>>>>Define CALLDRV_USE_ROWCOUNT_IN_TRANSACTIONS         For 77
82768>>>>>>>Define CALLDRV_USE_DFLEX_DATE_FORMAT                For 78
82768>>>>>>>Define CALLDRV_FORCE_FIELDS_NOT_NULL                For 79
82768>>>>>>>Define CALLDRV_ORA_CREATE_TABLE_FROM_DAT            For 80
82768>>>>>>>Define CALLDRV_MAX_DATA_SIZE                        For 81
82768>>>>>>>Define CALLDRV_CHUNK_SIZE                           For 82
82768>>>>>>>Define CALLDRV_GET_DATA_CHUNK                       For 83
82768>>>>>>>Define CALLDRV_MIRROR_SERVER                        For 84
82768>>>>>>>Define CALLDRV_COPY_DATA                            For 85
82768>>>>>>>Define CALLDRV_SET_SQL_CURSOR_TYPE                  For 86
82768>>>>>>>Define CALLDRV_ICF                                  For 87
82768>>>>>>>Define CALLDRV_CLEAR_INT_CACHE                      For 88
82768>>>>>>>Define CALLDRV_GET_CURRENT_USER_PASSWORD            For 89
82768>>>>>>>Define CALLDRV_FORCE_FIELDS_NULL                    For 90
82768>>>>>>>Define CALLDRV_TRANSACTIONS_ALLOWED                 For 91
82768>>>>>>>Define CALLDRV_SQL_ERROR_MESSAGE2                   For 92
82768>>>>>>>Define CALLDRV_PGSQL_NAME_SPACE                     For 93
82768>>>>>>>Define CALLDRV_EMBEDDED_SQL_TYPE                    For 94
82768>>>>>>>Define CALLDRV_CREATE_INVK_FUNCTIONS                For 95
82768>>>>>>>Define CALLDRV_DEFAULT_FILE_CASING                  For 96
82768>>>>>>>Define CALLDRV_GLOBAL_SETTING                       For 97
82768>>>>>>>Define CALLDRV_RESTRUCTURE_SCRIPT                   For 98
82768>>>>>>>Define CALLDRV_CURRENT_SQL_SERVER_CONNECTION        For 99
82768>>>>>>>Define CALLDRV_100                                  For 100
82768>>>>>>>Define CALLDRV_FILE_STRUCT_DYNAMIC_ONLINE           For 101
82768>>>>>>>Define CALLDRV_SET_FIXED_FILE_RECORDS_USED          For 102
82768>>>>>>>Define CALLDRV_GET_FIXED_FILE_RECORDS_USED          For 103
82768>>>>>>>Define CALLDRV_LOB_EX_WRITE                         For 104
82768>>>>>>>Define CALLDRV_LOB_EX_APPEND                        For 105
82768>>>>>>>Define CALLDRV_LOB_EX_READ                          For 106
82768>>>>>>>Define CALLDRV_LOB_EX_GET_LENGTH                    For 107
82768>>>>>>>Define CALLDRV_LOB_EX_SET_LENGTH                    For 108
82768>>>>>>>Define CALLDRV_LOB_EX_TEST                          For 109
82768>>>>>>>Define CALLDRV_LOB_EX_SET_NULL                      For 110
82768>>>>>>>
82768>>>>>>>// License and environment settings
82768>>>>>>>Define CALLDRV_DRIVER_REVISION                      For 0
82768>>>>>>>Define CALLDRV_COMPANY_NAME                         For 1
82768>>>>>>>Define CALLDRV_SERIAL_NUMBER                        For 2
82768>>>>>>>Define CALLDRV_LICENSED_USERS                       For 3
82768>>>>>>>Define CALLDRV_MAJOR_REVISION                       For 4
82768>>>>>>>Define CALLDRV_VERSION_COMMENTS                     For 5
82768>>>>>>>Define CALLDRV_OLEDB_OEM_TRANSLATION                For 6
82768>>>>>>>Define CALLDRV_SET_DB_PORT                          For 7
82768>>>>>>>Define CALLDRV_GET_DB_PORT                          For 8
82768>>>>>>>Define CALLDRV_SET_DB_SOCKET                        For 9
82768>>>>>>>Define CALLDRV_GET_DB_SOCKET                        For 10
82768>>>>>>>Define CALLDRV_SET_AS_SYSDBA                        For 11
82768>>>>>>>Define CALLDRV_OEM_TRANSLATION_STATE                For 12
82768>>>>>>>Define CALLDRV_TIME_TO_LIC_EXPIRATION               For 13
82768>>>>>>>Define CALLDRV_LICENSE_EXPIRATION_WARN              For 14
82768>>>>>>>Define CALLDRV_LICENSE_PATH                         For 15
82768>>>>>>>Define CALLDRV_AUTO_NUMERIC_REMAPPING               For 16
82768>>>>>>>Define CALLDRV_FORCE_DATE_FORMAT_INIT               For 17
82768>>>>>>>Define CALLDRV_STATIC_TABLE_OPT                     For 18
82768>>>>>>>Define CALLDRV_MAX_OBJECT_NAME_LENGTH               For 19
82768>>>>>>>Define CALLDRV_USE_LAZY_OPEN_MODE                   For 20
82768>>>>>>>Define CALLDRV_SET_CUSTOM_OEM_TO_ANSI               For 21
82768>>>>>>>Define CALLDRV_GET_CUSTOM_OEM_TO_ANSI               For 22
82768>>>>>>>
82768>>>>>>>//CALLDRV_ENUMERATE_SERVER_OPTION
82768>>>>>>>Define CALLDRV_ENUMERATE_SERVER_COUNT               For 0
82768>>>>>>>Define CALLDRV_ENUMERATE_SERVER_SERVER              For 1
82768>>>>>>>
82768>>>>>>>//CALLDRV_DEFAULT_FILE_CASING
82768>>>>>>>Define FILE_CASING_UPPER                            For 0
82768>>>>>>>Define FILE_CASING_LOWER                            For 1
82768>>>>>>>Define FILE_CASING_KEEP                             For 2
82768>>>>>>>
82768>>>>>>>// CALLDRV_GLOBAL_SETTING
82768>>>>>>>Define GLOBAL_SETTING_TABLESPACE_SET                For 0
82768>>>>>>>Define GLOBAL_SETTING_TABLESPACE_GET                For 1
82768>>>>>>>Define GLOBAL_SETTING_INDEX_TABLESPACE_SET          For 2
82768>>>>>>>Define GLOBAL_SETTING_INDEX_TABLESPACE_GET          For 3
82768>>>>>>>
82768>>>>>>>// CALLDRV_RESTRUCTURE_SCRIPT
82768>>>>>>>Define CALLDRV_RESTRUCTURE_SCRIPT_ENABLE            For 0
82768>>>>>>>Define CALLDRV_RESTRUCTURE_SCRIPT_DISABLE           For 1
82768>>>>>>>Define CALLDRV_RESTRUCTURE_SCRIPT_GET_CHUNK_SQL     For 2
82768>>>>>>>Define CALLDRV_RESTRUCTURE_SCRIPT_GET_CHUNK_INT     For 3
82768>>>>>>>
82768>>>>>>>// DF_SQL_RELATION_STATUS attributes
82768>>>>>>>Define FOREIGN_KEY_NONE                             For -1
82768>>>>>>>Define FOREIGN_KEY_CREATE                           For  0
82768>>>>>>>Define FOREIGN_KEY_ENABLE                           For  1
82768>>>>>>>Define FOREIGN_KEY_DISABLE                          For  2
82768>>>>>>>Define FOREIGN_KEY_DROP                             For  3
82768>>>>>>>
82768>>>>>>>// DF_SQL_RELATION_DELETE_REF_ACTION attributes
82768>>>>>>>Define DELETE_REF_NONE                              For 0
82768>>>>>>>Define DELETE_REF_CASCADE                           For 1
82768>>>>>>>Define DELETE_REF_SET_NULL                          For 2
82768>>>>>>>Define DELETE_REF_SET_DEFAULT                       For 3
82768>>>>>>>Define DELETE_REF_RESTRICT                          For 4
82768>>>>>>>
82768>>>>>>>//Embedded SQL Cursor Types
82768>>>>>>>Define CALLDRV_ENUMERATE_CURSOR_TYPE_NONE           For 0
82768>>>>>>>Define CALLDRV_ENUMERATE_CURSOR_TYPE_CLIENT         For 1
82768>>>>>>>Define CALLDRV_ENUMERATE_CURSOR_TYPE_SERVER         For 2
82768>>>>>>>Define CALLDRV_ENUMERATE_CURSOR_TYPE_PARAMETERIZED  For 3
82768>>>>>>>
82768>>>>>>>//Driver Call Direction
82768>>>>>>>Define CALLDRV_VALUE_GET                            For 0
82768>>>>>>>Define CALLDRV_VALUE_SET                            For 1
82768>>>>>>>
82768>>>>>>>//Inverse Key types
82768>>>>>>>Define REGULAR_SEG                                  For -1
82768>>>>>>>Define INVK_CASE_SEG                                For 0
82768>>>>>>>Define INVK_DESC_SEG                                For 1
82768>>>>>>>Define INVK_DESC_AND_CASE_SEG                       For 2
82768>>>>>>>
82768>>>>>>>//DB2 Index Types
82768>>>>>>>Define REG_INDEX                                    For 0
82768>>>>>>>Define REV_INDEX                                    For 1
82768>>>>>>>Define CLUST_INDEX                                  For 2
82768>>>>>>>Define REV_CLUST_INDEX                              For 3
82768>>>>>>>
82768>>>>>>>//Oracle Procedure Arguments type
82768>>>>>>>Define IS_NONE                                      For 0
82768>>>>>>>Define IS_IN                                        For 1
82768>>>>>>>Define IS_OUT                                       For 2
82768>>>>>>>Define IS_IN_OUT                                    For 3
82768>>>>>>>Define IS_RSET                                      For 4
82768>>>>>>>
82768>>>>>>>// SQL_GET_COL Attributes
82768>>>>>>>Define SQL_GET_COL_ATTRIB_SIZE                      For 1
82768>>>>>>>Define SQL_GET_COL_ATTRIB_DECIMALS                  For 2
82768>>>>>>>Define SQL_GET_COL_ATTRIB_LABEL                     For 3
82768>>>>>>>Define SQL_GET_COL_ATTRIB_COLUMN_NAME               For 4
82768>>>>>>>Define SQL_GET_COL_ATTRIB_TABLE_NAME                For 5
82768>>>>>>>Define SQL_GET_COL_ATTRIB_SQLTYPE                   For 6
82768>>>>>>>Define SQL_GET_COL_ATTRIB_NULLABLE                  For 7
82768>>>>>>>Define SQL_GET_COL_ATTRIB_DFTYPE                    For 8
82768>>>>>>>Define SQL_GET_COL_ATTRIB_DATA_LENGTH               For 9
82768>>>>>>>
82768>>>>>>>// MySQL Data Types
82768>>>>>>>Define eMySQL_DECIMAL                               For 0
82768>>>>>>>Define eMySQL_TINY                                  For 1
82768>>>>>>>Define eMySQL_SHORT                                 For 2
82768>>>>>>>Define eMySQL_LONG                                  For 3
82768>>>>>>>Define eMySQL_FLOAT                                 For 4
82768>>>>>>>Define eMySQL_DOUBLE                                For 5
82768>>>>>>>Define eMySQL_NULL                                  For 6
82768>>>>>>>Define eMySQL_TIMESTAMP                             For 7
82768>>>>>>>Define eMySQL_LONGLONG                              For 8
82768>>>>>>>Define eMySQL_INT24                                 For 9
82768>>>>>>>Define eMySQL_DATE                                  For 10
82768>>>>>>>Define eMySQL_TIME                                  For 11
82768>>>>>>>Define eMySQL_DATETIME                              For 12
82768>>>>>>>Define eMySQL_YEAR                                  For 13
82768>>>>>>>Define eMySQL_NEWDATE                               For 14
82768>>>>>>>Define eMySQL_BIT                                   For 16
82768>>>>>>>Define eMySQL_NEWDECIMAL                            For 246
82768>>>>>>>Define eMySQL_ENUM                                  For 247
82768>>>>>>>Define eMySQL_SET                                   For 248
82768>>>>>>>Define eMySQL_TINY_BLOB                             For 249
82768>>>>>>>Define eMySQL_MEDIUM_BLOB                           For 250
82768>>>>>>>Define eMySQL_LONG_BLOB                             For 251
82768>>>>>>>Define eMySQL_BLOB                                  For 252
82768>>>>>>>Define eMySQL_VAR_STRING                            For 253
82768>>>>>>>Define eMySQL_STRING                                For 254
82768>>>>>>>Define eMySQL_TINY_TEXT                             For -249
82768>>>>>>>Define eMySQL_MEDIUM_TEXT                           For -250
82768>>>>>>>Define eMySQL_LONG_TEXT                             For -251
82768>>>>>>>Define eMySQL_TEXT                                  For -252
82768>>>>>>>
82768>>>>>>>// Oracle Data Types
82768>>>>>>>Define eOracle_VARCHAR2                             For   1
82768>>>>>>>Define eOracle_NUMBER                               For   2
82768>>>>>>>Define eOracle_INT                                  For   3
82768>>>>>>>Define eOracle_FLOAT                                For   4
82768>>>>>>>Define eOracle_STRING                               For   5
82768>>>>>>>Define eOracle_LONG                                 For   8
82768>>>>>>>Define eOracle_ROWID                                For  11
82768>>>>>>>Define eOracle_DATE                                 For  12
82768>>>>>>>Define eOracle_RAW                                  For  23
82768>>>>>>>Define eOracle_LONGRAW                              For  24
82768>>>>>>>Define eOracle_CHAR                                 For  96
82768>>>>>>>Define eOracle_MSLABEL                              For 106
82768>>>>>>>Define eOracle_CLOB                                 For 112
82768>>>>>>>Define eOracle_BLOB                                 For 113
82768>>>>>>>Define eOracle_TIMESTAMP                            For 187
82768>>>>>>>Define eOracle_TIMESTAMPTZ                          For 188
82768>>>>>>>Define eOracle_INTERVALYM                           For 189
82768>>>>>>>Define eOracle_INTERVALDS                           For 190
82768>>>>>>>Define eOracle_TIMESTAMPLTZ                         For 232
82768>>>>>>>Define eOracle_NCHAR                                For 286
82768>>>>>>>Define eOracle_NVARCHAR2                            For 287
82768>>>>>>>Define eOracle_NCLOB                                For 288
82768>>>>>>>
82768>>>>>>>// PostgreSQL Data Types
82768>>>>>>>Define ePgSQL_CIRCLE                                For  718
82768>>>>>>>Define ePgSQL_MONEY                                 For  790
82768>>>>>>>Define ePgSQL_BOOL                                  For   16
82768>>>>>>>Define ePgSQL_BYTEA                                 For   17
82768>>>>>>>Define ePgSQL_CHAR                                  For   18
82768>>>>>>>Define ePgSQL_INT2                                  For   21
82768>>>>>>>Define ePgSQL_INT4                                  For   23
82768>>>>>>>Define ePgSQL_REGPROC                               For   24
82768>>>>>>>Define ePgSQL_REGPROCEDURE                          For 2202
82768>>>>>>>Define ePgSQL_REGOPER                               For 2203
82768>>>>>>>Define ePgSQL_REGOPERATOR                           For 2204
82768>>>>>>>Define ePgSQL_REGCLASS                              For 2205
82768>>>>>>>Define ePgSQL_REGTYPE                               For 2206
82768>>>>>>>Define ePgSQL_TEXT                                  For   25
82768>>>>>>>Define ePgSQL_CITEXT                                For  -25
82768>>>>>>>Define ePgSQL_OID                                   For   26
82768>>>>>>>Define ePgSQL_TID                                   For   27
82768>>>>>>>Define ePgSQL_XID                                   For   28
82768>>>>>>>Define ePgSQL_CID                                   For   29
82768>>>>>>>Define ePgSQL_XML                                   For  142
82768>>>>>>>Define ePgSQL_BPCHAR                                For 1042
82768>>>>>>>Define ePgSQL_VARCHAR                               For 1043
82768>>>>>>>Define ePgSQL_INT8                                  For   20
82768>>>>>>>Define ePgSQL_PATH                                  For  602
82768>>>>>>>Define ePgSQL_FLOAT4                                For  700
82768>>>>>>>Define ePgSQL_FLOAT8                                For  701
82768>>>>>>>Define ePgSQL_ABSTIME                               For  702
82768>>>>>>>Define ePgSQL_RELTIME                               For  703
82768>>>>>>>Define ePgSQL_TINTERVAL                             For  704
82768>>>>>>>Define ePgSQL_POINT                                 For  600
82768>>>>>>>Define ePgSQL_LINE                                  For  628
82768>>>>>>>Define ePgSQL_LSEG                                  For  601
82768>>>>>>>Define ePgSQL_BOX                                   For  603
82768>>>>>>>Define ePgSQL_POLYGON                               For  604
82768>>>>>>>Define ePgSQL_ACLITEM                               For 1033
82768>>>>>>>Define ePgSQL_MACADDR                               For  829
82768>>>>>>>Define ePgSQL_INET                                  For  869
82768>>>>>>>Define ePgSQL_CIDR                                  For  650
82768>>>>>>>Define ePgSQL_TIMESTAMP                             For 1114
82768>>>>>>>Define ePgSQL_DATE                                  For 1082
82768>>>>>>>Define ePgSQL_TIME                                  For 1083
82768>>>>>>>Define ePgSQL_TIMESTAMPTZ                           For 1184
82768>>>>>>>Define ePgSQL_INTERVAL                              For 1186
82768>>>>>>>Define ePgSQL_NUMERIC                               For 1700
82768>>>>>>>Define ePgSQL_TIMETZ                                For 1266
82768>>>>>>>Define ePgSQL_BIT                                   For 1560
82768>>>>>>>Define ePgSQL_VARBIT                                For 1562
82768>>>>>>>Define ePgSQL_UUID                                  For 2950
82768>>>>>>>
82768>>>>>>>// SQL Server Data Types
82768>>>>>>>Define eSQLServer_NA                                For    0
82768>>>>>>>Define eSQLServer_CHAR                              For    1
82768>>>>>>>Define eSQLServer_NUMERIC                           For    2
82768>>>>>>>Define eSQLServer_DECIMAL                           For    3
82768>>>>>>>Define eSQLServer_INT                               For    4
82768>>>>>>>Define eSQLServer_SMALLINT                          For    5
82768>>>>>>>Define eSQLServer_FLOAT                             For    6
82768>>>>>>>Define eSQLServer_REAL                              For    7
82768>>>>>>>Define eSQLServer_DOUBLE                            For    8
82768>>>>>>>Define eSQLServer_DATETIME                          For   11
82768>>>>>>>Define eSQLServer_VARCHAR                           For   12
82768>>>>>>>Define eSQLServer_DATE                              For   40
82768>>>>>>>Define eSQLServer_TIME                              For   41
82768>>>>>>>Define eSQLServer_DATETIME2                         For   42
82768>>>>>>>Define eSQLServer_DATETIMEOFFSET                    For   43
82768>>>>>>>Define eSQLServer_SMALLDATETIME                     For   58
82768>>>>>>>Define eSQLServer_TIMESTAMP                         For   93
82768>>>>>>>Define eSQLServer_HIERARCHYID                       For  128
82768>>>>>>>Define eSQLServer_GEOMETRY                          For  129
82768>>>>>>>Define eSQLServer_GEOGRAPHY                         For  130
82768>>>>>>>Define eSQLServer_TEXT                              For   -1
82768>>>>>>>Define eSQLServer_BINARY                            For   -2
82768>>>>>>>Define eSQLServer_VARBINARY                         For   -3
82768>>>>>>>Define eSQLServer_IMAGE                             For   -4
82768>>>>>>>Define eSQLServer_BIGINT                            For   -5
82768>>>>>>>Define eSQLServer_TINYINT                           For   -6
82768>>>>>>>Define eSQLServer_BIT                               For   -7
82768>>>>>>>Define eSQLServer_NCHAR                             For   -8
82768>>>>>>>Define eSQLServer_NVARCHAR                          For   -9
82768>>>>>>>Define eSQLServer_NTEXT                             For  -10
82768>>>>>>>Define eSQLServer_GUID                              For  -11
82768>>>>>>>Define eSQLServer_VARBINARYMAX                      For  -98
82768>>>>>>>Define eSQLServer_VARCHARMAX                        For  -99
82768>>>>>>>Define eSQLServer_NVARCHARMAX                       For -100
82768>>>>>>>Define eSQLServer_SQLVARIANT                        For -150
82768>>>>>>>Define eSQLServer_XML                               For -370
82768>>>>>>>
82768>>>>>>>//=============================================================================
82768>>>>>>>//Error Text
82768>>>>>>>//==========
82768>>>>>>>
82768>>>>>>>//=============================================================================
82768>>>>>>>//Define Self if needed
82768>>>>>>>//=====================
82768>>>>>>>
82768>>>>>>>
82768>>>>>>>//=============================================================================
82768>>>>>>>//Define varibles we need
82768>>>>>>>//=======================
82768>>>>>>>
82768>>>>>>>    Define MertechInc_Variables_Defined
82768>>>>>>>
82768>>>>>>>    Indicator MertechInc_bThereIsBinding
82768>>>>>>>
82768>>>>>>>    Integer MertechInc_FileNumber      //Replaces _SAVEFILENUMBER# and FILENUMBER
82768>>>>>>>    Integer MertechInc_iArg            //Replaces _LLONG#
82768>>>>>>>    Integer MertechInc_iCallBack       //Replaces _CALLBACK#
82768>>>>>>>    Integer MertechInc_iCount          //General loop limit integer
82768>>>>>>>    Integer MertechInc_iDecSep         //Holds the decimal seperator
82768>>>>>>>    Integer MertechInc_iFunction       //Replaces _FID#    ??? check is this is need when tidy is complete
82768>>>>>>>    Integer MertechInc_iLoop           //General loop integer
82768>>>>>>>    Integer Mertech_iMySQLParam        //Replaces _ALL_PAR_POS#
82768>>>>>>>    Integer MertechInc_iParamCount     //Replaces _NPAR#
82768>>>>>>>    Integer MertechInc_iRet            //Replaces _RET#
82768>>>>>>>    Integer MertechInc_iSaveCount      //Replaces _NPOS#
82768>>>>>>>    Integer MertechInc_iWork           //General work integer
82768>>>>>>>    Integer MertechInc_iWork2
82768>>>>>>>
82768>>>>>>>    String MertechInc_Blank            //Replaces _BLANK#
82768>>>>>>>    String MertechInc_DriverName       //Replaces _DRIVERNAME#
82768>>>>>>>    String MertechInc_sArg1 255        //Replaces _ARG1#
82768>>>>>>>    String MertechInc_sArg2 255        //Replaces _ARG2#
82768>>>>>>>    String MertechInc_sWork 255        //General work string
82768>>>>>>>
82768>>>>>>>    String MertechInc_CurrentDriver    //Keep the current driver name
82768>>>>>>>    //Global string are created pre-filled with spaces. We need an empty string
82768>>>>>>>    Move "" to MertechInc_Blank
82769>>>>>>>    Move "" to MertechInc_CurrentDriver
82770>>>>>>>
82770>>>>>>>
82770>>>>>>>//=============================================================================
82770>>>>>>>//Use Obsolete Code
82770>>>>>>>//=================
82770>>>>>>>
82770>>>>>>>
82770>>>>>>>
82770>>>>>>>//=============================================================================
82770>>>>>>>//Comment Block Template
82770>>>>>>>//======================
82770>>>>>>>
82770>>>>>>>/// @Name {Name of the command for indexing} (used for documentation)
82770>>>>>>>/// @Description {Short Command Description} (used for documentation)
82770>>>>>>>///     The description can be multiple lines, and contain HTML tags.
82770>>>>>>>///     The other tokens will have HTML encoded so we can show stuff
82770>>>>>>>///     like <param1> properly. A blank line will automatically be
82770>>>>>>>///         translated into a paragraph break in the documentation, so
82770>>>>>>>///     no need for <br> or <p> tags.
82770>>>>>>>///
82770>>>>>>>/// @Assumptions {Assumptions made in order for the command to work}
82770>>>>>>>/// @Status {Obsolete, Internal, or Public} (used for documentation)
82770>>>>>>>/// @Drivers {DB2Flex, MySQLFlex, ORAFlex, PgFlex, SQLFlex or All} (used for documentation)
82770>>>>>>>/// @VersionNote {Date and author of the last revision}
82770>>>>>>>/// @See {list of related commands}
82770>>>>>>>///
82770>>>>>>>/// @Syntax {Syntax of use} (used for documentation)
82770>>>>>>>/// @Param {Each parameter with a brief description} (used for documentation)
82770>>>>>>>/// @DBMS {List of supported databases}
82770>>>>>>>/// @DataFlex {List of supported DataFlex versions}
82770>>>>>>>/// @Usage {Different uses command can have multiple syntaxes} (used for documentation)
82770>>>>>>>///
82770>>>>>>>/// @Example {An example of the command being used} (used for documentation)
82770>>>>>>>
82770>>>>>>>//=============================================================================
82770>>>>>>>/// @Name        DO_GETFILENUMBER_DRIVERNAME
82770>>>>>>>/// @Description Retrieves the current driver name and or the file number
82770>>>>>>>/// that will be used by the macro commands.
82770>>>>>>>///
82770>>>>>>>/// @Assumptions
82770>>>>>>>/// @Status      Internal Use Only
82770>>>>>>>/// @Drivers     All
82770>>>>>>>/// @VersionNote Last Revised: 2009-07-14 By Ian Smith
82770>>>>>>>/// @See
82770>>>>>>>
82770>>>>>>>//Most commands use DO_GETFILENUMBER_DRIVERNAME so this code was being duplicated
82770>>>>>>>//all the time. It has been moved to this method to remove that duplication.
82770>>>>>>>Procedure MertechInc_Get_Driver_name Global
82772>>>>>>>    //If we have a file number get its driver, else find first loaded Mertech driver
82772>>>>>>>    If MertechInc_FileNumber GT 0 ;        Get_Attribute DF_FILE_DRIVER of MertechInc_FileNumber to MertechInc_DriverName
82777>>>>>>>    Else Begin
82778>>>>>>>        If (MertechInc_CurrentDriver > "") Move MertechInc_CurrentDriver to MertechInc_DriverName
82781>>>>>>>        Else Begin
82782>>>>>>>            Get_Attribute DF_NUMBER_DRIVERS to MertechInc_iCount
82785>>>>>>>            For MertechInc_iLoop from 1 to MertechInc_iCount
82791>>>>>>>>
82791>>>>>>>                Get_Attribute DF_DRIVER_NAME of MertechInc_iLoop to MertechInc_DriverName
82794>>>>>>>                Move (UPPERCASE(MertechInc_DriverName)) to MertechInc_DriverName
82795>>>>>>>                If (MertechInc_DriverName EQ ORAFLEX  or MertechInc_DriverName EQ SQLFLEX or MertechInc_DriverName EQ MDSDB2 or ;                    MertechInc_DriverName EQ MDSPgSQL or MertechInc_DriverName EQ MDSMySQL) Move MertechInc_iCount to MertechInc_iLoop
82798>>>>>>>                Else Move "" to MertechInc_DriverName
82800>>>>>>>            Loop
82801>>>>>>>>
82801>>>>>>>        End
82801>>>>>>>>
82801>>>>>>>    End
82801>>>>>>>>
82801>>>>>>>
82801>>>>>>>    //Ensure that we return a valid Mertech driver.
82801>>>>>>>    If (MertechInc_DriverName NE ORAFLEX  and ;        MertechInc_DriverName NE SQLFLEX  and ;        MertechInc_DriverName NE MDSDB2   and ;        MertechInc_DriverName NE MDSPgSQL and ;        MertechInc_DriverName NE MDSMySQL     ) ;        Begin
82803>>>>>>>
82803>>>>>>>        //Report invalid driver
82803>>>>>>>//        Error 25100 ("Invalid Driver - file" * String(MertechInc_FileNumber))
82803>>>>>>>//        Error 25100 ("Mertech.inc - Not a Mertech driver (file number " * String(MertechInc_FileNumber) * ")")
82803>>>>>>>        Error 25100 ("Mertech.inc - Not a Mertech driver. File" * String(MertechInc_FileNumber) * "Driver" * Trim(MertechInc_DriverName) )
82804>>>>>>>>
82804>>>>>>>
82804>>>>>>>        //Set MertechInc_FileNumber to MertechInc_Invalid_Driver so that the commands can
82804>>>>>>>        //determine if the driver is valid. MertechInc_FileNumber is use instead of
82804>>>>>>>        //MertechInc_DriverName as integer conparisons are quicker than string conparisons
82804>>>>>>>        Move MertechInc_Invalid_Driver to MertechInc_FileNumber
82805>>>>>>>    End
82805>>>>>>>>
82805>>>>>>>End_Procedure
82806>>>>>>>
82806>>>>>>>//=============================================================================
82806>>>>>>>/// @Name        MertechInc_Pre_Size_String
82806>>>>>>>/// @Description Returns a string full of spaces.
82806>>>>>>>///
82806>>>>>>>/// @Assumptions
82806>>>>>>>/// @Status      Internal
82806>>>>>>>/// @Drivers     n/a
82806>>>>>>>/// @VersionNote Last Revised: 2009-12-02 By Gandalf Hernandez
82806>>>>>>>/// @See
82806>>>>>>>Function MertechInc_Pre_Size_String Global Integer iSize Returns String
82808>>>>>>>   String sWork
82808>>>>>>>   Integer iBlocks iRemainder
82808>>>>>>>
82808>>>>>>>   If (iSize <= 1) Begin
82810>>>>>>>      // marcelo 06/28/2000 implemented logic to avoid VDF 7 crashing problems
82810>>>>>>>          If FMAC_VERSION eq 7 Move 1000 to iSize
82813>>>>>>>          Else Move 16384 to iSize
82815>>>>>>>   End
82815>>>>>>>>
82815>>>>>>>
82815>>>>>>>   // Build the string in blocks of 32, to speed things up
82815>>>>>>>   // If the string is less than 32 bytes, just fill it up regularly
82815>>>>>>>   Move (iSize / 32) to iBlocks
82816>>>>>>>   Move (Mod(iSize, 32)) to iRemainder
82817>>>>>>>
82817>>>>>>>   If (iBlocks > 0) Begin
82819>>>>>>>      Move (Repeat("                                ", iBlocks)) to sWork
82820>>>>>>>      Move (Append (sWork, (Repeat(" ", iRemainder)))) to sWork
82821>>>>>>>   End
82821>>>>>>>>
82821>>>>>>>   Else Move (Repeat(" ", iSize)) to sWork
82823>>>>>>>
82823>>>>>>>   Function_Return sWork
82824>>>>>>>End_Function
82825>>>>>>>
82825>>>>>>>//=============================================================================
82825>>>>>>>/// @Name        MertechInc_Set_DecSep
82825>>>>>>>/// @Description Saves the current decimal separator and sets the decimal
82825>>>>>>>/// separator to '.'.
82825>>>>>>>///
82825>>>>>>>/// @Assumptions
82825>>>>>>>/// @Status      Internal
82825>>>>>>>/// @Drivers     n/a
82825>>>>>>>/// @VersionNote Last Revised: 2009-08-17 By Ian Smith
82825>>>>>>>Procedure MertechInc_Set_DecSep Global
82827>>>>>>>    Get_Attribute DF_DECIMAL_SEPARATOR to MertechInc_iDecSep
82830>>>>>>>    If MertechInc_iDecSep Ne 46 Set_Attribute DF_DECIMAL_SEPARATOR to 46 // (.) WILL BE DECIMAL SEPARATOR
82835>>>>>>>End_Procedure
82836>>>>>>>
82836>>>>>>>//=============================================================================
82836>>>>>>>/// @Name        MertechInc_Reset_DecSep
82836>>>>>>>/// @Description Sets the decimal separator to the saved value.
82836>>>>>>>///
82836>>>>>>>/// @Status      Internal
82836>>>>>>>/// @Drivers     n/a
82836>>>>>>>/// @VersionNote Last Revised: 2009-08-17 By Ian Smith
82836>>>>>>>///
82836>>>>>>>Procedure MertechInc_Reset_DecSep Global
82838>>>>>>>    If MertechInc_iDecSep Ne 46 Set_Attribute DF_DECIMAL_SEPARATOR to MertechInc_iDecSep
82843>>>>>>>End_Procedure
82844>>>>>>>
82844>>>>>>>//=============================================================================
82844>>>>>>>/// @Name        FETCH_FIELD
82844>>>>>>>/// @Description Selects or de-selects the fields to be fetched during the
82844>>>>>>>/// next FIND (query).
82844>>>>>>>///
82844>>>>>>>/// @Status      Internal
82844>>>>>>>/// @Drivers     All
82844>>>>>>>/// @VersionNote Last Revised: 2009-07-16 By Ian Smith
82844>>>>>>>///
82844>>>>>>>/// @Syntax FETCH_FIELD <FileNum> <FieldStart> THRU <FieldEnd> TO DF_FETCH_TRUE
82844>>>>>>>/// @Param  FileNum    is the File Number
82844>>>>>>>/// @Param  FieldStart is the Field Name or Number that will start the selection range
82844>>>>>>>/// @Param  FieldEnd   is the Field Name or Number that will finish the selection range
82844>>>>>>>///
82844>>>>>>>/// @Syntax FETCH_FIELD <FileNum> <Field1> TO DF_FETCH_TRUE
82844>>>>>>>/// @Param  FileNum  is the File Number
82844>>>>>>>/// @Param  Field1 Fields Name or Number to be selected
82844>>>>>>>///
82844>>>>>>>
82844>>>>>>>//=============================================================================
82844>>>>>>>/// @Name        SQL_TEXT_MESSAGE
82844>>>>>>>/// @Description Use this command to manually insert a string into a trace
82844>>>>>>>/// file. This can be useful for readability within the trace file to log
82844>>>>>>>/// what is actually happening at certain points.
82844>>>>>>>///
82844>>>>>>>/// @Assumptions The text string is less than 80 characters long.
82844>>>>>>>/// @Status      Public
82844>>>>>>>/// @Drivers     All
82844>>>>>>>/// @VersionNote Last Revised: 20013-08-19 by Aaron Gulack
82844>>>>>>>/// @See         ENABLE_TRACE_ON DISABLE_TRACE_ON
82844>>>>>>>///
82844>>>>>>>/// @Syntax SQL_TEXT_MESSAGE {variable}
82844>>>>>>>/// @Param  {variable}          The string to insert into the trace file.
82844>>>>>>>///
82844>>>>>>>/// @Example
82844>>>>>>>/// Login "localhost" "mds" "mertech" "ora_drv"
82844>>>>>>>///
82844>>>>>>>/// ENABLE_TRACE_ON to "c:\trace.txt" DEBUG_LEVEL
82844>>>>>>>/// open Customer
82844>>>>>>>/// SQL_TEXT_MESSAGE "The table has been opened"
82844>>>>>>>
82844>>>>>>>//=============================================================================
82844>>>>>>>/// @Name       SELECT_COLUMNS_FIND
82844>>>>>>>/// @Description This command is used to fetch only a certain number of fields
82844>>>>>>>/// while doing a "find". When specifying the field number to start from and
82844>>>>>>>/// field number to end on, the find will only fetch the given fields from the
82844>>>>>>>/// record. It is important to always use this command after first deselecting
82844>>>>>>>/// all columns i.e. setting RESET_FETCH_FIELDS to DF_FETCH_FALSE. Also, after
82844>>>>>>>/// using this command, all columns need to be reselected i.e. setting
82844>>>>>>>/// RESET_FETCH_FIELDS to DF_FETCH_TRUE. Note that fields used as a part the
82844>>>>>>>/// index segment associated with the find will always be fetched regardless.
82844>>>>>>>///
82844>>>>>>>/// @Assumptions
82844>>>>>>>/// @Status      Public
82844>>>>>>>/// @Drivers     All
82844>>>>>>>/// @VersionNote Last Revised: 20014-04-30 by Marcello Yo
82844>>>>>>>/// @See         RESET_FETCH_FIELDS DISABLE_SELECT_COLUMNS_ERRORS
82844>>>>>>>///
82844>>>>>>>/// @Syntax SELECT_COLUMNS_FIND {FileNumber} {fieldStart} THRU {fieldEnd}
82844>>>>>>>/// @Param  FileNumber          The number of the file
82844>>>>>>>/// @Param  fieldStart          The field number to start the fetch from
82844>>>>>>>/// @Param  FieldEnd            The field number to end the fetch at
82844>>>>>>>///
82844>>>>>>>/// @Example
82844>>>>>>>/// Open Customer
82844>>>>>>>/// RESET_FETCH_FIELDS  CUSTOMER DF_FETCH_FALSE
82844>>>>>>>/// SELECT_COLUMNS_FIND CUSTOMER CUSTOMER_NUMBER NAME
82844>>>>>>>/// DISABLE_SELECT_COLUMNS_ERRORS DISABLED
82844>>>>>>>///
82844>>>>>>>/// Clear Customer
82844>>>>>>>/// Repeat
82844>>>>>>>///    Find Gt Customer by Index.1
82844>>>>>>>///    If (Found) Showln Customer.Customer_Number '-' Customer.Name
82844>>>>>>>/// Until (Not(Found))
82844>>>>>>>///
82844>>>>>>>/// RESET_FETCH_FIELDS Customer DF_FETCH_TRUE
82844>>>>>>>
82844>>>>>>>
82844>>>>>>>//=============================================================================
82844>>>>>>>/// @Name        RESET_FETCH_FIELDS
82844>>>>>>>/// @Description This command is used to specify whether to retrieve all columns
82844>>>>>>>/// or no columns when performing a find. It is usually used with the command
82844>>>>>>>/// SELECT_COLUMNS_FIND to reset the column fetching. This command can either be
82844>>>>>>>/// set to DF_FETCH_TRUE, which will fetch all columns or set to DF_FETCH_FALSE,
82844>>>>>>>/// which will fetch no columns.
82844>>>>>>>/// @Assumptions
82844>>>>>>>/// @Status      Public
82844>>>>>>>/// @Drivers     All
82844>>>>>>>/// @VersionNote Last Revised: 2014-04-30 by Marcello Yo
82844>>>>>>>/// @See         SELECT_COLUMNS_FIND DISABLE_SELECT_COLUMNS_ERRORS
82844>>>>>>>///
82844>>>>>>>/// @Syntax RESET_FETCH_FIELDS {FileNumber} {DF_FETCH_TRUE/DF_FETCH_FALSE}
82844>>>>>>>/// @Param  FileNumber                  The number of the file
82844>>>>>>>/// @Param  DF_FETCH_TRUE               fetch all columns
82844>>>>>>>/// @Param  DF_FETCH_FALSE              fetch no columns
82844>>>>>>>///
82844>>>>>>>/// @Example
82844>>>>>>>/// Open Customer
82844>>>>>>>/// RESET_FETCH_FIELDS  CUSTOMER DF_FETCH_FALSE
82844>>>>>>>/// SELECT_COLUMNS_FIND CUSTOMER CUSTOMER_NUMBER NAME
82844>>>>>>>/// DISABLE_SELECT_COLUMNS_ERRORS DISABLED
82844>>>>>>>///
82844>>>>>>>/// Clear Customer
82844>>>>>>>/// Repeat
82844>>>>>>>///    Find Gt Customer by Index.1
82844>>>>>>>///    If (Found) Showln Customer.Customer_Number '-' Customer.Name
82844>>>>>>>/// Until (Not(Found))
82844>>>>>>>///
82844>>>>>>>/// RESET_FETCH_FIELDS Customer DF_FETCH_TRUE
82844>>>>>>>
82844>>>>>>>//=============================================================================
82844>>>>>>>/// @Name        SQL_FOR_ONEROW
82844>>>>>>>/// @Description This command will instruct the driver to fetch one row
82844>>>>>>>/// per query
82844>>>>>>>///
82844>>>>>>>/// @Assumptions
82844>>>>>>>/// @Status      Deprecated
82844>>>>>>>/// @Drivers     All
82844>>>>>>>/// @VersionNote Last Revised: 2013-08-19 by Aaron Gulack
82844>>>>>>>/// @See
82844>>>>>>>///
82844>>>>>>>/// @Syntax SQL_FOR_ONEROW {FileNumber}
82844>>>>>>>/// @Param  FileNumber          The number of the file
82844>>>>>>>/// @Example
82844>>>>>>>///     open Customer
82844>>>>>>>///     SQL_FOR_ONEROW Customer.File_Number
82844>>>>>>>///     Repeat
82844>>>>>>>///             find gt Customer by Recnum
82844>>>>>>>///         If (Found) Begin
82844>>>>>>>///             showln "Sales name is " Customer.FirstName
82844>>>>>>>///         end
82844>>>>>>>///     until (Customer.ID = 10)
82844>>>>>>>
82844>>>>>>>//=============================================================================
82844>>>>>>>/// @Name        SQL_REFRESH_CACHE
82844>>>>>>>/// @Description For optimization during record retrieval, a set number of
82844>>>>>>>/// records are stored in a local cache. This command forces a refresh, by
82844>>>>>>>/// making the next find retrieve the record from the database instead of
82844>>>>>>>/// the cache.
82844>>>>>>>///
82844>>>>>>>/// @Assumptions
82844>>>>>>>/// @Status      Public
82844>>>>>>>/// @Drivers     All
82844>>>>>>>/// @VersionNote Last Revised: 2013-08-19 by Aaron Gulack
82844>>>>>>>/// @See
82844>>>>>>>///
82844>>>>>>>/// @Syntax SQL_REFRESH_CACHE OF {FileNumber}
82844>>>>>>>/// @Param  FileNumber          The number of the file
82844>>>>>>>/// @Example
82844>>>>>>>/// Open Customer
82844>>>>>>>///
82844>>>>>>>/// Find gt Customer by Index.1
82844>>>>>>>/// While (Found) Begin
82844>>>>>>>///     showln "Customer name is " CUSTOMER.CUSTOMER
82844>>>>>>>/// Loop
82844>>>>>>>///
82844>>>>>>>/// SQL_REFRESH_CACHE of CUSTOMER
82844>>>>>>>
82844>>>>>>>//=============================================================================
82844>>>>>>>/// @Name        SQL_FOR_SET
82844>>>>>>>/// @Description Use this command during LT or GT finds to only fetch a set
82844>>>>>>>/// number of rows. An option is also available for this command to disable
82844>>>>>>>/// the local cash by passing NOCACHE at the end of the command call. Note
82844>>>>>>>/// that if the rowcount is set low, too many round-trips to the server may
82844>>>>>>>/// result, effecting performance significantly. Also, if the rowcount is set
82844>>>>>>>/// too high a large number of records can be pre-fetched and end up not being
82844>>>>>>>/// used by the application. Because of this, the default of 10 rows and a cache
82844>>>>>>>/// will be adequate for most situations.
82844>>>>>>>///
82844>>>>>>>/// @Assumptions
82844>>>>>>>/// @Status      Public
82844>>>>>>>/// @Drivers     All
82844>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
82844>>>>>>>/// @See
82844>>>>>>>///
82844>>>>>>>/// @Syntax SQL_FOR_SET {FileNumber} MAXROWS {variable} {CACHE/NOCACHE}
82844>>>>>>>/// @Param  FileNumber          The number of the file
82844>>>>>>>/// @Param  variable            The maximum number of rows to retrieve
82844>>>>>>>/// @Param  CACHE               fetched rows will be kept at the local cache
82844>>>>>>>/// @Param  NOCACHE             fetched rows will not be kept at the local cache
82844>>>>>>>/// @Example
82844>>>>>>>/// Open Customer
82844>>>>>>>///
82844>>>>>>>/// SQL_FOR_SET Customer MAXROWS 15 CACHE
82844>>>>>>>/// find gt Customer by Index.1
82844>>>>>>>
82844>>>>>>>//=============================================================================
82844>>>>>>>/// @Name        SQL_SET
82844>>>>>>>/// @Description Initializes and sets an initial statement for embedded
82844>>>>>>>/// sql execution.
82844>>>>>>>///
82844>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
82844>>>>>>>/// @Status      Deprecated
82844>>>>>>>/// @Drivers     All
82844>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
82844>>>>>>>/// @See         SQL_SET_STMT
82844>>>>>>>///
82844>>>>>>>/// @Syntax SQL_SET {FileNumber}
82844>>>>>>>/// @Param  FileNumber          The number of the file
82844>>>>>>>
82844>>>>>>>Procedure MertechInc_SQL_SET Global String sStatement
82846>>>>>>>    Call_Driver 0 MertechInc_DriverName Function 1 CALLBACK 0 PASSING MertechInc_Blank sStatement 0 RESULT MertechInc_iRet
82851>>>>>>>End_Procedure
82852>>>>>>>
82852>>>>>>>//=============================================================================
82852>>>>>>>/// @Name        SQL_APPEND
82852>>>>>>>/// @Description Appends a string value to the current embedded sql statement
82852>>>>>>>/// already set.
82852>>>>>>>///
82852>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
82852>>>>>>>/// @Status      Deprecated
82852>>>>>>>/// @Drivers     All
82852>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
82852>>>>>>>/// @See                 SQL_APPEND_STMT
82852>>>>>>>
82852>>>>>>>Procedure MertechInc_SQL_APPEND Global String sStatement
82854>>>>>>>    Call_Driver 0 MertechInc_DriverName Function 2 CALLBACK 0 PASSING MertechInc_Blank sStatement 0 RESULT MertechInc_iRet
82859>>>>>>>End_Procedure
82860>>>>>>>
82860>>>>>>>//=============================================================================
82860>>>>>>>/// @Name        SQL_EXECUTE
82860>>>>>>>/// @Description Executes the current embedded SQL statement set and commits
82860>>>>>>>/// finishing any pending transaction.
82860>>>>>>>///
82860>>>>>>>/// @Assumptions
82860>>>>>>>/// @Status      Deprecated
82860>>>>>>>/// @Drivers     All
82860>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
82860>>>>>>>/// @See                 SQL_EXECUTE_STMT
82860>>>>>>>
82860>>>>>>>//=============================================================================
82860>>>>>>>/// @Name        LOCK_TABLE
82860>>>>>>>/// @Description Locks a table. This is equivalent to locking a DAT file.
82860>>>>>>>///
82860>>>>>>>/// @Assumptions
82860>>>>>>>/// @Status      Deprecated
82860>>>>>>>/// @Drivers     DB2Flex, and ORAFlex 3.x
82860>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
82860>>>>>>>/// @See
82860>>>>>>>///
82860>>>>>>>/// @Syntax LOCK_TABLE {FileName} {FileName1} {FileName2} {FileName3}...
82860>>>>>>>/// @Param  FileName            The name of file to be locked. Can be more than one
82860>>>>>>>
82860>>>>>>>//=============================================================================
82860>>>>>>>/// @Name        SQL_CHECK_TABLE
82860>>>>>>>/// @Description Use this command to verify that a given table exists on the
82860>>>>>>>/// SQL backend. This command takes three arguments, a string containing the
82860>>>>>>>/// name of the database, a string containing the name of the user and finally
82860>>>>>>>/// a string containing the name of the table being checked. If the table exists,
82860>>>>>>>/// the program proceeds normally. If the table does not exist then the flag
82860>>>>>>>/// "finderr" is set to true. Note that in order to handle the error a check must
82860>>>>>>>/// be done on the "finderr" variable.
82860>>>>>>>///
82860>>>>>>>/// @Assumptions All three parameters are less than 256 characters long.
82860>>>>>>>/// @Status      Public
82860>>>>>>>/// @Drivers     All
82860>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
82860>>>>>>>/// @See
82860>>>>>>>///
82860>>>>>>>/// @Syntax SQL_CHECK_TABLE {database} {username} {table}
82860>>>>>>>/// @Param  database            Name of the database
82860>>>>>>>/// @Param  username            Name of the user
82860>>>>>>>/// @Param  table                       Name of the table being checked
82860>>>>>>>///
82860>>>>>>>/// @Example
82860>>>>>>>/// SQL_CHECK_TABLE "testDB" "user" "Customer"
82860>>>>>>>/// If (finderr) Begin
82860>>>>>>>///     Showln "This table does not exist"
82860>>>>>>>/// End
82860>>>>>>>
82860>>>>>>>//=============================================================================
82860>>>>>>>/// @Name        SET_SQL_CONSTRAINT
82860>>>>>>>/// @Description This command allows you to put an additional constraint on
82860>>>>>>>/// your finds, moving filtering to the SQL backend. Using this command can
82860>>>>>>>/// result in significantly improved performance, since the server network traffic
82860>>>>>>>/// reduced. Note that the SQL statement passed for this command is added onto
82860>>>>>>>/// the predefined Database SQL statement so treat it as such. Because of this,
82860>>>>>>>/// it will almost always begin with "AND" followed by the desired constraint.
82860>>>>>>>///
82860>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
82860>>>>>>>/// @Status      Public
82860>>>>>>>/// @Drivers     All
82860>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
82860>>>>>>>/// @See         SQL_CONSTRAINT GET_SQL_CONSTRAINT DF_FIELD_PROGRAMMATIC_DEFAULT
82860>>>>>>>///
82860>>>>>>>/// @Syntax SET_SQL_CONSTRAINT of {file} to {variable}
82860>>>>>>>/// @Param  file                        Name or Number of the file.
82860>>>>>>>/// @Param  variable            A SQL expression that constrains the data
82860>>>>>>>///
82860>>>>>>>/// @Example
82860>>>>>>>/// Open Customer
82860>>>>>>>///
82860>>>>>>>/// SET_SQL_CONSTRAINT of 1 to (SFormat('AND "%1"."%2" = ' + "'%3'", "Customer", "Status", "Active"))
82860>>>>>>>///
82860>>>>>>>/// For_All Customer by Index.1 do
82860>>>>>>>///     Showln Customer.FirstName
82860>>>>>>>/// End_For_All
82860>>>>>>>
82860>>>>>>>Procedure MertechInc_SET_SQL_CONSTRAINT Global Integer iFunction String sConstraint
82862>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function iFunction CALLBACK 0 PASSING sConstraint MertechInc_Blank 0 RESULT MertechInc_iRet
82867>>>>>>>End_Procedure
82868>>>>>>>
82868>>>>>>>Procedure MertechInc_SET_SQL_CONSTRAINT_PROGRAMMATIC Global Integer iFunction
82870>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function iFunction CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank 4 RESULT MertechInc_iRet
82875>>>>>>>End_Procedure
82876>>>>>>>
82876>>>>>>>//=============================================================================
82876>>>>>>>/// @Name        GET_SQL_CONSTRAINT
82876>>>>>>>/// @Description This command returns the current SQL constraint for the given
82876>>>>>>>/// table.  If there is no current constraint, then a blank string is returned.
82876>>>>>>>///
82876>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
82876>>>>>>>/// @Status      Public
82876>>>>>>>/// @Drivers     All
82876>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
82876>>>>>>>/// @See         SQL_CONSTRAINT SET_SQL_CONSTRAINT
82876>>>>>>>///
82876>>>>>>>/// @Syntax GET_SQL_CONSTRAINT of {File} to {variable}
82876>>>>>>>/// @Param  File                        Name or number of the file
82876>>>>>>>/// @Param  variable            The string containing the constraining SQL expression
82876>>>>>>>///
82876>>>>>>>/// @Example
82876>>>>>>>/// Open Customer
82876>>>>>>>///
82876>>>>>>>/// String sCon
82876>>>>>>>///
82876>>>>>>>/// SET_SQL_CONSTRAINT of Customer to (SFormat('AND "%1"."%2" = ' + "'%3'", "Customer", "Status", "Active"))
82876>>>>>>>/// GET_SQL_CONSTRAINT of Customer to sCon
82876>>>>>>>///
82876>>>>>>>/// For_All Customer by Index.1 do
82876>>>>>>>///     Showln Customer.FirstName
82876>>>>>>>///     Showln sCon
82876>>>>>>>/// End_For_All
82876>>>>>>>
82876>>>>>>>Function MertechInc_GET_SQL_CONSTRAINT Global Integer iFunction Returns String
82878>>>>>>>    String sConstraint
82878>>>>>>>    Get MertechInc_Pre_Size_String 0 to sConstraint
82879>>>>>>>
82879>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function iFunction CALLBACK 0 PASSING sConstraint MertechInc_Blank 3 RESULT MertechInc_iRet
82884>>>>>>>    Function_Return sConstraint
82885>>>>>>>End_Function
82886>>>>>>>
82886>>>>>>>//=============================================================================
82886>>>>>>>/// @Name        SQL_CONSTRAINT
82886>>>>>>>/// @Description This command is used to toggle on or off the current SQL
82886>>>>>>>/// constraint that is set for a table. To deactivate the current constraint,
82886>>>>>>>/// pass the constant DEACTIVATE to this command. to reactivate the constraint,
82886>>>>>>>/// pass ACTIVATE to this command.
82886>>>>>>>///
82886>>>>>>>/// @Status      Public
82886>>>>>>>/// @Drivers     All
82886>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
82886>>>>>>>/// @See         SET_SQL_CONSTRAINT GET_SQL_CONSTRAINT
82886>>>>>>>///
82886>>>>>>>/// @Syntax SQL_CONSTRAINT of {File} to {Activate|Deactivate}
82886>>>>>>>/// @Param  File                        Name or Number of the file
82886>>>>>>>/// @Param  Activate            Activates the constraint
82886>>>>>>>/// @Param  Deactivate          Deactivates the constraint
82886>>>>>>>///
82886>>>>>>>/// @Example
82886>>>>>>>/// Open Customer
82886>>>>>>>///
82886>>>>>>>/// SET_SQL_CONSTRAINT of Customer to (SFormat('AND "%1"."%2" = ' + "'%3'", "Customer", "FirstName", "Aaron"))
82886>>>>>>>/// SQL_CONSTRAINT of Customer to Deactivate
82886>>>>>>>///
82886>>>>>>>/// For_All Customer by Index.1 do
82886>>>>>>>///     Showln Customer.FirstName
82886>>>>>>>/// End_For_All
82886>>>>>>>
82886>>>>>>>//=============================================================================
82886>>>>>>>/// @Name        CREATE_TD_FILE
82886>>>>>>>/// @Description A .TD file is created when the attribute is set to True.
82886>>>>>>>///
82886>>>>>>>/// @Assumptions
82886>>>>>>>/// @Status      Deprecated
82886>>>>>>>/// @Drivers     All
82886>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
82886>>>>>>>/// @See
82886>>>>>>>///
82886>>>>>>>/// @Syntax CREATE_TD_FILE {variable}
82886>>>>>>>/// @Param  variable            True to create the .TD file, false doesn't create it.
82886>>>>>>>
82886>>>>>>>//=============================================================================
82886>>>>>>>/// @Name        OPEN_INT
82886>>>>>>>/// @Description This command is used to replace the OPEN command in DataFlex.
82886>>>>>>>/// It can be useful when accessing tables that are not in the current filelist.
82886>>>>>>>/// To access these tables, the INT and FD files must be in the directory. From
82886>>>>>>>/// there, all that is needed is to open the table using this command under an
82886>>>>>>>/// alias name. If the command is executed successfully then the table can be
82886>>>>>>>/// queried normally as if it were a standard table. Note that if the desired
82886>>>>>>>/// table is already in the filelist or doesn't have an INT file then this
82886>>>>>>>/// command will act as a normal open command.
82886>>>>>>>///
82886>>>>>>>/// @Assumptions
82886>>>>>>>/// @Status      Public
82886>>>>>>>/// @Drivers     All
82886>>>>>>>/// @VersionNote Last Revised: 2013-08-21 by Aaron Gulack
82886>>>>>>>/// @See
82886>>>>>>>///
82886>>>>>>>/// @Syntax OPEN_INT {variable} as {aliasName}
82886>>>>>>>/// @Param  variable            The name of the int file without the extension.
82886>>>>>>>/// @Param  aliasName           The alias name being used to query this table.
82886>>>>>>>/// @Example
82886>>>>>>>/// OPEN_INT "customer" as Customer
82886>>>>>>>///
82886>>>>>>>/// For_All Customer by Index.1 do
82886>>>>>>>///     Showln Customer.FirstName
82886>>>>>>>/// End_For_All
82886>>>>>>>
82886>>>>>>>//=============================================================================
82886>>>>>>>/// @Name        SET_OPEN_MODE
82886>>>>>>>/// @Description This command is used to enable an option known as "Lazy Open
82886>>>>>>>/// Mode". When turned on the table's metadata i.e. table, columns, index
82886>>>>>>>/// descriptions, is deferred until a field is accessed, even if a OPEN has
82886>>>>>>>/// already been done. This can significantly improve an application's initial
82886>>>>>>>/// performance, especially when a large number of files are opened when the
82886>>>>>>>/// program is launched. By default, tables are set to open normally, but by
82886>>>>>>>/// passing the constant LAZY_MODE to this command, it can be altered to use
82886>>>>>>>/// this mode. Note that when this mode is activated, it effects all tables
82886>>>>>>>/// that are opened. To deactivate this feature, pass the constant "DEFAULT"
82886>>>>>>>/// to this command at any time. This is the preferred method to activate or
82886>>>>>>>/// deactive this feature but it can also be set globally in the .INI file.
82886>>>>>>>///
82886>>>>>>>/// Default Value: DEFAULT (Off)
82886>>>>>>>///
82886>>>>>>>/// @Assumptions
82886>>>>>>>/// @Status      Public
82886>>>>>>>/// @Drivers     All
82886>>>>>>>/// @VersionNote Last Revised: 2013-08-21 by Aaron Gulack
82886>>>>>>>/// @See
82886>>>>>>>///
82886>>>>>>>/// @Syntax SET_OPEN_MODE to {DEFAULT/LAZY_MODE}
82886>>>>>>>/// @Param  DEFAULT                     Used to turn of the lazy mode feature.
82886>>>>>>>/// @Param  LAZY_MODE           Turns on the lazy mode feature
82886>>>>>>>///
82886>>>>>>>/// @Example
82886>>>>>>>/// SET_OPEN_MODE TO LAZY_MODE
82886>>>>>>>/// Open "customer.int" as Customer
82886>>>>>>>/// ...
82886>>>>>>>/// ...
82886>>>>>>>/// Find gt Customer by Index.1
82886>>>>>>>
82886>>>>>>>//=============================================================================
82886>>>>>>>/// @Name        SQL_SET_STMT
82886>>>>>>>/// @Description Use this command to set an SQL statement to be executed on the
82886>>>>>>>/// desired table. The string passed to this command must be a valid SQL
82886>>>>>>>/// expression and must be on a table that has already been opened. Note that
82886>>>>>>>/// when using this command, the SQL_PREPARE_STMT and SQL_EXECUTE_STMT must be
82886>>>>>>>/// used in addition to carry out the expression. The option to pass the file
82886>>>>>>>/// name as an extra parameter is used in cases where the data needs to be
82886>>>>>>>/// fetched directly into the record buffer of the specified file.
82886>>>>>>>///
82886>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
82886>>>>>>>/// @Status      Public
82886>>>>>>>/// @Drivers     All
82886>>>>>>>/// @VersionNote Last Revised: 2013-08-21 by Aaron Gulack
82886>>>>>>>/// @See                 SQL_APPEND_STMT SQL_PREPARE_STMT SQL_EXECUTE_STMT SQL_CANCEL_QUERY_STMT SQL_FETCH_NEXT_ROW SQL_BINDCOLUMNS_STMT
82886>>>>>>>///
82886>>>>>>>/// @Syntax SQL_SET_STMT [of {file}] to {variable}
82886>>>>>>>/// @Param file                         Name or number of the file (optional)
82886>>>>>>>/// @Param variable                     String containing the SQL statement
82886>>>>>>>///
82886>>>>>>>/// @Usage SQL_SET_STMT of Customer to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
82886>>>>>>>/// @Usage SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
82886>>>>>>>///
82886>>>>>>>/// @Example
82886>>>>>>>/// Open Customer
82886>>>>>>>///
82886>>>>>>>/// String sID sFirstName sLastName sDOB
82886>>>>>>>///
82886>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
82886>>>>>>>/// SQL_PREPARE_STMT
82886>>>>>>>/// SQL_EXECUTE_STMT
82886>>>>>>>/// While (Found)
82886>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sFirstName sLastName sDOB
82886>>>>>>>///     Showln sID
82886>>>>>>>///     Showln sFirstName
82886>>>>>>>///     Showln sLastName
82886>>>>>>>///     Showln sDOB
82886>>>>>>>/// Loop
82886>>>>>>>/// SQL_CANCEL_QUERY_STMT
82886>>>>>>>
82886>>>>>>>Procedure MertechInc_SQL_SET_STMT Global String sStatment
82888>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function 22 CALLBACK 0 PASSING MertechInc_Blank sStatment 0 RESULT MertechInc_iRet
82893>>>>>>>End_Procedure
82894>>>>>>>
82894>>>>>>>//=============================================================================
82894>>>>>>>/// @Name        SQL_APPEND_STMT
82894>>>>>>>/// @Description This command is used to append a command string to the
82894>>>>>>>/// command buffer initialized by SQL_SET_STMT. SQL_APPEND_STMT was added
82894>>>>>>>/// so that long SQL expressions could be broken into smaller strings and
82894>>>>>>>/// appended to a dynamic command buffer, which is then passed to the server.
82894>>>>>>>/// The SQL_APPEND_STMT will concatenate a string to the command buffer
82894>>>>>>>/// initialized by the SQL_SET_STMT command. SQL_APPEND_STMT can be called as
82894>>>>>>>/// many times as necessary to complete the SQL expression. Subsequently, the
82894>>>>>>>/// SQL_EXECUTE_STMT command executes the completed command.  The option to
82894>>>>>>>/// pass the file name as an extra parameter is used in cases where the data
82894>>>>>>>/// needs to be fetched directly into the record buffer of the specified file.
82894>>>>>>>///
82894>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
82894>>>>>>>/// @Status      Public
82894>>>>>>>/// @Drivers     All
82894>>>>>>>/// @VersionNote Last Revised: 2013-08-22 by Aaron Gulack
82894>>>>>>>/// @See                 SQL_SET_STMT SQL_PREPARE_STMT SQL_EXECUTE_STMT SQL_CANCEL_QUERY_STMT SQL_FETCH_NEXT_ROW SQL_BINDCOLUMNS_STMT
82894>>>>>>>///
82894>>>>>>>/// @Syntax SQL_APPEND_STMT [of {file}] to {variable}
82894>>>>>>>/// @Param file                         The name or number of the file (optional)
82894>>>>>>>/// @Param variable                     The string to be appended to the current SQL expression
82894>>>>>>>///
82894>>>>>>>/// @Usage SQL_APPEND_STMT to " CUSTOMER.PHONE_NUMBER, CUSTOMER.FAX_NUMBER"
82894>>>>>>>/// @Usage SQL_APPEND_STMT of Customer to " CUSTOMER.PHONE_NUMBER, CUSTOMER.FAX_NUMBER"
82894>>>>>>>///
82894>>>>>>>/// @Example
82894>>>>>>>/// Open Customer
82894>>>>>>>///
82894>>>>>>>/// String sID sFirstName sLastName sDOB
82894>>>>>>>///
82894>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
82894>>>>>>>/// SQL_PREPARE_STMT
82894>>>>>>>/// SQL_EXECUTE_STMT
82894>>>>>>>/// While (Found)
82894>>>>>>>///     SQL_FETCH_NEXT_ROW into sID sFirstName sLastName sDOB
82894>>>>>>>///     Showln sID
82894>>>>>>>///     Showln sFirstName
82894>>>>>>>///     Showln sLastName
82894>>>>>>>///     Showln sDOB
82894>>>>>>>/// Loop
82894>>>>>>>/// SQL_CANCEL_QUERY_STMT
82894>>>>>>>
82894>>>>>>>Procedure MertechInc_SQL_APPEND_STMT Global String sStatement
82896>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function 22 CALLBACK 0 PASSING MertechInc_Blank sStatement 1 RESULT MertechInc_iRet
82901>>>>>>>End_Procedure
82902>>>>>>>
82902>>>>>>>//=============================================================================
82902>>>>>>>/// @Name        APPEND_UPDATE_COLUMN
82902>>>>>>>/// @Description Append a given string to the existing SQL statement
82902>>>>>>>/// already set.
82902>>>>>>>///
82902>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method
82902>>>>>>>/// @Status      Internal
82902>>>>>>>/// @Drivers     All
82902>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
82902>>>>>>>/// @See
82902>>>>>>>///
82902>>>>>>>/// @Syntax APPEND_UPDCOL_STMT {variable} for {fileName}.{fieldName} {fields...}
82902>>>>>>>/// @Param variable                             SQL expression to be appended
82902>>>>>>>/// @Param fileName                             Name of the file
82902>>>>>>>/// @Param fieldName                    Name of the field
82902>>>>>>>/// @Param fields...                    Any additional fields, use the file.field format
82902>>>>>>>
82902>>>>>>>Procedure MertechInc_APPEND_UPDATE_COLUMN Global String sStatement
82904>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function 22 CALLBACK 0 PASSING MertechInc_Blank sStatement 1 RESULT MertechInc_iRet
82909>>>>>>>End_Procedure
82910>>>>>>>
82910>>>>>>>//=============================================================================
82910>>>>>>>/// @Name        SQL_APPEND_UPDCOL_STMT
82910>>>>>>>/// @Description Used to optimize the update process of columns being loaded
82910>>>>>>>/// with the same value.
82910>>>>>>>///
82910>>>>>>>/// @Assumptions
82910>>>>>>>/// @Status      Deprecated
82910>>>>>>>/// @Drivers     All
82910>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
82910>>>>>>>/// @See
82910>>>>>>>///
82910>>>>>>>/// @Syntax SQL_APPEND_UPDCOL_STMT [of {file}] Value {variable} for {fileName}.{fieldName} {fields...}
82910>>>>>>>/// @Param file                         The name or number of the file (optional)
82910>>>>>>>/// @Param variable                     The value being uploaded
82910>>>>>>>/// @Param fileName                     The name of the file
82910>>>>>>>/// @Param fieldName            The name of the field
82910>>>>>>>/// @Param fields...            Any additional fields, use the file.field format
82910>>>>>>>///
82910>>>>>>>/// @Example
82910>>>>>>>/// Open Customer
82910>>>>>>>///
82910>>>>>>>/// SQL_SET_STMT    of Customer to "UPDATE CUSTOMER SET"
82910>>>>>>>/// SQL_APPEND_STMT of Customer to " ASC11='x', ASC12='y', ASC13='z'"
82910>>>>>>>///
82910>>>>>>>/// SQL_APPEND_UPDCOL_STMT of Customer value 0 ;
82910>>>>>>>///     for Customer.ID Customer.Purchases Customer.Credit ;
82910>>>>>>>///
82910>>>>>>>/// SQL_APPEND_STMT of Customer to " WHERE RECNUM=1"
82910>>>>>>>///
82910>>>>>>>/// SQL_PREPARE_STMT of Customer
82910>>>>>>>/// SQL_EXECUTE_STMT of Customer
82910>>>>>>>
82910>>>>>>>//=============================================================================
82910>>>>>>>/// @Name        SQL_SET_CURSOR_TYPE
82910>>>>>>>/// @Description Specify the SQL cursor type to be used during the next
82910>>>>>>>/// embedded SQL statement execution.
82910>>>>>>>///
82910>>>>>>>/// @Assumptions
82910>>>>>>>/// @Status      Internal
82910>>>>>>>/// @Drivers     SQLFlex
82910>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
82910>>>>>>>/// @See
82910>>>>>>>///
82910>>>>>>>/// @Syntax SQL_SET_CURSOR_TYPE to {TYPE_NONE/TYPE_CLIENT/TYPE_SERVER}
82910>>>>>>>/// @Param TYPE_NONE                    the default cursor type should be used
82910>>>>>>>/// @Param TYPE_CLIENT                  a client side cursor should be used
82910>>>>>>>/// @Param TYPE_SERVER                  a server side cursor should be used
82910>>>>>>>
82910>>>>>>>//=============================================================================
82910>>>>>>>/// @Name        CLEAR_INT_CACHE
82910>>>>>>>/// @Description Clears all memory-cached INT info. This is used in the
82910>>>>>>>/// test framework to force a "reload" of int info which the framework
82910>>>>>>>/// modifies for its tests. This is a different cache than the TD files
82910>>>>>>>/// which are a file based cache of the structure for use at file open.
82910>>>>>>>///
82910>>>>>>>/// @Assumptions
82910>>>>>>>/// @Status      Internal
82910>>>>>>>/// @Drivers     All
82910>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
82910>>>>>>>/// @See
82910>>>>>>>///
82910>>>>>>>/// @Syntax CLEAR_INT_CACHE
82910>>>>>>>
82910>>>>>>>//=============================================================================
82910>>>>>>>/// @Name        CREATE_INVERSE_KEY_FUNCTIONS
82910>>>>>>>/// @Description Create SQL Functions to handle Inverse Key columns.
82910>>>>>>>///
82910>>>>>>>/// @Assumptions
82910>>>>>>>/// @Status      Internal
82910>>>>>>>/// @Drivers     All (v10.1 and above)
82910>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
82910>>>>>>>/// @See
82910>>>>>>>///
82910>>>>>>>/// @Syntax CREATE_INVERSE_KEY_FUNCTIONS
82910>>>>>>>
82910>>>>>>>//=============================================================================
82910>>>>>>>/// @Name        SQL_PREPARE_STMT
82910>>>>>>>/// @Description Prepares a statement and opens a cursor to be executed by
82910>>>>>>>/// SQL_EXECUTE_STMT. This command tells the server to parse the SQL statement
82910>>>>>>>/// created by the respective SQL_SET_STMT and all subsequent SQL_APPEND_STMT
82910>>>>>>>/// statements and to allocate cursor handles to be used to fetch the data.
82910>>>>>>>/// A cursor can be thought of as a pointer to a record set. The CURSOR_TYPE
82910>>>>>>>/// argument is only supported by SQLFlex and by default SQLFLex is using a
82910>>>>>>>/// TYPE_SERVER cursor type to all embedded SQL. TYPE_CLIENT should be used only
82910>>>>>>>/// for the statements that are querying LOB columns i.e. TEXT, NVARCHAR(MAX),
82910>>>>>>>/// VARCHAR(MAX), IMAGE, VARBINARY(MAX), XML. If the cursor type is
82910>>>>>>>/// TYPE_SERVER and a LOB type column is selected, MS SQL Server will not be
82910>>>>>>>/// able to get into a transaction, either explicitly or implicitly through a
82910>>>>>>>/// REREAD, LOCK, SAVERECORD, etc.
82910>>>>>>>///
82910>>>>>>>/// @Assumptions
82910>>>>>>>/// @Status      Public
82910>>>>>>>/// @Drivers     All
82910>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
82910>>>>>>>/// @See                 SQL_SET_STMT SQL_APPEND_STMT SQL_EXECUTE_STMT SQL_CANCEL_QUERY_STMT SQL_FETCH_NEXT_ROW SQL_BINDCOLUMNS_STMT
82910>>>>>>>///
82910>>>>>>>/// @Syntax SQL_PREPARE_STMT [of {file}] CURSOR_TYPE {TYPE_NONE/TYPE_CLIENT/TYPE_SERVER}
82910>>>>>>>/// @Param file                         The name or number of the file (optional)
82910>>>>>>>/// @Param CURSOR_TYPE          Used if the cursor type is being set, do not include otherwise
82910>>>>>>>/// @Param TYPE_NONE            Default cursor will be used
82910>>>>>>>/// @Param TYPE_CLIENT          A client side cursor should be used
82910>>>>>>>/// @Param TYPE_SERVER          A server side cursor should be used (Default)
82910>>>>>>>///
82910>>>>>>>/// @Usage SQL_PREPARE_STMT
82910>>>>>>>/// @Usage SQL_PREPARE_STMT of Customer
82910>>>>>>>/// @Usage SQL_PREPARE_STMT CURSOR_TYPE TYPE_SERVER
82910>>>>>>>/// @Usage SQL_PREPARE_STMT of Customer CURSOR_TYPE TYPE_CLIENT
82910>>>>>>>///
82910>>>>>>>/// @Example
82910>>>>>>>/// Open Customer
82910>>>>>>>///
82910>>>>>>>/// String sID sFirstName
82910>>>>>>>///
82910>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
82910>>>>>>>/// SQL_PREPARE_STMT
82910>>>>>>>/// SQL_EXECUTE_STMT
82910>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sFirstName
82910>>>>>>>
82910>>>>>>>//=============================================================================
82910>>>>>>>/// @Name        SQL_BIND_COLUMN
82910>>>>>>>/// @Description Clears all cached INT info. This should be merged with
82910>>>>>>>/// SQL_BINDCOLUMNS_STMT, but has to remain as a separate command for
82910>>>>>>>/// compatibility.
82910>>>>>>>///
82910>>>>>>>/// @Assumptions
82910>>>>>>>/// @Status      Internal
82910>>>>>>>/// @Drivers     All
82910>>>>>>>/// @VersionNote Last Revised: 2013-08-26 by Aaron Gulack
82910>>>>>>>/// @See
82910>>>>>>>///
82910>>>>>>>/// @Syntax SQL_BIND_COLUMN FileNumber FieldNumber | DF_BIND_ALL_COLUMNS
82910>>>>>>>/// @Param FileNumber                   The number of the file
82910>>>>>>>/// @Param FieldNumber                  The number of the field
82910>>>>>>>
82910>>>>>>>//=============================================================================
82910>>>>>>>/// @Name        SQL_BINDCOLUMNS_STMT
82910>>>>>>>/// @Description This command is used to fetch the returned data of a
82910>>>>>>>/// specified SQL expression into the given field in the record buffer. By
82910>>>>>>>/// passing any number of fields to this command, the fetched record will then
82910>>>>>>>/// be put into the subsequent fields in the record buffer. The order of the
82910>>>>>>>/// fields must be the same as the order of the columns being retrieved from
82910>>>>>>>/// the SQL expression. SQL_FETCH_NEXT_ROW can then be called to take the data
82910>>>>>>>/// retrieved from the server and place it into the corresponding fields in the
82910>>>>>>>/// buffer. Instead of specifying each field, DF_BIND_ALL_COLUMNS can be passed,
82910>>>>>>>/// which will retrieve every column in the table.
82910>>>>>>>///
82910>>>>>>>/// @Assumptions
82910>>>>>>>/// @Status      Public
82910>>>>>>>/// @Drivers     All
82910>>>>>>>/// @VersionNote Last Revised: 2013-08-26 by Aaron Gulack
82910>>>>>>>/// @See                 SQL_SET_STMT SQL_APPEND_STMT SQL_PREPARE_STMT SQL_EXECUTE_STMT SQL_CANCEL_QUERY_STMT SQL_FETCH_NEXT_ROW
82910>>>>>>>///
82910>>>>>>>/// @Syntax SQL_BINDCOLUMNS_STMT of {file} to {field/DF_BIND_ALL_COLUMNS}
82910>>>>>>>///
82910>>>>>>>/// @Param file                 Name or number of the file
82910>>>>>>>/// @Param field                        Name or number of the field (can be multiple)
82910>>>>>>>/// @Param DF_BIND_ALL_COLUMNS  Used instead of the field to retrieve all columns in the file
82910>>>>>>>///
82910>>>>>>>/// @Example
82910>>>>>>>/// Open Customer
82910>>>>>>>///
82910>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
82910>>>>>>>/// SQL_PREPARE_STMT
82910>>>>>>>/// SQL_BINDCOLUMNS_STMT of Customer to DF_BIND_ALL_COLUMNS
82910>>>>>>>/// SQL_EXECUTE_STMT of Customer
82910>>>>>>>/// While (Found)
82910>>>>>>>///     SQL_FETCH_NEXT_ROW of Customer
82910>>>>>>>///     Showln Customer.ID
82910>>>>>>>///     Showln Customer.FirstName
82910>>>>>>>///     Showln Customer.LastName
82910>>>>>>>///     Showln Customer.DOB
82910>>>>>>>/// Loop
82910>>>>>>>/// SQL_CANCEL_QUERY_STMT
82910>>>>>>>
82910>>>>>>>//=============================================================================
82910>>>>>>>/// @Name        SQL_EXECUTE_STMT
82910>>>>>>>/// @Description This command is used to execute the SQL expression created
82910>>>>>>>/// by the SQL_SET_STMT and any subsequent SQL_APPEND_STMT commands issued
82910>>>>>>>/// after a SQL_PREPARE_STMT. If the results will be sent to the record
82910>>>>>>>/// buffer directly, then the file must be specified. An optional parameter
82910>>>>>>>/// can also be passed, indicating the maximum number of rows to be sent to
82910>>>>>>>/// the local cache. This is done by adding the constant ROWCOUNT followed
82910>>>>>>>/// by the maximun number.
82910>>>>>>>///
82910>>>>>>>/// @Assumptions
82910>>>>>>>/// @Status      Public
82910>>>>>>>/// @Drivers     All
82910>>>>>>>/// @VersionNote Last Revised: 2013-08-26 by Aaron Gulack
82910>>>>>>>/// @See                 SQL_SET_STMT SQL_APPEND_STMT SQL_PREPARE_STMT SQL_CANCEL_QUERY_STMT SQL_FETCH_NEXT_ROW SQL_BINDCOLUMNS_STMT
82910>>>>>>>///
82910>>>>>>>/// @Syntax SQL_EXECUTE_STMT [of {file} ROWCOUNT {variable}]
82910>>>>>>>/// @Param file                         Name or number of the file (optional)
82910>>>>>>>/// @Param variable                     Maximum number of rows to send to the local cache (optional)
82910>>>>>>>///
82910>>>>>>>/// @Usage SQL_EXECUTE_STMT
82910>>>>>>>/// @Usage SQL_EXECUTE_STMT of Customer
82910>>>>>>>/// @Usage SQL_EXECUTE_STMT of Customer ROWCOUNT 10
82910>>>>>>>///
82910>>>>>>>/// @Example
82910>>>>>>>/// Open Customer
82910>>>>>>>///
82910>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
82910>>>>>>>/// SQL_PREPARE_STMT
82910>>>>>>>/// SQL_BINDCOLUMNS_STMT of Customer to DF_BIND_ALL_COLUMNS
82910>>>>>>>/// SQL_EXECUTE_STMT of Customer
82910>>>>>>>/// While (Found)
82910>>>>>>>///     SQL_FETCH_NEXT_ROW of Customer
82910>>>>>>>///     Showln Customer.ID
82910>>>>>>>///     Showln Customer.FirstName
82910>>>>>>>///     Showln Customer.LastName
82910>>>>>>>///     Showln Customer.DOB
82910>>>>>>>/// Loop
82910>>>>>>>/// SQL_CANCEL_QUERY_STMT
82910>>>>>>>
82910>>>>>>>
82910>>>>>>>//This alias may be redundant. Is was only called from MertechInc_SQL_FUNCTION_EXECUTE
82910>>>>>>>//which has been recoded to directly call SQL_EXECUTE_STMT - I.S. 2009-09-19
82910>>>>>>>Procedure MertechInc_SQL_PROCEDURE_EXECUTE Global
82912>>>>>>>    SQL_EXECUTE_STMT
82927>>>>>>>End_Procedure
82928>>>>>>>
82928>>>>>>>//=============================================================================
82928>>>>>>>/// @Name        SQL_START_TRANSACTION_STMT
82928>>>>>>>/// @Description Transactions in SQL are used to maintain atomicity within
82928>>>>>>>/// an process. If one procedure in the transaction fails, then they all
82928>>>>>>>/// will fail. This command is used to start an SQL transaction. Inside of
82928>>>>>>>/// a transaction, there can be any number of SQL statements, none of which
82928>>>>>>>/// will be executed until SQL_COMMIT_STMT is called. Note that transactions
82928>>>>>>>/// are generally only needed when a table is being altered.
82928>>>>>>>///
82928>>>>>>>/// @Assumptions
82928>>>>>>>/// @Status      Public
82928>>>>>>>/// @Drivers     All
82928>>>>>>>/// @VersionNote Last Revised: 2013-08-26 by Aaron Gulack
82928>>>>>>>/// @See         SQL_COMMIT_STMT SQL_ROLLBACK_STMT
82928>>>>>>>///
82928>>>>>>>/// @Syntax SQL_START_TRANSACTION_STMT
82928>>>>>>>///
82928>>>>>>>/// @Example
82928>>>>>>>/// SQL_START_TRANSACTION_STMT
82928>>>>>>>/// SQL_SET_STMT to "UPDATE CUSTOMER SET STATUS = 'Inactive'"
82928>>>>>>>/// SQL_PREPARE_STMT
82928>>>>>>>/// SQL_EXECUTE_STMT
82928>>>>>>>/// SQL_COMMIT_STMT
82928>>>>>>>
82928>>>>>>>//=============================================================================
82928>>>>>>>/// @Name        SQL_COMMIT_STMT
82928>>>>>>>/// @Description Just as the SQL_EXECUTE_STMT is used to execute the SQL
82928>>>>>>>/// statement in the block, this command is used to commit the transaction
82928>>>>>>>/// started by SQL_START_TRANSACTION_STMT. When this command is called, any
82928>>>>>>>/// preceding statements or procedures that are apart of the transaction will
82928>>>>>>>/// be committed. If one or more of these statements fail, then none of them
82928>>>>>>>/// will be successful, thus maintaining atomicity.
82928>>>>>>>///
82928>>>>>>>/// @Assumptions
82928>>>>>>>/// @Status      Public
82928>>>>>>>/// @Drivers     All
82928>>>>>>>/// @VersionNote Last Revised: 2013-08-27 by Aaron Gulack
82928>>>>>>>/// @See                 SQL_START_TRANSACTION_STMT SQL_ROLLBACK_STMT
82928>>>>>>>///
82928>>>>>>>/// @Syntax SQL_COMMIT_STMT
82928>>>>>>>///
82928>>>>>>>/// @Example
82928>>>>>>>/// SQL_START_TRANSACTION_STMT
82928>>>>>>>/// SQL_SET_STMT to "UPDATE CUSTOMER SET STATUS = 'Inactive'"
82928>>>>>>>/// SQL_PREPARE_STMT
82928>>>>>>>/// SQL_EXECUTE_STMT
82928>>>>>>>/// SQL_COMMIT_STMT
82928>>>>>>>
82928>>>>>>>//=============================================================================
82928>>>>>>>/// @Name        SQL_ROLLBACK_STMT
82928>>>>>>>/// @Description Rolls back an SQL transaction, any data changes inside the
82928>>>>>>>/// transaction will not be committed by the server.
82928>>>>>>>///
82928>>>>>>>/// @Assumptions
82928>>>>>>>/// @Status      Public
82928>>>>>>>/// @Drivers     All
82928>>>>>>>/// @VersionNote Last Revised: 2013-08-27 by Aaron Gulack
82928>>>>>>>/// @See                 SQL_START_TRANSACTION_STMT SQL_COMMIT_STMT
82928>>>>>>>///
82928>>>>>>>/// @Syntax SQL_ROLLBACK_STMT
82928>>>>>>>///
82928>>>>>>>/// @Example
82928>>>>>>>/// SQL_START_TRANSACTION_STMT
82928>>>>>>>/// SQL_SET_STMT to "DELETE FROM CUSTOMER WHERE ID = 2145"
82928>>>>>>>/// SQL_PREPARE_STMT
82928>>>>>>>/// SQL_EXECUTE_STMT
82928>>>>>>>/// If (Err) Begin
82928>>>>>>>///             SQL_ERROR_MESSAGE errorString
82928>>>>>>>///     Showln errorString
82928>>>>>>>///     SQL_ROLLBACK_STMT
82928>>>>>>>/// End
82928>>>>>>>/// Else
82928>>>>>>>///     Showln "SQL Statement successful - committing"
82928>>>>>>>///     SQL_COMMIT_STMT
82928>>>>>>>
82928>>>>>>>//=============================================================================
82928>>>>>>>/// @Name        SET_TRANSACTIONS_ALLOWED
82928>>>>>>>/// @Description This command is used to toggle on or off the ability to
82928>>>>>>>/// complete transaction to the server. Passing false to this command will
82928>>>>>>>/// not allow transactions to be made, passing true will allow the transactions.
82928>>>>>>>///
82928>>>>>>>/// @Assumptions
82928>>>>>>>/// @Status      Internal
82928>>>>>>>/// @Drivers     All
82928>>>>>>>/// @VersionNote Last Revised: 2013-08-27 by Aaron Gulack
82928>>>>>>>/// @See
82928>>>>>>>///
82928>>>>>>>/// @Syntax SET_TRANSACTIONS_ALLOWED of {server} to {variable}
82928>>>>>>>/// @Param server                               The name of the server being used
82928>>>>>>>/// @Param variable                     Boolean to enable or disable transactions
82928>>>>>>>///
82928>>>>>>>/// @Example
82928>>>>>>>/// SET_TRANSACTIONS_ALLOWED of "localhost" to True
82928>>>>>>>
82928>>>>>>>//=============================================================================
82928>>>>>>>/// @Name        SQL_FETCH_NEXT_ROW
82928>>>>>>>/// @Description This command is used to fetch the next row returned by the
82928>>>>>>>/// associated SQL statement. The SQL statement is created from the
82928>>>>>>>/// SQL_SET_STMT and executed with the SQL_EXECUTE_STMT. This command can be
82928>>>>>>>/// used in two ways. If the results are to be attached to variables, then no
82928>>>>>>>/// file needs to be specified, just the variables for each column in the row.
82928>>>>>>>/// If the results are to be inserted into the record buffer directly, then the
82928>>>>>>>/// file must be specified. From there, a SQL_BINDCOLUMNS_STMT can be used to
82928>>>>>>>/// bind the fetched row to the specific fields in the file. Note that the
82928>>>>>>>/// columns are fecthed in the order that the SQL statement generates them, so
82928>>>>>>>/// the variables must follow the same order. The two constants, "found" and
82928>>>>>>>/// "finderr" are set depending on whether the next row was found.
82928>>>>>>>///
82928>>>>>>>/// @Assumptions
82928>>>>>>>/// @Status      Public
82928>>>>>>>/// @Drivers     All
82928>>>>>>>/// @VersionNote Last Revised: 2013-08-27 by Aaron Gulack
82928>>>>>>>/// @See                 SQL_SET_STMT SQL_APPEND_STMT SQL_PREPARE_STMT SQL_EXECUTE_STMT SQL_CANCEL_QUERY_STMT SQL_BINDCOLUMNS_STMT
82928>>>>>>>///
82928>>>>>>>/// @Syntax SQL_FETCH_NEXT_ROW [of {file}] into {variable}
82928>>>>>>>/// @Param  file                                The name or number of the file
82928>>>>>>>/// @Param  variable                    The variable that the next column in the fetched row will be put into (can be multiple)
82928>>>>>>>///
82928>>>>>>>/// @Usage SQL_FETCH_NEXT_ROW of Customer
82928>>>>>>>/// @Usage SQL_FETCH_NEXT_ROW into sRecnum sID
82928>>>>>>>///
82928>>>>>>>/// @Example
82928>>>>>>>/// String sID sRecnum
82928>>>>>>>///
82928>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER ID"
82928>>>>>>>/// SQL_APPEND_STMT to " BY NAME DESC"
82928>>>>>>>/// SQL_PREPARE_STMT
82928>>>>>>>/// SQL_EXECUTE_STMT
82928>>>>>>>/// While (found)
82928>>>>>>>///     SQL_FETCH_NEXT_ROW into sRecnum sID
82928>>>>>>>///     If (found) Begin
82928>>>>>>>///             Showln sID
82928>>>>>>>///    End
82928>>>>>>>/// Loop
82928>>>>>>>/// SQL_CANCEL_QUERY_STMT
82928>>>>>>>///
82928>>>>>>>/// @Example
82928>>>>>>>/// Open Customer
82928>>>>>>>///
82928>>>>>>>/// SQL_SET_STMT of Customer to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
82928>>>>>>>/// SQL_PREPARE_STMT of Customer
82928>>>>>>>/// SQL_BINDCOLUMNS_STMT of Customer to DF_BIND_ALL_COLUMNS
82928>>>>>>>/// SQL_EXECUTE_STMT of Customer
82928>>>>>>>/// While (Found)
82928>>>>>>>///     SQL_FETCH_NEXT_ROW of Customer
82928>>>>>>>///     Showln Customer.ID
82928>>>>>>>///     Showln Customer.FirstName
82928>>>>>>>///             Showln Customer.LastName
82928>>>>>>>/// Loop
82928>>>>>>>/// SQL_CANCEL_QUERY_STMT
82928>>>>>>>
82928>>>>>>>
82928>>>>>>>//=============================================================================
82928>>>>>>>/// @Name        GET_RESULT_SET
82928>>>>>>>/// @Description Fetches the next row in the result set returned by a
82928>>>>>>>/// query or stored procedure.
82928>>>>>>>///
82928>>>>>>>/// @Assumptions
82928>>>>>>>/// @Status      Deprecated
82928>>>>>>>/// @Drivers     All
82928>>>>>>>/// @VersionNote Last Revised: 2013-08-27 by Aaron Gulack
82928>>>>>>>/// @See
82928>>>>>>>///
82928>>>>>>>/// @Syntax GET_RESULT_SET into {variable}
82928>>>>>>>/// @Param variable                     The variable receiving the result (can be multiple)
82928>>>>>>>
82928>>>>>>>//=============================================================================
82928>>>>>>>/// @Name        SQL_GET_DATA_CHUNK
82928>>>>>>>/// @Description This command is used to get a chunk of data from a column
82928>>>>>>>/// retrieved through an embedded SQL statement. By passing the column number
82928>>>>>>>/// and the offset number, the chunk will be put into the specified variable.
82928>>>>>>>/// To specify how big of a chunk to get, use the SQL_SET_CHUNK_SIZE command.
82928>>>>>>>/// Otherwise the maximum length will be retrieved. An optional variable can
82928>>>>>>>/// also be passed which will store the length of the chunk. Note that unlike
82928>>>>>>>/// LOB_READ, this command works for any column type, not just LOB columns.
82928>>>>>>>///
82928>>>>>>>/// @Assumptions
82928>>>>>>>/// @Status      Public
82928>>>>>>>/// @Drivers     SQLFlex
82928>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
82928>>>>>>>/// @See                 SQL_SET_CHUNK_SIZE SQL_GET_CHUNK_SIZE SQL_SET_MAX_DATA_SIZE SQL_GET_MAX_DATA_SIZE
82928>>>>>>>///
82928>>>>>>>/// @Syntax SQL_GET_DATA_CHUNK COLUMN {column} OFFSET {offset} to {variable} {length}
82928>>>>>>>/// @Param column                               Column number to get chunk from
82928>>>>>>>/// @Param offset                       Offset to start at for the chunk
82928>>>>>>>/// @Param variable                     Variable to hold the returned chunk
82928>>>>>>>/// @Param length                       Variable to hold the chunk length
82928>>>>>>>///
82928>>>>>>>/// @Example
82928>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
82928>>>>>>>/// SQL_PREPARE_STMT
82928>>>>>>>/// SQL_EXECUTE_STMT
82928>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sBio
82928>>>>>>>/// If (Found) Begin
82928>>>>>>>///     SQL_SET_CHUNK_SIZE to 150
82928>>>>>>>///     SQL_GET_DATA_CHUNK COLUMN 6 OFFSET 1 to sChunk iLength
82928>>>>>>>///     Showln sChunk
82928>>>>>>>///     Showln iLength
82928>>>>>>>/// End
82928>>>>>>>
82928>>>>>>>Function MertechInc_SQL_GET_DATA_CHUNK Global Integer iColumn Integer iOffset Returns String
82930>>>>>>>    Integer iChuck_Size
82930>>>>>>>    String sChunk
82930>>>>>>>
82930>>>>>>>    //Get current Chuck size and pre size string
82930>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_CHUNK_SIZE CALLBACK 0 PASSING iChuck_Size MertechInc_Blank 1 RESULT MertechInc_iRet
82935>>>>>>>    Get MertechInc_Pre_Size_String iChuck_Size to sChunk
82936>>>>>>>
82936>>>>>>>    //Get data
82936>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_GET_DATA_CHUNK CALLBACK 0 PASSING iColumn sChunk iOffset RESULT MertechInc_iRet
82941>>>>>>>
82941>>>>>>>    //sArg1 (iColumn) contains the number of bytes returned, so move it to
82941>>>>>>>    //MertechInc_Arg1 to pass the value back
82941>>>>>>>    Move iColumn to MertechInc_sArg1
82942>>>>>>>
82942>>>>>>>    Function_Return sChunk
82943>>>>>>>End_Function
82944>>>>>>>
82944>>>>>>>//=============================================================================
82944>>>>>>>/// @Name        SQL_SET_CHUNK_SIZE
82944>>>>>>>/// @Description This command sets the size of the chunk to retrieve when
82944>>>>>>>/// using SQL_GET_DATA_CHUNK. Whatever number is set here will be the
82944>>>>>>>/// length of the chunk that is retrieved, as long as it does not exceed
82944>>>>>>>/// the maximum chunk size.
82944>>>>>>>///
82944>>>>>>>/// @Assumptions
82944>>>>>>>/// @Status      Public
82944>>>>>>>/// @Drivers     SQLFlex
82944>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
82944>>>>>>>/// @See                 SQL_GET_DATA_CHUNK SQL_GET_CHUNK_SIZE SQL_SET_MAX_DATA_SIZE SQL_GET_MAX_DATA_SIZE
82944>>>>>>>///
82944>>>>>>>/// @Syntax SQL_SET_CHUNK_SIZE to {variable}
82944>>>>>>>/// @Param variable                     Length of chunk to retrive
82944>>>>>>>///
82944>>>>>>>/// @Example
82944>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
82944>>>>>>>/// SQL_PREPARE_STMT
82944>>>>>>>/// SQL_EXECUTE_STMT
82944>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sBio
82944>>>>>>>/// If (Found) Begin
82944>>>>>>>///     SQL_SET_CHUNK_SIZE to 150
82944>>>>>>>///     SQL_GET_DATA_CHUNK COLUMN 6 OFFSET 1 to sChunk iLength
82944>>>>>>>///     Showln sChunk
82944>>>>>>>///     Showln iLength
82944>>>>>>>/// End
82944>>>>>>>
82944>>>>>>>//=============================================================================
82944>>>>>>>/// @Name        SQL_GET_CHUNK_SIZE
82944>>>>>>>/// @Description This command gets the size of the chunk being retrieved
82944>>>>>>>/// from SQL_GET_DATA_CHUNK and puts it into the specified variable.
82944>>>>>>>///
82944>>>>>>>/// @Assumptions
82944>>>>>>>/// @Status      Public
82944>>>>>>>/// @Drivers     SQLFlex
82944>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
82944>>>>>>>/// @See                 SQL_SET_CHUNK_SIZE SQL_GET_DATA_CHUNK SQL_SET_MAX_DATA_SIZE SQL_GET_MAX_DATA_SIZE
82944>>>>>>>///
82944>>>>>>>/// @Syntax SQL_GET_CHUNK_SIZE to {variable}
82944>>>>>>>/// @Param variable             Variable to hold the chunk size
82944>>>>>>>///
82944>>>>>>>/// @Example
82944>>>>>>>/// SQL_GET_CHUNK_SIZE to iLength
82944>>>>>>>
82944>>>>>>>//=============================================================================
82944>>>>>>>/// @Name        SQL_SET_MAX_DATA_SIZE
82944>>>>>>>/// @Description This command sets the maximum size for data chunks
82944>>>>>>>/// retrieved through SQL_GET_DATA_CHUNK. If SQL_SET_CHUNK_SIZE is higher
82944>>>>>>>/// than the maximum size set with this command, then this will override
82944>>>>>>>/// it and the chunk will be no longer than the maximum size set here.
82944>>>>>>>///
82944>>>>>>>/// @Assumptions
82944>>>>>>>/// @Status      Public
82944>>>>>>>/// @Drivers     SQLFlex
82944>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
82944>>>>>>>/// @See                 SQL_SET_CHUNK_SIZE SQL_GET_CHUNK_SIZE SQL_GET_DATA_CHUNK SQL_GET_MAX_DATA_SIZE
82944>>>>>>>///
82944>>>>>>>/// @Syntax SQL_SET_MAX_DATA_SIZE to {variable}
82944>>>>>>>/// @Param variable                     Max length to allow for chunks
82944>>>>>>>///
82944>>>>>>>/// @Example
82944>>>>>>>/// SQL_SET_MAX_DATA_SIZE to 1000
82944>>>>>>>
82944>>>>>>>//=============================================================================
82944>>>>>>>/// @Name        SQL_GET_MAX_DATA_SIZE
82944>>>>>>>/// @Description This command returns the maximum chunk size allowed
82944>>>>>>>/// for SQL_GET_DATA_CHUNK.
82944>>>>>>>///
82944>>>>>>>/// @Assumptions
82944>>>>>>>/// @Status      Public
82944>>>>>>>/// @Drivers     SQLFlex
82944>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
82944>>>>>>>/// @See                 SQL_SET_CHUNK_SIZE SQL_GET_CHUNK_SIZE SQL_GET_DATA_CHUNK SQL_SET_MAX_DATA_SIZE
82944>>>>>>>///
82944>>>>>>>/// @Syntax SQL_GET_MAX_DATA_SIZE to {variable}
82944>>>>>>>/// @Param variable             Variable to hold the maximum chunk size
82944>>>>>>>///
82944>>>>>>>/// @Example
82944>>>>>>>/// SQL_GET_MAX_DATA_SIZE to iLength
82944>>>>>>>
82944>>>>>>>//=============================================================================
82944>>>>>>>/// @Name        SQL_GET_NUM_COLS
82944>>>>>>>/// @Description This command is used to get the number of columns retrieved
82944>>>>>>>/// from an SQL expression result set. Since the column number is based on
82944>>>>>>>/// the result set, this command cannot be used when the results are being
82944>>>>>>>/// bound to the record buffer.  If this command is used with the record
82944>>>>>>>/// buffer or if no columns are found, -1 is returned.
82944>>>>>>>///
82944>>>>>>>/// @Assumptions
82944>>>>>>>/// @Status      Public
82944>>>>>>>/// @Drivers     All
82944>>>>>>>/// @VersionNote Last Revised: 2013-08-28 by Aaron Gulack
82944>>>>>>>/// @See                 SQL_PREPARE_STMT SQL_EXECUTE_STMT SQL_SET_STMT
82944>>>>>>>///
82944>>>>>>>/// @Syntax SQL_GET_NUM_COLS to {variable}
82944>>>>>>>/// @Param variable                     Variable to hold the number of columns.
82944>>>>>>>///
82944>>>>>>>/// @Example
82944>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE FIRSTNAME = 'Aaron'"
82944>>>>>>>/// SQL_PREPARE_STMT
82944>>>>>>>/// SQL_EXECUTE_STMT
82944>>>>>>>/// GET_RESULT_SET_NUM_COLS to iNumCols
82944>>>>>>>/// Showln iNumCols
82944>>>>>>>
82944>>>>>>>
82944>>>>>>>//=============================================================================
82944>>>>>>>/// @Name        GET_RESULT_SET_NUM_COLS
82944>>>>>>>/// @Description Returns the number of columns in the result set.
82944>>>>>>>///
82944>>>>>>>/// @Assumptions
82944>>>>>>>/// @Status      Deprecated
82944>>>>>>>/// @Drivers     All
82944>>>>>>>/// @VersionNote Last Revised: 2013-08-28 by Aaron Gulack
82944>>>>>>>/// @See                 SQL_GET_NUM_COLS
82944>>>>>>>///
82944>>>>>>>/// @Syntax GET_RESULT_SET_NUM_COLS to {variable}
82944>>>>>>>/// @Param variable                     Variable to hold the number of columns
82944>>>>>>>///
82944>>>>>>>/// @Example
82944>>>>>>>/// Integer iNumCols
82944>>>>>>>///
82944>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE FIRSTNAME = 'Aaron'"
82944>>>>>>>/// SQL_PREPARE_STMT
82944>>>>>>>/// SQL_EXECUTE_STMT
82944>>>>>>>/// GET_RESULT_SET_NUM_COLS to iNumCols
82944>>>>>>>/// Showln iNumCols
82944>>>>>>>
82944>>>>>>>//=============================================================================
82944>>>>>>>/// @Name        SQL_GET_NUM_ROWS
82944>>>>>>>/// @Description This command is used to get the number of rows retrieved
82944>>>>>>>/// from a result set of an SQL expression. It cannot be used when binding
82944>>>>>>>/// the result set to the record buffer.
82944>>>>>>>///
82944>>>>>>>/// Note: The number of rows may not always be available, depending
82944>>>>>>>/// on server and cursor types.
82944>>>>>>>///
82944>>>>>>>/// @Assumptions
82944>>>>>>>/// @Status      Public
82944>>>>>>>/// @Drivers     All
82944>>>>>>>/// @VersionNote Last Revised: 2013-08-30 by Aaron Gulack
82944>>>>>>>/// @See                 SQL_PREPARE_STMT SQL_EXECUTE_STMT
82944>>>>>>>///
82944>>>>>>>/// @Syntax SQL_GET_NUM_ROWS to {variable}
82944>>>>>>>/// @Param variable                     Variable to hold the number of rows
82944>>>>>>>///
82944>>>>>>>/// @Example
82944>>>>>>>/// Integer iNumRows
82944>>>>>>>///
82944>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
82944>>>>>>>/// SQL_PREPARE_STMT
82944>>>>>>>/// SQL_EXECUTE_STMT
82944>>>>>>>/// SQL_GET_NUM_ROWS to iNumRows
82944>>>>>>>/// Showln iNumRows
82944>>>>>>>
82944>>>>>>>
82944>>>>>>>//=============================================================================
82944>>>>>>>/// @Name        SQL_GET_COL_NAME
82944>>>>>>>/// @Description This command is used to retrieve the name of a specified
82944>>>>>>>/// column within an SQL result set. An optional second variable can be used
82944>>>>>>>/// to retrieve the size of the specified column. Note that this command
82944>>>>>>>/// cannot be used when the results are being directly binded to the record
82944>>>>>>>/// buffer, it can only be used for the results of an SQL statement.
82944>>>>>>>///
82944>>>>>>>/// @Assumptions
82944>>>>>>>/// @Status      Public
82944>>>>>>>/// @Drivers     All
82944>>>>>>>/// @VersionNote Last Revised: 2013-08-30 by Aaron Gulack
82944>>>>>>>/// @See                 SQL_GET_NUM_COLS
82944>>>>>>>///
82944>>>>>>>/// @Syntax SQL_GET_COL_NAME {columnNumber} to {variable} [{length}]
82944>>>>>>>/// @Param columnNumber                 The column number being used
82944>>>>>>>/// @Param variable                             String variable for the column name
82944>>>>>>>/// @Param length                       Variable to hold the column length (optional)
82944>>>>>>>///
82944>>>>>>>/// @Example
82944>>>>>>>/// Open Customer
82944>>>>>>>///
82944>>>>>>>/// String sColumnName
82944>>>>>>>/// Integer iLength
82944>>>>>>>///
82944>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
82944>>>>>>>/// SQL_PREPARE_STMT
82944>>>>>>>/// SQL_EXECUTE_STMT
82944>>>>>>>/// SQL_GET_COL_NAME 1 to sColumnName iLength
82944>>>>>>>/// showln sColumnName
82944>>>>>>>/// showln iLength
82944>>>>>>>
82944>>>>>>>
82944>>>>>>>//=============================================================================
82944>>>>>>>/// @Name        GET_RESULT_SET_COL_NAME
82944>>>>>>>/// @Description Returns the column name being populated from the result set.
82944>>>>>>>///
82944>>>>>>>/// @Assumptions
82944>>>>>>>/// @Status      Deprecated
82944>>>>>>>/// @Drivers     All
82944>>>>>>>/// @VersionNote Last Revised: 2013-08-30 by Aaron Gulack
82944>>>>>>>/// @See                 SQL_GET_COL_NAME
82944>>>>>>>///
82944>>>>>>>/// @Syntax GET_RESULT_SET_COL_NAME {columnNumber} to {variable} [{length}]
82944>>>>>>>/// @Param columnNumber                 The column number being used
82944>>>>>>>/// @Param variable                             String variable for the column name
82944>>>>>>>/// @Param length                       Variable receiving the column length (optional)
82944>>>>>>>
82944>>>>>>>//=============================================================================
82944>>>>>>>/// @Name        SQL_GET_COL_ATTRIBUTE
82944>>>>>>>/// @Description This command is used to get specific column information from
82944>>>>>>>/// the columns in a result set of an SQL statement. By passing one of the
82944>>>>>>>/// supported attributes below, the command will return the desired information.
82944>>>>>>>/// Note that some attributes only work with specific drivers. See the list
82944>>>>>>>/// below for more information.
82944>>>>>>>///
82944>>>>>>>/// Supported attributes are:
82944>>>>>>>/// <dl>
82944>>>>>>>/// <dt>SIZE        </dt><dd>The maximum length of the column</dd>
82944>>>>>>>/// <dt>DATA_LENGTH </dt><dd>Length of data currently in the column</dd>
82944>>>>>>>/// <dt>DECIMALS    </dt><dd>If numeric, shows number of decimal places</dd>
82944>>>>>>>/// <dt>LABEL       </dt><dd>Returns the column name in ORAFlex and MySQLFlex</dd>
82944>>>>>>>/// <dt>COLUMN_NAME </dt><dd>Returns the name of the column</dd>
82944>>>>>>>/// <dt>TABLE_NAME  </dt><dd>Returns the name of the table (MySQLFlex only)</dd>
82944>>>>>>>/// <dt>SQLTYPE     </dt><dd>Returns the number representing the SQL data type</dd>
82944>>>>>>>/// <dt>NULLABLE    </dt><dd>Returns true if null is allowed, false otherwise (doesn't work in PostgreSQL)</dd>
82944>>>>>>>/// <dt>DFTYPE      </dt><dd>Dataflex type column is mapped to</dd>
82944>>>>>>>/// </dl>
82944>>>>>>>///
82944>>>>>>>/// @Assumptions
82944>>>>>>>/// @Status      Public
82944>>>>>>>/// @Drivers     All
82944>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
82944>>>>>>>/// @See
82944>>>>>>>///
82944>>>>>>>/// @Syntax SQL_GET_COL_ATTRIBUTE of {columnNumber} {attribute} to {variable}
82944>>>>>>>/// @Param columnNumber                 The number of the column that is being examined
82944>>>>>>>/// @Param attribute                    The attribute being checked (see list)
82944>>>>>>>/// @Param variable                             Variable to hold the attribute value
82944>>>>>>>///
82944>>>>>>>/// @Example
82944>>>>>>>/// String sFirstName sLastName sColumn1Name sColumn2Name
82944>>>>>>>///
82944>>>>>>>/// Open Customer
82944>>>>>>>///
82944>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
82944>>>>>>>/// SQL_PREPARE_STMT
82944>>>>>>>/// SQL_EXECUTE_STMT
82944>>>>>>>/// SQL_FETCH_NEXT_ROW into sFirstName sLastName
82944>>>>>>>/// If (Found) Begin
82944>>>>>>>///     SQL_GET_COL_ATTRIBUTE of 1 COLUMN_NAME to sColumn1Name
82944>>>>>>>///     SQL_GET_COL_ATTRIBUTE of 2 COLUMN_NAME to sColumn2Name
82944>>>>>>>///     Showln (sColumn1Name + " = " + sFirstName)
82944>>>>>>>///     Showln (sColumn2Name + " = " + sLastName)
82944>>>>>>>/// End
82944>>>>>>>
82944>>>>>>>//=============================================================================
82944>>>>>>>/// @Name        DDO_GET_BIND_RSPARAMETERS
82944>>>>>>>/// @Description Recursively calls DO_GET_BIND_RSPARAMETERS.
82944>>>>>>>///
82944>>>>>>>/// @Assumptions
82944>>>>>>>/// @Status      Internal
82944>>>>>>>/// @Drivers     All
82944>>>>>>>/// @VersionNote Last Revised: 2013-08-30 by Aaron Gulack
82944>>>>>>>/// @See
82944>>>>>>>
82944>>>>>>>//=============================================================================
82944>>>>>>>/// @Name        DO_GET_BIND_RSPARAMETERS
82944>>>>>>>/// @Description Gets bound parameters values for result set call.
82944>>>>>>>///
82944>>>>>>>/// @Assumptions
82944>>>>>>>/// @Status      Internal
82944>>>>>>>/// @Drivers     All
82944>>>>>>>/// @VersionNote Last Revised: 2013-08-30 by Aaron Gulack
82944>>>>>>>/// @See
82944>>>>>>>
82944>>>>>>>Function MertechInc_DO_GET_BIND_RSPARAMETERS Global Integer bSQLFlex String sArg1 String sArg2 Integer iArg Returns String
82946>>>>>>>    String sReturnValue
82946>>>>>>>    Integer iSize
82946>>>>>>>
82946>>>>>>>    move 0 to iSize
82947>>>>>>>        SQL_GET_COL_ATTRIBUTE of iArg DATA_LENGTH to iSize
82964>>>>>>>>
82964>>>>>>>
82964>>>>>>>    Get MertechInc_Pre_Size_String (iSize+1) to sReturnValue
82965>>>>>>>    Move (|CI$10000 * iArg) To iArg // Shift column number 16 bits to the left
82966>>>>>>>    Call_Driver 0 MertechInc_DriverName Function 24 CALLBACK 0 PASSING sReturnValue MertechInc_Blank iArg RESULT MertechInc_iRet
82971>>>>>>>
82971>>>>>>>    Function_Return sReturnValue
82972>>>>>>>End_Function
82973>>>>>>>
82973>>>>>>>
82973>>>>>>>//=============================================================================
82973>>>>>>>/// @Name        SQL_NEXT_RESULT_SET
82973>>>>>>>/// @Description This command is used when working with SQL statements that
82973>>>>>>>/// return multiple result sets. In that scenario, calling this command will
82973>>>>>>>/// move to the next result set. That set can now be fetched or binded to
82973>>>>>>>/// columns on a table.
82973>>>>>>>///
82973>>>>>>>/// @See
82973>>>>>>>/// @Status      Public
82973>>>>>>>/// @Drivers     All
82973>>>>>>>/// @VersionNote Last Revised: 2013-09-02 by Aaron Gulack
82973>>>>>>>/// @See
82973>>>>>>>///
82973>>>>>>>/// @Syntax SQL_NEXT_RESULT_SET [of {file}]
82973>>>>>>>/// @Param file                 Name or number of the file (optional)
82973>>>>>>>///
82973>>>>>>>/// @Example
82973>>>>>>>/// SQL_SET_STMT to "SP_HELP CUSTOMER"
82973>>>>>>>/// SQL_PREPARE_STMT
82973>>>>>>>/// SQL_EXECUTE_STMT
82973>>>>>>>/// SQL_FETCH_NEXT_ROW into sTable sOwner sTableType dtCreated
82973>>>>>>>/// If (Found) Begin
82973>>>>>>>///     Showln sTable
82973>>>>>>>///     Showln sOwner
82973>>>>>>>///     Showln sTableType
82973>>>>>>>///     Showln dtCreated
82973>>>>>>>/// End
82973>>>>>>>/// SQL_NEXT_RESULT_SET
82973>>>>>>>/// SQL_FETCH_NEXT_ROW into sColumnName sColumnType sComputed sLength
82973>>>>>>>/// If (Found) Begin
82973>>>>>>>///     Showln sColumnName
82973>>>>>>>///     Showln sColumnType
82973>>>>>>>///     Showln sComputed
82973>>>>>>>///     Showln sLength
82973>>>>>>>/// End
82973>>>>>>>
82973>>>>>>>//=============================================================================
82973>>>>>>>/// @Name        DDO_PASS_ARGUMENTS
82973>>>>>>>/// @Description Calls DO_PASS_ARGUMENTS until the argument is "BINDING" and
82973>>>>>>>/// then stops.
82973>>>>>>>///
82973>>>>>>>/// @Assumptions
82973>>>>>>>/// @Status      Internal
82973>>>>>>>/// @Drivers     All
82973>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
82973>>>>>>>/// @See
82973>>>>>>>
82973>>>>>>>//=============================================================================
82973>>>>>>>/// @Name        DO_PASS_ARGUMENTS
82973>>>>>>>/// @Description Builds parameter statements for stored procedures and adds
82973>>>>>>>/// them to the current query.
82973>>>>>>>///
82973>>>>>>>/// @Assumptions
82973>>>>>>>/// @Status      internal
82973>>>>>>>/// @Drivers     All
82973>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
82973>>>>>>>/// @See
82973>>>>>>>
82973>>>>>>>//=============================================================================
82973>>>>>>>/// @Name        DDO_BIND_PARAMETERS
82973>>>>>>>/// @Description Recursively calls DO_BIND_PARAMETERS until the keyword
82973>>>>>>>/// "BINDING" is encountered.
82973>>>>>>>///
82973>>>>>>>/// @Assumptions
82973>>>>>>>/// @Status      Internal
82973>>>>>>>/// @Drivers     All
82973>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
82973>>>>>>>/// @See
82973>>>>>>>
82973>>>>>>>//=============================================================================
82973>>>>>>>/// @Name        DO_BIND_PARAMETERS
82973>>>>>>>/// @Description Binds parameters for a stored procedure call.
82973>>>>>>>///
82973>>>>>>>/// @Assumptions
82973>>>>>>>/// @Status      Internal
82973>>>>>>>/// @Drivers     All
82973>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
82973>>>>>>>/// @See
82973>>>>>>>
82973>>>>>>>Procedure MertechInc_DO_BIND_PARAMETERS Global String sValue String sName Integer iLength
82975>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_BIND_PARAMETER CALLBACK 0 PASSING sValue sName iLength RESULT MertechInc_iRet
82980>>>>>>>End_Procedure
82981>>>>>>>
82981>>>>>>>//=============================================================================
82981>>>>>>>/// @Name        DO_BIND_PAR_RET
82981>>>>>>>/// @Description Binds parameters for a stored procedure call.
82981>>>>>>>///
82981>>>>>>>/// @Assumptions
82981>>>>>>>/// @Status      Internal
82981>>>>>>>/// @Drivers     OraFlex
82981>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
82981>>>>>>>/// @See
82981>>>>>>>
82981>>>>>>>//=============================================================================
82981>>>>>>>/// @Name        DDO_GET_BIND_PARAMETERS
82981>>>>>>>/// @Description Recursively calls DO_GET_BIND_PARAMETERS.
82981>>>>>>>///
82981>>>>>>>/// @Assumptions
82981>>>>>>>/// @Status      Internal
82981>>>>>>>/// @Drivers     All
82981>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
82981>>>>>>>/// @See
82981>>>>>>>
82981>>>>>>>//=============================================================================
82981>>>>>>>/// @Name        DO_GET_BIND_PARAMETERS
82981>>>>>>>/// @Description Gets bound parameter values for a stored procedure call.
82981>>>>>>>///
82981>>>>>>>/// @Assumptions
82981>>>>>>>/// @Status      Internal
82981>>>>>>>/// @Drivers     All
82981>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
82981>>>>>>>/// @See
82981>>>>>>>
82981>>>>>>>Function MertechInc_DO_GET_BIND_PARAMETERS Global Integer bSQLFlex String sArg1 String sArg2 Integer iArg Returns String
82983>>>>>>>    String sReturnValue
82983>>>>>>>    Integer iSize
82983>>>>>>>
82983>>>>>>>    if (MertechInc_DriverName = SQLFLEX) ;                move (iArg+1) to iArg
82986>>>>>>>//        SQL_GET_COL_ATTRIBUTE of iArg DATA_LENGTH to iSize
82986>>>>>>>
82986>>>>>>>    Get MertechInc_Pre_Size_String (iSize+1) to sReturnValue
82987>>>>>>>    Call_Driver 0 MertechInc_DriverName Function 24 CALLBACK 0 PASSING sReturnValue MertechInc_Blank iArg RESULT MertechInc_iRet
82992>>>>>>>
82992>>>>>>>    Function_Return sReturnValue
82993>>>>>>>End_Function
82994>>>>>>>
82994>>>>>>>//=============================================================================
82994>>>>>>>/// @Name        SQL_GET_OUTPUT_VALUE
82994>>>>>>>/// @Description This command is used to get the value of a specific
82994>>>>>>>/// parameter associated with a stored procedure.  Although this
82994>>>>>>>/// command will work with any parameter, it is mostly used with
82994>>>>>>>/// IN/OUT or OUT parameters as their value will more often be important
82994>>>>>>>/// once returned. When multiple values are returned, this command can be
82994>>>>>>>/// more efficient than other options. Note that the specified parameter
82994>>>>>>>/// must first be defined using the SQL_SET_PROCEDURE_PARAMETER command
82994>>>>>>>/// in order to work properly.
82994>>>>>>>///
82994>>>>>>>/// @Assumptions
82994>>>>>>>/// @Status      Deprecated
82994>>>>>>>/// @Drivers     All
82994>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
82994>>>>>>>/// @See                 SQL_GET_PROCEDURE_PARAMETER
82994>>>>>>>///
82994>>>>>>>/// @Syntax SQL_GET_OUTPUT_VALUE {parameter} to {variable}
82994>>>>>>>/// @Param parameter            Number of the parameter
82994>>>>>>>/// @Param variable                     Variable to hold the parameter's value
82994>>>>>>>///
82994>>>>>>>/// @Example
82994>>>>>>>/// SQL_SET_PROCEDURE_NAME "user.getCustomerStatus" NUMPAR 1
82994>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to sCustomerID IN_OUT
82994>>>>>>>/// SQL_PROCEDURE_EXECUTE
82994>>>>>>>/// SQL_GET_OUTPUT_VALUE 1 to sStatus
82994>>>>>>>///
82994>>>>>>>/// Showln sStatus
82994>>>>>>>///
82994>>>>>>>/// @Example
82994>>>>>>>/// SQL_SET_PROCEDURE_NAME "user.getCustomerStatus" NUMPAR 2
82994>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to sCustomerID IN
82994>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 2 to sStatus OUT
82994>>>>>>>/// SQL_PROCEDURE_EXECUTE
82994>>>>>>>/// SQL_GET_OUTPUT_VALUE 2 to sStatus
82994>>>>>>>///
82994>>>>>>>/// Showln sStatus
82994>>>>>>>// OLI:
82994>>>>>>>// This function is identical in operation to SQL_GET_PROCEDURE_PARAMETER, so just do a replace
82994>>>>>>>
82994>>>>>>>//=============================================================================
82994>>>>>>>/// @Name        SQL_FETCH_COLUMN
82994>>>>>>>/// @Description This command is used to retrieve a specified column from a
82994>>>>>>>/// result set of an SQL statement. Note that this command cannot be used to
82994>>>>>>>/// replace SQL_FETCH_NEXT_ROW but is used in addition to it when only one
82994>>>>>>>/// column is needed. For most cases, SQL_FETCH_NEXT_ROW can be used alone
82994>>>>>>>/// to retrieve the columns desired so this should only be used if there is
82994>>>>>>>/// a specific reason to do so.
82994>>>>>>>///
82994>>>>>>>/// @Assumptions
82994>>>>>>>/// @Status      Public
82994>>>>>>>/// @Drivers     All
82994>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
82994>>>>>>>/// @See                 SQL_FETCH_NEXT_ROW
82994>>>>>>>///
82994>>>>>>>/// @Syntax SQL_FETCH_COLUMN {columnNumber} into {variable}
82994>>>>>>>/// @Param columnNumber    Number of the column to fetch
82994>>>>>>>/// @Param variable        Variable to hold the fetched value
82994>>>>>>>///
82994>>>>>>>/// @Example
82994>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
82994>>>>>>>/// SQL_PREPARE_STMT
82994>>>>>>>/// SQL_EXECUTE_STMT
82994>>>>>>>/// SQL_FETCH_NEXT_ROW
82994>>>>>>>/// SQL_GET_NUM_COLS to iCols
82994>>>>>>>/// For fieldIndex from 1 to iCols
82994>>>>>>>///     SQL_FETCH_COLUMN fieldIndex into sValue
82994>>>>>>>///     Showln sValue
82994>>>>>>>/// Loop
82994>>>>>>>
82994>>>>>>>Function MertechInc_SQL_FETCH_COLUMN Global String sArg1 String sArg2 Integer iArg Returns String
82996>>>>>>>    String sReturnValue
82996>>>>>>>    Integer iSize
82996>>>>>>>
82996>>>>>>>    Move 0 to iSize
82997>>>>>>>        SQL_GET_COL_ATTRIBUTE of iArg DATA_LENGTH to iSize
83014>>>>>>>>
83014>>>>>>>
83014>>>>>>>    Get MertechInc_Pre_Size_String (iSize+1) to sReturnValue
83015>>>>>>>    Move (|CI$10000 * iArg) to iArg // Shift column number 16 bits to the left
83016>>>>>>>    Call_Driver 0 MertechInc_DriverName Function 24 CALLBACK 0 PASSING sReturnValue MertechInc_Blank iArg RESULT MertechInc_iRet
83021>>>>>>>
83021>>>>>>>    Function_Return sReturnValue
83022>>>>>>>End_Function
83023>>>>>>>
83023>>>>>>>//=============================================================================
83023>>>>>>>/// @Name        SET_SCHEMA_NAME
83023>>>>>>>/// @Description This command is used to set the schema name to be used when
83023>>>>>>>/// opening tables. Note that this command will override the schema name that
83023>>>>>>>/// is set in the INT file.  The default schema for the current user is used
83023>>>>>>>/// when no name is set.
83023>>>>>>>///
83023>>>>>>>/// @Assumptions
83023>>>>>>>/// @Status      Public
83023>>>>>>>/// @Drivers     SQLFlex and ORAFlex
83023>>>>>>>/// @VersionNote Last Revised: 2013-09-24 by Aaron Gulack
83023>>>>>>>/// @See                 GET_SCHEMA_NAME
83023>>>>>>>///
83023>>>>>>>/// @Syntax SET_SCHEMA_NAME to {schema}
83023>>>>>>>/// @Param variable                     Name of the schema
83023>>>>>>>///
83023>>>>>>>/// @Example
83023>>>>>>>/// SET_SCHEMA_NAME to 'CustomerSchema'
83023>>>>>>>/// OPEN "CUSTOMER.INT" as CUSTOMER
83023>>>>>>>/// SET_SCHEMA_NAME to 'SalesSchema'
83023>>>>>>>/// OPEN "SALESP.INT" as SALESP
83023>>>>>>>
83023>>>>>>>//=============================================================================
83023>>>>>>>/// @Name        GET_SCHEMA_NAME
83023>>>>>>>/// @Description This command is used to get the name of the schema being
83023>>>>>>>/// used to open tables.
83023>>>>>>>///
83023>>>>>>>/// @Assumptions
83023>>>>>>>/// @Status      Public
83023>>>>>>>/// @Drivers     SQLFlex and ORAFlex
83023>>>>>>>/// @VersionNote Last Revised: 2013-09-24 by Aaron Gulack
83023>>>>>>>/// @See                 SET_SCHEMA_NAME
83023>>>>>>>///
83023>>>>>>>/// @Syntax GET_SCHEMA_NAME to {variable}
83023>>>>>>>/// @Param variable                     variable to hold the schema name
83023>>>>>>>///
83023>>>>>>>/// @Example
83023>>>>>>>/// GET_SCHEMA_NAME to sName
83023>>>>>>>/// Showln sName
83023>>>>>>>
83023>>>>>>>//=============================================================================
83023>>>>>>>/// @Name        CALL_ORACLE_STORED_PROCEDURE
83023>>>>>>>/// @Description This command is used to call a stored procedure on the SQL
83023>>>>>>>/// backend. To successfully call a procedure with this command, a string
83023>>>>>>>/// must be passed containing a valid procedure name. In addition, if the
83023>>>>>>>/// procedure takes any arguments, they must also be passed using the constant
83023>>>>>>>/// "passing" along with all of the needed arguments. If the procedure has a
83023>>>>>>>/// return value, then SQL_GET_FUNCTION_RETURN or SQL_FETCH_NEXT_ROW can be
83023>>>>>>>/// used to get the value(s). If an error is found then the indicator "Err"
83023>>>>>>>/// is set to true.
83023>>>>>>>///
83023>>>>>>>/// @Assumptions
83023>>>>>>>/// @Status      Deprecated
83023>>>>>>>/// @Drivers     ORAFLex
83023>>>>>>>/// @VersionNote Last Revised: 2013-09-25 by Aaron Gulack
83023>>>>>>>/// @See                 CALL_STORED_PROCEDURE
83023>>>>>>>///
83023>>>>>>>/// @Syntax CALL_ORACLE_STORED_PROCEDURE {procedure} Passing {variable}
83023>>>>>>>/// @Param procedure            Full name of the procedure
83023>>>>>>>/// @Param variable                     Argument being passed to procedure (can be multiple)
83023>>>>>>>///
83023>>>>>>>/// @Example
83023>>>>>>>/// CALL_ORACLE_STORED_PROCEDURE "sys.sp_addmessage" passing 50003 15 "Please enter a valid date"
83023>>>>>>>
83023>>>>>>>//=============================================================================
83023>>>>>>>/// @Name        SQL_SET_PROCEDURE_NAME
83023>>>>>>>/// @Description This command is used to set the procedure to be executed.
83023>>>>>>>/// This is used when the procedure is being split up into multiple lines
83023>>>>>>>/// as shown below. When using this command, SQL_PROCEDURE_EXECUTE must be
83023>>>>>>>/// called after all parameters have been set to successfully execute the
83023>>>>>>>/// procedure. The constant "NUMPAR" is used to indicate how many parameters
83023>>>>>>>/// will be passed.
83023>>>>>>>///
83023>>>>>>>/// @Assumptions The procedure is a valid procedure in the SQL database
83023>>>>>>>/// @Status      Public
83023>>>>>>>/// @Drivers     All
83023>>>>>>>/// @VersionNote Last Revised: 2013-09-25 by Aaron Gulack
83023>>>>>>>/// @See                 SQL_SET_PROCEDURE_PARAMETER SQL_PROCEDURE_EXECUTE
83023>>>>>>>///
83023>>>>>>>/// @Syntax SQL_SET_PROCEDURE_NAME {procedure} NUMPAR {variable}
83023>>>>>>>/// @Param procedure            Full name of the procedure
83023>>>>>>>/// @Param variable                     Number of parameters to be passed
83023>>>>>>>///
83023>>>>>>>/// @Example
83023>>>>>>>/// SQL_SET_PROCEDURE_NAME "sys.sp_addmessage" NUMPAR 3
83023>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to 500004 IN
83023>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 2 to 15 IN
83023>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 3 to "Please enter a valid Date" IN
83023>>>>>>>/// SQL_PROCEDURE_EXECUTE
83023>>>>>>>
83023>>>>>>>
83023>>>>>>>Procedure MertechInc_SQL_SET_ORAPROCEDURE_NAME Global String strProcName Integer iNumpar
83025>>>>>>>    Integer iParam
83025>>>>>>>
83025>>>>>>>    Move 0 to MertechInc_iParamCount       //Redundant, but left in incase called
83026>>>>>>>    INDICATE ERR False              //directly and not via SQL_SET_PROCEDURE_NAME
83027>>>>>>>    Move ORAFlex to MertechInc_DriverName  //
83028>>>>>>>
83028>>>>>>>    SQL_SET_STMT to "BEGIN "
83036>>>>>>>    SQL_APPEND_STMT to strProcName
83044>>>>>>>    SQL_APPEND_STMT to "( "
83052>>>>>>>    For iParam from 1 to iNumpar
83058>>>>>>>>
83058>>>>>>>        DO_PASS_ARGUMENTS iParam
83090>>>>>>>    Loop
83091>>>>>>>>
83091>>>>>>>    SQL_APPEND_STMT to  " ); END;"
83099>>>>>>>    SQL_PREPARE_STMT
83111>>>>>>> End_Procedure
83112>>>>>>>
83112>>>>>>>Procedure MertechInc_SQL_SET_MYPROCEDURE_NAME Global String strProcName Integer iNumpar
83114>>>>>>>    Integer iParam
83114>>>>>>>
83114>>>>>>>    Move 0 to MertechInc_iParamCount           //Redundant, but left in incase called
83115>>>>>>>    INDICATE ERR False                  //directly and not via SQL_SET_PROCEDURE_NAME
83116>>>>>>>    Move MySQLFlex to MertechInc_DriverName    //
83117>>>>>>>
83117>>>>>>>    SQL_SET_STMT to "CALL "
83125>>>>>>>    SQL_APPEND_STMT to strProcName
83133>>>>>>>    SQL_APPEND_STMT to "("
83141>>>>>>>    For iParam from 1 to iNumpar
83147>>>>>>>>
83147>>>>>>>        DO_PASS_ARGUMENTS iParam
83179>>>>>>>    Loop
83180>>>>>>>>
83180>>>>>>>    SQL_APPEND_STMT to ")"
83188>>>>>>>    SQL_PREPARE_STMT
83200>>>>>>>End_Procedure
83201>>>>>>>
83201>>>>>>>Procedure MertechInc_SQL_SET_MSPROCEDURE_NAME Global String strProcName Integer iNumpar
83203>>>>>>>    Integer iParam
83203>>>>>>>    String  sParam
83203>>>>>>>
83203>>>>>>>    Move SQLFlex to MertechInc_DriverName
83204>>>>>>>
83204>>>>>>>    // This calling syntax is referred to as the "ODBC CALL escape sequence".  This syntax is
83204>>>>>>>    // advised over the execute command since CALL allows for the retrieval of the return codes
83204>>>>>>>    // from the call.
83204>>>>>>>    SQL_SET_STMT to "{? = CALL "
83212>>>>>>>    SQL_APPEND_STMT to strProcName
83220>>>>>>>
83220>>>>>>>    // Note that DO_PASS_ARGUMENTS can add the open paren for us, but only if the keyword "PASSING"
83220>>>>>>>    // is passed to it first time through.  This is a bit weird, so we ignore that and just add
83220>>>>>>>    // the open and close parens ourself to make things more clear.
83220>>>>>>>    If (iNumpar > 0) SQL_APPEND_STMT to " ("
83230>>>>>>>
83230>>>>>>>    For iParam from 1 to iNumpar
83236>>>>>>>>
83236>>>>>>>        DO_PASS_ARGUMENTS iParam
83268>>>>>>>    Loop
83269>>>>>>>>
83269>>>>>>>
83269>>>>>>>    If (iNumpar > 0) SQL_APPEND_STMT to ")"
83279>>>>>>>    SQL_APPEND_STMT to  " };"
83287>>>>>>>
83287>>>>>>>    SQL_PREPARE_STMT
83299>>>>>>>
83299>>>>>>>    // This bind parameter is for the "{? = " which is technically the first parameter even though
83299>>>>>>>    // it is the return value.  The driver will bind MertechInc_iWork to it.
83299>>>>>>>    DO_BIND_PARAMETERS MertechInc_iWork
83322>>>>>>>End_Procedure
83323>>>>>>>
83323>>>>>>>Procedure MertechInc_SQL_SET_PGPROCEDURE_NAME Global String strProcName Integer iNumpar
83325>>>>>>>    Integer iParam
83325>>>>>>>    String  sParam
83325>>>>>>>
83325>>>>>>>    Move PgFlex to MertechInc_DriverName
83326>>>>>>>
83326>>>>>>>    // For Postgres, you can call a function just by passing the function name and
83326>>>>>>>    // open/close parens
83326>>>>>>>    SQL_SET_STMT to strProcName
83334>>>>>>>
83334>>>>>>>    // Note that DO_PASS_ARGUMENTS can add the open paren for us, but only if the keyword "PASSING"
83334>>>>>>>    // is passed to it first time through.  This is a bit weird, so we ignore that and just add
83334>>>>>>>    // the open and close parens ourself to make things more clear.
83334>>>>>>>    SQL_APPEND_STMT to "( "
83342>>>>>>>
83342>>>>>>>    For iParam from 1 to iNumpar
83348>>>>>>>>
83348>>>>>>>        DO_PASS_ARGUMENTS iParam
83380>>>>>>>    Loop
83381>>>>>>>>
83381>>>>>>>
83381>>>>>>>    SQL_APPEND_STMT to ")"
83389>>>>>>>
83389>>>>>>>    SQL_PREPARE_STMT
83401>>>>>>>    // Indicate that a stored function will be executed - Query = 0, Procedure = 1, Function = 2
83401>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_EMBEDDED_SQL_TYPE CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank 1 RESULT MertechInc_iRet
83406>>>>>>>End_Procedure
83407>>>>>>>
83407>>>>>>>//=============================================================================
83407>>>>>>>/// @Name        SQL_GET_STMT
83407>>>>>>>/// @Description This command returns the last embedded SQL statement that
83407>>>>>>>/// was executed into a string. Optional parameters can be passed to specify
83407>>>>>>>/// what character to start the string at and also the maximum number of
83407>>>>>>>/// characters to allow for the string.
83407>>>>>>>///
83407>>>>>>>/// @Assumptions
83407>>>>>>>/// @Status      Public
83407>>>>>>>/// @Drivers     All
83407>>>>>>>/// @VersionNote Last Revised: 2013-09-24 by Aaron Gulack
83407>>>>>>>/// @See                 SQL_GET_STATEMENT
83407>>>>>>>///
83407>>>>>>>/// @Syntax SQL_GET_STMT to {variable} [{max} {start}]
83407>>>>>>>/// @Param variable                     SQL statement to be executed
83407>>>>>>>/// @Param max                          Indicates the maximum number of characters to get (optional)
83407>>>>>>>/// @Param start                        Indicates what character to start at for the returned string (optional)
83407>>>>>>>///
83407>>>>>>>/// @Example
83407>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
83407>>>>>>>/// SQL_PREPARE_STMT
83407>>>>>>>/// SQL_EXECUTE_STMT
83407>>>>>>>/// SQL_FETCH_NEXT_ROW into sFirstName sLastName
83407>>>>>>>/// If (Found) Begin
83407>>>>>>>///     Showln sFirstName
83407>>>>>>>///     Showln sLastName
83407>>>>>>>/// End
83407>>>>>>>///
83407>>>>>>>/// SQL_GET_STATEMENT to sValue
83407>>>>>>>/// Showln sValue
83407>>>>>>>
83407>>>>>>>
83407>>>>>>>Function MertechInc_SQL_GET_STATEMENT Global Integer iLength Integer iStart Returns String
83409>>>>>>>    String sStatement
83409>>>>>>>
83409>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
83411>>>>>>>
83411>>>>>>>    If (MertechInc_FileNumber <> -1) Begin
83413>>>>>>>        Get MertechInc_Pre_Size_String 0 to sStatement
83414>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_GET_SQL_STMT CALLBACK 0 PASSING sStatement iStart iLength RESULT MertechInc_iRet
83419>>>>>>>    End
83419>>>>>>>>
83419>>>>>>>    Function_Return sStatement
83420>>>>>>>End_Function
83421>>>>>>>
83421>>>>>>>//=============================================================================
83421>>>>>>>/// @Name        SQL_SET_FUNCTION_NAME
83421>>>>>>>/// @Description This command is used in the same way as SQL_SET_PROCEDURE_NAME
83421>>>>>>>/// and SQL_SET_STMT to set the name of the function to be executed. When
83421>>>>>>>/// calling SQL functions in this fashion, this command must be used along with
83421>>>>>>>/// SQL_FUNCTION_EXECUTE (to execute the function), SQL_SET_FUNCTION_PARAMETER
83421>>>>>>>/// (to set the needed parameters) and SQL_GET_FUNCTION_RETURN (to get any
83421>>>>>>>/// returned value). The number of parameters must be set using the constant,
83421>>>>>>>/// NUMPAR, followed by the number of parameters. Note that when setting the
83421>>>>>>>/// name of the function, the user can be specified or, if left blank, the
83421>>>>>>>/// current user will be inserted before the function name.
83421>>>>>>>///
83421>>>>>>>/// @Assumptions
83421>>>>>>>/// @Status      Public
83421>>>>>>>/// @Drivers     All
83421>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
83421>>>>>>>/// @See                 SQL_FUNCTION_EXECUTE SQL_SET_FUNCTION_PARAMETER SQL_GET_FUNCTION_RETURN
83421>>>>>>>///
83421>>>>>>>/// @Syntax SQL_SET_FUNCTION_NAME {function} NUMPAR {parameters}
83421>>>>>>>/// @Param function                     Full name of the function
83421>>>>>>>/// @Param parameters           Number of parameters to pass
83421>>>>>>>///
83421>>>>>>>/// @Example
83421>>>>>>>/// SQL_SET_FUNCTION_NAME "getCustomerStatus" NUMPAR 1
83421>>>>>>>/// SQL_SET_FUNCTION_PARAMETER 1 to 'Jones' IN
83421>>>>>>>/// SQL_FUNCTION_EXECUTE
83421>>>>>>>/// SQL_GET_FUNCTION_RETURN to dDOB
83421>>>>>>>/// Showln dDOB
83421>>>>>>>
83421>>>>>>>Procedure MertechInc_SQL_SET_ORAFUNCTION_NAME Global String strProcName Integer iNumpar
83423>>>>>>>    Integer iParam
83423>>>>>>>
83423>>>>>>>    SQL_SET_STMT to "BEGIN "
83431>>>>>>>    SQL_APPEND_STMT to ":PAR_RET := "
83439>>>>>>>    SQL_APPEND_STMT to strProcName
83447>>>>>>>    SQL_APPEND_STMT to "( "
83455>>>>>>>    For iParam from 1 to iNumpar
83461>>>>>>>>
83461>>>>>>>        DO_PASS_ARGUMENTS iParam
83493>>>>>>>    Loop
83494>>>>>>>>
83494>>>>>>>    SQL_APPEND_STMT to  " ); END;"
83502>>>>>>>    SQL_PREPARE_STMT
83514>>>>>>>
83514>>>>>>>    Move IS_OUT to MertechInc_iArg
83515>>>>>>>    Call_Driver 0 ORAFLEX Function CALLDRV_SET_PROC_ATTRIBUTE_TYPE CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank MertechInc_iArg RESULT MertechInc_iRet
83520>>>>>>>
83520>>>>>>>    Increment MertechInc_iParamCount
83521>>>>>>>    Move ":PAR_RET" to MertechInc_sArg2
83522>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_BIND_PARAMETER CALLBACK 0 PASSING MertechInc_Blank MertechInc_sArg2 16384 RESULT MertechInc_iRet
83527>>>>>>>End_Procedure
83528>>>>>>>
83528>>>>>>>Procedure MertechInc_SQL_SET_MYFUNCTION_NAME Global String strProcName Integer iNumpar
83530>>>>>>>    Integer iParam
83530>>>>>>>
83530>>>>>>>    Move MySQLFlex to MertechInc_DriverName
83531>>>>>>>
83531>>>>>>>    SQL_SET_STMT to "SELECT "
83539>>>>>>>    SQL_APPEND_STMT to strProcName
83547>>>>>>>    SQL_APPEND_STMT to "("
83555>>>>>>>    For iParam from 1 to iNumpar
83561>>>>>>>>
83561>>>>>>>        DO_PASS_ARGUMENTS iParam
83593>>>>>>>    Loop
83594>>>>>>>>
83594>>>>>>>    SQL_APPEND_STMT to ")"
83602>>>>>>>    SQL_PREPARE_STMT
83614>>>>>>>End_Procedure
83615>>>>>>>
83615>>>>>>>Procedure MertechInc_SQL_SET_SQLFUNCTION_NAME Global String strProcName Integer iNumpar
83617>>>>>>>    Integer iParam
83617>>>>>>>
83617>>>>>>>    Move SQLFlex to MertechInc_DriverName
83618>>>>>>>
83618>>>>>>>    If (not(strProcName contains ".")) Begin
83620>>>>>>>        String schema
83620>>>>>>>        GET_SCHEMA_NAME to schema
83642>>>>>>>        Move (schema + "." + strProcName) to strProcName
83643>>>>>>>    End
83643>>>>>>>>
83643>>>>>>>
83643>>>>>>>    SQL_SET_STMT    to "SELECT "
83651>>>>>>>    SQL_APPEND_STMT to strProcName
83659>>>>>>>    SQL_APPEND_STMT to "("
83667>>>>>>>End_Procedure
83668>>>>>>>
83668>>>>>>>Procedure MertechInc_SQL_SET_PGFUNCTION_NAME Global String strProcName Integer iNumpar
83670>>>>>>>    Integer iParam
83670>>>>>>>
83670>>>>>>>    Move PgFlex to MertechInc_DriverName
83671>>>>>>>
83671>>>>>>>    SQL_SET_STMT    to "SELECT "
83679>>>>>>>    SQL_APPEND_STMT to strProcName
83687>>>>>>>    SQL_APPEND_STMT to "("
83695>>>>>>>End_Procedure
83696>>>>>>>
83696>>>>>>>//=============================================================================
83696>>>>>>>/// @Name        SQL_SET_PROCEDURE_PARAMETER
83696>>>>>>>/// @Description
83696>>>>>>>/// With this command you can pass one or more parameters to predefined
83696>>>>>>>/// stored procedures on a MySQL or Oracle server. The SQL_SET_PROCEDURE_PARAMETER
83696>>>>>>>/// command enables you to add a parameter to a stored procedure which you are
83696>>>>>>>/// planning to call. You can pass multiple parameters by calling the command
83696>>>>>>>/// for each parameter.
83696>>>>>>>///
83696>>>>>>>/// When passing parameters you'll have to inform the driver which variable
83696>>>>>>>/// you are passing, starting with 1 from left-to-right in the parameter list.
83696>>>>>>>///
83696>>>>>>>/// For each parameter you'll have to indicate if the variable is to be
83696>>>>>>>/// regarded as input, output or both.
83696>>>>>>>///
83696>>>>>>>///@Assumptions
83696>>>>>>>/// @Status      Public
83696>>>>>>>/// @Drivers     All
83696>>>>>>>/// @VersionNote Last Revised: 2013-09-27 by Aaron Gulack
83696>>>>>>>/// @See                 SQL_SET_PROCEDURE_NAME SQL_PROCEDURE_EXECUTE
83696>>>>>>>///
83696>>>>>>>/// @Syntax SQL_SET_PROCEDURE_PARAMETER {number} to {variable} {direction}
83696>>>>>>>/// @Param number                       Index number of the parameter being defined.
83696>>>>>>>/// @Param variable                     Variable holding the parameter to be passed.
83696>>>>>>>/// @Param direction            IN, OUT, IN_OUT, RSET, or leave blank
83696>>>>>>>///
83696>>>>>>>/// @Example
83696>>>>>>>/// SQL_SET_PROCEDURE_NAME "sys.sp_addmessage" NUMPAR 3
83696>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to 500004 IN
83696>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 2 to 15 IN
83696>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 3 to "Please enter a valid Date" IN
83696>>>>>>>/// SQL_PROCEDURE_EXECUTE
83696>>>>>>>
83696>>>>>>>
83696>>>>>>>
83696>>>>>>>//=============================================================================
83696>>>>>>>/// @Name        SQL_GET_PROCEDURE_PARAMETER
83696>>>>>>>/// @Description This command is used to get the value of a specific
83696>>>>>>>/// parameter associated with a stored procedure.  Although this
83696>>>>>>>/// command will work with any parameter, it is mostly be used with
83696>>>>>>>/// IN/OUT or OUT parameters as their value will more often be important
83696>>>>>>>/// once returned. When multiple values are returned, this command can be
83696>>>>>>>/// more efficient than other options. Note that the specified parameter
83696>>>>>>>/// must first be defined using the SQL_SET_PROCEDURE_PARAMETER command
83696>>>>>>>/// in order to work properly.
83696>>>>>>>///
83696>>>>>>>/// @Assumptions
83696>>>>>>>/// @Status      Public
83696>>>>>>>/// @Drivers     All
83696>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
83696>>>>>>>/// @See                 SQL_SET_PROCEDURE_NAME SQL_SET_PROCEDURE_PARAMETER SQL_PROCEDURE_EXECUTE
83696>>>>>>>///
83696>>>>>>>/// @Syntax SQL_GET_PROCEDURE_PARAMETER {parameter} to {variable}
83696>>>>>>>/// @Param parameter            Number of paramater to return
83696>>>>>>>/// @Param variable                     Variable to hold the value of the parameter
83696>>>>>>>///
83696>>>>>>>/// @Example
83696>>>>>>>/// SQL_SET_PROCEDURE_NAME "user.getCustomerStatus" NUMPAR 1
83696>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to sCustomerID IN_OUT
83696>>>>>>>/// SQL_PROCEDURE_EXECUTE
83696>>>>>>>/// SQL_GET_PROCEDURE_PARAMETER 1 to sStatus
83696>>>>>>>///
83696>>>>>>>/// Showln sStatus
83696>>>>>>>///
83696>>>>>>>/// @Example
83696>>>>>>>/// SQL_SET_PROCEDURE_NAME "user.getCustomerStatus" NUMPAR 2
83696>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to sCustomerID IN
83696>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 2 to sStatus OUT
83696>>>>>>>/// SQL_PROCEDURE_EXECUTE
83696>>>>>>>/// SQL_GET_PROCEDURE_PARAMETER 2 to sStatus
83696>>>>>>>///
83696>>>>>>>/// Showln sStatus
83696>>>>>>>
83696>>>>>>>
83696>>>>>>>
83696>>>>>>>//=============================================================================
83696>>>>>>>/// @Name        SQL_GET_FUNCTION_RETURN
83696>>>>>>>/// @Description This variable is used to get the value returned from a SQL
83696>>>>>>>/// function call. After the function has been successfully called, this
83696>>>>>>>/// command takes the returned value and inserts it the given variable.
83696>>>>>>>///
83696>>>>>>>/// @Assumptions
83696>>>>>>>/// @Status      Public
83696>>>>>>>/// @Drivers     All
83696>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
83696>>>>>>>/// @See                 SQL_SET_FUNCTION_NAME SQL_SET_FUNCTION_PARAMETER SQL_FUNCTION_EXECUTE
83696>>>>>>>///
83696>>>>>>>/// @Syntax SQL_GET_FUNCTION_RETURN to {variable}
83696>>>>>>>/// @Param variable                     Variable to hold the returned value
83696>>>>>>>///
83696>>>>>>>/// @Example
83696>>>>>>>/// SQL_SET_FUNCTION_NAME "getCustomerStatus" NUMPAR 1
83696>>>>>>>/// SQL_SET_FUNCTION_PARAMETER 1 to 'Jones' IN
83696>>>>>>>/// SQL_FUNCTION_EXECUTE
83696>>>>>>>/// SQL_GET_FUNCTION_RETURN to dDOB
83696>>>>>>>/// Showln dDOB
83696>>>>>>>
83696>>>>>>>//=============================================================================
83696>>>>>>>/// @Name        SQL_FUNCTION_EXECUTE
83696>>>>>>>/// @Description This command is used to execute the function statement
83696>>>>>>>/// that was built by the SQL_SET_FUNCTION_NAME and subsequent
83696>>>>>>>/// SQL_SET_FUNCTION_PARAMETER commands. This works similarly to the
83696>>>>>>>/// SQL_EXECUTE_STMT command. Note that executing the function with this
83696>>>>>>>/// command will not get any returned values but will simply execute the
83696>>>>>>>/// function.
83696>>>>>>>///
83696>>>>>>>/// @Assumptions
83696>>>>>>>/// @Status      Public
83696>>>>>>>/// @Drivers     All
83696>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
83696>>>>>>>/// @See                 SQL_SET_FUNCTION_NAME SQL_SET_FUNCTION_PARAMETER SQL_GET_FUNCTION_RETURN
83696>>>>>>>///
83696>>>>>>>/// @Syntax SQL_FUNCTION_EXECUTE
83696>>>>>>>///
83696>>>>>>>/// @Example
83696>>>>>>>/// SQL_SET_FUNCTION_NAME "getCustomerStatus" NUMPAR 1
83696>>>>>>>/// SQL_SET_FUNCTION_PARAMETER 1 to 'Jones' IN
83696>>>>>>>/// SQL_FUNCTION_EXECUTE
83696>>>>>>>/// SQL_GET_FUNCTION_RETURN to dDOB
83696>>>>>>>/// Showln dDOB
83696>>>>>>>
83696>>>>>>>Procedure MertechInc_SQL_FUNCTION_EXECUTE Global String sDriverName
83698>>>>>>>    Integer iParam
83698>>>>>>>    String  sParam
83698>>>>>>>
83698>>>>>>>    If (sDriverName = SQLFLEX or sDriverName = PgFlex) Begin
83700>>>>>>>       SQL_APPEND_STMT to ')'
83708>>>>>>>       SQL_PREPARE_STMT
83720>>>>>>>    End
83720>>>>>>>>
83720>>>>>>>
83720>>>>>>>    SQL_EXECUTE_STMT
83735>>>>>>>    If (sDriverName <> ORAFLEX) Begin
83737>>>>>>>        SQL_FETCH_NEXT_ROW
83752>>>>>>>>
83752>>>>>>>    End
83752>>>>>>>>
83752>>>>>>>End_Procedure
83753>>>>>>>
83753>>>>>>>//=============================================================================
83753>>>>>>>/// @Name        REEXEC_ORACLE_STORED_PROCEDURE
83753>>>>>>>/// @Description This command is used to re-execute a stored procedure
83753>>>>>>>/// when using Oracle. Although it follows the same format as
83753>>>>>>>/// CALL_STORED_PROCEDURE, it can be useful because it does not need to
83753>>>>>>>/// prepare the procedure again before executing. This can cause speed
83753>>>>>>>/// improvements when calling a stored procedure multiple times.
83753>>>>>>>///
83753>>>>>>>/// @Assumptions A procedure has already been created through CALL_STORED_PROCEDURE
83753>>>>>>>/// @Status      Public
83753>>>>>>>/// @Drivers     ORAFLex
83753>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
83753>>>>>>>/// @See                 CALL_STORED_PROCEDURE
83753>>>>>>>///
83753>>>>>>>/// @Syntax CALL_ORACLE_STORED_PROCEDURE {procedure} Passing {variable}
83753>>>>>>>/// @Param procedure            Full name of the procedure
83753>>>>>>>/// @Param variable                     Parameter to pass (optional and can be multiple)
83753>>>>>>>///
83753>>>>>>>/// @Example
83753>>>>>>>/// CALL_STORED_PROCEDURE "user.getCustomerStatus" Passing sCustomerID sStatus
83753>>>>>>>/// Showln sStatus
83753>>>>>>>///
83753>>>>>>>/// Move (sCustomerID + 1) to sCustomerID
83753>>>>>>>///
83753>>>>>>>/// REEXEC_ORACLE_STORED_PROCEDURE "user.getCustomerStatus" passing sCustomerID sStatus
83753>>>>>>>/// Showln sStatus
83753>>>>>>>
83753>>>>>>>
83753>>>>>>>//=============================================================================
83753>>>>>>>/// @Name        CALL_STORED_FUNCTION
83753>>>>>>>/// @Description This command is used to execute a function stored in the
83753>>>>>>>/// SQL backend. This is an alternative to building a function with the
83753>>>>>>>/// SQL_SET_FUNCTION_NAME, SQL_SET_FUNCTION_PARAMETER and SQL_FUNCTION_EXECUTE
83753>>>>>>>/// commands. This command builds and executes the function by setting the full
83753>>>>>>>/// function name, the parameter(s) to pass and the variable to hold the
83753>>>>>>>/// returned value. Note that this command can only return a single value
83753>>>>>>>/// so SQL_SET_FUNCTION_PARAMETER and SQL_SET_FUNCTION_NAME must be used when
83753>>>>>>>/// dealing with multiple return values.
83753>>>>>>>///
83753>>>>>>>/// Assumptions
83753>>>>>>>/// @Status      Public
83753>>>>>>>/// @Drivers     ORAFLex MySQLFlex PgFlex
83753>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
83753>>>>>>>/// @See
83753>>>>>>>///
83753>>>>>>>/// @Syntax CALL_STORED_FUNCTION {function} Returns {variable} Passing {parameters}
83753>>>>>>>/// @Param function                     Full name of the function
83753>>>>>>>/// @Param variable                     Variable to hold the returned value
83753>>>>>>>/// @Param parameters           Parameter to pass to the function (can be multiple)
83753>>>>>>>///
83753>>>>>>>/// @Example
83753>>>>>>>/// Move 5 to sCustomerID
83753>>>>>>>/// CALL_STORED_FUNCTION "getCustomerStatus" Returns sStatus Passing sCustomerID
83753>>>>>>>/// Showln sStatus
83753>>>>>>>
83753>>>>>>>//=============================================================================
83753>>>>>>>/// @Name        OUTPUT_INT_FILE
83753>>>>>>>/// @Description This command is used to output the int file of an opened
83753>>>>>>>/// table. If the file to be output to does not exist, it will be created
83753>>>>>>>/// upon execution of this command. Note that the INT file can be output
83753>>>>>>>/// into multiple types of files i.e. .doc, .txt, .int.
83753>>>>>>>///
83753>>>>>>>/// @Assumptions
83753>>>>>>>/// @Status      Public
83753>>>>>>>/// @Drivers     All
83753>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
83753>>>>>>>/// @See
83753>>>>>>>///
83753>>>>>>>/// @Syntax OUTPUT_INT_FILE for {FileNumber} to {variable}
83753>>>>>>>/// @Param FileNumber           The file number
83753>>>>>>>/// @Param variable                     Path of the file being output to
83753>>>>>>>///
83753>>>>>>>///@Example
83753>>>>>>>/// OUTPUT_INT_FILE for Customer.File_Number to "C:\Temp\Customer.int"
83753>>>>>>>
83753>>>>>>>//=============================================================================
83753>>>>>>>/// @Name        SQL_ERROR_MESSAGE
83753>>>>>>>/// @Description This command is used to get an error message
83753>>>>>>>/// from a given SQL statement. If the given statement is executed with
83753>>>>>>>/// no errors, the variable specified with this command will be blank.
83753>>>>>>>/// Otherwise the message will be stored in the given variable. Note that
83753>>>>>>>/// unless specified, strings have a size limit of 80 characters, so using
83753>>>>>>>/// a variant can ensure the full message is retrieved.
83753>>>>>>>///
83753>>>>>>>/// @Assumptions
83753>>>>>>>/// @Status      Public
83753>>>>>>>/// @Drivers     All
83753>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
83753>>>>>>>/// @See         SQL_ERROR_MESSAGE2
83753>>>>>>>///
83753>>>>>>>/// @Syntax SQL_ERROR_MESSAGE {variable}
83753>>>>>>>/// @Param variable                     Variable to hold the error message
83753>>>>>>>///
83753>>>>>>>/// @Example
83753>>>>>>>/// SQL_ERROR_MESSAGE sError
83753>>>>>>>
83753>>>>>>>Function MertechInc_SQL_ERROR_MESSAGE Global Returns String
83755>>>>>>>    String sMessage
83755>>>>>>>
83755>>>>>>>    Get MertechInc_Pre_Size_String 0 to sMessage
83756>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_SQL_ERROR_MESSAGE CALLBACK 0 PASSING MertechInc_Blank sMessage 0 RESULT MertechInc_iRet
83761>>>>>>>
83761>>>>>>>    Function_Return sMessage
83762>>>>>>>End_Function
83763>>>>>>>
83763>>>>>>>//=============================================================================
83763>>>>>>>/// @Name        SQL_ERROR_MESSAGE2
83763>>>>>>>/// @Description This command is used to get the last error message used
83763>>>>>>>/// for the specified server. This can be useful once a transaction has
83763>>>>>>>/// already been completed and any error messages need to be retrieved.
83763>>>>>>>///
83763>>>>>>>/// @Assumptions
83763>>>>>>>/// @Status      Public
83763>>>>>>>/// @Drivers     All
83763>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
83763>>>>>>>/// @See         SQL_ERROR_MESSAGE SQL_ERROR_MESSAGE2
83763>>>>>>>///
83763>>>>>>>/// @Syntax SQL_ERROR_MESSAGE2 of {server} to {variable}
83763>>>>>>>/// @Param server                       Name of the server
83763>>>>>>>/// @Param variable                     Variable to hold the error message
83763>>>>>>>///
83763>>>>>>>/// @Example
83763>>>>>>>/// SQL_ERROR_MESSAGE2 of "localhost" to sError
83763>>>>>>>
83763>>>>>>>Function MertechInc_SQL_ERROR_MESSAGE2 Global String sServer Returns String
83765>>>>>>>    String sMessage
83765>>>>>>>
83765>>>>>>>    Get MertechInc_Pre_Size_String 800 to sMessage
83766>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_SQL_ERROR_MESSAGE2 CALLBACK 0 PASSING sServer sMessage 0 RESULT MertechInc_iRet
83771>>>>>>>
83771>>>>>>>    Function_Return sMessage
83772>>>>>>>End_Function
83773>>>>>>>
83773>>>>>>>//=============================================================================
83773>>>>>>>/// @Name        MERTECH_WARNING_MESSAGE
83773>>>>>>>/// @Description When restructuring a table, i.e. Structure_Start, a warning
83773>>>>>>>/// message will appear to confirm the restructure before it is executed.
83773>>>>>>>/// This command is used to disable or enable that warning message. All that
83773>>>>>>>/// is passed is either the constant "Enabled" or "Disabled". By default,
83773>>>>>>>/// this message is enabled.
83773>>>>>>>///
83773>>>>>>>/// @Assumptions
83773>>>>>>>/// @Status      Public
83773>>>>>>>/// @Drivers     All
83773>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
83773>>>>>>>///
83773>>>>>>>/// @Syntax MERTECH_WARNING_MESSAGE {Enabled|Disabled}
83773>>>>>>>/// @Param Enabled                      Enables the restructure warning
83773>>>>>>>/// @Param Disabled                     Disables the restructure warning
83773>>>>>>>///
83773>>>>>>>/// @Example
83773>>>>>>>/// Move Customer.File_Number to hFile
83773>>>>>>>/// MERTECH_WARNING_MESSAGE Disabled
83773>>>>>>>///
83773>>>>>>>/// Structure_Start hFile
83773>>>>>>>///     Set_Attribute DF_FILE_OEM_TRANSLATION of hFile to True
83773>>>>>>>/// Structure_End hFile
83773>>>>>>>
83773>>>>>>>//=============================================================================
83773>>>>>>>/// @Name        DISABLE_SELECT_COLUMNS_ERRORS
83773>>>>>>>/// @Description When using SELECT_COLUMNS_FIND to limit the number of columns
83773>>>>>>>/// to fetch, the framework might still ask for columns that you do not need.
83773>>>>>>>/// As a result you'll end up getting runtime errors you do not want to see.
83773>>>>>>>/// This command gives you the ability to stop reporting errors for querying
83773>>>>>>>/// for data from columns that are not part of the query.
83773>>>>>>>///
83773>>>>>>>/// DISABLED_SELECT_COLUMNS_ERRORS DISABLED will disable the errors, use
83773>>>>>>>/// ENABLED to turn the error messages back on.
83773>>>>>>>///
83773>>>>>>>/// By default triggering error messages on unknown columns is ENABLED
83773>>>>>>>///
83773>>>>>>>/// @Assumptions
83773>>>>>>>/// @Status      Public
83773>>>>>>>/// @Drivers     All
83773>>>>>>>/// @VersionNote Last Revised: 2014-04-28 by Wil van Antwerpen
83773>>>>>>>/// @See         SELECT_COLUMNS_FIND RESET_FETCH_FIELDS
83773>>>>>>>///
83773>>>>>>>/// @Example
83773>>>>>>>/// Open Customer
83773>>>>>>>/// RESET_FETCH_FIELDS  CUSTOMER DF_FETCH_FALSE
83773>>>>>>>/// SELECT_COLUMNS_FIND CUSTOMER CUSTOMER_NUMBER NAME
83773>>>>>>>/// DISABLE_SELECT_COLUMNS_ERRORS DISABLED
83773>>>>>>>///
83773>>>>>>>/// Clear Customer
83773>>>>>>>/// Repeat
83773>>>>>>>///    Find Gt Customer by Index.1
83773>>>>>>>///    If (Found) Showln Customer.Customer_Number '-' Customer.Name
83773>>>>>>>/// Until (Not(Found))
83773>>>>>>>///
83773>>>>>>>/// RESET_FETCH_FIELDS Customer DF_FETCH_TRUE
83773>>>>>>>///
83773>>>>>>>/// @Syntax DISABLE_SELECT_COLUMNS_ERRORS {ENABLED|DISABLED}
83773>>>>>>>
83773>>>>>>>//=============================================================================
83773>>>>>>>/// @Name        SQLFlex_REVISION
83773>>>>>>>/// @Description This command will put the current version (decimals included)
83773>>>>>>>/// of the MSSQL driver associated with the current workspace into the
83773>>>>>>>/// specified variable.
83773>>>>>>>///
83773>>>>>>>/// @Assumptions
83773>>>>>>>/// @Status      Deprecated
83773>>>>>>>/// @Drivers     SQLFlex
83773>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
83773>>>>>>>/// @See                 GET_DRIVER_REVISION
83773>>>>>>>///
83773>>>>>>>/// @Syntax SQLFlex_REVISION {variable}
83773>>>>>>>/// @Param variable                     String variable to hold the returned version
83773>>>>>>>///
83773>>>>>>>/// @Example
83773>>>>>>>/// SQLFlex_REVISION sVersion
83773>>>>>>>
83773>>>>>>>//=============================================================================
83773>>>>>>>/// @Name        SQLFlex_MAJOR_REVISION
83773>>>>>>>/// @Description This command will put the major version (no decimals) of
83773>>>>>>>/// the the MSSQL driver associated with the current workspace into the
83773>>>>>>>/// specified variable.
83773>>>>>>>///
83773>>>>>>>/// @Assumptions
83773>>>>>>>/// @Status      Deprecated
83773>>>>>>>/// @Drivers     SQLFlex
83773>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
83773>>>>>>>/// @See                 GET_DRIVER_MAJOR_REVISION
83773>>>>>>>///
83773>>>>>>>/// @Syntax SQLFlex_MAJOR_REVISION {variable}
83773>>>>>>>/// @Param variable                     String variable to hold the returned version
83773>>>>>>>///
83773>>>>>>>/// @Example
83773>>>>>>>/// SQLFlex_MAJOR_REVISION sVersion
83773>>>>>>>
83773>>>>>>>//=============================================================================
83773>>>>>>>/// @Name        LOGGED_USERS
83773>>>>>>>/// @Description This command returns the number of native users that are
83773>>>>>>>/// using the driver currently. This number is stored in the variable that
83773>>>>>>>/// is passed with the command.
83773>>>>>>>///
83773>>>>>>>/// @Assumptions
83773>>>>>>>/// @Status      Public
83773>>>>>>>/// @Drivers     All
83773>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
83773>>>>>>>/// @See                 MAXIMUM_NUMBER_OF_USERS
83773>>>>>>>///
83773>>>>>>>/// @Syntax LOGGED_USERS {variable}
83773>>>>>>>/// @Param variable                     Variable to hold the number of users
83773>>>>>>>///
83773>>>>>>>/// @Example LOGGED_USERS sUsers
83773>>>>>>>
83773>>>>>>>//=============================================================================
83773>>>>>>>/// @Name        MAXIMUM_NUMBER_OF_USERS
83773>>>>>>>/// @Description This command returns the maximum number of user allowed by
83773>>>>>>>/// the current license.
83773>>>>>>>///
83773>>>>>>>/// @Assumptions
83773>>>>>>>/// @Status      Public
83773>>>>>>>/// @Drivers     All
83773>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
83773>>>>>>>/// @See                 LOGGED_USERS
83773>>>>>>>///
83773>>>>>>>/// @Syntax MAXIMUM_NUMBER_OF_USERS {variable}
83773>>>>>>>/// @Param variable                     Variable to hold the maximum number of users
83773>>>>>>>///
83773>>>>>>>/// @Example
83773>>>>>>>/// MAXIMUM_NUMBER_OF_USERS sMax
83773>>>>>>>
83773>>>>>>>//=============================================================================
83773>>>>>>>/// @Name        SET_DATABASE_NAME
83773>>>>>>>/// @Description This command overrides the database set in the INT file
83773>>>>>>>/// under DATABASE_SPACE_NAME. Any opens or finds will use the database
83773>>>>>>>/// specified here. This can be used when the database is not stated in
83773>>>>>>>/// the INT file or if the database needs to be dynamically changed for
83773>>>>>>>/// a certain query. If the database is not specified with this command
83773>>>>>>>/// or in the INT file, then the default database for the server will be
83773>>>>>>>/// used. To set the database to be used for embedded SQL statements,
83773>>>>>>>/// use SQL_USE_DATABASE.
83773>>>>>>>///
83773>>>>>>>/// @Assumptions
83773>>>>>>>/// @Status      Public
83773>>>>>>>/// @Drivers     SQLFlex, MySQLFlex and PGFlex
83773>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
83773>>>>>>>/// @See                 GET_DATABASE_NAME SQL_USE_DATABASE
83773>>>>>>>/// @INTOPT              DATABASE_SPACE_NAME
83773>>>>>>>///
83773>>>>>>>/// @Syntax SET_DATABASE_NAME to {database}
83773>>>>>>>/// @Param database                     Name of the database
83773>>>>>>>///
83773>>>>>>>/// @Example
83773>>>>>>>/// Login "localhost" "user" "pas123" "sql_drv"
83773>>>>>>>/// SET_DATABASE_NAME to "TestDB"
83773>>>>>>>/// Open Customer
83773>>>>>>>
83773>>>>>>>//=============================================================================
83773>>>>>>>/// @Name        GET_DATABASE_NAME
83773>>>>>>>/// @Description This command is used to get the name of the database
83773>>>>>>>/// currently being used. The name of the database is returned into the
83773>>>>>>>/// specified string. Even though this command works either way, it is
83773>>>>>>>/// typically used when the INT file does not contain the DATABASE_SPACE_NAME.
83773>>>>>>>///
83773>>>>>>>/// @Assumptions
83773>>>>>>>/// @Status      Public
83773>>>>>>>/// @Drivers     SQLFlex, MySQLFlex and PgFlex
83773>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
83773>>>>>>>/// @See SET_DATABASE_NAME SQL_USE_DATABASE
83773>>>>>>>///
83773>>>>>>>/// @Syntax GET_DATABASE_NAME to {variable}
83773>>>>>>>/// @Param variable                     Variable to hold the database name
83773>>>>>>>///
83773>>>>>>>/// @Example
83773>>>>>>>/// GET_DATABASE_NAME to sDbName
83773>>>>>>>
83773>>>>>>>//=============================================================================
83773>>>>>>>/// @Name        GET_NAME_SPACE
83773>>>>>>>/// @Description This command returns the name space, or schema, being
83773>>>>>>>/// used with the current application.
83773>>>>>>>///
83773>>>>>>>/// @Assumptions
83773>>>>>>>/// @Status      Public
83773>>>>>>>/// @Drivers     PgFlex
83773>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
83773>>>>>>>/// @See                 SET_NAME_SPACE
83773>>>>>>>///
83773>>>>>>>/// @Syntax GET_NAME_SPACE to {variable}
83773>>>>>>>/// @Param variable                     Variable to hold the returned name space.
83773>>>>>>>///
83773>>>>>>>/// @Example
83773>>>>>>>/// GET_NAME_SPACE to sNameSpace
83773>>>>>>>
83773>>>>>>>//=============================================================================
83773>>>>>>>/// @Name        SET_NAME_SPACE
83773>>>>>>>/// @Description This command sets the name space, or schema, to be used
83773>>>>>>>/// for the application. In Postgres, schemas are objects where all the
83773>>>>>>>/// tables,views and indexes are stored. Separate schemas are used to
83773>>>>>>>/// specify relational data. Note that this command will override the
83773>>>>>>>/// NAME_SPACE value in the INT file.
83773>>>>>>>///
83773>>>>>>>/// @Assumptions
83773>>>>>>>/// @Status      Public
83773>>>>>>>/// @Drivers     PgFlex
83773>>>>>>>/// @VersionNote Last Revised: 2009-08-14 By Ian Smith
83773>>>>>>>/// @See                 GET_NAME_SPACE
83773>>>>>>>/// @INTOPT              NAME_SPACE
83773>>>>>>>///
83773>>>>>>>/// @Syntax SET_NAME_SPACE to {variable}
83773>>>>>>>/// @Param variable                     Name of the name space
83773>>>>>>>///
83773>>>>>>>/// @Example
83773>>>>>>>/// SET_NAME_SPACE to "public"
83773>>>>>>>
83773>>>>>>>//=============================================================================
83773>>>>>>>/// @Name        SQL_USE_DATABASE
83773>>>>>>>/// @Description This command is used to specify which database is used
83773>>>>>>>/// for SQL statements only. Any normal table queries or changes will
83773>>>>>>>/// still use the default database, this only effects SQL statements.
83773>>>>>>>/// If none is specified then the default database is used. This can
83773>>>>>>>/// be useful if a certain SQL statement needs to query data from a
83773>>>>>>>/// database not currently being used. Note that this only works if
83773>>>>>>>/// the table name is not fully qualified in the SQl statement, i.e.
83773>>>>>>>/// "TestDB.Customer".
83773>>>>>>>///
83773>>>>>>>/// @Assumptions
83773>>>>>>>/// @Status      Public
83773>>>>>>>/// @Drivers     SQLFlex MySQLFLex PgSQL
83773>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
83773>>>>>>>/// @See                 SET_DATABASE_NAME GET_DATABASE_NAME
83773>>>>>>>///
83773>>>>>>>/// @Syntax SQL_USE_DATABASE of {server} to {database}
83773>>>>>>>/// @Param server                       Name of the server (Postgre only)
83773>>>>>>>/// @Param database                     Name of the database
83773>>>>>>>///
83773>>>>>>>/// @Example
83773>>>>>>>/// SQL_USE_DATABASE "testDB"
83773>>>>>>>///
83773>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
83773>>>>>>>/// SQL_PREPARE_STMT
83773>>>>>>>/// SQL_EXECUTE_STMT
83773>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sFirstName sLastName
83773>>>>>>>/// If (Found) Begin
83773>>>>>>>///     Showln sFirstName
83773>>>>>>>///     Showln sLastName
83773>>>>>>>/// End
83773>>>>>>>/// SQL_CANCEL_QUERY_STMT
83773>>>>>>>
83773>>>>>>>//=============================================================================
83773>>>>>>>/// @Name        SET_CURRENT_SQL_SERVER
83773>>>>>>>/// @Description This command is used to set the server to be used when
83773>>>>>>>/// opening tables. It will override the SERVER_NAME token in the INT file.
83773>>>>>>>/// If the server is not specified in the INT file or with this command,
83773>>>>>>>/// then the server used during login will be used. This command is only
83773>>>>>>>/// needed when connecting to multiple SQL servers. To set the server to
83773>>>>>>>/// use for embedded SQL statements, use SET_CURRENT_SQL_SERVER_CONNECTION.
83773>>>>>>>///
83773>>>>>>>/// @Assumptions
83773>>>>>>>/// @Status      Public
83773>>>>>>>/// @Drivers     All
83773>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
83773>>>>>>>/// @See                 GET_CURRENT_SQL_SERVER  SET_CURRENT_SQL_SERVER_CONNECTION GET_CURRENT_SQL_SERVER_CONNECTION
83773>>>>>>>/// @INTOPT              SERVER_NAME
83773>>>>>>>///
83773>>>>>>>/// @Syntax SET_CURRENT_SQL_SERVER to {server}
83773>>>>>>>/// @Param server                       Name of the server
83773>>>>>>>///
83773>>>>>>>/// @Example
83773>>>>>>>/// SET_CURRENT_SQL_SERVER to "localhost"
83773>>>>>>>
83773>>>>>>>//IGS - removed. CURRENT_SERVER is a property of Validation_List_Mixin so this
83773>>>>>>>//               replace conflicts with the property SET message.
83773>>>>>>>//#Replace SET_CURRENT_SERVER SET_CURRENT_SQL_SERVER
83773>>>>>>>
83773>>>>>>>//=============================================================================
83773>>>>>>>/// @Name        GET_CURRENT_SQL_SERVER
83773>>>>>>>/// @Description This command returns the name of the server to be used
83773>>>>>>>/// for opening and querying tables.
83773>>>>>>>///
83773>>>>>>>/// @Assumptions
83773>>>>>>>/// @Status      Public
83773>>>>>>>/// @Drivers     All
83773>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
83773>>>>>>>/// @See SET_CURRENT_SQL_SERVER SET_CURRENT_SQL_SERVER_CONNECTION GET_CURRENT_SQL_SERVER_CONNECTION
83773>>>>>>>///
83773>>>>>>>/// @Syntax GET_CURRENT_SERVER to {variable}
83773>>>>>>>/// @Param variable                     Variable to hold the server name
83773>>>>>>>///
83773>>>>>>>/// @Example
83773>>>>>>>/// GET_CURRENT_SQL_SERVER to sServer
83773>>>>>>>
83773>>>>>>>//IGS - removed. CURRENT_SERVER is a property of Validation_List_Mixin so this
83773>>>>>>>//               replace conflicts with the property GET message.
83773>>>>>>>//#Replace GET_CURRENT_SERVER GET_CURRENT_SQL_SERVER
83773>>>>>>>
83773>>>>>>>//=============================================================================
83773>>>>>>>/// @Name        SET_CURRENT_SQL_SERVER_CONNECTION
83773>>>>>>>/// @Description This command is used to specify which server to use for
83773>>>>>>>/// embedded SQL statements. By default, the last logged in server will
83773>>>>>>>/// be used. Note that in addition to setting the server, this command
83773>>>>>>>/// also sets the driver to be used. This command is only needed when
83773>>>>>>>/// connecting to multiple servers. To set the server for opening tables,
83773>>>>>>>/// use SET_CURRENT_SQL_SERVER.
83773>>>>>>>///
83773>>>>>>>/// @Assumptions
83773>>>>>>>/// @Status      Public
83773>>>>>>>/// @Drivers     All
83773>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
83773>>>>>>>/// @See                 GET_CURRENT_SQL_SERVER_CONNECTION GET_CURRENT_SQL_SERVER SET_CURRENT_SQL_SERVER
83773>>>>>>>///
83773>>>>>>>/// @Syntax SET_CURRENT_SQL_SERVER_CONNECTION of {constant} to {server}
83773>>>>>>>/// @Param constant                     MYSQLFLEX, ORAFLEX, PGFLEX, or SQLFLEX
83773>>>>>>>/// @Param server               Name of the server
83773>>>>>>>///
83773>>>>>>>/// @Example
83773>>>>>>>/// SET_CURRENT_SQL_SERVER_CONNECTION of SQLFLEX to "(localdb)\v11.0"
83773>>>>>>>
83773>>>>>>>//=============================================================================
83773>>>>>>>/// @Name        GET_CURRENT_SQL_SERVER_CONNECTION
83773>>>>>>>/// @Description This command returns the server currently being used for
83773>>>>>>>/// embedded SQL statements.
83773>>>>>>>///
83773>>>>>>>/// @Assumptions
83773>>>>>>>/// @Status      Public
83773>>>>>>>/// @Drivers     All
83773>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
83773>>>>>>>/// @See                 SET_CURRENT_SQL_SERVER_CONNECTION GET_CURRENT_SQL_SERVER SET_CURRENT_SQL_SERVER
83773>>>>>>>///
83773>>>>>>>/// @Syntax GET_CURRENT_SQL_SERVER_CONNECTION of {constant} to {variable}
83773>>>>>>>/// @Param constant                     MYSQLFLEX, ORAFLEX, PGFLEX, or SQLFLEX
83773>>>>>>>/// @Param variable             Variable to hold the name of the server
83773>>>>>>>///
83773>>>>>>>/// @Example
83773>>>>>>>/// GET_CURRENT_SQL_SERVER_CONNECTION of SQLFLEX to sServer
83773>>>>>>>
83773>>>>>>>//=============================================================================
83773>>>>>>>/// @Name        LOGIN_SQLFLEX
83773>>>>>>>/// @Description This command allows the user to login with a specified
83773>>>>>>>/// hostname. The default hostname that is passed is the path of the
83773>>>>>>>/// executable. Passing a custom hostname can be very useful for tracking
83773>>>>>>>/// a specific user for different situations. For example, if a company
83773>>>>>>>/// is using a terminal server and a whole sales team logs in under the
83773>>>>>>>/// same username and hostname, locating a specific user could otherwise
83773>>>>>>>/// be difficult. With this command, each user can pass a custom hostname,
83773>>>>>>>/// easily distinguishing themselves from other users.
83773>>>>>>>///
83773>>>>>>>/// @Assumptions
83773>>>>>>>/// @Status      Public
83773>>>>>>>/// @Drivers     SQLFlex
83773>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
83773>>>>>>>/// @See
83773>>>>>>>///
83773>>>>>>>/// @Syntax LOGIN_SQLFLEX {server} {username} {password} {hostname}
83773>>>>>>>/// @Param server               Server to use for login
83773>>>>>>>/// @Param username     Username to use for login
83773>>>>>>>/// @Param password     Password to use for login
83773>>>>>>>/// @Param hostname     Hostname to use for login
83773>>>>>>>///
83773>>>>>>>/// @Example
83773>>>>>>>/// LOGIN_SQLFLEX "localhost" "guestUser" "pas123" "WIN-MM7PQS5CP6C"
83773>>>>>>>
83773>>>>>>>//=============================================================================
83773>>>>>>>/// @Name        SQL_CANCEL_QUERY_STMT
83773>>>>>>>/// @Description This command is used to close any open cursors related to
83773>>>>>>>/// an SQL_EXECUTE_STMT. This should be used once the SQL statement has
83773>>>>>>>/// been executed and all rows have been fetched.
83773>>>>>>>///
83773>>>>>>>/// @Assumptions
83773>>>>>>>/// @Status      Public
83773>>>>>>>/// @Drivers     All
83773>>>>>>>/// @VersionNote Last Revised: 2013-10-03 by Aaron Gulack
83773>>>>>>>/// @See                 SQL_SET_STMT SQL_EXECUTE_STMT SQL_FETCH_NEXT_ROW SQL_APPEND_STMT SQL_PREPARE_STMT
83773>>>>>>>///
83773>>>>>>>/// @Syntax SQL_CANCEL_QUERY_STMT [of {FileName}]
83773>>>>>>>/// @Param FileName             Name of the file (optional)
83773>>>>>>>///
83773>>>>>>>/// @Example
83773>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
83773>>>>>>>/// SQL_PREPARE_STMT
83773>>>>>>>/// SQL_BINDCOLUMNS_STMT of Customer to DF_BIND_ALL_COLUMNS
83773>>>>>>>/// SQL_EXECUTE_STMT of Customer
83773>>>>>>>/// SQL_FETCH_NEXT_ROW of Customer
83773>>>>>>>/// If (Found) Begin
83773>>>>>>>///     Showln Customer.FirstName
83773>>>>>>>///     Showln Customer.LastName
83773>>>>>>>/// End
83773>>>>>>>/// SQL_CANCEL_QUERY_STMT of Customer
83773>>>>>>>
83773>>>>>>>//=============================================================================
83773>>>>>>>/// @Name        NATIVE_OPTIMIZATION
83773>>>>>>>/// @Description Allows user to turn off the use of index hints on the native
83773>>>>>>>/// server. Setting this command to DEFAULT will cause the server to use the
83773>>>>>>>/// default settings for hints. Hints are off by default in Microsoft SQL
83773>>>>>>>/// Server but are on in Oracle. Care should be taken with changing the
83773>>>>>>>/// default, and should only be used if the diagnostics tool for your server
83773>>>>>>>/// indicates performance problems with the type of queries that are being
83773>>>>>>>/// generated. Note that this can be turned off or on for the whole server
83773>>>>>>>/// or just for a specific table.
83773>>>>>>>///
83773>>>>>>>/// DEFAULT             - The specified server's default settings
83773>>>>>>>/// USE_INDEXHINT       - All Index hints will be used
83773>>>>>>>/// NO_INDEXHINT        - No index hints will be used
83773>>>>>>>///
83773>>>>>>>/// @Assumptions
83773>>>>>>>/// @Status      Public
83773>>>>>>>/// @Drivers     SQLFlex, ORAFlex
83773>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
83773>>>>>>>/// @See
83773>>>>>>>///
83773>>>>>>>/// @Syntax NATIVE_OPTIMIZATION of {scopeLevel} {variable} to {constant}
83773>>>>>>>/// @Param scopeLevel           TABLE or SERVER. Indicates the scope of the setting
83773>>>>>>>/// @Param variable                     Either the name of the server or of the table
83773>>>>>>>/// @Param constant                     DEFAULT, USE_INDEXHINT, or NO_INDEXHINT
83773>>>>>>>///
83773>>>>>>>/// @Example
83773>>>>>>>/// NATIVE_OPTIMIZATION of SERVER "localhost" to USE_INDEXHINT
83773>>>>>>>
83773>>>>>>>//=============================================================================
83773>>>>>>>/// @Name        SET_ISOLATION_LEVEL
83773>>>>>>>/// @Description This command sets the locking and row versioning behavior
83773>>>>>>>/// for SQL statements. See the options below for information on the various
83773>>>>>>>/// effects they can have on transactions.
83773>>>>>>>///
83773>>>>>>>/// DEFAULT  - The default isolation level for the server (READ_COMMITTED
83773>>>>>>>/// for MSSQL).
83773>>>>>>>///
83773>>>>>>>/// READ_COMMITTED - This option is used to prevent dirty reads. A dirty
83773>>>>>>>/// read is when one transaction reads data from another transaction that
83773>>>>>>>/// has yet to be committed. If one transaction fails, the other now is
83773>>>>>>>/// dealing with invalid data. By setting the isolation level to
83773>>>>>>>/// READ_COMMITTED, dirty reads will be avoided by not allowing transactions
83773>>>>>>>/// to deal with any other data that has not been committed yet. However,
83773>>>>>>>/// in between statements within the current transaction, data can be changed
83773>>>>>>>/// by other transactions. This can result in phantom data or non-repeatable
83773>>>>>>>/// reads. Note that this can slow down performance speeds but is usually
83773>>>>>>>/// good practice.
83773>>>>>>>///
83773>>>>>>>/// READ_UNCOMMITTED - This option is the least restrictive isolation level.
83773>>>>>>>/// With this option, dirty reads are allowed, thus no exclusive locks are
83773>>>>>>>/// honored and modified data from one uncommitted transaction can be read
83773>>>>>>>/// by other transactions.
83773>>>>>>>///
83773>>>>>>>/// REPEATABLE_READ - This option is similar to the READ_COMMITTED option
83773>>>>>>>/// in that locks all placed on all transactions and uncommitted data from
83773>>>>>>>///     other transactions cannot be read, preventing dirty reads. However, unlike
83773>>>>>>>/// READ_COMMITTED, new rows that are added by other transactions can be read
83773>>>>>>>/// by the current transaction if it is retried, possibly resulting in phantom
83773>>>>>>>/// reads. This option should not be used unless there is a specific reason to
83773>>>>>>>/// do so.
83773>>>>>>>///
83773>>>>>>>/// SERIALIZABLE - This option is the most restrictive isolation level. With
83773>>>>>>>/// this option, no interaction is allowed between transactions until they
83773>>>>>>>/// have been committed. Similar to READ_COMMITTED, no transaction can deal
83773>>>>>>>/// with any uncommitted data. On top of that though, range locks are placed on
83773>>>>>>>/// all rows being modified until the current transaction is complete. Because
83773>>>>>>>/// concurrency is so low with this option, performance speeds can be much lower
83773>>>>>>>/// and so this should only be used when there is a specific reason to do so.
83773>>>>>>>///
83773>>>>>>>/// @Assumptions
83773>>>>>>>/// @Status      Public
83773>>>>>>>/// @Drivers     All
83773>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
83773>>>>>>>/// @See
83773>>>>>>>///
83773>>>>>>>/// @Syntax SET_ISOLATION_LEVEL of {server} to {constant}
83773>>>>>>>/// @Param server                       Name of the server
83773>>>>>>>/// @Param constant                     DEFAULT, READ_COMMITTED, READ_UNCOMMITTED, REPEATABLE_READ, or SERIALIZABLE
83773>>>>>>>///
83773>>>>>>>/// @Example
83773>>>>>>>/// LOGIN "localhost" "user" "pass123" "SQL_DRV"
83773>>>>>>>/// SET_ISOLATION_LEVEL of "localhost" to READ_COMMITTED
83773>>>>>>>
83773>>>>>>>//=============================================================================
83773>>>>>>>/// @Name        SET_SESSION_PARAMETER
83773>>>>>>>/// @Description There are two sets of code pages used in windows, ANSI and
83773>>>>>>>/// OEM. ANSI is what is commonly used now, but some data still uses the OEM
83773>>>>>>>/// code pages. When migrating data, this command is used to determine whether
83773>>>>>>>/// the OEM data will be translated to ANSI during the migration. For example,
83773>>>>>>>/// migrating passwords with special characters may call for different code
83773>>>>>>>/// pages. Sending true will convert the OEM data to ANSI, sending false will
83773>>>>>>>/// not. Both OEM_TO_ANSI and OEM_TRANSLATION_STATE do essentially the same
83773>>>>>>>/// thing, however since MSSQL has the functionality built in, OEM_TO_ANSI
83773>>>>>>>/// will use MSSQL's built in translation and thus only works with SQLFlex.
83773>>>>>>>/// OEM_TRANSLATION_STATE is internal and built into the driver so it works
83773>>>>>>>/// for all drivers. Note that if using custom entries with
83773>>>>>>>/// SET_CUSTOM_OEM_TO_ANSI then OEM_TRANSLATION_STATE must be used. Also, if
83773>>>>>>>/// there are already custom entries set then turning OEM_TRANSLATION_STATE
83773>>>>>>>/// on will automatically enable those custom translations.
83773>>>>>>>///
83773>>>>>>>/// @Assumptions
83773>>>>>>>/// @Status      Public
83773>>>>>>>/// @Drivers     All
83773>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
83773>>>>>>>/// @See                 SET_CUSTOM_OEM_TO_ANSI GET_CUSTOM_OEM_TO_ANSI
83773>>>>>>>///
83773>>>>>>>/// @Syntax SET_SESSION_PARAMETER {OEM_TO_ANSI/OEM_TRANSLATION_STATE} to {variable}
83773>>>>>>>/// @Param variable                     Boolean variable enabling or disabling translation
83773>>>>>>>///
83773>>>>>>>/// @Example
83773>>>>>>>/// SET_SESSION_PARAMETER OEM_TO_ANSI to True
83773>>>>>>>
83773>>>>>>>Procedure MertechInc_SET_CUSTOM_OEM_TO_ANSI Global Integer iChar Integer iOem Integer iAnsi
83775>>>>>>>    Move iChar to MertechInc_sArg1
83776>>>>>>>    move (String(iOem) + "," + String(iAnsi)) to MertechInc_sArg2
83777>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_LICENSE_ENVIRONMENT_SET CALLBACK 0 PASSING MertechInc_sArg1 MertechInc_sArg2 CALLDRV_SET_CUSTOM_OEM_TO_ANSI RESULT MertechInc_iRet
83782>>>>>>>    IF MertechInc_iRet EQ -1 INDICATE ERR TRUE
83785>>>>>>>End_Procedure
83786>>>>>>>
83786>>>>>>>//=============================================================================
83786>>>>>>>/// @Name        SET_CUSTOM_OEM_TO_ANSI
83786>>>>>>>/// @Description In very rare situations, a custom OEM to ANSI translation
83786>>>>>>>/// is needed. When that is the case, this command can be used to create
83786>>>>>>>/// those custom entries. This is done by passing the character numbered
83786>>>>>>>/// position, the OEM value and the ANSI value. Note that
83786>>>>>>>/// OEM_TRANSLATION_STATE must be set to true for these custom entries to
83786>>>>>>>/// work.
83786>>>>>>>///
83786>>>>>>>/// @Assumptions
83786>>>>>>>/// @Status      Public
83786>>>>>>>/// @Drivers     All
83786>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
83786>>>>>>>/// @See                 GET_CUSTOM_OEM_TO_ANSI SET_SESSION_PARAMETER
83786>>>>>>>///
83786>>>>>>>/// @Syntax SET_CUSTOM_OEM_TO_ANSI {character} to OEM {value1} ANSI {value2}
83786>>>>>>>/// @Param character            Numbered position (0-255) of the character
83786>>>>>>>/// @Param value1                       Character number for the OEM value
83786>>>>>>>/// @Param value2                       Character number for the ANSI value
83786>>>>>>>
83786>>>>>>>Procedure MertechInc_GET_CUSTOM_OEM_TO_ANSI Global Integer iChar Integer iOem Integer iAnsi
83788>>>>>>>    Move iChar to MertechInc_sArg1
83789>>>>>>>    Move (Repeat(" ", 255)) to MertechInc_sArg2
83790>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_LICENSE_ENVIRONMENT_SET CALLBACK 0 PASSING MertechInc_sArg1 MertechInc_sArg2 CALLDRV_GET_CUSTOM_OEM_TO_ANSI RESULT MertechInc_iRet
83795>>>>>>>    IF MertechInc_iRet EQ -1 INDICATE ERR TRUE
83798>>>>>>>End_Function
83799>>>>>>>
83799>>>>>>>//=============================================================================
83799>>>>>>>/// @Name        GET_CUSTOM_OEM_TO_ANSI
83799>>>>>>>/// @Description This command returns the custom OEM and ANSI values
83799>>>>>>>/// respectively for a given character. If there is no custom translation
83799>>>>>>>/// for the specified character then no error will be raised, but nothing
83799>>>>>>>/// will be returned.
83799>>>>>>>///
83799>>>>>>>/// @Assumptions There exists a custom translation for the specified character
83799>>>>>>>/// @Status      Public
83799>>>>>>>/// @Drivers     All
83799>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
83799>>>>>>>/// @See
83799>>>>>>>///
83799>>>>>>>/// @Syntax SET_CUSTOM_OEM_TO_ANSI {character} to OEM {value1} ANSI {value2}
83799>>>>>>>/// @Param character            Numbered position (0-255) of the character
83799>>>>>>>/// @Param value1                       Variable to hold the OEM value
83799>>>>>>>/// @Param value2                       Variable to hold the ANSI value
83799>>>>>>>
83799>>>>>>>//=============================================================================
83799>>>>>>>/// @Name        SET_AUTOMATIC_NUMERIC_DATATYPE_REMAPPING
83799>>>>>>>/// @Description This command toggles off and on the automatic numeric
83799>>>>>>>/// data type remapping built into SQLFlex. When adding or creating
83799>>>>>>>/// smaller numeric columns during a restructure, SQLFlex will change
83799>>>>>>>/// the type to a more specific data type i.e. smallint or tinyint since
83799>>>>>>>/// they are handled more efficiently by the server. Sending false to this
83799>>>>>>>/// command will force SQl to keep the column as a numeric field, preserving
83799>>>>>>>/// the length and precision. Passing true will leave the remapping up to the
83799>>>>>>>/// driver.
83799>>>>>>>///
83799>>>>>>>/// @Assumptions
83799>>>>>>>/// @Status      Public
83799>>>>>>>/// @Drivers     SQLFlex
83799>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
83799>>>>>>>/// @See
83799>>>>>>>///
83799>>>>>>>/// @Syntax SET_AUTOMATIC_NUMERIC_DATATYPE_REMAPPING to {variable}
83799>>>>>>>/// @Param variable                     Boolean variable enabling or disabling remapping
83799>>>>>>>///
83799>>>>>>>/// @Example
83799>>>>>>>/// Structure_Start hFile
83799>>>>>>>///
83799>>>>>>>///     Create_Field hFile
83799>>>>>>>///
83799>>>>>>>///     SET_AUTOMATIC_NUMERIC_DATATYPE_REMAPPING to False
83799>>>>>>>///
83799>>>>>>>///     Set_Attribute DF_FIELD_NAME   of hFile iColumn to "Transaction_Count"
83799>>>>>>>///     Set_Attribute DF_FIELD_TYPE   of hFile iColumn to DF_BCD
83799>>>>>>>///     Set_Attribute DF_FIELD_LENGTH of hFile iColumn to 1
83799>>>>>>>///
83799>>>>>>>/// Structure_End hFile
83799>>>>>>>
83799>>>>>>>//=============================================================================
83799>>>>>>>/// @Name        SET_FORCE_DATE_FORMAT_INIT
83799>>>>>>>/// @Description At times, a stored procedure, function or trigger may
83799>>>>>>>/// alter the default format for dates. This could cause problems because,
83799>>>>>>>/// for example, if a trigger on a table does this, then every time a save
83799>>>>>>>/// takes place on that table, the format for dates will be changed. By
83799>>>>>>>/// sending true to this command, the date formats will reset to their
83799>>>>>>>/// default format. Note that this is essentially the same thing as running
83799>>>>>>>/// the SQL statement: "ALTER SESSION SET NLS_DATE_FORMAT='MM/DD/YYYY'", so
83799>>>>>>>/// in most situations, that should be used instead of this command.
83799>>>>>>>///
83799>>>>>>>/// @Assumptions
83799>>>>>>>/// @Status      Deprecated
83799>>>>>>>/// @Drivers     ORAFlex
83799>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
83799>>>>>>>/// @See
83799>>>>>>>///
83799>>>>>>>/// @Syntax SET_FORCE_DATE_FORMAT_INIT to {variable}
83799>>>>>>>/// @Param variable             Boolean variable enabling or disabling format reset
83799>>>>>>>
83799>>>>>>>//=============================================================================
83799>>>>>>>/// @Name        SET_STATIC_TABLE_OPTIMIZATION
83799>>>>>>>/// @Description At this time, this command no longer serves any function.
83799>>>>>>>///
83799>>>>>>>/// @Assumptions
83799>>>>>>>/// @Status      Deprecated
83799>>>>>>>/// @Drivers     SQLFlex
83799>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
83799>>>>>>>/// @See
83799>>>>>>>///
83799>>>>>>>/// @Syntax SET_STATIC_TABLE_OPTIMIZATION to {ENABLED/DISABLED}
83799>>>>>>>
83799>>>>>>>//=============================================================================
83799>>>>>>>/// @Name        GET_MAX_OBJECT_NAME_LENGTH
83799>>>>>>>/// @Description This command returns the maximum length allowed for object
83799>>>>>>>/// names in the SQl backend. This includes table names, column names,
83799>>>>>>>/// database names etc. The maximum length in put into the specified variable.
83799>>>>>>>///
83799>>>>>>>/// @Assumptions
83799>>>>>>>/// @Status      Public
83799>>>>>>>/// @Drivers     All
83799>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
83799>>>>>>>/// @See
83799>>>>>>>///
83799>>>>>>>/// @Syntax GET_MAX_OBJECT_NAME_LENGTH to {variable}
83799>>>>>>>/// @Param variable                     Variable to hold the maximum length
83799>>>>>>>///
83799>>>>>>>/// @Example
83799>>>>>>>/// GET_MAX_OBJECT_NAME_LENGTH to iMaxLength
83799>>>>>>>
83799>>>>>>>//=============================================================================
83799>>>>>>>/// @Name        SET_SQL_LOCK_TIMEOUT
83799>>>>>>>/// @Description This command is used to set the number of milliseconds
83799>>>>>>>/// an SQL statement waits for a database lock to be released before timing
83799>>>>>>>/// out. Locks are used with transactions to maintain atomicity. If a lock is
83799>>>>>>>/// not released before the timeout, then the statement will fail and an error
83799>>>>>>>/// will be raised. By default, the timeout is set to -1, indicating that
83799>>>>>>>/// statements will wait indefinitely before timing out.
83799>>>>>>>///
83799>>>>>>>/// @Assumptions
83799>>>>>>>/// @Status      Public
83799>>>>>>>/// @Drivers     SQLFlex
83799>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
83799>>>>>>>/// @See                 GET_SQL_LOCK_TIMEOUT
83799>>>>>>>///
83799>>>>>>>/// @Syntax SET_SQL_LOCAL_TIMEOUT of {server} to {variable}
83799>>>>>>>/// @Param server                       Name of the server
83799>>>>>>>/// @Param variable                     Number of milliseconds to wait until timeout
83799>>>>>>>///
83799>>>>>>>/// @Example
83799>>>>>>>/// SET_SQL_LOCK_TIMEOUT of "localhost" to 6000
83799>>>>>>>
83799>>>>>>>//=============================================================================
83799>>>>>>>/// @Name        GET_SQL_LOCK_TIMEOUT
83799>>>>>>>/// @Description This command returns the number of milliseconds an SQL
83799>>>>>>>/// statement will wait for a database lock to be released. If the lock
83799>>>>>>>/// is not released before the timeout, then the statement will fail and
83799>>>>>>>/// an error will be raised. Note that the default value is -1, indicating
83799>>>>>>>/// that the statement will wait indefinitely.
83799>>>>>>>///
83799>>>>>>>/// @Assumptions
83799>>>>>>>/// @Status      Public
83799>>>>>>>/// @Drivers     SQLFlex
83799>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
83799>>>>>>>/// @See                 SET_SQL_LOCK_TIMEOUT
83799>>>>>>>///
83799>>>>>>>/// @Syntax GET_SQL_LOCAL_TIMEOUT of {server} to {variable}
83799>>>>>>>/// @Param server                       Name of the server
83799>>>>>>>/// @Param variable                     Variable to hold the number of milliseconds
83799>>>>>>>///
83799>>>>>>>/// @Example
83799>>>>>>>/// GET_SQL_LOCK_TIMEOUT of "localhost" to iTimeout
83799>>>>>>>
83799>>>>>>>//=============================================================================
83799>>>>>>>/// @Name        DO_GET_SQLSERVER_PARAMETERS
83799>>>>>>>/// @Description Retrieves stored procedure parameter values.
83799>>>>>>>///
83799>>>>>>>/// @Assumptions
83799>>>>>>>/// @Status      Internal
83799>>>>>>>/// @Drivers     All
83799>>>>>>>/// @VersionNote Last Revised: 2009-08-18 By Ian Smith
83799>>>>>>>/// @See
83799>>>>>>>
83799>>>>>>>Function MertechInc_DO_GET_SQLSERVER_PARAMETERS Global Integer iParameter Returns String
83801>>>>>>>    String sValue
83801>>>>>>>
83801>>>>>>>    Get MertechInc_Pre_Size_String 0 to sValue //Need to check if Call_Driver needs pre sized strings. Until then assume it does
83802>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function 24 CALLBACK 0 PASSING sValue MertechInc_Blank iParameter RESULT MertechInc_iRet
83807>>>>>>>
83807>>>>>>>    Function_Return sValue
83808>>>>>>>End_Function
83809>>>>>>>
83809>>>>>>>//=============================================================================
83809>>>>>>>/// @Name        DO_BIND_SQLSERVER_PARAMETERS
83809>>>>>>>/// @Description Binds parameters for stored procedure call.
83809>>>>>>>///
83809>>>>>>>/// @Assumptions
83809>>>>>>>/// @Status      Internal
83809>>>>>>>/// @Drivers     All
83809>>>>>>>/// @VersionNote Last Revised: 2009-08-18 By Ian Smith
83809>>>>>>>/// @See
83809>>>>>>>
83809>>>>>>>Procedure MertechInc_DO_BIND_SQLSERVER_PARAMETERS Global String sDirection String sParameter Integer iSize
83811>>>>>>>    Call_Driver 0 SQLFLEX Function CALLDRV_BIND_PARAMETER CALLBACK 0 PASSING sDirection sParameter iSize RESULT MertechInc_iRet
83816>>>>>>>End_Procedure
83817>>>>>>>
83817>>>>>>>//=============================================================================
83817>>>>>>>/// @Name        DO_CHECK_BINDING
83817>>>>>>>/// @Description Sets MertechInc_bThereIsBinding True if any of the
83817>>>>>>>/// parameters is the keyword BINDING.
83817>>>>>>>///
83817>>>>>>>/// @Assumptions
83817>>>>>>>/// @Status      Internal
83817>>>>>>>/// @Drivers     All
83817>>>>>>>/// @VersionNote Last Revised: 2009-08-18 By Ian Smith
83817>>>>>>>/// @See
83817>>>>>>>
83817>>>>>>>//=============================================================================
83817>>>>>>>/// @Name        DO_FETCH_FIRST_ROW
83817>>>>>>>/// @Description Recursive - drops first parameter until the first parameter
83817>>>>>>>/// is BINDING and then calls SQL_FETCH_NEXT_ROW passing remaining parameters.
83817>>>>>>>///
83817>>>>>>>/// @Assumptions
83817>>>>>>>/// @Status      Internal
83817>>>>>>>/// @Drivers     SQLFlex
83817>>>>>>>/// @VersionNote Last Revised: 2009-08-18 By Ian Smith
83817>>>>>>>/// @See
83817>>>>>>>
83817>>>>>>>
83817>>>>>>>
83817>>>>>>>
83817>>>>>>>//=============================================================================
83817>>>>>>>/// @Name        CALL_STORED_PROCEDURE
83817>>>>>>>/// @Description This command is used to call a stored procedure on the SQL
83817>>>>>>>/// backend. To successfully call a procedure with this command, a string
83817>>>>>>>/// must be passed containing a valid procedure name. In addition, if the
83817>>>>>>>/// procedure takes any arguments, they must also be passed using the constant
83817>>>>>>>/// "passing" along with all of the needed arguments. If the procedure has a
83817>>>>>>>/// return value, then SQL_GET_FUNCTION_RETURN or SQL_FETCH_NEXT_ROW can be
83817>>>>>>>/// used to get the value(s). If an error is found then the indicator "Err"
83817>>>>>>>/// is set to true.
83817>>>>>>>///
83817>>>>>>>/// @Assumptions
83817>>>>>>>/// @Status      Public
83817>>>>>>>/// @Drivers     All
83817>>>>>>>/// @VersionNote Last Revised: 2013-09-25 by Aaron Gulack
83817>>>>>>>/// @See
83817>>>>>>>///
83817>>>>>>>/// @Syntax CALL_STORED_PROCEDURE {procedure} Passing {variable}
83817>>>>>>>/// @Param procedure            Full name of the procedure
83817>>>>>>>/// @Param variable                     Argument being passed (can be multiple)
83817>>>>>>>///
83817>>>>>>>/// @Example
83817>>>>>>>/// CALL_STORED_PROCEDURE "sys.sp_addmessage" passing 50003 15 "Please enter a valid date"
83817>>>>>>>
83817>>>>>>>//=============================================================================
83817>>>>>>>/// @Name        CALL_SQLSERVER_PROCEDURE
83817>>>>>>>/// @Description This command is used to call a stored procedure on the SQL
83817>>>>>>>/// backend. To successfully call a procedure with this command, a string
83817>>>>>>>/// must be passed containing a valid procedure name. In addition, if the
83817>>>>>>>/// procedure takes any arguments, they must also be passed using the constant
83817>>>>>>>/// "passing" along with all of the needed arguments. If the procedure has a
83817>>>>>>>/// return value, then SQL_GET_FUNCTION_RETURN, SQL_FETCH_NEXT_ROW or
83817>>>>>>>/// GET_PROCEDURE_RETURN can be used to get the value(s). If an error is found
83817>>>>>>>/// then the indicator "Err" is set to true.
83817>>>>>>>///
83817>>>>>>>/// @Status      Deprecated
83817>>>>>>>/// @Drivers     SQLFlex
83817>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
83817>>>>>>>/// @See                 CALL_STORED_PROCEDURE
83817>>>>>>>///
83817>>>>>>>/// @Syntax CALL_SQLSERVER_PROCEDURE {procedure} Passing {variable}
83817>>>>>>>/// @Param procedure            Full name of the procedure
83817>>>>>>>/// @Param variable                     Argument to be passed (can be multiple)
83817>>>>>>>///
83817>>>>>>>/// @Example
83817>>>>>>>/// CALL_SQLSERVER_PROCEDURE "sys.sp_addmessage" passing 50003 15 "Please enter a valid date"
83817>>>>>>>
83817>>>>>>>//=============================================================================
83817>>>>>>>/// @Name        END_CALL_PROCEDURE
83817>>>>>>>/// @Description This command is used to close any open cursors created
83817>>>>>>>/// by the respective stored procedure. Cursors are used in MSSQL to make
83817>>>>>>>/// the results from one procedure temporarily available to other procedures
83817>>>>>>>/// or triggers. To avoid causing unwanted results, it is good practice to
83817>>>>>>>/// use this command once a procedure call is completed.
83817>>>>>>>///
83817>>>>>>>/// @Assumptions
83817>>>>>>>/// @Status      Public
83817>>>>>>>/// @Drivers     SQLFlex
83817>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
83817>>>>>>>/// @See                 CALL_STORED_PROCEDURE
83817>>>>>>>///
83817>>>>>>>/// @Syntax END_CALL_PROCEDURE
83817>>>>>>>///
83817>>>>>>>/// @Example
83817>>>>>>>/// CALL_STORED_PROCEDURE "sys.sp_spaceused" Passing "Customer"
83817>>>>>>>/// GET_PROCEDURE_RETURN to sValue
83817>>>>>>>/// END_CALL_PROCEDURE
83817>>>>>>>/// Showln sValue
83817>>>>>>>
83817>>>>>>>//=============================================================================
83817>>>>>>>/// @Name        GET_PROCEDURE_RETURN
83817>>>>>>>/// @Description This command is used to get a returned value from a stored
83817>>>>>>>/// procedure using MSSQL. Note that this command can only handle one
83817>>>>>>>/// returned value and must be used after the procedure has already been
83817>>>>>>>/// built and executed.
83817>>>>>>>///
83817>>>>>>>/// @Assumptions
83817>>>>>>>/// @Status      Public
83817>>>>>>>/// @Drivers     SQLFlex
83817>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
83817>>>>>>>/// @See
83817>>>>>>>///
83817>>>>>>>/// @Syntax GET_PROCEDURE_RETURN to {variable}
83817>>>>>>>/// @Param variable             Variable to hold the returned value
83817>>>>>>>///
83817>>>>>>>/// @Example
83817>>>>>>>/// SQL_SET_PROCEDURE_NAME "sys.sp_spaceused" NUMPAR 1
83817>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to "Customer" IN
83817>>>>>>>/// SQL_PROCEDURE_EXECUTE
83817>>>>>>>/// GET_PROCEDURE_RETURN to sSpaceUsed
83817>>>>>>>/// Showln sSpaceUsed
83817>>>>>>>
83817>>>>>>>//=============================================================================
83817>>>>>>>/// @Name        SET_MIRROR_SERVER
83817>>>>>>>/// @Description This command is used to programmatically set the mirror
83817>>>>>>>/// server for the database. This is to be used along with SQl server
83817>>>>>>>/// failover mirroring. Note that this simply sets the server and database
83817>>>>>>>/// to be used for mirroring. All set up for the servers must already be
83817>>>>>>>/// working properly through SQL Server.
83817>>>>>>>///
83817>>>>>>>/// @Assumptions A compatible version of SQL Server is being used
83817>>>>>>>/// @Status      Public
83817>>>>>>>/// @Drivers     SQLFlex v9.2 and above
83817>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
83817>>>>>>>/// @See                 GET_MIRROR_SERVER
83817>>>>>>>///
83817>>>>>>>/// @Syntax SET_MIRROR_SERVER to {server} {database}
83817>>>>>>>/// @Param server                       The name of the mirror server
83817>>>>>>>/// @Param database                     The database acting as a mirror
83817>>>>>>>///
83817>>>>>>>/// @Example
83817>>>>>>>/// SET_MIRROR_SERVER to "(localdb)\v11.0" "MirrorDB"
83817>>>>>>>
83817>>>>>>>//=============================================================================
83817>>>>>>>/// @Name        GET_MIRROR_SERVER
83817>>>>>>>/// @Description This command is used to get the name of the server
83817>>>>>>>/// and database being used for failover mirroring. Mirroring must
83817>>>>>>>/// be properly set up in SQL Server for this command to return the
83817>>>>>>>/// correct values.
83817>>>>>>>///
83817>>>>>>>/// @Assumptions
83817>>>>>>>/// @Status      Public
83817>>>>>>>/// @Drivers     SQLFlex v9.2 and above
83817>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
83817>>>>>>>/// @See                 SET_MIRROR_SERVER
83817>>>>>>>///
83817>>>>>>>/// @Syntax GET_MIRROR_SERVER to {server} {database}
83817>>>>>>>/// @Param server                       Variable to hold the name of the mirrored server
83817>>>>>>>/// @Param database                     Variable to hold the name of the mirrored database
83817>>>>>>>///
83817>>>>>>>/// @Example
83817>>>>>>>/// GET_MIRROR_SERVER to sServer sDatabase
83817>>>>>>>
83817>>>>>>>//=============================================================================
83817>>>>>>>/// @Name        COPY_DATA
83817>>>>>>>/// @Description This command is used to copy data from a DAT file to an
83817>>>>>>>/// SQL table. Both the source and the destination files are opened, the
83817>>>>>>>/// data is copied and then the files are closed. This is usually used
83817>>>>>>>/// along with CREATE_TABLE_FROM_DAT_FILE, which creates the structure
83817>>>>>>>/// and then this command will insert the data. If needed, this command
83817>>>>>>>/// can also work backwards, copying data from an SQL table to a DAT file.
83817>>>>>>>/// This is an alternative to using the Flex2SQL Migration Tool and can
83817>>>>>>>/// improve performance when used in the right situations. Note that in
83817>>>>>>>/// order for this process to work properly the table being copied can not
83817>>>>>>>/// be opened. Because of this, a manual login must take place, using
83817>>>>>>>/// something like LOGIN_SQLFLEX or LOGIN. Since this only copies the data,
83817>>>>>>>/// CREATE_TABLE_FROM_DAT_FILE can be used to create the table structure.
83817>>>>>>>///
83817>>>>>>>/// Because COPY_DATA requires no user interaction, an optional callback
83817>>>>>>>/// function can be passed for tracing purposes. By passing the constant
83817>>>>>>>/// "CALLBACK" followed by the object name, a function can be used to set
83817>>>>>>>/// up messages for tracking and error handling. Below is more information
83817>>>>>>>/// regarding this callback object.
83817>>>>>>>///
83817>>>>>>>/// This function should follow this pattern:
83817>>>>>>>///
83817>>>>>>>/// Function Callback String sText Integer iStatusID Returns Integer
83817>>>>>>>///
83817>>>>>>>/// sText - Message corresponding to the current status ID
83817>>>>>>>///
83817>>>>>>>/// iStatusID - Integer value mapping to the current status constant:
83817>>>>>>>///                     DF_MESSAGE_PROGRESS_TITLE    Sent when SQLFlex starts the
83817>>>>>>>///                                                                              process
83817>>>>>>>///
83817>>>>>>>///             DF_MESSAGE_HEADING_1         Sent when SQLFlex is about to
83817>>>>>>>///                                                                              copy the source data
83817>>>>>>>///
83817>>>>>>>///             DF_MESSAGE_ERROR             Sent when an error occurs
83817>>>>>>>///
83817>>>>>>>///             DF_MESSAGE_PROGRESS_STATUS   Sent each time an additional
83817>>>>>>>///                                                                              10% of the data is copied
83817>>>>>>>///
83817>>>>>>>/// NOTE: Returning false each time the function is called will continue
83817>>>>>>>/// copying process. Returning true will end it.
83817>>>>>>>///
83817>>>>>>>/// Another optional parameter that can be used is a constrain on the data
83817>>>>>>>/// being copied. This is done by passing the constant "CONSTRAIN" followed
83817>>>>>>>/// by an SQL constrain statement. When passing a constrain but not a callback
83817>>>>>>>/// object, pass 0 for the callback before passsing the constrain.
83817>>>>>>>///
83817>>>>>>>/// @Assumptions
83817>>>>>>>/// @Status      Public
83817>>>>>>>/// @Drivers     All
83817>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
83817>>>>>>>/// @See                 CREATE_TABLE_FROM_DAT_FILE CONVERT_DAT_FILE
83817>>>>>>>///
83817>>>>>>>/// @Syntax COPY_DATA {from} to {destination} [CALLBACK {function}] [CONSTRAIN {variable}]
83817>>>>>>>/// @Param from                         Table to copy from.
83817>>>>>>>/// @Param destination          Table to copy to.
83817>>>>>>>/// @Param function             Object with callback function (optional)
83817>>>>>>>/// @Param variable                     SQL contraint to use when copying (optional)
83817>>>>>>>///
83817>>>>>>>/// @Example
83817>>>>>>>/// Object CallBackObj is a Array
83817>>>>>>>///     Function Callback String sText Integer iLogicalID Returns Integer
83817>>>>>>>///         If (iLogicalID = DF_MESSAGE_ERROR) Begin
83817>>>>>>>///             Showln "Error"
83817>>>>>>>///                             Showln sText
83817>>>>>>>///                             Function_Return True
83817>>>>>>>///         End
83817>>>>>>>///
83817>>>>>>>///         Else Showln sText
83817>>>>>>>///
83817>>>>>>>///                     Function_Return False
83817>>>>>>>///
83817>>>>>>>///     End_Function
83817>>>>>>>/// End_Object
83817>>>>>>>///
83817>>>>>>>/// Login "localhost" "user" "pass123" "sql_drv"
83817>>>>>>>/// CREATE_TABLE_FROM_DAT_FILE Customer.File_Number "Customer"
83817>>>>>>>/// COPY_DATA "Customer" to "sql_drv:Customer" CALLBACK (Callback(Self)) CONSTRAIN "STATUS = 'Active'"
83817>>>>>>>
83817>>>>>>>//=============================================================================
83817>>>>>>>/// @Name        ORAFlex_REVISION
83817>>>>>>>/// @Description This command will put the current version (decimals included)
83817>>>>>>>/// of the Oracle driver associated with the current workspace into the specified
83817>>>>>>>/// variable.
83817>>>>>>>///
83817>>>>>>>/// @Assumptions
83817>>>>>>>/// @Status      Deprecated
83817>>>>>>>/// @Drivers     ORAFlex
83817>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
83817>>>>>>>/// @See                 GET_DRIVER_REVISION
83817>>>>>>>///
83817>>>>>>>/// @Syntax ORAFlex_REVISION {variable}
83817>>>>>>>/// @Param variable                     String variable to hold the returned version
83817>>>>>>>///
83817>>>>>>>/// @Example
83817>>>>>>>/// ORAFlex_REVISION sVersion
83817>>>>>>>
83817>>>>>>>//=============================================================================
83817>>>>>>>/// @Name        KEEP_FILES_OPEN
83817>>>>>>>/// @Description Keep the files, currently in use, open after the server is
83817>>>>>>>/// logged out. Sometimes an application needs to login to the same server
83817>>>>>>>/// with a different user id. When logging out, however, the drivers
83817>>>>>>>/// automatically close all opened files. The overhead of opening these files
83817>>>>>>>/// should be avoided if the user will work with the same files that were
83817>>>>>>>/// closed. KEEP_FILES_OPEN keeps all files opened after a user logs out
83817>>>>>>>/// from the server.
83817>>>>>>>///
83817>>>>>>>/// @Status      Deprecated
83817>>>>>>>/// @Drivers     All
83817>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
83817>>>>>>>///
83817>>>>>>>/// @Syntax KEEP_FILES_OPEN of {server}
83817>>>>>>>/// @Param server               Name of the server
83817>>>>>>>
83817>>>>>>>
83817>>>>>>>//=============================================================================
83817>>>>>>>/// @Name        SET_MAX_OPEN_CURSORS
83817>>>>>>>/// @Description Set the maximum number of cursors you want the driver to use.
83817>>>>>>>///
83817>>>>>>>/// The driver will recycle the least used cursors if this limit is hit.
83817>>>>>>>/// The trade off is between increased resources on the server and
83817>>>>>>>/// re-preparing of cursors.
83817>>>>>>>///
83817>>>>>>>/// For a program that keeps 40+ files opened at the same time, 255 is a good
83817>>>>>>>/// number for the open cursors parameter. For programs that open less than
83817>>>>>>>/// 40 files, any number between 100-255 is sufficient. These numbers can be
83817>>>>>>>/// changed based on available server resources.
83817>>>>>>>///
83817>>>>>>>/// On Oracle this value should not exceed the value of open_cursors in
83817>>>>>>>/// init.ora
83817>>>>>>>///
83817>>>>>>>/// Note: Only change this setting if you are having performance issues
83817>>>>>>>/// and the server is indicating you are using up too many cursors or too
83817>>>>>>>/// much memory. GET_OPENED_CURSORS can be used to check the number of
83817>>>>>>>/// cursors the server has opened. If this number is hitting the limit,
83817>>>>>>>/// it is worth increasing the number, as long as the server has enough
83817>>>>>>>/// resources.
83817>>>>>>>///
83817>>>>>>>/// @Assumptions
83817>>>>>>>/// @Status      Public
83817>>>>>>>/// @Drivers     All
83817>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
83817>>>>>>>/// @See         GET_MAX_OPEN_CURSORS GET_OPENED_CURSORS
83817>>>>>>>///
83817>>>>>>>/// @Syntax SET_MAX_OPEN_CURSORS of {server} to {variable}
83817>>>>>>>/// @Param server                       The name of the server
83817>>>>>>>/// @Param variable                     Maximum number of cursors
83817>>>>>>>
83817>>>>>>>//=============================================================================
83817>>>>>>>/// @Name        GET_MAX_OPEN_CURSORS
83817>>>>>>>/// @Description This command will return the maximum number of open
83817>>>>>>>/// cursors allowed by the server.
83817>>>>>>>///
83817>>>>>>>/// @Assumptions
83817>>>>>>>/// @Status      Public
83817>>>>>>>/// @Drivers     All
83817>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
83817>>>>>>>/// @See         SET_MAX_OPEN_CURSORS GET_OPENED_CURSORS
83817>>>>>>>///
83817>>>>>>>/// @Syntax GET_MAX_OPEN_CURSORS of {server} to {variable}
83817>>>>>>>/// @Param server                       Name of the server
83817>>>>>>>/// @Param variable                     Variable to hold the maximum number of open cursors
83817>>>>>>>
83817>>>>>>>//=============================================================================
83817>>>>>>>/// @Name        GET_OPENED_CURSORS
83817>>>>>>>/// @Description This command returns the number of cursors currently
83817>>>>>>>/// open on the server.
83817>>>>>>>///
83817>>>>>>>/// @Assumptions
83817>>>>>>>/// @Status      Public
83817>>>>>>>/// @Drivers     All
83817>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
83817>>>>>>>/// @See         SET_MAX_OPEN_CURSORS GET_MAX_OPEN_CURSORS
83817>>>>>>>///
83817>>>>>>>/// @Syntax GET_MAX_OPEN_CURSORS of {server} to {variable}
83817>>>>>>>/// @Param server                       Name of the server
83817>>>>>>>/// @Param variable                     Variable to hold the number of cursors currently open
83817>>>>>>>///
83817>>>>>>>
83817>>>>>>>//=============================================================================
83817>>>>>>>/// @Name        ACTIVATE_TIME_STAMP
83817>>>>>>>/// @Description This command will specify whether or not to show the time
83817>>>>>>>/// portion of a date field. When set to ON, the time portion will be
83817>>>>>>>/// included, OFF will just show the date. This is the same as changing
83817>>>>>>>/// the date format with "ALTER SESSION SET nls_timestamp_format". Note that
83817>>>>>>>/// this will only take effect if the date is put into a string variable.
83817>>>>>>>///
83817>>>>>>>/// @Assumptions
83817>>>>>>>/// @Status      Deprecated
83817>>>>>>>/// @Drivers     OraFlex
83817>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
83817>>>>>>>/// @See
83817>>>>>>>///
83817>>>>>>>/// @Syntax ACTIVATE_TIME_STAMP of {server} to {ON/OFF}
83817>>>>>>>/// @Param server                       Name of the server
83817>>>>>>>///
83817>>>>>>>/// @Example
83817>>>>>>>/// ACTIVATE_TIME_STAMP of "localhost/orcl.localdomain" to OFF
83817>>>>>>>///
83817>>>>>>>/// SQL_SET_STMT to 'SELECT * from USER."Customer" '
83817>>>>>>>/// SQL_PREPARE_STMT
83817>>>>>>>/// SQL_EXECUTE_STMT
83817>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sFirstName sLastName sDOB
83817>>>>>>>/// If (Found) Begin
83817>>>>>>>///     Showln sDOB
83817>>>>>>>/// End
83817>>>>>>>
83817>>>>>>>//=============================================================================
83817>>>>>>>/// @Name        CALL_ORACLE_STORED_FUNCTION
83817>>>>>>>/// @Description This command is used to execute a function stored in Oracle.
83817>>>>>>>/// This is an alternative to building a function with the SQL_SET_FUNCTION_NAME,
83817>>>>>>>/// SQL_SET_FUNCTION_PARAMETER and SQL_FUNCTION_EXECUTE commands. This command
83817>>>>>>>/// builds and executes the function by setting the full function name, the
83817>>>>>>>/// parameter(s) to pass and the variable to hold the returned value. Note that
83817>>>>>>>/// this command can only return a single value so SQL_SET_FUNCTION_PARAMETER
83817>>>>>>>/// and SQL_SET_FUNCTION_NAME must be used when dealing with multiple return
83817>>>>>>>/// values.
83817>>>>>>>///
83817>>>>>>>/// @Status      Deprecated
83817>>>>>>>/// @Drivers     ORAFLex
83817>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
83817>>>>>>>/// @See                 CALL_STORED_FUNCTION
83817>>>>>>>///
83817>>>>>>>/// @Syntax CALL_ORACLE_STORED_FUNCTION {function} Returns {variable} Passing {argument}
83817>>>>>>>/// @Param function                     Full name of the function
83817>>>>>>>/// @Param variable                     Variable to hold the returned value
83817>>>>>>>/// @Param argument                     Argument to pass (can be multiple)
83817>>>>>>>///
83817>>>>>>>/// @Example
83817>>>>>>>/// CALL_ORACLE_STORED_FUNCTION "user.getCustomerStatus" Returns sStatus passing sCustomerID
83817>>>>>>>/// Showln sStatus
83817>>>>>>>
83817>>>>>>>//=============================================================================
83817>>>>>>>/// @Name        CALL_PGSQL_STORED_FUNCTION
83817>>>>>>>/// @Description This command is used to execute a function stored in Oracle.
83817>>>>>>>/// This is an alternative to building a function with the SQL_SET_FUNCTION_NAME,
83817>>>>>>>/// SQL_SET_FUNCTION_PARAMETER and SQL_FUNCTION_EXECUTE commands. This command
83817>>>>>>>/// builds and executes the function by setting the full function name, the
83817>>>>>>>/// parameter(s) to pass and the variable to hold the returned value. Note that
83817>>>>>>>/// this command can only return a single value so SQL_SET_FUNCTION_PARAMETER
83817>>>>>>>/// and SQL_SET_FUNCTION_NAME must be used when dealing with multiple return
83817>>>>>>>/// values.
83817>>>>>>>///
83817>>>>>>>/// @Status      Deprecated
83817>>>>>>>/// @Drivers     PGFlex
83817>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
83817>>>>>>>/// @See                 CALL_STORED_FUNCTION
83817>>>>>>>///
83817>>>>>>>/// @Syntax CALL_PGSQL_STORED_FUNCTION {function} Returns {variable} Passing {argument}
83817>>>>>>>/// @Param function                     Full name of the function
83817>>>>>>>/// @Param variable                     Variable to hold the returned value
83817>>>>>>>/// @Param argument                     Argument to pass (can be multiple)
83817>>>>>>>///
83817>>>>>>>/// @Example
83817>>>>>>>/// CALL_PGSQL_STORED_FUNCTION "user.getCustomerStatus" Returns sStatus passing sCustomerID
83817>>>>>>>/// Showln sStatus
83817>>>>>>>
83817>>>>>>>//=============================================================================
83817>>>>>>>/// @Name        MERTECH_LANGUAGE_SUPPORT
83817>>>>>>>/// @Description Sets the support language for the driver.
83817>>>>>>>///
83817>>>>>>>/// @Assumptions
83817>>>>>>>/// @Status      Internal
83817>>>>>>>/// @Drivers     ORAFLex
83817>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
83817>>>>>>>/// @See
83817>>>>>>>///
83817>>>>>>>/// @Syntax MERTECH_LANGUAGE_SUPPORT of {server} to {language}
83817>>>>>>>/// @Param server               The name of the server being used
83817>>>>>>>/// @Param language             The language to set support to
83817>>>>>>>
83817>>>>>>>//=============================================================================
83817>>>>>>>/// @Name        SQL_SAVE_BUFFER_BEGIN
83817>>>>>>>/// @Description This command is used to initialize a SAVE_BUFFER
83817>>>>>>>/// statement. Doing this will allow a specified set of records to be
83817>>>>>>>/// stored in the buffer before a save takes place. Once the buffer is
83817>>>>>>>/// filled, it will be saved automatically. This set of commands can be
83817>>>>>>>/// used to efficiently save a large number of records. Once the buffer
83817>>>>>>>/// is full, the save occurs automatically and the buffer will be emptied
83817>>>>>>>/// out. It is good practice to use this method inside of a transaction to
83817>>>>>>>/// maintain atomicity. Note that these commands should not be used in
83817>>>>>>>/// conjuction with finds.
83817>>>>>>>///
83817>>>>>>>/// @Assumptions
83817>>>>>>>/// @Status      Public
83817>>>>>>>/// @Drivers     All
83817>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
83817>>>>>>>/// @See         SQL_SAVE_BUFFER_END SQL_SAVE_BUFFER
83817>>>>>>>///
83817>>>>>>>/// @Syntax SQL_SAVE_BUFFER_BEGIN of {FileName} to {variable}
83817>>>>>>>/// @Param FileName                     Name of the file
83817>>>>>>>/// @Param variable                     Number of records to store in the buffer
83817>>>>>>>///
83817>>>>>>>/// @Example
83817>>>>>>>/// Open Customer
83817>>>>>>>///
83817>>>>>>>/// SQL_SAVE_BUFFER_BEGIN of Transactions to 10
83817>>>>>>>///
83817>>>>>>>/// For i from 0 to 1000
83817>>>>>>>///     Move i to Transactions.ID
83817>>>>>>>///     SQL_SAVE_BUFFER of Transactions
83817>>>>>>>/// Loop
83817>>>>>>>///
83817>>>>>>>/// SQL_SAVE_BUFFER_END of Customer
83817>>>>>>>
83817>>>>>>>//=============================================================================
83817>>>>>>>/// @Name        SQL_SAVE_BUFFER
83817>>>>>>>/// @Description This command is used to send a record to the "Save
83817>>>>>>>/// Record" buffer. It must be used along with SQL_SAVE_BUFFER_BEGIN
83817>>>>>>>/// and SQL_SAVE_BUFFER_END. SQL_SAVE_BUFFER_BEGIN sets the number of
83817>>>>>>>/// records to store in the buffer before a save is done on all the records
83817>>>>>>>/// at once. Each time a record is created, this command should be called
83817>>>>>>>/// to insert it into the buffer. Using this set of commands can be useful
83817>>>>>>>/// to efficiently save a large number of records. Once the buffer is full,
83817>>>>>>>/// the save occurs automatically and the buffer will be emptied out. It is
83817>>>>>>>/// good practice to use this method inside of a transaction to maintain
83817>>>>>>>/// atomicity.
83817>>>>>>>///
83817>>>>>>>/// @Assumptions
83817>>>>>>>/// @Status      Public
83817>>>>>>>/// @Drivers     All
83817>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
83817>>>>>>>/// @See                 SQL_SAVE_BUFFER_BEGIN SQL_SAVE_BUFFER_END
83817>>>>>>>///
83817>>>>>>>/// @Syntax SQL_SAVE_BUFFER of {FileName}
83817>>>>>>>/// @Param FileName                     Name of the file
83817>>>>>>>///
83817>>>>>>>/// @Example
83817>>>>>>>/// Open Customer
83817>>>>>>>///
83817>>>>>>>/// SQL_SAVE_BUFFER_BEGIN of Transactions to 10
83817>>>>>>>///
83817>>>>>>>/// For i from 0 to 1000
83817>>>>>>>///     Move i to Transactions.ID
83817>>>>>>>///     SQL_SAVE_BUFFER of Transactions
83817>>>>>>>/// Loop
83817>>>>>>>///
83817>>>>>>>/// SQL_SAVE_BUFFER_END of Customer
83817>>>>>>>
83817>>>>>>>//=============================================================================
83817>>>>>>>/// @Name        SQL_SAVE_BUFFER_END
83817>>>>>>>/// @Description This command indicates the end of the extended record
83817>>>>>>>/// buffer and forces a save of any data currently in the buffer.
83817>>>>>>>///
83817>>>>>>>/// @Assumptions
83817>>>>>>>/// @Status      Public
83817>>>>>>>/// @Drivers     All
83817>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
83817>>>>>>>/// @See         SQL_SAVE_BUFFER_BEGIN SQL_SAVE_BUFFER
83817>>>>>>>///
83817>>>>>>>/// @Syntax SQL_SAVE_BUFFER_END of {FileName}
83817>>>>>>>/// @Param FileName                     Name of the file
83817>>>>>>>///
83817>>>>>>>/// @Example
83817>>>>>>>/// Open Customer
83817>>>>>>>///
83817>>>>>>>/// SQL_SAVE_BUFFER_BEGIN of Transactions to 10
83817>>>>>>>///
83817>>>>>>>/// For i from 0 to 1000
83817>>>>>>>///     Move i to Transactions.ID
83817>>>>>>>///     SQL_SAVE_BUFFER of Transactions
83817>>>>>>>/// Loop
83817>>>>>>>///
83817>>>>>>>/// SQL_SAVE_BUFFER_END of Customer
83817>>>>>>>
83817>>>>>>>//=============================================================================
83817>>>>>>>/// @Name        SQL_SAVE_SET_ATTRIBUTES
83817>>>>>>>/// @Description Unknown - Not in help - Not call by any other macros
83817>>>>>>>///
83817>>>>>>>/// @Assumptions
83817>>>>>>>/// @Status      Internal
83817>>>>>>>/// @Drivers     SQLFlex
83817>>>>>>>/// @VersionNote Last Revised: 2009-08-18 By Ian Smith
83817>>>>>>>/// @See
83817>>>>>>>
83817>>>>>>>//=============================================================================
83817>>>>>>>/// @Name        ENABLE_TRACE_ON
83817>>>>>>>/// @Description This command enables driver level tracing to the
83817>>>>>>>/// specified file. Enabling trace on an application and using it
83817>>>>>>>/// in conjunction with SQL_TEXT_MESSAGE is a good way to study
83817>>>>>>>/// particular problems you encounter in the driver. SQL_TEXT_MESSAGE
83817>>>>>>>/// allows you to insert sections of your code into the trace file.
83817>>>>>>>/// This command can also set the trace to three different levels,
83817>>>>>>>/// allowing different amounts of information to be logged. Note that
83817>>>>>>>/// trace files can become very large so it is good practice to only
83817>>>>>>>/// turn them on when specifically needed.
83817>>>>>>>///
83817>>>>>>>/// @Assumptions
83817>>>>>>>/// @Status      Public
83817>>>>>>>/// @Drivers     All
83817>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
83817>>>>>>>/// @See                 DISABLE_TRACE_ON SQL_TEXT_MESSAGE
83817>>>>>>>///
83817>>>>>>>/// @Syntax ENABLE_TRACE_ON to {fileName} Debug_Level [{constant}]
83817>>>>>>>/// @Param fileName                     The path of the file to send the trace to
83817>>>>>>>/// @Param constant             DETAIL_LEVEL1, DETAIL_LEVEL2, DETAIL_LEVEL3 (optional)
83817>>>>>>>///
83817>>>>>>>/// @Example ENABLE_TRACE_ON TO "C:\Temp\trace_file.txt" Debug_Level DETAIL_LEVEL3
83817>>>>>>>
83817>>>>>>>//=============================================================================
83817>>>>>>>/// @Name        DISABLE_TRACE_ON
83817>>>>>>>/// @Description This command disables the current trace taking
83817>>>>>>>/// place on a driver.
83817>>>>>>>///
83817>>>>>>>/// @Assumptions
83817>>>>>>>/// @Status      Public
83817>>>>>>>/// @Drivers     All
83817>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
83817>>>>>>>/// @See ENABLE_TRACE_ON SQL_TEXT_MESSAGE
83817>>>>>>>///
83817>>>>>>>/// @Syntax DISABLE_TRACE_ON
83817>>>>>>>
83817>>>>>>>//=============================================================================
83817>>>>>>>/// @Name        CREATE_TABLE_FROM_DAT_FILE
83817>>>>>>>/// @Description This command is used to create a SQL table from a .DAT
83817>>>>>>>/// file. The table being copied must be not be opened in order for this
83817>>>>>>>/// command to work properly. This is the programmatic equivalent to
83817>>>>>>>/// using the Flex2SQL Migration Tool. Optional restructuring options
83817>>>>>>>/// can be specified here (see below) as well as an alternative table
83817>>>>>>>/// name than the physical name of the .DAT file. Note that this only
83817>>>>>>>/// creates the  table structure, no data will be copied here. To copy
83817>>>>>>>/// the data, use COPY_DATA after the table has been created.
83817>>>>>>>///
83817>>>>>>>/// DF_STRUCTEND_OPT_FORCE_INVK         - Deprecated
83817>>>>>>>///
83817>>>>>>>/// DF_STRUCTEND_OPT_OLD_INVK_NAME      - Deprecated
83817>>>>>>>///
83817>>>>>>>/// DF_STRUCTEND_OPT_FORCE_NOT_NULL - forces all fields to be created as NOT NULL.
83817>>>>>>>///
83817>>>>>>>/// @Assumptions
83817>>>>>>>/// @Status      Public
83817>>>>>>>/// @Drivers     All
83817>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
83817>>>>>>>/// @See                 COPY_DATA CONVERT_DAT_FILE
83817>>>>>>>///
83817>>>>>>>/// @Syntax CREATE_TABLE_FROM_DAT_FILE {FileNumber} [{options} {table}]
83817>>>>>>>/// @Param FileNumber           Number of the file
83817>>>>>>>/// @Param options                      DF_STRUCTEND_OPT_FORCE_INVK
83817>>>>>>>///                                                     DF_STRUCTEND_OPT_OLD_INVK_NAME
83817>>>>>>>///                                                     DF_STRUCTEND_OPT_FORCE_NOT_NULL (optional)
83817>>>>>>>/// @Param table            name of table to use instead of physical name (optional)
83817>>>>>>>///
83817>>>>>>>/// @Example
83817>>>>>>>/// Login "localhost" "user" "pass123" "sql_drv"
83817>>>>>>>/// CREATE_TABLE_FROM_DAT_FILE Customer.File_Number "Customer"
83817>>>>>>>/// COPY_DATA "Customer" to "sql_drv:Customer" CALLBACK (Callback(Self)) CONSTRAIN "STATUS = 'Active'"
83817>>>>>>>
83817>>>>>>>//=============================================================================
83817>>>>>>>/// @Name        CONVERT_DAT_FILE
83817>>>>>>>/// @Description This command is the programmatic equivalent to the
83817>>>>>>>/// Flex2SQL Migration Tool. With this command, a SQL table can be
83817>>>>>>>/// created from a .DAT table. This combines the COPY_DATA and
83817>>>>>>>/// CREATE_TABLE_FROM_DAT_FILE, creating the table structure and
83817>>>>>>>/// copying all the data into the new table with one command. The
83817>>>>>>>/// table being converted cannot be opened and so a manual login is
83817>>>>>>>/// needed. Note that to specify the database to copy the table to,
83817>>>>>>>/// use SET_DATABASE_NAME. Below is a list of the optional restructure
83817>>>>>>>/// options to use when creating the table.
83817>>>>>>>///
83817>>>>>>>/// DF_STRUCTEND_OPT_FORCE_INVK         - Deprecated
83817>>>>>>>///
83817>>>>>>>/// DF_STRUCTEND_OPT_OLD_INVK_NAME      - Deprecated
83817>>>>>>>///
83817>>>>>>>/// DF_STRUCTEND_OPT_FORCE_NOT_NULL - forces all fields to be created as NOT NULL.
83817>>>>>>>///
83817>>>>>>>/// @Assumptions
83817>>>>>>>/// @Status      Public
83817>>>>>>>/// @Drivers     All
83817>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
83817>>>>>>>/// @See                 CREATE_TABLE_FROM_DAT_FILE COPY_DATA
83817>>>>>>>///
83817>>>>>>>/// @Syntax CONVERT_DAT_FILE {FileNumber} [{options} {table}]
83817>>>>>>>/// @Param FileNumber           Number of the file
83817>>>>>>>/// @Param options                      DF_STRUCTEND_OPT_FORCE_INVK
83817>>>>>>>///                                                     DF_STRUCTEND_OPT_OLD_INVK_NAME
83817>>>>>>>///                                                     DF_STRUCTEND_OPT_FORCE_NOT_NULL (optional)
83817>>>>>>>/// @Param table            Name of table to use instead of physical name (optional)
83817>>>>>>>///
83817>>>>>>>/// @Example
83817>>>>>>>/// Login "localhost" "user" "pass123" "sql_drv"
83817>>>>>>>/// CONVERT_DAT_FILE Customer.File_Number DF_STRUCTEND_OPT_FORCE_NOT_NULL "Customer"
83817>>>>>>>
83817>>>>>>>//=============================================================================
83817>>>>>>>/// @Name        SET_DEFAULT_FILE_CASING
83817>>>>>>>/// @Description This command is used to set the file casing standard when
83817>>>>>>>/// creating or restructuring tables. By default, all table and column names
83817>>>>>>>/// are created using the specified casing. Passing FILE_CASING_UPPER or
83817>>>>>>>/// FILE_CASING_LOWER will allow the names to be saved in uppercase or
83817>>>>>>>/// lowercase respectively. This can be useful for backwards compatibility
83817>>>>>>>/// where casing was important. Note that the casing standard for a file can
83817>>>>>>>/// also be changed through mertech.ini. Below is a description of the constants
83817>>>>>>>/// that can be passed to this command.
83817>>>>>>>///
83817>>>>>>>/// FILE_CASING_UPPER : All created or edited object names will be converted to uppercase.
83817>>>>>>>/// FILE_CASING_LOWER : All created or edited object names will be converted to lowercase.
83817>>>>>>>/// FILE_CASING_KEEP (default) : All created or edited object names will maintain their inputed casing.
83817>>>>>>>///
83817>>>>>>>/// @Assumptions
83817>>>>>>>/// @Status      Public
83817>>>>>>>/// @Drivers     All
83817>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
83817>>>>>>>/// @See                 GET_DEFAULT_FILE_CASING
83817>>>>>>>///
83817>>>>>>>/// @Syntax SET_DEFAULT_FILE_CASING to {constant}
83817>>>>>>>/// @Param constant                     FILE_CASING_UPPER, FILE_CASING_LOWER, FILE_CASING_KEEP
83817>>>>>>>///
83817>>>>>>>/// @Example
83817>>>>>>>/// SET_DEFAULT_FILE_CASING to FILE_CASING_UPPER
83817>>>>>>>
83817>>>>>>>//=============================================================================
83817>>>>>>>/// @Name        GET_DEFAULT_FILE_CASING
83817>>>>>>>/// @Description This command returns the file casing standard used
83817>>>>>>>/// when creating or restructuring tables. Note that an integer is returned,
83817>>>>>>>/// mapping to a casing method. Below are the meanings of the possible
83817>>>>>>>/// returned integers.
83817>>>>>>>///
83817>>>>>>>/// 0 - FILE_CASING_UPPER : All created or edited object names will be converted to uppercase.
83817>>>>>>>/// 1 - FILE_CASING_LOWER : All created or edited object names will be converted to lowercase.
83817>>>>>>>/// 2 - FILE_CASING_KEEP : All created or edited object names will maintain their inputed casing.
83817>>>>>>>///
83817>>>>>>>/// @Assumptions
83817>>>>>>>/// @Status      Public
83817>>>>>>>/// @Drivers     All
83817>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
83817>>>>>>>/// @See                 SET_DEFAULT_FILE_CASING
83817>>>>>>>///
83817>>>>>>>/// @Syntax GET_DEFAULT_FILE_CASING to {variable}
83817>>>>>>>/// @Param variable                     Variable to hold the returned casing
83817>>>>>>>///
83817>>>>>>>/// @Example
83817>>>>>>>/// GET_DEFAULT_FILE_CASING TO iCasing
83817>>>>>>>
83817>>>>>>>//=============================================================================
83817>>>>>>>/// @Name        SET_DEFAULT_TABLESPACE
83817>>>>>>>/// @Description This command sets the default table space to use when
83817>>>>>>>/// creating tables through Dataflex. A tablespace is a container of
83817>>>>>>>/// segments (objects that have an allotted amount of space), i.e. tables
83817>>>>>>>/// and indexes.
83817>>>>>>>///
83817>>>>>>>/// @Assumptions
83817>>>>>>>/// @Status      Public
83817>>>>>>>/// @Drivers     ORAFlex, PgFlex
83817>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
83817>>>>>>>/// @See                 GET_DEFAULT_TABLESPACE SET_DEFAULT_INDEX_TABLESPACE GET_DEFAULT_INDEX_TABLESPACE
83817>>>>>>>///
83817>>>>>>>/// @Syntax SET_DEFAULT_TABLESPACE to {variable}
83817>>>>>>>/// @Param variable                     Name of the default table space
83817>>>>>>>///
83817>>>>>>>/// @Example
83817>>>>>>>/// SET_DEFAULT_TABLESPACE to "Users"
83817>>>>>>>
83817>>>>>>>//=============================================================================
83817>>>>>>>/// @Name        GET_DEFAULT_TABLESPACE
83817>>>>>>>/// @Description This command returns the default table space name for
83817>>>>>>>/// the current database.
83817>>>>>>>///
83817>>>>>>>/// @Assumptions
83817>>>>>>>/// @Status      Public
83817>>>>>>>/// @Drivers     ORAFlex, PgFlex
83817>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
83817>>>>>>>/// @See                 SET_DEFAULT_TABLESPACE SET_DEFAULT_INDEX_TABLESPACE GET_DEFAULT_INDEX_TABLESPACE
83817>>>>>>>///
83817>>>>>>>/// @Syntax GET_DEFAULT_TABLESPACE to {variable}
83817>>>>>>>/// @Param variable                     Variable to hold the default table space name.
83817>>>>>>>///
83817>>>>>>>/// @Example
83817>>>>>>>/// GET_DEFAULT_TABLESPACE to sTableSpace
83817>>>>>>>
83817>>>>>>>//=============================================================================
83817>>>>>>>/// @Name        SET_DEFAULT_INDEX_TABLESPACE
83817>>>>>>>/// @Description This command sets the default table space for indexes
83817>>>>>>>/// when creating tables through the DataFlex API. A tablespace is a
83817>>>>>>>/// container of segments (objects that have an allotted amount of space),
83817>>>>>>>/// i.e. tables and indexes.
83817>>>>>>>///
83817>>>>>>>/// @Assumptions
83817>>>>>>>/// @Status      Public
83817>>>>>>>/// @Drivers     ORAFlex, PgFlex
83817>>>>>>>/// @VersionNote Last Revised: 2013-10-09-2013 by Aaron Gulack
83817>>>>>>>/// @See                 SET_DEFAULT_TABLESPACE GET_DEFAULT_TABLESPACE GET_DEFAULT_INDEX_TABLESPACE
83817>>>>>>>///
83817>>>>>>>/// @Syntax SET_DEFAULT_INDEX_TABLESPACE to {variable}
83817>>>>>>>/// @Param variable                     Variable to hold the default index table space name.
83817>>>>>>>///
83817>>>>>>>/// @Example
83817>>>>>>>/// SET_DEFAULT_INDEX_TABLESPACE to "Users"
83817>>>>>>>
83817>>>>>>>//=============================================================================
83817>>>>>>>/// @Name        GET_DEFAULT_INDEX_TABLESPACE
83817>>>>>>>/// @Description This command returns the default table space name for
83817>>>>>>>/// indexes in the current database.
83817>>>>>>>///
83817>>>>>>>/// @Assumptions
83817>>>>>>>/// @Status      Public
83817>>>>>>>/// @Drivers     ORAFlex, PgFlex
83817>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
83817>>>>>>>/// @See                 SET_DEFAULT_TABLESPACE GET_DEFAULT_TABLESPACE SET_DEFAULT_INDEX_TABLESPACE
83817>>>>>>>///
83817>>>>>>>/// @Syntax GET_DEFAULT_INDEX_TABLESPACE to {variable}
83817>>>>>>>/// @Param variable                     Variable to hold the default index table space name.
83817>>>>>>>///
83817>>>>>>>/// @Example
83817>>>>>>>/// GET_DEFAULT_INDEX_TABLESPACE to sTableSpace
83817>>>>>>>
83817>>>>>>>//=============================================================================
83817>>>>>>>/// @Name        ENABLE_SCRIPTING
83817>>>>>>>/// @Description Scripting is used for testing and preparation. This
83817>>>>>>>/// command allows structural changes to be compiled and tested without
83817>>>>>>>/// actually making any of the changes. Any table restructuring done
83817>>>>>>>/// between this command and DISABLE_SCRIPTING will not actually be
83817>>>>>>>/// committed but will instead create a mock INT file. The script and
83817>>>>>>>/// INT file can then be retrieved and examined for testing purposes.
83817>>>>>>>///
83817>>>>>>>/// @Assumptions
83817>>>>>>>/// @Status      Public
83817>>>>>>>/// @Drivers     All
83817>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
83817>>>>>>>/// @See                 DISABLE_SCRIPTING GET_SQL_SCRIPT_CHUNK GET_INT_CHUNK
83817>>>>>>>///
83817>>>>>>>/// @Syntax ENABLE_SCRIPTING
83817>>>>>>>///
83817>>>>>>>/// @Example
83817>>>>>>>/// ENABLE_SCRIPTING
83817>>>>>>>///     //Table restructuring would go here
83817>>>>>>>/// DISABLE_SCRIPTING
83817>>>>>>>///
83817>>>>>>>/// GET_SQL_SCRIPT_CHUNK OFFSET 0 to sChunk sLength
83817>>>>>>>/// Showln sChunk
83817>>>>>>>
83817>>>>>>>//=============================================================================
83817>>>>>>>/// @Name        DISABLE_SCRIPTING
83817>>>>>>>/// @Description This command ends any scripting started by ENABLE_SCRIPTING.
83817>>>>>>>/// The mock INT file and script can then be retrieved and examined.
83817>>>>>>>///
83817>>>>>>>/// @Assumptions
83817>>>>>>>/// @Status      Public
83817>>>>>>>/// @Drivers     All
83817>>>>>>>/// @VersionNote Last Revised: 2010-12-13 By Marcelo Nachbar
83817>>>>>>>/// @See                 ENABLE_SCRIPTING  GET_SQL_SCRIPT_CHUNK GET_INT_CHUNK
83817>>>>>>>///
83817>>>>>>>/// @Syntax DISABLE_SCRIPTING
83817>>>>>>>///
83817>>>>>>>/// @Example
83817>>>>>>>/// ENABLE_SCRIPTING
83817>>>>>>>///     //Table restructuring would go here
83817>>>>>>>/// DISABLE_SCRIPTING
83817>>>>>>>///
83817>>>>>>>/// GET_SQL_SCRIPT_CHUNK OFFSET 0 to sChunk sLength
83817>>>>>>>/// Showln sChunk
83817>>>>>>>
83817>>>>>>>Function MertechInc_GET_RESTRUCTURE_SCRIPT Global Integer iLong Integer iOffset Returns String
83819>>>>>>>    Integer iChuck_Size
83819>>>>>>>    String sChunk
83819>>>>>>>
83819>>>>>>>    //Get current Chuck size and pre size string
83819>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_CHUNK_SIZE CALLBACK 0 PASSING iChuck_Size MertechInc_Blank 1 RESULT MertechInc_iRet
83824>>>>>>>    Get MertechInc_Pre_Size_String iChuck_Size to sChunk
83825>>>>>>>
83825>>>>>>>    //Get data
83825>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_RESTRUCTURE_SCRIPT CALLBACK 0 PASSING sChunk iOffset iLong RESULT MertechInc_iRet
83830>>>>>>>
83830>>>>>>>    // Replace insert a CR before any LF character
83830>>>>>>>    Move (Replaces(Character(10), sChunk, Character(13)+Character(10))) to sChunk
83831>>>>>>>
83831>>>>>>>    Function_Return sChunk
83832>>>>>>>End_Function
83833>>>>>>>
83833>>>>>>>
83833>>>>>>>//=============================================================================
83833>>>>>>>/// @Name        GET_SQL_SCRIPT_CHUNK
83833>>>>>>>/// @Description This command returns a chunk of the script generated
83833>>>>>>>/// from the restructuring done inside of ENABLE_SCRIPTING and
83833>>>>>>>/// DISABLE_SCRIPTING. Since some scripts can be very large, the script
83833>>>>>>>/// can be looped through, grabbing chunks at a time.
83833>>>>>>>///
83833>>>>>>>/// @Assumptions
83833>>>>>>>/// @Status      Public
83833>>>>>>>/// @Drivers     All
83833>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
83833>>>>>>>/// @See                 ENABLE_SCRIPTING DISABLE_SCRIPTING GET_INT_CHUNK
83833>>>>>>>///
83833>>>>>>>/// @Syntax GET_SQL_SCRIPT_CHUNK OFFSET {offset} to {variable} [{length}]
83833>>>>>>>/// @Param offset                       Specifies the offset to start at for the chunk
83833>>>>>>>/// @Param variable                     Variable to hold the chunk
83833>>>>>>>/// @Param length                       Length of chunk returned (optional)
83833>>>>>>>///
83833>>>>>>>/// @Example
83833>>>>>>>/// ENABLE_SCRIPTING
83833>>>>>>>///     //Table restructuring would go here
83833>>>>>>>/// DISABLE_SCRIPTING
83833>>>>>>>///
83833>>>>>>>/// GET_SQL_SCRIPT_CHUNK OFFSET 0 to sChunk sLength
83833>>>>>>>/// Showln sChunk
83833>>>>>>>
83833>>>>>>>//=============================================================================
83833>>>>>>>/// @Name        GET_INT_CHUNK
83833>>>>>>>/// @Description This command returns a chunk of the INT file generated
83833>>>>>>>/// from the restructuring done inside of ENABLE_SCRIPTING and
83833>>>>>>>/// DISABLE_SCRIPTING. Since some INT files can be very large, the file
83833>>>>>>>/// can be looped through, grabbing chunks at a time.
83833>>>>>>>///
83833>>>>>>>/// @Assumptions
83833>>>>>>>/// @Status      Public
83833>>>>>>>/// @Drivers     All
83833>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
83833>>>>>>>/// @See                 ENABLE_SCRIPTING DISABLE_SCRIPTING GET_SQL_SCRIPT_CHUNK
83833>>>>>>>///
83833>>>>>>>/// @Syntax GET_INT_CHUNK OFFSET {offset} to {variable} [{length}]
83833>>>>>>>/// @Param offset                       Specifies the offset to start at for the chunk
83833>>>>>>>/// @Param variable                     Variable to hold the chunk
83833>>>>>>>/// @Param length                       Length of chunk returned (optional)
83833>>>>>>>///
83833>>>>>>>/// @Example
83833>>>>>>>/// ENABLE_SCRIPTING
83833>>>>>>>///     //Table restructuring would go here
83833>>>>>>>/// DISABLE_SCRIPTING
83833>>>>>>>///
83833>>>>>>>/// GET_INT_CHUNK OFFSET 0 to sChunk sLength
83833>>>>>>>/// Showln sChunk
83833>>>>>>>
83833>>>>>>>//=============================================================================
83833>>>>>>>/// @Name        REPORT_STMT
83833>>>>>>>/// @Description This command is an alternative to DataFlex's "Report"
83833>>>>>>>/// command. This allows embedded SQL to be used to fetch data instead of
83833>>>>>>>/// standard table queries.. All of the finds, for example, normally found
83833>>>>>>>/// in "Report" are replaced by SQL_FETCH_NEXT_ROW.
83833>>>>>>>///
83833>>>>>>>/// @Assumptions
83833>>>>>>>/// @Status      Public
83833>>>>>>>/// @Drivers     n/a
83833>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
83833>>>>>>>/// @See
83833>>>>>>>///
83833>>>>>>>/// @Syntax See DataFlex / Visual DataFlex documentation
83833>>>>>>>///
83833>>>>>>>/// @Example
83833>>>>>>>/// /Header
83833>>>>>>>/// __/__/____                                                        Page ___.
83833>>>>>>>///                 MERTECH DATA SYSTEMS, INC. - NOT FOR RESALE
83833>>>>>>>///
83833>>>>>>>/// ID   NAME
83833>>>>>>>///
83833>>>>>>>/// /Body
83833>>>>>>>/// ____ _________________________
83833>>>>>>>/// /Total
83833>>>>>>>/// Records printed = _______.
83833>>>>>>>/// /*
83833>>>>>>>///
83833>>>>>>>///
83833>>>>>>>/// OPEN SALESP
83833>>>>>>>/// direct_output "con:"
83833>>>>>>>/// // Write the complete SELECT statement to retrieve the expected records from your REPORT
83833>>>>>>>/// // Must include the expression to qualify the required records and specify the order by as well
83833>>>>>>>///
83833>>>>>>>/// sql_set_stmt of salesp to "select recnum, id, name from SALESP where recnum > 5 order by id"
83833>>>>>>>/// sql_prepare_stmt of salesp
83833>>>>>>>/// sql_bindcolumns_stmt of salesp to salesp.recnum salesp.id salesp.name
83833>>>>>>>/// sql_execute_stmt of salesp
83833>>>>>>>///
83833>>>>>>>/// Report_stmt SALESP By Index.1
83833>>>>>>>///
83833>>>>>>>/// Section Header
83833>>>>>>>///     Sysdate Header.1
83833>>>>>>>///     Move PageCount to Header.2
83833>>>>>>>///     output header
83833>>>>>>>///
83833>>>>>>>/// Section Body
83833>>>>>>>///     Print Salesp.id   to Body.1
83833>>>>>>>///     Print Salesp.name to Body.2
83833>>>>>>>///     output body
83833>>>>>>>/// Section Total
83833>>>>>>>///
83833>>>>>>>/// Return
83833>>>>>>>/// ReportEnd
83833>>>>>>>
83833>>>>>>>//=============================================================================
83833>>>>>>>/// @Name        GET_SERVER_CFG
83833>>>>>>>/// @Description This command, when passed a valid server name, returns
83833>>>>>>>/// the a value for the specified attribute. See the list below for an
83833>>>>>>>/// explanation of each attribute.
83833>>>>>>>///
83833>>>>>>>/// SERVER_REVISION    Returns the major version, to the left of the decimal, of the server
83833>>>>>>>/// SUPPORT_DESC       Returns 1 if Server supports descending index segments
83833>>>>>>>/// SUPPORT_CASE       Returns 1 if Server supports case insensitive index segments
83833>>>>>>>/// SERVER_VERSION     Returns the full version of the server
83833>>>>>>>/// SERVER_ENCODING    Returns the Server Encoding
83833>>>>>>>/// CONNECTION_ACTIVE  Returns 1 if the connection to the server is active
83833>>>>>>>/// CITEXT_SUPPORT     Returns 1 if Server supports citext, a PostgreSQL data type
83833>>>>>>>///
83833>>>>>>>/// @Assumptions
83833>>>>>>>/// @Status      Internal
83833>>>>>>>/// @Drivers     All
83833>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
83833>>>>>>>/// @See
83833>>>>>>>///
83833>>>>>>>/// @Syntax GET_SERVER_CFG {constant} of {server} to {variable}
83833>>>>>>>/// @Param constant                     SERVER_REVISION,SERVER_MIN_REVISION,SUPPORT_DESC,SUPPORT_CASE,SERVER_VERSION,SERVER_ENCODING,CONNECTION_ACTIVE
83833>>>>>>>/// @Param server                       Name of the server being checked
83833>>>>>>>/// @Param variable                     Variable to hold the returned value
83833>>>>>>>///
83833>>>>>>>/// @Example
83833>>>>>>>/// GET_SERVER_CFG SERVER_VERSION of "localhost" to sVersion
83833>>>>>>>
83833>>>>>>>Function MertechInc_GET_SERVER_CFG Global String sServer Integer iAttribute Returns String
83835>>>>>>>    String sReturnValue
83835>>>>>>>
83835>>>>>>>    Get MertechInc_Pre_Size_String 512 to sReturnValue
83836>>>>>>>
83836>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_GET_SERVER_CFG CALLBACK 0 PASSING sServer sReturnValue iAttribute RESULT MertechInc_iRet
83841>>>>>>>
83841>>>>>>>    //If iAttribute = SERVER_VERSION or SERVER_ENCODING then return sReturnValue
83841>>>>>>>    //else we need to return MertechInc_iRet
83841>>>>>>>    If ((iAttribute = 4) or (iAttribute = 5)) Function_Return sReturnValue
83844>>>>>>>    Else                                      Function_Return MertechInc_iRet
83846>>>>>>>End_Function
83847>>>>>>>
83847>>>>>>>//=============================================================================
83847>>>>>>>/// @Name        GET_CONNECTION_STATUS
83847>>>>>>>/// @Description Retrieve the connection status for the specified server.
83847>>>>>>>///
83847>>>>>>>/// @Assumptions
83847>>>>>>>/// @Status      Internal
83847>>>>>>>/// @Drivers     All
83847>>>>>>>/// @VersionNote Last Revised: 2009-09-25 By Ian Smith
83847>>>>>>>/// @See
83847>>>>>>>///
83847>>>>>>>/// @Syntax GET_CONNECTION_STATUS of <serverName> [<databaseName>] to <variable>
83847>>>>>>>/// @Param serverName    Server Name
83847>>>>>>>/// @Param databaseName  Database Name
83847>>>>>>>/// @Param variable      DFTRUE means connection is active
83847>>>>>>>
83847>>>>>>>//=============================================================================
83847>>>>>>>/// @Name        GET_CLIENT_CFG
83847>>>>>>>/// @Description Returns the client character encoding (or encoding ID) information.
83847>>>>>>>///
83847>>>>>>>/// @Assumptions
83847>>>>>>>/// @Status      Internal
83847>>>>>>>/// @Drivers     MySQLFlex and PgFlex
83847>>>>>>>/// @VersionNote Last Revised: 2009-09-25 By Ian Smith
83847>>>>>>>/// @See
83847>>>>>>>///
83847>>>>>>>/// @Syntax GET_CLIENT_CFG [ENCODING | ENCODING_ID] of <Server> [<MySQL_Database>] to <Var>
83847>>>>>>>/// @Param Server           Server name to get encoding of
83847>>>>>>>/// @Param MySQL_Database   Database if   is the File Name
83847>>>>>>>/// @Param Var              Variable to hold returned value
83847>>>>>>>
83847>>>>>>>//=============================================================================
83847>>>>>>>/// @Name        SET_CLIENT_CFG
83847>>>>>>>/// @Description Returns the client character encoding (or encoding ID) information.
83847>>>>>>>///
83847>>>>>>>/// @Assumptions
83847>>>>>>>/// @Status      Internal
83847>>>>>>>/// @Drivers     MySQLFlex and PgFlex
83847>>>>>>>/// @VersionNote Last Revised: 2009-09-25 By Ian Smith
83847>>>>>>>/// @See
83847>>>>>>>///
83847>>>>>>>/// @Syntax SET_CLIENT_CFG [ENCODING | UNIQUE_CHECKS] of <Server> [<MySQL_Database>] to <Value>
83847>>>>>>>/// @Param Server           Server name to get encoding of
83847>>>>>>>/// @Param MySQL_Database   Database if   is the File Name
83847>>>>>>>/// @Param Value            Value to set
83847>>>>>>>///
83847>>>>>>>/// @Comment ENCODING - Set the Client Encoding
83847>>>>>>>/// @Comment UNIQUE_CHECKS {DFTRUE/DFFALSE} - enable/disable uniqueness checks for secondary indexes in InnoDB tables
83847>>>>>>>
83847>>>>>>>//=============================================================================
83847>>>>>>>/// @Name        CALL_DB2_PROCEDURE
83847>>>>>>>/// @Description Executes a DB2 Server stored procedure.
83847>>>>>>>/// @Status      Public
83847>>>>>>>/// @Drivers     DB2Flex
83847>>>>>>>/// @VersionNote Last Revised: 2009-08-19 By Ian Smith
83847>>>>>>>///
83847>>>>>>>/// @Syntax CALL_DB2_PROCEDURE <OWNER> <STORED_PROC> {PASSING <ARG1> {. <ARGn>}}
83847>>>>>>>/// @Param Owner        Name of the Procedure's Owner.
83847>>>>>>>/// @Param Stored_Proc  Full name of the stored procedure being called.
83847>>>>>>>/// @Param Arg1..Argn   Arguments passed to the procedure.
83847>>>>>>>///
83847>>>>>>>
83847>>>>>>>//=============================================================================
83847>>>>>>>/// @Name        GET_RESULTS
83847>>>>>>>/// @Description Returns the initial result set.
83847>>>>>>>/// @Status      Public
83847>>>>>>>/// @Drivers     DB2Flex
83847>>>>>>>/// @VersionNote Last Revised: 2009-08-19 By Ian Smith
83847>>>>>>>///
83847>>>>>>>/// @Syntax GET_RESULTS
83847>>>>>>>
83847>>>>>>>//=============================================================================
83847>>>>>>>/// @Name        GET_MORE_RESULTS
83847>>>>>>>/// @Description Returns remaining values not retrieved with GET_RESULT.
83847>>>>>>>/// @Status      Public
83847>>>>>>>/// @Drivers     DB2Flex
83847>>>>>>>/// @VersionNote Last Revised: 2009-08-19 By Ian Smith
83847>>>>>>>///
83847>>>>>>>/// @Syntax GET_MORE_RESULTS
83847>>>>>>>
83847>>>>>>>//=============================================================================
83847>>>>>>>/// @Name        GET_CURRENT_USER_NAME
83847>>>>>>>/// @Description This command is used to get the name of the user currently
83847>>>>>>>/// logged into the server.
83847>>>>>>>///
83847>>>>>>>/// @Assumptions
83847>>>>>>>/// @Status      Public
83847>>>>>>>/// @Drivers     All
83847>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
83847>>>>>>>/// @See                 GET_CURRENT_USER_PASSWORD
83847>>>>>>>///
83847>>>>>>>/// @Syntax GET_CURRENT_USER_NAME of {server} to {variable}
83847>>>>>>>/// @Param server               The name of the server the user is in
83847>>>>>>>/// @Param variable             Variable to hold the username
83847>>>>>>>///
83847>>>>>>>/// @Example
83847>>>>>>>/// GET_CURRENT_USER_NAME of "localhost" to sUserName
83847>>>>>>>
83847>>>>>>>//=============================================================================
83847>>>>>>>/// @Name        GET_CURRENT_USER_PASSWORD
83847>>>>>>>/// @Description This command is used to get the password associated with
83847>>>>>>>/// the user currently logged into the server.
83847>>>>>>>///
83847>>>>>>>/// @Assumptions
83847>>>>>>>/// @Status      Public
83847>>>>>>>/// @Drivers     All
83847>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
83847>>>>>>>/// @See                 GET_CURRENT_USER_NAME
83847>>>>>>>///
83847>>>>>>>/// @Syntax GET_CURRENT_USER_PASSWORD of {server} to {variable}
83847>>>>>>>/// @Param server               The name of the server the user is in
83847>>>>>>>/// @Param variable             Variable to hold the password
83847>>>>>>>///
83847>>>>>>>/// @Example
83847>>>>>>>/// GET_CURRENT_USER_PASSWORD of "localhost" to sPassword
83847>>>>>>>
83847>>>>>>>//=============================================================================
83847>>>>>>>/// @Name        CREATE_DB2_DATABASE
83847>>>>>>>/// @Description Creates a DB2 database with the same DataFlex collating sequence.
83847>>>>>>>/// @Status      Public
83847>>>>>>>/// @Drivers     All
83847>>>>>>>/// @VersionNote Last Revised: 2009-08-12 By Ian Smith
83847>>>>>>>///
83847>>>>>>>/// @Syntax CREATE_DB2_DATABASE <DB Name> <DB Alias> <Code Set> <Territory> [<Path> <Node Name> <User ID><Password>]
83847>>>>>>>/// @Param DB Name     Name of the database being created
83847>>>>>>>/// @Param DB Alias    Alias Name applied to the database being created
83847>>>>>>>/// @Param Code Set    Code Set used by the database being created
83847>>>>>>>/// @Param Territory   Territory associated to the database being created
83847>>>>>>>/// @Param Path        Location of the database                                    - Optional
83847>>>>>>>/// @Param Node Name   Name of the machine (node) where the database is to reside  - Optional
83847>>>>>>>/// @Param User ID     User ID owning the database                                 - Optional
83847>>>>>>>/// @Param Password    Password of the User owning the database                    - Optional
83847>>>>>>>///
83847>>>>>>>
83847>>>>>>>//=============================================================================
83847>>>>>>>/// @Name        SQL_OPEN_CURSOR_STMT
83847>>>>>>>/// @Description This command is used to create a new SQl Cursor. Once
83847>>>>>>>/// created, SQL_SET_CURRENT_CURSOR_STMT can be called to specify which
83847>>>>>>>/// cursor is to be used for a given SQL statement. Creating multiple
83847>>>>>>>/// cursors using this command allows multiple SQL statements to be
83847>>>>>>>/// opened at once. Optionally a different server can be specified for each
83847>>>>>>>/// cursor by passing the server name to this command as well. If no
83847>>>>>>>/// server is specified, the current server will be used. Note that it
83847>>>>>>>/// is important to close all cursors at the end using SQL_CLOSE_CURSOR_STMT.
83847>>>>>>>///
83847>>>>>>>/// @Assumptions
83847>>>>>>>/// @Status      Public
83847>>>>>>>/// @Drivers     All
83847>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
83847>>>>>>>/// @See                 SQL_CLOSE_CURSOR_STMT SQL_SET_CURRENT_CURSOR_STMT SQL_GET_CURRENT_CURSOR_STMT
83847>>>>>>>///
83847>>>>>>>/// @Syntax SQL_OPEN_CURSOR_STMT [of {server}] to {variable}
83847>>>>>>>/// @Param server                       Name of the server (optional)
83847>>>>>>>/// @Param variable                     Variable to hold the returned cursor handle
83847>>>>>>>///
83847>>>>>>>/// @Example
83847>>>>>>>///
83847>>>>>>>/// Integer iCursor1 iCursor2 iCustomer
83847>>>>>>>/// String  sName
83847>>>>>>>/// Number  nOrderTotal
83847>>>>>>>///
83847>>>>>>>/// SQL_OPEN_CURSOR_STMT to iCursor1
83847>>>>>>>/// SQL_SET_STMT         to "SELECT CUSTOMER_NUMBER,NAME FROM CUSTOMER "
83847>>>>>>>/// SQL_APPEND_STMT      to "ORDER BY NAME "
83847>>>>>>>/// SQL_PREPARE_STMT
83847>>>>>>>/// SQL_EXECUTE_STMT
83847>>>>>>>/// Repeat
83847>>>>>>>///     SQL_SET_CURRENT_CURSOR_STMT TO iCursor1
83847>>>>>>>///     SQL_FETCH_NEXT_ROW INTO iCustomer sName
83847>>>>>>>///     If (Found) Begin
83847>>>>>>>///        SQL_OPEN_CURSOR_STMT to iCursor2
83847>>>>>>>///        SQL_SET_STMT         to "SELECT SUM(ORDER_TOTAL) FROM ORDERHEA "
83847>>>>>>>///        SQL_APPEND_STMT      to ("WHERE CUSTOMER_NUMBER = " + Trim(iCustomer))
83847>>>>>>>///        SQL_PREPARE_STMT
83847>>>>>>>///        SQL_EXECUTE_STMT
83847>>>>>>>///        SQL_FETCH_NEXT_ROW INTO nOrderTotal
83847>>>>>>>///        If (Found and nOrderTotal > 0) Begin
83847>>>>>>>///            Showln "Customer : " iCustomer "-" sName " - Total: " nOrderTotal
83847>>>>>>>///        End
83847>>>>>>>///        SQL_CLOSE_CURSOR_STMT to Cursor2
83847>>>>>>>///
83847>>>>>>>///        Indicate Found True
83847>>>>>>>///     End
83847>>>>>>>/// Until (Not(Found))
83847>>>>>>>///
83847>>>>>>>/// SQL_CLOSE_CURSOR_STMT to Cursor1
83847>>>>>>>
83847>>>>>>>//=============================================================================
83847>>>>>>>/// @Name        SQL_CLOSE_CURSOR_STMT
83847>>>>>>>/// @Description This command closes the specified cursor that was created
83847>>>>>>>/// from SQL_OPEN_CURSOR_STMT. It is good practice to close all cursors
83847>>>>>>>/// once the statements associated with them are complete.
83847>>>>>>>///
83847>>>>>>>/// @Assumptions
83847>>>>>>>/// @Status      Public
83847>>>>>>>/// @Drivers     All
83847>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
83847>>>>>>>/// @See                 SQL_OPEN_CURSOR_STMT SQL_SET_CURRENT_CURSOR_STMT SQL_GET_CURRENT_CURSOR_STMT
83847>>>>>>>///
83847>>>>>>>/// @Syntax SQL_CLOSE_CURSOR_STMT [of {server}] to {variable}
83847>>>>>>>/// @Param server                       Name of the server (optional)
83847>>>>>>>/// @Param variable                     Cursor handle to close
83847>>>>>>>///
83847>>>>>>>/// @Example
83847>>>>>>>///
83847>>>>>>>/// SQL_OPEN_CURSOR_STMT to hCursor1
83847>>>>>>>///
83847>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
83847>>>>>>>/// SQL_PREPARE_STMT
83847>>>>>>>/// SQL_EXECUTE_STMT
83847>>>>>>>///
83847>>>>>>>/// SQL_OPEN_CURSOR_STMT to hCursor2
83847>>>>>>>///
83847>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Inactive' "
83847>>>>>>>/// SQL_PREPARE_STMT
83847>>>>>>>/// SQL_EXECUTE_STMT
83847>>>>>>>///
83847>>>>>>>/// Repeat
83847>>>>>>>///     SQL_SET_CURRENT_CURSOR_STMT to hCursor1
83847>>>>>>>///     SQL_FETCH_NEXT_ROW INTO  sID sFirstName sLastName
83847>>>>>>>///     If (Found) Begin
83847>>>>>>>///        Showln "Active : " sID "- " sFirstName sLastName
83847>>>>>>>///     End
83847>>>>>>>///
83847>>>>>>>///     SQL_SET_CURRENT_CURSOR_STMT to hCursor2
83847>>>>>>>///     SQL_FETCH_NEXT_ROW into sId sFirstName sLastName
83847>>>>>>>///     If (Found) Begin
83847>>>>>>>///         Showln "Inactive : " sID "- " sFirstName sLastName
83847>>>>>>>///     End
83847>>>>>>>/// Until (FindErr)
83847>>>>>>>///
83847>>>>>>>/// SQL_CLOSE_CURSOR_STMT to hCursor1
83847>>>>>>>/// SQL_CLOSE_CURSOR_STMT to hCursor2
83847>>>>>>>
83847>>>>>>>//=============================================================================
83847>>>>>>>/// @Name        SQL_SET_CURRENT_CURSOR_STMT
83847>>>>>>>/// @Description This command is used to open a cursor to be used for an
83847>>>>>>>/// SQl statement. The cursor must be created using the SQL_OPEN_CURSOR_STMT,
83847>>>>>>>/// but once it has been created, this command can easily switch between
83847>>>>>>>/// cursors as desired. Optionally a different server can be specified for each
83847>>>>>>>/// cursor by passing the server name to this command as well. If no
83847>>>>>>>/// server is specified, the current server will be used. Note that it
83847>>>>>>>/// is important to close all cursors at the end using SQL_CLOSE_CURSOR_STMT.
83847>>>>>>>///
83847>>>>>>>/// @Assumptions
83847>>>>>>>/// @Status      Public
83847>>>>>>>/// @Drivers     All
83847>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
83847>>>>>>>/// @See                 SQL_OPEN_CURSOR_STMT SQL_CLOSE_CURSOR_STMT SQL_GET_CURRENT_CURSOR_STMT
83847>>>>>>>///
83847>>>>>>>/// @Syntax SQL_SET_CURRENT_CURSOR_STMT [of {server}] to {variable}
83847>>>>>>>/// @Param server                       Name of the server (optional)
83847>>>>>>>/// @Param variable                     Cursor handle to use
83847>>>>>>>///
83847>>>>>>>/// @Example
83847>>>>>>>///
83847>>>>>>>/// SQL_OPEN_CURSOR_STMT to hCursor1
83847>>>>>>>///
83847>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
83847>>>>>>>/// SQL_PREPARE_STMT
83847>>>>>>>/// SQL_EXECUTE_STMT
83847>>>>>>>///
83847>>>>>>>/// SQL_OPEN_CURSOR_STMT to hCursor2
83847>>>>>>>///
83847>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Inactive' "
83847>>>>>>>/// SQL_PREPARE_STMT
83847>>>>>>>/// SQL_EXECUTE_STMT
83847>>>>>>>///
83847>>>>>>>/// Repeat
83847>>>>>>>///     SQL_SET_CURRENT_CURSOR_STMT to hCursor1
83847>>>>>>>///     SQL_FETCH_NEXT_ROW INTO  sID sFirstName sLastName
83847>>>>>>>///     If (Found) Begin
83847>>>>>>>///        Showln "Active : " sID "- " sFirstName sLastName
83847>>>>>>>///     End
83847>>>>>>>///
83847>>>>>>>///     SQL_SET_CURRENT_CURSOR_STMT to hCursor2
83847>>>>>>>///     SQL_FETCH_NEXT_ROW into sId sFirstName sLastName
83847>>>>>>>///     If (Found) Begin
83847>>>>>>>///         Showln "Inactive : " sID "- " sFirstName sLastName
83847>>>>>>>///     End
83847>>>>>>>/// Until (FindErr)
83847>>>>>>>///
83847>>>>>>>/// SQL_CLOSE_CURSOR_STMT to hCursor1
83847>>>>>>>/// SQL_CLOSE_CURSOR_STMT to hCursor2
83847>>>>>>>
83847>>>>>>>//=============================================================================
83847>>>>>>>/// @Name        SQL_GET_CURRENT_CURSOR_STMT
83847>>>>>>>/// @Description This command returns the current active cursor being
83847>>>>>>>/// used. The cursor is returned to the specified variable.
83847>>>>>>>///
83847>>>>>>>/// @Assumptions
83847>>>>>>>/// @Status      Public
83847>>>>>>>/// @Drivers     All
83847>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
83847>>>>>>>/// @See SQL_OPEN_CURSOR_STMT SQL_CLOSE_CURSOR_STMT SQL_SET_CURRENT_CURSOR_STMT
83847>>>>>>>///
83847>>>>>>>/// @Syntax SQL_GET_CURRENT_CURSOR_STMT [of {server}] to {variable}
83847>>>>>>>/// @Param server                       Name of the server (optional)
83847>>>>>>>/// @Param variable         Variable to hold the current cursor handle
83847>>>>>>>///
83847>>>>>>>/// @Example
83847>>>>>>>/// SQL_GET_CURRENT_CURSOR_STMT to hCursor
83847>>>>>>>
83847>>>>>>>//=============================================================================
83847>>>>>>>/// @Name        SQL_SET_MAX_CURSORS_STMT
83847>>>>>>>/// @Description Sets the maximum number of simultaneous cursors allowed.
83847>>>>>>>///
83847>>>>>>>/// @Assumptions
83847>>>>>>>/// @Status      Deprecated
83847>>>>>>>/// @Drivers     All
83847>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
83847>>>>>>>/// @See
83847>>>>>>>///
83847>>>>>>>/// @Syntax SQL_SET_MAX_CURSORS_STMT [of {server}] to {variable}
83847>>>>>>>/// @Param server                       Name of the server (optional)
83847>>>>>>>/// @Param variable                     Maximum number of cursors allowed
83847>>>>>>>///
83847>>>>>>>/// @Example
83847>>>>>>>/// SQL_SET_MAX_CURSORS_STMT to 50
83847>>>>>>>
83847>>>>>>>//=============================================================================
83847>>>>>>>/// @Name        SQL_GET_MAX_CURSORS_STMT
83847>>>>>>>/// @Description Retrieves the maximum number of cursors allowed.
83847>>>>>>>///
83847>>>>>>>/// @Assumptions
83847>>>>>>>/// @Status      Deprecated
83847>>>>>>>/// @Drivers     All
83847>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
83847>>>>>>>/// @See
83847>>>>>>>///
83847>>>>>>>/// @Syntax SQL_GET_MAX_CURSORS_STMT [of {server}] to {variable}
83847>>>>>>>/// @Param server                       Name of the server (optional)
83847>>>>>>>/// @Param variable                     Maximum number of cursors allowed
83847>>>>>>>///
83847>>>>>>>/// @Example
83847>>>>>>>/// SQL_GET_MAX_CURSORS_STMT to iCursors
83847>>>>>>>
83847>>>>>>>//=============================================================================
83847>>>>>>>/// @Name        SQL_SET_LOCAL_TD_PATH
83847>>>>>>>/// @Description Sets the directory where the driver will find the LOCAL TD files.
83847>>>>>>>/// @Status      Deprecated
83847>>>>>>>/// @Drivers     All
83847>>>>>>>/// @VersionNote Last Revised: 2009-08-19 By Ian Smith
83847>>>>>>>///
83847>>>>>>>/// @Syntax SQL_SET_LOCAL_TD_PATH TO <DirectoryPath|Variable>
83847>>>>>>>/// @Param DirectoryPath   Directory path were the TD files are to be located.
83847>>>>>>>
83847>>>>>>>//=============================================================================
83847>>>>>>>/// @Name        SQL_GET_LOCAL_TD_PATH
83847>>>>>>>/// @Description Gets the directory where the driver is looking for the LOCAL TD files.
83847>>>>>>>/// @Status      Deprecated
83847>>>>>>>/// @Drivers     All
83847>>>>>>>/// @VersionNote Last Revised: 2009-08-19 By Ian Smith
83847>>>>>>>///
83847>>>>>>>/// @Syntax SQL_SET_LOCAL_TD_PATH TO <DirectoryPath|Variable>
83847>>>>>>>/// @Param DirectoryPath   Directory path were the driver is looking
83847>>>>>>>
83847>>>>>>>//=============================================================================
83847>>>>>>>/// @Name        GET_DRIVER_REVISION
83847>>>>>>>/// @Description This command will put the current version (decimals included)
83847>>>>>>>/// of the driver associated with the current workspace into the specified
83847>>>>>>>/// variable.
83847>>>>>>>///
83847>>>>>>>/// @Assumptions
83847>>>>>>>/// @Status      Public
83847>>>>>>>/// @Drivers     All
83847>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
83847>>>>>>>/// @See                 GET_DRIVER_MAJOR_REVISION
83847>>>>>>>///
83847>>>>>>>/// @Syntax GET_DRIVER_REVISION to {variable}
83847>>>>>>>/// @Param variable                     String variable to hold the returned version
83847>>>>>>>///
83847>>>>>>>/// @Example
83847>>>>>>>/// GET_DRIVER_REVISION to sVersion
83847>>>>>>>
83847>>>>>>>//=============================================================================
83847>>>>>>>/// @Name        GET_DRIVER_MAJOR_REVISION
83847>>>>>>>/// @Description This command will put the current version (no decimals)
83847>>>>>>>/// of the driver associated with the current workspace into the specified
83847>>>>>>>/// variable.
83847>>>>>>>///
83847>>>>>>>/// @Assumptions
83847>>>>>>>/// @Status      Public
83847>>>>>>>/// @Drivers     All
83847>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
83847>>>>>>>/// @See                 GET_DRIVER_REVISION
83847>>>>>>>///
83847>>>>>>>/// @Syntax GET_DRIVER_MAJOR_REVISION to {variable}
83847>>>>>>>/// @Param variable                     String variable to hold the returned version
83847>>>>>>>///
83847>>>>>>>/// @Example
83847>>>>>>>/// GET_DRIVER_MAJOR_REVISION to sVersion
83847>>>>>>>
83847>>>>>>>//=============================================================================
83847>>>>>>>/// @Name        GET_DRIVER_LICENSE_EXPIRATION_TIME
83847>>>>>>>/// @Description This command is used to find out how long until a
83847>>>>>>>/// specific temporary license for a driver expires. If 0 is returned,
83847>>>>>>>/// then the license is not a temporary license. If -1 is returned, then
83847>>>>>>>/// the license has already expired. Otherwise, the number returned
83847>>>>>>>/// is the number of days until the license will expire.
83847>>>>>>>///
83847>>>>>>>/// @Assumptions
83847>>>>>>>/// @Status      Public
83847>>>>>>>/// @Drivers     All
83847>>>>>>>/// @VersionNote Last Revised: 2013-10-02 Aaron Gulack
83847>>>>>>>/// @See                 GET_DRIVER_LICENSE_PATH SET_DRIVER_LICENSE_EXPIRATION_WARNING
83847>>>>>>>///
83847>>>>>>>/// @Syntax GET_DRIVER_LICENSE_EXPIRATION_TIME to {variable}
83847>>>>>>>/// @Param variable                     Variable to hold the days until expiration
83847>>>>>>>///
83847>>>>>>>/// @Example
83847>>>>>>>/// GET_DRIVER_LICENSE_EXPIRATION_TIME to iExpire
83847>>>>>>>/// Showln iExpire
83847>>>>>>>
83847>>>>>>>//=============================================================================
83847>>>>>>>/// @Name        SET_DRIVER_LICENSE_EXPIRATION_WARNING
83847>>>>>>>/// @Description This command is used to set a custom warning message to
83847>>>>>>>/// be displayed when a temporary license for a driver is close to expiring.
83847>>>>>>>/// Note that since the license evaluation is done during Login and before
83847>>>>>>>/// any open calls, this command should be called before either of those.
83847>>>>>>>///
83847>>>>>>>/// @Assumptions
83847>>>>>>>/// @Status      Public
83847>>>>>>>/// @Drivers     All
83847>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
83847>>>>>>>/// @See                 GET_DRIVER_LICENSE_PATH GET_DRIVER_LICENSE_EXPIRATION_TIME
83847>>>>>>>///
83847>>>>>>>/// @Syntax SET_DRIVER_LICENSE_EXPIRATION_WARNING to {variable}
83847>>>>>>>/// @Param variable                     New warning message for expiring license
83847>>>>>>>///
83847>>>>>>>/// @Example
83847>>>>>>>/// SET_DRIVER_LICENSE_EXPIRATION_WARNING to "Your license is about to expire."
83847>>>>>>>/// Login "localhost" "" "" "sql_drv"
83847>>>>>>>
83847>>>>>>>//=============================================================================
83847>>>>>>>/// @Name        GET_DRIVER_LICENSE_PATH
83847>>>>>>>/// @Description This command will return the current path of the license
83847>>>>>>>/// associated with the driver.
83847>>>>>>>///
83847>>>>>>>/// @Assumptions
83847>>>>>>>/// @Status      Internal
83847>>>>>>>/// @Drivers     All
83847>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
83847>>>>>>>/// @See                 SET_DRIVER_LICENSE_EXPIRATION_WARNING GET_DRIVER_LICENSE_EXPIRATION_TIME
83847>>>>>>>///
83847>>>>>>>/// @Syntax GET_DRIVER_LICENSE_PATH to {variable}
83847>>>>>>>/// @Param variable                     Variable to hold the path of the license
83847>>>>>>>
83847>>>>>>>Function MertechInc_GET_DRIVER_LICENSE_PATH Global Returns String
83849>>>>>>>    String sReturnValue
83849>>>>>>>
83849>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
83851>>>>>>>    If (MertechInc_FileNumber <> -1) Begin
83853>>>>>>>        Get MertechInc_Pre_Size_String 4096 to sReturnValue
83854>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_LICENSE_ENVIRONMENT_SET CALLBACK 0 PASSING sReturnValue MertechInc_Blank CALLDRV_LICENSE_PATH RESULT MertechInc_iRet
83859>>>>>>>        If MertechInc_iRet EQ -1 INDICATE ERR True
83862>>>>>>>    End
83862>>>>>>>>
83862>>>>>>>
83862>>>>>>>    Function_Return sReturnValue
83863>>>>>>>End_Function
83864>>>>>>>
83864>>>>>>>//=============================================================================
83864>>>>>>>/// @Name        SET_DATABASE_PORT
83864>>>>>>>/// @Description This command is used to dynamically change the port
83864>>>>>>>/// number to use for all TCP/IP connections to the server. Note that
83864>>>>>>>/// the port is used for the current session only.
83864>>>>>>>///
83864>>>>>>>/// @Assumptions The port is valid and available
83864>>>>>>>/// @Status      Public
83864>>>>>>>/// @Drivers     MySQLFlex PgFlex
83864>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
83864>>>>>>>/// @See                 GET_DATABASE_PORT
83864>>>>>>>///
83864>>>>>>>/// @Syntax SET_DATABASE_PORT of {constant} to {variable}
83864>>>>>>>/// @Param constant                     MYSQL or PGSQL
83864>>>>>>>/// @Param variable                     Port number to use to connect to server
83864>>>>>>>///
83864>>>>>>>/// @Example
83864>>>>>>>/// GET_DATABASE_PORT of MYSQL to 1433
83864>>>>>>>
83864>>>>>>>//=============================================================================
83864>>>>>>>/// @Name        GET_DATABASE_PORT
83864>>>>>>>/// @Description This command returns the TCP/IP port used to connect
83864>>>>>>>/// to the server.
83864>>>>>>>///
83864>>>>>>>/// @Assumptions
83864>>>>>>>/// @Status      Public
83864>>>>>>>/// @Drivers     MySQLFlex PgFlex
83864>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
83864>>>>>>>/// @See                 SET_DATABASE_PORT
83864>>>>>>>///
83864>>>>>>>/// @Syntax GET_DATABASE_PORT of {MYSQL/PGSQL} to {variable}
83864>>>>>>>/// @Param variable                     Variable to hold the TCP/IP port number
83864>>>>>>>///
83864>>>>>>>/// @Example
83864>>>>>>>/// GET_DATABASE_PORT of MYSQL to iPort
83864>>>>>>>
83864>>>>>>>//=============================================================================
83864>>>>>>>/// @Name        GET_SERIAL_NUMBER
83864>>>>>>>/// @Description This command returns the serial number associated with
83864>>>>>>>/// the current driver's license.
83864>>>>>>>///
83864>>>>>>>/// @Assumptions
83864>>>>>>>/// @Status      Public
83864>>>>>>>/// @Drivers     All
83864>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
83864>>>>>>>/// @See
83864>>>>>>>///
83864>>>>>>>/// @Syntax GET_SERIAL_NUMBER to {variable}
83864>>>>>>>/// @Param variable                     Variable to hold the driver's serial number
83864>>>>>>>///
83864>>>>>>>/// @Example
83864>>>>>>>/// GET_SERIAL_NUMBER to iSerial
83864>>>>>>>
83864>>>>>>>//=============================================================================
83864>>>>>>>/// @Name        SET_DATABASE_SOCKET
83864>>>>>>>/// @Description This command is used to set the socket used to connect
83864>>>>>>>/// to the server when running an application under Linux/Unix.
83864>>>>>>>///
83864>>>>>>>/// @Assumptions
83864>>>>>>>/// @Status      Public
83864>>>>>>>/// @Drivers     MySQLFlex
83864>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
83864>>>>>>>/// @See                 GET_DATABASE_SOCKET
83864>>>>>>>///
83864>>>>>>>/// @Syntax SET_DATABASE_SOCKET of MYSQL to {variable}
83864>>>>>>>/// @Param variable                     Full name of the socket
83864>>>>>>>
83864>>>>>>>//=============================================================================
83864>>>>>>>/// @Name        GET_DATABASE_SOCKET
83864>>>>>>>/// @Description This command returns the name of the socket used to
83864>>>>>>>/// connect to the server when running an application under Linux/Unix.
83864>>>>>>>///
83864>>>>>>>/// @Assumptions
83864>>>>>>>/// @Status      Public
83864>>>>>>>/// @Drivers     MySQLFlex
83864>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
83864>>>>>>>/// @See                 SET_DATABASE_SOCKET
83864>>>>>>>///
83864>>>>>>>/// @Syntax SET_DATABASE_SOCKET of MYSQL to {variable}
83864>>>>>>>/// @Param variable                     Variable to hold the full socket name
83864>>>>>>>
83864>>>>>>>//=============================================================================
83864>>>>>>>/// @Name        SET_AUTHENTICATION_MODE
83864>>>>>>>/// @Description This command is used to control what mode the user logs
83864>>>>>>>/// in as. When DEFAULT is passed, the user will be logged in with the
83864>>>>>>>/// default privileges given to it. When SYSDBA is passed, the user will
83864>>>>>>>/// be logged in with the roles assigned to the sysdba user, most likely
83864>>>>>>>/// full control over the database.
83864>>>>>>>///
83864>>>>>>>/// @Assumptions
83864>>>>>>>/// @Status      Public
83864>>>>>>>/// @Drivers     OraFlex
83864>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
83864>>>>>>>/// @See
83864>>>>>>>///
83864>>>>>>>/// @Syntax SET_AUTHENTICATION_MODE of Oracle to {SYSDBA/DEFAULT}
83864>>>>>>>///
83864>>>>>>>/// @Example
83864>>>>>>>/// SET_AUTHENTICATION_MODE of Oracle to DEFAULT
83864>>>>>>>
83864>>>>>>>//=============================================================================
83864>>>>>>>/// @Name        SQL_ESCAPE_STRING
83864>>>>>>>/// @Description This command is used to properly escape strings before
83864>>>>>>>/// they are used in embedded SQL statements. This can be extremely
83864>>>>>>>/// important when you do not have full control of the strings being passed
83864>>>>>>>/// to the SQL statement as this will ensure that the strings are properly
83864>>>>>>>/// quoted.
83864>>>>>>>///
83864>>>>>>>/// @Assumptions
83864>>>>>>>/// @Status      Public
83864>>>>>>>/// @Drivers     All
83864>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
83864>>>>>>>/// @See
83864>>>>>>>///
83864>>>>>>>/// @Syntax SQL_ESCAPE_STRING of {string} to {variable}
83864>>>>>>>/// @Param string               The string to be escaped.
83864>>>>>>>/// @Param variable     Variable to hold the newly escaped string
83864>>>>>>>///
83864>>>>>>>/// @Example
83864>>>>>>>/// SQL_ESCAPE_STRING of "They said to me, 'hello'." to sEscaped
83864>>>>>>>
83864>>>>>>>Function SQLESCAPESTRING Global String sData Returns String
83866>>>>>>>    String sReturnData
83866>>>>>>>
83866>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
83868>>>>>>>
83868>>>>>>>    If (MertechInc_FileNumber <> -1) Begin
83870>>>>>>>        Get MertechInc_Pre_Size_String 0 to sReturnData
83871>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_ESCAPE_STRING CALLBACK 0 PASSING sData sReturnData 0 RESULT MertechInc_iRet
83876>>>>>>>    End
83876>>>>>>>>
83876>>>>>>>
83876>>>>>>>    Function_Return sReturnData
83877>>>>>>>End_Function
83878>>>>>>>
83878>>>>>>>//=============================================================================
83878>>>>>>>/// @Name        DIRECT_PATH_LOAD
83878>>>>>>>/// @Description
83878>>>>>>>///
83878>>>>>>>/// @Assumptions
83878>>>>>>>/// @Status      Internal
83878>>>>>>>/// @Drivers     OraFlex
83878>>>>>>>/// @VersionNote Last Revised: 2009-09-21 By Ian Smith
83878>>>>>>>/// @See
83878>>>>>>>
83878>>>>>>>//=============================================================================
83878>>>>>>>/// @Name        SQL_INITIALIZE_SEQUENCE
83878>>>>>>>/// @Description This command is used to initialize all auto increment
83878>>>>>>>/// columns, or sequences in Oracle, of the specified table to be the
83878>>>>>>>/// highest number plus one. This is useful when inserting a large amount
83878>>>>>>>/// of records in the table and the sequence is not being updated because
83878>>>>>>>/// the auto incremented column is being manually filled.
83878>>>>>>>///
83878>>>>>>>/// @Assumptions
83878>>>>>>>/// @Status      Public
83878>>>>>>>/// @Drivers     OraFlex PgFlex
83878>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
83878>>>>>>>/// @See
83878>>>>>>>///
83878>>>>>>>/// SQL_INITIALIZE_SEQUENCE of {FileNumber}
83878>>>>>>>/// @Param FileNumber                   The file number
83878>>>>>>>
83878>>>>>>>//=============================================================================
83878>>>>>>>/// @Name        LOB_APPEND
83878>>>>>>>/// @Description This command is used to append data to an existing LOB
83878>>>>>>>/// column in the database. When called, the data corresponding field
83878>>>>>>>/// in the buffer is appended to the respective column in the database.
83878>>>>>>>/// This can be very useful when saving data that exceeds VDF size limits
83878>>>>>>>/// but falls within the limits of the SQL database. Note that this command
83878>>>>>>>/// must write to a file that is active and locked. Also the save is handled
83878>>>>>>>/// within the command so no extra calls are needed to save the changes made.
83878>>>>>>>///
83878>>>>>>>/// @Assumptions The field being used is a LOB field
83878>>>>>>>/// @Status      Deprecated
83878>>>>>>>/// @Drivers     All
83878>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
83878>>>>>>>/// @See                 SQL_LOB_ADD_CHUNK
83878>>>>>>>///
83878>>>>>>>/// @Syntax LOB_APPEND of {FileName} {FieldNumber}
83878>>>>>>>/// @Param FileName                     Name of the file containing the LOB column
83878>>>>>>>/// @Param FieldNumber          Number of the field being appended to
83878>>>>>>>///
83878>>>>>>>/// @Example
83878>>>>>>>/// Clear Customer
83878>>>>>>>/// Find Gt Customer By Index.1
83878>>>>>>>///
83878>>>>>>>/// Direct_Input 'C:\Mertech.xml'
83878>>>>>>>/// Lock
83878>>>>>>>///    Find Eq Customer by Recnum
83878>>>>>>>///
83878>>>>>>>///    Read_Block Customer.Comments 16384
83878>>>>>>>///    SQL_LOB_WRITE of Customer 13 // Customer.Comments
83878>>>>>>>///    Repeat
83878>>>>>>>///        Read_Block Customer.Comments 16384
83878>>>>>>>///        SQL_LOB_APPEND of Customer 13 // Customer.Comments
83878>>>>>>>///    Until (SeqEOF)
83878>>>>>>>/// Unlock
83878>>>>>>>///
83878>>>>>>>/// Close_Input
83878>>>>>>>/// Find Eq Customer By Recnum
83878>>>>>>>/// SQL_LOB_LENGTH of Customer 13 to iLength
83878>>>>>>>/// Showln 'Length: ' iLength
83878>>>>>>>
83878>>>>>>>
83878>>>>>>>//=============================================================================
83878>>>>>>>/// @Name        LOB_LENGTH
83878>>>>>>>/// @Description This command returns the length of the data in the
83878>>>>>>>/// specified column. This command must be used after a proper FIND to
83878>>>>>>>/// ensure that a valid record is in the buffer. This can be a useful
83878>>>>>>>/// command for checking if uploaded data exceeds size limits.
83878>>>>>>>///
83878>>>>>>>/// @Assumptions The field being used is a LOB field
83878>>>>>>>/// @Status      Deprecated
83878>>>>>>>/// @Drivers     All
83878>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
83878>>>>>>>/// @See                 SQL_GET_LOB_LENGTH
83878>>>>>>>///
83878>>>>>>>/// @Syntax LOB_LENGTH of {FileName} {FieldNumber} to {variable}
83878>>>>>>>/// @Param FileName                     Name of the file
83878>>>>>>>/// @Param FieldNumber          Number of the LOB field
83878>>>>>>>/// @Param variable                     Variable to hold the length
83878>>>>>>>///
83878>>>>>>>/// @Example
83878>>>>>>>/// Clear Customer
83878>>>>>>>/// Find Gt Customer By Index.1
83878>>>>>>>/// SQL_LOB_LENGTH of Customer 13 to iLength
83878>>>>>>>/// Showln 'Length: ' iLength
83878>>>>>>>
83878>>>>>>>
83878>>>>>>>//=============================================================================
83878>>>>>>>/// @Name        LOB_READ
83878>>>>>>>/// @Description This command reads a chunk of data from a specified LOB
83878>>>>>>>/// column, moving it into its corresponding field buffer. Because the
83878>>>>>>>/// chunk will be moved into the field buffer, it can only be as large as
83878>>>>>>>/// the buffer allows. To account for this, the constants FIRST or NEXT
83878>>>>>>>/// are passed as well indicating whether to grab the first chunk for
83878>>>>>>>/// the buffer or the next. Each chunk grabbed will be as large as allowed.
83878>>>>>>>/// All these things considered, when reading data larger than the field
83878>>>>>>>/// buffer, it is good practice to perform the read in a loop, adding the
83878>>>>>>>/// length each time. Another optional parameter that can be passed is a
83878>>>>>>>/// variable that will store the length of the chunk. Note that a LOB read
83878>>>>>>>/// must be done after a successful find on the record.
83878>>>>>>>///
83878>>>>>>>/// @Assumptions The field being used is a LOB field
83878>>>>>>>/// @Status      Deprecated
83878>>>>>>>/// @Drivers     All
83878>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
83878>>>>>>>/// @See                 SQL_GET_LOB SQL_GET_LOB_CHUNK
83878>>>>>>>///
83878>>>>>>>/// @Syntax LOB_READ of {FileName} {FieldNumber} {FIRST/NEXT} [{length}]
83878>>>>>>>/// @Param FileName                     Name of the file containing the LOB field
83878>>>>>>>/// @Param FieldNumber          Number of the field being read from
83878>>>>>>>/// @Param FIRST                        Reads the first chunk of data
83878>>>>>>>/// @Param NEXT                         Reads the next chuck of data (if larger than buffer limit)
83878>>>>>>>/// @Param length                       Variable to hold the chunk length (optional)
83878>>>>>>>///
83878>>>>>>>/// @Example
83878>>>>>>>/// Direct_Output ('binary:Mertech.pdf')
83878>>>>>>>///
83878>>>>>>>/// Clear customer
83878>>>>>>>/// Find Gt customer by Index.1
83878>>>>>>>/// SQL_LOB_LENGTH of customer 13 to liLength
83878>>>>>>>///
83878>>>>>>>/// While (liLength > 0)
83878>>>>>>>///     Write customer.comments
83878>>>>>>>///     SQL_LOB_READ of customer 13 Next liLength
83878>>>>>>>/// Loop
83878>>>>>>>///
83878>>>>>>>/// Close_Output
83878>>>>>>>
83878>>>>>>>
83878>>>>>>>//=============================================================================
83878>>>>>>>/// @Name        LOB_WRITE
83878>>>>>>>/// @Description This command is used to write data to a LOB column.
83878>>>>>>>/// By passing the file name and field number of the LOB column, this
83878>>>>>>>/// command will take the current value of the respective field in
83878>>>>>>>/// the field buffer, write it to the database and save it. Any data
83878>>>>>>>/// currently in that field will be overridden by the data from the
83878>>>>>>>/// buffer. Note that this command must write to a file that is active
83878>>>>>>>/// and locked. Also this command handles the save so no extra calls
83878>>>>>>>/// are needed to save the changes.
83878>>>>>>>///
83878>>>>>>>/// @Assumptions The field being used is a LOB field
83878>>>>>>>/// @Status      Deprecated
83878>>>>>>>/// @Drivers     All
83878>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
83878>>>>>>>/// @See                 SQL_SET_LOB SQL_ADD_LOB_CHUNK
83878>>>>>>>///
83878>>>>>>>/// @Syntax LOB_WRITE of {FileName} {FieldNumber}
83878>>>>>>>/// @Param FileName                     Name of the file containing the LOB field
83878>>>>>>>/// @Param FieldNumber          Number of the field being written to
83878>>>>>>>///
83878>>>>>>>/// @Example
83878>>>>>>>/// Clear Customer
83878>>>>>>>/// Find Gt Customer By Index.1
83878>>>>>>>///
83878>>>>>>>/// Direct_Input 'C:\Mertech.xml'
83878>>>>>>>/// Lock
83878>>>>>>>///    Find Eq Customer by Recnum
83878>>>>>>>///
83878>>>>>>>///    Read_Block Customer.Comments 16384
83878>>>>>>>///    SQL_LOB_WRITE of Customer 13 // Customer.Comments
83878>>>>>>>///    Repeat
83878>>>>>>>///        Read_Block Customer.Comments 16384
83878>>>>>>>///        SQL_LOB_APPEND of Customer 13 // Customer.Comments
83878>>>>>>>///    Until (SeqEOF)
83878>>>>>>>/// Unlock
83878>>>>>>>/// Close_Input
83878>>>>>>>///
83878>>>>>>>/// Find Eq Customer By Recnum
83878>>>>>>>/// SQL_LOB_LENGTH of Customer 13 to iLength
83878>>>>>>>/// Showln 'Length: ' iLength
83878>>>>>>>
83878>>>>>>>
83878>>>>>>>//=============================================================================
83878>>>>>>>/// @Name        LOB_LOADFROMFILE
83878>>>>>>>/// @Description This command loads an external file into a specified LOB
83878>>>>>>>/// column. After specifying the file name and field number, the path and
83878>>>>>>>/// file must then be passed respectively. When using Oracle, instead of
83878>>>>>>>/// passing the directory, a directory alias must be passed. This alias
83878>>>>>>>/// can be created using a "CREATE DIRECTORY" statement in SQL. For more
83878>>>>>>>/// information on setting this directory alias, see the Oracle help.
83878>>>>>>>/// For other servers, the file must be a local file available to the
83878>>>>>>>/// application that is calling the command. Note that this command must
83878>>>>>>>/// write to a file that is active and locked. Also this command handles
83878>>>>>>>/// the save so no extra calls are needed to save the changes.
83878>>>>>>>///
83878>>>>>>>/// @Assumptions The field being used is a LOB field
83878>>>>>>>/// @Status      Deprecated
83878>>>>>>>/// @Drivers     All
83878>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
83878>>>>>>>/// @See                 LOB_APPEND LOB_LENGTH LOB_WRITE LOB_READ LOB_ERASE LOB_TRUNCATE FLUSH_LOB_BUFFER
83878>>>>>>>///
83878>>>>>>>/// @Syntax LOB_LOADFROMFILE of {FileName} {FieldNumber} From {path} {file}
83878>>>>>>>/// @Param FileName                     Name of the file containing the LOB column
83878>>>>>>>/// @Param FieldNumber          Number of the LOB column being used
83878>>>>>>>/// @Param path                         The path of the file, excluding the file name
83878>>>>>>>/// @Param file                         The name of the file, including the extension
83878>>>>>>>///
83878>>>>>>>/// @Example
83878>>>>>>>/// Clear Customer
83878>>>>>>>/// Find Gt Customer By Index.1
83878>>>>>>>/// Lock
83878>>>>>>>///    Find Eq Customer by Recnum
83878>>>>>>>///    LOB_TRUNCATE OF customel 13 to 0 // Customer.Comments
83878>>>>>>>///    Saverecord Customer
83878>>>>>>>///    // Directory name is case sensitive.
83878>>>>>>>///    // Make sure the name case matches
83878>>>>>>>///    LOB_LOADFROMFILE OF customel 13 FROM "C:\Mertech\FilesToLoad" "Mertech.XML"
83878>>>>>>>/// Unlock
83878>>>>>>>
83878>>>>>>>
83878>>>>>>>//=============================================================================
83878>>>>>>>/// @Name        LOB_ERASE
83878>>>>>>>/// @Description This command is used to erase a portion of data from a
83878>>>>>>>/// LOB column. For text fields, the portion of data to be erased is
83878>>>>>>>/// replaced with white space, and in binary fields, with 0X0. To erase
83878>>>>>>>/// a portion of the data, pass the length to erase as well as the number
83878>>>>>>>/// to offset from. For this command to work properly, it must be done
83878>>>>>>>/// after a valid find. Note that the save is handled inside this command
83878>>>>>>>/// so no extra commands are needed to save the changes.
83878>>>>>>>///
83878>>>>>>>/// @Assumptions The field being used is a LOB field
83878>>>>>>>/// @Status      Deprecated
83878>>>>>>>/// @Drivers     All
83878>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
83878>>>>>>>/// @See LOB_APPEND LOB_LENGTH LOB_WRITE LOB_READ LOB_LOADFROMFILE LOB_ERASE LOB_TRUNCATE FLUSH_LOB_BUFFER
83878>>>>>>>///
83878>>>>>>>/// @Syntax LOB_ERASE OF {FileName} {FieldNumber} {length} {offset}
83878>>>>>>>/// @Param FileName                     Name of the file containing the LOB column
83878>>>>>>>/// @Param FieldNumber          Number of the LOB column being erased
83878>>>>>>>/// @Param Length                       Length of chunk to erase from column
83878>>>>>>>/// @Param offset                       Starting position for erase
83878>>>>>>>///
83878>>>>>>>/// @Example
83878>>>>>>>/// Clear customer
83878>>>>>>>/// Find Gt customer by Recnum
83878>>>>>>>/// Lock
83878>>>>>>>/// Find Eq customer by Recnum
83878>>>>>>>/// LOB_LENGTH OF customer 13 to liTotalLength
83878>>>>>>>/// LOB_ERASE  OF customer 13    liTotalLength 1
83878>>>>>>>/// Unlock
83878>>>>>>>
83878>>>>>>>
83878>>>>>>>//=============================================================================
83878>>>>>>>/// @Name        LOB_TRUNCATE
83878>>>>>>>/// @Description This command is used to trim a LOB column down to a
83878>>>>>>>/// specified length. By passing the table name and column number, the
83878>>>>>>>/// value in the column can then be trimmed down the specified length.
83878>>>>>>>/// This can be a useful command for clearing out a column before entering
83878>>>>>>>/// new data into it. Note that this command must write to a file that is active
83878>>>>>>>/// and locked. Also this command handles the save so no extra calls
83878>>>>>>>/// are needed to save the changes. This command can be used to clear out a field before adding new data
83878>>>>>>>///
83878>>>>>>>/// @Assumptions The field being used is a LOB field
83878>>>>>>>/// @Status      Deprecated
83878>>>>>>>/// @Drivers     All
83878>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
83878>>>>>>>/// @See                 LOB_APPEND LOB_LENGTH LOB_WRITE LOB_READ LOB_LOADFROMFILE LOB_ERASE FLUSH_LOB_BUFFER
83878>>>>>>>///
83878>>>>>>>/// @Syntax LOB_TRUNCATE of {FileName} {FieldNumber} to {variable}
83878>>>>>>>/// @Param FileName                     Name of the file
83878>>>>>>>/// @Param FieldNumber          The field number
83878>>>>>>>/// @Param length                       New length to truncate to
83878>>>>>>>///
83878>>>>>>>/// @Example
83878>>>>>>>/// Clear Customer
83878>>>>>>>/// Find Gt Customer By Index.1
83878>>>>>>>/// Lock
83878>>>>>>>///    Find Eq Customer by Recnum
83878>>>>>>>///    SQL_LOB_TRUNCATE of Customer 13 to 0 // Customer.Comments
83878>>>>>>>///    Saverecord Customer
83878>>>>>>>/// Unlock
83878>>>>>>>
83878>>>>>>>
83878>>>>>>>//=============================================================================
83878>>>>>>>/// @Name        FLUSH_LOB_BUFFER
83878>>>>>>>/// @Description This command currently serves no function.
83878>>>>>>>///
83878>>>>>>>/// @Assumptions
83878>>>>>>>/// @Status      Deprecated
83878>>>>>>>/// @Drivers     MySQLFlex
83878>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
83878>>>>>>>/// @See
83878>>>>>>>///
83878>>>>>>>/// @Syntax FLUSH_LOB_BUFFER of {FileName}
83878>>>>>>>/// @Param FileName                     Name of the file
83878>>>>>>>
83878>>>>>>>
83878>>>>>>>//=============================================================================
83878>>>>>>>/// @Name        SQL_ENABLE_RECONNECT
83878>>>>>>>/// @Description Allow MySql Driver to auto reconnect after a time-out.
83878>>>>>>>///
83878>>>>>>>/// Driver auto-reconnect feature handles the issue where MySQL
83878>>>>>>>/// will kick off a user after inactivity.
83878>>>>>>>///
83878>>>>>>>/// @Status      Deprecated
83878>>>>>>>/// @Drivers     MySQL
83878>>>>>>>/// @VersionNote Last Revised: 2009-09-11 By Ian Smith
83878>>>>>>>///
83878>>>>>>>/// @Syntax SQL_ENABLE_RECONNECT of <ServerName> to dftrue/dffalse
83878>>>>>>>/// @Param ServerName  Server Name.
83878>>>>>>>///
83878>>>>>>>/// @Usage SQL_ENABLE_RECONNECT Of sServerID To dftrue
83878>>>>>>>
83878>>>>>>>//=============================================================================
83878>>>>>>>/// @Name        CALL_MYSQL_STORED_PROCEDURE
83878>>>>>>>/// @Description This command is used to call a stored procedure on the SQL
83878>>>>>>>/// backend. To successfully call a procedure with this command, a string
83878>>>>>>>/// must be passed containing a valid procedure name. In addition, if the
83878>>>>>>>/// procedure takes any arguments, they must also be passed using the constant
83878>>>>>>>/// "passing" along with all of the needed arguments. If the procedure has a
83878>>>>>>>/// return value, then SQL_GET_FUNCTION_RETURN or SQL_FETCH_NEXT_ROW can be
83878>>>>>>>/// used to get the value(s). If an error is found then the indicator "Err"
83878>>>>>>>/// is set to true.
83878>>>>>>>///
83878>>>>>>>/// @Assumptions
83878>>>>>>>/// @Status      Deprecated
83878>>>>>>>/// @Drivers     MySQLFlex
83878>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
83878>>>>>>>/// @See                 CALL_STORED_PROCEDURE
83878>>>>>>>///
83878>>>>>>>/// @Syntax CALL_MYSQL_STORED_PROCEDURE {procedure} Passing {argument}
83878>>>>>>>/// @Param procedure            Full name of the procedure
83878>>>>>>>/// @Param argument                     Argument to pass (can be multiple)
83878>>>>>>>///
83878>>>>>>>/// @Example
83878>>>>>>>/// CALL_MYSQL_STORED_PROCEDURE "getCustomerStatus" passing sCustomerID sStatus
83878>>>>>>>/// SQL_GET_PROCEDURE_PARAMETER 2 to sStatus
83878>>>>>>>/// Showln sStatus
83878>>>>>>>
83878>>>>>>>//=============================================================================
83878>>>>>>>/// @Name        CALL_MYSQL_STORED_FUNCTION
83878>>>>>>>/// @Description This command is used to execute a function stored in MySQL.
83878>>>>>>>/// This is an alternative to building a function with the SQL_SET_FUNCTION_NAME,
83878>>>>>>>/// SQL_SET_FUNCTION_PARAMETER and SQL_FUNCTION_EXECUTE commands. This command
83878>>>>>>>/// builds and executes the function by setting the full function name, the
83878>>>>>>>/// parameter(s) to pass and the variable to hold the returned value. Note that
83878>>>>>>>/// this command can only return a single value so SQL_SET_FUNCTION_PARAMETER
83878>>>>>>>/// and SQL_SET_FUNCTION_NAME must be used when dealing with multiple return
83878>>>>>>>/// values.
83878>>>>>>>///
83878>>>>>>>/// @Status      Deprecated
83878>>>>>>>/// @Drivers     MySQLFlex
83878>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
83878>>>>>>>/// @See                 CALL_STORED_FUNCTION
83878>>>>>>>///
83878>>>>>>>/// @Syntax CALL_MYSQL_STORED_FUNCTION {function} Returns {variable} Passing {argument}
83878>>>>>>>/// @Param function                     Full name of the function
83878>>>>>>>/// @Param variable                     Variable to hold the returned value
83878>>>>>>>/// @Param argument                     Argument to pass (can be multiple)
83878>>>>>>>///
83878>>>>>>>/// @Example
83878>>>>>>>/// CALL_MYSQL_STORED_FUNCTION "getCustomerStatus" Returns sStatus passing sCustomerID
83878>>>>>>>/// Showln sStatus
83878>>>>>>>
83878>>>>>>>//=============================================================================
83878>>>>>>>/// @Name        DO_SET_ALL_FUNCTION_PARAMETERS
83878>>>>>>>/// @Description Sets the parameters for a MySQL stored function call.
83878>>>>>>>///
83878>>>>>>>/// @Assumptions
83878>>>>>>>/// @Status      Internal
83878>>>>>>>/// @Drivers     MySQLFlex
83878>>>>>>>/// @VersionNote Last Revised: 2009-09-21 By Ian Smith
83878>>>>>>>/// @See
83878>>>>>>>///
83878>>>>>>>/// @Syntax DO_SET_ALL_FUNCTION_PARAMETERS [sParam1 [sParam2 . sParamn]]
83878>>>>>>>/// @Param sParam1.n    Parameters for the stored function
83878>>>>>>>
83878>>>>>>>//=============================================================================
83878>>>>>>>/// @Name        GET_NO_AVAILABLE_SQLSERVERS
83878>>>>>>>/// @Description This command is used to get the number of available MSSQL
83878>>>>>>>/// servers detected in the network. When used with GET_SQLSERVER_NAME,
83878>>>>>>>/// all the available server names can be easily retrieved.
83878>>>>>>>///
83878>>>>>>>/// @Assumptions SQL Server Browser Service is started and firewall is configured properly
83878>>>>>>>/// @Status      Public
83878>>>>>>>/// @Drivers     SQLFlex
83878>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
83878>>>>>>>/// @See                 GET_SQLSERVER_NAME
83878>>>>>>>///
83878>>>>>>>/// @Syntax GET_NO_AVAILABLE_SQLSERVERS to {variable}
83878>>>>>>>/// @Param variable                     Variable to hold number of servers
83878>>>>>>>///
83878>>>>>>>/// @Example
83878>>>>>>>/// GET_NO_AVAILABLE_SQLSERVERS to iServers
83878>>>>>>>///
83878>>>>>>>/// While (i <= iServers)
83878>>>>>>>///     GET_SQLSERVER_NAME i to sServer
83878>>>>>>>///     Showln sServer
83878>>>>>>>///     Increment i
83878>>>>>>>/// Loop
83878>>>>>>>
83878>>>>>>>Function SQL_AVAILABLE_SQL_SERVERS Global Returns Integer
83880>>>>>>>    Call_Driver 0 SQLFLEX Function CALLDRV_ENUMERATE_SERVER CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank CALLDRV_ENUMERATE_SERVER_COUNT RESULT MertechInc_iRet
83885>>>>>>>
83885>>>>>>>    Function_Return MertechInc_iRet
83886>>>>>>>End_Function
83887>>>>>>>
83887>>>>>>>
83887>>>>>>>//=============================================================================
83887>>>>>>>/// @Name        GET_SQLSERVER_NAME
83887>>>>>>>/// @Description This command returns the name of the server based on the
83887>>>>>>>/// specified index number. The number of servers can be retrieved from
83887>>>>>>>/// GET_NO_AVAILABLE_SQLSERVERS and the names can be indexed from that
83887>>>>>>>/// number.
83887>>>>>>>///
83887>>>>>>>/// @Assumptions SQL Server Browser Service is started and firewall is configured properly
83887>>>>>>>/// @Status      Public
83887>>>>>>>/// @Drivers     SQLFlex
83887>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
83887>>>>>>>/// @See                 GET_NO_AVAILABLE_SQLSERVERS
83887>>>>>>>///
83887>>>>>>>/// @Syntax SQL_AVAILABLE_SQL_SERVER_NAME {index} to {variable}
83887>>>>>>>/// @Param index                The numbered index name to retrieve
83887>>>>>>>/// @Param variable             Variable to hold the server name
83887>>>>>>>///
83887>>>>>>>/// @Example
83887>>>>>>>/// GET_NO_AVAILABLE_SQLSERVERS to iServers
83887>>>>>>>///
83887>>>>>>>/// While (i <= iServers)
83887>>>>>>>///     GET_SQLSERVER_NAME i to sServer
83887>>>>>>>///     Showln sServer
83887>>>>>>>///     Increment i
83887>>>>>>>/// Loop
83887>>>>>>>
83887>>>>>>>Function SQL_AVAILABLE_SQL_SERVER_NAME Global Integer iIndex Returns String
83889>>>>>>>    String sName
83889>>>>>>>
83889>>>>>>>    Get MertechInc_Pre_Size_String 80 to sName
83890>>>>>>>    Call_Driver 0 SQLFLEX Function CALLDRV_ENUMERATE_SERVER CALLBACK 0 PASSING sName iIndex CALLDRV_ENUMERATE_SERVER_SERVER RESULT MertechInc_iRet
83895>>>>>>>
83895>>>>>>>    Function_Return sName
83896>>>>>>>End_Function
83897>>>>>>>
83897>>>>>>>
83897>>>>>>>//=============================================================================
83897>>>>>>>/// @Name        SET_USE_ROWCOUNT_IN_TRANSACTION
83897>>>>>>>/// @Description Turn on / off Row_Count for specified server.
83897>>>>>>>/// @Status      Deprecated
83897>>>>>>>/// @Drivers     All
83897>>>>>>>/// @VersionNote Last Revised: 2009-09-21 By Ian Smith
83897>>>>>>>///
83897>>>>>>>/// @Syntax SET_USE_ROWCOUNT_IN_TRANSACTION OF <Server> To <State>
83897>>>>>>>/// @Param Server      Name of server to turn On / Off Row_Count
83897>>>>>>>/// @Param State       TRUE = turn on Row_Count  FALSE = turn off Row_Count
83897>>>>>>>///
83897>>>>>>>/// @Comment This SHOULD ALWAYS BE TURNED ON
83897>>>>>>>
83897>>>>>>>Procedure Set SQL_USE_ROWCOUNT_IN_TRANSACTIONS Global String sServer Integer iState
83899>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
83901>>>>>>>
83901>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_USE_ROWCOUNT_IN_TRANSACTIONS CALLBACK 0 PASSING sServer iState CALLDRV_VALUE_SET RESULT MertechInc_iRet
83906>>>>>>>    If MertechInc_iRet EQ -1 INDICATE ERR True
83909>>>>>>>End_Procedure
83910>>>>>>>
83910>>>>>>>//IGS - commented out by a.n. Other
83910>>>>>>>//#REPLACE UseRowCountInTransactions SQL_USE_ROWCOUNT_IN_TRANSACTIONS
83910>>>>>>>
83910>>>>>>>//=============================================================================
83910>>>>>>>/// @Name        GET_USE_ROWCOUNT_IN_TRANSACTION
83910>>>>>>>/// @Description Gets the Row_Count setting for specified server.
83910>>>>>>>/// @Status      Deprecated
83910>>>>>>>/// @Drivers     All
83910>>>>>>>/// @VersionNote Last Revised: 2009-09-21 By Ian Smith
83910>>>>>>>///
83910>>>>>>>/// @Syntax GET_USE_ROWCOUNT_IN_TRANSACTION OF <Server> To <State>
83910>>>>>>>/// @Param Server      Name of server to get Row_Count state of
83910>>>>>>>/// @Param State       Variable to hold returned value
83910>>>>>>>
83910>>>>>>>Function SQL_USE_ROWCOUNT_IN_TRANSACTIONS Global String sServer Returns Integer
83912>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
83914>>>>>>>
83914>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_USE_ROWCOUNT_IN_TRANSACTIONS CALLBACK 0 PASSING sServer MertechInc_Blank CALLDRV_VALUE_GET RESULT MertechInc_iRet
83919>>>>>>>
83919>>>>>>>    Function_Return MertechInc_iRet
83920>>>>>>>End_Function
83921>>>>>>>
83921>>>>>>>
83921>>>>>>>//=============================================================================
83921>>>>>>>/// @Name        SQL_SET_DATE_FORMAT
83921>>>>>>>/// @Description This command controls the date format of data returned
83921>>>>>>>/// through embedded SQL. If set to DATAFLEX, then the dates will be
83921>>>>>>>/// returned in whatever format is set in DF_DATE_FORMAT. When set to
83921>>>>>>>/// NATIVE, this command will force dates to return dates in the format
83921>>>>>>>/// specified on the SQL server. Note that in order for the variables to
83921>>>>>>>/// be in the right form, they need to be string variables.
83921>>>>>>>///
83921>>>>>>>/// @Assumptions
83921>>>>>>>/// @Status      Public
83921>>>>>>>/// @Drivers     SQLFlex
83921>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
83921>>>>>>>/// @See
83921>>>>>>>///
83921>>>>>>>/// @Syntax SQL_SET_DATE_FORMAT to {DATAFLEX/NATIVE}
83921>>>>>>>///
83921>>>>>>>/// @Example
83921>>>>>>>/// SQL_SET_DATE_FORMAT to NATIVE
83921>>>>>>>
83921>>>>>>>Procedure Set SQL_USE_DATAFLEX_DATEFORMAT Global Integer iState
83923>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
83925>>>>>>>
83925>>>>>>>    If MertechInc_DriverName eq SQLFlex Begin
83927>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_USE_DFLEX_DATE_FORMAT CALLBACK 0 PASSING iState MertechInc_Blank CALLDRV_VALUE_SET RESULT MertechInc_iRet
83932>>>>>>>        IF MertechInc_iRet EQ -1 INDICATE ERR TRUE
83935>>>>>>>    End
83935>>>>>>>>
83935>>>>>>>End_Procedure
83936>>>>>>>
83936>>>>>>>Function SQL_USE_DATAFLEX_DATEFORMAT Global Returns Integer
83938>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
83940>>>>>>>
83940>>>>>>>    If MertechInc_DriverName eq SQLFlex Begin
83942>>>>>>>        CALL_DRIVER 0 MertechInc_DriverName FUNCTION CALLDRV_USE_DFLEX_DATE_FORMAT CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank CALLDRV_VALUE_GET RESULT MertechInc_iRet
83947>>>>>>>    End
83947>>>>>>>>
83947>>>>>>>    Else Move DFFALSE to MertechInc_iRet
83949>>>>>>>
83949>>>>>>>    function_return MertechInc_iRet
83950>>>>>>>End_Function
83951>>>>>>>
83951>>>>>>>
83951>>>>>>>//=============================================================================
83951>>>>>>>/// @Name        SET_FIELDS_NOT_NULL
83951>>>>>>>/// @Description This command is used to specify how to handle blank
83951>>>>>>>/// and zero values on the SQL backend. Since blank or zero values can
83951>>>>>>>/// often be stored as null in the server database, this command allows
83951>>>>>>>/// that to be altered if needed. When set to true, a value will be
83951>>>>>>>/// inserted into blank records to keep them from being null. See the
83951>>>>>>>/// list below for what value will be stored instead of null. If set to
83951>>>>>>>/// false, values will be stored normally in the database. Note that this
83951>>>>>>>/// command effects all data types.
83951>>>>>>>///
83951>>>>>>>/// DF_ASCII and DF_TEXT -              ' ' (one blank space)
83951>>>>>>>///
83951>>>>>>>/// DF_BCD -                                    0 (zero)
83951>>>>>>>///
83951>>>>>>>/// DF_DATe and DF_DATETIME -   00/00/0000 for MYSQL
83951>>>>>>>///                                                             01/01/0001 for Oracle MSSQL, and Postgre
83951>>>>>>>///                                                             01/01/1753 for MSSQL Datetimes
83951>>>>>>>///
83951>>>>>>>/// DF_BINARY -                                 0X0
83951>>>>>>>///
83951>>>>>>>/// @Assumptions
83951>>>>>>>/// @Status      Public
83951>>>>>>>/// @Drivers     All
83951>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
83951>>>>>>>/// @See                 SET_FIELDS_NULL GET_FIELDS_NULL
83951>>>>>>>///
83951>>>>>>>/// @Syntax SET_FIELDS_NOT_NULL to {variable}
83951>>>>>>>/// @Param variable             Boolean variable to indicate how to handle null values
83951>>>>>>>///
83951>>>>>>>
83951>>>>>>>Procedure Set SQL_FORCE_FIELDS_NOT_NULL Global Integer iState
83953>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
83955>>>>>>>
83955>>>>>>>    If (MertechInc_FileNumber <> -1) Begin
83957>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_FORCE_FIELDS_NOT_NULL CALLBACK 0 PASSING iState MertechInc_Blank CALLDRV_VALUE_SET RESULT MertechInc_iRet
83962>>>>>>>        If MertechInc_iRet EQ -1 INDICATE ERR True
83965>>>>>>>    End
83965>>>>>>>>
83965>>>>>>>End_Procedure
83966>>>>>>>
83966>>>>>>>
83966>>>>>>>
83966>>>>>>>
83966>>>>>>>Function SQL_FORCE_FIELDS_NOT_NULL Global Returns Integer
83968>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
83970>>>>>>>
83970>>>>>>>    If (MertechInc_FileNumber <> -1) Begin
83972>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_FORCE_FIELDS_NOT_NULL CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank CALLDRV_VALUE_GET RESULT MertechInc_iRet
83977>>>>>>>    End
83977>>>>>>>>
83977>>>>>>>    Else Move DFFALSE to MertechInc_iRet
83979>>>>>>>
83979>>>>>>>    Function_Return MertechInc_iRet
83980>>>>>>>End_Function
83981>>>>>>>
83981>>>>>>>
83981>>>>>>>//=============================================================================
83981>>>>>>>/// @Name        SET_FIELDS_NULL
83981>>>>>>>/// @Description This command is used to specify how to store blank or zero
83981>>>>>>>/// values in the database. Since database can sometimes store these value,
83981>>>>>>>/// i.e. '' or 0, as null, using this command can be useful in managing that.
83981>>>>>>>/// When set to true, any value in a column of the given type considered blank
83981>>>>>>>/// or 0 will be stored as null in the database. Setting it to false will cause
83981>>>>>>>/// the server to save as it normally would. Note that this command is used to
83981>>>>>>>/// set specific data types only, it can not effect all types at once. Below is
83981>>>>>>>/// a list of value that would be considered blank/zero values.
83981>>>>>>>///
83981>>>>>>>/// DF_ASCII and DF_TEXT -              ' ' (one blank space)
83981>>>>>>>///
83981>>>>>>>/// DF_BCD -                                    0 (zero)
83981>>>>>>>///
83981>>>>>>>/// DF_DATe and DF_DATETIME -   00/00/0000 for MYSQL
83981>>>>>>>///                                                             01/01/0001 for Oracle MSSQL, and Postgre
83981>>>>>>>///                                                             01/01/1753 for MSSQL Datetimes
83981>>>>>>>///
83981>>>>>>>/// DF_BINARY -                                 0X0
83981>>>>>>>///
83981>>>>>>>/// @Assumptions
83981>>>>>>>/// @Status      Public
83981>>>>>>>/// @Drivers     All
83981>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
83981>>>>>>>/// @See                 GET_FIELDS_NULL SET_FIELDS_NOT_NULL
83981>>>>>>>///
83981>>>>>>>/// @Syntax SET_FIELDS_NULL {datatype} to {variable}
83981>>>>>>>/// @Param datatype                     DF_ASCII, DF_BCD, or DF_DATE
83981>>>>>>>/// @Param variable             Boolean to indicate how to handle blank data
83981>>>>>>>
83981>>>>>>>
83981>>>>>>>//=============================================================================
83981>>>>>>>/// @Name        GET_FIELDS_NULL
83981>>>>>>>/// @Description This command will return the value of SET_FIELDS_NULL for
83981>>>>>>>/// the specified data type.
83981>>>>>>>///
83981>>>>>>>/// @Assumptions
83981>>>>>>>/// @Status      Public
83981>>>>>>>/// @Drivers     All
83981>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
83981>>>>>>>/// @See                 SET_FIELDS_NULL SET_FIELDS_NOT_NULL
83981>>>>>>>///
83981>>>>>>>/// @Syntax GET_FIELDS_NULL {datatype} to {variable}
83981>>>>>>>/// @Param datatype                     DF_ASCII, DF_BCD, or DF_DATE
83981>>>>>>>/// @Param variable             Variable to hold the value of SET_FIELDS_NULL
83981>>>>>>>
83981>>>>>>>
83981>>>>>>>//=============================================================================
83981>>>>>>>/// @Name        STRUCTURE_START_DYNAMIC
83981>>>>>>>/// @Description This command is used when scripting structural changes.
83981>>>>>>>/// It is the same as using ENABLE_SCRIPTING and Structure_Start separately.
83981>>>>>>>/// It allows structural changes to be compiled and tested without
83981>>>>>>>/// actually making any of the changes. Any table restructuring done
83981>>>>>>>/// between this command and STRUCTURE_END_DYNAMIC will not actually be
83981>>>>>>>/// committed but will instead create a mock INT file. The script and
83981>>>>>>>/// INT file can then be retrieved and examined for testing purposes.
83981>>>>>>>///
83981>>>>>>>/// @Assumptions
83981>>>>>>>/// @Status      Deprecated
83981>>>>>>>/// @Drivers     All
83981>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
83981>>>>>>>/// @See                 ENABLE_SCRIPTING DISABLE_SCRIPTING
83981>>>>>>>///
83981>>>>>>>/// @Syntax STRUCTURE_START_DYNAMIC of {FileNumber}
83981>>>>>>>/// @Param FileNumber                   The number of the file
83981>>>>>>>
83981>>>>>>>//=============================================================================
83981>>>>>>>/// @Name        STRUCTURE_END_DYNAMIC
83981>>>>>>>/// @Description This command ends the scripting started by
83981>>>>>>>/// STRUCTURE_START_DYNAMIC. It is the same as calling Structure_End
83981>>>>>>>/// and DISABLE_SCRIPTING separately.
83981>>>>>>>///
83981>>>>>>>/// @Assumptions
83981>>>>>>>/// @Status      Deprecated
83981>>>>>>>/// @Drivers     All
83981>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
83981>>>>>>>/// @See                 ENABLE_SCRIPTING DISABLE_SCRIPTING
83981>>>>>>>///
83981>>>>>>>/// @Syntax STRUCTURE_START_DYNAMIC of {FileNumber}
83981>>>>>>>/// @Param FileNumber                   The number of the file
83981>>>>>>>
83981>>>>>>>//=============================================================================
83981>>>>>>>/// @Name        SQLSERVER_ATTACH_DB
83981>>>>>>>/// @Description Attachs an MS SQL mdf to the current server instance. If
83981>>>>>>>/// the passed database is already attached, no error is generated.
83981>>>>>>>///
83981>>>>>>>/// The SQLSERVER_ATTACH_DB command is intended for use with our new support
83981>>>>>>>/// of Microsoft LocalDB's.  When using LocalDB's a common use case might be
83981>>>>>>>/// to attach to a customer DB, do some work on it, and then detach this DB
83981>>>>>>>/// and attach to a different DB.  This was possible using stored procedures,
83981>>>>>>>/// but the code had some complexities that a developer need not worry about.
83981>>>>>>>/// When you attach a database, you must pass the database name, along with
83981>>>>>>>/// the path to an MDF file which contains the database.  Any associated LDF's
83981>>>>>>>/// (log files) and NDF's (secondary data files) must be in the same folder.
83981>>>>>>>///
83981>>>>>>>/// If you call SQLSERVER_ATTACH_DB on a database that is already attached,
83981>>>>>>>/// no error will be generated.  After you call SQLSERVER_ATTACH_DB, you
83981>>>>>>>/// should call SET_DATABASE_NAME if you wish to make the attached database
83981>>>>>>>/// the currently selected database.
83981>>>>>>>///
83981>>>>>>>/// SQLSERVER_ATTACH_DB will work on all supported version of SQL server.
83981>>>>>>>///
83981>>>>>>>/// @Assumptions
83981>>>>>>>/// @Status      Public
83981>>>>>>>/// @Drivers     SQLFlex
83981>>>>>>>/// @VersionNote Last Revised: 2013-10-09 Aaron Gulack
83981>>>>>>>/// @See
83981>>>>>>>///
83981>>>>>>>/// @Syntax SQLSERVER_ATTACH_DB {database} on {filePath}
83981>>>>>>>/// @Param database                     Name of the database
83981>>>>>>>/// @Param filePath                     Path of the MDF file
83981>>>>>>>///
83981>>>>>>>/// @Example
83981>>>>>>>/// SQLSERVER_ATTACH_DB "MTSample" ON "C:\Mertech\Data\SampleDb.mdf"
83981>>>>>>>
83981>>>>>>>//=============================================================================
83981>>>>>>>/// @Name        SQLSERVER_DETACH_DB
83981>>>>>>>/// @Description The SQLSERVER_DETACH_DB command is intended for use with our
83981>>>>>>>/// new support of Microsoft LocalDB's.  When using LocalDB's a common use
83981>>>>>>>/// case might be to attach to a customer DB, do some work on it, and then
83981>>>>>>>/// detach this DB and attach to a different DB.  This was possible using
83981>>>>>>>/// stored procedures, but the code had some complexities that a developer
83981>>>>>>>/// need not worry about.  A detach can only be done if the database passed
83981>>>>>>>/// has no open connections.  As part of the detach process, the command
83981>>>>>>>/// closes ALL open files (even those not associated with this database or
83981>>>>>>>/// driver).
83981>>>>>>>///
83981>>>>>>>/// NOTE: SQLSERVER_DETACH_DB will often fail to execute if you are testing
83981>>>>>>>/// your application from the studio.  This is because the studio itself
83981>>>>>>>/// normally has open connections to the database.  If you test your
83981>>>>>>>/// application outside of the studio and the studio is closed (and any
83981>>>>>>>/// other application or tools that access this database are closed) you
83981>>>>>>>/// can successfully detach the database.
83981>>>>>>>///
83981>>>>>>>/// @Assumptions
83981>>>>>>>/// @Status      Public
83981>>>>>>>/// @Drivers     SQLFlex
83981>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
83981>>>>>>>/// @See
83981>>>>>>>///
83981>>>>>>>/// @Syntax SQLSERVER_DETACH_DB {database}
83981>>>>>>>/// @Param database                     Name of the database
83981>>>>>>>///
83981>>>>>>>/// @Example
83981>>>>>>>/// SQLSERVER_DETACH_DB "TestDB"
83981>>>>>>>
83981>>>>>>>//=============================================================================
83981>>>>>>>/// @Name        SET_FIXED_FILE_RECORDS_USED
83981>>>>>>>/// @Description This command is used to set DF_FILE_RECORDS_USED to a
83981>>>>>>>/// fixed value. This can be useful because doing a SELECT COUNT(*) is
83981>>>>>>>/// a very expensive process to the server. Many applications do counts
83981>>>>>>>/// often and using this command can help cut down the server traffic.
83981>>>>>>>/// Sometimes when counts are used, an exact number is not necessary so
83981>>>>>>>/// a fixed value, updated occasionally can be used. By setting this
83981>>>>>>>/// command to 0 or greater, the value of DF_FILE_RECORDS_USED will be
83981>>>>>>>/// set to that specified value and the internal SELECT COUNT(*) will be
83981>>>>>>>/// suppressed. If this command is set to something less that zero,
83981>>>>>>>/// DF_FILE_RECORDS_USED will be dynamically calculated whenever it is
83981>>>>>>>/// called.
83981>>>>>>>///
83981>>>>>>>/// The default value for this command is -1
83981>>>>>>>///
83981>>>>>>>/// @Assumptions
83981>>>>>>>/// @Status              Public
83981>>>>>>>/// @Drivers     All
83981>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
83981>>>>>>>/// @See                 GET_FIXED_FILE_RECORDS_USED SUPPRESS_SELECT_COUNT UNSUPPRESS_SELECT_COUNT
83981>>>>>>>///
83981>>>>>>>/// @Syntax SET_FIXED_FILE_RECORDS_USED to {variable}
83981>>>>>>>/// @Param variable                     Fixed value for DF_FILE_RECORDS_USED
83981>>>>>>>///
83981>>>>>>>/// @Example
83981>>>>>>>/// SET_FIXED_FILE_RECORDS_USED to 10000
83981>>>>>>>
83981>>>>>>>//=============================================================================
83981>>>>>>>/// @Name        GET_FIXED_FILE_RECORDS_USED
83981>>>>>>>/// @Description This command returns the value of DF_FILE_RECORDS_USED
83981>>>>>>>/// if it has been set to a fixed value by SET_FIXED_FILE_RECORDS_USED.
83981>>>>>>>/// If anything greater than or equal to 0 is returned then that is the
83981>>>>>>>/// fixed value returned by any SELECT COUNT(*) statements, internal or
83981>>>>>>>/// not. If something less than zero is returned, then DF_FILE_RECORDS_USED
83981>>>>>>>/// returns a dynamic count whenever it is called.
83981>>>>>>>///
83981>>>>>>>/// By default the value of this is -1
83981>>>>>>>///
83981>>>>>>>/// @Assumptions
83981>>>>>>>/// @Status              Public
83981>>>>>>>/// @Drivers     All
83981>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
83981>>>>>>>/// @See                 SET_FIXED_FILE_RECORDS_USED SUPPRESS_SELECT_COUNT UNSUPPRESS_SELECT_COUNT
83981>>>>>>>///
83981>>>>>>>/// @Syntax GET_FILE_RECORDS_USED to {variable}
83981>>>>>>>/// @Param variable                     Variable to hold the fixed value
83981>>>>>>>///
83981>>>>>>>/// @Example
83981>>>>>>>/// GET_FIXED_FILE_RECORDS_USED to iRecords
83981>>>>>>>
83981>>>>>>>//=============================================================================
83981>>>>>>>/// @Name        SUPPRESS_SELECT_COUNT
83981>>>>>>>/// @Description This command sets the value of DF_FILE_RECORDS_USED to
83981>>>>>>>/// a fixed value of zero. That way anytime a SELECT COUNT(*) is done,
83981>>>>>>>/// zero is returned, cutting down on server traffic. This is the same
83981>>>>>>>/// as setting SET_FIXED_FILE_RECORDS_USED to 0.
83981>>>>>>>///
83981>>>>>>>/// @Assumptions
83981>>>>>>>/// @Status      Public
83981>>>>>>>/// @Drivers     All
83981>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
83981>>>>>>>/// @See                 UNSUPPRESS_SELECT_COUNT SET_FIXED_FILE_RECORDS_USED GET_FIXED_FILE_RECORDS_USED
83981>>>>>>>///
83981>>>>>>>/// @Syntax SUPPRESS_SELECT_COUNT
83981>>>>>>>
83981>>>>>>>//=============================================================================
83981>>>>>>>/// @Name        UNSUPPRESS_SELECT_COUNT
83981>>>>>>>/// @Description This command resets the value of DF_FILE_RECORDS_USED to
83981>>>>>>>/// -1. That way anytime a SELECT COUNT(*) is done, it returns the actual
83981>>>>>>>/// count of records. This is the same as setting SET_FIXED_FILE_RECORDS_USED
83981>>>>>>>/// to -1.
83981>>>>>>>///
83981>>>>>>>/// @Assumptions
83981>>>>>>>/// @Status      Public
83981>>>>>>>/// @Drivers     All
83981>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
83981>>>>>>>/// @See                 SUPPRESS_SELECT_COUNT SET_FIXED_FILE_RECORDS_USED GET_FIXED_FILE_RECORDS_USED
83981>>>>>>>///
83981>>>>>>>/// @Syntax UNSUPPRESS_SELECT_COUNT
83981>>>>>>>
83981>>>>>>>
83981>>>>>>>///
83981>>>>>>>// Private:
83981>>>>>>>// Get the filenumber of a file.field parameter
83981>>>>>>>//
83981>>>>>>>
83981>>>>>>>///
83981>>>>>>>// Private:
83981>>>>>>>// Get the fieldnumber of a file.field parameter
83981>>>>>>>//
83981>>>>>>>
83981>>>>>>>
83981>>>>>>>
83981>>>>>>>
83981>>>>>>>//
83981>>>>>>>// Minimum required DataFlex version for new LOB support below is VDF 4
83981>>>>>>>//
83981>>>>>>>
83981>>>>>>>TYPE tMertechLOB_Args
83981>>>>>>>    FIELD tMertechLOB_Args.cbSize       AS WORD          // always the size of the structure (verification + versioning)
83981>>>>>>>    FIELD tMertechLOB_Args.nField       AS DWORD         // always the field number
83981>>>>>>>    FIELD tMertechLOB_Args.pszData      AS POINTER
83981>>>>>>>    FIELD tMertechLOB_Args.nSize        AS DWORD
83981>>>>>>>    FIELD tMertechLOB_Args.nOffset      AS POINTER
83981>>>>>>>END_TYPE
83981>>>>>>>
83981>>>>>>>//=============================================================================
83981>>>>>>>/// @Name        SQL_SET_LOB
83981>>>>>>>/// @Description This command replaces whatever is currently in a LOB Field
83981>>>>>>>/// with the data passed. It writes to a client side buffer. It can be used
83981>>>>>>>/// to Write an arbitrary amount of data into a LOB.
83981>>>>>>>/// If passed an empty String, it will remove all the contents of the LOB.
83981>>>>>>>/// If you wish to Set a LOB back to NULL, please use the SQL_SET_LOB_NULL
83981>>>>>>>/// command.
83981>>>>>>>/// NOTE: Unlike the previous call LOB_WRITE, this call does not
83981>>>>>>>/// perform the Save. This must be done separately.
83981>>>>>>>///
83981>>>>>>>/// @Assumptions The field being used is a LOB field
83981>>>>>>>/// @Status      Public
83981>>>>>>>/// @Drivers     All
83981>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
83981>>>>>>>/// @See                 SQL_ADD_LOB_CHUNK SQL_GET_LOB SQL_GET_LOB_CHUNK SQL_GET_LOB_LENGTH SQL_LOB_TRUNCATE
83981>>>>>>>///
83981>>>>>>>/// @Syntax             SQL_SET_LOB {FileName.FieldName} to {variable}
83981>>>>>>>/// @Param              FileName                The name of the file containing the LOB field
83981>>>>>>>/// @Param              FieldName               The name of the LOB field being set
83981>>>>>>>/// @Param              variable                The variable to use to set the field's value
83981>>>>>>>///
83981>>>>>>>/// @Example
83981>>>>>>>/// Set_Argument_Size 262144
83981>>>>>>>/// String sLine
83981>>>>>>>///
83981>>>>>>>/// Clear Customer
83981>>>>>>>///    Move iID to Customer.ID
83981>>>>>>>/// Find Eq Customer by Index.1
83981>>>>>>>/// If (Found) Begin
83981>>>>>>>///    Direct_Input "C:\bigFile.xml"
83981>>>>>>>///    Reread Customer
83981>>>>>>>///       SQL_SET_LOB Customer.Comments to ""
83981>>>>>>>///       Read_Block sLine 262144
83981>>>>>>>///       SQL_SET_LOB Customer.Comments to sLine
83981>>>>>>>///       While (not(SeqEof))
83981>>>>>>>///          Read_Block sLine 262144
83981>>>>>>>///          SQL_ADD_LOB_CHUNK Customer.Comments to sLine
83981>>>>>>>///       Loop
83981>>>>>>>///    Saverecord Customer
83981>>>>>>>///    Unlock
83981>>>>>>>///    Close_Input
83981>>>>>>>/// End
83981>>>>>>>
83981>>>>>>>Procedure MertechInc_SQL_SET_LOB String sDriver Integer iFile Integer iField String sData
83984>>>>>>>    String sLOB_Args       // can drop local command if minimum vdf version is 6
83984>>>>>>>
83984>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
83985>>>>>>>    // First move the size of the structure to the Structure
83985>>>>>>>    Put tMertechLOB_Args_size to sLOB_Args at tMertechLOB_Args.cbSize
83986>>>>>>>    Put iField                to sLOB_Args at tMertechLOB_Args.nField
83987>>>>>>>    Put (AddressOf(sData))    to sLOB_Args at tMertechLOB_Args.pszData
83988>>>>>>>    Put (length(sData))       to sLOB_Args at tMertechLOB_Args.nSize
83989>>>>>>>
83989>>>>>>>    Call_Driver iFile sDriver Function CALLDRV_LOB_EX_WRITE CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
83994>>>>>>>End_Procedure // MertechInc_SQL_SET_LOB
83995>>>>>>>
83995>>>>>>>//=============================================================================
83995>>>>>>>/// @Name        SQL_ADD_LOB_CHUNK
83995>>>>>>>/// @Description This command is used to add additional chunks to the buffer
83995>>>>>>>/// before saving the record. After SQL_SET_LOB has been called
83995>>>>>>>/// SQL_ADD_LOB_CHUNK can be called as many times as needed to add additional
83995>>>>>>>/// chunks of data before a save. It can also be called independent of
83995>>>>>>>/// SQL_SET_LOB to append data to an existing LOB column.
83995>>>>>>>/// NOTE: Unlike the previous call LOB_APPEND, this call does not perform
83995>>>>>>>/// the save. This must be done separately.
83995>>>>>>>///
83995>>>>>>>/// @Assumptions The field being used is a LOB field
83995>>>>>>>/// @Status      Public
83995>>>>>>>/// @Drivers     All
83995>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
83995>>>>>>>/// @See                 SQL_SET_LOB SQL_GET_LOB SQL_GET_LOB_CHUNK SQL_GET_LOB_LENGTH SQL_LOB_TRUNCATE
83995>>>>>>>///
83995>>>>>>>/// @Syntax             SQL_ADD_LOB_CHUNK {FileName.FieldName} to {variable}
83995>>>>>>>/// @Param              FileName                The name of the file containing the LOB field
83995>>>>>>>/// @Param              FieldName               The name of the LOB field being set
83995>>>>>>>/// @Param              variable                The variable to add as the LOB chunk
83995>>>>>>>///
83995>>>>>>>/// @Example
83995>>>>>>>/// Set_Argument_Size 262144
83995>>>>>>>/// String sLine
83995>>>>>>>///
83995>>>>>>>/// Clear Customer
83995>>>>>>>///    Move iID to Customer.ID
83995>>>>>>>/// Find Eq Customer by Index.1
83995>>>>>>>/// If (Found) Begin
83995>>>>>>>///    Direct_Input "C:\bigFile.xml"
83995>>>>>>>///    Reread Customer
83995>>>>>>>///       SQL_SET_LOB Customer.Comments to ""
83995>>>>>>>///       Read_Block sLine 262144
83995>>>>>>>///       SQL_SET_LOB Customer.Comments to sLine
83995>>>>>>>///       While (not(SeqEof))
83995>>>>>>>///          Read_Block sLine 262144
83995>>>>>>>///          SQL_ADD_LOB_CHUNK Customer.Comments to sLine
83995>>>>>>>///       Loop
83995>>>>>>>///    Saverecord Customer
83995>>>>>>>///    Unlock
83995>>>>>>>///    Close_Input
83995>>>>>>>/// End
83995>>>>>>>
83995>>>>>>>Procedure MertechInc_SQL_ADD_LOB_CHUNK String sDriver Integer iFile Integer iField String sData
83998>>>>>>>    String sLOB_Args
83998>>>>>>>
83998>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
83999>>>>>>>    // First move the size of the structure to the Structure
83999>>>>>>>    Put tMertechLOB_Args_size to sLOB_Args at tMertechLOB_Args.cbSize
84000>>>>>>>    Put iField                to sLOB_Args at tMertechLOB_Args.nField
84001>>>>>>>    Put (AddressOf(sData))    to sLOB_Args at tMertechLOB_Args.pszData
84002>>>>>>>    Put (length(sData))       to sLOB_Args at tMertechLOB_Args.nSize
84003>>>>>>>
84003>>>>>>>    Call_Driver iFile sDriver Function CALLDRV_LOB_EX_APPEND CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
84008>>>>>>>end_procedure // MertechInc_SQL_ADD_LOB_CHUNK
84009>>>>>>>
84009>>>>>>>//=============================================================================
84009>>>>>>>/// @Name        SQL_GET_LOB
84009>>>>>>>/// @Description This command is used for getting the value of a specified LOB
84009>>>>>>>/// field. Two optional parameters can be passed specifying the offset and
84009>>>>>>>/// length of the chunk to get. Passing these parameters essentially makes this
84009>>>>>>>/// call the same as SQL_GET_LOB_CHUNK.
84009>>>>>>>/// Depending on the situation, the two calls can be interchanged for improved
84009>>>>>>>/// code readability. Excluding these additional parameters will get the whole
84009>>>>>>>/// field value within DataFlex variable size limits.
84009>>>>>>>///
84009>>>>>>>/// @Assumptions The field being used is a LOB field
84009>>>>>>>/// @Status      Public
84009>>>>>>>/// @Drivers     All
84009>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
84009>>>>>>>/// @See                 SQL_SET_LOB SQL_ADD_LOB_CHUNK SQL_GET_LOB_CHUNK SQL_GET_LOB_LENGTH SQL_LOB_TRUNCATE
84009>>>>>>>///
84009>>>>>>>/// @Syntax     SQL_GET_LOB {FileName.FieldName} TO {variable} [ OFFSET {offset} LENGTH {length} ]
84009>>>>>>>/// @Param              FileName                        The name of the file that contains the specified LOB field
84009>>>>>>>/// @Param              FieldName                       The name of the LOB field
84009>>>>>>>/// @Param              variable                        The variable to hold the LOB value
84009>>>>>>>/// @Param              offset                          Integer amount to offset when getting the LOB value (optional)
84009>>>>>>>/// @Param              length                          Length of value to get from the LOB field (optional)
84009>>>>>>>///
84009>>>>>>>/// @Example
84009>>>>>>>/// Set_Argument_Size 262144
84009>>>>>>>/// String sResult
84009>>>>>>>///
84009>>>>>>>/// Move 262144 to iChunkSize
84009>>>>>>>/// Move 0      to iChunk
84009>>>>>>>///
84009>>>>>>>/// Clear Customer
84009>>>>>>>///    Move iID to Customer.ID
84009>>>>>>>/// Find Eq Customer by Index.1
84009>>>>>>>/// If (Found) Begin
84009>>>>>>>///    Direct_Output ('Binary:' + sDestFileName)
84009>>>>>>>///    SQL_GET_LOB_LENGTH Customer.Comments to iLength
84009>>>>>>>///    While (iChunk*iChunkSize < iLength)
84009>>>>>>>///       SQL_GET_LOB Customer.Comments to sResult OFFSET (iChunk*iChunkSize) LENGTH iChunkSize
84009>>>>>>>///       Write sResult
84009>>>>>>>///       Increment iChunk
84009>>>>>>>///    Loop
84009>>>>>>>///    Close_Output
84009>>>>>>>/// End
84009>>>>>>>
84009>>>>>>>
84009>>>>>>>Function MertechInc_SQL_GET_LOB String sDriver Integer iFile Integer iField Integer iOffset Integer iLength Returns String
84012>>>>>>>    String sLOB_Args
84012>>>>>>>    String sData
84012>>>>>>>    DWord  nSize
84012>>>>>>>
84012>>>>>>>    Move "" To sData
84013>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
84014>>>>>>>    // First move the size of the structure to the Structure
84014>>>>>>>    Put tMertechLOB_Args_size to sLOB_Args at tMertechLOB_Args.cbSize
84015>>>>>>>    Put iField                to sLOB_Args at tMertechLOB_Args.nField
84016>>>>>>>
84016>>>>>>>    Call_Driver iFile sDriver Function CALLDRV_LOB_EX_GET_LENGTH CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
84021>>>>>>>
84021>>>>>>>    GetBuff from sLOB_Args at tMertechLOB_Args.nSize to nSize
84022>>>>>>>    If nSize GT 0 Begin
84024>>>>>>>      If (iOffset=0 and iLength=0) Begin
84026>>>>>>>        ZeroString nSize to sData
84027>>>>>>>            //Send Assert (AddressOf(sData) <> 0) ("AddressOf(sData) is NULL") DFTrue
84027>>>>>>>        Put (AddressOf(sData)) to sLOB_Args at tMertechLOB_Args.pszData
84028>>>>>>>      End
84028>>>>>>>>
84028>>>>>>>      Else Begin
84029>>>>>>>        ZeroString iLength to sData
84030>>>>>>>        Put (AddressOf(sData)) to sLOB_Args at tMertechLOB_Args.pszData
84031>>>>>>>        Put iLength            to sLOB_Args at tMertechLOB_Args.nSize
84032>>>>>>>        Put iOffset            to sLOB_Args at tMertechLOB_Args.nOffset
84033>>>>>>>      End
84033>>>>>>>>
84033>>>>>>>      Call_Driver iFile sDriver Function CALLDRV_LOB_EX_READ CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
84038>>>>>>>    End
84038>>>>>>>>
84038>>>>>>>    Else Begin
84039>>>>>>>        Move "" to sData
84040>>>>>>>    End
84040>>>>>>>>
84040>>>>>>>    Function_Return sData
84041>>>>>>>End_Function // MertechInc_SQL_GET_LOB
84042>>>>>>>
84042>>>>>>>//=============================================================================
84042>>>>>>>/// @Name        SQL_GET_LOB_CHUNK
84042>>>>>>>/// @Description This command is used for getting a chunk of data from a specified
84042>>>>>>>/// LOB field. The difference between this command and SQL_GET_LOB is only that
84042>>>>>>>/// the parameters OFFSET and LENGTH are not optional when using this command.
84042>>>>>>>/// You may consider using this command to retrieve small portions of a very
84042>>>>>>>/// large BLOB so as to reduce memory usage.
84042>>>>>>>///
84042>>>>>>>/// @Assumptions The field being used is a LOB field
84042>>>>>>>/// @Status      Public
84042>>>>>>>/// @Drivers     All
84042>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
84042>>>>>>>/// @See                 SQL_SET_LOB SQL_ADD_LOB_CHUNK SQL_GET_LOB SQL_GET_LOB_LENGTH SQL_LOB_TRUNCATE
84042>>>>>>>///
84042>>>>>>>/// @Syntax     SQL_GET_LOB_CHUNK {FileName.FieldName} TO {variable} OFFSET {offset} LENGTH {length}
84042>>>>>>>/// @Param              FileName                        The name of the file that contains the specified LOB field
84042>>>>>>>/// @Param              FieldName                       The name of the LOB field
84042>>>>>>>/// @Param              variable                        The variable to hold the LOB chunk
84042>>>>>>>/// @Param              offset                          Integer amount to offset when getting the LOB chunk
84042>>>>>>>/// @Param              length                          Length of chunk to get from the LOB field
84042>>>>>>>///
84042>>>>>>>/// @Example
84042>>>>>>>/// Set_Argument_Size 262144
84042>>>>>>>/// String sResult
84042>>>>>>>///
84042>>>>>>>/// Move 262144 to iChunkSize
84042>>>>>>>/// Move 0      to iChunk
84042>>>>>>>///
84042>>>>>>>/// Clear Customer
84042>>>>>>>///    Move iID to Customer.ID
84042>>>>>>>/// Find Eq Customer by Index.1
84042>>>>>>>/// If (Found) Begin
84042>>>>>>>///    SQL_GET_LOB_LENGTH Customer.Comments to iLength
84042>>>>>>>///    While (iChunk*iChunkSize < iLength)
84042>>>>>>>///       SQL_GET_LOB_CHUNK Customer.Comments to sResult OFFSET (iChunk*iChunkSize) LENGTH iChunkSize
84042>>>>>>>///       // Do something with the LOB data
84042>>>>>>>///       Increment iChunk
84042>>>>>>>///    Loop
84042>>>>>>>/// End
84042>>>>>>>
84042>>>>>>>//=============================================================================
84042>>>>>>>/// @Name        SQL_GET_LOB_LENGTH
84042>>>>>>>/// @Description This command is used to get the length of a specified LOB field.
84042>>>>>>>/// It is useful, for example, in determining the number of iterations to
84042>>>>>>>/// perform while reading from a LOB field using chunking.
84042>>>>>>>///
84042>>>>>>>/// @Assumptions The field being used is a LOB field
84042>>>>>>>/// @Status      Public
84042>>>>>>>/// @Drivers     All
84042>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
84042>>>>>>>/// @See                 SQL_SET_LOB SQL_ADD_LOB_CHUNK SQL_GET_LOB SQL_GET_LOB_CHUNK SQL_LOB_TRUNCATE
84042>>>>>>>///
84042>>>>>>>/// @Syntax             SQL_GET_LOB_LENGTH {FileName.FieldName} to {variable}
84042>>>>>>>/// @Param              FileName                        The name of the file containing the LOB field
84042>>>>>>>/// @Param              FieldName                       The name of the specified LOB field
84042>>>>>>>/// @Param              variable                        The variable to hold the length of the field
84042>>>>>>>///
84042>>>>>>>/// @Example
84042>>>>>>>/// Set_Argument_Size 262144
84042>>>>>>>/// String sResult
84042>>>>>>>///
84042>>>>>>>/// Move 16384 to iChunkSize
84042>>>>>>>/// Move 0     to iChunk
84042>>>>>>>///
84042>>>>>>>/// Clear Customer
84042>>>>>>>///    Move iID to Customer.ID
84042>>>>>>>/// Find Eq Customer by Index.1
84042>>>>>>>/// If (Found) Begin
84042>>>>>>>///    SQL_GET_LOB_LENGTH Customer.Comments to iLength
84042>>>>>>>///    While (iChunk*iChunkSize < iLength)
84042>>>>>>>///       SQL_GET_LOB Customer.Comments to sResult OFFSET (iChunk*iChunkSize) LENGTH iChunkSize
84042>>>>>>>///       // Do something with the LOB data
84042>>>>>>>///       Increment iChunk
84042>>>>>>>///    Loop
84042>>>>>>>/// End
84042>>>>>>>
84042>>>>>>>
84042>>>>>>>Function MertechInc_SQL_GET_LOB_LENGTH String sDriver Integer iFile Integer iField Returns Integer
84045>>>>>>>    String sLOB_Args
84045>>>>>>>    DWord  nSize
84045>>>>>>>
84045>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
84046>>>>>>>    // First move the size of the structure to the Structure
84046>>>>>>>    Put tMertechLOB_Args_size to sLOB_Args at tMertechLOB_Args.cbSize
84047>>>>>>>    Put iField                to sLOB_Args at tMertechLOB_Args.nField
84048>>>>>>>
84048>>>>>>>    Call_Driver iFile sDriver Function CALLDRV_LOB_EX_GET_LENGTH CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
84053>>>>>>>
84053>>>>>>>    GetBuff from sLOB_Args at tMertechLOB_Args.nSize to nSize
84054>>>>>>>    Function_Return nSize
84055>>>>>>>End_Function // MertechInc_SQL_GET_LOB_LENGTH
84056>>>>>>>
84056>>>>>>>//=============================================================================
84056>>>>>>>/// @Name        SQL_SET_LOB_NULL
84056>>>>>>>/// @Description This command is used to set a LOB column to null. Often
84056>>>>>>>/// LOB columns should either contain data or be null. A "blank" LOB column
84056>>>>>>>/// often doesn't appear empty in other environments, so settings it back to
84056>>>>>>>/// null is best.
84056>>>>>>>///
84056>>>>>>>/// @Assumptions The field being used is a LOB field
84056>>>>>>>/// @Status      Public
84056>>>>>>>/// @Drivers     All
84056>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
84056>>>>>>>/// @See                 SQL_SET_LOB SQL_ADD_LOB_CHUNK SQL_GET_LOB SQL_GET_LOB_CHUNK SQL_LOB_TRUNCATE
84056>>>>>>>///
84056>>>>>>>/// @Syntax             SQL_SET_LOB_NULL    {FileName.FieldName}
84056>>>>>>>/// @Param              FileName                        The name of the file containing the LOB field
84056>>>>>>>/// @Param              FieldName                       The name of the specified LOB field
84056>>>>>>>///
84056>>>>>>>/// @Example
84056>>>>>>>////
84056>>>>>>>/// Clear Customer
84056>>>>>>>/// Move iID to Customer.ID
84056>>>>>>>/// Find Eq Customer by Index.1
84056>>>>>>>/// If (Found) Begin
84056>>>>>>>///    Reread Customer
84056>>>>>>>///        SQL_SET_LOB_NULL Customer.Comments
84056>>>>>>>///        Saverecord Customer
84056>>>>>>>///    Unlock
84056>>>>>>>/// End
84056>>>>>>>
84056>>>>>>>
84056>>>>>>>Procedure MertechInc_SQL_SET_LOB_NULL String sDriver Integer iFile Integer iField
84059>>>>>>>    String sLOB_Args
84059>>>>>>>
84059>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
84060>>>>>>>    // First move the size of the structure to the Structure
84060>>>>>>>    Put tMertechLOB_Args_size to sLOB_Args at tMertechLOB_Args.cbSize
84061>>>>>>>    Put iField                to sLOB_Args at tMertechLOB_Args.nField
84062>>>>>>>
84062>>>>>>>    Call_Driver iFile sDriver Function CALLDRV_LOB_EX_SET_NULL CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
84067>>>>>>>End_Procedure // MertechInc_SQL_SET_LOB_NULL
84068>>>>>>>
84068>>>>>>>
84068>>>>>>>
84068>>>>>>>//=============================================================================
84068>>>>>>>// End of Mertech.inc
84068>>>>>>>//=============================================================================
84068>>>>>
84068>>>>>
84068>>>>>
84068>>>>>
84068>>>>>
84068>>>>>// *** Constant Declarations: ***
84068>>>>>//
84068>>>>>
84068>>>>>// NOTE: These text constants should be added to the various "Language_xxx.inc" files:
84068>>>>>
84068>>>>>
84068>>>>>
84068>>>>>
84068>>>>>
84068>>>>>// 2016-12-12, Samuel:  Added section for Portuguese
84068>>>>>
84068>>>>>
84068>>>>>
84068>>>>>
84068>>>>>
84068>>>>>
84068>>>>>
84068>>>>>
84068>>>>>    Define DATAFLEX_ID for "DATAFLEX"
84068>>>>>
84068>>>>>// System icon menu constants. If the upper left hand
84068>>>>>// icon in dialogs is clicked, shadow all menu items except Move & Close.
84068>>>>>    Define SC_RESTORE  for |CI$F120
84068>>>>>    Define SC_MOVE     for |CI$F010
84068>>>>>    Define SC_SIZE     for |CI$F000
84068>>>>>    Define SC_MINIMIZE for |CI$F020
84068>>>>>    Define SC_MAXIMIZE for |CI$F030
84068>>>>>    Define SC_CLOSE    for |CI$F060
84068>>>>>    Define SC_KEYMENU  for |CI$F100
84068>>>>>    Define SC_NEXTWINDOW for |CI$F040
84068>>>>>    Define SC_PREVWINDOW for |CI$F050
84068>>>>>
84068>>>>>// *** Struct Declarations: ***
84068>>>>>//#IF (Required_RT_Version > 18) // Temp! Should be "19". Fix after 19.1 beta phase1
84068>>>>>//#ELSE
84068>>>>>Struct tWinMemoryStatusEx
84068>>>>>    UInteger dwLength
84068>>>>>    UInteger dwMemoryLoad
84068>>>>>    UBigInt ullTotalPhys
84068>>>>>    UBigInt ullAvailPhys
84068>>>>>    UBigInt ullTotalPageFile
84068>>>>>    UBigInt ullAvailPageFile
84068>>>>>    UBigInt ullTotalVirtual
84068>>>>>    UBigInt ullAvailVirtual
84068>>>>>    UBigInt ullAvailExtendedVirtual
84068>>>>>End_Struct
84068>>>>>//#ENDIF
84068>>>>>
84068>>>>>// OBSOLETE STRUCTURE AND WINDOWS API CALL. KEPT FOR BACKWARDS COMPATIBILITY
84068>>>>>//Type MEMORYSTATUS
84068>>>>>//   Field MEMORYSTATUS.dwLength         as DWord // sizeof(MEMORYSTATUS)
84068>>>>>//   Field MEMORYSTATUS.dwMemoryLoad     as DWord // percent Of memory in use
84068>>>>>//   Field MEMORYSTATUS.dwTotalPhys      as DWord // bytes Of physical memory
84068>>>>>//   Field MEMORYSTATUS.dwAvailPhys      as DWord // free physical memory bytes
84068>>>>>//   Field MEMORYSTATUS.dwTotalPageFile  as DWord // bytes Of paging file
84068>>>>>//   Field MEMORYSTATUS.dwAvailPageFile  as DWord // free bytes Of paging file
84068>>>>>//   Field MEMORYSTATUS.dwTotalVirtual   as DWord // user bytes Of address space
84068>>>>>//   Field MEMORYSTATUS.dwAvailVirtual   as DWord // free user bytes
84068>>>>>//End_Type
84068>>>>>
84068>>>>>// *** External Function calls: ***
84068>>>>>//
84068>>>>>    External_Function GetSystemMenu "GetSystemMenu" User32.dll Handle hWnd Boolean bRevert Returns Handle
84069>>>>>
84069>>>>>    External_Function GetRemoveMenu "RemoveMenu" user32.dll Handle hWnd UInteger uPosition UInteger uFlags Returns Handle
84070>>>>>
84070>>>>>    External_Function WNetGetUser "WNetGetUserA" MPR.DLL Pointer lpName Pointer lpUser_Name Pointer lpLength Returns DWord
84071>>>>>
84071>>>>>    External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
84072>>>>>
84072>>>>>    External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
84073>>>>>
84073>>>>>// *** Global/Desktop Function Declarations: ***
84073>>>>>
84073>>>>>Function ComputerName for Desktop Returns String
84075>>>>>    String sName
84075>>>>>    Get_Environment "COMPUTERNAME" to sName
84076>>>>>>
84076>>>>>    Function_Return sName
84077>>>>>End_Function
84078>>>>>
84078>>>>>Function Network_User_Name for cDesktop Returns String
84080>>>>>    String sName
84080>>>>>    Get_Environment "USERNAME" to sName
84081>>>>>>
84081>>>>>    Function_Return sName
84082>>>>>End_Function
84083>>>>>
84083>>>>>// *** Class Declarations: ***
84083>>>>>//
84083>>>>>Class cBitmapContainerVDFLink is a BitmapContainer
84084>>>>>    Procedure Mouse_Click Integer iWindowNumber Integer iPosition
84086>>>>>        Send Mouse_Up iWindowNumber iPosition
84087>>>>>    End_Procedure
84088>>>>>    Procedure Mouse_Up Integer iWindowNumber Integer iPosition
84090>>>>>        Forward Send Mouse_Up iWindowNumber iPosition
84092>>>>>        Send Show_HomePage "http://www.dataaccess.com/"
84093>>>>>    End_Procedure
84094>>>>>End_Class
84095>>>>>
84095>>>>>Class cCopyEditorContentButton is a Button
84096>>>>>    Procedure Construct_Object
84098>>>>>        Forward Send Construct_Object
84100>>>>>        Property Handle phoEditorHandle
84101>>>>>        Set psToolTip to C_$DescCopy
84102>>>>>    End_Procedure
84103>>>>>
84103>>>>>    Procedure CopyToWindowsClipboard
84105>>>>>        String sValue
84105>>>>>        Handle hoEditor
84105>>>>>        Boolean bCanCopy
84105>>>>>        Address aEditorAddress
84105>>>>>
84105>>>>>        Get phoEditorHandle to hoEditor
84106>>>>>        Send Select_All of hoEditor
84107>>>>>        Get CanCopy of hoEditor to bCanCopy
84108>>>>>        If (bCanCopy = True) Begin
84110>>>>>            Get paValue of hoEditor to aEditorAddress
84111>>>>>            Move aEditorAddress to sValue
84112>>>>>            Send Copy   of hoEditor
84113>>>>>            // Remove the selection after text is copied to the clipboard.
84113>>>>>            Send Beginning_of_Data of hoEditor
84114>>>>>            Send Info_Box C_$CopyToClipboard_Text
84115>>>>>        End
84115>>>>>>
84115>>>>>    End_Procedure
84116>>>>>End_Class
84117>>>>>
84117>>>>>Class SysinfoDisplay is a cTextEdit
84118>>>>>    Procedure Construct_Object
84120>>>>>        Forward Send Construct_Object
84122>>>>>
84122>>>>>        Set Size to 104 247
84123>>>>>        Set Location to 4 6
84124>>>>>        Set Border_Style to Border_None
84125>>>>>        Set peAnchors to anAll
84126>>>>>        Set Read_Only_State to True
84127>>>>>        Set pbWrap to True
84128>>>>>    End_Procedure
84129>>>>>
84129>>>>>    // Augmented class message to adjust certain text strings that are wrong...
84129>>>>>
84129>>>>>    Procedure AppendTextLn String sText
84131>>>>>        String sWorkspaceWSFile
84131>>>>>
84131>>>>>        // Only works for English:
84131>>>>>        If (ghoApplication > 0) Begin
84133>>>>>            If (sText contains "Workspace Name") Begin
84135>>>>>                Move "Workspace Config Filename:" to sText
84136>>>>>                Get psWorkspaceWSFile of (phoWorkspace(ghoApplication)) to sWorkspaceWSFile
84137>>>>>                Move (sText * sWorkspaceWSFile) to sText
84138>>>>>            End
84138>>>>>>
84138>>>>>        End
84138>>>>>>
84138>>>>>        Send AppendText sText
84139>>>>>        Send AppendText (character(10))
84140>>>>>    End_Procedure
84141>>>>>
84141>>>>>    //****************************************************************************
84141>>>>>    // $Module type: PROCEDURE
84141>>>>>    // $Module name: Show_Current_Directory
84141>>>>>    // $Author     : VOO
84141>>>>>    // Created     : 06-10-96 @ 15:24
84141>>>>>    //
84141>>>>>    // Description
84141>>>>>    //    This method will show the name Of the current directory in the system
84141>>>>>    //    information box
84141>>>>>    //
84141>>>>>    // $Rev History
84141>>>>>    //    06-10-96  Module header created
84141>>>>>    //****************************************************************************
84141>>>>>    Procedure Show_Current_Directory
84143>>>>>        String sDir
84143>>>>>
84143>>>>>        Get_Current_Directory To sDir
84144>>>>>
84144>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
84145>>>>>    End_Procedure
84146>>>>>
84146>>>>>    Procedure Show_Windows_Directory
84148>>>>>        String sWindir
84148>>>>>
84148>>>>>        Get_Windows_Directory To sWindir
84149>>>>>
84149>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
84150>>>>>    End_Procedure
84151>>>>>
84151>>>>>    Procedure Show_Current_User
84153>>>>>        Send AppendTextLn (SFormat (C_$Computer_Name, ComputerName (Self)))
84154>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
84155>>>>>    End_Procedure
84156>>>>>
84156>>>>>    Procedure Show_Number_Format
84158>>>>>        Integer iFormat
84158>>>>>        String sFormatText
84158>>>>>
84158>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
84161>>>>>        Move (Character (iFormat)) To sFormatText
84162>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
84163>>>>>
84163>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
84166>>>>>        Move (Character (iFormat)) to sFormatText
84167>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
84168>>>>>    End_Procedure
84169>>>>>
84169>>>>>    Procedure Show_Filelist_Name
84171>>>>>        String sFilename
84171>>>>>
84171>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
84174>>>>>
84174>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
84175>>>>>    End_Procedure
84176>>>>>
84176>>>>>    Procedure Show_Lock_Delay
84178>>>>>        Integer iLockdelay
84178>>>>>
84178>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
84181>>>>>
84181>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
84182>>>>>    End_Procedure
84183>>>>>
84183>>>>>    Procedure Show_Lock_Timeout
84185>>>>>        Integer iLockTimeout
84185>>>>>
84185>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
84188>>>>>
84188>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
84189>>>>>    End_Procedure
84190>>>>>
84190>>>>>    Procedure Show_Screen_Size
84192>>>>>        Integer iYscreensize iXscreensize
84192>>>>>
84192>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) To iXscreensize
84193>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) To iYscreensize
84194>>>>>
84194>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
84195>>>>>    End_Procedure
84196>>>>>
84196>>>>>    Procedure Show_Page_Size
84198>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
84199>>>>>    End_procedure
84200>>>>>
84200>>>>>    Procedure Show_Date
84202>>>>>        Date dToday
84202>>>>>
84202>>>>>        Sysdate dToday
84203>>>>>
84203>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
84204>>>>>    End_procedure
84205>>>>>
84205>>>>>    Procedure Show_Date_Format
84207>>>>>        Integer iDateFormat
84207>>>>>        String sDateFormat
84207>>>>>
84207>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
84210>>>>>        Case Begin
84210>>>>>            Case (iDateFormat = DF_DATE_USA)
84212>>>>>                Move C_$USA To sDateFormat
84213>>>>>                Case Break
84214>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
84217>>>>>                Move C_$European To sDateFormat
84218>>>>>                Case Break
84219>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
84222>>>>>                Move C_$Military To sDateFormat
84223>>>>>                Case Break
84224>>>>>            Case Else
84224>>>>>                Move C_$UnknownDateType To sDateFormat
84225>>>>>                Case Break
84226>>>>>        Case End
84226>>>>>
84226>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
84227>>>>>    End_Procedure
84228>>>>>
84228>>>>>    // 2013-08-14 NGS
84228>>>>>    // Unformatted numeric values shown doesn't look good. These looks much better.
84228>>>>>    Procedure Show_Systemresources
84230>>>>>        tWinMemoryStatusEx MemoryStatusInfo
84230>>>>>        tWinMemoryStatusEx MemoryStatusInfo
84230>>>>>        Integer iRetval
84230>>>>>        Number nValue
84230>>>>>        String sValue
84230>>>>>
84230>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
84231>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
84232>>>>>        If (iRetval = 0) Begin
84234>>>>>            Move (ShowLastError ()) to iRetval
84235>>>>>            Procedure_Return
84236>>>>>        End
84236>>>>>>
84236>>>>>
84236>>>>>        Send AppendTextLn ""
84237>>>>>        Move MemoryStatusInfo.ullTotalPhys to nValue
84238>>>>>
84238>>>>>        // Show memory in Gigabytes:
84238>>>>>        Move (nValue/1024/1024/1024) to nValue
84239>>>>>        Move (Round(nValue)) to nValue
84240>>>>>        Get FormatNumber nValue 2 to sValue
84241>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, (sValue * "GB")))
84242>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, String(MemoryStatusInfo.dwMemoryLoad) * "%"))
84243>>>>>
84243>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0))
84243>>>>>        Move (Real(MemoryStatusInfo.ullAvailPhys) / Real(MemoryStatusInfo.ullTotalPhys) * 100.0) to nValue
84244>>>>>        Move (Round(nValue)) to nValue
84245>>>>>        Get FormatNumber nValue 0 to sValue
84246>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, (sValue * "%")))
84247>>>>>
84247>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0))
84247>>>>>        Move (Real(MemoryStatusInfo.ullAvailPageFile) / Real(MemoryStatusInfo.ullTotalPageFile) * 100.0) to nValue
84248>>>>>        Move (Round(nValue)) to nValue
84249>>>>>        Get FormatNumber nValue 0 to sValue
84250>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, (sValue * "%")))
84251>>>>>
84251>>>>>//        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0))
84251>>>>>        Move (Real(MemoryStatusInfo.ullAvailVirtual) / Real(MemoryStatusInfo.ullTotalVirtual) * 100.0) to nValue
84252>>>>>        Move (Round(nValue)) to nValue
84253>>>>>        Get FormatNumber nValue 0 to sValue
84254>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, (sValue * "%")))
84255>>>>>
84255>>>>>        // Add an empty row after the memory information:
84255>>>>>        Send AppendTextLn ""
84256>>>>>    End_Procedure
84257>>>>>
84257>>>>>    Procedure Show_Registration
84259>>>>>        String sRegName
84259>>>>>        Integer iSN iUsersMax iUserCount
84259>>>>>
84259>>>>>        Registration sRegName iSN
84260>>>>>>
84260>>>>>        Get_Licensed_Max_Users to iUsersMax
84261>>>>>        Get_Current_User_Count to iUserCount
84262>>>>>
84262>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
84263>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
84264>>>>>        Send AppendTextLn (SFormat (C_$Current_User_Count, iUserCount))
84265>>>>>        Send AppendTextLn (SFormat (C_$Max_Licensed_User_Count, iUsersMax))
84266>>>>>    End_Procedure
84267>>>>>
84267>>>>>    //****************************************************************************
84267>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
84267>>>>>    // To the workspace object passing the an object and message To send back
84267>>>>>    // To this object. It is expected that the workspace object will send this
84267>>>>>    // message for every line Of information it wants displayed (passing the
84267>>>>>    // information To be displayed
84267>>>>>    //****************************************************************************
84267>>>>>    Register_Procedure EnumerateWorkspaceData Integer hObjId Integer hmMessId
84267>>>>>
84267>>>>>    Procedure Show_ServicePack
84269>>>>>        String sKey sVersion sDataFlex
84269>>>>>        Handle hoRegistry
84269>>>>>        Boolean bExists bOpened
84269>>>>>
84269>>>>>        Move "DataFlex"        to sDataFlex
84270>>>>>
84270>>>>>        Get Create U_cRegistry to hoRegistry
84271>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
84272>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
84273>>>>>        Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
84274>>>>>
84274>>>>>        If (bExists) Begin
84276>>>>>            Move ("SOFTWARE\Wow6432Node\Data Access Worldwide\" + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
84277>>>>>        End
84277>>>>>>
84277>>>>>        Else Begin
84278>>>>>            Move ("SOFTWARE\Data Access Worldwide\"             + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
84279>>>>>        End
84279>>>>>>
84279>>>>>        Get KeyExists of hoRegistry sKey to bExists
84280>>>>>        If (bExists) Begin
84282>>>>>            Get OpenKey of hoRegistry sKey to bOpened
84283>>>>>            If (bOpened) Begin
84285>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
84286>>>>>                If (bExists) Begin
84288>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersion
84289>>>>>                End
84289>>>>>>
84289>>>>>                Send CloseKey of hoRegistry
84290>>>>>            End
84290>>>>>>
84290>>>>>        End
84290>>>>>>
84290>>>>>        Send Destroy of hoRegistry
84291>>>>>
84291>>>>>        If (sVersion <> "") Begin
84293>>>>>           Send AppendTextLn sVersion
84294>>>>>           Send AppendTextLn ""
84295>>>>>        End
84295>>>>>>
84295>>>>>    End_Procedure
84296>>>>>
84296>>>>>    Procedure Show_WorkspaceInformation
84298>>>>>        Integer hoWorkspace
84298>>>>>
84298>>>>>        If (ghoApplication <> 0) Begin
84300>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
84301>>>>>            If (hoWorkspace <> 0) Begin
84303>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self msg_AppendTextLn
84304>>>>>            End
84304>>>>>>
84304>>>>>        End
84304>>>>>>
84304>>>>>    End_Procedure
84305>>>>>
84305>>>>>    //****************************************************************************
84305>>>>>    // If connection ids are used, we will send the message EnumerateConnections
84305>>>>>    // to the connection manager object passing the an object and message to send
84305>>>>>    // back to this object. It is expected that the connection manager object will
84305>>>>>    // send this message for every line Of information it wants displayed (passing
84305>>>>>    // the information To be displayed
84305>>>>>    //****************************************************************************
84305>>>>>    Register_Procedure EnumerateConnections Integer hObjId Integer hmMessId
84305>>>>>
84305>>>>>    Procedure Show_ConnectionIdInformation
84307>>>>>        If (ghoConnection > 0) Begin
84309>>>>>            Send EnumerateConnections of ghoConnection Self (RefProc(AppendTextLn))
84310>>>>>            Send AppendTextLn ""
84311>>>>>        End
84311>>>>>>
84311>>>>>    End_Procedure
84312>>>>>
84312>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
84314>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
84315>>>>>    End_Function
84316>>>>>
84316>>>>>    Procedure Show_Versions
84318>>>>>        Integer iVersion iRevision iBuild
84318>>>>>
84318>>>>>        Version_information iVersion iRevision iBuild
84320>>>>>
84320>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(self,iVersion,iRevision,iBuild) ))
84321>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
84322>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
84323>>>>>    End_Procedure
84324>>>>>
84324>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
84326>>>>>        Boolean bOK
84326>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
84327>>>>>        Function_Return bOK
84328>>>>>    End_Function
84329>>>>>
84329>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
84331>>>>>        Boolean bOK
84331>>>>>        Move (sDriverID = SQLFLEX or sDriverID = ORAFLEX or sDriverID = MDSPgSQL or sDriverID = MySQLFlex) to bOK
84332>>>>>        Function_Return bOK
84333>>>>>    End_Function
84334>>>>>
84334>>>>>    //***
84334>>>>>    //*** BW
84334>>>>>    //*** Procedure: Show_Drivers
84334>>>>>    //*** Purpose  : Show loaded database drivers
84334>>>>>    //***
84334>>>>>
84334>>>>>    Procedure Show_Drivers
84336>>>>>        String sDriverID sVersion sClient sValue
84336>>>>>        Integer iNumberOfDrivers iDriver iClient iUsersMax iSerialNo iNumServers iCount
84336>>>>>        Handle hoCLIHandler hoBtrvHandler
84336>>>>>        Boolean bStudioLicense bIsDAWDriver bIsMertechDriver
84336>>>>>
84336>>>>>        Move False to bStudioLicense
84337>>>>>
84337>>>>>        Get Create U_cCLIHandler      to hoCLIHandler
84338>>>>>        Get Create U_cDFBtrDrvHandler to hoBtrvHandler
84339>>>>>
84339>>>>>        // For testing purposes:
84339>>>>>//        Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
84339>>>>>//        Load_Driver MSSQLDRV_ID
84339>>>>>//        Load_Driver ODBC_DRV_ID
84339>>>>>//        Load_Driver DB2_DRV_ID
84339>>>>>//        Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
84339>>>>>//
84339>>>>>//        #IFDEF DUF_Use_Mertech_Drivers
84339>>>>>//            Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
84339>>>>>//            Load_Driver SQLFLEX
84339>>>>>//            Load_Driver MDSPgSQL
84339>>>>>//            Load_Driver MDSMySQL
84339>>>>>//            Load_Driver ORAFLEX
84339>>>>>//            Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
84339>>>>>//        #ENDIF
84339>>>>>        Move False to Err
84340>>>>>
84340>>>>>        // Loop through all loaded drivers.
84340>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
84343>>>>>        If (iNumberOfDrivers > 1) Begin
84345>>>>>            Send AppendTextLn ""
84346>>>>>        End
84346>>>>>>
84346>>>>>        For iDriver from 1 to iNumberOfDrivers
84352>>>>>>
84352>>>>>            // For some weird reason it can happen that - when using Mertech drivers - that the driver index
84352>>>>>            // was increased in the CLI array, but it has no value. In that case a "Bad parameter..." error
84352>>>>>            // would be thrown, so we safeguard from that here.
84352>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
84353>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
84356>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
84357>>>>>            Get IsDAWSQLDriver sDriverID to bIsDAWDriver
84358>>>>>            Get IsMertechDriver sDriverID to bIsMertechDriver
84359>>>>>
84359>>>>>            If (sDriverID = DFBTRDRV_ID or bIsDAWDriver = True or bIsMertechDriver = True) Begin
84361>>>>>
84361>>>>>                // Pervasive/Btrieve database
84361>>>>>                If (sDriverID = DFBTRDRV_ID) Begin
84363>>>>>                    Get CKRevision of hoBtrvHandler to sVersion
84364>>>>>                    Get PSQLLocalEngineVersionInfo of hoBtrvHandler 0 to sClient
84365>>>>>                    If (sClient <> "0.0.0") Begin
84367>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Local_Engine_Version, sClient))
84368>>>>>                    End
84368>>>>>>
84368>>>>>                    Get PSQLServerEngineVersionInfo of hoBtrvHandler 0 to sClient
84369>>>>>                    If (sClient <> "0.0.0") Begin
84371>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Server_Engine_Version, sClient))
84372>>>>>                    End
84372>>>>>>
84372>>>>>                End
84372>>>>>>
84372>>>>>
84372>>>>>                Else Begin
84373>>>>>                    Set psDriverID of hoCLIHandler to sDriverID
84374>>>>>                    Move 0 to iNumServers
84375>>>>>                    If (sDriverID <> DATAFLEX_ID) Begin
84377>>>>>                        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iNumServers
84380>>>>>                    End
84380>>>>>>
84380>>>>>
84380>>>>>                    If (bIsDAWDriver = True) Begin
84382>>>>>                        If (sDriverID = MSSQLDRV_ID) Begin
84384>>>>>                            // This info is only available for the MS SQL driver:
84384>>>>>                            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClient
84387>>>>>                            If (iClient = 13) Begin
84389>>>>>                                Move C_$SQLSERVER2016DRVRSTR              to sClient
84390>>>>>                            End
84390>>>>>>
84390>>>>>                            If (iClient = 12) Begin
84392>>>>>                                Move C_$SQLSERVER2014DRVRSTR              to sClient
84393>>>>>                            End
84393>>>>>>
84393>>>>>                            If (iClient = 11) Begin
84395>>>>>                                Move C_$SQL_Server_Native_Client_11_0     to sClient
84396>>>>>                            End
84396>>>>>>
84396>>>>>                            If (iClient = 10) Begin
84398>>>>>                                Move C_$SQL_Server_Native_Client_10_0     to sClient
84399>>>>>                            End
84399>>>>>>
84399>>>>>                            If (iClient = 9) Begin
84401>>>>>                                Move C_$SQL_Native_Client                 to sClient
84402>>>>>                            End
84402>>>>>>
84402>>>>>                            If (iClient = 8) Begin
84404>>>>>                                Move C_$SQL_Server_SQL_Server_2000_client to sClient
84405>>>>>                            End
84405>>>>>>
84405>>>>>                            If (sClient <> "") Begin
84407>>>>>                                Move ("    " + sClient) to sClient
84408>>>>>                            End
84408>>>>>>
84408>>>>>                        End
84408>>>>>>
84408>>>>>
84408>>>>>                        Get CKRevision of hoCLIHandler to sVersion
84409>>>>>                    End
84409>>>>>>
84409>>>>>
84409>>>>>                    If (bIsMertechDriver = True) Begin
84411>>>>>                        GET_DRIVER_REVISION to sVersion
84424>>>>>>
84424>>>>>                    End
84424>>>>>>
84424>>>>>
84424>>>>>                    // If the serialnumber is = 0, it means that the
84424>>>>>                    // Studio licens is in use and there is no
84424>>>>>                    // number of max users defined because the driver is
84424>>>>>                    // relying on the info from the VDF license.
84424>>>>>                    If (bStudioLicense = False) Begin
84426>>>>>                        Get SerialNumber of hoCLIHandler to iSerialNo
84427>>>>>                        Move (iSerialNo = 0) to bStudioLicense
84428>>>>>                    End
84428>>>>>>
84428>>>>>                End
84428>>>>>>
84428>>>>>                Send AppendTextLn (SFormat (C_$DatabaseDriver, (sDriverID * "-" * (C_$Version + ": " + sVersion))))
84429>>>>>                If (iNumServers <> 0) Begin
84431>>>>>                    For iCount from 1 to iNumServers
84437>>>>>>
84437>>>>>                        Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
84440>>>>>                        Send AppendTextLn ("    " + "Server/DSN:" * sValue)
84441>>>>>                    Loop
84442>>>>>>
84442>>>>>                End
84442>>>>>>
84442>>>>>                If (sClient <> "" and sDriverID = MSSQLDRV_ID) Begin
84444>>>>>                    Send AppendTextLn sClient
84445>>>>>                End
84445>>>>>>
84445>>>>>            End
84445>>>>>>
84445>>>>>        Loop
84446>>>>>>
84446>>>>>
84446>>>>>        Send AppendTextLn ""
84447>>>>>        If (bStudioLicense = False) Begin
84449>>>>>            Get MaxUsers of hoCLIHandler to iUsersMax
84450>>>>>            Send AppendTextLn (SFormat (C_$Max_DbDriver_Licensed_User_Count, iUsersMax))
84451>>>>>        End
84451>>>>>>
84451>>>>>        Else Begin
84452>>>>>            Send AppendTextLn C_$VDF_Studio_License_Text
84453>>>>>        End
84453>>>>>>
84453>>>>>        Send Destroy of hoCLIHandler
84454>>>>>        Send Destroy of hoBtrvHandler
84455>>>>>    End_Procedure
84456>>>>>
84456>>>>>    Procedure Show_HelpFile
84458>>>>>        String sHelpFile
84458>>>>>        Integer eHelpType
84458>>>>>
84458>>>>>        If (ghoApplication <> 0) Begin
84460>>>>>            Get peHelpType Of ghoApplication To eHelpType
84461>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
84463>>>>>                Get GetHelpFile Of ghoHtmlHelp To sHelpFile
84464>>>>>            End
84464>>>>>>
84464>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
84467>>>>>                Get Help_filename Of Help_object_id To sHelpFile
84468>>>>>            End
84468>>>>>>
84468>>>>>            Else Begin
84469>>>>>                Move C_$ThereIsNoHelpfileDefined To sHelpFile
84470>>>>>            End
84470>>>>>>
84470>>>>>
84470>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
84471>>>>>        End
84471>>>>>>
84471>>>>>    End_Procedure
84472>>>>>
84472>>>>>    Procedure Show_EnterAsTab
84474>>>>>        Boolean bEnterKeyAsTabKey
84474>>>>>        String sText
84474>>>>>
84474>>>>>        If (ghoApplication <> 0) Begin
84476>>>>>            Get pbEnterKeyAsTabKey Of ghoApplication To bEnterKeyAsTabKey
84477>>>>>            If (bEnterKeyAsTabKey) Begin
84479>>>>>                Move "True" To sText
84480>>>>>            End
84480>>>>>>
84480>>>>>            Else Begin
84481>>>>>                Move "False" To sText
84482>>>>>            End
84482>>>>>>
84482>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
84483>>>>>        End
84483>>>>>>
84483>>>>>    End_Procedure
84484>>>>>
84484>>>>>    //****************************************************************************
84484>>>>>    // $Module type: PROCEDURE
84484>>>>>    // $Module name: Add_Focus
84484>>>>>    // $Author     : VOO
84484>>>>>    // Created     : 24-09-96 @ 19:43
84484>>>>>    //
84484>>>>>    // Description
84484>>>>>    //    During activation we will remove the old information and add the newly
84484>>>>>    //    found systeminformation
84484>>>>>    //
84484>>>>>    // $Rev History
84484>>>>>    //    24-09-96  Module header created
84484>>>>>    //****************************************************************************
84484>>>>>    Procedure Add_Focus Integer hoRoot
84486>>>>>        Forward Send Add_Focus hoRoot
84488>>>>>
84488>>>>>        Send Delete_Data
84489>>>>>
84489>>>>>        Set Changed_State To False
84490>>>>>        Set Read_Only_State To True
84491>>>>>
84491>>>>>        Send Show_Registration
84492>>>>>        Send Show_Drivers
84493>>>>>        Send AppendTextLn ""
84494>>>>>
84494>>>>>        Send Show_ServicePack
84495>>>>>        If (ghoApplication <> 0) Begin
84497>>>>>            Send Show_WorkSpaceInformation
84498>>>>>            Send Show_HelpFile
84499>>>>>            Send AppendTextLn ""
84500>>>>>        End
84500>>>>>>
84500>>>>>        Else Begin
84501>>>>>            Send AppendTextLn ""
84502>>>>>        End
84502>>>>>>
84502>>>>>
84502>>>>>        If (ghoConnection <> 0) Begin
84504>>>>>            Send Show_ConnectionIdInformation
84505>>>>>        End
84505>>>>>>
84505>>>>>
84505>>>>>        Send Show_Current_User
84506>>>>>        Send Show_Windows_Directory
84507>>>>>        Send Show_Current_Directory
84508>>>>>
84508>>>>>        // This is already shown in the workspace details,
84508>>>>>        // unless no workspace object is present:
84508>>>>>        If (ghoApplication = 0) Begin
84510>>>>>            Send Show_Filelist_Name
84511>>>>>        End
84511>>>>>>
84511>>>>>
84511>>>>>        If (ghoApplication <> 0) Begin
84513>>>>>            Send AppendTextLn ""
84514>>>>>            Send Show_EnterAsTab
84515>>>>>        End
84515>>>>>>
84515>>>>>
84515>>>>>        Send Show_Versions
84516>>>>>        Send Show_Screen_Size
84517>>>>>        Send Show_Page_Size
84518>>>>>        Send Show_Number_Format
84519>>>>>        Send Show_Date_Format
84520>>>>>        Send Show_Lock_Delay
84521>>>>>        Send Show_Lock_Timeout
84522>>>>>        Send Show_Date
84523>>>>>        Send Show_Systemresources
84524>>>>>        Send Beginning_of_Data
84525>>>>>
84525>>>>>        Set Icon to 'default.ico'
84526>>>>>    End_Procedure
84527>>>>>End_Class
84528>>>>>
84528>>>>>//****************************************************************************
84528>>>>>// $Module type: OBJECT
84528>>>>>// $Module name: Sysinfo_Dialog
84528>>>>>// $Author     : VOO
84528>>>>>// Created     : 24-09-96 @ 18:47
84528>>>>>//
84528>>>>>// Description
84528>>>>>//    This object shows the systeminformation on the screen
84528>>>>>//
84528>>>>>// $Rev History
84528>>>>>//    24-09-96  Module header created
84528>>>>>//****************************************************************************
84528>>>>>Class SysInfoDialog is a ModalPanel
84529>>>>>    Procedure Construct_Object
84531>>>>>        Forward Send Construct_Object
84533>>>>>
84533>>>>>        Set Label to C_$SystemInformation
84534>>>>>        Set Size to 140 267
84535>>>>>        Set Locate_Mode to CENTER_ON_PARENT
84536>>>>>        Set Border_Style to Border_Thick
84537>>>>>        Set Sysmenu_Icon to False
84538>>>>>
84538>>>>>        // "+1" will make the panel to paint correctly.
84538>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)) +1)
84539>>>>>
84539>>>>>        // 2014-09-14 NGS
84539>>>>>        // Added a container object around the cTexteditor
84539>>>>>        // object to get a border around the text.
84539>>>>>        Object oSysinfoDisplayContainer is a Container3d
84541>>>>>            Set Location to 2 4
84542>>>>>            Set Size to 110 255
84543>>>>>            Set Border_Style to Border_ClientEdge
84544>>>>>            Set Color to clWhite
84545>>>>>            Set peAnchors to anAll
84546>>>>>
84546>>>>>            Object oSysinfoDisplay is a SysInfoDisplay
84548>>>>>            End_Object
84549>>>>>
84549>>>>>        End_Object
84550>>>>>
84550>>>>>        Object oCloseButton is a Button
84552>>>>>            Set Label to C_$Close
84553>>>>>            Set Location to 120 210
84554>>>>>            Set Message item 0 to msg_Close_Panel
84555>>>>>            Set Default_State To True
84556>>>>>            // In case someone likes to make the AboutDialog's Border_Style to thick,
84556>>>>>            // and changes its peAnchors, we might as well prepare this object
84556>>>>>            // for that situation.
84556>>>>>            Set peAnchors to anBottomRight
84557>>>>>        End_Object
84558>>>>>
84558>>>>>        Object oCopyButton is a cCopyEditorContentButton
84560>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
84561>>>>>            Set Size to 14 50
84562>>>>>            Set Location to 120 158
84563>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
84563>>>>>            // we might as well prepare the object for it.
84563>>>>>            Set peAnchors to anBottomRight
84564>>>>>            Set phoEditorHandle to (oSysinfoDisplay(Self))
84565>>>>>        End_Object
84566>>>>>
84566>>>>>        On_Key kCancel Send Close_Panel
84567>>>>>    End_Procedure
84568>>>>>
84568>>>>>    Procedure Page Integer iPageObject
84570>>>>>        Handle hMenu
84570>>>>>        Integer iPrevState
84570>>>>>
84570>>>>>        Forward Send Page iPageObject
84572>>>>>
84572>>>>>        // Ok, this seems to have been fixed in VDF 17.1!
84572>>>>>        //
84572>>>>>    End_Procedure
84573>>>>>
84573>>>>>End_Class
84574>>>>>
84574>>>>>Class cAboutEdit is an cRichEdit
84575>>>>>    Procedure Construct_Object
84577>>>>>        Forward Send Construct_Object
84579>>>>>
84579>>>>>        Set Size to 57 153
84580>>>>>        Set Location to 8 60
84581>>>>>
84581>>>>>        Set Read_Only_State to True
84582>>>>>        Set Skip_State to True
84583>>>>>        // Font size is calculated in "Twips", which are 1/1440 of an inch,
84583>>>>>        // or 1/20 of a printer's point.
84583>>>>>//        Set piFontSize    to (9 * 20)
84583>>>>>        Set piRightMargin to (0.1 * 1440)
84584>>>>>        Set Border_Style  to Border_None
84585>>>>>    End_Procedure
84586>>>>>
84586>>>>>    // Adds a line of text to the edit object
84586>>>>>    Procedure Add_Line String sVal
84588>>>>>        String sText
84588>>>>>        Address aAddress
84588>>>>>        Get paValue to aAddress
84589>>>>>        Move aAddress to sText
84590>>>>>        Move (sText + String(sVal)) to sVal
84591>>>>>        Move (AddressOf(sVal)) to aAddress
84592>>>>>        Set paValue to aAddress
84593>>>>>    End_Procedure
84594>>>>>
84594>>>>>    // Compared to Add_Line above, this adds an extra empty line after the passed value.
84594>>>>>    // Note that we use the paValue interface,
84594>>>>>    // because the object isn't paged yet when we add the
84594>>>>>    // values and the COM edit object needs to be paged
84594>>>>>    // for the "Set Value" interface to be used.
84594>>>>>    Procedure Add_LineLn String sVal
84596>>>>>        String sText
84596>>>>>        Address aAddress
84596>>>>>        Get paValue to aAddress
84597>>>>>        Move aAddress to sText
84598>>>>>        Move (sText + String(sVal) + Character(10) + Character(13)) to sVal
84599>>>>>        Move (AddressOf(sVal)) to aAddress
84600>>>>>        Set paValue to aAddress
84601>>>>>    End_Procedure
84602>>>>>
84602>>>>>    Procedure OnLinkClicked Integer iPositionStart Integer iPositionEnd
84604>>>>>        String sLinkText
84604>>>>>        Get TextRange iPositionStart iPositionEnd to sLinkText
84605>>>>>        Send Show_HomePage sLinkText
84606>>>>>    End_Procedure
84607>>>>>
84607>>>>>End_Class
84608>>>>>
84608>>>>>// Purpose:
84608>>>>>//
84608>>>>>// Ken Ross 12/17/96 5:16PM
84608>>>>>//
84608>>>>>Class AboutDialog is a ModalPanel
84609>>>>>    Procedure Construct_Object
84611>>>>>
84611>>>>>        Forward Send Construct_Object
84613>>>>>
84613>>>>>        Set Label to C_$About
84614>>>>>        Set Size to 96 230
84615>>>>>        Set Locate_Mode To CENTER_ON_PARENT
84616>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
84617>>>>>//        Set Sysmenu_Icon to True
84617>>>>>
84617>>>>>        Object oSysInfoDialog is a SysInfoDialog
84619>>>>>        End_Object
84620>>>>>
84620>>>>>        Object oBox is a Container3d
84622>>>>>            Set Border_Style to Border_Normal
84623>>>>>            Set Size to 70 220
84624>>>>>            Set Location to 4 5
84625>>>>>            Set Color to clWhite
84626>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
84626>>>>>            // we might as well prepare the object for it.
84626>>>>>            Set peAnchors to anAll
84627>>>>>
84627>>>>>            Object oAboutGraphic is a BitmapContainer
84629>>>>>                Set Border_Style To Border_None
84630>>>>>                Set Bitmap_Style to Bitmap_Center
84631>>>>>                Set Color to clWhite
84632>>>>>                Set Size to 45 50
84633>>>>>                Set Location to 0 3
84634>>>>>            End_Object
84635>>>>>
84635>>>>>            Object oPoweredByVDFGraphic is a cBitmapContainerVDFLink
84637>>>>>                Set Border_Style to Border_None
84638>>>>>                Set Bitmap_Style to Bitmap_Center
84639>>>>>                Set Color to clWhite
84640>>>>>                Set Size to 30 55 //28 50
84641>>>>>                Set Location to 44 3
84642>>>>>            End_Object
84643>>>>>
84643>>>>>            Object oInfoList_Editor is an cAboutEdit
84645>>>>>                // In case someone wants to set the AboutDialog's Border_Style to thick,
84645>>>>>                // we might as well prepare the object for it.
84645>>>>>                Set peAnchors to anAll
84646>>>>>            End_Object
84647>>>>>
84647>>>>>            // These objects are here for backwards compatability only.
84647>>>>>            // They are not used.
84647>>>>>            Object oProductName is a TextBox
84649>>>>>                Set Label To C_$ProductName
84650>>>>>                Set Size To 10 45
84651>>>>>                Set Location To 8 53
84652>>>>>                Set Visible_State to False
84653>>>>>                Set Focus_Mode to NonFocusable
84654>>>>>            End_Object
84655>>>>>
84655>>>>>            Object oVersion is a TextBox
84657>>>>>                Set Label To C_$Version
84658>>>>>                Set Size To 10 25
84659>>>>>                Set Location To 21 53
84660>>>>>                Set Visible_State to False
84661>>>>>                Set Focus_Mode to NonFocusable
84662>>>>>            End_Object
84663>>>>>
84663>>>>>            Object oCopyright is a TextBox
84665>>>>>                Set Label To C_$Copyright
84666>>>>>                Set Size To 10 31
84667>>>>>                Set Location To 34 53
84668>>>>>                Set Visible_State to False
84669>>>>>                Set Focus_Mode to NonFocusable
84670>>>>>            End_Object
84671>>>>>
84671>>>>>            Object oAuthor is a TextBox
84673>>>>>                Set Label To C_$Author
84674>>>>>                Set Size To 10 22
84675>>>>>                Set Location To 46 53
84676>>>>>                Set Visible_State to False
84677>>>>>                Set Focus_Mode to NonFocusable
84678>>>>>            End_Object
84679>>>>>
84679>>>>>        End_Object
84680>>>>>
84680>>>>>        Object oOKButton Is A Button
84682>>>>>            On_Item C_$Close Send Close_Panel
84683>>>>>            Set Location to 78 176
84684>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
84684>>>>>            // we might as well prepare the object for it.
84684>>>>>            Set peAnchors to anBottomRight
84685>>>>>        End_Object
84686>>>>>
84686>>>>>        Object oSysInfoButton Is A Button
84688>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
84689>>>>>            Set Location to 78 123
84690>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
84690>>>>>            // we might as well prepare the object for it.
84690>>>>>            Set peAnchors to anBottomRight
84691>>>>>        End_Object
84692>>>>>
84692>>>>>        Object oCopyButton is a cCopyEditorContentButton
84694>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
84695>>>>>            Set Size to 14 50
84696>>>>>            Set Location to 78 70
84697>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
84697>>>>>            // we might as well prepare the object for it.
84697>>>>>            Set peAnchors to anBottomRight
84698>>>>>            Set phoEditorHandle to (oInfoList_Editor(Self))
84699>>>>>        End_Object
84700>>>>>
84700>>>>>        On_Key Kcancel Send KeyAction of oOKButton
84701>>>>>        Set Logo    to "DacAbout.bmp"  // Square bitmaps of 80x80 work best
84702>>>>>//        Set LogoVDF to "PoweredByDataFlex.bmp"
84702>>>>>        Set LogoVDF to "PoweredByOrange.bmp"
84703>>>>>    End_Procedure
84704>>>>>
84704>>>>>    Procedure Page Integer iPageObject
84706>>>>>        Handle hMenu
84706>>>>>        Integer iPrevState
84706>>>>>
84706>>>>>        Forward Send Page iPageObject
84708>>>>>        // Due to a bug in the ModalPanel class, we need to set the icon here:
84708>>>>>//        Set Icon to "ActionAbout.ico"
84708>>>>>
84708>>>>>        // Shadow upper left corner menu items: (icon menu items)
84708>>>>>        Move (GetSystemMenu(Window_Handle(Self), False)) to hMenu
84709>>>>>        Move (EnableMenuItem(hMenu, SC_RESTORE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
84710>>>>>        // The "Move" menu command may come in handy to have.
84710>>>>>        // Move (EnableMenuItem(hMenu, SC_MOVE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
84710>>>>>        Move (EnableMenuItem(hMenu, SC_SIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
84711>>>>>        Move (EnableMenuItem(hMenu, SC_MINIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
84712>>>>>        Move (EnableMenuItem(hMenu, SC_MAXIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
84713>>>>>        // The "Close" menu command may be good to have.
84713>>>>>        // Move (EnableMenuItem(hMenu, SC_CLOSE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
84713>>>>>    End_Procedure
84714>>>>>
84714>>>>>    Procedure Set ProductName String sText
84716>>>>>        Set Value of oProductName to sText
84717>>>>>    End_Procedure
84718>>>>>
84718>>>>>    Procedure Set Copyright String sText
84720>>>>>        Set Value of oCopyright to sText
84721>>>>>    End_Procedure
84722>>>>>
84722>>>>>    Procedure Set Author String sText
84724>>>>>        Set Value of oAuthor to sText
84725>>>>>    End_Procedure
84726>>>>>
84726>>>>>    Procedure Set Version String sVersion
84728>>>>>        Handle hoVersionInfo
84728>>>>>        Boolean bIncluded
84728>>>>>        Integer iMajor iMinor iRelease iBuild
84728>>>>>        Date dCompileDate
84728>>>>>
84728>>>>>        If (sVersion = "") Begin
84730>>>>>            // This automatically shows the program version of the program, if available.
84730>>>>>            // It will be displayed as the second item in the edit object.
84730>>>>>            If (ghoApplication <> 0) Begin
84732>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
84733>>>>>                If (hoVersionInfo <> 0) Begin
84735>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
84736>>>>>                    If (bIncluded) Begin
84738>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
84739>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
84740>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
84741>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
84742>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sVersion
84743>>>>>                    End
84743>>>>>>
84743>>>>>                End
84743>>>>>>
84743>>>>>            End
84743>>>>>>
84743>>>>>        End
84743>>>>>>
84743>>>>>
84743>>>>>        // Display the compiled date as the next row in the edit object, after the program version.
84743>>>>>        Get GetCompileDate to dCompileDate
84744>>>>>        If (sVersion <> "") Begin
84746>>>>>            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(dCompileDate))
84747>>>>>        End
84747>>>>>>
84747>>>>>    End_Procedure
84748>>>>>
84748>>>>>    Function GetCompileDate Returns Date
84750>>>>>        Date dCompileDate
84750>>>>>        String sAppFilename sData sCompileDate
84750>>>>>        Integer iChannel iPos iDateFormat
84750>>>>>
84750>>>>>        // Get full path to the current running executable
84750>>>>>        Get GetApplicationFileName of ghoApplication to sAppFilename
84751>>>>>
84751>>>>>        //Read the current file  up to where the data we're interesting in is (this was hand calced and so could vary)
84751>>>>>        Get Seq_Open_Input_Channel ("binary:" * sAppFilename) to iChannel
84752>>>>>        Read_Block channel iChannel sData (8 * 1024)    // First 8K is .exe header skip it
84754>>>>>        Read_Block channel iChannel sData 75            // The compile information we're interested in
84756>>>>>        Send Seq_Close_Channel iChannel
84757>>>>>
84757>>>>>        // The data is padded with Character(0)s. Strip them out
84757>>>>>        Move (CString(sData)) to sData
84758>>>>>
84758>>>>>        // The compile date is after the first ", ", so string parsing is required
84758>>>>>        Move (Pos(", ", sData)) to iPos
84759>>>>>        Move (Mid(sData, 10, (iPos + 2) ))  to sCompileDate // In US format
84760>>>>>        // If the current date format is non US, we need to temporary
84760>>>>>        // change the format and then move the string to the date variable.
84760>>>>>        Get_Attribute DF_DATE_FORMAT        to iDateFormat
84763>>>>>        Set_Attribute DF_DATE_FORMAT        to DF_DATE_USA
84766>>>>>        Move (Date(sCompileDate))           to dCompileDate
84767>>>>>        Set_Attribute DF_DATE_FORMAT        to iDateFormat // Reset date format
84770>>>>>
84770>>>>>        Function_Return dCompileDate
84771>>>>>    End_Function
84772>>>>>
84772>>>>>    Procedure Add_LineLn String sValue
84774>>>>>        Send Add_LineLn of oInfoList_Editor sValue
84775>>>>>    End_Procedure
84776>>>>>
84776>>>>>    Procedure Add_Line String sValue
84778>>>>>        Send Add_Line of oInfoList_Editor sValue
84779>>>>>    End_Procedure
84780>>>>>
84780>>>>>    Procedure Set Logo string sLogo
84782>>>>>        // Square bitmaps of 80x80 work best
84782>>>>>        Set Bitmap of oAboutGraphic to sLogo
84783>>>>>    End_Procedure
84784>>>>>
84784>>>>>    Procedure Set LogoVDF String sLogo
84786>>>>>        Set Bitmap of oPoweredByVDFGraphic to sLogo
84787>>>>>    End_Procedure
84788>>>>>
84788>>>>>    Procedure Show_Sysinfo
84790>>>>>        Send Popup_Modal of oSysinfoDialog
84791>>>>>    End_Procedure
84792>>>>>
84792>>>>>    Procedure Show_HomePage String sWebpage
84794>>>>>        Handle hWnd hInstance
84794>>>>>        Get Window_Handle to hWnd
84795>>>>>        Move (ShellExecute(hWnd, "open", (Trim(sWebpage)), "", "", 1)) to hInstance
84796>>>>>    End_Procedure
84797>>>>>
84797>>>>>//    Procedure End_Construct_Object
84797>>>>>//        Handle hoVersionInfo
84797>>>>>//        Boolean bIncluded
84797>>>>>//        Integer iMajor iMinor iRelease iBuild
84797>>>>>//        String sLabel sVersion
84797>>>>>//
84797>>>>>//        If (sVersion = "") Begin
84797>>>>>//            // This automatically shows the program version of the program, if available.
84797>>>>>//            // It will be displayed as the last item in the edit object.
84797>>>>>//            If (ghoApplication <> 0) Begin
84797>>>>>//                Get phoVersionInfo of ghoApplication to hoVersionInfo
84797>>>>>//                If (hoVersionInfo <> 0) Begin
84797>>>>>//                    Get pbIncluded of hoVersionInfo to bIncluded
84797>>>>>//                    If (bIncluded) Begin
84797>>>>>//                        Get piVersionMajor of hoVersionInfo to iMajor
84797>>>>>//                        Get piVersionMinor of hoVersionInfo to iMinor
84797>>>>>//                        Get piVersionRelease of hoVersionInfo to iRelease
84797>>>>>//                        Get piVersionBuild of hoVersionInfo to iBuild
84797>>>>>//                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sLabel
84797>>>>>//                        Set Version to sLabel
84797>>>>>//                    End
84797>>>>>//                End
84797>>>>>//            End
84797>>>>>//        End
84797>>>>>//
84797>>>>>//        Forward Send End_Construct_Object
84797>>>>>//    End_Procedure
84797>>>>>
84797>>>>>End_Class
84798>>>
84798>>>// *************************************************************************
84798>>>//  Public message. This is the default message. It is expected that you will
84798>>>//   create your own message to override this
84798>>>// *************************************************************************
84798>>>
84798>>>Procedure Activate_About
84801>>>   Send DoAbout "" "" "" "" ""
84802>>>End_Procedure
84803>>>
84803>>>// *************************************************************************
84803>>>//  Public message. It is expected that you will send this message (most
84803>>>//  likely from Activate_About. This creates an about object, activates it
84803>>>//  and destroys it when done. It is not exepected that you will augment this.
84803>>>// *************************************************************************
84803>>>// Sample usage:
84803>>>//   The first two params will automatically be filled from the application settings if not provided.
84803>>>//   Send DoAbout "" "" ("Copyright: 2013" * psCompany(ghoApplication)) "Created by: Your Name" "YourAppBitmap.bmp" "Internet: http://www.YourWebAddress.com" "E-mail: mailto:support@YourEmailAddress.com" "Some other description of choice" "9th param" "and last param"
84803>>>
84803>>>Procedure DoAbout String sTitle String sVersion String sCopyRight String sAuthor String sBitmap ;                  String sParam6 String sParam7 String sParam8 String sParam9 String sParam10
84806>>>        Integer hoObj hoMain iArgs
84806>>>        String sValue
84806>>>
84806>>>        // Create object
84806>>>        Object About is an AboutDialog
84808>>>            // Uncomment these two lines if you would like to have a resizable About object.
84808>>>//            Set Border_Style to Border_Thick
84808>>>//            Set peAnchors to anAll
84808>>>
84808>>>            // Add checking for the number of arguments passed to avoid runtime errors
84808>>>            // if one of them is not passed. This makes the interface
84808>>>            // more flexible.
84808>>>            Move num_arguments to iArgs
84809>>>
84809>>>            // If no title is passed use the label of the main panel (if a main panel exists).
84809>>>            If (iArgs > 0 and sTitle = "") Begin
84811>>>                Get Main_Window of Desktop to hoMain
84812>>>                If hoMain Begin
84814>>>                    Get Label of hoMain to sValue
84815>>>                End
84815>>>>
84815>>>            End
84815>>>>
84815>>>            Else If (iArgs > 0 and sTitle <> "") Begin
84818>>>                Move sTitle to sValue
84819>>>            End
84819>>>>
84819>>>            Else If (iArgs = 0) Begin
84822>>>                Get Main_Window of Desktop to hoMain
84823>>>                If hoMain Begin
84825>>>                    Get Label of hoMain to sValue
84826>>>                End
84826>>>>
84826>>>            End
84826>>>>
84826>>>
84826>>>            If (sValue <> "") Begin
84828>>>                Send Add_LineLn sValue
84829>>>            End
84829>>>>
84829>>>            Move "" to sValue
84830>>>
84830>>>            // If the passed sVersion value is blank, the info will be retrieved from the cApplication object.
84830>>>            // For this to work the Project Properties Version must have been set in the Studio.
84830>>>            If (iArgs < 2) Begin
84832>>>                Move "" to sValue
84833>>>            End
84833>>>>
84833>>>            Else Begin
84834>>>                Move sVersion to sValue
84835>>>            End
84835>>>>
84835>>>            Set Version to sValue
84836>>>
84836>>>            If (iArgs > 2 and sCopyRight <> "") Begin
84838>>>                Send Add_LineLn sCopyRight
84839>>>            End
84839>>>>
84839>>>
84839>>>            // If only the five "standard" params were passed we don't add an extra linefeed;
84839>>>            // else we do.
84839>>>            If (iArgs > 3 and iArgs < 6 and sAuthor <> "") Begin
84841>>>                Send Add_Line sAuthor
84842>>>            End
84842>>>>
84842>>>            Else If (iArgs > 5 and sAuthor <> "") Begin
84845>>>                Send Add_LineLn sAuthor
84846>>>            End
84846>>>>
84846>>>
84846>>>            // Square bitmaps of 80x80 works best
84846>>>            If (iArgs > 4 and sBitmap <> "") Begin
84848>>>               Set Logo to sBitMap
84849>>>            End
84849>>>>
84849>>>
84849>>>            // Here starts handling of the five optional params:
84849>>>            If (iArgs = 6 and sParam6  <> "") Begin
84851>>>                Send Add_Line sParam6
84852>>>            End
84852>>>>
84852>>>            Else If (iArgs > 6 and sParam6  <> "") Begin
84855>>>                Send Add_LineLn sParam6
84856>>>            End
84856>>>>
84856>>>
84856>>>            If (iArgs = 7 and sParam7  <> "") Begin
84858>>>                Send Add_Line sParam7
84859>>>            End
84859>>>>
84859>>>            Else If (iArgs > 7 and sParam7  <> "") Begin
84862>>>                Send Add_LineLn sParam7
84863>>>            End
84863>>>>
84863>>>
84863>>>            If (iArgs = 8 and sParam8  <> "") Begin
84865>>>                Send Add_Line sParam8
84866>>>            End
84866>>>>
84866>>>            Else If (iArgs > 8 and sParam8  <> "") Begin
84869>>>                Send Add_LineLn sParam8
84870>>>            End
84870>>>>
84870>>>
84870>>>            If (iArgs = 9 and sParam9  <> "") Begin
84872>>>                Send Add_Line sParam9
84873>>>            End
84873>>>>
84873>>>            Else If (iArgs > 9 and sParam9  <> "") Begin
84876>>>                Send Add_LineLn sParam9
84877>>>            End
84877>>>>
84877>>>
84877>>>            If (iArgs = 10 and sParam10 <> "") Begin
84879>>>                Send Add_Line sParam10
84880>>>            End
84880>>>>
84880>>>
84880>>>            Move Self to hoObj
84881>>>        End_Object
84882>>>
84882>>>        Send Popup   of hoObj // Popup the about object
84883>>>        Send Destroy of hoObj // When done, it will be destroyed
84884>>>End_Procedure
84885>        Use DatabaseSelection.dg
Including file: DatabaseSelection.dg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\DatabaseSelection.dg)
84885>>>Use Windows.pkg
84885>>>Use cCJGridPromptList.pkg
Including file: cCJGridPromptList.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJGridPromptList.pkg)
84885>>>>>Use Windows.pkg
84885>>>>>Use cCJGrid.pkg
84885>>>>>
84885>>>>>
84885>>>>>
84885>>>>>Class cCJGridPromptList is a cCJGrid
84886>>>>>
84886>>>>>    Procedure Construct_Object
84888>>>>>        Forward Send Construct_Object
84890>>>>>
84890>>>>>        Property Boolean pbAutoSeed True     // if we should seed list from invoking data
84891>>>>>        Property Boolean Private_pbAutoOrdering True
84892>>>>>        Property Boolean pbAutoSearch True  // pops up search window
84893>>>>>        Property Integer peUpdateMode umPromptValue
84894>>>>>        Property Integer piUpdateColumn 0
84895>>>>>        Property Integer piInitialColumn -1
84896>>>>>        Property String  psSeedValue ''
84897>>>>>        Property Handle phmPromptUpdateCallback 0
84898>>>>>        Property Integer phoInvokingObject
84899>>>>>        
84899>>>>>        Property Boolean pbStoredAutoSeed
84900>>>>>        Property Boolean pbStoredAutoOrdering
84901>>>>>        Property Boolean pbStoredAutoSearch
84902>>>>>        Property Integer peStoredUpdateMode
84903>>>>>        Property Integer piStoredUpdateColumn
84904>>>>>        Property Integer piStoredInitialColumn
84905>>>>>        Property Handle  phmStoredPromptUpdateCallback
84906>>>>>        Property Boolean pbStoredSelectionEnable
84907>>>>>        Property Boolean pbStoredMultipleSelection
84908>>>>>
84908>>>>>        // internally set by list
84908>>>>>        // these must be set upon closing the list and can be used for manual list updates
84908>>>>>        Property Boolean pbCanceled
84909>>>>>        Property Integer[] pSelectedRows
84910>>>>>
84910>>>>>        Property Boolean pbNeedsNewOrdering
84911>>>>>        Property Boolean pbRequestSearch
84912>>>>>        Property tGridKeyPair[] pSearchKeys
84913>>>>>        
84913>>>>>        // these properties makes a prompt list a prompt list
84913>>>>>        // and should not be changed.
84913>>>>>        Set pbEditOnKeyNavigation to False
84914>>>>>        Set pbEditOnClick to False
84915>>>>>        Set pbReadOnly to True
84916>>>>>        Set pbFocusSubItems to True
84917>>>>>        
84917>>>>>        // these could maybe be changed
84917>>>>>        Set pbShadeSortColumn to True
84918>>>>>        Set pbHeaderReorders to True
84919>>>>>        Set pbHeaderTogglesDirection to True
84920>>>>>        Set pbHeaderSelectsColumn to True
84921>>>>>        Set peHorizontalGridStyle to xtpGridNoLines
84922>>>>>        Set piFocusCellBackColor to clNone
84923>>>>>        Set piFocusCellForeColor to clNone
84924>>>>>        Set piFocusCellRectangleColor to clBlack
84925>>>>>        Set pbUseFocusCellRectangle to False
84926>>>>>        Set pbSelectionEnable to True
84927>>>>>        
84927>>>>>        On_Key kEnter Send Ok
84928>>>>>        On_Key kCancel Send Cancel
84929>>>>>
84929>>>>>    End_Procedure
84930>>>>>    
84930>>>>>    // reorder list automatically on column change
84930>>>>>    // this also set pbFocusSubItems which is required to make the two states work
84930>>>>>    Procedure Set pbAutoOrdering Boolean bAutoOrder
84932>>>>>        Set Private_pbAutoOrdering to bAutoOrder
84933>>>>>        Set pbFocusSubItems to bAutoOrder
84934>>>>>    End_Procedure
84935>>>>>    
84935>>>>>    Function pbAutoOrdering Returns Boolean
84937>>>>>        Boolean bAutoOrder
84937>>>>>        Get Private_pbAutoOrdering to bAutoOrder
84938>>>>>        Function_Return bAutoOrder
84939>>>>>    End_Function
84940>>>>>
84940>>>>>    // augmented to handle auto-ordering and invoking the search popup list
84940>>>>>    Procedure OnIdle
84942>>>>>        Boolean bNeedsReorder bSearch bOldToggle
84942>>>>>        Handle hoCol
84942>>>>>        Integer iKy1 iKy2 iCol
84942>>>>>
84942>>>>>        Get pbNeedsNewOrdering to bNeedsReorder
84943>>>>>        If bNeedsReorder Begin
84945>>>>>            Get SelectedColumn to iCol
84946>>>>>            If (iCol<>-1) Begin
84948>>>>>                
84948>>>>>                Get pbHeaderTogglesDirection to bOldToggle
84949>>>>>                Set pbHeaderTogglesDirection to False
84950>>>>>                Send HeaderReorder iCol
84951>>>>>                Set pbHeaderTogglesDirection to bOldToggle
84952>>>>>                
84952>>>>>                Set pbNeedsNewOrdering to False
84953>>>>>            End
84953>>>>>>
84953>>>>>        End
84953>>>>>>
84953>>>>>        
84953>>>>>        Get pbRequestSearch to bSearch
84954>>>>>        If bSearch Begin
84956>>>>>            Send Request_SearchEx // will use the keys pSearchKeys as eed
84957>>>>>        End
84957>>>>>>
84957>>>>>        
84957>>>>>        Forward Send OnIdle
84959>>>>>    End_Procedure
84960>>>>>    
84960>>>>>    Procedure OnStoreDefaults
84962>>>>>        Integer iVal
84962>>>>>        Boolean bVal
84962>>>>>
84962>>>>>        Get pbAutoSeed to bVal           
84963>>>>>        Set pbStoredAutoSeed to bVal           
84964>>>>>        
84964>>>>>        Get pbAutoOrdering to bVal        
84965>>>>>        Set pbStoredAutoOrdering to bVal      
84966>>>>>        
84966>>>>>        Get pbAutoSearch to bVal         
84967>>>>>        Set pbStoredAutoSearch to bVal         
84968>>>>>        
84968>>>>>        Get peUpdateMode to iVal
84969>>>>>        Set peStoredUpdateMode to iVal
84970>>>>>        
84970>>>>>        Get piUpdateColumn to iVal       
84971>>>>>        Set piStoredUpdateColumn to iVal       
84972>>>>>
84972>>>>>        Get piInitialColumn to iVal       
84973>>>>>        Set piStoredInitialColumn to iVal       
84974>>>>>
84974>>>>>        Get phmPromptUpdateCallback to iVal       
84975>>>>>        Set phmStoredPromptUpdateCallback to iVal       
84976>>>>>
84976>>>>>        Get pbSelectionEnable to bVal
84977>>>>>        Set pbStoredSelectionEnable to bVal
84978>>>>>        
84978>>>>>        Get pbMultipleSelection to bVal
84979>>>>>        Set pbStoredMultipleSelection to bVal
84980>>>>>        
84980>>>>>    End_Procedure
84981>>>>>
84981>>>>>    Procedure OnRestoreDefaults
84983>>>>>        Integer iVal
84983>>>>>        Boolean bVal
84983>>>>>
84983>>>>>        Get pbStoredAutoSeed to bVal           
84984>>>>>        Set pbAutoSeed to bVal           
84985>>>>>        
84985>>>>>        Get pbStoredAutoOrdering to bVal        
84986>>>>>        Set pbAutoOrdering to bVal      
84987>>>>>        
84987>>>>>        Get pbStoredAutoSearch to bVal         
84988>>>>>        Set pbAutoSearch to bVal         
84989>>>>>        
84989>>>>>        Get peStoredUpdateMode to iVal
84990>>>>>        Set peUpdateMode to iVal
84991>>>>>        
84991>>>>>        Get piStoredInitialColumn to iVal       
84992>>>>>        Set piInitialColumn to iVal       
84993>>>>>        
84993>>>>>        Get phmStoredPromptUpdateCallback to iVal       
84994>>>>>        Set phmPromptUpdateCallback to iVal       
84995>>>>>
84995>>>>>        Get pbStoredSelectionEnable to bVal
84996>>>>>        Set pbSelectionEnable to bVal
84997>>>>>        
84997>>>>>        Get pbStoredMultipleSelection to bVal
84998>>>>>        Set pbMultipleSelection to bVal
84999>>>>>
84999>>>>>    End_Procedure
85000>>>>>    
85000>>>>>    // finds the target seed value in the updatecolumn. If we autoseed and there is a
85000>>>>>    // seed value (psSeedValue), attempt to find GE that value, else move to first row
85000>>>>>    // Suitable for augmentation
85000>>>>>    Procedure OnSeedData
85002>>>>>        Integer iUpdateColumn iSortColumn
85002>>>>>        Boolean bSeed bAuto
85002>>>>>        String sValue
85002>>>>>        Handle hoCol
85002>>>>>
85002>>>>>        Get piUpdateColumn to iUpdateColumn
85003>>>>>        Get psSeedValue to sValue
85004>>>>>        Get pbAutoSeed to bSeed
85005>>>>>        Get piSortColumn to iSortColumn
85006>>>>>        Get pbAutoOrdering to bAuto
85007>>>>>        // if not yet sorted and this is auto ordering we will
85007>>>>>        // sort the data for the search column. We do this to make the
85007>>>>>        // column search GE logic work properly. 
85007>>>>>        If (bSeed and bAuto and iUpdateColumn<>-1 and iSortColumn<>iUpdateColumn) Begin
85009>>>>>            Get ColumnObject iUpdateColumn to hoCol
85010>>>>>            Send SortGridByColumn hoCol False
85011>>>>>        End
85011>>>>>>
85011>>>>>
85011>>>>>        If (bSeed and sValue<>"" and iUpdateColumn<>-1) Begin
85013>>>>>            Send RequestFindColumnValue iUpdateColumn sValue True 0  
85014>>>>>        End
85014>>>>>>
85014>>>>>        Else Begin
85015>>>>>            Send MovetoFirstRow
85016>>>>>        End
85016>>>>>>
85016>>>>>
85016>>>>>    End_Function
85017>>>>>
85017>>>>>    Procedure OnMoveValueOutByValue
85019>>>>>        String sValue
85019>>>>>        Handle hoInvokingObject hoCol  hoDataSource
85019>>>>>        Integer iRow iCol
85019>>>>>        Integer[] SelRowsIndexes
85020>>>>>
85020>>>>>        Get phoInvokingObject to hoInvokingObject
85021>>>>>        Get pSelectedRows to SelRowsIndexes
85022>>>>>        If (SizeOfArray(SelRowsIndexes)>0) Begin
85024>>>>>            Get piUpdateColumn to iCol
85025>>>>>            Get ColumnObject iCol to hoCol
85026>>>>>            Get RowValue of hoCol SelRowsIndexes[0] to sValue
85027>>>>>            Set Value of hoInvokingObject to sValue
85028>>>>>            Set Item_Changed_State of hoInvokingObject to True
85029>>>>>        End
85029>>>>>>
85029>>>>>    End_Procedure
85030>>>>>
85030>>>>>    Procedure OnMoveValueOutByCustom
85032>>>>>    End_Procedure
85033>>>>>
85033>>>>>    // augment to popup a search window when allowed
85033>>>>>    Procedure OnComKeyDown Short ByRef llKeyCode Short llShift
85035>>>>>        Boolean bSubFocus bAutoSearch bChar
85035>>>>>        Integer iVal
85035>>>>>        
85035>>>>>        Get pbFocusSubItems to bSubFocus
85036>>>>>        Get pbAutoSearch to bAutoSearch
85037>>>>>        Forward Send OnComKeyDown llKeyCode llShift
85039>>>>>        If (bAutoSearch and not(bSubFocus)) Begin
85041>>>>>            If ((llShift iand 6)=0) Begin // skip alt and ctrl
85043>>>>>                Get GetVKeyToAnsi llKeyCode llShift to iVal
85044>>>>>                Move (iVal<>0) to bChar
85045>>>>>            End
85045>>>>>>
85045>>>>>            If bChar Begin
85047>>>>>                // this can get called multiple times before a search dialog pops up
85047>>>>>                Send AddToSearchKeys llKeyCode llShift
85048>>>>>            End
85048>>>>>>
85048>>>>>        End
85048>>>>>>
85048>>>>>    End_Procedure
85049>>>>>    
85049>>>>>    Procedure OnComRequestEdit Variant llRow Variant llColumn Variant llItem Boolean ByRef llCancel
85051>>>>>        Boolean bAutoSearch
85051>>>>>        Integer iKeyCode iShiftCode
85051>>>>>        Get pbAutoSearch to bAutoSearch
85052>>>>>        If bAutoSearch Begin
85054>>>>>            // this can get called multiple times before a search dialog pops up
85054>>>>>            Get piLastKey to iKeyCode
85055>>>>>            Get piLastKey2 to iShiftCode
85056>>>>>            Send AddToSearchKeys iKeyCode iShiftCode
85057>>>>>        End
85057>>>>>>
85057>>>>>        Move True to llCancel
85058>>>>>    End_Procedure  // OnComRequestEdit
85059>>>>>    
85059>>>>>    Procedure OnComRowDblClick Variant llRow Variant llItem
85061>>>>>        Send ClearSearchRequest // kill any deferred search popup
85062>>>>>        Forward Send OnComRowDblClick llRow llItem
85064>>>>>    End_Procedure
85065>>>>>    
85065>>>>>    Procedure OnRowDoubleClick Integer iRow Integer iCol
85067>>>>>        Send Ok
85068>>>>>    End_Procedure
85069>>>>>    
85069>>>>>    
85069>>>>>    // we don't want a menu for prompt lists
85069>>>>>    Function CreateContextMenu Returns Handle
85071>>>>>        Function_Return 0
85072>>>>>    End_Function
85073>>>>>
85073>>>>>    // if we use auto-ordering, change the order when the column changes
85073>>>>>    Procedure ColumnChanged Integer iOld Integer iNew
85075>>>>>        Boolean bAutoOrder
85075>>>>>        Forward Send ColumnChanged iOld iNew
85077>>>>>        Get pbAutoOrdering to bAutoOrder
85078>>>>>        If bAutoOrder Begin
85080>>>>>            // will be reordered in idle event
85080>>>>>            Set pbNeedsNewOrdering to True
85081>>>>>        End
85081>>>>>>
85081>>>>>    End_Procedure
85082>>>>>    
85082>>>>>
85082>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
85084>>>>>        Integer eMode
85084>>>>>        Integer[] SelRowsIndexes
85085>>>>>        Set pbCanceled to True // assume cancel unless changed
85086>>>>>        Set pSelectedRows to SelRowsIndexes // empty
85087>>>>>        Get peUpdateMode to eMode
85088>>>>>        If (eMode<>umPromptNonInvoking) Begin
85090>>>>>            Send OnStoreDefaults
85091>>>>>        End
85091>>>>>>
85091>>>>>        Send InitializePromptList
85092>>>>>        Forward Send Add_Focus hoParent
85094>>>>>        Send LoadData
85095>>>>>        Set psSeedValue to ""
85096>>>>>    End_Procedure
85097>>>>>    
85097>>>>>    // called before the list is activated. 
85097>>>>>    Procedure InitializePromptList
85099>>>>>        Integer hoInvokingObject
85099>>>>>        Boolean bAutoColumn bAutoSeed 
85099>>>>>        Integer i iOldMode eUpdateMode
85099>>>>>        String sValue
85099>>>>>        
85099>>>>>        Get peUpdateMode to eUpdateMode
85100>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
85102>>>>>            Get Focus of Desktop to hoInvokingObject
85103>>>>>            If (hoInvokingObject<=Desktop) Begin
85105>>>>>                Error DFERR_PROGRAM "Prompt list has no invoking object"
85106>>>>>>
85106>>>>>                Procedure_Return
85107>>>>>            End
85107>>>>>>
85107>>>>>
85107>>>>>            Set phoInvokingObject to hoInvokingObject
85108>>>>>
85108>>>>>            Send Prompt_Callback to hoInvokingObject Self
85109>>>>>            Get peUpdateMode to eUpdateMode
85110>>>>>        End
85110>>>>>>
85110>>>>>
85110>>>>>        Send ClearSearchRequest // clear the search keys
85111>>>>>        Set pbNeedsNewOrdering to False
85112>>>>>
85112>>>>>        Get pbAutoSeed to bAutoSeed
85113>>>>>
85113>>>>>        If (eUpdateMode=umPromptValue) Begin // else not used here intentionally
85115>>>>>            Get Value of hoInvokingObject to sValue
85116>>>>>            Set psSeedValue to sValue
85117>>>>>        End
85117>>>>>>
85117>>>>>        
85117>>>>>    End_Procedure
85118>>>>>    
85118>>>>>    // called after list is created and active. Load Data, seed list, select start column, etc.
85118>>>>>    Procedure LoadData
85120>>>>>        Handle hoInvokingObject hoDataSource hoInitialColumn
85120>>>>>        Integer iUpdateColumn iRows iInitialColumn iInitialOrder
85120>>>>>        Integer eUpdateMode
85120>>>>>        Boolean bAutoSeed bAutoColumn bCancel bSubFocus bAutoOrder 
85120>>>>>        
85120>>>>>        Get phoDataSource to hoDataSource
85121>>>>>        Get peUpdateMode to eUpdateMode
85122>>>>>        Get phoInvokingObject to hoInvokingObject
85123>>>>>        Get pbAutoSeed to bAutoSeed
85124>>>>>        Get piInitialColumn to iInitialColumn
85125>>>>>        Get piUpdateColumn to iUpdateColumn
85126>>>>>        Get RowCount of hoDataSource to iRows
85127>>>>>        
85127>>>>>        // We need an initial column. if you specified an initial column that will get used for the start column
85127>>>>>        // and the initial sort order. If you did not, which is typical, it will use the update column
85127>>>>>        If (iInitialColumn=-1) Begin
85129>>>>>            Move iUpdateColumn to iInitialColumn
85130>>>>>        End
85130>>>>>>
85130>>>>>        If (iInitialColumn>=0) Begin
85132>>>>>            Get ColumnObject iInitialColumn to hoInitialColumn
85133>>>>>            Set pbVisible of hoInitialColumn to True // initial column should be visible
85134>>>>>        End
85134>>>>>>
85134>>>>>        Send OnSeedData // find a good starting place for the row
85135>>>>>        Get pbFocusSubItems to bSubFocus
85136>>>>>        If bSubFocus Begin
85138>>>>>            // if column focus, which is normal, go to initialcolumn       
85138>>>>>            If hoInitialColumn Begin
85140>>>>>                Get MoveToColumnObject hoInitialColumn to bCancel
85141>>>>>            End
85141>>>>>>
85141>>>>>            Else Begin
85142>>>>>                Send MoveToFirstEnterableColumn
85143>>>>>            End
85143>>>>>>
85143>>>>>        End
85143>>>>>>
85143>>>>>
85143>>>>>    End_Procedure
85144>>>>>    
85144>>>>>    // This is only called in a successful close
85144>>>>>    Procedure ClosePromptList
85146>>>>>        Handle hoDataSource hoInvokingObject
85146>>>>>        Handle hmCallBack
85146>>>>>        Integer iRow eUpdateMode
85146>>>>>        Integer[] SelRowsIndexes
85147>>>>>        
85147>>>>>        Get phoDataSource to hoDataSource
85148>>>>>        Get phoInvokingObject to hoInvokingObject
85149>>>>>        
85149>>>>>        If (pbMultipleSelection(Self)) Begin
85151>>>>>            Get GetIndexesForSelectedRows to SelRowsIndexes
85152>>>>>        End
85152>>>>>>
85152>>>>>        Else Begin
85153>>>>>            Get SelectedRow of hoDataSource to iRow
85154>>>>>            If (iRow<>-1) Begin
85156>>>>>                Move iRow to SelRowsIndexes[0]
85157>>>>>            End
85157>>>>>>
85157>>>>>        End
85157>>>>>>
85157>>>>>        
85157>>>>>        Set pbCanceled to False
85158>>>>>        Set pSelectedRows to SelRowsIndexes
85159>>>>>        
85159>>>>>        Get peUpdateMode to eUpdateMode
85160>>>>>        // if non-invoking there is by definition, no move value out
85160>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
85162>>>>>            
85162>>>>>            If (eUpdateMode=umPromptValue) Begin
85164>>>>>                Send OnMoveValueOutByValue
85165>>>>>            End
85165>>>>>>
85165>>>>>            Else If (eUpdateMode=umPromptCustom) Begin
85168>>>>>                Send OnMoveValueOutByCustom
85169>>>>>            End
85169>>>>>>
85169>>>>>                Get phmPromptUpdateCallback to hmCallBack
85170>>>>>                If hmCallBack Begin
85172>>>>>                    Send hmCallBack of hoInvokingObject Self
85173>>>>>                End
85173>>>>>>
85173>>>>>        End
85173>>>>>>
85173>>>>>
85173>>>>>        Send Close_Panel
85174>>>>>    End_Procedure
85175>>>>>
85175>>>>>    // augment to send OnRestoreDefaults.
85175>>>>>    Procedure Release_Focus
85177>>>>>        Integer eUpdateMode
85177>>>>>        Get peUpdateMode to eUpdateMode
85178>>>>>        Forward Send Release_Focus
85180>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
85182>>>>>            Send OnRestoreDefaults
85183>>>>>        End
85183>>>>>>
85183>>>>>    End_Procedure
85184>>>>>    
85184>>>>>    Function SelectedRowIds Returns RowID[]
85186>>>>>        RowID[] SelectedRowids
85187>>>>>        Integer[] SelectedRows
85188>>>>>        Integer i iRows
85188>>>>>        Handle hoDataSource
85188>>>>>        Get phoDataSource to hoDataSource
85189>>>>>        Get pSelectedRows to SelectedRows
85190>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
85191>>>>>        For i from 0 to (iRows-1)
85197>>>>>>
85197>>>>>            Get RowTag of hoDataSource SelectedRows[i] to SelectedRowIds[i]
85198>>>>>        Loop
85199>>>>>>
85199>>>>>        Function_Return SelectedRowids
85200>>>>>    End_Function
85201>>>>>
85201>>>>>    Function SelectedColumnValues Integer iCol Returns String[]
85203>>>>>        String[] SelectedValues
85204>>>>>        Integer[] SelectedRows
85205>>>>>        Integer i iRows
85205>>>>>        Handle hoCol
85205>>>>>        Get ColumnObject iCol to hoCol
85206>>>>>        Get pSelectedRows to SelectedRows
85207>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
85208>>>>>        For i from 0 to (iRows-1)
85214>>>>>>
85214>>>>>            Get RowValue of hoCol SelectedRows[i] to SelectedValues[i]
85215>>>>>        Loop
85216>>>>>>
85216>>>>>        Function_Return SelectedValues
85217>>>>>    End_Function
85218>>>>>
85218>>>>>    Procedure Ok Returns Integer
85220>>>>>        Send ClosePromptList
85221>>>>>    End_Procedure
85222>>>>>
85222>>>>>    Procedure Cancel Returns Integer
85224>>>>>        Send Close_Panel
85225>>>>>    End_Procedure
85226>>>>>        
85226>>>>>    Procedure Search
85228>>>>>        Send Activate // give focus back to list so focus things are correct
85229>>>>>        Send Request_Search 0 0
85230>>>>>    End_Procedure
85231>>>>>    
85231>>>>>    // do a search using the current keys in the search key buffer for the sort column.
85231>>>>>    // Becaue this is called via an OnIdle it is possible to have multiple keys pressed before
85231>>>>>    // the OnIdle. These have been stored in pSearchKeys and will be passed to the popup dialog
85231>>>>>    Procedure Request_SearchEx
85233>>>>>        tGridKeyPair[] Keys
85233>>>>>        tGridKeyPair[] Keys
85234>>>>>        Integer iCol
85234>>>>>        Handle hoCol hoSearchDialog 
85234>>>>>        Boolean bOk
85234>>>>>        String sValue
85234>>>>>
85234>>>>>        Get piSortColumn to iCol
85235>>>>>        If (iCol<>-1) Begin
85237>>>>>            Get ColumnObject iCol to hoCol
85238>>>>>                Get pSearchKeys to Keys
85239>>>>>            Get CreateGridSearchDialogObject to hoSearchDialog
85240>>>>>            Get RequestGridSearchEx of hoSearchDialog Keys hoCol (&sValue) to bOk
85241>>>>>            If bOk Begin
85243>>>>>               Send RequestFindColumnValue iCol sValue True 0  
85244>>>>>            End
85244>>>>>>
85244>>>>>            Send Destroy of hoSearchDialog
85245>>>>>        End
85245>>>>>>
85245>>>>>        Send ClearSearchRequest // clear the search keys
85246>>>>>    End_Procedure
85247>>>>>    
85247>>>>>    // set pbRequestSearch to true and add the keys to the search buffer.
85247>>>>>    Procedure AddToSearchKeys Integer iKeyCode Integer iShiftCode
85249>>>>>        tGridKeyPair[] Keys
85249>>>>>        tGridKeyPair[] Keys
85250>>>>>        tGridKeyPair KeyPair
85250>>>>>        tGridKeyPair KeyPair
85250>>>>>        Set pbRequestSearch to True
85251>>>>>        Move iKeyCode to KeyPair.KeyCode
85252>>>>>        Move iShiftCode to KeyPair.ShiftCode
85253>>>>>        Get pSearchKeys to Keys                
85254>>>>>        Move KeyPair to Keys[SizeOfArray(Keys)]
85255>>>>>        Set pSearchKeys to Keys                
85256>>>>>    End_Procedure
85257>>>>>
85257>>>>>    Procedure ClearSearchRequest
85259>>>>>        tGridKeyPair[] SearchKeys
85259>>>>>        tGridKeyPair[] SearchKeys
85260>>>>>        Set pSearchKeys to SearchKeys
85261>>>>>        Set pbRequestSearch to False
85262>>>>>    End_Procedure
85263>>>>>    
85263>>>>>End_Class
85264>>>Use cDbUpdateFunctionLibrary.pkg
Including file: cDbUpdateFunctionLibrary.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.pkg)
85264>>>>>//****************************************************************************
85264>>>>>// $Module type: Class
85264>>>>>// $Module name: cDbUpdateFunctionLibrary
85264>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
85264>>>>>// Web-site    : http://www.rdctools.com
85264>>>>>// Created     : 2014-09-05 @ 09:50 (Military date format: YY-MM-DD)
85264>>>>>//
85264>>>>>// Description : The class consists of a function library for database manipulations, aka make changes to a database.
85264>>>>>//               It has top level functions that uses the DataFlex db API, _but_ also specialized
85264>>>>>//               functions to make db changes to Sql databases with the DAW & Mertech drivers,
85264>>>>>//               with the help of Sql-scripts.
85264>>>>>//
85264>>>>>// $Rev History:
85264>>>>>//    2014-09-05  Module header created
85264>>>>>//
85264>>>>>//****************************************************************************
85264>>>>>Use cApplication.pkg
85264>>>>>Use seq_chnl.pkg
85264>>>>>Use GlobalFunctionsProcedures.pkg
85264>>>>>Use Datadict.pkg                        // Declaration of DF_FILE_SQL_TABLE_NAME
85264>>>>>Use DUFStatusPanel.pkg
Including file: DUFStatusPanel.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\DUFStatusPanel.pkg)
85264>>>>>>>// StatPnl.pkg - creates the standard status_panel object.
85264>>>>>>>//
85264>>>>>>>//
85264>>>>>>>// This is the default Status Panel object used by any of the Visual DataFlex classes that
85264>>>>>>>// invoke the standard status panel. The standard has always been that the package name
85264>>>>>>>// is StatPnl.pkg and the name of the object is Status_Panel. As of 12.0, there are major
85264>>>>>>>// changes in the way the status panel operates The Sentinel based external status panel used in
85264>>>>>>>// prior revisions has been replace with status panel that is part of the application.
85264>>>>>>>// This should work much better and faster than the old sentinel based solution.
85264>>>>>>>// While the way this operates has changed, the interface has not and therefore this should work
85264>>>>>>>// with most applications.
85264>>>>>>>//
85264>>>>>>>// As of 12.0, we have added a global handle that contains the object ID of this status panel.
85264>>>>>>>// This variable ghoStatusPanel can be used in place of the object name Status_Panel. This provides
85264>>>>>>>// a cleaner more robust interface.
85264>>>>>>>//
85264>>>>>>>//
85264>>>>>>>// Compatibility Note:
85264>>>>>>>//
85264>>>>>>>// When used in the standard way, this change will require no changes. A developer will only need to
85264>>>>>>>// change their code if they've modified the sentinel program, which was a difficult thing to do.
85264>>>>>>>//
85264>>>>>>>// If for some reason you application will not work using this as a replacement for the old status
85264>>>>>>>// panel, you've probably done something special with the old status-panel. If you don't want to
85264>>>>>>>// figure out how to use the new one and you want to continue using the old one you are going to need
85264>>>>>>>// to add some code to include the old status panel in your application. Add the following to your project (your src).
85264>>>>>>>//
85264>>>>>>>// Use StatPnl.pkg    // Make sure you load the new status panel object first. this is not optional!
85264>>>>>>>// Use OldStatPnl.pkg // load the old status panel. Status_Panel is now this old object
85264>>>>>>>//
85264>>>>>>>// If you do this, you will lose access to the new status-panel via Status_Panel. However, you
85264>>>>>>>// can still access the new object via the ghoStatusPanel handle.
85264>>>>>>>//
85264>>>>>>>//
85264>>>>>>>// Creating your own Status Panel objects
85264>>>>>>>//
85264>>>>>>>// If a developer wishes to create a custom panel, they should use this package as their template.
85264>>>>>>>// This panel can be visually modeled and changed any way you wish. Just save your new custom panel
85264>>>>>>>// with a different file and object name and direct your status panel request to the new object.
85264>>>>>>>//
85264>>>>>>>// If the new panel changes the interface and updates objects that are not currently defined, you
85264>>>>>>>// want to make sure you send the message ProcessEvents after you've updated the object. This allows
85264>>>>>>>// the object to paint when inside of a tight loop. For example, if you wanted to add a progress
85264>>>>>>>// bar (cProgressBar) you would want to Send ProcessEvents after you update the progress bar.
85264>>>>>>>// e.g.
85264>>>>>>>//       Procedure UpdateStatusBar
85264>>>>>>>//           Send DoAdvance of oProgressBar
85264>>>>>>>//           Send ProcessEvents
85264>>>>>>>//       End_Procedure
85264>>>>>>>//
85264>>>>>>>// of course, if you use the standard interfaces in status bar and your forward send these
85264>>>>>>>// messages this will be done for you.
85264>>>>>>>//
85264>>>>>>>// the standard Interface for status panels are:
85264>>>>>>>//
85264>>>>>>>// Send Initialize_StatusPanel - initializes values for caption, title & message
85264>>>>>>>// Send Start_StatusPanel      - start the status panel
85264>>>>>>>// Send Stop_StatusPanel       - stop the status panel
85264>>>>>>>// Send Update_StatusPanel     - update the status panel's action area
85264>>>>>>>// Get  Check_StatusPanel      - check for cancel (if cancel or pbCancel is set, close the panel)
85264>>>>>>>//
85264>>>>>>>// Get/Set Caption_Text - updates the caption bar
85264>>>>>>>// Get/Set Title_Text   - updates the title area
85264>>>>>>>// Get/Set Message_Text - updates the Message area
85264>>>>>>>// Get/Set Action_Text  - updates the action area
85264>>>>>>>// Get/Set Button_Text  - updates the button area
85264>>>>>>>//
85264>>>>>>>// Get/Set Allow_cancel_state - determines if panel can be canceled
85264>>>>>>>// Send EnableCancelButton - code you should provide to enable/disable cancel button
85264>>>>>>>//
85264>>>>>>>// ghoStatusPanel - global handle that points to the standard status panel.
85264>>>>>>>Use cProcessStatusPanel.pkg
85264>>>>>>>Use cCJSkinFramework.pkg
85264>>>>>>>Use cProgressBar.pkg
Including file: cProgressBar.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cProgressBar.pkg)
85264>>>>>>>>>Use Windows.pkg
85264>>>>>>>>>Use cWinControl.pkg
85264>>>>>>>>>Use CommCtrl.pkg
85264>>>>>>>>>
85264>>>>>>>>>Type tPbRange
85264>>>>>>>>>    Field tPbRange.iLow  as DWord
85264>>>>>>>>>    Field tPbRange.iHigh as DWord
85264>>>>>>>>>End_Type
85264>>>>>>>>>
85264>>>>>>>>>//{ OverrideProperty=pbEnabled DesignTime=False }
85264>>>>>>>>>Class cProgressBar is a cWinControl
85265>>>>>>>>>
85265>>>>>>>>>    Procedure Construct_Object
85267>>>>>>>>>        Forward Send Construct_Object
85269>>>>>>>>>        Property Integer private_piMinimum
85270>>>>>>>>>        Property Integer private_piMaximum   100
85271>>>>>>>>>        Property Integer private_piAdvanceBy 10
85272>>>>>>>>>        Property Integer private_piPosition
85273>>>>>>>>>        Property Integer private_pbVertical  False
85274>>>>>>>>>        Property Integer private_pbSmooth    False
85275>>>>>>>>>        Property Integer private_piBackColor clDefault
85276>>>>>>>>>        Property Integer private_piBarColor  clDefault
85277>>>>>>>>>
85277>>>>>>>>>        Send Define_ToolTip_Support_Mixin
85278>>>>>>>>>
85278>>>>>>>>>        Set External_Class_Name 'cVdfProgressBar' To 'msctls_progress32'
85279>>>>>>>>>        Set Focus_Mode to NonFocusable
85280>>>>>>>>>        Set Skip_State to True
85281>>>>>>>>>        Set pbUseFormWindowHandle to False     // Must come after Define_ToolTip_Support_Mixin
85282>>>>>>>>>    End_Procedure
85283>>>>>>>>>
85283>>>>>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
85284>>>>>>>>>
85284>>>>>>>>>    Procedure Set piMinimum Integer iMin
85286>>>>>>>>>        Integer iMax
85286>>>>>>>>>
85286>>>>>>>>>        Set private_piMinimum to iMin
85287>>>>>>>>>        Get private_piMaximum To iMax
85288>>>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
85289>>>>>>>>>    End_Procedure
85290>>>>>>>>>    Function piMinimum Returns Integer
85292>>>>>>>>>        If (Window_Handle(self)) Function_Return (WindowsMessage(PBM_GETRANGE, 1, 0))
85295>>>>>>>>>        Else Function_Return (private_piMinimum(self))
85297>>>>>>>>>    End_Function
85298>>>>>>>>>
85298>>>>>>>>>    Procedure Set piMaximum Integer iMax
85300>>>>>>>>>        Integer iMin
85300>>>>>>>>>
85300>>>>>>>>>        Set private_piMaximum to iMax
85301>>>>>>>>>        Get private_piMinimum To iMin
85302>>>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
85303>>>>>>>>>    End_Procedure
85304>>>>>>>>>    Function piMaximum Returns Integer
85306>>>>>>>>>        If (Window_Handle(self)) Function_Return (WindowsMessage(PBM_GETRANGE, 0, 0))
85309>>>>>>>>>        Else Function_Return (private_piMaximum(self))
85311>>>>>>>>>    End_Function
85312>>>>>>>>>
85312>>>>>>>>>    Procedure Set piAdvanceBy Integer iAdvanceBy
85314>>>>>>>>>        Set private_piAdvanceBy To iAdvanceBy
85315>>>>>>>>>        Send Windows_Message PBM_SETSTEP iAdvanceBy 0
85316>>>>>>>>>    End_Procedure
85317>>>>>>>>>    Function piAdvanceBy Returns Integer
85319>>>>>>>>>        Function_Return (private_piAdvanceBy(self))
85320>>>>>>>>>    End_Function
85321>>>>>>>>>
85321>>>>>>>>>    Procedure Set piPosition Integer iPos
85323>>>>>>>>>        Set private_piPosition To iPos
85324>>>>>>>>>        Send Windows_Message PBM_SETPOS iPos 0
85325>>>>>>>>>    End_Procedure
85326>>>>>>>>>
85326>>>>>>>>>    Function piPosition Returns Integer
85328>>>>>>>>>        If (Window_Handle(self)) Function_Return (WindowsMessage(PBM_GETPOS, 0, 0))
85331>>>>>>>>>        Else Function_Return (private_piPosition(self))
85333>>>>>>>>>    End_Function
85334>>>>>>>>>
85334>>>>>>>>>    Procedure Set pbVertical Boolean bVertical
85336>>>>>>>>>        If (private_pbVertical(self) <> bVertical) Begin
85338>>>>>>>>>            Set private_pbVertical To bVertical
85339>>>>>>>>>           Send DoRecreateWindow
85340>>>>>>>>>        End
85340>>>>>>>>>>
85340>>>>>>>>>    End_Procedure
85341>>>>>>>>>
85341>>>>>>>>>    Function pbVertical Returns Boolean
85343>>>>>>>>>        Function_Return (private_pbVertical(self))
85344>>>>>>>>>    End_Function
85345>>>>>>>>>
85345>>>>>>>>>    Procedure Set pbSmooth Boolean bSmooth
85347>>>>>>>>>        If (private_pbSmooth(self) <> bSmooth) Begin
85349>>>>>>>>>           Set private_pbSmooth To bSmooth
85350>>>>>>>>>           Send DoRecreateWindow
85351>>>>>>>>>        End
85351>>>>>>>>>>
85351>>>>>>>>>    End_Procedure
85352>>>>>>>>>    Function pbSmooth Returns Boolean
85354>>>>>>>>>        Function_Return (private_pbSmooth(self))
85355>>>>>>>>>    End_Function
85356>>>>>>>>>
85356>>>>>>>>>    Procedure Set piBackColor Integer rgbColor
85358>>>>>>>>>        Set private_piBackColor To rgbColor
85359>>>>>>>>>        Send Windows_Message PBM_SETBKCOLOR 0 rgbColor
85360>>>>>>>>>    End_Procedure
85361>>>>>>>>>    Function piBackColor Returns Integer
85363>>>>>>>>>        Function_Return (private_piBackColor(self))
85364>>>>>>>>>    End_Function
85365>>>>>>>>>
85365>>>>>>>>>    Procedure Set piBarColor Integer rgbColor
85367>>>>>>>>>        Set private_piBarColor To rgbColor
85368>>>>>>>>>        Send Windows_Message PBM_SETBARCOLOR 0 rgbColor
85369>>>>>>>>>    End_Procedure
85370>>>>>>>>>    Function piBarColor Returns Integer
85372>>>>>>>>>        Function_Return (private_piBarColor(self))
85373>>>>>>>>>    End_Function
85374>>>>>>>>>
85374>>>>>>>>>    Procedure DoAdvance
85376>>>>>>>>>        Send Windows_Message PBM_STEPIT 0 0
85377>>>>>>>>>    End_procedure
85378>>>>>>>>>
85378>>>>>>>>>    Procedure DoAdvanceBy  Integer iAdvanceBy
85380>>>>>>>>>        Send Windows_Message PBM_DELTAPOS iAdvanceBy 0
85381>>>>>>>>>    End_procedure
85382>>>>>>>>>
85382>>>>>>>>>    Procedure private_DoInitWindow
85384>>>>>>>>>        Set piBarColor  To (private_piBarColor(self))
85385>>>>>>>>>        Set piBackColor To (private_piBackColor(self))
85386>>>>>>>>>        Set piAdvanceBy To (private_piAdvanceBy(self))
85387>>>>>>>>>        Set piMinimum   To (private_piMinimum(self))
85388>>>>>>>>>        Set piMaximum   To (private_piMaximum(self))
85389>>>>>>>>>        Set piPosition  To (private_piPosition(self))
85390>>>>>>>>>    End_Procedure
85391>>>>>>>>>
85391>>>>>>>>>    Procedure Page_Object Integer iState
85393>>>>>>>>>        Handle hWnd
85393>>>>>>>>>
85393>>>>>>>>>        Get Window_Handle To hWnd
85394>>>>>>>>>        If (hWnd=0 and iState) Begin
85396>>>>>>>>>            Set Window_Style To PBS_VERTICAL (private_pbVertical(self))
85397>>>>>>>>>            Set Window_Style To PBS_SMOOTH   (private_pbSmooth(self))
85398>>>>>>>>>            Forward Send Page_Object True
85400>>>>>>>>>        End
85400>>>>>>>>>>
85400>>>>>>>>>        Else Forward Send Page_Object iState
85403>>>>>>>>>     
85403>>>>>>>>>        // Handle tooltip support....
85403>>>>>>>>>        If (iState = 0) Begin
85405>>>>>>>>>            Send RequestDeleteToolTip
85406>>>>>>>>>        End 
85406>>>>>>>>>>
85406>>>>>>>>>        Else Begin
85407>>>>>>>>>            Send RequestAddToolTip
85408>>>>>>>>>        End
85408>>>>>>>>>>
85408>>>>>>>>>    End_Procedure
85409>>>>>>>>>
85409>>>>>>>>>    Procedure Page Integer iState
85411>>>>>>>>>        Forward Send Page iState
85413>>>>>>>>>        If (iState =1) Send private_DoInitWindow
85416>>>>>>>>>    End_Procedure
85417>>>>>>>>>
85417>>>>>>>>>    // Called by Page_Object. Handles tooltip creation. We use a dedicated
85417>>>>>>>>>    // method to perform AddToolTip because it is often the case that Page_Object
85417>>>>>>>>>    // is implemented in a mixin class.
85417>>>>>>>>>    Procedure RequestAddToolTip
85419>>>>>>>>>        Send AddToolTip
85420>>>>>>>>>    End_Procedure  // RequestAddToolTip
85421>>>>>>>>>
85421>>>>>>>>>
85421>>>>>>>>>    // Called by Page_Object. Handles tooltip removal. 
85421>>>>>>>>>    Procedure RequestDeleteToolTip
85423>>>>>>>>>        Send DeleteToolTip
85424>>>>>>>>>    End_Procedure // RequestDeleteToolTip
85425>>>>>>>>>End_Class
85426>>>>>>>Use Windows.pkg
85426>>>>>>>
85426>>>>>>>
85426>>>>>>>    Global_Variable Handle ghoProgressBar // will contain the ID of the embedded progress bar.
85426>>>>>>>
85426>>>>>>>    Global_Variable Handle ghoProgressBarOverall // will contain the ID of the embedded progress bar with overall results
85426>>>>>>>
85426>>>>>>>Object Status_Panel is a cProcessStatusPanel
85428>>>>>>>    Set Size to 148 222
85429>>>>>>>    Set Border_Style to Border_Dialog
85430>>>>>>>//    Set Sysmenu_Icon to False
85430>>>>>>>//    Set Icon to "DbUpdateFrameworkdf19.ico" 
85430>>>>>>>    Set Icon to "Default.ico"
85431>>>>>>>    Move Self to ghoStatusPanel // this can be used throughout the applicaton to access this object
85432>>>>>>>
85432>>>>>>>    Property Boolean Cancel_Button_Visible_State True
85434>>>>>>>
85434>>>>>>>    Procedure Activate
85437>>>>>>>        Integer iSizeBefore
85437>>>>>>>        Get GuiSize to iSizeBefore
85438>>>>>>>        Forward Send Activate
85440>>>>>>>        Set GuiSize to (Hi(iSizeBefore)) (Low(iSizeBefore))
85441>>>>>>>    End_Procedure
85442>>>>>>>
85442>>>>>>>    Procedure End_Construct_Object
85445>>>>>>>        Forward Send End_Construct_Object
85447>>>>>>>        Set Label of oTitleTxt      to ""
85448>>>>>>>        Set Label of oTableNameTxt  to ""
85449>>>>>>>        Set Label of oMessageTxt    to ""
85450>>>>>>>        Set Label of oActionTxt     to ""
85451>>>>>>>    End_Procedure
85452>>>>>>>
85452>>>>>>>    Object oTitleTxt is a TextBox
85454>>>>>>>        Set Location to 5 21
85455>>>>>>>        Set Size to 8 179
85456>>>>>>>        Set Auto_Size_State to False
85457>>>>>>>        Set Justification_Mode  to jMode_Center
85458>>>>>>>        Set Label to "This is the Title Text"
85459>>>>>>>    End_Object
85460>>>>>>>
85460>>>>>>>    Object oTableNameTxt is a TextBox
85462>>>>>>>        Set Size to 19 204
85463>>>>>>>        Set Location to 18 9
85464>>>>>>>        Set Auto_Size_State to False
85465>>>>>>>        Set Justification_Mode to JMode_Left
85466>>>>>>>        Set Label to "This is the TableName Text"
85467>>>>>>>    End_Object
85468>>>>>>>
85468>>>>>>>    Object oMessageTxt is a TextBox
85470>>>>>>>        Set Location to 39 9
85471>>>>>>>        Set Size to 19 204
85472>>>>>>>        Set Auto_Size_State to False
85473>>>>>>>        Set Justification_Mode to JMode_Left
85474>>>>>>>        Set Label to "This is the Message text"
85475>>>>>>>    End_Object
85476>>>>>>>
85476>>>>>>>    Object oActionTxt is a TextBox
85478>>>>>>>        Set Size to 16 204
85479>>>>>>>        Set Location to 60 9
85480>>>>>>>        Set Auto_Size_State to False
85481>>>>>>>        Set Justification_Mode to JMode_Left
85482>>>>>>>        Set Label to "This is the Action Text"
85483>>>>>>>    End_Object
85484>>>>>>>
85484>>>>>>>    Object oStopButton is a Button
85486>>>>>>>        Set Location to 120 82
85487>>>>>>>        Set Label to C_$Cancel
85488>>>>>>>
85488>>>>>>>        Procedure OnClick
85491>>>>>>>            Send Close_panel
85492>>>>>>>        End_Procedure
85493>>>>>>>
85493>>>>>>>    End_Object
85494>>>>>>>
85494>>>>>>>    Object oPercentage_tb is a TextBox
85496>>>>>>>        Set Location to 74 196
85497>>>>>>>        Set Size to 10 25
85498>>>>>>>//        Set Label to "% Done"
85498>>>>>>>    End_Object
85499>>>>>>>
85499>>>>>>>    Object oCopyRight is a TextBox
85501>>>>>>>        Set Location to 137 21
85502>>>>>>>        Set Size to 9 197
85503>>>>>>>        Set FontPointHeight to 8
85504>>>>>>>        Set Auto_Size_State to False
85505>>>>>>>        Set Justification_Mode  to jMode_Center
85506>>>>>>>        Set Label to "Copyright 2001-2018 RDC Tools International"
85507>>>>>>>    End_Object
85508>>>>>>>
85508>>>>>>>    Object oProgressBar is a cProgressBar
85510>>>>>>>        Set Size to 10 179
85511>>>>>>>        Set Location to 83 22
85512>>>>>>>        Set pbVisible to True // default
85513>>>>>>>        Move Self to ghoProgressBar // this can be used throughout your application to access the progress bar
85514>>>>>>>    End_Object
85515>>>>>>>
85515>>>>>>>    Procedure Set Progress_Bar_Visible_State Boolean bVisible
85518>>>>>>>        Set pbVisible of ghoProgressBar to bVisible
85519>>>>>>>    End_Procedure
85520>>>>>>>
85520>>>>>>>    Function Progress_Bar_Visible_State Returns Boolean
85523>>>>>>>        Boolean bVisible
85523>>>>>>>        Get pbVisible of ghoProgressBar to bVisible
85524>>>>>>>        Function_Return (bVisible)
85525>>>>>>>    End_Function
85526>>>>>>>
85526>>>>>>>    Object oProgressBarOverall is a cProgressBar
85528>>>>>>>        Set Size to 10 179
85529>>>>>>>        Set Location to 104 22
85530>>>>>>>        Set pbVisible to True // default
85531>>>>>>>        Move Self to ghoProgressBarOverall // this can be used throughout your application to access the progress bar
85532>>>>>>>    End_Object
85533>>>>>>>
85533>>>>>>>    Object oOverallProgress_tb is a TextBox
85535>>>>>>>        Set Size to 10 65
85536>>>>>>>        Set Location to 95 24
85537>>>>>>>        Set Label to "Overall Progress"
85538>>>>>>>    End_Object
85539>>>>>>>
85539>>>>>>>    Procedure Set Progress_Bar_Overall_Visible_State Boolean bVisible
85542>>>>>>>        Set pbVisible of ghoProgressBarOverall to bVisible
85543>>>>>>>    End_Procedure
85544>>>>>>>
85544>>>>>>>    Function Progress_Bar_Overall_Visible_State Returns Boolean
85547>>>>>>>        Boolean bVisible
85547>>>>>>>        Get pbVisible of ghoProgressBarOverall to bVisible
85548>>>>>>>        Function_Return (bVisible)
85549>>>>>>>    End_Function
85550>>>>>>>
85550>>>>>>>    // These messages bind the standard cProcessStatusPanel interface to the actual
85550>>>>>>>    // objects defined within this instance of the status panel.
85550>>>>>>>
85550>>>>>>>    // note: all of the messages that change text should be forwarded
85550>>>>>>>    // as the forwarded messages allows the panel to paint when in a tight loop
85550>>>>>>>
85550>>>>>>>    Procedure Set Message_Text String sText
85553>>>>>>>        Set Label of oMessageTxt to sText
85554>>>>>>>        Forward Set Message_Text to sText
85556>>>>>>>    End_Procedure
85557>>>>>>>
85557>>>>>>>    Function Message_Text Returns String
85560>>>>>>>        Function_Return (Label(oMessageTxt))
85561>>>>>>>    End_Function
85562>>>>>>>
85562>>>>>>>    Procedure Set Action_Text String sText
85565>>>>>>>        Set Label of oActionTxt to sText
85566>>>>>>>        Forward Set Action_Text to sText
85568>>>>>>>    End_Procedure
85569>>>>>>>
85569>>>>>>>    Function Action_Text Returns String
85572>>>>>>>        Function_Return (Label(oActionTxt))
85573>>>>>>>    End_Function
85574>>>>>>>
85574>>>>>>>    Procedure Set Button_Text String sText
85577>>>>>>>        Set Label of oStopButton to sText
85578>>>>>>>        Forward Set Button_Text to sText
85580>>>>>>>    End_Procedure
85581>>>>>>>
85581>>>>>>>    Function Button_Text Returns String
85584>>>>>>>        Function_Return (Label(oStopButton))
85585>>>>>>>    End_Function
85586>>>>>>>
85586>>>>>>>    Procedure Set Title_Text String sText
85589>>>>>>>        Set Label of oTitleTxt to sText
85590>>>>>>>        Forward Set Title_Text to sText
85592>>>>>>>    End_Procedure
85593>>>>>>>
85593>>>>>>>    Function Title_Text Returns String
85596>>>>>>>        Function_Return (Label(oTitleTxt))
85597>>>>>>>    End_Function
85598>>>>>>>
85598>>>>>>>    Procedure Set TableName_Text String sText
85601>>>>>>>        Set Label of oTableNameTxt to sText
85602>>>>>>>    End_Procedure
85603>>>>>>>
85603>>>>>>>    Function TableName_Text Returns String
85606>>>>>>>        Function_Return (Label(oTableNameTxt))
85607>>>>>>>    End_Function
85608>>>>>>>
85608>>>>>>>    Procedure Set License_Text String sText
85611>>>>>>>//        Set Label of oLicense_txt to sText
85611>>>>>>>    End_Procedure
85612>>>>>>>
85612>>>>>>>    // gets called when status panel is activated passing whether a button
85612>>>>>>>    // should appear
85612>>>>>>>    Procedure EnableCancelButton Boolean bEnable
85615>>>>>>>        Boolean bVisible
85615>>>>>>>        Get Cancel_Button_Visible_State to bVisible
85616>>>>>>>        If (bEnable = False) Begin
85618>>>>>>>            Set Visible_State of oStopButton to bVisible
85619>>>>>>>        End
85619>>>>>>>>
85619>>>>>>>        Set Enabled_State of oStopButton to bEnable
85620>>>>>>>    End_Procedure
85621>>>>>>>
85621>>>>>>>    Procedure Reset_StatusPanel
85624>>>>>>>        Set Allow_Cancel_State of ghoStatusPanel to True
85625>>>>>>>        Set Cancel_Button_Visible_State of ghoStatusPanel to True
85626>>>>>>>        Set Progress_Bar_Visible_State  of ghoStatusPanel to True
85627>>>>>>>        Set Progress_Bar_Overall_Visible_State of ghoProgressBarOverall to False
85628>>>>>>>    End_Procedure
85629>>>>>>>
85629>>>>>>>//    Object oProgressBar is a cProgressBar
85629>>>>>>>//        Move Self to ghoProgressBar
85629>>>>>>>//        Set Location to 1 25
85629>>>>>>>//        Set Size to 9 173
85629>>>>>>>//        Set piMinimum        to 0
85629>>>>>>>//        Set piMaximum        to 2000
85629>>>>>>>//        Set piAdvanceBy      to 100
85629>>>>>>>//        Set pbSmooth to True
85629>>>>>>>//
85629>>>>>>>//        // For some weird reason the application skin makes the coloring of the progressbar
85629>>>>>>>//        // to malfunction. By telling the CodeJock SkinFramework to skip this object, the
85629>>>>>>>//        // color will show correctly.
85629>>>>>>>//        Procedure Page Integer iPageObject
85629>>>>>>>//            Handle hWin
85629>>>>>>>//            Forward Send Page iPageObject
85629>>>>>>>//            If (ghoSkinFramework <> 0) Begin
85629>>>>>>>//                Get Window_Handle to hWin
85629>>>>>>>//                Send ComRemoveWindow of ghoSkinFramework hWin
85629>>>>>>>//            End
85629>>>>>>>//        End_Procedure
85629>>>>>>>//    End_Object
85629>>>>>>>
85629>>>>>>>End_Object
85630>>>>>>>
85630>>>>>Use cDbUpdateFunctionLibrary.inc        // Various constant definitions, structs etc.
Including file: cDbUpdateFunctionLibrary.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.inc)
85630>>>>>>>Use DUFLanguageConstants.inc
Including file: DUFLanguageConstants.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\DUFLanguageConstants.inc)
85630>>>>>>>>>//
85630>>>>>>>>>// *** The Database Update Framework Include file ***
85630>>>>>>>>>// Language constant declarations for all classes included in "DUF - The Database Update Framework"
85630>>>>>>>>>// They have all been placed in this central spot to make translations to various languages more convenient.
85630>>>>>>>>>//
85630>>>>>>>>>//
85630>>>>>>>>>Use LanguageText.Pkg
85630>>>>>>>>>
85630>>>>>>>>>// *** cSQLConnectionsIniFile Class Language Constants ***
85630>>>>>>>>>//
85630>>>>>>>>>    Define CS_DUF_DuplicateConnectionIDPre  for "Cannot register connection ID"
85630>>>>>>>>>    Define CS_DUF_DuplicateConnectionIDPost for "This ID already exists."
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>// *** cSQLConnectionsHandler Class Language Constants ***
85630>>>>>>>>>//
85630>>>>>>>>>    Define CS_DUF_SetupErrorcConnection  for "Cannot login to the database server as the cConnection hasn't been setup properly. Can't continue. Program will now exit."
85630>>>>>>>>>    Define CS_DUF_CannotLoginToServer    for "Could not login to the database server. Can't continue. Program will now exit."
85630>>>>>>>>>    Define CS_DUF_ErrorText              for "\n\nError Text:"
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>// *** cDbUpdateFunctionLibrary Class Language Constants ***
85630>>>>>>>>>//
85630>>>>>>>>>    Define CS_SQLConnectError       for "SQL error. Could not connect to the SQL database manager"
85630>>>>>>>>>    Define CS_SQLAttachError        for "Could not attach to the database:"
85630>>>>>>>>>    Define CS_SQLDeletingIndex      for "Deleting index"
85630>>>>>>>>>    Define CS_SQLCopyingData        for "Copying data"
85630>>>>>>>>>    Define CS_SQLCreatingIndex      for "Creating index"
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>// *** cDbUpdateVersion Class Language Constants ***
85630>>>>>>>>>//
85630>>>>>>>>>    Define CS_UpdateVersion     for "Updating database"
85630>>>>>>>>>    Define CS_UpdateFromVersion for "from version"
85630>>>>>>>>>    Define CS_UpdateToVersion   for "to version:"
85630>>>>>>>>>    Define CS_DbUpdateTableMissing for "Cannot open the 'DbVersion' table that is used when updating the database! Cannot continue!"
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>// *** cDbUpdateHandler.inc Class Language Constants ***
85630>>>>>>>>>//
85630>>>>>>>>>    Define CS_DatabaseInUseShort  for "There are others using the application/database. Are you sure you still want to update the database?"
85630>>>>>>>>>    Define CS_DatabaseNeedsUpdate for ("The database needs to be updated." + "\n\nATTENTION! The database may not be in use while this work is performed. Make sure that nobody else is using the application before clicking 'Yes' below.\n\n" + "Start update now?")
85630>>>>>>>>>    Define CS_HeaderUpdateText    for "Important!"
85630>>>>>>>>>    Define CS_DatabaseInUseText   for "There are others using the application/database or at least one table could NOT be opened exclusively. Please close all other applications using the database and try again. The Application will now close."
85630>>>>>>>>>    Define CS_WorkingHeaderText   for "Working!"
85630>>>>>>>>>    Define CS_WorkingUpdateText   for "The database is being updated. Please wait..."
85630>>>>>>>>>    Define CS_DatabaseUpdatedText for "Ready! The database was updated."
85630>>>>>>>>>    Define CS_DatabaseCheckedText for "Ready! The database was checked but no updates was needed."
85630>>>>>>>>>    Define CS_DbUpdatedErrorText  for "One or more errors occured while the database was updated. Please check the logfile.\n\nThe program will now close."
85630>>>>>>>>>    Define CS_UpdateInProgressTxt for ("System locked!\n\nThe database is being updated. Please try again later...\n\n" * "The program will now close.")
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>>>
85630>>>>>>>
85630>>>>>>>Register_Function paSQLQueryMessages Returns String[]
85630>>>>>>>Register_Procedure Set paSQLQueryMessages String[] aSQLQueryMessages
85630>>>>>>>
85630>>>>>>>// Global handle to a cDatabaseUpdateHandler object
85630>>>>>>>    Global_Variable Handle ghoDbUpdateHandler
85630>>>>>>>
85630>>>>>>>    Define CS_DatabaseUpdateFramework for " ***  The Database Update Framework (DUF) ***"
85630>>>>>>>
85630>>>>>>>
85630>>>>>>>    Define CS_OEM_Txt for "OEM"
85630>>>>>>>
85630>>>>>>>    Define CS_ANSI_Txt for "ANSI"
85630>>>>>>>
85630>>>>>>>    Define CS_DFCONNID for "DFCONNID"
85630>>>>>>>
85630>>>>>>>    Define CS_SERVER for "SERVER"
85630>>>>>>>
85630>>>>>>>    Define CS_SERVER_NAME for "SERVER_NAME"
85630>>>>>>>
85630>>>>>>>    Define CS_DRIVER_NAME for "DRIVER_NAME"
85630>>>>>>>
85630>>>>>>>    Define CS_DATABASE_NAME for "DATABASE_NAME"
85630>>>>>>>
85630>>>>>>>    Define CS_SCHEMA_NAME for "SCHEMA_NAME"
85630>>>>>>>
85630>>>>>>>    Define CS_TABLE_CHARACTER_FORMAT for "TABLE_CHARACTER_FORMAT"
85630>>>>>>>
85630>>>>>>>    Define CS_USE_DUMMY_ZERO_DATE for "USE_DUMMY_ZERO_DATE"
85630>>>>>>>
85630>>>>>>>    Define CS_SYSTEM_FILE for "SYSTEM_FILE"
85630>>>>>>>
85630>>>>>>>    Define CS_RECNUM_TABLE for "RECNUM_TABLE"
85630>>>>>>>
85630>>>>>>>    Define CS_PRIMARY_INDEX for "PRIMARY_INDEX"
85630>>>>>>>
85630>>>>>>>    Define CS_INDEX_NUMBER for "INDEX_NUMBER"
85630>>>>>>>
85630>>>>>>>    Define CS_INDEX_NAME for "INDEX_NAME"
85630>>>>>>>
85630>>>>>>>    Define CS_DUFLowestAllowedDateValue for "01/01/1753"
85630>>>>>>>    Define CS_DUFLowestSQLDateValue     for "1753-01-01"
85630>>>>>>>
85630>>>>>>>
85630>>>>>>>    Global_Variable Handle ghoDbUpdateFunctionLibrary
85630>>>>>>>
85630>>>>>>>Struct tSQLScriptArray
85630>>>>>>>    Boolean bError
85630>>>>>>>    Boolean bArgumentSizeChanged
85630>>>>>>>    Integer iOrgArgumentSize
85630>>>>>>>    String[] sSQLScriptArray
85630>>>>>>>End_Struct
85630>>>>>>>
85630>>>>>>>Struct tSqlErrorArray
85630>>>>>>>    String[]  sSqlErrorArray
85630>>>>>>>    String[]  sSqlStatementArray
85630>>>>>>>    Integer[] iSqlErrorArray
85630>>>>>>>End_Struct
85630>>>>>>>
85630>>>>>>>Struct tSqlColumnNew
85630>>>>>>>    String  sBaseColumnName
85630>>>>>>>    String  sBaseTableName
85630>>>>>>>    String  sLabel
85630>>>>>>>    Integer iSqlType
85630>>>>>>>    Integer iSize
85630>>>>>>>    Integer iPrecision
85630>>>>>>>    Integer iDFType
85630>>>>>>>    Integer iDFNativeType
85630>>>>>>>End_Struct
85630>>>>>>>
85630>>>>>>>Struct tColumnType
85630>>>>>>>    String  sSQLType
85630>>>>>>>    Integer iSQLType
85630>>>>>>>    Boolean bCanEditSize
85630>>>>>>>    Integer iDefaultSize
85630>>>>>>>    Integer iMinSize
85630>>>>>>>    Number  nMaxSize
85630>>>>>>>    String  sDataFlexType
85630>>>>>>>    Integer iDataFlexType
85630>>>>>>>    Boolean bNativeDataType
85630>>>>>>>    String  sPrecision
85630>>>>>>>End_Struct
85630>>>>>>>
85630>>>>>>>// Used to store/retreive SQL keywords in a struct array.
85630>>>>>>>// Various SQL back-ends can have slightly different
85630>>>>>>>// keywords.
85630>>>>>>>Struct tSQLKeyWords
85630>>>>>>>    Integer iSQLWord
85630>>>>>>>    Integer iSQLDbType
85630>>>>>>>    String  sSQLPhrase // Can be more than one word.
85630>>>>>>>End_Struct
85630>>>>>>>
85630>>>>>>>Struct tSQLRelation
85630>>>>>>>    Integer iFileNumber
85630>>>>>>>    Integer iFieldNumber
85630>>>>>>>    String  sFileName
85630>>>>>>>    String  sFieldName
85630>>>>>>>End_Struct
85630>>>>>>>
85630>>>>>>>Struct tSQLLoggedInUser
85630>>>>>>>    String sUser
85630>>>>>>>    String sProgram
85630>>>>>>>End_Struct
85630>>>>>>>
85630>>>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
85630>>>>>>>Enumeration_List
85630>>>>>>>    Define DUF_ERROR_REPORT    // Report Error on screen
85630>>>>>>>    Define DUF_ERROR_NO_REPORT // Show no Error..
85630>>>>>>>End_Enumeration_List
85630>>>>>>>
85630>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
85630>>>>>>>// They can have slightly different SQL keywords.
85630>>>>>>>// Note: If a new type is added to the list,
85630>>>>>>>//       the struct array xxx must be adjusted
85630>>>>>>>//       so that it is filled with all SQL
85630>>>>>>>//       keywords for that new type.
85630>>>>>>>Enum_List
85630>>>>>>>    Define EN_DbTypeMSSQL
85630>>>>>>>    Define EN_DbTypeMySQL
85630>>>>>>>    Define EN_DbTypeOracle
85630>>>>>>>    Define EN_DbTypeDB2
85630>>>>>>>    Define EN_DbTypePostgre
85630>>>>>>>    Define EN_DbTypeDataFlex // Embedded database.
85630>>>>>>>End_Enum_List
85630>>>>>>>
85630>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
85630>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
85630>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
85630>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
85630>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
85630>>>>>>>Define CS_DbTypeOracle      for "Oracle"
85630>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
85630>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
85630>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
85630>>>>>>>
85630>>>>>>>// We need to re-define the standard constants because several driver constants
85630>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
85630>>>>>>>// e.g. creating a column with embedded SQL (ESQL).
85630>>>>>>>Enum_List
85630>>>>>>>    Define DF_ASCII_DUF     for -1500 // All of these are DF_xxx constant values - 1500
85630>>>>>>>    Define DF_BCD_DUF       for -1499
85630>>>>>>>    Define DF_DATE_DUF      for -1498
85630>>>>>>>    Define DF_TEXT_DUF      for -1495
85630>>>>>>>    Define DF_BINARY_DUF    for -1494
85630>>>>>>>    Define DF_DATETIME_DUF  for -1493
85630>>>>>>>End_Enum_List
85630>>>>>>>
85630>>>>>>>    Define SQL_TEXT for (DF_TEXT + 1024)
85630>>>>>>>
85630>>>>>>>Define SQL_CHARBIT          for (DF_BINARY + 1024)
85630>>>>>>>Define SQL_LONGVARCHARBIT   for (DF_BINARY + 1025)
85630>>>>>>>Define SQL_VARCHARBIT       for (DF_BINARY + 1026)
85630>>>>>>>
85630>>>>>>>// These are not defined pre DF 18:
85630>>>>>>>
85630>>>>>>>Struct tSQLIntTableInfo
85630>>>>>>>    String sDriverName
85630>>>>>>>    String sServerName
85630>>>>>>>    String sDatabaseName
85630>>>>>>>    String sSchemaName
85630>>>>>>>    Boolean bRecnumTable
85630>>>>>>>    Integer iPrimaryIndex
85630>>>>>>>    Integer iGenerateRecordIdMethod  // RIM_NONE, RIM_IDENTITY_COLUMN,  RIM_DISPENSER_TABLE, RIM_EXTERNAL
85630>>>>>>>    String sTableCharacterFormat
85630>>>>>>>    Boolean bUseDummyZeroDate
85630>>>>>>>    Integer iFileDummyUpdateColumn // Init value to -1 if not exists (value can be in range 1 - number of columns)
85630>>>>>>>    Integer iFileBlockSize         // Init value to -1 if not exists
85630>>>>>>>    Integer iFileMaxRowsFetched    // Init value to -1 if not exists
85630>>>>>>>    Integer iFileGetRidAfterCreate // Init value to -1. But is boolean!
85630>>>>>>>    Integer iFileJitBinding        // Init value to -1. But is boolean!
85630>>>>>>>    String sRefindAfterSave        // Yes or No (how to handle?)
85630>>>>>>>    String sSystemFile             // Yes or No (how to handle?)
85630>>>>>>>    String sFileIndexTablespace
85630>>>>>>>    String sFileLongTablespace
85630>>>>>>>    String sTableTablespace
85630>>>>>>>End_Struct
85630>>>>>>>
85630>>>>>>>Struct tSQLIntColumnInfo
85630>>>>>>>    Integer iFieldNumber
85630>>>>>>>    Integer iFieldIndex
85630>>>>>>>    Integer iFieldRelatedFile
85630>>>>>>>    Integer iFieldRelatedField
85630>>>>>>>    Integer iIndexNumber
85630>>>>>>>    Integer iIndexNumberSegments
85630>>>>>>>    Integer iIndexSegmentField1
85630>>>>>>>    Integer iIndexSegmentField2
85630>>>>>>>    Integer iIndexSegmentFieldn
85630>>>>>>>    String  sIndexName
85630>>>>>>>End_Struct
85630>>>>>>>
85630>>>>>>>Struct tAPIColumn
85630>>>>>>>    Integer iFieldNumber
85630>>>>>>>    String  sFieldName
85630>>>>>>>    Integer iType
85630>>>>>>>    String  sType
85630>>>>>>>    Integer iLength
85630>>>>>>>    Integer iPrecision
85630>>>>>>>    Integer iOptions
85630>>>>>>>    Boolean bIsSQLType
85630>>>>>>>    Boolean bAllowNULL 
85630>>>>>>>    String  sDefaultValue
85630>>>>>>>    Boolean bShouldChange
85630>>>>>>>    Boolean bCancel
85630>>>>>>>    Boolean bError
85630>>>>>>>End_Struct
85630>>>>>>>
85630>>>>>>>Struct tAPIColumnCompare
85630>>>>>>>    Integer iFieldNumber
85630>>>>>>>    // FROM database:
85630>>>>>>>    Boolean bExistsFrom
85630>>>>>>>    String  sFieldNameFrom
85630>>>>>>>    Integer iTypeFrom
85630>>>>>>>    String  sTypeFrom
85630>>>>>>>    Integer iLengthFrom
85630>>>>>>>    Integer iPrecisionFrom
85630>>>>>>>    Integer iOptionsFrom
85630>>>>>>>    Boolean bIsSQLTypeFrom
85630>>>>>>>    Boolean bAllowNULLFrom
85630>>>>>>>    String  sDefaultValueFrom
85630>>>>>>>    Boolean bShouldChangeFrom
85630>>>>>>>    Boolean bCancelFrom
85630>>>>>>>    Boolean bErrorFrom 
85630>>>>>>>    // TO database:
85630>>>>>>>    Boolean bExistsTo
85630>>>>>>>    Integer iFieldNumberTo
85630>>>>>>>    String  sFieldNameTo
85630>>>>>>>    Integer iTypeTo
85630>>>>>>>    String  sTypeTo
85630>>>>>>>    Integer iLengthTo
85630>>>>>>>    Integer iPrecisionTo
85630>>>>>>>    Integer iOptionsTo
85630>>>>>>>    Boolean bIsSQLTypeTo
85630>>>>>>>    Boolean bAllowNULLTo
85630>>>>>>>    String  sDefaultValueTo
85630>>>>>>>    Boolean bShouldChangeTo
85630>>>>>>>    Boolean bCancelTo
85630>>>>>>>    Boolean bErrorTo
85630>>>>>>>End_Struct
85630>>>>>>>
85630>>>>>>>Struct tAPIRelation
85630>>>>>>>    Handle  hTableFrom
85630>>>>>>>    Integer iColumnFrom
85630>>>>>>>    Handle  hTableTo
85630>>>>>>>    Integer iColumnTo
85630>>>>>>>    String  sLogicalNameFrom
85630>>>>>>>    String  sLogicalNameTo
85630>>>>>>>    String  sFieldNameFrom
85630>>>>>>>    String  sFieldNameTo
85630>>>>>>>    Boolean bShouldChange
85630>>>>>>>    Boolean bCancel
85630>>>>>>>    Boolean bError
85630>>>>>>>End_Struct
85630>>>>>>>
85630>>>>>>>Struct tAPIRelationCompare
85630>>>>>>>    // Common:
85630>>>>>>>    Handle  hTableFrom
85630>>>>>>>    Integer iColumnFrom
85630>>>>>>>    Handle  hTableTo
85630>>>>>>>    Integer iColumnTo
85630>>>>>>>    // FROM database:
85630>>>>>>>    Boolean bExistsFrom
85630>>>>>>>    String  sLogicalNameFrom_From
85630>>>>>>>    String  sLogicalNameTo_From
85630>>>>>>>    String  sFieldNameFrom_From
85630>>>>>>>    String  sFieldNameTo_From
85630>>>>>>>    Boolean bShouldChange_From
85630>>>>>>>    Boolean bCancel_From
85630>>>>>>>    Boolean bError_From
85630>>>>>>>    // TO database:
85630>>>>>>>    Boolean bExistsTo
85630>>>>>>>    String  sLogicalNameFrom_To
85630>>>>>>>    String  sLogicalNameTo_To
85630>>>>>>>    String  sFieldNameFrom_To
85630>>>>>>>    String  sFieldNameTo_To
85630>>>>>>>    Boolean bShouldChange_To
85630>>>>>>>    Boolean bCancel_To
85630>>>>>>>    Boolean bError_To
85630>>>>>>>End_Struct
85630>>>>>>>
85630>>>>>>>Struct tAPIIndexSegment
85630>>>>>>>    Integer iFieldNumber
85630>>>>>>>    String  sFieldName
85630>>>>>>>    Boolean bUppercase
85630>>>>>>>    Boolean bAscending
85630>>>>>>>    Boolean bShouldChange
85630>>>>>>>    Boolean bCancel
85630>>>>>>>    Boolean bError
85630>>>>>>>End_Struct
85630>>>>>>>
85630>>>>>>>Struct tAPIIndex
85630>>>>>>>    Integer iIndexNumber
85630>>>>>>>    Integer iPrimaryIndex
85630>>>>>>>    String  sSQLIndexName
85630>>>>>>>    Integer iSQLIndexType
85630>>>>>>>    Boolean bIsSQLClustered
85630>>>>>>>    Boolean bIsSQLPrimaryKey
85630>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
85630>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
85630>>>>>>>    Boolean bShouldChange
85630>>>>>>>    Boolean bCancel
85630>>>>>>>    Boolean bError
85630>>>>>>>End_Struct
85630>>>>>>>
85630>>>>>>>Struct tAPIIndexCompare
85630>>>>>>>    // Common:
85630>>>>>>>    Integer iIndexNumber
85630>>>>>>>    // FROM database:
85630>>>>>>>    Boolean bExistsFrom
85630>>>>>>>    Integer iPrimaryIndexFrom
85630>>>>>>>    String  sSQLIndexNameFrom
85630>>>>>>>    Integer iSQLIndexTypeFrom
85630>>>>>>>    Boolean bIsSQLClusteredFrom
85630>>>>>>>    Boolean bIsSQLPrimaryKeyFrom
85630>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
85630>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
85630>>>>>>>    Boolean bShouldChangeFrom
85630>>>>>>>    Boolean bCancelFrom
85630>>>>>>>    Boolean bErrorFrom
85630>>>>>>>    // TO database:
85630>>>>>>>    Boolean bExistsTo
85630>>>>>>>    Integer iPrimaryIndexTo
85630>>>>>>>    String  sSQLIndexNameTo
85630>>>>>>>    Integer iSQLIndexTypeTo
85630>>>>>>>    Boolean bIsSQLClusteredTo
85630>>>>>>>    Boolean bIsSQLPrimaryKeyTo
85630>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
85630>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
85630>>>>>>>    Boolean bShouldChangeTo
85630>>>>>>>    Boolean bCancelTo
85630>>>>>>>    Boolean bErrorTo
85630>>>>>>>End_Struct
85630>>>>>>>
85630>>>>>>>Struct tAPITableNameInfo
85630>>>>>>>    Integer iTableNumber
85630>>>>>>>    String  sRootName
85630>>>>>>>    String  sLogicalName
85630>>>>>>>    String  sDisplayName
85630>>>>>>>    String  sDriverID
85630>>>>>>>    Boolean bIsAlias
85630>>>>>>>    Boolean bIsSQL  
85630>>>>>>>    Boolean bIsSystemFile
85630>>>>>>>    Boolean bShouldChange
85630>>>>>>>    Boolean bCancel
85630>>>>>>>    Boolean bError
85630>>>>>>>End_Struct
85630>>>>>>>
85630>>>>>>>Struct tAPITableNameInfoCompare
85630>>>>>>>    Integer iTableNumber
85630>>>>>>>    // FROM
85630>>>>>>>    Boolean bExistsFrom
85630>>>>>>>    String  sRootNameFrom
85630>>>>>>>    String  sLogicalNameFrom
85630>>>>>>>    String  sDisplayNameFrom
85630>>>>>>>    String  sDriverIDFrom
85630>>>>>>>    Boolean bIsAliasFrom
85630>>>>>>>    Boolean bIsSQLFrom
85630>>>>>>>    Boolean bIsSystemFileFrom
85630>>>>>>>    // TO database:
85630>>>>>>>    Boolean bExistsTo
85630>>>>>>>    String  sRootNameTo
85630>>>>>>>    String  sLogicalNameTo
85630>>>>>>>    String  sDisplayNameTo
85630>>>>>>>    String  sDriverIDTo
85630>>>>>>>    Boolean bIsAliasTo
85630>>>>>>>    Boolean bIsSQLTo
85630>>>>>>>    Boolean bIsSystemFileTo // *** Implement!
85630>>>>>>>    Boolean bShouldChange
85630>>>>>>>    Boolean bCancel
85630>>>>>>>    Boolean bError
85630>>>>>>>End_Struct
85630>>>>>>>
85630>>>>>>>Struct tAPITable
85630>>>>>>>    Handle hTable
85630>>>>>>>    Boolean bFromTable
85630>>>>>>>    Boolean bToTable
85630>>>>>>>    tAPITableNameInfo ApiTableInfo
85630>>>>>>>    tAPITableNameInfo ApiTableInfo
85630>>>>>>>    tAPIColumn[]      aApiColumns
85630>>>>>>>    tAPIColumn[]      aApiColumns
85630>>>>>>>    tAPIIndex[]       aApiIndexes
85630>>>>>>>    tAPIIndex[]       aApiIndexes
85630>>>>>>>    tAPIRelation[]    aApiRelations
85630>>>>>>>    tAPIRelation[]    aApiRelations
85630>>>>>>>    Boolean bShouldChange
85630>>>>>>>    Boolean bCancel
85630>>>>>>>    Boolean bError
85630>>>>>>>End_Struct
85630>>>>>>>
85630>>>>>>>Struct tAPITableCompare
85630>>>>>>>    Handle hTable
85630>>>>>>>    // FROM database:
85630>>>>>>>    Boolean bExistsFrom
85630>>>>>>>    // TO database:
85630>>>>>>>    Boolean bExistsTo
85630>>>>>>>    // Both:
85630>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
85630>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
85630>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
85630>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
85630>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
85630>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
85630>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
85630>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
85630>>>>>>>    Boolean bShouldChange   // Not implemented yet (!)
85630>>>>>>>    Boolean bCancel         // User cancel
85630>>>>>>>    Boolean bError          // Error occured while collecting data
85630>>>>>>>End_Struct
85630>>>>>>>
85630>>>>>>>
85630>>>>>>>Struct tAPITableBooleans  
85630>>>>>>>    Boolean bApiTableUpdateAuto
85630>>>>>>>    Boolean bCompareDate_DateTime
85630>>>>>>>    Boolean bCompareIndexAscending
85630>>>>>>>    Boolean bCompareIndexUppercase
85630>>>>>>>    Boolean bCompareFilelistUppercase
85630>>>>>>>End_Struct
85630>>>>>>>
85630>>>>>>>Define C_tAPIColumn_None for 0
85630>>>>>>>Define C_tAPIColumn_Identity for 1
85630>>>>>>>
85630>>>>>>>// SQL Key-Word Constants:
85630>>>>>>>// Used by the _SqlFindKeyWord function to return a proper keyword depending on the backend SQL,
85630>>>>>>>// i.e. one of the EN_DbTypeXXX members from the Enum_list above.
85630>>>>>>>// E.g. the CI_SQLAlterTable is only defined once, but the _SqlFindKeyWord function can return
85630>>>>>>>// different wording content depending on the EN_xxx value also passed to the function.
85630>>>>>>>Enum_List
85630>>>>>>>    Define CI_SQLAlterDatabase         //for "ALTER DATABASE"          
85630>>>>>>>    Define CI_SQLSingle_User           //for "SINGLE_USER"
85630>>>>>>>    Define CI_SQLMulti_User            //for "USER_USER"
85630>>>>>>>    Define CI_SQLRollback              //for "ROLLBACK"
85630>>>>>>>    Define CI_SQLIMMEDIATE             //for "IMMEDIATE"
85630>>>>>>>    Define CI_SQLAlterTable            //for "ALTER TABLE"
85630>>>>>>>    Define CI_SQLAlterColumn           //for "ALTER COLUMN"
85630>>>>>>>    Define CI_SQLRenameColumn          //for "RENAME COLUMN"
85630>>>>>>>    Define CI_SQLColumn                //for "COLUMN"
85630>>>>>>>    Define CI_SQLSelect                //for "SELECT"
85630>>>>>>>    Define CI_SQLWhere                 //for "WHERE"
85630>>>>>>>    Define CI_SQLInfoSchema            //for "INFORMATION_SCHEMA.COLUMNS"
85630>>>>>>>    Define CI_SQLTable_Name            //for "TABLE_NAME"
85630>>>>>>>    Define CI_SQLTable                 //for "TABLE"
85630>>>>>>>    Define CI_SQLSys                   //for "SYS"
85630>>>>>>>    Define CI_SQLSp_Help               //for "SP_HELP"
85630>>>>>>>    Define CI_SQLFrom                  //for "FROM"
85630>>>>>>>    Define CI_SQLAdd                   //for "ADD"
85630>>>>>>>    Define CI_SQLDropColumn            //for "DROP"
85630>>>>>>>    Define CI_SQLCreateDatabase        //for "CREATE DATABASE"
85630>>>>>>>    Define CI_SQLDatabaseCollation     //for "COLLATE"
85630>>>>>>>    Define CI_SQLCreateTable           //for "CREATE TABLE"
85630>>>>>>>    Define CI_SQLDropTable             //for "DROP TABLE"
85630>>>>>>>    Define CI_SQLCreateView            //for "CREATE VIEW"
85630>>>>>>>    Define CI_SQLRenameTable           //for "RENAME TABLE"
85630>>>>>>>//    Define CI_SQLSelectFromWhereName   //for "SELECT name from [master].[dbo].[sysdatabases] where name"
85630>>>>>>>    Define CI_SQLDropView              //for "DROP VIEW"
85630>>>>>>>    Define CI_SQLSetNoCountOn          //for "SET NOCOUNT ON"
85630>>>>>>>    Define CI_SQLTo                    //for "TO"
85630>>>>>>>    Define CI_SQLGO                    //for "GO"
85630>>>>>>>    Define CI_SQLUse                   //for "USE"
85630>>>>>>>    Define CI_SQLDBO                   //for "DBO"
85630>>>>>>>
85630>>>>>>>    Define CI_SQLName                  //for "NAME"
85630>>>>>>>    Define CI_SQLMaster                //for "MASTER"
85630>>>>>>>    Define CI_SQLDatabases             //for "DATABASES"
85630>>>>>>>    Define CI_SQLSysIndexes            //for "SYS.INDEXES"
85630>>>>>>>    Define CI_SQLObjectID              //for "OBJECT_ID"
85630>>>>>>>    Define CI_SQLID                    //for "ID"
85630>>>>>>>    Define CI_SQLAND                   //for "AND"
85630>>>>>>>    Define CI_SQLUpdate                //for "UPDATE"
85630>>>>>>>    Define CI_SQLSet                   //for "SET"
85630>>>>>>>    Define CI_SQLWith                  //for "WITH"
85630>>>>>>>    Define CI_SQLNotNull               //for "NOT NULL"
85630>>>>>>>End_Enum_List
85630>>>>>>>
85630>>>>>Use cDbUpdateFunctionLibrary_Mixin.pkg  // Properties used by the cDbUpdateFunctionLibrary class.
Including file: cDbUpdateFunctionLibrary_Mixin.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary_Mixin.pkg)
85630>>>>>>>// *** Mixin Class For the cDbUpdateFunctionLibrary Class ***
85630>>>>>>>//
85630>>>>>>>// We need to create a mixin class for the library.
85630>>>>>>>// Why? Because we import the library to the cDbUpdateVersion class; that imports
85630>>>>>>>// all messages (functions & procedures) but all Properties are "lost", aka not imported by
85630>>>>>>>// the Import_Class_Protocol command. So we need a way to create our properties somewhere else...
85630>>>>>>>// Note: This class should _not_ have a construct_object defined.
85630>>>>>>>//
85630>>>>>>>Use VdfBase.pkg
85630>>>>>>>Use WinUuid.pkg
Including file: WinUuid.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\WinUuid.pkg)
85630>>>>>>>>>External_Function WinAPI_UuidCreate "UuidCreate" Rpcrt4.dll Address Uuid Returns Integer
85631>>>>>>>>>External_Function WinAPI_UuidToString  "UuidToStringA" Rpcrt4.dll Address aUuid Address lpUUIDString Returns Integer
85632>>>>>>>>>External_Function WinAPI_UuidCreateSequential "UuidCreateSequential" Rpcrt4.dll Address aUuid Returns Integer
85633>>>>>>>>>External_Function WinAPI_RpcStringFree "RpcStringFreeA" Rpcrt4.dll Address pStr Returns Integer
85634>>>>>>>>>
85634>>>>>>>>>// RandomHexUUID:
85634>>>>>>>>>
85634>>>>>>>>>// Returns a 'random' Universally Unique Identifier string as a 32 digit hex number.
85634>>>>>>>>>Function RandomHexUUID Global Returns String
85636>>>>>>>>>    Address pUUID pUUIDStr
85636>>>>>>>>>    Integer iRetval iOffset iChar
85636>>>>>>>>>    String sUUID sKey
85636>>>>>>>>>    
85636>>>>>>>>>    Move (Alloc(16)) to pUUID
85637>>>>>>>>>    
85637>>>>>>>>>    Move (WinAPI_UuidCreate (pUUID)) to iRetval
85638>>>>>>>>>    
85638>>>>>>>>>    If (iRetval = 0) Begin
85640>>>>>>>>>        Move 0 to pUUIDStr
85641>>>>>>>>>        
85641>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
85642>>>>>>>>>        If (iRetval = 0) Begin
85644>>>>>>>>>            Move pUUIDStr to sUUID
85645>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
85646>>>>>>>>> 
85646>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
85647>>>>>>>>>        End
85647>>>>>>>>>>
85647>>>>>>>>>    End
85647>>>>>>>>>>
85647>>>>>>>>>    
85647>>>>>>>>>    Move (Free(pUUID)) to iRetval 
85648>>>>>>>>>    
85648>>>>>>>>>    Function_Return sUUID
85649>>>>>>>>>End_Function
85650>>>>>>>>>
85650>>>>>>>>>
85650>>>>>>>>>// SeqHexUUID:
85650>>>>>>>>>
85650>>>>>>>>>// Returns a sequential Universally Unique Identifier string as a 32 digit hex number.
85650>>>>>>>>>Function SeqHexUUID Global Returns String    
85652>>>>>>>>>    Address pUUID pUUIDStr
85652>>>>>>>>>    Integer iRetval iOffset iChar
85652>>>>>>>>>    String sUUID sKey
85652>>>>>>>>>    
85652>>>>>>>>>    Move (Alloc(16)) to pUUID
85653>>>>>>>>>    
85653>>>>>>>>>    Move (WinAPI_UuidCreateSequential (pUUID)) to iRetval
85654>>>>>>>>>    
85654>>>>>>>>>    If (iRetval = 0) Begin
85656>>>>>>>>>        Move 0 to pUUIDStr
85657>>>>>>>>>        
85657>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
85658>>>>>>>>>        If (iRetval = 0) Begin
85660>>>>>>>>>            Move pUUIDStr to sUUID
85661>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
85662>>>>>>>>> 
85662>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
85663>>>>>>>>>        End
85663>>>>>>>>>>
85663>>>>>>>>>    End
85663>>>>>>>>>>
85663>>>>>>>>>    
85663>>>>>>>>>    Move (Free(pUUID)) to iRetval 
85664>>>>>>>>>    
85664>>>>>>>>>    Function_Return sUUID
85665>>>>>>>>>End_Function
85666>>>>>>>Use cli.pkg
85666>>>>>>>Use sql.pkg
85666>>>>>>>Use MSSqldrv.pkg
85666>>>>>>>Use db2_drv.pkg
85666>>>>>>>Use odbc_drv.pkg
85666>>>>>>>Use DFBTRDRV.PKG
85666>>>>>>>Use cDbUpdateFunctionLibrary.inc
85666>>>>>>>Use cSQLConnectionIniFile.inc
Including file: cSQLConnectionIniFile.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.inc)
85666>>>>>>>>>//****************************************************************************
85666>>>>>>>>>// $Module type: Include file
85666>>>>>>>>>// $Module name: cSQLConnectionIniFile.inc
85666>>>>>>>>>//
85666>>>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
85666>>>>>>>>>// Copyright (c) 2012 RDC Tools International
85666>>>>>>>>>// E-mail      : support@rdctools.com
85666>>>>>>>>>// Web-site    : http://www.rdctools.com
85666>>>>>>>>>//
85666>>>>>>>>>// Created     : 2017-01-18 @ 13:04 (Military date format - Year-Month-Day)
85666>>>>>>>>>//
85666>>>>>>>>>// Note        : Header file with constant declarations for the cSQLConnectionIniFile class.
85666>>>>>>>>>//
85666>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
85666>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
85666>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
85666>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
85666>>>>>>>>>// in the help folder for more details.
85666>>>>>>>>>//
85666>>>>>>>>>Use Winkern.pkg
85666>>>>>>>>>Use cIniFile.pkg
85666>>>>>>>>>Use cCryptographer.pkg
Including file: cCryptographer.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCryptographer.pkg)
85666>>>>>>>>>>>Use VdfBase.pkg
85666>>>>>>>>>>>
85666>>>>>>>>>>>Use CryptographerConstants.pkg
Including file: CryptographerConstants.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\CryptographerConstants.pkg)
85666>>>>>>>>>>>>>//                                      
85666>>>>>>>>>>>>>// File    : CryptographerConstants.pkg
85666>>>>>>>>>>>>>//
85666>>>>>>>>>>>>>//   Author  : Ulbe Stellema
85666>>>>>>>>>>>>>//             Data Access Worldwide
85666>>>>>>>>>>>>>//
85666>>>>>>>>>>>>>//   Date    : October 4, 2009
85666>>>>>>>>>>>>>//
85666>>>>>>>>>>>>>
85666>>>>>>>>>>>>>
85666>>>>>>>>>>>>>
85666>>>>>>>>>>>>>// Algorithm classes
85666>>>>>>>>>>>>>Define ALG_CLASS_ANY                    for |CI$00000000 // (0)
85666>>>>>>>>>>>>>Define ALG_CLASS_SIGNATURE              for |CI$00002000 // (1 << 13)
85666>>>>>>>>>>>>>Define ALG_CLASS_MSG_ENCRYPT            for |CI$00004000 // (2 << 13)
85666>>>>>>>>>>>>>Define ALG_CLASS_DATA_ENCRYPT           for |CI$00006000 // (3 << 13)
85666>>>>>>>>>>>>>Define ALG_CLASS_HASH                   for |CI$00008000 // (4 << 13)
85666>>>>>>>>>>>>>Define ALG_CLASS_KEY_EXCHANGE           for |CI$0000A000 // (5 << 13)
85666>>>>>>>>>>>>>Define ALG_CLASS_ALL                    for |CI$0000E000 // (7 << 13)
85666>>>>>>>>>>>>>
85666>>>>>>>>>>>>>// Algorithm types
85666>>>>>>>>>>>>>Define ALG_TYPE_ANY                     for |CI$00000000 // (0)
85666>>>>>>>>>>>>>Define ALG_TYPE_DSS                     for |CI$00000200 // (1 << 9)
85666>>>>>>>>>>>>>Define ALG_TYPE_RSA                     for |CI$00000400 // (2 << 9)
85666>>>>>>>>>>>>>Define ALG_TYPE_BLOCK                   for |CI$00000600 // (3 << 9)
85666>>>>>>>>>>>>>Define ALG_TYPE_STREAM                  for |CI$00000800 // (4 << 9)
85666>>>>>>>>>>>>>Define ALG_TYPE_DH                      for |CI$00000A00 // (5 << 9)
85666>>>>>>>>>>>>>Define ALG_TYPE_SECURECHANNEL           for |CI$00000C00 // (6 << 9)
85666>>>>>>>>>>>>>
85666>>>>>>>>>>>>>// Generic sub-ids
85666>>>>>>>>>>>>>Define ALG_SID_ANY                      for |CI$00000000 // (0)
85666>>>>>>>>>>>>>
85666>>>>>>>>>>>>>// RSA sub-ids
85666>>>>>>>>>>>>>Define ALG_SID_RSA_ANY                  for 0
85666>>>>>>>>>>>>>Define ALG_SID_RSA_PKCS                 for 1
85666>>>>>>>>>>>>>Define ALG_SID_RSA_MSATWORK             for 2
85666>>>>>>>>>>>>>Define ALG_SID_RSA_ENTRUST              for 3
85666>>>>>>>>>>>>>Define ALG_SID_RSA_PGP                  for 4
85666>>>>>>>>>>>>>
85666>>>>>>>>>>>>>// DSS sub-ids
85666>>>>>>>>>>>>>Define ALG_SID_DSS_ANY                  for 0
85666>>>>>>>>>>>>>Define ALG_SID_DSS_PKCS                 for 1
85666>>>>>>>>>>>>>Define ALG_SID_DSS_DMS                  for 2
85666>>>>>>>>>>>>>
85666>>>>>>>>>>>>>// DES sub_ids
85666>>>>>>>>>>>>>Define ALG_SID_DES                      for 1
85666>>>>>>>>>>>>>Define ALG_SID_3DES                     for 3
85666>>>>>>>>>>>>>Define ALG_SID_DESX                     for 4
85666>>>>>>>>>>>>>Define ALG_SID_IDEA                     for 5
85666>>>>>>>>>>>>>Define ALG_SID_CAST                     for 6
85666>>>>>>>>>>>>>Define ALG_SID_SAFERSK64                for 7
85666>>>>>>>>>>>>>Define ALG_SID_SAFERSK128               for 8
85666>>>>>>>>>>>>>Define ALG_SID_3DES_112                 for 9
85666>>>>>>>>>>>>>Define ALG_SID_CYLINK_MEK               for 12
85666>>>>>>>>>>>>>Define ALG_SID_RC5                      for 13
85666>>>>>>>>>>>>>Define ALG_SID_AES_128                  for 14
85666>>>>>>>>>>>>>Define ALG_SID_AES_192                  for 15
85666>>>>>>>>>>>>>Define ALG_SID_AES_256                  for 16
85666>>>>>>>>>>>>>Define ALG_SID_AES                      for 17
85666>>>>>>>>>>>>>
85666>>>>>>>>>>>>>// Fortezza sub-ids
85666>>>>>>>>>>>>>Define ALG_SID_SKIPJACK                 for 10
85666>>>>>>>>>>>>>Define ALG_SID_TEK                      for 11
85666>>>>>>>>>>>>>
85666>>>>>>>>>>>>>// RC2 sub-ids
85666>>>>>>>>>>>>>Define ALG_SID_RC2                      for 2
85666>>>>>>>>>>>>>
85666>>>>>>>>>>>>>// Stream cipher sub-ids
85666>>>>>>>>>>>>>Define ALG_SID_RC4                      for 1
85666>>>>>>>>>>>>>Define ALG_SID_SEAL                     for 2
85666>>>>>>>>>>>>>
85666>>>>>>>>>>>>>// Diffie-Hellman sub-ids
85666>>>>>>>>>>>>>Define ALG_SID_DH_SANDF                 for 1
85666>>>>>>>>>>>>>Define ALG_SID_DH_EPHEM                 for 2
85666>>>>>>>>>>>>>Define ALG_SID_AGREED_KEY_ANY           for 3
85666>>>>>>>>>>>>>Define ALG_SID_KEA                      for 4
85666>>>>>>>>>>>>>
85666>>>>>>>>>>>>>// Hash sub ids
85666>>>>>>>>>>>>>Define ALG_SID_MD2                      for 1
85666>>>>>>>>>>>>>Define ALG_SID_MD4                      for 2
85666>>>>>>>>>>>>>Define ALG_SID_MD5                      for 3
85666>>>>>>>>>>>>>Define ALG_SID_SHA                      for 4
85666>>>>>>>>>>>>>Define ALG_SID_SHA1                     for 4
85666>>>>>>>>>>>>>Define ALG_SID_MAC                      for 5
85666>>>>>>>>>>>>>Define ALG_SID_RIPEMD                   for 6
85666>>>>>>>>>>>>>Define ALG_SID_RIPEMD160                for 7
85666>>>>>>>>>>>>>Define ALG_SID_SSL3SHAMD5               for 8
85666>>>>>>>>>>>>>Define ALG_SID_HMAC                     for 9
85666>>>>>>>>>>>>>Define ALG_SID_TLS1PRF                  for 10
85666>>>>>>>>>>>>>Define ALG_SID_HASH_REPLACE_OWF         for 11
85666>>>>>>>>>>>>>Define ALG_SID_SHA_256                  for 12
85666>>>>>>>>>>>>>Define ALG_SID_SHA_384                  for 13
85666>>>>>>>>>>>>>Define ALG_SID_SHA_512                  for 14
85666>>>>>>>>>>>>>
85666>>>>>>>>>>>>>// secure channel sub ids
85666>>>>>>>>>>>>>Define ALG_SID_SSL3_MASTER              for 1
85666>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MASTER_HASH     for 2
85666>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MAC_KEY         for 3
85666>>>>>>>>>>>>>Define ALG_SID_PCT1_MASTER              for 4
85666>>>>>>>>>>>>>Define ALG_SID_SSL2_MASTER              for 5
85666>>>>>>>>>>>>>Define ALG_SID_TLS1_MASTER              for 6
85666>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_ENC_KEY         for 7
85666>>>>>>>>>>>>>
85666>>>>>>>>>>>>>// algorithm identifier definitions
85666>>>>>>>>>>>>>Define CALG_MD2                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD2)
85666>>>>>>>>>>>>>Define CALG_MD4                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD4)
85666>>>>>>>>>>>>>Define CALG_MD5                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD5)
85666>>>>>>>>>>>>>Define CALG_SHA                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA)
85666>>>>>>>>>>>>>Define CALG_SHA1                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA1)
85666>>>>>>>>>>>>>Define CALG_MAC                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MAC)
85666>>>>>>>>>>>>>Define CALG_RSA_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
85666>>>>>>>>>>>>>Define CALG_DSS_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_DSS ior ALG_SID_DSS_ANY)
85666>>>>>>>>>>>>>Define CALG_NO_SIGN                     for (ALG_CLASS_SIGNATURE ior ALG_TYPE_ANY ior ALG_SID_ANY)
85666>>>>>>>>>>>>>Define CALG_RSA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
85666>>>>>>>>>>>>>Define CALG_DES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DES)
85666>>>>>>>>>>>>>Define CALG_3DES_112                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES_112)
85666>>>>>>>>>>>>>Define CALG_3DES                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES)
85666>>>>>>>>>>>>>Define CALG_DESX                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DESX)
85666>>>>>>>>>>>>>Define CALG_RC2                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC2)
85666>>>>>>>>>>>>>Define CALG_RC4                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_RC4)
85666>>>>>>>>>>>>>Define CALG_SEAL                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_SEAL)
85666>>>>>>>>>>>>>Define CALG_DH_SF                       for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_SANDF)
85666>>>>>>>>>>>>>Define CALG_DH_EPHEM                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_EPHEM)
85666>>>>>>>>>>>>>Define CALG_AGREEDKEY_ANY               for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_AGREED_KEY_ANY)
85666>>>>>>>>>>>>>Define CALG_KEA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_KEA)
85666>>>>>>>>>>>>>Define CALG_HUGHES_MD5                  for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_ANY ior ALG_SID_MD5)
85666>>>>>>>>>>>>>Define CALG_SKIPJACK                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_SKIPJACK)
85666>>>>>>>>>>>>>Define CALG_TEK                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_TEK)
85666>>>>>>>>>>>>>Define CALG_CYLINK_MEK                  for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_CYLINK_MEK)
85666>>>>>>>>>>>>>Define CALG_SSL3_SHAMD5                 for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SSL3SHAMD5)
85666>>>>>>>>>>>>>Define CALG_SSL3_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL3_MASTER)
85666>>>>>>>>>>>>>Define CALG_SCHANNEL_MASTER_HASH        for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MASTER_HASH)
85666>>>>>>>>>>>>>Define CALG_SCHANNEL_MAC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MAC_KEY)
85666>>>>>>>>>>>>>Define CALG_SCHANNEL_ENC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_ENC_KEY)
85666>>>>>>>>>>>>>Define CALG_PCT1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_PCT1_MASTER)
85666>>>>>>>>>>>>>Define CALG_SSL2_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL2_MASTER)
85666>>>>>>>>>>>>>Define CALG_TLS1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_TLS1_MASTER)
85666>>>>>>>>>>>>>Define CALG_RC5                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC5)
85666>>>>>>>>>>>>>Define CALG_HMAC                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HMAC)
85666>>>>>>>>>>>>>Define CALG_TLS1PRF                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_TLS1PRF)
85666>>>>>>>>>>>>>Define CALG_HASH_REPLACE_OWF            for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HASH_REPLACE_OWF)
85666>>>>>>>>>>>>>Define CALG_AES_128                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_128)
85666>>>>>>>>>>>>>Define CALG_AES_192                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_192)
85666>>>>>>>>>>>>>Define CALG_AES_256                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_256)
85666>>>>>>>>>>>>>Define CALG_AES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES)
85666>>>>>>>>>>>>>Define CALG_SHA_256                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_256)
85666>>>>>>>>>>>>>Define CALG_SHA_384                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_384)
85666>>>>>>>>>>>>>Define CALG_SHA_512                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_512)
85666>>>>>>>>>>>>>
85666>>>>>>>>>>>>>// Providers
85666>>>>>>>>>>>>>Define MS_DEF_PROV                      for "Microsoft Base Cryptographic Provider v1.0"
85666>>>>>>>>>>>>>Define MS_ENHANCED_PROV                 for "Microsoft Enhanced Cryptographic Provider v1.0"
85666>>>>>>>>>>>>>Define MS_STRONG_PROV                   for "Microsoft Strong Cryptographic Provider"
85666>>>>>>>>>>>>>Define MS_DEF_RSA_SIG_PROV              for "Microsoft RSA Signature Cryptographic Provider"
85666>>>>>>>>>>>>>Define MS_DEF_RSA_SCHANNEL_PROV         for "Microsoft RSA SChannel Cryptographic Provider"
85666>>>>>>>>>>>>>Define MS_DEF_DSS_PROV                  for "Microsoft Base DSS Cryptographic Provider"
85666>>>>>>>>>>>>>Define MS_DEF_DSS_DH_PROV               for "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
85666>>>>>>>>>>>>>Define MS_ENH_DSS_DH_PROV               for "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
85666>>>>>>>>>>>>>Define MS_DEF_DH_SCHANNEL_PROV          for "Microsoft DH SChannel Cryptographic Provider"
85666>>>>>>>>>>>>>Define MS_SCARD_PROV                    for "Microsoft Base Smart Card Crypto Provider"
85666>>>>>>>>>>>>>Define MS_ENH_RSA_AES_PROV              for "Microsoft Enhanced RSA and AES Cryptographic Provider"
85666>>>>>>>>>>>>>
85666>>>>>>>>>>>>>// dwFlags definitions for CryptAcquireContext
85666>>>>>>>>>>>>>Define CRYPT_VERIFYCONTEXT              for |CI$F0000000
85666>>>>>>>>>>>>>Define CRYPT_NEWKEYSET                  for |CI$00000008
85666>>>>>>>>>>>>>Define CRYPT_DELETEKEYSET               for |CI$00000010
85666>>>>>>>>>>>>>Define CRYPT_MACHINE_KEYSET             for |CI$00000020
85666>>>>>>>>>>>>>Define CRYPT_SILENT                     for |CI$00000040
85666>>>>>>>>>>>>>
85666>>>>>>>>>>>>>// dwFlag definitions for CryptGenKey
85666>>>>>>>>>>>>>Define CRYPT_EXPORTABLE                 for |CI$00000001
85666>>>>>>>>>>>>>Define CRYPT_USER_PROTECTED             for |CI$00000002
85666>>>>>>>>>>>>>Define CRYPT_CREATE_SALT                for |CI$00000004
85666>>>>>>>>>>>>>Define CRYPT_UPDATE_KEY                 for |CI$00000008
85666>>>>>>>>>>>>>Define CRYPT_NO_SALT                    for |CI$00000010
85666>>>>>>>>>>>>>Define CRYPT_PREGEN                     for |CI$00000040
85666>>>>>>>>>>>>>Define CRYPT_RECIPIENT                  for |CI$00000010
85666>>>>>>>>>>>>>Define CRYPT_INITIATOR                  for |CI$00000040
85666>>>>>>>>>>>>>Define CRYPT_ONLINE                     for |CI$00000080
85666>>>>>>>>>>>>>Define CRYPT_SF                         for |CI$00000100
85666>>>>>>>>>>>>>Define CRYPT_CREATE_IV                  for |CI$00000200
85666>>>>>>>>>>>>>Define CRYPT_KEK                        for |CI$00000400
85666>>>>>>>>>>>>>Define CRYPT_DATA_KEY                   for |CI$00000800
85666>>>>>>>>>>>>>Define CRYPT_VOLATILE                   for |CI$00001000
85666>>>>>>>>>>>>>Define CRYPT_SGCKEY                     for |CI$00002000
85666>>>>>>>>>>>>>Define CRYPT_ARCHIVABLE                 for |CI$00004000
85666>>>>>>>>>>>>>
85666>>>>>>>>>>>>>// Provider types
85666>>>>>>>>>>>>>Define PROV_RSA_FULL                    for 1
85666>>>>>>>>>>>>>Define PROV_RSA_SIG                     for 2
85666>>>>>>>>>>>>>Define PROV_DSS                         for 3
85666>>>>>>>>>>>>>Define PROV_FORTEZZA                    for 4
85666>>>>>>>>>>>>>Define PROV_MS_EXCHANGE                 for 5
85666>>>>>>>>>>>>>Define PROV_SSL                         for 6
85666>>>>>>>>>>>>>Define PROV_RSA_SCHANNEL                for 12
85666>>>>>>>>>>>>>Define PROV_DSS_DH                      for 13
85666>>>>>>>>>>>>>Define PROV_EC_ECDSA_SIG                for 14
85666>>>>>>>>>>>>>Define PROV_EC_ECNRA_SIG                for 15
85666>>>>>>>>>>>>>Define PROV_EC_ECDSA_FULL               for 16
85666>>>>>>>>>>>>>Define PROV_EC_ECNRA_FULL               for 17
85666>>>>>>>>>>>>>Define PROV_DH_SCHANNEL                 for 18
85666>>>>>>>>>>>>>Define PROV_SPYRUS_LYNKS                for 20
85666>>>>>>>>>>>>>Define PROV_RNG                         for 21
85666>>>>>>>>>>>>>Define PROV_INTEL_SEC                   for 22
85666>>>>>>>>>>>>>Define PROV_REPLACE_OWF                 for 23
85666>>>>>>>>>>>>>Define PROV_RSA_AES                     for 24
85666>>>>>>>>>>>>>
85666>>>>>>>>>>>>>// KP_MODE
85666>>>>>>>>>>>>>// KP_MODE
85666>>>>>>>>>>>>>Define CRYPT_MODE_CBC                   for 1       // Cipher block chaining
85666>>>>>>>>>>>>>Define CRYPT_MODE_ECB                   for 2       // Electronic code book
85666>>>>>>>>>>>>>Define CRYPT_MODE_OFB                   for 3       // Output feedback mode
85666>>>>>>>>>>>>>Define CRYPT_MODE_CFB                   for 4       // Cipher feedback mode
85666>>>>>>>>>>>>>Define CRYPT_MODE_CTS                   for 5       // Ciphertext stealing mode
85666>>>>>>>>>>>>>Define CRYPT_MODE_CBCI                  for 6       // ANSI CBC Interleaved
85666>>>>>>>>>>>>>Define CRYPT_MODE_CFBP                  for 7       // ANSI CFB Pipelined
85666>>>>>>>>>>>>>Define CRYPT_MODE_OFBP                  for 8       // ANSI OFB Pipelined
85666>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFM                for 9       // ANSI CBC + OF Masking
85666>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFMI               for 10      // ANSI CBC + OFM Interleaved
85666>>>>>>>>>>>>>
85666>>>>>>>>>>>>>// dwParam definitions for CryptGetKeyParam
85666>>>>>>>>>>>>>Define KP_IV                            for 1       // Initialization vector
85666>>>>>>>>>>>>>Define KP_SALT                          for 2       // Salt value
85666>>>>>>>>>>>>>Define KP_PADDING                       for 3       // Padding values
85666>>>>>>>>>>>>>Define KP_MODE                          for 4       // Mode of the cipher
85666>>>>>>>>>>>>>Define KP_MODE_BITS                     for 5       // Number of bits to feedback
85666>>>>>>>>>>>>>Define KP_PERMISSIONS                   for 6       // Key permissions DWORD
85666>>>>>>>>>>>>>Define KP_ALGID                         for 7       // Key algorithm
85666>>>>>>>>>>>>>Define KP_BLOCKLEN                      for 8       // Block size of the cipher
85666>>>>>>>>>>>>>Define KP_KEYLEN                        for 9       // Length of key in bits
85666>>>>>>>>>>>>>Define KP_SALT_EX                       for 10      // Length of salt in bytes
85666>>>>>>>>>>>>>Define KP_P                             for 11      // DSS/Diffie-Hellman P value
85666>>>>>>>>>>>>>Define KP_G                             for 12      // DSS/Diffie-Hellman G value
85666>>>>>>>>>>>>>Define KP_Q                             for 13      // DSS Q value
85666>>>>>>>>>>>>>Define KP_X                             for 14      // Diffie-Hellman X value
85666>>>>>>>>>>>>>Define KP_Y                             for 15      // Y value
85666>>>>>>>>>>>>>Define KP_RA                            for 16      // Fortezza RA value
85666>>>>>>>>>>>>>Define KP_RB                            for 17      // Fortezza RB value
85666>>>>>>>>>>>>>Define KP_INFO                          for 18      // for putting information into an RSA envelope
85666>>>>>>>>>>>>>Define KP_EFFECTIVE_KEYLEN              for 19      // setting and getting RC2 effective key length
85666>>>>>>>>>>>>>Define KP_SCHANNEL_ALG                  for 20      // for setting the Secure Channel algorithms
85666>>>>>>>>>>>>>Define KP_CLIENT_RANDOM                 for 21      // for setting the Secure Channel client random data
85666>>>>>>>>>>>>>Define KP_SERVER_RANDOM                 for 22      // for setting the Secure Channel server random data
85666>>>>>>>>>>>>>Define KP_RP                            for 23
85666>>>>>>>>>>>>>Define KP_PRECOMP_MD5                   for 24
85666>>>>>>>>>>>>>Define KP_PRECOMP_SHA                   for 25
85666>>>>>>>>>>>>>Define KP_CERTIFICATE                   for 26      // for setting Secure Channel certificate data (PCT1)
85666>>>>>>>>>>>>>Define KP_CLEAR_KEY                     for 27      // for setting Secure Channel clear key data (PCT1)
85666>>>>>>>>>>>>>Define KP_PUB_EX_LEN                    for 28
85666>>>>>>>>>>>>>Define KP_PUB_EX_VAL                    for 29
85666>>>>>>>>>>>>>Define KP_KEYVAL                        for 30
85666>>>>>>>>>>>>>Define KP_ADMIN_PIN                     for 31
85666>>>>>>>>>>>>>Define KP_KEYEXCHANGE_PIN               for 32
85666>>>>>>>>>>>>>Define KP_SIGNATURE_PIN                 for 33
85666>>>>>>>>>>>>>Define KP_PREHASH                       for 34
85666>>>>>>>>>>>>>Define KP_ROUNDS                        for 35
85666>>>>>>>>>>>>>Define KP_OAEP_PARAMS                   for 36      // for setting OAEP params on RSA keys
85666>>>>>>>>>>>>>Define KP_CMS_KEY_INFO                  for 37
85666>>>>>>>>>>>>>Define KP_CMS_DH_KEY_INFO               for 38
85666>>>>>>>>>>>>>Define KP_PUB_PARAMS                    for 39      // for setting public parameters
85666>>>>>>>>>>>>>Define KP_VERIFY_PARAMS                 for 40      // for verifying DSA and DH parameters
85666>>>>>>>>>>>>>Define KP_HIGHEST_VERSION               for 41      // for TLS protocol version setting
85666>>>>>>>>>>>>>Define KP_GET_USE_COUNT                 for 42      // for use with PP_CRYPT_COUNT_KEY_USE contexts
85666>>>>>>>>>>>>>
85666>>>>>>>>>>>>>// dwParam definitions for CryptGetHashParam
85666>>>>>>>>>>>>>Define HP_ALGID                         for |CI$0001  // Hash algorithm
85666>>>>>>>>>>>>>Define HP_HASHVAL                       for |CI$0002  // Hash value
85666>>>>>>>>>>>>>Define HP_HASHSIZE                      for |CI$0004  // Hash value size
85666>>>>>>>>>>>>>Define HP_HMAC_INFO                     for |CI$0005  // information for creating an HMA
85666>>>>>>>>>>>>>
85666>>>>>>>>>>>>>// key BLOB types
85666>>>>>>>>>>>>>Define KEYSTATEBLOB                     for |CI$0C
85666>>>>>>>>>>>>>Define OPAQUEKEYBLOB                    for |CI$09
85666>>>>>>>>>>>>>Define PLAINTEXTKEYBLOB                 for |CI$08
85666>>>>>>>>>>>>>Define PRIVATEKEYBLOB                   for |CI$07
85666>>>>>>>>>>>>>Define PUBLICKEYBLOB                    for |CI$06
85666>>>>>>>>>>>>>Define PUBLICKEYBLOBEX                  for |CI$0A
85666>>>>>>>>>>>>>Define SIMPLEBLOB                       for |CI$01
85666>>>>>>>>>>>>>Define SYMMETRICWRAPKEYBLOB             for |CI$0B
85666>>>>>>>>>>>>>
85666>>>>>>>>>>>>>Define CUR_BLOB_VERSION                 for 2
85666>>>>>>>>>>>>>
85666>>>>>>>>>>>>>//  Structure cryptimportkey
85666>>>>>>>>>>>>>Struct PUBLICKEYSTRUC
85666>>>>>>>>>>>>>    UChar    bType
85666>>>>>>>>>>>>>    UChar    bVersion
85666>>>>>>>>>>>>>    UShort   reserved
85666>>>>>>>>>>>>>    UInteger aiKeyAlg
85666>>>>>>>>>>>>>End_Struct
85666>>>>>>>>>>>>>
85666>>>>>>>>>>>>>Struct tPLAINTEXTKEYBLOB
85666>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
85666>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
85666>>>>>>>>>>>>>    UInteger       dwKeySize
85666>>>>>>>>>>>>>//    UChar[]        rgbKeyData
85666>>>>>>>>>>>>>End_Struct
85666>>>>>>>>>>>>>
85666>>>>>>>>>>>>>
85666>>>>>>>>>>>>>
85666>>>>>>>>>>>>>//  Structure for specifying the inner and outer strings when calculating HMAC hash (use with CryptSetHashParam)
85666>>>>>>>>>>>>>Struct HMAC_INFO
85666>>>>>>>>>>>>>    UInteger HashAlgid
85666>>>>>>>>>>>>>    Pointer pbInnerString
85666>>>>>>>>>>>>>    DWord cbInnerString
85666>>>>>>>>>>>>>    Pointer pbOuterString
85666>>>>>>>>>>>>>    DWord cbOuterString
85666>>>>>>>>>>>>>End_Struct
85666>>>>>>>>>>>>>
85666>>>>>>>>>>>>>
85666>>>>>>>>>>>>>External_Function CryptAcquireContext "CryptAcquireContextA" advapi32.dll ;    Pointer phProv ;    Pointer szContainer ;    Pointer szProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
85667>>>>>>>>>>>>>
85667>>>>>>>>>>>>>External_Function CryptReleaseContext "CryptReleaseContext" advapi32.dll ;    Handle hProv ;    Integer dwFlags ;    Returns Boolean
85668>>>>>>>>>>>>>
85668>>>>>>>>>>>>>External_Function CryptCreateHash "CryptCreateHash" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hKey ;    Integer dwFlags ;    Pointer phHash ;    Returns Boolean
85669>>>>>>>>>>>>>
85669>>>>>>>>>>>>>External_Function CryptDestroyHash "CryptDestroyHash" advapi32.dll ;    Handle hHash ;    Returns Boolean
85670>>>>>>>>>>>>>
85670>>>>>>>>>>>>>External_Function CryptHashData "CryptHashData" advapi32.dll ;    Handle hHash ;    Pointer pbData ;    Integer dwDataLen ;    Integer dwFlags ;    Returns Boolean
85671>>>>>>>>>>>>>
85671>>>>>>>>>>>>>External_Function CryptDeriveKey "CryptDeriveKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hBaseData ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
85672>>>>>>>>>>>>>
85672>>>>>>>>>>>>>External_Function CryptGetHashParam "CryptGetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    DWord dwFlags ;    Returns Integer
85673>>>>>>>>>>>>>
85673>>>>>>>>>>>>>External_Function CryptDestroyKey "CryptDestroyKey" advapi32.dll ;    Handle hKey ;    Returns Boolean
85674>>>>>>>>>>>>>
85674>>>>>>>>>>>>>External_Function CryptImportKey "CryptImportKey" advapi32.dll ;    Handle hProv ;    Pointer pbData ;    Integer dwDataLen ;    Handle hPubKey ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
85675>>>>>>>>>>>>>
85675>>>>>>>>>>>>>External_Function CryptGetKeyParam "CryptGetKeyParam" advapi32.dll ;    Handle hKey ;    Integer dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwFlags ;    Returns Boolean
85676>>>>>>>>>>>>>    
85676>>>>>>>>>>>>>External_Function CryptSetKeyParam "CryptSetKeyParam" advapi32.dll ;    Handle   hKey ;    UInteger dwParam ;    Pointer  pbdata ;    UInteger dwFlags ;    Returns  Boolean
85677>>>>>>>>>>>>>
85677>>>>>>>>>>>>>External_Function CryptEncrypt "CryptEncrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwBufLen ;    Returns Boolean
85678>>>>>>>>>>>>>
85678>>>>>>>>>>>>>External_Function CryptDecrypt "CryptDecrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
85679>>>>>>>>>>>>>
85679>>>>>>>>>>>>>External_Function CryptGenRandom "CryptGenRandom" advapi32.dll ;    Handle hProv ;    DWord dwLen ;    Pointer pbBuffer ;    Returns Boolean
85680>>>>>>>>>>>>>    
85680>>>>>>>>>>>>>External_Function CryptSetHashParam "CryptSetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Integer dwFlags ;    Returns Boolean
85681>>>>>>>>>>>>>    
85681>>>>>>>>>>>
85681>>>>>>>>>>>Class cCryptographer is a cObject
85682>>>>>>>>>>>    
85682>>>>>>>>>>>    // Procedure : Construct_Object
85682>>>>>>>>>>>    // Purpose   : Object constructor
85682>>>>>>>>>>>    Procedure Construct_Object
85684>>>>>>>>>>>        Forward Send Construct_Object
85686>>>>>>>>>>>
85686>>>>>>>>>>>        Property String     psProvider  MS_ENHANCED_PROV
85687>>>>>>>>>>>        Property Integer    piProvider  PROV_RSA_FULL
85688>>>>>>>>>>>        Property Integer    piCipher    CALG_RC4
85689>>>>>>>>>>>        Property Integer    piHash      CALG_MD5
85690>>>>>>>>>>>        
85690>>>>>>>>>>>        // Private properties
85690>>>>>>>>>>>        Property Handle     Private_phProv
85691>>>>>>>>>>>    End_Procedure
85692>>>>>>>>>>>    
85692>>>>>>>>>>>    
85692>>>>>>>>>>>    // Function : AcquireContext
85692>>>>>>>>>>>    // Purpose  : Acquire key container handle
85692>>>>>>>>>>>    Function AcquireContext Returns Handle
85694>>>>>>>>>>>        Integer iProvider
85694>>>>>>>>>>>        String sProvider
85694>>>>>>>>>>>        Handle hProv
85694>>>>>>>>>>>        Boolean bOk
85694>>>>>>>>>>>        Address addrProv
85694>>>>>>>>>>>        
85694>>>>>>>>>>>        Move 0 to hProv
85695>>>>>>>>>>>        Get piProvider to iProvider
85696>>>>>>>>>>>        Get psProvider to sProvider
85697>>>>>>>>>>>        
85697>>>>>>>>>>>        //  Determine address to be passed as provider
85697>>>>>>>>>>>        If (Trim(sProvider) <> "") Begin
85699>>>>>>>>>>>            Move (AddressOf(sProvider)) to addrProv
85700>>>>>>>>>>>        End
85700>>>>>>>>>>>>
85700>>>>>>>>>>>        Else Begin
85701>>>>>>>>>>>            Move 0 to addrProv
85702>>>>>>>>>>>        End
85702>>>>>>>>>>>>
85702>>>>>>>>>>>        
85702>>>>>>>>>>>        //  Acquire Crypto Context
85702>>>>>>>>>>>        Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_VERIFYCONTEXT)) to bOk
85703>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
85705>>>>>>>>>>>            Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_NEWKEYSET ior CRYPT_VERIFYCONTEXT)) to bOk
85706>>>>>>>>>>>        End
85706>>>>>>>>>>>>
85706>>>>>>>>>>>        
85706>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
85708>>>>>>>>>>>            // Fallback to original
85708>>>>>>>>>>>            Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,0)) to bOk
85709>>>>>>>>>>>            
85709>>>>>>>>>>>            If (not(bOk) or hProv = 0) Begin
85711>>>>>>>>>>>                Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_NEWKEYSET)) to bOk
85712>>>>>>>>>>>            End
85712>>>>>>>>>>>>
85712>>>>>>>>>>>        End
85712>>>>>>>>>>>>
85712>>>>>>>>>>>        Set Private_phProv to hProv
85713>>>>>>>>>>>        
85713>>>>>>>>>>>        Function_Return hProv
85714>>>>>>>>>>>    End_Function
85715>>>>>>>>>>>    
85715>>>>>>>>>>>    // Function : ReleaseContext
85715>>>>>>>>>>>    // Purpose  : Releases key container handle
85715>>>>>>>>>>>    Function ReleaseContext Handle hProv Returns Boolean
85717>>>>>>>>>>>        Function_Return (CryptReleaseContext(hProv,0))
85718>>>>>>>>>>>    End_Function
85719>>>>>>>>>>>    
85719>>>>>>>>>>>    // Function : CreateHash
85719>>>>>>>>>>>    // Purpose  : Creates hash object
85719>>>>>>>>>>>    Function CreateHash Handle hProv Returns Handle
85721>>>>>>>>>>>        Integer iAlgorithm
85721>>>>>>>>>>>        Handle hHash
85721>>>>>>>>>>>        Boolean bOk
85721>>>>>>>>>>>        
85721>>>>>>>>>>>        Move 0 to hHash
85722>>>>>>>>>>>        Get piHash to iAlgorithm
85723>>>>>>>>>>>        Move (CryptCreateHash(hProv,iAlgorithm,0,0,AddressOf(hHash))) to bOk
85724>>>>>>>>>>>        
85724>>>>>>>>>>>        Function_Return hHash
85725>>>>>>>>>>>    End_Function
85726>>>>>>>>>>>    
85726>>>>>>>>>>>    // Function : DestroyHash
85726>>>>>>>>>>>    // Purpose  : Destroys the hash object
85726>>>>>>>>>>>    Function DestroyHash Handle hHash Returns Boolean
85728>>>>>>>>>>>        Function_Return (CryptDestroyHash(hHash))
85729>>>>>>>>>>>    End_Function
85730>>>>>>>>>>>    
85730>>>>>>>>>>>    // Function : HashData
85730>>>>>>>>>>>    // Purpose  : Adds data to hash object
85730>>>>>>>>>>>    Function HashData Handle hHash String sData Returns Boolean
85732>>>>>>>>>>>        Function_Return (CryptHashData(hHash,AddressOf(sData),Length(sData),0))
85733>>>>>>>>>>>    End_Function
85734>>>>>>>>>>>    
85734>>>>>>>>>>>    // Function : DeriveKey
85734>>>>>>>>>>>    // Purpose  : Generates session key
85734>>>>>>>>>>>    Function DeriveKey Handle hProv Handle hHash Returns Handle
85736>>>>>>>>>>>        Integer iAlgorithm
85736>>>>>>>>>>>        Handle hKey
85736>>>>>>>>>>>        Boolean bOk
85736>>>>>>>>>>>        
85736>>>>>>>>>>>        Move 0 to hKey
85737>>>>>>>>>>>        Get piCipher to iAlgorithm
85738>>>>>>>>>>>        Move (CryptDeriveKey(hProv,iAlgorithm,hHash,CRYPT_EXPORTABLE,AddressOf(hKey))) to bOk
85739>>>>>>>>>>>        
85739>>>>>>>>>>>        Function_Return hKey
85740>>>>>>>>>>>    End_Function
85741>>>>>>>>>>>    
85741>>>>>>>>>>>    // Function : ImportPlainTextKey
85741>>>>>>>>>>>    // Purpose  : Imports a plain text key
85741>>>>>>>>>>>    Function ImportPlainTextKey Handle hProv UChar[] ucaKey Returns Handle
85743>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
85743>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
85743>>>>>>>>>>>        Boolean   bSuccess
85743>>>>>>>>>>>        Handle    hKey
85743>>>>>>>>>>>        Integer   iHeadSize iKeySize
85743>>>>>>>>>>>        UChar[]   ucaKeyblob
85744>>>>>>>>>>>        Integer iVoid
85744>>>>>>>>>>>    
85744>>>>>>>>>>>        Move (SizeOfType(tPLAINTEXTKEYBLOB)) to iHeadSize
85745>>>>>>>>>>>        Move (SizeOfArray(ucaKey)) to iKeySize
85746>>>>>>>>>>>    
85746>>>>>>>>>>>        Move PLAINTEXTKEYBLOB to blobhead.hdr.bType
85747>>>>>>>>>>>        Move CUR_BLOB_VERSION   to blobhead.hdr.bVersion
85748>>>>>>>>>>>        Get piCipher            to blobhead.hdr.aiKeyAlg
85749>>>>>>>>>>>        Move iKeySize           to blobhead.dwKeySize
85750>>>>>>>>>>>    
85750>>>>>>>>>>>        Move (ResizeArray(ucaKeyblob, iHeadSize)) to ucaKeyblob
85751>>>>>>>>>>>        Move (CopyMemory(AddressOf(ucaKeyblob), AddressOf(blobhead), iHeadSize)) to iVoid
85752>>>>>>>>>>>        Move (AppendArray(ucaKeyblob, ucaKey)) to ucaKeyblob
85753>>>>>>>>>>>    
85753>>>>>>>>>>>        Move 0 to hKey
85754>>>>>>>>>>>        Move (CryptImportKey(hProv, AddressOf(ucaKeyblob), SizeOfArray(ucaKeyblob), 0, 0, AddressOf(hKey))) to bSuccess
85755>>>>>>>>>>>        If (not(bSuccess)) Begin 
85757>>>>>>>>>>>            Move (ShowLastError()) to iVoid
85758>>>>>>>>>>>        End
85758>>>>>>>>>>>>
85758>>>>>>>>>>>    
85758>>>>>>>>>>>        Function_Return hKey
85759>>>>>>>>>>>    End_Function
85760>>>>>>>>>>>
85760>>>>>>>>>>>    // Function : DestroyKey
85760>>>>>>>>>>>    // Purpose  : Destroys the key
85760>>>>>>>>>>>    Function DestroyKey Handle hKey Returns Boolean
85762>>>>>>>>>>>        Function_Return (CryptDestroyKey(hKey))
85763>>>>>>>>>>>    End_Function
85764>>>>>>>>>>>    
85764>>>>>>>>>>>    // Function : KeyParameter
85764>>>>>>>>>>>    // Purpose  : Retrieves key data
85764>>>>>>>>>>>    Function KeyParameter Handle hKey Integer iQuery Returns Integer
85766>>>>>>>>>>>        Integer iBuffer iLen
85766>>>>>>>>>>>        Boolean bOk
85766>>>>>>>>>>>        
85766>>>>>>>>>>>        Move (SizeOfType(Integer)) to iLen
85767>>>>>>>>>>>        Move (CryptGetKeyParam(hKey,iQuery,AddressOf(iBuffer),AddressOf(iLen),0)) to bOk
85768>>>>>>>>>>>        Function_Return iBuffer
85769>>>>>>>>>>>    End_Function
85770>>>>>>>>>>>    
85770>>>>>>>>>>>    // Function : HashValue
85770>>>>>>>>>>>    // Purpose  : Retrieves a hash value
85770>>>>>>>>>>>    Function HashValue Handle lhHash Returns String
85772>>>>>>>>>>>        Pointer lpSize
85772>>>>>>>>>>>        Pointer lpHash
85772>>>>>>>>>>>        String  lsSize
85772>>>>>>>>>>>        String  lsHash
85772>>>>>>>>>>>        Integer liResult
85772>>>>>>>>>>>
85772>>>>>>>>>>>        Move (Repeat(Character(0),4)) to lsSize
85773>>>>>>>>>>>        GetAddress of lsSize to lpSize
85774>>>>>>>>>>>
85774>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,0,lpSize,0)) to liResult
85775>>>>>>>>>>>        If (liResult = 0) Function_Return ""
85778>>>>>>>>>>>
85778>>>>>>>>>>>        Move (Repeat(Character(0),BytesTodWord(lsSize,1))) to lsHash
85779>>>>>>>>>>>        GetAddress of lsHash to lpHash
85780>>>>>>>>>>>
85780>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,lpHash,lpSize,0)) to liResult
85781>>>>>>>>>>>        If (liResult = 0) Function_Return ""
85784>>>>>>>>>>>
85784>>>>>>>>>>>        Function_Return lsHash
85785>>>>>>>>>>>    End_Function  // HashValue
85786>>>>>>>>>>>    
85786>>>>>>>>>>>            
85786>>>>>>>>>>>    // Function : Encrypt
85786>>>>>>>>>>>    // Purpose  : Encrypts data
85786>>>>>>>>>>>    Function Encrypt String sPassword String sData Returns String
85788>>>>>>>>>>>        Handle hProv hHash hKey
85788>>>>>>>>>>>        Integer iAlgorithm iDataLen iCipherLen iErr
85788>>>>>>>>>>>        Boolean bOk
85788>>>>>>>>>>>        
85788>>>>>>>>>>>        Get AcquireContext to hProv
85789>>>>>>>>>>>        If (hProv) Begin
85791>>>>>>>>>>>            Get CreateHash hProv to hHash
85792>>>>>>>>>>>            If (hHash) Begin
85794>>>>>>>>>>>                Get HashData hHash sPassword to bOk
85795>>>>>>>>>>>                If (bOk) Begin
85797>>>>>>>>>>>                    Get piCipher to iAlgorithm
85798>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
85799>>>>>>>>>>>                End // If (bOk) Begin            
85799>>>>>>>>>>>>
85799>>>>>>>>>>>                Get DestroyHash hHash to bOk
85800>>>>>>>>>>>            End // If (hHash) Begin
85800>>>>>>>>>>>>
85800>>>>>>>>>>>            
85800>>>>>>>>>>>            If (hKey) Begin
85802>>>>>>>>>>>                //  First call to determine resulting data size
85802>>>>>>>>>>>                Move (Length(sData)) to iDataLen
85803>>>>>>>>>>>                Move (Length(sData)) to iCipherLen
85804>>>>>>>>>>>                Move (CryptEncrypt(hKey, 0, True, 0, 0, AddressOf(iCipherLen), iDataLen)) to bOk
85805>>>>>>>>>>>                
85805>>>>>>>>>>>                //  Reserve space in string
85805>>>>>>>>>>>                If (iDataLen < iCipherLen) Begin
85807>>>>>>>>>>>                    Move (sData + Repeat(" ", iCipherLen - iDataLen)) to sData
85808>>>>>>>>>>>                End
85808>>>>>>>>>>>>
85808>>>>>>>>>>>                
85808>>>>>>>>>>>                //  Call to really decrypt
85808>>>>>>>>>>>                Move (CryptEncrypt(hKey,0,True,0,AddressOf(sData),AddressOf(iDataLen),Length(sData))) to bOk
85809>>>>>>>>>>>                //If (not(bOk)) Begin
85809>>>>>>>>>>>                    //Move "" to sData
85809>>>>>>>>>>>                    //Move (GetLastError()) to iErr
85809>>>>>>>>>>>                //End
85809>>>>>>>>>>>                
85809>>>>>>>>>>>                Get DestroyKey hKey to bOk
85810>>>>>>>>>>>            End // If (hKey) Begin
85810>>>>>>>>>>>>
85810>>>>>>>>>>>            Get ReleaseContext hProv to bOk
85811>>>>>>>>>>>        End // If (hProv) Begin
85811>>>>>>>>>>>>
85811>>>>>>>>>>>        Function_Return sData
85812>>>>>>>>>>>    End_Function
85813>>>>>>>>>>>    
85813>>>>>>>>>>>    // Function : Decrypt
85813>>>>>>>>>>>    // Purpose  : Decrypts data
85813>>>>>>>>>>>    Function Decrypt String sPassword String sData Returns String
85815>>>>>>>>>>>        Handle hProv hHash hKey
85815>>>>>>>>>>>        Integer iAlgorithm iDataLen
85815>>>>>>>>>>>        Boolean bOk
85815>>>>>>>>>>>        
85815>>>>>>>>>>>        Get AcquireContext to hProv
85816>>>>>>>>>>>        If (hProv) Begin
85818>>>>>>>>>>>            Get CreateHash hProv to hHash
85819>>>>>>>>>>>            If (hHash) Begin
85821>>>>>>>>>>>                Get HashData hHash sPassword to bOk
85822>>>>>>>>>>>                If (bOk) Begin
85824>>>>>>>>>>>                    Get piCipher to iAlgorithm
85825>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
85826>>>>>>>>>>>                End // If (bOk) Begin            
85826>>>>>>>>>>>>
85826>>>>>>>>>>>                Get DestroyHash hHash to bOk
85827>>>>>>>>>>>            End // If (hHash) Begin
85827>>>>>>>>>>>>
85827>>>>>>>>>>>            
85827>>>>>>>>>>>            If (hKey) Begin
85829>>>>>>>>>>>                Move (Length(sData)) to iDataLen
85830>>>>>>>>>>>                Move (CryptDecrypt(hKey,0,True,0,AddressOf(sData),AddressOf(iDataLen))) to bOk
85831>>>>>>>>>>>                //If (bOk = False) Move "" to sData
85831>>>>>>>>>>>                
85831>>>>>>>>>>>                //  Resulting dat can be shorter as the input string, in that case we shorten the result string
85831>>>>>>>>>>>                If (Length(sData) > iDataLen) Begin
85833>>>>>>>>>>>                    Move (Left(sData, iDataLen)) to sData
85834>>>>>>>>>>>                End
85834>>>>>>>>>>>>
85834>>>>>>>>>>>                
85834>>>>>>>>>>>                Get DestroyKey hKey to bOk
85835>>>>>>>>>>>            End // If (hKey) Begin
85835>>>>>>>>>>>>
85835>>>>>>>>>>>            Get ReleaseContext hProv to bOk
85836>>>>>>>>>>>        End // If (hProv) Begin
85836>>>>>>>>>>>>
85836>>>>>>>>>>>        Function_Return sData
85837>>>>>>>>>>>    End_Function
85838>>>>>>>>>>>    
85838>>>>>>>>>>>    //  Function : GenerateRandom
85838>>>>>>>>>>>    //  Purpose  : Generates random data.
85838>>>>>>>>>>>    Function GenerateRandom Integer iBytes Returns UChar[]
85840>>>>>>>>>>>        Handle hProv
85840>>>>>>>>>>>        UChar[] uaResult
85841>>>>>>>>>>>        Boolean bRes
85841>>>>>>>>>>>        
85841>>>>>>>>>>>        Get AcquireContext to hProv
85842>>>>>>>>>>>        
85842>>>>>>>>>>>        Move (ResizeArray(uaResult, iBytes)) to uaResult
85843>>>>>>>>>>>        Move (CryptGenRandom(hProv, iBytes, AddressOf(uaResult))) to bRes
85844>>>>>>>>>>>        
85844>>>>>>>>>>>        Get ReleaseContext hProv to bRes
85845>>>>>>>>>>>        
85845>>>>>>>>>>>        Function_Return uaResult
85846>>>>>>>>>>>    End_Function
85847>>>>>>>>>>>    
85847>>>>>>>>>>>    //  Function : GenerateRandomString
85847>>>>>>>>>>>    //  Purpose  : Generates random data and does a base64 encoding to properly present it as a string.
85847>>>>>>>>>>>    Function GenerateRandomString Integer iLenght Returns String
85849>>>>>>>>>>>        String sResult
85849>>>>>>>>>>>        UChar[] aData
85850>>>>>>>>>>>        Address pBase64
85850>>>>>>>>>>>        Integer iVoid
85850>>>>>>>>>>>
85850>>>>>>>>>>>        Get GenerateRandom iLenght to aData
85851>>>>>>>>>>>        
85851>>>>>>>>>>>        Move (Base64Encode(AddressOf(aData), iLenght)) to pBase64
85852>>>>>>>>>>>        Move pBase64 to sResult
85853>>>>>>>>>>>        Move (Free(pBase64)) to iVoid    
85854>>>>>>>>>>>        
85854>>>>>>>>>>>        Function_Return (Left(sResult, iLenght))
85855>>>>>>>>>>>    End_Function
85856>>>>>>>>>>>
85856>>>>>>>>>>>End_Class
85857>>>>>>>>>Use Base64Functions.pkg
Including file: Base64Functions.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\Base64Functions.pkg)
85857>>>>>>>>>>>//> This package enables base64 encoding and decoding of strings:
85857>>>>>>>>>>>//>
85857>>>>>>>>>>>//>     Get EncodeString of oBase64Functions sValue to sValue
85857>>>>>>>>>>>//>     Get DecodeString of oBase64Functions sValue to sValue
85857>>>>>>>>>>>//>
85857>>>>>>>>>>>//> Remember to set the "max argument size" if dealing with very large
85857>>>>>>>>>>>//> strings.
85857>>>>>>>>>>>//>
85857>>>>>>>>>>>//> For 17.1 and later the functionality of this package is based on two functions (Base64Encode and
85857>>>>>>>>>>>//> Base64Decode) that are built into the runtime.
85857>>>>>>>>>>>//>
85857>>>>>>>>>>>//> But for versions up to and including 17.0 it's based on the vdfBase64.dll file that was obtained
85857>>>>>>>>>>>//> from DAE that have kindly allowed me to distribute it to other DF developers. Programs including
85857>>>>>>>>>>>//> this package will give off an error on start-up if vdfBase64.dll is not found in the /bin folder
85857>>>>>>>>>>>//> if the VDF runtime. You will find the DLL in the /programs folder of the StureApsPublicLib workspace
85857>>>>>>>>>>>
85857>>>>>>>>>>>Use VdfBase.pkg
85857>>>>>>>>>>>
85857>>>>>>>>>>>// Functions in vdfBase64.dll
85857>>>>>>>>>>>External_Function xxBase64Encode "vdfbase64Encode" vdfBase64.dll Pointer pBuffer Returns Integer
85858>>>>>>>>>>>External_Function xxBase64Decode "vdfbase64Decode" vdfBase64.dll Pointer pBuffer Returns Integer
85859>>>>>>>>>>>External_Function xxBase64Free   "vdfbase64Free"   vdfBase64.dll Pointer pBuffer Returns Integer
85860>>>>>>>>>>>
85860>>>>>>>>>>>// Structure
85860>>>>>>>>>>>Struct txxfBase64Buffer
85860>>>>>>>>>>>    Pointer pData
85860>>>>>>>>>>>    Integer iLength
85860>>>>>>>>>>>End_Struct
85860>>>>>>>>>>>
85860>>>>>>>>>>>Global_Variable Integer oBase64Functions
85860>>>>>>>>>>>
85860>>>>>>>>>>>Object _oBase64Functions is a cObject
85862>>>>>>>>>>>    Move Self to oBase64Functions
85863>>>>>>>>>>>
85863>>>>>>>>>>>
85863>>>>>>>>>>>    Function EncodeString String sValue Returns String
85866>>>>>>>>>>>        Address pBase64
85866>>>>>>>>>>>        String sResult
85866>>>>>>>>>>>        Integer iVoid
85866>>>>>>>>>>>        Move (Base64Encode(AddressOf(sValue), Length(sValue))) to pBase64
85867>>>>>>>>>>>        Move pBase64 to sResult
85868>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
85869>>>>>>>>>>>        Function_Return sResult
85870>>>>>>>>>>>    End_Function
85871>>>>>>>>>>>
85871>>>>>>>>>>>    Function DecodeString String sValue Returns String
85874>>>>>>>>>>>        Address pBinary
85874>>>>>>>>>>>        String sBinary
85874>>>>>>>>>>>        Integer iVoid iLen
85874>>>>>>>>>>>        Move (Base64Decode(AddressOf(sValue), &iLen)) to pBinary
85875>>>>>>>>>>>        Move (Repeat(Character(0), iLen)) to sBinary
85876>>>>>>>>>>>        Move (MemCopy(AddressOf(sBinary), pBinary, iLen)) to iVoid
85877>>>>>>>>>>>        Move (Free(pBinary)) to iVoid
85878>>>>>>>>>>>        Function_Return sBinary
85879>>>>>>>>>>>    End_Function
85880>>>>>>>>>>>
85880>>>>>>>>>>>End_Object
85881>>>>>>>>>Use MSSqldrv.pkg
85881>>>>>>>>>Use db2_drv.pkg
85881>>>>>>>>>Use odbc_drv.pkg
85881>>>>>>>>>Use vWin32fh.pkg
Including file: vWin32fh.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\vWin32fh.pkg)
85881>>>>>>>>>>>// This code is part of VDF GUIdance
85881>>>>>>>>>>>// Visit us @ http://www.vdf-guidance.com
85881>>>>>>>>>>>// e-Mail us @ info@vdf-guidance.com
85881>>>>>>>>>>>// VDF GUIdance is a mutual project of
85881>>>>>>>>>>>// Frank Vandervelpen - Vandervelpen Systems and
85881>>>>>>>>>>>// Wil van Antwerpen  - Antwise Solutions
85881>>>>>>>>>>>// All software source code should be used <<AS IS>> without any warranty.
85881>>>>>>>>>>>//
85881>>>>>>>>>>>//
85881>>>>>>>>>>>// *** Windows 32bit file handling wrapper class ***
85881>>>>>>>>>>>//
85881>>>>>>>>>>>
85881>>>>>>>>>>>// 05-09-2000 **WvA: Changed namingconvention of all classes and methods to new standard
85881>>>>>>>>>>>//                   This may be painfull for some of you, but it was really needed as it was
85881>>>>>>>>>>>//                   getting messy. The "vs" -prefix we used before was confusing and could
85881>>>>>>>>>>>//                   unintentionally have been interpreted as "Vdf-GUIdance String".
85881>>>>>>>>>>>//
85881>>>>>>>>>>>// The used naming-convention is:
85881>>>>>>>>>>>//     - a prefix of "vWin32_" for every external function declaration
85881>>>>>>>>>>>//     - a prefix of the letter "v" for the full API name for the vdf-wrapper function.
85881>>>>>>>>>>>//
85881>>>>>>>>>>>// By using this we are guarding ourselves for conflicts with variable declarations
85881>>>>>>>>>>>// of DataAccess in the future.
85881>>>>>>>>>>>// Or at least almost as the letter "v" is now also synonym for variant (duh~!)
85881>>>>>>>>>>>//
85881>>>>>>>>>>>// mm-dd-yyyy Author Description
85881>>>>>>>>>>>//
85881>>>>>>>>>>>//                   vSHGetFolderPath added to retrieve the new shell folders
85881>>>>>>>>>>>//                   vGetWindowsDirectory
85881>>>>>>>>>>>//
85881>>>>>>>>>>>//                   vGetTempFileName
85881>>>>>>>>>>>//                   vGetTempPath
85881>>>>>>>>>>>// 11-17-2001 **WvA: Removed User Interface Error popups such as Error handling.
85881>>>>>>>>>>>//                   This is an absolute need for WebApp. We expect you to handle the
85881>>>>>>>>>>>//                   error in your application anyways. Changed this for:
85881>>>>>>>>>>>//                   vDeleteFile, vCopyFile, vMoveFile and vRenameFile
85881>>>>>>>>>>>// 03-02-2002 **WvA: vRemoveDirectory added
85881>>>>>>>>>>>// 03-11-2002 **WvA: The parameter lpdword in the external function declaration for
85881>>>>>>>>>>>//                   vWin32_SHBrowsForFolder can cause compiler errors.
85881>>>>>>>>>>>//                   It is renamed too avoid this.
85881>>>>>>>>>>>// 11-11-2002 **WvA: Codecleanup, vcSelectFile_Dialog is now cvSelectFile_Dialog, its
85881>>>>>>>>>>>//                   function vSelectedFileName is now just SelectedFileName
85881>>>>>>>>>>>//                   Removed the local keyword in the variable declarations
85881>>>>>>>>>>>// 10-17-2003 **WvA: Cleaned up function vSelect_File and added code to destroy the dynamically
85881>>>>>>>>>>>//                   created file-open dialog
85881>>>>>>>>>>>// 02-12-2004 **WvA: Allan Ankerstjeme pointed me into a bug for the vCreateTempFileInPath
85881>>>>>>>>>>>//                   in that it didn't exactly return the correct filename of the file created.
85881>>>>>>>>>>>//                   This has now been taken care of.
85881>>>>>>>>>>>// 02-19-2004 **WvA: Removed all API declarations from the package itself to improve readability
85881>>>>>>>>>>>//                   These declarations are now included from the vWin32fh header file.
85881>>>>>>>>>>>// 02-19-2004 **WvA: Changed the default way in which the standard file handling works
85881>>>>>>>>>>>//                   Before today one could always undo the operation, as of now you cannot as
85881>>>>>>>>>>>//                   the default was a silly one using unnecessary resources (mainly diskspace)
85881>>>>>>>>>>>//                   Since i don't really expect someone to use that feature it has been removed.
85881>>>>>>>>>>>//                   One can however restore to the old way of handling by simply calling the
85881>>>>>>>>>>>//                   vWin32fhCompatibilityMode procedure ONE time before accessing any of the
85881>>>>>>>>>>>//                   filehandling operations
85881>>>>>>>>>>>// 02-19-2004 **WvA: The functions ParseFolderName, ParseFileName and ParseFileExtenstion added
85881>>>>>>>>>>>//                   as well as the StringFromRightOfChar function.
85881>>>>>>>>>>>// 02-19-2004 **WvA: sfoFormatDisk function added which can use to format a floppydisk
85881>>>>>>>>>>>//                   DISABLED now as testing shows that it does not work as advertised...
85881>>>>>>>>>>>// 02-20-2004 **WvA: The function vDDE_Error_Handler didn't pass the errornumber on to the DDE_Error_To_String function
85881>>>>>>>>>>>//                   Moved the hardcoded strings from vDDE_Error_Handler to define declarations for easier translation later on.
85881>>>>>>>>>>>// 09-10-2004 **WvA: Added the ToAnsi function to the fileoperations method so that
85881>>>>>>>>>>>//                   extended characters are treated ok too.
85881>>>>>>>>>>>//                   Reported by Flemming from
85881>>>>>>>>>>>// 12-17-2004 **WvA: Changed vFilePathExists to be global, reported by Peter van Mil
85881>>>>>>>>>>>// 12-28-2004 **WvA: WebApp compatibility added by introducing compiler directives
85881>>>>>>>>>>>// 03-10-2006 **WvA: Added more CSIDL types to our header file for use with the vSHGetFolderPath function
85881>>>>>>>>>>>// 01-02-2007 **WvA: Set NoChangeDir_State on vSelect_File and vSelectSaveFile to True but changed it back due to side effects.
85881>>>>>>>>>>>//                   Added vSelectSavefile function to create a file save dialog
85881>>>>>>>>>>>//                   Fixed ParseFolderName which was horribly broken (thanks for the reports)
85881>>>>>>>>>>>//                   Added vParentPath function to retrieve the parent "node" of a path
85881>>>>>>>>>>>// 01-04-2008 **WvA: Fixed vCreateTempFileInPath as the function wasn't working
85881>>>>>>>>>>>// 10-04-2009 **WvA: Added vshCreateDirectoryEx from Micheal Mullan, moved filedialogs to cvFileDialogs.pkg
85881>>>>>>>>>>>// 01-11-2010 **WvA: Added vWin32_APIFilesize as supplied by Renato Villa, to get the filesize of the specified file. See http://support.dataaccess.com/forums/showthread.php?t=41982
85881>>>>>>>>>>>// 10-02-2011 **WvA: Added vCSIDL_SYSTEMX86, courtesy of Ola Eldoy for pointing this out and providing the define statement.
85881>>>>>>>>>>>// 20-12-2012 **WvA: Default behavior on copy/move is now to autocreate subfolders, tip by Frank Cheng
85881>>>>>>>>>>>// 29-09-2014 **WvA: Added function vFolderFileCount to count the number of files in a folder, add vCSIDL_PROGRAM_FILESx86
85881>>>>>>>>>>>// 04-10-2014 **WvA: Added extra checks on vFilePathExists and vFolderExists courtesy of Nils Svedmyr
85881>>>>>>>>>>>
85881>>>>>>>>>>>//Use Case.mac
85881>>>>>>>>>>>Use File_Dlg.pkg      // Contains OpenDialog class definition
85881>>>>>>>>>>>Use cvFileDialogs.pkg
Including file: cvFileDialogs.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cvFileDialogs.pkg)
85881>>>>>>>>>>>>>//***************************************************************************
85881>>>>>>>>>>>>>//*
85881>>>>>>>>>>>>>//* Class:        cvSaveAsDialog
85881>>>>>>>>>>>>>//* Package Name: cvFileDialogs.pkg
85881>>>>>>>>>>>>>//*
85881>>>>>>>>>>>>>//***************************************************************************
85881>>>>>>>>>>>>>
85881>>>>>>>>>>>>>Use File_dlg.pkg
85881>>>>>>>>>>>>>
85881>>>>>>>>>>>>>// *WvA: 13-01-1999 Created
85881>>>>>>>>>>>>>// The Class cSelectFile_Dialog is created to support the function Select_File
85881>>>>>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
85881>>>>>>>>>>>>>// file_name.
85881>>>>>>>>>>>>>Class cvSelectFile_Dialog Is An OpenDialog
85882>>>>>>>>>>>>>
85882>>>>>>>>>>>>>  Procedure Construct_Object Integer iImage_Id
85884>>>>>>>>>>>>>    Forward Send Construct_Object iImage_Id
85886>>>>>>>>>>>>>    Set HideReadOnly_State To True
85887>>>>>>>>>>>>>  End_Procedure // Construct_Object
85888>>>>>>>>>>>>>
85888>>>>>>>>>>>>>  Function SelectedFileName Returns String
85890>>>>>>>>>>>>>    String sFileName
85890>>>>>>>>>>>>>    Move "" To sFileName
85891>>>>>>>>>>>>>    If (Show_Dialog(Self)) Begin
85893>>>>>>>>>>>>>      Move (RTrim(File_Name(Self))) To sFileName
85894>>>>>>>>>>>>>    End
85894>>>>>>>>>>>>>>
85894>>>>>>>>>>>>>    Function_Return sFileName
85895>>>>>>>>>>>>>  End_Function // SelectedFileName
85896>>>>>>>>>>>>>End_Class // cvSelectFile_Dialog
85897>>>>>>>>>>>>>
85897>>>>>>>>>>>>>
85897>>>>>>>>>>>>>// *WvA: 13-01-1999 Created
85897>>>>>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
85897>>>>>>>>>>>>>// file_name. Returns '' if the user didn't make a selection.
85897>>>>>>>>>>>>>// **WvA: 17-10-2003 Cleaned up and added code to destroy the dynamically created
85897>>>>>>>>>>>>>//                   file-open dialog
85897>>>>>>>>>>>>>Function vSelect_File Global String sSupportedFileTypes String sCaptionText String sInitialFolder Returns String
85899>>>>>>>>>>>>>  String sSelectedFile
85899>>>>>>>>>>>>>  Integer hoOpenFileDialog
85899>>>>>>>>>>>>>
85899>>>>>>>>>>>>>  Object oOpenFileDialog Is A cvSelectFile_Dialog
85901>>>>>>>>>>>>>
85901>>>>>>>>>>>>>    Set Dialog_Caption    To sCaptionText
85902>>>>>>>>>>>>>    Set Filter_String     To sSupportedFileTypes
85903>>>>>>>>>>>>>    Set Initial_Folder    To sInitialFolder
85904>>>>>>>>>>>>>
85904>>>>>>>>>>>>>    Move Self       To hoOpenFileDialog
85905>>>>>>>>>>>>>  End_Object // oOpenFileDialog
85906>>>>>>>>>>>>>
85906>>>>>>>>>>>>>  Get SelectedFileName Of hoOpenFileDialog To sSelectedFile
85907>>>>>>>>>>>>>  Send Destroy_Object To hoOpenFileDialog
85908>>>>>>>>>>>>>  Function_Return sSelectedFile
85909>>>>>>>>>>>>>End_Function // vSelect_File
85910>>>>>>>>>>>>>
85910>>>>>>>>>>>>>
85910>>>>>>>>>>>>>Class cvSaveAsDialog is a SaveAsDialog
85911>>>>>>>>>>>>>
85911>>>>>>>>>>>>>  Procedure Construct_Object
85913>>>>>>>>>>>>>    Forward Send Construct_Object
85915>>>>>>>>>>>>>    Set HideReadOnly_State To True
85916>>>>>>>>>>>>>  End_Procedure // Construct_Object
85917>>>>>>>>>>>>>
85917>>>>>>>>>>>>>  Function SelectedFileName Returns String
85919>>>>>>>>>>>>>    String sFileName
85919>>>>>>>>>>>>>    Move "" To sFileName
85920>>>>>>>>>>>>>    If (Show_Dialog(Self)) Begin
85922>>>>>>>>>>>>>      Move (RTrim(File_Name(Self))) To sFileName
85923>>>>>>>>>>>>>    End
85923>>>>>>>>>>>>>>
85923>>>>>>>>>>>>>    Function_Return sFileName
85924>>>>>>>>>>>>>  End_Function // SelectedFileName
85925>>>>>>>>>>>>>
85925>>>>>>>>>>>>>End_Class // cvSaveAsDialog
85926>>>>>>>>>>>>>
85926>>>>>>>>>>>>>// Added optional default filename as suggested by Nils
85926>>>>>>>>>>>>>Function vSelectSaveFile Global String sSupportedFileTypes String sCaptionText String sInitialFolder String sDefaultFileName Returns String
85928>>>>>>>>>>>>>  String sSelectedFile
85928>>>>>>>>>>>>>  Integer hoDialog
85928>>>>>>>>>>>>>
85928>>>>>>>>>>>>>  Move "" To sSelectedFile
85929>>>>>>>>>>>>>  Get Create U_cvSaveAsDialog To hoDialog
85930>>>>>>>>>>>>>  If (hoDialog) Begin
85932>>>>>>>>>>>>>    //Set NoChangeDir_State Of hoDialog To True
85932>>>>>>>>>>>>>    Set Dialog_Caption    Of hoDialog To sCaptionText
85933>>>>>>>>>>>>>    Set Filter_String     Of hoDialog To sSupportedFileTypes
85934>>>>>>>>>>>>>    Set Initial_Folder    Of hoDialog To sInitialFolder
85935>>>>>>>>>>>>>    If (Num_Arguments = 4) Begin
85937>>>>>>>>>>>>>      Set File_Title        of hoDialog to sDefaultFileName
85938>>>>>>>>>>>>>    End
85938>>>>>>>>>>>>>>
85938>>>>>>>>>>>>>    Get SelectedFileName  Of hoDialog To sSelectedFile
85939>>>>>>>>>>>>>    Send Destroy Of hoDialog
85940>>>>>>>>>>>>>  End
85940>>>>>>>>>>>>>>
85940>>>>>>>>>>>>>  Function_Return sSelectedFile
85941>>>>>>>>>>>>>End_Function // vSelectSaveFile
85942>>>>>>>>>>>Use Seq_chnl.pkg
85942>>>>>>>>>>>
85942>>>>>>>>>>>Use Windows.pkg
85942>>>>>>>>>>>//Use Dferror
85942>>>>>>>>>>>Use Dll.pkg
85942>>>>>>>>>>>Use vWin32fh.h       // Header file with WinAPI declarations
Including file: vwin32fh.h    (C:\Projects\DF18\DbUpdateFramework\AppSrc\vwin32fh.h)
85942>>>>>>>>>>>>>//TH-Header
85942>>>>>>>>>>>>>//*****************************************************************************************
85942>>>>>>>>>>>>>// Copyright (c)  2004 KURANT Project
85942>>>>>>>>>>>>>// All rights reserved.
85942>>>>>>>>>>>>>//
85942>>>>>>>>>>>>>// $FileName    : G:\Projects\vWin32fh\vWin32fh.h
85942>>>>>>>>>>>>>// $ProjectName : Windows 32 bits file handling
85942>>>>>>>>>>>>>// $Authors     : Wil van Antwerpen
85942>>>>>>>>>>>>>// $Created     : 19.02.2004  19:25
85942>>>>>>>>>>>>>// $Type        : BSD (as in do with it whatever you like)
85942>>>>>>>>>>>>>//
85942>>>>>>>>>>>>>// Contents:
85942>>>>>>>>>>>>>//  This file contains the Windows API external function call definitions and
85942>>>>>>>>>>>>>//  constants as they are used in the vWin32fh package.
85942>>>>>>>>>>>>>//*****************************************************************************************
85942>>>>>>>>>>>>>//TH-RevisionStart
85942>>>>>>>>>>>>>//TH-RevisionEnd
85942>>>>>>>>>>>>>
85942>>>>>>>>>>>>>Define CS_DDE_ERR_FILE_NOT_FOUND  For "The specified file was not found.\n"
85942>>>>>>>>>>>>>Define CS_DDE_ERR_PATH_NOT_FOUND  For "The specified path was not found.\n"
85942>>>>>>>>>>>>>Define CS_DDE_ERR_BAD_FORMAT      For "The .EXE file is invalid.\n"
85942>>>>>>>>>>>>>Define CS_DDE_ERR_ACCESSDENIED    For "The operating system denied access to the specified file.\n"
85942>>>>>>>>>>>>>Define CS_DDE_ERR_ASSOCINCOMPLETE For "The filename association is incomplete or invalid.\n"
85942>>>>>>>>>>>>>Define CS_DDE_ERR_DDEBUSY         For "The DDE transaction could not be completed because other DDE\ntransactions were being processed.\n"
85942>>>>>>>>>>>>>Define CS_DDE_ERR_DDEFAIL         For "The DDE transaction failed.\n"
85942>>>>>>>>>>>>>Define CS_DDE_ERR_DDETIMEOUT      For "The DDE transaction could not be completed,\nbecause the request timed out.\n"
85942>>>>>>>>>>>>>Define CS_DDE_ERR_DLLNOTFOUND     For "The specified dynamic-link library was not found.\n"
85942>>>>>>>>>>>>>Define CS_DDE_ERR_NOASSOC         For "There is no application associated with the given filename extension.\n"
85942>>>>>>>>>>>>>Define CS_DDE_ERR_OOM             For "There is not enough free memory available to complete the operation.\n"
85942>>>>>>>>>>>>>Define CS_DDE_ERR_PNF             For "The specified path was not found.\n"
85942>>>>>>>>>>>>>Define CS_DDE_ERR_SHARE           For "A sharing violation occurred.\n"
85942>>>>>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE1   For "Unknown DDE-error occurred.\nErrornumber"
85942>>>>>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
85942>>>>>>>>>>>>>Define CS_DDE_ERR_HANDL_PAKTC     For "\nPress a key to continue...\n\n"
85942>>>>>>>>>>>>>Define CS_DDE_ERR_HANDL_CAPTION   For "a DDE-error occurred"
85942>>>>>>>>>>>>>
85942>>>>>>>>>>>>>
85942>>>>>>>>>>>>>Define vMax_Path     For |CI260
85942>>>>>>>>>>>>>Define vMinChar      For |CI$80
85942>>>>>>>>>>>>>Define vMaxChar      For |CI$7F
85942>>>>>>>>>>>>>Define vMinShort     For |CI$8000
85942>>>>>>>>>>>>>Define vMaxShort     For |CI$7FFF
85942>>>>>>>>>>>>>Define vMinLong      For |CI$80000000
85942>>>>>>>>>>>>>Define vMaxLong      For |CI$7FFFFFFF
85942>>>>>>>>>>>>>Define vMaxByte      For |CI$FF
85942>>>>>>>>>>>>>Define vMaxWord      For |CI$FFFF
85942>>>>>>>>>>>>>Define vMaxDword     For |CI$FFFFFFFF
85942>>>>>>>>>>>>>
85942>>>>>>>>>>>>>
85942>>>>>>>>>>>>>
85942>>>>>>>>>>>>>// For FindFirstFile
85942>>>>>>>>>>>>>Define vINVALID_HANDLE_VALUE   For |CI-1
85942>>>>>>>>>>>>>Define vINVALID_FILE_SIZE      For |CI$FFFFFFFF
85942>>>>>>>>>>>>>Define vERROR_NO_MORE_FILES    For |CI18
85942>>>>>>>>>>>>>
85942>>>>>>>>>>>>>// The defines below can be used to find out what kind of error has occurred if
85942>>>>>>>>>>>>>// the API-call ShellExecute is used.
85942>>>>>>>>>>>>>Define vERROR_FILE_NOT_FOUND   For |CI0002
85942>>>>>>>>>>>>>Define vERROR_PATH_NOT_FOUND   For |CI0003
85942>>>>>>>>>>>>>Define vERROR_BAD_FORMAT       For |CI0011
85942>>>>>>>>>>>>>Define vSE_ERR_ACCESSDENIED    For |CI0005
85942>>>>>>>>>>>>>Define vSE_ERR_ASSOCINCOMPLETE For |CI0027
85942>>>>>>>>>>>>>Define vSE_ERR_DDEBUSY         For |CI0030
85942>>>>>>>>>>>>>Define vSE_ERR_DDEFAIL         For |CI0029
85942>>>>>>>>>>>>>Define vSE_ERR_DDETIMEOUT      For |CI0028
85942>>>>>>>>>>>>>Define vSE_ERR_DLLNOTFOUND     For |CI0032
85942>>>>>>>>>>>>>Define vSE_ERR_FNF             For |CI0002
85942>>>>>>>>>>>>>Define vSE_ERR_NOASSOC         For |CI0031
85942>>>>>>>>>>>>>Define vSE_ERR_OOM             For |CI0008
85942>>>>>>>>>>>>>Define vSE_ERR_PNF             For |CI0003
85942>>>>>>>>>>>>>Define vSE_ERR_SHARE           For |CI0026
85942>>>>>>>>>>>>>
85942>>>>>>>>>>>>>
85942>>>>>>>>>>>>>// C-Structure
85942>>>>>>>>>>>>>//typedef struct _browseinfo {
85942>>>>>>>>>>>>>//    HWND hwndOwner;
85942>>>>>>>>>>>>>//    LPCITEMIDLIST pidlRoot;
85942>>>>>>>>>>>>>//    LPSTR pszDisplayName;
85942>>>>>>>>>>>>>//    LPCSTR lpszTitle;
85942>>>>>>>>>>>>>//    UINT ulFlags;
85942>>>>>>>>>>>>>//    BFFCALLBACK lpfn;
85942>>>>>>>>>>>>>//    LPARAM lParam;
85942>>>>>>>>>>>>>//    int iImage;
85942>>>>>>>>>>>>>//} BROWSEINFO, *PBROWSEINFO, *LPBROWSEINFO;
85942>>>>>>>>>>>>>
85942>>>>>>>>>>>>>//declare C structure struct_browseinfo
85942>>>>>>>>>>>>>//as documented in MSDN under Windows Shell API
85942>>>>>>>>>>>>>Type vtBrowseInfo
85942>>>>>>>>>>>>>  Field vtBrowseInfo.hWndOwner      as Handle
85942>>>>>>>>>>>>>  Field vtBrowseInfo.pIDLRoot       as Pointer
85942>>>>>>>>>>>>>  Field vtBrowseInfo.pszDisplayName as Pointer
85942>>>>>>>>>>>>>  Field vtBrowseInfo.lpszTitle      as Pointer
85942>>>>>>>>>>>>>  Field vtBrowseInfo.ulFlags        as dWord
85942>>>>>>>>>>>>>  Field vtBrowseInfo.lpfnCallback   as Pointer
85942>>>>>>>>>>>>>  Field vtBrowseInfo.lParam         as dWord
85942>>>>>>>>>>>>>  Field vtBrowseInfo.iImage         as dWord
85942>>>>>>>>>>>>>End_Type // tBrowseInfo
85942>>>>>>>>>>>>>
85942>>>>>>>>>>>>>// Browsing for directory.
85942>>>>>>>>>>>>>Define vBIF_RETURNONLYFSDIRS   For |CI$0001  // For finding a folder to start document searching
85942>>>>>>>>>>>>>Define vBIF_DONTGOBELOWDOMAIN  For |CI$0002  // For starting the Find Computer
85942>>>>>>>>>>>>>Define vBIF_STATUSTEXT         For |CI$0004  // Includes a status area in the dialog box.
85942>>>>>>>>>>>>>                                            // The callback function can set the status text by
85942>>>>>>>>>>>>>                                            // sending messages to the dialog box.
85942>>>>>>>>>>>>>Define vBIF_RETURNFSANCESTORS  For |CI$0008  // Only returns file system ancestors.
85942>>>>>>>>>>>>>
85942>>>>>>>>>>>>>Define vBIF_BROWSEFORCOMPUTER  For |CI$1000  // Browsing for Computers.
85942>>>>>>>>>>>>>Define vBIF_BROWSEFORPRINTER   For |CI$2000  // Browsing for Printers
85942>>>>>>>>>>>>>
85942>>>>>>>>>>>>>// message from browser
85942>>>>>>>>>>>>>//Define BFFM_INITIALIZED        1
85942>>>>>>>>>>>>>//Define BFFM_SELCHANGED         2
85942>>>>>>>>>>>>>
85942>>>>>>>>>>>>>// messages to browser
85942>>>>>>>>>>>>>//Define BFFM_SETSTATUSTEXT      (WM_USER + 100)
85942>>>>>>>>>>>>>//Define BFFM_ENABLEOK           (WM_USER + 101)
85942>>>>>>>>>>>>>//Define BFFM_SETSELECTION       (WM_USER + 102)
85942>>>>>>>>>>>>>
85942>>>>>>>>>>>>>
85942>>>>>>>>>>>>>External_function vWin32_SHBrowseForFolder "SHBrowseForFolder" shell32.dll ;  Pointer lpsBrowseInfo Returns dWord
85943>>>>>>>>>>>>>
85943>>>>>>>>>>>>>External_function vWin32_SHGetPathFromIDList "SHGetPathFromIDList" shell32.dll ;  Pointer pidList Pointer lpBuffer Returns dWord
85944>>>>>>>>>>>>>
85944>>>>>>>>>>>>>External_function vWin32_CoTaskMemFree "CoTaskMemFree" ole32.dll Pointer pV Returns Integer
85945>>>>>>>>>>>>>
85945>>>>>>>>>>>>>
85945>>>>>>>>>>>>>
85945>>>>>>>>>>>>>
85945>>>>>>>>>>>>>Type vtSecurity_attributes
85945>>>>>>>>>>>>>  Field vtSecurity_attributes.nLength        as dWord
85945>>>>>>>>>>>>>  Field vtSecurity_attributes.lpDescriptor   as Pointer
85945>>>>>>>>>>>>>  Field vtSecurity_attributes.bInheritHandle as Integer
85945>>>>>>>>>>>>>End_Type // vtSecurity_attributes
85945>>>>>>>>>>>>>
85945>>>>>>>>>>>>>//nLength:
85945>>>>>>>>>>>>>// Specifies the size, in bytes, of this structure. Set this value to the size of the
85945>>>>>>>>>>>>>// SECURITY_ATTRIBUTES structure.
85945>>>>>>>>>>>>>// Windows NT: Some functions that use the SECURITY_ATTRIBUTES structure do not verify the
85945>>>>>>>>>>>>>// value of the nLength member. However, an application should still set it properly.
85945>>>>>>>>>>>>>// That ensures current, future, and cross-platform compatibility.
85945>>>>>>>>>>>>>//
85945>>>>>>>>>>>>>//lpSecurityDescriptor:
85945>>>>>>>>>>>>>// Points to a security descriptor for the object that controls the sharing of it.
85945>>>>>>>>>>>>>// If NULL is specified for this member, the object may be assigned the default security
85945>>>>>>>>>>>>>// descriptor of the calling process.
85945>>>>>>>>>>>>>//
85945>>>>>>>>>>>>>//bInheritHandle:
85945>>>>>>>>>>>>>// Specifies whether the returned handle is inherited when a new process is created.
85945>>>>>>>>>>>>>// If this member is TRUE, the new process inherits the handle.
85945>>>>>>>>>>>>>
85945>>>>>>>>>>>>>
85945>>>>>>>>>>>>>// BOOL CreateDirectory(
85945>>>>>>>>>>>>>//    LPCTSTR lpPathName,
85945>>>>>>>>>>>>>//    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // pointer to a security descriptor
85945>>>>>>>>>>>>>//   );
85945>>>>>>>>>>>>>//
85945>>>>>>>>>>>>>// lpPathName
85945>>>>>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
85945>>>>>>>>>>>>>//  to be created.
85945>>>>>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
85945>>>>>>>>>>>>>//  This limit is related to how the CreateDirectory function parses paths.
85945>>>>>>>>>>>>>// lpSecurityAttributes
85945>>>>>>>>>>>>>//  Pointer to a SECURITY_ATTRIBUTES structure als called a security descriptor that
85945>>>>>>>>>>>>>//  determines whether the returned handle can be inherited by child processes.
85945>>>>>>>>>>>>>//  If lpSecurityAttributes is NULL, the handle cannot be inherited.
85945>>>>>>>>>>>>>// Returns:
85945>>>>>>>>>>>>>//  If the function succeeds, the return value is nonzero.
85945>>>>>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
85945>>>>>>>>>>>>>External_function vWin32_CreateDirectory "CreateDirectoryA" kernel32.dll ;  Pointer lpPathName Pointer lpSecurity_Attributes Returns Integer
85946>>>>>>>>>>>>>
85946>>>>>>>>>>>>>
85946>>>>>>>>>>>>>// lpPathName
85946>>>>>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
85946>>>>>>>>>>>>>//  to be removed.
85946>>>>>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
85946>>>>>>>>>>>>>// Returns:
85946>>>>>>>>>>>>>//  If the function succeeds, the return value is nonzero.
85946>>>>>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
85946>>>>>>>>>>>>>External_function vWin32_RemoveDirectory "RemoveDirectoryA" kernel32.dll ;  Pointer lpPathName Returns Integer
85947>>>>>>>>>>>>>
85947>>>>>>>>>>>>>
85947>>>>>>>>>>>>>
85947>>>>>>>>>>>>>// The ShellExecute function opens or prints a specified file. The file can be an
85947>>>>>>>>>>>>>// executable file or a document file.
85947>>>>>>>>>>>>>//
85947>>>>>>>>>>>>>// Operation can be one of the following:
85947>>>>>>>>>>>>>//    "OPEN"  The function opens the file specified by lpFile.
85947>>>>>>>>>>>>>//            The file can be an executable file or a document file.
85947>>>>>>>>>>>>>//            The file can be a folder to open.
85947>>>>>>>>>>>>>//    "PRINT" The function prints the file specified by lpFile.
85947>>>>>>>>>>>>>//            The file should be a document file. If the file is an executable file,
85947>>>>>>>>>>>>>//            the function opens the file, as if "open" had been specified.
85947>>>>>>>>>>>>>//  "EXPLORE" The function explores the folder specified by lpFile.
85947>>>>>>>>>>>>>//
85947>>>>>>>>>>>>>// Return Values:
85947>>>>>>>>>>>>>//
85947>>>>>>>>>>>>>// If the function succeeds, the return value is the instance handle of the application that
85947>>>>>>>>>>>>>// was run, or the handle of a dynamic data exchange (DDE) server application.
85947>>>>>>>>>>>>>// If the function fails, the return value is an error value that is less than or equal to 32.
85947>>>>>>>>>>>>>//
85947>>>>>>>>>>>>>// The following table lists these error values:
85947>>>>>>>>>>>>>// Public Const ERROR_FILE_NOT_FOUND = 2&
85947>>>>>>>>>>>>>// Public Const ERROR_PATH_NOT_FOUND = 3&
85947>>>>>>>>>>>>>// Public Const ERROR_BAD_FORMAT = 11&
85947>>>>>>>>>>>>>// Public Const SE_ERR_ACCESSDENIED = 5
85947>>>>>>>>>>>>>// Public Const SE_ERR_ASSOCINCOMPLETE = 27
85947>>>>>>>>>>>>>// Public Const SE_ERR_DDEBUSY = 30
85947>>>>>>>>>>>>>// Public Const SE_ERR_DDEFAIL = 29
85947>>>>>>>>>>>>>// Public Const SE_ERR_DDETIMEOUT = 28
85947>>>>>>>>>>>>>// Public Const SE_ERR_DLLNOTFOUND = 32
85947>>>>>>>>>>>>>// Public Const SE_ERR_FNF = 2
85947>>>>>>>>>>>>>// Public Const SE_ERR_NOASSOC = 31
85947>>>>>>>>>>>>>// Public Const SE_ERR_OOM = 8
85947>>>>>>>>>>>>>// Public Const SE_ERR_PNF = 3
85947>>>>>>>>>>>>>// Public Const SE_ERR_SHARE = 26
85947>>>>>>>>>>>>>
85947>>>>>>>>>>>>>
85947>>>>>>>>>>>>>
85947>>>>>>>>>>>>>// Code to open the program that is associated with the selected file.
85947>>>>>>>>>>>>>//
85947>>>>>>>>>>>>>// External function call used in Procedure DoStartDocument
85947>>>>>>>>>>>>>External_function vWin32_ShellExecute "ShellExecuteA" shell32.dll ;  Handle hWnd ;  Pointer lpOperation ;  Pointer lpFile ;  Pointer lpParameters ;  Pointer lpDirectory ;  Dword iShowCmd Returns Handle
85948>>>>>>>>>>>>>
85948>>>>>>>>>>>>>
85948>>>>>>>>>>>>>
85948>>>>>>>>>>>>>
85948>>>>>>>>>>>>>
85948>>>>>>>>>>>>>                                          // Must be freed using SHFreeNameMappings
85948>>>>>>>>>>>>>
85948>>>>>>>>>>>>>Type vtShFileOpStruct
85948>>>>>>>>>>>>>  Field vtShFileOpStruct.hWnd                   as Handle
85948>>>>>>>>>>>>>  Field vtShFileOpStruct.wFunc                  as Integer
85948>>>>>>>>>>>>>  Field vtShFileOpStruct.pFrom                  as Pointer
85948>>>>>>>>>>>>>  Field vtShFileOpStruct.pTo                    as Pointer
85948>>>>>>>>>>>>>  Field vtShFileOpStruct.fFlags                 as Short
85948>>>>>>>>>>>>>  Field vtShFileOpStruct.fAnyOperationsAborted  as Short
85948>>>>>>>>>>>>>  Field vtShFileOpStruct.hNameMappings          as Pointer
85948>>>>>>>>>>>>>  Field vtShFileOpStruct.lpszProgressTitle      as Pointer // only used if FOF_SIMPLEPROGRESS
85948>>>>>>>>>>>>>End_Type // tShFileOpStruct
85948>>>>>>>>>>>>>
85948>>>>>>>>>>>>>// hwnd
85948>>>>>>>>>>>>>//   Handle of the dialog box to use to display information about the status of the operation.
85948>>>>>>>>>>>>>
85948>>>>>>>>>>>>>// wFunc
85948>>>>>>>>>>>>>//   Operation to perform. This member can be one of the following values:
85948>>>>>>>>>>>>>//     FO_COPY     Copies the files specified by pFrom to the location specified by pTo.
85948>>>>>>>>>>>>>//     FO_DELETE   Deletes the files specified by pFrom (pTo is ignored).
85948>>>>>>>>>>>>>//     FO_MOVE     Moves the files specified by pFrom to the location specified by pTo.
85948>>>>>>>>>>>>>//     FO_RENAME   Renames the files specified by pFrom.
85948>>>>>>>>>>>>>
85948>>>>>>>>>>>>>// pFrom
85948>>>>>>>>>>>>>//   Pointer to a buffer that specifies one or more source file names. Multiple names must
85948>>>>>>>>>>>>>//   be null-separated. The list of names must be double null-terminated.
85948>>>>>>>>>>>>>
85948>>>>>>>>>>>>>// pTo
85948>>>>>>>>>>>>>//   Pointer to a buffer that contains the name of the destination file or directory. The
85948>>>>>>>>>>>>>//   buffer can contain mutiple destination file names if the fFlags member specifies
85948>>>>>>>>>>>>>//   FOF_MULTIDESTFILES. Multiple names must be null-separated. The list of names must be
85948>>>>>>>>>>>>>//   double null-terminated.
85948>>>>>>>>>>>>>
85948>>>>>>>>>>>>>// fAnyOperationsAborted
85948>>>>>>>>>>>>>//   Value that receives TRUE if the user aborted any file operations before they
85948>>>>>>>>>>>>>//   were completed or FALSE otherwise.
85948>>>>>>>>>>>>>
85948>>>>>>>>>>>>>
85948>>>>>>>>>>>>>// Performs a copy, move, rename, or delete operation on a file system object.
85948>>>>>>>>>>>>>// This can be a file or a folder.
85948>>>>>>>>>>>>>// With thanks to Andrew S Kaplan
85948>>>>>>>>>>>>>External_function vWin32_SHFileOperation "SHFileOperationA" Shell32.dll ;        Pointer lpFileOp Returns Integer
85949>>>>>>>>>>>>>
85949>>>>>>>>>>>>>
85949>>>>>>>>>>>>>// Thanks To Oliver Nelson for posting this code on the newsgroups
85949>>>>>>>>>>>>>External_function vWin32_GetWindowsDirectory "GetWindowsDirectoryA" kernel32.dll ;                           Pointer lpBuffer Integer nSize Returns Integer
85950>>>>>>>>>>>>>
85950>>>>>>>>>>>>>
85950>>>>>>>>>>>>>
85950>>>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
85950>>>>>>>>>>>>>//External_Function vWin32_GetTempFileName "GetTempFileNameA" Kernel32.Dll ;
85950>>>>>>>>>>>>>//   Pointer lpPathName ;
85950>>>>>>>>>>>>>//   Pointer lpPrefixString ;
85950>>>>>>>>>>>>>//   Integer uUnique ;
85950>>>>>>>>>>>>>//   Pointer lpTempFileName ;
85950>>>>>>>>>>>>>//   Returns Integer
85950>>>>>>>>>>>>>// **WvA: 28-04-2005 Changed string parameter type into pointers
85950>>>>>>>>>>>>>External_function vWin32_GetTempFileName "GetTempFileNameA" kernel32.dll Pointer lpsPath ;        Pointer lpsPrefix Integer iUnique Pointer pLoad Returns Integer
85951>>>>>>>>>>>>>
85951>>>>>>>>>>>>>External_function vWin32_GetTempPath "GetTempPathA" Kernel32.Dll ;   Dword nBufferLength ;   Pointer lpBuffer ;   Returns Integer
85952>>>>>>>>>>>>>
85952>>>>>>>>>>>>>External_function vWin32_DeleteFile "DeleteFileA" Kernel32.Dll ;   Pointer lpFileName ;   Returns Integer
85953>>>>>>>>>>>>>                  
85953>>>>>>>>>>>>>// from:
85953>>>>>>>>>>>>>// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/shell/reference/enums/csidl.asp
85953>>>>>>>>>>>>>//
85953>>>>>>>>>>>>>Define vCSIDL_FLAG_CREATE       For |CI$8000 // IE5+, use this to create a special folder
85953>>>>>>>>>>>>>Define vCSIDL_ADMIN_TOOLS       For |CI$0030 // IE5+, The file system directory that is used to store administrative tools for an individual user
85953>>>>>>>>>>>>>Define vCSIDL_ALT_STARTUP       For |CI$001D // The file system directory that corresponds to the user's nonlocalized Startup program group
85953>>>>>>>>>>>>>Define vCSIDL_APPDATA           For |CI$001A // Version 4.71. The file system directory that serves as a common repository for application-specific data. A typical path is C:\Documents and Settings\<username>\Application Data
85953>>>>>>>>>>>>>Define vCSIDL_BITBUCKET         For |CI$000A // The virtual folder containing the objects in the user's Recycle Bin
85953>>>>>>>>>>>>>Define vCSIDL_CDBURN_AREA       For |CI$003B // IE6+ The file system directory acting as a staging area for files waiting to be written to CD. A typical path is C:\Documents and Settings\<username>\Local Settings\Application Data\Microsoft\CD Burning
85953>>>>>>>>>>>>>Define vCSIDL_COMMON_ADMINTOOLS For |CI$002F // IE5+ The file system directory containing administrative tools for all users of the computer
85953>>>>>>>>>>>>>Define vCSIDL_COMMON_ALTSTARTUP For |CI$001E // The file system directory that corresponds to the nonlocalized Startup program group for all users
85953>>>>>>>>>>>>>Define vCSIDL_COMMON_APPDATA    For |CI$0023 // IE5+ The file system directory containing application data for all users. A typical path is C:\Documents and Settings\All Users\Application Data
85953>>>>>>>>>>>>>Define vCSIDL_COMMON_DESKTOPDIRECTORY for |CI$0019 // WinNT+ Only, The file system directory that contains files and folders that appear on the desktop for all users. A typical path is C:\Documents and Settings\All Users\Desktop
85953>>>>>>>>>>>>>Define vCSIDL_COMMON_DOCUMENTS  For |CI$002E // IE5+ The file system directory that contains documents that are common to all users. A typical paths is C:\Documents and Settings\All Users\Documents
85953>>>>>>>>>>>>>Define vCSIDL_COMMON_FAVORITES  For |CI$001F // The file system directory that serves as a common repository for favorite items common to all users
85953>>>>>>>>>>>>>Define vCSIDL_COMMON_MUSIC      For |CI$0035 // IE6+ The file system directory that serves as a repository for music files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Music
85953>>>>>>>>>>>>>Define vCSIDL_COMMON_PICTURES   For |CI$0036 // The file system directory that serves as a repository for image files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Pictures
85953>>>>>>>>>>>>>Define vCSIDL_COMMON_PROGRAMS   For |CI$0017 // WinNT+ The file system directory that contains the directories for the common program groups that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs
85953>>>>>>>>>>>>>Define vCSIDL_COMMON_STARTMENU  For |CI$0016 // WinNT+ The file system directory that contains the programs and folders that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu
85953>>>>>>>>>>>>>Define vCSIDL_COMMON_STARTUP    For |CI$0018 // WinNT+ The file system directory that contains the programs that appear in the Startup folder for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs\Startup
85953>>>>>>>>>>>>>Define vCSIDL_COMMON_TEMPLATES  For |CI$002D // WinNT+ The file system directory that contains the templates that are available to all users. A typical path is C:\Documents and Settings\All Users\Templates
85953>>>>>>>>>>>>>Define vCSIDL_COMMON_VIDEO      For |CI$0037 // IE6+ The file system directory that serves as a repository for video files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Videos
85953>>>>>>>>>>>>>Define vCSIDL_COMPUTERSNEARME   For |CI$003D // The folder representing other machines in your workgroup
85953>>>>>>>>>>>>>Define vCSIDL_CONNECTIONS       For |CI$0031 // The virtual folder representing Network Connections, containing network and dial-up connections
85953>>>>>>>>>>>>>Define vCSIDL_CONTROLS          For |CI$0003 // The virtual folder containing icons for the Control Panel applications
85953>>>>>>>>>>>>>Define vCSIDL_COOKIES           For |CI$0021 // The file system directory that serves as a common repository for Internet cookies. A typical path is C:\Documents and Settings\username\Cookies
85953>>>>>>>>>>>>>Define vCSIDL_DESKTOP           For |CI$0000 // The virtual folder representing the Windows desktop, the root of the namespace
85953>>>>>>>>>>>>>Define vCSIDL_DESKTOPDIRECTORY  For |CI$0010 // The file system directory used to physically store file objects on the desktop (not to be confused with the desktop folder itself). A typical path is C:\Documents and Settings\username\Desktop
85953>>>>>>>>>>>>>Define vCSIDL_DRIVES            For |CI$0011 // The virtual folder representing My Computer, containing everything on the local computer: storage devices, printers, and Control Panel. The folder may also contain mapped network drives
85953>>>>>>>>>>>>>Define vCSIDL_FAVORITES         For |CI$0006 // The file system directory that serves as a common repository for the user's favorite items. A typical path is C:\Documents and Settings\username\Favorites
85953>>>>>>>>>>>>>Define vCSIDL_FONTS             For |CI$0014 // A virtual folder containing fonts. A typical path is C:\Windows\Fonts
85953>>>>>>>>>>>>>Define vCSIDL_HISTORY           For |CI$0022 // The file system directory that serves as a common repository for Internet history items
85953>>>>>>>>>>>>>Define vCSIDL_INTERNET          For |CI$0001 // A virtual folder representing the Internet
85953>>>>>>>>>>>>>Define vCSIDL_INTERNET_CACHE    For |CI$0020 // Comctl4.72+, The file system directory that serves as a common repository for temporary Internet files. A typical path is C:\Documents and Settings\username\Local Settings\Temporary Internet Files
85953>>>>>>>>>>>>>Define vCSIDL_LOCAL_APPDATA     For |CI$001C // IE5+ The file system directory that serves as a data repository for local (nonroaming) applications. A typical path is C:\Documents and Settings\username\Local Settings\Application Data
85953>>>>>>>>>>>>>Define vCSIDL_MYDOCUMENTS       For |CI$000C // IE6+ The virtual folder representing the My Documents desktop item
85953>>>>>>>>>>>>>Define vCSIDL_MYMUSIC           For |CI$000D // The file system directory that serves as a common repository for music files. A typical path is C:\Documents and Settings\User\My Documents\My Music
85953>>>>>>>>>>>>>Define vCSIDL_MYPICTURES        For |CI$0027 // IE5+ The file system directory that serves as a common repository for image files. A typical path is C:\Documents and Settings\username\My Documents\My Pictures
85953>>>>>>>>>>>>>Define vCSIDL_MYVIDEO           For |CI$000E // IE6+ The file system directory that serves as a common repository for video files. A typical path is C:\Documents and Settings\username\My Documents\My Videos
85953>>>>>>>>>>>>>Define vCSIDL_NETHOOD           For |CI$0013 // A file system directory containing the link objects that may exist in the My Network Places virtual folder. It is not the same as CSIDL_NETWORK, which represents the network namespace root. A typical path is C:\Documents and Settings\username\NetHood
85953>>>>>>>>>>>>>Define vCSIDL_NETWORK           For |CI$0012 // A virtual folder representing Network Neighborhood, the root of the network namespace hierarchy
85953>>>>>>>>>>>>>Define vCSIDL_PERSONAL          For |CI$0005 // (Documents folder) IE6 The virtual folder representing the My Documents desktop item.
85953>>>>>>>>>>>>>                                             // This is equivalent to CSIDL_MYDOCUMENTS. Previous to Version 6.0. The file system directory used to physically store a user's common repository of documents. A typical path is C:\Documents and Settings\username\My Documents
85953>>>>>>>>>>>>>Define vCSIDL_PHOTOALBUMS       For |CI$0045 // Vista+ The virtual folder used to store photo albums, typically username\My Pictures\Photo Albums
85953>>>>>>>>>>>>>Define vCSIDL_PLAYLISTS         For |CI$003F // Vista+ The virtual folder used to store play albums, typically username\My Music\Playlists
85953>>>>>>>>>>>>>Define vCSIDL_PRINTERS          For |CI$0004 // The virtual folder containing installed printers
85953>>>>>>>>>>>>>Define vCSIDL_PRINTHOOD         For |CI$001B // The file system directory that contains the link objects that can exist in the Printers virtual folder. A typical path is C:\Documents and Settings\username\PrintHood
85953>>>>>>>>>>>>>Define vCSIDL_PROFILE           For |CI$0028 // IE5+ The user's profile folder. A typical path is C:\Documents and Settings\username
85953>>>>>>>>>>>>>Define vCSIDL_PROGRAM_FILES     For |CI$0026 // IE5+ The Program Files folder. A typical path is C:\Program Files
85953>>>>>>>>>>>>>Define vCSIDL_PROGRAM_FILESx86  for |CI$002A // The Program Files folder for x86 programs. A typical path is C:\Program Files (x86)
85953>>>>>>>>>>>>>Define vCSIDL_PROGRAM_FILES_COMMON For |CI$002B // IE5+, WinNT+ A folder for components that are shared across applications. A typical path is C:\Program Files\Common
85953>>>>>>>>>>>>>Define vCSIDL_PROGRAMS          For |CI$0002 // The file system directory that contains the user's program groups (which are themselves file system directories). A typical path is C:\Documents and Settings\username\Start Menu\Programs
85953>>>>>>>>>>>>>Define vCSIDL_RECENT            For |CI$0008 // The file system directory that contains shortcuts to the user's most recently used documents. A typical path is C:\Documents and Settings\username\My Recent Documents
85953>>>>>>>>>>>>>Define vCSIDL_RESOURCES         For |CI$0038 // undocumented
85953>>>>>>>>>>>>>Define vCSIDL_SAMPLE_MUSIC      For |CI$0040 // Vista+, The file system directory that contains sample music. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Music
85953>>>>>>>>>>>>>Define vCSIDL_SAMPLE_PLAYLISTS  For |CI$0041 // Vista+, The file system directory that contains sample playlists. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Playlists
85953>>>>>>>>>>>>>Define vCSIDL_SAMPLE_PICTURES   For |CI$0042 // Vista+, The file system directory that contains sample pictures. A typical path is C:\Documents and Settings\username\My Documents\My Pictures\Sample Pictures
85953>>>>>>>>>>>>>Define vCSIDL_SAMPLE_VIDEOS     For |CI$0043 // Vista+, The file system directory that contains sample videos. A typical path is C:\Documents and Settings\username\My Documents\My Videos\Sample Videos
85953>>>>>>>>>>>>>Define vCSIDL_SENDTO            For |CI$0009 // The file system directory that contains Send To menu items. A typical path is C:\Documents and Settings\username\SendTo
85953>>>>>>>>>>>>>Define vCSIDL_STARTMENU         For |CI$000B // The file system directory containing Start menu items. A typical path is C:\Documents and Settings\username\Start Menu
85953>>>>>>>>>>>>>Define vCSIDL_STARTUP           For |CI$0007 // The file system directory that corresponds to the user's Startup program group. The system starts these programs whenever any user logs onto Windows NT or starts Windows 95. A typical path is C:\Documents and Settings\username\Start Menu\Programs\Startup
85953>>>>>>>>>>>>>Define vCSIDL_SYSTEM            For |CI$0025 // The Windows System folder. A typical path is C:\Windows\System32
85953>>>>>>>>>>>>>Define vCSIDL_SYSTEMX86         For |CI$0029 //
85953>>>>>>>>>>>>>Define vCSIDL_TEMPLATES         For |CI$0015 // The file system directory that serves as a common repository for document templates. A typical path is C:\Documents and Settings\username\Templates
85953>>>>>>>>>>>>>Define vCSIDL_WINDOWS           For |CI$0024 // The Windows directory or SYSROOT. This corresponds to the %windir% or %SYSTEMROOT% environment variables. A typical path is C:\Windows
85953>>>>>>>>>>>>>
85953>>>>>>>>>>>>>
85953>>>>>>>>>>>>>//HRESULT SHGetFolderPath(
85953>>>>>>>>>>>>>//    HWND hwndOwner,
85953>>>>>>>>>>>>>//    int nFolder,
85953>>>>>>>>>>>>>//    HANDLE hToken,
85953>>>>>>>>>>>>>//    DWORD dwFlags,
85953>>>>>>>>>>>>>//    LPTSTR pszPath
85953>>>>>>>>>>>>>//);
85953>>>>>>>>>>>>>// This function is a superset of SHGetSpecialFolderPath, included with earlier versions of
85953>>>>>>>>>>>>>// the shell. It is implemented in a redistributable DLL, SHFolder.dll, that also simulates
85953>>>>>>>>>>>>>// many of the new shell folders on older platforms such as Windows 95, Windows 98, and
85953>>>>>>>>>>>>>// Windows NT 4.0. This DLL always calls the current platform's version of this function.
85953>>>>>>>>>>>>>// If that fails, it will try to simulate the appropriate behavior.
85953>>>>>>>>>>>>>//
85953>>>>>>>>>>>>>External_function vWin32_SHGetFolderPath "SHGetFolderPathA" SHFolder.Dll ;   Pointer hWnd ;   Integer nFolder ;   Pointer hToken ;   DWord   dwFlags ;   Pointer lpszPath ;   Returns Integer
85954>>>>>>>>>>>>>
85954>>>>>>>>>>>>>
85954>>>>>>>>>>>>>
85954>>>>>>>>>>>>>Type vWin32_Find_Data
85954>>>>>>>>>>>>>  Field vWin32_Find_Data.dwFileAttributes As Dword
85954>>>>>>>>>>>>>  Field vWin32_Find_Data.ftCreationLowDateTime As Dword
85954>>>>>>>>>>>>>  Field vWin32_Find_Data.ftCreationHighDateTime As Dword
85954>>>>>>>>>>>>>  Field vWin32_Find_Data.ftLastAccessLowDateTime As dword
85954>>>>>>>>>>>>>  Field vWin32_Find_Data.ftLastAccessHighDateTime As Dword
85954>>>>>>>>>>>>>  Field vWin32_Find_Data.ftLastWriteLowDateTime As Dword
85954>>>>>>>>>>>>>  Field vWin32_Find_Data.ftLastWriteHighDateTime As Dword
85954>>>>>>>>>>>>>  Field vWin32_Find_Data.nFileSizeHigh As Dword
85954>>>>>>>>>>>>>  Field vWin32_Find_Data.nFileSizeLow As Dword
85954>>>>>>>>>>>>>  Field vWin32_Find_Data.dwReserved0 As Dword
85954>>>>>>>>>>>>>  Field vWin32_Find_Data.dwReserved1 As Dword
85954>>>>>>>>>>>>>  Field vWin32_Find_Data.cFileName As Char vMax_Path
85954>>>>>>>>>>>>>  Field vWin32_Find_Data.cAlternateFileName As Char 14
85954>>>>>>>>>>>>>End_Type // vWin32_Find_Data
85954>>>>>>>>>>>>>
85954>>>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
85954>>>>>>>>>>>>>// lpFileName      : address of name of file to search for
85954>>>>>>>>>>>>>// lpFindFileData  : address of returned information
85954>>>>>>>>>>>>>External_function vWin32_FindFirstFile "FindFirstFileA"  Kernel32.dll Pointer lpFileName ;          Pointer lpFindFileData Returns Handle
85955>>>>>>>>>>>>>
85955>>>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
85955>>>>>>>>>>>>>// hFindFile       : handle of search
85955>>>>>>>>>>>>>// lpFindFileData  : address of structure for data on found file
85955>>>>>>>>>>>>>External_function vWin32_FindNextFile "FindNextFileA" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
85956>>>>>>>>>>>>>
85956>>>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
85956>>>>>>>>>>>>>//  hFindFile      : file search handle
85956>>>>>>>>>>>>>External_function vWin32_FindClose "FindClose" Kernel32.dll Handle hFindFile Returns Integer
85957>>>>>>>>>>>>>
85957>>>>>>>>>>>>>
85957>>>>>>>>>>>>>
85957>>>>>>>>>>>>>Type vFileTime
85957>>>>>>>>>>>>>  Field vFileTime.dwLowDateTime As Dword
85957>>>>>>>>>>>>>  Field vFileTime.dwHighDateTime As Dword
85957>>>>>>>>>>>>>End_Type // vFileTime
85957>>>>>>>>>>>>>
85957>>>>>>>>>>>>>
85957>>>>>>>>>>>>>Type vSystemTime
85957>>>>>>>>>>>>>  Field vSystemTime.wYear As Word
85957>>>>>>>>>>>>>  Field vSystemTime.wMonth As Word
85957>>>>>>>>>>>>>  Field vSystemTime.wDayOfWeek As Word
85957>>>>>>>>>>>>>  Field vSystemTime.wDay As Word
85957>>>>>>>>>>>>>  Field vSystemTime.wHour As Word
85957>>>>>>>>>>>>>  Field vSystemTime.wMinute As Word
85957>>>>>>>>>>>>>  Field vSystemTime.wSecond As Word
85957>>>>>>>>>>>>>  Field vSystemTime.wMilliSeconds As Word
85957>>>>>>>>>>>>>End_Type // vSystemTime
85957>>>>>>>>>>>>>
85957>>>>>>>>>>>>>
85957>>>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
85957>>>>>>>>>>>>>//  lpFileTime     : pointer to file time to convert
85957>>>>>>>>>>>>>//  lpSystemTime   : pointer to structure to receive system time
85957>>>>>>>>>>>>>External_function vWin32_FileTimeToSystemTime "FileTimeToSystemTime" Kernel32.Dll ;          Pointer lpFileTime Pointer lpsystemTime Returns Integer
85958>>>>>>>>>>>>>
85958>>>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
85958>>>>>>>>>>>>>// This function formats the time in a picture-string passed
85958>>>>>>>>>>>>>//
85958>>>>>>>>>>>>>// Picture      Meaning
85958>>>>>>>>>>>>>//    h         Hours with no leading zero for single-digit hours; 12-hour clock
85958>>>>>>>>>>>>>//    hh        Hours with leading zero for single-digit hours; 12-hour clock
85958>>>>>>>>>>>>>//    H         Hours with no leading zero for single-digit hours; 24-hour clock
85958>>>>>>>>>>>>>//    HH        Hours with leading zero for single-digit hours; 24-hour clock
85958>>>>>>>>>>>>>//    m         Minutes with no leading zero for single-digit minutes
85958>>>>>>>>>>>>>//    mm        Minutes with leading zero for single-digit minutes
85958>>>>>>>>>>>>>//    s         Seconds with no leading zero for single-digit seconds
85958>>>>>>>>>>>>>//    ss        Seconds with leading zero for single-digit seconds
85958>>>>>>>>>>>>>//    t         One character time marker string, such as A or P
85958>>>>>>>>>>>>>//    tt        Multicharacter time marker string, such as AM or PM
85958>>>>>>>>>>>>>//
85958>>>>>>>>>>>>>// For example, to get the time string  "11:29:40 PM"
85958>>>>>>>>>>>>>//    use the following picture string: "hh" : "mm" : "ss tt"
85958>>>>>>>>>>>>>
85958>>>>>>>>>>>>>External_function vWin32_GetTimeFormat "GetTimeFormatA" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpTimeStr ;  Integer cchTime Returns Integer
85959>>>>>>>>>>>>>
85959>>>>>>>>>>>>>
85959>>>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
85959>>>>>>>>>>>>>// This function formats the date in a picture-string passed
85959>>>>>>>>>>>>>//
85959>>>>>>>>>>>>>// Picture      Meaning
85959>>>>>>>>>>>>>//    d         Day of month as digits with no leading zero for single-digit days.
85959>>>>>>>>>>>>>//    dd        Day of month as digits with leading zero for single-digit days.
85959>>>>>>>>>>>>>//    ddd       Day of week as a three-letter abbreviation. The function uses the
85959>>>>>>>>>>>>>//              LOCALE_SABBREVOAYMAME value associated with the specified locale.
85959>>>>>>>>>>>>>//    dddd      Day of week as its full name. The function uses the LOCALE_SDAYNAME
85959>>>>>>>>>>>>>//              value associated with the specified locale.
85959>>>>>>>>>>>>>//    M         Month as digits with no leading zero for single-digit months.
85959>>>>>>>>>>>>>//    MM        Month as digits with leading zero for single-digit months.
85959>>>>>>>>>>>>>//    MMM       Month as a three-letter abbreviation. The function uses the
85959>>>>>>>>>>>>>//              LOCALE_SABBREVMONTHNAME value associated with the specified locale.
85959>>>>>>>>>>>>>//    MMMM      Month as its full name. The function uses the LOCALE_SMONTHNAME value
85959>>>>>>>>>>>>>//              associated with the specified locale.
85959>>>>>>>>>>>>>//    y         Year as last two digits, but with no leading zero for years less than 10.
85959>>>>>>>>>>>>>//    yy        Year as last two digits, but with leading zero for years less than 10.
85959>>>>>>>>>>>>>//    yyyy      Year represented hy full four digits.
85959>>>>>>>>>>>>>//    gg        Period/era string. The function uses the CAL_SERASTRING value associated
85959>>>>>>>>>>>>>//              with the specified locale. This element is ignored if the date to be formatted
85959>>>>>>>>>>>>>//              does not have an associated era or period string.
85959>>>>>>>>>>>>>// For example, to get the date string  "Wed, Aug 31 94"
85959>>>>>>>>>>>>>// use the following picture string:    "ddd","MMM dd yy"
85959>>>>>>>>>>>>>
85959>>>>>>>>>>>>>External_function vWin32_GetDateFormat "GetDateFormatA" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpDateStr ;  Integer cchDate Returns Integer
85960>>>>>>>>>>>>>
85960>>>>>>>>>>>>>Define LOCALE_NOUSEROVERRIDE    For |CI$80000000  //  do not use user overrides
85960>>>>>>>>>>>>>Define TIME_NOMIHUTESORSECONDS  For |CI$0000000l  //  do not use minutes or seconds
85960>>>>>>>>>>>>>Define TIME_NOSECONDS           For |CI$00000002  //  do not use seconds
85960>>>>>>>>>>>>>Define TIME_NOTIMEMARKER        For |CI$00000004  //  do not use time marker
85960>>>>>>>>>>>>>Define TIME_FORCE24HOURFORMAT   For |CI$00000008  //  always use 24 hour format
85960>>>>>>>>>>>>>
85960>>>>>>>>>>>>>//  Date Flags for GetDateFormatW.
85960>>>>>>>>>>>>>//
85960>>>>>>>>>>>>>Define DATE_SHORTDATE           For |CI$0000000l  //  use short date picture
85960>>>>>>>>>>>>>Define DATE_LONGDATE            For |CI$00000002  //  use long date picture
85960>>>>>>>>>>>>>Define DATE_USE_ALT_CALENDAR    For |CI$00000004  //  use alternate calendar (if any)
85960>>>>>>>>>>>>>
85960>>>>>>>>>>>>>
85960>>>>>>>>>>>>>External_function vWin32_SetLastError "SetLastError" Kernel32.Dll Dword dwLastError Returns Integer
85961>>>>>>>>>>>>>
85961>>>>>>>>>>>>>
85961>>>>>>>>>>>>>// **WvA: 20-02-2004
85961>>>>>>>>>>>>>// While i was testing the format capabilities i stumbled over a very
85961>>>>>>>>>>>>>// weird problem where it looks like that the integer value gets somehow translated
85961>>>>>>>>>>>>>// incorrectly into an unsigned integer.
85961>>>>>>>>>>>>>// I don't have the time to dive into this.. so added a workaround (and removed it again)
85961>>>>>>>>>>>>>// It does smell a bit fishy though
85961>>>>>>>>>>>>>// Tested it with the same results on both VDF7 and VDF9.1
85961>>>>>>>>>>>>>
85961>>>>>>>>>>>>>Define SHFMT_ID_DEFAULT        For |CI$0000FFFF // The default format ID
85961>>>>>>>>>>>>>Define SHFMT_OPT_DEFAULT       For |CI$00000000 // The default "Quick Format" option.
85961>>>>>>>>>>>>>Define SHFMT_OPT_FULL          For |CI$00000001 // Deselects the "Quick Format" option, providing a full format instead. This is useful when an unformatted disk is detected.
85961>>>>>>>>>>>>>Define SHFMT_OPT_SYSONLY       For |CI$00000002 // Selects the "Create an MS-DOS startup disk" option, creating a system boot disk.
85961>>>>>>>>>>>>>
85961>>>>>>>>>>>>>// Possible errors that can be returned by the shellformat function
85961>>>>>>>>>>>>>Define SHFMT_ERROR             For (|CI$FFFFFFFF+1) // An error occurred during the last format or no drive parameter passed. This does not indicate that the disk is unformatable.
85961>>>>>>>>>>>>>Define SHFMT_CANCEL            For (|CI$FFFFFFFE+1) // The last format was canceled.
85961>>>>>>>>>>>>>Define SHFMT_NOFORMAT          For (|CI$FFFFFFFD+1) // The drive cannot be formatted.
85961>>>>>>>>>>>>>                                                
85961>>>>>>>>>>>>>
85961>>>>>>>>>>>>> // Courtesy Of Steve Walter,
85961>>>>>>>>>>>>> // USA Software, Inc
85961>>>>>>>>>>>>> // Format a disk
85961>>>>>>>>>>>>> // Called By:  Move (vWin32_ShFormatDrive(hWnd,0,$FFFF,1)) To dwReturn
85961>>>>>>>>>>>>>External_function vWin32_ShFormatDrive "SHFormatDrive" shell32.dll Handle hWnd ;         Integer iDrive Integer iFormatID Integer iOptions Returns DWORD
85962>>>>>>>>>>>>>
85962>>>>>>>>>>>>>// Michael Mullan.  I Wanted to create all the folders in one statement...
85962>>>>>>>>>>>>>
85962>>>>>>>>>>>>>// SHCreateDirectoryEx
85962>>>>>>>>>>>>>
85962>>>>>>>>>>>>>//    Note  This function is available through Microsoft Windows XP Service Pack 2 (SP2) and Windows Server 2003.
85962>>>>>>>>>>>>>//    It might be altered or unavailable in subsequent versions of Windows.
85962>>>>>>>>>>>>>//
85962>>>>>>>>>>>>>//    This function creates a file system folder whose fully qualified path is given by pszPath. If one or more
85962>>>>>>>>>>>>>//    of the intermediate folders do not exist, they are created as well. SHCreateDirectoryEx also verifies that
85962>>>>>>>>>>>>>//    the files are visible. If they are not visible, expect one of the following:
85962>>>>>>>>>>>>>//
85962>>>>>>>>>>>>>//        * If hwnd is set to a valid window handle, a message box is displayed warning the user that he or she
85962>>>>>>>>>>>>>//        might not be able to access the files. If the user chooses not to proceed, the function returns
85962>>>>>>>>>>>>>//        ERROR_CANCELLED.
85962>>>>>>>>>>>>>//        * If hwnd is set to NULL, no user interface is displayed and the function returns ERROR_CANCELLED.
85962>>>>>>>>>>>>>
85962>>>>>>>>>>>>>//        Returns ERROR_SUCCESS if successful. If the operation fails, other error codes can be returned,
85962>>>>>>>>>>>>>//        including those listed here. For values not specifically listed, see System Error Codes.
85962>>>>>>>>>>>>>//      161  ERROR_BAD_PATHNAME                The pszPath parameter was set to a relative path.
85962>>>>>>>>>>>>>//      206  ERROR_FILENAME_EXCED_RANGE     The path pointed to by pszPath is too long.
85962>>>>>>>>>>>>>//      3    ERROR_PATH_NOT_FOUND            The system cannot find the path pointed to by pszPath. The path may contain an invalid entry.
85962>>>>>>>>>>>>>//      80   ERROR_FILE_EXISTS                The directory exists.
85962>>>>>>>>>>>>>//      183  ERROR_ALREADY_EXISTS            The directory exists.
85962>>>>>>>>>>>>>//      1223 ERROR_CANCELLED                The user canceled the operation.
85962>>>>>>>>>>>>>
85962>>>>>>>>>>>>>//        int SHCreateDirectoryEx(
85962>>>>>>>>>>>>>//            HWND hwnd,
85962>>>>>>>>>>>>>//            LPCTSTR pszPath,
85962>>>>>>>>>>>>>//            const SECURITY_ATTRIBUTES *psa
85962>>>>>>>>>>>>>//        );
85962>>>>>>>>>>>>>
85962>>>>>>>>>>>>>External_function vWin32_SHCreateDirectoryEx "SHCreateDirectoryExA" shell32.dll Handle hWnd;                  pointer pszPath  Pointer lpSecurity_Attributes Returns Integer
85963>>>>>>>>>>>
85963>>>>>>>>>>>
85963>>>>>>>>>>>
85963>>>>>>>>>>>
85963>>>>>>>>>>>
85963>>>>>>>>>>>//
85963>>>>>>>>>>>// Gets the string from the right of the last sStopChar in sFrom
85963>>>>>>>>>>>// If sStopChar has no occurences in the string an empty string is
85963>>>>>>>>>>>// returned.
85963>>>>>>>>>>>Function StringFromRightOfChar Global String sFrom String sStopChar Returns String
85965>>>>>>>>>>>  String  sRetVal
85965>>>>>>>>>>>  String  sChar
85965>>>>>>>>>>>  Integer iLength
85965>>>>>>>>>>>  Integer iPos
85965>>>>>>>>>>>  Boolean bStopChar
85965>>>>>>>>>>>  Move "" To sRetval
85966>>>>>>>>>>>  Move (Length(sFrom)) To iLength
85967>>>>>>>>>>>  If ((iLength>0) And (Pos(sStopChar,sFrom) <> 0)) Begin
85969>>>>>>>>>>>    Move iLength   To iPos
85970>>>>>>>>>>>    Move (False)   To bStopChar
85971>>>>>>>>>>>    While Not bStopChar
85975>>>>>>>>>>>      Move (Mid(sFrom,1,iPos)) To sChar
85976>>>>>>>>>>>      Decrement iPos
85977>>>>>>>>>>>      If ((sChar=sStopChar) Or (iPos<1)) Begin
85979>>>>>>>>>>>        Move (True) To bStopChar
85980>>>>>>>>>>>      End
85980>>>>>>>>>>>>
85980>>>>>>>>>>>      Else Begin
85981>>>>>>>>>>>        Move (sChar+sRetVal) To sRetVal
85982>>>>>>>>>>>      End
85982>>>>>>>>>>>>
85982>>>>>>>>>>>    Loop
85983>>>>>>>>>>>>
85983>>>>>>>>>>>  End
85983>>>>>>>>>>>>
85983>>>>>>>>>>>  Function_Return sRetVal
85984>>>>>>>>>>>End_Function // StringFromRightOfChar
85985>>>>>>>>>>>
85985>>>>>>>>>>>
85985>>>>>>>>>>>// Pre:  sFileName contains the complete path of the file.
85985>>>>>>>>>>>// Post: returns the complete path of the file.
85985>>>>>>>>>>>// This function is inspired on function SEQ_ExtractPathFromFileName of Sture Andersen.
85985>>>>>>>>>>>Function ParseFolderName Global String sFileName Returns String
85987>>>>>>>>>>>  String sFile
85987>>>>>>>>>>>  String sFolderName
85987>>>>>>>>>>>  String sDirSep // this is "\" for windows, or "/" for unix
85987>>>>>>>>>>>  MOve "" To sFolderName
85988>>>>>>>>>>>  Move (sysconf(SYSCONF_DIR_SEPARATOR)) To sDirSep
85989>>>>>>>>>>>  If sDirSep In sFileName Begin
85991>>>>>>>>>>>    Move (StringFromRightOfChar(sFileName,sDirSep)) To sFile
85992>>>>>>>>>>>    Move (Replace(sFile,sFileName,"")) To sFolderName
85993>>>>>>>>>>>  End
85993>>>>>>>>>>>>
85993>>>>>>>>>>>  Else If ":" In sFileName Begin
85996>>>>>>>>>>>    Move (StringFromRightOfChar(sFileName,":")) To sFile
85997>>>>>>>>>>>    Move (Replace(sFile,sFileName,"")) To sFolderName
85998>>>>>>>>>>>  End
85998>>>>>>>>>>>>
85998>>>>>>>>>>>  Function_Return sFolderName
85999>>>>>>>>>>>End_Function // ParseFolderName
86000>>>>>>>>>>>
86000>>>>>>>>>>>
86000>>>>>>>>>>>// Pre:  sFileName contains the complete path of the file.
86000>>>>>>>>>>>// post: The returned filename has it's path removed, but will have a extension
86000>>>>>>>>>>>Function ParseFileName Global String sFileName Returns String
86002>>>>>>>>>>>  String sFolderName
86002>>>>>>>>>>>  String sDirSep // this is "\" for windows, or "/" for unix
86002>>>>>>>>>>>  Move (sysconf(SYSCONF_DIR_SEPARATOR)) To sDirSep
86003>>>>>>>>>>>  Get ParseFolderName sFileName To sFolderName
86004>>>>>>>>>>>  If (sFolderName <> "") Begin
86006>>>>>>>>>>>    Move (Replace(sFolderName,sFileName,"")) to sFileName
86007>>>>>>>>>>>  End
86007>>>>>>>>>>>>
86007>>>>>>>>>>>  Move (Replace(sDirSep,sFileName,"")) To sFileName
86008>>>>>>>>>>>  Function_Return sFilename
86009>>>>>>>>>>>End_Function // ParseFileName
86010>>>>>>>>>>>
86010>>>>>>>>>>>
86010>>>>>>>>>>>// Pre:  sFileName may contain the complete path of the file.
86010>>>>>>>>>>>//       or contain multiple dots in the filename, so temp.gif.bak will
86010>>>>>>>>>>>//       return "bak" as the extension and not "gif"
86010>>>>>>>>>>>// Post: returns the extension only, this extension can be a valid unixlike extension
86010>>>>>>>>>>>//       such as "html" or "java"
86010>>>>>>>>>>>Function ParseFileExtension Global String sFileName Returns String
86012>>>>>>>>>>>  String  sFileExtension
86012>>>>>>>>>>>  Get StringFromRightOfChar sFileName "." To sFileExtension
86013>>>>>>>>>>>  Function_Return sFileExtension
86014>>>>>>>>>>>End_Function // ParseFileExtension
86015>>>>>>>>>>>
86015>>>>>>>>>>>
86015>>>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
86015>>>>>>>>>>>
86015>>>>>>>>>>>
86015>>>>>>>>>>>Function DDE_Error_To_String Integer iErrorID Returns String
86018>>>>>>>>>>>  String sMessage
86018>>>>>>>>>>>  Case Begin
86018>>>>>>>>>>>    Case (iErrorID = vERROR_FILE_NOT_FOUND)
86020>>>>>>>>>>>      Move CS_DDE_ERR_FILE_NOT_FOUND To sMessage
86021>>>>>>>>>>>      Case Break
86022>>>>>>>>>>>    Case (iErrorID = vERROR_PATH_NOT_FOUND)
86025>>>>>>>>>>>      Move CS_DDE_ERR_PATH_NOT_FOUND To sMessage
86026>>>>>>>>>>>      Case Break
86027>>>>>>>>>>>    Case (iErrorID = vERROR_BAD_FORMAT)
86030>>>>>>>>>>>      Move CS_DDE_ERR_BAD_FORMAT To sMessage
86031>>>>>>>>>>>      Case Break
86032>>>>>>>>>>>    Case (iErrorID = vSE_ERR_ACCESSDENIED)
86035>>>>>>>>>>>      Move CS_DDE_ERR_ACCESSDENIED To sMessage
86036>>>>>>>>>>>      Case Break
86037>>>>>>>>>>>    Case (iErrorID = vSE_ERR_ASSOCINCOMPLETE)
86040>>>>>>>>>>>      Move CS_DDE_ERR_ASSOCINCOMPLETE To sMessage
86041>>>>>>>>>>>      Case Break
86042>>>>>>>>>>>    Case (iErrorID = vSE_ERR_DDEBUSY)
86045>>>>>>>>>>>      Move CS_DDE_ERR_DDEBUSY To sMessage
86046>>>>>>>>>>>      Case Break
86047>>>>>>>>>>>    Case (iErrorID = vSE_ERR_DDEFAIL)
86050>>>>>>>>>>>      Move CS_DDE_ERR_DDEFAIL To sMessage
86051>>>>>>>>>>>      Case Break
86052>>>>>>>>>>>    Case (iErrorID = vSE_ERR_DDETIMEOUT)
86055>>>>>>>>>>>      Move CS_DDE_ERR_DDETIMEOUT To sMessage
86056>>>>>>>>>>>      Case Break
86057>>>>>>>>>>>    Case (iErrorID = vSE_ERR_DLLNOTFOUND)
86060>>>>>>>>>>>      Move CS_DDE_ERR_DLLNOTFOUND To sMessage
86061>>>>>>>>>>>      Case Break
86062>>>>>>>>>>>    Case (iErrorID = vSE_ERR_NOASSOC)
86065>>>>>>>>>>>      Move CS_DDE_ERR_NOASSOC To sMessage
86066>>>>>>>>>>>      Case Break
86067>>>>>>>>>>>    Case ((iErrorID = vSE_ERR_OOM) Or (iErrorID = 0))
86070>>>>>>>>>>>      Move CS_DDE_ERR_OOM To sMessage
86071>>>>>>>>>>>      Case Break
86072>>>>>>>>>>>    Case (iErrorID = vSE_ERR_PNF)
86075>>>>>>>>>>>      Move CS_DDE_ERR_PNF To sMessage
86076>>>>>>>>>>>      Case Break
86077>>>>>>>>>>>    Case (iErrorID = vSE_ERR_SHARE)
86080>>>>>>>>>>>      Move CS_DDE_ERR_SHARE To sMessage
86081>>>>>>>>>>>      Case Break
86082>>>>>>>>>>>    Case Else
86082>>>>>>>>>>>      Move CS_DDE_ERR_UNKNOWN_LINE1 To sMessage
86083>>>>>>>>>>>      Move (sMessage*Trim(iErrorID)*CS_DDE_ERR_UNKNOWN_LINE2) To sMessage
86084>>>>>>>>>>>      Case Break
86085>>>>>>>>>>>  Case End
86085>>>>>>>>>>>  Function_Return sMessage
86086>>>>>>>>>>>End_Function // DDE_Error_To_String
86087>>>>>>>>>>>
86087>>>>>>>>>>>
86087>>>>>>>>>>>Procedure vDDE_Error_Handler Integer iErrorID
86090>>>>>>>>>>>  String sMessage
86090>>>>>>>>>>>  Get DDE_Error_To_String iErrorID To sMessage
86091>>>>>>>>>>>  Append sMessage CS_DDE_ERR_HANDL_PAKTC //  "Press a key to continue..."
86092>>>>>>>>>>>  Send Stop_Box sMessage CS_DDE_ERR_HANDL_CAPTION
86093>>>>>>>>>>>End_Procedure // vDDE_Error_Handler hInstance
86094>>>>>>>>>>>
86094>>>>>>>>>>>
86094>>>>>>>>>>>// Does the directory exist? - No = 0, Yes = 1
86094>>>>>>>>>>>// This also works with UNC path encoding and wildcards
86094>>>>>>>>>>>Function vFolderExists Global String sFolderName Returns Integer
86096>>>>>>>>>>>  String  sFolder sTmp
86096>>>>>>>>>>>  Integer bFolderExists iCh
86096>>>>>>>>>>>
86096>>>>>>>>>>>  // 2013-09-29 NGS Check for empty folder name and convert to ANSI
86096>>>>>>>>>>>  Move (ToANSI(Trim(sFolderName))) to sFolderName
86097>>>>>>>>>>>  If (sFolderName = "") Begin
86099>>>>>>>>>>>    Function_Return False
86100>>>>>>>>>>>  End
86100>>>>>>>>>>>>
86100>>>>>>>>>>>
86100>>>>>>>>>>>  Move dfTrue To bFolderExists
86101>>>>>>>>>>>  Move "dir:" To sFolder
86102>>>>>>>>>>>  Append sFolder sFolderName
86103>>>>>>>>>>>  Get Seq_New_Channel To iCh  // get free channel for input
86104>>>>>>>>>>>  Direct_Input Channel iCh sFolder
86106>>>>>>>>>>>    Repeat
86106>>>>>>>>>>>>
86106>>>>>>>>>>>      Readln Channel iCh sTmp
86108>>>>>>>>>>>      If (Trim(sTmp)="") Begin
86110>>>>>>>>>>>        Move False to bFolderExists
86111>>>>>>>>>>>      End
86111>>>>>>>>>>>>
86111>>>>>>>>>>>      Else Begin
86112>>>>>>>>>>>        Move True to bFolderExists
86113>>>>>>>>>>>        Move True to SeqEof // end loop
86114>>>>>>>>>>>        End
86114>>>>>>>>>>>>
86114>>>>>>>>>>>    Until (seqeof)
86116>>>>>>>>>>>  Close_Input Channel iCh
86118>>>>>>>>>>>  Send Seq_Release_Channel iCh
86119>>>>>>>>>>>  Function_Return bFolderExists
86120>>>>>>>>>>>End_Function  // vFolderExists
86121>>>>>>>>>>>
86121>>>>>>>>>>>
86121>>>>>>>>>>>// returns folder name if a folder was selected, otherwise returns ""
86121>>>>>>>>>>>Function vSHBrowseForFolder Global String sDialogTitle Returns String
86123>>>>>>>>>>>  String sFolder sBrowseInfo sTitle
86123>>>>>>>>>>>  Pointer lpItemIdList lpsFolder lpsBrowseInfo lpsTitle
86123>>>>>>>>>>>  Integer iFolderSelected iRetval
86123>>>>>>>>>>>
86123>>>>>>>>>>>  // fill string variable with null characters
86123>>>>>>>>>>>  ZeroType vtBrowseInfo To sBrowseInfo
86124>>>>>>>>>>>
86124>>>>>>>>>>>  If (sDialogTitle<>"") Begin
86126>>>>>>>>>>>    Move sDialogTitle To sTitle
86127>>>>>>>>>>>    // Torben Lund suggested converting the string with toansi. Doing it like that
86127>>>>>>>>>>>    // disables showing some commonly used ascii characters like ascii 137 ()
86127>>>>>>>>>>>    // These chars are correctly shown if no toansi is used.
86127>>>>>>>>>>>    // I can imagine that he wanted to path to be ANSI, but as long as it isa just
86127>>>>>>>>>>>    // selected it will always be valid.
86127>>>>>>>>>>>    Move (AddressOf(sTitle)) to lpsTitle
86128>>>>>>>>>>>    Put lpsTitle To sBrowseInfo At vtBrowseInfo.lpszTitle
86129>>>>>>>>>>>  End
86129>>>>>>>>>>>>
86129>>>>>>>>>>>
86129>>>>>>>>>>>  Put vBIF_RETURNONLYFSDIRS To sBrowseInfo At vtBrowseInfo.ulFlags
86130>>>>>>>>>>>
86130>>>>>>>>>>>  // Torben Lund added line below. Move handle of focus object to structure before
86130>>>>>>>>>>>  // calling function. Otherwise, the folderdialog will be started as a seperate task.
86130>>>>>>>>>>>  Put (window_handle(focus(desktop))) To sBrowseInfo At vtBrowseInfo.hWndOwner
86131>>>>>>>>>>>
86131>>>>>>>>>>>  Move (AddressOf(sBrowseInfo)) to lpsBrowseInfo
86132>>>>>>>>>>>
86132>>>>>>>>>>>  // null 128 chars into var (make space)
86132>>>>>>>>>>>  Move (Repeat(Character(0), vMAX_PATH)) To sFolder
86133>>>>>>>>>>>  Move (AddressOf(sFolder)) to lpsFolder
86134>>>>>>>>>>>
86134>>>>>>>>>>>  // select folder
86134>>>>>>>>>>>  Move (vWin32_SHBrowseForFolder(lpsBrowseInfo)) To lpItemIdList
86135>>>>>>>>>>>  // get selected folder name
86135>>>>>>>>>>>  Move (vWin32_SHGetPathFromIDList(lpItemIdList, lpsFolder)) To iFolderSelected
86136>>>>>>>>>>>
86136>>>>>>>>>>>  // release memory resources that are used by the ItemIdList
86136>>>>>>>>>>>  Move (vWin32_CoTaskMemFree(lpItemIdList)) To iRetval
86137>>>>>>>>>>>
86137>>>>>>>>>>>  If (iFolderSelected<>0) Begin
86139>>>>>>>>>>>    Function_Return (CString(sFolder))
86140>>>>>>>>>>>  End
86140>>>>>>>>>>>>
86140>>>>>>>>>>>  Else Begin
86141>>>>>>>>>>>    Function_Return ""
86142>>>>>>>>>>>  End
86142>>>>>>>>>>>>
86142>>>>>>>>>>>End_Function // vSHBrowseForFolder
86143>>>>>>>>>>>
86143>>>>>>>>>>>
86143>>>>>>>>>>>// returns 0 if the folder is created.
86143>>>>>>>>>>>//         1 if the API-call returned an error.
86143>>>>>>>>>>>Function vCreateDirectory Global String sNewFolder Returns Integer
86145>>>>>>>>>>>  String  sFolder sSA
86145>>>>>>>>>>>  Pointer lpsFolder lpsSecurity_Attributes lpDescriptor
86145>>>>>>>>>>>  Integer iRetval bFolderCreated bInheritHandle
86145>>>>>>>>>>>
86145>>>>>>>>>>>  Move (False) To bFolderCreated
86146>>>>>>>>>>>  // fill string variable with null characters
86146>>>>>>>>>>>  ZeroType vtSecurity_attributes To sSA
86147>>>>>>>>>>>
86147>>>>>>>>>>>  // null MAX_PATH chars into var (make space)
86147>>>>>>>>>>>  Move (Repeat(Character(0), vMAX_PATH)) To sFolder
86148>>>>>>>>>>>
86148>>>>>>>>>>>  If (sNewFolder <> "") Begin
86150>>>>>>>>>>>
86150>>>>>>>>>>>    Move dfTrue To  bInheritHandle
86151>>>>>>>>>>>    // Setting this to NULL is already done by the zerotype command
86151>>>>>>>>>>>    // Move NULL   To  lpDescriptor
86151>>>>>>>>>>>    Put (length(sSA))   To sSA At vtSecurity_attributes.nLength
86152>>>>>>>>>>>    //Put lpDescriptor To sSA at vtSecurity_attributes.lpDescriptor
86152>>>>>>>>>>>    Put bInheritHandle To sSA At vtSecurity_attributes.bInheritHandle
86153>>>>>>>>>>>
86153>>>>>>>>>>>    Move (AddressOf(sSA)) to lpsSecurity_Attributes
86154>>>>>>>>>>>
86154>>>>>>>>>>>    //
86154>>>>>>>>>>>    Move sNewFolder To sFolder
86155>>>>>>>>>>>    Move (AddressOf(sFolder)) to lpsFolder
86156>>>>>>>>>>>    Move (vWin32_CreateDirectory(lpsFolder, lpsSecurity_Attributes)) To bFolderCreated
86157>>>>>>>>>>>  End
86157>>>>>>>>>>>>
86157>>>>>>>>>>>
86157>>>>>>>>>>>  If (not(bFolderCreated)) Begin
86159>>>>>>>>>>>    Move 1 to iRetVal
86160>>>>>>>>>>>  End
86160>>>>>>>>>>>>
86160>>>>>>>>>>>  Function_Return iRetVal
86161>>>>>>>>>>>End_Function // vCreateDirectory
86162>>>>>>>>>>>
86162>>>>>>>>>>>
86162>>>>>>>>>>>// **WvA: 03-02-2002 Function created.
86162>>>>>>>>>>>// With this function one can remove a directory.
86162>>>>>>>>>>>// returns 0 if the folder is removed.
86162>>>>>>>>>>>//         1 if the API-call returned an error (Use GetLastError API to get the details)
86162>>>>>>>>>>>//         2 if the folder did not exist
86162>>>>>>>>>>>//         3 if the sFolder parameter passed is equal to ""
86162>>>>>>>>>>>Function vRemoveDirectory Global String sFolder Returns Integer
86164>>>>>>>>>>>  String  sPath
86164>>>>>>>>>>>  Pointer lpsPath
86164>>>>>>>>>>>  Integer iRetval bRemoved
86164>>>>>>>>>>>
86164>>>>>>>>>>>  Move (False) To bRemoved
86165>>>>>>>>>>>  Move 0 To iRetVal
86166>>>>>>>>>>>  Move (Trim(sFolder)) To sFolder
86167>>>>>>>>>>>  If (sFolder="") Begin
86169>>>>>>>>>>>    Move 3 To iRetVal
86170>>>>>>>>>>>  End
86170>>>>>>>>>>>>
86170>>>>>>>>>>>  If (vFolderExists(sFolder)=False) Begin
86172>>>>>>>>>>>    Move 2 To iRetVal
86173>>>>>>>>>>>  End
86173>>>>>>>>>>>>
86173>>>>>>>>>>>  If (iRetVal=0) Begin
86175>>>>>>>>>>>    // null MAX_PATH chars into var (make space)
86175>>>>>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) To sPath
86176>>>>>>>>>>>    //
86176>>>>>>>>>>>    Move (Insert(sFolder,sPath,1)) To sPath
86177>>>>>>>>>>>    Move (AddressOf(sPath)) to lpsPath
86178>>>>>>>>>>>    Move (vWin32_RemoveDirectory(lpsPath)) To bRemoved
86179>>>>>>>>>>>  End
86179>>>>>>>>>>>>
86179>>>>>>>>>>>
86179>>>>>>>>>>>  If ((iRetVal=0) And (bRemoved=False)) Begin
86181>>>>>>>>>>>    Move 1 To iRetVal
86182>>>>>>>>>>>  End
86182>>>>>>>>>>>>
86182>>>>>>>>>>>  Function_Return iRetVal
86183>>>>>>>>>>>End_Function // vRemoveDirectory
86184>>>>>>>>>>>
86184>>>>>>>>>>>
86184>>>>>>>>>>>
86184>>>>>>>>>>>// This function informs the user that he entered a yet unknown folder and
86184>>>>>>>>>>>// asks if he/she wants to create the folder (Yes/No)
86184>>>>>>>>>>>// Choice: "Yes" - this creates the folder
86184>>>>>>>>>>>//                 if successful, the function returns false
86184>>>>>>>>>>>//                 else it will be true.
86184>>>>>>>>>>>// Choice: "No"  - returns TRUE, This allows the programmer to take action
86184>>>>>>>>>>>//                 For example: to stop a save
86184>>>>>>>>>>>// Precondition: A foldername must be entered. We do not check for empty paths
86184>>>>>>>>>>>// This function returns a non-zero value if the folder isn't created afterwards
86184>>>>>>>>>>>Function vVerifyNewFolder Global String sFolderName Returns Integer
86186>>>>>>>>>>>  Integer bIsNotValid
86186>>>>>>>>>>>  Integer iUsers_Choice
86186>>>>>>>>>>>  String  sMessage
86186>>>>>>>>>>>
86186>>>>>>>>>>>  If (vFolderExists(sFolderName) Eq 0) Begin
86188>>>>>>>>>>>    Move "The folder '" To sMessage
86189>>>>>>>>>>>    Append sMessage sFolderName
86190>>>>>>>>>>>    Append sMessage "' does not yet exist,\n"
86191>>>>>>>>>>>    Append sMessage "Do you want to create it now?"
86192>>>>>>>>>>>    Get YesNo_Box sMessage "Confirm" MB_DefButton1 To iUsers_Choice
86193>>>>>>>>>>>    Case Begin
86193>>>>>>>>>>>      Case (iUsers_Choice = MBR_Yes)
86195>>>>>>>>>>>        Move (vCreateDirectory(sFolderName)) To bIsNotValid
86196>>>>>>>>>>>        If bIsNotValid Begin
86198>>>>>>>>>>>          Move "An error occurred while trying to create folder '" To sMessage
86199>>>>>>>>>>>          Append sMessage sFolderName "'.\n\n"
86201>>>>>>>>>>>          Send Info_Box sMessage "Info"
86202>>>>>>>>>>>          End
86202>>>>>>>>>>>>
86202>>>>>>>>>>>        Case Break
86203>>>>>>>>>>>      Case (iUsers_Choice = MBR_No)
86206>>>>>>>>>>>        Move dfTrue To bIsNotValid // Cancel the save
86207>>>>>>>>>>>        Case Break
86208>>>>>>>>>>>    Case End
86208>>>>>>>>>>>  End
86208>>>>>>>>>>>>
86208>>>>>>>>>>>  Function_Return bIsNotValid
86209>>>>>>>>>>>End_Function // vVerifyNewFolder
86210>>>>>>>>>>>
86210>>>>>>>>>>>
86210>>>>>>>>>>>// This will perform an operation on a file (e.g. open) with the application
86210>>>>>>>>>>>// registered in the Windows Registry to open that type of file (via its extension)
86210>>>>>>>>>>>// sOperation would be "OPEN" (it could also be "PRINT" etc).
86210>>>>>>>>>>>Procedure vShellExecute global String sOperation String sDocument String sParameters String sPath
86212>>>>>>>>>>>  Handle  hInstance hWnd
86212>>>>>>>>>>>  Pointer lpsOperation
86212>>>>>>>>>>>  Pointer lpsDocument
86212>>>>>>>>>>>  Pointer lpsParameters
86212>>>>>>>>>>>  Pointer lpsPath
86212>>>>>>>>>>>  // remove any leading/trailing spaces in the string
86212>>>>>>>>>>>  Move (Trim(sDocument)) To sDocument
86213>>>>>>>>>>>  Move (Trim(sPath))     To sPath
86214>>>>>>>>>>>  // Make the strings readable for windows API, by converting them to null-terminated
86214>>>>>>>>>>>  Append sOperation   (Character(0))
86215>>>>>>>>>>>  Append sDocument    (Character(0))
86216>>>>>>>>>>>  Append sParameters  (Character(0))
86217>>>>>>>>>>>  Append sPath        (Character(0))
86218>>>>>>>>>>>  // Connect the corresponding pointers to the strings
86218>>>>>>>>>>>  Move (AddressOf(sOperation))  to lpsOperation
86219>>>>>>>>>>>  Move (AddressOf(sDocument))   to lpsDocument
86220>>>>>>>>>>>  Move (AddressOf(sParameters)) To lpsParameters
86221>>>>>>>>>>>  Move (AddressOf(sPath))       to lpsPath
86222>>>>>>>>>>>
86222>>>>>>>>>>>  Get Window_Handle To hWnd
86223>>>>>>>>>>>  Move (vWin32_ShellExecute (hWnd, lpsOperation, lpsDocument, lpsParameters, lpsPath, 1)) To hInstance
86224>>>>>>>>>>>  If (hInstance <= 32) Begin
86226>>>>>>>>>>>    Send vDDE_Error_Handler hInstance
86227>>>>>>>>>>>  End
86227>>>>>>>>>>>>
86227>>>>>>>>>>>End_Procedure // vShellExecute
86228>>>>>>>>>>>
86228>>>>>>>>>>>
86228>>>>>>>>>>>Class cShellFileOperations Is a Array
86229>>>>>>>>>>>
86229>>>>>>>>>>>  Procedure Construct_Object
86231>>>>>>>>>>>    Forward Send Construct_Object
86233>>>>>>>>>>>    Property Integer piDeleteFlags 0
86234>>>>>>>>>>>    Property Integer piCopyFlags   0
86235>>>>>>>>>>>    Property Integer piMoveFlags   0
86236>>>>>>>>>>>    Property Integer piRenameFlags 0
86237>>>>>>>>>>>
86237>>>>>>>>>>>    Set piDeleteFlags To (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
86238>>>>>>>>>>>    Set piCopyFlags   To (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR Ior vFOF_NOCONFIRMATION)
86239>>>>>>>>>>>    Set piMoveFlags   To (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR iOr vFOF_NOCONFIRMATION)
86240>>>>>>>>>>>    Set piRenameFlags To (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
86241>>>>>>>>>>>  End_Procedure // Construct_Object
86242>>>>>>>>>>>
86242>>>>>>>>>>>
86242>>>>>>>>>>>  // This function uses the shell API to perform a file operation on the
86242>>>>>>>>>>>  // files supplied.
86242>>>>>>>>>>>  //
86242>>>>>>>>>>>  Function FileOperation String sSource String sDestination Integer iOperation Integer iFlags Returns Integer
86244>>>>>>>>>>>    String   sShFileOp
86244>>>>>>>>>>>    Pointer  lpShFileOp
86244>>>>>>>>>>>    Pointer  lpsSource
86244>>>>>>>>>>>    Pointer  lpsDestination
86244>>>>>>>>>>>    Integer  iRetVal
86244>>>>>>>>>>>    Integer  bUserAbort
86244>>>>>>>>>>>
86244>>>>>>>>>>>    ZeroType vtShFileOpStruct To sShFileOp
86245>>>>>>>>>>>    Move (ToAnsi(sSource)+Character(0)+Character(0))      To sSource
86246>>>>>>>>>>>    Move (ToAnsi(sDestination)+Character(0)+Character(0)) To sDestination
86247>>>>>>>>>>>    Move (AddressOf(sSource))    To lpsSource
86248>>>>>>>>>>>    If iOperation Ne vFO_DELETE Begin
86250>>>>>>>>>>>      Move (AddressOf(sDestination))      To lpsDestination
86251>>>>>>>>>>>      Put lpsDestination To sShFileOp At vtShFileOpStruct.pTo
86252>>>>>>>>>>>    End
86252>>>>>>>>>>>>
86252>>>>>>>>>>>
86252>>>>>>>>>>>    Put iOperation     To sShFileOp At vtShFileOpStruct.wFunc
86253>>>>>>>>>>>    Put lpsSource      To sShFileOp At vtShFileOpStruct.pFrom
86254>>>>>>>>>>>    Put iFlags         To sShFileOp At vtShFileOpStruct.fFlags
86255>>>>>>>>>>>
86255>>>>>>>>>>>    Move (AddressOf(sShFileOp)) to lpShFileOp
86256>>>>>>>>>>>
86256>>>>>>>>>>>    Move (vWin32_SHFileOperation(lpShFileOp)) To iRetVal
86257>>>>>>>>>>>    GetBuff From sShFileOp At vtShFileOpStruct.fAnyOperationsAborted To bUserAbort
86258>>>>>>>>>>>    If (bUserAbort <> 0) Begin
86260>>>>>>>>>>>      Move 80 To iRetVal  // file Operation Aborted by USER
86261>>>>>>>>>>>    End
86261>>>>>>>>>>>>
86261>>>>>>>>>>>    Function_Return (iRetVal)
86262>>>>>>>>>>>  End_Function // FileOperation
86263>>>>>>>>>>>
86263>>>>>>>>>>>
86263>>>>>>>>>>>  Function sfoDeleteFile String sFileName Returns Integer
86265>>>>>>>>>>>    Integer  iRetVal
86265>>>>>>>>>>>    Integer  iFlags
86265>>>>>>>>>>>
86265>>>>>>>>>>>    Get piDeleteFlags To iFlags
86266>>>>>>>>>>>    Get FileOperation sFileName "" vFO_DELETE iFlags To iRetVal
86267>>>>>>>>>>>    Function_Return iRetVal
86268>>>>>>>>>>>  End_Function // sfoDeleteFile
86269>>>>>>>>>>>
86269>>>>>>>>>>>
86269>>>>>>>>>>>  Function sfoCopyFile String sSource String sDestination Returns Integer
86271>>>>>>>>>>>    Integer  iRetVal
86271>>>>>>>>>>>    Integer  iFlags
86271>>>>>>>>>>>
86271>>>>>>>>>>>    Get piCopyFlags To iFlags
86272>>>>>>>>>>>    Get FileOperation sSource sDestination vFO_COPY iFlags To iRetVal
86273>>>>>>>>>>>    Function_Return iRetVal
86274>>>>>>>>>>>  End_Function // sfoCopyFile
86275>>>>>>>>>>>
86275>>>>>>>>>>>
86275>>>>>>>>>>>  Function sfoMoveFile String sSource String sDestination Returns Integer
86277>>>>>>>>>>>    Integer  iRetVal
86277>>>>>>>>>>>    Integer  iFlags
86277>>>>>>>>>>>
86277>>>>>>>>>>>    Get piMoveFlags To iFlags
86278>>>>>>>>>>>    Get FileOperation sSource sDestination vFO_MOVE iFlags To iRetVal
86279>>>>>>>>>>>    Function_Return iRetVal
86280>>>>>>>>>>>  End_Function // sfoMoveFile
86281>>>>>>>>>>>
86281>>>>>>>>>>>
86281>>>>>>>>>>>  // Rename a file or folder
86281>>>>>>>>>>>  // Returns a nonzero value if the operation failed.
86281>>>>>>>>>>>  Function sfoRenameFile String sSource String sDestination Returns Integer
86283>>>>>>>>>>>    Integer  iRetVal
86283>>>>>>>>>>>    Integer  iFlags
86283>>>>>>>>>>>
86283>>>>>>>>>>>    Get piRenameFlags To iFlags
86284>>>>>>>>>>>    Get FileOperation sSource sDestination vFO_RENAME iFlags To iRetVal
86285>>>>>>>>>>>    Function_Return iRetVal
86286>>>>>>>>>>>  End_Function // sfoRenameFile
86287>>>>>>>>>>>
86287>>>>>>>>>>>  // Courtesy Of Steve Walter
86287>>>>>>>>>>>  // Requires Windows 2000 and up according to msdn but it was
86287>>>>>>>>>>>  //  in fact available before that as an unpublished API call
86287>>>>>>>>>>>  //  a little google search shows that this was already available
86287>>>>>>>>>>>  //  in windows 95 and NT
86287>>>>>>>>>>>  //
86287>>>>>>>>>>>  // The format is controlled by the dialog interface.
86287>>>>>>>>>>>  // That is, the user must click the OK button To actually Begin the format
86287>>>>>>>>>>>  // the format cannot be started programmatically.
86287>>>>>>>>>>>  // An alternative to this functionality would be to use a controlpanel
86287>>>>>>>>>>>  //  http://www.vdf-guidance.com/ContribPage.asp?Page=PKGCLSDFCPLAPP&ContribRecId=93
86287>>>>>>>>>>>  //
86287>>>>>>>>>>>  // hWnd = The windows handle of the object from which the format Function
86287>>>>>>>>>>>  //        is called.
86287>>>>>>>>>>>  // To Get this,
86287>>>>>>>>>>>  //          use:  Get Window_Handle Of <object>
86287>>>>>>>>>>>  //          For instance, in this app, we're going to use the Report_Panel:
86287>>>>>>>>>>>  //                  Get Window_Handle Of (Report_Panel(Main(Self))) To hWind
86287>>>>>>>>>>>  //
86287>>>>>>>>>>>  // sDrive = The drive letter. At this moment only A and B are valid
86287>>>>>>>>>>>  //
86287>>>>>>>>>>>  // iOptions = Format options.
86287>>>>>>>>>>>  //  SHFMT_OPT_DEFAULT = Quick format
86287>>>>>>>>>>>  //  SHFMT_OPT_FULL    = Full Format
86287>>>>>>>>>>>  //  SHFMT_OPT_SYSONLY = System only
86287>>>>>>>>>>>  //  3                 = Full format with system. (unsupported)
86287>>>>>>>>>>>  //
86287>>>>>>>>>>>  // Return Values:
86287>>>>>>>>>>>  //  SHFMT_ERROR    = Error on format or no drive specified.
86287>>>>>>>>>>>  //  SHFMT_CANCEL   = Format cancelled by user.
86287>>>>>>>>>>>  //  SHFMT_NOFORMAT = Drive is not formatable.
86287>>>>>>>>>>>  //
86287>>>>>>>>>>>  //
86287>>>>>>>>>>>  // *** ATTENTION: This function has been disabled as it doesn't
86287>>>>>>>>>>>  //                seem to work, i must have made a silly mistake
86287>>>>>>>>>>>  //                somewhere.
86287>>>>>>>>>>>  //
86287>>>>>>>>>>>  Function sfoFormatDisk String sDrive Integer iOptions Returns DWORD
86289>>>>>>>>>>>    Handle   hWnd
86289>>>>>>>>>>>    Integer  iObj
86289>>>>>>>>>>>    DWORD    dwReturnVal
86289>>>>>>>>>>>    Integer iDrive
86289>>>>>>>>>>>
86289>>>>>>>>>>>    Function_Return (1) // STOP HERE
86290>>>>>>>>>>>
86290>>>>>>>>>>>    Move (Trim(sDrive)) To sDrive
86291>>>>>>>>>>>    If ( sDrive <> '' ) Begin
86293>>>>>>>>>>>      If ( sDrive contains ':' ) Begin
86295>>>>>>>>>>>        Move (Replace(':',sDrive,'')) to sDrive
86296>>>>>>>>>>>      End
86296>>>>>>>>>>>>
86296>>>>>>>>>>>      If (not( 'AB' contains sDrive )) Begin
86298>>>>>>>>>>>         Function_Return (SHFMT_NOFORMAT)
86299>>>>>>>>>>>      End
86299>>>>>>>>>>>>
86299>>>>>>>>>>>      If ( sDrive = 'A') Begin
86301>>>>>>>>>>>        Move 0 to iDrive
86302>>>>>>>>>>>      End
86302>>>>>>>>>>>>
86302>>>>>>>>>>>      Else If ( sDrive = 'B') Begin
86305>>>>>>>>>>>        Move 1 to iDrive
86306>>>>>>>>>>>      End
86306>>>>>>>>>>>>
86306>>>>>>>>>>>      // Window_Handle Of Desktop equals to 0
86306>>>>>>>>>>>
86306>>>>>>>>>>>      Get focus Of desktop To iObj
86307>>>>>>>>>>>      If (iObj>desktop) ;          Get Container_Handle Of iObj To hWnd
86310>>>>>>>>>>>      While (hWnd=0 And iObj<>Desktop)
86314>>>>>>>>>>>          Get Parent Of iObj To iObj
86315>>>>>>>>>>>          Get Container_Handle Of iObj To hWnd
86316>>>>>>>>>>>      End
86317>>>>>>>>>>>>
86317>>>>>>>>>>>
86317>>>>>>>>>>>      //Showln "hWnd = " hWnd " iDrive " iDrive " iOptions " iOptions
86317>>>>>>>>>>>      Move (vWin32_ShFormatDrive(hWnd, iDrive, SHFMT_ID_DEFAULT, iOptions)) To dwReturnVal
86318>>>>>>>>>>>    End
86318>>>>>>>>>>>>
86318>>>>>>>>>>>    Else Begin
86319>>>>>>>>>>>      Move (SHFMT_ERROR) To dwReturnVal
86320>>>>>>>>>>>    End
86320>>>>>>>>>>>>
86320>>>>>>>>>>>    Function_Return dwReturnVal
86321>>>>>>>>>>>  End_Function // sfoFormatDisk
86322>>>>>>>>>>>
86322>>>>>>>>>>>  //Example:
86322>>>>>>>>>>>  // Get sfoFormatDisk 'A' 0 To dReturnVal    // Formats drive A in QuickFormat
86322>>>>>>>>>>>  //                                          mode.
86322>>>>>>>>>>>
86322>>>>>>>>>>>End_Class // cShellFileOperations
86323>>>>>>>>>>>
86323>>>>>>>>>>>
86323>>>>>>>>>>>Object oShellFileOperations Is a cShellFileOperations
86325>>>>>>>>>>>End_Object // oShellFileOperations
86326>>>>>>>>>>>
86326>>>>>>>>>>>
86326>>>>>>>>>>>// Restore to the old way of working with the shell file operations.
86326>>>>>>>>>>>// or.. to put lay man terms, allow any of the operations vDeleteFile
86326>>>>>>>>>>>// vCopyFile/vMoveFile/vRenameFile to have an UNDO
86326>>>>>>>>>>>Procedure vWin32fhCompatibilityMode
86329>>>>>>>>>>>  Integer hoSFO
86329>>>>>>>>>>>  Integer iFlags
86329>>>>>>>>>>>
86329>>>>>>>>>>>  Move (vFOF_SILENT Ior vFOF_NOCONFIRMATION Ior vFOF_ALLOWUNDO) To iFlags
86330>>>>>>>>>>>  Move (oShellFileOperations(Self)) To hoSFO
86331>>>>>>>>>>>
86331>>>>>>>>>>>  Set piDeleteFlags Of hoSFO To iFlags
86332>>>>>>>>>>>  Set piCopyFlags   Of hoSFO To iFlags
86333>>>>>>>>>>>  Set piMoveFlags   Of hoSFO To iFlags
86334>>>>>>>>>>>  Set piRenameFlags Of hoSFO To iFlags
86335>>>>>>>>>>>End_Procedure // vWin32fhCompatibilityMode
86336>>>>>>>>>>>
86336>>>>>>>>>>>
86336>>>>>>>>>>>Function vDeleteFile Global String sFileName Returns Integer
86338>>>>>>>>>>>  Integer  iRetVal
86338>>>>>>>>>>>
86338>>>>>>>>>>>  Get sfoDeleteFile Of (oShellFileOperations(Self)) sFileName To iRetVal
86339>>>>>>>>>>>  Function_Return iRetVal
86340>>>>>>>>>>>End_Function // vDeleteFile
86341>>>>>>>>>>>
86341>>>>>>>>>>>
86341>>>>>>>>>>>Function vCopyFile Global String sSource String sDestination Returns Integer
86343>>>>>>>>>>>  Integer  iRetVal
86343>>>>>>>>>>>
86343>>>>>>>>>>>  Get sfoCopyFile Of (oShellFileOperations(Self)) sSource sDestination To iRetVal
86344>>>>>>>>>>>  Function_Return iRetVal
86345>>>>>>>>>>>End_Function // vCopyFile
86346>>>>>>>>>>>
86346>>>>>>>>>>>
86346>>>>>>>>>>>Function vMoveFile Global String sSource String sDestination Returns Integer
86348>>>>>>>>>>>  Integer  iRetVal
86348>>>>>>>>>>>
86348>>>>>>>>>>>  Get sfoMoveFile Of (oShellFileOperations(Self)) sSource sDestination To iRetVal
86349>>>>>>>>>>>  Function_Return iRetVal
86350>>>>>>>>>>>End_Function // vMoveFile
86351>>>>>>>>>>>
86351>>>>>>>>>>>
86351>>>>>>>>>>>// Rename a file or folder
86351>>>>>>>>>>>// Returns a nonzero value if the operation failed.
86351>>>>>>>>>>>Function vRenameFile Global String sSource String sDestination Returns Integer
86353>>>>>>>>>>>  Integer  iRetVal
86353>>>>>>>>>>>
86353>>>>>>>>>>>  Get sfoRenameFile Of (oShellFileOperations(Self)) sSource sDestination To iRetVal
86354>>>>>>>>>>>  Function_Return iRetVal
86355>>>>>>>>>>>End_Function // vRenameFile
86356>>>>>>>>>>>
86356>>>>>>>>>>>
86356>>>>>>>>>>>
86356>>>>>>>>>>>Function vGetWindowsDirectory Returns String
86359>>>>>>>>>>>  String  sDirectory
86359>>>>>>>>>>>  Pointer lpDirectory
86359>>>>>>>>>>>  Integer iVoid
86359>>>>>>>>>>>
86359>>>>>>>>>>>  ZeroString vMAX_PATH To sDirectory
86360>>>>>>>>>>>  Move (AddressOf(sDirectory)) to lpDirectory
86361>>>>>>>>>>>
86361>>>>>>>>>>>  Move (vWin32_GetWindowsDirectory(lpDirectory, vMAX_PATH)) To iVoid
86362>>>>>>>>>>>  Function_Return (CString(sDirectory))  // **WvA: Changed to CString()
86363>>>>>>>>>>>End_Function // vGetWindowsDirectory
86364>>>>>>>>>>>
86364>>>>>>>>>>>
86364>>>>>>>>>>>
86364>>>>>>>>>>>
86364>>>>>>>>>>>// Courtesy of Marco Kuipers
86364>>>>>>>>>>>Function vMakeTempFile Returns String
86367>>>>>>>>>>>    Integer iRetval
86367>>>>>>>>>>>    String  sTempPath sTempFileName sPrefixString
86367>>>>>>>>>>>    Pointer lpTempPath lpTempFileName lpPrefixString
86367>>>>>>>>>>>
86367>>>>>>>>>>>    Move (Repeat (Character (0), 255)) To sTempPath
86368>>>>>>>>>>>    Move (AddressOf(sTempPath)) to lpTempPath
86369>>>>>>>>>>>    Move (vWin32_GetTempPath (255, lpTempPath)) To iRetVal
86370>>>>>>>>>>>
86370>>>>>>>>>>>    If (sTempPath = "") Begin
86372>>>>>>>>>>>       Get_Current_Directory To sTempPath
86373>>>>>>>>>>>    End
86373>>>>>>>>>>>>
86373>>>>>>>>>>>    Move (pad(sTempPath,vMax_Path-14)) To sTempPath // *WvA: 28-04-2005 Quote from msdn: The string cannot be longer than MAX_PATH-14 characters.
86374>>>>>>>>>>>    Move (Repeat (Character (0), 255)) To sTempFileName
86375>>>>>>>>>>>    Move (AddressOf(sTempFileName)) To lpTempFileName
86376>>>>>>>>>>>    Move ("tmp"+character(0)) To sPrefixString // **WvA: 28-04-2005 Added a null
86377>>>>>>>>>>>    Move (AddressOf(sPrefixString)) To lpPrefixString
86378>>>>>>>>>>>    Move (AddressOf(sTempPath)) to lpTempPath
86379>>>>>>>>>>>    Move (vWin32_GetTempFileName (lpTempPath, lpPrefixString, 0, lpTempFileName)) To iRetval
86380>>>>>>>>>>>    If (iRetval = 0) Begin  // **WvA: 28-04-2005 Changed condition, the api call returns 0 if an error occurs
86382>>>>>>>>>>>        Move "" To sTempFileName
86383>>>>>>>>>>>    End
86383>>>>>>>>>>>>
86383>>>>>>>>>>>
86383>>>>>>>>>>>    Function_Return (Cstring(sTempFileName)) // **WvA: 28-04-2005 Cstring added
86384>>>>>>>>>>>End_Function // vMakeTempFile
86385>>>>>>>>>>>
86385>>>>>>>>>>>
86385>>>>>>>>>>>// This function creates a uniquely named temporary file in folder sPath
86385>>>>>>>>>>>// The file created will have a prefix based on the first 3 characters in sPrefix
86385>>>>>>>>>>>// Note that you will have to cleanup the tempfile yourself as the function
86385>>>>>>>>>>>// does not take care of that.
86385>>>>>>>>>>>Function vCreateTempFileInPath String sPath String sPrefix Returns String
86388>>>>>>>>>>>    String sTempFileName
86388>>>>>>>>>>>    Integer iRetVal
86388>>>>>>>>>>>    Pointer lpTempFileName
86388>>>>>>>>>>>    Pointer lpPath
86388>>>>>>>>>>>    Pointer lpPrefix
86388>>>>>>>>>>>
86388>>>>>>>>>>>    Move (ToAnsi(sPath)+Character(0))   To sPath
86389>>>>>>>>>>>    Move (ToAnsi(sPrefix)+Character(0)) To sPrefix
86390>>>>>>>>>>>    Move (pad("", vMAX_PATH)) To sTempFileName
86391>>>>>>>>>>>    Move (AddressOf(sTempFileName)) To lpTempFileName
86392>>>>>>>>>>>    Move (AddressOf(sPath))         To lpPath
86393>>>>>>>>>>>    Move (AddressOf(sPrefix))       to lpPrefix
86394>>>>>>>>>>>
86394>>>>>>>>>>>    Move (vWin32_GetTempFileName(lpPath, lpPrefix, 0, lpTempFileName)) To iRetVal
86395>>>>>>>>>>>    Move (Trim(Cstring(sTempFileName))) To sTempFileName
86396>>>>>>>>>>>    Function_Return sTempFileName
86397>>>>>>>>>>>End_Function // vCreateTempFileInPath
86398>>>>>>>>>>>
86398>>>>>>>>>>>//
86398>>>>>>>>>>>// Get a specific shell folder for example to get the desktop folder
86398>>>>>>>>>>>// simply call this function and pass it vCSIDL_DESKTOP
86398>>>>>>>>>>>//
86398>>>>>>>>>>>Function vSHGetFolderPath Integer eFolder Returns String
86401>>>>>>>>>>>  String  sFolder
86401>>>>>>>>>>>  Integer iVoid
86401>>>>>>>>>>>  Pointer lpsFolder
86401>>>>>>>>>>>  Handle  hWnd
86401>>>>>>>>>>>  Move (Window_Handle(focus(desktop))) To hWnd
86402>>>>>>>>>>>
86402>>>>>>>>>>>  Move (Repeat(Character(0), vMAX_PATH)) To sFolder
86403>>>>>>>>>>>  Move (AddressOf(sFolder)) To lpsFolder
86404>>>>>>>>>>>
86404>>>>>>>>>>>  Move (vWin32_SHGetFolderPath(hWnd,eFolder, 0, 0,lpsFolder)) To iVoid
86405>>>>>>>>>>>  Function_Return (CString(sFolder))
86406>>>>>>>>>>>End_Function // vSHGetFolderPath
86407>>>>>>>>>>>
86407>>>>>>>>>>>
86407>>>>>>>>>>>
86407>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
86407>>>>>>>>>>>Function vConvertFileDateTime Global Dword dwLowDateTime Dword dwHighDateTime Returns String
86409>>>>>>>>>>>  String  sftTime sSystemTime sFormattedTime sFormattedDate
86409>>>>>>>>>>>  Pointer lpsftTime lpsSystemTime lpsFormattedTime lpsFormattedDate
86409>>>>>>>>>>>  Integer iSuccess iLenCcTime iDataLength iLenCcDate
86409>>>>>>>>>>>
86409>>>>>>>>>>>  ZeroType vFileTime  To sftTime
86410>>>>>>>>>>>  Put dwLowDateTime  To sftTime At vFileTime.dwLowDateTime
86411>>>>>>>>>>>  Put dwHighDateTime To sftTime At vFileTime.dwHighDateTime
86412>>>>>>>>>>>  Move (AddressOf(sftTime)) to lpsftTime
86413>>>>>>>>>>>
86413>>>>>>>>>>>  ZeroType vSystemTime To sSystemTime
86414>>>>>>>>>>>  Move (AddressOf(sSystemTime)) To lpsSystemTime
86415>>>>>>>>>>>
86415>>>>>>>>>>>  Move (vWin32_FileTimeToSystemTime (lpsftTime, lpsSystemTime)) To iSuccess
86416>>>>>>>>>>>  If iSuccess Eq DfTrue Begin
86418>>>>>>>>>>>    ZeroString 255 To sFormattedTime
86419>>>>>>>>>>>    Move (AddressOf(sFormattedTime)) To lpsFormattedTime
86420>>>>>>>>>>>    Length sFormattedTime To iLenCcTime
86421>>>>>>>>>>>>
86421>>>>>>>>>>>    Move (vWin32_GetTimeFormat (LOCALE_USER_DEFAULT, 0, lpsSystemTime, 0, ;                             lpsFormattedTime, iLenCcTime)) To iDataLength
86422>>>>>>>>>>>    ZeroString 255 To sFormattedDate
86423>>>>>>>>>>>    Move (AddressOf(sFormattedDate)) to lpsFormattedDate
86424>>>>>>>>>>>    Move (Length(sFormattedDate)) to iLenCcDate
86425>>>>>>>>>>>    Move (vWin32_GetDateFormat (LOCALE_USER_DEFAULT, 0, lpsSystemTime, 0, ;                             lpsFormattedDate, iLenCcDate)) To iDataLength
86426>>>>>>>>>>>    Function_Return (Cstring (sFormattedDate)  * Cstring (sFormattedTime))
86427>>>>>>>>>>>  End // iSuccess
86427>>>>>>>>>>>>
86427>>>>>>>>>>>End_Function // vConvertFileDateTime
86428>>>>>>>>>>>
86428>>>>>>>>>>>
86428>>>>>>>>>>>// **WvA Removed, See the cFileSet class for an alternative
86428>>>>>>>>>>>//Procedure DoBrowseDir String sFilePath
86428>>>>>>>>>>>//End_Procedure // DoBrowseDir
86428>>>>>>>>>>>
86428>>>>>>>>>>>// **WvA:
86428>>>>>>>>>>>// A windows replacement for the standard function FileExists.
86428>>>>>>>>>>>// This version will also return (true) for a file when it is open by an application.
86428>>>>>>>>>>>// Note that you can apply normal windows mask-signs in the filename such as * and ?
86428>>>>>>>>>>>// Example: Get vFilePathExists "C:\config.sy?"
86428>>>>>>>>>>>// This will return true if you have a file matching these conditions. (aka config.sys)
86428>>>>>>>>>>>Function vFilePathExists Global String sFilePathMask Returns Integer
86430>>>>>>>>>>>  String  sWin32FindData
86430>>>>>>>>>>>  String  sDirSep
86430>>>>>>>>>>>  Pointer lpsFilePathMask lpsWin32FindData
86430>>>>>>>>>>>  Handle  hFindFile
86430>>>>>>>>>>>  Integer iVoid
86430>>>>>>>>>>>
86430>>>>>>>>>>>  Move vINVALID_HANDLE_VALUE To hFindFile
86431>>>>>>>>>>>  Move (ToANSI(trim(sFilePathMask))) To sFilePathMask
86432>>>>>>>>>>>
86432>>>>>>>>>>>  If (length(sFilePathMask)>0) Begin
86434>>>>>>>>>>>    // 2014-09-29 NGS Remove any trailing dir separators, as they make the function fail.
86434>>>>>>>>>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
86435>>>>>>>>>>>    While (Right(sFilePathMask, 1) = sDirSep)
86439>>>>>>>>>>>      Move (Left(sFilePathMask, Length(sFilePathMask) -1)) to sFilePathMask
86440>>>>>>>>>>>    Loop
86441>>>>>>>>>>>>
86441>>>>>>>>>>>
86441>>>>>>>>>>>    Move (AddressOf(sFilePathMask)) To lpsFilePathMask
86442>>>>>>>>>>>    ZeroType vWin32_Find_Data To sWin32FindData
86443>>>>>>>>>>>    Move (AddressOf(sWin32FindData)) to lpswin32FindData
86444>>>>>>>>>>>    Move (vWin32_FindFirstFile (lpsFilePathMask, lpsWin32FindData)) To hFindFile
86445>>>>>>>>>>>    Move (vWin32_FindClose (hFindFile)) To iVoid
86446>>>>>>>>>>>  End
86446>>>>>>>>>>>>
86446>>>>>>>>>>>  Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
86447>>>>>>>>>>>End_Function // vFilePathExists
86448>>>>>>>>>>>
86448>>>>>>>>>>>
86448>>>>>>>>>>>// **WvA
86448>>>>>>>>>>>// Formats a foldername by first trimming it and after that by sticking a
86448>>>>>>>>>>>// directory separator (/\) to the end if it doesn't have one there already.
86448>>>>>>>>>>>// The folder may contain a drive letter or UNC encoding.
86448>>>>>>>>>>>Function vFolderFormat Global String sFolderName Returns String
86450>>>>>>>>>>>  String sDirSep
86450>>>>>>>>>>>  Move (sysconf(SYSCONF_DIR_SEPARATOR)) To sDirSep  // normally \ (backslash)
86451>>>>>>>>>>>  Move (Trim(sFolderName)) To sFolderName
86452>>>>>>>>>>>  If (Right(sFolderName,1)<>sDirSep) Begin
86454>>>>>>>>>>>    Move (sFolderName+sDirSep) To sFolderName
86455>>>>>>>>>>>  End
86455>>>>>>>>>>>>
86455>>>>>>>>>>>  Function_Return sFolderName
86456>>>>>>>>>>>End_Function // vFolderFormat
86457>>>>>>>>>>>//
86457>>>>>>>>>>>// Returns the amount of files in the folder (if it exists)
86457>>>>>>>>>>>// Returns -1 if folder doesn't exist.
86457>>>>>>>>>>>// The files "." and ".." are not counted.
86457>>>>>>>>>>>//
86457>>>>>>>>>>>Function vFolderFileCount Global String sFolderName Returns Integer
86459>>>>>>>>>>>  Boolean bFound
86459>>>>>>>>>>>  Handle  hFindFile
86459>>>>>>>>>>>  Integer iCount  iVoid
86459>>>>>>>>>>>  Integer iSuccess
86459>>>>>>>>>>>  Pointer lpsFolderName lpsWin32FindData
86459>>>>>>>>>>>  String  sWin32FindData
86459>>>>>>>>>>>  String  sFileName
86459>>>>>>>>>>>
86459>>>>>>>>>>>  Move -1 To iCount
86460>>>>>>>>>>>  Get vFolderFormat sFolderName To sFolderName
86461>>>>>>>>>>>  Move (sFolderName+"*") To sFolderName // match any filename in the folder
86462>>>>>>>>>>>  Move (AddressOf(sFolderName)) To lpsFolderName
86463>>>>>>>>>>>  ZeroType vWin32_Find_Data To sWin32FindData
86464>>>>>>>>>>>  Move (AddressOf(sWin32FindData)) to lpswin32FindData
86465>>>>>>>>>>>  Move (vWin32_FindFirstFile (lpsFolderName, lpsWin32FindData)) To hFindFile
86466>>>>>>>>>>>  Move (hFindFile<>vINVALID_HANDLE_VALUE) To bFound
86467>>>>>>>>>>>  If (bFound) Begin
86469>>>>>>>>>>>    Move 0 to iCount
86470>>>>>>>>>>>  End
86470>>>>>>>>>>>>
86470>>>>>>>>>>>  While (bFound)
86474>>>>>>>>>>>    Increment iCount
86475>>>>>>>>>>>    GetBuff_String From sWin32FindData At vWin32_Find_Data.cFileName To sFileName
86476>>>>>>>>>>>    If (sFileName="." or sFileName="..") Begin
86478>>>>>>>>>>>        Decrement iCount
86479>>>>>>>>>>>    End
86479>>>>>>>>>>>>
86479>>>>>>>>>>>    Move (vWin32_FindNextFile(hFindFile, lpsWin32FindData)) To iSuccess
86480>>>>>>>>>>>    Move (iSuccess<>0) To bFound
86481>>>>>>>>>>>  Loop
86482>>>>>>>>>>>>
86482>>>>>>>>>>>  Move (vWin32_FindClose (hFindFile)) To iVoid
86483>>>>>>>>>>>  Function_Return iCount
86484>>>>>>>>>>>End_Function // vFolderFileCount
86485>>>>>>>>>>>
86485>>>>>>>>>>>
86485>>>>>>>>>>>//
86485>>>>>>>>>>>// Gets the parent path of the currently supplied path
86485>>>>>>>>>>>// Returns "" when we are at the root folder.
86485>>>>>>>>>>>//
86485>>>>>>>>>>>Function vParentPath Global String sPath Returns String
86487>>>>>>>>>>>  String sStrip
86487>>>>>>>>>>>  Integer iLength
86487>>>>>>>>>>>
86487>>>>>>>>>>>  If (Right(sPath,1)="\") Begin
86489>>>>>>>>>>>    Move (Left(sPath,Length(sPath)-1)) To sPath
86490>>>>>>>>>>>  End
86490>>>>>>>>>>>>
86490>>>>>>>>>>>  If (Pos("\",sPath)) Begin
86492>>>>>>>>>>>    Move (StringFromRightOfChar(sPath,"\")) to sStrip
86493>>>>>>>>>>>    Move (Length(sStrip)) to iLength
86494>>>>>>>>>>>    Move (Left(sPath, (Length(sPath) - iLength -1))) to sPath
86495>>>>>>>>>>>//    Move (Replace(sStrip,sPath,"")) To sPath
86495>>>>>>>>>>>  End
86495>>>>>>>>>>>>
86495>>>>>>>>>>>  Else Begin
86496>>>>>>>>>>>    Move "" To sPath
86497>>>>>>>>>>>  End
86497>>>>>>>>>>>>
86497>>>>>>>>>>>  Function_Return sPath
86498>>>>>>>>>>>End_Function // vParentPath
86499>>>>>>>>>>>
86499>>>>>>>>>>>// Create the folder, including intermediate directories.
86499>>>>>>>>>>>// Don't panic if the folder already exists.
86499>>>>>>>>>>>// Michael Mullan June 2009.
86499>>>>>>>>>>>Function vshCreateDirectoryEX Global String sNewFolder Returns Integer
86501>>>>>>>>>>>  String  sFolder sSA
86501>>>>>>>>>>>  Pointer lpsFolder lpsSecurity_Attributes
86501>>>>>>>>>>>  Integer iRetval bFolderCreated bInheritHandle
86501>>>>>>>>>>>  Move (False) to bFolderCreated
86502>>>>>>>>>>>  // fill string variable with null characters
86502>>>>>>>>>>>  ZeroType vtSecurity_attributes to sSA
86503>>>>>>>>>>>  // null MAX_PATH chars into var (make space)
86503>>>>>>>>>>>  Move (Repeat(Character(0), vMAX_PATH)) to sFolder
86504>>>>>>>>>>>  If (sNewFolder <> "") Begin
86506>>>>>>>>>>>    Move dfTrue to  bInheritHandle
86507>>>>>>>>>>>    // Setting this to NULL is already done by the zerotype command
86507>>>>>>>>>>>    // Move NULL   To  lpDescriptor
86507>>>>>>>>>>>    Put (length(sSA))   to sSA At vtSecurity_attributes.nLength
86508>>>>>>>>>>>    //Put lpDescriptor To sSA at vtSecurity_attributes.lpDescriptor
86508>>>>>>>>>>>    Put bInheritHandle to sSA At vtSecurity_attributes.bInheritHandle
86509>>>>>>>>>>>    Move (AddressOf(sSA)) to lpsSecurity_Attributes
86510>>>>>>>>>>>    //
86510>>>>>>>>>>>    Move sNewFolder to sFolder
86511>>>>>>>>>>>    Move (AddressOf(sFolder)) to lpsFolder
86512>>>>>>>>>>>    Move (vWin32_SHCreateDirectoryEx(0,lpsFolder, lpsSecurity_Attributes)) to bFolderCreated
86513>>>>>>>>>>>  End
86513>>>>>>>>>>>>
86513>>>>>>>>>>>
86513>>>>>>>>>>>  If (bFolderCreated <> 0) Begin
86515>>>>>>>>>>>    Move 1 to iRetVal
86516>>>>>>>>>>>
86516>>>>>>>>>>>    If (bFolderCreated = 161 ) Begin
86518>>>>>>>>>>>        Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_BAD_PATHNAME)")
86519>>>>>>>>>>>>
86519>>>>>>>>>>>    End
86519>>>>>>>>>>>>
86519>>>>>>>>>>>    Else If (bFolderCreated = 206 ) Begin
86522>>>>>>>>>>>        Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_FILENAME_EXCED_RANGE)")
86523>>>>>>>>>>>>
86523>>>>>>>>>>>    End
86523>>>>>>>>>>>>
86523>>>>>>>>>>>    Else If (bFolderCreated = 3   ) Begin
86526>>>>>>>>>>>        Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_PATH_NOT_FOUND)")
86527>>>>>>>>>>>>
86527>>>>>>>>>>>    End
86527>>>>>>>>>>>>
86527>>>>>>>>>>>    Else If (bFolderCreated = 80  ) Begin
86530>>>>>>>>>>>        Move 0 to iRetval // "ERROR_FILE_EXISTS"     not really an error
86531>>>>>>>>>>>    End
86531>>>>>>>>>>>>
86531>>>>>>>>>>>    Else If (bFolderCreated = 183 ) Begin
86534>>>>>>>>>>>        Move 0 to iRetval //  "ERROR_ALREADY_EXISTS"     not really an error
86535>>>>>>>>>>>    End
86535>>>>>>>>>>>>
86535>>>>>>>>>>>    Else If (bFolderCreated = 1223) Begin
86538>>>>>>>>>>>        Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_CANCELLED)")
86539>>>>>>>>>>>>
86539>>>>>>>>>>>    End
86539>>>>>>>>>>>>
86539>>>>>>>>>>>    Else Begin
86540>>>>>>>>>>>        Error DFERR_OPERATOR ("Folder Creation Error # " + String(bfoldercreated) + "\n" + sNewFolder + "(FILE_CREATION_ERROR)")
86541>>>>>>>>>>>>
86541>>>>>>>>>>>    End
86541>>>>>>>>>>>>
86541>>>>>>>>>>>  End
86541>>>>>>>>>>>>
86541>>>>>>>>>>>  Function_Return iRetVal
86542>>>>>>>>>>>End_Function // vshCreateDirectoryEX
86543>>>>>>>>>>>
86543>>>>>>>>>>>
86543>>>>>>>>>>>Function vWin32_APIFileSize Global string sFileName returns integer
86545>>>>>>>>>>>     dWord dwFileSizeHigh dwFileSizeLow
86545>>>>>>>>>>>     integer iFileSize iVoid
86545>>>>>>>>>>>     handle hFindFile
86545>>>>>>>>>>>     pointer lpsFilePath lpsWin32FindData
86545>>>>>>>>>>>     string sWin32FindData
86545>>>>>>>>>>>
86545>>>>>>>>>>>     Move (AddressOf(sFileName)) to lpsFilePath
86546>>>>>>>>>>>
86546>>>>>>>>>>>     ZeroType vWin32_Find_Data to sWin32FindData
86547>>>>>>>>>>>     Move (AddressOf(sWin32FindData)) to lpsWin32FindData
86548>>>>>>>>>>>
86548>>>>>>>>>>>     move (vWin32_FindFirstFile (lpsFilePath, lpsWin32FindData)) to hFindFile
86549>>>>>>>>>>>     if (hFindFile<>vINVALID_HANDLE_VALUE) begin
86551>>>>>>>>>>>         GetBuff From sWin32FindData At vWin32_Find_Data.nFileSizeHigh To dwFileSizeHigh
86552>>>>>>>>>>>         GetBuff From sWin32FindData At vWin32_Find_Data.nFileSizeLow To dwFileSizeLow
86553>>>>>>>>>>>     end
86553>>>>>>>>>>>>
86553>>>>>>>>>>>     move (vWin32_FindClose (hFindFile)) to iVoid
86554>>>>>>>>>>>
86554>>>>>>>>>>>     Move ((dwFileSizeHigh * vMaxDword) + dwFileSizeLow) to iFileSize
86555>>>>>>>>>>>
86555>>>>>>>>>>>     function_return iFileSize
86556>>>>>>>>>>>End_Function  // vWin32_APIFileSize
86557>>>>>>>>>>>
86557>>>>>>>>>>>
86557>>>>>>>>>
86557>>>>>>>>>Use DUFLanguageConstants.inc
86557>>>>>>>>>Use MertechDUF.pkg
Including file: MertechDUF.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\MertechDUF.pkg)
86557>>>>>>>>>>>//
86557>>>>>>>>>>>// Use of Mertech drivers:
86557>>>>>>>>>>>// Put the line "Define DUF_Use_Mertech_Drivers in YOUR code prior the "Use" statement for this package if using Mertech drivers!
86557>>>>>>>>>>>// And put the line right before the "Use cDbUpdateHandler.pkg" line.
86557>>>>>>>>>>>//Define DUF_Use_Mertech_Drivers
86557>>>>>>>>>>>//
#REM USE MERTECH.INC
86557>>>>>>>>>>>    Use Flex2SQLDUF.pkg
Including file: Flex2SQLDUF.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\Flex2SQLDUF.pkg)
86557>>>>>>>>>>>>>//*************************************************************************
86557>>>>>>>>>>>>>//*                                                                       *
86557>>>>>>>>>>>>>//*  Confidential Trade Secret.                                           *
86557>>>>>>>>>>>>>//*  Copyright (c) 1997-2014 Mertech Data Systems Inc, Miami Florida      *
86557>>>>>>>>>>>>>//*  All rights reserved.                                                 *
86557>>>>>>>>>>>>>//*  DataFlex is a registered trademark of Data Access Corporation.       *
86557>>>>>>>>>>>>>//*                                                                       *
86557>>>>>>>>>>>>>//*  NOTE: This version of Flex2SQL is specially adapted to be used with  *
86557>>>>>>>>>>>>>// * the Database Update Framework (DUF)                                  *
86557>>>>>>>>>>>>>// *                                                                      *
86557>>>>>>>>>>>>>//*************************************************************************
86557>>>>>>>>>>>>>Use mertech.inc
86557>>>>>>>>>>>>>Use cli.pkg
86557>>>>>>>>>>>>>
#REM -----------------------------------------------
#REM MERTECH DATA SYSTEMS INC. - WWW.MERTECHDATA.COM
#REM MERTECH.INC VERSION 1.0.3 FOR DATAFLEX UPDATE FRAMEWORK
#REM -----------------------------------------------
86557>>>>>>>>>>>>>
86557>>>>>>>>>>>>>Struct tCLIHandleMap
86557>>>>>>>>>>>>>    Integer iHdbc
86557>>>>>>>>>>>>>    String sDriver
86557>>>>>>>>>>>>>    String sConnect
86557>>>>>>>>>>>>>End_Struct
86557>>>>>>>>>>>>>
86557>>>>>>>>>>>>>Struct tColumnMap
86557>>>>>>>>>>>>>    Integer iFileNum
86557>>>>>>>>>>>>>    Variant[] vResultColumn
86557>>>>>>>>>>>>>End_Struct
86557>>>>>>>>>>>>>
86557>>>>>>>>>>>>>//*** Embedded SQL statement attribute constants
86557>>>>>>>>>>>>>Define SQLSTMTATTRIB_COLUMNCOUNT    for 1
86557>>>>>>>>>>>>>Define SQLSTMTATTRIB_ROWCOUNT       for 2
86557>>>>>>>>>>>>>Define SQLSTMTATTRIB_ROWCOUNT_TYPE  for 3
86557>>>>>>>>>>>>>Define SQLSTMTATTRIB_NUMMESSAGES    for 4
86557>>>>>>>>>>>>>
86557>>>>>>>>>>>>>//*** Embedded SQL column attribute constants
86557>>>>>>>>>>>>>Define SQLCOLATTRIB_SIZE           for 1
86557>>>>>>>>>>>>>Define SQLCOLATTRIB_LENGTH         for 1
86557>>>>>>>>>>>>>Define SQLCOLATTRIB_PRECISION      for 2
86557>>>>>>>>>>>>>Define SQLCOLATTRIB_LABEL          for 3
86557>>>>>>>>>>>>>Define SQLCOLATTRIB_BASECOLUMNNAME for 4
86557>>>>>>>>>>>>>Define SQLCOLATTRIB_BASETABLENAME  for 5
86557>>>>>>>>>>>>>Define SQLCOLATTRIB_SQLTYPE        for 6
86557>>>>>>>>>>>>>Define SQLCOLATTRIB_NULLABLE       for 7
86557>>>>>>>>>>>>>Define SQLCOLATTRIB_DFTYPE         for 8
86557>>>>>>>>>>>>>
86557>>>>>>>>>>>>>
86557>>>>>>>>>>>>>//*** Enforced DAC SQL.PKG Compatibility
86557>>>>>>>>>>>>>Define SQL_DAC_HIGH_COMPATABILITY for 1
86557>>>>>>>>>>>>>Define SQL_DAC_NORMAL_COMPATIBILITY  for 0
86557>>>>>>>>>>>>>
86557>>>>>>>>>>>>>Global_Variable Integer giSQLCompatibilityMode
86557>>>>>>>>>>>>>Move SQL_DAC_NORMAL_COMPATIBILITY to giSQLCompatibilityMode
86558>>>>>>>>>>>>>
86558>>>>>>>>>>>>>//*** Global object handle for the manager
86558>>>>>>>>>>>>>Handle _embsqlghoSQLHandleMngr
86558>>>>>>>>>>>>>Register_Function CompareMaps tCLIHandleMap map1 tCLIHandleMap map2 Returns Integer
86558>>>>>>>>>>>>>
86558>>>>>>>>>>>>>Class cSQLStatementDUF is a cObject
86559>>>>>>>>>>>>>    Procedure Construct_Object
86561>>>>>>>>>>>>>        Forward Send Construct_Object
86563>>>>>>>>>>>>>
86563>>>>>>>>>>>>>        Property Integer phCLIHandle      0
86564>>>>>>>>>>>>>        Property Integer piLastColumn     0
86565>>>>>>>>>>>>>        Property Integer piLastArgument   0
86566>>>>>>>>>>>>>        Property Integer piBindFile       0
86567>>>>>>>>>>>>>        Property Integer piCursorNum      0
86568>>>>>>>>>>>>>        Property Boolean pisBeforeFetch   True
86569>>>>>>>>>>>>>        Property Integer piParameterCount 0
86570>>>>>>>>>>>>>
86570>>>>>>>>>>>>>        Property Integer piDataChunkOffset 0
86571>>>>>>>>>>>>>        Property String psProcName ""
86572>>>>>>>>>>>>>        Property String psSchemaName ""
86573>>>>>>>>>>>>>        Property Variant[] pvParams
86574>>>>>>>>>>>>>        Property tColumnMap ptColumnMap
86575>>>>>>>>>>>>>    End_Procedure
86576>>>>>>>>>>>>>
86576>>>>>>>>>>>>>    Function SQLDateToDFDate String sSQLDate Returns String
86578>>>>>>>>>>>>>        Integer hoCLIHandler
86578>>>>>>>>>>>>>        Date dDFDate
86578>>>>>>>>>>>>>
86578>>>>>>>>>>>>>        //*** Create a CLI handler object
86578>>>>>>>>>>>>>        Object oSQLDFCLIHandler is a cCLIHandler
86580>>>>>>>>>>>>>            Move Current_Object to hoCLIHandler
86581>>>>>>>>>>>>>        End_Object // oCLIHandler
86582>>>>>>>>>>>>>
86582>>>>>>>>>>>>>        //*** Convert the date
86582>>>>>>>>>>>>>        Get CLISQLDateToDFDate of hoCLIHandler (psDRiverID(Current_Object)) sSQLDate to dDFDate
86583>>>>>>>>>>>>>
86583>>>>>>>>>>>>>        //*** Destroy the object
86583>>>>>>>>>>>>>        Send Destroy_Object to hoCLIHandler
86584>>>>>>>>>>>>>
86584>>>>>>>>>>>>>        Function_Return dDFDate
86585>>>>>>>>>>>>>    End_Function // SQLDateToDFDate
86586>>>>>>>>>>>>>
86586>>>>>>>>>>>>>    Function DFDateToSQLDate for cSQLStatementDUF Date dDFDate Returns String
86588>>>>>>>>>>>>>        Integer hoCLIHandler
86588>>>>>>>>>>>>>        String sSQLDate
86588>>>>>>>>>>>>>
86588>>>>>>>>>>>>>        //*** Create a CLI handler object
86588>>>>>>>>>>>>>        Object oDFSQLCLIHandler is a cCLIHandler
86590>>>>>>>>>>>>>            Move Current_Object to hoCLIHandler
86591>>>>>>>>>>>>>        End_Object // oCLIHandler
86592>>>>>>>>>>>>>
86592>>>>>>>>>>>>>        //*** Convert the date
86592>>>>>>>>>>>>>        Get CLIDFDateToSQLDate of hoCLIHandler (psDRiverID(Current_Object)) dDFDate to sSQLDate
86593>>>>>>>>>>>>>
86593>>>>>>>>>>>>>        //*** Destroy the object
86593>>>>>>>>>>>>>        Send Destroy_Object to hoCLIHandler
86594>>>>>>>>>>>>>
86594>>>>>>>>>>>>>        Function_Return sSQLDate
86595>>>>>>>>>>>>>    End_Function // DFDateToSQLDate
86596>>>>>>>>>>>>>
86596>>>>>>>>>>>>>
86596>>>>>>>>>>>>>    Function IsProcedure String sFunctionName Returns Boolean
86598>>>>>>>>>>>>>        String sRoutineType
86598>>>>>>>>>>>>>
86598>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
86612>>>>>>>>>>>>>>
86612>>>>>>>>>>>>>
86612>>>>>>>>>>>>>        Case Begin
86612>>>>>>>>>>>>>            Case (MertechInc_DriverName = SQLFLEX)
86614>>>>>>>>>>>>>                sql_set_stmt to (SFormat("select type from master.sys.sysobjects where name = '%1' union all select type from sys.sysobjects where name = '%1'", sFunctionName))
86622>>>>>>>>>>>>>                sql_prepare_stmt
86634>>>>>>>>>>>>>                sql_execute_stmt
86649>>>>>>>>>>>>>
86649>>>>>>>>>>>>>                sql_fetch_next_row into sRoutineType
86673>>>>>>>>>>>>>>
86673>>>>>>>>>>>>>                If (sRoutineType = "P") Begin
86675>>>>>>>>>>>>>                    Move "PROCEDURE" to sRoutineType
86676>>>>>>>>>>>>>                End
86676>>>>>>>>>>>>>>
86676>>>>>>>>>>>>>                Else Begin
86677>>>>>>>>>>>>>                    Move "FUNCTION" to sRoutineType
86678>>>>>>>>>>>>>                End
86678>>>>>>>>>>>>>>
86678>>>>>>>>>>>>>                Case Break
86679>>>>>>>>>>>>>            Case (MertechInc_DriverName = MySQLFlex)
86682>>>>>>>>>>>>>                sql_set_stmt to (SFormat("select routine_type from information_schema.routines where routine_name = '%1'", sFunctionName))
86690>>>>>>>>>>>>>                sql_prepare_stmt
86702>>>>>>>>>>>>>                sql_execute_stmt
86717>>>>>>>>>>>>>                sql_fetch_next_row into sRoutineType
86741>>>>>>>>>>>>>>
86741>>>>>>>>>>>>>
86741>>>>>>>>>>>>>                Case Break
86742>>>>>>>>>>>>>            Case (MertechInc_DriverName = ORAFLEX)
86745>>>>>>>>>>>>>                sql_set_stmt  to (SFormat("SELECT object_type from all_objects where object_name = '%1'", sFunctionName))
86753>>>>>>>>>>>>>                sql_prepare_stmt
86765>>>>>>>>>>>>>                sql_execute_stmt
86780>>>>>>>>>>>>>                sql_fetch_next_row into sRoutineType
86804>>>>>>>>>>>>>>
86804>>>>>>>>>>>>>
86804>>>>>>>>>>>>>                Case Break
86805>>>>>>>>>>>>>            Case (MertechInc_DriverName = PgFlex)
86808>>>>>>>>>>>>>                // Postgres doesn't differentiate between procedures and functions, so treat everything as procedures
86808>>>>>>>>>>>>>                // because that is better tested.
86808>>>>>>>>>>>>>                Move "PROCEDURE" to sRoutineType
86809>>>>>>>>>>>>>                Case Break
86810>>>>>>>>>>>>>        Case End
86810>>>>>>>>>>>>>
86810>>>>>>>>>>>>>        Function_Return (sRoutineType = "PROCEDURE")
86811>>>>>>>>>>>>>    End_Function
86812>>>>>>>>>>>>>
86812>>>>>>>>>>>>>    Function ProcParams String sFunctionName Returns Variant[]
86814>>>>>>>>>>>>>        Variant[] vFuncParams
86815>>>>>>>>>>>>>        Integer i iParamType
86815>>>>>>>>>>>>>
86815>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
86829>>>>>>>>>>>>>>
86829>>>>>>>>>>>>>
86829>>>>>>>>>>>>>        Case Begin
86829>>>>>>>>>>>>>            Case (MertechInc_DriverName = SQLFLEX)
86831>>>>>>>>>>>>>                sql_set_stmt to (SFormat("sys.sp_procedure_params_managed @procedure_name = '%1'", sFunctionName))
86839>>>>>>>>>>>>>                sql_prepare_stmt
86851>>>>>>>>>>>>>                sql_execute_stmt
86866>>>>>>>>>>>>>
86866>>>>>>>>>>>>>                Repeat
86866>>>>>>>>>>>>>>
86866>>>>>>>>>>>>>                    sql_fetch_next_row
86881>>>>>>>>>>>>>>
86881>>>>>>>>>>>>>                    If (Found) Begin
86883>>>>>>>>>>>>>                        sql_fetch_column 6 into iParamType
86888>>>>>>>>>>>>>
86888>>>>>>>>>>>>>                        If (iParamType = 1) Move "IN" to vFuncParams[i]
86891>>>>>>>>>>>>>                        If (iParamType = 2) Move "INOUT" to vFuncParams[i]
86894>>>>>>>>>>>>>                        If (iParamType = 3) Move "OUT" to vFuncParams[i]
86897>>>>>>>>>>>>>                        If (iParamType <> 4) Increment i
86900>>>>>>>>>>>>>                    End
86900>>>>>>>>>>>>>>
86900>>>>>>>>>>>>>                Until (not(Found))
86902>>>>>>>>>>>>>
86902>>>>>>>>>>>>>                Function_Return vFuncParams
86903>>>>>>>>>>>>>
86903>>>>>>>>>>>>>                Case Break
86904>>>>>>>>>>>>>            Case (MertechInc_DriverName = MySQLFlex)
86907>>>>>>>>>>>>>                sql_set_stmt to (SFormat("select parameter_mode from INFORMATION_SCHEMA.PARAMETERS where SPECIFIC_NAME = '%1' order by ordinal_position", sFunctionName))
86915>>>>>>>>>>>>>                sql_prepare_stmt
86927>>>>>>>>>>>>>                sql_execute_stmt
86942>>>>>>>>>>>>>
86942>>>>>>>>>>>>>                Case Break
86943>>>>>>>>>>>>>            Case (MertechInc_DriverName = ORAFLEX)
86946>>>>>>>>>>>>>                sql_set_stmt to    "SELECT all_arguments.in_out as parameter_mode "
86954>>>>>>>>>>>>>                sql_append_stmt to "FROM all_objects inner join all_arguments on all_objects.object_id = all_arguments.object_id "
86962>>>>>>>>>>>>>                sql_append_stmt to (SFormat("WHERE all_objects.object_name = '%1' order by all_arguments.position", sFunctionName))
86970>>>>>>>>>>>>>                sql_prepare_stmt
86982>>>>>>>>>>>>>                sql_execute_stmt
86997>>>>>>>>>>>>>
86997>>>>>>>>>>>>>                Case Break
86998>>>>>>>>>>>>>            Case (MertechInc_DriverName = PgFlex)
87001>>>>>>>>>>>>>                sql_set_stmt    to "select information_schema.parameters.parameter_mode "
87009>>>>>>>>>>>>>                sql_append_stmt to "from information_schema.routines inner join information_schema.parameters "
87017>>>>>>>>>>>>>                sql_append_stmt to "on information_schema.routines.specific_name=information_schema.parameters.specific_name "
87025>>>>>>>>>>>>>                sql_append_stmt to (SFormat("where information_schema.routines.routine_name = '%1' ", sFunctionName))
87033>>>>>>>>>>>>>                sql_append_stmt to "order by information_schema.parameters.ordinal_position"
87041>>>>>>>>>>>>>                sql_prepare_stmt
87053>>>>>>>>>>>>>                sql_execute_stmt
87068>>>>>>>>>>>>>
87068>>>>>>>>>>>>>                Case Break
87069>>>>>>>>>>>>>        Case End
87069>>>>>>>>>>>>>
87069>>>>>>>>>>>>>        Repeat
87069>>>>>>>>>>>>>>
87069>>>>>>>>>>>>>            sql_fetch_next_row into vFuncParams[i]
87093>>>>>>>>>>>>>>
87093>>>>>>>>>>>>>            Increment i
87094>>>>>>>>>>>>>        Until (not(Found))
87096>>>>>>>>>>>>>
87096>>>>>>>>>>>>>        Function_Return vFuncParams
87097>>>>>>>>>>>>>    End_Function
87098>>>>>>>>>>>>>
87098>>>>>>>>>>>>>    Procedure Set StoreHandleInfo Handle hConn
87100>>>>>>>>>>>>>        Set phCLIHandle to hConn
87101>>>>>>>>>>>>>    End_Procedure
87102>>>>>>>>>>>>>
87102>>>>>>>>>>>>>    Procedure FreeHandle
87104>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
87118>>>>>>>>>>>>>>
87118>>>>>>>>>>>>>
87118>>>>>>>>>>>>>                                 Case Begin
87118>>>>>>>>>>>>>            Case (MertechInc_DriverName = SQLFLEX)
87120>>>>>>>>>>>>>                                END_CALL_PROCEDURE
87125>>>>>>>>>>>>>                Case Break
87126>>>>>>>>>>>>>            Case (MertechInc_DriverName = MySQLFlex)
87129>>>>>>>>>>>>>                Case Break
87130>>>>>>>>>>>>>            Case (MertechInc_DriverName = ORAFLEX)
87133>>>>>>>>>>>>>                Case Break
87134>>>>>>>>>>>>>            Case (MertechInc_DriverName = PgFlex)
87137>>>>>>>>>>>>>                Case Break
87138>>>>>>>>>>>>>        Case End
87138>>>>>>>>>>>>>
87138>>>>>>>>>>>>>
87138>>>>>>>>>>>>>        SQL_CLOSE_CURSOR_STMT to (piCursorNum(Self))
87152>>>>>>>>>>>>>>
87152>>>>>>>>>>>>>        Send Destroy_Object
87153>>>>>>>>>>>>>    End_Procedure // FreeHandle
87154>>>>>>>>>>>>>
87154>>>>>>>>>>>>>    Procedure SQLClose
87156>>>>>>>>>>>>>        Send FreeHandle
87157>>>>>>>>>>>>>    End_Procedure // SQLClose
87158>>>>>>>>>>>>>
87158>>>>>>>>>>>>>    Procedure HandleError Integer ihstmt Integer ihdbc String sDrvrId String sOriginMsg
87160>>>>>>>>>>>>>        Integer iErrHandle
87160>>>>>>>>>>>>>        Integer iErrNum
87160>>>>>>>>>>>>>        String  sLocationInfo
87160>>>>>>>>>>>>>
87160>>>>>>>>>>>>>        //*** Get the DataFlex statement identifier
87160>>>>>>>>>>>>>        Move Current_object to iErrHandle
87161>>>>>>>>>>>>>
87161>>>>>>>>>>>>>        //*** Determine error number
87161>>>>>>>>>>>>>        If (ihstmt = 0) ;            Move CLIERR_SQLINVALID_CLI_STMT_HANDLE to iErrNum
87164>>>>>>>>>>>>>        Else If (ihdbc = 0) ;            Move CLIERR_SQLINVALID_CLI_CONN_HANDLE to iErrNum
87168>>>>>>>>>>>>>        Else If (sDrvrId = "") ;            Move CLIERR_SQLINVALID_DRIVER_ID to iErrNum
87172>>>>>>>>>>>>>        Else ;            Move CLIERR_SQL_ERROR to iErrNum
87174>>>>>>>>>>>>>
87174>>>>>>>>>>>>>        //*** Create location information
87174>>>>>>>>>>>>>        Move "[" to sLocationInfo
87175>>>>>>>>>>>>>        If (sOriginMsg <> "") Begin
87177>>>>>>>>>>>>>            Move (Append(sLocationInfo, sOriginMsg)) to sLocationInfo
87178>>>>>>>>>>>>>            Move (Append(sLocationInfo, ", "))       to sLocationInfo
87179>>>>>>>>>>>>>        End
87179>>>>>>>>>>>>>>
87179>>>>>>>>>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) to sLocationInfo
87180>>>>>>>>>>>>>        Move (Append(sLocationInfo, iErrHandle))          to sLocationInfo
87181>>>>>>>>>>>>>        Move (Append(sLocationInfo, "]"))                 to sLocationInfo
87182>>>>>>>>>>>>>
87182>>>>>>>>>>>>>        //*** Generate the error
87182>>>>>>>>>>>>>        Error iErrNum sLocationInfo
87183>>>>>>>>>>>>>>
87183>>>>>>>>>>>>>    End_Procedure
87184>>>>>>>>>>>>>
87184>>>>>>>>>>>>>    Procedure StmtError Integer iErrNum String sErrText String sOriginMsg
87186>>>>>>>>>>>>>        Integer iErrHandle
87186>>>>>>>>>>>>>        String  sLocationInfo
87186>>>>>>>>>>>>>
87186>>>>>>>>>>>>>        //*** Get the DataFlex statement identifier
87186>>>>>>>>>>>>>        Move Current_object to iErrHandle
87187>>>>>>>>>>>>>
87187>>>>>>>>>>>>>
87187>>>>>>>>>>>>>        //*** Create location information
87187>>>>>>>>>>>>>        Move "[" to sLocationInfo
87188>>>>>>>>>>>>>        If (sOriginMsg <> "") Begin
87190>>>>>>>>>>>>>            Move (Append(sLocationInfo, sOriginMsg)) to sLocationInfo
87191>>>>>>>>>>>>>            Move (Append(sLocationInfo, ", "))       to sLocationInfo
87192>>>>>>>>>>>>>        End
87192>>>>>>>>>>>>>>
87192>>>>>>>>>>>>>        If (sErrtext <> "") Begin
87194>>>>>>>>>>>>>            Move (Append(sLocationInfo, sErrtext)) to sLocationInfo
87195>>>>>>>>>>>>>            Move (Append(sLocationInfo, ", "))     to sLocationInfo
87196>>>>>>>>>>>>>        End
87196>>>>>>>>>>>>>>
87196>>>>>>>>>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) to sLocationInfo
87197>>>>>>>>>>>>>        Move (Append(sLocationInfo, iErrHandle))          to sLocationInfo
87198>>>>>>>>>>>>>        Move (Append(sLocationInfo, "]"))                 to sLocationInfo
87199>>>>>>>>>>>>>
87199>>>>>>>>>>>>>        //*** Generate the error
87199>>>>>>>>>>>>>        Error iErrNum sLocationInfo
87200>>>>>>>>>>>>>>
87200>>>>>>>>>>>>>    End_Procedure
87201>>>>>>>>>>>>>
87201>>>>>>>>>>>>>    Procedure SQLIllegalAttribute String sErrText String sOriginMsg
87203>>>>>>>>>>>>>        Integer bReport
87203>>>>>>>>>>>>>
87203>>>>>>>>>>>>>        Get_Attribute DF_REPORT_UNSUPPORTED_ATTRIBUTES to bReport
87206>>>>>>>>>>>>>        If (bReport) ;            Send StmtError CLIERR_SQLINVALID_ATTRIBUTE sErrtext sOriginMsg
87209>>>>>>>>>>>>>    End_Procedure // SQLIllegalAttribute
87210>>>>>>>>>>>>>
87210>>>>>>>>>>>>>    Function SQLColumnValue Integer iCol Returns String
87212>>>>>>>>>>>>>        String sResult
87212>>>>>>>>>>>>>        Integer iCols
87212>>>>>>>>>>>>>        Integer iOrgDateFmt
87212>>>>>>>>>>>>>        Integer iOrgDateSep
87212>>>>>>>>>>>>>        String sType
87212>>>>>>>>>>>>>
87212>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
87226>>>>>>>>>>>>>>
87226>>>>>>>>>>>>>
87226>>>>>>>>>>>>>        SQL_GET_NUM_COLS to iCols
87236>>>>>>>>>>>>>>
87236>>>>>>>>>>>>>        If (iCol <= iCols) Begin
87238>>>>>>>>>>>>>            //DAC SQL Driver currently uses military format for the SQL getting of dates.
87238>>>>>>>>>>>>>            If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
87240>>>>>>>>>>>>>                Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
87243>>>>>>>>>>>>>                Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
87246>>>>>>>>>>>>>                Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
87249>>>>>>>>>>>>>                Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
87252>>>>>>>>>>>>>            End
87252>>>>>>>>>>>>>>
87252>>>>>>>>>>>>>
87252>>>>>>>>>>>>>            //DAC SQL Driver cannot directly get TEXT fields into a result.
87252>>>>>>>>>>>>>            If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
87254>>>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol DFTYPE to sType
87271>>>>>>>>>>>>>>
87271>>>>>>>>>>>>>                If (sType=5) Move "" to sResult
87274>>>>>>>>>>>>>                Else Begin
87275>>>>>>>>>>>>>                    SQL_FETCH_COLUMN iCol into sResult
87280>>>>>>>>>>>>>                End
87280>>>>>>>>>>>>>>
87280>>>>>>>>>>>>>            End
87280>>>>>>>>>>>>>>
87280>>>>>>>>>>>>>            Else Begin
87281>>>>>>>>>>>>>               SQL_FETCH_COLUMN iCol into sResult
87286>>>>>>>>>>>>>            End
87286>>>>>>>>>>>>>>
87286>>>>>>>>>>>>>
87286>>>>>>>>>>>>>
87286>>>>>>>>>>>>>            If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
87288>>>>>>>>>>>>>                Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
87291>>>>>>>>>>>>>                Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
87294>>>>>>>>>>>>>            End
87294>>>>>>>>>>>>>>
87294>>>>>>>>>>>>>
87294>>>>>>>>>>>>>            Function_Return sResult
87295>>>>>>>>>>>>>        End
87295>>>>>>>>>>>>>>
87295>>>>>>>>>>>>>        Else Send HandleError (phCLIHandle(Self)) (phCLIHandle(Parent(Self))) (psDriverID(Self)) "SQLColumnValue"
87297>>>>>>>>>>>>>    End_Function // SQLColumnValue
87298>>>>>>>>>>>>>
87298>>>>>>>>>>>>>    Function SQLNextColumn Returns String
87300>>>>>>>>>>>>>        Integer iCol
87300>>>>>>>>>>>>>        String  sResult
87300>>>>>>>>>>>>>
87300>>>>>>>>>>>>>        Get piLastColumn to iCol
87301>>>>>>>>>>>>>        Increment iCol
87302>>>>>>>>>>>>>        Get SQLColumnValue iCol to sResult
87303>>>>>>>>>>>>>        Set piLastColumn to iCol
87304>>>>>>>>>>>>>
87304>>>>>>>>>>>>>        Function_Return sResult
87305>>>>>>>>>>>>>    End_Function // SQLNextColumn
87306>>>>>>>>>>>>>
87306>>>>>>>>>>>>>    Procedure SQLPrepare String sStatement
87308>>>>>>>>>>>>>        tColumnMap tColumnMap
87308>>>>>>>>>>>>>        tColumnMap tColumnMap
87308>>>>>>>>>>>>>        Set ptColumnMap to tColumnMap
87309>>>>>>>>>>>>>        Set pisBeforeFetch to True
87310>>>>>>>>>>>>>
87310>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
87324>>>>>>>>>>>>>>
87324>>>>>>>>>>>>>        SQL_SET_STMT to sStatement
87332>>>>>>>>>>>>>
87332>>>>>>>>>>>>>        SQL_PREPARE_STMT
87344>>>>>>>>>>>>>    End_Procedure // SQLPrepare
87345>>>>>>>>>>>>>
87345>>>>>>>>>>>>>    Procedure SQLExecute
87347>>>>>>>>>>>>>        SQL_EXECUTE_STMT
87362>>>>>>>>>>>>>    End_Procedure
87363>>>>>>>>>>>>>
87363>>>>>>>>>>>>>    Procedure SQLExecDirect String sStatement
87365>>>>>>>>>>>>>        tColumnMap tColumnMap
87365>>>>>>>>>>>>>        tColumnMap tColumnMap
87365>>>>>>>>>>>>>        Set ptColumnMap to tColumnMap
87366>>>>>>>>>>>>>        Set pisBeforeFetch to True
87367>>>>>>>>>>>>>
87367>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
87381>>>>>>>>>>>>>>
87381>>>>>>>>>>>>>
87381>>>>>>>>>>>>>        SQL_SET_STMT to sStatement
87389>>>>>>>>>>>>>        SQL_PREPARE_STMT
87401>>>>>>>>>>>>>        SQL_EXECUTE_STMT
87416>>>>>>>>>>>>>    End_Procedure
87417>>>>>>>>>>>>>
87417>>>>>>>>>>>>>    Function SQLFetch Returns Integer
87419>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
87433>>>>>>>>>>>>>>
87433>>>>>>>>>>>>>        Set pisBeforeFetch to False
87434>>>>>>>>>>>>>
87434>>>>>>>>>>>>>        SQL_FETCH_NEXT_ROW
87449>>>>>>>>>>>>>>
87449>>>>>>>>>>>>>        Function_Return (Found)
87450>>>>>>>>>>>>>    End_Function
87451>>>>>>>>>>>>>
87451>>>>>>>>>>>>>    Procedure SQLBindFile Integer iFileNum
87453>>>>>>>>>>>>>        tColumnMap tColumnMap
87453>>>>>>>>>>>>>        tColumnMap tColumnMap
87453>>>>>>>>>>>>>        String[] sBindFileColumns
87454>>>>>>>>>>>>>        Integer[] iBufferColumn
87455>>>>>>>>>>>>>        Integer iColCnt i iDateFormat iResultColumnType iBindFileColumnType
87455>>>>>>>>>>>>>        String sColumnName
87455>>>>>>>>>>>>>        Variant vFieldValue
87455>>>>>>>>>>>>>        Boolean isRecnumTable
87455>>>>>>>>>>>>>
87455>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
87469>>>>>>>>>>>>>>
87469>>>>>>>>>>>>>
87469>>>>>>>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE of iFileNum to isRecnumTable
87472>>>>>>>>>>>>>        Get ptColumnMap to tColumnMap
87473>>>>>>>>>>>>>
87473>>>>>>>>>>>>>        If (tColumnMap.iFileNum <> iFileNum) Begin
87475>>>>>>>>>>>>>            Move iFileNum to tColumnMap.iFileNum
87476>>>>>>>>>>>>>
87476>>>>>>>>>>>>>            // First we build an array of the column names (in order) from the file buffer to bind to
87476>>>>>>>>>>>>>            Get_Attribute DF_FILE_NUMBER_FIELDS of iFileNum to iColCnt
87479>>>>>>>>>>>>>            For i from 0 to iColCnt
87485>>>>>>>>>>>>>>
87485>>>>>>>>>>>>>                If (isRecnumTable) Get_Attribute DF_FIELD_NAME of iFileNum i to sColumnName
87490>>>>>>>>>>>>>                Else Move "" to sColumnName
87492>>>>>>>>>>>>>
87492>>>>>>>>>>>>>                Move (Uppercase(sColumnName)) to sBindFileColumns[i]
87493>>>>>>>>>>>>>            Loop
87494>>>>>>>>>>>>>>
87494>>>>>>>>>>>>>
87494>>>>>>>>>>>>>            // Next we iterate over the columns in the resultset.  Any column names that match we
87494>>>>>>>>>>>>>            // set its match location into an array that maps each resultset column to its matching
87494>>>>>>>>>>>>>            // column number in the file buffer.  If there is no match, we set that resultset
87494>>>>>>>>>>>>>            // column mappped column to -1.
87494>>>>>>>>>>>>>            //
87494>>>>>>>>>>>>>            // Since Arrays are zero based and columns are numbered from 1, when we actually map
87494>>>>>>>>>>>>>            // to set the value, we need to add 1 to array indexer to get the proper resultset
87494>>>>>>>>>>>>>            // column AND we need to add 1 to the mapped-to column since it was loaded into a zero
87494>>>>>>>>>>>>>            // based array also.  (Ex: vResultColumn[0] = 2 means column 1 from the resultset maps
87494>>>>>>>>>>>>>            // to Column 3 of the file buffer)
87494>>>>>>>>>>>>>
87494>>>>>>>>>>>>>
87494>>>>>>>>>>>>>            SQL_GET_NUM_COLS to iColCnt
87504>>>>>>>>>>>>>>
87504>>>>>>>>>>>>>            For i from 1 to iColCnt
87510>>>>>>>>>>>>>>
87510>>>>>>>>>>>>>                SQL_GET_COL_NAME i to sColumnName
87526>>>>>>>>>>>>>>
87526>>>>>>>>>>>>>                // Because SearchArray returns -1 if there isn't a match, we don't need to do
87526>>>>>>>>>>>>>                // anything to make an "unmapped column" have a value of -1.
87526>>>>>>>>>>>>>                Move (SearchArray(Uppercase(sColumnName), sBindFileColumns)) to tColumnMap.vResultColumn[i-1]
87527>>>>>>>>>>>>>
87527>>>>>>>>>>>>>                // If the types don't match between the columns, then "unmap" the column.  This
87527>>>>>>>>>>>>>                // should only occur when you're not mapping to the same file as the resultset.
87527>>>>>>>>>>>>>                // In this case, sql.pkg silently does nothing, so we need to duplicate this instead
87527>>>>>>>>>>>>>                // of generating an error.  If the mapping is to a string, then any type can be
87527>>>>>>>>>>>>>                // converted to a string so its okay.
87527>>>>>>>>>>>>>                If (tColumnMap.vResultColumn[i-1] <> -1) Begin
87529>>>>>>>>>>>>>                    SQL_GET_COL_ATTRIBUTE of i DFTYPE to iResultColumnType
87546>>>>>>>>>>>>>>
87546>>>>>>>>>>>>>                    Get_Attribute DF_FIELD_TYPE of iFileNum (tColumnMap.vResultColumn[i-1]) to iBindFileColumnType
87549>>>>>>>>>>>>>
87549>>>>>>>>>>>>>                    // If the conversion is to string (even if the resultset column is something
87549>>>>>>>>>>>>>                    // else) its ok, so Break out of the If block before we muck things up.
87549>>>>>>>>>>>>>                    If (iBindFileColumnType = DF_ASCII) Break
87552>>>>>>>>>>>>>
87552>>>>>>>>>>>>>                    // Otherwise, break the mapping
87552>>>>>>>>>>>>>                    If (iResultColumnType <> iBindFileColumnType) Move -1 to tColumnMap.vResultColumn[i-1]
87555>>>>>>>>>>>>>                End
87555>>>>>>>>>>>>>>
87555>>>>>>>>>>>>>            Loop
87556>>>>>>>>>>>>>>
87556>>>>>>>>>>>>>
87556>>>>>>>>>>>>>            Set ptColumnMap to tColumnMap
87557>>>>>>>>>>>>>        End
87557>>>>>>>>>>>>>>
87557>>>>>>>>>>>>>
87557>>>>>>>>>>>>>        Get SQL_USE_DATAFLEX_DATEFORMAT to iDateFormat
87558>>>>>>>>>>>>>        Set SQL_USE_DATAFLEX_DATEFORMAT to True
87559>>>>>>>>>>>>>        Clear iFileNum
87560>>>>>>>>>>>>>        For i from 0 to (SizeOfArray(tColumnMap.vResultColumn)-1)
87566>>>>>>>>>>>>>>
87566>>>>>>>>>>>>>            If (tColumnMap.vResultColumn[i] > -1) Begin
87568>>>>>>>>>>>>>                SQL_FETCH_COLUMN (i+1) into vFieldValue
87573>>>>>>>>>>>>>                Set_Field_Value iFileNum (tColumnMap.vResultColumn[i]) to vFieldValue
87576>>>>>>>>>>>>>            End
87576>>>>>>>>>>>>>>
87576>>>>>>>>>>>>>        Loop
87577>>>>>>>>>>>>>>
87577>>>>>>>>>>>>>        Set_Attribute DF_FILE_STATUS of iFileNum to DF_FILE_ACTIVE
87580>>>>>>>>>>>>>        Set SQL_USE_DATAFLEX_DATEFORMAT to iDateFormat
87581>>>>>>>>>>>>>    End_Procedure
87582>>>>>>>>>>>>>
87582>>>>>>>>>>>>>    Function SQLGetData Integer iCol Integer iLen Returns String
87584>>>>>>>>>>>>>        String data
87584>>>>>>>>>>>>>        Integer retlen
87584>>>>>>>>>>>>>
87584>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
87598>>>>>>>>>>>>>>
87598>>>>>>>>>>>>>
87598>>>>>>>>>>>>>        SQL_SET_CHUNK_SIZE to iLen
87615>>>>>>>>>>>>>>
87615>>>>>>>>>>>>>        SQL_GET_DATA_CHUNK COLUMN iCol OFFSET (piDataChunkOffset(Self)) to data retlen
87625>>>>>>>>>>>>>>
87625>>>>>>>>>>>>>        Set piDataChunkOffset to (piDataChunkOffset(Self)+retlen)
87626>>>>>>>>>>>>>
87626>>>>>>>>>>>>>        Function_Return data
87627>>>>>>>>>>>>>    End_Function
87628>>>>>>>>>>>>>
87628>>>>>>>>>>>>>    Function SQLColumnMap String sColname Returns Integer
87630>>>>>>>>>>>>>        Integer iNumColumns i iIndex
87630>>>>>>>>>>>>>        String[] cols
87631>>>>>>>>>>>>>
87631>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
87645>>>>>>>>>>>>>>
87645>>>>>>>>>>>>>
87645>>>>>>>>>>>>>        Get SQLStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT to iNumColumns
87646>>>>>>>>>>>>>
87646>>>>>>>>>>>>>        For i from 1 to iNumColumns
87652>>>>>>>>>>>>>>
87652>>>>>>>>>>>>>            SQL_GET_COL_NAME i to cols[i-1]
87668>>>>>>>>>>>>>>
87668>>>>>>>>>>>>>            Move (trim(Uppercase(cols[i-1]))) to cols[i-1]
87669>>>>>>>>>>>>>        Loop
87670>>>>>>>>>>>>>>
87670>>>>>>>>>>>>>
87670>>>>>>>>>>>>>        Move (trim(Uppercase(sColname))) to sColname
87671>>>>>>>>>>>>>        Move (SearchArray(sColname, cols)) to iIndex
87672>>>>>>>>>>>>>        Function_Return (iIndex+1)  // even if searcharray returns -1 (not found) this expects 0 for not found, so it's ok
87673>>>>>>>>>>>>>    End_Function
87674>>>>>>>>>>>>>
87674>>>>>>>>>>>>>    Function SQLStmtAttribute Integer iAttribId Returns String
87676>>>>>>>>>>>>>        Integer iCnt
87676>>>>>>>>>>>>>
87676>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
87690>>>>>>>>>>>>>>
87690>>>>>>>>>>>>>
87690>>>>>>>>>>>>>        Case Begin
87690>>>>>>>>>>>>>            Case (iAttribId = SQLSTMTATTRIB_COLUMNCOUNT)
87692>>>>>>>>>>>>>                SQL_GET_NUM_COLS to iCnt
87702>>>>>>>>>>>>>>
87702>>>>>>>>>>>>>                Function_Return iCnt
87703>>>>>>>>>>>>>                Case Break
87704>>>>>>>>>>>>>            Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT)
87707>>>>>>>>>>>>>                SQL_GET_NUM_ROWS to iCnt
87717>>>>>>>>>>>>>>
87717>>>>>>>>>>>>>
87717>>>>>>>>>>>>>                //DAC Driver doesn't know the rowcount before the first fetch.
87717>>>>>>>>>>>>>                If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
87719>>>>>>>>>>>>>                    If (pisBeforeFetch(Self)) Function_Return -1
87722>>>>>>>>>>>>>                End
87722>>>>>>>>>>>>>>
87722>>>>>>>>>>>>>
87722>>>>>>>>>>>>>                Function_Return iCnt
87723>>>>>>>>>>>>>                Case Break
87724>>>>>>>>>>>>>            Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT_TYPE)
87727>>>>>>>>>>>>>                // TODO: Need something to indicate the quality of the SQL_GET_NUM_ROWS, or fake till I make it
87727>>>>>>>>>>>>>                Case Break
87728>>>>>>>>>>>>>            Case (iAttribId = SQLSTMTATTRIB_NUMMESSAGES)
87731>>>>>>>>>>>>>                Function_Return -1
87732>>>>>>>>>>>>>                // TODO: Are the messages returned in SQLGetMessage from the driver, or from the underlying connection?
87732>>>>>>>>>>>>>                Case Break
87733>>>>>>>>>>>>>            Case Else
87733>>>>>>>>>>>>>        Case End
87733>>>>>>>>>>>>>
87733>>>>>>>>>>>>>    End_Function
87734>>>>>>>>>>>>>
87734>>>>>>>>>>>>>    Function SQLColAttribute Integer iCol Integer iAttribId Returns String
87736>>>>>>>>>>>>>        String sValue
87736>>>>>>>>>>>>>        Integer iSQLType
87736>>>>>>>>>>>>>        Integer iDFType
87736>>>>>>>>>>>>>
87736>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
87750>>>>>>>>>>>>>>
87750>>>>>>>>>>>>>        SQL_GET_COL_ATTRIBUTE of iCol SQLTYPE to iSQLType
87767>>>>>>>>>>>>>>
87767>>>>>>>>>>>>>        SQL_GET_COL_ATTRIBUTE of iCol DFTYPE to iDFType
87784>>>>>>>>>>>>>>
87784>>>>>>>>>>>>>
87784>>>>>>>>>>>>>        Case Begin
87784>>>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_SIZE)
87786>>>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol SIZE to sValue
87803>>>>>>>>>>>>>>
87803>>>>>>>>>>>>>
87803>>>>>>>>>>>>>                //DAC Driver uses different values.
87803>>>>>>>>>>>>>                If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
87805>>>>>>>>>>>>>                    If (iSQLType=12) Move (Integer(sValue-1)) to sValue
87808>>>>>>>>>>>>>                    If (iDFType=5) Move "0" to sValue
87811>>>>>>>>>>>>>                    If (iSQLType=40)  Move "10" to sValue
87814>>>>>>>>>>>>>                End
87814>>>>>>>>>>>>>>
87814>>>>>>>>>>>>>
87814>>>>>>>>>>>>>                Case Break
87815>>>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_PRECISION)
87818>>>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol DECIMALS to sValue
87835>>>>>>>>>>>>>>
87835>>>>>>>>>>>>>                Case Break
87836>>>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_LABEL)
87839>>>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol COLUMN_NAME to sValue
87856>>>>>>>>>>>>>>
87856>>>>>>>>>>>>>                Case Break
87857>>>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_BASECOLUMNNAME)
87860>>>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol COLUMN_NAME to sValue
87877>>>>>>>>>>>>>>
87877>>>>>>>>>>>>>
87877>>>>>>>>>>>>>                //DAC Driver doesn't use Base Column Name.
87877>>>>>>>>>>>>>                If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
87879>>>>>>>>>>>>>                    Move "" to sValue
87880>>>>>>>>>>>>>                End
87880>>>>>>>>>>>>>>
87880>>>>>>>>>>>>>
87880>>>>>>>>>>>>>                Case Break
87881>>>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_BASETABLENAME)
87884>>>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol TABLE_NAME to sValue
87901>>>>>>>>>>>>>>
87901>>>>>>>>>>>>>                Case Break
87902>>>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_SQLTYPE)
87905>>>>>>>>>>>>>                Move iSQLType to sValue
87906>>>>>>>>>>>>>
87906>>>>>>>>>>>>>                //DAC Driver uses different values.
87906>>>>>>>>>>>>>                If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
87908>>>>>>>>>>>>>                    If (iSQLType=2) Move "3" to sValue
87911>>>>>>>>>>>>>                    If (iSQLType=-99) Move "12" to sValue
87914>>>>>>>>>>>>>                    If (iSQLType=40)  Move "91" to sValue
87917>>>>>>>>>>>>>                End
87917>>>>>>>>>>>>>>
87917>>>>>>>>>>>>>
87917>>>>>>>>>>>>>                Case Break
87918>>>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_NULLABLE)
87921>>>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol NULLABLE to sValue
87938>>>>>>>>>>>>>>
87938>>>>>>>>>>>>>                Case Break
87939>>>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_DFTYPE)
87942>>>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol DFTYPE to sValue
87959>>>>>>>>>>>>>>
87959>>>>>>>>>>>>>
87959>>>>>>>>>>>>>                //DAC Driver uses different values.
87959>>>>>>>>>>>>>                If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
87961>>>>>>>>>>>>>                    If (iDFType = 5) Move "0" to sValue
87964>>>>>>>>>>>>>                End
87964>>>>>>>>>>>>>>
87964>>>>>>>>>>>>>                Case Break
87965>>>>>>>>>>>>>        Case End
87965>>>>>>>>>>>>>
87965>>>>>>>>>>>>>        Function_Return sValue
87966>>>>>>>>>>>>>    End_Function
87967>>>>>>>>>>>>>
87967>>>>>>>>>>>>>    Procedure SQLSetProcedureName String sProcName String sSchemaArg
87969>>>>>>>>>>>>>        Set psProcName to sProcName
87970>>>>>>>>>>>>>        If (Num_Arguments >= 2) ;            Set psSchemaName to sSchemaArg
87973>>>>>>>>>>>>>        Else ;            Set psSchemaName to ""
87975>>>>>>>>>>>>>    End_Procedure
87976>>>>>>>>>>>>>
87976>>>>>>>>>>>>>    Procedure SQLSetNextArgument String sArgument
87978>>>>>>>>>>>>>        Integer iArgnum
87978>>>>>>>>>>>>>
87978>>>>>>>>>>>>>        Get piLastArgument to iArgnum
87979>>>>>>>>>>>>>        Increment iArgnum
87980>>>>>>>>>>>>>        Send SQLSetArgument iArgnum sArgument
87981>>>>>>>>>>>>>        Set piLastArgument to iArgnum
87982>>>>>>>>>>>>>    End_Procedure // SQLSetNextArgument
87983>>>>>>>>>>>>>
87983>>>>>>>>>>>>>    Procedure SQLSetArgument Integer iArgnum String sArgument
87985>>>>>>>>>>>>>        Variant[] vParams
87986>>>>>>>>>>>>>
87986>>>>>>>>>>>>>        Get pvParams to vParams
87987>>>>>>>>>>>>>        Move sArgument to vParams[iArgnum-1]
87988>>>>>>>>>>>>>        Set pvParams to vParams
87989>>>>>>>>>>>>>
87989>>>>>>>>>>>>>    End_Procedure // SQLSetArgument
87990>>>>>>>>>>>>>
87990>>>>>>>>>>>>>    Procedure SQLCall
87992>>>>>>>>>>>>>        Variant[] vParams
87993>>>>>>>>>>>>>        Variant[] vParamOpts
87994>>>>>>>>>>>>>        Integer i
87994>>>>>>>>>>>>>        Integer iMax
87994>>>>>>>>>>>>>        Integer iParamsIn
87994>>>>>>>>>>>>>        String sParameter
87994>>>>>>>>>>>>>        Boolean bIsProcedure
87994>>>>>>>>>>>>>
87994>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
88008>>>>>>>>>>>>>>
88008>>>>>>>>>>>>>
88008>>>>>>>>>>>>>        Get pvParams to vParams
88009>>>>>>>>>>>>>
88009>>>>>>>>>>>>>        // First, we need to figure out if this is a procedure or a function. Then if
88009>>>>>>>>>>>>>        // it's a procedure, "analyze" it to figure out which parameters are IN,
88009>>>>>>>>>>>>>        // OUT, or IN_OUT.  Then we adjust how we call SQL_SET_PROCEDURE_PARAMETER
88009>>>>>>>>>>>>>        // so that after the call you can retrieve the value.
88009>>>>>>>>>>>>>
88009>>>>>>>>>>>>>        Get IsProcedure (psProcName(Self)) to bIsProcedure
88010>>>>>>>>>>>>>
88010>>>>>>>>>>>>>        If (bIsProcedure) Begin
88012>>>>>>>>>>>>>            Get ProcParams (psProcName(Self)) to vParamOpts
88013>>>>>>>>>>>>>
88013>>>>>>>>>>>>>            Move (sizeOfArray(vParamOpts)) to iMax
88014>>>>>>>>>>>>>            Move (SizeOfArray(vParams)) to iParamsIn
88015>>>>>>>>>>>>>            Set piParameterCount to iMax
88016>>>>>>>>>>>>>
88016>>>>>>>>>>>>>            SQL_SET_PROCEDURE_NAME (psProcName(Self)) NUMPAR iMax
88036>>>>>>>>>>>>>            For i from 1 to iMax
88042>>>>>>>>>>>>>>
88042>>>>>>>>>>>>>                If ( (i-1) >= iParamsIn) Move "" to sParameter
88045>>>>>>>>>>>>>                Else Move vParams[i-1] to sParameter
88047>>>>>>>>>>>>>
88047>>>>>>>>>>>>>                Case Begin
88047>>>>>>>>>>>>>                    Case (vParamOpts[i-1] = "IN")
88049>>>>>>>>>>>>>                        SQL_SET_PROCEDURE_PARAMETER i to sParameter IN
88090>>>>>>>>>>>>>>
88090>>>>>>>>>>>>>                        Case Break
88091>>>>>>>>>>>>>                    Case (vParamOpts[i-1] = "OUT")
88094>>>>>>>>>>>>>                        SQL_SET_PROCEDURE_PARAMETER i to sParameter OUT
88135>>>>>>>>>>>>>>
88135>>>>>>>>>>>>>                        Case Break
88136>>>>>>>>>>>>>                    Case (vParamOpts[i-1] = "IN/OUT" or vParamOpts[i-1] = "INOUT")
88139>>>>>>>>>>>>>                        SQL_SET_PROCEDURE_PARAMETER i to sParameter IN_OUT
88180>>>>>>>>>>>>>>
88180>>>>>>>>>>>>>                        Case Break
88181>>>>>>>>>>>>>                Case End
88181>>>>>>>>>>>>>            Loop
88182>>>>>>>>>>>>>>
88182>>>>>>>>>>>>>
88182>>>>>>>>>>>>>            SQL_PROCEDURE_EXECUTE
88197>>>>>>>>>>>>>        End
88197>>>>>>>>>>>>>>
88197>>>>>>>>>>>>>        Else Begin
88198>>>>>>>>>>>>>            SQL_SET_FUNCTION_NAME (psProcName(Self)) NUMPAR (SizeOfArray(vParams))
88222>>>>>>>>>>>>>            For i from 1 to (SizeOfArray(vParams))
88228>>>>>>>>>>>>>>
88228>>>>>>>>>>>>>                SQL_SET_FUNCTION_PARAMETER i to vParams[i-1]
88300>>>>>>>>>>>>>>
88300>>>>>>>>>>>>>            Loop
88301>>>>>>>>>>>>>>
88301>>>>>>>>>>>>>
88301>>>>>>>>>>>>>            SQL_FUNCTION_EXECUTE
88302>>>>>>>>>>>>>        End
88302>>>>>>>>>>>>>>
88302>>>>>>>>>>>>>    End_Procedure
88303>>>>>>>>>>>>>
88303>>>>>>>>>>>>>    Function SQLGetNextArgument Returns String
88305>>>>>>>>>>>>>        Integer iArgnum
88305>>>>>>>>>>>>>        String  sResult
88305>>>>>>>>>>>>>
88305>>>>>>>>>>>>>        Get piLastArgument to iArgnum
88306>>>>>>>>>>>>>        Increment iArgnum
88307>>>>>>>>>>>>>        Get SQLGetArgument iArgnum to sResult
88308>>>>>>>>>>>>>        Set piLastArgument to iArgnum
88309>>>>>>>>>>>>>
88309>>>>>>>>>>>>>        Function_Return sResult
88310>>>>>>>>>>>>>    End_Function // SQLGetNextArgument
88311>>>>>>>>>>>>>
88311>>>>>>>>>>>>>    Function SQLGetArgument Integer iArgnum Returns String
88313>>>>>>>>>>>>>        String retval
88313>>>>>>>>>>>>>
88313>>>>>>>>>>>>>        If ( (piParameterCount(Self)) < iArgnum) Function_Return ""
88316>>>>>>>>>>>>>        SQL_GET_PROCEDURE_PARAMETER iArgnum to retval
88340>>>>>>>>>>>>>>
88340>>>>>>>>>>>>>
88340>>>>>>>>>>>>>        Function_Return retval
88341>>>>>>>>>>>>>    End_Function
88342>>>>>>>>>>>>>
88342>>>>>>>>>>>>>    Function SQLReturnValue Returns String
88344>>>>>>>>>>>>>        String retval
88344>>>>>>>>>>>>>
88344>>>>>>>>>>>>>        SQL_GET_FUNCTION_RETURN to retval
88376>>>>>>>>>>>>>        Function_Return retval
88377>>>>>>>>>>>>>    End_Function
88378>>>>>>>>>>>>>
88378>>>>>>>>>>>>>    Function SQLNextResultSet Returns Integer
88380>>>>>>>>>>>>>        SQL_NEXT_RESULT_SET
88392>>>>>>>>>>>>>
88392>>>>>>>>>>>>>        Function_Return (Found)
88393>>>>>>>>>>>>>    End_Function
88394>>>>>>>>>>>>>
88394>>>>>>>>>>>>>    Function SQLGetMessage Integer iMessageNum Returns String
88396>>>>>>>>>>>>>        // TODO
88396>>>>>>>>>>>>>    End_Function
88397>>>>>>>>>>>>>
88397>>>>>>>>>>>>>    Procedure SQLFetchActivatesBuffer Integer iFileNum Integer bState
88399>>>>>>>>>>>>>        // TODO
88399>>>>>>>>>>>>>    End_Procedure
88400>>>>>>>>>>>>>
88400>>>>>>>>>>>>>
88400>>>>>>>>>>>>>End_Class
88401>>>>>>>>>>>>>
88401>>>>>>>>>>>>>Class cSQLConnectionDUF is a cObject
88402>>>>>>>>>>>>>    Procedure Construct_Object
88404>>>>>>>>>>>>>        Forward Send Construct_Object
88406>>>>>>>>>>>>>
88406>>>>>>>>>>>>>        Property Handle phCLIHandle 0
88407>>>>>>>>>>>>>        Property String psDriverID MertechInc_DriverName
88408>>>>>>>>>>>>>        Property Integer piBindFile 0
88409>>>>>>>>>>>>>        Property String psUsername ""
88410>>>>>>>>>>>>>        Property String psPassword ""
88411>>>>>>>>>>>>>
88411>>>>>>>>>>>>>        Property String psCurrentDatabase ""
88412>>>>>>>>>>>>>
88412>>>>>>>>>>>>>        Property tCLIHandleMap ptCLIHandleMap
88413>>>>>>>>>>>>>    End_Procedure
88414>>>>>>>>>>>>>
88414>>>>>>>>>>>>>    Procedure StoreHandleInfo Handle hCLIHandle String sDrvrId Handle iParentHandle
88416>>>>>>>>>>>>>        Set phCLIHandle      to hCLIHandle
88417>>>>>>>>>>>>>        Set psDriverID       to sDrvrId
88418>>>>>>>>>>>>>    End_Procedure // StoreHandleInfo
88419>>>>>>>>>>>>>
88419>>>>>>>>>>>>>    Procedure FreeHandle
88421>>>>>>>>>>>>>        Send Destroy
88422>>>>>>>>>>>>>    End_Procedure
88423>>>>>>>>>>>>>
88423>>>>>>>>>>>>>    Procedure Set SQLDatabase String sDatabase
88425>>>>>>>>>>>>>        tCLIHandleMap conn
88425>>>>>>>>>>>>>        tCLIHandleMap conn
88425>>>>>>>>>>>>>
88425>>>>>>>>>>>>>        Get ptCLIHandleMap to conn
88426>>>>>>>>>>>>>        Set psCurrentDatabase to sDatabase
88427>>>>>>>>>>>>>        SQL_USE_DATABASE of conn.sConnect to sDatabase
88441>>>>>>>>>>>>>>
88441>>>>>>>>>>>>>    End_Procedure
88442>>>>>>>>>>>>>
88442>>>>>>>>>>>>>    Function SQLConnect String sDriver String sConnect Returns Handle
88444>>>>>>>>>>>>>        tCLIHandleMap[] maps
88444>>>>>>>>>>>>>        tCLIHandleMap[] maps
88445>>>>>>>>>>>>>        tCLIHandleMap conn
88445>>>>>>>>>>>>>        tCLIHandleMap conn
88445>>>>>>>>>>>>>
88445>>>>>>>>>>>>>        Get ptCLIHandleMaps to maps
88446>>>>>>>>>>>>>        Move sDriver to conn.sDriver
88447>>>>>>>>>>>>>        Move sConnect to conn.sConnect
88448>>>>>>>>>>>>>
88448>>>>>>>>>>>>>        If (SizeOfArray(maps) > 0) Move (maps[(SizeOfArray(maps)-1)].iHdbc+1) to conn.iHdbc
88451>>>>>>>>>>>>>        Else Move 1 to conn.iHdbc
88453>>>>>>>>>>>>>
88453>>>>>>>>>>>>>        Set CurrentConnection to sDriver sConnect
88454>>>>>>>>>>>>>        If (not(Err)) Begin
88456>>>>>>>>>>>>>            Move conn to maps[(SizeOfArray(maps))]
88457>>>>>>>>>>>>>            Set ptCLIHandleMaps to maps
88458>>>>>>>>>>>>>            Set ptCLIHandleMap to conn
88459>>>>>>>>>>>>>        End
88459>>>>>>>>>>>>>>
88459>>>>>>>>>>>>>
88459>>>>>>>>>>>>>        Function_Return Self
88460>>>>>>>>>>>>>    End_Function
88461>>>>>>>>>>>>>
88461>>>>>>>>>>>>>    Function SQLFileConnect Integer iFileNum Returns Integer
88463>>>>>>>>>>>>>        Boolean bIsOpen
88463>>>>>>>>>>>>>        String sDriver sServer
88463>>>>>>>>>>>>>        tCLIHandleMap[] maps
88463>>>>>>>>>>>>>        tCLIHandleMap[] maps
88464>>>>>>>>>>>>>        tCLIHandleMap conn
88464>>>>>>>>>>>>>        tCLIHandleMap conn
88464>>>>>>>>>>>>>
88464>>>>>>>>>>>>>        Get_Attribute DF_FILE_OPENED of iFileNum to bIsOpen
88467>>>>>>>>>>>>>        If (bIsOpen) Begin
88469>>>>>>>>>>>>>            //*** Fill the driver id, assume longest is 255 characters
88469>>>>>>>>>>>>>            Move (Repeat(' ', 255)) to sDriver
88470>>>>>>>>>>>>>            Move (Repeat(' ', 255)) to sServer
88471>>>>>>>>>>>>>            Get_Attribute DF_FILE_DRIVER of iFileNum to sDriver
88474>>>>>>>>>>>>>            Get_Attribute DF_FILE_SERVER_NAME of iFileNum to sServer
88477>>>>>>>>>>>>>
88477>>>>>>>>>>>>>            Indicate Err False
88478>>>>>>>>>>>>>
88478>>>>>>>>>>>>>            Get ptCLIHandleMaps to maps
88479>>>>>>>>>>>>>            Move sDriver to conn.sDriver
88480>>>>>>>>>>>>>            Move sServer to conn.sConnect
88481>>>>>>>>>>>>>
88481>>>>>>>>>>>>>            If (SizeOfArray(maps) > 0) Move (maps[(SizeOfArray(maps)-1)].iHdbc+1) to conn.iHdbc
88484>>>>>>>>>>>>>            Else Move 1 to conn.iHdbc
88486>>>>>>>>>>>>>
88486>>>>>>>>>>>>>            Set CurrentConnection to sDriver sServer
88487>>>>>>>>>>>>>            If (not(Err)) Begin
88489>>>>>>>>>>>>>                Move conn to maps[(SizeOfArray(maps))]
88490>>>>>>>>>>>>>                Set ptCLIHandleMaps to maps
88491>>>>>>>>>>>>>                Set ptCLIHandleMap to conn
88492>>>>>>>>>>>>>            End
88492>>>>>>>>>>>>>>
88492>>>>>>>>>>>>>
88492>>>>>>>>>>>>>            Send StoreHandleInfo conn.iHdbc conn.sDriver
88493>>>>>>>>>>>>>            Set piBindFile to iFileNum
88494>>>>>>>>>>>>>        End
88494>>>>>>>>>>>>>>
88494>>>>>>>>>>>>>        Else Error 4099 "File Not Open"
88496>>>>>>>>>>>>>
88496>>>>>>>>>>>>>        //*** Return success status
88496>>>>>>>>>>>>>        Function_Return (not(Err))
88497>>>>>>>>>>>>>    End_Function
88498>>>>>>>>>>>>>
88498>>>>>>>>>>>>>    Procedure SQLDisconnect
88500>>>>>>>>>>>>>        tCLIHandleMap map
88500>>>>>>>>>>>>>        tCLIHandleMap map
88500>>>>>>>>>>>>>        tCLIHandleMap[] maps
88500>>>>>>>>>>>>>        tCLIHandleMap[] maps
88501>>>>>>>>>>>>>        Integer iFound
88501>>>>>>>>>>>>>
88501>>>>>>>>>>>>>        Get ptCLIHandleMap to map
88502>>>>>>>>>>>>>        Get ptCLIHandleMaps to maps
88503>>>>>>>>>>>>>
88503>>>>>>>>>>>>>        Move (SearchArray(map, maps, Parent(Self), RefFunc(CompareMaps))) to iFound
88504>>>>>>>>>>>>>        If (iFound > -1) Begin
88506>>>>>>>>>>>>>            Send FreeHandle
88507>>>>>>>>>>>>>        End
88507>>>>>>>>>>>>>>
88507>>>>>>>>>>>>>    End_Procedure // SQLDisconnect
88508>>>>>>>>>>>>>
88508>>>>>>>>>>>>>    Function CreateHandle Returns Integer
88510>>>>>>>>>>>>>        Handle hSQL
88510>>>>>>>>>>>>>        Integer iCursor
88510>>>>>>>>>>>>>
88510>>>>>>>>>>>>>        Get Create U_cSQLStatementDUF to hSQL
88511>>>>>>>>>>>>>
88511>>>>>>>>>>>>>        Set piBindFile of hSQL to (piBindFile(Current_object))
88512>>>>>>>>>>>>>
88512>>>>>>>>>>>>>        SQL_OPEN_CURSOR_STMT to iCursor
88526>>>>>>>>>>>>>>
88526>>>>>>>>>>>>>        Set piCursorNum of hSQL to iCursor
88527>>>>>>>>>>>>>
88527>>>>>>>>>>>>>        Function_Return hSQL
88528>>>>>>>>>>>>>    End_Function // CreateHandle
88529>>>>>>>>>>>>>
88529>>>>>>>>>>>>>    Function SQLOpen Returns Integer
88531>>>>>>>>>>>>>        Handle hDFHandle
88531>>>>>>>>>>>>>
88531>>>>>>>>>>>>>        Get CreateHandle to hDFHandle
88532>>>>>>>>>>>>>
88532>>>>>>>>>>>>>        Send StoreHandleInfo to hDFHandle Self (psDriverID(Self))
88533>>>>>>>>>>>>>
88533>>>>>>>>>>>>>        Function_Return hDFHandle
88534>>>>>>>>>>>>>    End_Function // SQLOpen
88535>>>>>>>>>>>>>
88535>>>>>>>>>>>>>
88535>>>>>>>>>>>>>
88535>>>>>>>>>>>>>
88535>>>>>>>>>>>>>    Function DriverIndex String sDriver Returns Integer
88537>>>>>>>>>>>>>        String sCurrentDriver
88537>>>>>>>>>>>>>        Integer iDriver
88537>>>>>>>>>>>>>        Integer iNumDrivers
88537>>>>>>>>>>>>>
88537>>>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumDrivers
88540>>>>>>>>>>>>>        For iDriver from 1 to iNumDrivers
88546>>>>>>>>>>>>>>
88546>>>>>>>>>>>>>          Get_Attribute DF_DRIVER_NAME of iDriver to sCurrentDriver
88549>>>>>>>>>>>>>          If (Uppercase(sDriver) = Uppercase(sCurrentDriver)) ;              Function_Return iDriver
88552>>>>>>>>>>>>>        Loop
88553>>>>>>>>>>>>>>
88553>>>>>>>>>>>>>        Function_Return 0
88554>>>>>>>>>>>>>    End_Function // DriverIndex
88555>>>>>>>>>>>>>
88555>>>>>>>>>>>>>    Function FirstServerForDriverNo Integer iDriver Returns String
88557>>>>>>>>>>>>>        String sServer
88557>>>>>>>>>>>>>        Integer iNumServers
88557>>>>>>>>>>>>>        Integer iServer
88557>>>>>>>>>>>>>
88557>>>>>>>>>>>>>        If (iDriver <> 0) Begin
88559>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iNumServers
88562>>>>>>>>>>>>>            If (iNumServers<>0) Begin
88564>>>>>>>>>>>>>                Move 1 to iServer
88565>>>>>>>>>>>>>                Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iServer to sServer
88568>>>>>>>>>>>>>            End
88568>>>>>>>>>>>>>>
88568>>>>>>>>>>>>>        End
88568>>>>>>>>>>>>>>
88568>>>>>>>>>>>>>
88568>>>>>>>>>>>>>        Function_Return sServer
88569>>>>>>>>>>>>>    End_Function
88570>>>>>>>>>>>>>
88570>>>>>>>>>>>>>    Procedure Set CurrentConnection String sDriver String sServer
88572>>>>>>>>>>>>>        Integer iDriver
88572>>>>>>>>>>>>>        String sUsername
88572>>>>>>>>>>>>>        String sPassword
88572>>>>>>>>>>>>>
88572>>>>>>>>>>>>>        If (sDriver="") Begin
88574>>>>>>>>>>>>>            DO_GETFILENUMBER_DRIVERNAME 0
88576>>>>>>>>>>>>>            Move MertechInc_DriverName to sDriver
88577>>>>>>>>>>>>>        End
88577>>>>>>>>>>>>>>
88577>>>>>>>>>>>>>
88577>>>>>>>>>>>>>        If ("MDSMYSQL|ORA_DRV|MDSPGSQL|SQL_DRV|MDS_DB2" contains Uppercase(Trim(sDriver))) Begin
88579>>>>>>>>>>>>>            Move (Uppercase(Trim(sDriver))) to MertechInc_DriverName
88580>>>>>>>>>>>>>
88580>>>>>>>>>>>>>            If (Trim(sDriver) <> "") Move (Uppercase(Trim(sDriver))) to MertechInc_CurrentDriver
88583>>>>>>>>>>>>>            Else Move "" to MertechInc_CurrentDriver
88585>>>>>>>>>>>>>
88585>>>>>>>>>>>>>            Get psUsername to sUsername
88586>>>>>>>>>>>>>            Get psPassword to sPassword
88587>>>>>>>>>>>>>
88587>>>>>>>>>>>>>            Get DriverIndex MertechInc_CurrentDriver to iDriver
88588>>>>>>>>>>>>>
88588>>>>>>>>>>>>>            If (sServer="") Get FirstServerForDriverNo iDriver to sServer
88591>>>>>>>>>>>>>            If (sUsername="") GET_CURRENT_USER_NAME of sServer to sUsername
88608>>>>>>>>>>>>>            If (sPassword="") get_current_user_password of sServer to sPassword
88625>>>>>>>>>>>>>            Move False to Err
88626>>>>>>>>>>>>>            Send Ignore_Error of Error_Object_Id 25000
88627>>>>>>>>>>>>>            Login sServer sUsername sPassword sDriver
88629>>>>>>>>>>>>>            Send Trap_Error of Error_Object_Id 25000
88630>>>>>>>>>>>>>            If (Err = False) Begin
88632>>>>>>>>>>>>>                Call_Driver 0 MertechInc_DriverName Function CALLDRV_CURRENT_SQL_SERVER_CONNECTION CALLBACK 0 PASSING sServer MertechInc_Blank 0 RESULT MertechInc_iRet
88637>>>>>>>>>>>>>            End
88637>>>>>>>>>>>>>>
88637>>>>>>>>>>>>>            Else Begin
88638>>>>>>>>>>>>>                Procedure_Return
88639>>>>>>>>>>>>>            End
88639>>>>>>>>>>>>>>
88639>>>>>>>>>>>>>
88639>>>>>>>>>>>>>            If MertechInc_iRet EQ -1 INDICATE ERR True
88642>>>>>>>>>>>>>        End
88642>>>>>>>>>>>>>>
88642>>>>>>>>>>>>>        Else Error 4099 "Invalid Driver"
88644>>>>>>>>>>>>>
88644>>>>>>>>>>>>>    End_Procedure
88645>>>>>>>>>>>>>
88645>>>>>>>>>>>>>End_Class
88646>>>>>>>>>>>>>
88646>>>>>>>>>>>>>Class cSQLHandleManagerDUF is a cObject
88647>>>>>>>>>>>>>
88647>>>>>>>>>>>>>    Procedure Construct_Object
88649>>>>>>>>>>>>>        Forward Send Construct_Object
88651>>>>>>>>>>>>>
88651>>>>>>>>>>>>>        Property String  psDefaultDriver     ""
88652>>>>>>>>>>>>>        Property String  psDefaultConnection ""
88653>>>>>>>>>>>>>        Property tCLIHandleMap[] ptCLIHandleMaps
88654>>>>>>>>>>>>>    End_Procedure
88655>>>>>>>>>>>>>
88655>>>>>>>>>>>>>    Function CompareMaps tCLIHandleMap map1 tCLIHandleMap map2 Returns Integer
88657>>>>>>>>>>>>>        If ((map1.iHdbc = map2.iHdbc) and (map1.sConnect = map2.sConnect) and (map1.sDriver = map2.sDriver)) Begin
88659>>>>>>>>>>>>>            Function_Return (EQ)
88660>>>>>>>>>>>>>        End
88660>>>>>>>>>>>>>>
88660>>>>>>>>>>>>>    End_Function
88661>>>>>>>>>>>>>
88661>>>>>>>>>>>>>    Function CreateHandle Returns Handle
88663>>>>>>>>>>>>>        Handle hSQL
88663>>>>>>>>>>>>>
88663>>>>>>>>>>>>>        Get Create U_cSQLConnectionDUF to hSQL
88664>>>>>>>>>>>>>        Function_Return hSQL
88665>>>>>>>>>>>>>    End_Function
88666>>>>>>>>>>>>>
88666>>>>>>>>>>>>>    Procedure SQLSetConnect String sDriver String sConnect
88668>>>>>>>>>>>>>        Set psDefaultDriver to sDriver
88669>>>>>>>>>>>>>        Set psDefaultConnection to sConnect
88670>>>>>>>>>>>>>    End_Procedure
88671>>>>>>>>>>>>>
88671>>>>>>>>>>>>>    Function SQLConnect String sDriver String sConnect String sUsername String sPassword Returns Handle
88673>>>>>>>>>>>>>        Handle hSql
88673>>>>>>>>>>>>>        Boolean bOK
88673>>>>>>>>>>>>>
88673>>>>>>>>>>>>>        Get CreateHandle to hSql
88674>>>>>>>>>>>>>
88674>>>>>>>>>>>>>        If (sDriver = "" and sConnect = "") Begin
88676>>>>>>>>>>>>>            Move (psDefaultDriver(Self)) to sDriver
88677>>>>>>>>>>>>>            Move (psDefaultConnection(Self)) to sConnect
88678>>>>>>>>>>>>>        End
88678>>>>>>>>>>>>>>
88678>>>>>>>>>>>>>
88678>>>>>>>>>>>>>        If (num_arguments>2) Begin
88680>>>>>>>>>>>>>            Set psUsername of hSql to sUsername
88681>>>>>>>>>>>>>            Set psPassword of hSql to sPassword
88682>>>>>>>>>>>>>        End
88682>>>>>>>>>>>>>>
88682>>>>>>>>>>>>>
88682>>>>>>>>>>>>>        Get SQLConnect of hSql sDriver sConnect to bOK
88683>>>>>>>>>>>>>        If (not(bOK)) Begin
88685>>>>>>>>>>>>>            Send FreeHandle of hSQL
88686>>>>>>>>>>>>>            Function_Return 0
88687>>>>>>>>>>>>>        End
88687>>>>>>>>>>>>>>
88687>>>>>>>>>>>>>
88687>>>>>>>>>>>>>        Function_Return hSql
88688>>>>>>>>>>>>>    End_Function
88689>>>>>>>>>>>>>
88689>>>>>>>>>>>>>    Function SQLFileConnect Integer iFileNum Returns Integer
88691>>>>>>>>>>>>>        Handle hSql
88691>>>>>>>>>>>>>        Boolean bOK
88691>>>>>>>>>>>>>
88691>>>>>>>>>>>>>        //*** Allocate a new handle
88691>>>>>>>>>>>>>        Get CreateHandle to hSql
88692>>>>>>>>>>>>>        Get SQLFileConnect of hSql iFileNum to bOK
88693>>>>>>>>>>>>>
88693>>>>>>>>>>>>>        //*** If failure, kill the handle and return a 0 handle
88693>>>>>>>>>>>>>        If (not(bOK)) Begin
88695>>>>>>>>>>>>>            Send FreeHandle of hSql
88696>>>>>>>>>>>>>            Function_Return 0
88697>>>>>>>>>>>>>        End
88697>>>>>>>>>>>>>>
88697>>>>>>>>>>>>>
88697>>>>>>>>>>>>>        Function_Return hSql
88698>>>>>>>>>>>>>    End_Function // SQLFileConnect
88699>>>>>>>>>>>>>
88699>>>>>>>>>>>>>End_Class
88700>>>>>>>>>>>>>
88700>>>>>>>>>>>>>
88700>>>>>>>>>>>>>Function CreateSQLmanager for cDesktop Returns Integer
88702>>>>>>>>>>>>>    Handle hSqlManager
88702>>>>>>>>>>>>>
88702>>>>>>>>>>>>>    Get Create U_cSQLHandleManagerDUF to hSqlManager
88703>>>>>>>>>>>>>    Function_Return hSqlManager
88704>>>>>>>>>>>>>End_Function // CreateSQLMngr
88705>>>>>>>>>>>>>
88705>>>>>>>>>>>>>
88705>>>>>>>>>>>>>
88705>>>>>>>>>>>>>
88705>>>>>>>>>>>>>
88705>>>>>>>>>>>>>
88705>>>>>>>>>>>>>Get CreateSQLManager of Desktop to _embsqlghoSQLHandleMngr
88706>>>>>>>>>>>>>
88706>>>>>>>>>>>>>
88706>>>>>>>>>>>    Use Mertech.inc
88706>>>>>>>>>>>
88706>>>>>>>>>>>Use cDbUpdateFunctionLibrary.inc
88706>>>>>>>>>
88706>>>>>>>>>// This needs to be after Mertech drivers are defined.
88706>>>>>>>>>Use cDbUpdateFunctionLibrary_Mixin.pkg
88706>>>>>>>>>
88706>>>>>>>>>
88706>>>>>>>>>
88706>>>>>>>>>
88706>>>>>>>>>
88706>>>>>>>>>
88706>>>>>>>>>
88706>>>>>>>>>// SQLConnection.ini constants:
88706>>>>>>>>>    Define CS_SQLConnectionIDText       for "DFConnectionId"
88706>>>>>>>>>Define CS_SQLIniFileName                for "SQLConnections.ini"
88706>>>>>>>>>Define CS_SQLDF19IniFileName            for "DFConnId.ini"
88706>>>>>>>>>Define CS_SQLIniConnectionSection       for "SQL Connections" // Obsolete!
88706>>>>>>>>>Define CS_SQLIniSectionName             for "Connection"
88706>>>>>>>>>
88706>>>>>>>>>// DF 19 ini-file settings:
88706>>>>>>>>>Define CS_SQLIniConnectionIdKeyword     for "Id"
88706>>>>>>>>>Define CS_SQLIniDriverKeyword           for "Driver"
88706>>>>>>>>>Define CS_SQLIniConnectionKeyWord       for "Connection"
88706>>>>>>>>>Define CS_SQLIniUIDKeyword              for "UID"
88706>>>>>>>>>Define CS_SQLIniPWDKeyword              for "PWD"
88706>>>>>>>>>Define CS_SQLIniDFPWDKeyword            for "DFPWD"
88706>>>>>>>>>Define CS_SQLIniServerKeyword           for "SERVER"
88706>>>>>>>>>Define CS_SQLIniDSNKeyword              for "DSN"
88706>>>>>>>>>Define CS_SQLIniDatabaseKeyword         for "DATABASE"
88706>>>>>>>>>Define CS_SQLIniTrustedKeyword          for "Trusted_Connection"
88706>>>>>>>>>
88706>>>>>>>>>// Database Update Framework extended settings:
88706>>>>>>>>>Define CS_SQLIniDbTypeKeyword           for "DbType"
88706>>>>>>>>>Define CS_SQLIniSchemaKeyword           for "Schema"
88706>>>>>>>>>Define CS_SQLIniBaseTableSpaceKeyword   for "Base Table Space"
88706>>>>>>>>>Define CS_SQLIniLongTableSpaceKeyword   for "Long Table Space"
88706>>>>>>>>>Define CS_SQLIniIndexTableSpaceKeyword  for "Index Table Space"
88706>>>>>>>>>Define CS_SQLIniSilentLoginKeyword      for "Silent Login"
88706>>>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"      // For compatability with DF19.
88706>>>>>>>>>
88706>>>>>>>>>Define CS_SQLIniConnectionPWD           for "PWD"
88706>>>>>>>>>Define CS_SQLIniConnectionYes           for "Yes"
88706>>>>>>>>>Define CS_SQLIniConnectionNo            for "No"
88706>>>>>>>>>
88706>>>>>>>>>Struct tSQLConnection
88706>>>>>>>>>    Boolean bEnabled                // 1. There can only be one active/enabled connection at a time.
88706>>>>>>>>>    String sConnectionID            // 2. The name of the connection ID.
88706>>>>>>>>>    Integer iDbType                 // 3. Database type; "MS-SQL Server", "DB2", "Oracle", "MySQL", "PostgreSQL"
88706>>>>>>>>>    String sDriverID                // 4. Name of the driver. E.g. "MSSQLDRV", "DB2_DRV" or "ODBC_DRV".
88706>>>>>>>>>    String sServer                  // 5. SQL Server/DSN/ODBC source name. (In DF19 this is the "sString" member of the tConnection struct.)
88706>>>>>>>>>    String sDatabase                // 6. SQL Database
88706>>>>>>>>>    String sConnectionString        // 7. Full connection string as is needed by e.g. the login command.
88706>>>>>>>>>    Boolean bTrusted                // 8. Trusted connection (then is UID & PWD not used)
88706>>>>>>>>>    String sUserID                  // 9. User ID
88706>>>>>>>>>    String sPassword                // 10. Password
88706>>>>>>>>>    String sSchema                  // 11. DB2 (and perhaps ODBC specific)
88706>>>>>>>>>    String sBaseTableSpace          // 12. DB2 specific
88706>>>>>>>>>    String sLongTableSpace          // 13. DB2 specific
88706>>>>>>>>>    String sIndexTableSpace         // 14. DB2 specific
88706>>>>>>>>>    Boolean bSilentLogin            // 15. True=Silent login. (i.e. don't show Database login dialog if database login to fails). Same as driver "Options" parameter.
88706>>>>>>>>>    Boolean bError                  // 16. Set to true on error.
88706>>>>>>>>>    Boolean bDAWConnection          // 17. True if a DFConnId.ini file (from DAW) has been used instead of a DUF SQLConnections.ini file.
88706>>>>>>>>>//    Boolean bDisabled               // 17. For compatability with DF19 Managed Connections only. Not used by DUF (Database Update Framework).
88706>>>>>>>>>//    Integer iDriverIndex            // 18. For compatability with DF19 Managed Connections only. Not used by DUF (Database Update Framework).
88706>>>>>>>>>End_Struct
88706>>>>>>>
88706>>>>>>>Class cDbUpdateFunctionLibrary_Mixin is a Mixin
88707>>>>>>>    Procedure CreateDbUpdateLibraryProperties
88709>>>>>>>        Handle hoSQLManagerMT
88709>>>>>>>
88709>>>>>>>        Property String Private.psUseDatabase ""
88710>>>>>>>
88710>>>>>>>//        { Visibility=Private }
88710>>>>>>>        // These are used by the Error routine to show the Table# & Field# if something goes wrong:
88710>>>>>>>        Property Handle  Private.phCurrentTable 0
88711>>>>>>>        Property Integer Private.piCurrentField 0
88712>>>>>>>
88712>>>>>>>        Property Handle phoCLIHandler      (Create(Self,RefClass(cCLIHandler)))
88713>>>>>>>        Property Handle phoSQLManager      (Create(Self,RefClass(cSQLHandleManager)))
88714>>>>>>>
88714>>>>>>>        Property Handle phoSQLManagerMT
88715>>>>>>>            Move (Create(Self,RefClass(cSQLHandleManagerDUF))) to hoSQLManagerMT
88716>>>>>>>            Set phoSQLManagerMT to hoSQLManagerMT
88717>>>>>>>
88717>>>>>>>        Property Handle phoMSSQLHandler    (Create(Self,RefClass(cMSSQLHandler)))
88718>>>>>>>        Property Handle phoDB2SQLHandler   (Create(Self,RefClass(cDB2Handler)))
88719>>>>>>>        Property Handle phoODBCSQLHandler  (Create(Self,RefClass(cODBCHandler)))
88720>>>>>>>        Property Handle phoSQLConnectionHandler 0
88721>>>>>>>        Property tSQLKeyWords[] paSQLKeywordArray
88722>>>>>>>
88722>>>>>>>        Property Boolean pbHandleQueryErrors True
88723>>>>>>>
88723>>>>>>>        Property tSqlColumnNew[] paQueryColumns
88724>>>>>>>        Property String[] paSQLFetchResults
88725>>>>>>>
88725>>>>>>>        // Error handling     
88725>>>>>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT        
88726>>>>>>>        Property Boolean pbSqlError False
88727>>>>>>>        Property tSqlErrorArray paSqlErrorArray
88728>>>>>>>        Property Boolean pbProcessingError False
88729>>>>>>>
88729>>>>>>>        // Statistics on query
88729>>>>>>>        Property TimeSpan ptsTotalQueryTime
88730>>>>>>>        Property TimeSpan ptsQueryExec
88731>>>>>>>        Property TimeSpan ptsFetchResults
88732>>>>>>>        Property Integer piColumns 0
88733>>>>>>>        Property Integer piRows 0
88734>>>>>>>        Property Integer piRowType 0
88735>>>>>>>        Property String[] paQueryMessages
88736>>>>>>>        Property String psSQLStatementString
88737>>>>>>>
88737>>>>>>>        Property Integer[] paTableConvertExceptions
88738>>>>>>>
88738>>>>>>>        Property Integer[] paTableDateCorrectionExceptions
88739>>>>>>>
88739>>>>>>>        // Number of SQL statements (chunks) to be executed when executing a really big
88739>>>>>>>        // SQL file that has been compiled into the program. It is way faster to divide
88739>>>>>>>        // the statements in smaller chunks than to execute them all at the same time.
88739>>>>>>>        Property Integer piChunkMax 500
88740>>>>>>>
88740>>>>>>>        // Fill the paSQLKeywordArray array with values;
88740>>>>>>>        Send SetupSQLKeywordArray
88741>>>>>>>    End_Procedure
88742>>>>>>>
88742>>>>>>>    // Custom array find function. It compares both the iSQLWord & iSQLDbType params.
88742>>>>>>>    Function CompareFindSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
88744>>>>>>>        If (SQLKeywords1.iSQLWord = SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType = SQLKeywords2.iSQLDbType) Begin
88746>>>>>>>            Function_Return (EQ)
88747>>>>>>>        End
88747>>>>>>>>
88747>>>>>>>        Function_Return (GT)
88748>>>>>>>    End_Function
88749>>>>>>>
88749>>>>>>>    // Custom array sort function. It compares both the iSQLWord & iSQLDbType params.
88749>>>>>>>    Function CompareSortSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
88751>>>>>>>        If (SQLKeywords1.iSQLWord   < SQLKeywords2.iSQLWord) ;            Function_Return (LT)
88754>>>>>>>        If (SQLKeywords1.iSQLWord   > SQLKeywords2.iSQLWord) ;            Function_Return (GT)
88757>>>>>>>        If (SQLKeywords1.iSQLDbType < SQLKeywords2.iSQLDbType) ;            Function_Return (LT)
88760>>>>>>>        If (SQLKeywords1.iSQLDbType > SQLKeywords2.iSQLDbType) ;            Function_Return (GT)
88763>>>>>>>
88763>>>>>>>        Function_Return (EQ)
88764>>>>>>>    End_Function
88765>>>>>>>
88765>>>>>>>    Procedure Add_Element Integer iSQLKeywordConstant Integer iEN_dbType String sSQLKeyword
88767>>>>>>>        tSQLKeyWords[] SQLKeywordArray
88767>>>>>>>        tSQLKeyWords[] SQLKeywordArray
88768>>>>>>>        Integer iSize
88768>>>>>>>
88768>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
88769>>>>>>>        Move (SizeOfArray(SQLKeywordArray)) to iSize
88770>>>>>>>        Move iSQLKeywordConstant to SQLKeywordArray[iSize].iSQLWord
88771>>>>>>>        Move iEN_dbType          to SQLKeywordArray[iSize].iSQLDbType
88772>>>>>>>        Move sSQLKeyword         to SQLKeywordArray[iSize].sSQLPhrase
88773>>>>>>>
88773>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
88774>>>>>>>    End_Procedure
88775>>>>>>>
88775>>>>>>>    // Creates a struct array with all SQL keywords
88775>>>>>>>    // for all EN_xxx SQL back-ends. Various back-ends can
88775>>>>>>>    // have slightly different wording.
88775>>>>>>>    // If a new EN_dbTypexxx type is added; additions
88775>>>>>>>    // needs to be done for every keyword group below.
88775>>>>>>>    Procedure SetupSQLKeywordArray
88777>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
88777>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
88779>>>>>>>
88779>>>>>>>        // This should only be called once; but in case it is
88779>>>>>>>        // we delete the array first.
88779>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
88780>>>>>>>
88780>>>>>>>        // ToDo: *** Not all SQL Key-words has been checked for other backends than MS-SQL ***
88780>>>>>>>        //
88780>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMSSQL    "ALTER DATABASE"
88781>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMySQL    "ALTER DATABASE"
88782>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeOracle   "ALTER DATABASE"
88783>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeDB2      "ALTER DATABASE"
88784>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypePostgre  "ALTER DATABASE"  
88785>>>>>>>        
88785>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMSSQL    "SINGLE_USER"
88786>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMySQL    "SINGLE_USER"
88787>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeOracle   "SINGLE_USER"
88788>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeDB2      "SINGLE_USER"
88789>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypePostgre  "SINGLE_USER"  
88790>>>>>>>        
88790>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMSSQL    "MULTI_USER"
88791>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMySQL    "MULTI_USER"
88792>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeOracle   "MULTI_USER"
88793>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeDB2      "MULTI_USER"
88794>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypePostgre  "MULTI_USER"  
88795>>>>>>>        
88795>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMSSQL    "ROLLBACK"
88796>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMySQL    "ROLLBACK"
88797>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeOracle   "ROLLBACK"
88798>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeDB2      "ROLLBACK"
88799>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypePostgre  "ROLLBACK"  
88800>>>>>>>        
88800>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMSSQL    "IMMEDIATE"
88801>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMySQL    "IMMEDIATE"
88802>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeOracle   "IMMEDIATE"
88803>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeDB2      "IMMEDIATE"
88804>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypePostgre  "IMMEDIATE"  
88805>>>>>>>        
88805>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMSSQL    "ALTER TABLE"
88806>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMySQL    "ALTER TABLE"
88807>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeOracle   "ALTER TABLE"
88808>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeDB2      "ALTER TABLE"
88809>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypePostgre  "ALTER TABLE"
88810>>>>>>>
88810>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMSSQL           "ADD"
88811>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMySQL           "ADD"
88812>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeOracle          "ADD"
88813>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeDB2             "ADD"
88814>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypePostgre         "ADD"
88815>>>>>>>
88815>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMSSQL        "UPDATE"
88816>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMySQL        "UPDATE"
88817>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeOracle       "UPDATE"
88818>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeDB2          "UPDATE"
88819>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypePostgre      "UPDATE"
88820>>>>>>>
88820>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMSSQL       "NOT NULL"
88821>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMySQL       "NOT NULL"
88822>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeOracle      "" // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
88823>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeDB2         "DEFAULT NOT NULL"
88824>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypePostgre     "NOT NULL"
88825>>>>>>>
88825>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMSSQL           "SET"
88826>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMySQL           "SET"
88827>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeOracle          "SET"
88828>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeDB2             "SET"
88829>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypePostgre         "SET"
88830>>>>>>>
88830>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMSSQL          "WITH"
88831>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMySQL          "WITH"
88832>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeOracle         "WITH"
88833>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeDB2            "WITH"
88834>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypePostgre        "WITH"
88835>>>>>>>
88835>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMSSQL    "CREATE DATABASE"
88836>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMySQL    "CREATE DATABASE"
88837>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeOracle   "CREATE DATABASE"
88838>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeDB2      "CREATE DATABASE"
88839>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypePostgre  "CREATE DATABASE"
88840>>>>>>>
88840>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMSSQL    "COLLATE"
88841>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMySQL    "COLLATE"
88842>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeOracle   "COLLATE"
88843>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeDB2      "COLLATE"
88844>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypePostgre  "COLLATE"
88845>>>>>>>
88845>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMSSQL    "CREATE VIEW"
88846>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMySQL    "CREATE VIEW"
88847>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeOracle   "CREATE VIEW"
88848>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeDB2      "CREATE VIEW"
88849>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypePostgre  "CREATE VIEW"
88850>>>>>>>
88850>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMSSQL      "DROP VIEW"
88851>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMySQL      "DROP VIEW"
88852>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeOracle     "DROP VIEW"
88853>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeDB2        "DROP VIEW"
88854>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypePostgre    "DROP VIEW"
88855>>>>>>>
88855>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMSSQL   "CREATE TABLE"
88856>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMySQL   "CREATE TABLE"
88857>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeOracle  "CREATE TABLE"
88858>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeDB2     "CREATE TABLE"
88859>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypePostgre "CREATE TABLE"
88860>>>>>>>
88860>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMSSQL     "DROP TABLE"
88861>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMySQL     "DROP TABLE"
88862>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeOracle    "DROP TABLE"
88863>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeDB2       "DROP TABLE"
88864>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypePostgre   "DROP TABLE"
88865>>>>>>>
88865>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMSSQL   "EXEC sp_rename"
88866>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMySQL   "RENAME TABLE"
88867>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeOracle  "RENAME TABLE"
88868>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeDB2     "RENAME TABLE"
88869>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypePostgre "RENAME TO"
88870>>>>>>>
88870>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMSSQL    "DROP COLUMN"
88871>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMySQL    "DROP COLUMN"
88872>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeOracle   "DROP COLUMN"
88873>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeDB2      "DROP COLUMN"
88874>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypePostgre  "DROP COLUMN"
88875>>>>>>>
88875>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMSSQL        "COLUMN"
88876>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMySQL        "COLUMN"
88877>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeOracle       "COLUMN"
88878>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeDB2          "COLUMN"
88879>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypePostgre      "COLUMN"
88880>>>>>>>
88880>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMSSQL   "ALTER COLUMN"
88881>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMySQL   "MODIFY"
88882>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeOracle  "MODIFY"
88883>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeDB2     "ALTER COLUMN"
88884>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypePostgre "ALTER COLUMN"
88885>>>>>>>
88885>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMSSQL   "EXEC sp_RENAME"
88886>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMySQL   "CHANGE"
88887>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeOracle  "RENAME COLUMN"
88888>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeDB2     "RENAME COLUMN"
88889>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypePostgre "RENAME COLUMN"
88890>>>>>>>
88890>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMSSQL        "SELECT"
88891>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMySQL        "SELECT"
88892>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeOracle       "SELECT"
88893>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeDB2          "SELECT"
88894>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypePostgre      "SELECT"
88895>>>>>>>
88895>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMSSQL         "WHERE"
88896>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMySQL         "WHERE"
88897>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeOracle        "WHERE"
88898>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeDB2           "WHERE"
88899>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypePostgre       "WHERE"
88900>>>>>>>
88900>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMSSQL          "FROM"
88901>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMySQL          "FROM"
88902>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeOracle         "FROM"
88903>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeDB2            "FROM"
88904>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypePostgre        "FROM"
88905>>>>>>>
88905>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMSSQL    "INFORMATION_SCHEMA.COLUMNS"
88906>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMySQL    "INFORMATION_SCHEMA.COLUMNS"
88907>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeOracle   "INFORMATION_SCHEMA.COLUMNS"
88908>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeDB2      "INFORMATION_SCHEMA.COLUMNS"
88909>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypePostgre  "INFORMATION_SCHEMA.COLUMNS"
88910>>>>>>>
88910>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMSSQL    "TABLE_NAME"
88911>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMySQL    "TABLE_NAME"
88912>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeOracle   "TABLE_NAME"
88913>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeDB2      "TABLE_NAME"
88914>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypePostgre  "TABLE_NAME"
88915>>>>>>>
88915>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMSSQL         "TABLE"
88916>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMySQL         "TABLE"
88917>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeOracle        "TABLE"
88918>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeDB2           "TABLE"
88919>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypePostgre       "TABLE"
88920>>>>>>>
88920>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMSSQL           "SYS"
88921>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMySQL           "SYS"
88922>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeOracle          "SYS"
88923>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeDB2             "SYS"
88924>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypePostgre         "SYS"
88925>>>>>>>
88925>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMSSQL       "SP_HELP"
88926>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMySQL       "SP_HELP"
88927>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeOracle      "SP_HELP"
88928>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeDB2         "SP_HELP"
88929>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypePostgre     "SP_HELP"
88930>>>>>>>
88930>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMSSQL      "SET NOCOUNT ON"
88931>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMySQL      "SET NOCOUNT ON"
88932>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeOracle     "SET NOCOUNT ON"
88933>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeDB2        "SET NOCOUNT ON"
88934>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypePostgre    "SET NOCOUNT ON"
88935>>>>>>>
88935>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMSSQL            "TO"
88936>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMySQL            "TO"
88937>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeOracle           "TO"
88938>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeDB2              "TO"
88939>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypePostgre          "TO"
88940>>>>>>>
88940>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMSSQL            "GO"
88941>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMySQL            "GO"
88942>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeOracle           "GO"
88943>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeDB2              "GO"
88944>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypePostgre          "GO"
88945>>>>>>>
88945>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMSSQL           "USE"
88946>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMySQL           "USE"
88947>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeOracle          "USE"
88948>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeDB2             "USE"
88949>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypePostgre         "USE"
88950>>>>>>>
88950>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMSSQL           "dbo"
88951>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMySQL           "dbo"
88952>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeOracle          "dbo"
88953>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeDB2             "dbo"
88954>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypePostgre         "dbo"
88955>>>>>>>
88955>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMSSQL        "MASTER"
88956>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMySQL        "MASTER"
88957>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeOracle       "MASTER"
88958>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeDB2          "MASTER"
88959>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypePostgre      "MASTER"
88960>>>>>>>
88960>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMSSQL          "NAME"
88961>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMySQL          "NAME"
88962>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeOracle         "NAME"
88963>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeDB2            "NAME"
88964>>>>>>>        Send Add_Element CI_SQLName EN_dbTypePostgre        "NAME"
88965>>>>>>>
88965>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMSSQL     "DATABASES"
88966>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMySQL     "DATABASES"
88967>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeOracle    "DATABASES"
88968>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeDB2       "DATABASES"
88969>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypePostgre   "DATABASES"
88970>>>>>>>
88970>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMSSQL    "SYS.INDEXES"
88971>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMySQL    "SYS.INDEXES"
88972>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeOracle   "SYS.INDEXES"
88973>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeDB2      "SYS.INDEXES"
88974>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypePostgre  "SYS.INDEXES"
88975>>>>>>>
88975>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMSSQL      "OBJECT_ID"
88976>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMySQL      "OBJECT_ID"
88977>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeOracle     "OBJECT_ID"
88978>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeDB2        "OBJECT_ID"
88979>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypePostgre    "OBJECT_ID"
88980>>>>>>>
88980>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMSSQL            "ID"
88981>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMySQL            "ID"
88982>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeOracle           "ID"
88983>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeDB2              "ID"
88984>>>>>>>        Send Add_Element CI_SQLID EN_dbTypePostgre          "ID"
88985>>>>>>>
88985>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMSSQL           "AND"
88986>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMySQL           "AND"
88987>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeOracle          "AND"
88988>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeDB2             "AND"
88989>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypePostgre         "AND"
88990>>>>>>>
88990>>>>>>>        // In case we didn't put the above in order (and we don't need to); we sort the struct array.
88990>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
88991>>>>>>>        Move (SortArray(SQLKeywordArray, Self, (RefFunc(CompareSortSQLKeyWords)))) to SQLKeywordArraySorted
88992>>>>>>>        Set paSQLKeywordArray to SQLKeywordArraySorted
88993>>>>>>>
88993>>>>>>>    End_Procedure
88994>>>>>>>
88994>>>>>>>End_Class
88995>>>>>Use cSQLConnectionHandler.pkg
Including file: cSQLConnectionHandler.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cSQLConnectionHandler.pkg)
88995>>>>>>>//****************************************************************************
88995>>>>>>>// $Module type: Class
88995>>>>>>>// $Module name: cSQLConnectionHandler.pkg
88995>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
88995>>>>>>>// Web-site    : http://www.rdctools.com
88995>>>>>>>// Created     : 2015-08-11 @ 16:02 (Military date format: YY-MM-DD)
88995>>>>>>>//
88995>>>>>>>// Description : A handler class for using CLI connection ID's to login to a database server.
88995>>>>>>>//
88995>>>>>>>// $Rev History:
88995>>>>>>>//    2015-08-11  Module header created
88995>>>>>>>//    2016-09-26  Changed name of the objecthandle from ghoCreateConnectionID to ghoSQLConnectionHandler.
88995>>>>>>>//                Added a new structure for passing connection data back & forth.
88995>>>>>>>//                Added better error handling.
88995>>>>>>>//                Added a decompose message for the connection string.
88995>>>>>>>//    2017-01-09  Added support for Mertech drivers
88995>>>>>>>//                Big overhaul to comply better with "Managed Connections" (DF 19)
88995>>>>>>>//                These changes make the class compatible with DFConnId.ini (can read/write DAW connection ini-files)
88995>>>>>>>//    2017-02-12  Reworked the whole connection property interface.
88995>>>>>>>//                Now there is one struct property that is the at cencter of a connection.
88995>>>>>>>//****************************************************************************
88995>>>>>>>Use cli.pkg
88995>>>>>>>Use MSSqldrv.pkg
88995>>>>>>>Use db2_drv.pkg
88995>>>>>>>Use odbc_drv.pkg
88995>>>>>>>Use cSQLConnectionIniFile.pkg
Including file: cSQLConnectionIniFile.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.pkg)
88995>>>>>>>>>//****************************************************************************
88995>>>>>>>>>// $Module type: Class
88995>>>>>>>>>// $Module name: cSQLConnectionIniFile.pkg
88995>>>>>>>>>//
88995>>>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
88995>>>>>>>>>// Copyright (c) 2012 RDC Tools International
88995>>>>>>>>>// E-mail      : support@rdctools.com
88995>>>>>>>>>// Web-site    : http://www.rdctools.com
88995>>>>>>>>>//
88995>>>>>>>>>// Created     : 2012-09-20 @ 18:04 (Military date format - Year-Month-Day)
88995>>>>>>>>>//
88995>>>>>>>>>// Note        : The file must be USEd after declaration of the ghoApplication object, as it uses
88995>>>>>>>>>//               properties of that object.
88995>>>>>>>>>//
88995>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
88995>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
88995>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
88995>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
88995>>>>>>>>>// in the help folder for more details.
88995>>>>>>>>>//
88995>>>>>>>>>Use cSQLConnectionIniFile.inc
88995>>>>>>>>>Use cDbUpdateDatabaseDriver.pkg
Including file: cDbUpdateDatabaseDriver.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateDatabaseDriver.pkg)
88995>>>>>>>>>>>Use cSQLConnectionIniFile.inc
88995>>>>>>>>>>>
88995>>>>>>>>>>>Class cDbUpdateGenericDatabaseDriver is a cObject
88996>>>>>>>>>>>    Procedure Construct_Object
88998>>>>>>>>>>>        Forward Send Construct_Object
89000>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
89001>>>>>>>>>>>    End_Procedure
89002>>>>>>>>>>>
89002>>>>>>>>>>>    Function ServerKeyword Returns String
89004>>>>>>>>>>>        Function_Return CS_SQLIniDSNKeyword
89005>>>>>>>>>>>    End_Function
89006>>>>>>>>>>>
89006>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
89008>>>>>>>>>>>        String sConnect
89008>>>>>>>>>>>
89008>>>>>>>>>>>        Move (sConnect * ServerKeyword(Self) + "=" + sServer) to sConnect
89009>>>>>>>>>>>        If (sDatabase <> "") Begin
89011>>>>>>>>>>>            Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
89012>>>>>>>>>>>        End
89012>>>>>>>>>>>>
89012>>>>>>>>>>>        If (bTrusted = True) Begin
89014>>>>>>>>>>>            Move (sConnect * ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
89015>>>>>>>>>>>        End
89015>>>>>>>>>>>>
89015>>>>>>>>>>>        Else Begin
89016>>>>>>>>>>>            Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
89017>>>>>>>>>>>        End
89017>>>>>>>>>>>>
89017>>>>>>>>>>>        Function_Return sConnect
89018>>>>>>>>>>>    End_Function
89019>>>>>>>>>>>
89019>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
89021>>>>>>>>>>>        Boolean bLoginSuccessful
89021>>>>>>>>>>>        String sDriverID
89021>>>>>>>>>>>
89021>>>>>>>>>>>        Get psDriverID to sDriverID
89022>>>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
89024>>>>>>>>>>>            Function_Return True
89025>>>>>>>>>>>        End
89025>>>>>>>>>>>>
89025>>>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
89026>>>>>>>>>>>        If (bTrusted = False) Begin
89028>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID
89030>>>>>>>>>>>        End
89030>>>>>>>>>>>>
89030>>>>>>>>>>>        Else Begin
89031>>>>>>>>>>>            Login sConnectionString "" "" sDriverID
89033>>>>>>>>>>>        End
89033>>>>>>>>>>>>
89033>>>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
89034>>>>>>>>>>>        Function_Return bLoginSuccessful
89035>>>>>>>>>>>    End_Function
89036>>>>>>>>>>>End_Class
89037>>>>>>>>>>>
89037>>>>>>>>>>>Class cDbUpdateMSSQLDriver is a cDbUpdateGenericDatabaseDriver
89038>>>>>>>>>>>    Function ServerKeyword Returns String
89040>>>>>>>>>>>        Function_Return CS_SQLIniServerKeyword
89041>>>>>>>>>>>    End_Function
89042>>>>>>>>>>>End_Class
89043>>>>>>>>>>>
89043>>>>>>>>>>>Class cDbUpdateODBCDriver is a cDbUpdateGenericDatabaseDriver
89044>>>>>>>>>>>End_Class
89045>>>>>>>>>>>
89045>>>>>>>>>>>Class cDbUpdateDB2Driver is a cDbUpdateGenericDatabaseDriver
89046>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
89048>>>>>>>>>>>        Boolean bLoginSuccessful
89048>>>>>>>>>>>        String sDriverID
89048>>>>>>>>>>>
89048>>>>>>>>>>>        Move False to Err
89049>>>>>>>>>>>        Get psDriverID to sDriverID
89050>>>>>>>>>>>        If (not(Uppercase(sServer) contains "DSN")) Begin
89052>>>>>>>>>>>            Move ("DSN=" + sServer) to sServer
89053>>>>>>>>>>>        End
89053>>>>>>>>>>>>
89053>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
89055>>>>>>>>>>>
89055>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
89056>>>>>>>>>>>        Function_Return bLoginSuccessful
89057>>>>>>>>>>>    End_Function
89058>>>>>>>>>>>End_Class
89059>>>>>>>>>>>
89059>>>>>>>>>>>Class cDbUpdateDataFlexDriver is a cDbUpdateGenericDatabaseDriver
89060>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
89062>>>>>>>>>>>        Function_Return ""
89063>>>>>>>>>>>    End_Function
89064>>>>>>>>>>>End_Class
89065>>>>>>>>>>>
89065>>>>>>>>>>>Class cDbUpdateSQLFLEXDriver is a cDbUpdateGenericDatabaseDriver
89066>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
89068>>>>>>>>>>>        Boolean bLoginSuccessful
89068>>>>>>>>>>>        String sDriverID
89068>>>>>>>>>>>
89068>>>>>>>>>>>        Get psDriverID to sDriverID
89069>>>>>>>>>>>        //For the Mertech driver, using the Err indicator is the sanctioned way
89069>>>>>>>>>>>        Move False to Err
89070>>>>>>>>>>>        If (bTrusted = False) Begin
89072>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID
89074>>>>>>>>>>>        End
89074>>>>>>>>>>>>
89074>>>>>>>>>>>        Else Begin
89075>>>>>>>>>>>            Login sServer "" "" sDriverID
89077>>>>>>>>>>>        End
89077>>>>>>>>>>>>
89077>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
89078>>>>>>>>>>>
89078>>>>>>>>>>>        Function_Return bLoginSuccessful
89079>>>>>>>>>>>    End_Function
89080>>>>>>>>>>>End_Class
89081>>>>>>>>>>>
89081>>>>>>>>>>>Class cDbUpdateORAFLEXDriver is a cDbUpdateGenericDatabaseDriver
89082>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
89084>>>>>>>>>>>        Boolean bLoginSuccessful
89084>>>>>>>>>>>        String sDriverID
89084>>>>>>>>>>>        Integer iPos
89084>>>>>>>>>>>
89084>>>>>>>>>>>        Get psDriverID to sDriverID
89085>>>>>>>>>>>        Move (Pos("/", sServer)) to iPos
89086>>>>>>>>>>>        If (iPos = 0) Begin
89088>>>>>>>>>>>            If (sDatabase <> "") Begin
89090>>>>>>>>>>>                Move (sServer + "/" + sDatabase) to sServer
89091>>>>>>>>>>>            End
89091>>>>>>>>>>>>
89091>>>>>>>>>>>        End
89091>>>>>>>>>>>>
89091>>>>>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
89091>>>>>>>>>>>        Move False to Err
89092>>>>>>>>>>>        // For Oracle I don't believe "Trusted" doesn't exist.
89092>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
89094>>>>>>>>>>>
89094>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
89095>>>>>>>>>>>        Function_Return bLoginSuccessful
89096>>>>>>>>>>>    End_Function
89097>>>>>>>>>>>End_Class
89098>>>>>>>>>>>
89098>>>>>>>>>>>Class cDbUpdateMDSMySQLDriver is a cDbUpdateGenericDatabaseDriver
89099>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
89101>>>>>>>>>>>        Boolean bLoginSuccessful
89101>>>>>>>>>>>        String sDriverID
89101>>>>>>>>>>>
89101>>>>>>>>>>>        Get psDriverID to sDriverID
89102>>>>>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
89102>>>>>>>>>>>        Move False to Err
89103>>>>>>>>>>>        If (bTrusted = False) Begin
89105>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID
89107>>>>>>>>>>>        End
89107>>>>>>>>>>>>
89107>>>>>>>>>>>        Else Begin
89108>>>>>>>>>>>            Login sServer "" "" sDriverID
89110>>>>>>>>>>>        End
89110>>>>>>>>>>>>
89110>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
89111>>>>>>>>>>>        Function_Return bLoginSuccessful
89112>>>>>>>>>>>    End_Function
89113>>>>>>>>>>>End_Class
89114>>>>>>>>>>>
89114>>>>>>>>>>>Class cDbUpdateMDSPgSQLDriver is a cDbUpdateGenericDatabaseDriver
89115>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
89117>>>>>>>>>>>        Boolean bLoginSuccessful
89117>>>>>>>>>>>        String sDriverID
89117>>>>>>>>>>>
89117>>>>>>>>>>>        Get psDriverID to sDriverID
89118>>>>>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
89118>>>>>>>>>>>        Move False to Err
89119>>>>>>>>>>>        If (bTrusted = False) Begin
89121>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID
89123>>>>>>>>>>>        End
89123>>>>>>>>>>>>
89123>>>>>>>>>>>        Else Begin
89124>>>>>>>>>>>            Login sServer "" "" sDriverID
89126>>>>>>>>>>>        End
89126>>>>>>>>>>>>
89126>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
89127>>>>>>>>>>>        Function_Return bLoginSuccessful
89128>>>>>>>>>>>    End_Function
89129>>>>>>>>>>>End_Class
89130>>>>>>>>>>>
89130>>>>>>>>>>>Class cDbUpdateDatabaseDriver is a cObject
89131>>>>>>>>>>>    Procedure Construct_Object
89133>>>>>>>>>>>        Forward Send Construct_Object
89135>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
89136>>>>>>>>>>>        Property Handle phoDriverSpecificObject
89137>>>>>>>>>>>    End_Procedure
89138>>>>>>>>>>>
89138>>>>>>>>>>>    Function CreateDriver Returns Handle
89140>>>>>>>>>>>        String sDriverID
89140>>>>>>>>>>>        Handle hoDriver hcDriverClass
89140>>>>>>>>>>>
89140>>>>>>>>>>>        Get psDriverID to sDriverID
89141>>>>>>>>>>>        Case Begin
89141>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
89143>>>>>>>>>>>                Move (RefClass(cDbUpdateMSSQLDriver))    to hcDriverClass
89144>>>>>>>>>>>                Case Break
89145>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
89148>>>>>>>>>>>                Move (RefClass(cDbUpdateODBCDriver))     to hcDriverClass
89149>>>>>>>>>>>                Case Break
89150>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
89153>>>>>>>>>>>                Move (RefClass(cDbUpdateDB2Driver))      to hcDriverClass
89154>>>>>>>>>>>                Case Break
89155>>>>>>>>>>>            Case (sDriverID = SQLFLEX)
89158>>>>>>>>>>>                Move (RefClass(cDbUpdateSQLFLEXDriver))  to hcDriverClass
89159>>>>>>>>>>>                Case Break
89160>>>>>>>>>>>            Case (sDriverID = ORAFLEX)
89163>>>>>>>>>>>                Move (RefClass(cDbUpdateORAFLEXDriver))  to hcDriverClass
89164>>>>>>>>>>>                Case Break
89165>>>>>>>>>>>            Case (sDriverID = MDSPgSQL)
89168>>>>>>>>>>>                Move (RefClass(cDbUpdateMDSPgSQLDriver)) to hcDriverClass
89169>>>>>>>>>>>                Case Break
89170>>>>>>>>>>>            Case (sDriverID = MDSMySQL)
89173>>>>>>>>>>>                Move (RefClass(cDbUpdateMDSMySQLDriver)) to hcDriverClass
89174>>>>>>>>>>>                Case Break
89175>>>>>>>>>>>            // DATAFLEX_ID = Default driver
89175>>>>>>>>>>>            Case Else
89175>>>>>>>>>>>                Move (RefClass(cDbUpdateDataFlexDriver)) to hcDriverClass
89176>>>>>>>>>>>                Move DATAFLEX_ID to sDriverID
89177>>>>>>>>>>>        Case End
89177>>>>>>>>>>>
89177>>>>>>>>>>>        Get Create hcDriverClass to hoDriver
89178>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
89179>>>>>>>>>>>        Set phoDriverSpecificObject to hoDriver
89180>>>>>>>>>>>
89180>>>>>>>>>>>        Function_Return hoDriver
89181>>>>>>>>>>>    End_Procedure
89182>>>>>>>>>>>
89182>>>>>>>>>>>    Procedure DestroyDriver
89184>>>>>>>>>>>        If (phoDriverSpecificObject(Self)) Begin
89186>>>>>>>>>>>            Send Destroy of (phoDriverSpecificObject(Self))
89187>>>>>>>>>>>        End
89187>>>>>>>>>>>>
89187>>>>>>>>>>>    End_Procedure
89188>>>>>>>>>>>
89188>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
89190>>>>>>>>>>>        String sConnect
89190>>>>>>>>>>>        Handle hoDriver
89190>>>>>>>>>>>
89190>>>>>>>>>>>        Get CreateDriver to hoDriver
89191>>>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
89192>>>>>>>>>>>        Send DestroyDriver
89193>>>>>>>>>>>        Function_Return sConnect
89194>>>>>>>>>>>    End_Function
89195>>>>>>>>>>>
89195>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
89197>>>>>>>>>>>        Boolean bLoginSuccessful
89197>>>>>>>>>>>        Handle hoDriver
89197>>>>>>>>>>>
89197>>>>>>>>>>>        Get CreateDriver to hoDriver
89198>>>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
89199>>>>>>>>>>>        Send DestroyDriver
89200>>>>>>>>>>>        Function_Return bLoginSuccessful
89201>>>>>>>>>>>    End_Function
89202>>>>>>>>>>>
89202>>>>>>>>>>>End_Class
89203>>>>>>>>>
89203>>>>>>>>>Class cSQLConnectionIniFile is a cIniFile
89204>>>>>>>>>    Procedure Construct_Object
89206>>>>>>>>>        Forward Send Construct_Object
89208>>>>>>>>>
89208>>>>>>>>>        Property String Private_psIniFilePath
89209>>>>>>>>>        Property String Private_psIniFileName CS_SQLIniFileName
89210>>>>>>>>>        Property String psIniSectionName (CS_SQLIniSectionName + "1")
89211>>>>>>>>>
89211>>>>>>>>>//        { Visibility=Private }
89211>>>>>>>>>        Property Boolean pbDFConnId False
89212>>>>>>>>>
89212>>>>>>>>>        // We use Base64 coding instead of the cCryptographer class because the
89212>>>>>>>>>        // password will get scrambled while writing/reading to/from the ini-file.
89212>>>>>>>>>//        { Visibility=Public }
89212>>>>>>>>>//        // *** You really want to change this value! ***
89212>>>>>>>>>//        Property String psHashString "zx!2139(LI0+?ips7433"
89212>>>>>>>>>
89212>>>>>>>>>    End_Procedure
89213>>>>>>>>>
89213>>>>>>>>>    Procedure End_Construct_Object
89215>>>>>>>>>        Forward Send End_Construct_Object
89217>>>>>>>>>    End_Procedure
89218>>>>>>>>>
89218>>>>>>>>>    Procedure Set psIniFilePath String sPath
89220>>>>>>>>>        String sIniFile
89220>>>>>>>>>        Get vFolderFormat sPath to sPath
89221>>>>>>>>>        Set private_psIniFilePath to sPath
89222>>>>>>>>>        Get psIniFileName to sIniFile
89223>>>>>>>>>        Set psFileName to (sPath + sIniFile)
89224>>>>>>>>>    End_Procedure
89225>>>>>>>>>
89225>>>>>>>>>    Function psIniFilePath Returns String
89227>>>>>>>>>        Function_Return (private_psIniFilePath(Self))
89228>>>>>>>>>    End_Function
89229>>>>>>>>>
89229>>>>>>>>>    Procedure Set psIniFileName String sFileName
89231>>>>>>>>>        String sPath
89231>>>>>>>>>        Get psIniFilePath to sPath
89232>>>>>>>>>        Set psFileName to (sPath + sFileName)
89233>>>>>>>>>        Set private_psIniFileName to sFileName
89234>>>>>>>>>    End_Procedure
89235>>>>>>>>>
89235>>>>>>>>>    Function psIniFileName Returns String
89237>>>>>>>>>        Function_Return (private_psIniFileName(Self))
89238>>>>>>>>>    End_Function
89239>>>>>>>>>
89239>>>>>>>>>    // *** Generalized messages to Get & Set values of the ini file.
89239>>>>>>>>>    // Sets a value in the program's ini file (write)
89239>>>>>>>>>    // Pass a section name, the value name parameter and the value itself to be written.
89239>>>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
89241>>>>>>>>>        String sIniFile sPath
89241>>>>>>>>>
89241>>>>>>>>>        Get psIniFilePath to sPath
89242>>>>>>>>>        Get psIniFileName to sIniFile
89243>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
89244>>>>>>>>>        Set psFileName to sIniFile
89245>>>>>>>>>        Send WriteString sSection sValueName sValue
89246>>>>>>>>>    End_Procedure
89247>>>>>>>>>
89247>>>>>>>>>    // Get a value from program's ini-file (read)
89247>>>>>>>>>    // Pass a section name and the name of the value parameter & a default value.
89247>>>>>>>>>    // Returns the value
89247>>>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
89249>>>>>>>>>        String sValue sIniFile sPath
89249>>>>>>>>>
89249>>>>>>>>>        Get psIniFilePath to sPath
89250>>>>>>>>>        Get psIniFileName to sIniFile
89251>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
89252>>>>>>>>>        Set psFileName to sIniFile
89253>>>>>>>>>        Get ReadString sSection sValueName sDefaultValue to sValue
89254>>>>>>>>>
89254>>>>>>>>>        Function_Return sValue
89255>>>>>>>>>    End_Function
89256>>>>>>>>>
89256>>>>>>>>>    // Sort function that first sorts on bEnabled & then on the connection string.
89256>>>>>>>>>    Function SortActiveFirst tSQLConnection SQLConnectionRow1 tSQLConnection SQLConnectionRow2 Returns Integer
89258>>>>>>>>>        If (SQLConnectionRow1.bEnabled > SQLConnectionRow2.bEnabled) ;            Function_Return (LT)
89261>>>>>>>>>        If (SQLConnectionRow1.bEnabled < SQLConnectionRow2.bEnabled) ;            Function_Return (GT)
89264>>>>>>>>>
89264>>>>>>>>>        If (SQLConnectionRow1.sConnectionID < SQLConnectionRow2.sConnectionID) ;            Function_Return (LT)
89267>>>>>>>>>        If (SQLConnectionRow1.sConnectionID > SQLConnectionRow2.sConnectionID) ;            Function_Return (GT)
89270>>>>>>>>>
89270>>>>>>>>>        If (SQLConnectionRow1.iDbType < SQLConnectionRow2.iDbType) ;            Function_Return (LT)
89273>>>>>>>>>        If (SQLConnectionRow1.iDbType > SQLConnectionRow2.iDbType) ;            Function_Return (GT)
89276>>>>>>>>>
89276>>>>>>>>>        If (SQLConnectionRow1.sServer < SQLConnectionRow2.sServer) ;            Function_Return (LT)
89279>>>>>>>>>        If (SQLConnectionRow1.sServer > SQLConnectionRow2.sServer) ;            Function_Return (GT)
89282>>>>>>>>>
89282>>>>>>>>>        If (SQLConnectionRow1.sDatabase < SQLConnectionRow2.sDatabase) ;            Function_Return (LT)
89285>>>>>>>>>        If (SQLConnectionRow1.sDatabase > SQLConnectionRow2.sDatabase) ;            Function_Return (GT)
89288>>>>>>>>>
89288>>>>>>>>>        If (SQLConnectionRow1.sDriverID < SQLConnectionRow2.sDriverID) ;            Function_Return (LT)
89291>>>>>>>>>        If (SQLConnectionRow1.sDriverID > SQLConnectionRow2.sDriverID) ;            Function_Return (GT)
89294>>>>>>>>>
89294>>>>>>>>>        If (SQLConnectionRow1.sConnectionString < SQLConnectionRow2.sConnectionString) ;            Function_Return (LT)
89297>>>>>>>>>        If (SQLConnectionRow1.sConnectionString > SQLConnectionRow2.sConnectionString) ;            Function_Return (GT)
89300>>>>>>>>>
89300>>>>>>>>>        Function_Return (EQ)
89301>>>>>>>>>    End_Function
89302>>>>>>>>>
89302>>>>>>>>>    Function SQLIniFileNumberOfConnections Returns Integer
89304>>>>>>>>>        Handle hoSections
89304>>>>>>>>>        Integer iItems
89304>>>>>>>>>
89304>>>>>>>>>        Send ReadSections hoSections
89305>>>>>>>>>        Move (Item_Count(hoSections)) to iItems
89306>>>>>>>>>        Function_Return iItems
89307>>>>>>>>>    End_Function
89308>>>>>>>>>
89308>>>>>>>>>    // The normal connection string looks something like this;
89308>>>>>>>>>    // "SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
89308>>>>>>>>>    // ...but the full connection string looks like this;
89308>>>>>>>>>    // "DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
89308>>>>>>>>>//    Function SQLIniFileAddConnection String sFullConnectionString Returns Boolean
89308>>>>>>>>>//        String sSection
89308>>>>>>>>>//        Integer iCount
89308>>>>>>>>>//
89308>>>>>>>>>//        Move False to Err
89308>>>>>>>>>//        Get psIniSectionName to sSection
89308>>>>>>>>>//        Get SQLIniFileNumberOfConnections to iCount
89308>>>>>>>>>//        Increment iCount
89308>>>>>>>>>//        Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to sFullConnectionString
89308>>>>>>>>>//
89308>>>>>>>>>//        Function_Return (Err = False)
89308>>>>>>>>>//    End_Function
89308>>>>>>>>>
89308>>>>>>>>>    Function SQLIniFileDeleteAllConnections Returns Boolean
89310>>>>>>>>>        Integer iCount
89310>>>>>>>>>        Boolean bExists
89310>>>>>>>>>        String sSection
89310>>>>>>>>>
89310>>>>>>>>>        Move False to Err
89311>>>>>>>>>        Move 1 to iCount
89312>>>>>>>>>        Get psIniSectionName to sSection
89313>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
89314>>>>>>>>>        While (bExists = True)
89318>>>>>>>>>            Send DeleteSection (CS_SQLIniSectionName + String(iCount))
89319>>>>>>>>>            Increment iCount
89320>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
89321>>>>>>>>>        Loop
89322>>>>>>>>>>
89322>>>>>>>>>        Function_Return (Err = False)
89323>>>>>>>>>    End_Function
89324>>>>>>>>>
89324>>>>>>>>>    Function SQLIniFileDeleteConnection Integer iItem Returns Boolean
89326>>>>>>>>>        Integer iCount
89326>>>>>>>>>        String sSection
89326>>>>>>>>>        Boolean bExists
89326>>>>>>>>>
89326>>>>>>>>>        Move False to Err
89327>>>>>>>>>        Move 1 to iCount
89328>>>>>>>>>        Get psIniSectionName to sSection
89329>>>>>>>>>        Get KeyExists sSection CS_SQLIniConnectionIdKeyword to bExists
89330>>>>>>>>>        While (bExists = True)
89334>>>>>>>>>            If (iCount = iItem) Begin
89336>>>>>>>>>                Send DeleteSection sSection
89337>>>>>>>>>//                Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to ""
89337>>>>>>>>>                Move 9999 to iCount // Just some ridiculously high number to get out of the loop as we're done.
89338>>>>>>>>>            End
89338>>>>>>>>>>
89338>>>>>>>>>            Increment iCount
89339>>>>>>>>>            Get KeyExists sSection (CS_SQLIniSectionName + String(iCount)) to bExists
89340>>>>>>>>>        Loop
89341>>>>>>>>>>
89341>>>>>>>>>
89341>>>>>>>>>        Function_Return (Err = False)
89342>>>>>>>>>    End_Function
89343>>>>>>>>>
89343>>>>>>>>>    // Returns all connection details for the passed Connection ID as a tSQLConnection
89343>>>>>>>>>    // If it fails the returned struct member SQLConnection.bError = True.
89343>>>>>>>>>    Function SQLIniFileConnectionID String sConnectionID Returns tSQLConnection
89345>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
89345>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
89346>>>>>>>>>        tSQLConnection   SQLConnection
89346>>>>>>>>>        tSQLConnection   SQLConnection
89346>>>>>>>>>        Integer iIndex
89346>>>>>>>>>
89346>>>>>>>>>        Get SQLIniFileConnectionIDIndex sConnectionID to iIndex
89347>>>>>>>>>        If (iIndex = -1) Begin
89349>>>>>>>>>            Move True to SQLConnection.bError
89350>>>>>>>>>            Function_Return SQLConnection
89351>>>>>>>>>        End
89351>>>>>>>>>>
89351>>>>>>>>>
89351>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
89352>>>>>>>>>        Move SQLConnectionsArray[iIndex -1] to SQLConnection
89353>>>>>>>>>
89353>>>>>>>>>        Function_Return SQLConnection
89354>>>>>>>>>    End_Function
89355>>>>>>>>>
89355>>>>>>>>>    // Returns -1 if the passed connection ID was not found, else the item number.
89355>>>>>>>>>    Function SQLIniFileConnectionIDIndex String sConnectionID Returns Integer
89357>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
89357>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
89358>>>>>>>>>        Integer iRetval iCount iSize
89358>>>>>>>>>        String sValue
89358>>>>>>>>>        Boolean bExists
89358>>>>>>>>>
89358>>>>>>>>>        Move -1 to iRetval
89359>>>>>>>>>
89359>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
89360>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
89361>>>>>>>>>        Decrement iSize
89362>>>>>>>>>        For iCount from 0 to iSize
89368>>>>>>>>>>
89368>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
89369>>>>>>>>>            Move (Uppercase(sValue) = Uppercase(sConnectionID)) to bExists
89370>>>>>>>>>            If (bExists) Begin
89372>>>>>>>>>                Move (iCount + 1) to iRetval // The [ConnectionX] keys are one-based (starts at 1) but the loop starts at zero.
89373>>>>>>>>>                Move iSize to iCount         // We're done!
89374>>>>>>>>>            End
89374>>>>>>>>>>
89374>>>>>>>>>        Loop
89375>>>>>>>>>>
89375>>>>>>>>>
89375>>>>>>>>>        Function_Return iRetval
89376>>>>>>>>>    End_Function
89377>>>>>>>>>
89377>>>>>>>>>    // Checks if the passed sConnectionID exists more than once in the passed struct array.
89377>>>>>>>>>    // Used to check that ConnectionID's are unique.
89377>>>>>>>>>    Function IsConnectionIDDuplicate String sConnectionID Returns Boolean
89379>>>>>>>>>        Integer iCount iSize iItems
89379>>>>>>>>>        String sValue
89379>>>>>>>>>        Boolean bExists
89379>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
89379>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
89380>>>>>>>>>
89380>>>>>>>>>        Move 0 to iItems
89381>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
89382>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
89383>>>>>>>>>        Decrement iSize
89384>>>>>>>>>        For iCount from 0 to iSize
89390>>>>>>>>>>
89390>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
89391>>>>>>>>>            Move (sValue = sConnectionID) to bExists
89392>>>>>>>>>            If (bExists) Begin
89394>>>>>>>>>                Increment iItems
89395>>>>>>>>>            End
89395>>>>>>>>>>
89395>>>>>>>>>        Loop
89396>>>>>>>>>>
89396>>>>>>>>>
89396>>>>>>>>>        Function_Return (iItems > 1)
89397>>>>>>>>>    End_Function
89398>>>>>>>>>
89398>>>>>>>>>    // To update the SQLConnections.ini file with a new default Connection ID.
89398>>>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
89400>>>>>>>>>        Boolean bOK
89400>>>>>>>>>        Integer iSize iCount
89400>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
89400>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
89401>>>>>>>>>        tSQLConnection SQLConnection
89401>>>>>>>>>        tSQLConnection SQLConnection
89401>>>>>>>>>        String sConnectionString
89401>>>>>>>>>
89401>>>>>>>>>        Move False to Err
89402>>>>>>>>>        Get psConnectionString to sConnectionString
89403>>>>>>>>>
89403>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
89404>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
89405>>>>>>>>>        Decrement iSize
89406>>>>>>>>>        // Set all current connection to inactive.
89406>>>>>>>>>        For iCount from 0 to iSize
89412>>>>>>>>>>
89412>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
89413>>>>>>>>>        Loop
89414>>>>>>>>>>
89414>>>>>>>>>
89414>>>>>>>>>        Get SQLIniFileConnectionID sConnectionID to SQLConnection
89415>>>>>>>>>        Move True              to SQLConnection.bEnabled
89416>>>>>>>>>        Move sConnectionString to SQLConnection.sConnectionString
89417>>>>>>>>>        Move (InsertInArray(SQLConnectionsArray, 0, SQLConnection)) to SQLConnectionsArray
89418>>>>>>>>>        Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
89419>>>>>>>>>
89419>>>>>>>>>        Function_Return (bOK = True)
89420>>>>>>>>>    End_Function
89421>>>>>>>>>
89421>>>>>>>>>    // Used for updating an existing connection with new data.
89421>>>>>>>>>    // Returns True if successful.
89421>>>>>>>>>    Function SQLIniFileUpdateConnection tSQLConnection SQLConnection Returns Boolean
89423>>>>>>>>>        Boolean bOK
89423>>>>>>>>>        Integer iItem iSize iCount
89423>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
89423>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
89424>>>>>>>>>
89424>>>>>>>>>        Move False to Err
89425>>>>>>>>>        Move -1 to iItem
89426>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
89427>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
89428>>>>>>>>>        Decrement iSize
89429>>>>>>>>>        // Set all current connection to inactive.
89429>>>>>>>>>        For iCount from 0 to iSize
89435>>>>>>>>>>
89435>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
89436>>>>>>>>>            If (SQLConnectionsArray[iCount].sConnectionID = SQLConnection.sConnectionID) Begin
89438>>>>>>>>>                Move iCount to iItem
89439>>>>>>>>>            End
89439>>>>>>>>>>
89439>>>>>>>>>        Loop
89440>>>>>>>>>>
89440>>>>>>>>>
89440>>>>>>>>>        If (iItem <> -1) Begin
89442>>>>>>>>>            Move True to SQLConnection.bEnabled
89443>>>>>>>>>            Move SQLConnection to SQLConnectionsArray[iItem]
89444>>>>>>>>>            Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
89445>>>>>>>>>        End
89445>>>>>>>>>>
89445>>>>>>>>>
89445>>>>>>>>>        Function_Return (bOK = True)
89446>>>>>>>>>    End_Function
89447>>>>>>>>>
89447>>>>>>>>>    Function SQLIniFileReadConnections Returns tSQLConnection[]
89449>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
89449>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
89450>>>>>>>>>        String sSection sValue
89450>>>>>>>>>        Integer iCount
89450>>>>>>>>>        Boolean bExists bEnabled
89450>>>>>>>>>
89450>>>>>>>>>        Get psIniSectionName to sSection
89451>>>>>>>>>        Get SectionExists sSection to bExists
89452>>>>>>>>>        If (bExists = False) Begin
89454>>>>>>>>>            Function_Return SQLConnectionsArray
89455>>>>>>>>>        End
89455>>>>>>>>>>
89455>>>>>>>>>        Get SectionExists CS_SQLIniConnectionSection to bExists
89456>>>>>>>>>        If (bExists = True) Begin
89458>>>>>>>>>            Error DFERR_PROGRAM "Sorry, the format for the SQLConnections.ini file has been changed and this file has the old format that is no longer valid and thus cannot be read. You need to re-enter your connection(s)."
89459>>>>>>>>>>
89459>>>>>>>>>        End
89459>>>>>>>>>>
89459>>>>>>>>>
89459>>>>>>>>>        Move 1 to iCount // The section name "[ConnectionXX]" starts with "1"
89460>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
89461>>>>>>>>>
89461>>>>>>>>>        While (bExists = True)
89465>>>>>>>>>            // We always put the enabled/active connection at the top
89465>>>>>>>>>            Move (iCount = 1) to bEnabled
89466>>>>>>>>>            Move bEnabled to SQLConnectionsArray[iCount].bEnabled
89467>>>>>>>>>
89467>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionIdKeyword ""        to SQLConnectionsArray[iCount].sConnectionID
89468>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDriverKeyword       ""        to SQLConnectionsArray[iCount].sDriverID
89469>>>>>>>>>
89469>>>>>>>>>            // The iDbType might be missing from the ini-file. This is e.g. the case when a DAW Managed Connection "DFConnId.ini" file is read.
89469>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDbTypeKeyword       "99"      to sValue
89470>>>>>>>>>            If (sValue = "99") Begin
89472>>>>>>>>>                Get SqlUtilDbTypeFromDriver SQLConnectionsArray[iCount].sDriverID to sValue
89473>>>>>>>>>            End
89473>>>>>>>>>>
89473>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].iDbType
89474>>>>>>>>>
89474>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionKeyWord   ""        to SQLConnectionsArray[iCount].sConnectionString
89475>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnectionsArray[iCount].sServer
89476>>>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
89478>>>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDSNKeyword +"=")   to SQLConnectionsArray[iCount].sServer
89479>>>>>>>>>            End
89479>>>>>>>>>>
89479>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnectionsArray[iCount].sDatabase
89480>>>>>>>>>
89480>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniTrustedKeyword      ""        to sValue
89481>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bTrusted
89482>>>>>>>>>
89482>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniUIDKeyword          ""        to SQLConnectionsArray[iCount].sUserID
89483>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDFPWDKeyword        ""        to sValue
89484>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
89486>>>>>>>>>                Get DecryptPassword sValue to sValue
89487>>>>>>>>>            End
89487>>>>>>>>>>
89487>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].sPassword
89488>>>>>>>>>
89488>>>>>>>>>            // Here we reconstruct the connection string to be complete with all params;
89488>>>>>>>>>            Get ConstructConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                          SQLConnectionsArray[iCount].bTrusted SQLConnectionsArray[iCount].sUserID SQLConnectionsArray[iCount].sPassword ;                                          to SQLConnectionsArray[iCount].sConnectionString
89489>>>>>>>>>
89489>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSchemaKeyword          ""     to SQLConnectionsArray[iCount].sSchema
89490>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniBaseTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sBaseTableSpace
89491>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniLongTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sLongTableSpace
89492>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniIndexTableSpaceKeyword ""     to SQLConnectionsArray[iCount].sIndexTableSpace
89493>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSilentLoginKeyword     ""     to SQLConnectionsArray[iCount].bSilentLogin
89494>>>>>>>>>//            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDisabledKeyword        ""     to SQLConnectionsArray[iCount].bDisabled
89494>>>>>>>>>
89494>>>>>>>>>            Increment iCount
89495>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
89496>>>>>>>>>        Loop
89497>>>>>>>>>>
89497>>>>>>>>>
89497>>>>>>>>>        // Lastly, we remove the very first array item as it is empty (we started at 1 because that is the first [Connection#])
89497>>>>>>>>>        If (SizeOfArray(SQLConnectionsArray) > 0) Begin
89499>>>>>>>>>            Move (RemoveFromArray(SQLConnectionsArray, 0)) to SQLConnectionsArray
89500>>>>>>>>>        End
89500>>>>>>>>>>
89500>>>>>>>>>
89500>>>>>>>>>        Function_Return SQLConnectionsArray
89501>>>>>>>>>    End_Function
89502>>>>>>>>>
89502>>>>>>>>>    Function SQLIniFileWriteConnections tSQLConnection[] SQLConnectionsArray Returns Boolean
89504>>>>>>>>>        Integer iCount iSize
89504>>>>>>>>>        Boolean bOK
89504>>>>>>>>>        String sConnectionString sSection sValue
89504>>>>>>>>>
89504>>>>>>>>>        // First we need to _remove_ all current connections in the ini-file, we
89504>>>>>>>>>        // do that by setting their values to "".
89504>>>>>>>>>        Move 0 to iCount
89505>>>>>>>>>        Get SQLIniFileDeleteAllConnections to bOK
89506>>>>>>>>>        If (bOK = False) Begin
89508>>>>>>>>>            Function_Return False
89509>>>>>>>>>        End
89509>>>>>>>>>>
89509>>>>>>>>>
89509>>>>>>>>>        Move False to Err
89510>>>>>>>>>        Get psIniSectionName to sSection
89511>>>>>>>>>        // Sorting will make sure we have the active connection record as the first connection item in the ini-file.
89511>>>>>>>>>        Move (SortArray(SQLConnectionsArray, Self, (RefFunc(SortActiveFirst)))) to SQLConnectionsArray
89512>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
89513>>>>>>>>>        Decrement iSize
89514>>>>>>>>>
89514>>>>>>>>>        For iCount from 0 to iSize
89520>>>>>>>>>>
89520>>>>>>>>>            // DF 19 compatible settings:
89520>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionIdKeyword   to SQLConnectionsArray[iCount].sConnectionID
89521>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDriverKeyword         to SQLConnectionsArray[iCount].sDriverID
89522>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniUIDKeyword            to SQLConnectionsArray[iCount].sUserID
89523>>>>>>>>>
89523>>>>>>>>>            Move SQLConnectionsArray[iCount].sPassword to sValue
89524>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
89526>>>>>>>>>                Get EncryptPassword sValue to sValue
89527>>>>>>>>>            End
89527>>>>>>>>>>
89527>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDFPWDKeyword          to sValue
89528>>>>>>>>>
89528>>>>>>>>>            If (SQLConnectionsArray[iCount].bTrusted = True) Begin
89530>>>>>>>>>                Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniTrustedKeyword    to CS_SQLIniConnectionYes
89531>>>>>>>>>            End
89531>>>>>>>>>>
89531>>>>>>>>>
89531>>>>>>>>>            Get ConstructShortConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                            to SQLConnectionsArray[iCount].sConnectionString
89532>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionKeyWord     to SQLConnectionsArray[iCount].sConnectionString
89533>>>>>>>>>
89533>>>>>>>>>            // The Database Update Framework extended settings:
89533>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDbTypeKeyword          to SQLConnectionsArray[iCount].iDbType
89534>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSchemaKeyword          to SQLConnectionsArray[iCount].sSchema
89535>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniBaseTableSpaceKeyword  to SQLConnectionsArray[iCount].sBaseTableSpace
89536>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniLongTableSpaceKeyword  to SQLConnectionsArray[iCount].sLongTableSpace
89537>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniIndexTableSpaceKeyword to SQLConnectionsArray[iCount].sIndexTableSpace
89538>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSilentLoginKeyword     to SQLConnectionsArray[iCount].bSilentLogin
89539>>>>>>>>>        Loop
89540>>>>>>>>>>
89540>>>>>>>>>
89540>>>>>>>>>        Function_Return (bOK and Err = False)
89541>>>>>>>>>    End_Function
89542>>>>>>>>>
89542>>>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
89542>>>>>>>>>    //
89542>>>>>>>>>    // SQL utility function that returns a database type (string) constant
89542>>>>>>>>>    // corresponding to the passed iDbType.
89542>>>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
89544>>>>>>>>>        String sRetval
89544>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
89546>>>>>>>>>            Move CS_dbTypeMSSQL to sRetval
89547>>>>>>>>>        End
89547>>>>>>>>>>
89547>>>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
89549>>>>>>>>>            Move CS_dbTypeMySQL to sRetval
89550>>>>>>>>>        End
89550>>>>>>>>>>
89550>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
89552>>>>>>>>>            Move CS_dbTypeOracle to sRetval
89553>>>>>>>>>        End
89553>>>>>>>>>>
89553>>>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
89555>>>>>>>>>            Move CS_dbTypeDB2 to sRetval
89556>>>>>>>>>        End
89556>>>>>>>>>>
89556>>>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
89558>>>>>>>>>            Move CS_dbTypePostgre to sRetval
89559>>>>>>>>>        End
89559>>>>>>>>>>
89559>>>>>>>>>        Function_Return sRetval
89560>>>>>>>>>    End_Function
89561>>>>>>>>>
89561>>>>>>>>>    // SQL utility function that returns a database type constant (integer)
89561>>>>>>>>>    // corresponding to the passed sDbType string constant.
89561>>>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType  Returns Integer
89563>>>>>>>>>        Integer iRetval
89563>>>>>>>>>        If (sDbType = CS_dbTypeMSSQL) Begin
89565>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
89566>>>>>>>>>        End
89566>>>>>>>>>>
89566>>>>>>>>>        If (sDbType = CS_dbTypeMySQL) Begin
89568>>>>>>>>>            Move EN_dbTypeMySQL to iRetval
89569>>>>>>>>>        End
89569>>>>>>>>>>
89569>>>>>>>>>        If (sDbType = CS_dbTypeOracle) Begin
89571>>>>>>>>>            Move EN_dbTypeOracle to iRetval
89572>>>>>>>>>        End
89572>>>>>>>>>>
89572>>>>>>>>>        If (sDbType = CS_dbTypeDB2) Begin
89574>>>>>>>>>            Move EN_dbTypeDB2 to iRetval
89575>>>>>>>>>        End
89575>>>>>>>>>>
89575>>>>>>>>>        If (sDbType = CS_dbTypePostgre) Begin
89577>>>>>>>>>            Move EN_dbTypePostgre to iRetval
89578>>>>>>>>>        End
89578>>>>>>>>>>
89578>>>>>>>>>        Function_Return iRetval
89579>>>>>>>>>    End_Function
89580>>>>>>>>>
89580>>>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
89580>>>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
89580>>>>>>>>>    // the SQL Connection program's grid.
89580>>>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
89582>>>>>>>>>        String sRetval
89582>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
89584>>>>>>>>>            Move "EN_dbTypeMSSQL" to sRetval
89585>>>>>>>>>        End
89585>>>>>>>>>>
89585>>>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
89587>>>>>>>>>            Move "EN_dbTypeMySQL" to sRetval
89588>>>>>>>>>        End
89588>>>>>>>>>>
89588>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
89590>>>>>>>>>            Move "EN_dbTypeOracle" to sRetval
89591>>>>>>>>>        End
89591>>>>>>>>>>
89591>>>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
89593>>>>>>>>>            Move "EN_dbTypeDB2" to sRetval
89594>>>>>>>>>        End
89594>>>>>>>>>>
89594>>>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
89596>>>>>>>>>            Move "EN_dbTypePostgre" to sRetval
89597>>>>>>>>>        End
89597>>>>>>>>>>
89597>>>>>>>>>        Function_Return sRetval
89598>>>>>>>>>    End_Function
89599>>>>>>>>>
89599>>>>>>>>>    // Pass a driver id and the function will return
89599>>>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
89599>>>>>>>>>    // quite work and always returns "MS SQL Server"
89599>>>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
89601>>>>>>>>>        Integer iRetval
89601>>>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
89603>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
89604>>>>>>>>>        End
89604>>>>>>>>>>
89604>>>>>>>>>        If (sDriverID = SQLFLEX) Begin
89606>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
89607>>>>>>>>>        End
89607>>>>>>>>>>
89607>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
89609>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
89610>>>>>>>>>        End
89610>>>>>>>>>>
89610>>>>>>>>>        If (sDriverID = MDSMySQL) Begin
89612>>>>>>>>>            Move EN_dbTypeMySQL to iRetval
89613>>>>>>>>>        End
89613>>>>>>>>>>
89613>>>>>>>>>        If (sDriverID = ORAFLEX) Begin
89615>>>>>>>>>            Move EN_dbTypeOracle to iRetval
89616>>>>>>>>>        End
89616>>>>>>>>>>
89616>>>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
89618>>>>>>>>>            Move EN_dbTypeDB2 to iRetval
89619>>>>>>>>>        End
89619>>>>>>>>>>
89619>>>>>>>>>        If (sDriverID = MDSPgSQL) Begin
89621>>>>>>>>>            Move EN_dbTypePostgre to iRetval
89622>>>>>>>>>        End
89622>>>>>>>>>>
89622>>>>>>>>>        Function_Return iRetval
89623>>>>>>>>>    End_Function
89624>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
89624>>>>>>>>>>
89624>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
89626>>>>>>>>>>    Integer iStart iEnd
89626>>>>>>>>>>    String sRetval
89626>>>>>>>>>>
89626>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
89627>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
89628>>>>>>>>>>    If (iStart = 0) Begin
89630>>>>>>>>>>        Function_Return ""
89631>>>>>>>>>>    End
89631>>>>>>>>>>>
89631>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
89632>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
89633>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
89635>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
89636>>>>>>>>>>    End
89636>>>>>>>>>>>
89636>>>>>>>>>>    Else Begin
89637>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
89638>>>>>>>>>>    End
89638>>>>>>>>>>>
89638>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
89640>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
89641>>>>>>>>>>        Decrement iEnd
89642>>>>>>>>>>    End
89642>>>>>>>>>>>
89642>>>>>>>>>>    If (iEnd <> 0) Begin
89644>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
89645>>>>>>>>>>    End
89645>>>>>>>>>>>
89645>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
89646>>>>>>>>>>
89646>>>>>>>>>>    Function_Return (Trim(sRetval))
89647>>>>>>>>>>End_Function
89648>>>>>>>>>>
89648>>>>>>>>>>
89648>>>>>>>>>
89648>>>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
89650>>>>>>>>>        String sConnect
89650>>>>>>>>>        Handle hoDriver
89650>>>>>>>>>
89650>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
89651>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
89652>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
89653>>>>>>>>>        Send Destroy   of hoDriver
89654>>>>>>>>>
89654>>>>>>>>>//        Case Begin
89654>>>>>>>>>//            Case (sDriverID = MSSQLDRV_ID)
89654>>>>>>>>>//                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
89654>>>>>>>>>//                If (sDatabase <> "") Begin
89654>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
89654>>>>>>>>>//                End
89654>>>>>>>>>//                If (bTrusted = True) Begin
89654>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
89654>>>>>>>>>//                End
89654>>>>>>>>>//                Else Begin
89654>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
89654>>>>>>>>>//                End
89654>>>>>>>>>//                Case Break
89654>>>>>>>>>//
89654>>>>>>>>>//            Case (sDriverID = ODBC_DRV_ID)
89654>>>>>>>>>//                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
89654>>>>>>>>>//                If (sDatabase <> "") Begin
89654>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
89654>>>>>>>>>//                End
89654>>>>>>>>>//                If (bTrusted = True) Begin
89654>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
89654>>>>>>>>>//                End
89654>>>>>>>>>//                Else Begin
89654>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
89654>>>>>>>>>//                End
89654>>>>>>>>>//                Case Break
89654>>>>>>>>>//
89654>>>>>>>>>//            Case (sDriverID = DB2_DRV_ID)
89654>>>>>>>>>//                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
89654>>>>>>>>>////                If (sDatabase <> "") Begin
89654>>>>>>>>>////                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
89654>>>>>>>>>////                End
89654>>>>>>>>>////                If (bTrusted = True) Begin
89654>>>>>>>>>////                    Move (sConnect * ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
89654>>>>>>>>>////                End
89654>>>>>>>>>////                Else Begin
89654>>>>>>>>>//                Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
89654>>>>>>>>>////                End
89654>>>>>>>>>//                Case Break
89654>>>>>>>>>//
89654>>>>>>>>>//            Case (sDriverID = SQLFLEX)
89654>>>>>>>>>//                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
89654>>>>>>>>>//                If (sDatabase <> "") Begin
89654>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
89654>>>>>>>>>//                End
89654>>>>>>>>>//                If (bTrusted = True) Begin
89654>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
89654>>>>>>>>>//                End
89654>>>>>>>>>//                Else Begin
89654>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
89654>>>>>>>>>//                End
89654>>>>>>>>>//                Case Break
89654>>>>>>>>>//
89654>>>>>>>>>//            Case (sDriverID = ORAFLEX)
89654>>>>>>>>>//                If (sDatabase <> "" and (not(sServer contains "/"))) Begin
89654>>>>>>>>>//                    Move (sServer + "/" + sDatabase)                  to sServer
89654>>>>>>>>>//                End
89654>>>>>>>>>//                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
89654>>>>>>>>>//                Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
89654>>>>>>>>>//                Case Break
89654>>>>>>>>>//
89654>>>>>>>>>//            Case (sDriverID = MDSPgSQL)
89654>>>>>>>>>//                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
89654>>>>>>>>>//                If (sDatabase <> "") Begin
89654>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
89654>>>>>>>>>//                End
89654>>>>>>>>>//                Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
89654>>>>>>>>>//                Case Break
89654>>>>>>>>>//
89654>>>>>>>>>//            Case (sDriverID = MDSMySQL)
89654>>>>>>>>>//                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
89654>>>>>>>>>//                If (sDatabase <> "") Begin
89654>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
89654>>>>>>>>>//                End
89654>>>>>>>>>//                Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
89654>>>>>>>>>//                Case Break
89654>>>>>>>>>//
89654>>>>>>>>>//            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
89654>>>>>>>>>//                Break
89654>>>>>>>>>//
89654>>>>>>>>>//            Case Else
89654>>>>>>>>>//                Move "" to sConnect
89654>>>>>>>>>//        Case End
89654>>>>>>>>>
89654>>>>>>>>>        Function_Return sConnect
89655>>>>>>>>>    End_Function
89656>>>>>>>>>
89656>>>>>>>>>    // Short connection string used when writing to ini-file. This is to be compatible with DF19 DFConnId.ini files that uses this short format.
89656>>>>>>>>>    Function ConstructShortConnectionString String sDriverID String sServer String sDatabase Returns String
89658>>>>>>>>>        String sConnect
89658>>>>>>>>>
89658>>>>>>>>>        Case Begin
89658>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID or sDriverID = SQLFLEX)
89660>>>>>>>>>                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
89661>>>>>>>>>                If (sDatabase <> "") Begin
89663>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
89664>>>>>>>>>                End
89664>>>>>>>>>>
89664>>>>>>>>>                Case Break
89665>>>>>>>>>
89665>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
89668>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
89669>>>>>>>>>                If (sDatabase <> "") Begin
89671>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
89672>>>>>>>>>                End
89672>>>>>>>>>>
89672>>>>>>>>>                Case Break
89673>>>>>>>>>
89673>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
89676>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
89677>>>>>>>>>                If (sDatabase <> "") Begin
89679>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
89680>>>>>>>>>                End
89680>>>>>>>>>>
89680>>>>>>>>>                Case Break
89681>>>>>>>>>
89681>>>>>>>>>            Case (sDriverID = ORAFLEX)
89684>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
89685>>>>>>>>>                If (sDatabase <> "") Begin
89687>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
89688>>>>>>>>>                End
89688>>>>>>>>>>
89688>>>>>>>>>                Case Break
89689>>>>>>>>>
89689>>>>>>>>>            Case (sDriverID = MDSPgSQL)
89692>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
89693>>>>>>>>>                If (sDatabase <> "") Begin
89695>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
89696>>>>>>>>>                End
89696>>>>>>>>>>
89696>>>>>>>>>                Case Break
89697>>>>>>>>>
89697>>>>>>>>>            Case (sDriverID = MDSMySQL)
89700>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
89701>>>>>>>>>                If (sDatabase <> "") Begin
89703>>>>>>>>>                    Move (sConnect * ";" +CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
89704>>>>>>>>>                End
89704>>>>>>>>>>
89704>>>>>>>>>                Case Break
89705>>>>>>>>>
89705>>>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
89708>>>>>>>>>                Break
89709>>>>>>>>>
89709>>>>>>>>>            Case Else
89709>>>>>>>>>                Move "" to sConnect
89710>>>>>>>>>        Case End
89710>>>>>>>>>
89710>>>>>>>>>        Function_Return sConnect
89711>>>>>>>>>    End_Function
89712>>>>>>>>>
89712>>>>>>>>>    // Use Base64
89712>>>>>>>>>    Function EncryptPassword String sPassword Returns String
89714>>>>>>>>>        String sRetval
89714>>>>>>>>>//        Handle hoCryptographer
89714>>>>>>>>>//
89714>>>>>>>>>//        Get psHashString to sHashString
89714>>>>>>>>>//        Get Create (RefClass(cCryptographer)) to hoCryptographer
89714>>>>>>>>>//        Set psProvider of hoCryptographer to MS_ENHANCED_PROV
89714>>>>>>>>>//        Get Encrypt of hoCryptographer sHashString sPassword to sRetval
89714>>>>>>>>>//
89714>>>>>>>>>//        Send Destroy of hoCryptographer
89714>>>>>>>>>          Get EncodeString of oBase64Functions sPassword to sRetval
89715>>>>>>>>>        Function_Return sRetval
89716>>>>>>>>>    End_Function
89717>>>>>>>>>
89717>>>>>>>>>    Function DecryptPassword String sPassword Returns String
89719>>>>>>>>>        String sRetval
89719>>>>>>>>>//        Handle hoCryptographer
89719>>>>>>>>>//
89719>>>>>>>>>//        Get psHashString to sHashString
89719>>>>>>>>>//        Get Create (RefClass(cCryptographer)) to hoCryptographer
89719>>>>>>>>>//        Set psProvider of hoCryptographer to MS_ENHANCED_PROV
89719>>>>>>>>>//        Get Decrypt of hoCryptographer sHashString sPassword to sRetval
89719>>>>>>>>>//
89719>>>>>>>>>//        Send Destroy of hoCryptographer
89719>>>>>>>>>          Get DecodeString of oBase64Functions sPassword to sRetval
89720>>>>>>>>>
89720>>>>>>>>>        Function_Return sRetval
89721>>>>>>>>>    End_Function
89722>>>>>>>>>
89722>>>>>>>>>    // Returns the full path of the Application (no trailing "\")
89722>>>>>>>>>    Function ApplicationPath Returns String
89724>>>>>>>>>        String sApplicationFileName sPath
89724>>>>>>>>>        Integer iNumChars iRetval
89724>>>>>>>>>
89724>>>>>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
89725>>>>>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
89726>>>>>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
89727>>>>>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
89728>>>>>>>>>        Move (CString(sApplicationFileName)) to sPath
89729>>>>>>>>>
89729>>>>>>>>>        Function_Return sPath
89730>>>>>>>>>    End_Function
89731>>>>>>>>>
89731>>>>>>>>>End_Class
89732>>>>>>>Use cDbUpdateDatabaseDriver.pkg
89732>>>>>>>
89732>>>>>>>// The cConnection class is the new SQL connections class for DF 19.
89732>>>>>>>// If an object of the cConnection class hasn't been instantiated we use a "dummy" class in its place.
89732>>>>>>>
89732>>>>>>>// We're making references to this object handle so we need it defined
89732>>>>>>>// here as well as for the cDbUpdateHandler class
89732>>>>>>>
89732>>>>>>>    Global_Variable Handle ghoSQLConnectionHandler
89732>>>>>>>
89732>>>>>>>Class cSQLConnectionHandler is a cObject
89733>>>>>>>
89733>>>>>>>    Procedure Construct_Object
89735>>>>>>>        Forward Send Construct_Object
89737>>>>>>>        Move Self to ghoSQLConnectionHandler
89738>>>>>>>
89738>>>>>>>        Property Handle phoSQLConnectionIniFile (Create(Self,RefClass(cSQLConnectionIniFile)))
89739>>>>>>>
89739>>>>>>>        // These properties are used by the cDbUpdateVersion and cDbUpdateFunctionLibrary classes,
89739>>>>>>>        // but put here so they can be set/get in both class objects. Those classes has "relay"
89739>>>>>>>        // methods to this class.
89739>>>>>>>        Property Boolean pbUseConnectionID True
89740>>>>>>>        Property Boolean pbToANSI          True
89741>>>>>>>        Property Boolean pbRecnum          True
89742>>>>>>>        Property Boolean pbCopyData        True
89743>>>>>>>        Property Boolean pbApiTableUpdateAuto    False
89744>>>>>>>        Property Boolean pbCompareDate_DateTime  False
89745>>>>>>>        Property Boolean pbCompareIndexAscending False
89746>>>>>>>        Property Boolean pbCompareIndexUppercase False
89747>>>>>>>
89747>>>>>>>        // Driver default value settings:
89747>>>>>>>        // Note: When the object is created the corresponding values
89747>>>>>>>        // from the driver .int files are read.
89747>>>>>>>        // Sample: Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of {driverNumber} to {StringVariable}
89747>>>>>>>        Property String psDriverDefaultValueASCII    ""
89748>>>>>>>        Property String psDriverDefaultValueBinary   ""
89749>>>>>>>        Property String psDriverDefaultValueDate     ""
89750>>>>>>>        Property String psDriverDefaultValueDateTime ""
89751>>>>>>>        Property String psDriverDefaultValueNumeric  ""
89752>>>>>>>        Property String psDriverDefaultValueText     ""
89753>>>>>>>
89753>>>>>>>        // Driver "nullability" settings:
89753>>>>>>>        // Note: When the object is created the corresponding values
89753>>>>>>>        // from the driver .int files are read.
89753>>>>>>>        // Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII of {driverNumber} to {BooleanVariable}
89753>>>>>>>        Property Boolean pbDriverDefaultNullableASCII    False
89754>>>>>>>        Property Boolean pbDriverDefaultNullableBinary   False
89755>>>>>>>        Property Boolean pbDriverDefaultNullableDate     False
89756>>>>>>>        Property Boolean pbDriverDefaultNullableDateTime False
89757>>>>>>>        Property Boolean pbDriverDefaultNullableNumeric  False
89758>>>>>>>        Property Boolean pbDriverDefaultNullableText     False
89759>>>>>>>
89759>>>>>>>        // *** This is the central point of connection data for the Database Update Framework ***
89759>>>>>>>        //     It is private because the get/set version also updates the DAW/Mertech
89759>>>>>>>        //     driver interfaces.
89759>>>>>>>        //     There are also procedure/function pairs to set/get individual data members
89759>>>>>>>        //     of the struct they are all routed throu this struct property.
89759>>>>>>>        Property tSQLConnection Private.pSQLConnection
89760>>>>>>>
89760>>>>>>>    End_Procedure
89761>>>>>>>
89761>>>>>>>    Procedure End_Construct_Object
89763>>>>>>>        Boolean bReadSettings
89763>>>>>>>        tSQLConnection SQLConnection
89763>>>>>>>        tSQLConnection SQLConnection
89763>>>>>>>
89763>>>>>>>        Forward Send End_Construct_Object
89765>>>>>>>
89765>>>>>>>        // Now is the time to read and apply SQL connection settings.
89765>>>>>>>        Get SetupSQLConnection True True to SQLConnection
89766>>>>>>>        Set Private.pSQLConnection to SQLConnection
89767>>>>>>>    End_Procedure
89768>>>>>>>
89768>>>>>>>    // *** Properties ***
89768>>>>>>>    // All connection related "properties" (get/set pairs) are really done by changing the
89768>>>>>>>    // private.pSQLConnection struct connection property. These "properties" are
89768>>>>>>>    // merely here for conveniance.
89768>>>>>>>    //
89768>>>>>>>    // The pSQLConnection get/set are here so we have a "central hub"
89768>>>>>>>    // where we update data to/from the DAW & Mertech driver interfaces and this framework.
89768>>>>>>>    // This struct property contains all the connection data.
89768>>>>>>>    //
89768>>>>>>>    Procedure Set pSQLConnection tSQLConnection SQLConnection
89770>>>>>>>        Boolean bIsDaw bOK
89770>>>>>>>
89770>>>>>>>        Set Private.pSQLConnection to SQLConnection
89771>>>>>>>
89771>>>>>>>        // When starting a program we might not have a connection id yet:
89771>>>>>>>        If (SQLConnection.sConnectionID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
89773>>>>>>>            Procedure_Return
89774>>>>>>>        End
89774>>>>>>>>
89774>>>>>>>
89774>>>>>>>        // If a DAW DFConnId.ini file was read instead of the DUF SQLConnections.ini file we should by now
89774>>>>>>>        // be logged in already and don't want to do it again.
89774>>>>>>>        If (SQLConnection.bDAWConnection = False) Begin
89776>>>>>>>            // After we have set the class property we need to tell the DAW/Mertech
89776>>>>>>>            // driver interfaces about the change & make a new login.
89776>>>>>>>            Get SQLLogin SQLConnection to bOK
89777>>>>>>>            If (bOK = False) Begin
89779>>>>>>>                Error DFERR_PROGRAM "Login error."
89780>>>>>>>>
89780>>>>>>>            End
89780>>>>>>>>
89780>>>>>>>        End
89780>>>>>>>>
89780>>>>>>>
89780>>>>>>>        // Now is the time to setup our driver default values by reading the driver .int file:
89780>>>>>>>        Send SetupDriverDefaults SQLConnection.sDriverID
89781>>>>>>>
89781>>>>>>>    End_Procedure
89782>>>>>>>
89782>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
89782>>>>>>>    // attempt to load the driver.
89782>>>>>>>    // Returns true if the passed driver is SQL based.
89782>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
89784>>>>>>>        Boolean bOK
89784>>>>>>>
89784>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
89785>>>>>>>        If (bOK = False) Begin
89787>>>>>>>            Get IsMertechDriver sDriverID to bOK
89788>>>>>>>        End
89788>>>>>>>>
89788>>>>>>>
89788>>>>>>>        Function_Return bOK
89789>>>>>>>    End_Function
89790>>>>>>>
89790>>>>>>>    // Reads the driver .int file and sets class properties of the cDbUpdateFunctionLibrary accordingly.
89790>>>>>>>    Procedure SetupDriverDefaults String sDriverID
89792>>>>>>>        String sAttributeValue
89792>>>>>>>        Integer iDriverID
89792>>>>>>>        Boolean bNULL bSQLDriver
89792>>>>>>>
89792>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
89793>>>>>>>        If (bSQLDriver = False) Begin
89795>>>>>>>            Procedure_Return
89796>>>>>>>        End
89796>>>>>>>>
89796>>>>>>>
89796>>>>>>>        Get DriverIndex sDriverID to iDriverID
89797>>>>>>>
89797>>>>>>>        // Driver default values for various data types:
89797>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_ASCII of iDriverID      to sAttributeValue
89800>>>>>>>        Set psDriverDefaultValueASCII                                   to sAttributeValue
89801>>>>>>>
89801>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_BINARY of iDriverID     to sAttributeValue
89804>>>>>>>        Set psDriverDefaultValueBinary                                  to sAttributeValue
89805>>>>>>>
89805>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATE of iDriverID       to sAttributeValue
89808>>>>>>>        Set psDriverDefaultValueDate                                    to sAttributeValue
89809>>>>>>>
89809>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATETIME of iDriverID   to sAttributeValue
89812>>>>>>>        Set psDriverDefaultValueDateTime                                to sAttributeValue
89813>>>>>>>
89813>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of iDriverID    to sAttributeValue
89816>>>>>>>        Set psDriverDefaultValueNumeric                                 to sAttributeValue
89817>>>>>>>
89817>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_TEXT of iDriverID       to sAttributeValue
89820>>>>>>>        Set psDriverDefaultValueText                                    to sAttributeValue
89821>>>>>>>
89821>>>>>>>        // The default setting for the "nullability" of newly created ASCII columns.
89821>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII      of iDriverID to bNULL
89824>>>>>>>        Set pbDriverDefaultNullableASCII to bNULL
89825>>>>>>>
89825>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_BINARY     of iDriverID to bNULL
89828>>>>>>>        Set pbDriverDefaultNullableBinary to bNULL
89829>>>>>>>
89829>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATE       of iDriverID to bNULL
89832>>>>>>>        Set pbDriverDefaultNullableDate to bNULL
89833>>>>>>>
89833>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATETIME   of iDriverID to bNULL
89836>>>>>>>        Set pbDriverDefaultNullableDateTime to bNULL
89837>>>>>>>
89837>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_NUMERIC    of iDriverID to bNULL
89840>>>>>>>        Set pbDriverDefaultNullableNumeric to bNULL
89841>>>>>>>
89841>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_TEXT       of iDriverID to bNULL
89844>>>>>>>        Set pbDriverDefaultNullableText to bNULL
89845>>>>>>>
89845>>>>>>>    End_Procedure
89846>>>>>>>
89846>>>>>>>    Function SQLLogin tSQLConnection SQLConnection Returns Boolean
89848>>>>>>>        Boolean bOK bIsDaw bIsMertech bTrusted
89848>>>>>>>        String sConnectionString sServer sDatabase sUserId sPassword sDriverID
89848>>>>>>>        Handle hoErrorObj hoDriver hoIniFile
89848>>>>>>>        Integer iDriverID
89848>>>>>>>
89848>>>>>>>        Move False to bOK
89849>>>>>>>
89849>>>>>>>        Get IsDAWSQLDriver SQLConnection.sDriverID to bIsDaw
89850>>>>>>>        If (bIsDaw = False) Begin
89852>>>>>>>            Get IsMertechDriver SQLConnection.sDriverID to bIsMertech
89853>>>>>>>            If (bIsMertech = False) Begin
89855>>>>>>>                Function_Return False
89856>>>>>>>            End
89856>>>>>>>>
89856>>>>>>>        End
89856>>>>>>>>
89856>>>>>>>
89856>>>>>>>        Move Error_Object_Id to hoErrorObj
89857>>>>>>>        Move Self to Error_Object_Id
89858>>>>>>>
89858>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
89859>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
89860>>>>>>>        Get DriverIndex SQLConnection.sDriverID to iDriverID
89861>>>>>>>        If (iDriverID = 0) Begin
89863>>>>>>>            Move hoErrorObj to Error_Object_Id
89864>>>>>>>            Function_Return False
89865>>>>>>>        End
89865>>>>>>>>
89865>>>>>>>
89865>>>>>>>        // There's a bug in Mertech drivers creating "an Exception error" in the debugger (probably will crash an application too.)
89865>>>>>>>        If (bIsMertech = False) Begin
89867>>>>>>>            Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to SQLConnection.bSilentLogin
89870>>>>>>>        End
89870>>>>>>>>
89870>>>>>>>
89870>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
89871>>>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
89872>>>>>>>        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
89873>>>>>>>        Send Destroy   of hoDriver
89874>>>>>>>        Move hoErrorObj to Error_Object_Id
89875>>>>>>>
89875>>>>>>>        Function_Return bOK
89876>>>>>>>    End_Function
89877>>>>>>>
89877>>>>>>>    Function pSQLConnection Returns tSQLConnection
89879>>>>>>>        tSQLConnection SQLConnection
89879>>>>>>>        tSQLConnection SQLConnection
89879>>>>>>>        Get Private.pSQLConnection to SQLConnection
89880>>>>>>>        Function_Return SQLConnection
89881>>>>>>>    End_Function
89882>>>>>>>
89882>>>>>>>    Procedure Set psConnectionID String sValue
89884>>>>>>>        tSQLConnection SQLConnection
89884>>>>>>>        tSQLConnection SQLConnection
89884>>>>>>>
89884>>>>>>>        Get Private.pSQLConnection to SQLConnection
89885>>>>>>>        If (SQLConnection.sConnectionID = "") Begin
89887>>>>>>>            Move sValue to SQLConnection.sConnectionID
89888>>>>>>>        End
89888>>>>>>>>
89888>>>>>>>
89888>>>>>>>        // Else we might want to change the current connection ID
89888>>>>>>>        Else If (SQLConnection.sConnectionID <> "" and SQLConnection.sConnectionID <> sValue) Begin
89891>>>>>>>            Move False to Err
89892>>>>>>>            Logout SQLConnection.sDriverID
89893>>>>>>>            // This will also make a login to the new server.
89893>>>>>>>            Get SQLIniFileConnectionID of (phoSQLConnectionIniFile(Self)) sValue to SQLConnection
89894>>>>>>>        End
89894>>>>>>>>
89894>>>>>>>        Set pSQLConnection to SQLConnection
89895>>>>>>>    End_Procedure
89896>>>>>>>
89896>>>>>>>    Function psConnectionID Returns String
89898>>>>>>>        tSQLConnection SQLConnection
89898>>>>>>>        tSQLConnection SQLConnection
89898>>>>>>>        Get Private.pSQLConnection to SQLConnection
89899>>>>>>>        Function_Return SQLConnection.sConnectionID
89900>>>>>>>    End_Procedure
89901>>>>>>>
89901>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
89901>>>>>>>    //       the psDriverID *must* be the first property that is changed!
89901>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
89901>>>>>>>    //       for a connection string has the wrong format for that driver.
89901>>>>>>>    Procedure Set psDriverID String sValue
89903>>>>>>>        tSQLConnection SQLConnection
89903>>>>>>>        tSQLConnection SQLConnection
89903>>>>>>>        Get pSQLConnection to SQLConnection
89904>>>>>>>        Move sValue        to SQLConnection.sDriverID
89905>>>>>>>        Set pSQLConnection to SQLConnection
89906>>>>>>>        If (sValue <> DATAFLEX_ID) Begin
89908>>>>>>>            Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
89909>>>>>>>        End
89909>>>>>>>>
89909>>>>>>>    End_Procedure
89910>>>>>>>
89910>>>>>>>    Function psDriverID Returns String
89912>>>>>>>        tSQLConnection SQLConnection
89912>>>>>>>        tSQLConnection SQLConnection
89912>>>>>>>        Get Private.pSQLConnection to SQLConnection
89913>>>>>>>        If (SQLConnection.sDriverID = "") Begin
89915>>>>>>>            Move DATAFLEX_ID to SQLConnection.sDriverID // Default is the DataFlex driver.
89916>>>>>>>        End
89916>>>>>>>>
89916>>>>>>>        Function_Return SQLConnection.sDriverID
89917>>>>>>>    End_Function
89918>>>>>>>
89918>>>>>>>    Procedure Set psConnectionString String sValue
89920>>>>>>>        tSQLConnection SQLConnection
89920>>>>>>>        tSQLConnection SQLConnection
89920>>>>>>>        Get Private.pSQLConnection to SQLConnection
89921>>>>>>>        Move sValue        to SQLConnection.sConnectionString
89922>>>>>>>        Set pSQLConnection to SQLConnection
89923>>>>>>>    End_Procedure
89924>>>>>>>
89924>>>>>>>    Function psConnectionString Returns String
89926>>>>>>>        tSQLConnection SQLConnection
89926>>>>>>>        tSQLConnection SQLConnection
89926>>>>>>>        Get Private.pSQLConnection to SQLConnection
89927>>>>>>>        Function_Return SQLConnection.sConnectionString
89928>>>>>>>    End_Function
89929>>>>>>>
89929>>>>>>>    Procedure Set psServer String sValue
89931>>>>>>>        tSQLConnection SQLConnection
89931>>>>>>>        tSQLConnection SQLConnection
89931>>>>>>>        Get Private.pSQLConnection to SQLConnection
89932>>>>>>>        Move sValue        to SQLConnection.sServer
89933>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
89934>>>>>>>        Set pSQLConnection to SQLConnection
89935>>>>>>>    End_Procedure
89936>>>>>>>
89936>>>>>>>    Function psServer Returns String
89938>>>>>>>        tSQLConnection SQLConnection
89938>>>>>>>        tSQLConnection SQLConnection
89938>>>>>>>        Get Private.pSQLConnection to SQLConnection
89939>>>>>>>        Function_Return SQLConnection.sServer
89940>>>>>>>    End_Function
89941>>>>>>>
89941>>>>>>>    Procedure Set psDatabase String sValue
89943>>>>>>>        tSQLConnection SQLConnection
89943>>>>>>>        tSQLConnection SQLConnection
89943>>>>>>>        Get Private.pSQLConnection to SQLConnection
89944>>>>>>>        Move sValue        to SQLConnection.sDatabase
89945>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
89946>>>>>>>        Set pSQLConnection to SQLConnection
89947>>>>>>>    End_Procedure
89948>>>>>>>
89948>>>>>>>    Function psDatabase Returns String
89950>>>>>>>        tSQLConnection SQLConnection
89950>>>>>>>        tSQLConnection SQLConnection
89950>>>>>>>        Get Private.pSQLConnection to SQLConnection
89951>>>>>>>        Function_Return SQLConnection.sDatabase
89952>>>>>>>    End_Function
89953>>>>>>>
89953>>>>>>>    Procedure Set psUserID String sValue
89955>>>>>>>        tSQLConnection SQLConnection
89955>>>>>>>        tSQLConnection SQLConnection
89955>>>>>>>        Get Private.pSQLConnection to SQLConnection
89956>>>>>>>        Move sValue        to SQLConnection.sUserID
89957>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
89958>>>>>>>        Set pSQLConnection to SQLConnection
89959>>>>>>>    End_Procedure
89960>>>>>>>
89960>>>>>>>    Function psUserID Returns String
89962>>>>>>>        tSQLConnection SQLConnection
89962>>>>>>>        tSQLConnection SQLConnection
89962>>>>>>>        Get Private.pSQLConnection to SQLConnection
89963>>>>>>>        Function_Return SQLConnection.sUserID
89964>>>>>>>    End_Function
89965>>>>>>>
89965>>>>>>>    // This is the uncrypted password
89965>>>>>>>    Procedure Set psPassword String sValue
89967>>>>>>>        tSQLConnection SQLConnection
89967>>>>>>>        tSQLConnection SQLConnection
89967>>>>>>>        Get Private.pSQLConnection to SQLConnection
89968>>>>>>>        Move sValue        to SQLConnection.sPassword
89969>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
89970>>>>>>>        Set pSQLConnection to SQLConnection
89971>>>>>>>    End_Procedure
89972>>>>>>>
89972>>>>>>>    Function psPassword Returns String
89974>>>>>>>        tSQLConnection SQLConnection
89974>>>>>>>        tSQLConnection SQLConnection
89974>>>>>>>        Get Private.pSQLConnection to SQLConnection
89975>>>>>>>        Function_Return SQLConnection.sPassword
89976>>>>>>>    End_Function
89977>>>>>>>
89977>>>>>>>    Procedure Set pbTrusted Boolean bValue
89979>>>>>>>        tSQLConnection SQLConnection
89979>>>>>>>        tSQLConnection SQLConnection
89979>>>>>>>        Get Private.pSQLConnection to SQLConnection
89980>>>>>>>        Move bValue        to SQLConnection.bTrusted
89981>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
89982>>>>>>>        Set pSQLConnection to SQLConnection
89983>>>>>>>    End_Procedure
89984>>>>>>>
89984>>>>>>>    Function pbTrusted Returns Boolean
89986>>>>>>>        tSQLConnection SQLConnection
89986>>>>>>>        tSQLConnection SQLConnection
89986>>>>>>>        Get Private.pSQLConnection to SQLConnection
89987>>>>>>>        Function_Return SQLConnection.bTrusted
89988>>>>>>>    End_Function
89989>>>>>>>
89989>>>>>>>    // *** All of these properties are special to the Database Update Framework ***
89989>>>>>>>    //     Thus they are not propagated to the DAW/Mertech classes and that is why
89989>>>>>>>    //     the Private.pSQLConnection property is set instead of the going throu
89989>>>>>>>    //     the central pSQLConnection "hub".
89989>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
89991>>>>>>>        tSQLConnection SQLConnection
89991>>>>>>>        tSQLConnection SQLConnection
89991>>>>>>>        Get Private.pSQLConnection to SQLConnection
89992>>>>>>>        Move bValue to SQLConnection.bTrusted
89993>>>>>>>        Set Private.pSQLConnection to SQLConnection
89994>>>>>>>    End_Procedure
89995>>>>>>>
89995>>>>>>>    Function pbSilentLogin Returns Boolean
89997>>>>>>>        tSQLConnection SQLConnection
89997>>>>>>>        tSQLConnection SQLConnection
89997>>>>>>>        Get Private.pSQLConnection to SQLConnection
89998>>>>>>>        Function_Return SQLConnection.bSilentLogin
89999>>>>>>>    End_Function
90000>>>>>>>
90000>>>>>>>    Procedure Set piDbType Integer iValue
90002>>>>>>>        tSQLConnection SQLConnection
90002>>>>>>>        tSQLConnection SQLConnection
90002>>>>>>>        Get Private.pSQLConnection to SQLConnection
90003>>>>>>>        Move iValue to SQLConnection.iDbType
90004>>>>>>>        Set Private.pSQLConnection to SQLConnection
90005>>>>>>>    End_Procedure
90006>>>>>>>
90006>>>>>>>    Function piDbType Returns Integer
90008>>>>>>>        tSQLConnection SQLConnection
90008>>>>>>>        tSQLConnection SQLConnection
90008>>>>>>>        Get Private.pSQLConnection to SQLConnection
90009>>>>>>>        Function_Return SQLConnection.iDbType
90010>>>>>>>    End_Function
90011>>>>>>>
90011>>>>>>>    Procedure Set psBaseTableSpace String sValue
90013>>>>>>>        tSQLConnection SQLConnection
90013>>>>>>>        tSQLConnection SQLConnection
90013>>>>>>>        Get Private.pSQLConnection to SQLConnection
90014>>>>>>>        Move sValue to SQLConnection.sBaseTableSpace
90015>>>>>>>        Set Private.pSQLConnection to SQLConnection
90016>>>>>>>    End_Procedure
90017>>>>>>>
90017>>>>>>>    Function psBaseTableSpace Returns String
90019>>>>>>>        tSQLConnection SQLConnection
90019>>>>>>>        tSQLConnection SQLConnection
90019>>>>>>>        Get Private.pSQLConnection to SQLConnection
90020>>>>>>>        Function_Return SQLConnection.sBaseTableSpace
90021>>>>>>>    End_Function
90022>>>>>>>
90022>>>>>>>    Procedure Set psIndexTableSpace String sValue
90024>>>>>>>        tSQLConnection SQLConnection
90024>>>>>>>        tSQLConnection SQLConnection
90024>>>>>>>        Get Private.pSQLConnection to SQLConnection
90025>>>>>>>        Move sValue to SQLConnection.sIndexTableSpace
90026>>>>>>>        Set Private.pSQLConnection to SQLConnection
90027>>>>>>>    End_Procedure
90028>>>>>>>
90028>>>>>>>    Function psIndexTableSpace Returns String
90030>>>>>>>        tSQLConnection SQLConnection
90030>>>>>>>        tSQLConnection SQLConnection
90030>>>>>>>        Get Private.pSQLConnection to SQLConnection
90031>>>>>>>        Function_Return SQLConnection.sIndexTableSpace
90032>>>>>>>    End_Function
90033>>>>>>>
90033>>>>>>>    Procedure Set psLongTableSpace String sValue
90035>>>>>>>        tSQLConnection SQLConnection
90035>>>>>>>        tSQLConnection SQLConnection
90035>>>>>>>        Get Private.pSQLConnection to SQLConnection
90036>>>>>>>        Move sValue to SQLConnection.sLongTableSpace
90037>>>>>>>        Set Private.pSQLConnection to SQLConnection
90038>>>>>>>    End_Procedure
90039>>>>>>>
90039>>>>>>>    Function psLongTableSpace Returns String
90041>>>>>>>        tSQLConnection SQLConnection
90041>>>>>>>        tSQLConnection SQLConnection
90041>>>>>>>        Get Private.pSQLConnection to SQLConnection
90042>>>>>>>        Function_Return SQLConnection.sLongTableSpace
90043>>>>>>>    End_Function
90044>>>>>>>
90044>>>>>>>    Procedure Set psSchema String sValue
90046>>>>>>>        tSQLConnection SQLConnection
90046>>>>>>>        tSQLConnection SQLConnection
90046>>>>>>>        Get Private.pSQLConnection to SQLConnection
90047>>>>>>>        Move sValue to SQLConnection.sSchema
90048>>>>>>>        Set Private.pSQLConnection to SQLConnection
90049>>>>>>>    End_Procedure
90050>>>>>>>
90050>>>>>>>    Function psSchema Returns String
90052>>>>>>>        tSQLConnection SQLConnection
90052>>>>>>>        tSQLConnection SQLConnection
90052>>>>>>>        Get Private.pSQLConnection to SQLConnection
90053>>>>>>>        Function_Return SQLConnection.sSchema
90054>>>>>>>    End_Function
90055>>>>>>>
90055>>>>>>>    Procedure Set pbEnabled Boolean bValue
90057>>>>>>>        tSQLConnection SQLConnection
90057>>>>>>>        tSQLConnection SQLConnection
90057>>>>>>>        Get Private.pSQLConnection to SQLConnection
90058>>>>>>>        Move bValue to SQLConnection.bEnabled
90059>>>>>>>        Set Private.pSQLConnection to SQLConnection
90060>>>>>>>    End_Procedure
90061>>>>>>>
90061>>>>>>>    Function pbEnabled Returns Boolean
90063>>>>>>>        tSQLConnection SQLConnection
90063>>>>>>>        tSQLConnection SQLConnection
90063>>>>>>>        Get Private.pSQLConnection to SQLConnection
90064>>>>>>>        Function_Return SQLConnection.bEnabled
90065>>>>>>>    End_Function
90066>>>>>>>
90066>>>>>>>
90066>>>>>>>    // ************************************
90066>>>>>>>    Function SetupSQLConnection Boolean bReadDFConnSettings Boolean bReadSQLConnections Returns tSQLConnection
90068>>>>>>>        tSQLConnection SQLConnection
90068>>>>>>>        tSQLConnection SQLConnection
90068>>>>>>>
90068>>>>>>>        // If this object was created by the cDbUpdateHandler class we will
90068>>>>>>>        // deferr reading SQL connection values until later.
90068>>>>>>>        If (bReadDFConnSettings = True) Begin
90070>>>>>>>            // This is the new SQL login logic for DF 19 and up; "Managed Connections"
90070>>>>>>>            If (ghoConnection > 0) Begin
90072>>>>>>>                Get ReadcConnections to SQLConnection
90073>>>>>>>            End
90073>>>>>>>>
90073>>>>>>>
90073>>>>>>>            // In addition to the above; there might be other values set even if a cConnection
90073>>>>>>>            // object is used.
90073>>>>>>>            If (bReadSQLConnections = True) Begin
90075>>>>>>>                Get ReadSQLConnectionsIniSettings to SQLConnection
90076>>>>>>>            End
90076>>>>>>>>
90076>>>>>>>        End
90076>>>>>>>>
90076>>>>>>>
90076>>>>>>>        Function_Return SQLConnection
90077>>>>>>>    End_Function
90078>>>>>>>
90078>>>>>>>    // This is for the new cConnection class used by DF 19 and up (only).
90078>>>>>>>    Function ReadcConnections Returns tSQLConnection
90080>>>>>>>        tConnection Connection
90080>>>>>>>        tConnection Connection
90080>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
90080>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
90080>>>>>>>        Integer iRetval iDbType
90080>>>>>>>        Boolean bOK bEnabled bConnected
90080>>>>>>>        String sConnectionID sSchema
90080>>>>>>>
90080>>>>>>>            tConnection[] Connections
90080>>>>>>>            tConnection[] Connections
90081>>>>>>>            // - If the DF 19 cConnection class has been used in the cApplication object
90081>>>>>>>            // - and there are multiple connection id's defined for the same driver. This is
90081>>>>>>>            //   because otherwise we can't possibly know which connection id to use... So
90081>>>>>>>            //   we then generate an error and abort the program...
90081>>>>>>>            Get IsSinglecConnection (&sConnectionID) to bOK
90082>>>>>>>            If (bOK = False) Begin
90084>>>>>>>                Error DFERR_PROGRAM ("Programming error. The psConnectionID must be set in the cDbUpdateVersion object when a cConnect object is used in the cApplication object, and there are multiple connections defined. Program will now exit!")
90085>>>>>>>>
90085>>>>>>>                Abort
90086>>>>>>>>
90086>>>>>>>            End
90086>>>>>>>>
90086>>>>>>>            If (sConnectionID = "") Begin
90088>>>>>>>                Get ConnectionIDs of ghoConnection to Connections
90089>>>>>>>                If (SizeOfArray(Connections) > 0) Begin
90091>>>>>>>                    Move Connections[0].sId to sConnectionID
90092>>>>>>>                End
90092>>>>>>>>
90092>>>>>>>            End
90092>>>>>>>>
90092>>>>>>>
90092>>>>>>>            Move 0 to iRetval
90093>>>>>>>            // DAW DF19 connection info:
90093>>>>>>>            // We first check that the connection is OK:
90093>>>>>>>            Get ConnectionIdIndex of ghoConnection sConnectionID to iRetval
90094>>>>>>>            // It might happen that no connection has been setup although the object exists, in case we do nothing.
90094>>>>>>>            If (iRetval = -1) Begin
90096>>>>>>>                Function_Return SQLConnectionEmpty
90097>>>>>>>            End
90097>>>>>>>>
90097>>>>>>>
90097>>>>>>>            If (sConnectionID <> "") Begin
90099>>>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
90100>>>>>>>            End
90100>>>>>>>>
90100>>>>>>>            If (Connection.sId = "") Begin
90102>>>>>>>                Move True to SQLConnectionEmpty.bError
90103>>>>>>>                Function_Return SQLConnectionEmpty
90104>>>>>>>            End
90104>>>>>>>>
90104>>>>>>>
90104>>>>>>>            // DUF connection info struct property:
90104>>>>>>>            Get Private.pSQLConnection                       to SQLConnection
90105>>>>>>>
90105>>>>>>>            Move Connection.sId to sConnectionID
90106>>>>>>>            Get IsConnectionIdLoggedIn of ghoConnection sConnectionID to bConnected
90107>>>>>>>
90107>>>>>>>            If (bConnected = False) Begin
90109>>>>>>>                Get LoginConnectionId of ghoConnection sConnectionID to iRetval
90110>>>>>>>                If (iRetval <> 0) Begin
90112>>>>>>>                    Send UserError CS_DUF_CannotLoginToServer
90113>>>>>>>                    Send Exit_Application
90114>>>>>>>                End
90114>>>>>>>>
90114>>>>>>>                Move True                                   to SQLConnection.bDAWConnection
90115>>>>>>>                // We need to get the DAW connection info again as it might have
90115>>>>>>>                // been changed in the DAW db login dialog.
90115>>>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
90116>>>>>>>            End
90116>>>>>>>>
90116>>>>>>>
90116>>>>>>>            Move True                                        to SQLConnection.bEnabled
90117>>>>>>>            Move Connection.bTrustedConnection               to SQLConnection.bTrusted
90118>>>>>>>
90118>>>>>>>            // Not used in DUF:
90118>>>>>>>            // Move Connection.iDriverIndex                    to SQLConnection.iDriverIndex
90118>>>>>>>
90118>>>>>>>            Move (If(Connection.iOptions = 0, False, True))  to SQLConnection.bSilentLogin
90119>>>>>>>            Move Connection.sConnectionString                to SQLConnection.sConnectionString
90120>>>>>>>            Move Connection.sDriver                          to SQLConnection.sDriverID
90121>>>>>>>            Move Connection.sId                              to SQLConnection.sConnectionID
90122>>>>>>>            Move Connection.sUID                             to SQLConnection.sUserID
90123>>>>>>>            Move Connection.sPWD                             to SQLConnection.sPassword
90124>>>>>>>
90124>>>>>>>            // Not used in DUF:
90124>>>>>>>            // Move Connection.sSection to SQLConnection.xxx
90124>>>>>>>
90124>>>>>>>            // The rest of the properties of the SQLConnection struct should have been
90124>>>>>>>            // setup in the cDbUpdateHandler object, and we should be able to reach them through delegation:
90124>>>>>>>            If (Connection.sDriver <> ODBC_DRV_ID) Begin
90126>>>>>>>                Get ParseKeyWord Connection.sString CS_SQLIniServerKeyword to SQLConnection.sServer
90127>>>>>>>            End
90127>>>>>>>>
90127>>>>>>>            If (Connection.sDriver = ODBC_DRV_ID) Begin
90129>>>>>>>                Get ParseKeyWord Connection.sString CS_SQLIniDSNKeyword    to SQLConnection.sServer
90130>>>>>>>            End
90130>>>>>>>>
90130>>>>>>>            Get ParseKeyWord Connection.sString CS_SQLIniDatabaseKeyword   to SQLConnection.sDatabase
90131>>>>>>>
90131>>>>>>>            // The DbType is a bit special. If the piDbType has _not_ been setup in object code we try to derave
90131>>>>>>>            // the value from the driver id:
90131>>>>>>>            Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(Self)) Connection.sDriver to SQLConnection.iDbType
90132>>>>>>>            // ...but in case it has been explicitly set in the object we use that value.
90132>>>>>>>            Get piDbType                                     to iDbType
90133>>>>>>>            If (iDbType <> SQLConnection.iDbType) Begin
90135>>>>>>>                Move iDbType to SQLConnection.iDbType
90136>>>>>>>            End
90136>>>>>>>>
90136>>>>>>>            Get psBaseTableSpace                             to SQLConnection.sBaseTableSpace
90137>>>>>>>            Get psLongTableSpace                             to SQLConnection.sLongTableSpace
90138>>>>>>>            Get psIndexTableSpace                            to SQLConnection.sIndexTableSpace
90139>>>>>>>            Get psSchema                                     to SQLConnection.sSchema
90140>>>>>>>
90140>>>>>>>            // We finally set the struct property to the newly fetched values.
90140>>>>>>>            Set pSQLConnection to SQLConnection
90141>>>>>>>
90141>>>>>>>        Function_Return SQLConnection
90142>>>>>>>    End_Function
90143>>>>>>>
90143>>>>>>>    // Returns True if the psConnectionID has been set in the cDbUpateHandler object,
90143>>>>>>>    // or the DAW cConnect array of registered connection only contains one active/enabled
90143>>>>>>>    // connection id for a particular driver.
90143>>>>>>>    // So either the psConnectionID or the psDriverID can have been set in the cDbUpdateHandler
90143>>>>>>>    // object. We can then match a connection id from the DAW cConnect class array.
90143>>>>>>>    // Returns False if there are multiple connections that are enabled or the psConnectionID has
90143>>>>>>>    // been set in the cDbUpdateHandler object but it cannot be found amongst the registered
90143>>>>>>>    // connections of the DAW cConnect class.
90143>>>>>>>    Function IsSinglecConnection String ByRef sConnectionID Returns Boolean
90145>>>>>>>        tConnection[] ConnIdArray
90145>>>>>>>        tConnection[] ConnIdArray
90146>>>>>>>        Integer iCount iSize iConnectionIDCounter
90146>>>>>>>        Boolean bEnabled bFound
90146>>>>>>>        String sConnectionID2 sDriverID sDriverConn
90146>>>>>>>
90146>>>>>>>        Move False to bFound
90147>>>>>>>        If (ghoConnection > 0) Begin
90149>>>>>>>
90149>>>>>>>            // The property of the cDbUpdateHandler container object
90149>>>>>>>            Get psDriverID to sDriverID
90150>>>>>>>
90150>>>>>>>            Move 0 to iConnectionIDCounter
90151>>>>>>>            // This is the the DAW cConnect array with all registered connection id's.
90151>>>>>>>                Get ConnectionIDs of ghoConnection to ConnIdArray
90152>>>>>>>            Move (SizeOfArray(ConnIdArray)) to iSize
90153>>>>>>>            Decrement iSize
90154>>>>>>>            For iCount from 0 to iSize
90160>>>>>>>>
90160>>>>>>>                Move ConnIdArray[iCount].sDriver to sDriverConn
90161>>>>>>>                Move ConnIdArray[iCount].sId to sConnectionID2
90162>>>>>>>                Move (ConnIdArray[iCount].bDisabled = False) to bEnabled
90163>>>>>>>                // If no psConnectionID specified in the cDbUpdateHandler, we check if there is a driver
90163>>>>>>>                // connection in the DAW cConnect object _and_ that there is only one!
90163>>>>>>>                If (sConnectionID = "") Begin
90165>>>>>>>                    Move (sDriverID = sDriverConn and bEnabled = True) to bFound
90166>>>>>>>                End
90166>>>>>>>>
90166>>>>>>>                Else Begin
90167>>>>>>>                    If (Uppercase(sConnectionID) = Uppercase(sConnectionID2)) Begin
90169>>>>>>>                        Move iSize to iCount // Then we've found what we were looking for and we're out of here...
90170>>>>>>>                    End
90170>>>>>>>>
90170>>>>>>>                End
90170>>>>>>>>
90170>>>>>>>
90170>>>>>>>                If (bFound = True) Begin
90172>>>>>>>                    Increment iConnectionIDCounter
90173>>>>>>>                End
90173>>>>>>>>
90173>>>>>>>            Loop
90174>>>>>>>>
90174>>>>>>>            Move (iConnectionIDCounter <= 1 and sDriverConn <> "" and sConnectionID2 <> "") to bFound
90175>>>>>>>            If (bFound = True) Begin
90177>>>>>>>                Move sConnectionID2 to sConnectionID
90178>>>>>>>            End
90178>>>>>>>>
90178>>>>>>>        End
90178>>>>>>>>
90178>>>>>>>
90178>>>>>>>        // Special case; a cConnection object has been setup in the cApplication,
90178>>>>>>>        // but no DFConn.ini record has been created.
90178>>>>>>>        If (iSize = -1) Begin
90180>>>>>>>            Move True to bFound
90181>>>>>>>        End
90181>>>>>>>>
90181>>>>>>>
90181>>>>>>>        Function_Return bFound
90182>>>>>>>    End_Function
90183>>>>>>>
90183>>>>>>>    // Send on object creation to read the default connection string settings, and
90183>>>>>>>    // create a connection to the server.
90183>>>>>>>    Function ReadSQLConnectionsIniSettings Returns tSQLConnection
90185>>>>>>>        String sPath sFileName sPassword
90185>>>>>>>        Boolean bExists
90185>>>>>>>        tSQLConnection[] SQLConnectionArray
90185>>>>>>>        tSQLConnection[] SQLConnectionArray
90186>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
90186>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
90186>>>>>>>        Handle hoIniFile
90186>>>>>>>        Integer iSize iCount
90186>>>>>>>
90186>>>>>>>        Get psIniFilePath to sPath
90187>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
90188>>>>>>>        If (sPath = "") Begin
90190>>>>>>>            Get ApplicationPath of hoIniFile to sPath
90191>>>>>>>            Set psIniFilePath   of hoIniFile to sPath
90192>>>>>>>        End
90192>>>>>>>>
90192>>>>>>>        Get vFolderFormat sPath to sPath
90193>>>>>>>        Get psIniFileName to sFileName
90194>>>>>>>        Get vFilePathExists (sPath + sFileName) to bExists
90195>>>>>>>
90195>>>>>>>        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
90196>>>>>>>        Move (SizeOfArray(SQLConnectionArray)) to iSize
90197>>>>>>>        If (iSize = 0) Begin
90199>>>>>>>            // This may have been set by the "ReadcConnections" function,
90199>>>>>>>            // if a cConnection object has been setup for DataFlex 19 or later
90199>>>>>>>            // in the cApplication object.
90199>>>>>>>            Get pSQLConnection to SQLConnection
90200>>>>>>>            If (SQLConnection.sConnectionID = "") Begin
90202>>>>>>>                Function_Return SQLConnectionEmpty
90203>>>>>>>            End
90203>>>>>>>>
90203>>>>>>>            Move SQLConnection to SQLConnectionArray[0]
90204>>>>>>>        End
90204>>>>>>>>
90204>>>>>>>
90204>>>>>>>        // The first connection should be the one that is active, but just in case...
90204>>>>>>>        Decrement iSize
90205>>>>>>>        For iCount from 0 to iSize
90211>>>>>>>>
90211>>>>>>>            Move SQLConnectionArray[iCount] to SQLConnection
90212>>>>>>>            If (SQLConnection.bEnabled = True) Begin
90214>>>>>>>                Move iSize to iCount // We've found the enabled item, so we're out of here.
90215>>>>>>>            End
90215>>>>>>>>
90215>>>>>>>        Loop
90216>>>>>>>>
90216>>>>>>>
90216>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID ;             SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted ;             SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bSilentLogin
90217>>>>>>>
90217>>>>>>>        Set pSQLConnection to SQLConnection
90218>>>>>>>        Send AutoSetConnectionID
90219>>>>>>>
90219>>>>>>>        Function_Return SQLConnection
90220>>>>>>>    End_Function
90221>>>>>>>
90221>>>>>>>    Procedure Set psIniFilePath String sPath
90223>>>>>>>        Set psIniFilePath of (phoSQLConnectionIniFile(Self)) to sPath
90224>>>>>>>    End_Procedure
90225>>>>>>>
90225>>>>>>>    Function psIniFilePath Returns String
90227>>>>>>>        String sRetval
90227>>>>>>>        Get psIniFilePath of (phoSQLConnectionIniFile(Self)) to sRetval
90228>>>>>>>        Function_Return sRetval
90229>>>>>>>    End_Function
90230>>>>>>>
90230>>>>>>>    Procedure Set psIniFileName String sFileName
90232>>>>>>>        Set psIniFileName of (phoSQLConnectionIniFile(Self)) to sFileName
90233>>>>>>>    End_Procedure
90234>>>>>>>
90234>>>>>>>    Function psIniFileName Returns String
90236>>>>>>>        String sRetval
90236>>>>>>>        Get psIniFileName of (phoSQLConnectionIniFile(Self)) to sRetval
90237>>>>>>>        Function_Return sRetval
90238>>>>>>>    End_Function
90239>>>>>>>
90239>>>>>>>    // We use Base64 coding instead of the cCryptographer class because the
90239>>>>>>>    // password will get scrambled while writing/reading to/from the ini-file.
90239>>>>>>>//    { MethodType=Property Category="Behavior" InitialValue="zx!2139(LI0+?ips7433"}
90239>>>>>>>//    Procedure Set psHashString String sHashString
90239>>>>>>>//        Set psHashString of (phoSQLConnectionIniFile(Self)) to sHashString
90239>>>>>>>//    End_Procedure
90239>>>>>>>//
90239>>>>>>>//    Function psHashString Returns String
90239>>>>>>>//        String sRetval
90239>>>>>>>//        Get psHashString of (phoSQLConnectionIniFile(Self)) to sRetval
90239>>>>>>>//        Function_Return sRetval
90239>>>>>>>//    End_Function
90239>>>>>>>
90239>>>>>>>    Procedure Set psIniSectionName String sSection
90241>>>>>>>        Set psIniSectionName of (phoSQLConnectionIniFile(Self)) to sSection
90242>>>>>>>    End_Procedure
90243>>>>>>>
90243>>>>>>>    Function psIniSectionName Returns String
90245>>>>>>>        String sRetval
90245>>>>>>>        Get psIniSectionName of (phoSQLConnectionIniFile(Self)) to sRetval
90246>>>>>>>        Function_Return sRetval
90247>>>>>>>    End_Function
90248>>>>>>>
90248>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
90250>>>>>>>        Handle ho
90250>>>>>>>        Get phoSQLConnectionIniFile to ho
90251>>>>>>>        Set IniFileValue of ho to sSection sValueName sValue
90252>>>>>>>    End_Procedure
90253>>>>>>>
90253>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
90255>>>>>>>        Handle ho
90255>>>>>>>        String sRetval
90255>>>>>>>        Get phoSQLConnectionIniFile to ho
90256>>>>>>>        Get IniFileValue of ho sSection sValueName sDefaultValue to sRetval
90257>>>>>>>        Function_Return sRetval
90258>>>>>>>    End_Function
90259>>>>>>>
90259>>>>>>>    Function SectionExists String sSection Returns Boolean
90261>>>>>>>        Handle ho
90261>>>>>>>        Boolean bRetval
90261>>>>>>>        Get phoSQLConnectionIniFile to ho
90262>>>>>>>        Get SectionExists of ho sSection to bRetval
90263>>>>>>>        Function_Return bRetval
90264>>>>>>>    End_Function
90265>>>>>>>
90265>>>>>>>    Function KeyExists String sSection String sKey Returns Boolean
90267>>>>>>>        Handle ho
90267>>>>>>>        Boolean bRetval
90267>>>>>>>        Get phoSQLConnectionIniFile to ho
90268>>>>>>>        Get KeyExists of ho sSection sKey to bRetval
90269>>>>>>>        Function_Return bRetval
90270>>>>>>>    End_Function
90271>>>>>>>
90271>>>>>>>    Function EncryptPassword String sPassword Returns String
90273>>>>>>>        Handle ho
90273>>>>>>>        String sRetval
90273>>>>>>>        Get phoSQLConnectionIniFile to ho
90274>>>>>>>        Get EncryptPassword of ho sPassword to sRetval
90275>>>>>>>        Function_Return sRetval
90276>>>>>>>    End_Function
90277>>>>>>>
90277>>>>>>>    Function DecryptPassword String sPassword Returns String
90279>>>>>>>        Handle ho
90279>>>>>>>        String sRetval
90279>>>>>>>        Get phoSQLConnectionIniFile to ho
90280>>>>>>>        Get DecryptPassword of ho sPassword to sRetval
90281>>>>>>>        Function_Return sRetval
90282>>>>>>>    End_Function
90283>>>>>>>
90283>>>>>>>    // *** Main Connection Message ***
90283>>>>>>>    // It will create a Connection ID for the passed driver.
90283>>>>>>>    // It will also set the psDriverID & psConnectionID of this class.
90283>>>>>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent
90285>>>>>>>        Handle hoDriver
90285>>>>>>>        String sConnectionString sError
90285>>>>>>>        Boolean bLoginSuccessful
90285>>>>>>>
90285>>>>>>>        Get ConstructConnectionString sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnectionString
90286>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
90287>>>>>>>        Set psDriverID of hoDriver to sDriverID
90288>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
90289>>>>>>>        If (bLoginSuccessful = False) Begin
90291>>>>>>>            Error DFERR_PROGRAM (CS_DUF_CannotLoginToServer * CS_DUF_ErrorText * String(sError) + "\nConnectionID = " * sConnectionID + "\nConnection String = " * sConnectionString)
90292>>>>>>>>
90292>>>>>>>            Send Exit_Application
90293>>>>>>>        End
90293>>>>>>>>
90293>>>>>>>        Send Destroy of hoDriver
90294>>>>>>>
90294>>>>>>>    End_Procedure
90295>>>>>>>
90295>>>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
90297>>>>>>>        Integer iRetval
90297>>>>>>>        Handle hoCLI
90297>>>>>>>        String sDriverID
90297>>>>>>>
90297>>>>>>>        Get psDriverID to sDriverID
90298>>>>>>>        Get Create (Refclass(cCLIHandler)) to hoCLI
90299>>>>>>>        If (hoCLI <> 0) Begin
90301>>>>>>>            Set psDriverID of hoCLI to sDriverID
90302>>>>>>>            Get RedirectConnection of hoCLI sOldConnection sNewConnection to iRetval
90303>>>>>>>            Send Destroy of hoCLI
90304>>>>>>>        End
90304>>>>>>>>
90304>>>>>>>
90304>>>>>>>        Function_Return iRetval
90305>>>>>>>    End_Function
90306>>>>>>>
90306>>>>>>>    Procedure CreateConnParamsFromConnectionString String sDriverID String sConnectionString
90308>>>>>>>        String sServer sDatabase sUserID sPassword
90308>>>>>>>        tSQLConnection SQLConnection
90308>>>>>>>        tSQLConnection SQLConnection
90308>>>>>>>
90308>>>>>>>        Set psDriverID to sDriverID
90309>>>>>>>        Get DeComposeConnectionString sDriverID sConnectionString to SQLConnection
90310>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID SQLConnection.sServer;                                 SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted
90311>>>>>>>    End_Procedure
90312>>>>>>>
90312>>>>>>>    // This is needed when e.g. the connection id we have specified in the program code
90312>>>>>>>    // also exists in e.g. the MSSQLDRV.ini file (can either be local in the Data folder
90312>>>>>>>    // or the one in the DataFlex Bin folder.)
90312>>>>>>>    // We then need to delete the current one before creating a new one.
90312>>>>>>>    // This is because the parameters may differ between the program code and the
90312>>>>>>>    // MSSQLDRV.ini file in a deployed environment. Also DataFlex will generate an error
90312>>>>>>>    // when one tries to create a Connection ID that already exists.
90312>>>>>>>    Procedure RemoveExistingConnectionID String sDriverID String sConnectionID
90314>>>>>>>        Integer iResult iDriver iNumConn iConn
90314>>>>>>>        Handle hoCLI
90314>>>>>>>        String sID
90314>>>>>>>
90314>>>>>>>        If (sDriverID = "" or sConnectionID = "") Begin
90316>>>>>>>            Procedure_Return
90317>>>>>>>        End
90317>>>>>>>>
90317>>>>>>>
90317>>>>>>>        Move 0 to iResult
90318>>>>>>>        Get Create U_cCLIHandler to hoCLI
90319>>>>>>>        If (hoCLI <> 0) Begin
90321>>>>>>>            Set psDriverID of hoCLI to sDriverID
90322>>>>>>>            Get DriverIndex sDriverID to iDriver
90323>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
90326>>>>>>>            Decrement iNumConn
90327>>>>>>>            For iConn from 0 to iNumConn
90333>>>>>>>>
90333>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
90336>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
90338>>>>>>>                    Get DeleteConnectionID of hoCLI sConnectionID -1 to iResult
90339>>>>>>>                End
90339>>>>>>>>
90339>>>>>>>            Loop
90340>>>>>>>>
90340>>>>>>>            Send Destroy of hoCLI
90341>>>>>>>        End
90341>>>>>>>>
90341>>>>>>>
90341>>>>>>>    End_Procedure
90342>>>>>>>
90342>>>>>>>    Function ExistingConnectionSettings String sDriverID String sConnectionID Returns tSQLConnection
90344>>>>>>>        Integer iResult iDriver iNumConn iConn
90344>>>>>>>        Handle hoCLI
90344>>>>>>>        String sID sConnectionString sVal sDatabase
90344>>>>>>>        tSQLConnection SQLConnection
90344>>>>>>>        tSQLConnection SQLConnection
90344>>>>>>>        Boolean bTrusted
90344>>>>>>>
90344>>>>>>>        Move 0 to iResult
90345>>>>>>>        Get Create U_cCLIHandler to hoCLI
90346>>>>>>>        If (hoCLI <> 0) Begin
90348>>>>>>>            Set psDriverID of hoCLI to sDriverID
90349>>>>>>>            Get DriverIndex sDriverID to iDriver
90350>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
90353>>>>>>>            Decrement iNumConn
90354>>>>>>>            For iConn from 0 to iNumConn
90360>>>>>>>>
90360>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
90363>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
90365>>>>>>>                    Move sDriverID                                                      to SQLConnection.sDriverID      // For completeness only...
90366>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn              to SQLConnection.sConnectionID  // For completeness only...
90369>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iConn       to sConnectionString
90372>>>>>>>                    Move sConnectionString                                              to SQLConnection.sConnectionString
90373>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_OPTIONS of iDriver iConn      to SQLConnection.bSilentLogin
90376>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnection.sServer
90377>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnection.sDatabase
90378>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to SQLConnection.sUserID
90379>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to SQLConnection.sPassword
90380>>>>>>>
90380>>>>>>>                    Case Begin
90380>>>>>>>                        Case (sDriverID = MSSQLDRV_ID)
90382>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=") to sVal
90383>>>>>>>                            Move (If(Uppercase(sVal) = Uppercase(CS_SQLIniConnectionYes), True, False)) to bTrusted
90384>>>>>>>                            Move bTrusted                                               to SQLConnection.bTrusted
90385>>>>>>>                            Case Break
90386>>>>>>>                        Case (sDriverID = DB2_DRV_ID)
90389>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
90390>>>>>>>                            Case Break
90391>>>>>>>                        Case (sDriverID = ODBC_DRV_ID)
90394>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
90395>>>>>>>                            Case Break
90396>>>>>>>                        Case (sDriverID = SQLFLEX)
90399>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
90400>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
90401>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
90403>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
90404>>>>>>>                            End
90404>>>>>>>>
90404>>>>>>>                            Else Begin
90405>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
90406>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
90407>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
90408>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
90409>>>>>>>                            End
90409>>>>>>>>
90409>>>>>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
90410>>>>>>>                            Case Break
90411>>>>>>>                        Case (sDriverID = MDSMySQL)
90414>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
90415>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
90416>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
90418>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
90419>>>>>>>                            End
90419>>>>>>>>
90419>>>>>>>                            Else Begin
90420>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
90421>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
90422>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
90423>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
90424>>>>>>>                            End
90424>>>>>>>>
90424>>>>>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
90425>>>>>>>                            Case Break
90426>>>>>>>                        Case (sDriverID = MDSPgSQL)
90429>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
90430>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
90431>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
90433>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
90434>>>>>>>                            End
90434>>>>>>>>
90434>>>>>>>                            Else Begin
90435>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
90436>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
90437>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
90438>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
90439>>>>>>>                            End
90439>>>>>>>>
90439>>>>>>>                            Move sConnectionString                                                to SQLConnection.sConnectionString
90440>>>>>>>                            Case Break
90441>>>>>>>
90441>>>>>>>                        Case (sDriverID = ORAFLEX)
90444>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to SQLConnection.sServer
90445>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)         to sConnectionString
90446>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
90447>>>>>>>                            If (sDatabase <> "" and (not(SQLConnection.sServer contains "/"))) Begin
90449>>>>>>>                                Move (SQLConnection.sServer + "/" + sDatabase)                  to SQLConnection.sServer
90450>>>>>>>                            End
90450>>>>>>>>
90450>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
90452>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
90453>>>>>>>                            End
90453>>>>>>>>
90453>>>>>>>                            Else Begin
90454>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
90455>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
90456>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
90457>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
90458>>>>>>>                            End
90458>>>>>>>>
90458>>>>>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
90459>>>>>>>                            Case Break
90460>>>>>>>                        Case Else
90460>>>>>>>                            Error ("Wrong driver ID passed:" * sDriverID)
90461>>>>>>>>
90461>>>>>>>                            Case Break
90462>>>>>>>                    Case End
90462>>>>>>>                End
90462>>>>>>>>
90462>>>>>>>            Loop
90463>>>>>>>>
90463>>>>>>>            Send Destroy of hoCLI
90464>>>>>>>        End
90464>>>>>>>>
90464>>>>>>>
90464>>>>>>>        Function_Return SQLConnection
90465>>>>>>>    End_Function
90466>>>>>>>
90466>>>>>>>    Function DriverIndex String sDriverID Returns Integer
90468>>>>>>>        String  sCurrentDriver
90468>>>>>>>        Integer iNumberOfDrivers iDriver iCount
90468>>>>>>>
90468>>>>>>>        Move 0 to iDriver
90469>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
90472>>>>>>>        For iCount from 1 to iNumberOfDrivers
90478>>>>>>>>
90478>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
90481>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
90483>>>>>>>                Function_Return iCount
90484>>>>>>>            End
90484>>>>>>>>
90484>>>>>>>        Loop
90485>>>>>>>>
90485>>>>>>>
90485>>>>>>>        // If driver not previously loaded; attempt to do so now.
90485>>>>>>>        If (iDriver = 0) Begin
90487>>>>>>>            Move 0 to LastErr
90488>>>>>>>            Load_Driver sDriverID
90489>>>>>>>            // If driver could not be loaded.
90489>>>>>>>            If (LastErr = 4255) Begin
90491>>>>>>>                Move 0 to iCount
90492>>>>>>>            End
90492>>>>>>>>
90492>>>>>>>            Function_Return iCount
90493>>>>>>>        End
90493>>>>>>>>
90493>>>>>>>        Function_Return 0
90494>>>>>>>    End_Function
90495>>>>>>>
90495>>>>>>>    // This will update connection settings of the cCLIHandler object with that passed struct values.
90495>>>>>>>    Procedure UpdateConnectionString tSQLConnection SQLConnection
90497>>>>>>>        String sDriverID sConnectionID sServer sDatabase sUserID sPassword
90497>>>>>>>        Boolean bTrusted bSilent
90497>>>>>>>
90497>>>>>>>        Move SQLConnection.sDriverID     to sDriverID
90498>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
90499>>>>>>>        Move SQLConnection.sServer       to sServer
90500>>>>>>>        Move SQLConnection.sDatabase     to sDatabase
90501>>>>>>>        Move SQLConnection.bTrusted      to bTrusted
90502>>>>>>>        Move SQLConnection.sUserID       to sUserID
90503>>>>>>>        Move SQLConnection.sPassword     to sPassword
90504>>>>>>>        Move SQLConnection.bSilentLogin  to bSilent
90505>>>>>>>
90505>>>>>>>        Send CreateSQLConnection sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent
90506>>>>>>>        // Note that this message will first delete the current ConnectionID if it exists; which is needed by the cCLIHandler logic.
90506>>>>>>>        Send AutoSetConnectionID
90507>>>>>>>    End_Procedure
90508>>>>>>>
90508>>>>>>>    // Called when the object is constructed.
90508>>>>>>>    // It will check the psDriverID for a ConnectionID and save it
90508>>>>>>>    // as psConnectionID property. It is later used whenever a login to
90508>>>>>>>    // the database is needed.
90508>>>>>>>    Procedure AutoSetConnectionID
90510>>>>>>>        String sConnectionID sDriverID sConnectionString
90510>>>>>>>        Integer iDriver iRetval
90510>>>>>>>        Handle hoCLI
90510>>>>>>>        Boolean bOK bSilent bMertechDriver
90510>>>>>>>
90510>>>>>>>        Get pbSilentLogin      to bSilent
90511>>>>>>>        Get psConnectionID     to sConnectionID
90512>>>>>>>        Get psConnectionString to sConnectionString
90513>>>>>>>        // Get the driver Connection ID string & set the psConnectionString property.
90513>>>>>>>        Get psDriverID to sDriverID
90514>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
90515>>>>>>>        If (bOK = False) Begin
90517>>>>>>>            Procedure_Return
90518>>>>>>>        End
90518>>>>>>>>
90518>>>>>>>
90518>>>>>>>        // Mertech drivers can't use connection ID's.
90518>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
90519>>>>>>>        If (bMertechDriver = True) Begin
90521>>>>>>>            // This ensures that the correct Server & Database attributes are set both for
90521>>>>>>>            // embedded SQL calls and "normal" database commands like e.g. "Open".
90521>>>>>>>            Get _MertechSQLManagerHandle to hoCLI
90522>>>>>>>            Procedure_Return
90523>>>>>>>        End
90523>>>>>>>>
90523>>>>>>>
90523>>>>>>>        Get DriverIndex sDriverID          to iDriver
90524>>>>>>>        // If driver not loaded; load it.
90524>>>>>>>        If (iDriver = 0) Begin
90526>>>>>>>            Load_Driver sDriverID
90527>>>>>>>            Get DriverIndex sDriverID      to iDriver
90528>>>>>>>        End
90528>>>>>>>>
90528>>>>>>>        // This shouldn't be possible; unless the driver.dll file is missing or something...
90528>>>>>>>        If (iDriver = 0) Begin
90530>>>>>>>            Error DFERR_PROGRAM ("The database driver could not be loaded! Connection to database failed." * sDriverID)
90531>>>>>>>>
90531>>>>>>>            Procedure_Return
90532>>>>>>>        End
90532>>>>>>>>
90532>>>>>>>
90532>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
90533>>>>>>>        Set psDriverID of hoCLI            to sDriverID
90534>>>>>>>        // Delete the connection first; in case it exists
90534>>>>>>>        Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
90535>>>>>>>        Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to iRetval
90536>>>>>>>
90536>>>>>>>        Send Destroy of hoCLI
90537>>>>>>>    End_Procedure
90538>>>>>>>
90538>>>>>>>    // Returns the handle of the Mertech SQL handler.
90538>>>>>>>    // It also ensures that the correct Server & Database attributes are set both for
90538>>>>>>>    // embedded SQL calls and "normal" database commands like e.g. "Open".
90538>>>>>>>    // Note: This does _not_ return a proper CLI handler handle as it is not in this class.
90538>>>>>>>    //       So the return value is of no use! But we don't need the handle for this class.
90538>>>>>>>    Function _MertechSQLManagerHandle Returns Handle
90540>>>>>>>        Handle hoSQLHandler
90540>>>>>>>        String sDriverID sServer sDatabase
90540>>>>>>>
90540>>>>>>>        Move 0 to hoSQLHandler
90541>>>>>>>        Get psDriverID to sDriverID
90542>>>>>>>        Get psServer   to sServer
90543>>>>>>>        Get psDatabase to sDatabase
90544>>>>>>>        // This command is used to set the server to be used when opening tables
90544>>>>>>>        SET_CURRENT_SQL_SERVER to sServer
90563>>>>>>>>
90563>>>>>>>        // This command is used to specify which server to use for embedded SQL statements,
90563>>>>>>>        // but it has been constructed rather studidly as only constants and not variables
90563>>>>>>>        // are allowed...
90563>>>>>>>        If (sDriverID = MDSPgSQL) Begin
90565>>>>>>>            SET_CURRENT_SQL_SERVER_CONNECTION of MDSPgSQL to sServer
90581>>>>>>>        End
90581>>>>>>>>
90581>>>>>>>        If (sDriverID = MDSMySQL) Begin
90583>>>>>>>            SET_CURRENT_SQL_SERVER_CONNECTION of MDSMySQL to sServer
90599>>>>>>>        End
90599>>>>>>>>
90599>>>>>>>        If (sDriverID = ORAFLEX) Begin
90601>>>>>>>            SET_CURRENT_SQL_SERVER_CONNECTION of ORAFLEX to sServer
90617>>>>>>>        End
90617>>>>>>>>
90617>>>>>>>        If (sDriverID = SQLFLEX) Begin
90619>>>>>>>            SET_CURRENT_SQL_SERVER_CONNECTION of SQLFLEX to sServer
90635>>>>>>>        End
90635>>>>>>>>
90635>>>>>>>
90635>>>>>>>        // This command is used to specify which database is used for embedded SQL statements.
90635>>>>>>>        SQL_USE_DATABASE sDatabase
90649>>>>>>>>
90649>>>>>>>        SET_DATABASE_NAME to sDatabase
90663>>>>>>>>
90663>>>>>>>
90663>>>>>>>        // Can't have this here because the property is defined for the cDbUpdateFunctionLibrary class,
90663>>>>>>>        // which object may or may not have been created at this point. So don't use the return
90663>>>>>>>        // value for this function!
90663>>>>>>>        //Get phoSQLManagerMT to hoSQLHandler
90663>>>>>>>
90663>>>>>>>        Function_Return hoSQLHandler
90664>>>>>>>    End_Function
90665>>>>>>>
90665>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
90667>>>>>>>        Boolean bOK bMertechDriver
90667>>>>>>>
90667>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
90668>>>>>>>
90668>>>>>>>        If (bOK = False) Begin
90670>>>>>>>            Get IsMertechDriver sDriverID to bOK
90671>>>>>>>        End
90671>>>>>>>>
90671>>>>>>>
90671>>>>>>>        If (bOK = False) Begin
90673>>>>>>>            Get IsMertechDriver sDriverID to bMertechDriver
90674>>>>>>>            If (bMertechDriver = True) Begin
90676>>>>>>>                Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID, ODBC_DRV_ID, SQLFLEX, ORAFLEX, MDSPgSQL or MDSMYSQL"
90677>>>>>>>>
90677>>>>>>>            End
90677>>>>>>>>
90677>>>>>>>            Else Begin
90678>>>>>>>                Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID or ODBC_DRV_ID"
90679>>>>>>>>
90679>>>>>>>            End
90679>>>>>>>>
90679>>>>>>>            Function_Return False
90680>>>>>>>        End
90680>>>>>>>>
90680>>>>>>>
90680>>>>>>>        Function_Return True
90681>>>>>>>    End_Function
90682>>>>>>>
90682>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
90684>>>>>>>        Boolean bOK
90684>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
90685>>>>>>>        Function_Return bOK
90686>>>>>>>    End_Function
90687>>>>>>>
90687>>>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
90689>>>>>>>        Boolean bOK
90689>>>>>>>        Move False to bOK
90690>>>>>>>            Move (sDriverID = SQLFLEX or sDriverID = ORAFLEX or sDriverID = MDSPgSQL or sDriverID = MDSMYSQL) to bOK
90691>>>>>>>        Function_Return bOK
90692>>>>>>>    End_Function
90693>>>>>>>
90693>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
90695>>>>>>>        Handle hoIniFile
90695>>>>>>>        String sConnect
90695>>>>>>>
90695>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
90696>>>>>>>        Get ConstructConnectionString of hoIniFile sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnect
90697>>>>>>>
90697>>>>>>>        Function_Return sConnect
90698>>>>>>>    End_Function
90699>>>>>>>
90699>>>>>>>    // Sample sConnString: "SERVER=(local)\SQLEXPRESS;UID=dbuser;PWD=secret;DATABASE=OrderEntry;, 0"
90699>>>>>>>    // Pass a complete driver connection string
90699>>>>>>>    // Returns the following as a struct:
90699>>>>>>>    //   sServer, sDatabase, sUser, sPassword & True if Trusted_Connection is used.
90699>>>>>>>    // Finally also returns a boolean TRUE if trusted_connection=yes, else false is returned.
90699>>>>>>>    //
90699>>>>>>>    Function DeComposeConnectionString String sDriverID String sConnectionString Returns tSQLConnection
90701>>>>>>>        tSQLConnection SQLConnection
90701>>>>>>>        tSQLConnection SQLConnection
90701>>>>>>>        String sValue sConnectionID sServer sDatabase sUserID sPassword
90701>>>>>>>        Boolean bTrusted bSilent bOK
90701>>>>>>>        Integer iPos
90701>>>>>>>
90701>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
90702>>>>>>>        If (bOK = False) Begin
90704>>>>>>>            Function_Return SQLConnection
90705>>>>>>>        End
90705>>>>>>>>
90705>>>>>>>
90705>>>>>>>        Move False to bTrusted
90706>>>>>>>        Move False to bSilent
90707>>>>>>>
90707>>>>>>>        Case Begin
90707>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
90709>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
90710>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
90711>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
90712>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
90713>>>>>>>                If (bTrusted = False) Begin
90715>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
90716>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
90717>>>>>>>                End
90717>>>>>>>>
90717>>>>>>>                Case Break
90718>>>>>>>
90718>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
90721>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
90722>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
90723>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
90724>>>>>>>                If (bTrusted = False) Begin
90726>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
90727>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
90728>>>>>>>                End
90728>>>>>>>>
90728>>>>>>>                Case Break
90729>>>>>>>
90729>>>>>>>            Case (sDriverID = DB2_DRV_ID)
90732>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
90733>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
90734>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
90735>>>>>>>                Case Break
90736>>>>>>>
90736>>>>>>>            Case (sDriverID = SQLFLEX)
90739>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
90740>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
90741>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
90742>>>>>>>                If (bTrusted = False) Begin
90744>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
90745>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
90746>>>>>>>                End
90746>>>>>>>>
90746>>>>>>>                Case Break
90747>>>>>>>
90747>>>>>>>            Case (sDriverID = ORAFLEX)
90750>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
90751>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
90752>>>>>>>                If (sDatabase <> "" and (not(sServer contains "/"))) Begin
90754>>>>>>>                    Move (sServer + "/" + sDatabase)                                to sServer
90755>>>>>>>                End
90755>>>>>>>>
90755>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
90756>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
90757>>>>>>>                Case Break
90758>>>>>>>
90758>>>>>>>            Case (sDriverID = MDSPgSQL)
90761>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
90762>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
90763>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
90764>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
90765>>>>>>>                Case Break
90766>>>>>>>
90766>>>>>>>            Case (sDriverID = MDSMySQL)
90769>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
90770>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
90771>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
90772>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
90773>>>>>>>                Case Break
90774>>>>>>>
90774>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
90777>>>>>>>                Break
90778>>>>>>>        Case End
90778>>>>>>>
90778>>>>>>>        Get ParseKeyWord sConnectionString (Uppercase(CS_SQLConnectionIDText))  to sConnectionID
90779>>>>>>>
90779>>>>>>>        // bSilent?
90779>>>>>>>        Move (Pos(",0", sConnectionString))                                     to iPos
90780>>>>>>>        If (iPos = 0) Begin
90782>>>>>>>            Move (Pos(",1", sConnectionString))                                 to iPos
90783>>>>>>>        End
90783>>>>>>>>
90783>>>>>>>        If (iPos = 0) Begin
90785>>>>>>>            Move "0"                                                            to sValue
90786>>>>>>>        End
90786>>>>>>>>
90786>>>>>>>        Else Begin
90787>>>>>>>            Move (Mid(sConnectionString, 1, (iPos +1)))                         to sValue
90788>>>>>>>        End
90788>>>>>>>>
90788>>>>>>>        Move (If(sValue = 1, True, False))                                      to bSilent
90789>>>>>>>
90789>>>>>>>        Move (Trim(sDriverID))                                                  to SQLConnection.sDriverID
90790>>>>>>>        Move (Trim(sConnectionID))                                              to SQLConnection.sConnectionID
90791>>>>>>>        Move (Trim(sConnectionString))                                          to SQLConnection.sConnectionString
90792>>>>>>>        Move (Trim(sServer))                                                    to SQLConnection.sServer
90793>>>>>>>        Move (Trim(sDatabase))                                                  to SQLConnection.sDatabase
90794>>>>>>>        Move bTrusted                                                           to SQLConnection.bTrusted
90795>>>>>>>        Move (Trim(sUserID))                                                    to SQLConnection.sUserID
90796>>>>>>>        Move (Trim(sPassword))                                                  to SQLConnection.sPassword
90797>>>>>>>        Move bSilent                                                            to SQLConnection.bSilentLogin
90798>>>>>>>
90798>>>>>>>        Function_Return SQLConnection
90799>>>>>>>    End_Function
90800>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
90800>>>>>>>>
90800>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
90802>>>>>>>>    Integer iStart iEnd
90802>>>>>>>>    String sRetval
90802>>>>>>>>
90802>>>>>>>>    Move (Trim(sConnect)) to sConnect
90803>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
90804>>>>>>>>    If (iStart = 0) Begin
90806>>>>>>>>        Function_Return ""
90807>>>>>>>>    End
90807>>>>>>>>>
90807>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
90808>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
90809>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
90811>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
90812>>>>>>>>    End
90812>>>>>>>>>
90812>>>>>>>>    Else Begin
90813>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
90814>>>>>>>>    End
90814>>>>>>>>>
90814>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
90816>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
90817>>>>>>>>        Decrement iEnd
90818>>>>>>>>    End
90818>>>>>>>>>
90818>>>>>>>>    If (iEnd <> 0) Begin
90820>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
90821>>>>>>>>    End
90821>>>>>>>>>
90821>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
90822>>>>>>>>
90822>>>>>>>>    Function_Return (Trim(sRetval))
90823>>>>>>>>End_Function
90824>>>>>>>>
90824>>>>>>>>
90824>>>>>>>
90824>>>>>>>    // To update the SQLSettings.ini file with updated connection data (SQLConnection struct data).
90824>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
90826>>>>>>>        Handle ho
90826>>>>>>>        Integer iIndex
90826>>>>>>>        Boolean bRetval bOK
90826>>>>>>>        tSQLConnection SQLConnection
90826>>>>>>>        tSQLConnection SQLConnection
90826>>>>>>>
90826>>>>>>>        Get pSQLConnection to SQLConnection
90827>>>>>>>        Get phoSQLConnectionIniFile to ho
90828>>>>>>>        Get SQLIniFileConnectionIDIndex of ho sConnectionID to iIndex
90829>>>>>>>        If (iIndex = -1) Begin
90831>>>>>>>            Function_Return False
90832>>>>>>>        End
90832>>>>>>>>
90832>>>>>>>
90832>>>>>>>        Get SQLIniFileUpdateConnection of ho SQLConnection to bRetval
90833>>>>>>>        Send UpdateConnectionString of ghoSQLConnectionHandler SQLConnection
90834>>>>>>>        If (ghoConnection > 0) Begin
90836>>>>>>>            Get ConnectionIdIndex of ghoConnection SQLConnection.sConnectionID to iIndex
90837>>>>>>>            If (iIndex <> -1) Begin
90839>>>>>>>                Get RedirectConnectionId of ghoConnection SQLConnection.sConnectionID (SQLConnection.sServer + ";" + CS_SQLIniDatabaseKeyword + "=" + SQLConnection.sDatabase) SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted True to bOK
90840>>>>>>>            End
90840>>>>>>>>
90840>>>>>>>        End
90840>>>>>>>>
90840>>>>>>>
90840>>>>>>>        Function_Return bRetval
90841>>>>>>>    End_Function
90842>>>>>>>
90842>>>>>>>End_Class
90843>>>>>Use vWin32fh.pkg
90843>>>>>
90843>>>>>//
90843>>>>>Class cDbUpdateFunctionLibrary is a cObject
90844>>>>>    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
Including file: ParseKeyWord.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
90845>>>>>>
90845>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
90847>>>>>>    Integer iStart iEnd
90847>>>>>>    String sRetval
90847>>>>>>
90847>>>>>>    Move (Trim(sConnect)) to sConnect
90848>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
90849>>>>>>    If (iStart = 0) Begin
90851>>>>>>        Function_Return ""
90852>>>>>>    End
90852>>>>>>>
90852>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
90853>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
90854>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
90856>>>>>>        Move (Pos(",", sRetval))          to iEnd
90857>>>>>>    End
90857>>>>>>>
90857>>>>>>    Else Begin
90858>>>>>>        Move (Pos(";", sRetval))          to iEnd
90859>>>>>>    End
90859>>>>>>>
90859>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
90861>>>>>>        Move (Pos(",", sRetval))          to iEnd
90862>>>>>>        Decrement iEnd
90863>>>>>>    End
90863>>>>>>>
90863>>>>>>    If (iEnd <> 0) Begin
90865>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
90866>>>>>>    End
90866>>>>>>>
90866>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
90867>>>>>>
90867>>>>>>    Function_Return (Trim(sRetval))
90868>>>>>>End_Function
90869>>>>>>
90869>>>>>>
90869>>>>>
90869>>>>>    Procedure Construct_Object
90871>>>>>        Handle ho
90871>>>>>        Forward Send Construct_Object
90873>>>>>
90873>>>>>        Move Self to ghoDbUpdateFunctionLibrary
90874>>>>>
90874>>>>>        Send CreateDbUpdateLibraryProperties
90875>>>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
90875>>>>>        // we will create one as it is used for all ConnectionID, ConnectionString
90875>>>>>        // etc settings.
90875>>>>>        If (ghoSQLConnectionHandler = 0) Begin
90877>>>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
90878>>>>>            Set phoSQLConnectionHandler to ho
90879>>>>>        End
90879>>>>>>
90879>>>>>
90879>>>>>    End_Procedure
90880>>>>>
90880>>>>>    Procedure End_Construct_Object
90882>>>>>        Forward Send End_Construct_Object
90884>>>>>    End_Procedure
90885>>>>>
90885>>>>>    // *** SQL Messages for making changes to the SQL back-end ***
90885>>>>>    //
90885>>>>>    // * Dummy function for the Studio's Code Explorer *
90885>>>>>    Function SQL_DATABASE_FUNCTIONS Returns Boolean
90887>>>>>        Function_Return False
90888>>>>>    End_Function
90889>>>>>
90889>>>>>    // Function for creating a new *Database*.
90889>>>>>    // Note: This is for creating SQL DATABASES - not tables!
90889>>>>>    // Returns True if successful.
90889>>>>>    // ToDo: Only works for MS-SQL...
90889>>>>>    Function SqlDatabaseCreate String sDriverID String sDatabase Boolean bUpdateConnectionString Boolean bPermanantly Returns Boolean
90891>>>>>        String sSQL sSQL1 sConnectionID sConnectionString 
90891>>>>>        String sCreateDatabaseKeyWord sSelectFromWhereName sCollation sCollateKeyWord
90891>>>>>        Handle hConnection hStmt hoSQLManager
90891>>>>>        Integer iFetchResult iDbType
90891>>>>>        Boolean bOK bMertechDriver
90891>>>>>
90891>>>>>        Get piDbType to iDbType
90892>>>>>        If (iDbType <> EN_DbTypeMSSQL) Begin
90894>>>>>            Error DFERR_PROGRAM "Sorry, the SqlDatabaseCreate function is currently only supported for MS-SQL"
90895>>>>>>
90895>>>>>            Function_Return False
90896>>>>>        End
90896>>>>>>
90896>>>>>
90896>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
90897>>>>>        If (bMertechDriver = False) Begin
90899>>>>>            Get phoSQLManager to hoSQLManager
90900>>>>>        End
90900>>>>>>
90900>>>>>        Else Begin
90901>>>>>            Get _MertechSQLManagerHandle to hoSQLManager
90902>>>>>        End
90902>>>>>>
90902>>>>>        
90902>>>>>        Get psConnectionID     to sConnectionID
90903>>>>>        Get psConnectionString to sConnectionString
90904>>>>>        Move 0 to LastErr
90905>>>>>
90905>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
90906>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
90907>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
90908>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
90910>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
90911>>>>>>
90911>>>>>            Function_Return False
90912>>>>>        End
90912>>>>>>
90912>>>>>
90912>>>>>        Get SqlOpen of hConnection to hStmt
90913>>>>>
90913>>>>>        If (hStmt = 0) Begin
90915>>>>>            Send SqlDisconnect of hoSQLManager
90916>>>>>            Error DFERR_PROGRAM CS_SQLConnectError
90917>>>>>>
90917>>>>>            Function_Return False
90918>>>>>        End
90918>>>>>>
90918>>>>>
90918>>>>>        Get _SqlFindKeyWord CI_SQLCreateDatabase to sCreateDatabaseKeyWord
90919>>>>>        Get _SqlSelectFromWhereName to sSelectFromWhereName
90920>>>>>        Move (sSelectFromWhereName + "='" + sDatabase + "'") to sSQL 
90921>>>>>        
90921>>>>>        // Check if database exists
90921>>>>>        Send SqlExecDirect of hStmt sSQL
90922>>>>>        Get SqlFetch of hStmt to iFetchResult
90923>>>>>        Send SqlClose of hStmt
90924>>>>>        Send SqlDisconnect of hConnection
90925>>>>>
90925>>>>>        // If database already exists we're out of here!
90925>>>>>        // Note that we return True as this is not an error.
90925>>>>>        If (iFetchResult > 0) Begin
90927>>>>>            Function_Return True
90928>>>>>        End
90928>>>>>>
90928>>>>>
90928>>>>>        // Database doesn't exist, create it.
90928>>>>>        If (iFetchResult = 0) Begin
90930>>>>>            Move (sCreateDatabaseKeyWord + " [" + sDatabase + "]") to sSQL1
90931>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
90932>>>>>
90932>>>>>            Get psCollation to sCollation
90933>>>>>            If (sCollation <> "") Begin
90935>>>>>                Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
90936>>>>>                Move (sSQL1 * String(sCollateKeyWord) * String(sCollation)) to sSQL1
90937>>>>>            End
90937>>>>>>
90937>>>>>
90937>>>>>            Send SqlUtilExecuteQuery sSQL1 sDriverID
90938>>>>>
90938>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
90939>>>>>            If (LastErr = CLIERR_GENERAL_ERROR) Begin
90941>>>>>               Function_Return False
90942>>>>>            End
90942>>>>>>
90942>>>>>
90942>>>>>            // We need to wait a short time for Sql to finish, especially Windows to write the new file to disk.
90942>>>>>            Sleep 1
90943>>>>>            Send SqlUtilExecuteQuery sSQL sDriverID
90944>>>>>        End
90944>>>>>>
90944>>>>>
90944>>>>>        // If used in e.g. the cDbUpdteHandler we want to change the login database name to
90944>>>>>        // the one we just created.
90944>>>>>        If (bUpdateConnectionString = True) Begin
90946>>>>>            Set psDatabase to sDatabase
90947>>>>>            //...and perhaps also the SQLConnections.ini file setting.
90947>>>>>            If (bPermanantly = True) Begin
90949>>>>>                If (ghoSQLConnectionHandler <> 0) Begin
90951>>>>>                    Get SQLIniFileSetDefaultConnection of ghoSQLConnectionHandler sConnectionID to bOK
90952>>>>>                End
90952>>>>>>
90952>>>>>            End
90952>>>>>>
90952>>>>>        End
90952>>>>>>
90952>>>>>
90952>>>>>        Function_Return (Err = False)
90953>>>>>    End_Function
90954>>>>>
90954>>>>>    // Backs up an SQL database to a folder of choice. If no path is passed the SQL default backup folder
90954>>>>>    // will be used.
90954>>>>>    Function SqlDatabaseBackupToDisk String sDatabase String sBackupName String sPath Boolean bShowProg Returns Boolean
90956>>>>>        Boolean bOK bExists bShowProgress
90956>>>>>        String sStatement sDriverID
90956>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
90956>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
90956>>>>>        Integer iDbType
90956>>>>>
90956>>>>>        If (sDatabase = "") Begin
90958>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
90959>>>>>>
90959>>>>>            Function_Return False
90960>>>>>        End
90960>>>>>>
90960>>>>>        If (sBackupName = "") Begin
90962>>>>>            Error DFERR_PROGRAM "The database backup name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
90963>>>>>>
90963>>>>>            Function_Return False
90964>>>>>        End
90964>>>>>>
90964>>>>>
90964>>>>>        // Create backup-folder if it doesn't exist
90964>>>>>        Get vFolderExists sPath to bExists
90965>>>>>        If (bExists = False) Begin
90967>>>>>            Get vCreateDirectory sPath to bOK
90968>>>>>            If (bOK = False) Begin
90970>>>>>                Error DFERR_PROGRAM ("Could not create database backup folder:" * sPath)
90971>>>>>>
90971>>>>>                Function_Return False
90972>>>>>            End
90972>>>>>>
90972>>>>>        End
90972>>>>>>
90972>>>>>        // Make sure the path ends with a back-slash
90972>>>>>        If (sPath <> "") Begin
90974>>>>>            Get vFolderFormat sPath to sPath
90975>>>>>        End
90975>>>>>>
90975>>>>>
90975>>>>>        Get psDriverID to sDriverID
90976>>>>>        Get piDbType   to iDbType
90977>>>>>        If (num_arguments > 3) Begin
90979>>>>>            Move bShowProg to bShowProgress
90980>>>>>        End
90980>>>>>>
90980>>>>>
90980>>>>>        Case Begin
90980>>>>>            Case (iDbType = EN_DbTypeMSSQL)
90982>>>>>                SQLIncludeScriptFile ..\Scripts\BackupMSSQLDatabase.sql as BackupMSSQLDatabase.sql
90982>>>>>                SQLIncludeScriptFile ..\Scripts\GetPercentageBackupCompletionMSSQL.sql as GetPercentageBackupCompletionMSSQL.sql
90982>>>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "BackupMSSQLDatabase.sql" sDriverID False to SQLScriptArray
90983>>>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "GetPercentageBackupCompletionMSSQL.sql" sDriverID False to SQLScriptArrayPercentReady
90984>>>>>
90984>>>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
90985>>>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase))   to sStatement
90986>>>>>                Move (Replaces("BACKUP_PATH_XXX",   sStatement, sPath))       to sStatement
90987>>>>>                Move (Replaces("BACKUP_NAME_XXX",   sStatement, sBackupName)) to sStatement
90988>>>>>                Move sStatement to SQLScriptArray.sSQLScriptArray[0]
90989>>>>>                Get SqlUtilExecuteEmbeddedScript of ghoDbUpdateFunctionLibrary SQLScriptArray sDriverID False "" bShowProgress to bOK
90990>>>>>                Case Break
90991>>>>>            Case Else
90991>>>>>                Send Info_Box ("The SqlUtilBackupDatabaseToDisk function is currently not implemented for the driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and add a little ESQL code snippet to make it work for that driver! Thanks for helping out.")
90992>>>>>        Case End
90992>>>>>
90992>>>>>        Function_Return bOK
90993>>>>>    End_Function
90994>>>>>
90994>>>>>    Function SqlDatabaseCollationQuery String sDatabase Returns String
90996>>>>>        Boolean bOK bExists 
90996>>>>>        String sStatement sDriverID sRetval sPrevious
90996>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
90996>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
90996>>>>>        Integer iDbType iRows iFetchResult iColumn
90996>>>>>        Handle hoSQLHandler hoSQLConnect hstmt 
90996>>>>>        tSQLConnection SQLConnection
90996>>>>>        tSQLConnection SQLConnection
90996>>>>>
90996>>>>>        If (sDatabase = "") Begin
90998>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilDatabaseCollation' function"
90999>>>>>>
90999>>>>>            Function_Return False
91000>>>>>        End
91000>>>>>>
91000>>>>>        
91000>>>>>        Move "" to sRetval
91001>>>>>        Get psDriverID to sDriverID
91002>>>>>        Get piDbType   to iDbType
91003>>>>>
91003>>>>>        Case Begin
91003>>>>>            Case (iDbType = EN_DbTypeMSSQL)
91005>>>>>                SQLIncludeScriptFile ..\Scripts\QueryMSSQLCollation.sql as QueryMSSQLCollation.sql
91005>>>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "QueryMSSQLCollation.sql" sDriverID False to SQLScriptArray
91006>>>>>
91006>>>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
91007>>>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase)) to sStatement
91008>>>>>                Get phoSQLManager to hoSQLHandler
91009>>>>>        
91009>>>>>                If (hoSQLHandler <> 0) Begin
91011>>>>>                    Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
91012>>>>>                    Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
91013>>>>>        
91013>>>>>                    If (hoSQLConnect <> 0) Begin
91015>>>>>                        Get SQLOpen of hoSQLConnect to hstmt
91016>>>>>                        If (hstmt <> 0) Begin
91018>>>>>                            Send SqlExecDirect of hstmt sStatement
91019>>>>>                            Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
91020>>>>>                            Get SQLFetch of hstmt to iFetchResult
91021>>>>>                            If (iFetchResult <> 0) Begin
91023>>>>>                                Get SQLColumnValue of hstmt 2 to sRetval // Column 1 = Database Name, 2 = Collation Name.
91024>>>>>                            End
91024>>>>>>
91024>>>>>                            Send SQLClose of hstmt
91025>>>>>                        End
91025>>>>>>
91025>>>>>                        Send SQLDisconnect of hoSQLConnect
91026>>>>>                    End
91026>>>>>>
91026>>>>>                End
91026>>>>>>
91026>>>>>                Case Break
91027>>>>>            Case Else
91027>>>>>                Send Info_Box ("The SqlDatabaseCollationQuery function is currently not implemented for the driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and add a little ESQL code snippet to make it work for that driver! Thanks for helping out.")
91028>>>>>        Case End
91028>>>>>
91028>>>>>        Function_Return sRetval
91029>>>>>    End_Function
91030>>>>>
91030>>>>>    Function SqlDatabaseCollationChange String sDatabase String sSQLCollation Returns Boolean
91032>>>>>        Boolean bOK bExists bMertechDriver
91032>>>>>        String sDriverID sSQL sSQL1 sConnectionID sConnectionString sSet sWith
91032>>>>>        String sAlterDatabaseKeyWord sCollateKeyWord sSQLCollationCheck sSingle_User sMulti_User sRollback sImmediate
91032>>>>>        Handle hConnection hStmt hoSQLManager
91032>>>>>        Integer iFetchResult iDbType
91032>>>>>
91032>>>>>        If (sDatabase = "") Begin
91034>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
91035>>>>>>
91035>>>>>            Function_Return False
91036>>>>>        End
91036>>>>>>
91036>>>>>        
91036>>>>>        If (sSQLCollation = "") Begin
91038>>>>>            Error DFERR_PROGRAM "The SQL Collation name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
91039>>>>>>
91039>>>>>            Function_Return False
91040>>>>>        End
91040>>>>>>
91040>>>>>        
91040>>>>>        Get psDriverID to sDriverID
91041>>>>>        Get piDbType   to iDbType
91042>>>>>
91042>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
91043>>>>>        If (bMertechDriver = False) Begin
91045>>>>>            Get phoSQLManager to hoSQLManager
91046>>>>>        End
91046>>>>>>
91046>>>>>        Else Begin
91047>>>>>            Get _MertechSQLManagerHandle to hoSQLManager
91048>>>>>        End
91048>>>>>>
91048>>>>>        
91048>>>>>        Get psConnectionID     to sConnectionID
91049>>>>>        Get psConnectionString to sConnectionString
91050>>>>>        Move 0 to LastErr
91051>>>>>
91051>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
91052>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
91053>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
91054>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
91056>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
91057>>>>>>
91057>>>>>            Function_Return False
91058>>>>>        End
91058>>>>>>
91058>>>>>
91058>>>>>        Get SqlOpen of hConnection to hStmt
91059>>>>>
91059>>>>>        If (hStmt = 0) Begin
91061>>>>>            Send SqlDisconnect of hoSQLManager
91062>>>>>            Error DFERR_PROGRAM CS_SQLConnectError
91063>>>>>>
91063>>>>>            Function_Return False
91064>>>>>        End
91064>>>>>>
91064>>>>>        
91064>>>>>        // Check if collation already exists   
91064>>>>>        Get SqlDatabaseCollationQuery sDatabase to sSQLCollationCheck
91065>>>>>        // If the current collate is the same as the new; do nothing.
91065>>>>>        If (sSQLCollation = sSQLCollationCheck) Begin
91067>>>>>            Function_Return True
91068>>>>>        End
91068>>>>>>
91068>>>>>            
91068>>>>>        Get _SqlFindKeyWord CI_SQLSet               to sSet
91069>>>>>        Get _SqlFindKeyWord CI_SQLWith              to sWith
91070>>>>>        Get _SqlFindKeyWord CI_SQLSingle_User       to sSingle_User
91071>>>>>        Get _SqlFindKeyWord CI_SQLMulti_User        to sMulti_User
91072>>>>>        Get _SqlFindKeyWord CI_SQLRollback          to sRollback
91073>>>>>        Get _SqlFindKeyWord CI_SQLIMMEDIATE         to sImmediate
91074>>>>>        Get _SqlFindKeyWord CI_SQLAlterDatabase     to sAlterDatabaseKeyWord
91075>>>>>        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
91076>>>>>        
91076>>>>>        // MS-SQL Syntax:
91076>>>>>        // ALTER DATABASE [database] SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
91076>>>>>        // ALTER DATABASE [database] COLLATE SQL_1xCompat_CP850_CI_AS;
91076>>>>>        // ALTER DATABASE [database] SET MULTI_USER;
91076>>>>>        Move (              sAlterDatabaseKeyWord  * String(sDatabase) * String(sSet) * String(sSingle_User) * String(sWith) * String(sRollback) * String(sImmediate)) to sSQL
91077>>>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
91078>>>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sSet) * String(sMulti_User)) to sSQL
91079>>>>>//        Move (sAlterDatabaseKeyWord * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL 
91079>>>>>        
91079>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
91080>>>>>        Send SqlUtilExecuteQuery sSQL sDriverID False
91081>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
91082>>>>>        If (LastErr = CLIERR_GENERAL_ERROR) Begin
91084>>>>>           Function_Return False
91085>>>>>        End
91085>>>>>>
91085>>>>>
91085>>>>>        Function_Return (Err = False)
91086>>>>>    End_Function
91087>>>>>
91087>>>>>    // * Dummy function for the Studio's Code Explorer *
91087>>>>>    Function SQL_TABLE_FUNCTIONS Returns Boolean
91089>>>>>        Function_Return False
91090>>>>>    End_Function
91091>>>>>    // Converts from SQL to Embedded (DataFlex .dat files).
91091>>>>>    // To convert from SQL -> SQL (e.g. from Oracle - > MS SQL)
91091>>>>>    //   first use SQLTableConvertToEmbedded in one cDbUpdateVersion object,
91091>>>>>    //   and then use the ApiTableConvertToSQL method in a second cDbUpdateVersion object.
91091>>>>>    // Note: To convert an embedded table to SQL use ApiTableConvertToSQL.
91091>>>>>    Function SqlTableConvertToEmbedded Handle hTable Boolean bCpyDat Returns Boolean
91093>>>>>        Handle hToTable
91093>>>>>        Boolean bOK bExists bOpened bMertechDriver bCopyData
91093>>>>>        String sDriverID sPhysicalName sRootName sDisplayName
91093>>>>>        tSQLConnection SQLConnection
91093>>>>>        tSQLConnection SQLConnection
91093>>>>>        Integer iPos iMaxRecords
91093>>>>>
91093>>>>>        Get psDriverID to sDriverID
91094>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
91095>>>>>        If (bExists = False) Begin
91097>>>>>            Function_Return False
91098>>>>>        End
91098>>>>>>
91098>>>>>
91098>>>>>        If (num_arguments > 1) Begin
91100>>>>>            Move bCpyDat to bCopyData
91101>>>>>        End
91101>>>>>>
91101>>>>>        Else Begin
91102>>>>>            Move False to bCopyData
91103>>>>>        End
91103>>>>>>
91103>>>>>
91103>>>>>        Open hTable
91105>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
91108>>>>>        If (bOpened = False) Begin
91110>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
91111>>>>>>
91111>>>>>            Function_Return False
91112>>>>>        End
91112>>>>>>
91112>>>>>        Move 0 to hToTable
91113>>>>>
91113>>>>>        Move 16711679 to iMaxRecords
91114>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
91117>>>>>        Move (Pos(".", sDisplayName)) to iPos
91118>>>>>        If (iPos > 0) Begin
91120>>>>>            Move (Mid(sDisplayName, 200, (iPos +1))) to sDisplayName
91121>>>>>        End
91121>>>>>>
91121>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
91124>>>>>        Get _TableNameOnly sRootName                 to sRootName
91125>>>>>        Move (sRootName + ".dat")                    to sPhysicalName
91126>>>>>
91126>>>>>        If (ghoProgressBar <> 0) Begin
91128>>>>>            Send DoAdvance of ghoProgressBar
91129>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to Embedded - Table:" * String(sRootName) * "Number:" * String(hTable))
91130>>>>>        End
91130>>>>>>
91130>>>>>
91130>>>>>        Move False to Err
91131>>>>>
91131>>>>>        Structure_Start hToTable DATAFLEX_ID
91132>>>>>            Structure_Copy hTable to hToTable
91133>>>>>
91133>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
91136>>>>>            Set_Attribute DF_FILE_REUSE_DELETED of hToTable to DF_FILE_DELETED_REUSE
91139>>>>>            Set_Attribute DF_FILE_MULTIUSER     of hToTable to DF_FILE_USER_MULTI
91142>>>>>            Set_Attribute DF_FILE_TRANSACTION   of hToTable to DF_FILE_TRANSACTION_CLIENT_ATOMIC
91145>>>>>            Set_Attribute DF_FILE_MAX_RECORDS   of hToTable to iMaxRecords
91148>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
91149>>>>>
91149>>>>>        Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
91151>>>>>
91151>>>>>        Set Action_Text of ghoStatusPanel to ""
91152>>>>>        Move (not(Err)) to bOK
91153>>>>>        If (bOK = True and bCopyData = True) Begin
91155>>>>>            Get ApiTableCopyData hTable sPhysicalName sRootName DATAFLEX_ID to bOK
91156>>>>>        End
91156>>>>>>
91156>>>>>
91156>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
91157>>>>>        If (bMertechDriver = True) Begin
91159>>>>>            Open hTable
91161>>>>>        End
91161>>>>>>
91161>>>>>
91161>>>>>        // This must be after copying data...
91161>>>>>        If (Err = False) Begin
91163>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
91166>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
91169>>>>>        End
91169>>>>>>
91169>>>>>        Move (not(Err)) to bOK
91170>>>>>
91170>>>>>        Function_Return (bOK = True)
91171>>>>>    End_Function
91172>>>>>
91172>>>>>    // Creates an SQL Table at the SQL end by its filelist number;
91172>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
91172>>>>>    Function SqlTableCreate Integer hTable Returns Boolean
91174>>>>>        String sTableName sSQLString sPath sCreateTable sDriverID
91174>>>>>        Integer iDbType
91174>>>>>        Boolean bExists
91174>>>>>
91174>>>>>        Get psDriverID to sDriverID
91175>>>>>        Get UtilTableHandleToString hTable to sTableName
91176>>>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
91177>>>>>        If (bExists = True) Begin
91179>>>>>            Function_Return False
91180>>>>>        End
91180>>>>>>
91180>>>>>
91180>>>>>        Get psDataPathFirstPart to sPath
91181>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
91182>>>>>
91182>>>>>        Get piDbType to iDbType
91183>>>>>        Get _SqlProperTableName sTableName to sTableName
91184>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
91185>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
91186>>>>>
91186>>>>>        Move False to Err
91187>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
91188>>>>>
91188>>>>>        Function_Return (Err = False)
91189>>>>>    End_Function
91190>>>>>
91190>>>>>    // Same as SqlTableCreate but creates an SQL Table at the SQL end by a table name;
91190>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
91190>>>>>    Function SqlTableCreateByTableName String sTableName  Returns Boolean
91192>>>>>        String sSQLString sPath sCreateTable sDriverID
91192>>>>>        Integer iDbType
91192>>>>>        Boolean bExists
91192>>>>>
91192>>>>>        Get psDriverID to sDriverID
91193>>>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
91194>>>>>        If (bExists = True) Begin
91196>>>>>            Function_Return False
91197>>>>>        End
91197>>>>>>
91197>>>>>
91197>>>>>        Get psDataPathFirstPart to sPath
91198>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
91199>>>>>        If (bExists = True) Begin
91201>>>>>            // ToDo: What should we do if an .int file already exists?
91201>>>>>        End
91201>>>>>>
91201>>>>>
91201>>>>>        Get piDbType to iDbType
91202>>>>>        Get _SqlProperTableName sTableName to sTableName
91203>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
91204>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
91205>>>>>
91205>>>>>        Move False to Err
91206>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
91207>>>>>
91207>>>>>        Function_Return (Err = False)
91208>>>>>    End_Function
91209>>>>>
91209>>>>>    // First deletes the data cache file and then drops the passed SQL table.
91209>>>>>    // Note: The table needs to exist in filelist.cfg, and it must be possible to open it,
91209>>>>>    //       else try using the SqlTableRemoveByTableName message.
91209>>>>>    Function SqlTableRemove Integer hTable Returns Boolean
91211>>>>>        String sSQLString sPath sDropTable sTableName sDriverID
91211>>>>>        Integer iRetval iDbType
91211>>>>>        Boolean bExists bMertechDriver bOK
91211>>>>>
91211>>>>>        Get psDriverID to sDriverID
91212>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
91213>>>>>        Get UtilTableHandleToString hTable to sTableName
91214>>>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
91215>>>>>        If (bExists = False) Begin
91217>>>>>            Function_Return False
91218>>>>>        End
91218>>>>>>
91218>>>>>
91218>>>>>        Get psDataPathFirstPart to sPath
91219>>>>>        Get UtilDeleteCacheFile sTableName to iRetval
91220>>>>>
91220>>>>>        Get piDbType to iDbType
91221>>>>>        Get _SqlProperTableName sTableName to sTableName
91222>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
91223>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
91224>>>>>
91224>>>>>        Move False to Err
91225>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
91226>>>>>
91226>>>>>        // We also need to remove the cache-file since the table has been changed
91226>>>>>        Get UtilDeleteCacheFile sTableName to bOK
91227>>>>>
91227>>>>>        Function_Return (Err = False)
91228>>>>>    End_Function
91229>>>>>
91229>>>>>    // First deletes the data cache file and then drops the passed data table.
91229>>>>>    Function SqlTableRemoveByTableName String sTableName Returns Boolean
91231>>>>>        String sSQLString sPath sDropTable sVal sSchema sDriverID
91231>>>>>        Integer iRetval iDbType
91231>>>>>        Boolean bMertechDriver bOK
91231>>>>>
91231>>>>>        Get psDriverID to sDriverID
91232>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
91233>>>>>        Get psDataPathFirstPart to sPath
91234>>>>>        Get UtilDeleteCacheFile sTableName to iRetval
91235>>>>>
91235>>>>>        Get piDbType to iDbType
91236>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
91237>>>>>        Get psSchema to sSchema
91238>>>>>        If (sSchema = "") Begin
91240>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
91241>>>>>        End
91241>>>>>>
91241>>>>>        Move (Uppercase(sTableName)) to sVal
91242>>>>>        If (not(sVal contains (sSchema + "."))) Begin
91244>>>>>            Move (Lowercase(sSchema) + "." + sTableName) to sTableName
91245>>>>>        End
91245>>>>>>
91245>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
91246>>>>>
91246>>>>>        Move False to Err
91247>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
91248>>>>>
91248>>>>>        // We also need to remove the cache-file since the table has been changed
91248>>>>>        Get UtilDeleteCacheFile sTableName to bOK
91249>>>>>
91249>>>>>        Function_Return (Err = False)
91250>>>>>    End_Function
91251>>>>>
91251>>>>>    // *** Sql View Messages ***
91251>>>>>
91251>>>>>    // First deletes the data cache file and then drops the passed Sql data view.
91251>>>>>    Function SqlViewRemove String sDataView Returns Boolean
91253>>>>>        String sDriverID sSQLString sDropViewKeyWord
91253>>>>>        Integer iRetval
91253>>>>>        Boolean bMertechDriver bOK
91253>>>>>
91253>>>>>        Get psDriverID to sDriverID
91254>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
91255>>>>>        Get UtilDeleteCacheFile sDataView to iRetval
91256>>>>>
91256>>>>>        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
91257>>>>>        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
91258>>>>>        Set psSQLStatementString to sSQLString
91259>>>>>
91259>>>>>        // As we don't check if the view exist or not, it might happen
91259>>>>>        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
91259>>>>>        Move False to Err
91260>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91261>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
91262>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91263>>>>>        Move 0 to LastErr
91264>>>>>
91264>>>>>        // We also need to remove the cache-file since the table has been changed
91264>>>>>        Get UtilDeleteCacheFile sDataView to bOK
91265>>>>>
91265>>>>>        Function_Return (Err = False)
91266>>>>>    End_Function
91267>>>>>
91267>>>>>    Function SqlTableRename Handle hTable String sCurrentTableName String sNewtTableName Returns Boolean
91269>>>>>        Boolean bOK
91269>>>>>        Integer iDbType
91269>>>>>        String sDriverID sAlterTable sRenameTable sSQLTo sSQLString
91269>>>>>
91269>>>>>        Get psDriverID to sDriverID
91270>>>>>        Get piDbType   to iDbType
91271>>>>>
91271>>>>>        Case Begin
91271>>>>>            Case (iDbType = EN_DbTypeDB2)
91273>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
91274>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
91275>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * sNewtTableName) to sSQLString
91276>>>>>            Break
91277>>>>>
91277>>>>>            Case (iDbType = EN_DbTypeMSSQL)
91280>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
91281>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
91282>>>>>                Move (sRenameTable * "'" - sCurrentTableName - "', '" - sNewtTableName - "'") to sSQLString
91283>>>>>            Break
91284>>>>>
91284>>>>>            Case (iDbType = EN_DbTypeOracle)
91287>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
91288>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
91289>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * sNewtTableName) to sSQLString
91290>>>>>            Break
91291>>>>>
91291>>>>>            Case (iDbType = EN_DbTypePostgre)
91294>>>>>                Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
91295>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
91296>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
91297>>>>>                Move (sAlterTable * sCurrentTableName * sRenameTable * sSQLTo * sNewtTableName) to sSQLString
91298>>>>>            Break
91299>>>>>
91299>>>>>            Case (iDbType = EN_DbTypeMySQL)
91302>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
91303>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
91304>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * sNewtTableName) to sSQLString
91305>>>>>            Break
91306>>>>>        Case End
91306>>>>>
91306>>>>>        Move False to Err
91307>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
91308>>>>>        Move (Err = False) to bOK
91309>>>>>
91309>>>>>        Function_Return bOK
91310>>>>>    End_Function
91311>>>>>
91311>>>>>    // * Dummy function for the Studio's Code Explorer *
91311>>>>>    Function SQL_COLUMN_FUNCTIONS Returns Boolean
91313>>>>>        Function_Return False
91314>>>>>    End_Function
91315>>>>>
91315>>>>>    // Sample: Get SqlColumnAdd MyTable.File_Number "NewColumnName" True "InitValue" DF_ASCII_DUF 35
91315>>>>>    Function SqlColumnAdd Integer hTable String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
91317>>>>>        Integer iLength iDecimals
91317>>>>>        String sColumnValue
91317>>>>>        String sTableName sDriverID
91317>>>>>        Boolean bOK bInitializeValue
91317>>>>>
91317>>>>>        Get psDriverID to sDriverID
91318>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
91319>>>>>        If (bOK = False) Begin
91321>>>>>            Function_Return False
91322>>>>>        End
91322>>>>>>
91322>>>>>
91322>>>>>        Get UtilTableHandleToString hTable to sTableName
91323>>>>>        If (sTableName = "") Begin
91325>>>>>            Function_Return False
91326>>>>>        End
91326>>>>>>
91326>>>>>
91326>>>>>        If (num_arguments > 3) Begin
91328>>>>>            Move iLen     to iLength
91329>>>>>            Move iDec     to iDecimals
91330>>>>>            Move bInitVal to bInitializeValue
91331>>>>>            Move sColVal  to sColumnValue
91332>>>>>        End
91332>>>>>>
91332>>>>>
91332>>>>>        Get SqlColumnAddByTableName sTableName sColumnName iDataType iLen iDecimals bInitializeValue sColumnValue to bOK
91333>>>>>
91333>>>>>        Function_Return (bOK = True)
91334>>>>>    End_Function
91335>>>>>
91335>>>>>    // Sample: Get SqlColumnAddByTableName "MyTable" "NewColumnName" DF_ASCII_DUF 35 0 True "InitValue"
91335>>>>>    Function SqlColumnAddByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
91337>>>>>        Integer iDbType iLength iDecimals iDriver
91337>>>>>        String sStmt sAlterTable sAddColumn sVal sDataType sLengthAndDecimals sColumnValue
91337>>>>>        String sDriverID sNotNull
91337>>>>>        Boolean bOK bInitializeValue bRetval bFixed bDriverIgnoreErrorState
91337>>>>>        Handle hTable
91337>>>>>
91337>>>>>        Get psDriverID to sDriverID
91338>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
91339>>>>>        If (bOK = False) Begin
91341>>>>>            Function_Return False
91342>>>>>        End
91342>>>>>>
91342>>>>>
91342>>>>>        Get UtilTableNameToHandle sTableName to hTable
91343>>>>>        If (hTable = 0) Begin
91345>>>>>            Get NextFreeFilelistSlot to hTable
91346>>>>>        End
91346>>>>>>
91346>>>>>
91346>>>>>        Get piDbType to iDbType
91347>>>>>        // If a field/column already exists; we just ignore the request to not add unneccesary errors to the log.
91347>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
91348>>>>>        If (Uppercase(sVal) = Uppercase(sColumnName)) Begin
91350>>>>>            Function_Return False
91351>>>>>        End
91351>>>>>>
91351>>>>>
91351>>>>>        Get DriverIndex sDriverID to iDriver
91352>>>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
91355>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
91358>>>>>
91358>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
91359>>>>>        If (num_arguments > 3) Begin
91361>>>>>            Move iLen     to iLength
91362>>>>>            Move iDec     to iDecimals
91363>>>>>            Move bInitVal to bInitializeValue
91364>>>>>            Move sColVal  to sColumnValue
91365>>>>>        End
91365>>>>>>
91365>>>>>
91365>>>>>        Get _SqlProperTableName sTableName   to sTableName
91366>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
91367>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
91368>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
91369>>>>>
91369>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
91370>>>>>        If (bFixed = False) Begin
91372>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
91373>>>>>        End
91373>>>>>>
91373>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
91374>>>>>
91374>>>>>        Move False to Err
91375>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
91376>>>>>
91376>>>>>        If (bInitializeValue = True and Err = False) Begin
91378>>>>>            Get SQLColumnUpdateValue hTable sColumnName sColumnValue to bRetval
91379>>>>>        End
91379>>>>>>
91379>>>>>
91379>>>>>        If (Err = False) Begin
91381>>>>>            Get SqlUtilAdjustAuxFiles hTable sTableName sColumnName to bOK
91382>>>>>        End
91382>>>>>>
91382>>>>>
91382>>>>>        Move (not(Err)) to bRetval
91383>>>>>
91383>>>>>        // We also need to remove the cache-file since the table has been changed
91383>>>>>        Get UtilDeleteCacheFile sTableName to bOK
91384>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
91387>>>>>
91387>>>>>        Function_Return bRetval
91388>>>>>    End_Function
91389>>>>>
91389>>>>>    // To update all current rows for a table column with a common value.
91389>>>>>    Function SqlColumnUpdateValue Handle hTable String sColumnName String sColumnValue Returns Boolean
91391>>>>>        String sDriverID sTableName sUpdate sSet sNoCountOn sStmt
91391>>>>>        Boolean bRetval bSQLDriver
91391>>>>>        Integer iCurrErr
91391>>>>>
91391>>>>>        Move False to bRetval
91392>>>>>        Get psDriverID to sDriverID
91393>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
91394>>>>>        If (bSQLDriver = False) Begin
91396>>>>>            Function_Return bRetval
91397>>>>>        End
91397>>>>>>
91397>>>>>        Get UtilTableHandleToString hTable to sTableName
91398>>>>>
91398>>>>>        Move Err to iCurrErr
91399>>>>>        Move False to Err
91400>>>>>        Get _SqlFindKeyWord CI_SQLUpdate       to sUpdate
91401>>>>>        Get _SqlFindKeyWord CI_SQLSet          to sSet
91402>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountOn
91403>>>>>        Move (sNoCountOn * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
91404>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
91405>>>>>        Move (Err = False) to bRetval
91406>>>>>        Move iCurrErr to Err
91407>>>>>
91407>>>>>        Function_Return bRetval
91408>>>>>    End_Function
91409>>>>>
91409>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
91409>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
91409>>>>>    Function SqlColumnChange Handle hTable String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
91411>>>>>        String sDriverID sTableName
91411>>>>>        Boolean bOK
91411>>>>>
91411>>>>>        Get psDriverID to sDriverID
91412>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
91413>>>>>        If (bOK = False) Begin
91415>>>>>            Function_Return False
91416>>>>>        End
91416>>>>>>
91416>>>>>
91416>>>>>        Get UtilTableHandleToString hTable to sTableName
91417>>>>>        Get SqlColumnChangeByTableName sTableName sColumnName iDataType iLen iDec to bOK
91418>>>>>
91418>>>>>        Function_Return (Err = False)
91419>>>>>    End_Function
91420>>>>>
91420>>>>>    // Same as SqlColumnChange but instead of passing a filelist number; pass the table name as a string.
91420>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
91420>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
91420>>>>>    Function SqlColumnChangeByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
91422>>>>>        Integer iDbType iLength iDecimals
91422>>>>>        String sDriverID sStmt sAlterTable sAlterColumn sDataType sLengthAndDecimals sNotNull
91422>>>>>        Boolean bExists bOK bFixed
91422>>>>>        Handle hTable
91422>>>>>
91422>>>>>        Get psDriverID to sDriverID
91423>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
91424>>>>>        If (bOK = False) Begin
91426>>>>>            Function_Return False
91427>>>>>        End
91427>>>>>>
91427>>>>>
91427>>>>>        Get UtilTableNameToHandle sTableName to hTable
91428>>>>>        If (hTable = 0) Begin
91430>>>>>            Get NextFreeFilelistSlot to hTable
91431>>>>>        End
91431>>>>>>
91431>>>>>        Get SQLUtilColumnExists sTableName sColumnName to bExists
91432>>>>>        If (bExists = True) Begin
91434>>>>>            Function_Return False
91435>>>>>        End
91435>>>>>>
91435>>>>>
91435>>>>>        If (num_arguments > 3) Begin
91437>>>>>            Move iLen to iLength
91438>>>>>        End
91438>>>>>>
91438>>>>>        If (num_arguments > 4) Begin
91440>>>>>            Move iDec to iDecimals
91441>>>>>        End
91441>>>>>>
91441>>>>>
91441>>>>>        Get piDbType to iDbType
91442>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
91443>>>>>
91443>>>>>        Move False to Err
91444>>>>>        Get _SqlProperTableName sTableName    to sTableName
91445>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
91446>>>>>        Get _SqlFindKeyWord CI_SQLAlterColumn to sAlterColumn
91447>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
91448>>>>>
91448>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
91449>>>>>        If (bFixed = False) Begin
91451>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
91452>>>>>        End
91452>>>>>>
91452>>>>>
91452>>>>>        Move (sAlterTable * sTableName * sAlterColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
91453>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
91454>>>>>
91454>>>>>        // We also need to remove the cache-file since the table has been changed
91454>>>>>        Get UtilDeleteCacheFile sTableName to bOK
91455>>>>>
91455>>>>>        Function_Return (Err = False)
91456>>>>>    End_Function
91457>>>>>
91457>>>>>    Function SqlColumnDefaultValue Handle hTable Integer iColumn String sValue Returns Boolean
91459>>>>>        Boolean bOK bErr bIsSQLDriver
91459>>>>>        String sDriverID  
91459>>>>>        Integer iDataType
91459>>>>>
91459>>>>>        Get psDriverID to sDriverID
91460>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
91461>>>>>        If (bIsSQLDriver = False) Begin
91463>>>>>            Function_Return False
91464>>>>>        End
91464>>>>>>
91464>>>>>
91464>>>>>        Move Err to bErr
91465>>>>>        Move False to bErr
91466>>>>>
91466>>>>>        // There seems to be a problem with the ODBC_DRV driver that sometimes
91466>>>>>        // inserts randomly character(10) and spaces, so we correct from that here:
91466>>>>>        Move (Replaces(Character(10), Trim(sValue), "")) to sValue
91467>>>>>        Get_Attribute DF_FIELD_TYPE of hTable iColumn to iDataType 
91470>>>>>        If (iDataType = DF_BCD and Left(sValue, 1 <> "[")) Begin
91472>>>>>            Move ("[" + String(sValue) + "]") to sValue
91473>>>>>        End
91473>>>>>>
91473>>>>>        
91473>>>>>        Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sValue
91476>>>>>        Move (not(Err)) to bOK
91477>>>>>        Move bErr to Err
91478>>>>>
91478>>>>>        Function_Return bOK
91479>>>>>    End_Function
91480>>>>>
91480>>>>>    Function SqlColumnNullable Handle hTable Integer iColumn Boolean bNullable Returns Boolean
91482>>>>>        Boolean bOK bErr bCurrentState bOpen bIsSQLDriver
91482>>>>>        String sDriverID
91482>>>>>
91482>>>>>        Get psDriverID to sDriverID
91483>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
91484>>>>>        If (bIsSQLDriver = False) Begin
91486>>>>>            Function_Return False
91487>>>>>        End
91487>>>>>>
91487>>>>>
91487>>>>>        Move Err to bErr
91488>>>>>        Move False to bErr
91489>>>>>        Get_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bCurrentState
91492>>>>>        If (bNullable = bCurrentState) Begin
91494>>>>>            Function_Return True
91495>>>>>        End
91495>>>>>>
91495>>>>>
91495>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
91498>>>>>        If (bOpen = False) Begin
91500>>>>>            Get AutoConnectionIDLogin to bOK
91501>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91502>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
91503>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
91504>>>>>            Open hTable
91506>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91507>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
91508>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
91509>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
91512>>>>>        End
91512>>>>>>
91512>>>>>        If (bOpen = True) Begin
91514>>>>>            Structure_Start hTable sDriverID
91515>>>>>                Set_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bNullable
91518>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
91519>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
91521>>>>>            Set Action_Text of ghoStatusPanel to ""
91522>>>>>        End
91522>>>>>>
91522>>>>>
91522>>>>>        Move (not(Err)) to bOK
91523>>>>>        Move bErr to Err
91524>>>>>
91524>>>>>        Function_Return bOK
91525>>>>>    End_Function
91526>>>>>
91526>>>>>    // Drop column by its table handle
91526>>>>>    Function SqlColumnRemove Handle hTable String sColumnName Returns Boolean
91528>>>>>        String sDriverID sTableName
91528>>>>>        Boolean bOK
91528>>>>>
91528>>>>>        Get psDriverID to sDriverID
91529>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
91530>>>>>        If (bOK = False) Begin
91532>>>>>            Function_Return False
91533>>>>>        End
91533>>>>>>
91533>>>>>
91533>>>>>        Get UtilTableHandleToString hTable to sTableName
91534>>>>>        If (sTableName = "") Begin
91536>>>>>            Function_Return False
91537>>>>>        End
91537>>>>>>
91537>>>>>
91537>>>>>        Get SqlColumnRemoveByTableName sTableName sColumnName to bOK
91538>>>>>
91538>>>>>        Function_Return (bOK = True)
91539>>>>>    End_Function
91540>>>>>
91540>>>>>    // Drop column by its table name as a string.
91540>>>>>    Function SqlColumnRemoveByTableName String sTableName String sColumnName Returns Boolean
91542>>>>>        Integer iDbType iDriver
91542>>>>>        String sDriverID sStmt sAlterTable sDropColumn
91542>>>>>        Boolean bExists bOK bRetval bDriverIgnoreErrorState
91542>>>>>        Handle hTable
91542>>>>>
91542>>>>>        Get psDriverID to sDriverID
91543>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
91544>>>>>        If (bOK = False) Begin
91546>>>>>            Function_Return False
91547>>>>>        End
91547>>>>>>
91547>>>>>
91547>>>>>        Get DriverIndex sDriverID to iDriver
91548>>>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
91551>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
91554>>>>>
91554>>>>>        Get UtilTableNameToHandle sTableName to hTable
91555>>>>>        If (hTable <> 0) Begin
91557>>>>>            Get SQLUtilColumnExists sTableName sColumnName to bExists
91558>>>>>            If (bExists = False) Begin
91560>>>>>                Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
91563>>>>>                Function_Return False
91564>>>>>            End
91564>>>>>>
91564>>>>>        End
91564>>>>>>
91564>>>>>
91564>>>>>        Get piDbType to iDbType
91565>>>>>        If (iDbType = EN_DbTypeMSSQL) Begin
91567>>>>>            Get _SqlUtilRemoveTableColumnMSSQL sTableName sColumnName to bOK
91568>>>>>            Get UtilDeleteCacheFile sTableName to bOK
91569>>>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
91572>>>>>            Function_Return bOK
91573>>>>>        End
91573>>>>>>
91573>>>>>
91573>>>>>        Move False to Err
91574>>>>>        Get _SqlProperTableName sTableName    to sTableName
91575>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
91576>>>>>        Get _SqlFindKeyWord CI_SQLDropColumn  to sDropColumn
91577>>>>>
91577>>>>>        Move (sAlterTable * sTableName * sDropColumn * sColumnName) to sStmt
91578>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
91579>>>>>        Move (not(Err)) to bRetval
91580>>>>>
91580>>>>>        // We also need to remove the cache-file since the table has been changed
91580>>>>>        Get UtilDeleteCacheFile sTableName to bOK
91581>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
91584>>>>>
91584>>>>>        Function_Return bRetval
91585>>>>>    End_Function
91586>>>>>
91586>>>>>    // Rename a field/column by table handle (filelist number)
91586>>>>>    Function SqlColumnRename Integer hTable String sColumnName String sNewColumnName Returns Boolean
91588>>>>>        String sDriverID sTableName
91588>>>>>        Boolean bOK
91588>>>>>
91588>>>>>        Get psDriverID to sDriverID
91589>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
91590>>>>>        If (bOK = False) Begin
91592>>>>>            Function_Return False
91593>>>>>        End
91593>>>>>>
91593>>>>>
91593>>>>>        Get UtilTableHandleToString hTable to sTableName
91594>>>>>        Get SqlColumnRenameByTableName sTableName sColumnName sNewColumnName to bOK
91595>>>>>
91595>>>>>        Function_Return (Err = False)
91596>>>>>    End_Function
91597>>>>>
91597>>>>>    // Rename a field/column by table name.
91597>>>>>    Function SqlColumnRenameByTableName String sTableName String sColumnName String sNewColumnName Returns Boolean
91599>>>>>        Integer iDbType iDataType
91599>>>>>        String sDriverID sStmt sAlterTable sRenameColumn sVal sColumnKeyWord sOrgTableName sDatabase sDataType
91599>>>>>        Boolean bOK bRetval
91599>>>>>        Handle hTable
91599>>>>>
91599>>>>>        Move sTableName to sOrgTableName
91600>>>>>        Get psDriverID to sDriverID
91601>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
91602>>>>>        If (bOK = False) Begin
91604>>>>>            Function_Return False
91605>>>>>        End
91605>>>>>>
91605>>>>>
91605>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
91606>>>>>        If (sVal = "") Begin
91608>>>>>            Function_Return False
91609>>>>>        End
91609>>>>>>
91609>>>>>
91609>>>>>        Get piDbType to iDbType
91610>>>>>        Get _SqlFindKeyWord CI_SQLColumn       to sColumnKeyWord
91611>>>>>        Get _SqlProperTableName sTableName     to sTableName
91612>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable   to sAlterTable
91613>>>>>        Get _SqlFindKeyWord CI_SQLRenameColumn to sRenameColumn
91614>>>>>
91614>>>>>        Case Begin
91614>>>>>            Case (iDbType = EN_dbTypeMSSQL)
91616>>>>>                Move (sRenameColumn * "'" + sTableName + "." + sColumnName + "'," * "'" + sNewColumnName + "'," * "'" + sColumnKeyWord + "'") to sStmt
91617>>>>>                Case Break
91618>>>>>            // Alter table "SYS"."Customer" rename column "Comments" to "NewColumnName"
91618>>>>>            Case (iDbType = EN_dbTypeOracle)
91621>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
91622>>>>>                Case Break
91623>>>>>            // ALTER TABLE Schema.TableName RENAME COLUMN "deptnumb" TO "deptnum"
91623>>>>>            Case (iDbType = EN_dbTypeDB2)
91626>>>>>                Move (sAlterTable *  sTableName * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
91627>>>>>                Case Break
91628>>>>>            // ALTER TABLE "Customer" RENAME COLUMN "Comments" TO "NewColumnName"
91628>>>>>            Case (iDbType = EN_dbTypePostgre)
91631>>>>>                Move sOrgTableName to sTableName
91632>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
91633>>>>>                Case Break
91634>>>>>            Case (iDbType = EN_dbTypeMySQL)
91637>>>>>                // ALTER TABLE orderentry.customer CHANGE Comments NewColumnName text // Note: The last token is the column type!
91637>>>>>                Move sOrgTableName to sTableName
91638>>>>>                Get psDatabase to sDatabase
91639>>>>>                Get UtilTableNameToHandle sTableName to hTable
91640>>>>>                If (hTable = 0) Begin
91642>>>>>                    Get UtilTableOpen hTable sTableName DF_SHARE to bOK
91643>>>>>                    If (bOK = False) Begin
91645>>>>>                        Function_Return False
91646>>>>>                    End
91646>>>>>>
91646>>>>>                    Get NextFreeFilelistSlot to hTable
91647>>>>>                End
91647>>>>>>
91647>>>>>                Else Begin
91648>>>>>                    Open hTable
91650>>>>>                End
91650>>>>>>
91650>>>>>                Get SQLColumnType sDriverID hTable sTableName sColumnName to iDataType
91651>>>>>                Get UtilColumnTypeToString sDriverID iDbType iDataType    to sDataType
91652>>>>>                Move (sAlterTable * sDatabase + "." + sTableName * sRenameColumn * sColumnName * sNewColumnName * sDataType) to sStmt
91653>>>>>                Case Break
91654>>>>>            Case Else
91654>>>>>                Move (sAlterTable * "'" + sTableName + "'" * sRenameColumn * "'" + sTableName + "." + sColumnName + "'" * "TO" * "'" + sNewColumnName + "'") to sStmt
91655>>>>>        Case End
91655>>>>>
91655>>>>>        Move False to Err
91656>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
91657>>>>>        Move (Err = False) to bRetval
91658>>>>>        // We also need to remove the cache-file since the table has been changed
91658>>>>>        Get UtilDeleteCacheFile sTableName to bOK
91659>>>>>
91659>>>>>        Function_Return bRetval
91660>>>>>    End_Function
91661>>>>>
91661>>>>>    Function SqlColumnType String sDriverID Handle hTable String sTableName String sColumnName Returns Integer
91663>>>>>        Handle hoSQLHandler hSQLConnect hStmt
91663>>>>>        Boolean bMertechDriver
91663>>>>>        Integer iNumCols iCount iDataType
91663>>>>>        String sValue
91663>>>>>
91663>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
91664>>>>>        If (bMertechDriver = False) Begin
91666>>>>>            Get phoSQLManager to hoSQLHandler
91667>>>>>        End
91667>>>>>>
91667>>>>>        Else Begin
91668>>>>>            Get _MertechSQLManagerHandle to hoSQLHandler
91669>>>>>        End
91669>>>>>>
91669>>>>>
91669>>>>>        Get SQLFileConnect of hoSQLHandler hTable to hSQLConnect
91670>>>>>        If (hSQLConnect <> 0) Begin
91672>>>>>            Get SQLOpen of hSQLConnect to hStmt
91673>>>>>            If (hStmt <> 0) Begin
91675>>>>>                Send SQLExecDirect of hStmt ("select * from" * sTableName)
91676>>>>>
91676>>>>>                Get SQLStmtAttribute of hStmt SQLSTMTATTRIB_COLUMNCOUNT to iNumCols
91677>>>>>                For iCount from 1 to iNumCols
91683>>>>>>
91683>>>>>                    Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_LABEL to sValue
91684>>>>>                    If (Lowercase(sValue) = Lowercase(sColumnName)) Begin
91686>>>>>                        Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_SQLTYPE to iDataType
91687>>>>>                        Move iNumCols to iCount // We're out of here
91688>>>>>                    End
91688>>>>>>
91688>>>>>                Loop
91689>>>>>>
91689>>>>>
91689>>>>>                Send SQLClose of hStmt
91690>>>>>            End
91690>>>>>>
91690>>>>>            Send SQLDisconnect of hSQLConnect
91691>>>>>        End
91691>>>>>>
91691>>>>>
91691>>>>>        Function_Return iDataType
91692>>>>>    End_Function
91693>>>>>
91693>>>>>    // * Dummy function for the Studio's Code Explorer *
91693>>>>>    Function SQL_EXECUTE_FUNCTIONS Returns Boolean
91695>>>>>        Function_Return False
91696>>>>>    End_Function
91697>>>>>
91697>>>>>    Procedure SqlUtilExecuteQuery String sStmt String sDriverID Boolean bShowProgr
91699>>>>>        String sConnectionString sMessage
91699>>>>>        Handle hoSqlHandler hoSQLConnect hoStmt hoError
91699>>>>>        Integer i iMsgs iFetchResult iRowType iRows iErr iMessage iLastErr
91699>>>>>        String[] sMsg aSQLQueryMessages aSQLFetchResults
91702>>>>>        DateTime dtQueryExecStart dtQueryExecEnd dtFetchStart dtFetchEnd
91702>>>>>        TimeSpan tsQuery tsFetch
91702>>>>>        tSqlErrorArray aSqlErrorArray
91702>>>>>        tSqlErrorArray aSqlErrorArray
91702>>>>>        Boolean bOK bMertechDriver bShowProgress
91702>>>>>        tSQLConnection SQLConnection
91702>>>>>        tSQLConnection SQLConnection
91702>>>>>
91702>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
91703>>>>>        If (bOK = False) Begin
91705>>>>>            Procedure_Return
91706>>>>>        End
91706>>>>>>
91706>>>>>
91706>>>>>        If (num_arguments > 2) Begin
91708>>>>>            Move bShowProgr to bShowProgress
91709>>>>>        End
91709>>>>>>
91709>>>>>
91709>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
91710>>>>>
91710>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
91711>>>>>        If (bMertechDriver = True) Begin
91713>>>>>            Get _MertechSQLConnect sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
91714>>>>>        End
91714>>>>>>
91714>>>>>        If (bMertechDriver = False) Begin
91716>>>>>            Get phoSQLManager to hoSqlHandler
91717>>>>>            Send SqlSetConnect of hoSqlHandler sDriverID SQLConnection.sConnectionString
91718>>>>>            Get SqlConnect     of hoSqlHandler "" "" to hoSQLConnect
91719>>>>>        End
91719>>>>>>
91719>>>>>
91719>>>>>        If (hoSQLConnect <> 0) Begin
91721>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
91722>>>>>            If (hoStmt <> 0) Begin
91724>>>>>                // record starting date/time stamp
91724>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
91725>>>>>                // turn on error handling if enabled
91725>>>>>                If (pbHandleQueryErrors(Self)) Begin
91727>>>>>                    Set pbSqlError to False
91728>>>>>                    Set paSqlErrorArray to aSqlErrorArray
91729>>>>>                    Move Error_Object_Id to hoError 
91730>>>>>                    If (ghoDbUpdateHandler <> 0) Begin
91732>>>>>                        Move ghoDbUpdateHandler to Error_Object_Id
91733>>>>>                    End                                           
91733>>>>>>
91733>>>>>                    Else Begin
91734>>>>>                        Move Self to Error_Object_Id
91735>>>>>                    End
91735>>>>>>
91735>>>>>                End
91735>>>>>>
91735>>>>>
91735>>>>>                // Before we execute the statement; save it so we can display the faulty statement in the error log.
91735>>>>>                Set psSQLStatementString to sStmt 
91736>>>>>                Send Cursor_Wait of Cursor_Control
91737>>>>>                Send SqlExecDirect of hoStmt sStmt
91738>>>>>                Send Cursor_Ready of Cursor_Control
91739>>>>>
91739>>>>>                If (pbHandleQueryErrors(Self)) Begin
91741>>>>>                    Move hoError to Error_Object_Id
91742>>>>>                End
91742>>>>>>
91742>>>>>
91742>>>>>                Move 0 to iMsgs
91743>>>>>                // ToDo: There seems to be some issues with this code and Mertech drivers that makes
91743>>>>>                // the debugger crash in some cases like an error in the ESQL statement; so we exclude it for now.
91743>>>>>                If (bMertechDriver = False) Begin
91745>>>>>                    Move Err to iErr
91746>>>>>                    Move LastErr to iLastErr
91747>>>>>                    Get SqlStmtAttribute of hoStmt SQLSTMTATTRIB_NUMMESSAGES   to iMsgs
91748>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT      to iRows
91749>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
91750>>>>>                    Send _SqlColumnInfo hoStmt
91751>>>>>                    Send Ignore_Error of Error_Object_Id 12289
91752>>>>>                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91753>>>>>                    Repeat
91753>>>>>>
91753>>>>>                        Get SqlFetch of hoStmt to iFetchResult
91754>>>>>                        If (iFetchResult <> 0) Begin
91756>>>>>                            Get SQLColumnValue of hoStmt 1 to aSQLFetchResults[SizeOfArray(aSQLFetchResults)]
91757>>>>>                        End
91757>>>>>>
91757>>>>>                    Until (iFetchResult = 0)
91759>>>>>                    Send Trap_Error of Error_Object_Id 12289
91760>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
91761>>>>>                    Move iErr to Err
91762>>>>>                    Move iLastErr to LastErr
91763>>>>>                    Set paSQLFetchResults to aSQLFetchResults
91764>>>>>                End
91764>>>>>>
91764>>>>>
91764>>>>>                Set piRows    to iRows
91765>>>>>                Set piRowType to iRowType
91766>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
91767>>>>>                Move (CurrentDateTime()) to dtFetchStart
91768>>>>>
91768>>>>>                If (iMsgs <> 0) Begin
91770>>>>>                    If (ghoDbUpdateHandler > 0) Begin
91772>>>>>                        Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
91773>>>>>                    End
91773>>>>>>
91773>>>>>                    For i from 1 to iMsgs
91779>>>>>>
91779>>>>>                        Get SqlGetMessage of hoStmt i to sMessage
91780>>>>>                        Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
91781>>>>>                        If (bShowProgress = True) Begin
91783>>>>>                            If (Active_State(ghoStatusPanel)) Begin
91785>>>>>                                Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
91786>>>>>                            End
91786>>>>>>
91786>>>>>                            Else Begin
91787>>>>>                                Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
91789>>>>>                            End
91789>>>>>>
91789>>>>>                        End
91789>>>>>>
91789>>>>>                        Move sMessage to sMsg[SizeOfArray(sMsg)]
91790>>>>>                        Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
91791>>>>>                    Loop
91792>>>>>>
91792>>>>>                    If (ghoDbUpdateHandler > 0) Begin
91794>>>>>                        Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
91795>>>>>                    End
91795>>>>>>
91795>>>>>                    Set paQueryMessages to sMsg
91796>>>>>                End 
91796>>>>>>
91796>>>>>                Else Begin
91797>>>>>                    If (bShowProgress = True) Begin
91799>>>>>                        Get paSqlErrorArray to aSqlErrorArray
91800>>>>>                        If (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) Begin
91802>>>>>                            Move (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) to iMsgs
91803>>>>>                            Decrement iMsgs
91804>>>>>                            For i from 0 to iMsgs
91810>>>>>>
91810>>>>>                                Showln "Embedded SQL Statement: " aSqlErrorArray.sSqlStatementArray[i]
91813>>>>>                                Showln "SQL Error Message     : " aSqlErrorArray.sSqlErrorArray[i]
91816>>>>>                            Loop
91817>>>>>>
91817>>>>>                        End
91817>>>>>>
91817>>>>>                    End
91817>>>>>>
91817>>>>>                End
91817>>>>>>
91817>>>>>                Move (CurrentDateTime()) to dtFetchEnd
91818>>>>>            End
91818>>>>>>
91818>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
91819>>>>>            Move (dtFetchStart - dtFetchEnd) to tsFetch
91820>>>>>            Set ptsQueryExec to tsQuery
91821>>>>>            Set ptsFetchResults to tsFetch
91822>>>>>            Send SqlClose of hoStmt
91823>>>>>        End
91823>>>>>>
91823>>>>>
91823>>>>>        Send SqlDisconnect of hoSQLConnect
91824>>>>>    End_Procedure
91825>>>>>
91825>>>>>    // *** Main message for executing an SQL script that has been compiled into the program as a resource ***
91825>>>>>    // Use the SQLIncludeScriptFile command to include an SQL script into the program.
91825>>>>>    // Returns False if no error occured.
91825>>>>>    Function SqlUtilExecuteResource String sMemFileName String sDriverID Boolean bCreateScriptFile Boolean bShowProgr Returns Boolean
91827>>>>>        Boolean bOK bShowProgress
91827>>>>>        tSQLScriptArray SQLScriptArray
91827>>>>>        tSQLScriptArray SQLScriptArray
91827>>>>>        DateTime dtTotalQueryStart dtTotalQueryEnd
91827>>>>>        TimeSpan tsTotalTime
91827>>>>>
91827>>>>>        Move (CurrentDateTime()) to dtTotalQueryStart
91828>>>>>        Get SqlUtilReadResource sMemFileName to SQLScriptArray
91829>>>>>        If (SQLScriptArray.bError = True) Begin
91831>>>>>            Function_Return False
91832>>>>>        End
91832>>>>>>
91832>>>>>
91832>>>>>        If (num_arguments > 3) Begin
91834>>>>>            Move bShowProgr to bShowProgress
91835>>>>>        End
91835>>>>>>
91835>>>>>
91835>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91836>>>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID bCreateScriptFile sMemFileName bShowProgress to bOK
91837>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91838>>>>>
91838>>>>>        If (SQLScriptArray.bArgumentSizeChanged = True) Begin
91840>>>>>            Set_Argument_Size SQLScriptArray.iOrgArgumentSize
91841>>>>>>
91841>>>>>        End
91841>>>>>>
91841>>>>>
91841>>>>>        Move (CurrentDateTime()) to dtTotalQueryEnd
91842>>>>>        Move (dtTotalQueryEnd - dtTotalQueryStart) to tsTotalTime
91843>>>>>        Set ptsTotalQueryTime to tsTotalTime
91844>>>>>
91844>>>>>        Function_Return bOK
91845>>>>>    End_Procedure
91846>>>>>
91846>>>>>    // Reads a SQL script file that has been compiled into the .exe program as a resource.
91846>>>>>    // Pass: The memory resource reference and a boolean True if you want to create the file on disk (in the Home folder).
91846>>>>>    // Returns: A tSQLScriptArray Struct with the Sql script as an uChar Array will be returned along with the a bError boolean.
91846>>>>>    Function SqlUtilReadResource String sMemFileName Returns tSQLScriptArray
91848>>>>>        Integer iChannel iArgumentSize iCount
91848>>>>>        Number nByteCount
91848>>>>>        String sSQLScript
91848>>>>>        tSQLScriptArray SqlScriptArray
91848>>>>>        tSQLScriptArray SqlScriptArray
91848>>>>>        UChar[] uCharData
91849>>>>>
91849>>>>>        Move False to Err
91850>>>>>        Get Seq_New_Channel to iChannel
91851>>>>>        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
91853>>>>>            Error DFERR_PROGRAM 'No channel available...'
91854>>>>>>
91854>>>>>            Move True to SqlScriptArray.bError
91855>>>>>            Function_Return SqlScriptArray
91856>>>>>        End
91856>>>>>>
91856>>>>>
91856>>>>>        // First decide the size of the script
91856>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
91858>>>>>        Read_Block channel iChannel uCharData -1 // -1 means that all data should be read.
91860>>>>>        Close_Input channel iChannel
91862>>>>>
91862>>>>>        Move (SizeOfArray(uCharData)) to nByteCount
91863>>>>>        If (nByteCount  < 1) Begin
91865>>>>>            Send Seq_Release_Channel iChannel
91866>>>>>            Move True to SqlScriptArray.bError
91867>>>>>            Function_Return SqlScriptArray
91868>>>>>        End
91868>>>>>>
91868>>>>>
91868>>>>>        // If necessary change the string argument_size
91868>>>>>        Get_Argument_Size to iArgumentSize
91869>>>>>        If (nByteCount >= iArgumentSize) Begin
91871>>>>>            Move (nByteCount + 2048) to nByteCount
91872>>>>>            Set_Argument_Size nByteCount // Set new argument size just a bit higher than "needed" for overhead margin.
91873>>>>>>
91873>>>>>            Move True          to SqlScriptArray.bArgumentSizeChanged
91874>>>>>            Move iArgumentSize to SqlScriptArray.iOrgArgumentSize
91875>>>>>        End
91875>>>>>>
91875>>>>>        Else Begin
91876>>>>>            Move False to SqlScriptArray.bArgumentSizeChanged
91877>>>>>        End
91877>>>>>>
91877>>>>>
91877>>>>>        // Read the script file from memory line-by-line
91877>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
91879>>>>>            Move 0 to iCount
91880>>>>>            Repeat
91880>>>>>>
91880>>>>>                Readln channel iChannel sSQLScript
91882>>>>>                Move sSQLScript to SqlScriptArray.sSQLScriptArray[iCount]
91883>>>>>                Increment iCount
91884>>>>>            Until (SeqEof = True)
91886>>>>>        Close_Input channel iChannel
91888>>>>>        Send Seq_Release_Channel iChannel
91889>>>>>
91889>>>>>        // Finally "sanitize" the script by removing all comments.
91889>>>>>        Get _SqlUtilSanitizeScript SqlScriptArray to SqlScriptArray
91890>>>>>
91890>>>>>        Function_Return SqlScriptArray
91891>>>>>    End_Function
91892>>>>>
91892>>>>>    Function SqlUtilExecuteEmbeddedScript tSQLScriptArray SQLScriptArray String sDriverID Boolean bCreateScriptFile String sMemFileName Boolean bShowProgr Returns Boolean
91894>>>>>        String sSQLVal sStmt sCR sGOKeyWord sNoCountKeyWord sMessage sExportFile
91894>>>>>        Handle hoSql hoSQLConnect hoStmt hoError
91894>>>>>        Integer i iMsgs iRows iRowType iCount iChunkCounter iChunkMax iOut iNextSet iMessage
91894>>>>>        String[] sMsg aSQLQueryMessages
91896>>>>>        DateTime dtQueryExecStart dtQueryExecEnd
91896>>>>>        TimeSpan tsQuery
91896>>>>>        tSqlErrorArray aSqlErrorArray
91896>>>>>        tSqlErrorArray aSqlErrorArray
91896>>>>>        tSQLConnection SQLConnection
91896>>>>>        tSQLConnection SQLConnection
91896>>>>>        Boolean bMertechDriver bShowProgress
91896>>>>>
91896>>>>>        If (num_arguments > 4) Begin
91898>>>>>            Move bShowProgr to bShowProgress
91899>>>>>        End
91899>>>>>>
91899>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
91900>>>>>        If (bMertechDriver = False) Begin
91902>>>>>            Get phoSQLManager to hoSql
91903>>>>>        End
91903>>>>>>
91903>>>>>        Else Begin
91904>>>>>            Get _MertechSQLManagerHandle to hoSql
91905>>>>>        End
91905>>>>>>
91905>>>>>
91905>>>>>        Get _SqlFindKeyWord CI_SQLGO to sGOKeyWord
91906>>>>>        // There seems to be a problem to pass strings when their value gets really big, aka
91906>>>>>        // above the argument_size level. It isn't clear when these problems starts but sooner
91906>>>>>        // or later SqlExecDirect stops working correctly with no error messages!
91906>>>>>        // To guard from this we set a max number of lines (iChunkMax) that can be processed
91906>>>>>        // at a time. Testing with the Create Chinook Database script; 500 seems like a number that works fine.
91906>>>>>        // A bonus of this is that it turns out that it is actually faster to run in chunks!
91906>>>>>        Get piChunkMax to iChunkMax
91907>>>>>        Move 0 to iChunkCounter
91908>>>>>        Move "" to sStmt
91909>>>>>
91909>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
91910>>>>>        Move (Character(13) + Character(10)) to sCR
91911>>>>>
91911>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
91912>>>>>
91912>>>>>        If (bMertechDriver = True) Begin
91914>>>>>            Get _MertechSQLConnect sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
91915>>>>>        End
91915>>>>>>
91915>>>>>        If (bMertechDriver = False) Begin
91917>>>>>            Get phoSQLManager  to hoSQL
91918>>>>>            Send SqlSetConnect of hoSQL sDriverID SQLConnection.sConnectionString
91919>>>>>            Get SqlConnect     of hoSQL "" "" to hoSQLConnect
91920>>>>>        End
91920>>>>>>
91920>>>>>
91920>>>>>        If (hoSQLConnect <> 0) Begin
91922>>>>>            Move False to Err
91923>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
91924>>>>>            If (hoStmt <> 0) Begin
91926>>>>>
91926>>>>>                // If the embedded resource should be written as a script file to disk:
91926>>>>>                If (bCreateScriptFile = True) Begin
91928>>>>>                    Get psHome of (phoWorkspace(ghoApplication)) to sExportFile
91929>>>>>                    Get vFolderFormat sExportFile to sExportFile
91930>>>>>                    Move (sExportFile + sMemFileName) to sExportFile
91931>>>>>                    Get Seq_New_Channel to iOut
91932>>>>>                    If (iOut <> DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
91934>>>>>                        Direct_Output channel iOut sExportFile
91936>>>>>                    End
91936>>>>>>
91936>>>>>                End
91936>>>>>>
91936>>>>>
91936>>>>>                // Record starting date/time stamp
91936>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
91937>>>>>                // Turn on error handling if enabled
91937>>>>>                If (pbHandleQueryErrors(Self)) Begin
91939>>>>>                    Set pbSqlError to False
91940>>>>>                    Set paSqlErrorArray to aSqlErrorArray
91941>>>>>                    Move Error_Object_Id to hoError
91942>>>>>                    Move Self to Error_Object_Id
91943>>>>>                End
91943>>>>>>
91943>>>>>
91943>>>>>                Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iRows
91944>>>>>                Decrement iRows
91945>>>>>                Move (sNoCountKeyWord + sCR) to sStmt
91946>>>>>
91946>>>>>                For iCount from 0 to iRows
91952>>>>>>
91952>>>>>                    Move (SQLScriptArray.sSQLScriptArray[iCount]) to sSQLVal
91953>>>>>
91953>>>>>                    If (Uppercase(sSQLVal) <> sGOKeyWord) Begin
91955>>>>>                        If (sSQLVal <> "") Begin
91957>>>>>                            Move (sSQLVal + sCR) to sSQLVal
91958>>>>>                        End
91958>>>>>>
91958>>>>>                        Move (Append(sStmt, (sSQLVal))) to sStmt
91959>>>>>                    End
91959>>>>>>
91959>>>>>
91959>>>>>                    // - Each time we encounter a "GO" statement we execute it,
91959>>>>>                    // or if at the very end of the script.
91959>>>>>                    If (Uppercase(sSQLVal) = sGOKeyWord or iChunkCounter >= iChunkMax or iCount = iRows) Begin
91961>>>>>
91961>>>>>                        // - It turns out it can be at least 10 times faster to execute SQL statements in chunks,
91961>>>>>                        // instead of all in one go.
91961>>>>>                        Send SqlExecDirect of hoStmt sStmt
91962>>>>>
91962>>>>>                        If (bCreateScriptFile = True) Begin
91964>>>>>                            Write channel iOut sStmt
91966>>>>>                        End
91966>>>>>>
91966>>>>>                        Move "" to sStmt
91967>>>>>                        Move 0 to iChunkCounter
91968>>>>>                    End
91968>>>>>>
91968>>>>>                    Increment iChunkCounter
91969>>>>>                Loop
91970>>>>>>
91970>>>>>
91970>>>>>                Repeat
91970>>>>>>
91970>>>>>                    If (pbHandleQueryErrors(Self)) Begin
91972>>>>>                        Move hoError to Error_Object_Id
91973>>>>>                    End
91973>>>>>>
91973>>>>>                    Move (CurrentDateTime()) to dtQueryExecEnd
91974>>>>>
91974>>>>>                    Send _SqlColumnInfo hoStmt
91975>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT to iRows
91976>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
91977>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_NUMMESSAGES to iMsgs
91978>>>>>                    Set piRows    to iRows
91979>>>>>                    Set piRowType to iRowType
91980>>>>>
91980>>>>>                    If (iMsgs <> 0) Begin
91982>>>>>                        If (ghoDbUpdateHandler > 0) Begin
91984>>>>>                            Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
91985>>>>>                        End
91985>>>>>>
91985>>>>>                        For i from 1 to iMsgs
91991>>>>>>
91991>>>>>                            Get SqlGetMessage of hoStmt i to sMessage
91992>>>>>                            Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
91993>>>>>                            If (bShowProgress = True) Begin
91995>>>>>                                If (Active_State(ghoStatusPanel)) Begin
91997>>>>>                                    Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
91998>>>>>                                End
91998>>>>>>
91998>>>>>                                Else Begin
91999>>>>>                                    Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
92001>>>>>                                End
92001>>>>>>
92001>>>>>                            End
92001>>>>>>
92001>>>>>                            Move sMessage to sMsg[SizeOfArray(sMsg)]
92002>>>>>                            Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
92003>>>>>                        Loop
92004>>>>>>
92004>>>>>
92004>>>>>
92004>>>>>                        If (ghoDbUpdateHandler > 0) Begin
92006>>>>>                            Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
92007>>>>>                        End
92007>>>>>>
92007>>>>>                        Set paQueryMessages to sMsg
92008>>>>>                    End
92008>>>>>>
92008>>>>>
92008>>>>>                    Get SQLNextResultSet of hoStmt to iNextSet
92009>>>>>                Until (iNextSet = 0)
92011>>>>>
92011>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
92012>>>>>            End
92012>>>>>>
92012>>>>>
92012>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
92013>>>>>            Set ptsQueryExec to tsQuery
92014>>>>>            Send SqlClose of hoStmt
92015>>>>>
92015>>>>>            If (bCreateScriptFile = True) Begin
92017>>>>>                Close_Output channel iOut
92019>>>>>                Send Seq_Release_Channel iOut
92020>>>>>            End
92020>>>>>>
92020>>>>>        End
92020>>>>>>
92020>>>>>        Send SqlDisconnect of hoSQLConnect
92021>>>>>
92021>>>>>        Function_Return (hoSQLConnect <> 0 and Err = False)
92022>>>>>    End_Function
92023>>>>>
92023>>>>>    // * Dummy function for the Studio's Code Explorer *
92023>>>>>    Function SQL_UTILITY_FUNCTIONS Returns Boolean
92025>>>>>        Function_Return False
92026>>>>>    End_Function
92027>>>>>
92027>>>>>    // Does three things with auxilirary files;
92027>>>>>    // 1) Deletes the cache file in the first Data folder of the psDataPath property as the table at the SQL end has been changed.
92027>>>>>    // 2) Adds the sColumnName to the TableName.tag file in the first Data folder of the psDataPath property
92027>>>>>    // 3) Creates a new TableName.fd file if the DdSrc folder is available (if this is a development environment)
92027>>>>>    Function SqlUtilAdjustAuxFiles Handle hTable String sTableName String sColumnName Returns Boolean
92029>>>>>        String sDataPath sDDSrcPath sDriverID
92029>>>>>        Boolean bOK bExists bMertechDriver
92029>>>>>        Integer iCount iCh iPos
92029>>>>>
92029>>>>>        // If table name equals e.g. "dbo.MyTable" we need to remove the prefix.
92029>>>>>        If (sTableName contains ".") Begin
92031>>>>>            Move (Pos(".", sTableName)) to iPos
92032>>>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
92033>>>>>        End
92033>>>>>>
92033>>>>>
92033>>>>>        Get psDriverID to sDriverID
92034>>>>>        Get psDataPathFirstPart to sDataPath
92035>>>>>        Get vFolderExists sDataPath to bOK
92036>>>>>        If (bOK = False) Begin
92038>>>>>            Error DFERR_PROGRAM "Function SqlUtilAdjustAuxFiles; psDataPath not found!"
92039>>>>>>
92039>>>>>            Function_Return False
92040>>>>>        End
92040>>>>>>
92040>>>>>
92040>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
92041>>>>>        // First delete the cache file:
92041>>>>>        Get UtilDeleteCacheFile sTableName to bOK
92042>>>>>
92042>>>>>        Get Seq_New_Channel to iCh
92043>>>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
92045>>>>>            Function_Return False
92046>>>>>        End
92046>>>>>>
92046>>>>>
92046>>>>>        Get vFilePathExists (sDataPath + sTableName + ".tag") to bExists
92047>>>>>        If (bExists = False) Begin
92049>>>>>            Function_Return False
92050>>>>>        End
92050>>>>>>
92050>>>>>
92050>>>>>        // Add the new column name to the .tag file:
92050>>>>>        Append_Output channel iCh (sDataPath + sTableName + ".tag")
92052>>>>>            Writeln channel iCh sColumnName
92055>>>>>        Close_Output
92056>>>>>
92056>>>>>        // If in development environment; output new .fd file:
92056>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
92057>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
92058>>>>>        If (iCount > 1) Begin
92060>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
92061>>>>>        End
92061>>>>>>
92061>>>>>        Get vFolderExists sDDSrcPath to bExists
92062>>>>>        If (bExists = True) Begin
92064>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
92065>>>>>            Move False to Err
92066>>>>>            Get AutoConnectionIDLogin to bOK
92067>>>>>            If (hTable <> 0) Begin
92069>>>>>                Open hTable
92071>>>>>            End
92071>>>>>>
92071>>>>>            Else Begin
92072>>>>>                Get UtilTableOpen hTable sTableName DF_SHARE to bOK
92073>>>>>            End
92073>>>>>>
92073>>>>>
92073>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOK
92076>>>>>            If (bOK = True) Begin
92078>>>>>                Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
92080>>>>>            End
92080>>>>>>
92080>>>>>            If (Err = True) Begin
92082>>>>>                Move False to bOK
92083>>>>>            End
92083>>>>>>
92083>>>>>        End
92083>>>>>>
92083>>>>>
92083>>>>>        Function_Return (bOK = True)
92084>>>>>    End_Function
92085>>>>>
92085>>>>>    // Message for changing .int files to use connection ID's
92085>>>>>    //
92085>>>>>    // Changes all ".int" files for the passed sDataPath to use a sConnectionID,
92085>>>>>    // OR changes an existing connection id to a new id.
92085>>>>>    // Pass the full path to the data folder and the name of the connection id (string value).
92085>>>>>    // Pass a True for the bShowResult parameter to show work in progress (showln's).
92085>>>>>    Procedure SqlUtilChangeIntFilesToConnectionIDs String sDataPath String sConnectionID Boolean bShowResult
92087>>>>>        String sFileName sDriverID sDriverFile sConnectionString
92087>>>>>        String[] sFilesData
92088>>>>>        Boolean bOK bCancel
92088>>>>>        Integer iSize iCount
92088>>>>>
92088>>>>>        Get SqlUtilEnumerateIntFiles sDataPath to sFilesData
92089>>>>>        Move (SizeOfArray(sFilesData))    to iSize
92090>>>>>        If (iSize = 0) Begin
92092>>>>>            If (ghoStatusPanel <> 0) Begin
92094>>>>>                If (Active_State(ghoStatusPanel)) Begin
92096>>>>>                    Send Stop_StatusPanel of ghoStatusPanel
92097>>>>>                End
92097>>>>>>
92097>>>>>            End
92097>>>>>>
92097>>>>>            Send Info_Box "No .int files found! Nothing was changed."
92098>>>>>            Procedure_Return
92099>>>>>        End
92099>>>>>>
92099>>>>>
92099>>>>>        Move (Trim(sConnectionID)) to sConnectionID
92100>>>>>        Get vFolderFormat sDataPath to sDataPath
92101>>>>>        Decrement iSize
92102>>>>>        For iCount from 0 to iSize
92108>>>>>>
92108>>>>>            Move sFilesData[iCount] to sFileName
92109>>>>>            // This makes sure that we also can change an existing connection id to something new:
92109>>>>>            Get UtilChangeSourceCodeLine (sDataPath + sFileName) CS_SERVER_NAME (CS_SERVER_NAME * CS_DFCONNID + "=" + sConnectionID) bShowResult to bOK
92110>>>>>            If (ghoStatusPanel <> 0) Begin
92112>>>>>                If (Active_State(ghoStatusPanel)) Begin
92114>>>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
92115>>>>>                    If (bCancel = True) Begin
92117>>>>>                        Send Deactivate of ghoStatusPanel
92118>>>>>                        Procedure_Return
92119>>>>>                    End
92119>>>>>>
92119>>>>>                End
92119>>>>>>
92119>>>>>            End
92119>>>>>>
92119>>>>>        Loop
92120>>>>>>
92120>>>>>
92120>>>>>        Get psDriverID to sDriverID
92121>>>>>
92121>>>>>         // Finally also change the driver file e.g. MSSQLDRV.int file in the Data folder in case it has a "DFconnectionID xxxxID,SERVER..."
92121>>>>>        Move "" to sFileName
92122>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
92124>>>>>            Move "MSSQLDrv.int" to sFileName
92125>>>>>        End
92125>>>>>>
92125>>>>>        If (sDriverID = DB2_DRV_ID) Begin
92127>>>>>            Move "DB2_Drv.int" to sFileName
92128>>>>>        End
92128>>>>>>
92128>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
92130>>>>>            Move "ODBC_Drv.int" to sFileName
92131>>>>>        End
92131>>>>>>
92131>>>>>        If (sFileName <> "") Begin
92133>>>>>            Move "" to sDriverFile
92134>>>>>            Get_File_Path sFileName to sDriverFile
92135>>>>>            If (sDriverFile <> "") Begin
92137>>>>>                Get psConnectionString to sConnectionString
92138>>>>>                Get UtilChangeSourceCodeLine sDriverFile CS_SQLConnectionIDText (CS_SQLConnectionIDText * String(sConnectionID) + "," * String(sConnectionString) * String(",0")) bShowResult to bOK
92139>>>>>            End
92139>>>>>>
92139>>>>>        End
92139>>>>>>
92139>>>>>    End_Procedure
92140>>>>>
92140>>>>>    // Checks if the database exists in SQL. Returns = True if it does.
92140>>>>>    Function SqlUtilCheckIfDatabaseExists String sDatabase Returns Boolean
92142>>>>>        String[] sDatabaseArray
92143>>>>>        String sVal sServer sDriverID
92143>>>>>        Integer iCount iSize iPos
92143>>>>>        Boolean bExists
92143>>>>>        tSQLConnection SQLConnection
92143>>>>>        tSQLConnection SQLConnection
92143>>>>>
92143>>>>>        Move False to bExists
92144>>>>>        Get psDriverID to sDriverID
92145>>>>>        // DB2 doesn't need to have a "Database" name, so we always return True.
92145>>>>>        If (sDriverID = DB2_DRV_ID) Begin
92147>>>>>            Function_Return bExists
92148>>>>>        End
92148>>>>>>
92148>>>>>
92148>>>>>        Get SqlUtilEnumerateDatabases sDriverID to sDatabaseArray
92149>>>>>        If (SizeOfArray(sDatabaseArray) = 0) Begin
92151>>>>>            Function_Return False
92152>>>>>        End
92152>>>>>>
92152>>>>>
92152>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
92153>>>>>        Get ParseKeyWord SQLConnection.sConnectionString (CS_SQLIniDSNKeyword + "=") to sServer
92154>>>>>        If (sServer contains "/") Begin
92156>>>>>            Move (Pos("/", sServer)) to iPos
92157>>>>>            Move (Mid(sServer, 999, (iPos +1)))                        to sDatabase
92158>>>>>        End
92158>>>>>>
92158>>>>>
92158>>>>>        Move (SizeOfArray(sDatabaseArray)) to iSize
92159>>>>>        Decrement iSize
92160>>>>>        For iCount from 0 to iSize
92166>>>>>>
92166>>>>>            Move sDatabaseArray[iCount] to sVal
92167>>>>>            If (Uppercase(sVal) = Uppercase(sDatabase)) Begin
92169>>>>>                Move True to bExists
92170>>>>>            End
92170>>>>>>
92170>>>>>        Loop
92171>>>>>>
92171>>>>>
92171>>>>>        Function_Return bExists
92172>>>>>    End_Function
92173>>>>>
92173>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
92173>>>>>    Function SqlUtilCheckIfTableHandleExists Handle hTable String sDriverID Returns Boolean
92175>>>>>        String sTableName sVal
92175>>>>>        Boolean bExists
92175>>>>>        String[] sTablesArray
92176>>>>>        Integer iSize iCount
92176>>>>>
92176>>>>>        Move False to bExists
92177>>>>>        Get UtilTableHandleToString hTable to sTableName
92178>>>>>        Get SqlUtilEnumerateTables sDriverID to sTablesArray
92179>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
92180>>>>>        Decrement iSize
92181>>>>>        For iCount from 0 to iSize
92187>>>>>>
92187>>>>>            Move sTablesArray[iCount] to sVal
92188>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
92190>>>>>                Move True to bExists
92191>>>>>                Move iSize to iCount // We're done!
92192>>>>>            End
92192>>>>>>
92192>>>>>        Loop
92193>>>>>>
92193>>>>>
92193>>>>>        Function_Return bExists
92194>>>>>    End_Function
92195>>>>>
92195>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
92195>>>>>    Function SqlUtilCheckIfTableNameExists String sTableName String sDriverID Returns Boolean
92197>>>>>        String sVal
92197>>>>>        Boolean bExists
92197>>>>>        String[] sTablesArray
92198>>>>>        Integer iSize iCount
92198>>>>>
92198>>>>>        Move False to bExists
92199>>>>>        Get SqlUtilEnumerateTables sDriverID to sTablesArray
92200>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
92201>>>>>        Decrement iSize
92202>>>>>        For iCount from 0 to iSize
92208>>>>>>
92208>>>>>            Move sTablesArray[iCount] to sVal
92209>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
92211>>>>>                Move True to bExists
92212>>>>>                Move iSize to iCount // We're done!
92213>>>>>            End
92213>>>>>>
92213>>>>>        Loop
92214>>>>>>
92214>>>>>
92214>>>>>        Function_Return bExists
92215>>>>>    End_Function
92216>>>>>
92216>>>>>    // ToDo: This index name function needs to be finished...
92216>>>>>    Function SqlUtilCheckIfIndexNameExists Handle hTable String sIndexName Returns Boolean
92218>>>>>        String sSchema sTableName sDriverID
92218>>>>>        Boolean bExists
92218>>>>>
92218>>>>>        Get psDriverID to sDriverID
92219>>>>>        Get psSchema to sSchema
92220>>>>>        Get UtilTableHandleToString hTable to sTableName
92221>>>>>
92221>>>>>        Function_Return bExists
92222>>>>>    End_Function
92223>>>>>
92223>>>>>    // Checks if a column/field name exists in a SQL table definition
92223>>>>>    // Returns True if it does
92223>>>>>    // Sample:
92223>>>>>    //   Get SQLUtilColumnExists "MySQLTable" "MyColumnName" to bExists
92223>>>>>    Function SqlUtilColumnExists String sTableName String sFieldName Returns Boolean
92225>>>>>        Integer iNumColumns iColumn
92225>>>>>        String sColumn sDriverID
92225>>>>>        String[] sColumnsArray
92226>>>>>        Boolean bExists bOK
92226>>>>>
92226>>>>>        Move False to bExists
92227>>>>>        Get AutoConnectionIDLogin to bOK
92228>>>>>        Get psDriverID to sDriverID
92229>>>>>
92229>>>>>        Get SqlUtilEnumerateColumns sDriverID sTableName to sColumnsArray
92230>>>>>        Move (SizeOfArray(sColumnsArray)) to iNumColumns
92231>>>>>        Decrement iNumColumns
92232>>>>>        For iColumn from 0 to iNumColumns
92238>>>>>>
92238>>>>>            Move sColumnsArray[iColumn] to sColumn
92239>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
92241>>>>>                Move True to bExists
92242>>>>>                Move iNumColumns to iColumn // We're out of here
92243>>>>>            End
92243>>>>>>
92243>>>>>        Loop
92244>>>>>>
92244>>>>>
92244>>>>>        Function_Return bExists
92245>>>>>    End_Function
92246>>>>>
92246>>>>>    Function SqlUtilConvertColumnTypesToSQL2008 Handle hTable Returns Boolean
92248>>>>>        Integer iNumColumns iColumn iDFType iNativeType
92248>>>>>        Boolean bOpened bOK
92248>>>>>        String sColumnName sNativeTypeName
92248>>>>>
92248>>>>>        Get AutoConnectionIDLogin to bOK
92249>>>>>        Get OpenTableExclusive hTable to bOK
92250>>>>>        If (bOK = False) Begin
92252>>>>>            Function_Return False
92253>>>>>        End
92253>>>>>>
92253>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
92256>>>>>        If (bOpened = False) Begin
92258>>>>>            Error DFERR_PROGRAM ("Function SQLUtilConvertColumnTypesToSQL2008; Could not open table" * String(hTable))
92259>>>>>>
92259>>>>>            Function_Return False
92260>>>>>        End
92260>>>>>>
92260>>>>>
92260>>>>>        Move False to Err
92261>>>>>
92261>>>>>        Structure_Start hTable
92262>>>>>            Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
92265>>>>>
92265>>>>>            For iColumn from 1 to iNumColumns
92271>>>>>>
92271>>>>>                Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iDfType
92274>>>>>                Get_Attribute DF_FIELD_NAME             of hTable iColumn to sColumnName
92277>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iNativeType
92280>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE_Name of hTable iColumn to sNativeTypeName
92283>>>>>
92283>>>>>                Case Begin
92283>>>>>                    Case (iDFType = DF_DATE)
92285>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
92287>>>>>                            // Convert datetime to date
92287>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_DATE
92290>>>>>                        End
92290>>>>>>
92290>>>>>                        Case Break
92291>>>>>                    Case (iDFType = DF_DATETIME)
92294>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
92296>>>>>                            // Convert datetime to datetime2
92296>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_TIMESTAMP2
92299>>>>>                        End
92299>>>>>>
92299>>>>>                        Case Break
92300>>>>>                    Case (iDFType = DF_ASCII)
92303>>>>>                        If (iNativeType = SQL_CHAR) Begin
92305>>>>>                            // Convert char to varchar
92305>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
92308>>>>>                        End
92308>>>>>>
92308>>>>>                        Case Break
92309>>>>>                    Case (iDFType = DF_TEXT)
92312>>>>>                        If (iNativeType = SQL_LONGVARCHAR) Begin
92314>>>>>                            // Convert text to varchar(max)
92314>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
92317>>>>>                        End
92317>>>>>>
92317>>>>>                        Case Break
92318>>>>>                    Case (iDFType = DF_BINARY)
92321>>>>>                        If (iNativeType = SQL_LONGVARBINARY) Begin
92323>>>>>                            // Convert image to varbinary(max)
92323>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARBINARY
92326>>>>>                        End
92326>>>>>>
92326>>>>>                        Case Break
92327>>>>>                Case End
92327>>>>>            Loop
92328>>>>>>
92328>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
92329>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
92331>>>>>
92331>>>>>        Set Action_Text of ghoStatusPanel to ""
92332>>>>>        Function_Return (Err = False)
92333>>>>>    End_Function
92334>>>>>
92334>>>>>
92334>>>>>    // Will create an SQL table with the passed sTableName & sColumnName as Numeric 4.2 to keep
92334>>>>>    // the DbUpdateVersion database revision in.
92334>>>>>    // Also pass the file number of the current (embedded?) table number used in development.
92334>>>>>    // It will first create the SQL Table & column, then create the .int file and change Filelist.cfg
92334>>>>>    Function SqlUtilCreateDbVersionTable Handle hTable String sColumnName String sDriverID Returns Boolean
92336>>>>>        Boolean bOK bOpened
92336>>>>>        String sTableName sDataType sAlterTable sAddColumn sLengthAndDecimals sStmt
92336>>>>>
92336>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
92339>>>>>        Get _TableNameOnly sTableName to sTableName
92340>>>>>        If (sTableName = "") Begin
92342>>>>>            Function_Return False
92343>>>>>        End
92343>>>>>>
92343>>>>>
92343>>>>>        // This just creates the table and a "dummy" column.
92343>>>>>        Get SqlTableCreate hTable sDriverID to bOK
92344>>>>>        If (bOK = False) Begin
92346>>>>>            Function_Return False
92347>>>>>        End
92347>>>>>>
92347>>>>>
92347>>>>>        Close hTable
92348>>>>>        Move False to Err
92349>>>>>
92349>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
92350>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
92351>>>>>        Move "Decimal" to sDataType
92352>>>>>        Get _SqlFormatLengthAndDecimalAsString 4 2 to sLengthAndDecimals
92353>>>>>
92353>>>>>        // Adds the "sColumnName" passed to the function
92353>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals) to sStmt
92354>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
92355>>>>>
92355>>>>>        // Now we can delete the dummy column:
92355>>>>>        Get SqlColumnRemoveByTableName sTableName "Dummy" to bOK
92356>>>>>
92356>>>>>        // Finally, we attach to the newly created table.
92356>>>>>        If (Err = False) Begin
92358>>>>>            Get ApiTableAttachToSQL hTable True to bOK
92359>>>>>        End
92359>>>>>>
92359>>>>>        Open hTable
92361>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
92364>>>>>
92364>>>>>        Function_Return (Err = False and bOK = True and bOpened = True)
92365>>>>>    End_Function
92366>>>>>
92366>>>>>    // The table must already exist in the filelist for this function to work.
92366>>>>>    // It creates a rudimentary .int file in the first Data folder of the psDataPath property.
92366>>>>>    Function SqlUtilCreateIntFile Handle hTable String sDriverID String sConnectionID Boolean bAnsi Boolean bSysFile Returns Boolean
92368>>>>>        Boolean bOK bExists bUseConnectionID bMertech
92368>>>>>        String sDataPath sRootName sLogicalName sPhysicalFileName sConnectionString sDatabaseName sSchemaName sANSI_OEM
92368>>>>>        String[] sIndexArray
92369>>>>>        Integer iCount iCh iSize
92369>>>>>
92369>>>>>        Move (Trim(sConnectionID) <> "") to bUseConnectionID
92370>>>>>        Get psConnectionString to sConnectionString
92371>>>>>
92371>>>>>        Move CS_ANSI_Txt to sANSI_OEM
92372>>>>>        If (bANSI = False) Begin
92374>>>>>            Move CS_OEM_Txt to sANSI_OEM
92375>>>>>        End
92375>>>>>>
92375>>>>>
92375>>>>>        Get psDataPathFirstPart to sDataPath
92376>>>>>        Get vFolderExists sDataPath to bOK
92377>>>>>        If (bOK = False) Begin
92379>>>>>            Error DFERR_PROGRAM "Function SqlUtilCreateIntFile; psDataPath not found!"
92380>>>>>>
92380>>>>>            Function_Return False
92381>>>>>        End
92381>>>>>>
92381>>>>>        Get vFolderFormat sDataPath to sDataPath
92382>>>>>
92382>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
92385>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
92388>>>>>        Get _TableNameOnly sRootName to sDatabaseName
92389>>>>>        Move sLogicalName  to sPhysicalFileName
92390>>>>>        Move (sPhysicalFileName + ".int") to sPhysicalFileName
92391>>>>>
92391>>>>>        Get IsMertechDriver sDriverID to bMertech
92392>>>>>        If (bMertech = True) Begin
92394>>>>>            // This should not be called here. Instead it is called by the SqlUtilUpdateIntFile!
92394>>>>>            // Else it will create an error in the error log (although it won't do anything...)
92394>>>>>            // Get _MertechSqlUtilCreateIntFile hTable sDataPath sPhysicalFileName to bOK
92394>>>>>            Function_Return (bOK = True)
92395>>>>>        End
92395>>>>>>
92395>>>>>
92395>>>>>        Get psSchema hTable to sSchemaName
92396>>>>>        If (sSchemaName = "") Begin
92398>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchemaName
92399>>>>>        End
92399>>>>>>
92399>>>>>
92399>>>>>        // If the .int file already exists; we rename it to "FileName" + ".bak"
92399>>>>>        Get vFilePathExists (sDataPath + sPhysicalFileName) to bExists
92400>>>>>        If (bExists = True) Begin
92402>>>>>            Get vRenameFile (sDataPath + sPhysicalFileName) (sDataPath + sPhysicalFileName + ".bak") to bOK
92403>>>>>        End
92403>>>>>>
92403>>>>>
92403>>>>>        Get UtilDeleteCacheFile sRootName to bOK
92404>>>>>        Get SqlUtilEnumerateIndexes sRootName sDriverID to sIndexArray
92405>>>>>
92405>>>>>        Get Seq_Open_Output_Channel (sDataPath + sPhysicalFileName) to iCh
92406>>>>>            Writeln channel iCh CS_DRIVER_NAME     " " sDriverID
92411>>>>>            If (bUseConnectionID = True) Begin
92413>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_DFCONNID "=" sConnectionID
92420>>>>>            End
92420>>>>>>
92420>>>>>            Else Begin
92421>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_SERVER "=" sConnectionString
92428>>>>>            End
92428>>>>>>
92428>>>>>            Writeln channel iCh CS_DATABASE_NAME          " " sDatabaseName
92433>>>>>            Writeln channel iCh CS_SCHEMA_NAME            " " (Lowercase(sSchemaName))
92438>>>>>            // There seems to be a new order how these are set from DF19.
92438>>>>>            If (bSysFile = True) Begin
92440>>>>>                Writeln channel iCh CS_RECNUM_TABLE       " " "NO"
92445>>>>>            End
92445>>>>>>
92445>>>>>            Writeln channel iCh CS_TABLE_CHARACTER_FORMAT " " sANSI_OEM
92450>>>>>            Writeln channel iCh CS_USE_DUMMY_ZERO_DATE    " " "YES" // ToDo: We maybe need to paramerize this setting?
92455>>>>>            If (bSysFile = True) Begin
92457>>>>>                Writeln channel iCh CS_SYSTEM_FILE        " " "YES"
92462>>>>>            End
92462>>>>>>
92462>>>>>
92462>>>>>            If (bSysFile = False) Begin
92464>>>>>                Move (SizeOfArray(sIndexArray)) to iSize
92465>>>>>                Move (SortArray(sIndexArray)) to sIndexArray
92466>>>>>                If (iSize > 0) Begin
92468>>>>>                    Writeln channel iCh (CS_PRIMARY_INDEX * String("0"))
92471>>>>>                    Writeln channel iCh // Just an empty line
92473>>>>>                End
92473>>>>>>
92473>>>>>                Decrement iSize
92474>>>>>                For iCount from 0 to iSize
92480>>>>>>
92480>>>>>                    Writeln channel iCh (CS_INDEX_NUMBER * String(iCount))
92483>>>>>                    Writeln channel iCh (CS_INDEX_NAME   * String(sIndexArray[iCount]))
92486>>>>>                    Writeln channel iCh
92488>>>>>                Loop
92489>>>>>>
92489>>>>>            End
92489>>>>>>
92489>>>>>        Send Seq_Close_Channel iCh
92490>>>>>
92490>>>>>        // Wait a sec for Windows to finish writing the file:
92490>>>>>        Sleep 1
92491>>>>>
92491>>>>>        Function_Return (bOK = True)
92492>>>>>    End_Function
92493>>>>>
92493>>>>>    // Returns a handle to the SQL server associated with the passed driver ID.
92493>>>>>    // Pass e.g. the psServer property to determine the current connection server.
92493>>>>>    // Returns a handle to the database connection, or a zero (0) if it fails.
92493>>>>>    // This handle can be used to obtain attributes about the server, such as default
92493>>>>>    // column types.
92493>>>>>    Function SqlUtilDatabaseHandle String sDriverID String sServer Returns Handle
92495>>>>>        Handle hDatabase
92495>>>>>        Integer iDriver iServers iCount
92495>>>>>        String sValue
92495>>>>>
92495>>>>>        If (sServer = "") Begin
92497>>>>>            Function_Return 0
92498>>>>>        End
92498>>>>>>
92498>>>>>
92498>>>>>        Get DriverIndex sDriverID to iDriver
92499>>>>>        If (iDriver = 0) Begin
92501>>>>>            Function_Return 0
92502>>>>>        End
92502>>>>>>
92502>>>>>
92502>>>>>        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iServers
92505>>>>>        For iCount from 1 to iServers
92511>>>>>>
92511>>>>>            Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
92514>>>>>            If (Uppercase(sValue) contains Uppercase(sServer)) Begin
92516>>>>>                Get_Attribute DF_DATABASE_ID of iDriver iCount to hDatabase
92519>>>>>            End
92519>>>>>>
92519>>>>>        Loop
92520>>>>>>
92520>>>>>
92520>>>>>        Function_Return hDatabase
92521>>>>>    End_Function
92522>>>>>
92522>>>>>//    Function UtilIsFilelistEntryDriverBased Integer hTable String sDriverID Returns Boolean
92522>>>>>//        String sRootName
92522>>>>>//        Boolean bOK
92522>>>>>//
92522>>>>>//        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
92522>>>>>//        Move (sRootName contains sDriverID) to bOK
92522>>>>>//
92522>>>>>//        Function_Return bOK
92522>>>>>//    End_Function
92522>>>>>
92522>>>>>//    Function UtilFilelistAddDriverInfo Integer hTable Returns Boolean
92522>>>>>//        String sDriverID sRootName sDisplayName sSchema sVal
92522>>>>>//        Integer iDbType
92522>>>>>//        Boolean bOK
92522>>>>>//
92522>>>>>//        Get UtilIsFilelistEntryDriverBased to bOK
92522>>>>>//        If (bOK = True) Begin
92522>>>>>//            Function_Return False
92522>>>>>//        End
92522>>>>>//
92522>>>>>//        Get psDriverID to sDriverID
92522>>>>>//        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
92522>>>>>//        Move (sDriverID + ":" + sRootName)           to sRootName
92522>>>>>//        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
92522>>>>>//
92522>>>>>//        Get psDriverID to sDriverID
92522>>>>>//        Get piDbType   to iDbType
92522>>>>>//        Get psSchema   to sSchema
92522>>>>>//        If (sSchema = "") Begin
92522>>>>>//            Get _SqlFindKeyWord CI_SQLDBO to sSchema
92522>>>>>//        End
92522>>>>>//
92522>>>>>//        Move (Uppercase(sDisplayName)) to sVal
92522>>>>>//        If (not(sVal contains (sSchema + "."))) Begin
92522>>>>>//            If (iDbType = EN_dbTypeDB2) Begin
92522>>>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
92522>>>>>//            End
92522>>>>>//            Else Begin
92522>>>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
92522>>>>>//            End
92522>>>>>//        End
92522>>>>>//
92522>>>>>//        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
92522>>>>>//        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
92522>>>>>//
92522>>>>>//        Function_Return True
92522>>>>>//    End_Function
92522>>>>>
92522>>>>>    // Removes all driver identifications (e.g. "MSSQLDRV;MyTable" or "MyTable.MSSQLDRV"
92522>>>>>    // from the passed filelist.
92522>>>>>    // Returns the number of tables affected.
92522>>>>>    Function SqlUtilFilelistRemoveDriverInfo String sFilelist Returns Integer
92524>>>>>        String sCurrentFileList sRootName sDisplayName sLogicalName sVal
92524>>>>>        Integer iRetval
92524>>>>>        Handle hTable
92524>>>>>
92524>>>>>        // We first save the current filelist as the passed filelist name
92524>>>>>        // may come from another workspace, to restore it when we're ready.
92524>>>>>        Get_Attribute DF_FILELIST_NAME to sCurrentFileList
92527>>>>>        Set_Attribute DF_FILELIST_NAME to sFilelist
92530>>>>>        Move 0 to hTable
92531>>>>>        Move 0 to iRetval
92532>>>>>
92532>>>>>        Repeat
92532>>>>>>
92532>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92535>>>>>            If (hTable <> 0) Begin
92537>>>>>                Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
92540>>>>>                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
92543>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
92546>>>>>                Move (Uppercase(sRootName)) to sVal
92547>>>>>                If (sVal contains MSSQLDRV_ID or sVal contains DB2_DRV_ID or sVal contains ODBC_DRV_ID) Begin
92549>>>>>                    // Prefixes:
92549>>>>>                    Move (Replace((MSSQLDRV_ID + ":"), sRootName, "")) to sRootName
92550>>>>>                    Move (Replace((DB2_DRV_ID  + ":"), sRootName, "")) to sRootName
92551>>>>>                    Move (Replace((ODBC_DRV_ID + ":"), sRootName, "")) to sRootName
92552>>>>>                    // Suffixes:
92552>>>>>                    Move (Replace(("." + MSSQLDRV_ID), sRootName, "")) to sRootName
92553>>>>>                    Move (Replace(("." + DB2_DRV_ID),  sRootName, "")) to sRootName
92554>>>>>                    Move (Replace(("." + ODBC_DRV_ID), sRootName, "")) to sRootName
92555>>>>>
92555>>>>>                    // Change Filelist entry:
92555>>>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable          to sRootName
92558>>>>>
92558>>>>>                    Move (Lowercase(sDisplayName)) to sVal
92559>>>>>                    If (sVal contains "dbo.") Begin
92561>>>>>                        Move (Replace("dbo.", sDisplayName, ""))       to sDisplayName
92562>>>>>
92562>>>>>                        // Change Filelist entry:
92562>>>>>                        Set_Attribute DF_FILE_DISPLAY_NAME of hTable   to sDisplayName
92565>>>>>                    End
92565>>>>>>
92565>>>>>                    Increment iRetval
92566>>>>>                End
92566>>>>>>
92566>>>>>            End
92566>>>>>>
92566>>>>>        Until (hTable = 0)
92568>>>>>
92568>>>>>        Set_Attribute DF_FILELIST_NAME to sCurrentFileList
92571>>>>>
92571>>>>>        Function_Return iRetval
92572>>>>>    End_Function
92573>>>>>
92573>>>>>    // To open all Sql based tables in Filelist.cfg
92573>>>>>    Procedure SqlUtilOpenAllTables
92575>>>>>        Handle hTable
92575>>>>>        String sRoot sDriverID
92575>>>>>        Boolean bOK
92575>>>>>
92575>>>>>        Move 0 to hTable
92576>>>>>        Move "" to sDriverID
92577>>>>>        Get AutoConnectionIDLogin to bOK
92578>>>>>
92578>>>>>        Repeat
92578>>>>>>
92578>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92581>>>>>            If (hTable > 0) Begin
92583>>>>>                Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
92586>>>>>                If (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) Begin
92588>>>>>                    Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
92591>>>>>                    If (Uppercase(sRoot) contains ".INT" or Uppercase(sRoot) contains MSSQLDRV_ID or Uppercase(sRoot) contains DB2_DRV_ID or Uppercase(sRoot) contains ODBC_DRV_ID) Begin
92593>>>>>                        Open hTable
92595>>>>>                    End
92595>>>>>>
92595>>>>>                End
92595>>>>>>
92595>>>>>            End
92595>>>>>>
92595>>>>>
92595>>>>>        Until (hTable = 0)
92597>>>>>    End_Procedure
92598>>>>>
92598>>>>>//    Function SqlUtilSchemaName Handle hTable Returns String
92598>>>>>//        String sRetval sDriverID
92598>>>>>//        String sTableName
92598>>>>>//        Integer iDbType iIndex
92598>>>>>//        Boolean bOK
92598>>>>>//
92598>>>>>//        Get psDriverID to sDriverID
92598>>>>>//        Get _SqlCheckCurrentDriver sDriverID to bOK
92598>>>>>//        If (hTable = 0 or bOK = False) Begin
92598>>>>>//            Function_Return ""
92598>>>>>//        End
92598>>>>>//
92598>>>>>//        Move False to Err
92598>>>>>//        Get UtilTableHandleToString hTable to sTableName
92598>>>>>//        Get piDbType to iDbType
92598>>>>>//        Get _SqlUtilEnumerateTableIndex sTableName sDriverID to iIndex
92598>>>>>//        If (iIndex = -1) Begin
92598>>>>>//            Function_Return ""
92598>>>>>//        End
92598>>>>>//
92598>>>>>//        Function_Return sRetval
92598>>>>>//    End_Function
92598>>>>>
92598>>>>>    // Checks if the passed Table;
92598>>>>>    // 1) Already has a Filelist entry that points to SQL and
92598>>>>>    // 2) It has an .int file.
92598>>>>>    // If both is True it should already be connected to SQL
92598>>>>>    Function SqlUtilTableIsAttached String sDriverID Handle hTable Returns Boolean
92600>>>>>        Boolean bExists bRootName
92600>>>>>        String sRootName sDataPath
92600>>>>>
92600>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
92603>>>>>        Move (sRootName contains sDriverID) to bRootName
92604>>>>>
92604>>>>>        Get psDataPathFirstPart to sDataPath
92605>>>>>        Get vFolderExists sDataPath to bExists
92606>>>>>        If (bExists = False) Begin
92608>>>>>            // If the path doesn't exist it cannot have an .int file and we're done, although it shouldn't happen.
92608>>>>>            Function_Return False
92609>>>>>        End
92609>>>>>>
92609>>>>>
92609>>>>>        Get vFolderFormat sDataPath to sDataPath
92610>>>>>        Get _TableNameOnly sRootName to sRootName
92611>>>>>        Get vFilePathExists (sDataPath + sRootName + ".int") to bExists
92612>>>>>
92612>>>>>        Function_Return (bRootName = True and bExists = True)
92613>>>>>    End_Function
92614>>>>>
92614>>>>>    Function SqlUtilTableIsViewType String sDriverID Handle hTable Returns Boolean
92616>>>>>        Boolean bViewTableType bOpen bOK
92616>>>>>        Integer iTableCount iNumTables
92616>>>>>        String sTableName sOwner sTableType sEnumTableName sEnumSchemaName
92616>>>>>        Handle hoCliHandler
92616>>>>>        tSQLConnection SQLConnection
92616>>>>>        tSQLConnection SQLConnection
92616>>>>>
92616>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
92619>>>>>        If (bOpen = False) Begin
92621>>>>>            Get AutoConnectionIDLogin to bOK
92622>>>>>            Open hTable
92624>>>>>        End
92624>>>>>>
92624>>>>>
92624>>>>>        Get pSQLConnection to SQLConnection
92625>>>>>        Get phoCLIHandler to hoCliHandler
92626>>>>>        Set psDriverID of hoCliHandler to sDriverID
92627>>>>>
92627>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
92630>>>>>        Get _TableNameOnly sTableName to sTableName
92631>>>>>        Get_Attribute DF_FILE_OWNER     of hTable to sOwner
92634>>>>>        Get EnumerateTables of hoCliHandler SQLConnection.sConnectionString to iNumTables
92635>>>>>
92635>>>>>        For iTableCount from 1 to iNumTables
92641>>>>>>
92641>>>>>            Get TableName  of hoCliHandler iTableCount to sEnumTableName
92642>>>>>            Get SchemaName of hoCliHandler iTableCount to sEnumSchemaName
92643>>>>>            If ((Uppercase(sEnumTableName)  = Uppercase(sTableName)) and (Uppercase(sEnumSchemaName) = Uppercase(sOwner))) Begin
92645>>>>>                Get TableType of hoCliHandler iTableCount to sTableType
92646>>>>>                Move iNumTables to iTableCount // We're done.
92647>>>>>            End
92647>>>>>>
92647>>>>>        Loop
92648>>>>>>
92648>>>>>
92648>>>>>        Move (sTableType = "VIEW") to bViewTableType
92649>>>>>        If (bOpen = False) Begin
92651>>>>>            Close hTable
92652>>>>>        End
92652>>>>>>
92652>>>>>
92652>>>>>        Function_Return bViewTableType
92653>>>>>    End_Function
92654>>>>>
92654>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
92654>>>>>    //
92654>>>>>    // SQL utility function that returns a database type (string) constant
92654>>>>>    // corresponding to the passed iDbType.
92654>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
92656>>>>>        String sRetval
92656>>>>>        Get SqlUtilDbTypeToString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
92657>>>>>        Function_Return sRetval
92658>>>>>    End_Function
92659>>>>>
92659>>>>>    // SQL utility function that returns a database type constant (integer)
92659>>>>>    // corresponding to the passed sDbType string constant.
92659>>>>>    Function SqlUtilDbTypeToInteger String sDbType Returns Integer
92661>>>>>        Integer iRetval
92661>>>>>        Get SqlUtilDbTypeToInteger of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDbType to iRetval
92662>>>>>        Function_Return iRetval
92663>>>>>    End_Function
92664>>>>>
92664>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
92664>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
92664>>>>>    // the SQL Connection program's grid.
92664>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
92666>>>>>        String sRetval
92666>>>>>        Get SqlUtilDbTypeIntegerToStringConstant of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
92667>>>>>        Function_Return sRetval
92668>>>>>    End_Function
92669>>>>>
92669>>>>>    // Pass a driver name as a string and the function will return
92669>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
92669>>>>>    // quite work and always returns "MS SQL Server"
92669>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
92671>>>>>        Integer iRetval
92671>>>>>        Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverID to iRetval
92672>>>>>        Function_Return iRetval
92673>>>>>    End_Function
92674>>>>>
92674>>>>>    // Returns a temp table name that consists of the RootName, an underscore and as much of a GUID
92674>>>>>    // that "fits" in the max allowed length for table names.
92674>>>>>    // Max number of characters allowed for table names;
92674>>>>>    // IBM DB2      = 128
92674>>>>>    // MS-SQL       = 128
92674>>>>>    // Oracle       = 128 (Version 12.2 and later. 30 characters for earlier versions)
92674>>>>>    // MySQL        = 64
92674>>>>>    // PostgreSQL   = 64
92674>>>>>    Function SqlUtilGUIDTempTableName String sRootName Returns String
92676>>>>>        String sGUIDName
92676>>>>>        Integer iDbType iLength
92676>>>>>
92676>>>>>        Get piDbType to iDbType
92677>>>>>        Move (RandomHexUUID()) to sGUIDName
92678>>>>>        Move (sRootName + "_" + sGUIDName) to sGUIDName
92679>>>>>        Move (Length(sGUIDName)) to iLength
92680>>>>>
92680>>>>>        Case Begin
92680>>>>>            Case (iDbType = EN_DbTypeDB2)
92682>>>>>            If (iLength > 128) Begin
92684>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
92685>>>>>            End
92685>>>>>>
92685>>>>>            Case Break
92686>>>>>
92686>>>>>            Case (iDbType = EN_DbTypeMSSQL)
92689>>>>>            If (iLength > 128) Begin
92691>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
92692>>>>>            End
92692>>>>>>
92692>>>>>            Case Break
92693>>>>>
92693>>>>>            Case (iDbType = EN_DbTypeOracle) // Note: We assume an Oracle version of 12.2 or later.
92696>>>>>            If (iLength > 128) Begin
92698>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
92699>>>>>            End
92699>>>>>>
92699>>>>>            Case Break
92700>>>>>
92700>>>>>            Case (iDbType = EN_DbTypeMySQL)
92703>>>>>            If (iLength > 64) Begin
92705>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
92706>>>>>            End
92706>>>>>>
92706>>>>>            Case Break
92707>>>>>
92707>>>>>            Case (iDbType = EN_DbTypePostgre)
92710>>>>>            If (iLength > 64) Begin
92712>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
92713>>>>>            End
92713>>>>>>
92713>>>>>        Case End
92713>>>>>
92713>>>>>        Function_Return sGUIDName
92714>>>>>    End_Function
92715>>>>>
92715>>>>>    // Reads a resource that has been embedded by the compiler and writes it to disk.
92715>>>>>    // Pass the memory resource file reference and the filename to be created,
92715>>>>>    // including full path.
92715>>>>>    Procedure SqlUtilCreateFileFromMemory String sMemFileName String sFileName
92717>>>>>        String sText
92717>>>>>        Integer iCh iSize iArgSize
92717>>>>>
92717>>>>>        Move ("Resource:" + sMemFileName) to sMemFileName
92718>>>>>        Get Seq_Open_Input_Channel sMemFileName to iCh
92719>>>>>            Get_Channel_Size iCh to iSize
92720>>>>>            Get_Argument_Size to iArgSize
92721>>>>>            If (iSize > iArgSize) Begin
92723>>>>>                Set_Argument_Size iSize
92724>>>>>>
92724>>>>>            End
92724>>>>>>
92724>>>>>            Read_Block channel iCh sText iSize
92726>>>>>        Send Seq_Close_Channel iCh
92727>>>>>
92727>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
92728>>>>>            Write channel iCh sText
92730>>>>>        Send Seq_Close_Channel iCh
92731>>>>>
92731>>>>>        If (iSize <> iArgSize) Begin
92733>>>>>            Set_Argument_Size iArgSize
92734>>>>>>
92734>>>>>        End
92734>>>>>>
92734>>>>>
92734>>>>>        // Wait for file to be written to disk.
92734>>>>>        Sleep 2
92735>>>>>    End_Procedure
92736>>>>>
92736>>>>>    Function SqlUtilDefaultNullValue String sDriverID Integer iDbType Integer iDataType Returns String
92738>>>>>        String sNotNull sRetval sDefaultValue
92738>>>>>        Boolean bOK
92738>>>>>
92738>>>>>        Get IsSQLDriver sDriverID to bOK
92739>>>>>        If (bOK = False) Begin
92741>>>>>            Function_Return ""
92742>>>>>        End
92742>>>>>>
92742>>>>>
92742>>>>>        Get UtilDataTypeDefaultValue sDriverID iDbType iDataType to sDefaultValue
92743>>>>>        Get _SqlFindKeyWord CI_SQLNotNull to sNotNull
92744>>>>>
92744>>>>>        Case Begin
92744>>>>>            Case (iDbType = EN_dbTypeMSSQL)
92746>>>>>                Move ("DEFAULT" * String(sDefaultValue) * String(sNotNull)) to sRetval
92747>>>>>                Case Break
92748>>>>>            Case (iDbType = EN_dbTypeMySQL)
92751>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
92752>>>>>                Case Break
92753>>>>>            Case (iDbType = EN_dbTypePostgre)
92756>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
92757>>>>>                Case Break
92758>>>>>            Case (iDbType = EN_dbTypeDB2)
92761>>>>>                Move (String(sNotNull))                                     to sRetval
92762>>>>>                Case Break
92763>>>>>
92763>>>>>            // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
92763>>>>>            // ToDo: We need to look deeper into how Oracle handles NULL
92763>>>>>            Case (iDbType = EN_dbTypeOracle)
92766>>>>>                Move  ""                                                    to sRetval
92767>>>>>                Case Break
92768>>>>>
92768>>>>>            Case Else
92768>>>>>                Move  ""                                                    to sRetval
92769>>>>>        Case End
92769>>>>>
92769>>>>>        Function_Return sRetval
92770>>>>>    End_Function
92771>>>>>
92771>>>>>    Function SqlUtilUpdateIntFile Integer hTable Returns Boolean
92773>>>>>        String sOrgFormat sNewFormat sRootName sDatabaseName sPhysicalFileName sDriverID sDataPath
92773>>>>>        Boolean bOpened bOK bMertech
92773>>>>>
92773>>>>>        // For some reason this .int file update screws up of CodeMast & CodeType .int files
92773>>>>>        // which makes the program unable to run because they can't be opened.
92773>>>>>        // ToDo: This needs further investigation but for now we just skip CodeMast & CodeType .int files update...
92773>>>>>        // Also note that there is another helper function "UtilTableCreateCodeMastCodeTypeIntFiles" to create
92773>>>>>        // proper .int files for the two tables.
92773>>>>>        If (Uppercase(sDatabaseName) = "CODETYPE" or Uppercase(sDatabaseName) = "CODEMAST") Begin
92775>>>>>            Function_Return True
92776>>>>>        End
92776>>>>>>
92776>>>>>
92776>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
92779>>>>>        Get _TableNameOnly sRootName to sDatabaseName
92780>>>>>        Move CS_OEM_Txt  to sOrgFormat
92781>>>>>        Move CS_ANSI_Txt to sNewFormat
92782>>>>>        Get AutoConnectionIDLogin to bOK
92783>>>>>
92783>>>>>        // It seems this can be called to quickly; causing a 13001 error "Cannot open cache file for write"
92783>>>>>        Sleep 2
92784>>>>>        Get OpenTableExclusive hTable to bOpened
92785>>>>>        If (bOpened = False) Begin
92787>>>>>            Function_Return False
92788>>>>>        End
92788>>>>>>
92788>>>>>
92788>>>>>        Get psDriverID to sDriverID
92789>>>>>        Get IsMertechDriver sDriverID to bMertech
92790>>>>>        If (bMertech = True) Begin
92792>>>>>            Get psDataPathFirstPart to sDataPath
92793>>>>>            Get vFolderExists sDataPath to bOK
92794>>>>>            If (bOK = False) Begin
92796>>>>>                Error DFERR_PROGRAM "Function SqlUtilUpdateIntFile; psDataPath not found!"
92797>>>>>>
92797>>>>>                Function_Return False
92798>>>>>            End
92798>>>>>>
92798>>>>>            Get vFolderFormat sDataPath to sDataPath
92799>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
92802>>>>>            Get _TableNameOnly sRootName to sDatabaseName
92803>>>>>            Move sDatabaseName to sPhysicalFileName
92804>>>>>            Move (sPhysicalFileName + ".int") to sPhysicalFileName
92805>>>>>            Get _MertechSqlUtilCreateIntFile hTable sDataPath sPhysicalFileName to bOK
92806>>>>>            Function_Return (bOK = True)
92807>>>>>        End
92807>>>>>>
92807>>>>>
92807>>>>>        Move False to Err
92808>>>>>        Get_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
92811>>>>>        Move (Uppercase(sOrgFormat)) to sOrgFormat
92812>>>>>        // Lets swap the OEM/ANSI format, just to make a change in Structure_Start below (and back),
92812>>>>>        // to "touch" the table so the driver feels there has been a change and updates the .int file.
92812>>>>>        Move (If(sOrgFormat = CS_OEM_Txt, CS_ANSI_Txt, CS_OEM_Txt)) to sNewFormat
92813>>>>>
92813>>>>>        If (hTable > 0) Begin
92815>>>>>            Structure_Start hTable
92816>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
92819>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
92822>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
92824>>>>>        End
92824>>>>>>
92824>>>>>        Else Begin
92825>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
92828>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
92831>>>>>        End
92831>>>>>>
92831>>>>>        Function_Return (Err = False)
92832>>>>>    End_Function
92833>>>>>
92833>>>>>    Function SqlProcedureArrayMertech String sStmt String sArgument Returns String[]
92835>>>>>        String[] sReturnArray
92836>>>>>        String sValue sUserID sPassword
92836>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
92836>>>>>        Integer iFetchResult iRetval
92836>>>>>        tSQLConnection SQLConnection
92836>>>>>        tSQLConnection SQLConnection
92836>>>>>
92836>>>>>        Get _MertechSQLManagerHandle to hoSQLHandler
92837>>>>>        If (hoSQLHandler <> 0) Begin
92839>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
92840>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
92841>>>>>            If (hoSQLConnect <> 0) Begin
92843>>>>>                Get SQLOpen of hoSQLConnect to hStmt
92844>>>>>                If (hStmt <> 0) Begin
92846>>>>>                    Send SQLSetProcedureName of hStmt sStmt
92847>>>>>                    If (sArgument <> "") Begin
92849>>>>>                        Send SqlSetArgument  of hStmt 1 sArgument
92850>>>>>                    End
92850>>>>>>
92850>>>>>                    Send SQLCall of hStmt
92851>>>>>
92851>>>>>                    Get SqlReturnValue       of hStmt to iRetval
92852>>>>>                    If (iRetval = 0) Begin
92854>>>>>                        Repeat
92854>>>>>>
92854>>>>>                            Get SQLFetch of hStmt to iFetchResult
92855>>>>>                            If (iFetchResult <> 0) Begin
92857>>>>>                                Get SQLColumnValue of hStmt 1 to sValue
92858>>>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
92859>>>>>                            End
92859>>>>>>
92859>>>>>                        Until (iFetchResult = 0)
92861>>>>>                        Send SQLClose of hStmt
92862>>>>>                    End
92862>>>>>>
92862>>>>>                End
92862>>>>>>
92862>>>>>                Send SQLDisconnect of hoSQLConnect
92863>>>>>            End
92863>>>>>>
92863>>>>>        End
92863>>>>>>
92863>>>>>
92863>>>>>        Function_Return sReturnArray
92864>>>>>    End_Function
92865>>>>>
92865>>>>>    // * Dummy function for the Studio's Code Explorer *
92865>>>>>    Function SQL_ENUMERATION_FUNCTIONS Returns Boolean
92867>>>>>        Function_Return False
92868>>>>>    End_Function
92869>>>>>
92869>>>>>    // Enumerate SQL Servers.
92869>>>>>    // Pass a driver id. Returns a string array.
92869>>>>>    // The iDataSourceType (iDatSrcType) parameter is optional and is for the ODBC driver only.
92869>>>>>    // Note: Returns servers for MSSQLDRV; else data-sources on the machine.
92869>>>>>    Function SqlUtilEnumerateServers String sDriverID Integer iDatSrcType Returns String[]
92871>>>>>        String[] sReturnArray
92872>>>>>        Handle hoSQLHandler
92872>>>>>        String sServer
92872>>>>>        Integer iCount iNumItems iDataSourceType
92872>>>>>
92872>>>>>        If (num_arguments > 1) Begin
92874>>>>>            Move iDatSrcType to iDataSourceType
92875>>>>>        End
92875>>>>>>
92875>>>>>
92875>>>>>        Case Begin
92875>>>>>            Case (sDriverID = MSSQLDRV_ID)
92877>>>>>                Get phoMSSQLHandler to hoSQLHandler
92878>>>>>                // Not sure why, but this doesn't seem to work with the updated DAW MSSQLDRV driver.
92878>>>>>//                #IFNDEF get_ComparetConnectionById
92878>>>>>//                    Get EnumerateServers of hoSQLHandler to iNumItems
92878>>>>>//                #ELSE
92878>>>>>//                    Get EnumerateServersLocal of hoSQLHandler to iNumItems
92878>>>>>//                    If (iNumItems = 0) Begin
92878>>>>>                        Get EnumerateServers of hoSQLHandler to iNumItems
92879>>>>>//                    End
92879>>>>>//                #ENDIF
92879>>>>>                For iCount from 0 to (iNumItems - 1)
92885>>>>>>
92885>>>>>                    Get String_Value of hoSQLHandler item iCount to sServer
92886>>>>>                    Move (Trim(sServer)) to sReturnArray[iCount]
92887>>>>>                Loop
92888>>>>>>
92888>>>>>                Case Break
92889>>>>>
92889>>>>>            Case (sDriverID = DB2_DRV_ID)
92892>>>>>                Get phoDB2SQLHandler to hoSQLHandler
92893>>>>>                Send SeedDataSources of hoSQLHandler
92894>>>>>                Move 0 to iCount
92895>>>>>                Repeat
92895>>>>>>
92895>>>>>                    Get DataSources of hoSQLHandler to sServer
92896>>>>>                    If (sServer <> "") Begin
92898>>>>>                        Move (Replace(",", sServer, "")) to sServer
92899>>>>>                        Move sServer to sReturnArray[iCount]
92900>>>>>                    End
92900>>>>>>
92900>>>>>                    Increment iCount
92901>>>>>                Until (sServer = "")
92903>>>>>                Case Break
92904>>>>>
92904>>>>>            Case (sDriverID = ODBC_DRV_ID)
92907>>>>>                Get phoODBCSQLHandler to hoSQLHandler
92908>>>>>                Set DataSourceType of hoSQLHandler to iDataSourceType
92909>>>>>                Move 0 to iCount
92910>>>>>                Repeat
92910>>>>>>
92910>>>>>                    Get DataSources of hoSQLHandler to sServer
92911>>>>>                    If (sServer <> "") Begin
92913>>>>>                        Move (Replace(",", sServer, ", ")) to sServer
92914>>>>>                        Move sServer to sReturnArray[iCount]
92915>>>>>                    End
92915>>>>>>
92915>>>>>                    Increment iCount
92916>>>>>                Until (sServer = "")
92918>>>>>                Case Break
92919>>>>>
92919>>>>>            Case (sDriverID = SQLFLEX)
92922>>>>>                Get _MertechEnumerateSQLFlexServers to sReturnArray
92923>>>>>                Case Break
92924>>>>>
92924>>>>>            Case (sDriverID = ORAFLEX)
92927>>>>>                Get _MertechEnumerateORAFLEXServers to sReturnArray
92928>>>>>                Case Break
92929>>>>>
92929>>>>>            // There appearantly is no way to enumerate servers for this backend.
92929>>>>>            Case (sDriverID = MDSPgSQL)
92932>>>>>                Move "localhost" to sReturnArray[0]
92933>>>>>                Case Break
92934>>>>>
92934>>>>>            // There appearantly is no way to enumerate servers for this backend.
92934>>>>>            Case (sDriverID = MDSMySQL)
92937>>>>>                Move "localhost" to sReturnArray[0]
92938>>>>>                Case Break
92939>>>>>
92939>>>>>            Case Else
92939>>>>>                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateServers function"
92940>>>>>>
92940>>>>>        Case End
92940>>>>>
92940>>>>>        Function_Return sReturnArray
92941>>>>>    End_Function
92942>>>>>
92942>>>>>    // Returns all databases as a string array for the passed driver id.
92942>>>>>    Function SqlUtilEnumerateDatabases String sDriverID Returns String[]
92944>>>>>        String[] sReturnArray
92945>>>>>        Boolean bOK
92945>>>>>
92945>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
92946>>>>>        If (bOK = False) Begin
92948>>>>>            Function_Return sReturnArray
92949>>>>>        End
92949>>>>>>
92949>>>>>
92949>>>>>        Case Begin
92949>>>>>            Case (sDriverID = MSSQLDRV_ID)
92951>>>>>                Get _SqlDatabasesArrayMSSQL to sReturnArray
92952>>>>>                Case Break
92953>>>>>            Case (sDriverID = DB2_DRV_ID)
92956>>>>>                Get _SqlDatabasesArrayDB2 to sReturnArray
92957>>>>>                Case Break
92958>>>>>
92958>>>>>            // Enumeration of ODBC databases should be irrelevant as the database
92958>>>>>            // should have been specified when the ODBC source was setup with the ODBC manager.
92958>>>>>            Case (sDriverID = ODBC_DRV_ID)
92961>>>>>                Case Break
92962>>>>>
92962>>>>>            Case (sDriverID = SQLFLEX)
92965>>>>>                Get SqlProcedureArrayMertech "sp_databases" "" to sReturnArray
92966>>>>>                Case Break
92967>>>>>
92967>>>>>            Case (sDriverID = MDSPgSQL)
92970>>>>>                Get SqlEnumerateEsqlMertech "SELECT datname FROM pg_database" to sReturnArray
92971>>>>>                Case Break
92972>>>>>
92972>>>>>            Case (sDriverID = MDSMySQL)
92975>>>>>                Get SqlEnumerateEsqlMertech "show databases" to sReturnArray
92976>>>>>                Case Break
92977>>>>>
92977>>>>>            Case (sDriverID = ORAFLEX)
92980>>>>>                Get SqlEnumerateEsqlMertech "SELECT NAME FROM v$database" to sReturnArray
92981>>>>>                Case Break
92982>>>>>
92982>>>>>            Case Else
92982>>>>>                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateDatabases function"
92983>>>>>>
92983>>>>>        Case End
92983>>>>>
92983>>>>>        Function_Return sReturnArray
92984>>>>>    End_Function
92985>>>>>
92985>>>>>    // Returns all table spaces as a string array for the passed driver id.
92985>>>>>    Function SqlUtilEnumerateTableSpaces String sDriverID Returns String[]
92987>>>>>        String[] sReturnArray
92988>>>>>        Boolean bOK
92988>>>>>
92988>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
92989>>>>>        If (bOK = False) Begin
92991>>>>>            Function_Return sReturnArray
92992>>>>>        End
92992>>>>>>
92992>>>>>
92992>>>>>        Case Begin
92992>>>>>            Case (sDriverID = DB2_DRV_ID)
92994>>>>>                Get SqlEnumerateEsqlDAW "select tablespace_name from dba_tablespaces" 1 to sReturnArray
92995>>>>>                Case Break
92996>>>>>
92996>>>>>            Case (sDriverID = MDSPgSQL)
92999>>>>>                Get SqlEnumerateEsqlMertech "SELECT spcname FROM pg_tablespace" 1 to sReturnArray
93000>>>>>                Case Break
93001>>>>>
93001>>>>>            Case (sDriverID = ORAFLEX)
93004>>>>>                Get SqlEnumerateEsqlMertech "SELECT TABLESPACE_NAME FROM USER_TABLESPACES" 1 to sReturnArray
93005>>>>>                Case Break
93006>>>>>
93006>>>>>            Case Else
93006>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateTableSpaces function."
93007>>>>>>
93007>>>>>                Case Break
93008>>>>>        Case End
93008>>>>>
93008>>>>>        Function_Return sReturnArray
93009>>>>>    End_Function
93010>>>>>
93010>>>>>    // Returns all schemas as a string array for the passed driver id.
93010>>>>>    Function SqlUtilEnumerateSchemas String sDriverID Returns String[]
93012>>>>>        String[] sReturnArray
93013>>>>>        Boolean bOK
93013>>>>>
93013>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
93014>>>>>        If (bOK = False) Begin
93016>>>>>            Function_Return sReturnArray
93017>>>>>        End
93017>>>>>>
93017>>>>>
93017>>>>>        Case Begin
93017>>>>>            Case (sDriverID = DB2_DRV_ID)
93019>>>>>                Get SqlEnumerateEsqlDAW "select schemaname from syscat.schemata" 1 to sReturnArray
93020>>>>>                Case Break
93021>>>>>
93021>>>>>            Case (sDriverID = MDSPgSQL)
93024>>>>>                Get SqlEnumerateEsqlMertech "select schema_name from information_schema.schemata" 1 to sReturnArray
93025>>>>>                Case Break
93026>>>>>
93026>>>>>            Case (sDriverID = ORAFLEX)
93029>>>>>                Get SqlEnumerateEsqlMertech "SELECT username from dba_users WHERE default_tablespace not in ('SYSTEM','SYSAUX')" 1 to sReturnArray
93030>>>>>                Case Break
93031>>>>>
93031>>>>>            Case Else
93031>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateSchemas function."
93032>>>>>>
93032>>>>>                Case Break
93033>>>>>        Case End
93033>>>>>
93033>>>>>        Function_Return sReturnArray
93034>>>>>    End_Function
93035>>>>>
93035>>>>>    // Returns a string array with all tables for the current database.
93035>>>>>    Function SqlUtilEnumerateTables String sDriverID Returns String[]
93037>>>>>        String[] sReturnArray sArray
93039>>>>>        String sDatabase sConnectionString sSelect sSchema
93039>>>>>        Integer iSize iCount
93039>>>>>        Boolean bOK
93039>>>>>
93039>>>>>        If (sDriverID = DATAFLEX_ID) Begin
93041>>>>>            Function_Return sArray
93042>>>>>        End
93042>>>>>>
93042>>>>>
93042>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
93043>>>>>        If (bOK = False) Begin
93045>>>>>            Function_Return sReturnArray
93046>>>>>        End
93046>>>>>>
93046>>>>>
93046>>>>>        Get psConnectionString to sConnectionString
93047>>>>>        Get psDatabase to sDatabase
93048>>>>>        Get psSchema   to sSchema
93049>>>>>
93049>>>>>        Case Begin
93049>>>>>            Case (sDriverID = MSSQLDRV_ID)
93051>>>>>                Get _SqlTableArrayDAW to sReturnArray
93052>>>>>                Case Break
93053>>>>>
93053>>>>>            Case (sDriverID = DB2_DRV_ID)
93056>>>>>                Get _SqlTableArrayDAW to sReturnArray
93057>>>>>                Case Break
93058>>>>>
93058>>>>>            Case (sDriverID = ODBC_DRV_ID)
93061>>>>>                Get _SqlTableArrayDAW to sReturnArray
93062>>>>>                Case Break
93063>>>>>
93063>>>>>            Case (sDriverID = SQLFLEX)
93066>>>>>                Move ("SELECT TABLE_NAME FROM" * sDatabase + ".INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE != 'VIEW'") to sSelect
93067>>>>>                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
93068>>>>>                Case Break
93069>>>>>
93069>>>>>            Case (sDriverID = MDSMySQL)
93072>>>>>                Move ("SELECT TABLE_NAME from INFORMATION_SCHEMA.TABLES where TABLE_SCHEMA = '" + sDatabase + "' and TABLE_TYPE = 'BASE TABLE' order by TABLE_NAME") to sSelect
93073>>>>>                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
93074>>>>>                Case Break
93075>>>>>
93075>>>>>            Case (sDriverID = MDSPgSQL)
93078>>>>>                Move "select tablename, schemaname from pg_catalog.pg_tables order by tablename"  to sSelect
93079>>>>>                Get SqlEnumerateEsqlMertech sSelect "" to sReturnArray
93080>>>>>                Case Break
93081>>>>>
93081>>>>>            Case (sDriverID = ORAFLEX)
93084>>>>>                Move "SELECT table_name from user_tables" to sSelect
93085>>>>>                Get SqlEnumerateEsqlMertech sSelect to sArray
93086>>>>>                Move (SizeOfArray(sArray)) to iSize
93087>>>>>                Decrement iSize
93088>>>>>                For iCount from 0 to iSize
93094>>>>>>
93094>>>>>                    If (not(sArray[iCount] contains "$")) Begin
93096>>>>>                        Move sArray[iCount] to sReturnArray[SizeOfArray(sReturnArray)]
93097>>>>>                    End
93097>>>>>>
93097>>>>>                Loop
93098>>>>>>
93098>>>>>                Case Break
93099>>>>>
93099>>>>>            Case Else
93099>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateTables function."
93100>>>>>>
93100>>>>>                Case Break
93101>>>>>        Case End
93101>>>>>
93101>>>>>        Function_Return sReturnArray
93102>>>>>    End_Function
93103>>>>>
93103>>>>>    // Returns a string array with all table columns/fields for the passed table handle and driver id.
93103>>>>>    Function SqlUtilEnumerateColumns String sDriverID String sTableName Returns String[]
93105>>>>>        String[] sReturnArray
93106>>>>>        String sConnectionString sSelect sSchema
93106>>>>>        Boolean bOK
93106>>>>>
93106>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
93107>>>>>        If (bOK = False) Begin
93109>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
93110>>>>>>
93110>>>>>            Function_Return sReturnArray
93111>>>>>        End
93111>>>>>>
93111>>>>>
93111>>>>>        Get psConnectionString to sConnectionString
93112>>>>>        Get psSchema to sSchema
93113>>>>>
93113>>>>>        Case Begin
93113>>>>>            Case (sDriverID = MSSQLDRV_ID)
93115>>>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
93116>>>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
93117>>>>>                Case Break
93118>>>>>
93118>>>>>            Case (sDriverID = DB2_DRV_ID)
93121>>>>>                Move ("SELECT colname from syscat.columns WHERE tabschema = '" + sSchema + "'" * "AND tabname = '" + sTableName + "'") to sSelect
93122>>>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
93123>>>>>                Case Break
93124>>>>>
93124>>>>>            Case (sDriverID = SQLFLEX)
93127>>>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
93128>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
93129>>>>>                Case Break
93130>>>>>
93130>>>>>            Case (sDriverID = MDSMySQL)
93133>>>>>                Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
93134>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
93135>>>>>                Case Break
93136>>>>>
93136>>>>>            Case (sDriverID = MDSPgSQL)
93139>>>>>                Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
93140>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
93141>>>>>                Case Break
93142>>>>>
93142>>>>>            Case (sDriverID = ORAFLEX)
93145>>>>>                Move ("SELECT column_name from user_tab_cols WHERE table_name = '" + sTableName + "'") to sSelect
93146>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
93147>>>>>                Case Break
93148>>>>>
93148>>>>>            Case Else
93148>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateColumns function."
93149>>>>>>
93149>>>>>                Case Break
93150>>>>>        Case End
93150>>>>>
93150>>>>>        Function_Return sReturnArray
93151>>>>>    End_Function
93152>>>>>
93152>>>>>
93152>>>>>    // Returns a string array with all table indexes for the passed table handle and driver id.
93152>>>>>    Function SqlUtilEnumerateIndexes String sTableName String sDriverID Returns String[]
93154>>>>>        String[] sReturnArray sReturnArray2
93156>>>>>        String sConnectionString sSelect sSchema
93156>>>>>        Boolean bOK
93156>>>>>        Integer iCount iSize
93156>>>>>
93156>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
93157>>>>>        If (bOK = False) Begin
93159>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
93160>>>>>>
93160>>>>>            Function_Return sReturnArray
93161>>>>>        End
93161>>>>>>
93161>>>>>
93161>>>>>        Get psConnectionString to sConnectionString
93162>>>>>        Get psSchema to sSchema
93163>>>>>
93163>>>>>        Case Begin
93163>>>>>            Case (sDriverID = MSSQLDRV_ID)
93165>>>>>                Move ("select * from sys.indexes where object_id = (select object_id from sys.objects where name = '" + sTableName + "')") to sSelect
93166>>>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
93167>>>>>                Case Break
93168>>>>>
93168>>>>>            Case (sDriverID = DB2_DRV_ID)
93171>>>>>                Error "Not implemented yet! The select statement has not been finalized."
93172>>>>>>
93172>>>>>//                Move () to sSelect
93172>>>>>//                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
93172>>>>>                Case Break
93173>>>>>
93173>>>>>            Case (sDriverID = SQLFLEX)
93176>>>>>                Error "Not implemented yet! The select statement has not been finalized."
93177>>>>>>
93177>>>>>//                Move () to sSelect
93177>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
93177>>>>>                Case Break
93178>>>>>
93178>>>>>            Case (sDriverID = MDSMySQL)
93181>>>>>                Error "Not implemented yet! The select statement has not been finalized."
93182>>>>>>
93182>>>>>//                Move () to sSelect
93182>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
93182>>>>>                Case Break
93183>>>>>
93183>>>>>            Case (sDriverID = MDSPgSQL)
93186>>>>>                Error "Not implemented yet! The select statement has not been finalized."
93187>>>>>>
93187>>>>>//                Move () to sSelect
93187>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
93187>>>>>                Case Break
93188>>>>>
93188>>>>>            Case (sDriverID = ORAFLEX)
93191>>>>>                Error "Not implemented yet! The select statement has not been finalized."
93192>>>>>>
93192>>>>>//                Move () to sSelect
93192>>>>>//                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
93192>>>>>                Case Break
93193>>>>>
93193>>>>>            Case Else
93193>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateIndexes function."
93194>>>>>>
93194>>>>>                Case Break
93195>>>>>        Case End
93195>>>>>
93195>>>>>        Move (SizeOfArray(sReturnArray)) to iSize
93196>>>>>        Decrement iSize
93197>>>>>        For iCount from 0 to iSize
93203>>>>>>
93203>>>>>            If (Trim(sReturnArray[iCount]) <> "") Begin
93205>>>>>                Move sReturnArray[iCount] to sReturnArray2[SizeOfArray(sReturnArray2)]
93206>>>>>            End
93206>>>>>>
93206>>>>>        Loop
93207>>>>>>
93207>>>>>
93207>>>>>        Function_Return sReturnArray2
93208>>>>>    End_Function
93209>>>>>
93209>>>>>    // Returns a string array with all table names the passed table handle has relation ships with.
93209>>>>>    // The format of the array is "TableName.FieldName"
93209>>>>>    Function SqlUtilEnumerateRelations String sTableName String sDriverID Returns tSQLRelation[]
93211>>>>>        String[] sFileNameArray sFieldNameArray
93213>>>>>        tSQLRelation[] sRelationsArray
93213>>>>>        tSQLRelation[] sRelationsArray
93214>>>>>        String sConnectionString sSelect sSchema sFileName sFieldName
93214>>>>>        Boolean bOK
93214>>>>>        Integer iCount iSize iLength
93214>>>>>
93214>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
93215>>>>>        If (bOK = False) Begin
93217>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
93218>>>>>>
93218>>>>>            Function_Return sRelationsArray
93219>>>>>        End
93219>>>>>>
93219>>>>>
93219>>>>>        Get psConnectionString to sConnectionString
93220>>>>>        Get psSchema to sSchema
93221>>>>>
93221>>>>>        Case Begin
93221>>>>>            Case (sDriverID = MSSQLDRV_ID)
93223>>>>>                Move ("SELECT object_name(parent_object_id), object_name(referenced_object_id), name from sys.foreign_keys WHERE parent_object_id = object_id( '" + sTableName + "')") to sSelect
93224>>>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sFileNameArray
93225>>>>>                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
93226>>>>>                Case Break
93227>>>>>
93227>>>>>            Case (sDriverID = DB2_DRV_ID)
93230>>>>>                Error "Not implemented yet! The select statement has not been finalized."
93231>>>>>>
93231>>>>>//                Move () to sSelect
93231>>>>>//                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
93231>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
93231>>>>>                Case Break
93232>>>>>
93232>>>>>            Case (sDriverID = SQLFLEX)
93235>>>>>                Error "Not implemented yet! The select statement has not been finalized."
93236>>>>>>
93236>>>>>//                Move () to sSelect
93236>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
93236>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
93236>>>>>                Case Break
93237>>>>>
93237>>>>>            Case (sDriverID = MDSMySQL)
93240>>>>>                Error "Not implemented yet! The select statement has not been finalized."
93241>>>>>>
93241>>>>>//                Move () to sSelect
93241>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
93241>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
93241>>>>>                Case Break
93242>>>>>
93242>>>>>            Case (sDriverID = MDSPgSQL)
93245>>>>>                Error "Not implemented yet! The select statement has not been finalized."
93246>>>>>>
93246>>>>>//                Move () to sSelect
93246>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
93246>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
93246>>>>>                Case Break
93247>>>>>
93247>>>>>            Case (sDriverID = ORAFLEX)
93250>>>>>                Error "Not implemented yet! The select statement has not been finalized."
93251>>>>>>
93251>>>>>//                Move () to sSelect
93251>>>>>//                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
93251>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
93251>>>>>                Case Break
93252>>>>>
93252>>>>>            Case Else
93252>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to the SqlUtilEnumerateRelations function."
93253>>>>>>
93253>>>>>                Case Break
93254>>>>>        Case End
93254>>>>>
93254>>>>>        Move (Length(sTableName)) to iLength
93255>>>>>        Move (iLength + 4)        to iLength // The related to field key has the format "FK_TableName + FieldName"
93256>>>>>        Move (SizeOfArray(sFileNameArray)) to iSize
93257>>>>>        Decrement iSize
93258>>>>>        For iCount from 0 to iSize
93264>>>>>>
93264>>>>>            If (Trim(sFileNameArray[iCount]) <> "") Begin
93266>>>>>                Move sFileNameArray[iCount]         to sFileName
93267>>>>>                Move sFieldNameArray[iCount]        to sFieldName
93268>>>>>                Move (Mid(sFieldName, 99, iLength)) to sFieldName
93269>>>>>                Move sFileName  to sRelationsArray[iCount].sFileName
93270>>>>>                Move sFieldName to sRelationsArray[iCount].sFieldName
93271>>>>>            End
93271>>>>>>
93271>>>>>        Loop
93272>>>>>>
93272>>>>>
93272>>>>>        Function_Return sRelationsArray
93273>>>>>    End_Function
93274>>>>>
93274>>>>>    Function SqlUtilEnumerateLoggedInUsers String sDriverID String sDatabase Returns tSQLLoggedInUser[]
93276>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
93276>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
93277>>>>>        String[] sUsers sPrograms
93279>>>>>        String sSelect
93279>>>>>        Integer iSize iCount
93279>>>>>
93279>>>>>        Case Begin
93279>>>>>            Case (sDriverID = MSSQLDRV_ID)
93281>>>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
93282>>>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sUsers
93283>>>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sPrograms
93284>>>>>                Case Break
93285>>>>>            Case (sDriverID = SQLFLEX)
93288>>>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
93289>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sUsers
93290>>>>>                Get SqlEnumerateEsqlMertech sSelect 2 to sPrograms
93291>>>>>                Case Break
93292>>>>>            Case Else
93292>>>>>                Error DFERR_PROGRAM ("Not implemented yet for this driver (" + sDriverID + ")")
93293>>>>>>
93293>>>>>        Case End
93293>>>>>
93293>>>>>        Move (SizeOfArray(sUsers)) to iSize
93294>>>>>        Decrement iSize
93295>>>>>        For iCount from 0 to iSize
93301>>>>>>
93301>>>>>            Move sUsers[iCount]    to SQLLoggedInUser[iCount].sUser
93302>>>>>            Move sPrograms[iCount] to SQLLoggedInUser[iCount].sProgram
93303>>>>>        Loop
93304>>>>>>
93304>>>>>
93304>>>>>        Function_Return SQLLoggedInUser
93305>>>>>    End_Function
93306>>>>>
93306>>>>>    // Returns an array with all ".int" files for the passed sDataPath, _except_ for the driver .int files;
93306>>>>>    // "MSSQLDRV.int", "DB2_DRV.int" & "ODBC_DRV.int".
93306>>>>>    Function SqlUtilEnumerateIntFiles String sDataPath Returns String[]
93308>>>>>        String[] sFilesData
93309>>>>>        Boolean bExists
93309>>>>>        Integer iCh
93309>>>>>        String sFileName sExt
93309>>>>>
93309>>>>>        Get vFolderExists sDataPath to bExists
93310>>>>>        If (bExists = True) Begin
93312>>>>>            Move (ToANSI(Trim(sDataPath))) to sDataPath
93313>>>>>            Move ("dir:" + sDataPath)      to sDataPath
93314>>>>>            Get Seq_New_Channel to iCh  // get free channel for input
93315>>>>>            Direct_Input channel iCh sDataPath
93317>>>>>                Repeat
93317>>>>>>
93317>>>>>                    Readln channel iCh sFileName
93319>>>>>                    Get ParseFileExtension sFileName to sExt
93320>>>>>                    If (Uppercase(sExt) = "INT") Begin
93322>>>>>                        If (not(Uppercase(sFileName) contains "MSSQLDRV" and Uppercase(sFileName) contains "DB2_DRV" and Uppercase(sFileName) contains "ODBC_DRV")) Begin
93324>>>>>                            Move sFileName to sFilesData[SizeOfArray(sFilesData)]
93325>>>>>                        End
93325>>>>>>
93325>>>>>                    End
93325>>>>>>
93325>>>>>                Until (SeqEof = True)
93327>>>>>            Close_Input channel iCh
93329>>>>>        End
93329>>>>>>
93329>>>>>        Function_Return sFilesData
93330>>>>>    End_Function
93331>>>>>
93331>>>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
93331>>>>>    // for DAW drivers.
93331>>>>>    // Returns: A string array.
93331>>>>>    Function SqlEnumerateEsqlDAW String sStmt Integer iColumn Returns String[]
93333>>>>>        String[] sReturnArray
93334>>>>>        String sValue sPrevious
93334>>>>>        Handle hoSQLHandler hoSQLConnect hstmt
93334>>>>>        Integer iFetchResult iRows
93334>>>>>        tSQLConnection SQLConnection
93334>>>>>        tSQLConnection SQLConnection
93334>>>>>
93334>>>>>        Get phoSQLManager to hoSQLHandler
93335>>>>>
93335>>>>>        If (hoSQLHandler <> 0) Begin
93337>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
93338>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
93339>>>>>
93339>>>>>            If (hoSQLConnect <> 0) Begin
93341>>>>>                Get SQLOpen of hoSQLConnect to hstmt
93342>>>>>                If (hstmt <> 0) Begin
93344>>>>>                    Send SqlExecDirect of hstmt sStmt
93345>>>>>                    Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
93346>>>>>                    Repeat
93346>>>>>>
93346>>>>>                        Get SQLFetch of hstmt to iFetchResult
93347>>>>>                        If (iFetchResult <> 0) Begin
93349>>>>>                            Get SQLColumnValue of hstmt iColumn to sValue
93350>>>>>                            If (sValue <> sPrevious) Begin
93352>>>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
93353>>>>>                            End
93353>>>>>>
93353>>>>>                            Move sValue to sPrevious
93354>>>>>                        End
93354>>>>>>
93354>>>>>                    Until (iFetchResult = 0)
93356>>>>>                    Send SQLClose of hstmt
93357>>>>>                End
93357>>>>>>
93357>>>>>                Send SQLDisconnect of hoSQLConnect
93358>>>>>            End
93358>>>>>>
93358>>>>>        End
93358>>>>>>
93358>>>>>
93358>>>>>        Function_Return sReturnArray
93359>>>>>    End_Function
93360>>>>>
93360>>>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
93360>>>>>    // for Mertech drivers.
93360>>>>>    // Returns: A string array.
93360>>>>>    Function SqlEnumerateEsqlMertech String sStmt Returns String[]
93362>>>>>        String[] sReturnArray
93363>>>>>        String sValue sUserID sPassword
93363>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
93363>>>>>        Integer iFetchResult iRows
93363>>>>>        tSQLConnection SQLConnection
93363>>>>>        tSQLConnection SQLConnection
93363>>>>>
93363>>>>>        Get _MertechSQLManagerHandle to hoSQLHandler
93364>>>>>
93364>>>>>        If (hoSQLHandler <> 0) Begin
93366>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
93367>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
93368>>>>>
93368>>>>>            If (hoSQLConnect <> 0) Begin
93370>>>>>                Get SQLOpen of hoSQLConnect to hStmt
93371>>>>>                If (hStmt <> 0) Begin
93373>>>>>                    Send SqlExecDirect of hStmt sStmt
93374>>>>>                    Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_ROWCOUNT to iRows
93375>>>>>                    Repeat
93375>>>>>>
93375>>>>>                        Get SQLFetch of hStmt to iFetchResult
93376>>>>>                        If (iFetchResult <> 0) Begin
93378>>>>>                            Get SQLColumnValue of hStmt 1 to sValue
93379>>>>>                            Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
93380>>>>>                        End
93380>>>>>>
93380>>>>>                    Until (iFetchResult = 0)
93382>>>>>                    Send SQLClose of hStmt
93383>>>>>                End
93383>>>>>>
93383>>>>>                Send SQLDisconnect of hoSQLConnect
93384>>>>>            End
93384>>>>>>
93384>>>>>        End
93384>>>>>>
93384>>>>>
93384>>>>>        Function_Return sReturnArray
93385>>>>>    End_Function
93386>>>>>
93386>>>>>    // * Dummy function for the Studio's Code Explorer *
93386>>>>>    Function PRIVATE_SQL_SUB_FUNCTIONS Returns Boolean
93388>>>>>        Function_Return False
93389>>>>>    End_Function
93390>>>>>
93390>>>>>    // Returns the index for the passed sTableName
93390>>>>>    // Returns >= 0 if successful. It is e.g. needed to get the SchemaName for a table.
93390>>>>>    Function _SqlUtilEnumerateTableIndex String sTableName String sDriverID Returns Integer
93392>>>>>        Integer iIndex iSize iCount
93392>>>>>        String[] sTablesArray
93393>>>>>        String sVal sConnectionString
93393>>>>>
93393>>>>>        Move -1 to iIndex
93394>>>>>        Get psConnectionString to sConnectionString
93395>>>>>        Get SqlUtilEnumerateTables sDriverID to sTablesArray
93396>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
93397>>>>>        Decrement iSize
93398>>>>>        For iCount from 0 to iSize
93404>>>>>>
93404>>>>>            Move sTablesArray[iCount] to sVal
93405>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
93407>>>>>                Move iCount to iIndex // We found it!
93408>>>>>                Move iSize to iCount  // End the loop
93409>>>>>            End
93409>>>>>>
93409>>>>>        Loop
93410>>>>>>
93410>>>>>
93410>>>>>        Function_Return iIndex
93411>>>>>    End_Function
93412>>>>>
93412>>>>>    // Helper function that builds a string like;
93412>>>>>    // "SELECT name from [Master].[sys].[databases] where name"
93412>>>>>    Function _SqlSelectFromWhereName Returns String
93414>>>>>        String sRetval sSelect sName sFrom sMaster sSys sDatabases sWhere sDBO
93414>>>>>
93414>>>>>        Get _SqlFindKeyWord CI_SQLSelect       to sSelect
93415>>>>>        Get _SqlFindKeyWord CI_SQLName         to sName
93416>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBO
93417>>>>>        Get _SqlFindKeyWord CI_SQLFrom         to sFrom
93418>>>>>        Get _SqlFindKeyWord CI_SQLMaster       to sMaster
93419>>>>>        Get _SqlFindKeyWord CI_SQLSys          to sSys
93420>>>>>        Get _SqlFindKeyWord CI_SQLDatabases    to sDatabases
93421>>>>>        Get _SqlFindKeyWord CI_SQLWhere        to sWhere
93422>>>>>        Move (sSelect * sName * sFrom * "[" + sMaster + "].[" + sDBO + "].[" + sSys + sDatabases + "]" * sWhere * sName) to sRetval
93423>>>>>        Function_Return sRetval
93424>>>>>    End_Function
93425>>>>>
93425>>>>>    // Helper function to create a SQL statement like;
93425>>>>>    // "SELECT * FROM SYS.INDEXES WHERE NAME = MyIndexName AND OBJECT_ID = OBJECT_ID([MySchmaName].[MyTableName])"
93425>>>>>    // Used for checking if an index exists.
93425>>>>>    Function _SqlQueryIfIndexExists String sSchemaName String sTableName String sIndexName Returns String
93427>>>>>        String sRetval sSelect sFrom sSysIndexes sWhere sObjectID sAnd sName
93427>>>>>
93427>>>>>        Get _SqlFindKeyWord CI_SQLSelect to sSelect
93428>>>>>        Get _SqlFindKeyWord CI_SQLFrom to sFrom
93429>>>>>        Get _SqlFindKeyWord CI_SQLSysIndexes to sSysIndexes
93430>>>>>        Get _SqlFindKeyWord CI_SQLWhere to sWhere
93431>>>>>        Get _SqlFindKeyWord CI_SQLObjectID to sObjectID
93432>>>>>        Get _SqlFindKeyWord CI_SQLAND to sAnd
93433>>>>>        Get _SqlFindKeyWord CI_SQLName to sName
93434>>>>>
93434>>>>>        Move (sSelect * String("*") * sFrom * sSysIndexes * sWhere * sName * "=" * sIndexName * sAnd * sObjectID * "=([" + sSchemaName + "].[" + sTableName + "])") to sRetval
93435>>>>>
93435>>>>>        Function_Return sRetval
93436>>>>>    End_Function
93437>>>>>
93437>>>>>    // Formats a columns iLenght & iDecimal parameters as SQL expects them in a string.
93437>>>>>    // E.g. (4,2), where 4 is the iLength and 2 the iDecimals param.
93437>>>>>    Function _SqlFormatLengthAndDecimalAsString Integer iLength Integer iDecimals Returns String
93439>>>>>        String sRetval
93439>>>>>        If (iLength <> 0) Begin
93441>>>>>            Move ("(" + String(iLength)) to sRetval
93442>>>>>            If (iDecimals <> 0) Begin
93444>>>>>                Move (sRetval + "," + String(iDecimals)) to sRetval
93445>>>>>            End
93445>>>>>>
93445>>>>>            Move (sRetval + ")") to sRetval
93446>>>>>        End
93446>>>>>>
93446>>>>>        Function_Return sRetval
93447>>>>>    End_Function
93448>>>>>
93448>>>>>    Procedure _SqlColumnInfo Handle hoStmt
93450>>>>>        Integer i iCols iItem
93450>>>>>        tSqlColumnNew[] aQueryColumns
93450>>>>>        tSqlColumnNew[] aQueryColumns
93451>>>>>
93451>>>>>        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
93452>>>>>        For i from 1 to iCols
93458>>>>>>
93458>>>>>            Move (SizeOfArray(aQueryColumns)) to iItem
93459>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASECOLUMNNAME to aQueryColumns[iItem].sBaseColumnName
93460>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASETABLENAME  to aQueryColumns[iItem].sBaseTableName
93461>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_LABEL          to aQueryColumns[iItem].sLabel
93462>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SQLTYPE        to aQueryColumns[iItem].iSqlType
93463>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_DFTYPE         to aQueryColumns[iItem].iDFType
93464>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SIZE           to aQueryColumns[iItem].iSize
93465>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_PRECISION      to aQueryColumns[iItem].iPrecision
93466>>>>>        Loop
93467>>>>>>
93467>>>>>        Set piColumns to iCols
93468>>>>>        Set paQueryColumns to aQueryColumns
93469>>>>>    End_Procedure
93470>>>>>
93470>>>>>    // Checks that the passed sDriverID is defined.
93470>>>>>    // Also checks if the driver has been loaded; else it gets loaded.
93470>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
93472>>>>>        Boolean bOK
93472>>>>>        Integer iDriver
93472>>>>>
93472>>>>>        If (sDriverID = DATAFLEX_ID) Begin
93474>>>>>            Function_Return False
93475>>>>>        End
93475>>>>>>
93475>>>>>
93475>>>>>        Get IsDAWSQLDriver sDriverID to bOK
93476>>>>>
93476>>>>>        If (bOK = False) Begin
93478>>>>>            Get IsMertechDriver sDriverID to bOK
93479>>>>>        End
93479>>>>>>
93479>>>>>
93479>>>>>        If (bOK = False) Begin
93481>>>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV, DB2_DRV, ODBC_DRV, SQLFLEX, ORAFLEX, MDSPgSQL or MDSMySQL"
93482>>>>>>
93482>>>>>            Function_Return False
93483>>>>>        End
93483>>>>>>
93483>>>>>
93483>>>>>        Get DriverIndex sDriverID to iDriver
93484>>>>>        If (iDriver = 0) Begin
93486>>>>>            Load_Driver sDriverID
93487>>>>>        End
93487>>>>>>
93487>>>>>
93487>>>>>        Function_Return True
93488>>>>>    End_Function
93489>>>>>
93489>>>>>    // Checks that the length parameter has been passed correctly.
93489>>>>>    // This is only of concern for certain SQL data types.
93489>>>>>    Function _SqlCheckLengthParamForDataType Integer iDataType Integer iLen Returns Boolean
93491>>>>>        Integer iLength
93491>>>>>        Boolean bOK bCheckTypeLength
93491>>>>>
93491>>>>>        If (num_arguments > 1) Begin
93493>>>>>            Move iLen to iLength
93494>>>>>        End
93494>>>>>>
93494>>>>>        Move (iDataType = SQL_DECIMAL   or iDataType = SQL_NUMERIC or iDataType = SQL_FLOAT   or iDataType = SQL_INTEGER or;              iDataType = SQL_VARBINARY or iDataType = SQL_BINARY  or iDataType = SQL_VARCHAR or iDataType = SQL_CHAR or;              iDataType = SQL_BIGINT    or iDataType = SQL_REAL) to bCheckTypeLength
93495>>>>>
93495>>>>>        If (bCheckTypeLength = True) Begin
93497>>>>>            Move (iLength > 0) to bOK
93498>>>>>        End
93498>>>>>>
93498>>>>>
93498>>>>>        Function_Return (bOK = True)
93499>>>>>    End_Function
93500>>>>>
93500>>>>>    Function _SqlProperTableName String sTableName Returns String
93502>>>>>        String sVal sSchema sDriverID
93502>>>>>        Integer iDbType
93502>>>>>
93502>>>>>        If (Trim(sTableName) = "") Begin
93504>>>>>            Function_Return ""
93505>>>>>        End
93505>>>>>>
93505>>>>>
93505>>>>>        Get psDriverID to sDriverID
93506>>>>>        Get piDbType   to iDbType
93507>>>>>        If (iDbType = EN_dbTypeOracle) Begin
93509>>>>>            Get psUserID to sSchema
93510>>>>>            // Not sure about this uppercasing but it seems like Oracle wants that?
93510>>>>>            Move (Uppercase(sSchema)) to sSchema
93511>>>>>            Move ('"' + sSchema + '"."' + sTableName + '"') to sTableName
93512>>>>>            Function_Return sTableName
93513>>>>>        End
93513>>>>>>
93513>>>>>        If (iDbType = EN_DbTypeMySQL) Begin
93515>>>>>            Get psDatabase to sVal
93516>>>>>            Move (sVal + "." + sTableName) to sTableName
93517>>>>>            Function_Return sTableName
93518>>>>>        End
93518>>>>>>
93518>>>>>        If (iDbType = EN_DbTypePostgre) Begin
93520>>>>>            Move ('"' + sTableName + '"') to sTableName
93521>>>>>            Function_Return sTableName
93522>>>>>        End
93522>>>>>>
93522>>>>>
93522>>>>>        Get psSchema to sSchema
93523>>>>>        If (sSchema = "") Begin
93525>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
93526>>>>>        End
93526>>>>>>
93526>>>>>
93526>>>>>        Move (Uppercase(sTableName)) to sVal
93527>>>>>        If (not(sVal contains (sSchema + "."))) Begin
93529>>>>>            If (iDbType = EN_dbTypeDB2) Begin
93531>>>>>                Move (Lowercase(sSchema) + "." + sTableName) to sTableName
93532>>>>>            End
93532>>>>>>
93532>>>>>            Else Begin
93533>>>>>                Move (sSchema + "." + sTableName) to sTableName
93534>>>>>            End
93534>>>>>>
93534>>>>>        End
93534>>>>>>
93534>>>>>
93534>>>>>        Function_Return sTableName
93535>>>>>    End_Function
93536>>>>>
93536>>>>>    // SQL column names can be case-sensitive. This function is used to check that
93536>>>>>    // the passed sFieldName has the correct spelling.
93536>>>>>    // Used with Embedded SQL statement calls.
93536>>>>>    // If the spelling or fieldname doesn't exist, the return value is "" (blank).
93536>>>>>    Function _SqlFindColumnName String sTableName String sColumnName Returns String
93538>>>>>        String sRetval sValue sDriverID
93538>>>>>        String[] sColumnNamesArray
93539>>>>>        Integer iCount iColumns
93539>>>>>
93539>>>>>        Move "" to sRetval
93540>>>>>        Get psDriverID to sDriverID
93541>>>>>        Get SqlUtilEnumerateColumns sDriverID sTableName to sColumnNamesArray
93542>>>>>        Move (SizeOfArray(sColumnNamesArray)) to iColumns
93543>>>>>        Decrement iColumns
93544>>>>>
93544>>>>>        For iCount from 0 to iColumns
93550>>>>>>
93550>>>>>            Move sColumnNamesArray[iCount] to sValue
93551>>>>>            If (Uppercase(sColumnName) = Uppercase(sValue)) Begin
93553>>>>>                Move sValue to sRetval
93554>>>>>                Move iColumns to iCount // We're done.
93555>>>>>            End
93555>>>>>>
93555>>>>>        Loop
93556>>>>>>
93556>>>>>
93556>>>>>        Function_Return sRetval
93557>>>>>    End_Function
93558>>>>>
93558>>>>>    Function _SqlDatabasesArrayMSSQL Returns String[]
93560>>>>>        String[] sReturnArray
93561>>>>>        Handle hoSQLHandler
93561>>>>>        Integer iCount iSize iItem
93561>>>>>        String sServer sUser sPassword
93561>>>>>        tSQLConnection SQLConnection
93561>>>>>        tSQLConnection SQLConnection
93561>>>>>
93561>>>>>        Get phoMSSQLHandler to hoSQLHandler
93562>>>>>        Send Delete_Data    of hoSQLHandler
93563>>>>>        Get pSQLConnection  of ghoSQLConnectionHandler to SQLConnection
93564>>>>>
93564>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
93565>>>>>        Get EnumerateDatabases of hoSQLHandler SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to iSize
93566>>>>>        Decrement iSize
93567>>>>>
93567>>>>>        For iCount from 0 to iSize
93573>>>>>>
93573>>>>>            Get String_Value of hoSQLHandler item iCount to sServer
93574>>>>>            Move (Trim(sServer)) to sReturnArray[iItem]
93575>>>>>            Increment iItem
93576>>>>>        Loop
93577>>>>>>
93577>>>>>
93577>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
93578>>>>>
93578>>>>>        Function_Return sReturnArray
93579>>>>>    End_Function
93580>>>>>
93580>>>>>    Function _SqlTableArrayDAW Returns String[]
93582>>>>>        String[] sReturnArray
93583>>>>>        String sTable sTableType sSchema sDefSchema sComment sTableKeyWord sSysKeyWord
93583>>>>>        Handle hoSQLHandler
93583>>>>>        Integer iCount iSize iItem
93583>>>>>        Boolean bOK
93583>>>>>        tSQLConnection SQLConnection
93583>>>>>        tSQLConnection SQLConnection
93583>>>>>
93583>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
93584>>>>>        If (SQLConnection.sConnectionString = "") Begin
93586>>>>>            Function_Return sReturnArray
93587>>>>>        End
93587>>>>>>
93587>>>>>
93587>>>>>        Move SQLConnection.sSchema      to sDefSchema
93588>>>>>        Move (Uppercase(sDefSchema))    to sDefSchema
93589>>>>>        Get _SqlFindKeyWord CI_SQLTable to sTableKeyWord
93590>>>>>        Get _SqlFindKeyWord CI_SQLSys   to sSysKeyWord
93591>>>>>
93591>>>>>        Get phoCLIHandler to hoSQLHandler
93592>>>>>        Set psDriverID    of hoSQLHandler to SQLConnection.sDriverID
93593>>>>>        Send Delete_Data  of hoSQLHandler
93594>>>>>
93594>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
93595>>>>>        Get EnumerateTables of hoSQLHandler SQLConnection.sConnectionString to iSize
93596>>>>>        Move False to Err
93597>>>>>        Decrement iSize
93598>>>>>
93598>>>>>        For iCount from 0 to iSize
93604>>>>>>
93604>>>>>            Get TableName    of hoSQLHandler iCount to sTable
93605>>>>>            Get TableType    of hoSQLHandler iCount to sTableType
93606>>>>>            Get SchemaName   of hoSQLHandler iCount to sSchema
93607>>>>>            Get TableComment of hoSQLHandler iCount to sComment
93608>>>>>            Move (Trim(sTable)) to sTable
93609>>>>>            If (SQLConnection.sDriverID = DB2_DRV_ID) Begin
93611>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) = sDefSchema) to bOK
93612>>>>>            End
93612>>>>>>
93612>>>>>            Else Begin
93613>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) <> sSysKeyWord and Uppercase(sSchema) <> "SYSTOOLS") to bOK
93614>>>>>            End
93614>>>>>>
93614>>>>>            If (bOK = True) Begin
93616>>>>>                Move sTable to sReturnArray[iItem]
93617>>>>>                Increment iItem
93618>>>>>            End
93618>>>>>>
93618>>>>>        Loop
93619>>>>>>
93619>>>>>
93619>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
93620>>>>>
93620>>>>>        Function_Return sReturnArray
93621>>>>>    End_Function
93622>>>>>
93622>>>>>    Function _SqlProcedureArrayDAW String sStmt String sArgument Returns String[]
93624>>>>>        String[] sReturnArray
93625>>>>>        String sValue
93625>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
93625>>>>>        Integer iRetval iCols iFetchResult
93625>>>>>        tSQLConnection SQLConnection
93625>>>>>        tSQLConnection SQLConnection
93625>>>>>
93625>>>>>        Get phoSQLManager to hoSQLHandler
93626>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
93627>>>>>        Get SqlConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
93628>>>>>
93628>>>>>        If (hoSQLConnect <> 0) Begin
93630>>>>>            Get SqlOpen of hoSQLConnect to hStmt
93631>>>>>            If (hStmt <> 0) Begin
93633>>>>>                Send SqlSetProcedurename of hStmt sStmt
93634>>>>>                If (sArgument <> "") Begin
93636>>>>>                    Send SqlSetArgument  of hStmt 1 sArgument
93637>>>>>                End
93637>>>>>>
93637>>>>>
93637>>>>>                Send SqlCall             of hStmt
93638>>>>>                Get SqlReturnValue       of hStmt to iRetval
93639>>>>>                If (iRetval = 0) Begin
93641>>>>>                    Repeat
93641>>>>>>
93641>>>>>                        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
93642>>>>>                        If (iCols > 0) Begin
93644>>>>>                            Repeat
93644>>>>>>
93644>>>>>                                Get SqlFetch of hStmt to iFetchResult
93645>>>>>                                If (iFetchResult <> 0) Begin
93647>>>>>                                    Get SqlColumnValue of hStmt 1 to sValue
93648>>>>>                                    Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)]
93649>>>>>                                End
93649>>>>>>
93649>>>>>                            Until (iFetchResult = 0)
93651>>>>>                        End
93651>>>>>>
93651>>>>>                        Get SqlNextResultSet of hStmt to iRetval
93652>>>>>                    Until (iRetval = 0)
93654>>>>>                    Send SqlClose of hStmt
93655>>>>>                End
93655>>>>>>
93655>>>>>            End
93655>>>>>>
93655>>>>>            Send SqlDisconnect of hoSQLConnect
93656>>>>>        End
93656>>>>>>
93656>>>>>        Function_Return sReturnArray
93657>>>>>    End_Function
93658>>>>>
93658>>>>>    Function _SqlDatabasesArrayDB2 Returns String[]
93660>>>>>        String[] sReturnArray
93661>>>>>        String sDataSource
93661>>>>>        Handle hoSQLHandler
93661>>>>>        Integer iItem
93661>>>>>
93661>>>>>        Get phoDB2SQLHandler to hoSQLHandler
93662>>>>>        Send SeedDataSources of hoSQLHandler
93663>>>>>
93663>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
93664>>>>>
93664>>>>>        Repeat
93664>>>>>>
93664>>>>>            Get DataSources of hoSQLHandler to sDataSource
93665>>>>>            Move (Replaces(",", sDataSource, "")) to sDataSource
93666>>>>>            Move (Trim(sDataSource)) to sReturnArray[iItem]
93667>>>>>            Increment iItem
93668>>>>>        Until (sDataSource = "")
93670>>>>>
93670>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
93671>>>>>
93671>>>>>        Function_Return sReturnArray
93672>>>>>    End_Function
93673>>>>>
93673>>>>>    Function _SqlDatabasesArrayODBC Returns String[]
93675>>>>>        String[] sReturnArray
93676>>>>>        String sDataSource
93676>>>>>        Handle hoSQLHandler
93676>>>>>        Integer iItem
93676>>>>>
93676>>>>>        Get phoODBCSQLHandler to hoSQLHandler
93677>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
93678>>>>>
93678>>>>>        Send SeedDataSources of hoSQLHandler
93679>>>>>
93679>>>>>        Repeat
93679>>>>>>
93679>>>>>            Get DataSources of hoSQLHandler to sDataSource
93680>>>>>            If (Trim(sDataSource) <> "" and not(sDataSource contains "*.")) Begin
93682>>>>>                Move (Trim(sDataSource)) to sReturnArray[iItem]
93683>>>>>                Increment iItem
93684>>>>>            End
93684>>>>>>
93684>>>>>        Until (sDataSource = "")
93686>>>>>
93686>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
93687>>>>>
93687>>>>>        Function_Return sReturnArray
93688>>>>>    End_Function
93689>>>>>
93689>>>>>    // We might have a split Sql script where the info about which database to use is
93689>>>>>    // put on top of the Sql script, we then need to save it to be able to retrieve it later and
93689>>>>>    // insert it for scriplets to come after the first one.
93689>>>>>    Function _SqlFormatStatement String sStmt Returns String
93691>>>>>        String sUseDatabase sTmp sUseKeyWord sCreateViewKeyWord sDBOKeyWord sNoCountKeyWord sDriverID
93691>>>>>        Integer iStart iEnd iDbType
93691>>>>>        Boolean bOK
93691>>>>>
93691>>>>>        Get piDbType to iDbType
93692>>>>>        Get psDriverID to sDriverID
93693>>>>>        Get _SqlFindKeyWord CI_SQLUse          to sUseKeyWord
93694>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
93695>>>>>        Get _SqlFindKeyWord CI_SQLCreateView   to sCreateViewKeyWord
93696>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBOKeyWord
93697>>>>>        Move (Replaces(" ", sStmt, "")) to sTmp
93698>>>>>        If (Uppercase(sTmp) contains (sUseKeyWord +"[")) Begin
93700>>>>>            Move (Pos("[", (Uppercase(sTmp)))) to iStart
93701>>>>>            Move (Pos("]", sTmp)) to iEnd
93702>>>>>            Move (Mid(sTmp, (iEnd -iStart +1), iStart)) to sUseDatabase
93703>>>>>            Move (sUseKeyWord * sUseDatabase + " ") to sUseDatabase
93704>>>>>            Set Private.psUseDatabase to sUseDatabase
93705>>>>>        End
93705>>>>>>
93705>>>>>        Else Begin
93706>>>>>            Move (Uppercase(sStmt)) to sTmp
93707>>>>>
93707>>>>>            // A "Create View" statement _must_ be the very first words in a Sql statement.
93707>>>>>            If (not(sTmp contains sCreateViewKeyWord)) Begin
93709>>>>>                Get Private.psUseDatabase to sUseDatabase
93710>>>>>                Move (Insert(sUseDatabase, sStmt, 1)) to sStmt
93711>>>>>            End
93711>>>>>>
93711>>>>>
93711>>>>>            // This is a bit special to place here but was done so because it was easier that way.
93711>>>>>            // We will get an error when trying to create a view if it already exists.
93711>>>>>            // So to avoid such errors; we first remove it & then recreate it.
93711>>>>>            Else If (sTmp contains sCreateViewKeyWord) Begin
93714>>>>>                // Make sure we only have one space between statements/words.
93714>>>>>                Move (Replaces("  ", sTmp, " ")) to sTmp
93715>>>>>                Move (Replace(sCreateViewKeyWord, sTmp, "")) to sTmp
93716>>>>>                Move (Trim(sTmp)) to sTmp
93717>>>>>                Move (Pos(" ", sTmp)) to iEnd
93718>>>>>                Move (Left(sTmp, iEnd)) to sTmp
93719>>>>>                If ((not(sTmp contains ("[" + sDBOKeyWord + "]."))) and (not(sTmp contains (sDBOKeyWord + ".")))) Begin
93721>>>>>                    Move (sDBOKeyWord + "." + Trim(sTmp)) to sTmp
93722>>>>>                End
93722>>>>>>
93722>>>>>                Move (Trim(sTmp)) to sTmp
93723>>>>>                // Remove data view as it already exists!
93723>>>>>                Get SqlViewRemove sDriverID sTmp to bOK
93724>>>>>            End
93724>>>>>>
93724>>>>>        End
93724>>>>>>
93724>>>>>
93724>>>>>        Function_Return sStmt
93725>>>>>    End_Function
93726>>>>>
93726>>>>>    // Returns the proper Sql language key word(s) for the passed SQL key-word constant
93726>>>>>    Function _SqlFindKeyWord Integer iSQLKeywordConstant Returns String
93728>>>>>        String sRetval
93728>>>>>        Integer iDbType iIndex
93728>>>>>        tSQLKeyWords[] SQLKeywordArray
93728>>>>>        tSQLKeyWords[] SQLKeywordArray
93729>>>>>        tSQLKeyWords   SQLKeyWords
93729>>>>>        tSQLKeyWords   SQLKeyWords
93729>>>>>
93729>>>>>        // Sql back-end type. E.g. MS-SQL, MySQL, Oracle, DB2...
93729>>>>>        Get piDbType to iDbType
93730>>>>>        Move iDbType             to SQLKeyWords.iSQLDbType
93731>>>>>        Move iSQLKeywordConstant to SQLKeyWords.iSQLWord
93732>>>>>
93732>>>>>        Get paSQLKeywordArray to SQLKeywordArray
93733>>>>>        Move (SearchArray(SQLKeyWords, SQLKeywordArray, Self, RefFunc(CompareFindSQLKeyWords))) to iIndex
93734>>>>>        Move SQLKeywordArray[iIndex].sSQLPhrase to sRetval
93735>>>>>
93735>>>>>        Function_Return sRetval
93736>>>>>    End_Function
93737>>>>>
93737>>>>>    // Function will "clean/sanitize" the script by removing all comments and blank lines.
93737>>>>>    Function _SqlUtilSanitizeScript tSQLScriptArray SqlScriptArray Returns tSQLScriptArray[]
93739>>>>>        String[] sSQLScriptArray
93740>>>>>        String sText sLine sTmp sCommentStart sCommentEnd sDashComment
93740>>>>>        Integer iSize iCount
93740>>>>>        Boolean bCommentStart bCommentEnd bDashComment
93740>>>>>
93740>>>>>        Move False to bCommentStart
93741>>>>>        Move False to bCommentEnd
93742>>>>>        Move False to bDashComment
93743>>>>>        Move "/*"  to sCommentStart   // These are the standard comment start & stop tokens...
93744>>>>>        Move "*/"  to sCommentEnd
93745>>>>>        Move "--"  to sDashComment    // ...but a comment can also start with two dashes "--".
93746>>>>>
93746>>>>>        Move (SizeOfArray(SqlScriptArray.sSQLScriptArray)) to iSize
93747>>>>>        Decrement iSize
93748>>>>>        Move "" to sText
93749>>>>>
93749>>>>>        For iCount from 0 to iSize
93755>>>>>>
93755>>>>>            Move SqlScriptArray.sSQLScriptArray[iCount] to sLine
93756>>>>>            Move (Trim(sLine)) to sTmp
93757>>>>>            If (sTmp <> "") Begin
93759>>>>>                Move (Left(sTmp, 2) = sDashComment) to bDashComment
93760>>>>>                If (bCommentStart = False) Begin
93762>>>>>                    Move (Left(sTmp, 2) = sCommentStart) to bCommentStart
93763>>>>>                    If (bCommentStart = False) Begin
93765>>>>>                    End
93765>>>>>>
93765>>>>>                End
93765>>>>>>
93765>>>>>                Move (sTmp contains sCommentEnd) to bCommentEnd
93766>>>>>                If (bCommentEnd = True) Begin
93768>>>>>                    Move False to bCommentStart
93769>>>>>                End
93769>>>>>>
93769>>>>>                If (bDashComment = False and bCommentStart = False and bCommentEnd = False) Begin
93771>>>>>                    Move sLine to sSQLScriptArray[SizeOfArray(sSQLScriptArray)]
93772>>>>>                End
93772>>>>>>
93772>>>>>            End
93772>>>>>>
93772>>>>>        Loop
93773>>>>>>
93773>>>>>
93773>>>>>        // Update the retval struct array:
93773>>>>>        Move sSQLScriptArray to SqlScriptArray.sSQLScriptArray
93774>>>>>        Function_Return SqlScriptArray
93775>>>>>    End_Function
93776>>>>>
93776>>>>>
93776>>>>>    // *** Database API Functions: ***
93776>>>>>    // Instead of using Sql Scripts (ESQL), we can opt to use the DataFlex Database API's to
93776>>>>>    // make changes/updates to the database.
93776>>>>>
93776>>>>>    // * Dummy function for the Studio's Code Explorer *
93776>>>>>    Function API_TABLE_FUNCTIONS Returns Boolean
93778>>>>>        Function_Return False
93779>>>>>    End_Function
93780>>>>>
93780>>>>>    // This might not do what you think - Here's what it does:
93780>>>>>    // It checks that the passed hTable TableName in filelist.cfg is exactly the same as at the SQL back-end.
93780>>>>>    // If that is True; it creates an .int file for it and changes Filelist.cfg to point
93780>>>>>    // to the SQL table.
93780>>>>>    // Typical usage for this function is when an entry exists in the Filelist for a table and the table
93780>>>>>    // already exists in SQL.
93780>>>>>    // This is a bit fiddly as the DF_FILE_PHYSICAL_NAME attribute can only be set inside a
93780>>>>>    // Structure_Start ... Structure_End operation when creating a NEW table. Thus it cannot be set when
93780>>>>>    // restructuring an existing table.
93780>>>>>    Function ApiTableAttachToSql Handle hTable Boolean bUseConnID Returns Boolean
93782>>>>>        Boolean bExists bOpened bOK bSystemFile bMertechDriver bUseConnectionID bIsAlias
93782>>>>>        String sDriverID sConnectionID sConnectionString sDisplayName sRootName sLogicalName sPhysicalName sSchema
93782>>>>>        Handle hToTable
93782>>>>>        Integer iPos
93782>>>>>
93782>>>>>        Move True to bUseConnectionID
93783>>>>>        If (num_arguments > 1) Begin
93785>>>>>            Move bUseConnID to bUseConnectionID
93786>>>>>        End
93786>>>>>>
93786>>>>>
93786>>>>>        Get psDriverID to sDriverID
93787>>>>>        // If the table doesn't exist on the SQL back-end we do nothing.
93787>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
93788>>>>>        If (bExists = False) Begin
93790>>>>>            Function_Return False
93791>>>>>        End
93791>>>>>>
93791>>>>>
93791>>>>>        Get UtilTableIsAlias hTable to bIsAlias
93792>>>>>
93792>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
93793>>>>>        If (bOK = False) Begin
93795>>>>>            Function_Return False
93796>>>>>        End
93796>>>>>>
93796>>>>>
93796>>>>>        // Then we need to check that the function hasn't been called before; which in case
93796>>>>>        // we do nothing
93796>>>>>        Get SQLUtilTableIsAttached sDriverID hTable to bExists
93797>>>>>        If (bExists = True) Begin
93799>>>>>            Function_Return False
93800>>>>>        End
93800>>>>>>
93800>>>>>
93800>>>>>        Get psConnectionID     to sConnectionID
93801>>>>>        Get psConnectionString to sConnectionString
93802>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
93804>>>>>            Error DFERR_PROGRAM ("An SQL connection has NOT been setup correctly. Could not attach table:" * String(hTable) * "to SQL")
93805>>>>>>
93805>>>>>            Function_Return False
93806>>>>>        End
93806>>>>>>
93806>>>>>
93806>>>>>        Set Private.phCurrentTable to hTable
93807>>>>>        Get psSchema to sSchema
93808>>>>>        If (sSchema = "") Begin
93810>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
93811>>>>>        End
93811>>>>>>
93811>>>>>
93811>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
93812>>>>>
93812>>>>>        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
93812>>>>>        // was a programmer's error and we adjust for it here.
93812>>>>>        If (bMertechDriver = True) Begin
93814>>>>>            Move False to bUseConnectionID
93815>>>>>        End
93815>>>>>>
93815>>>>>
93815>>>>>        // If we should use a connection id we need to check it exists;
93815>>>>>        // else we create it before attempting creating the table
93815>>>>>        If (bUseConnectionID = True) Begin
93817>>>>>            Get AutoConnectionIDLogin to bOK
93818>>>>>            If (bOk = False) Begin
93820>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
93821>>>>>>
93821>>>>>                Function_Return False
93822>>>>>            End
93822>>>>>>
93822>>>>>        End
93822>>>>>>
93822>>>>>
93822>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
93825>>>>>        Get _TableNameOnly sRootName to sRootName
93826>>>>>        If (sRootName = "") Begin
93828>>>>>            Function_Return False
93829>>>>>        End
93829>>>>>>
93829>>>>>        Move (sRootName + ".int")                    to sPhysicalName
93830>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
93833>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
93836>>>>>
93836>>>>>        // We don't want to change the display name if it starts with an ampersand ("@"),
93836>>>>>        // because then the table should not be visible to users.
93836>>>>>        Move (Pos("@", sDisplayName)) to iPos
93837>>>>>        If (iPos <> 1) Begin
93839>>>>>            If (sDisplayName contains ".") Begin
93841>>>>>                Move (Pos(".", sDisplayName)) to iPos
93842>>>>>                Move (Mid(sDisplayName, 200 ,(iPos + 1))) to sDisplayName
93843>>>>>                Move (sSchema + "." + sDisplayName)       to sDisplayName
93844>>>>>            End
93844>>>>>>
93844>>>>>            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
93846>>>>>                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
93847>>>>>            End
93847>>>>>>
93847>>>>>        End
93847>>>>>>
93847>>>>>
93847>>>>>        If (bIsAlias = False) Begin
93849>>>>>            Get OpenTableExclusive hTable to bOpened
93850>>>>>            If (bOpened = False) Begin
93852>>>>>                Error DFERR_PROGRAM ("Function ApiTableAttachToSQL - Could not open table number:" * String(hTable) * sLogicalName)
93853>>>>>>
93853>>>>>                Function_Return False
93854>>>>>            End
93854>>>>>>
93854>>>>>        End
93854>>>>>>
93854>>>>>
93854>>>>>        If (ghoProgressBar <> 0) Begin
93856>>>>>            Send DoAdvance of ghoProgressBar
93857>>>>>            Set TableName_Text of ghoStatusPanel to ("Attaching to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable) * "to SQL")
93858>>>>>        End
93858>>>>>>
93858>>>>>        // Note: The hToTable will get changed by the Structure_xxx command...
93858>>>>>        Move hTable to hToTable
93859>>>>>        Move False to Err
93860>>>>>
93860>>>>>        // We now create a stub .int file and after Structure_end and also change the Filelist.cfg,
93860>>>>>        // then we do a pseudo .int file change with the "SqlUtilUpdateIntFile" function. After that we have
93860>>>>>        // a proper and updated .int file.
93860>>>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemFile
93863>>>>>        Get SqlUtilCreateIntFile hTable sDriverID sConnectionID True bSystemFile to bOK
93864>>>>>
93864>>>>>        If (bIsAlias = False) Begin
93866>>>>>            Structure_Start hToTable sDriverID
93867>>>>>                Set Private.phCurrentTable to hTable
93868>>>>>                If (bUseConnectionID = True) Begin
93870>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to (CS_DFCONNID + "=" + sConnectionID)
93873>>>>>                End
93873>>>>>>
93873>>>>>                Else Begin
93874>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to sConnectionString
93877>>>>>                End
93877>>>>>>
93877>>>>>                Set_Attribute DF_FILE_OWNER         of hToTable to (Lowercase(sSchema))
93880>>>>>                // For unknown reason the above sometimes triggers an error and it doesn't help to try to trap the error; so we cheat...
93880>>>>>                Move False to Err
93881>>>>>                Move 0 to LastErr
93882>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
93883>>>>>            Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
93885>>>>>            Set Action_Text of ghoStatusPanel to ""
93886>>>>>        End
93886>>>>>>
93886>>>>>
93886>>>>>        Move (not(Err)) to bOK
93887>>>>>        If (bOK = True) Begin
93889>>>>>            // The attributes set above will always trigger an error
93889>>>>>            // We also adjust the Filelist entries
93889>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to (sDriverID + ":" + sRootName)
93892>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
93895>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
93898>>>>>
93898>>>>>            // This updates the .int file to make it up-to-date with the SQL back-end.
93898>>>>>            Get SqlUtilUpdateIntFile hTable to bOK
93899>>>>>        End
93899>>>>>>
93899>>>>>
93899>>>>>        Function_Return (bOK = True)
93900>>>>>    End_Function
93901>>>>>
93901>>>>>    // Sample usage:
93901>>>>>    //    Get ApiTableChangeAttribute SysInfo.File_Number DF_FILE_IS_SYSTEM_FILE True to bOK
93901>>>>>    //    Get ApiTableChangeAttribute OrderHea.File_Number DF_FILE_REUSE_DELETED DF_FILE_DELETED_NOREUSE to bOK
93901>>>>>    Function ApiTableChangeAttribute Handle hTable Integer iAttribute Integer iValue Returns Boolean
93903>>>>>        Boolean bOK bIsSQLTable
93903>>>>>
93903>>>>>        Get AutoConnectionIDLogin to bOK
93904>>>>>        Move False to Err
93905>>>>>        Get OpenTableExclusive hTable to bOK
93906>>>>>        If (bOK = False) Begin
93908>>>>>            Function_Return False
93909>>>>>        End 
93909>>>>>>
93909>>>>>        
93909>>>>>        // ToDo: Add to all table change functions!
93909>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
93910>>>>>            If (bIsSQLTable = True) Begin
93912>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
93915>>>>>            End
93915>>>>>>
93915>>>>>        
93915>>>>>        Set Private.phCurrentTable to hTable
93916>>>>>        Structure_Start hTable
93917>>>>>            Set_Attribute iAttribute of hTable to iValue
93920>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
93921>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
93923>>>>>
93923>>>>>        Set Action_Text of ghoStatusPanel to ""
93924>>>>>        Function_Return (Err = False)
93925>>>>>    End_Function
93926>>>>>
93926>>>>>    // To use a filelist slot for the passed FileName, TableName & DisplayName,
93926>>>>>    // or to change the filelist slot names.
93926>>>>>    Function ApiTableChangeFileListSlot String sRootName String sLogicalName String sDisplayName Handle hTable String sDriverID Returns Boolean
93928>>>>>        Boolean bExists
93928>>>>>
93928>>>>>        Move False to Err
93929>>>>>        Get UtilTableNumberIsInUse hTable to bExists
93930>>>>>        If (bExists = False) Begin
93932>>>>>            Function_Return False
93933>>>>>        End
93933>>>>>>
93933>>>>>
93933>>>>>        If (ghoProgressBar <> 0) Begin
93935>>>>>            Send DoAdvance of ghoProgressBar
93936>>>>>            Set TableName_Text of ghoStatusPanel to ("Changing Filelist slot for Table:" * String(sLogicalName) * "Number:" * String(hTable))
93937>>>>>        End
93937>>>>>>
93937>>>>>        // If all strings are empty it means that we should remove this entry from filelist.
93937>>>>>        If (sRootName = "" and sLogicalName = "" and sDisplayName = "") Begin
93939>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
93942>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
93945>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
93948>>>>>            Function_Return (Err = False) // And we're done.
93949>>>>>        End
93949>>>>>>
93949>>>>>
93949>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
93951>>>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
93954>>>>>        End
93954>>>>>>
93954>>>>>        Else Begin
93955>>>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
93958>>>>>        End
93958>>>>>>
93958>>>>>
93958>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
93961>>>>>
93961>>>>>        If (sDriverID <> DATAFLEX_ID and not(Uppercase(sDisplayName) contains "DBO.")) Begin
93963>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ("dbo." + sDisplayName)
93966>>>>>        End
93966>>>>>>
93966>>>>>        Else Begin
93967>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
93970>>>>>        End
93970>>>>>>
93970>>>>>
93970>>>>>        Function_Return (Err = False)
93971>>>>>    End_Function
93972>>>>>
93972>>>>>    Function ApiTableChangeRecordLength Handle hTable Integer iRecordLength Returns Boolean
93974>>>>>        Boolean bOK
93974>>>>>
93974>>>>>        Get AutoConnectionIDLogin to bOK
93975>>>>>        Move False to Err
93976>>>>>        Get OpenTableExclusive hTable to bOK
93977>>>>>        If (bOK = False) Begin
93979>>>>>            Function_Return False
93980>>>>>        End
93980>>>>>>
93980>>>>>
93980>>>>>        Set Private.phCurrentTable to hTable
93981>>>>>        Structure_Start hTable
93982>>>>>            Set_Attribute DF_FILE_RECORD_LENGTH of hTable to iRecordLength
93985>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
93986>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
93988>>>>>
93988>>>>>        Set Action_Text of ghoStatusPanel to ""
93989>>>>>        Function_Return (Err = False)
93990>>>>>    End_Function
93991>>>>>
93991>>>>>    Function ApiTableChangeRelation Handle hTable Handle hToTable Integer iFromField Integer iToField Returns Boolean
93993>>>>>        Boolean bOK
93993>>>>>
93993>>>>>        Move False to Err
93994>>>>>        Get AutoConnectionIDLogin to bOK
93995>>>>>        Open hToTable
93997>>>>>        Get OpenTableExclusive hTable to bOK
93998>>>>>        If (bOK = False) Begin
94000>>>>>            Function_Return False
94001>>>>>        End
94001>>>>>>
94001>>>>>
94001>>>>>        Set Private.phCurrentTable to hTable
94002>>>>>        Structure_Start hTable
94003>>>>>            Set_Attribute DF_FIELD_RELATED_FILE  of hTable iFromField to hToTable
94006>>>>>            Set_Attribute DF_FIELD_RELATED_FIELD of hTable iFromField to iToField
94009>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
94010>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
94012>>>>>
94012>>>>>        Set Action_Text of ghoStatusPanel to ""
94013>>>>>        Function_Return (Err = False)
94014>>>>>    End_Function
94015>>>>>
94015>>>>>    Procedure ApiTableConvertAllAddException Integer hTable
94017>>>>>        Integer[] aTableConvertExceptions
94018>>>>>        Get paTableConvertExceptions to aTableConvertExceptions
94019>>>>>        Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
94020>>>>>        Set paTableConvertExceptions to aTableConvertExceptions
94021>>>>>    End_Procedure
94022>>>>>
94022>>>>>    Procedure ApiTableDateCorrectionAddException Integer hTable
94024>>>>>        Integer[] aTableDateCorrectionExceptions
94025>>>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
94026>>>>>        Move hTable to aTableDateCorrectionExceptions[SizeOfArray(aTableDateCorrectionExceptions)]
94027>>>>>        Set paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
94028>>>>>    End_Procedure
94029>>>>>
94029>>>>>    Procedure ApiTableConvertALLToSql
94031>>>>>        Integer[] iTablesArray
94032>>>>>        Integer iSize iCount
94032>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
94032>>>>>        String sDriverID
94032>>>>>
94032>>>>>        Get psDriverID to sDriverID
94033>>>>>        Get pbUseConnectionID to bUseConnectionID
94034>>>>>        Get pbToANSI          to bToANSI
94035>>>>>        Get pbRecnum          to bRecnum
94036>>>>>        Get pbCopyData        to bCopyData
94037>>>>>        If (ghoDbUpdateHandler > 0) Begin
94039>>>>>            Get pbContinueOnError to bContinueOnError
94040>>>>>        End
94040>>>>>>
94040>>>>>
94040>>>>>        Get _AllTablesToConvert to iTablesArray
94041>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
94042>>>>>        Set pbVisible   of ghoProgressBarOverall to True
94043>>>>>        Set piPosition  of ghoProgressBarOverall to 0
94044>>>>>        Set piAdvanceBy of ghoProgressBarOverall to 1
94045>>>>>        Set piMaximum   of ghoProgressBarOverall to iSize
94046>>>>>
94046>>>>>        Decrement iSize
94047>>>>>        For iCount from 0 to iSize
94053>>>>>>
94053>>>>>            Set piPosition of ghoProgressBarOverall to iCount
94054>>>>>            Get ApiTableConvertToSQL_Ex iTablesArray[iCount] sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
94055>>>>>            // Probably the right logic here is to just continue trying to convert every table even
94055>>>>>            // if there was an error converting one table...
94055>>>>>            //If (bContinueOnError = False and bOK = False) Break
94055>>>>>        Loop
94056>>>>>>
94056>>>>>
94056>>>>>    End_Procedure
94057>>>>>
94057>>>>>    Procedure ApiTableAttachALLToSql
94059>>>>>        Integer[] iTablesArray
94060>>>>>        Integer iSize iCount
94060>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
94060>>>>>        String sDriverID
94060>>>>>
94060>>>>>        Get psDriverID to sDriverID
94061>>>>>        Get pbUseConnectionID to bUseConnectionID
94062>>>>>        Get pbToANSI          to bToANSI
94063>>>>>        Get pbRecnum          to bRecnum
94064>>>>>        Get pbCopyData        to bCopyData
94065>>>>>        If (ghoDbUpdateHandler > 0) Begin
94067>>>>>            Get pbContinueOnError to bContinueOnError
94068>>>>>        End
94068>>>>>>
94068>>>>>
94068>>>>>        Get _AllTablesToConvert to iTablesArray
94069>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
94070>>>>>        Decrement iSize
94071>>>>>        For iCount from 0 to iSize
94077>>>>>>
94077>>>>>            Get ApiTableAttachToSQL iTablesArray[iCount] bUseConnectionID to bOK
94078>>>>>        Loop
94079>>>>>>
94079>>>>>
94079>>>>>    End_Procedure      
94080>>>>>    
94080>>>>>    // Subfunction to the ApiTableUpdate function (et al)
94080>>>>>    Function _UtilTableCheckChangeFilelistNames tAPITableNameInfo APITableNameInfoFrom Boolean bIsSQLTableTo Returns Boolean
94082>>>>>        Handle hTable 
94082>>>>>        String sRootNameTo sLogicalNameTo sDisplayNameTo sConnectionID
94082>>>>>        Boolean bIsSQLTableFrom bTableExists bSameTableNames bANSI bOK
94082>>>>>        
94082>>>>>        Get ApiTableFilelistNamesCompare True APITableNameInfoFrom to bSameTableNames
94083>>>>>        If (bSameTableNames = True) Begin
94085>>>>>            Function_Return True
94086>>>>>        End 
94086>>>>>>
94086>>>>>        
94086>>>>>        Move True to bOK
94087>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable  
94088>>>>>        Set Private.phCurrentTable              to hTable
94089>>>>>        Set_Attribute DF_FILE_ROOT_NAME         of hTable to APITableNameInfoFrom.sRootName
94092>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME      of hTable to APITableNameInfoFrom.sLogicalName
94095>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME      of hTable to APITableNameInfoFrom.sDisplayName
94098>>>>>        
94098>>>>>        If (APITableNameInfoFrom.bIsSQL = True) Begin
94100>>>>>            Get psConnectionID to sConnectionID
94101>>>>>            Get UtilTableExists hTable to bTableExists
94102>>>>>            If (bTableExists = True) Begin  
94104>>>>>                Get SqlUtilUpdateIntFile hTable to bOK
94105>>>>>            End
94105>>>>>>
94105>>>>>            Else Begin
94106>>>>>                Get pbToANSI to bANSI 
94107>>>>>                Get SqlUtilCreateIntFile hTable APITableNameInfoFrom.sDriverID sConnectionID bANSI False to bOK
94108>>>>>            End
94108>>>>>>
94108>>>>>        End
94108>>>>>>
94108>>>>>
94108>>>>>        Function_Return bOK
94109>>>>>    End_Function
94110>>>>>
94110>>>>>    Function ApiTableConvertToSql_Ex Handle hTable String sDriverID Boolean bUseConnectionID Boolean bToAnsi Boolean bRecnum Boolean bCopyData Returns Boolean
94112>>>>>        Handle hToTable hoLogFile
94112>>>>>        Boolean bOK bExists bOpened bMertechDriver bDAWDriver bContinueOnError bIsAlias
94112>>>>>        String sPhysicalName sRootName sLogicalName sDisplayName sConnectionID sConnectionString
94112>>>>>        String sANSI_OEM sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace sDatabase sGUIDName sWarning
94112>>>>>        tSQLConnection SQLConnection
94112>>>>>        tSQLConnection SQLConnection
94112>>>>>        
94112>>>>>        Get UtilTableIsAlias hTable to bIsAlias
94113>>>>>        // If this is an Alias file there is nothing to convert to SQL.
94113>>>>>        // Instead we change the Filelist.cfg by adding the driver id to the rootname and create an .int file
94113>>>>>        If (bIsAlias = True) Begin
94115>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
94118>>>>>            If (sDriverID <> DATAFLEX_ID and not(sRootName contains ":")) Begin
94120>>>>>                Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
94123>>>>>                Get psConnectionID to sConnectionID
94124>>>>>                Get SqlUtilCreateIntFile hTable sDriverID sConnectionID True False to bOK
94125>>>>>            End
94125>>>>>>
94125>>>>>            Function_Return True
94126>>>>>        End
94126>>>>>>
94126>>>>>
94126>>>>>        Set Private.phCurrentTable to hTable
94127>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
94130>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
94133>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
94136>>>>>
94136>>>>>        If (ghoProgressBar <> 0) Begin
94138>>>>>            Send DoAdvance of ghoProgressBar
94139>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(sLogicalName))
94140>>>>>        End
94140>>>>>>
94140>>>>>
94140>>>>>        // Marco Kuipers suggestion;
94140>>>>>        // If Filelist.cfg points to an embedded .dat table and the table already exists as
94140>>>>>        // an SQL table; rename the SQL table by adding a GUID at the end, then convert the
94140>>>>>        // table again.
94140>>>>>        Get UtilTableIsSQL hTable to bOK
94141>>>>>        If (bOK = False) Begin
94143>>>>>            Get SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
94144>>>>>            If (bExists = True) Begin
94146>>>>>                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
94147>>>>>                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
94148>>>>>                Get phoLogFile to hoLogFile
94149>>>>>                If (hoLogFile <> 0) Begin
94151>>>>>                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The existing SQL table was renamed to:" * String(sGUIDName) * "and then converted again.") to sWarning
94152>>>>>                    Send LogError sWarning False
94153>>>>>                End
94153>>>>>>
94153>>>>>                Else Begin
94154>>>>>                    Error DFERR_PROGRAM sWarning
94155>>>>>>
94155>>>>>                End
94155>>>>>>
94155>>>>>            End
94155>>>>>>
94155>>>>>        End
94155>>>>>>
94155>>>>>
94155>>>>>        // Does the rootname contain a driver?
94155>>>>>        If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
94157>>>>>            // Does the table already exist as an SQL table?
94157>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
94158>>>>>            // It can happen that the table is missing from Filelist.cfg but still
94158>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
94158>>>>>            If (bExists = False) Begin
94160>>>>>                Get SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
94161>>>>>            End
94161>>>>>>
94161>>>>>            If (bExists = True) Begin
94163>>>>>                Set TableName_Text of ghoStatusPanel to ""
94164>>>>>                Function_Return False
94165>>>>>            End
94165>>>>>>
94165>>>>>        End
94165>>>>>>
94165>>>>>        Move (If(bToAnsi = True, CS_ANSI_Txt, CS_OEM_Txt)) to sANSI_OEM
94166>>>>>
94166>>>>>        Get IsDAWSQLDriver sDriverID to bDAWDriver
94167>>>>>        // Mertech drivers don't use Connection ID's; so if bUseConnectionID was
94167>>>>>        // passed as True, we adjust for that here.
94167>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
94168>>>>>        If (bMertechDriver = True and bUseConnectionID = True) Begin
94170>>>>>            Move False to bUseConnectionID
94171>>>>>        End
94171>>>>>>
94171>>>>>
94171>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
94172>>>>>        Move SQLConnection.sSchema           to sSchema
94173>>>>>        If (sSchema = "") Begin
94175>>>>>            Get _SqlFindKeyWord CI_SQLDBO    to sSchema
94176>>>>>            Move (Lowercase(sSchema))        to sSchema
94177>>>>>        End
94177>>>>>>
94177>>>>>
94177>>>>>        If (sDriverID = ORAFLEX) Begin
94179>>>>>            Move SQLConnection.sUserID       to sSchema
94180>>>>>        End
94180>>>>>>
94180>>>>>
94180>>>>>        Move SQLConnection.sDatabase         to sDatabase
94181>>>>>        Move SQLConnection.sConnectionID     to sConnectionID
94182>>>>>        Move SQLConnection.sConnectionString to sConnectionString
94183>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
94185>>>>>            Error DFERR_PROGRAM ("The SQL connection info has NOT been setup. Could not convert table:" * String(hTable) * "to SQL")
94186>>>>>>
94186>>>>>            Function_Return False
94187>>>>>        End
94187>>>>>>
94187>>>>>
94187>>>>>        Get AutoConnectionIDLogin to bOK
94188>>>>>        Open hTable
94190>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
94193>>>>>        If (bOpened = False) Begin
94195>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
94196>>>>>>
94196>>>>>            Function_Return False
94197>>>>>        End
94197>>>>>>
94197>>>>>
94197>>>>>        If (ghoProgressBar <> 0) Begin
94199>>>>>            Send DoAdvance of ghoProgressBar
94200>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable))
94201>>>>>        End
94201>>>>>>
94201>>>>>
94201>>>>>        Move 0 to hToTable
94202>>>>>        Get _TableNameOnly sRootName                 to sRootName
94203>>>>>        Move (sRootName + ".int")                    to sPhysicalName
94204>>>>>
94204>>>>>        Case Begin
94204>>>>>            Case (sDriverID = MSSQLDRV_ID)
94206>>>>>                Case Break
94207>>>>>            Case (sDriverID = ODBC_DRV_ID)
94210>>>>>                Case Break
94211>>>>>            Case (sDriverID = DB2_DRV_ID)
94214>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
94215>>>>>                Move SQLConnection.sLongTableSpace  to sLongTableSpace
94216>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
94217>>>>>                Case Break
94218>>>>>            Case (sDriverID = ORAFLEX)
94221>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
94222>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
94223>>>>>                Case Break
94224>>>>>            Case (sDriverID = MDSMySQL)
94227>>>>>                Case Break
94228>>>>>            Case (sDriverID = MDSPgSQL)
94231>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
94232>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
94233>>>>>                Case Break
94234>>>>>            Case (sDriverID = DATAFLEX_ID)
94237>>>>>                Case Break
94238>>>>>            Case Else
94238>>>>>                Error DFERR_PROGRAM "Wrong database driver passed to the 'ApiTableConvertToSQL_Ex' function."
94239>>>>>>
94239>>>>>                Case Break
94240>>>>>        Case End
94240>>>>>
94240>>>>>        Move False to Err
94241>>>>>
94241>>>>>        If (bIsAlias = False) Begin
94243>>>>>
94243>>>>>            If (bMertechDriver = True) Begin
94245>>>>>                // Note: This function also sets the Err flag.
94245>>>>>                Get _MertechApiTableConvertToSQL hTable sRootName sDatabase sDriverID sBaseTableSpace sIndexTableSpace bCopyData to bOK
94246>>>>>            End
94246>>>>>>
94246>>>>>
94246>>>>>            If (bMertechDriver = False) Begin
94248>>>>>                Structure_Start hToTable sDriverID
94249>>>>>                    Structure_Copy hTable to hToTable
94250>>>>>
94250>>>>>                    Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
94253>>>>>
94253>>>>>                    If (sDriverID <> DATAFLEX_ID) Begin
94255>>>>>                        If (bUseConnectionID = True) Begin
94257>>>>>                            Set_Attribute DF_FILE_LOGIN     of hToTable to (CS_DFCONNID + "=" + sConnectionID)
94260>>>>>                        End
94260>>>>>>
94260>>>>>                        Else Begin
94261>>>>>                            Set_Attribute DF_FILE_LOGIN     of hToTable to sConnectionString
94264>>>>>                        End
94264>>>>>>
94264>>>>>
94264>>>>>                        Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT   of hToTable to sANSI_OEM
94267>>>>>                        Set_Attribute DF_FILE_RECNUM_TABLE             of hToTable to bRecnum
94270>>>>>
94270>>>>>                        If (sSchema <> "") Begin
94272>>>>>                            Set_Attribute DF_FILE_OWNER                of hToTable to sSchema
94275>>>>>                        End
94275>>>>>>
94275>>>>>
94275>>>>>                        If (sDriverID = DB2_DRV_ID) Begin
94277>>>>>                            If (sLongTableSpace <> "") Begin
94279>>>>>                                Set_Attribute DF_FILE_LONG_TABLESPACE  of hToTable to sLongTableSpace
94282>>>>>                            End
94282>>>>>>
94282>>>>>                            If (sBaseTableSpace <> "") Begin
94284>>>>>                                Set_Attribute DF_FILE_TABLE_TABLESPACE of hToTable to sBaseTableSpace
94287>>>>>                            End
94287>>>>>>
94287>>>>>                            If (sIndexTableSpace <> "") Begin
94289>>>>>                                Set_Attribute DF_FILE_INDEX_TABLESPACE of hToTable to sIndexTableSpace
94292>>>>>                            End
94292>>>>>>
94292>>>>>                        End
94292>>>>>>
94292>>>>>                    End
94292>>>>>>
94292>>>>>
94292>>>>>                    Set Action_Text of ghoStatusPanel to "Restructures table..."
94293>>>>>                Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
94295>>>>>                Set Action_Text of ghoStatusPanel to ""
94296>>>>>            End
94296>>>>>>
94296>>>>>
94296>>>>>            Move (not(Err)) to bOK
94297>>>>>            If (bOK = True and bCopyData = True and bMertechDriver = False) Begin
94299>>>>>                If (bIsAlias = False) Begin
94301>>>>>                    Get ApiTableCopyData hTable sPhysicalName sRootName sDriverID to bOK
94302>>>>>                    If (ghoDbUpdateHandler > 0) Begin
94304>>>>>                        Get pbContinueOnError to bContinueOnError
94305>>>>>                    End
94305>>>>>>
94305>>>>>                    // If the data copy failed we will keep the newly created SQL table but
94305>>>>>                    // rename it by adding a GUID at the end of the table name
94305>>>>>                    // - or as much as "fit" because different SQL back-ends have
94305>>>>>                    // different rules how long a table name can be.
94305>>>>>                    // The new table will probably contain data but something went
94305>>>>>                    // wrong while converting the data from embedded to SQL.
94305>>>>>                    If (bOK = False and bContinueOnError = False) Begin
94307>>>>>                        Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
94308>>>>>                        Get SqlTableRename hTable sLogicalName sGUIDName to bOK
94309>>>>>                        Error DFERR_PROGRAM ("Copying of data failed. The SQL table:" * sLogicalName * "was renamed to:" * String(sGUIDName))
94310>>>>>>
94310>>>>>                    End
94310>>>>>>
94310>>>>>                End
94310>>>>>>
94310>>>>>            End
94310>>>>>>
94310>>>>>        End
94310>>>>>>
94310>>>>>
94310>>>>>        If (bMertechDriver = True) Begin
94312>>>>>            Open hTable
94314>>>>>        End
94314>>>>>>
94314>>>>>
94314>>>>>        // This must be after copying data...
94314>>>>>        If (Err = False) Begin
94316>>>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
94319>>>>>            // We also adjust the display name by prefixing it by the schema name;
94319>>>>>            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
94321>>>>>                // The max length for the display_name is 31 characters...
94321>>>>>                If (Length(sSchema + "." + sDisplayName) < 31) Begin
94323>>>>>                    Set_Attribute DF_FILE_DISPLAY_NAME of hTable to (Lowercase(sSchema) + "." + sDisplayName)
94326>>>>>                End
94326>>>>>>
94326>>>>>            End
94326>>>>>>
94326>>>>>        End
94326>>>>>>
94326>>>>>
94326>>>>>        Close hTable
94327>>>>>        Move (not(Err)) to bOK
94328>>>>>        Function_Return (bOK = True)
94329>>>>>    End_Function
94330>>>>>
94330>>>>>    // Calls a driver function directly to copy data from one table to another (table structures needs to be the same).
94330>>>>>    // It will first drop all indicies, copy the data and then recreate indicies.
94330>>>>>    // An error log file with the sRootname + ".err" will be created in the Data folder.
94330>>>>>    Function ApiTableCopyData Integer hFromTable String sPhysicalName String sRootName String sDriverID Returns Boolean
94332>>>>>        Boolean bOpened bOK
94332>>>>>        Integer hToTable iIndex iRetval iVoid iOrgFreq
94332>>>>>        String sErrorFile sEmpty sPath
94332>>>>>
94332>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of 0 to hToTable
94335>>>>>        Get AutoConnectionIDLogin to bOK
94336>>>>>        If (sDriverID = DATAFLEX_ID) Begin
94338>>>>>            Send IncreaseSortBufferSize
94339>>>>>//            Send SetAllIndexesToBatch hToTable
94339>>>>>        End
94339>>>>>>
94339>>>>>
94339>>>>>        Move False to Err
94340>>>>>        Open sPhysicalName as hToTable
94342>>>>>        Get_Attribute DF_FILE_OPENED of hToTable to bOpened
94345>>>>>        If (bOpened = False) Begin
94347>>>>>            Function_Return False
94348>>>>>        End
94348>>>>>>
94348>>>>>
94348>>>>>        If (ghoStatusPanel <> 0) Begin
94350>>>>>            Set TableName_Text of ghoStatusPanel to ("Copying Data for Table:" * sRootName * "Number:" * String(hFromTable))
94351>>>>>            Set piMinimum of ghoProgressBar to 0 
94352>>>>>            Set piMaximum of ghoProgressBar to 100 // 100%
94353>>>>>        End
94353>>>>>>
94353>>>>>
94353>>>>>        Move "" to sEmpty
94354>>>>>        Move False to Err
94355>>>>>        Move True to bOK
94356>>>>>        Set Private.phCurrentTable to hToTable
94357>>>>>
94357>>>>>        // No need to get the record identifier
94357>>>>>        Set_Attribute DF_FILE_GET_RID_AFTER_CREATE of hToTable to False        
94360>>>>>        Get_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
94363>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
94365>>>>>            // Remove all indices to speed up copying of data:
94365>>>>>            Call_Driver hToTable sDriverID Function CLI_DROPINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
94370>>>>>            If (iRetval <> 0) Begin
94372>>>>>                Error DFERR_PROGRAM ("Failed dropping indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
94373>>>>>>
94373>>>>>                Function_Return False
94374>>>>>            End
94374>>>>>>
94374>>>>>        End
94374>>>>>>
94374>>>>>
94374>>>>>        Move (sRootName + ".err") to sErrorFile
94375>>>>>        Move 0 to iIndex
94376>>>>>        Move False to Err
94377>>>>>        
94377>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
94379>>>>>            Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to 10
94382>>>>>            Call_Driver hToTable sDriverID Function CLI_BCP CallBack ghoDbUpdateHandler Passing iIndex sEmpty hFromTable Result iRetval
94387>>>>>            If (iRetval <> 0) Begin
94389>>>>>                Error DFERR_PROGRAM ("Failed copying data for table Number:" * String(hToTable) * "Name:" * String(sRootName))
94390>>>>>>
94390>>>>>                Function_Return False
94391>>>>>            End
94391>>>>>>
94391>>>>>        End 
94391>>>>>>
94391>>>>>        Else Begin
94392>>>>>            Copy_Records hFromTable to hToTable using 0 Callback ghoDbUpdateHandler
94395>>>>>        End
94395>>>>>>
94395>>>>>
94395>>>>>        If (Err = False) Begin
94397>>>>>            Get psHome of (phoWorkspace(ghoApplication)) to sPath
94398>>>>>            Get vDeleteFile (sPath + sErrorFile) to iRetval
94399>>>>>        End
94399>>>>>>
94399>>>>>
94399>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
94401>>>>>            // Recreate indices:
94401>>>>>            Call_Driver hToTable sDriverID Function CLI_CREATEINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
94406>>>>>            If (iRetval <> 0) Begin
94408>>>>>                Error DFERR_PROGRAM ("Failed creating indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
94409>>>>>>
94409>>>>>                Function_Return False
94410>>>>>            End
94410>>>>>>
94410>>>>>        End
94410>>>>>>
94410>>>>>
94410>>>>>        Close hToTable
94411>>>>>        Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
94414>>>>>
94414>>>>>        If (bOK = True) Begin
94416>>>>>            Move (not(Err)) to bOK
94417>>>>>        End
94417>>>>>>
94417>>>>>
94417>>>>>        If (ghoStatusPanel <> 0) Begin
94419>>>>>            Set TableName_Text of ghoStatusPanel to ""
94420>>>>>            Set Message_Text   of ghoStatusPanel to ""
94421>>>>>            Set Action_Text    of ghoStatusPanel to ""
94422>>>>>        End
94422>>>>>>
94422>>>>>
94422>>>>>        Function_Return (bOK = True)
94423>>>>>    End_Function
94424>>>>>
94424>>>>>    // The bANSI parameter's default value = True, meaning a table in ANSI format will be created.
94424>>>>>    // i.e. DF_FILE_TABLE_CHARACTER_FORMAT {"OEM"|"ANSI"}
94424>>>>>    Function ApiTableCreate Handle hTable String sRootName String sDisplayName String sLogicalName Boolean bUseConnectionID Boolean bANSI Boolean bRecnum tAPIColumn[] aColumnIn Returns Boolean
94426>>>>>        Handle hFile
94426>>>>>        String sConnectionID sPhysicalFile sANSI_OEM sVal sSchema sOriginalDriverID sDriverID sTableName
94426>>>>>        Integer iColumn iIdentityType iDataType iDbType iCount iSize
94426>>>>>        Boolean bOk bExists bSqlDriver bMertechDriver bDeleteDummy bExistsInFilelist bSysFile
94426>>>>>        tSQLConnection SQLConnection
94426>>>>>        tSQLConnection SQLConnection
94426>>>>>        tAPIColumn[] aColumns
94426>>>>>        tAPIColumn[] aColumns
94427>>>>>        tColumnType ColumnType
94427>>>>>        tColumnType ColumnType
94427>>>>>
94427>>>>>        // First check if the passed filenumber already exists; in case we do nothing
94427>>>>>        Get UtilTableExists hTable to bOk
94428>>>>>        If (bOk = True) Begin
94430>>>>>            Function_Return False
94431>>>>>        End
94431>>>>>>
94431>>>>>
94431>>>>>        Set Private.phCurrentTable to hTable
94432>>>>>        Move sLogicalName to sTableName
94433>>>>>        If (ghoProgressBar <> 0) Begin
94435>>>>>            Send DoAdvance of ghoProgressBar
94436>>>>>            Set TableName_Text of ghoStatusPanel to ("Creating Table:" * String(sTableName) * "Number:" * String(hTable) * String(sLogicalName))
94437>>>>>        End
94437>>>>>>
94437>>>>>
94437>>>>>        Get UtilTableLogicalNameIsInUse sTableName to bExistsInFilelist
94438>>>>>        Get psDriverID to sDriverID
94439>>>>>        Get IsSQLDriver sDriverID to bSqlDriver
94440>>>>>        Get piDbType to iDbType
94441>>>>>
94441>>>>>        // If no columns passed in, we need to create a "dummy" column
94441>>>>>        Move False to bDeleteDummy
94442>>>>>        If (Num_Arguments = 8) Begin
94444>>>>>            Move aColumnIn to aColumns
94445>>>>>        End
94445>>>>>>
94445>>>>>        If ((SizeOfArray(aColumns)) = 0) Begin
94447>>>>>            Get UtilDFDataTypeToSqlTypeMapping sDriverID iDbType DF_BCD to ColumnType
94448>>>>>            Move ColumnType.iSQLType to iDataType
94449>>>>>            If (bRecnum = False) Begin
94451>>>>>                Move C_tAPIColumn_Identity to iIdentityType
94452>>>>>            End
94452>>>>>>
94452>>>>>            Else Begin
94453>>>>>                Move C_tAPIColumn_None     to iIdentityType
94454>>>>>            End
94454>>>>>>
94454>>>>>            Get _AppendAPIColumn aColumns "temp" iDataType 10 0 iIdentityType to aColumns
94455>>>>>            Move True to bDeleteDummy
94456>>>>>        End
94456>>>>>>
94456>>>>>
94456>>>>>        // If columns have been passed as an array we need to check if an identity column
94456>>>>>        // has been specified (aColumns[iCounter].iOptions = C_tAPIColumn_Identity), and
94456>>>>>        // if so auto-set the bRecnum to FALSE. This is because else there would be
94456>>>>>        // two identity columns and SQL doesn't like that and throws an error.
94456>>>>>        If (bRecnum = True and (SizeOfArray(aColumns)) <> 0) Begin
94458>>>>>            Move (SizeOfArray(aColumns)) to iSize
94459>>>>>            Decrement iSize
94460>>>>>            for iCount from 0 to iSize
94466>>>>>>
94466>>>>>                If (aColumns[iCount].iOptions = C_tAPIColumn_Identity) Begin
94468>>>>>                    Move False to bRecnum
94469>>>>>                    Move iSize to iCount
94470>>>>>                End
94470>>>>>>
94470>>>>>            Loop
94471>>>>>>
94471>>>>>        End
94471>>>>>>
94471>>>>>
94471>>>>>        // If this is a SQL based driver we also check if the table exists
94471>>>>>        // in the SQL back end; in case we do nothing.
94471>>>>>        If (bSqlDriver = True) Begin
94473>>>>>            // Get all connection properties
94473>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
94474>>>>>            Move SQLConnection.sSchema to sSchema
94475>>>>>            If (sSchema = "") Begin
94477>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
94478>>>>>            End
94478>>>>>>
94478>>>>>
94478>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
94479>>>>>            // It can happen that the table is missing from Filelist.cfg but still
94479>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
94479>>>>>            If (bExists = False) Begin
94481>>>>>                Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
94482>>>>>            End
94482>>>>>>
94482>>>>>            // If the table exists on the SQL back-end but not in Filelist.cfg,
94482>>>>>            // we will just add it to Filelist.cfg
94482>>>>>            If (bExists = True) Begin
94484>>>>>                If (bExistsInFilelist = False) Begin
94486>>>>>                    If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
94488>>>>>                        Move (sDriverID + ":" + sRootName) to sRootName
94489>>>>>                    End
94489>>>>>>
94489>>>>>                    Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
94492>>>>>                    Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
94495>>>>>                    Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
94498>>>>>                    Move False to bSysFile
94499>>>>>                    Get SqlUtilCreateIntFile hTable sDriverID SQLConnection.sConnectionID bANSI bSysFile to bOK
94500>>>>>                End
94500>>>>>>
94500>>>>>                Function_Return False
94501>>>>>            End
94501>>>>>>
94501>>>>>        End
94501>>>>>>
94501>>>>>
94501>>>>>        Move CS_ANSI_Txt to sANSI_OEM
94502>>>>>        If (num_arguments > 6) Begin
94504>>>>>            If (bANSI = False) Begin
94506>>>>>                Move CS_OEM_Txt to sANSI_OEM
94507>>>>>            End
94507>>>>>>
94507>>>>>        End
94507>>>>>>
94507>>>>>
94507>>>>>        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
94507>>>>>        // is a programmer's error and we auto-correct for it here.
94507>>>>>        // This is also a bit messy. If a Mertech driver is used and we want to create a new table,
94507>>>>>        // we first need to create it as embedded (DataFlex) and then convert it to SQL (!)
94507>>>>>        // So we set the driver ID temporarily to "DataFlex" to get the table created as embedded and later
94507>>>>>        // set it back and use a Mertech function to convert it to SQL.
94507>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
94508>>>>>        If (bMertechDriver = True) Begin
94510>>>>>            If (bUseConnectionID = True) Begin
94512>>>>>                Move False to bUseConnectionID
94513>>>>>            End
94513>>>>>>
94513>>>>>            Move sDriverID to sOriginalDriverID
94514>>>>>            Move DATAFLEX_ID to sDriverID
94515>>>>>        End
94515>>>>>>
94515>>>>>
94515>>>>>        Move False to Err
94516>>>>>        If (sDriverID = DATAFLEX_ID) Begin
94518>>>>>            Move sRootName to sPhysicalFile
94519>>>>>        End
94519>>>>>>
94519>>>>>
94519>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
94521>>>>>            Move SQLConnection.sConnectionID to sConnectionID
94522>>>>>
94522>>>>>            // If DAW driver and we should use a connection id we need to
94522>>>>>            // check if the connection ID exists; else we create it before attempting creating the table
94522>>>>>            If (bMertechDriver = False and bUseConnectionID = True) Begin
94524>>>>>                Get IsConnectionID sConnectionID sDriverID to bExists
94525>>>>>                If (bExists = False) Begin
94527>>>>>                    Get UtilCreateConnectionID sConnectionID to bOk
94528>>>>>                    If (bOk = False) Begin
94530>>>>>                        Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
94531>>>>>>
94531>>>>>                        Function_Return False
94532>>>>>                    End
94532>>>>>>
94532>>>>>                End
94532>>>>>>
94532>>>>>            End
94532>>>>>>
94532>>>>>
94532>>>>>            If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
94534>>>>>                Move (sTableName + ".int") to sPhysicalFile
94535>>>>>            End
94535>>>>>>
94535>>>>>            Else Begin
94536>>>>>                Move (sRootName + ".int") to sPhysicalFile
94537>>>>>            End
94537>>>>>>
94537>>>>>            Move (Uppercase(sDisplayName)) to sVal
94538>>>>>            If (not(sVal contains (sSchema + "."))) Begin
94540>>>>>                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
94541>>>>>            End
94541>>>>>>
94541>>>>>        End
94541>>>>>>
94541>>>>>        Move False to Err
94542>>>>>        Move 0 to hFile
94543>>>>>
94543>>>>>        Structure_Start hFile sDriverID
94544>>>>>            If (sDriverID <> DATAFLEX_ID) Begin
94546>>>>>                If (bUseConnectionID = True) Begin
94548>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to (CS_DFCONNID + "=" + sConnectionID)
94551>>>>>                End
94551>>>>>>
94551>>>>>                Else Begin
94552>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to SQLConnection.sConnectionString
94555>>>>>                End
94555>>>>>>
94555>>>>>                Set_Attribute DF_FILE_TABLE_NAME               of hFile to sTableName
94558>>>>>                Set_Attribute DF_FILE_USE_DUMMY_ZERO_DATE      of hFile to True
94561>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT   of hFile to sANSI_OEM
94564>>>>>                Set_Attribute DF_FILE_RECNUM_TABLE             of hFile to bRecnum
94567>>>>>
94567>>>>>                If (sSchema <> "") Begin
94569>>>>>                    Set_Attribute DF_FILE_OWNER                of hFile to sSchema
94572>>>>>                End
94572>>>>>>
94572>>>>>
94572>>>>>                If (sDriverID = DB2_DRV_ID) Begin
94574>>>>>                    If (SQLConnection.sLongTableSpace <> "") Begin
94576>>>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hFile to SQLConnection.sLongTableSpace
94579>>>>>                    End
94579>>>>>>
94579>>>>>                End
94579>>>>>>
94579>>>>>                If (sDriverID = DB2_DRV_ID or sDriverID = ORAFLEX or sDriverID = MDSPgSQL) Begin
94581>>>>>                    If (SQLConnection.sBaseTableSpace <> "") Begin
94583>>>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hFile to SQLConnection.sBaseTableSpace
94586>>>>>                    End
94586>>>>>>
94586>>>>>                    If (SQLConnection.sIndexTableSpace <> "") Begin
94588>>>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hFile to SQLConnection.sIndexTableSpace
94591>>>>>                    End
94591>>>>>>
94591>>>>>                End
94591>>>>>>
94591>>>>>            End
94591>>>>>>
94591>>>>>
94591>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hFile to sPhysicalFile
94594>>>>>            Get ApiColumnsAddToTable hFile aColumns True to bOk
94595>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
94596>>>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
94598>>>>>        Set Action_Text of ghoStatusPanel to ""
94599>>>>>
94599>>>>>        // If Mertech driver we convert the newly created embedded table (DataFlex) to SQL
94599>>>>>        If (bMertechDriver = True) Begin
94601>>>>>            Move sOriginalDriverID to sDriverID
94602>>>>>            If (not(sVal contains (sSchema + "."))) Begin
94604>>>>>                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
94605>>>>>            End
94605>>>>>>
94605>>>>>            // Note: This function also sets the Err flag.
94605>>>>>            Get _MertechApiTableConvertToSQL hTable sRootName SQLConnection.sDatabase sDriverID SQLConnection.sBaseTableSpace SQLConnection.sIndexTableSpace False to bOK
94606>>>>>        End
94606>>>>>>
94606>>>>>
94606>>>>>        Move (not(Err)) to bOK
94607>>>>>        If (bOk = True) Begin
94609>>>>>            If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
94611>>>>>                Move (sDriverID + ":" + sRootName) to sRootName
94612>>>>>            End
94612>>>>>>
94612>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
94615>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
94618>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
94621>>>>>
94621>>>>>            // Lastly we remove the temporary column we created above, if all went well.
94621>>>>>            If (bDeleteDummy) Begin
94623>>>>>                Get ApiColumnRemove hTable "temp" to bOk
94624>>>>>            End
94624>>>>>>
94624>>>>>        End
94624>>>>>>
94624>>>>>
94624>>>>>        Close hTable
94625>>>>>        Function_Return (bOK = True)
94626>>>>>    End_Function
94627>>>>>
94627>>>>>    Function ApiTableCreateAlias String sFileName String sDisplayName String sAliasName Integer iFilelistSlot Returns Boolean
94629>>>>>        Move False to Err
94630>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of iFilelistSlot to sFileName
94633>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of iFilelistSlot to sDisplayName
94636>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of iFilelistSlot to sAliasName
94639>>>>>
94639>>>>>        Function_Return (Err = False)
94640>>>>>    End_Function
94641>>>>>
94641>>>>>    // ToDo: Needs to be revised
94641>>>>>    Procedure ApiTableCreateFromDEF String sPath String sFileName String sTableName String sDisplayName Integer iFilelistSlot
94643>>>>>        Handle hTable
94643>>>>>        String sDEFName sDataPath
94643>>>>>        Boolean bExists
94643>>>>>
94643>>>>>        // Do nothing if MSSQL Driver.
94643>>>>>//        Get IsMSSQLDriver to bExists
94643>>>>>//        If (bExists = True) Begin
94643>>>>>//            Procedure_Return
94643>>>>>//        End
94643>>>>>
94643>>>>>        Get psDataPathFirstPart to sDataPath
94644>>>>>        Get vFilePathExists (sDataPath + sFileName + ".dat") to bExists
94645>>>>>        If (bExists = True) Begin
94647>>>>>            // We also needs to check if it is an Alias file, in case the sFileName.dat exists, but it may
94647>>>>>            // still be missing from the filelist and needs to be added.
94647>>>>>            Get UtilTableNumberIsInUse iFilelistSlot to bExists
94648>>>>>            If (bExists = True) Begin
94650>>>>>                Procedure_Return
94651>>>>>            End
94651>>>>>>
94651>>>>>            // Do _not_ use the DEF file if an alias, it will overwrite the base table data.
94651>>>>>            Else Begin
94652>>>>>                Set_Attribute DF_FILE_ROOT_NAME    of iFilelistSlot to sFileName
94655>>>>>                Set_Attribute DF_FILE_LOGICAL_NAME of iFilelistSlot to sTableName
94658>>>>>                Set_Attribute DF_FILE_DISPLAY_NAME of iFilelistSlot to sDisplayName
94661>>>>>                Procedure_Return
94662>>>>>            End
94662>>>>>>
94662>>>>>        End
94662>>>>>>
94662>>>>>
94662>>>>>        Move (sPath + sFileName + ".def") to sDEFName
94663>>>>>        Move 0 to hTable
94664>>>>>        Move False to Err
94665>>>>>
94665>>>>>        Structure_Start hTable DATAFLEX_ID
94666>>>>>            Load_Def sDEFName Onto hTable
94667>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hTable to sFileName
94670>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
94671>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
94673>>>>>        Set Action_Text of ghoStatusPanel to ""
94674>>>>>
94674>>>>>        Move iFilelistSlot to hTable
94675>>>>>        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sFileName
94678>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
94681>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
94684>>>>>
94684>>>>>    End_Procedure
94685>>>>>
94685>>>>>    Function ApiTableMoveToFileSlot Integer iFromFileSlot Integer iToFileSlot String sDriverID Returns Boolean
94687>>>>>        Boolean bTmp bErr bOK
94687>>>>>        String sTableName sDisplayName sFileName
94687>>>>>
94687>>>>>        // We preserve the value of the Err flag, by saving its current state and resetting it before end of function.
94687>>>>>        Move Err to bTmp
94688>>>>>        Move False to Err
94689>>>>>
94689>>>>>        Get AutoConnectionIDLogin to bOK
94690>>>>>        // First get the info for the current filelist slot:
94690>>>>>        Open iFromFileSlot
94692>>>>>        Get_Attribute DF_FILE_OPENED of iFromFileSlot to bOK
94695>>>>>        If (bOK = True) Begin
94697>>>>>            Get_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to sFileName
94700>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to sTableName
94703>>>>>            Get_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to sDisplayName
94706>>>>>
94706>>>>>            //...then move it.
94706>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iToFileSlot to sFileName
94709>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iToFileSlot to sTableName
94712>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iToFileSlot to sDisplayName
94715>>>>>
94715>>>>>            //...and finally remove the old filelist values.
94715>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to ""
94718>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to ""
94721>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to ""
94724>>>>>        End
94724>>>>>>
94724>>>>>        Close iFromFileSlot
94725>>>>>
94725>>>>>        Move Err to bErr
94726>>>>>        Move bTmp to Err
94727>>>>>        Function_Return (bErr = False)
94728>>>>>    End_Function
94729>>>>>
94729>>>>>    Function ApiTableRelate Handle hTableFrom Handle hTableTo Integer iColumnFrom Integer iColumnTo Returns Boolean
94731>>>>>        Handle hTable
94731>>>>>        Boolean bOK
94731>>>>>        String sDriverID
94731>>>>>
94731>>>>>        Get AutoConnectionIDLogin to bOK
94732>>>>>        Move False to Err
94733>>>>>        Open hTableFrom Mode DF_EXCLUSIVE
94735>>>>>        If (hTableTo > 0) Begin
94737>>>>>            Open hTableTo
94739>>>>>        End
94739>>>>>>
94739>>>>>        Move hTableFrom to hTable
94740>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
94743>>>>>        Set Private.phCurrentTable to hTable
94744>>>>>
94744>>>>>        Structure_Start hTable sDriverID            
94745>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumnFrom to hTableTo
94748>>>>>            If (iColumnTo <> 0) Begin
94750>>>>>                Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumnFrom to iColumnTo
94753>>>>>            End
94753>>>>>>
94753>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
94754>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
94756>>>>>        Set Action_Text of ghoStatusPanel to ""
94757>>>>>
94757>>>>>        If (hTableTo > 0) Begin
94759>>>>>            Close hTableTo
94760>>>>>        End
94760>>>>>>
94760>>>>>
94760>>>>>        Function_Return (Err = False)
94761>>>>>    End_Function
94762>>>>>
94762>>>>>    // Removes the passed table name completely from disk, filelist (& Sql Server if an Sql-driver)
94762>>>>>    Function ApiTableRemove Handle hTable Returns Boolean
94764>>>>>        String sTableName sDriverID
94764>>>>>        Boolean bOk
94764>>>>>        String sDataPath
94764>>>>>
94764>>>>>        Get AutoConnectionIDLogin to bOK
94765>>>>>        Move False to Err
94766>>>>>        Get psDriverID to sDriverID
94767>>>>>        Get UtilTableHandleToString hTable sDriverID to sTableName
94768>>>>>        If (sTableName = "") Begin
94770>>>>>            Function_Return False
94771>>>>>        End
94771>>>>>>
94771>>>>>
94771>>>>>        Set Private.phCurrentTable to hTable
94772>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
94773>>>>>        Delete_db sTableName
94774>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
94775>>>>>
94775>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
94777>>>>>            Get SqlTableRemoveByTableName sDriverID sTableName to bOk
94778>>>>>            Get psDataPathFirstPart to sDataPath
94779>>>>>            Get vDeleteFile (sDataPath + sTableName + ".int") to bOk
94780>>>>>        End
94780>>>>>>
94780>>>>>        // Also remove table from filelist.cfg in case the physical file didn't exist.
94780>>>>>        If (hTable <> 0) Begin
94782>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
94785>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
94788>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
94791>>>>>        End
94791>>>>>>
94791>>>>>
94791>>>>>        Close hTable
94792>>>>>        Function_Return (hTable <> 0)
94793>>>>>    End_Function
94794>>>>>
94794>>>>>    Function ApiTableRemoveRelation Handle hTableTo Integer iColumn Returns Boolean
94796>>>>>        Handle hTable
94796>>>>>        Boolean bOK
94796>>>>>
94796>>>>>        Get AutoConnectionIDLogin to bOK
94797>>>>>        Move False to Err
94798>>>>>        Open hTableTo Mode DF_EXCLUSIVE
94800>>>>>        Move hTableTo to hTable
94801>>>>>
94801>>>>>        Structure_Start hTable
94802>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to 0
94805>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
94806>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
94808>>>>>        Set Action_Text of ghoStatusPanel to ""
94809>>>>>
94809>>>>>        Close hTableTo
94810>>>>>        Function_Return (Err = False)
94811>>>>>    End_Function
94812>>>>>
94812>>>>>    Function ApiTableRename Integer hTable String sRootName String sDisplayName String sLogicalName Returns Boolean
94814>>>>>        String sPhysicalName sRootNameTo sLogicalNameTo sDataPath sDriverID sSchema sPhysicalNameTo
94814>>>>>        Boolean bOK bExists bOpened     
94814>>>>>        tAPITableNameInfo APITableNameInfo
94814>>>>>        tAPITableNameInfo APITableNameInfo
94814>>>>>        
94814>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
94817>>>>>        If (bOpened = False) Begin
94819>>>>>            Get OpenTableExclusive hTable to bOpened
94820>>>>>            If (bOpened = False) Begin
94822>>>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
94823>>>>>                Function_Return False
94824>>>>>            End
94824>>>>>>
94824>>>>>        End
94824>>>>>>
94824>>>>>
94824>>>>>        Set Private.phCurrentTable to hTable
94825>>>>>        Move hTable         to APITableNameInfo.iTableNumber
94826>>>>>        Move sRootName      to APITableNameInfo.sRootName
94827>>>>>        Move sLogicalName   to APITableNameInfo.sLogicalName
94828>>>>>        Move sDisplayName   to APITableNameInfo.sDisplayName
94829>>>>>        Get ApiTableFilelistNamesCompare True APITableNameInfo to bExists
94830>>>>>        If (bExists = True) Begin
94832>>>>>            Function_Return True
94833>>>>>        End
94833>>>>>>
94833>>>>>        
94833>>>>>        Set Private.phCurrentTable to hTable
94834>>>>>        Move False to Err  
94835>>>>>        Get psDataPathFirstPart to sDataPath
94836>>>>>        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName
94839>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
94842>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
94845>>>>>
94845>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
94848>>>>>        Close hTable
94849>>>>>        If (sDriverID = DATAFLEX_ID) Begin
94851>>>>>            Get vFilePathExists (sDataPath + sRootNameTo + ".dat") to bExists
94852>>>>>            If (bExists = True) Begin
94854>>>>>                If (Uppercase(sRootName) <> Uppercase(sRootNameTo)) Begin
94856>>>>>                    Copy_db (sDataPath + sRootNameTo) to (sDataPath + sRootName)
94859>>>>>                    // We need a short break here before attempting to delete the physical old files or Windows
94859>>>>>                    // might report "File in use..." and the deletion will fail.
94859>>>>>                    Sleep 2
94860>>>>>                    Get vDeleteFile (sDataPath + sRootNameTo + ".*") to bOK
94861>>>>>                End
94861>>>>>>
94861>>>>>            End
94861>>>>>>
94861>>>>>        End
94861>>>>>>
94861>>>>>
94861>>>>>        If (sDriverID <> DATAFLEX_ID) Begin           
94863>>>>>            If (not(sPhysicalName contains ".")) Begin
94865>>>>>                Move (sPhysicalName + String(".int")) to sPhysicalName
94866>>>>>            End
94866>>>>>>
94866>>>>>            
94866>>>>>            // Change the table name in the .int file to the new table new:
94866>>>>>            Get UtilChangeSourceCodeLine (sDataPath + sPhysicalName) (CS_DATABASE_NAME * String(sLogicalNameTo)) (CS_DATABASE_NAME * String(sLogicalName)) False to bOK
94867>>>>>            If (bOK = False) Begin
94869>>>>>                Function_Return False
94870>>>>>            End
94870>>>>>>
94870>>>>>            
94870>>>>>            // Change table name at the SQL side:
94870>>>>>            Get psSchema to sSchema
94871>>>>>            Get SqlTableRename hTable sLogicalNameTo sLogicalName to bOK 
94872>>>>>            
94872>>>>>            Get _TableNameOnly sRootName to sPhysicalNameTo
94873>>>>>            // Remove cache file and Rename the physical file names:
94873>>>>>            Get vDeleteFile (sDataPath + sPhysicalNameTo + ".cch")                                  to bOK 
94874>>>>>            Get vRenameFile (sDataPath + sPhysicalName)            (sDataPath + sRootName + ".int") to bOK
94875>>>>>            Get vRenameFile (sDataPath + sPhysicalNameTo + ".tag") (sDataPath + sRootName + ".tag") to bOK
94876>>>>>            Move (sDriverID + ":" + sRootName) to sRootName         
94877>>>>>            If (not(sDisplayName contains ".")) Begin
94879>>>>>                Move (sSchema + "." + sDisplayName) to sDisplayName
94880>>>>>            End
94880>>>>>>
94880>>>>>        End
94880>>>>>>
94880>>>>>
94880>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
94883>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
94886>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
94889>>>>>
94889>>>>>        Function_Return (Err = False)
94890>>>>>    End_Function
94891>>>>>
94891>>>>>    Function ApiTableRenameAlias Integer hTable String sDisplayName String sLogicalName Returns Boolean
94893>>>>>        Move False to Err
94894>>>>>        Set Private.phCurrentTable to hTable
94895>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
94898>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
94901>>>>>
94901>>>>>        Function_Return (Err = False)
94902>>>>>    End_Function
94903>>>>>
94903>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
94903>>>>>    // Note that it first removes any driver prefixes in the rootname.
94903>>>>>    Function ApiTableFilelistNamesCompare Boolean bCompareFilelistUppercase tAPITableNameInfo APITableInfo Returns Boolean
94905>>>>>        String sRootNameFrom sRootNameTo sDisplayNameTo sLogicalNameTo
94905>>>>>        Handle hTable
94905>>>>>        Boolean bIsSame
94905>>>>>
94905>>>>>        Move APITableInfo.iTableNumber      to hTable
94906>>>>>        Get _TableNameOnly APITableInfo.sRootName     to sRootNameFrom
94907>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
94910>>>>>        Get _TableNoPrefix sRootNameTo                to sRootNameTo
94911>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
94914>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayNameTo
94917>>>>>        Get _TableNoPrefix sDisplayNameTo             to sDisplayNameTo
94918>>>>>
94918>>>>>        If (bCompareFilelistUppercase = True) Begin
94920>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(APITableInfo.sLogicalName) = Uppercase(sLogicalNameTo) and ;                  Uppercase(APITableInfo.sDisplayName) = Uppercase(sDisplayNameTo)) to bIsSame
94921>>>>>        End
94921>>>>>>
94921>>>>>        Else Begin
94922>>>>>            Move (sRootNameFrom = sRootNameTo and APITableInfo.sLogicalName = sLogicalNameTo and APITableInfo.sDisplayName = sDisplayNameTo) to bIsSame
94923>>>>>        End
94923>>>>>>
94923>>>>>
94923>>>>>        Function_Return bIsSame
94924>>>>>    End_Function
94925>>>>>    
94925>>>>>    // Note: This table update function does _not_ convert an embedded table to SQL. Use function ApiTableConvertToSQL first for that.
94925>>>>>    Function ApiTableUpdate tAPITableNameInfo APITableNameInfoFrom tAPIColumn[] aColumnsFrom tAPIIndex[] aIndexesFrom tAPIRelation[] aRelationsFrom Returns Boolean
94927>>>>>        Handle hFile hTable
94927>>>>>        String sTableName sLogicalName sDisplayName
94927>>>>>        String sConnectionID sVal sSchema sOriginalDriverID sDriverIDFrom sDriverIDTo sRootName
94927>>>>>        Integer iColumn iDbType
94927>>>>>        Boolean bOk bExists bMertechDriver bExistsInFilelist bOpened bApiTableUpdateAuto
94927>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase bTableExists
94927>>>>>        Boolean bIsSame bSameTableNames bFilelistError bIsAliasFrom bIsAliasTo bIsSQLTableFrom bIsSQLTableTo
94927>>>>>        tSQLConnection SQLConnection
94927>>>>>        tSQLConnection SQLConnection
94927>>>>>        tAPITable      APITableFrom APITableTo
94927>>>>>        tAPITable      APITableFrom APITableTo
94927>>>>>        tColumnType    ColumnType
94927>>>>>        tColumnType    ColumnType
94927>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
94927>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
94928>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
94928>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
94929>>>>>        tAPIRelationCompare[] aAPIRelationCompare
94929>>>>>        tAPIRelationCompare[] aAPIRelationCompare
94930>>>>>
94930>>>>>        // We don't allow update of the framework's DbVersion table.
94930>>>>>        If (Lowercase(sTableName) = "dbversion") Begin
94932>>>>>            Function_Return False
94933>>>>>        End
94933>>>>>>
94933>>>>>        
94933>>>>>        Move APITableNameInfoFrom.sDriverID     to sDriverIDFrom
94934>>>>>        Get piDbType                            to iDbType
94935>>>>>        Get pbRecnum                            to bRecnum
94936>>>>>        Get pbToANSI                            to bToANSI
94937>>>>>        Get pbCopyData                          to bCopyData
94938>>>>>        Get pbApiTableUpdateAuto                to bApiTableUpdateAuto
94939>>>>>        Get pbCompareDate_DateTime              to bCompareDate_DateTime
94940>>>>>        Get pbCompareIndexAscending             to bCompareIndexAscending
94941>>>>>        Get pbCompareIndexUppercase             to bCompareIndexUppercase   
94942>>>>>        Get IsMertechDriver sDriverIDFrom       to bMertechDriver
94943>>>>>        Get pbUseConnectionID                   to bUseConnectionID
94944>>>>>        If (bMertechDriver = True and bUseConnectionID = True) Begin
94946>>>>>            Move False                          to bUseConnectionID
94947>>>>>        End
94947>>>>>>
94947>>>>>
94947>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
94948>>>>>        Set Private.phCurrentTable              to hTable
94949>>>>>        Get UtilTableExists  hTable             to bTableExists     
94950>>>>>        
94950>>>>>        If (ghoProgressBar <> 0) Begin
94952>>>>>            Send DoAdvance of ghoProgressBar
94953>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
94954>>>>>        End
94954>>>>>>
94954>>>>>
94954>>>>>        Move APITableNameInfoFrom.bIsAlias      to bIsAliasFrom
94955>>>>>        Move APITableNameInfoFrom.bIsSQL        to bIsSQLTableFrom
94956>>>>>        Get UtilDriverFromTableNumber hTable    to sDriverIDTo
94957>>>>>        Get UtilTableIsSQL   hTable             to bIsSQLTableTo
94958>>>>>        Move True                               to APITableFrom.bFromTable
94959>>>>>        Move hTable                             to APITableFrom.hTable
94960>>>>>        Move APITableNameInfoFrom               to APITableFrom.ApiTableInfo
94961>>>>>        Move aColumnsFrom                       to APITableFrom.aApiColumns
94962>>>>>        Move aIndexesFrom                       to APITableFrom.aApiIndexes
94963>>>>>        Move aRelationsFrom                     to APITableFrom.aApiRelations
94964>>>>>        
94964>>>>>        If (bTableExists = True) Begin
94966>>>>>            Get OpenTableExclusive hTable to bOpened
94967>>>>>            If (bOpened = False) Begin
94969>>>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
94970>>>>>                Function_Return False
94971>>>>>            End
94971>>>>>>
94971>>>>>            Get UtilTableStructFill hTable False                                                        to APITableTo
94972>>>>>            Get UtilColumnCombineFromAndToArrays APITableFrom.aApiColumns     APITableTo.aApiColumns    to aAPIColumnCompare
94973>>>>>            Get UtilIndexCombineFromAndToArrays  APITableFrom.aApiIndexes     APITableTo.aApiIndexes    to aAPIIndexCompare
94974>>>>>            Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations  to aAPIRelationCompare
94975>>>>>        End
94975>>>>>>
94975>>>>>        
94975>>>>>        Move False to Err
94976>>>>>        Case Begin
94976>>>>>            // Alias table:
94976>>>>>            Case (bIsAliasFrom = True)
94978>>>>>                Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
94979>>>>>                Case Break
94980>>>>>            
94980>>>>>            // New Table:
94980>>>>>            Case (bTableExists = False)
94983>>>>>                Get ApiTableCreate      hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName bUseConnectionID bToANSI bRecnum aColumnsFrom to bOk
94984>>>>>                Get UtilIndexesUpdate   hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
94985>>>>>                Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
94986>>>>>                Case Break
94987>>>>>    
94987>>>>>            // Update table:    
94987>>>>>            Case (bTableExists = True)
94990>>>>>                Get UtilTableCompare APITableFrom APITableTo False (&bFilelistError) to bIsSame
94991>>>>>                If (bIsSame = True) Begin
94993>>>>>                    Case Break
94994>>>>>                End
94994>>>>>>
94994>>>>>                If (bFilelistError = True) Begin
94996>>>>>                    Get ApiTableRename hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName to bOk
94997>>>>>                    If (bOk = False) Begin
94999>>>>>                        Case Break
95000>>>>>                    End
95000>>>>>>
95000>>>>>                End
95000>>>>>>
95000>>>>>
95000>>>>>                If (ghoProgressBar <> 0) Begin
95002>>>>>                    Send DoAdvance of ghoProgressBar
95003>>>>>                    Set TableName_Text of ghoStatusPanel to ("Updating Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
95004>>>>>                End
95004>>>>>>
95004>>>>>        
95004>>>>>                // Columns:            
95004>>>>>                Move True to bOk
95005>>>>>                Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
95006>>>>>                If (bIsSame = False) Begin
95008>>>>>                    Get ApiColumnsUpdate sDriverIDFrom hTable bIsSQLTableFrom APITableFrom.aApiColumns APITableTo.aApiColumns bCompareDate_DateTime to bOk
95009>>>>>                End
95009>>>>>>
95009>>>>>                If (bOk = False) Begin
95011>>>>>                    Case Break
95012>>>>>                End
95012>>>>>>
95012>>>>>
95012>>>>>                // Indexes:
95012>>>>>                Get UtilIndexesCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
95013>>>>>                If (bIsSame = False) Begin
95015>>>>>                    Get UtilIndexesUpdate hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
95016>>>>>                End
95016>>>>>>
95016>>>>>                
95016>>>>>                // Relations:
95016>>>>>                Get UtilRelationsCompare hTable aAPIRelationCompare to bIsSame
95017>>>>>                If (bIsSame = False) Begin
95019>>>>>                    Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
95020>>>>>                    If (bOk = False) Begin
95022>>>>>                        Case Break
95023>>>>>                    End
95023>>>>>>
95023>>>>>                End                                                               
95023>>>>>>
95023>>>>>                
95023>>>>>                // Filelist Names:
95023>>>>>                Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
95024>>>>>                Case Break
95025>>>>>
95025>>>>>            Case Else
95025>>>>>                Error DFERR_PROGRAM "Unknown Case structure exit in Function ApiTableUpdate"
95026>>>>>>
95026>>>>>                Move False to bOk
95027>>>>>        Case End                     
95027>>>>>
95027>>>>>        Close hTable
95028>>>>>        Set TableName_Text of ghoStatusPanel to ""
95029>>>>>
95029>>>>>        Function_Return (bOK = True)
95030>>>>>    End_Function
95031>>>>>    
95031>>>>>    // Replaces all date values with CS_DUFLowestAllowedDateValue for all tables in Filelist.cfg,
95031>>>>>    // _except_ those tables that has been excluded with the "ApiTableDateCorrectionAddException" message.
95031>>>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.               
95031>>>>>    // This is for prepairing embedded tables (*.dat) before an SQL conversion.
95031>>>>>    //
95031>>>>>    // The root of the problem is the following:
95031>>>>>    // The data type Date in SQL has a range of accepted values from 01-01-0001 through 12-31-9999
95031>>>>>    // while the data type DateTime has a range of accepted values from 01-01-1753 through 12-31-9999
95031>>>>>    // So if you happen to have a Date from before 1753, or an empty / NULL value - this will be outside 
95031>>>>>    // the range that DateTime can handle and if you then try to change a Date column to a DateTime,
95031>>>>>    // an SQL error will be thrown;
95031>>>>>    // "The conversion of a date data type to a datetime data type resulted in an out-of-range value".
95031>>>>>    Function ApiTableFixAllDateBogusValues Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
95033>>>>>        Boolean bOK bIsAlias bIsSQL
95033>>>>>        Integer iCount iSize iDateSize iItems
95033>>>>>        Handle hTable                        
95033>>>>>        String sLogicalName
95033>>>>>        Integer[] aTablesToCheck aDateFields
95035>>>>>        
95035>>>>>        Get _AllTablesDateCorrections to aTablesToCheck
95036>>>>>        Move (SizeOfArray(aTablesToCheck)) to iSize
95037>>>>>        Set pbVisible    of ghoProgressBarOverall to True
95038>>>>>        Set piPosition   of ghoProgressBarOverall to 0
95039>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
95040>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
95041>>>>>
95041>>>>>        Move True to bOK
95042>>>>>        Decrement iSize
95043>>>>>        for iCount from 0 to iSize
95049>>>>>>
95049>>>>>            Move aTablesToCheck[iCount] to hTable 
95050>>>>>            Set piPosition of ghoProgressBarOverall to iCount
95051>>>>>            Get UtilTableIsAlias hTable to bIsAlias
95052>>>>>            Get UtilTableIsSql   hTable to bIsSQL
95053>>>>>            
95053>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
95056>>>>>            Set TableName_Text of ghoStatusPanel to ("Processing Table Number:" * String(hTable) * "Name:" * String(sLogicalName))
95057>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
95058>>>>>
95058>>>>>            If (bIsAlias = False and bIsSQL = False) Begin
95060>>>>>                Get UtilCheckForDateFields hTable to aDateFields
95061>>>>>                Move (SizeOfArray(aDateFields)) to iDateSize
95062>>>>>                If (iDateSize > 0) Begin
95064>>>>>                    Get UtilTableCorrectBogusDateValues hTable aDateFields bFixZeroDates bResetIndexesToOnLine to bOK
95065>>>>>                    Close hTable                                     
95066>>>>>                End
95066>>>>>>
95066>>>>>            End  
95066>>>>>>
95066>>>>>        Loop
95067>>>>>>
95067>>>>>        
95067>>>>>        Close DF_ALL
95068>>>>>        Function_Return bOK
95069>>>>>    End_Function
95070>>>>>    
95070>>>>>    // Returns all fields of type Date or DateTime in an integer array with the field numbers.
95070>>>>>    Function UtilCheckForDateFields Handle hTable Returns Integer[]
95072>>>>>        Integer[] aDateFields aDateFieldsEmpty
95074>>>>>        Integer iField iSize iCount iType
95074>>>>>        Boolean bOpen
95074>>>>>        
95074>>>>>        Open hTable
95076>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
95079>>>>>        If (bOpen = False) Begin  
95081>>>>>            Error ("Table could not be opened." * String(hTable))
95082>>>>>>
95082>>>>>            Function_Return aDateFieldsEmpty
95083>>>>>        End                                 
95083>>>>>>
95083>>>>>        
95083>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iSize
95086>>>>>        for iCount from 1 to iSize
95092>>>>>>
95092>>>>>            Get_Attribute DF_FIELD_TYPE of hTable iCount to iType
95095>>>>>            If (iType = DF_DATE or iType = DF_DATETIME) Begin
95097>>>>>                Move iCount to aDateFields[SizeOfArray(aDateFields)]
95098>>>>>            End
95098>>>>>>
95098>>>>>        Loop
95099>>>>>>
95099>>>>>        
95099>>>>>        Function_Return aDateFields
95100>>>>>    End_Function         
95101>>>>>        
95101>>>>>    // Loops through all records for the passed hTable, and checks that all Date values
95101>>>>>    // for the passed aDateFields array are OK. Else the Data value is set to CS_DUFLowestAllowedDateValue
95101>>>>>    // and the record is saved  
95101>>>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed. 
95101>>>>>    // Note: It first sets all indexes to BATCH and reset them at the end.
95101>>>>>    Function UtilTableCorrectBogusDateValues Handle hTable Integer[] aDateFields Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
95103>>>>>        Integer iSize iCount iField iRecord iRetval iTotalRecords iDateFormat
95103>>>>>        String sValue    
95103>>>>>        Boolean bCancel bFound bOK bChange bOpened bSaveChanges
95103>>>>>        Date dDate dDateMin 
95103>>>>>        Integer[] iaChangeField
95104>>>>>        
95104>>>>>        // The CS_DUFLowestAllowedDateValue is defined as "01/01/1753", so we first set the 
95104>>>>>        // date format to "USA" = "MM/DD/YYYY"
95104>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
95107>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_USA
95110>>>>>        
95110>>>>>        Send SetAllIndexesToBatch hTable True
95111>>>>>        Open hTable                               
95113>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
95116>>>>>        If (bOpened = False) Begin
95118>>>>>            Function_Return False
95119>>>>>        End                      
95119>>>>>>
95119>>>>>        
95119>>>>>        Set Private.phCurrentTable to hTable
95120>>>>>        Move 0 to iRecord
95121>>>>>        Move (SizeOfArray(aDateFields)) to iSize
95122>>>>>        Decrement iSize
95123>>>>>        
95123>>>>>        Get_Attribute DF_FILE_RECORDS_USED of hTable to iTotalRecords
95126>>>>>        Set piPosition   of ghoProgressBar to 0
95127>>>>>        Set piAdvanceBy  of ghoProgressBar to 100
95128>>>>>        Set piMaximum    of ghoProgressBar to iTotalRecords
95129>>>>>        Move CS_DUFLowestAllowedDateValue  to dDateMin
95130>>>>>        Move False to Err
95131>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
95132>>>>>        
95132>>>>>        Clear hTable     
95133>>>>>        Repeat
95133>>>>>>
95133>>>>>            Vfind hTable 0 GT
95135>>>>>            Move Found to bFound
95136>>>>>            If (bFound = True) Begin    
95138>>>>>                Move False to bSaveChanges   
95139>>>>>                Move (ResizeArray(iaChangeField, 0)) to iaChangeField 
95140>>>>>                Move (SizeOfArray(aDateFields)) to iSize
95141>>>>>                Decrement iSize
95142>>>>>                for iCount from 0 to iSize   
95148>>>>>>
95148>>>>>                    Move aDateFields[iCount] to iField
95149>>>>>                    Get_Field_Value hTable iField to dDate
95152>>>>>                    If (bFixZeroDates = True) Begin
95154>>>>>                        Move (dDate = 0 or dDate < dDateMin) to bChange
95155>>>>>                    End 
95155>>>>>>
95155>>>>>                    Else Begin
95156>>>>>                        Move (dDate <> 0 and dDate < dDateMin) to bChange
95157>>>>>                    End
95157>>>>>>
95157>>>>>                    If (bChange = True) Begin      
95159>>>>>                        Move iField to iaChangeField[SizeOfArray(iaChangeField)]            
95160>>>>>                    End
95160>>>>>>
95160>>>>>                Loop       
95161>>>>>>
95161>>>>>                
95161>>>>>                // Only change Date fields that needs to be changed.
95161>>>>>                If (SizeOfArray(iaChangeField)) Begin
95163>>>>>                    Reread hTable 
95167>>>>>                        Move (SizeOfArray(iaChangeField)) to iSize
95168>>>>>                        Decrement iSize      
95169>>>>>                        for iCount from 0 to iSize
95175>>>>>>
95175>>>>>                            Move iaChangeField[iCount] to iField
95176>>>>>                            Set Private.piCurrentField to iField
95177>>>>>                            Set_Field_Value hTable iField to dDateMin  
95180>>>>>                        Loop
95181>>>>>>
95181>>>>>                        Move False to Err
95182>>>>>                        SaveRecord hTable
95183>>>>>                    Unlock
95184>>>>>>
95184>>>>>                End
95184>>>>>>
95184>>>>>                
95184>>>>>                Increment iRecord
95185>>>>>                // Increment the StatusPanel counter and check the
95185>>>>>                // cancel status every 100 records rather than every
95185>>>>>                // record, it's way faster.
95185>>>>>                If (Mod(iRecord, 100) = 0) Begin
95187>>>>>                    Send DoAdvance of ghoProgressBar
95188>>>>>                    Set Action_Text of ghoStatusPanel to ("Record:" * String(iRecord))
95189>>>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
95190>>>>>                End 
95190>>>>>>
95190>>>>>            End
95190>>>>>>
95190>>>>>        Until (bFound = False)
95192>>>>>                
95192>>>>>        Set_Attribute DF_DATE_FORMAT to iDateFormat   
95195>>>>>        If (bResetIndexesToOnLine = True) Begin
95197>>>>>            Send SetAllIndexesToBatch hTable False
95198>>>>>        End
95198>>>>>>
95198>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
95199>>>>>        
95199>>>>>        Function_Return (Err = False)
95200>>>>>    End_Function 
95201>>>>>        
95201>>>>>
95201>>>>>    // * Dummy function for the Studio's Code Explorer *
95201>>>>>    Function API_COLUMN_FUNCTIONS Returns Boolean
95203>>>>>        Function_Return False
95204>>>>>    End_Function
95205>>>>>
95205>>>>>    // Adds a column name to the passed table number.
95205>>>>>    Function ApiColumnAdd Handle hTable String sFieldName Integer iType Integer iLength Integer iPrec Boolean bInitVal String sColVal Returns Boolean
95207>>>>>        Integer iColumn iCount iFile iPrecision
95207>>>>>        Boolean bExists bOK bInitializeValue bRetval
95207>>>>>        String sDdSrcPath sTableName sColumnValue
95207>>>>>
95207>>>>>        Get UtilColumnExists hTable sFieldName to bExists
95208>>>>>        Move False to Err
95209>>>>>        If (bExists = True) Begin
95211>>>>>            Function_Return False
95212>>>>>        End
95212>>>>>>
95212>>>>>        If (num_arguments > 4) Begin
95214>>>>>            Move iPrec to iPrecision
95215>>>>>        End
95215>>>>>>
95215>>>>>        If (num_arguments > 6) Begin
95217>>>>>            Move bInitVal to bInitializeValue
95218>>>>>            Move sColVal  to sColumnValue
95219>>>>>        End
95219>>>>>>
95219>>>>>        If (iType < -1490) Begin
95221>>>>>            Move (iType + 1500) to iType
95222>>>>>        End
95222>>>>>>
95222>>>>>
95222>>>>>        Get AutoConnectionIDLogin to bOK
95223>>>>>        Move False to Err
95224>>>>>        // Structure_start will change the value of hTable...
95224>>>>>        Move hTable to iFile
95225>>>>>        Open iFile Mode DF_EXCLUSIVE
95227>>>>>
95227>>>>>        Set Private.phCurrentTable to hTable
95228>>>>>        Structure_Start iFile
95229>>>>>            Move 0 to iColumn
95230>>>>>            Set Private.piCurrentField to iColumn
95231>>>>>            Create_Field hTable At iColumn
95232>>>>>            Set_Attribute DF_FIELD_NAME      of iFile iColumn to sFieldName
95235>>>>>            Set_Attribute DF_FIELD_TYPE      of iFile iColumn to iType
95238>>>>>            Set_Attribute DF_FIELD_LENGTH    of iFile iColumn to (iLength + iPrecision)
95241>>>>>            Set_Attribute DF_FIELD_PRECISION of iFile iColumn to iPrecision
95244>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
95245>>>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
95247>>>>>        Set Action_Text of ghoStatusPanel to ""
95248>>>>>
95248>>>>>        // If in development environment; create .fd file:
95248>>>>>        Open hTable
95250>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
95251>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
95252>>>>>        If (iCount > 1) Begin
95254>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
95255>>>>>        End
95255>>>>>>
95255>>>>>        Get vFolderExists sDDSrcPath to bExists
95256>>>>>        If (bExists = True) Begin
95258>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
95259>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
95262>>>>>            Get _TableNameOnly sTableName to sTableName
95263>>>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
95265>>>>>        End
95265>>>>>>
95265>>>>>
95265>>>>>        // Check for a default value
95265>>>>>        If (bInitializeValue = True and sColumnValue <> "" and Err = False) Begin
95267>>>>>            Get ApiColumnUpdateValue hTable sFieldName sColumnValue to bRetval
95268>>>>>        End
95268>>>>>>
95268>>>>>        Close hTable
95269>>>>>
95269>>>>>        Function_Return (Err = False)
95270>>>>>    End_Function
95271>>>>>
95271>>>>>    // Adds a column name to the passed table number.
95271>>>>>    Function ApiColumnInsert Handle hTable Integer iColumn String sFieldName Integer iType Integer iLength Integer iPrec Boolean bIsSQLType Returns Boolean
95273>>>>>        Integer iCount iFile iPrecision iNumberOfFields
95273>>>>>        Boolean bExists bOK bInitializeValue bRetval bIsDateType
95273>>>>>        String sDdSrcPath sTableName sColumnValue
95273>>>>>
95273>>>>>        Get UtilColumnExists hTable sFieldName to bExists
95274>>>>>        Move False to Err
95275>>>>>        If (bExists = True) Begin
95277>>>>>            Function_Return False
95278>>>>>        End
95278>>>>>>
95278>>>>>        If (num_arguments > 4) Begin
95280>>>>>            Move iPrec to iPrecision
95281>>>>>        End
95281>>>>>>
95281>>>>>        If (iType < -1490) Begin
95283>>>>>            Move (iType + 1500) to iType
95284>>>>>        End
95284>>>>>>
95284>>>>>
95284>>>>>        Get AutoConnectionIDLogin to bOK
95285>>>>>        Move False to Err
95286>>>>>        // Structure_start will change the value of hTable...
95286>>>>>        Move hTable to iFile
95287>>>>>        Get OpenTableExclusive iFile to bOK
95288>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iNumberOfFields
95291>>>>>        
95291>>>>>        // If the passed column number is higher than the current number of fields
95291>>>>>        // in the table, this means we should _not_ insert a field but rather add
95291>>>>>        // a new field to the end:
95291>>>>>        If (iColumn > iNumberOfFields) Begin
95293>>>>>            Move 0 to iColumn
95294>>>>>        End
95294>>>>>>
95294>>>>>
95294>>>>>        Set Private.phCurrentTable to hTable
95295>>>>>        Set Private.piCurrentField to iColumn
95296>>>>>
95296>>>>>        Structure_Start iFile
95297>>>>>            Create_Field iFile At iColumn
95298>>>>>            Set_Attribute DF_FIELD_NAME            of iFile iColumn to sFieldName
95301>>>>>            If (bIsSQLType = False) Begin
95303>>>>>                Set_Attribute DF_FIELD_TYPE        of iFile iColumn to iType
95306>>>>>            End 
95306>>>>>>
95306>>>>>            Else Begin
95307>>>>>                Set_Attribute DF_FIELD_NATIVE_TYPE of iFile iColumn to iType
95310>>>>>            End
95310>>>>>>
95310>>>>>            Get UtilColumnIsDateType iType False to bIsDateType
95311>>>>>            If (bIsDateType = False) Begin
95313>>>>>                Set_Attribute DF_FIELD_LENGTH       of iFile iColumn to (iLength + iPrecision)
95316>>>>>                Set_Attribute DF_FIELD_PRECISION    of iFile iColumn to iPrecision
95319>>>>>            End
95319>>>>>>
95319>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
95320>>>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
95322>>>>>
95322>>>>>        Set Action_Text of ghoStatusPanel to ""
95323>>>>>        // If in development environment; create .fd file:
95323>>>>>        Open hTable
95325>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
95326>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
95327>>>>>        If (iCount > 1) Begin
95329>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
95330>>>>>        End
95330>>>>>>
95330>>>>>        Get vFolderExists sDDSrcPath to bExists
95331>>>>>        If (bExists = True) Begin
95333>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
95334>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
95337>>>>>            Get _TableNameOnly sTableName to sTableName
95338>>>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
95340>>>>>        End
95340>>>>>>
95340>>>>>
95340>>>>>        // Check for a default value
95340>>>>>        Close hTable
95341>>>>>
95341>>>>>        Function_Return (Err = False)
95342>>>>>    End_Function
95343>>>>>
95343>>>>>//    Function ApiColumnAddMultiple Handle hTable tAPIColumn[] aColumns Returns Boolean
95343>>>>>//        Integer iColumn iCount iFile
95343>>>>>//        Boolean bExists bOK
95343>>>>>//        String sDdSrcPath sTableName
95343>>>>>//
95343>>>>>//        Get AutoConnectionIDLogin to bOK
95343>>>>>//        Move False to Err
95343>>>>>//
95343>>>>>//        // Structure_start will change the value of hTable...
95343>>>>>//        Move hTable to iFile
95343>>>>>//        Open iFile Mode DF_EXCLUSIVE
95343>>>>>//
95343>>>>>//        Structure_Start iFile
95343>>>>>//            Send ApiColumnsAddToTable iFile aColumns False
95343>>>>>//        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
95343>>>>>//
95343>>>>>//        // If in development environment; create .fd file:
95343>>>>>//        Open hTable
95343>>>>>//        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
95343>>>>>//        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
95343>>>>>//        If (iCount > 1) Begin
95343>>>>>//            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
95343>>>>>//        End
95343>>>>>//        Get vFolderExists sDDSrcPath to bExists
95343>>>>>//        If (bExists = True) Begin
95343>>>>>//            Get vFolderFormat sDDSrcPath to sDDSrcPath
95343>>>>>//            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
95343>>>>>//            Get _TableNameOnly sTableName to sTableName
95343>>>>>//            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
95343>>>>>//        End
95343>>>>>//        Close hTable
95343>>>>>//
95343>>>>>//        Function_Return (Err = False)
95343>>>>>//    End_Function
95343>>>>>
95343>>>>>    // To update all records for a table column with a fixed value.
95343>>>>>    Function ApiColumnUpdateValue Handle hTable String sFieldName String sColumnValue Returns Boolean
95345>>>>>        Integer iRecs iCurrErr iField iRecord
95345>>>>>        Boolean bRetval bOpen
95345>>>>>
95345>>>>>        Move 0 to iRecs
95346>>>>>        Move False to bRetval
95347>>>>>        Move Err to iCurrErr
95348>>>>>        Move False to Err
95349>>>>>
95349>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
95352>>>>>        If (bOpen = False) Begin
95354>>>>>            Open hTable
95356>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
95359>>>>>            If (bOpen = False) Begin
95361>>>>>                Function_Return bRetval
95362>>>>>            End
95362>>>>>>
95362>>>>>        End
95362>>>>>>
95362>>>>>
95362>>>>>        Field_Map hTable sFieldName to iField
95364>>>>>        If (iField <> 0) Begin
95366>>>>>            Set Private.phCurrentTable to hTable
95367>>>>>            Set Private.piCurrentField to iField
95368>>>>>            Clear hTable
95369>>>>>            Repeat
95369>>>>>>
95369>>>>>                Vfind hTable 0 GT
95371>>>>>                If (Found) Begin
95373>>>>>                    If (ghoStatusPanel <> 0) Begin
95375>>>>>                        Get_Field_Value hTable 0 to iRecord
95378>>>>>                        Send Update_StatusPanel of ghoStatusPanel (CS_UpdateVersion * String(iRecord))
95379>>>>>                    End
95379>>>>>>
95379>>>>>                    Reread hTable
95383>>>>>                        Set_Field_Value hTable iField to sColumnValue
95386>>>>>                        SaveRecord hTable
95387>>>>>                    Unlock
95388>>>>>>
95388>>>>>                End
95388>>>>>>
95388>>>>>           Until (not(Found))
95390>>>>>        End
95390>>>>>>
95390>>>>>
95390>>>>>        Move (Err = False) to bRetval
95391>>>>>        Move iCurrErr to Err
95392>>>>>
95392>>>>>        Function_Return bRetval
95393>>>>>    End_Function
95394>>>>>    
95394>>>>>    // Note: This can only be used from within a Structure_Start/End construct.
95394>>>>>    Function ApiColumnsAddToTable Handle hTable tAPIColumn[] aColumns Boolean bCreating Returns Boolean
95396>>>>>        Integer iCount iSize iColumn iType iDataFlexType iIndex iDbType
95396>>>>>        Boolean bFieldExists bNativeType bIsSQLDriver bIsDAWSqlDriver bIsSqlTable bRecnumTable bIsOpen bIsDateType
95396>>>>>        String sFieldName sDriverID sTableName sDefaultValue
95396>>>>>
95396>>>>>//        Set Private.phCurrentTable to hTable
95396>>>>>        Get psDriverID to sDriverID
95397>>>>>        Get piDbType to iDbType
95398>>>>>        Get UtilTableHandleToString hTable to sTableName
95399>>>>>        Get IsSQLDriver    sDriverID to bIsSQLDriver
95400>>>>>        Get IsDAWSQLDriver sDriverID to bIsDAWSqlDriver
95401>>>>>        Get UtilTableIsSQL hTable to bIsSqlTable
95402>>>>>        If (bIsSqlTable = False and bCreating = True and bIsSQLDriver = True) Begin
95404>>>>>            Move True to bIsSqlTable
95405>>>>>        End
95405>>>>>>
95405>>>>>        Move False to bIsOpen
95406>>>>>        If (hTable > 0) Begin
95408>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
95411>>>>>        End
95411>>>>>>
95411>>>>>        If (bIsOpen = True) Begin
95413>>>>>            Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
95416>>>>>        End
95416>>>>>>
95416>>>>>        Else Begin        
95417>>>>>            Get pbRecnum to bRecnumTable
95418>>>>>        End
95418>>>>>>
95418>>>>>        
95418>>>>>        Move False to Err
95419>>>>>        Move (SizeOfArray(aColumns)) to iSize
95420>>>>>        Decrement iSize
95421>>>>>        for iCount from 0 to iSize
95427>>>>>>
95427>>>>>            Move aColumns[iCount].sFieldName to sFieldName
95428>>>>>            If (hTable > 0) Begin
95430>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
95431>>>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
95432>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn to sFieldName
95435>>>>>                Move (Trim(sFieldName) <> "") to bFieldExists
95436>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
95437>>>>>                Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
95438>>>>>            End
95438>>>>>>
95438>>>>>            Else Begin
95439>>>>>                Move False to bFieldExists
95440>>>>>            End
95440>>>>>>
95440>>>>>
95440>>>>>            If (bFieldExists = False) Begin
95442>>>>>                Move 0 to iColumn
95443>>>>>                Create_Field hTable At iColumn
95444>>>>>            End
95444>>>>>>
95444>>>>>            Else Begin
95445>>>>>                Move iCount to iColumn
95446>>>>>            End
95446>>>>>>
95446>>>>>
95446>>>>>            Set Private.piCurrentField to iColumn
95447>>>>>
95447>>>>>            Move                                        iColumn to aColumns[iCount].iFieldNumber
95448>>>>>            Set_Attribute DF_FIELD_NAME       of hTable iColumn to aColumns[iCount].sFieldName
95451>>>>>
95451>>>>>            Move aColumns[iCount].iType to iType
95452>>>>>            Move (not(iType < -1490)) to bNativeType
95453>>>>>            If (iType < -1490) Begin
95455>>>>>                Move (iType + 1500) to iType
95456>>>>>            End
95456>>>>>>
95456>>>>>
95456>>>>>            If (bIsSqlTable = True) Begin
95458>>>>>                If (aColumns[iCount].bIsSQLType = True) Begin
95460>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iDataFlexType
95461>>>>>                    Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iDataFlexType
95464>>>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iType  
95467>>>>>                    Set_Attribute DF_FIELD_NULL_ALLOWED  of hTable iColumn to aColumns[iCount].bAllowNULL
95470>>>>>                    
95470>>>>>                    Move aColumns[iCount].sDefaultValue                    to sDefaultValue
95471>>>>>                    If (iDataFlexType = DF_BCD and Left(sDefaultValue, 1 <> "[")) Begin
95473>>>>>                        Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
95474>>>>>                    End
95474>>>>>>
95474>>>>>                    Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sDefaultValue 
95477>>>>>                
95477>>>>>                End
95477>>>>>>
95477>>>>>                Else Begin
95478>>>>>                    Set_Attribute DF_FIELD_TYPE        of hTable iColumn to iType
95481>>>>>                End
95481>>>>>>
95481>>>>>            End
95481>>>>>>
95481>>>>>            Else Begin
95482>>>>>                If (bCreating = False) Begin
95484>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iType
95485>>>>>                End
95485>>>>>>
95485>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iColumn to iType
95488>>>>>            End
95488>>>>>>
95488>>>>>            
95488>>>>>            Get UtilColumnIsDateType iType bIsSqlTable to bIsDateType
95489>>>>>            If (bIsDateType = False) Begin
95491>>>>>                Set_Attribute DF_FIELD_LENGTH     of hTable iColumn to aColumns[iCount].iLength
95494>>>>>                Set_Attribute DF_FIELD_PRECISION  of hTable iColumn to aColumns[iCount].iPrecision
95497>>>>>            End
95497>>>>>>
95497>>>>>
95497>>>>>            If (aColumns[iCount].iOptions iand C_tAPIColumn_Identity) Begin
95499>>>>>                Move 0 to iIndex
95500>>>>>                Create_Index hTable at iIndex
95501>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to 1
95504>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD   of hTable iIndex 1 to iColumn
95507>>>>>                Set_Attribute DF_FILE_PRIMARY_INDEX    of hTable iIndex to 1
95510>>>>>
95510>>>>>                // If we have an identity table - we must create a primary_key table.
95510>>>>>                If (bIsSqlTable = True) Begin
95512>>>>>                    Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to True
95515>>>>>                    Set_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to True
95518>>>>>                End
95518>>>>>>
95518>>>>>            End
95518>>>>>>
95518>>>>>        Loop             
95519>>>>>>
95519>>>>>        
95519>>>>>        Function_Return (Err = False)
95520>>>>>    End_Function
95521>>>>>
95521>>>>>    // Changes a field type, length and precision for the passed table number and field name
95521>>>>>    Function ApiColumnChange Handle hTable String sFieldNameFrom Integer iTypeFrom Integer iLengthFrom Integer iPrec Returns Boolean
95523>>>>>        Integer iColumn iPrecFrom iTypeTo iLengthTo iPrecTo
95523>>>>>        Boolean bOK bIsSqlTable
95523>>>>>        String sFieldNameTo
95523>>>>>
95523>>>>>        If (num_arguments > 4) Begin
95525>>>>>            Move iPrec to iPrecFrom
95526>>>>>        End
95526>>>>>>
95526>>>>>        If (iTypeFrom < -1490) Begin
95528>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
95529>>>>>        End
95529>>>>>>
95529>>>>>
95529>>>>>        Get AutoConnectionIDLogin to bOK
95530>>>>>        Move False to Err
95531>>>>>        Get OpenTableExclusive hTable to bOK
95532>>>>>        If (bOK = False) Begin
95534>>>>>            Function_Return False
95535>>>>>        End
95535>>>>>>
95535>>>>>
95535>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
95536>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
95537>>>>>        Field_Map hTable sFieldNameFrom to iColumn
95539>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
95540>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
95541>>>>>        If (Err = True) Begin
95543>>>>>            Function_Return False
95544>>>>>        End
95544>>>>>>
95544>>>>>
95544>>>>>        Get_Attribute DF_FIELD_NAME                  of hTable iColumn to sFieldNameTo
95547>>>>>        Get UtilTableIsSQL hTable to bIsSqlTable
95548>>>>>        If (bIsSqlTable = False) Begin
95550>>>>>            Get_Attribute DF_FIELD_TYPE              of hTable iColumn to iTypeTo
95553>>>>>        End
95553>>>>>>
95553>>>>>        Else Begin
95554>>>>>            Get_Attribute DF_FIELD_NATIVE_TYPE       of hTable iColumn to iTypeTo
95557>>>>>        End
95557>>>>>>
95557>>>>>        // Let the driver decide the other values;
95557>>>>>        Get_Attribute DF_FIELD_LENGTH                of hTable iColumn to iLengthTo
95560>>>>>        Get_Attribute DF_FIELD_PRECISION             of hTable iColumn to iPrecTo
95563>>>>>
95563>>>>>        If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo) Begin
95565>>>>>            Function_Return False
95566>>>>>        End
95566>>>>>>
95566>>>>>
95566>>>>>        Set Private.phCurrentTable to hTable
95567>>>>>        Set Private.piCurrentField to iColumn
95568>>>>>
95568>>>>>        Structure_Start hTable
95569>>>>>            Set_Attribute DF_FIELD_NAME              of hTable iColumn to sFieldNameFrom
95572>>>>>            If (bIsSqlTable = False) Begin
95574>>>>>                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
95577>>>>>            End
95577>>>>>>
95577>>>>>            Else Begin
95578>>>>>                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
95581>>>>>                Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iTypeFrom
95584>>>>>            End
95584>>>>>>
95584>>>>>            Set_Attribute DF_FIELD_LENGTH            of hTable iColumn to iLengthFrom
95587>>>>>            Set_Attribute DF_FIELD_PRECISION         of hTable iColumn to iPrecFrom
95590>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
95591>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
95593>>>>>
95593>>>>>        Set Action_Text of ghoStatusPanel to ""
95594>>>>>        Function_Return (Err = False)
95595>>>>>    End_Function
95596>>>>>
95596>>>>>    // Changes a field type, length and precision for the passed table number and field name
95596>>>>>    Function ApiColumnChangeByColumnNumber String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo String sFieldNameFrom Integer iColumn Integer iTypeFrom Integer iLengthFrom Integer iPrec Integer iOpt Returns Boolean
95598>>>>>        Integer iPrecFrom iTypeTo iLengthTo iPrecTo iDbType iOptionFrom iOptionTo iDataFlexType iIndex
95598>>>>>        Boolean bOK bCompareDate_DateTime bSkip bRecnumTable bIsSameDataType
95598>>>>>        String sFieldNameTo sDriverIDTo
95598>>>>>        tColumnType ColumnType
95598>>>>>        tColumnType ColumnType
95598>>>>>        
95598>>>>>        Get pbCompareDate_DateTime to bCompareDate_DateTime
95599>>>>>        Get piDbType to iDbType
95600>>>>>        If (num_arguments > 4) Begin
95602>>>>>            Move iPrec to iPrecFrom
95603>>>>>            Move iOpt  to iOptionFrom
95604>>>>>        End
95604>>>>>>
95604>>>>>        If (iTypeFrom < -1490) Begin
95606>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
95607>>>>>        End
95607>>>>>>
95607>>>>>
95607>>>>>        Get AutoConnectionIDLogin to bOK
95608>>>>>        Move False to Err   
95609>>>>>        Close hTable
95610>>>>>        Get OpenTableExclusive hTable to bOK
95611>>>>>        If (bOK = False) Begin
95613>>>>>            Function_Return False
95614>>>>>        End 
95614>>>>>>
95614>>>>>
95614>>>>>        Get_Attribute DF_FILE_DRIVER                of hTable         to sDriverIDTo
95617>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE          of hTable         to bRecnumTable
95620>>>>>        Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iTypeTo iLengthTo to iDataFlexType
95621>>>>>        Get_Attribute DF_FIELD_NAME                 of hTable iColumn to sFieldNameTo 
95624>>>>>
95624>>>>>        If (bIsSQLTableTo = True) Begin
95626>>>>>            Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iTypeTo
95629>>>>>        End
95629>>>>>>
95629>>>>>        Else Begin
95630>>>>>            Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iTypeTo
95633>>>>>        End
95633>>>>>>
95633>>>>>
95633>>>>>        Get_Attribute DF_FIELD_LENGTH               of hTable iColumn to iLengthTo
95636>>>>>        Get_Attribute DF_FIELD_PRECISION            of hTable iColumn to iPrecTo
95639>>>>>            Get_Attribute DF_FIELD_IS_IDENTITY      of hTable iColumn to iOptionTo 
95642>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
95642>>>>>        // data types between Embedded and SQL, else we can't compare the data types.
95642>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
95644>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeFrom
95645>>>>>        End
95645>>>>>>
95645>>>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
95648>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeTo
95649>>>>>        End
95649>>>>>>
95649>>>>>        Move (iTypeFrom = iTypeTo) to bIsSameDataType
95650>>>>>
95650>>>>>        If (bCompareDate_DateTime = False) Begin
95652>>>>>            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkip
95653>>>>>            If (bSkip = True) Begin
95655>>>>>                If (sFieldNameFrom = sFieldNameTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
95657>>>>>                    Function_Return True
95658>>>>>                End
95658>>>>>>
95658>>>>>            End
95658>>>>>>
95658>>>>>        End
95658>>>>>>
95658>>>>>        Else If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
95661>>>>>            Function_Return True
95662>>>>>        End
95662>>>>>>
95662>>>>>
95662>>>>>        Set Private.phCurrentTable to hTable
95663>>>>>        Set Private.piCurrentField to iColumn
95664>>>>>       
95664>>>>>        Structure_Start hTable                                               
95665>>>>>            If (sFieldNameFrom <> sFieldNameTo) Begin
95667>>>>>                Set_Attribute DF_FIELD_NAME             of hTable iColumn to sFieldNameFrom
95670>>>>>            End
95670>>>>>>
95670>>>>>            
95670>>>>>            If (bIsSameDataType = False) Begin
95672>>>>>                Set_Attribute DF_FIELD_TYPE             of hTable iColumn to iDataFlexType
95675>>>>>                If (bIsSQLTableTo = True) Begin
95677>>>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE  of hTable iColumn to iTypeFrom
95680>>>>>                End
95680>>>>>>
95680>>>>>            End                                         
95680>>>>>>
95680>>>>>            
95680>>>>>            If (iLengthFrom <> iLengthTo) Begin
95682>>>>>                Set_Attribute DF_FIELD_LENGTH           of hTable iColumn to iLengthFrom
95685>>>>>            End
95685>>>>>>
95685>>>>>            If (iPrecFrom <> iPrecTo) Begin
95687>>>>>                Set_Attribute DF_FIELD_PRECISION        of hTable iColumn to iPrecFrom
95690>>>>>            End
95690>>>>>>
95690>>>>>
95690>>>>>            If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
95692>>>>>                // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
95692>>>>>                If (bRecnumTable = True) Begin
95694>>>>>                    Set_Attribute DF_FILE_RECNUM_TABLE  of hTable to False
95697>>>>>                End
95697>>>>>>
95697>>>>>
95697>>>>>                // We might need to create an index here.
95697>>>>>                // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
95697>>>>>                // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
95697>>>>>                // index update checking logic.
95697>>>>>                Get_Attribute DF_FIELD_INDEX               of hTable iColumn to iIndex
95700>>>>>                If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
95702>>>>>                    Create_Index hTable At iIndex
95703>>>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex   to 1
95706>>>>>                End
95706>>>>>>
95706>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD       of hTable iIndex 1 to iColumn
95709>>>>>                Set_Attribute DF_FILE_PRIMARY_INDEX        of hTable          to iIndex
95712>>>>>                    Set_Attribute DF_FIELD_IS_IDENTITY     of hTable iColumn  to True
95715>>>>>                If (bIsSQLTableTo = True) Begin
95717>>>>>                    Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex   to True
95720>>>>>                End
95720>>>>>>
95720>>>>>            End
95720>>>>>>
95720>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
95721>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
95723>>>>>
95723>>>>>        Set Action_Text of ghoStatusPanel to ""
95724>>>>>        Function_Return (Err = False)
95725>>>>>    End_Function
95726>>>>>
95726>>>>>    Function ApiColumnChangeMainIndex Handle hTable Integer iIndex Integer iColumn Returns Boolean
95728>>>>>        Boolean bOK
95728>>>>>
95728>>>>>        Get AutoConnectionIDLogin to bOK
95729>>>>>        Move False to Err
95730>>>>>        Get OpenTableExclusive hTable to bOK
95731>>>>>        If (bOK = False) Begin
95733>>>>>            Function_Return False
95734>>>>>        End
95734>>>>>>
95734>>>>>
95734>>>>>        Structure_Start hTable
95735>>>>>            Set_Attribute DF_FIELD_INDEX of hTable iColumn to iIndex
95738>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
95739>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
95741>>>>>
95741>>>>>        Set Action_Text of ghoStatusPanel to ""
95742>>>>>        Function_Return (Err = False)
95743>>>>>    End_Function
95744>>>>>
95744>>>>>    // To move an existing field to another position in a table.
95744>>>>>    Function ApiColumnMove Handle hTable Integer iOld Integer iNew Boolean bIsSQLType Returns Boolean
95746>>>>>        String sColumn sDriverID
95746>>>>>        Integer iType iSQLType iLength iPrecision iDbType
95746>>>>>        Boolean bOK bIsDate
95746>>>>>        
95746>>>>>        Close hTable
95747>>>>>        Get AutoConnectionIDLogin to bOK
95748>>>>>        Get OpenTableExclusive hTable to bOK
95749>>>>>        If (bOK = False) Begin
95751>>>>>            Function_Return False
95752>>>>>        End
95752>>>>>>
95752>>>>>        
95752>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
95755>>>>>        If (sDriverID = DFBTRDRV_ID) Begin
95757>>>>>            Error DFERR_PROGRAM "Function 'ColumnMove' is not supported for the Pervasive database."
95758>>>>>>
95758>>>>>            Function_Return False
95759>>>>>        End
95759>>>>>>
95759>>>>>        
95759>>>>>        Get_Attribute DF_FIELD_NAME of hTable iOld to sColumn
95762>>>>>        Get_Attribute DF_FIELD_TYPE of hTable iOld to iType
95765>>>>>
95765>>>>>        Set Private.phCurrentTable to hTable
95766>>>>>        Set Private.piCurrentField to iOld
95767>>>>>
95767>>>>>        Get UtilColumnIsDateType iType bIsSQLType to bIsDate
95768>>>>>        If (bIsDate = False) Begin
95770>>>>>            Get_Attribute DF_FIELD_LENGTH    of hTable iOld to iLength
95773>>>>>            Get_Attribute DF_FIELD_PRECISION of hTable iOld to iPrecision
95776>>>>>        End  
95776>>>>>>
95776>>>>>        Else Begin
95777>>>>>            Move 6 to iLength 
95778>>>>>            Move 0 to iPrecision
95779>>>>>        End
95779>>>>>>
95779>>>>>
95779>>>>>        Move False to Err
95780>>>>>
95780>>>>>        Structure_Start hTable
95781>>>>>            Delete_Field hTable iOld
95782>>>>>            Create_Field hTable At iNew
95783>>>>>            Set_Attribute DF_FIELD_NAME of hTable iNew to sColumn 
95786>>>>>            
95786>>>>>            If (bIsSQLType = False) Begin
95788>>>>>                Set_Attribute DF_FIELD_TYPE        of hTable iNew to iType
95791>>>>>            End 
95791>>>>>>
95791>>>>>            Else Begin
95792>>>>>                Set_Attribute DF_FIELD_TYPE        of hTable iNew to iType
95795>>>>>//                Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iNew to iSQLType  
95795>>>>>            End
95795>>>>>>
95795>>>>>            
95795>>>>>            If (bIsDate = False) Begin
95797>>>>>                Set_Attribute DF_FIELD_LENGTH    of hTable iNew to iLength
95800>>>>>                Set_Attribute DF_FIELD_PRECISION of hTable iNew to iPrecision
95803>>>>>            End
95803>>>>>>
95803>>>>>
95803>>>>>            Set_Attribute DF_FIELD_OLD_NUMBER of hTable iNew to iOld
95806>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
95807>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
95809>>>>>
95809>>>>>        Set Action_Text of ghoStatusPanel to ""
95810>>>>>        Function_Return (Err = False)
95811>>>>>    End_Function
95812>>>>>
95812>>>>>    // Deletes a column name for the passed table number (and column number).
95812>>>>>    Function ApiColumnRemove Handle hTable String sFieldName Returns Boolean
95814>>>>>        Integer iColumn
95814>>>>>        Boolean bOK
95814>>>>>
95814>>>>>        Get AutoConnectionIDLogin to bOK
95815>>>>>        Move False to Err
95816>>>>>        Close hTable
95817>>>>>        Get OpenTableExclusive hTable to bOK
95818>>>>>        If (bOK = False) Begin
95820>>>>>            Function_Return False
95821>>>>>        End
95821>>>>>>
95821>>>>>
95821>>>>>        If (not(Err)) Begin 
95823>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
95824>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
95825>>>>>            Field_Map hTable sFieldName to iColumn
95827>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
95828>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
95829>>>>>            If (Err = True) Begin
95831>>>>>                Function_Return False
95832>>>>>            End
95832>>>>>>
95832>>>>>            Move False to Err
95833>>>>>
95833>>>>>            Set Private.phCurrentTable to hTable
95834>>>>>            Set Private.piCurrentField to iColumn
95835>>>>>        
95835>>>>>            Structure_Start hTable
95836>>>>>                Delete_Field hTable iColumn
95837>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
95838>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
95840>>>>>            Set Action_Text of ghoStatusPanel to ""
95841>>>>>        End
95841>>>>>>
95841>>>>>        Else Begin
95842>>>>>            Error DFERR_PROGRAM ("The table number:" * String(hTable) * "could not be opened exclusiv. This indicates the table is in use!")
95843>>>>>>
95843>>>>>        End
95843>>>>>>
95843>>>>>
95843>>>>>        Function_Return (Err = False)
95844>>>>>    End_Function
95845>>>>>
95845>>>>>    // Renames a field for the passed table number & old field name & new field name
95845>>>>>    // Returns True if no errors occured.
95845>>>>>    // Sample usage:
95845>>>>>    //   Get ColumnRename Quote.File_Number "ID#" "ID" to bOK
95845>>>>>    Function ApiColumnRename Integer hTable String sOldFieldName String sNewFieldName Returns Boolean
95847>>>>>        Integer iField
95847>>>>>        Boolean bOK bExists bIsOpen
95847>>>>>
95847>>>>>        Get UtilColumnExists hTable sNewFieldName to bExists
95848>>>>>        If (bExists = True) Begin
95850>>>>>            Function_Return False
95851>>>>>        End
95851>>>>>>
95851>>>>>        
95851>>>>>        // Note: The Field_Map command does _not_ work if the table has been
95851>>>>>        //       opened exclusively, so we first open it in normal mode.
95851>>>>>        Close hTable
95852>>>>>        Open hTable                
95854>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
95857>>>>>        If (bIsOpen = False) Begin
95859>>>>>            Function_Return False
95860>>>>>        End
95860>>>>>>
95860>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
95861>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
95862>>>>>        Field_Map hTable sOldFieldName to iField   
95864>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
95865>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
95866>>>>>        
95866>>>>>        Get AutoConnectionIDLogin to bOK
95867>>>>>        Get OpenTableExclusive hTable to bOK
95868>>>>>        If (bOK = False) Begin
95870>>>>>            Function_Return False
95871>>>>>        End
95871>>>>>>
95871>>>>>
95871>>>>>        Move False to Err
95872>>>>>        Send Ignore_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
95873>>>>>        Set Private.phCurrentTable to hTable
95874>>>>>        Set Private.piCurrentField to iField
95875>>>>>
95875>>>>>        If (iField > 0) Begin
95877>>>>>            Structure_Start hTable
95878>>>>>                Set_Attribute DF_FIELD_NAME of hTable iField to sNewFieldName
95881>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
95882>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
95884>>>>>        End
95884>>>>>>
95884>>>>>        Else Begin
95885>>>>>            Move 0 to LastErr
95886>>>>>            Move False to Err
95887>>>>>        End
95887>>>>>>
95887>>>>>
95887>>>>>        Set Action_Text of ghoStatusPanel to ""
95888>>>>>        Send Trap_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
95889>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
95890>>>>>
95890>>>>>        Function_Return (Err = False)
95891>>>>>    End_Function  
95892>>>>>    
95892>>>>>    Function UtilColumnsCheckForInserts Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[] 
95894>>>>>        tAPIColumnCompare[] aAPIColumnsToInsert
95894>>>>>        tAPIColumnCompare[] aAPIColumnsToInsert
95895>>>>>        Integer iSize iCount iItem iFieldTo iNumberOfFieldsTo
95895>>>>>        Boolean bRenameField bExists
95895>>>>>        
95895>>>>>        Open hTable
95897>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
95898>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
95899>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize       
95900>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumberOfFieldsTo  
95903>>>>>        Move (iSize min iNumberOfFieldsTo) to iSize
95904>>>>>        Decrement iSize
95905>>>>>        for iCount from 0 to iSize    
95911>>>>>>
95911>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
95913>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
95914>>>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
95915>>>>>
95915>>>>>                Field_Map hTable aAPIColumnCompare[iCount].sFieldNameFrom to iFieldTo
95917>>>>>                If (iFieldTo = 0) Begin 
95919>>>>>                    Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount] to bRenameField
95920>>>>>                    Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to bExists
95921>>>>>                    If (bRenameField = False and bExists = False) Begin
95923>>>>>                        Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToInsert[iItem].iFieldNumber 
95924>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToInsert[iItem].sFieldNameFrom
95925>>>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to aAPIColumnsToInsert[iItem].iTypeFrom 
95926>>>>>                        Move aAPIColumnCompare[iCount].sTypeFrom        to aAPIColumnsToInsert[iItem].sTypeFrom
95927>>>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to aAPIColumnsToInsert[iItem].iLengthFrom
95928>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to aAPIColumnsToInsert[iItem].iPrecisionFrom
95929>>>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeFrom   to aAPIColumnsToInsert[iItem].bIsSQLTypeFrom
95930>>>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeTo     to aAPIColumnsToInsert[iItem].bIsSQLTypeTo
95931>>>>>                        Move True                                       to aAPIColumnsToInsert[iItem].bExistsFrom
95932>>>>>                        Move False                                      to aAPIColumnsToInsert[iItem].bExistsTo
95933>>>>>                        Increment iItem
95934>>>>>                    End
95934>>>>>>
95934>>>>>                End
95934>>>>>>
95934>>>>>            End
95934>>>>>>
95934>>>>>        Loop
95935>>>>>>
95935>>>>>        
95935>>>>>        Move False to Err
95936>>>>>        Move 0 to LastErr
95937>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
95938>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
95939>>>>>        Function_Return aAPIColumnsToInsert
95940>>>>>    End_Function   
95941>>>>>    
95941>>>>>    Function UtilColumnsInsert Handle hTable tAPIColumnCompare[] aAPIColumnsToInsert Returns Boolean
95943>>>>>        Integer iSize iCount
95943>>>>>        Boolean bOK                             
95943>>>>>        tAPIColumn[] aColumnsTo 
95943>>>>>        tAPIColumn[] aColumnsTo 
95944>>>>>        tAPIColumnCompare[] aAPIColumnCompare
95944>>>>>        tAPIColumnCompare[] aAPIColumnCompare
95945>>>>>
95945>>>>>        Move (SizeOfArray(aAPIColumnsToInsert)) to iSize
95946>>>>>        If (iSize = 0) Begin
95948>>>>>            Function_Return True
95949>>>>>        End                     
95949>>>>>>
95949>>>>>        
95949>>>>>        Move False to Err
95950>>>>>        Decrement iSize
95951>>>>>        for iCount from 0 to iSize
95957>>>>>>
95957>>>>>            Get ApiColumnInsert hTable aAPIColumnsToInsert[iCount].iFieldNumber aAPIColumnsToInsert[iCount].sFieldNameFrom aAPIColumnsToInsert[iCount].iTypeFrom aAPIColumnsToInsert[iCount].iLengthFrom aAPIColumnsToInsert[iCount].iPrecisionFrom aAPIColumnsToInsert[iCount].bIsSQLTypeFrom to bOK
95958>>>>>        Loop
95959>>>>>>
95959>>>>>        
95959>>>>>        Function_Return bOK
95960>>>>>    End_Function
95961>>>>>    
95961>>>>>    // Returns a struct array with fields that has the same names but different field numbers.
95961>>>>>    Function UtilColumnsCheckForMoves Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[] 
95963>>>>>        tAPIColumnCompare[] aAPIColumnsToMove
95963>>>>>        tAPIColumnCompare[] aAPIColumnsToMove
95964>>>>>        Integer iSize iCount iItem iFieldTo
95964>>>>>        
95964>>>>>        Open hTable
95966>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
95967>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
95968>>>>>
95968>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize       
95969>>>>>        Decrement iSize
95970>>>>>        for iCount from 0 to iSize    
95976>>>>>>
95976>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
95978>>>>>                Field_Map hTable aAPIColumnCompare[iCount].sFieldNameFrom to iFieldTo
95980>>>>>                If (iFieldTo > 0) Begin
95982>>>>>                    Move aAPIColumnCompare[iCount].iFieldNumber to aAPIColumnsToMove[iItem].iFieldNumber 
95983>>>>>                    Move iFieldTo                               to aAPIColumnsToMove[iItem].iFieldNumberTo 
95984>>>>>                    Increment iItem
95985>>>>>                End
95985>>>>>>
95985>>>>>            End
95985>>>>>>
95985>>>>>        Loop
95986>>>>>>
95986>>>>>        
95986>>>>>        Move False to Err
95987>>>>>        Move 0 to LastErr
95988>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
95989>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
95990>>>>>        Function_Return aAPIColumnsToMove
95991>>>>>    End_Function   
95992>>>>>    
95992>>>>>    Function UtilColumnsMove Handle hTable tAPIColumnCompare[] aAPIColumnsToMove Returns Boolean
95994>>>>>        Integer iSize iCount
95994>>>>>        Boolean bOK                             
95994>>>>>        tAPIColumn[] aColumnsTo 
95994>>>>>        tAPIColumn[] aColumnsTo 
95995>>>>>        tAPIColumnCompare[] aAPIColumnCompare
95995>>>>>        tAPIColumnCompare[] aAPIColumnCompare
95996>>>>>
95996>>>>>        Move (SizeOfArray(aAPIColumnsToMove)) to iSize
95997>>>>>        If (iSize = 0) Begin
95999>>>>>            Function_Return True
96000>>>>>        End                     
96000>>>>>>
96000>>>>>        
96000>>>>>        Move False to Err
96001>>>>>        Decrement iSize
96002>>>>>        for iCount from 0 to iSize
96008>>>>>>
96008>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
96009>>>>>            If (aAPIColumnsToMove[iCount].bExistsFrom = True and aAPIColumnsToMove[iCount].bExistsTo = True) Begin
96011>>>>>                Get ApiColumnMove hTable aAPIColumnsToMove[iCount].iFieldNumberTo aAPIColumnsToMove[iCount].iFieldNumber aAPIColumnsToMove[iCount].bIsSQLTypeFrom to bOK
96012>>>>>            End
96012>>>>>>
96012>>>>>        Loop
96013>>>>>>
96013>>>>>        
96013>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
96014>>>>>        Function_Return bOK
96015>>>>>    End_Function
96016>>>>>
96016>>>>>    // Checks if the "FROM" and "TO" database field is the same _except_ for the field name.
96016>>>>>    // We then assume this field should be renamed.
96016>>>>>//    Function UtilColumCheckRename Handle hTable tAPIColumnCompare aAPIColumnCompare Returns Boolean
96016>>>>>//        Boolean bDifferentFieldNames bShouldBeRenamed        
96016>>>>>//        
96016>>>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
96016>>>>>//        Move (Uppercase(aAPIColumnCompare.sFieldNameFrom) <> Uppercase(aAPIColumnCompare.sFieldNameTo)) to bDifferentFieldNames
96016>>>>>//        
96016>>>>>//        If (bDifferentFieldNames = True) Begin
96016>>>>>//            Move (aAPIColumnCompare.iFieldNumber = aAPIColumnCompare.iFieldNumberTo) to bShouldBeRenamed
96016>>>>>//            If (bShouldBeRenamed = False) Begin
96016>>>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
96016>>>>>//                Function_Return False
96016>>>>>//            End
96016>>>>>//        
96016>>>>>//            Move (aAPIColumnCompare.iTypeFrom = aAPIColumnCompare.iTypeTo) to bShouldBeRenamed
96016>>>>>//            If (bShouldBeRenamed = False) Begin
96016>>>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
96016>>>>>//                Function_Return False
96016>>>>>//            End
96016>>>>>//        
96016>>>>>//            Move (aAPIColumnCompare.iLengthFrom = aAPIColumnCompare.iLengthTo) to bShouldBeRenamed
96016>>>>>//            If (bShouldBeRenamed = False) Begin
96016>>>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
96016>>>>>//                Function_Return False
96016>>>>>//            End
96016>>>>>//        
96016>>>>>//            Move (aAPIColumnCompare.iPrecisionFrom = aAPIColumnCompare.iPrecisionTo) to bShouldBeRenamed
96016>>>>>//            If (bShouldBeRenamed = False) Begin
96016>>>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
96016>>>>>//                Function_Return False
96016>>>>>//            End
96016>>>>>//        End
96016>>>>>//    
96016>>>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
96016>>>>>//        Function_Return True
96016>>>>>//    End_Function                   
96016>>>>>    
96016>>>>>    // Takes a tAPIColumnCompare struct as parameter and returns True if;
96016>>>>>    // - Field Numbers, Data Types, Lengths and Precisions are all equal.
96016>>>>>    // - The "FROM" field name is <> "TO" field name
96016>>>>>    // - The "FROM" field name also exists in the "TO" table; or the "TO" is part
96016>>>>>    //   of the "FROM" field name. E.g. "FROM" = LATEST_REPL_COST_DATE, "TO" = Latest_Repl_Cos would results in a TRUE.
96016>>>>>    Function UtilColumnShouldBeRenamed tAPIColumnCompare aAPIColumnCompare Returns Boolean
96018>>>>>        Boolean bExists bShouldRename
96018>>>>>        String sFieldNameFrom sFieldNameTo
96018>>>>>        
96018>>>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameFrom)) to sFieldNameFrom
96019>>>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameTo))   to sFieldNameTo  
96020>>>>>        If (sFieldNameFrom = sFieldNameTo) Begin
96022>>>>>            Function_Return False
96023>>>>>        End
96023>>>>>>
96023>>>>>        
96023>>>>>        Move (aAPIColumnCompare.bExistsFrom    = aAPIColumnCompare.bExistsTo      and ;              aAPIColumnCompare.iFieldNumber   = aAPIColumnCompare.iFieldNumberTo and ;              aAPIColumnCompare.iTypeFrom      = aAPIColumnCompare.iTypeTo        and ;              aAPIColumnCompare.iLengthFrom    = aAPIColumnCompare.iLengthTo      and ;              aAPIColumnCompare.iPrecisionFrom = aAPIColumnCompare.iPrecisionTo   and ;              aAPIColumnCompare.iOptionsFrom   = aAPIColumnCompare.iOptionsTo) to bShouldRename
96024>>>>>        If (bShouldRename = False) Begin
96026>>>>>            Function_Return False
96027>>>>>        End                      
96027>>>>>>
96027>>>>>        
96027>>>>>        If (sFieldNameFrom contains sFieldNameTo) Begin
96029>>>>>            Function_Return True
96030>>>>>        End
96030>>>>>>
96030>>>>>        
96030>>>>>        Function_Return bShouldRename
96031>>>>>    End_Function
96032>>>>>    
96032>>>>>    Function UtilColumnExistsWithOtherNumber tAPIColumnCompare[] aAPIColumnCompare Integer iColumn Returns Boolean
96034>>>>>        Boolean bExists
96034>>>>>        Integer iCount iSize
96034>>>>>        String sFieldNameFrom
96034>>>>>        
96034>>>>>        Move (Uppercase(aAPIColumnCompare[iColumn].sFieldNameFrom)) to sFieldNameFrom
96035>>>>>        
96035>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
96036>>>>>        Decrement iSize
96037>>>>>        for iCount from 0 to iSize
96043>>>>>>
96043>>>>>            // We're only interested in fields other than the passed field/column number:
96043>>>>>            If ((iCount +1) <> iColumn) Begin
96045>>>>>                If (Uppercase(aAPIColumnCompare[iCount].sFieldNameTo) = sFieldNameFrom) Begin
96047>>>>>                    Move True to bExists 
96048>>>>>                End  
96048>>>>>>
96048>>>>>                Else If (sFieldNameFrom contains Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
96051>>>>>                    Move True to bExists 
96052>>>>>                End
96052>>>>>>
96052>>>>>            End
96052>>>>>>
96052>>>>>        Loop
96053>>>>>>
96053>>>>>        
96053>>>>>        Function_Return bExists 
96054>>>>>    End_Function
96055>>>>>    
96055>>>>>    Function UtilColumnsCheckForRenames Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[] 
96057>>>>>        tAPIColumnCompare[] aAPIColumnsToRename
96057>>>>>        tAPIColumnCompare[] aAPIColumnsToRename
96058>>>>>        Integer iSize iCount iItem iFieldTo iNumberOfFieldsTo
96058>>>>>        Boolean bRenameField
96058>>>>>        
96058>>>>>        Open hTable
96060>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumberOfFieldsTo
96063>>>>>        Move 0 to iItem
96064>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize                    
96065>>>>>        Move (iSize min iNumberOfFieldsTo)    to iSize
96066>>>>>        Decrement iSize
96067>>>>>        for iCount from 0 to iSize    
96073>>>>>>
96073>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
96075>>>>>                Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount] to bRenameField
96076>>>>>                If (bRenameField = True) Begin
96078>>>>>                    Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToRename[iItem].iFieldNumber 
96079>>>>>                    Move iFieldTo                                   to aAPIColumnsToRename[iItem].iFieldNumberTo 
96080>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToRename[iItem].sFieldNameFrom
96081>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameTo     to aAPIColumnsToRename[iItem].sFieldNameTo
96082>>>>>                    Increment iItem
96083>>>>>                End
96083>>>>>>
96083>>>>>            End
96083>>>>>>
96083>>>>>        Loop
96084>>>>>>
96084>>>>>        
96084>>>>>        Move False to Err
96085>>>>>        Move 0 to LastErr
96086>>>>>        Function_Return aAPIColumnsToRename
96087>>>>>    End_Function   
96088>>>>>    
96088>>>>>    Function UtilColumnsRename Handle hTable tAPIColumnCompare[] aAPIColumnsToRename Returns Boolean
96090>>>>>        Integer iSize iCount
96090>>>>>        Boolean bOK                             
96090>>>>>        tAPIColumn[] aColumnsTo 
96090>>>>>        tAPIColumn[] aColumnsTo 
96091>>>>>        tAPIColumnCompare[] aAPIColumnCompare
96091>>>>>        tAPIColumnCompare[] aAPIColumnCompare
96092>>>>>
96092>>>>>        Move (SizeOfArray(aAPIColumnsToRename)) to iSize
96093>>>>>        If (iSize = 0) Begin
96095>>>>>            Function_Return True
96096>>>>>        End                     
96096>>>>>>
96096>>>>>        
96096>>>>>        Move False to Err
96097>>>>>        Decrement iSize
96098>>>>>        For iCount from 0 to iSize
96104>>>>>>
96104>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
96105>>>>>            Get ApiColumnRename hTable aAPIColumnsToRename[iCount].sFieldNameTo aAPIColumnsToRename[iCount].sFieldNameFrom to bOK 
96106>>>>>        Loop
96107>>>>>>
96107>>>>>        
96107>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
96108>>>>>        Function_Return bOK
96109>>>>>    End_Function
96110>>>>>
96110>>>>>    Function UtilColumnIsDateType Integer iType Boolean bIsSQLTableTo Returns Boolean
96112>>>>>        Boolean bDateType
96112>>>>>        
96112>>>>>        If (bIsSQLTableTo = True) Begin
96114>>>>>            Move (iType = SQL_TYPE_DATE or iType = SQL_TYPE_TIMESTAMP or iType = SQL_TYPE_TIMESTAMP2) to bDateType
96115>>>>>        End 
96115>>>>>>
96115>>>>>        Else Begin
96116>>>>>            Move (iType = DF_DATE or iType = DF_DATETIME) to bDateType
96117>>>>>        End
96117>>>>>>
96117>>>>>    
96117>>>>>        Function_Return bDateType
96118>>>>>    End_Function
96119>>>>>    
96119>>>>>    Function ApiColumnsUpdate String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo Boolean bCompareDate_DateTime Returns Boolean
96121>>>>>        Integer iCount iSize iColumn iTypeFrom iTypeTo iDataFlexType iIndex iLengthFrom iLengthTo iPrecisionFrom iPrecisionTo iOptionFrom iOptionTo iDbType
96121>>>>>        Handle hFile
96121>>>>>        Boolean bFieldExistsFrom bFieldExistsTo bShouldMove bIsSQLDriver bIsSame bOK bSkip
96121>>>>>        Boolean bRecnum bIsSQLTableTo bOpened bRecnumTable bIsOpen bSkipTypeChange bIsDateType
96121>>>>>        String sFieldNameFrom sFieldNameTo sDriverIDTo sDefaultValue
96121>>>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns
96121>>>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns
96125>>>>>        tColumnType ColumnType
96125>>>>>        tColumnType ColumnType
96125>>>>>
96125>>>>>        Move False to Err
96126>>>>>        Close hTable
96127>>>>>        Get OpenTableExclusive hTable to bIsOpen
96128>>>>>        If (bIsOpen = False) Begin
96130>>>>>            Error DFERR_PROGRAM ("Function 'ApiColumnsUpdate'. Can't open table number:" * String(hTable))
96131>>>>>>
96131>>>>>            Function_Return False
96132>>>>>        End
96132>>>>>>
96132>>>>>
96132>>>>>        Get piDbType to iDbType
96133>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
96136>>>>>        Get IsSQLDriver sDriverIDFrom to bIsSQLDriver
96137>>>>>        Get UtilTableIsSQL hTable     to bIsSQLTableTo
96138>>>>>        If (bIsSQLTableTo = False) Begin
96140>>>>>            Move DATAFLEX_ID to sDriverIDTo
96141>>>>>        End
96141>>>>>>
96141>>>>>        Else Begin          
96142>>>>>            Get_Attribute DF_FILE_DRIVER of hTable to sDriverIDTo
96145>>>>>        End
96145>>>>>>
96145>>>>>        
96145>>>>>        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
96146>>>>>        
96146>>>>>        // Before we start to change the table we need to do three things;
96146>>>>>        // 1) Insert any new fields
96146>>>>>        Get UtilColumnsCheckForInserts hTable aAPIColumnCompare to aApiInsertColumns
96147>>>>>        If (SizeOfArray(aApiInsertColumns)) Begin
96149>>>>>            Get UtilColumnsInsert hTable aApiInsertColumns to bOK
96150>>>>>            If (bOK = False) Begin
96152>>>>>                Function_Return False
96153>>>>>            End                  
96153>>>>>>
96153>>>>>            // Update info with changes made.
96153>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
96154>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
96155>>>>>        End
96155>>>>>>
96155>>>>>        
96155>>>>>        // 2) Rename fields
96155>>>>>        Get UtilColumnsCheckForRenames hTable aAPIColumnCompare to aAPIRenameColumns
96156>>>>>        If (SizeOfArray(aAPIRenameColumns)) Begin
96158>>>>>            Get UtilColumnsRename hTable aAPIRenameColumns to bOK
96159>>>>>            If (bOK = False) Begin
96161>>>>>                Function_Return False
96162>>>>>            End
96162>>>>>>
96162>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
96163>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
96164>>>>>        End
96164>>>>>>
96164>>>>>
96164>>>>>        // 3) Move fields with same names
96164>>>>>        Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIMoveColumns
96165>>>>>        If (SizeOfArray(aAPIMoveColumns)) Begin
96167>>>>>            Get UtilColumnsMove hTable aAPIMoveColumns to bOK
96168>>>>>            If (bOK = False) Begin
96170>>>>>                Function_Return False
96171>>>>>            End
96171>>>>>>
96171>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
96172>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
96173>>>>>        End
96173>>>>>>
96173>>>>>        
96173>>>>>        // If any of the fields were changed by "Insert", "Rename" or "Move", we need to compare the fields again: 
96173>>>>>        If (SizeOfArray(aApiInsertColumns) or SizeOfArray(aAPIRenameColumns) or SizeOfArray(aAPIMoveColumns)) Begin
96175>>>>>            Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
96176>>>>>            If (bIsSame = True) Begin
96178>>>>>                Function_Return True
96179>>>>>            End
96179>>>>>>
96179>>>>>        End
96179>>>>>>
96179>>>>>        
96179>>>>>        // We can now continue to make standard field changes:
96179>>>>>        Get OpenTableExclusive hTable to bIsOpen
96180>>>>>        Set Private.phCurrentTable to hTable
96181>>>>>        Move hTable to hFile
96182>>>>>        Structure_Start hFile sDriverIDTo
96183>>>>>
96183>>>>>            Move (SizeOfArray(aAPIColumnCompare)) to iSize
96184>>>>>            Decrement iSize
96185>>>>>            For iCount from 0 to iSize
96191>>>>>>
96191>>>>>                Send DoAdvance of ghoProgressBar
96192>>>>>                                
96192>>>>>                Move aAPIColumnCompare[iCount].bExistsFrom          to bFieldExistsFrom
96193>>>>>                If (bFieldExistsFrom = True) Begin
96195>>>>>                    Move aAPIColumnCompare[iCount].bExistsTo        to bFieldExistsTo
96196>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameFrom   to sFieldNameFrom
96197>>>>>                    Move aAPIColumnCompare[iCount].iFieldNumber     to iColumn              
96198>>>>>                    Set Private.piCurrentField                      to iColumn
96199>>>>>                    Move aAPIColumnCompare[iCount].iLengthFrom      to iLengthFrom                                   
96200>>>>>                    Move aAPIColumnCompare[iCount].iPrecisionFrom   to iPrecisionFrom
96201>>>>>                    Move aAPIColumnCompare[iCount].iOptionsFrom     to iOptionFrom
96202>>>>>                    
96202>>>>>                    Move aAPIColumnCompare[iCount].iTypeFrom        to iTypeFrom
96203>>>>>//                    Get UtilDFDataTypeToSqlTypeMapping sDriverIDFrom iDbType iTypeFrom to ColumnType
96203>>>>>//                    Move ColumnType.iDataFlexType                   to iDataFlexType
96203>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iDataFlexType
96204>>>>>                    If (iTypeFrom < -1490) Begin
96206>>>>>                        Move (iTypeFrom + 1500)                     to iTypeFrom
96207>>>>>                    End
96207>>>>>>
96207>>>>>    
96207>>>>>                    // If one of the two tables are SQL and the other Embedded we need to "translate"
96207>>>>>                    // data types between Embedded and SQL, else we can't compare the data types.
96207>>>>>                    If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
96209>>>>>                        Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeFrom
96210>>>>>                    End
96210>>>>>>
96210>>>>>                    Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
96213>>>>>                        Get UtilSqlColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeTo
96214>>>>>                    End
96214>>>>>>
96214>>>>>                    
96214>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameTo to sFieldNameTo
96215>>>>>                    Move aAPIColumnCompare[iCount].iLengthTo    to iLengthTo
96216>>>>>                    Move aAPIColumnCompare[iCount].iPrecisionTo to iPrecisionTo
96217>>>>>                    Move aAPIColumnCompare[iCount].iOptionsTo   to iOptionTo
96218>>>>>                    Move aAPIColumnCompare[iCount].iTypeTo      to iTypeTo
96219>>>>>                    
96219>>>>>                    Move False to bSkipTypeChange
96220>>>>>                    If (bCompareDate_DateTime = False) Begin
96222>>>>>                        Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkipTypeChange
96223>>>>>                    End
96223>>>>>>
96223>>>>>                    
96223>>>>>                    If (bFieldExistsTo = False) Begin 
96225>>>>>                        Move 0 to iColumn
96226>>>>>                        Create_Field hFile At iColumn
96227>>>>>                        Set Private.piCurrentField to iColumn
96228>>>>>                    End
96228>>>>>>
96228>>>>>                    
96228>>>>>                    If (sFieldNameFrom <> sFieldNameTo) Begin
96230>>>>>                        Set_Attribute DF_FIELD_NAME of hFile iColumn to sFieldNameFrom
96233>>>>>                    End                   
96233>>>>>>
96233>>>>>                    
96233>>>>>                    If (bIsSQLTableFrom = True and aAPIColumnCompare[iCount].iOptionsFrom <> C_tAPIColumn_Identity) Begin
96235>>>>>                        Set_Attribute DF_FIELD_NULL_ALLOWED  of hFile iColumn to aAPIColumnCompare[iCount].bAllowNULLFrom
96238>>>>>                        Move aAPIColumnCompare[iCount].sDefaultValueFrom to sDefaultValue
96239>>>>>                        If (iDataFlexType = DF_BCD and Left(sDefaultValue, 1 <> "[")) Begin
96241>>>>>                            Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
96242>>>>>                        End
96242>>>>>>
96242>>>>>                        Set_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefaultValue
96245>>>>>                    End
96245>>>>>>
96245>>>>>                    
96245>>>>>                    If (bSkipTypeChange = False) Begin
96247>>>>>                        If (iTypeFrom <> iTypeTo) Begin 
96249>>>>>                            If (bIsSQLTableTo = True) Begin
96251>>>>>                                Set_Attribute DF_FIELD_NATIVE_TYPE   of hFile iColumn to iTypeFrom
96254>>>>>                            End
96254>>>>>>
96254>>>>>                            Else Begin
96255>>>>>                                Set_Attribute DF_FIELD_TYPE          of hFile iColumn to iDataFlexType
96258>>>>>                            End
96258>>>>>>
96258>>>>>                        End
96258>>>>>>
96258>>>>>                    End
96258>>>>>>
96258>>>>>                    
96258>>>>>                    Get UtilColumnIsDateType iTypeFrom bIsSQLTableTo to bIsDateType   
96259>>>>>                    // We can't set the length or precision for Date type columns (they are fixed).
96259>>>>>                    If (bIsDateType = False) Begin
96261>>>>>                        If (iLengthFrom <> iLengthTo) Begin
96263>>>>>                            Set_Attribute DF_FIELD_LENGTH of hFile iColumn to iLengthFrom
96266>>>>>                        End
96266>>>>>>
96266>>>>>                        If (iPrecisionFrom <> iPrecisionTo) Begin
96268>>>>>                            Set_Attribute DF_FIELD_PRECISION of hFile iColumn to iPrecisionFrom
96271>>>>>                        End
96271>>>>>>
96271>>>>>                    End
96271>>>>>>
96271>>>>>    
96271>>>>>                    If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
96273>>>>>                        // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
96273>>>>>                        If (bRecnumTable = True) Begin
96275>>>>>                            Set_Attribute DF_FILE_RECNUM_TABLE of hTable to False
96278>>>>>                        End
96278>>>>>>
96278>>>>>    
96278>>>>>                        // We might need to create an index here.
96278>>>>>                        // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
96278>>>>>                        // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
96278>>>>>                        // index update checking logic.
96278>>>>>                        Get_Attribute DF_FIELD_INDEX           of hFile iColumn to iIndex
96281>>>>>                        If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
96283>>>>>                            Create_Index hFile at iIndex
96284>>>>>                            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hFile iIndex to 1
96287>>>>>                        End
96287>>>>>>
96287>>>>>
96287>>>>>                        Set_Attribute DF_INDEX_SEGMENT_FIELD   of hFile iIndex 1 to iColumn
96290>>>>>                        Set_Attribute DF_FILE_PRIMARY_INDEX    of hFile          to iIndex
96293>>>>>                            // Note: The order of these two are crucial!
96293>>>>>                            Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hFile iIndex to True
96296>>>>>                            Set_Attribute DF_FIELD_IS_IDENTITY of hFile iColumn    to True
96299>>>>>                    End
96299>>>>>>
96299>>>>>                End
96299>>>>>>
96299>>>>>            Loop 
96300>>>>>>
96300>>>>>        
96300>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
96301>>>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
96303>>>>>
96303>>>>>        Set Action_Text of ghoStatusPanel to ""
96304>>>>>        Function_Return (Err = False)
96305>>>>>    End_Function
96306>>>>>
96306>>>>>    // * Dummy function for the Studio's Code Explorer *
96306>>>>>    Function API_INDEX_FUNCTIONS Returns Boolean
96308>>>>>        Function_Return False
96309>>>>>    End_Function
96310>>>>>
96310>>>>>    // Get ApiIndexCreate Customers.File_Number 1 2 0 1 -1 -1 -1 -1 -1 -1 -1 -1 to bOK
96310>>>>>    // Note: the "-1" can be left out as this function is overloaded to make it easier to call.
96310>>>>>    // Note: This doesn't set Descending attributes - Use function IndexChangeDirection to do that.
96310>>>>>    Function ApiIndexCreate Handle hTable Integer iIndex Integer iSegments Integer iSgmnt1 Integer iSgmnt2 Integer iSgmnt3 Integer iSgmnt4 Integer iSgmnt5 Integer iSgmnt6 Integer iSgmnt7 Integer iSgmnt8 Integer iSgmnt9 Integer iSgmnt10 Returns Boolean
96312>>>>>        Integer iTableNo iSegment1 iSegment2 iSegment3 iSegment4 iSegment5 iSegment6 iSegment7 iSegment8 iSegment9 iSegment10
96312>>>>>        String sDriverID
96312>>>>>        Boolean bOK
96312>>>>>
96312>>>>>        Get AutoConnectionIDLogin to bOK
96313>>>>>        Move -1 to iSegment1
96314>>>>>        Move -1 to iSegment2
96315>>>>>        Move -1 to iSegment3
96316>>>>>        Move -1 to iSegment4
96317>>>>>        Move -1 to iSegment5
96318>>>>>        Move -1 to iSegment6
96319>>>>>        Move -1 to iSegment7
96320>>>>>        Move -1 to iSegment8
96321>>>>>        Move -1 to iSegment9
96322>>>>>        Move -1 to iSegment10
96323>>>>>
96323>>>>>        If (num_arguments > 3) Begin
96325>>>>>            Move iSgmnt1 to iSegment1
96326>>>>>        End
96326>>>>>>
96326>>>>>        If (num_arguments > 4) Begin
96328>>>>>            Move iSgmnt2 to iSegment2
96329>>>>>        End
96329>>>>>>
96329>>>>>        If (num_arguments > 5) Begin
96331>>>>>            Move iSgmnt3 to iSegment3
96332>>>>>        End
96332>>>>>>
96332>>>>>        If (num_arguments > 6) Begin
96334>>>>>            Move iSgmnt4 to iSegment4
96335>>>>>        End
96335>>>>>>
96335>>>>>        If (num_arguments > 7) Begin
96337>>>>>            Move iSgmnt5 to iSegment5
96338>>>>>        End
96338>>>>>>
96338>>>>>        If (num_arguments > 8) Begin
96340>>>>>            Move iSgmnt6 to iSegment6
96341>>>>>        End
96341>>>>>>
96341>>>>>        If (num_arguments > 9) Begin
96343>>>>>            Move iSgmnt7 to iSegment7
96344>>>>>        End
96344>>>>>>
96344>>>>>        If (num_arguments > 10) Begin
96346>>>>>            Move iSgmnt8 to iSegment8
96347>>>>>        End
96347>>>>>>
96347>>>>>        If (num_arguments > 11) Begin
96349>>>>>            Move iSgmnt9 to iSegment9
96350>>>>>        End
96350>>>>>>
96350>>>>>        If (num_arguments > 12) Begin
96352>>>>>            Move iSgmnt10 to iSegment10
96353>>>>>        End
96353>>>>>>
96353>>>>>
96353>>>>>        Move False to Err
96354>>>>>        Move hTable to iTableNo
96355>>>>>        Get OpenTableExclusive hTable to bOK
96356>>>>>        If (bOK = False) Begin
96358>>>>>            Function_Return False
96359>>>>>        End
96359>>>>>>
96359>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
96362>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
96363>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
96364>>>>>        Send Ignore_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
96365>>>>>
96365>>>>>        // We start by deleting the index
96365>>>>>        Structure_Start hTable sDriverID
96366>>>>>            Delete_Index iTableNo iIndex
96367>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
96368>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
96370>>>>>
96370>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
96371>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
96372>>>>>        Send Trap_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
96373>>>>>        Set Action_Text of ghoStatusPanel to ""
96374>>>>>        Move False to Err 
96375>>>>>        Move 0 to LastErr
96376>>>>>        Move iTableNo to hTable
96377>>>>>        Get OpenTableExclusive hTable to bOK
96378>>>>>        If (bOK = False) Begin
96380>>>>>            Function_Return False
96381>>>>>        End
96381>>>>>>
96381>>>>>
96381>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
96382>>>>>        Structure_Start hTable sDriverID
96383>>>>>            Create_Index hTable At iIndex
96384>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iSegments
96387>>>>>
96387>>>>>            If (iSgmnt1 <> -1) Begin
96389>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 1 to iSegment1
96392>>>>>            End
96392>>>>>>
96392>>>>>            If (iSegment2 <> -1) Begin
96394>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 2 to iSegment2
96397>>>>>            End
96397>>>>>>
96397>>>>>            If (iSegment3 <> -1) Begin
96399>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 3 to iSegment3
96402>>>>>            End
96402>>>>>>
96402>>>>>            If (iSegment4 <> -1) Begin
96404>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 4 to iSegment4
96407>>>>>            End
96407>>>>>>
96407>>>>>            If (iSegment5 <> -1) Begin
96409>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 5 to iSegment5
96412>>>>>            End
96412>>>>>>
96412>>>>>            If (iSegment6 <> -1) Begin
96414>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 6 to iSegment6
96417>>>>>            End
96417>>>>>>
96417>>>>>            If (iSegment7 <> -1) Begin
96419>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 7 to iSegment7
96422>>>>>            End
96422>>>>>>
96422>>>>>            If (iSegment8 <> -1) Begin
96424>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 8 to iSegment8
96427>>>>>            End
96427>>>>>>
96427>>>>>            If (iSegment9 <> -1) Begin
96429>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 9 to iSegment9
96432>>>>>            End
96432>>>>>>
96432>>>>>            If (iSegment10 <> -1) Begin
96434>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 10 to iSegment10
96437>>>>>            End
96437>>>>>>
96437>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
96438>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
96440>>>>>
96440>>>>>        Set Action_Text of ghoStatusPanel to ""
96441>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
96442>>>>>
96442>>>>>        Function_Return (Err = False)
96443>>>>>    End_Function
96444>>>>>
96444>>>>>    Function APIIndexCreateByFieldNames Handle hTable tAPIIndex APIIndex tAPIIndex[] APIIndexTo tAPIIndexSegment[] aIndexSegments Returns Boolean
96446>>>>>        String[] aFields
96447>>>>>        Integer iCount iSegmentsFrom iFieldFrom iFieldTo iSegmentsTo iSQLIndexType iLastIndex iTableNo iSQLIndexTo
96447>>>>>        String sDriverID sSQLIndexName sTableName
96447>>>>>        Boolean bOK bIsSQLTable bIsOpen bIsSQLPrimaryKey bIsSQLClustered bIsSQLTemporaryIndex bExists
96447>>>>>
96447>>>>>        Move (SizeOfArray(aIndexSegments)) to iSegmentsFrom
96448>>>>>        If (iSegmentsFrom = 0) Begin
96450>>>>>            Function_Return False
96451>>>>>        End
96451>>>>>>
96451>>>>>
96451>>>>>        Get AutoConnectionIDLogin to bOK
96452>>>>>        Move False to Err
96453>>>>>        Get OpenTableExclusive hTable to bIsOpen
96454>>>>>        If (bIsOpen = False) Begin
96456>>>>>            Function_Return False
96457>>>>>        End
96457>>>>>>
96457>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
96460>>>>>        Get UtilTableIsSql hTable to bIsSQLTable   
96461>>>>>        
96461>>>>>        Move 0     to iSegmentsTo    
96462>>>>>        Move 0     to iSQLIndexType 
96463>>>>>        Move ""    to sSQLIndexName
96464>>>>>        Move False to bIsSQLTemporaryIndex 
96465>>>>>        Move False to bIsSQLPrimaryKey
96466>>>>>        Move False to bIsSQLClustered
96467>>>>>        
96467>>>>>//        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable                               to iLastIndex
96467>>>>>//        If (APIIndex.iIndexNumber <= iLastIndex) Begin
96467>>>>>//            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber      to iSegmentsTo
96467>>>>>//            If (bIsSQLTable = True) Begin
96467>>>>>//                Get_Attribute DF_INDEX_NAME of hTable APIIndex.iIndexNumber             to sSQLIndexName
96467>>>>>//                #IF (Required_RT_Version > 17)                                    
96467>>>>>//                Get_Attribute DF_INDEX_SQL_TYPE of hTable APIIndex.iIndexNumber         to iSQLIndexType
96467>>>>>//                Move (iSQLIndexType = DF_INDEX_TEMPORARY)                               to bIsSQLTemporaryIndex
96467>>>>>//                Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber  to bIsSQLPrimaryKey
96467>>>>>//                Get_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber  to bIsSQLClustered
96467>>>>>//                #ENDIF
96467>>>>>//            End
96467>>>>>//        End
96467>>>>>        
96467>>>>>        Move hTable to iTableNo 
96468>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber to bExists
96471>>>>>        If (bExists = True) Begin
96473>>>>>            Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber to bIsSQLPrimaryKey
96476>>>>>            If (bIsSQLPrimaryKey = False) Begin
96478>>>>>                // We start by deleting the index, if it exists
96478>>>>>                Structure_Start iTableNo sDriverID
96479>>>>>                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
96480>>>>>                    Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
96481>>>>>                    Delete_Index iTableNo APIIndex.iIndexNumber
96482>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
96483>>>>>                    Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
96484>>>>>                    Set Action_Text of ghoStatusPanel to "Restructures table..."
96485>>>>>                Structure_End iTableNo DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
96487>>>>>                Set Action_Text of ghoStatusPanel to ""
96488>>>>>                
96488>>>>>                Get OpenTableExclusive hTable to bOK
96489>>>>>                If (bOK = False) Begin
96491>>>>>                    Function_Return False
96492>>>>>                End
96492>>>>>>
96492>>>>>            End
96492>>>>>>
96492>>>>>        End
96492>>>>>>
96492>>>>>        
96492>>>>>        Move hTable to iTableNo
96493>>>>>        Move False to Err
96494>>>>>        Move 0 to LastErr 
96495>>>>>
96495>>>>>        // Note: If the SQL index type = DF_INDEX_TEMPORARY, we _must_ set the DF_INDEX_SQL_TYPE 
96495>>>>>        //       _outside_ the Structure_Start/End construct.
96495>>>>>//        Move False to bIsSQLTemporaryIndex
96495>>>>>//        #IF (Required_RT_Version > 17)                                    
96495>>>>>//            If (bIsSQLTemporaryIndex = True and APIIndex.iIndexNumber <= iLastIndex) Begin
96495>>>>>//                If (APIIndex.iSQLIndexType <> iSQLIndexType) Begin
96495>>>>>//                    Set_Attribute DF_INDEX_SQL_TYPE of hTable APIIndex.iIndexNumber to APIIndex.iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
96495>>>>>//                End
96495>>>>>//            End
96495>>>>>//        #ENDIF
96495>>>>>        
96495>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
96496>>>>>        Structure_Start hTable sDriverID
96497>>>>>            If (bIsSQLPrimaryKey = False) Begin
96499>>>>>                Create_Index hTable At APIIndex.iIndexNumber
96500>>>>>            End
96500>>>>>>
96500>>>>>
96500>>>>>//            If (bIsSQLTable = True) Begin                                                         
96500>>>>>//                // In case the SQL Index name already exists for another index number; we temporarily rename that index name;
96500>>>>>//                Get UtilIndexSQLIndexNameExists iTableNo APIIndex.iIndexNumber APIIndex.sSQLIndexName APIIndexTo to iSQLIndexTo
96500>>>>>//                If (iSQLIndexTo > 0) Begin   
96500>>>>>//                    Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
96500>>>>>//                    Set_Attribute DF_INDEX_NAME of hTable iSQLIndexTo to (sTableName + String("001") + String(iSQLIndexTo))
96500>>>>>//                End
96500>>>>>//                Set_Attribute DF_INDEX_NAME of hTable APIIndex.iIndexNumber to APIIndex.sSQLIndexName
96500>>>>>//            End
96500>>>>>            
96500>>>>>            If (bIsSQLTable = True) Begin // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
96502>>>>>                Set_Attribute DF_INDEX_SQL_TYPE        of hTable APIIndex.iIndexNumber to APIIndex.iSQLIndexType 
96505>>>>>                Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLPrimaryKey
96508>>>>>                Set_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLClustered
96511>>>>>            End
96511>>>>>>
96511>>>>>                
96511>>>>>                If (iSegmentsFrom <> iSegmentsTo) Begin
96513>>>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber to iSegmentsFrom
96516>>>>>            End
96516>>>>>>
96516>>>>>            
96516>>>>>            for iCount from 0 to (iSegmentsFrom -1)
96522>>>>>>
96522>>>>>                Move aIndexSegments[iCount].iFieldNumber to iFieldFrom   
96523>>>>>                If (iFieldFrom <> -1 ) Begin
96525>>>>>                        Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable APIIndex.iIndexNumber (iCount +1) to iFieldFrom
96528>>>>>                End
96528>>>>>>
96528>>>>>            Loop                         
96529>>>>>>
96529>>>>>                
96529>>>>>            // If more segments existed; remove them
96529>>>>>//            If (iSegmentsTo > iSegmentsFrom) Begin
96529>>>>>//                for iCount from iSegmentsFrom to iSegmentsTo
96529>>>>>//                          Get ApiIndexDeleteSegment hTable APIIndex.iIndexNumber iCount to bOK
96529>>>>>//                Loop
96529>>>>>//                  Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber to iSegmentsFrom
96529>>>>>//            End
96529>>>>>                
96529>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
96530>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
96532>>>>>
96532>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
96533>>>>>        Set Action_Text of ghoStatusPanel to ""
96534>>>>>        
96534>>>>>        Function_Return (Err = False)
96535>>>>>    End_Function 
96536>>>>>    
96536>>>>>    // Checks if an SQL Index name for the "FROM" database already exists in the TO database,
96536>>>>>    // but with another Index number. We can then not rename the SQL index name for the TO database table.
96536>>>>>    Function UtilIndexSQLIndexNameExists Handle hTable Integer iIndexNumberFrom String sSQLIndexNameFrom tAPIIndex[] APIIndexTo Returns Integer
96538>>>>>        Integer iSize iCount iIndexNumberTo
96538>>>>>        String sSQLIndexNameTo
96538>>>>>        Integer iRetVal
96538>>>>>        
96538>>>>>        Move 0 to iRetVal     
96539>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndexNumberFrom to iRetVal
96542>>>>>        If (iRetVal = 0) Begin
96544>>>>>            Function_Return 0
96545>>>>>        End
96545>>>>>>
96545>>>>>        Move (SizeOfArray(APIIndexTo)) to iSize
96546>>>>>        Decrement iSize
96547>>>>>        for iCount from 0 to iSize
96553>>>>>>
96553>>>>>            If (Uppercase(sSQLIndexNameFrom) = Uppercase(APIIndexTo[iCount].sSQLIndexName)) Begin
96555>>>>>                If (iIndexNumberFrom <> APIIndexTo[iCount].iIndexNumber) Begin
96557>>>>>                    Move APIIndexTo[iCount].iIndexNumber to iRetVal
96558>>>>>                End
96558>>>>>>
96558>>>>>            End
96558>>>>>>
96558>>>>>        Loop
96559>>>>>>
96559>>>>>        
96559>>>>>        Function_Return iRetVal
96560>>>>>    End_Function   
96561>>>>>    
96561>>>>>    Function ApiIndexDeleteSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
96563>>>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
96563>>>>>    
96563>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
96566>>>>>        If (iSegment = iNumSegments) Begin
96568>>>>>//            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
96568>>>>>        End
96568>>>>>>
96568>>>>>    
96568>>>>>        Else If (iSegment > 0 and iSegment < iNumSegments) Begin
96571>>>>>            for iCurSegment from iSegment to (iNumSegments - 1)
96577>>>>>>
96577>>>>>                //*** Move index segment attributes
96577>>>>>                Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
96580>>>>>                Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
96583>>>>>                Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
96586>>>>>    
96586>>>>>                Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment to iSegmentCase
96589>>>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment to iSegmentDirection
96592>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment to iSegmentColumn
96595>>>>>            Loop
96596>>>>>>
96596>>>>>    
96596>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
96599>>>>>        End
96599>>>>>>
96599>>>>>    
96599>>>>>    End_Procedure
96600>>>>>
96600>>>>>    Function APIIndexRemoveAllIndexes Handle hTable tAPIIndex[] APIIndex Returns Boolean
96602>>>>>        String[] aFields
96603>>>>>        Integer iCount iSize iIndex 
96603>>>>>        String sDriverID
96603>>>>>        Boolean bOK bIsSQLTable bIsOpen bIsSQLPrimaryKey
96603>>>>>
96603>>>>>        Move (SizeOfArray(APIIndex)) to iSize
96604>>>>>        If (iSize = 0) Begin
96606>>>>>            Function_Return True
96607>>>>>        End
96607>>>>>>
96607>>>>>
96607>>>>>        Get AutoConnectionIDLogin to bOK
96608>>>>>        Move False to Err
96609>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
96612>>>>>        If (bIsOpen = False) Begin
96614>>>>>            Get OpenTableExclusive hTable to bIsOpen
96615>>>>>            If (bIsOpen = False) Begin
96617>>>>>                Function_Return False
96618>>>>>            End
96618>>>>>>
96618>>>>>        End    
96618>>>>>>
96618>>>>>        
96618>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
96621>>>>>        Get UtilTableIsSql hTable to bIsSQLTable
96622>>>>>
96622>>>>>        Move False to Err
96623>>>>>        Move 0 to LastErr             
96624>>>>>        Decrement iSize
96625>>>>>
96625>>>>>        Structure_Start hTable sDriverID
96626>>>>>            for iCount from 0 to iSize
96632>>>>>>
96632>>>>>//                Move False to bIsSQLPrimaryKey
96632>>>>>//                #IF ((Required_RT_Version * 10 + Required_RT_Revision) > 180)   // DF 18.1 and up
96632>>>>>//                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
96632>>>>>//                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex[iCount].iIndexNumber to bIsSQLPrimaryKey
96632>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
96632>>>>>//                #ENDIF
96632>>>>>                // We can't delete if this is a primary key index:
96632>>>>>//                If (bIsSQLPrimaryKey = False) Begin
96632>>>>>                    Move APIIndex[iCount].iIndexNumber to iIndex
96633>>>>>                    Delete_Index hTable iIndex
96634>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
96634>>>>>//                End
96634>>>>>            Loop
96635>>>>>>
96635>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
96636>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
96638>>>>>//        Move False to Err
96638>>>>>        Move 0 to LastErr
96639>>>>>
96639>>>>>        Set Action_Text of ghoStatusPanel to ""
96640>>>>>        Function_Return (Err = False)
96641>>>>>    End_Function
96642>>>>>
96642>>>>>    Function ApiIndexChangeDirection Handle hTable Integer iIndex Integer iSegment Integer iDirection Returns Boolean
96644>>>>>        Boolean bOK
96644>>>>>
96644>>>>>        Get AutoConnectionIDLogin to bOK
96645>>>>>        Move False to Err
96646>>>>>        Get OpenTableExclusive hTable to bOK
96647>>>>>        If (bOK = False) Begin
96649>>>>>            Function_Return False
96650>>>>>        End
96650>>>>>>
96650>>>>>        Structure_Start hTable
96651>>>>>            Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to iDirection
96654>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
96655>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
96657>>>>>
96657>>>>>        Set Action_Text of ghoStatusPanel to ""
96658>>>>>        Function_Return (Err = False)
96659>>>>>    End_Function
96660>>>>>
96660>>>>>    Function ApiIndexChangeUppercase Handle hTable Integer iIndex Integer iSegment Boolean bUppercase Returns Boolean
96662>>>>>        Integer iCase
96662>>>>>        Boolean bOK
96662>>>>>
96662>>>>>        If (bUppercase = True) Begin
96664>>>>>            Move DF_CASE_IGNORED to iCase
96665>>>>>        End
96665>>>>>>
96665>>>>>        Else Begin
96666>>>>>            Move DF_CASE_USED to iCase
96667>>>>>        End
96667>>>>>>
96667>>>>>
96667>>>>>        Get AutoConnectionIDLogin to bOK
96668>>>>>        Move False to Err
96669>>>>>        Get OpenTableExclusive hTable to bOK
96670>>>>>        If (bOK = False) Begin
96672>>>>>            Function_Return False
96673>>>>>        End
96673>>>>>>
96673>>>>>        Structure_Start hTable
96674>>>>>            Set_Attribute DF_INDEX_SEGMENT_CASE of hTable iIndex iSegment to iCase
96677>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
96678>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
96680>>>>>
96680>>>>>        Set Action_Text of ghoStatusPanel to ""
96681>>>>>        Function_Return (Err = False)
96682>>>>>    End_Function
96683>>>>>
96683>>>>>    // To delete an index
96683>>>>>    Function ApiIndexRemove Handle hTable Integer iIndex Returns Boolean
96685>>>>>        Integer iTableNo iNumSegments
96685>>>>>        String sDriverID
96685>>>>>        Boolean bOK
96685>>>>>
96685>>>>>        Get AutoConnectionIDLogin to bOK
96686>>>>>        Move False to Err
96687>>>>>        Move hTable to iTableNo
96688>>>>>        Get OpenTableExclusive hTable to bOK
96689>>>>>        If (bOK = False) Begin
96691>>>>>            Function_Return False
96692>>>>>        End
96692>>>>>>
96692>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
96695>>>>>
96695>>>>>        // Check to see if the index exists or not...
96695>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
96698>>>>>        If (iNumSegments = 0) Begin
96700>>>>>            Function_Return False
96701>>>>>        End
96701>>>>>>
96701>>>>>
96701>>>>>        Structure_Start hTable sDriverID
96702>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
96703>>>>>            Delete_Index iTableNo iIndex
96704>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
96705>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
96706>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
96708>>>>>
96708>>>>>        Set Action_Text of ghoStatusPanel to ""
96709>>>>>        Function_Return (Err = False)
96710>>>>>    End_Function
96711>>>>>
96711>>>>>    // Delete an Index Segment
96711>>>>>    Function ApiIndexRemoveSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
96713>>>>>        Boolean bOK bSQLDriver bIndexTemporary
96713>>>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
96713>>>>>        Integer iIndexType
96713>>>>>        String sDriverID
96713>>>>>
96713>>>>>        Get AutoConnectionIDLogin to bOK
96714>>>>>        Move False to Err
96715>>>>>
96715>>>>>        Get OpenTableExclusive hTable to bOK
96716>>>>>        If (bOK = False) Begin
96718>>>>>            Function_Return False
96719>>>>>        End
96719>>>>>>
96719>>>>>
96719>>>>>        // Check to see if the index exists or not...
96719>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
96722>>>>>        If (iNumSegments = 0) Begin
96724>>>>>            Function_Return False
96725>>>>>        End
96725>>>>>>
96725>>>>>
96725>>>>>        Move False to bIndexTemporary
96726>>>>>        Get psDriverID to sDriverID
96727>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
96728>>>>>        If (bSQLDriver) Begin
96730>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
96733>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
96736>>>>>                Move True to bIndexTemporary
96737>>>>>        End
96737>>>>>>
96737>>>>>
96737>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
96737>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
96739>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
96742>>>>>            If (iSegment = iNumSegments) Begin
96744>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
96747>>>>>            End
96747>>>>>>
96747>>>>>            Else If (iSegment > 0 and iSegment < iNumSegments) Begin
96750>>>>>                For iCurSegment from iSegment to (iNumSegments - 1)
96756>>>>>>
96756>>>>>                    //*** Move index segment attributes
96756>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
96759>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
96762>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
96765>>>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
96768>>>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
96771>>>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
96774>>>>>                Loop
96775>>>>>>
96775>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
96778>>>>>            End
96778>>>>>>
96778>>>>>        End
96778>>>>>>
96778>>>>>
96778>>>>>        Else Begin
96779>>>>>           Structure_Start hTable
96780>>>>>               Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
96783>>>>>               If (iSegment = iNumSegments) Begin
96785>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
96788>>>>>               End
96788>>>>>>
96788>>>>>               Else If (iSegment > 0 and iSegment < iNumSegments) Begin
96791>>>>>                   for iCurSegment from iSegment to (iNumSegments - 1)
96797>>>>>>
96797>>>>>                       //*** Move index segment attributes
96797>>>>>                       Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
96800>>>>>                       Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
96803>>>>>                       Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
96806>>>>>                       Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
96809>>>>>                       Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
96812>>>>>                       Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
96815>>>>>                   Loop
96816>>>>>>
96816>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
96819>>>>>               End
96819>>>>>>
96819>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
96820>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
96822>>>>>            Set Action_Text of ghoStatusPanel to ""
96823>>>>>        End
96823>>>>>>
96823>>>>>
96823>>>>>        Function_Return (Err = False)
96824>>>>>    End_Function
96825>>>>>
96825>>>>>    // Add/Insert an Index Segment
96825>>>>>    Function ApiIndexInsertSegment Handle hTable Integer iIndex Integer iSegment Integer iSegmentColumn Integer iSegmentCase Integer iSegmentDirection Returns Boolean
96827>>>>>        Boolean bOK bSQLDriver bIndexTemporary
96827>>>>>        Integer iNumSegments iCurSegment iCurSegmentColumn iCurSegmentCase iCurSegmentDirection
96827>>>>>        Integer iIndexType
96827>>>>>        String sDriverId
96827>>>>>
96827>>>>>        Get AutoConnectionIDLogin to bOK
96828>>>>>        Move False to Err
96829>>>>>
96829>>>>>        Get OpenTableExclusive hTable to bOK
96830>>>>>        If (bOK = False) Begin
96832>>>>>            Function_Return False
96833>>>>>        End
96833>>>>>>
96833>>>>>
96833>>>>>        Move False to bIndexTemporary
96834>>>>>        // Check to see if the index exists or not...
96834>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
96837>>>>>        If (iNumSegments = 0) Begin
96839>>>>>            Function_Return False
96840>>>>>        End
96840>>>>>>
96840>>>>>
96840>>>>>        Get psDriverID to sDriverID
96841>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
96842>>>>>        If (bSQLDriver) Begin
96844>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
96847>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
96850>>>>>                Move True to bIndexTemporary
96851>>>>>        End
96851>>>>>>
96851>>>>>
96851>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
96851>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
96853>>>>>           Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
96856>>>>>
96856>>>>>           If (iSegment > iNumSegments) Begin
96858>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
96861>>>>>               Move (iNumSegments + 1) to iCurSegment
96862>>>>>           End
96862>>>>>>
96862>>>>>           Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
96865>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
96868>>>>>               Move iNumSegments to iCurSegment
96869>>>>>
96869>>>>>               While (iCurSegment > iSegment)
96873>>>>>                   //*** Move index segment attributes
96873>>>>>                   Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iCurSegmentCase
96876>>>>>                   Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iCurSegmentDirection
96879>>>>>                   Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
96882>>>>>                   Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iCurSegmentCase
96885>>>>>                   Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iCurSegmentDirection
96888>>>>>                   Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iCurSegmentColumn
96891>>>>>                   Decrement iCurSegment
96892>>>>>               End
96893>>>>>>
96893>>>>>
96893>>>>>               //*** Now set new segment attributes
96893>>>>>               Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
96896>>>>>               Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
96899>>>>>               Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
96902>>>>>           End
96902>>>>>>
96902>>>>>        End
96902>>>>>>
96902>>>>>
96902>>>>>        Else Begin
96903>>>>>           Structure_Start hTable
96904>>>>>              Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
96907>>>>>
96907>>>>>              If (iSegment > iNumSegments) Begin
96909>>>>>                  Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
96912>>>>>                  Move (iNumSegments + 1) to iCurSegment
96913>>>>>              End
96913>>>>>>
96913>>>>>              Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
96916>>>>>                  Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
96919>>>>>                  Move iNumSegments to iCurSegment
96920>>>>>
96920>>>>>                  While (iCurSegment > iSegment)
96924>>>>>                      //*** Move index segment attributes
96924>>>>>                      Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iSegmentCase
96927>>>>>                      Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iSegmentDirection
96930>>>>>                      Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
96933>>>>>                      Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
96936>>>>>                      Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
96939>>>>>                      Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
96942>>>>>                      Decrement iCurSegment
96943>>>>>                  End
96944>>>>>>
96944>>>>>
96944>>>>>                  //*** Now set new segment attributes
96944>>>>>                  Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
96947>>>>>                  Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
96950>>>>>                  Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
96953>>>>>              End
96953>>>>>>
96953>>>>>              Set Action_Text of ghoStatusPanel to "Restructures table..."
96954>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
96956>>>>>            Set Action_Text of ghoStatusPanel to ""
96957>>>>>        End
96957>>>>>>
96957>>>>>
96957>>>>>        Function_Return (Err = False)
96958>>>>>    End_Function
96959>>>>>
96959>>>>>    Function API_TABLE_UTILITY_FUNCTIONS Returns Boolean
96961>>>>>        Function_Return False
96962>>>>>    End_Function
96963>>>>>
96963>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
96963>>>>>    // Note that it first removes any driver prefixes in the rootname.
96963>>>>>    Function UtilTableInfoCompare Boolean bCompareFilelistUppercase tAPITableNameInfoCompare APITableInfoCompare Returns Boolean
96965>>>>>        Boolean bIsSame
96965>>>>>        String sRootNameFrom sRootNameTo sLogicalNameFrom sLogicalNameTo sDisplayNameFrom sDisplayNameTo
96965>>>>>
96965>>>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameFrom    to sRootNameFrom
96966>>>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameTo      to sRootNameTo
96967>>>>>        Move APITableInfoCompare.sLogicalNameFrom               to sLogicalNameFrom
96968>>>>>        Move APITableInfoCompare.sLogicalNameTo                 to sLogicalNameTo
96969>>>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameFrom to sDisplayNameFrom
96970>>>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameTo   to sDisplayNameTo
96971>>>>>
96971>>>>>        If (bCompareFilelistUppercase = True) Begin
96973>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(sLogicalNameFrom) = Uppercase(sLogicalNameTo)) to bIsSame
96974>>>>>        End
96974>>>>>>
96974>>>>>        Else Begin
96975>>>>>            Move (sRootNameFrom = sRootNameTo and sLogicalNameFrom = sLogicalNameTo and sDisplayNameFrom = sDisplayNameTo) to bIsSame
96976>>>>>        End  
96976>>>>>>
96976>>>>>        If (bIsSame = False) Begin
96978>>>>>            Function_Return False
96979>>>>>        End 
96979>>>>>>
96979>>>>>
96979>>>>>        Move (APITableInfoCompare.bIsAliasFrom = APITableInfoCompare.bIsAliasTo) to bIsSame
96980>>>>>        If (bIsSame = False) Begin
96982>>>>>            Function_Return False
96983>>>>>        End 
96983>>>>>>
96983>>>>>
96983>>>>>        Move (APITableInfoCompare.bIsSQLFrom = APITableInfoCompare.bIsSQLTo) to bIsSame
96984>>>>>        If (bIsSame = False) Begin
96986>>>>>            Function_Return False
96987>>>>>        End 
96987>>>>>>
96987>>>>>
96987>>>>>        Move (APITableInfoCompare.bIsSystemFileFrom = APITableInfoCompare.bIsSystemFileTo) to bIsSame
96988>>>>>        If (bIsSame = False) Begin
96990>>>>>            Function_Return False
96991>>>>>        End 
96991>>>>>>
96991>>>>>
96991>>>>>        Function_Return bIsSame
96992>>>>>    End_Function
96993>>>>>
96993>>>>>    Function UtilTableCompare tAPITable APITableFrom tAPITable APITableTo Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
96995>>>>>        Handle hTableFrom hTableTo
96995>>>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
96995>>>>>        Boolean bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase
96995>>>>>        String sRootName sDriverIDFrom sDriverIDTo
96995>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
96995>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
96996>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
96996>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
96997>>>>>        tAPIRelationCompare[] aAPIRelationCompare
96997>>>>>        tAPIRelationCompare[] aAPIRelationCompare
96998>>>>>
96998>>>>>        Move (IsSameStruct(APITableFrom, APITableTo)) to bIsSame
96999>>>>>        If (bIsSame = True) Begin
97001>>>>>            Function_Return True
97002>>>>>        End
97002>>>>>>
97002>>>>>
97002>>>>>        Move False to bFilelistError
97003>>>>>        Move True to bIsSame
97004>>>>>        Get pbCompareDate_DateTime  to bCompareDate_DateTime
97005>>>>>        Get pbCompareIndexAscending to bCompareIndexAscending
97006>>>>>        Get pbCompareIndexUppercase to bCompareIndexUppercase
97007>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
97008>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
97009>>>>>
97009>>>>>        Move APITableFrom.ApiTableInfo.sRootName to sRootName
97010>>>>>        Get _TableNameOnly sRootName             to sRootName
97011>>>>>        Move sRootName to APITableTo.ApiTableInfo.sRootName
97012>>>>>
97012>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg is the same).
97012>>>>>        // bCodeGenerateMode = True = Code Generation mode.
97012>>>>>        If (bCodeGenerateMode = True) Begin
97014>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
97014>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
97016>>>>>                Function_Return False
97017>>>>>            End
97017>>>>>>
97017>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
97018>>>>>            If (bIsSame = False) Begin
97020>>>>>                Send UserError ("Yikes! There is a serious problem with the Filelist.cfg slot number:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * ".\nThis needs to be fixed before you can generate code for this table number.")
97021>>>>>                Move True to bFilelistError
97022>>>>>                Function_Return False
97023>>>>>            End
97023>>>>>>
97023>>>>>        End
97023>>>>>>
97023>>>>>
97023>>>>>        If (bCodeGenerateMode = False) Begin
97025>>>>>            // Then we want to create this table
97025>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
97027>>>>>                Function_Return False
97028>>>>>            End
97028>>>>>>
97028>>>>>
97028>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
97029>>>>>            If (bIsSame = False) Begin
97031>>>>>                Error DFERR_PROGRAM ("'UtilTableCompare function' problem in Filelist.cfg! Table No:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * "No changes was made for this entry.")
97032>>>>>>
97032>>>>>                Move True to bFilelistError
97033>>>>>                Function_Return False
97034>>>>>            End
97034>>>>>>
97034>>>>>        End
97034>>>>>>
97034>>>>>
97034>>>>>        // Check columns:
97034>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
97035>>>>>        Move APITableFrom.ApiTableInfo.bIsSQL       to bIsSQLFrom
97036>>>>>        Move APITableFrom.ApiTableInfo.sDriverID    to sDriverIDFrom
97037>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
97038>>>>>        Move APITableTo.ApiTableInfo.bIsSQL         to bIsSQLTo
97039>>>>>        Move APITableTo.ApiTableInfo.sDriverID      to sDriverIDTo
97040>>>>>        Get UtilColumnsStructFill hTableTo          to APITableTo.aApiColumns
97041>>>>>        Get UtilColumnCombineFromAndToArrays APITableFrom.aApiColumns APITableTo.aApiColumns to aAPIColumnCompare
97042>>>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
97043>>>>>        If (bIsSame = False) Begin
97045>>>>>            Function_Return False
97046>>>>>        End
97046>>>>>>
97046>>>>>
97046>>>>>        // ...then check indexes:
97046>>>>>        Get UtilIndexesStructFill hTableFrom to APITableTo.aApiIndexes
97047>>>>>        Get UtilIndexCombineFromAndToArrays APITableFrom.aApiIndexes APITableTo.aApiIndexes to aAPIIndexCompare
97048>>>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
97049>>>>>        If (bIsSame = False) Begin
97051>>>>>            Function_Return False
97052>>>>>        End
97052>>>>>>
97052>>>>>
97052>>>>>        // ...and finally relationships:
97052>>>>>        Get UtilRelationsStructFill hTableFrom to APITableTo.aApiRelations
97053>>>>>        Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations to aAPIRelationCompare
97054>>>>>        Move (IsSameArray(APITableFrom.aApiRelations, APITableTo.aApiRelations)) to bIsSame
97055>>>>>        Get UtilRelationsCompare hTableFrom aAPIRelationCompare to bIsSame
97056>>>>>
97056>>>>>        Function_Return (bIsSame = True)
97057>>>>>    End_Function
97058>>>>>
97058>>>>>    // Similar to UtilTableCompare, but takes a tAPITableCompare struct array and a tAPITableBooleans struct as params.
97058>>>>>    Function UtilTableCompare_Ex tAPITableCompare APITableCompare tAPITableBooleans CompareTableBooleans Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
97060>>>>>        Handle hTable
97060>>>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
97060>>>>>        String sRootName sDriverIDFrom sDriverIDTo
97060>>>>>
97060>>>>>        If (APITableCompare.APITableNameInfoCompare.bExistsFrom = False and APITableCompare.APITableNameInfoCompare.bExistsTo = False) Begin
97062>>>>>            Move True to bFilelistError
97063>>>>>            Function_Return False
97064>>>>>        End
97064>>>>>>
97064>>>>>
97064>>>>>        Move APITableCompare.hTable to hTable
97065>>>>>        Move True  to bIsSame
97066>>>>>        Move False to bFilelistError
97067>>>>>
97067>>>>>        If (APITableCompare.bExistsFrom = True) Begin
97069>>>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameFrom to sRootName
97070>>>>>        End
97070>>>>>>
97070>>>>>        Else Begin
97071>>>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameTo   to sRootName
97072>>>>>        End
97072>>>>>>
97072>>>>>        Get _TableNameOnly sRootName                                   to sRootName
97073>>>>>
97073>>>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDFrom     to sDriverIDFrom
97074>>>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDTo       to sDriverIDTo
97075>>>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLFrom        to bIsSQLFrom
97076>>>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLTo          to bIsSQLTo
97077>>>>>
97077>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg are the same).
97077>>>>>        // bCodeGenerateMode = True = Code Generation mode.
97077>>>>>        If (bCodeGenerateMode = True) Begin
97079>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
97079>>>>>            If (APITableCompare.bExistsTo = False) Begin
97081>>>>>                Function_Return False
97082>>>>>            End
97082>>>>>>
97082>>>>>            Move (Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) = Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameTo)) to bIsSame
97083>>>>>            If (bIsSame = False) Begin
97085>>>>>                Send UserError ("Yikes! There is a problem with the Filelist.cfg slot number:" * String(hTable) + ;                    ".\nThe FROM table logical name is:" * String(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) * "\nwhile the TO table logical name is:" * ;                    String(APITableCompare.APITableNameInfoCompare.sLogicalNameTo) * ".\nThis needs to be fixed before you can generate code for this table number.")
97086>>>>>                Move True to bFilelistError
97087>>>>>                Function_Return False
97088>>>>>            End
97088>>>>>>
97088>>>>>        End
97088>>>>>>
97088>>>>>
97088>>>>>        If (bCodeGenerateMode = False) Begin
97090>>>>>            If (APITableCompare.bExistsTo = False) Begin
97092>>>>>                // Then we might want to create this table
97092>>>>>                Function_Return False
97093>>>>>            End
97093>>>>>>
97093>>>>>
97093>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsAliasFrom = APITableCompare.APITableNameInfoCompare.bIsAliasTo) to bIsSame
97094>>>>>            If (bIsSame = False) Begin
97096>>>>>                Function_Return False
97097>>>>>            End 
97097>>>>>>
97097>>>>>    
97097>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSQLFrom = APITableCompare.APITableNameInfoCompare.bIsSQLTo) to bIsSame
97098>>>>>            If (bIsSame = False) Begin
97100>>>>>                Function_Return False
97101>>>>>            End 
97101>>>>>>
97101>>>>>    
97101>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSystemFileFrom = APITableCompare.APITableNameInfoCompare.bIsSystemFileTo) to bIsSame
97102>>>>>            If (bIsSame = False) Begin
97104>>>>>                Function_Return False
97105>>>>>            End 
97105>>>>>>
97105>>>>>
97105>>>>>            // Check table names et al.
97105>>>>>            Get UtilTableInfoCompare CompareTableBooleans.bCompareFilelistUppercase APITableCompare.APITableNameInfoCompare to bIsSame
97106>>>>>            If (bIsSame = False) Begin
97108>>>>>                Function_Return False
97109>>>>>            End
97109>>>>>>
97109>>>>>        End
97109>>>>>>
97109>>>>>
97109>>>>>        // Check Columns:
97109>>>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo APITableCompare.aAPIColumnsCompare CompareTableBooleans.bCompareDate_DateTime to bIsSame
97110>>>>>        If (bIsSame = False) Begin
97112>>>>>            Function_Return False
97113>>>>>        End
97113>>>>>>
97113>>>>>
97113>>>>>        // ...then check Indexes:
97113>>>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo APITableCompare.aAPIIndexesCompare CompareTableBooleans.bCompareIndexUppercase CompareTableBooleans.bCompareIndexAscending to bIsSame
97114>>>>>        If (bIsSame = False) Begin
97116>>>>>            Function_Return False
97117>>>>>        End
97117>>>>>>
97117>>>>>
97117>>>>>        // ...and finally Relationships:
97117>>>>>        Get UtilRelationsCompare hTable APITableCompare.aAPIRelationsCompare to bIsSame
97118>>>>>
97118>>>>>        Function_Return (bIsSame = True)
97119>>>>>    End_Function
97120>>>>>
97120>>>>>    // To fill a complete Table array structure (tAPITable[]) with data.
97120>>>>>    // The data + filelist.cfg path, login et al must have been setup properly first.
97120>>>>>    // Pass a True as first parameter if the ghoStatusPanel is active and progress info should be shown.
97120>>>>>    // Pass a second True if this is a comparison and the text should either reflect "FROM" or "TO" database.
97120>>>>>    Function UtilTablesStructArrayFill Boolean bStatusPanel Boolean bCompareUtil Boolean bFromTables Returns tAPITable[]
97122>>>>>        tAPITableNameInfo ApiTableNameInfo
97122>>>>>        tAPITableNameInfo ApiTableNameInfo
97122>>>>>        tAPITable[]     aApiTables aApiTablesEmpty
97122>>>>>        tAPITable[]     aApiTables aApiTablesEmpty
97124>>>>>        tAPIColumn[]    aApiColumns
97124>>>>>        tAPIColumn[]    aApiColumns
97125>>>>>        tAPIIndex[]     aApiIndexes
97125>>>>>        tAPIIndex[]     aApiIndexes
97126>>>>>        tAPIRelation[]  aApiRelations
97126>>>>>        tAPIRelation[]  aApiRelations
97127>>>>>        Handle hTable
97127>>>>>        Integer iCount iPos
97127>>>>>        Boolean bIsAlias bUserCancel bIsSQL bIsOpen
97127>>>>>        String sLogicalName sMessageText
97127>>>>>
97127>>>>>        Move 0 to hTable
97128>>>>>        If (bFromTables = True) Begin
97130>>>>>            Move "Reading 'FROM' Table Structure:" to sMessageText
97131>>>>>            If (bCompareUtil = True) Begin
97133>>>>>                Move (sMessageText * "(1 of 3)") to sMessageText
97134>>>>>            End
97134>>>>>>
97134>>>>>        End
97134>>>>>>
97134>>>>>        Else Begin
97135>>>>>            Move "Reading 'TO' Table Structure:" to sMessageText
97136>>>>>            If (bCompareUtil = True) Begin
97138>>>>>                Move (sMessageText * "(2 of 3)") to sMessageText
97139>>>>>            End
97139>>>>>>
97139>>>>>        End
97139>>>>>>
97139>>>>>        Set Message_Text of ghoStatusPanel to sMessageText
97140>>>>>
97140>>>>>        Get UtilFilelistNoOfTables to iCount
97141>>>>>        Set piMaximum of ghoProgressBar to iCount
97142>>>>>        Move 0 to iCount
97143>>>>>
97143>>>>>        Repeat
97143>>>>>>
97143>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
97146>>>>>            If (hTable > 0 and hTable <> 50) Begin
97148>>>>>            
97148>>>>>                Open hTable
97150>>>>>                Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
97153>>>>>                If (bIsOpen = False) Begin
97155>>>>>                    Move True to aApiTablesEmpty[0].bError
97156>>>>>                    Move hTable to aApiTablesEmpty[0].ApiTableInfo.iTableNumber
97157>>>>>                    Function_Return aApiTablesEmpty
97158>>>>>                End
97158>>>>>>
97158>>>>>
97158>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName 
97161>>>>>                Set piPosition of ghoProgressBar to iCount
97162>>>>>                Send DoAdvance of ghoProgressBarOverall
97163>>>>>                Set Action_Text of ghoStatusPanel to ("Number:" * String(hTable) * String(sLogicalName))
97164>>>>>
97164>>>>>                Get UtilTableStructFill hTable bFromTables to aApiTables[iCount]
97165>>>>>//                // Table Name Info
97165>>>>>//                Get UtilTableNameInfoStructFill hTable to ApiTableNameInfo
97165>>>>>//                
97165>>>>>//                // Fill columns
97165>>>>>//                Get UtilColumnsStructFill hTable to aApiColumns
97165>>>>>//                If (aApiColumns[0].bCancel = True) Begin
97165>>>>>//                    Move True to aApiTablesEmpty[0].bError
97165>>>>>//                    Move hTable to aApiTablesEmpty[0].ApiTableInfo.iTableNumber
97165>>>>>//                    Function_Return aApiTablesEmpty
97165>>>>>//                End
97165>>>>>//
97165>>>>>//                // Fill indexes
97165>>>>>//                Get UtilIndexesStructFill hTable to aApiIndexes
97165>>>>>//                If (aApiIndexes[0].bCancel = True) Begin
97165>>>>>//                    Move True to aApiTablesEmpty[0].bError
97165>>>>>//                    Move hTable to aApiTablesEmpty[0].ApiTableInfo.iTableNumber
97165>>>>>//                    Function_Return aApiTablesEmpty
97165>>>>>//                End
97165>>>>>//
97165>>>>>//                // Fill relationships
97165>>>>>//                Get UtilRelationsStructFill hTable to aApiRelations
97165>>>>>//                If (aApiRelations[0].bCancel = True) Begin
97165>>>>>//                    Move True to aApiTablesEmpty[0].bError
97165>>>>>//                    Move hTable to aApiTablesEmpty[0].ApiTableInfo.iTableNumber
97165>>>>>//                    Function_Return aApiTablesEmpty
97165>>>>>//                End
97165>>>>>
97165>>>>>                Close hTable DF_PERMANENT
97167>>>>>
97167>>>>>//                Move hTable             to aApiTables[iCount].hTable
97167>>>>>//                Move bFromTables        to aApiTables[iCount].bFromTable
97167>>>>>//                Move (not(bFromTables)) to aApiTables[iCount].bToTable   
97167>>>>>//                Move ApiTableNameInfo   to aApiTables[iCount].ApiTableInfo
97167>>>>>//                Move aApiColumns        to aApiTables[iCount].aApiColumns
97167>>>>>//                Move aApiIndexes        to aApiTables[iCount].aApiIndexes
97167>>>>>//                Move aApiRelations      to aApiTables[iCount].aApiRelations
97167>>>>>                Increment iCount
97168>>>>>            End
97168>>>>>>
97168>>>>>
97168>>>>>            If (bStatusPanel = True) Begin
97170>>>>>                Get Check_StatusPanel of ghoStatusPanel to bUserCancel
97171>>>>>                If (bUserCancel = True) Begin
97173>>>>>                    Move True to aApiTablesEmpty[0].bCancel
97174>>>>>                    Function_Return aApiTablesEmpty
97175>>>>>                End
97175>>>>>>
97175>>>>>            End
97175>>>>>>
97175>>>>>
97175>>>>>        Until (hTable = 0)
97177>>>>>
97177>>>>>        Function_Return aApiTables
97178>>>>>    End_Function
97179>>>>>    
97179>>>>>    // Returns a 'single' table APITable struct.
97179>>>>>    Function UtilTableStructFill Handle hTable Boolean bFromTables Returns tAPITable
97181>>>>>        tAPITableNameInfo ApiTableNameInfo
97181>>>>>        tAPITableNameInfo ApiTableNameInfo
97181>>>>>        tAPITable         ApiTable ApiTableEmpty
97181>>>>>        tAPITable         ApiTable ApiTableEmpty
97181>>>>>        tAPIColumn[]     aApiColumns
97181>>>>>        tAPIColumn[]     aApiColumns
97182>>>>>        tAPIIndex[]      aApiIndexes
97182>>>>>        tAPIIndex[]      aApiIndexes
97183>>>>>        tAPIRelation[]   aApiRelations
97183>>>>>        tAPIRelation[]   aApiRelations
97184>>>>>        Integer iCount iPos
97184>>>>>        Boolean bIsAlias bUserCancel bIsSQL bIsOpen
97184>>>>>        String sLogicalName sRootName sDisplayName sTableName sDriverID sMessageText
97184>>>>>
97184>>>>>        Open hTable
97186>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
97189>>>>>        If (bIsOpen = False) Begin
97191>>>>>            Move True to ApiTableEmpty.bError
97192>>>>>            Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
97193>>>>>            Function_Return ApiTableEmpty
97194>>>>>        End
97194>>>>>>
97194>>>>>        
97194>>>>>        // Fill Table Name Info
97194>>>>>        Get UtilTableNameInfoStructFill hTable to ApiTableNameInfo
97195>>>>>                
97195>>>>>        // Fill columns
97195>>>>>        Get UtilColumnsStructFill hTable to aApiColumns
97196>>>>>        If (SizeOfArray(aApiColumns)) Begin
97198>>>>>            If (aApiColumns[0].bCancel = True) Begin
97200>>>>>                Move True to ApiTableEmpty.bError
97201>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
97202>>>>>                Function_Return ApiTableEmpty
97203>>>>>            End
97203>>>>>>
97203>>>>>        End
97203>>>>>>
97203>>>>>        
97203>>>>>        // Fill indexes
97203>>>>>        Get UtilIndexesStructFill hTable to aApiIndexes
97204>>>>>        If (SizeOfArray(aApiIndexes)) Begin
97206>>>>>            If (aApiIndexes[0].bCancel = True) Begin
97208>>>>>                Move True to ApiTableEmpty.bError
97209>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
97210>>>>>                Function_Return ApiTableEmpty
97211>>>>>            End
97211>>>>>>
97211>>>>>        End
97211>>>>>>
97211>>>>>        
97211>>>>>
97211>>>>>        // Fill relationships
97211>>>>>        Get UtilRelationsStructFill hTable to aApiRelations
97212>>>>>        If (SizeOfArray(aApiRelations)) Begin
97214>>>>>            If (aApiRelations[0].bCancel = True) Begin
97216>>>>>                Move True to ApiTableEmpty.bError
97217>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
97218>>>>>                Function_Return ApiTableEmpty
97219>>>>>            End
97219>>>>>>
97219>>>>>        End
97219>>>>>>
97219>>>>>        
97219>>>>>        Move hTable             to ApiTable.hTable
97220>>>>>        Move bFromTables        to ApiTable.bFromTable
97221>>>>>        Move (not(bFromTables)) to ApiTable.bToTable   
97222>>>>>
97222>>>>>        Move ApiTableNameInfo   to ApiTable.ApiTableInfo
97223>>>>>        Move aApiColumns        to ApiTable.aApiColumns
97224>>>>>        Move aApiIndexes        to ApiTable.aApiIndexes
97225>>>>>        Move aApiRelations      to ApiTable.aApiRelations
97226>>>>>
97226>>>>>        Function_Return ApiTable
97227>>>>>    End_Function
97228>>>>>
97228>>>>>
97228>>>>>    Function UtilTableNameInfoStructFill Handle hTable Returns tAPITableNameInfo
97230>>>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty                                      
97230>>>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty                                      
97230>>>>>        Boolean bIsOpen
97230>>>>>        
97230>>>>>        Open hTable
97232>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
97235>>>>>        If (bIsOpen = False) Begin
97237>>>>>            Move True   to APITableNameInfoEmpty.bError
97238>>>>>            Move hTable to APITableNameInfoEmpty.iTableNumber
97239>>>>>            Function_Return APITableNameInfoEmpty
97240>>>>>        End
97240>>>>>>
97240>>>>>
97240>>>>>        Move hTable                                  to APITableNameInfo.iTableNumber
97241>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to APITableNameInfo.sRootName
97244>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to APITableNameInfo.sLogicalName
97247>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to APITableNameInfo.sDisplayName
97250>>>>>        Get_Attribute DF_FILE_DRIVER       of hTable to APITableNameInfo.sDriverID
97253>>>>>        
97253>>>>>        Get UtilTableIsAlias                  hTable to APITableNameInfo.bIsAlias
97254>>>>>        Get UtilTableIsSQL                    hTable to APITableNameInfo.bIsSQL
97255>>>>>
97255>>>>>        Close hTable
97256>>>>>
97256>>>>>        Function_Return APITableNameInfo
97257>>>>>    End_Function 
97258>>>>>    
97258>>>>>    Function UtilFindTableArrayItem tAPITable[] ByRef aTableStructure String sLogicalTableName Returns Integer
97260>>>>>        Integer iSize iCount iTable iItem
97260>>>>>        tAPITableNameInfo ApiTableNameInfo
97260>>>>>        tAPITableNameInfo ApiTableNameInfo
97260>>>>>
97260>>>>>        Move -1 to iItem
97261>>>>>        Move (SizeOfArray(aTableStructure)) to iSize
97262>>>>>        Decrement iSize
97263>>>>>        for iCount from 0 to iSize
97269>>>>>>
97269>>>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
97270>>>>>            If (Uppercase(ApiTableNameInfo.sLogicalName) = Uppercase(sLogicalTableName)) Begin
97272>>>>>                Move iCount to iItem
97273>>>>>                Move iSize  to iCount // We're done.
97274>>>>>            End
97274>>>>>>
97274>>>>>        Loop
97275>>>>>>
97275>>>>>
97275>>>>>        Function_Return iItem
97276>>>>>    End_Function
97277>>>>>
97277>>>>>    Function UtilTableArrayCompare tAPITable APITableFrom tAPITable APITableTo Returns Integer
97279>>>>>        If (APITableFrom.hTable  > APITableTo.hTable) ;            Function_Return (GT)
97282>>>>>        If (APITableFrom.hTable  < APITableTo.hTable) ;            Function_Return (LT)
97285>>>>>
97285>>>>>        If (APITableFrom.bFromTable = True)  ;            Function_Return (LT)
97288>>>>>        If (APITableFrom.bFromTable = False) ;            Function_Return (GT)
97291>>>>>
97291>>>>>        Function_Return (EQ)
97292>>>>>    End_Function
97293>>>>>
97293>>>>>    Function UtilTableCombineFromAndToArrays tAPITable[] aAPITableFrom tAPITable[] aAPITableTo Returns tAPITableCompare[]
97295>>>>>        Integer iCount iSize iSizeFrom iSizeTo iItemFrom iItemTo iItem
97295>>>>>        Handle hTable
97295>>>>>        tAPITable[] aAPITableFromAndTo aAPITableEmpty
97295>>>>>        tAPITable[] aAPITableFromAndTo aAPITableEmpty
97297>>>>>        tAPITable   APITableFrom APITableTo
97297>>>>>        tAPITable   APITableFrom APITableTo
97297>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
97297>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
97297>>>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
97297>>>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
97298>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
97298>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
97299>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
97299>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
97300>>>>>        tAPIRelationCompare[] aAPIRelationCompare
97300>>>>>        tAPIRelationCompare[] aAPIRelationCompare
97301>>>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
97301>>>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
97301>>>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
97301>>>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
97304>>>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
97304>>>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
97307>>>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
97307>>>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
97310>>>>>
97310>>>>>        Move (SizeOfArray(aAPITableFrom)) to iSizeFrom
97311>>>>>        Move (SizeOfArray(aAPITableTo))   to iSizeTo
97312>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
97314>>>>>            Function_Return aAPITableCompare
97315>>>>>        End
97315>>>>>>
97315>>>>>
97315>>>>>        Move (AppendArray(aAPITableFrom, aAPITableTo)) to aAPITableFromAndTo
97316>>>>>        Move (SortArray(aAPITableFromAndTo, Self, RefFunc(UtilTableArrayCompare))) to aAPITableFromAndTo
97317>>>>>
97317>>>>>        Move 0 to iItem
97318>>>>>        Move (SizeOfArray(aAPITableFromAndTo)) to iSize
97319>>>>>        Decrement iSize
97320>>>>>        for iCount from 0 to iSize
97326>>>>>>
97326>>>>>
97326>>>>>            Move iCount to iItemFrom
97327>>>>>            Move iCount to iItemTo
97328>>>>>            Move aAPITableEmpty to APITableFrom
97329>>>>>            Move aAPITableEmpty to APITableTo
97330>>>>>
97330>>>>>            If (aAPITableFromAndTo[iCount].bFromTable = True) Begin
97332>>>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
97333>>>>>            End
97333>>>>>>
97333>>>>>            If (aAPITableFromAndTo[iCount].bToTable = True) Begin
97335>>>>>                Move aAPITableFromAndTo[iCount]     to APITableTo
97336>>>>>            End
97336>>>>>>
97336>>>>>            If (aAPITableFromAndTo[iCount].hTable = aAPITableFromAndTo[iCount + 1].hTable) Begin
97338>>>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
97339>>>>>                Move (iCount + 1) to iItemTo
97340>>>>>                Move aAPITableFromAndTo[iItemTo]    to APITableTo
97341>>>>>            End
97341>>>>>>
97341>>>>>
97341>>>>>            Move APITableFrom.ApiTableInfo  to ApiTableInfoFrom
97342>>>>>            Move APITableFrom.aApiColumns   to aApiColumnsFrom
97343>>>>>            Move APITableFrom.aApiIndexes   to aApiIndexFrom
97344>>>>>            Move APITableFrom.aApiRelations to aApiRelationFrom
97345>>>>>
97345>>>>>            Move APITableTo.ApiTableInfo    to ApiTableInfoTo
97346>>>>>            Move APITableTo.aApiColumns     to aApiColumnsTo
97347>>>>>            Move APITableTo.aApiIndexes     to aApiIndexTo
97348>>>>>            Move APITableTo.aApiRelations   to aApiRelationTo
97349>>>>>
97349>>>>>            Move aAPITableFromAndTo[iCount].hTable to hTable
97350>>>>>
97350>>>>>            If (hTable > 0) Begin
97352>>>>>
97352>>>>>                // Table info:
97352>>>>>                Get UtilTableINFOCombineFromAndToArrays ApiTableInfoFrom ApiTableInfoTo to APITableNameInfoCompare
97353>>>>>                Move APITableNameInfoCompare.iTableNumber                               to aAPITableCompare[iItem].hTable
97354>>>>>                Move APITableNameInfoCompare.bExistsFrom                                to aAPITableCompare[iItem].bExistsFrom
97355>>>>>                Move APITableNameInfoCompare.bExistsTo                                  to aAPITableCompare[iItem].bExistsTo
97356>>>>>                Move APITableNameInfoCompare                                            to aAPITableCompare[iItem].APITableNameInfoCompare
97357>>>>>
97357>>>>>                // Column info:
97357>>>>>                Get UtilColumnCombineFromAndToArrays aApiColumnsFrom aApiColumnsTo      to aAPIColumnCompare
97358>>>>>                Move aAPIColumnCompare                                                  to aAPITableCompare[iItem].aAPIColumnsCompare
97359>>>>>
97359>>>>>                // Index info:
97359>>>>>                Get UtilIndexCombineFromAndToArrays aApiIndexFrom aApiIndexTo           to aAPIIndexCompare
97360>>>>>                Move aAPIIndexCompare                                                   to aAPITableCompare[iItem].aAPIIndexesCompare
97361>>>>>
97361>>>>>                // Relation info:
97361>>>>>                Get UtilRelationCombineFromAndToArrays aApiRelationFrom aApiRelationTo  to aAPIRelationCompare
97362>>>>>                Move aAPIRelationCompare                                                to aAPITableCompare[iItem].aAPIRelationsCompare
97363>>>>>
97363>>>>>                Move False                                                              to aAPITableCompare[iItem].bShouldChange
97364>>>>>                Move False                                                              to aAPITableCompare[iItem].bCancel
97365>>>>>                Move False                                                              to aAPITableCompare[iItem].bError
97366>>>>>                If (iItemTo > iItemFrom) Begin
97368>>>>>                    Increment iCount
97369>>>>>                End
97369>>>>>>
97369>>>>>                Increment iItem
97370>>>>>            End
97370>>>>>>
97370>>>>>
97370>>>>>        Loop
97371>>>>>>
97371>>>>>
97371>>>>>        Function_Return aAPITableCompare
97372>>>>>    End_Function
97373>>>>>
97373>>>>>    Function UtilTableInfoCombineFromAndToArrays tAPITableNameInfo APITableNameInfoFrom tAPITableNameInfo APITableNameInfoTo Returns tAPITableNameInfoCompare
97375>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
97375>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
97375>>>>>
97375>>>>>        // FROM database info:
97375>>>>>        If (APITableNameInfoFrom.iTableNumber > 0) Begin
97377>>>>>            Move APITableNameInfoFrom.iTableNumber  to APITableNameInfoCompare.iTableNumber
97378>>>>>            Move APITableNameInfoFrom.sRootName     to APITableNameInfoCompare.sRootNameFrom
97379>>>>>            Move APITableNameInfoFrom.sLogicalName  to APITableNameInfoCompare.sLogicalNameFrom
97380>>>>>            Move APITableNameInfoFrom.sDisplayName  to APITableNameInfoCompare.sDisplayNameFrom
97381>>>>>            Move APITableNameInfoFrom.sDriverID     to APITableNameInfoCompare.sDriverIDFrom
97382>>>>>            Move APITableNameInfoFrom.bIsAlias      to APITableNameInfoCompare.bIsAliasFrom
97383>>>>>            Move APITableNameInfoFrom.bIsSQL        to APITableNameInfoCompare.bIsSQLFrom
97384>>>>>            Move True                               to APITableNameInfoCompare.bExistsFrom
97385>>>>>        End
97385>>>>>>
97385>>>>>
97385>>>>>        // TO database info:
97385>>>>>        If (APITableNameInfoTo.iTableNumber > 0) Begin
97387>>>>>            Move APITableNameInfoTo.iTableNumber    to APITableNameInfoCompare.iTableNumber
97388>>>>>            Move APITableNameInfoTo.sRootName       to APITableNameInfoCompare.sRootNameTo
97389>>>>>            Move APITableNameInfoTo.sLogicalName    to APITableNameInfoCompare.sLogicalNameTo
97390>>>>>            Move APITableNameInfoTo.sDisplayName    to APITableNameInfoCompare.sDisplayNameTo
97391>>>>>            Move APITableNameInfoTo.sDriverID       to APITableNameInfoCompare.sDriverIDTo
97392>>>>>            Move APITableNameInfoTo.bIsAlias        to APITableNameInfoCompare.bIsAliasTo
97393>>>>>            Move APITableNameInfoTo.bIsSQL          to APITableNameInfoCompare.bIsSQLTo
97394>>>>>            Move True                               to APITableNameInfoCompare.bExistsTo
97395>>>>>        End
97395>>>>>>
97395>>>>>
97395>>>>>        Function_Return APITableNameInfoCompare
97396>>>>>    End_Function
97397>>>>>
97397>>>>>    // Note:
97397>>>>>    // The DF_FILE_TABLE_NAME attribute holds the name of the table at the back end. Depending on the back end, table
97397>>>>>    // names may be case sensitive, contain spaces or other special characters. This attribute is used to determine a table's
97397>>>>>    // back end name when using Embedded SQL. Since Embedded SQL works on the back end directly, the back end's name must be used.
97397>>>>>    // In most cases the back end name will be the same as the table name used in DataFlex.
97397>>>>>    // To do the opposite; To get the file handle from a table name string use the UtilTableNameToHandle function.
97397>>>>>    Function UtilTableHandleToString Handle hTable Returns String
97399>>>>>        String sTableName
97399>>>>>        Boolean bOpen bExists bOK
97399>>>>>
97399>>>>>        Get UtilTableNumberIsInUse hTable to bExists
97400>>>>>        If (bExists = False) Begin
97402>>>>>            Function_Return ""
97403>>>>>        End
97403>>>>>>
97403>>>>>
97403>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
97404>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
97407>>>>>        If (bOpen = False) Begin
97409>>>>>            Get AutoConnectionIDLogin to bOK
97410>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
97411>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
97412>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
97413>>>>>            Open hTable
97415>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
97416>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
97417>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
97418>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
97421>>>>>        End
97421>>>>>>
97421>>>>>        If (bOpen = True) Begin
97423>>>>>            Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
97424>>>>>            Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName
97427>>>>>            // If blank it is an embedded table:
97427>>>>>            If (sTableName = "") Begin
97429>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
97432>>>>>                Move 0 to LastErr
97433>>>>>                Move False to Err
97434>>>>>            End
97434>>>>>>
97434>>>>>            Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
97435>>>>>        End
97435>>>>>>
97435>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
97436>>>>>
97436>>>>>        Function_Return sTableName
97437>>>>>    End_Function
97438>>>>>
97438>>>>>    // Returns the filenumber for the passed Table name from Filelist.cfg.
97438>>>>>    // Returns 0 if unsuccessful.
97438>>>>>    // To do the opposite; To get the string value from a table handle string use the UtilTableHandleToString function.
97438>>>>>    Function UtilTableNameToHandle String sTableName Returns Integer
97440>>>>>        String sValue sPrefixTableName sDriverID
97440>>>>>        Handle hTable hRetval
97440>>>>>
97440>>>>>        Get psDriverID to sDriverID
97441>>>>>        If (sDriverID <> DATAFLEX_ID and not(sTableName contains ":")) Begin
97443>>>>>            Move (sDriverID + ":" + sTableName) to sPrefixTableName
97444>>>>>        End
97444>>>>>>
97444>>>>>        Move 0 to hTable
97445>>>>>        Move 0 to hRetval
97446>>>>>        Repeat
97446>>>>>>
97446>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
97449>>>>>            If (hTable <> 0) Begin
97451>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sValue
97454>>>>>                If (Uppercase(sValue) = Uppercase(sTableName) or Uppercase(sValue) = Uppercase(sPrefixTableName)) Begin
97456>>>>>                    Move hTable to hRetval
97457>>>>>                    Move 0 to hTable
97458>>>>>                End
97458>>>>>>
97458>>>>>            End
97458>>>>>>
97458>>>>>        Until (hTable = 0)
97460>>>>>
97460>>>>>        Function_Return hRetval
97461>>>>>    End_Function
97462>>>>>
97462>>>>>    // * Dummy function for the Studio's Code Explorer *
97462>>>>>    Function API_COLUMN_UTILITY_FUNCTIONS Returns Boolean
97464>>>>>        Function_Return False
97465>>>>>    End_Function
97466>>>>>
97466>>>>>    // Compare multiple columns. (For 'FROM' & 'TO' tables)
97466>>>>>    Function UtilColumnsCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare[] aAPIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
97468>>>>>        Boolean bIsSame
97468>>>>>        Integer iCount iSize iColumn
97468>>>>>
97468>>>>>        Move True to bIsSame
97469>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
97470>>>>>        Set piMaximum of ghoProgressBar  to iSize
97471>>>>>
97471>>>>>        Decrement iSize
97472>>>>>        for iCount from 0 to iSize
97478>>>>>>
97478>>>>>            Set piPosition of ghoProgressBar to iCount
97479>>>>>            Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare[iCount] bCompareDate_DataTime to bIsSame
97480>>>>>            If (bIsSame = False) Begin
97482>>>>>                Function_Return False
97483>>>>>            End
97483>>>>>>
97483>>>>>        Loop
97484>>>>>>
97484>>>>>
97484>>>>>        Function_Return (bIsSame = True)
97485>>>>>    End_Function
97486>>>>>
97486>>>>>    // Compares a single column (For 'FROM' & 'TO' tables)
97486>>>>>    Function UtilColumnCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare APIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
97488>>>>>        Integer iFromType iToType iDbType
97488>>>>>        tColumnType ColumnType 
97488>>>>>        tColumnType ColumnType 
97488>>>>>        Boolean bIsDateTypeFrom bIsDateTypeTo
97488>>>>>        
97488>>>>>        If (APIColumnCompare.bCancelFrom = True or APIColumnCompare.bCancelTo = True) Begin
97490>>>>>            Function_Return False
97491>>>>>        End
97491>>>>>>
97491>>>>>        If (APIColumnCompare.bExistsFrom = False or APIColumnCompare.bExistsTo = False) Begin
97493>>>>>            Function_Return False
97494>>>>>        End
97494>>>>>>
97494>>>>>        If (Uppercase(APIColumnCompare.sFieldNameFrom) <> Uppercase(APIColumnCompare.sFieldNameTo)) Begin
97496>>>>>            Function_Return False
97497>>>>>        End  
97497>>>>>>
97497>>>>>        If (APIColumnCompare.bAllowNULLFrom <> APIColumnCompare.bAllowNULLTo) Begin
97499>>>>>            Function_Return False
97500>>>>>        End                      
97500>>>>>>
97500>>>>>        If (APIColumnCompare.sDefaultValueFrom <> APIColumnCompare.sDefaultValueTo) Begin
97502>>>>>            Function_Return False
97503>>>>>        End                      
97503>>>>>>
97503>>>>>
97503>>>>>        Get piDbType                       to iDbType
97504>>>>>        Move APIColumnCompare.iTypeFrom    to iFromType
97505>>>>>        Move APIColumnCompare.iTypeTo      to iToType 
97506>>>>>
97506>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
97506>>>>>        // data types between Embedded and SQL.
97506>>>>>        If (bIsSQLFrom = True and bIsSQLTo = False) Begin
97508>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iFromType APIColumnCompare.iLengthFrom to iFromType
97509>>>>>        End
97509>>>>>>
97509>>>>>        If (bIsSQLFrom = False and bIsSQLTo = True) Begin
97511>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iToType APIColumnCompare.iLengthTo to iToType
97512>>>>>        End
97512>>>>>>
97512>>>>>
97512>>>>>        Get UtilColumnIsDateType iFromType bIsSQLFrom to bIsDateTypeFrom
97513>>>>>        Get UtilColumnIsDateType iToType   bIsSQLTo   to bIsDateTypeTo
97514>>>>>
97514>>>>>        // Make Date and DateTime comparison?
97514>>>>>        If (bCompareDate_DataTime = True) Begin
97516>>>>>            If (iFromType <> iToType) Begin
97518>>>>>                Function_Return False
97519>>>>>            End
97519>>>>>>
97519>>>>>        End
97519>>>>>>
97519>>>>>
97519>>>>>        // This is when not checking for Date/DateTime differences but all other other field types...
97519>>>>>        If (bCompareDate_DataTime = False and bIsDateTypeFrom = False) Begin
97521>>>>>            If (iFromType <> iToType) Begin
97523>>>>>                Function_Return False
97524>>>>>            End
97524>>>>>>
97524>>>>>        End
97524>>>>>>
97524>>>>>
97524>>>>>        // Only if the field is not a Date type (any of them) we compare length & precision.
97524>>>>>        If (bIsDateTypeFrom = False) Begin
97526>>>>>            If (APIColumnCompare.iLengthFrom <> APIColumnCompare.iLengthTo) Begin
97528>>>>>                Function_Return False
97529>>>>>            End
97529>>>>>>
97529>>>>>            If (APIColumnCompare.iPrecisionFrom <> APIColumnCompare.iPrecisionTo) Begin
97531>>>>>                Function_Return False
97532>>>>>            End
97532>>>>>>
97532>>>>>        End
97532>>>>>>
97532>>>>>
97532>>>>>        If (APIColumnCompare.iOptionsFrom <> APIColumnCompare.iOptionsTo) Begin
97534>>>>>            Function_Return False
97535>>>>>        End
97535>>>>>>
97535>>>>>
97535>>>>>        Function_Return True
97536>>>>>    End_Function
97537>>>>>
97537>>>>>    Function UtilColumnsStructFill Handle hTable Returns tAPIColumn[]
97539>>>>>        Integer iNumColumns iColumn iCount iOptions iDbType iType iLength iPrecision iCheckFieldNumber
97539>>>>>        Boolean bIdentityKey bDawSqlDriver bSqlDriver bIsOpen bExists bIsSqlTable bUserCancel bState
97539>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
97539>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
97541>>>>>        String sDriverID sFieldName sRootName sLogicalName sValue
97541>>>>>
97541>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
97542>>>>>        Get piDbType to iDbType
97543>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
97546>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
97549>>>>>
97549>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
97552>>>>>        If (bIsOpen = False) Begin
97554>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
97555>>>>>            Open hTable
97557>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
97558>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
97561>>>>>            If (bIsOpen = False) Begin
97563>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
97564>>>>>                Move True to APIColumnsEmpty[0].bError
97565>>>>>                Function_Return APIColumnsEmpty
97566>>>>>            End
97566>>>>>>
97566>>>>>        End
97566>>>>>>
97566>>>>>
97566>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
97569>>>>>        Get IsSQLDriver    sDriverID to bSqlDriver
97570>>>>>        Get IsDAWSQLDriver sDriverID to bDawSqlDriver
97571>>>>>
97571>>>>>        Get UtilTableIsSQLByRootName sRootName to bIsSqlTable
97572>>>>>        If (bIsSqlTable = True) Begin
97574>>>>>            Get UtilTableExists hTable to bExists
97575>>>>>            If (bExists = False) Begin
97577>>>>>                Move True to APIColumnsEmpty[0].bError
97578>>>>>                Function_Return APIColumnsEmpty
97579>>>>>            End
97579>>>>>>
97579>>>>>        End
97579>>>>>>
97579>>>>>
97579>>>>>        Move 0 to iCount
97580>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
97583>>>>>        Set piMaximum of ghoProgressBar to iNumColumns
97584>>>>>
97584>>>>>        for iColumn from 1 to iNumColumns
97590>>>>>>
97590>>>>>            Move 0 to iOptions
97591>>>>>            Move False to bIdentityKey
97592>>>>>            Move False to Err
97593>>>>>            Move 0     to LastErr
97594>>>>>            Move bIsSqlTable to APIColumns[iCount].bIsSQLType
97595>>>>>            Set piPosition of ghoProgressBar to iColumn
97596>>>>>            If (bDawSqlDriver = True) Begin
97598>>>>>                Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
97599>>>>>                If (bIsSqlTable = True) Begin
97601>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iType
97604>>>>>                    Move iType                                                to APIColumns[iCount].iType
97605>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE_NAME of hTable iColumn to APIColumns[iCount].sType
97608>>>>>                    Get_Attribute DF_FIELD_NULL_ALLOWED     of hTable iColumn to APIColumns[iCount].bAllowNULL
97611>>>>>                    Get_Attribute DF_FIELD_DEFAULT_VALUE    of hTable iColumn to APIColumns[iCount].sDefaultValue 
97614>>>>>                End
97614>>>>>>
97614>>>>>                Else Begin
97615>>>>>                    Get_Attribute DF_FIELD_TYPE             of hTable iColumn to APIColumns[iCount].iType
97618>>>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
97619>>>>>                End
97619>>>>>>
97619>>>>>
97619>>>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
97619>>>>>                Get_Attribute DF_Field_Number of hTable iColumn to iCheckFieldNumber
97622>>>>>                Move (iCheckFieldNumber >= 0) to bExists
97623>>>>>                If (bExists = False) Begin
97625>>>>>                    Move 0 to APIColumns[iCount].iType
97626>>>>>                End
97626>>>>>>
97626>>>>>                If (bExists = True) Begin
97628>>>>>                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
97631>>>>>                End
97631>>>>>>
97631>>>>>                Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
97632>>>>>                If (bIdentityKey = True) Begin
97634>>>>>                    Move C_tAPIColumn_Identity to APIColumns[iCount].iOptions
97635>>>>>                End
97635>>>>>>
97635>>>>>            End
97635>>>>>>
97635>>>>>            Else Begin
97636>>>>>                Move False to Err
97637>>>>>                Move 0     to LastErr
97638>>>>>                If (bIsSqlTable = True) Begin
97640>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to APIColumns[iCount].iType
97643>>>>>                End
97643>>>>>>
97643>>>>>                Else Begin
97644>>>>>                    Get_Attribute DF_FIELD_TYPE        of hTable iColumn to APIColumns[iCount].iType
97647>>>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
97648>>>>>                End
97648>>>>>>
97648>>>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
97648>>>>>                Move (LastErr <> DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) to bExists
97649>>>>>                If (bExists = False) Begin
97651>>>>>                    Move 0 to APIColumns[iCount].iType
97652>>>>>                End
97652>>>>>>
97652>>>>>            End
97652>>>>>>
97652>>>>>
97652>>>>>            If (bExists = True) Begin
97654>>>>>                Move iColumn to APIColumns[iCount].iFieldNumber
97655>>>>>                Get_Attribute DF_FIELD_NAME        of hTable iColumn to APIColumns[iCount].sFieldName
97658>>>>>                // ToDo: Can't use native_size as it can get way to big and causes "out of memory" problems.
97658>>>>>//                If (bIsSqlTable = True) Begin
97658>>>>>//                    Get_Attribute DF_FIELD_NATIVE_SIZE of hTable iColumn to APIColumns[iCount].iLength
97658>>>>>//                    Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
97658>>>>>//                End
97658>>>>>                Get_Attribute DF_FIELD_LENGTH      of hTable iColumn to APIColumns[iCount].iLength
97661>>>>>                Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
97664>>>>>
97664>>>>>                // If the length was zero we might have an Overlap(!) field.
97664>>>>>                // We then need check the DF_FIELD_TYPE if it really is and reset data for this array item.
97664>>>>>                If (APIColumns[iCount].iLength = 0) Begin
97666>>>>>                    Get_Attribute DF_FIELD_TYPE    of hTable iColumn to iType
97669>>>>>                    If (iType = DF_OVERLAP) Begin
97671>>>>>                        Move 0 to APIColumns[iCount].iFieldNumber
97672>>>>>                        Move 0 to APIColumns[iCount].iLength
97673>>>>>                        Move 0 to APIColumns[iCount].iOptions
97674>>>>>                        Move 0 to APIColumns[iCount].iPrecision
97675>>>>>                        Move DF_OVERLAP to APIColumns[iCount].iType
97676>>>>>                        Move "" to APIColumns[iCount].sFieldName
97677>>>>>                        Decrement iCount
97678>>>>>                    End
97678>>>>>>
97678>>>>>                End
97678>>>>>>
97678>>>>>            End
97678>>>>>>
97678>>>>>            Get Check_StatusPanel of ghoStatusPanel to bUserCancel
97679>>>>>            If (bUserCancel = True) Begin
97681>>>>>                Move True to APIColumnsEmpty[0].bCancel
97682>>>>>                Function_Return APIColumnsEmpty
97683>>>>>            End
97683>>>>>>
97683>>>>>            Increment iCount
97684>>>>>        Loop
97685>>>>>>
97685>>>>>
97685>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
97686>>>>>        Function_Return APIColumns
97687>>>>>    End_Function
97688>>>>>
97688>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
97688>>>>>    // The combined data will be sorted on the first struct member: iIndexNumber
97688>>>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
97688>>>>>    // have "holes" in the series of index numbers.
97688>>>>>    Function UtilColumnCombineFromAndToArrays tAPIColumn[] APIColumnFrom tAPIColumn[] APIColumnTo Returns tAPIIndexCompare[]
97690>>>>>        tAPIColumnCompare[] aAPIColumnCompare
97690>>>>>        tAPIColumnCompare[] aAPIColumnCompare
97691>>>>>        tAPIColumnCompare   APIColumnCompare
97691>>>>>        tAPIColumnCompare   APIColumnCompare
97691>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem iColumnFrom iColumnTo
97691>>>>>
97691>>>>>        Move (SizeOfArray(APIColumnFrom)) to iSizeFrom
97692>>>>>        Decrement iSizeFrom
97693>>>>>        for iCount from 0 to iSizeFrom
97699>>>>>>
97699>>>>>            Move APIColumnFrom[iCount].iFieldNumber     to aAPIColumnCompare[iCount].iFieldNumber
97700>>>>>            Move APIColumnFrom[iCount].sFieldName       to aAPIColumnCompare[iCount].sFieldNameFrom
97701>>>>>            Move APIColumnFrom[iCount].iType            to aAPIColumnCompare[iCount].iTypeFrom
97702>>>>>            Move APIColumnFrom[iCount].sType            to aAPIColumnCompare[iCount].sTypeFrom
97703>>>>>            Move APIColumnFrom[iCount].iLength          to aAPIColumnCompare[iCount].iLengthFrom
97704>>>>>            Move APIColumnFrom[iCount].iPrecision       to aAPIColumnCompare[iCount].iPrecisionFrom
97705>>>>>            Move APIColumnFrom[iCount].iOptions         to aAPIColumnCompare[iCount].iOptionsFrom
97706>>>>>            Move APIColumnFrom[iCount].bIsSQLType       to aAPIColumnCompare[iCount].bIsSQLTypeFrom  
97707>>>>>            Move APIColumnFrom[iCount].bAllowNULL       to aAPIColumnCompare[iCount].bAllowNULLFrom
97708>>>>>            Move APIColumnFrom[iCount].sDefaultValue    to aAPIColumnCompare[iCount].sDefaultValueFrom
97709>>>>>            Move APIColumnFrom[iCount].bShouldChange    to aAPIColumnCompare[iCount].bShouldChangeFrom
97710>>>>>            Move APIColumnFrom[iCount].bCancel          to aAPIColumnCompare[iCount].bCancelFrom
97711>>>>>            Move APIColumnFrom[iCount].bError           to aAPIColumnCompare[iCount].bErrorFrom
97712>>>>>            Move True                                   to aAPIColumnCompare[iCount].bExistsFrom
97713>>>>>        Loop
97714>>>>>>
97714>>>>>
97714>>>>>        Move (SizeOfArray(APIColumnTo)) to iSizeTo
97715>>>>>        Decrement iSizeTo
97716>>>>>        for iCount from 0 to iSizeTo
97722>>>>>>
97722>>>>>            Move APIColumnTo[iCount].iFieldNumber       to APIColumnCompare.iFieldNumber
97723>>>>>            // Search if the field number already exists in the array; else add it.
97723>>>>>            Move (SearchArray(APIColumnCompare, aAPIColumnCompare)) to iItem
97724>>>>>            If (iItem = -1) Begin
97726>>>>>                Move (SizeOfArray(aAPIColumnCompare))   to iItem
97727>>>>>            End
97727>>>>>>
97727>>>>>
97727>>>>>            Move APIColumnCompare.iFieldNumber          to aAPIColumnCompare[iItem].iFieldNumber
97728>>>>>            Move APIColumnTo[iCount].iFieldNumber       to aAPIColumnCompare[iItem].iFieldNumberTo
97729>>>>>            Move APIColumnTo[iCount].sFieldName         to aAPIColumnCompare[iItem].sFieldNameTo
97730>>>>>            Move APIColumnTo[iCount].iType              to aAPIColumnCompare[iItem].iTypeTo
97731>>>>>            Move APIColumnTo[iCount].sType              to aAPIColumnCompare[iItem].sTypeTo
97732>>>>>            Move APIColumnTo[iCount].iLength            to aAPIColumnCompare[iItem].iLengthTo
97733>>>>>            Move APIColumnTo[iCount].iPrecision         to aAPIColumnCompare[iItem].iPrecisionTo
97734>>>>>            Move APIColumnTo[iCount].iOptions           to aAPIColumnCompare[iItem].iOptionsTo
97735>>>>>            Move APIColumnTo[iCount].bIsSQLType         to aAPIColumnCompare[iItem].bIsSQLTypeTo
97736>>>>>            Move APIColumnTo[iCount].bAllowNULL         to aAPIColumnCompare[iItem].bAllowNULLTo
97737>>>>>            Move APIColumnTo[iCount].sDefaultValue      to aAPIColumnCompare[iItem].sDefaultValueTo
97738>>>>>            Move APIColumnTo[iCount].bShouldChange      to aAPIColumnCompare[iItem].bShouldChangeTo
97739>>>>>            Move APIColumnTo[iCount].bCancel            to aAPIColumnCompare[iItem].bCancelTo
97740>>>>>            Move APIColumnTo[iCount].bError             to aAPIColumnCompare[iItem].bErrorTo
97741>>>>>            Move True                                   to aAPIColumnCompare[iItem].bExistsTo
97742>>>>>        Loop
97743>>>>>>
97743>>>>>
97743>>>>>        Move (SortArray(aAPIColumnCompare)) to aAPIColumnCompare
97744>>>>>
97744>>>>>        Function_Return aAPIColumnCompare
97745>>>>>    End_Function
97746>>>>>
97746>>>>>    // Checks if a field name exists in a table definition
97746>>>>>    // Returns True if it does
97746>>>>>    // Sample:
97746>>>>>    //   Get UtilColumnExists MyTable.File_Number "MyColumnName" to iExists
97746>>>>>    Function UtilColumnExists Handle hTable String sFieldName Returns Boolean
97748>>>>>        Integer iNumColumns iColumn
97748>>>>>        String sColumn
97748>>>>>        Boolean bExists bOK bOpen
97748>>>>>
97748>>>>>        Get AutoConnectionIDLogin to bOK
97749>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
97750>>>>>        Open hTable
97752>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
97753>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
97756>>>>>        If (bOpen = False) Begin
97758>>>>>            Function_Return False
97759>>>>>        End
97759>>>>>>
97759>>>>>
97759>>>>>        Move False to bExists
97760>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
97763>>>>>        for iColumn from 1 to iNumColumns
97769>>>>>>
97769>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
97772>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
97774>>>>>                Move iNumColumns to iColumn
97775>>>>>                Move True to bExists
97776>>>>>            End
97776>>>>>>
97776>>>>>        Loop
97777>>>>>>
97777>>>>>        Close hTable
97778>>>>>
97778>>>>>        Function_Return bExists
97779>>>>>    End_Function
97780>>>>>
97780>>>>>    // Returns the field/column number for the passed FieldName as an integer.
97780>>>>>    Function UtilColumnNameToColumnNumber Handle hTable String sFieldName Returns Integer
97782>>>>>        Integer iNumColumns iColumn iRetval
97782>>>>>        String sColumn
97782>>>>>        Boolean bOK bOpen
97782>>>>>
97782>>>>>        Get AutoConnectionIDLogin to bOK
97783>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
97784>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
97785>>>>>        Open hTable
97787>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
97788>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
97791>>>>>        If (bOpen = False) Begin
97793>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
97794>>>>>            Function_Return False
97795>>>>>        End
97795>>>>>>
97795>>>>>
97795>>>>>        Move 0 to iColumn
97796>>>>>        Move 0 to iRetval
97797>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
97800>>>>>        for iColumn from 1 to iNumColumns
97806>>>>>>
97806>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
97809>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
97811>>>>>                Move iColumn to iRetval
97812>>>>>                Move iNumColumns to iColumn
97813>>>>>            End
97813>>>>>>
97813>>>>>        Loop
97814>>>>>>
97814>>>>>        Close hTable
97815>>>>>
97815>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
97816>>>>>        Function_Return iRetval
97817>>>>>    End_Function
97818>>>>>
97818>>>>>    // To convert between a data type string name and its integer constant declaration. E.g."VarChar" -> SQL_VarChar
97818>>>>>    // The reciprocal function is UtilColumnTypeToInteger.
97818>>>>>    Function UtilColumnTypeToInteger String sDriverID Integer iDbType String sDataType Returns Integer
97820>>>>>        tColumnType RetvalType
97820>>>>>        tColumnType RetvalType
97820>>>>>
97820>>>>>        Get _UtilColumnType sDriverID iDbType 0 sDataType False to RetvalType
97821>>>>>        Function_Return RetvalType.iSQLType
97822>>>>>    End_Function
97823>>>>>
97823>>>>>    // To convert between an integer data type constant and its string value. E.g. SQL_VarChar -> "VarChar".
97823>>>>>    // The reciprocal function is UtilColumnTypeToString.
97823>>>>>    Function UtilColumnTypeToString String sDriverID Integer iDbType Integer iDataType Returns String
97825>>>>>        tColumnType RetvalType
97825>>>>>        tColumnType RetvalType
97825>>>>>
97825>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
97826>>>>>        Function_Return RetvalType.sSQLType
97827>>>>>    End_Function
97828>>>>>
97828>>>>>    Function UtilColumnTypePrecision String sDriverID Integer iDbType Integer iDataType Returns String
97830>>>>>        tColumnType RetvalType
97830>>>>>        tColumnType RetvalType
97830>>>>>
97830>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
97831>>>>>        Function_Return RetvalType.sPrecision
97832>>>>>    End_Function
97833>>>>>
97833>>>>>    Function UtilColumnTypeFixed String sDriverID Integer iDbType Integer iDataType Returns Boolean
97835>>>>>        tColumnType RetvalType
97835>>>>>        tColumnType RetvalType
97835>>>>>
97835>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
97836>>>>>        Function_Return RetvalType.bCanEditSize
97837>>>>>    End_Function
97838>>>>>
97838>>>>>    Function UtilColumnTypePrecisionSize String sDriverID Integer iDbType Integer iDataType Returns Integer
97840>>>>>        tColumnType RetvalType
97840>>>>>        tColumnType RetvalType
97840>>>>>        String sValue
97840>>>>>        Integer iRetval iPos
97840>>>>>
97840>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
97841>>>>>        Move RetvalType.sPrecision to sValue
97842>>>>>        Move (Pos(".", sValue)) to iPos
97843>>>>>        If (iPos <> 0) Begin
97845>>>>>            Move (Left(sValue, (iPos -1))) to iRetval
97846>>>>>        End
97846>>>>>>
97846>>>>>        Else Begin
97847>>>>>            Move sValue to iRetval
97848>>>>>        End
97848>>>>>>
97848>>>>>        Function_Return iRetval
97849>>>>>    End_Function
97850>>>>>
97850>>>>>    Function UtilColumnTypePrecisionDec String sDriverID Integer iDbType Integer iDataType Returns Integer
97852>>>>>        tColumnType RetvalType
97852>>>>>        tColumnType RetvalType
97852>>>>>        String sValue
97852>>>>>        Integer iRetval iPos
97852>>>>>
97852>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
97853>>>>>        Move RetvalType.sPrecision to sValue
97854>>>>>        Move (Pos(".", sValue)) to iPos
97855>>>>>        If (iPos = 0) Begin
97857>>>>>            Function_Return 0
97858>>>>>        End
97858>>>>>>
97858>>>>>        Move (Mid(sValue, 99, (iPos + 1))) to iRetval
97859>>>>>
97859>>>>>        Function_Return iRetval
97860>>>>>    End_Function
97861>>>>>
97861>>>>>    // * Dummy function for the Studio's Code Explorer *
97861>>>>>    Function API_INDEX_UTILITY_FUNCTIONS Returns Boolean
97863>>>>>        Function_Return False
97864>>>>>    End_Function
97865>>>>>
97865>>>>>    // Compares multiple indexes for a 'FROM' and a 'TO' table.
97865>>>>>    Function UtilIndexesCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare[] aAPIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
97867>>>>>        Boolean bIsSame
97867>>>>>        Integer iCount iSize
97867>>>>>
97867>>>>>        Move True to bIsSame
97868>>>>>        Move (SizeOfArray(aAPIIndexCompare)) to iSize
97869>>>>>        Decrement iSize
97870>>>>>        For iCount from 0 to iSize
97876>>>>>>
97876>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
97877>>>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
97878>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
97879>>>>>            If (bIsSame = False) Begin
97881>>>>>                Function_Return False
97882>>>>>            End
97882>>>>>>
97882>>>>>        Loop
97883>>>>>>
97883>>>>>
97883>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
97884>>>>>        Function_Return bIsSame
97885>>>>>    End_Function
97886>>>>>
97886>>>>>    // Compares a single index for a 'FROM' and a 'TO' table.
97886>>>>>    // ToDo: ReDo; remove table handles! And add bIsSQLtablefrom/to
97886>>>>>    Function UtilIndexCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare APIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
97888>>>>>        Boolean bIsSame
97888>>>>>        Integer iSegment
97888>>>>>
97888>>>>>        Move (APIIndexCompare.bExistsFrom = APIIndexCompare.bExistsTo) to bIsSame
97889>>>>>        If (bIsSame = False) Begin
97891>>>>>            Function_Return False
97892>>>>>        End
97892>>>>>>
97892>>>>>        Move (APIIndexCompare.iPrimaryIndexFrom = APIIndexCompare.iPrimaryIndexTo) to bIsSame
97893>>>>>        If (bIsSame = False) Begin
97895>>>>>            Function_Return False
97896>>>>>        End
97896>>>>>>
97896>>>>>
97896>>>>>        If (bIsSqlTableFrom = True and bIsSqlTableTo = True) Begin
97898>>>>>            // * We should probably not compare SQL index names?
97898>>>>>            // Move (Uppercase(aIndexFrom.sSQLIndexName) = Uppercase(aIndexTo.sSQLIndexName)) to bIsSame
97898>>>>>            // If (bIsSame = False) Begin   DF_INDEX_SERVER_ONLY
97898>>>>>            //     Function_Return False
97898>>>>>            // End
97898>>>>>            Move (APIIndexCompare.bIsSQLPrimaryKeyFrom = APIIndexCompare.bIsSQLPrimaryKeyTo) to bIsSame
97899>>>>>            If (bIsSame = False) Begin
97901>>>>>                Function_Return False
97902>>>>>            End
97902>>>>>>
97902>>>>>            Move (APIIndexCompare.bIsSQLClusteredFrom = APIIndexCompare.bIsSQLClusteredTo) to bIsSame
97903>>>>>            If (bIsSame = False) Begin
97905>>>>>                Function_Return False
97906>>>>>            End
97906>>>>>>
97906>>>>>            Move (APIIndexCompare.iSQLIndexTypeFrom = APIIndexCompare.iSQLIndexTypeTo) to bIsSame
97907>>>>>            If (bIsSame = False) Begin
97909>>>>>                Function_Return False
97910>>>>>            End
97910>>>>>>
97910>>>>>        End
97910>>>>>>
97910>>>>>
97910>>>>>        Get UtilIndexSegmentsCompare APIIndexCompare.IndexSegmentArrayFrom APIIndexCompare.IndexSegmentArrayTo bCompareIndexUppercase bCompareIndexAscending to iSegment
97911>>>>>        Move (iSegment = -1) to bIsSame
97912>>>>>
97912>>>>>        Function_Return (bIsSame = True)
97913>>>>>    End_Function
97914>>>>>
97914>>>>>    // Compares each segment for the passed index.
97914>>>>>    // Returns -1 if same; else returns the index segment that differs.
97914>>>>>    Function UtilIndexSegmentsCompare tAPIIndexSegment[] aIndexSegmentFrom tAPIIndexSegment[] aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
97916>>>>>        Integer iNumSegmentsFrom iNumSegmentsTo iNumSegments iSegment
97916>>>>>        Boolean bIsSame
97916>>>>>
97916>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
97917>>>>>        Move (SizeOfArray(aIndexSegmentFrom))      to iNumSegmentsFrom
97918>>>>>        Move (SizeOfArray(aIndexSegmentTo))        to iNumSegmentsTo
97919>>>>>        Move (iNumSegmentsFrom max iNumSegmentsTo) to iNumSegments
97920>>>>>
97920>>>>>        Decrement iNumSegments
97921>>>>>        for iSegment from 0 to iNumSegments
97927>>>>>>
97927>>>>>            Move False to bIsSame
97928>>>>>            If (iSegment <= iNumSegmentsFrom and iSegment <= iNumSegmentsTo) Begin
97930>>>>>                Get UtilIndexSegmentCompare aIndexSegmentFrom[iSegment] aIndexSegmentTo[iSegment] bCompareIndexUppercase bCompareIndexAscending to bIsSame
97931>>>>>            End
97931>>>>>>
97931>>>>>            If (bIsSame = False) Begin
97933>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
97934>>>>>                Function_Return iSegment
97935>>>>>            End
97935>>>>>>
97935>>>>>        Loop
97936>>>>>>
97936>>>>>
97936>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
97937>>>>>        Function_Return -1 // This means bIsSame = True
97938>>>>>    End_Function
97939>>>>>
97939>>>>>    Function UtilIndexSegmentCompare tAPIIndexSegment aIndexSegmentFrom tAPIIndexSegment aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
97941>>>>>        Boolean bIsSame
97941>>>>>
97941>>>>>        Move (aIndexSegmentFrom.iFieldNumber = aIndexSegmentTo.iFieldNumber) to bIsSame
97942>>>>>        If (bIsSame = False) Begin
97944>>>>>            Function_Return False
97945>>>>>        End
97945>>>>>>
97945>>>>>        If (bCompareIndexUppercase = True) Begin
97947>>>>>            Move (aIndexSegmentFrom.bUppercase = aIndexSegmentTo.bUppercase) to bIsSame
97948>>>>>            If (bIsSame = False) Begin
97950>>>>>                Function_Return False
97951>>>>>            End
97951>>>>>>
97951>>>>>        End
97951>>>>>>
97951>>>>>        If (bCompareIndexAscending = True) Begin
97953>>>>>            Move (aIndexSegmentFrom.bAscending = aIndexSegmentTo.bAscending) to bIsSame
97954>>>>>            If (bIsSame = False) Begin
97956>>>>>                Function_Return False
97957>>>>>            End
97957>>>>>>
97957>>>>>        End
97957>>>>>>
97957>>>>>
97957>>>>>        Function_Return True
97958>>>>>    End_Function
97959>>>>>
97959>>>>>    Function UtilIndexesUpdate Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndex[] aIndexesFrom tAPIIndex[] aIndexesTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
97961>>>>>        Boolean bIsSame bOK bExists
97961>>>>>        Integer iSize iSizeFrom iSizeTo iCount iIndexSegment               
97961>>>>>        tAPIIndexCompare[] aAPIIndexCompare
97961>>>>>        tAPIIndexCompare[] aAPIIndexCompare
97962>>>>>
97962>>>>>        Move (SizeOfArray(aIndexesFrom)) to iSize
97963>>>>>        If (iSize = 0) Begin
97965>>>>>            Function_Return True
97966>>>>>        End                     
97966>>>>>>
97966>>>>>        Move (SizeOfArray(aIndexesTo)) to iSizeTo  
97967>>>>>        Get UtilTableIsSql hTable to bIsSQLTableTo
97968>>>>>        Get UtilIndexCombineFromAndToArrays aIndexesFrom aIndexesTo to aAPIIndexCompare
97969>>>>>        
97969>>>>>        for iCount from 0 to (iSize - 1) 
97975>>>>>>
97975>>>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
97976>>>>>            If (bIsSame = False) Begin
97978>>>>>                Get APIIndexCreateByFieldNames hTable aIndexesFrom[iCount] aIndexesTo aIndexesFrom[iCount].IndexSegmentArray to bOK
97979>>>>>            End
97979>>>>>>
97979>>>>>        Loop  
97980>>>>>>
97980>>>>>        
97980>>>>>        // We probably should delete other indexes if they exists.
97980>>>>>        for iCount from (iSize +1) to iSizeTo
97986>>>>>>
97986>>>>>            Get ApiIndexRemove hTable iCount to bOK
97987>>>>>        Loop
97988>>>>>>
97988>>>>>
97988>>>>>        Function_Return bOK
97989>>>>>    End_Function
97990>>>>>
97990>>>>>//    Function UtilIsSameColumnDefinitions Handle hTable tAPIColumn[] aColumns Returns Boolean
97990>>>>>//        Boolean bEqual bIdentityKey bSqlDriver bDawSqlDriver bIsOpen
97990>>>>>//        Integer iCount iColumn iSize iOptions iLength iPrecision iType
97990>>>>>//        String sFieldName sDriverID
97990>>>>>//
97990>>>>>//        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
97990>>>>>//        If (bIsOpen = False) Begin
97990>>>>>//            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
97990>>>>>//            Open hTable
97990>>>>>//            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
97990>>>>>//            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
97990>>>>>//            If (bIsOpen = False) Begin
97990>>>>>//                Function_Return False
97990>>>>>//            End
97990>>>>>//        End
97990>>>>>//
97990>>>>>//        Move True to bEqual
97990>>>>>//        Get psDriverID to sDriverID
97990>>>>>//        Get IsSQLDriver    sDriverID to bSqlDriver
97990>>>>>//        Get IsDAWSQLDriver sDriverID to bDawSqlDriver
97990>>>>>//        Move (SizeOfArray(aColumns)) to iSize
97990>>>>>//        Decrement iSize
97990>>>>>//
97990>>>>>//        For iCount from 0 to iSize
97990>>>>>//            Move 0 to iOptions
97990>>>>>//            Move False to bIdentityKey
97990>>>>>//            Move aColumns[iCount].sFieldName to sFieldName
97990>>>>>//
97990>>>>>//            // We need to use the column name - not the column integer as
97990>>>>>//            // the order does not need to be the same, and the logic should still work.
97990>>>>>//            Get UtilColumnNameToColumnNumber hTable sFieldName to iColumn
97990>>>>>//            If (iColumn > 0) Begin
97990>>>>>//                If (bDawSqlDriver = True) Begin
97990>>>>>//                    Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
97990>>>>>//                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iType
97990>>>>>//                    If (iType <> aColumns[iCount].iSQLType) Begin
97990>>>>>//                        Move False to bEqual
97990>>>>>//                    End
97990>>>>>//                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
97990>>>>>//                    If (bIdentityKey = True) Begin
97990>>>>>//                        Move C_tAPIColumn_Identity to iOptions
97990>>>>>//                    End
97990>>>>>//                    If (iOptions <> aColumns[iCount].iOptions) Begin
97990>>>>>//                        Move False to bEqual
97990>>>>>//                    End
97990>>>>>//                    Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
97990>>>>>//                End
97990>>>>>//                Else Begin
97990>>>>>//                    Get_Attribute DF_FIELD_TYPE     of hTable iColumn to iType
97990>>>>>//                    If (iType <> aColumns[iCount].iSQLType) Begin
97990>>>>>//                        Move False to bEqual
97990>>>>>//                    End
97990>>>>>//                End
97990>>>>>//                Get_Attribute DF_FIELD_LENGTH       of hTable iColumn to iLength
97990>>>>>//                If (iLength <> aColumns[iCount].iLength) Begin
97990>>>>>//                    Move False to bEqual
97990>>>>>//                End
97990>>>>>//                Get_Attribute DF_FIELD_PRECISION    of hTable iColumn to iPrecision
97990>>>>>//                If (iPrecision <> aColumns[iCount].iPrecision) Begin
97990>>>>>//                    Move False to bEqual
97990>>>>>//                End
97990>>>>>//                If (bEqual = False) Begin
97990>>>>>//                    Function_Return False
97990>>>>>//                End
97990>>>>>//            End
97990>>>>>//
97990>>>>>//            Else Begin
97990>>>>>//                Function_Return False
97990>>>>>//            End
97990>>>>>//        Loop
97990>>>>>//
97990>>>>>//        Function_Return bEqual
97990>>>>>//    End_Function
97990>>>>>
97990>>>>>    Function UtilIndexesStructFill Handle hTable Returns tAPIIndex[]
97992>>>>>        tAPIIndex[] APIIndexes
97992>>>>>        tAPIIndex[] APIIndexes
97993>>>>>        Integer iCount iIndex iIndexes iSegment iSegmentCount iNumSegments iColumn
97993>>>>>        String sDriverID
97993>>>>>        Boolean bDAWSQLDriver bIsOpen bIsSQLTable bIsSQLPrimaryKey
97993>>>>>
97993>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
97994>>>>>        Get psDriverID to sDriverID
97995>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
97996>>>>>        Get UtilTableIsSQL hTable to bIsSQLTable
97997>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
98000>>>>>        If (bIsOpen = False) Begin
98002>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
98003>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
98004>>>>>            Open hTable
98006>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
98007>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
98008>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
98011>>>>>            If (bIsOpen = False) Begin
98013>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
98014>>>>>                Move True to APIIndexes[0].bError
98015>>>>>                Function_Return APIIndexes
98016>>>>>            End
98016>>>>>>
98016>>>>>        End
98016>>>>>>
98016>>>>>
98016>>>>>        Move 0 to iCount
98017>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iIndexes
98020>>>>>        for iIndex from 1 to iIndexes
98026>>>>>>
98026>>>>>            // This is a test that the index exists as there might be "holes" aka the index
98026>>>>>            // numbers doesn't not need to be consequitive:
98026>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
98029>>>>>            If (iNumSegments > 0) Begin
98031>>>>>
98031>>>>>                Move iIndex                                                     to APIIndexes[iCount].iIndexNumber
98032>>>>>                Get_Attribute DF_FILE_PRIMARY_INDEX of hTable                   to APIIndexes[iCount].iPrimaryIndex
98035>>>>>                If (bIsSQLTable = True) Begin
98037>>>>>                    Get_Attribute DF_INDEX_NAME         of hTable iIndex        to APIIndexes[iCount].sSQLIndexName
98040>>>>>                        Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to APIIndexes[iCount].bIsSQLPrimaryKey
98043>>>>>                        Get_Attribute DF_INDEX_CLUSTERED of hTable iIndex       to APIIndexes[iCount].bIsSQLClustered
98046>>>>>                        Get_Attribute DF_INDEX_SQL_TYPE of hTable iIndex        to APIIndexes[iCount].iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
98049>>>>>                End
98049>>>>>>
98049>>>>>
98049>>>>>                Move 0 to iSegmentCount
98050>>>>>                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
98053>>>>>                For iSegment from 1 to iNumSegments
98059>>>>>>
98059>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iSegment to iColumn
98062>>>>>                    Move iColumn                                                       to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].iFieldNumber
98063>>>>>                    Get_Attribute DF_FIELD_NAME              of hTable iColumn         to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].sFieldName
98066>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bUppercase
98069>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bAscending
98072>>>>>                    Increment iSegmentCount
98073>>>>>                Loop
98074>>>>>>
98074>>>>>                Increment iCount
98075>>>>>            End
98075>>>>>>
98075>>>>>        Loop
98076>>>>>>
98076>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
98077>>>>>
98077>>>>>        Function_Return APIIndexes
98078>>>>>    End_Function
98079>>>>>
98079>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
98079>>>>>    // The combined data will be sorted on the first struct member: iIndexNumber
98079>>>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
98079>>>>>    // have "holes" in the series of index numbers.
98079>>>>>    Function UtilIndexCombineFromAndToArrays tAPIIndex[] APIIndexFrom tAPIIndex[] APIIndexTo Returns tAPIIndexCompare[]
98081>>>>>        tAPIIndexCompare[] aAPIIndexCompare
98081>>>>>        tAPIIndexCompare[] aAPIIndexCompare
98082>>>>>        tAPIIndexCompare   APIIndexCompare
98082>>>>>        tAPIIndexCompare   APIIndexCompare
98082>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem iIndexFrom iIndexTo
98082>>>>>
98082>>>>>        Move (SizeOfArray(APIIndexFrom)) to iSizeFrom
98083>>>>>        Move (SizeOfArray(APIIndexTo)) to iSizeTo
98084>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
98086>>>>>            Function_Return aAPIIndexCompare
98087>>>>>        End
98087>>>>>>
98087>>>>>
98087>>>>>        Decrement iSizeFrom
98088>>>>>        for iCount from 0 to iSizeFrom
98094>>>>>>
98094>>>>>            Move APIIndexFrom[iCount].iIndexNumber      to aAPIIndexCompare[iCount].iIndexNumber
98095>>>>>            Move APIIndexFrom[iCount].iPrimaryIndex     to aAPIIndexCompare[iCount].iPrimaryIndexFrom
98096>>>>>            Move APIIndexFrom[iCount].sSQLIndexName     to aAPIIndexCompare[iCount].sSQLIndexNameFrom
98097>>>>>            Move APIIndexFrom[iCount].iSQLIndexType     to aAPIIndexCompare[iCount].iSQLIndexTypeFrom
98098>>>>>            Move APIIndexFrom[iCount].bIsSQLClustered   to aAPIIndexCompare[iCount].bIsSQLClusteredFrom
98099>>>>>            Move APIIndexFrom[iCount].bIsSQLPrimaryKey  to aAPIIndexCompare[iCount].bIsSQLPrimaryKeyFrom
98100>>>>>            Move APIIndexFrom[iCount].IndexSegmentArray to aAPIIndexCompare[iCount].IndexSegmentArrayFrom
98101>>>>>            Move APIIndexFrom[iCount].bShouldChange     to aAPIIndexCompare[iCount].bShouldChangeFrom
98102>>>>>            Move APIIndexFrom[iCount].bCancel           to aAPIIndexCompare[iCount].bCancelFrom
98103>>>>>            Move APIIndexFrom[iCount].bError            to aAPIIndexCompare[iCount].bErrorFrom
98104>>>>>            Move True                                   to aAPIIndexCompare[iCount].bExistsFrom
98105>>>>>        Loop
98106>>>>>>
98106>>>>>
98106>>>>>        Decrement iSizeTo
98107>>>>>        for iCount from 0 to iSizeTo
98113>>>>>>
98113>>>>>            Move APIIndexTo[iCount].iIndexNumber        to APIIndexCompare.iIndexNumber
98114>>>>>            // Search if the Index number already exists in the array; else add it.
98114>>>>>            Move (SearchArray(APIIndexCompare, aAPIIndexCompare)) to iItem
98115>>>>>            If (iItem = -1) Begin
98117>>>>>                Move (SizeOfArray(aAPIIndexCompare))    to iItem
98118>>>>>            End
98118>>>>>>
98118>>>>>
98118>>>>>            Move APIIndexCompare.iIndexNumber           to aAPIIndexCompare[iItem].iIndexNumber
98119>>>>>            Move APIIndexTo[iCount].iPrimaryIndex       to aAPIIndexCompare[iItem].iPrimaryIndexTo
98120>>>>>            Move APIIndexTo[iCount].sSQLIndexName       to aAPIIndexCompare[iItem].sSQLIndexNameTo
98121>>>>>            Move APIIndexTo[iCount].iSQLIndexType       to aAPIIndexCompare[iItem].iSQLIndexTypeTo
98122>>>>>            Move APIIndexTo[iCount].bIsSQLClustered     to aAPIIndexCompare[iItem].bIsSQLClusteredTo
98123>>>>>            Move APIIndexTo[iCount].bIsSQLPrimaryKey    to aAPIIndexCompare[iItem].bIsSQLPrimaryKeyTo
98124>>>>>            Move APIIndexTo[iCount].IndexSegmentArray   to aAPIIndexCompare[iItem].IndexSegmentArrayTo
98125>>>>>            Move APIIndexTo[iCount].bShouldChange       to aAPIIndexCompare[iItem].bShouldChangeTo
98126>>>>>            Move APIIndexTo[iCount].bCancel             to aAPIIndexCompare[iItem].bCancelTo
98127>>>>>            Move APIIndexTo[iCount].bError              to aAPIIndexCompare[iItem].bErrorTo
98128>>>>>            Move True                                   to aAPIIndexCompare[iItem].bExistsTo
98129>>>>>        Loop
98130>>>>>>
98130>>>>>
98130>>>>>        Move (SortArray(aAPIIndexCompare)) to aAPIIndexCompare
98131>>>>>
98131>>>>>        Function_Return aAPIIndexCompare
98132>>>>>    End_Function
98133>>>>>
98133>>>>>    // This is the same as the UtilIndexCompare function but it takes tAPIIndex structs as params.
98133>>>>>    Function UtilIndexTypeNumberCompare Handle hTable tAPIIndex aIndexFrom tAPIIndex aIndexTo Returns Boolean
98135>>>>>        Boolean bIsSame bDAWSQLDriver bIsSqlTable
98135>>>>>        String sDriverID
98135>>>>>        Integer iSegment
98135>>>>>        
98135>>>>>        Get psDriverID to sDriverID
98136>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
98137>>>>>        Get IsSQLDriver sDriverID to bIsSqlTable
98138>>>>>        If (bIsSqlTable = True) Begin
98140>>>>>            Get UtilTableIsSQL hTable to bIsSqlTable
98141>>>>>        End
98141>>>>>>
98141>>>>>
98141>>>>>        Move (aIndexFrom.iIndexNumber = aIndexTo.iIndexNumber) to bIsSame
98142>>>>>        If (bIsSame = False) Begin
98144>>>>>            Function_Return False
98145>>>>>        End
98145>>>>>>
98145>>>>>
98145>>>>>        If (bDAWSQLDriver = True and bIsSqlTable = True) Begin
98147>>>>>            // Don't think we should do this. Or should we?
98147>>>>>            // Move (aIndexesFrom[iCount].sSQLIndexName = aIndexesTo[iCount].sSQLIndexName) to bIsSame
98147>>>>>
98147>>>>>            Move (aIndexFrom.iSQLIndexType = aIndexTo.iSQLIndexType) to bIsSame
98148>>>>>            If (bIsSame = False) Begin
98150>>>>>                Function_Return False
98151>>>>>            End    
98151>>>>>>
98151>>>>>            Move (aIndexFrom.iPrimaryIndex = aIndexTo.iPrimaryIndex) to bIsSame
98152>>>>>            If (bIsSame = False) Begin
98154>>>>>                Function_Return False
98155>>>>>            End
98155>>>>>>
98155>>>>>            Move (aIndexFrom.bIsSQLPrimaryKey = aIndexTo.bIsSQLPrimaryKey) to bIsSame
98156>>>>>            If (bIsSame = False) Begin
98158>>>>>                Function_Return False
98159>>>>>            End                      
98159>>>>>>
98159>>>>>            Move (aIndexFrom.bIsSQLClustered = aIndexTo.bIsSQLClustered) to bIsSame
98160>>>>>            If (bIsSame = False) Begin
98162>>>>>                Function_Return False
98163>>>>>            End                      
98163>>>>>>
98163>>>>>        End
98163>>>>>>
98163>>>>>        
98163>>>>>        Function_Return bIsSame
98164>>>>>    End_Function
98165>>>>>
98165>>>>>    // DF_INDEX_SQL_TYPE values
98165>>>>>    // Pass one of the DF_INDEX_XXX integer constants and the function
98165>>>>>    // returns a string with the name.
98165>>>>>    Function UtilIndexTypeToString Integer iIndexType Returns String
98167>>>>>        String sRetval
98167>>>>>        Case Begin
98167>>>>>            Case (iIndexType = DF_INDEX_CLIENT)
98169>>>>>                Move "DF_INDEX_CLIENT" to sRetval
98170>>>>>                Case Break
98171>>>>>            Case (iIndexType = DF_INDEX_SERVER)
98174>>>>>                Move "DF_INDEX_SERVER" to sRetval
98175>>>>>                Case Break
98176>>>>>            Case (iIndexType = DF_INDEX_SERVER_ONLY)
98179>>>>>                Move "DF_INDEX_SERVER_ONLY" to sRetval
98180>>>>>                Case Break
98181>>>>>            Case (iIndexType = DF_INDEX_TEMPORARY)
98184>>>>>                Move "DF_INDEX_TEMPORARY" to sRetval
98185>>>>>                Case Break
98186>>>>>            Case Else
98186>>>>>                Move "UNKNOWN INDEX TYPE" to sRetval
98187>>>>>        Case End
98187>>>>>        Function_Return sRetval
98188>>>>>    End_Function
98189>>>>>
98189>>>>>    // * Dummy function for the Studio's Code Explorer *
98189>>>>>    Function API_RELATION_UTILITY_FUNCTIONS Returns Boolean
98191>>>>>        Function_Return False
98192>>>>>    End_Function
98193>>>>>
98193>>>>>    // Compares multiple relationships for a 'FROM' and a 'TO' databases
98193>>>>>    Function UtilRelationsCompare Handle hTable tAPIRelationCompare[] aAPIRelationCompare Returns Boolean
98195>>>>>        Boolean bIsSame
98195>>>>>        Integer iSize iCount
98195>>>>>
98195>>>>>        Move True to bIsSame
98196>>>>>        Move (SizeOfArray(aAPIRelationCompare)) to iSize
98197>>>>>        Decrement iSize
98198>>>>>        For iCount from 0 to iSize
98204>>>>>>
98204>>>>>            Get UtilRelationCompare hTable aAPIRelationCompare[iCount] to bIsSame
98205>>>>>            If (bIsSame = False) Begin
98207>>>>>                Function_Return False
98208>>>>>            End
98208>>>>>>
98208>>>>>        Loop
98209>>>>>>
98209>>>>>
98209>>>>>        Function_Return bIsSame
98210>>>>>    End_Function
98211>>>>>
98211>>>>>    // Compares a single relationship for a 'FROM' and a 'TO' table
98211>>>>>    Function UtilRelationCompare Handle hTable tAPIRelationCompare APIRelationCompare Returns Boolean
98213>>>>>        Boolean bIsSame
98213>>>>>
98213>>>>>        Move True to bIsSame
98214>>>>>        If (APIRelationCompare.bExistsFrom <> APIRelationCompare.bExistsTo) Begin
98216>>>>>            Function_Return False
98217>>>>>        End
98217>>>>>>
98217>>>>>        If (APIRelationCompare.hTableFrom = 0 or APIRelationCompare.hTableTo = 0) Begin
98219>>>>>            Function_Return False
98220>>>>>        End
98220>>>>>>
98220>>>>>
98220>>>>>        // We could also compare field names, but I don't think that is necessary...
98220>>>>>
98220>>>>>        Function_Return bIsSame
98221>>>>>    End_Function
98222>>>>>
98222>>>>>    // This message is different from ApiTableCreate in that it will not do a function_return if the table
98222>>>>>    // already exists. 
98222>>>>>    Function UtilRelationsUpdate Handle hTable tAPIRelation[] aRelationsFrom tAPIRelation[] aRelationsTo Returns Boolean
98224>>>>>        Boolean bIsSame bOK
98224>>>>>        Integer iSizeTo iSize iCount iColumn
98224>>>>>        String sDriverID
98224>>>>>        
98224>>>>>        Move True to bOK                                                                                
98225>>>>>        Move (SizeOfArray(aRelationsTo))   to iSizeTo
98226>>>>>        If (iSizeTo > 0) Begin
98228>>>>>            Get AutoConnectionIDLogin to bOK
98229>>>>>            Move False to Err
98230>>>>>            Open hTable Mode DF_EXCLUSIVE
98232>>>>>            Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
98235>>>>>            Decrement iSizeTo
98236>>>>>
98236>>>>>            // We should probably not make any comparison between "FROM" and "TO" database; instead just create all "FROM" relations
98236>>>>>            // for the "TO" database. But start by deleting all current "TO" relations:
98236>>>>>            Structure_Start hTable sDriverID            
98237>>>>>                for iCount from 0 to iSizeTo                                                
98243>>>>>>
98243>>>>>                    Move aRelationsTo[iCount].iColumnFrom to iColumn
98244>>>>>                    Set_Attribute DF_FIELD_RELATED_FILE  of hTable iColumn to 0
98247>>>>>                    Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn to 0
98250>>>>>                End
98251>>>>>>
98251>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
98252>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
98254>>>>>            Set Action_Text of ghoStatusPanel to ""
98255>>>>>        End
98255>>>>>>
98255>>>>>
98255>>>>>        Move (SizeOfArray(aRelationsFrom)) to iSize
98256>>>>>        Decrement iSize
98257>>>>>        for iCount from 0 to iSize
98263>>>>>>
98263>>>>>            Get ApiTableRelate aRelationsFrom[iCount].hTableFrom aRelationsFrom[iCount].hTableTo aRelationsFrom[iCount].iColumnFrom aRelationsFrom[iCount].iColumnTo aRelationsTo to bOK
98264>>>>>        Loop
98265>>>>>>
98265>>>>>
98265>>>>>        Function_Return bOK
98266>>>>>    End_Function
98267>>>>>
98267>>>>>    Function UtilRelationsStructFill Handle hTable Returns tAPIRelation[]
98269>>>>>        tAPIRelation[] APIRelations
98269>>>>>        tAPIRelation[] APIRelations
98270>>>>>        Integer iColumn iColumnTo iNumColumns iCount
98270>>>>>        Handle hParent
98270>>>>>        Boolean bIsOpen
98270>>>>>
98270>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
98271>>>>>        Move 0 to iCount
98272>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
98275>>>>>        If (bIsOpen = False) Begin
98277>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
98278>>>>>            Open hTable
98280>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
98281>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
98284>>>>>            If (bIsOpen = False) Begin
98286>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
98287>>>>>                Move True to APIRelations[0].bError
98288>>>>>                Function_Return APIRelations
98289>>>>>            End
98289>>>>>>
98289>>>>>        End
98289>>>>>>
98289>>>>>
98289>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
98292>>>>>        For iColumn from 1 to iNumColumns
98298>>>>>>
98298>>>>>            Get_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to hParent
98301>>>>>            If (hParent <> 0) Begin
98303>>>>>                Open hParent
98305>>>>>                Move hTable                                             to APIRelations[iCount].hTableFrom
98306>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable            to APIRelations[iCount].sLogicalNameFrom
98309>>>>>                Move iColumn                                            to APIRelations[iCount].iColumnFrom
98310>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn           to APIRelations[iCount].sFieldNameFrom
98313>>>>>
98313>>>>>                Move hParent                                            to APIRelations[iCount].hTableTo
98314>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hParent           to APIRelations[iCount].sLogicalNameTo
98317>>>>>                Get_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn  to iColumnTo
98320>>>>>                Move iColumnTo                                          to APIRelations[iCount].iColumnTo
98321>>>>>                Get_Attribute DF_FIELD_NAME of hParent iColumnTo        to APIRelations[iCount].sFieldNameTo
98324>>>>>                Move False                                              to APIRelations[iCount].bShouldChange
98325>>>>>                Move False                                              to APIRelations[iCount].bCancel
98326>>>>>                Move False                                              to APIRelations[iCount].bError
98327>>>>>                Close hParent
98328>>>>>                Increment iCount
98329>>>>>            End
98329>>>>>>
98329>>>>>        Loop
98330>>>>>>
98330>>>>>
98330>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
98331>>>>>        Function_Return APIRelations
98332>>>>>    End_Function
98333>>>>>
98333>>>>>    Function UtilRelationArrayCompare tAPIRelation RelationCurrent tAPIRelation RelationNew Returns Integer
98335>>>>>        If (RelationCurrent.hTableFrom  = RelationNew.hTableFrom and ;            RelationCurrent.iColumnFrom = RelationNew.iColumnFrom and ;            RelationCurrent.hTableTo    = RelationNew.hTableTo and ;            RelationCurrent.iColumnTo   = RelationNew.iColumnTo) Begin
98337>>>>>            Function_Return (EQ)
98338>>>>>        End
98338>>>>>>
98338>>>>>
98338>>>>>        Function_Return (GT)
98339>>>>>    End_Function
98340>>>>>
98340>>>>>    Function SearchRelationCompare tAPIRelationCompare RelationCompareCurrent tAPIRelationCompare RelationCompareNew Returns Integer
98342>>>>>        If (RelationCompareCurrent.hTableFrom  = RelationCompareNew.hTableFrom and ;            RelationCompareCurrent.iColumnFrom = RelationCompareNew.iColumnFrom and ;            RelationCompareCurrent.hTableTo    = RelationCompareNew.hTableTo and ;            RelationCompareCurrent.iColumnTo   = RelationCompareNew.iColumnTo) ;            Function_Return (EQ)
98345>>>>>
98345>>>>>        Function_Return (GT)
98346>>>>>    End_Function
98347>>>>>
98347>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
98347>>>>>    // The combined data will be sorted on the first 4 struct members: hTableFrom, iColumnFrom, hTableTo and iColumnTo
98347>>>>>    Function UtilRelationCombineFromAndToArrays tAPIRelation[] aAPIRelationFrom tAPIRelation[] aAPIRelationTo Returns tAPIIndexCompare[]
98349>>>>>        tAPIRelation[] aAPIRelationFromAndTo
98349>>>>>        tAPIRelation[] aAPIRelationFromAndTo
98350>>>>>        tAPIRelationCompare[] aAPIRelationCompare
98350>>>>>        tAPIRelationCompare[] aAPIRelationCompare
98351>>>>>        tAPIRelationCompare   APIRelationCompare
98351>>>>>        tAPIRelationCompare   APIRelationCompare
98351>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
98351>>>>>
98351>>>>>        Move (SizeOfArray(aAPIRelationFrom)) to iSizeFrom
98352>>>>>        Move (SizeOfArray(aAPIRelationTo))   to iSizeTo
98353>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
98355>>>>>            Function_Return aAPIRelationCompare
98356>>>>>        End
98356>>>>>>
98356>>>>>
98356>>>>>        Move (AppendArray(aAPIRelationFrom, aAPIRelationTo)) to aAPIRelationFromAndTo
98357>>>>>        Move (SortArray(aAPIRelationFromAndTo, Self, RefFunc(UtilRelationArrayCompare))) to aAPIRelationFromAndTo
98358>>>>>
98358>>>>>        Decrement iSizeFrom
98359>>>>>        for iCount from 0 to iSizeFrom
98365>>>>>>
98365>>>>>            Move aAPIRelationFrom[iCount].hTableFrom        to aAPIRelationCompare[iCount].hTableFrom
98366>>>>>            Move aAPIRelationFrom[iCount].iColumnFrom       to aAPIRelationCompare[iCount].iColumnFrom
98367>>>>>            Move aAPIRelationFrom[iCount].hTableTo          to aAPIRelationCompare[iCount].hTableTo
98368>>>>>            Move aAPIRelationFrom[iCount].iColumnTo         to aAPIRelationCompare[iCount].iColumnTo
98369>>>>>            Move aAPIRelationFrom[iCount].sLogicalNameFrom  to aAPIRelationCompare[iCount].sLogicalNameFrom_From
98370>>>>>            Move aAPIRelationFrom[iCount].sLogicalNameTo    to aAPIRelationCompare[iCount].sLogicalNameTo_From
98371>>>>>            Move aAPIRelationFrom[iCount].sFieldNameFrom    to aAPIRelationCompare[iCount].sFieldNameFrom_From
98372>>>>>            Move aAPIRelationFrom[iCount].sFieldNameTo      to aAPIRelationCompare[iCount].sFieldNameTo_From
98373>>>>>            Move aAPIRelationFrom[iCount].bShouldChange     to aAPIRelationCompare[iCount].bShouldChange_From
98374>>>>>            Move aAPIRelationFrom[iCount].bCancel           to aAPIRelationCompare[iCount].bCancel_From
98375>>>>>            Move aAPIRelationFrom[iCount].bError            to aAPIRelationCompare[iCount].bError_From
98376>>>>>            Move True                                       to aAPIRelationCompare[iCount].bExistsFrom
98377>>>>>        Loop
98378>>>>>>
98378>>>>>
98378>>>>>        Decrement iSizeTo
98379>>>>>        for iCount from 0 to iSizeTo
98385>>>>>>
98385>>>>>            Move aAPIRelationTo[iCount].hTableFrom          to APIRelationCompare.hTableFrom
98386>>>>>            Move aAPIRelationTo[iCount].iColumnFrom         to APIRelationCompare.iColumnFrom
98387>>>>>            Move aAPIRelationTo[iCount].hTableTo            to APIRelationCompare.hTableTo
98388>>>>>            Move aAPIRelationTo[iCount].iColumnTo           to APIRelationCompare.iColumnTo
98389>>>>>
98389>>>>>            // Search if the relation already exists in the array; else add it.
98389>>>>>            Move (SearchArray(APIRelationCompare, aAPIRelationCompare, Self, RefFunc(SearchRelationCompare))) to iItem
98390>>>>>            If (iItem = -1) Begin
98392>>>>>                Move (SizeOfArray(aAPIRelationCompare))     to iItem
98393>>>>>            End
98393>>>>>>
98393>>>>>
98393>>>>>            Move APIRelationCompare.hTableFrom              to aAPIRelationCompare[iItem].hTableFrom
98394>>>>>            Move APIRelationCompare.iColumnFrom             to aAPIRelationCompare[iItem].iColumnFrom
98395>>>>>            Move APIRelationCompare.hTableTo                to aAPIRelationCompare[iItem].hTableTo
98396>>>>>            Move APIRelationCompare.iColumnTo               to aAPIRelationCompare[iItem].iColumnTo
98397>>>>>            Move aAPIRelationTo[iCount].sLogicalNameFrom    to aAPIRelationCompare[iItem].sLogicalNameFrom_To
98398>>>>>            Move aAPIRelationTo[iCount].sLogicalNameTo      to aAPIRelationCompare[iItem].sLogicalNameTo_To
98399>>>>>            Move aAPIRelationTo[iCount].sFieldNameFrom      to aAPIRelationCompare[iItem].sFieldNameFrom_To
98400>>>>>            Move aAPIRelationTo[iCount].sFieldNameTo        to aAPIRelationCompare[iItem].sFieldNameTo_To
98401>>>>>            Move aAPIRelationTo[iCount].bShouldChange       to aAPIRelationCompare[iItem].bShouldChange_To
98402>>>>>            Move aAPIRelationTo[iCount].bCancel             to aAPIRelationCompare[iItem].bCancel_To
98403>>>>>            Move aAPIRelationTo[iCount].bError              to aAPIRelationCompare[iItem].bError_To
98404>>>>>            Move True                                       to aAPIRelationCompare[iItem].bExistsTo
98405>>>>>        Loop
98406>>>>>>
98406>>>>>
98406>>>>>        Move (SortArray(aAPIRelationCompare, Self, RefFunc(SearchRelationCompare))) to aAPIRelationCompare
98407>>>>>
98407>>>>>        Function_Return aAPIRelationCompare
98408>>>>>    End_Function
98409>>>>>
98409>>>>>    // * Dummy function for the Studio's Code Explorer *
98409>>>>>    Function CODEMAST_UTILITY_FUNCTIONS Returns Boolean
98411>>>>>        Function_Return False
98412>>>>>    End_Function
98413>>>>>
98413>>>>>    // To add a value to the CodeMast & CodeType tables. Pass; a) bCodeType if it is CodeType that should be updated.
98413>>>>>    // Else it is CodeMast. b) sTypeValue; either to be added If bCodeType = True, or it will be used to find the correct
98413>>>>>    // CodeType record. c) sValue1 and d) sValue2 is the CodeType Description & Comment, or CodeMast Type and Code values.
98413>>>>>    Function UtilCodeMasterAddValue Boolean bCodeType String sTypeValue String sValue2 String sValue3 Returns Boolean
98415>>>>>        Boolean bFound
98415>>>>>
98415>>>>>        Move False to Err
98416>>>>>        Open CodeMast
98418>>>>>        Open CodeType
98420>>>>>
98420>>>>>        If (bCodeType = True) Begin
98422>>>>>            Clear CodeType
98423>>>>>            Move sTypeValue to CODETYPE.Type
98424>>>>>            Find eq CODETYPE.Type
98425>>>>>>
98425>>>>>            Move (Found = True) to bFound
98426>>>>>            If (bFound = True) Begin
98428>>>>>                Reread CodeType
98432>>>>>            End
98432>>>>>>
98432>>>>>            If (bFound = False) Begin
98434>>>>>                Clear CodeType
98435>>>>>            End
98435>>>>>>
98435>>>>>                Move sTypeValue to CODETYPE.Type
98436>>>>>                Move sValue2    to CODETYPE.Description
98437>>>>>                Move sValue3    to CODETYPE.Comment
98438>>>>>                SaveRecord CODETYPE
98439>>>>>            If (bFound = True) Begin
98441>>>>>                Unlock
98442>>>>>>
98442>>>>>            End
98442>>>>>>
98442>>>>>        End
98442>>>>>>
98442>>>>>
98442>>>>>        If (bCodeType = False) Begin
98444>>>>>            Clear CODEMAST
98445>>>>>            Move sTypeValue to CODEMAST.Type
98446>>>>>            Move sValue2    to CODEMAST.Code
98447>>>>>            Find eq CODEMAST.Code
98448>>>>>>
98448>>>>>            Move (Found = True) to bFound
98449>>>>>            If (bFound = True) Begin
98451>>>>>                Reread CODEMAST
98455>>>>>            End
98455>>>>>>
98455>>>>>            If (bFound = False) Begin
98457>>>>>                Clear CODEMAST
98458>>>>>            End
98458>>>>>>
98458>>>>>                Move sTypeValue to CODEMAST.Type
98459>>>>>                Move sValue2    to CODEMAST.Code
98460>>>>>                Move sValue3    to CODEMAST.Description
98461>>>>>                SaveRecord CODEMAST
98462>>>>>            If (bFound = True) Begin
98464>>>>>            Unlock
98465>>>>>>
98465>>>>>            End
98465>>>>>>
98465>>>>>        End
98465>>>>>>
98465>>>>>
98465>>>>>        Close CodeMast
98466>>>>>        Close CodeType
98467>>>>>
98467>>>>>        Function_Return (Err = False)
98468>>>>>    End_Function
98469>>>>>
98469>>>>>    // Changes values in CodeType & CodeMast - From type value To type value. It first changes the type value in
98469>>>>>    // CodeType and then spins through all CodeMast records to change all related records.
98469>>>>>    Function UtilCodeMasterChangeValue String sFromValue String sToValue Returns Boolean
98471>>>>>        Boolean bFound
98471>>>>>
98471>>>>>        Move False to Err
98472>>>>>        Open CodeMast
98474>>>>>        Open CodeType
98476>>>>>
98476>>>>>        Clear CodeType
98477>>>>>        Move sFromValue to CODETYPE.Type
98478>>>>>        Find eq CODETYPE.Type
98479>>>>>>
98479>>>>>        If (Found = True) Begin
98481>>>>>            Reread CODETYPE
98485>>>>>                Move sToValue to CODETYPE.Type
98486>>>>>                SaveRecord CODETYPE
98487>>>>>            Unlock
98488>>>>>>
98488>>>>>        End
98488>>>>>>
98488>>>>>
98488>>>>>        Clear CODEMAST
98489>>>>>        Find gt CODEMAST by Recnum
98490>>>>>>
98490>>>>>        While (Found = True)
98494>>>>>            Move (Trim(Uppercase(CODEMAST.Type) = Trim(Uppercase(sFromValue)))) to bFound
98495>>>>>            If (bFound = True) Begin
98497>>>>>                Reread CODEMAST
98501>>>>>                    Move sToValue to CODEMAST.Type
98502>>>>>                    SaveRecord CODEMAST
98503>>>>>                Unlock
98504>>>>>>
98504>>>>>            End
98504>>>>>>
98504>>>>>            Find gt CODEMAST by Recnum
98505>>>>>>
98505>>>>>        Loop
98506>>>>>>
98506>>>>>
98506>>>>>        Close CodeMast
98507>>>>>        Close CodeType
98508>>>>>
98508>>>>>        Function_Return (Err = False)
98509>>>>>    End_Function
98510>>>>>
98510>>>>>    // Removes a value from CodeMast. Pass the sTypeValue and the sValue2 to remove.
98510>>>>>    Function UtilCodeMasterRemoveValue String sTypeValue String sValue2 Returns Boolean
98512>>>>>        Boolean bFound
98512>>>>>
98512>>>>>        Move False to Err
98513>>>>>        Open CodeMast
98515>>>>>
98515>>>>>        Clear CODEMAST
98516>>>>>        Move sTypeValue to CODEMAST.Type
98517>>>>>        Move sValue2    to CODEMAST.Code
98518>>>>>        Find eq CODEMAST.Code
98519>>>>>>
98519>>>>>        Move (Found = True) to bFound
98520>>>>>        If (bFound = True) Begin
98522>>>>>            Delete CODEMAST
98523>>>>>        End
98523>>>>>>
98523>>>>>
98523>>>>>        Close CodeMast
98524>>>>>
98524>>>>>        Function_Return (Err = False)
98525>>>>>    End_Function
98526>>>>>
98526>>>>>    Function UtilTableCreateCodeMastCodeTypeIntFiles String sDataPath Returns Boolean
98528>>>>>        Boolean bRecnum bToAnsi
98528>>>>>        Integer iCh
98528>>>>>        String sFileName sDriverID sConnectionID sSchemaName sANSI_OEM
98528>>>>>
98528>>>>>        If (Trim(sDataPath) = "") Begin
98530>>>>>            Function_Return False
98531>>>>>        End
98531>>>>>>
98531>>>>>
98531>>>>>        Move False to Err
98532>>>>>        Get psDriverID     to sDriverID
98533>>>>>        Get psConnectionID to sConnectionID
98534>>>>>        Get psSchema       to sSchemaName
98535>>>>>        Get True           to bRecnum
98536>>>>>        Get pbToANSI       to bToAnsi
98537>>>>>        Move CS_ANSI_Txt to sANSI_OEM
98538>>>>>        If (bToAnsi = False) Begin
98540>>>>>            Move CS_OEM_Txt to sANSI_OEM
98541>>>>>        End
98541>>>>>>
98541>>>>>
98541>>>>>        Get vFolderFormat sDataPath to sDataPath
98542>>>>>        Move "CodeMast.int"         to sFileName
98543>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
98544>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
98547>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
98550>>>>>            Writeln channel iCh ("DATABASE_NAME CODEMAST")
98553>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
98556>>>>>            Writeln channel iCh ("")
98559>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
98562>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
98565>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
98568>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
98571>>>>>            Writeln channel iCh ("")
98574>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
98577>>>>>            Writeln channel iCh ("INDEX_NAME CODEMAST001_PK")
98580>>>>>            Writeln channel iCh ("")
98583>>>>>        Send Seq_Close_Channel iCh
98584>>>>>
98584>>>>>        Get vFolderFormat sDataPath to sDataPath
98585>>>>>        Move "CodeType.int"         to sFileName
98586>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
98587>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
98590>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
98593>>>>>            Writeln channel iCh ("DATABASE_NAME CODETYPE")
98596>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
98599>>>>>            Writeln channel iCh ("")
98602>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
98605>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
98608>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
98611>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
98614>>>>>            Writeln channel iCh ("")
98617>>>>>            Writeln channel iCh ("INDEX_NUMBER 0")
98620>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE000")
98623>>>>>            Writeln channel iCh ("")
98626>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
98629>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE001_PK")
98632>>>>>            Writeln channel iCh ("")
98635>>>>>        Send Seq_Close_Channel iCh
98636>>>>>
98636>>>>>        Function_Return (Err = False)
98637>>>>>    End_Function
98638>>>>>
98638>>>>>    // * Dummy function for the Studio's Code Explorer *
98638>>>>>    Function OTHER_UTILITY_FUNCTIONS Returns Boolean
98640>>>>>        Function_Return False
98641>>>>>    End_Function
98642>>>>>
98642>>>>>    // Check if the file exists in the Data folder,
98642>>>>>    // else creates it from memory as it has been compiled into the program as a resource:
98642>>>>>    Function UtilCheckCreateIfFileExists String sFileName String sResourceName Boolean bDataFile Returns Boolean
98644>>>>>        String sPath sDataPath
98644>>>>>        Boolean bExists
98644>>>>>
98644>>>>>        Get psDataPathFirstPart to sPath
98645>>>>>        Move (sPath + sFileName) to sFileName
98646>>>>>        Get vFilePathExists sFileName to bExists
98647>>>>>
98647>>>>>        If (bExists = False) Begin
98649>>>>>            // Read from memory & create file on disk.
98649>>>>>            Send SqlUtilCreateFileFromMemory sResourceName sFileName
98650>>>>>            Get vFilePathExists sFileName to bExists
98651>>>>>        End
98651>>>>>>
98651>>>>>        Function_Return bExists
98652>>>>>    End_Function
98653>>>>>
98653>>>>>    Function UtilSqlColumnTypeToDataFlexType String sDriverID Integer iDbType Integer iDataType Integer iLength Returns Integer
98655>>>>>        tColumnType RetvalType
98655>>>>>        tColumnType RetvalType
98655>>>>>        Integer iRetval
98655>>>>>
98655>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
98656>>>>>        Move RetvalType.iDataFlexType to iRetval
98657>>>>>        If (RetvalType.iDataFlexType = DF_TEXT) Begin
98659>>>>>            If (iLength <= 255) Begin
98661>>>>>                Move DF_ASCII to iRetval
98662>>>>>            End
98662>>>>>>
98662>>>>>        End
98662>>>>>>
98662>>>>>        Function_Return iRetval
98663>>>>>    End_Function       
98664>>>>>    
98664>>>>>    Function UtilDataFlexDataTypeToString Integer iDataType Returns String
98666>>>>>        String sRetval 
98666>>>>>
98666>>>>>        Case Begin
98666>>>>>            Case (iDataType = DF_ASCII)
98668>>>>>                Move "DF_ASCII" to sRetval
98669>>>>>                Case Break
98670>>>>>            Case (iDataType = DF_BCD)
98673>>>>>                Move "DF_BCD" to sRetval
98674>>>>>                Case Break
98675>>>>>            Case (iDataType = DF_BINARY)
98678>>>>>                Move "DF_BINARY" to sRetval
98679>>>>>                Case Break
98680>>>>>            Case (iDataType = DF_DATE)
98683>>>>>                Move "DF_DATE" to sRetval
98684>>>>>                Case Break
98685>>>>>            Case (iDataType = DF_DATETIME)
98688>>>>>                Move "DF_DATETIME" to sRetval
98689>>>>>                Case Break
98690>>>>>            Case (iDataType = DF_TEXT)
98693>>>>>                Move "DF_TEXT" to sRetval
98694>>>>>                Case Break
98695>>>>>            Case Else
98695>>>>>                Move "" to sRetval
98696>>>>>        Case End
98696>>>>>
98696>>>>>        Function_Return sRetval
98697>>>>>    End_Function
98698>>>>>
98698>>>>>    // The default value used for a datatype as specified in the driver int file.
98698>>>>>    Function UtilDataTypeDefaultValue String sDriverID Integer iDbType Integer iDataType Returns String
98700>>>>>        String sRetval sServer
98700>>>>>        tColumnType RetvalType
98700>>>>>        tColumnType RetvalType
98700>>>>>        Integer iDriver iDataFlexType
98700>>>>>        Handle hDatabase
98700>>>>>
98700>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
98701>>>>>        Move RetvalType.iDataFlexType to iDataFlexType
98702>>>>>        Get DriverIndex sDriverID to iDriver
98703>>>>>        Get psServer to sServer
98704>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
98705>>>>>        If (hDatabase = 0) Begin
98707>>>>>            Function_Return ""
98708>>>>>        End
98708>>>>>>
98708>>>>>
98708>>>>>        Case Begin
98708>>>>>            Case (iDataFlexType = DF_ASCII)
98710>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_ASCII     of iDriver hDatabase to sRetval
98713>>>>>                Case Break
98714>>>>>            Case (iDataFlexType = DF_BCD)
98717>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_NUMERIC   of iDriver hDatabase to sRetval
98720>>>>>                Case Break
98721>>>>>            Case (iDataFlexType = DF_BINARY)
98724>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_BINARY    of iDriver hDatabase to sRetval
98727>>>>>                Case Break
98728>>>>>            Case (iDataFlexType = DF_DATE)
98731>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE      of iDriver hDatabase to sRetval
98734>>>>>                Case Break
98735>>>>>            Case (iDataFlexType = DF_DATETIME)
98738>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME  of iDriver hDatabase to sRetval
98741>>>>>                Case Break
98742>>>>>            Case (iDataFlexType = DF_TEXT)
98745>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_TEXT      of iDriver hDatabase to sRetval
98748>>>>>                Case Break
98749>>>>>            Case Else
98749>>>>>                Move "" to sRetval
98750>>>>>        Case End
98750>>>>>
98750>>>>>        Function_Return sRetval
98751>>>>>    End_Function
98752>>>>>
98752>>>>>    Procedure Set Df_Database_Default_Default_Date_DUF String sDateValue
98754>>>>>        String sDriverID sServer
98754>>>>>        tColumnType RetvalType
98754>>>>>        tColumnType RetvalType
98754>>>>>        Integer iDbType iDriver
98754>>>>>        Handle hDatabase
98754>>>>>
98754>>>>>        Get psDriverID to sDriverID
98755>>>>>        Get piDbType   to iDbType
98756>>>>>        Get DriverIndex sDriverID to iDriver
98757>>>>>        Get psServer to sServer
98758>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
98759>>>>>        If (hDatabase = 0) Begin
98761>>>>>            Error DFERR_PROGRAM "Could not change the Default Date Value. Could not get a handle to the database."
98762>>>>>>
98762>>>>>            Procedure_Return
98763>>>>>        End
98763>>>>>>
98763>>>>>
98763>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE of iDriver hDatabase to sDateValue
98766>>>>>
98766>>>>>    End_Procedure
98767>>>>>
98767>>>>>    Procedure Set Df_Database_Default_Default_Datetime_DUF String sDateValue
98769>>>>>        String sDriverID sServer
98769>>>>>        tColumnType RetvalType
98769>>>>>        tColumnType RetvalType
98769>>>>>        Integer iDbType iDriver
98769>>>>>        Handle hDatabase
98769>>>>>
98769>>>>>        Get psDriverID to sDriverID
98770>>>>>        Get piDbType   to iDbType
98771>>>>>        Get DriverIndex sDriverID to iDriver
98772>>>>>        Get psServer to sServer
98773>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
98774>>>>>        If (hDatabase = 0) Begin
98776>>>>>            Error DFERR_PROGRAM "Could not change the Default DateTime Value. Could not get a handle to the database."
98777>>>>>>
98777>>>>>            Procedure_Return
98778>>>>>        End
98778>>>>>>
98778>>>>>
98778>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME of iDriver hDatabase to sDateValue
98781>>>>>
98781>>>>>    End_Procedure
98782>>>>>
98782>>>>>    // Returns a struct array with the default column types for the SQL back-end and how they
98782>>>>>    // are mapped to the standard DataFlex data types.
98782>>>>>    // The DataFlex data types are: "ASCII", "BINARY", "DATE", "DATETIME", "NUMERIC" and "TEXT".
98782>>>>>    Function UtilDefaultSqlTypeMappings String sDriverID Integer iDbType Returns tColumnType[]
98784>>>>>        tColumnType[] ColumnTypeArray EmptyArray
98784>>>>>        tColumnType[] ColumnTypeArray EmptyArray
98786>>>>>        String sDataType
98786>>>>>        Integer iDataType iDriverID iCount
98786>>>>>        Boolean bSQLDriver
98786>>>>>
98786>>>>>        Move 0 to iCount
98787>>>>>        Get DriverIndex sDriverID to iDriverID
98788>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
98789>>>>>        If (bSQLDriver = False) Begin
98791>>>>>            Function_Return EmptyArray
98792>>>>>        End
98792>>>>>>
98792>>>>>
98792>>>>>        // DF_ASCII
98792>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
98794>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
98797>>>>>        End
98797>>>>>>
98797>>>>>        Else Begin
98798>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
98801>>>>>        End
98801>>>>>>
98801>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
98802>>>>>        Move DF_ASCII    to ColumnTypeArray[iCount].iDataFlexType
98803>>>>>        Move "ASCII"     to ColumnTypeArray[iCount].sDataFlexType
98804>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
98805>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
98806>>>>>        Increment iCount
98807>>>>>
98807>>>>>        // DF_BINARY
98807>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
98809>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
98812>>>>>        End
98812>>>>>>
98812>>>>>        Else Begin
98813>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
98816>>>>>        End
98816>>>>>>
98816>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
98817>>>>>        Move DF_BINARY   to ColumnTypeArray[iCount].iDataFlexType
98818>>>>>        Move "Binary"    to ColumnTypeArray[iCount].sDataFlexType
98819>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
98820>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
98821>>>>>        Increment iCount
98822>>>>>
98822>>>>>        // DF_DATE
98822>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
98824>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
98827>>>>>        End
98827>>>>>>
98827>>>>>        Else Begin
98828>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
98831>>>>>        End
98831>>>>>>
98831>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
98832>>>>>        Move DF_DATE     to ColumnTypeArray[iCount].iDataFlexType
98833>>>>>        Move "Date"      to ColumnTypeArray[iCount].sDataFlexType
98834>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
98835>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
98836>>>>>        Increment iCount
98837>>>>>
98837>>>>>        // DF_DATETIME
98837>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
98839>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
98842>>>>>        End
98842>>>>>>
98842>>>>>        Else Begin
98843>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
98846>>>>>        End
98846>>>>>>
98846>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
98847>>>>>        Move DF_DATETIME to ColumnTypeArray[iCount].iDataFlexType
98848>>>>>        Move "DateTime"  to ColumnTypeArray[iCount].sDataFlexType
98849>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
98850>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
98851>>>>>        Increment iCount
98852>>>>>
98852>>>>>        // DF_NUMERIC
98852>>>>>        // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
98852>>>>>        // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
98852>>>>>        // we make them here all "Numeric"...
98852>>>>>        Case Begin
98852>>>>>            Case (sDriverID = MSSQLDRV_ID)
98854>>>>>                Move SQL_NUMERIC to iDataType
98855>>>>>                Move "numeric"   to sDataType
98856>>>>>                Case Break
98857>>>>>            Case (sDriverID = DB2_DRV_ID)
98860>>>>>                Move SQL_NUMERIC to iDataType
98861>>>>>                Move "NUMERIC"   to sDataType
98862>>>>>                Case Break
98863>>>>>            Case (sDriverID = SQLFLEX)
98866>>>>>                Move eSQLServer_NUMERIC to iDataType
98867>>>>>                Move "numeric"   to sDataType
98868>>>>>                Case Break
98869>>>>>            Case (sDriverID = MDSMySQL)
98872>>>>>                Move eMySQL_DECIMAL to iDataType
98873>>>>>                Move "decimal"   to sDataType
98874>>>>>                Case Break
98875>>>>>            Case (sDriverID = ORAFLEX)
98878>>>>>                Move eOracle_NUMBER to iDataType
98879>>>>>                Move "NUMBER"   to sDataType
98880>>>>>                Case Break
98881>>>>>            Case (sDriverID = MDSPgSQL)
98884>>>>>                Move ePgSQL_FLOAT4 to iDataType
98885>>>>>                Move "decimal"   to sDataType
98886>>>>>                Case Break
98887>>>>>            Case Else
98887>>>>>                Move DF_BCD      to iDataType
98888>>>>>                Move "Numeric"   to sDataType
98889>>>>>        Case End
98889>>>>>        Move DF_BCD      to ColumnTypeArray[iCount].iDataFlexType
98890>>>>>        Move "Numeric"   to ColumnTypeArray[iCount].sDataFlexType
98891>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
98892>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
98893>>>>>        Increment iCount
98894>>>>>
98894>>>>>        // DF_TEXT
98894>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
98896>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
98899>>>>>        End
98899>>>>>>
98899>>>>>        Else Begin
98900>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
98903>>>>>        End
98903>>>>>>
98903>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
98904>>>>>        Move DF_TEXT     to ColumnTypeArray[iCount].iDataFlexType
98905>>>>>        Move "Text"      to ColumnTypeArray[iCount].sDataFlexType
98906>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
98907>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
98908>>>>>
98908>>>>>        Function_Return ColumnTypeArray
98909>>>>>    End_Function
98910>>>>>
98910>>>>>    Function UtilDFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
98912>>>>>        tColumnType[] ColumnTypeArray
98912>>>>>        tColumnType[] ColumnTypeArray
98913>>>>>        tColumnType   ColumnType
98913>>>>>        tColumnType   ColumnType
98913>>>>>        Integer iCount iSize
98913>>>>>
98913>>>>>        Get UtilDefaultSqlTypeMappings sDriverID iDbType iType to ColumnTypeArray
98914>>>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
98915>>>>>        Decrement iSize
98916>>>>>
98916>>>>>        for iCount from 0 to iSize
98922>>>>>>
98922>>>>>            If (iType = ColumnTypeArray[iCount].iDataFlexType) Begin
98924>>>>>                Move ColumnTypeArray[iCount].bCanEditSize   to ColumnType.bCanEditSize
98925>>>>>                Move ColumnTypeArray[iCount].iDataFlexType  to ColumnType.iDataFlexType
98926>>>>>                Move ColumnTypeArray[iCount].iSQLType       to ColumnType.iSQLType
98927>>>>>                Move ColumnTypeArray[iCount].sDataFlexType  to ColumnType.sDataFlexType
98928>>>>>                Move ColumnTypeArray[iCount].sPrecision     to ColumnType.sPrecision
98929>>>>>                Move ColumnTypeArray[iCount].sSQLType       to ColumnType.sSQLType
98930>>>>>                Move iSize to iCount
98931>>>>>            End
98931>>>>>>
98931>>>>>        Loop
98932>>>>>>
98932>>>>>
98932>>>>>        Function_Return ColumnType
98933>>>>>    End_Function
98934>>>>>
98934>>>>>    // Returns a struct with the default column types for the SQL back-end and how they
98934>>>>>    // are mapped to a DUF data type.
98934>>>>>    Function UtilDUFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
98936>>>>>        tColumnType ColumnType
98936>>>>>        tColumnType ColumnType
98936>>>>>        String sDataType
98936>>>>>        Integer iDriverID iCount
98936>>>>>
98936>>>>>        Move 0 to iCount
98937>>>>>        Get DriverIndex sDriverID to iDriverID
98938>>>>>
98938>>>>>        Case Begin
98938>>>>>            // DF_ASCII
98938>>>>>            Case (iType = DF_ASCII_DUF)
98940>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
98942>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
98945>>>>>                End
98945>>>>>>
98945>>>>>                Else Begin
98946>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
98949>>>>>                End
98949>>>>>>
98949>>>>>                Move DF_ASCII    to ColumnType.iDataFlexType
98950>>>>>                Move "ASCII"     to ColumnType.sDataFlexType
98951>>>>>                Move sDataType   to ColumnType.sSQLType
98952>>>>>                Move DF_ASCII    to ColumnType.iSQLType
98953>>>>>                Move False       to ColumnType.bCanEditSize
98954>>>>>                Case Break
98955>>>>>
98955>>>>>            // DF_BINARY
98955>>>>>            Case (iType = DF_BINARY_DUF)
98958>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
98960>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
98963>>>>>                End
98963>>>>>>
98963>>>>>                Else Begin
98964>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
98967>>>>>                End
98967>>>>>>
98967>>>>>                Move DF_BINARY   to ColumnType.iDataFlexType
98968>>>>>                Move "Binary"    to ColumnType.sDataFlexType
98969>>>>>                Move sDataType   to ColumnType.sSQLType
98970>>>>>                Move DF_BINARY   to ColumnType.iSQLType
98971>>>>>                Move False       to ColumnType.bCanEditSize
98972>>>>>                Case Break
98973>>>>>
98973>>>>>            // DF_DATE
98973>>>>>            Case (iType = DF_DATE_DUF)
98976>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
98978>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
98981>>>>>                End
98981>>>>>>
98981>>>>>                Else Begin
98982>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
98985>>>>>                End
98985>>>>>>
98985>>>>>                Move DF_DATE     to ColumnType.iDataFlexType
98986>>>>>                Move "Date"      to ColumnType.sDataFlexType
98987>>>>>                Move sDataType   to ColumnType.sSQLType
98988>>>>>                Move DF_DATE     to ColumnType.iSQLType
98989>>>>>                Move True        to ColumnType.bCanEditSize
98990>>>>>                Case Break
98991>>>>>
98991>>>>>            // DF_DATETIME
98991>>>>>            Case (iType = DF_DATETIME_DUF)
98994>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
98996>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
98999>>>>>                End
98999>>>>>>
98999>>>>>                Else Begin
99000>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
99003>>>>>                End
99003>>>>>>
99003>>>>>                Move DF_DATETIME to ColumnType.iDataFlexType
99004>>>>>                Move "DateTime"  to ColumnType.sDataFlexType
99005>>>>>                Move sDataType   to ColumnType.sSQLType
99006>>>>>                Move DF_DATETIME to ColumnType.iSQLType
99007>>>>>                Move True        to ColumnType.bCanEditSize
99008>>>>>                Case Break
99009>>>>>
99009>>>>>            // DF_NUMERIC
99009>>>>>            // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
99009>>>>>            // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
99009>>>>>            // we make them here all "Numeric"...
99009>>>>>            // If (sDriverID = ODBC_DRV_ID) Begin
99009>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
99009>>>>>            // End
99009>>>>>            // Else Begin
99009>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
99009>>>>>            // End
99009>>>>>            // ToDo: How should we find the best "Numeric" data type here?
99009>>>>>            Case (iType = DF_BCD_DUF)
99012>>>>>                Move DF_BCD      to ColumnType.iDataFlexType
99013>>>>>                Move "Numeric"   to ColumnType.sDataFlexType
99014>>>>>                Move "Numeric"   to ColumnType.sSQLType
99015>>>>>                Move SQL_NUMERIC to ColumnType.iSQLType
99016>>>>>                Move False       to ColumnType.bCanEditSize
99017>>>>>                Case Break
99018>>>>>
99018>>>>>            // DF_TEXT
99018>>>>>            Case (iType = DF_TEXT_DUF)
99021>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
99023>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
99026>>>>>                End
99026>>>>>>
99026>>>>>                Else Begin
99027>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
99030>>>>>                End
99030>>>>>>
99030>>>>>                Move DF_TEXT     to ColumnType.iDataFlexType
99031>>>>>                Move "Text"      to ColumnType.sDataFlexType
99032>>>>>                Move sDataType   to ColumnType.sSQLType
99033>>>>>                Move DF_TEXT     to ColumnType.iSQLType
99034>>>>>                Move False       to ColumnType.bCanEditSize
99035>>>>>                Case Break
99036>>>>>
99036>>>>>            Case Else
99036>>>>>                Move -1999       to ColumnType.iDataFlexType
99037>>>>>                Move "Undefined" to ColumnType.sDataFlexType
99038>>>>>                Move "Undefined" to ColumnType.sSQLType
99039>>>>>                Move -1999       to ColumnType.iSQLType
99040>>>>>                Move True        to ColumnType.bCanEditSize
99041>>>>>
99041>>>>>        Case End
99041>>>>>
99041>>>>>        Function_Return ColumnType
99042>>>>>    End_Function
99043>>>>>
99043>>>>>    Function UtilDeleteCacheFile String sTableName Returns Boolean
99045>>>>>        String sDataPath sDriverID
99045>>>>>        Boolean bMertechDriver bOK
99045>>>>>        Integer iPos
99045>>>>>
99045>>>>>        If (sTableName contains ".") Begin
99047>>>>>            Move (Pos(".", sTableName)) to iPos
99048>>>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
99049>>>>>        End
99049>>>>>>
99049>>>>>
99049>>>>>        Get psDriverID to sDriverID
99050>>>>>        Get psDataPathFirstPart to sDataPath
99051>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
99052>>>>>        // First delete the cache file:
99052>>>>>        If (bMertechDriver = False) Begin
99054>>>>>            Get vDeleteFile (sDataPath + sTableName + ".cch") to bOK
99055>>>>>        End
99055>>>>>>
99055>>>>>        Else Begin
99056>>>>>            Get _MertechDeleteTDFile sTableName to bOK
99057>>>>>        End
99057>>>>>>
99057>>>>>
99057>>>>>        Function_Return bOK
99058>>>>>    End_Function
99059>>>>>
99059>>>>>    // Changes source code files.
99059>>>>>    // Pass a file name with full path and a value to search for, together with the value
99059>>>>>    // to change to. Can e.g. be used for changing all .int files from using a fixed server name,
99059>>>>>    // to use a Connection ID.
99059>>>>>    // Sample: Get UtilChangeSourceCodeLine "C:\DataFlex 18.2 Examples\Order Entry\Data\Order.int" "SERVER_NAME SERVER=(local)\SQLEXPRESS1" "SERVER_NAME DFCONNID=ChinookDb"
99059>>>>>    // Pass "True" for the bShowResult if you want to see the result while it works. Showln will then be used for output
99059>>>>>    // Returns True if no errors occured.
99059>>>>>    Function UtilChangeSourceCodeLine String sFileName String sChangeFrom String sChangeTo Boolean bShowResult Returns Boolean
99061>>>>>        Integer iCh iRow iItems iCount
99061>>>>>        String sValue sRow
99061>>>>>        String[] sFileArray
99062>>>>>        Boolean bExists bIsActive
99062>>>>>
99062>>>>>        Move False to Err
99063>>>>>        Move 0 to iRow
99064>>>>>
99064>>>>>        If (ghoStatusPanel <> 0) Begin
99066>>>>>            Get Active_state of ghoStatusPanel to bIsActive
99067>>>>>        End
99067>>>>>>
99067>>>>>
99067>>>>>        Get vFilePathExists sFileName to bExists
99068>>>>>        If (bExists = False) Begin
99070>>>>>            If (bShowResult = True) Begin
99072>>>>>                If (bIsActive = True) Begin
99074>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("File does not exist:" * String(sFileName))
99075>>>>>                End
99075>>>>>>
99075>>>>>                Else Begin
99076>>>>>                    Showln "File does not exist: " sFileName
99079>>>>>                End
99079>>>>>>
99079>>>>>            End
99079>>>>>>
99079>>>>>            Function_Return False
99080>>>>>        End
99080>>>>>>
99080>>>>>
99080>>>>>        Get Seq_Open_Input_Channel sFileName to iCh
99081>>>>>        If (iCh < 1) Begin
99083>>>>>            Function_Return False
99084>>>>>        End
99084>>>>>>
99084>>>>>
99084>>>>>        If (bShowResult = True) Begin
99086>>>>>            If (ghoStatusPanel <> 0) Begin
99088>>>>>                Get Active_state of ghoStatusPanel to bIsActive
99089>>>>>                If (bIsActive = True) Begin
99091>>>>>                    Set Message_Text of ghoStatusPanel to sFileName
99092>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("sChangeFrom =" * String(sChangeFrom) * "sChangeTo =" * String(sChangeTo))
99093>>>>>                    Send DoAdvance of ghoProgressBar
99094>>>>>                End
99094>>>>>>
99094>>>>>            End
99094>>>>>>
99094>>>>>            Else Begin
99095>>>>>                Showln ""
99097>>>>>                Showln "sFileName = " sFileName
99100>>>>>                Showln "sChangeFrom = " sChangeFrom " sChangeTo = " sChangeTo
99105>>>>>            End
99105>>>>>>
99105>>>>>        End
99105>>>>>>
99105>>>>>
99105>>>>>        While (not(SeqEof))
99109>>>>>            Readln channel iCh sRow
99111>>>>>            If (Uppercase(sRow) contains Uppercase(sChangeFrom)) Begin
99113>>>>>//                If (bShowResult = True) Begin
99113>>>>>//                    If (bIsActive = True) Begin
99113>>>>>//                        Send Update_StatusPanel of ghoStatusPanel ("Changed from:" * String(sRow) * "to:" * String(sChangeTo))
99113>>>>>//                    End
99113>>>>>//                    Else Begin
99113>>>>>//                        Showln "Changed from: " sRow " to: " sChangeTo
99113>>>>>//                    End
99113>>>>>//                End
99113>>>>>                // Change the whole line to the new connection id:
99113>>>>>                Move sChangeTo to sRow
99114>>>>>                // Move (Replaces(sChangeFrom, sRow, sChangeTo)) to sValue
99114>>>>>            End
99114>>>>>>
99114>>>>>            Move sRow to sFileArray[iRow]
99115>>>>>            Increment iRow
99116>>>>>        End
99117>>>>>>
99117>>>>>        Send Seq_Close_Channel iCh
99118>>>>>
99118>>>>>        Sleep 1 // Wait for Windows to close the file
99119>>>>>
99119>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
99120>>>>>        If (iCh < 1) Begin
99122>>>>>            Function_Return False
99123>>>>>        End
99123>>>>>>
99123>>>>>        Move (SizeOfArray(sFileArray)) to iItems
99124>>>>>        Decrement iItems
99125>>>>>
99125>>>>>        For iCount from 0 to iItems
99131>>>>>>
99131>>>>>            Move sFileArray[iCount] to sValue
99132>>>>>            Writeln channel iCh sValue
99135>>>>>        Loop
99136>>>>>>
99136>>>>>        Send Seq_Close_Channel iCh
99137>>>>>
99137>>>>>        Function_Return (Err = False)
99138>>>>>    End_Function
99139>>>>>
99139>>>>>    // This might be needed by API-methods when a connection id is to be used and
99139>>>>>    // the connection ID hasn't been established with the driver's CLI interface.
99139>>>>>    // NOTE: Only applicable for DAW drivers, as Mertech drivers doesn't use connection ID's.
99139>>>>>    Function UtilCreateConnectionID String sConnectionID Returns Boolean
99141>>>>>        String sConnectionString sDriverID
99141>>>>>        Boolean bOK bSilent bDawDriver
99141>>>>>        Handle hoCLI
99141>>>>>
99141>>>>>        Move False to bOK
99142>>>>>        Get psDriverID to sDriverID
99143>>>>>        Get IsDAWSQLDriver sDriverID to bDawDriver
99144>>>>>        If (bDawDriver = False) Begin
99146>>>>>            Error DFERR_PROGRAM "The UtilCreateConnectionID function is only available for DAW drivers. (Not Mertech)."
99147>>>>>>
99147>>>>>            Function_Return False
99148>>>>>        End
99148>>>>>>
99148>>>>>
99148>>>>>        Get psConnectionString to sConnectionString
99149>>>>>        Get pbSilentLogin      to bSilent
99150>>>>>
99150>>>>>        Get phoCLIHandler to hoCLI
99151>>>>>        If (hoCLI <> 0) Begin
99153>>>>>            Set psDriverID of hoCLI to sDriverID
99154>>>>>            Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to bOK
99155>>>>>        End
99155>>>>>>
99155>>>>>
99155>>>>>        Function_Return (bOK = False)
99156>>>>>    End_Function
99157>>>>>
99157>>>>>    // This message creates an error log in the "Home" folder named "SQLErrorLog.txt",
99157>>>>>    // and opens it in "notepad.exe".
99157>>>>>    // Note: This is _not_ used by the cDbUpdateHandler & cDbUpdateVersion classes!
99157>>>>>    //       Instead the cDbUpdateLogFile's WriteErrorLog & ShowErrorLog are used.
99157>>>>>    Procedure UtilShowErrorList
99159>>>>>        tSqlErrorArray aSqlErrorArray
99159>>>>>        tSqlErrorArray aSqlErrorArray
99159>>>>>        Integer iRows iCount iCh iErrorNum
99159>>>>>        String sPath sFileName sErrorTxt sStatement
99159>>>>>
99159>>>>>        Get psHome of (phoWorkspace(ghoApplication)) to sPath
99160>>>>>        Get vFolderFormat sPath to sPath
99161>>>>>        Move "SQLErrorLog.txt"  to sFileName
99162>>>>>        Get Seq_Open_Output_Channel (sPath + sFileName) to iCh
99163>>>>>            Get paSqlErrorArray to aSqlErrorArray
99164>>>>>            Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iRows
99165>>>>>            If (iRows > 0) Begin
99167>>>>>                Decrement iRows
99168>>>>>                for iCount from 0 to iRows
99174>>>>>>
99174>>>>>                    Move aSqlErrorArray.sSqlErrorArray[iCount]      to sErrorTxt
99175>>>>>                    Move aSqlErrorArray.sSqlStatementArray[iCount]  to sStatement
99176>>>>>                    Move aSqlErrorArray.iSqlErrorArray[iCount]      to iErrorNum
99177>>>>>                    Writeln channel iCh "Error No: " iErrorNum " Error Text: " sErrorTxt
99183>>>>>                    Writeln channel iCh "SQL Statement: " sStatement
99187>>>>>                Loop
99188>>>>>>
99188>>>>>            End
99188>>>>>>
99188>>>>>        Send Seq_Close_Channel iCh
99189>>>>>
99189>>>>>        If (iRows > 0) Begin
99191>>>>>            Runprogram Shell Background (sPath + sFileName)
99192>>>>>        End
99192>>>>>>
99192>>>>>    End_Procedure
99193>>>>>
99193>>>>>    // For this to be returning a True value, the table number needs to be in the Filelist.cfg,
99193>>>>>    // and the table needs to exist as an SQL table.
99193>>>>>    Function UtilTableIsSql Handle hTable Returns Boolean
99195>>>>>        String sRootName sDriverID
99195>>>>>        Boolean bIsSQL
99195>>>>>
99195>>>>>        Move False to bIsSQL
99196>>>>>        If (hTable > 0) Begin
99198>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
99201>>>>>            Move (sRootName contains ":") to bIsSQL
99202>>>>>            If (bIsSQL = True) Begin
99204>>>>>                Get psDriverID to sDriverID
99205>>>>>                Get _TableNameOnly sRootName to sRootName
99206>>>>>                Get SqlUtilCheckIfTableNameExists sRootName sDriverID to bIsSQL
99207>>>>>            End
99207>>>>>>
99207>>>>>        End
99207>>>>>>
99207>>>>>
99207>>>>>        Function_Return bIsSQL
99208>>>>>    End_Function
99209>>>>>
99209>>>>>    Function UtilTableIsSqlByRootName String sRootName Returns Boolean
99211>>>>>        Boolean bIsSQL
99211>>>>>        Move (sRootName contains ":") to bIsSQL
99212>>>>>        Function_Return bIsSQL
99213>>>>>    End_Function
99214>>>>>
99214>>>>>
99214>>>>>    // Returns True if the passed hTable (filelist slot number) is an Alias table.
99214>>>>>    // An Alias file/table is a filelist number that share the same Physical filename
99214>>>>>    // but the Logical name is different.
99214>>>>>    // Note: If the table cannot be opened; the table is not considered to be an Alias.
99214>>>>>//    Function UtilTableIsAlias Handle hTable Returns Boolean
99214>>>>>//        String sPhysicalName sPhysicalNameCompare
99214>>>>>//        Boolean bWasOpen bOpened bOK
99214>>>>>//        Integer iCount
99214>>>>>//
99214>>>>>//        Move 0 to iCount
99214>>>>>//        Get_Attribute DF_FILE_OPENED of hTable to bWasOpen
99214>>>>>//        If (bWasOpen = False) Begin
99214>>>>>//            Open hTable
99214>>>>>//            Get_Attribute DF_FILE_OPENED of hTable to bOpened
99214>>>>>//            If (bOpened = False) Begin
99214>>>>>//                Function_Return False
99214>>>>>//            End
99214>>>>>//        End
99214>>>>>//
99214>>>>>//        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName
99214>>>>>//        Get _TableNameOnly sPhysicalName to sPhysicalName
99214>>>>>//        If (bWasOpen = False and bOpened = True) Begin
99214>>>>>//            Close hTable
99214>>>>>//        End
99214>>>>>//
99214>>>>>//        Move 0 to hTable
99214>>>>>//        Repeat
99214>>>>>//            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
99214>>>>>//            If (hTable > 0 and hTable <> 50) Begin
99214>>>>>//                Open hTable
99214>>>>>//                Get_Attribute DF_FILE_OPENED of hTable to bOpened
99214>>>>>//                If (bOpened = True) Begin
99214>>>>>//                    Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalNameCompare
99214>>>>>//                    Close hTable
99214>>>>>//                    Get _TableNameOnly sPhysicalNameCompare to sPhysicalNameCompare
99214>>>>>//                    If (Uppercase(sPhysicalName) = Uppercase(sPhysicalNameCompare)) Begin
99214>>>>>//                        Increment iCount
99214>>>>>//                    End
99214>>>>>//                End
99214>>>>>//            End
99214>>>>>//        Until (hTable = 0)
99214>>>>>//
99214>>>>>//        If (iCount > 1) Begin
99214>>>>>//            Function_Return True
99214>>>>>//        End
99214>>>>>//
99214>>>>>//        Function_Return False
99214>>>>>//    End_Function
99214>>>>>
99214>>>>>    Function UtilTableIsAlias Handle hTable Returns Boolean
99216>>>>>        String sPhysicalName sPhysicalNameCompare
99216>>>>>        Integer iCount iMaster iAlias iInTable
99216>>>>>
99216>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sPhysicalName
99219>>>>>        Get _TableNameOnly sPhysicalName to sPhysicalName
99220>>>>>        Move hTable to iInTable
99221>>>>>        Move 0 to hTable
99222>>>>>        Move 0 to iCount
99223>>>>>
99223>>>>>        Repeat
99223>>>>>>
99223>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
99226>>>>>            If (hTable > 0 and hTable <> 50) Begin
99228>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sPhysicalNameCompare
99231>>>>>                Get _TableNameOnly sPhysicalNameCompare to sPhysicalNameCompare
99232>>>>>                If (Uppercase(sPhysicalName) = Uppercase(sPhysicalNameCompare)) Begin
99234>>>>>
99234>>>>>                    If (iCount = 0) Begin
99236>>>>>                        Move hTable to iMaster
99237>>>>>                    End
99237>>>>>>
99237>>>>>                    If (iCount > 0) Begin
99239>>>>>                        Move hTable to iAlias
99240>>>>>                    End
99240>>>>>>
99240>>>>>                    Increment iCount
99241>>>>>                End
99241>>>>>>
99241>>>>>            End
99241>>>>>>
99241>>>>>        Until (hTable = 0)
99243>>>>>
99243>>>>>        If (iCount > 1) Begin
99245>>>>>            Function_Return (iInTable >= iAlias and iAlias > iMaster)
99246>>>>>        End
99246>>>>>>
99246>>>>>
99246>>>>>        Function_Return False
99247>>>>>    End_Function
99248>>>>>
99248>>>>>//    Function UtilTableIsAliasFdFile Handle hTable Returns Boolean
99248>>>>>//        String sDDSrcPath sDataPath sLogicalName
99248>>>>>//        Boolean bOK bExists
99248>>>>>//
99248>>>>>//        Get psDataPath  of (phoWorkspace(ghoApplication)) to sDataPath
99248>>>>>//        If (Right(sDataPath, 1) = "\") Begin
99248>>>>>//            Move (Left(sDataPath, (Length(sDataPath) -1))) to sDataPath
99248>>>>>//        End
99248>>>>>//        Move (StringFromRightOfChar(sDataPath, "\")) to sDDSrcPath
99248>>>>>//        Move (Replace(sDDSrcPath, sDataPath, ""))    to sDDSrcPath
99248>>>>>//        Move (sDDSrcPath + "DDSrc")                  to sDDSrcPath
99248>>>>>//        Get vFolderFormat sDDSrcPath                 to sDDSrcPath
99248>>>>>//
99248>>>>>//        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
99248>>>>>//        Get vFilePathExists (sDDSrcPath + sLogicalName + ".fd") to bExists
99248>>>>>//
99248>>>>>//        Function_Return bExists
99248>>>>>//    End_Function
99248>>>>>
99248>>>>>    // To Open a table with any driver.
99248>>>>>    // Note: If the driver is <> DATAFLEX_ID  - login credentials are used; it is then assumed
99248>>>>>    //       that the proper login properties has been setup properly with the cSQLConnections object.
99248>>>>>    //
99248>>>>>    // If the open command fails the Err flag will be reset to false, at the end of the function!
99248>>>>>    // The found flag is still used to indicate if the open was successful or not. The function
99248>>>>>    // returns a True if successful (table could be opened).
99248>>>>>    //
99248>>>>>    // Using the "Open As" syntax with drivers means that we don't need to rely on .int file settings.
99248>>>>>    // This is good because with DFConnectionID's those credentials doesn't need to be available in
99248>>>>>    // the .int file (and probably aren't). As long as the login properties of this object have been
99248>>>>>    // set properly we can open the table.
99248>>>>>    //
99248>>>>>    // DAW Driver Syntax:
99248>>>>>    //  <CKId>:<Schema>#<Table>@<ConnectString>|<Filename>.int
99248>>>>>    //  Now the @<ConnectString> can be followed by a pipe character '|' followed by the name of the INT file.
99248>>>>>    //  Doing so, the driver will apply the information from the .INT file to the passed direct Open String.
99248>>>>>    //  Note that when an INT file has been passed, it will skip the keyword DRIVER_NAME, SERVER_NAME,
99248>>>>>    //  DATABASE_NAME and SCHEMA_NAME from the INT file because those are supposed to be supplied in the String already.
99248>>>>>    //  Open mode; iMode = DF_SHARE or DF_EXCLUSIVE.
99248>>>>>    //
99248>>>>>    // DAW Driver Sample:
99248>>>>>    //   Open "MSSQLDRV:dbo#MyFile@SERVER=(local)\SQLEXPRESS;Trusted_Connection=yes;DATABASE=OrderEntry|options|intfile=MyFile.int"
99248>>>>>    //
99248>>>>>    // Mertech Driver Samples:
99248>>>>>    //   SQLFlex:   Open "sql_drv:\\<serverName>\<database>*<owner>*<tableName>=<numberFieds>" as table
99248>>>>>    //   MySQLFlex: Open "mdsmysql:\\<serverName>\<database>*<tableName>=<numberFieds>" as table
99248>>>>>    //   PgFlex:    Open "mdspgsql:\\<serverName>\<database>*<schema>*<tableName>=<numberFieds>" as table
99248>>>>>    //   ORAFlex:   Open "ora_drv:\\<serverName>\<owner>*<tableName>=<numberFieds>" as table
99248>>>>>    Function UtilTableOpen Integer hTable String sTableName Integer iMode Returns Boolean
99250>>>>>        String sDriverID sConnection sSchema sExt sTableNameShort sTableNameOrg
99250>>>>>        Boolean bOpen bMertechDriver bOK
99250>>>>>        tSQLConnection SQLConnection
99250>>>>>        tSQLConnection SQLConnection
99250>>>>>
99250>>>>>        Move sTableName to sTableNameOrg
99251>>>>>        If (hTable > 0) Begin
99253>>>>>            Send Ignore_Error of Error_Object_Id 20529
99254>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
99255>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
99256>>>>>            Open hTable
99258>>>>>            Send Trap_Error of Error_Object_Id 20529
99259>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
99260>>>>>            Send Trap_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
99261>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
99264>>>>>            If (bOpen = True) Begin
99266>>>>>                Function_Return True
99267>>>>>            End
99267>>>>>>
99267>>>>>        End
99267>>>>>>
99267>>>>>
99267>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
99268>>>>>        Move SQLConnection.sDriverID to sDriverID
99269>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
99270>>>>>        Move SQLConnection.sConnectionString to sConnection
99271>>>>>        Move SQLConnection.sSchema to sSchema
99272>>>>>        If (sSchema = "") Begin
99274>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
99275>>>>>        End
99275>>>>>>
99275>>>>>
99275>>>>>        // We need to remove the ".int" part of the table name because
99275>>>>>        // the table name after the "#" in the connection syntax below wants the
99275>>>>>        // "bare" table name without any extension.
99275>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
99277>>>>>            If (Lowercase(sTableName) contains ".int") Begin
99279>>>>>                Get ParseFileExtension sTableName to sExt
99280>>>>>                Move (Replace(("." + sExt), sTableName, "")) to sTableNameShort
99281>>>>>            End
99281>>>>>>
99281>>>>>            Else Begin
99282>>>>>                Move sTableName to sTableNameShort
99283>>>>>                Move (Append(sTableName, ".int")) to sTableName
99284>>>>>            End
99284>>>>>>
99284>>>>>            If (bMertechDriver = False) Begin
99286>>>>>                Move (sDriverID + ":" + sSchema + "#" + sTableNameShort + "@" + sConnection + "|options|intfile=" + sTableName) to sConnection
99287>>>>>                Move sConnection to sTableName
99288>>>>>            End
99288>>>>>>
99288>>>>>        End
99288>>>>>>
99288>>>>>
99288>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
99289>>>>>        Send Ignore_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
99290>>>>>        If (hTable = 0) Begin
99292>>>>>            Get NextFreeFilelistSlot to hTable
99293>>>>>        End
99293>>>>>>
99293>>>>>
99293>>>>>        Case Begin
99293>>>>>            Case (sDriverID = MSSQLDRV_ID)
99295>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
99295>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
99297>>>>>                    Open sTableName as hTable
99299>>>>>                End
99299>>>>>>
99299>>>>>                Else Begin
99300>>>>>                    Get OpenTableExclusive hTable to bOK
99301>>>>>                    If (bOK = False) Begin
99303>>>>>                        Function_Return False
99304>>>>>                    End
99304>>>>>>
99304>>>>>                End
99304>>>>>>
99304>>>>>                Case Break
99305>>>>>
99305>>>>>            Case (sDriverID = DB2_DRV_ID)
99308>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
99308>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
99310>>>>>                    Open sTableName as hTable
99312>>>>>                End
99312>>>>>>
99312>>>>>                Else Begin
99313>>>>>                    Get OpenTableExclusive hTable to bOK
99314>>>>>                    If (bOK = False) Begin
99316>>>>>                        Function_Return False
99317>>>>>                    End
99317>>>>>>
99317>>>>>                End
99317>>>>>>
99317>>>>>                Case Break
99318>>>>>
99318>>>>>            Case (sDriverID = ODBC_DRV_ID)
99321>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
99321>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
99323>>>>>                    Open sTableName as hTable
99325>>>>>                End
99325>>>>>>
99325>>>>>                Else Begin
99326>>>>>                    Get OpenTableExclusive hTable to bOK
99327>>>>>                    If (bOK = False) Begin
99329>>>>>                        Function_Return False
99330>>>>>                    End
99330>>>>>>
99330>>>>>                End
99330>>>>>>
99330>>>>>                Case Break
99331>>>>>
99331>>>>>            Case (sDriverID = SQLFLEX)
99334>>>>>                // ToDo: What is the <owner>? Same as Schema?
99334>>>>>                // SQLFlex:   Open "sql_drv:\\<serverName>\<database>*<owner>*<tableName>=<numberFieds>" as table
99334>>>>>                Move (SQLFLEX + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + SQLConnection.sSchema + "*" + sTableNameOrg) to sTableName
99335>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
99335>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
99337>>>>>                    Open sTableName as hTable
99339>>>>>                End
99339>>>>>>
99339>>>>>                Else Begin
99340>>>>>                    Get OpenTableExclusive hTable to bOK
99341>>>>>                    If (bOK = False) Begin
99343>>>>>                        Function_Return False
99344>>>>>                    End
99344>>>>>>
99344>>>>>                End
99344>>>>>>
99344>>>>>                Case Break
99345>>>>>
99345>>>>>            Case (sDriverID = MDSMySQL)
99348>>>>>                // MySQLFlex: Open "mdsmysql:\\<serverName>\<database>*<tableName>=<numberFieds>" as table
99348>>>>>                Move (MDSMySQL + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + "*" + sTableNameOrg) to sTableName
99349>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
99349>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
99351>>>>>                    Open sTableName as hTable
99353>>>>>                End
99353>>>>>>
99353>>>>>                Else Begin
99354>>>>>                    Get OpenTableExclusive hTable to bOK
99355>>>>>                    If (bOK = False) Begin
99357>>>>>                        Function_Return False
99358>>>>>                    End
99358>>>>>>
99358>>>>>                End
99358>>>>>>
99358>>>>>                Case Break
99359>>>>>
99359>>>>>            Case (sDriverID = MDSPgSQL)
99362>>>>>                // PgFlex: Open "mdspgsql:\\<serverName>\<database>*<schema>*<tableName>=<numberFieds>" as table
99362>>>>>                Move (MDSPgSQL + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + "*" + SQLConnection.sSchema + "*" + sTableNameOrg) to sTableName
99363>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
99363>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
99365>>>>>                    Open sTableName as hTable
99367>>>>>                End
99367>>>>>>
99367>>>>>                Else Begin
99368>>>>>                    Get OpenTableExclusive hTable to bOK
99369>>>>>                    If (bOK = False) Begin
99371>>>>>                        Function_Return False
99372>>>>>                    End
99372>>>>>>
99372>>>>>                End
99372>>>>>>
99372>>>>>                Case Break
99373>>>>>
99373>>>>>            Case (sDriverID = ORAFLEX)
99376>>>>>                // ToDo: What is the <owner>? Same as Schema?
99376>>>>>                // ORAFlex: Open "ora_drv:\\<serverName>\<owner>*<tableName>=<numberFieds>" as table
99376>>>>>                Move (ORAFLEX + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sSchema + "*" + sTableName) to sTableName
99377>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
99377>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
99379>>>>>                    Open sTableName as hTable
99381>>>>>                End
99381>>>>>>
99381>>>>>                Else Begin
99382>>>>>                    Get OpenTableExclusive hTable to bOK
99383>>>>>                    If (bOK = False) Begin
99385>>>>>                        Function_Return False
99386>>>>>                    End
99386>>>>>>
99386>>>>>                End
99386>>>>>>
99386>>>>>                Case Break
99387>>>>>
99387>>>>>            Case (sDriverID = DATAFLEX_ID)
99390>>>>>                If (sTableName <> "" and iMode <> DF_EXCLUSIVE) Begin
99392>>>>>                    Open sTableName as hTable
99394>>>>>                End
99394>>>>>>
99394>>>>>                Else If (iMode = DF_EXCLUSIVE) Begin
99397>>>>>                    Get OpenTableExclusive hTable to bOK
99398>>>>>                    If (bOK = False) Begin
99400>>>>>                        Function_Return False
99401>>>>>                    End
99401>>>>>>
99401>>>>>                End
99401>>>>>>
99401>>>>>                Else Begin
99402>>>>>                    Open hTable
99404>>>>>                End
99404>>>>>>
99404>>>>>                Case Break
99405>>>>>
99405>>>>>            // ToDo: Logic needs to be expanded for Mertech drivers!
99405>>>>>
99405>>>>>            Case Else
99405>>>>>                Error DFERR_PROGRAM ("Invalid driver:" * sDriverID)
99406>>>>>>
99406>>>>>        Case End
99406>>>>>
99406>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
99407>>>>>        Send Trap_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
99408>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
99410>>>>>            Move False to Found
99411>>>>>        End
99411>>>>>>
99411>>>>>        // If open failed, the Err is set to true,
99411>>>>>        // but we don't want that because it could end our loop.
99411>>>>>        Move False to Err
99412>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
99415>>>>>
99415>>>>>        Function_Return bOpen
99416>>>>>    End_Function
99417>>>>>
99417>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
99417>>>>>    // that the embedded .dat file exists on disk _or_ that the SQL table exists
99417>>>>>    // if it is an SQL table
99417>>>>>    Function UtilTableExists Handle hTable Returns Boolean
99419>>>>>        Boolean bExists bIsSQLTable
99419>>>>>        String sDataPath sRootName
99419>>>>>
99419>>>>>        Get UtilTableNumberIsInUse hTable to bExists
99420>>>>>        If (bExists = False) Begin
99422>>>>>            Function_Return False
99423>>>>>        End
99423>>>>>>
99423>>>>>
99423>>>>>        Move False to bIsSQLTable
99424>>>>>        If (hTable > 0) Begin
99426>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
99429>>>>>            Move (sRootName contains ":") to bIsSQLTable
99430>>>>>        End
99430>>>>>>
99430>>>>>        If (bIsSQLTable = True) Begin
99432>>>>>            Get UtilTableIsSQL hTable to bExists
99433>>>>>            Function_Return bExists
99434>>>>>        End
99434>>>>>>
99434>>>>>        Else Begin
99435>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
99436>>>>>            Get vFolderFormat sDataPath to sDataPath
99437>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
99438>>>>>        End
99438>>>>>>
99438>>>>>
99438>>>>>        Function_Return bExists
99439>>>>>    End_Function
99440>>>>>
99440>>>>>    // Pass a table handle
99440>>>>>    // Returns True if the table exists in filelist.cfg.
99440>>>>>    Function UtilTableNumberIsInUse Handle hCheckTable Returns Boolean
99442>>>>>        Handle hTable
99442>>>>>        Boolean bFound
99442>>>>>
99442>>>>>        Move False to bFound
99443>>>>>        Move 0 to hTable
99444>>>>>        Repeat
99444>>>>>>
99444>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
99447>>>>>            If (hTable > 0) Begin
99449>>>>>                If (hTable = hCheckTable) Begin
99451>>>>>                    Move True to bFound
99452>>>>>                End
99452>>>>>>
99452>>>>>            End
99452>>>>>>
99452>>>>>            If (bFound = True) ;                Break
99455>>>>>        Until (hTable = 0)
99457>>>>>
99457>>>>>        Function_Return (bFound = True)
99458>>>>>    End_Function
99459>>>>>
99459>>>>>    Function UtilDriverFromTableNumber Handle hTable Returns String
99461>>>>>        Boolean bOK bExists                              
99461>>>>>        String sDriverID
99461>>>>>        
99461>>>>>        Get UtilTableExists hTable to bExists
99462>>>>>        If (bExists = False) Begin
99464>>>>>            Function_Return ""
99465>>>>>        End
99465>>>>>>
99465>>>>>        Get OpenTableExclusive hTable to bOK
99466>>>>>        If (bOK = False) Begin
99468>>>>>            Function_Return ""
99469>>>>>        End 
99469>>>>>>
99469>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
99472>>>>>        
99472>>>>>        Function_Return sDriverID
99473>>>>>    End_Function        
99474>>>>>    
99474>>>>>    // Number of tables in Filelist.cfg. Returns integger
99474>>>>>    Function UtilFilelistNoOfTables Returns Integer
99476>>>>>        Handle hTable
99476>>>>>        Integer iRetval
99476>>>>>
99476>>>>>        Move 0 to hTable
99477>>>>>        Move 0 to iRetval
99478>>>>>
99478>>>>>        Repeat
99478>>>>>>
99478>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
99481>>>>>            If (hTable > 0) Begin
99483>>>>>                Increment iRetval
99484>>>>>            End
99484>>>>>>
99484>>>>>        Until (hTable = 0)
99486>>>>>
99486>>>>>        Function_Return iRetval
99487>>>>>    End_Function
99488>>>>>
99488>>>>>    Function UtilFilelistIsDataFlexTablesOnly Returns Boolean
99490>>>>>        String sRootName
99490>>>>>        Boolean bIsSQL
99490>>>>>        Handle hTable
99490>>>>>
99490>>>>>        Move False to bIsSQL
99491>>>>>        Move 0 to hTable
99492>>>>>        Repeat
99492>>>>>>
99492>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
99495>>>>>            If (hTable > 0) Begin
99497>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
99500>>>>>                Move (sRootName contains ":") to bIsSQL
99501>>>>>                If (bIsSQL = True) Begin
99503>>>>>                    Move 0 to hTable
99504>>>>>                End
99504>>>>>>
99504>>>>>            End
99504>>>>>>
99504>>>>>        Until (hTable = 0)
99506>>>>>
99506>>>>>        Function_Return (bIsSQL = False)
99507>>>>>    End_Function
99508>>>>>
99508>>>>>    // Pass a table's logical name
99508>>>>>    // Returns True if the table exists in filelist.cfg.
99508>>>>>    Function UtilTableLogicalNameIsInUse String sCheckTable Returns Boolean
99510>>>>>        Handle hTable
99510>>>>>        Boolean bFound
99510>>>>>        String sCompareTable
99510>>>>>
99510>>>>>        Move False to bFound
99511>>>>>        Move 0 to hTable
99512>>>>>        Repeat
99512>>>>>>
99512>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
99515>>>>>            If (hTable > 0) Begin
99517>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sCompareTable
99520>>>>>                If (Uppercase(sCompareTable) = Uppercase(sCheckTable)) Begin
99522>>>>>                    Move True to bFound
99523>>>>>                End
99523>>>>>>
99523>>>>>            End
99523>>>>>>
99523>>>>>            If (bFound = True) ;                Break
99526>>>>>        Until (hTable = 0)
99528>>>>>
99528>>>>>        Function_Return (bFound = True)
99529>>>>>    End_Function
99530>>>>>
99530>>>>>    // * Dummy function for the Studio's Code Explorer *
99530>>>>>    Function UTIL_ENUMERATION_FUNCTIONS Returns Boolean
99532>>>>>        Function_Return False
99533>>>>>    End_Function
99534>>>>>
99534>>>>>    Function UtilEnumerateOverlapFields Integer hTable Integer iField Returns String[]
99536>>>>>        String  sRetval
99536>>>>>        String[] sOverlapFieldsArray
99537>>>>>        Integer iType iColumn iColumns
99537>>>>>        Boolean bOpen bOverlap
99537>>>>>
99537>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
99540>>>>>        If (bOpen = False) Begin
99542>>>>>            Open hTable
99544>>>>>        End
99544>>>>>>
99544>>>>>
99544>>>>>        Move "" to sRetval
99545>>>>>
99545>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iColumns
99548>>>>>
99548>>>>>        for iColumn from 0 to iColumns
99554>>>>>>
99554>>>>>            Get_Attribute DF_FIELD_TYPE of hTable iColumn to iType
99557>>>>>            If (iField <> iColumn and iType <> DF_OVERLAP) Begin
99559>>>>>                Get_Attribute DF_FIELD_OVERLAP of hTable iField iColumn to bOverlap
99562>>>>>                If (bOverlap) Begin
99564>>>>>                    If (sRetval <> "") Begin
99566>>>>>                        Append sRetval ","
99567>>>>>                    End
99567>>>>>>
99567>>>>>                    Append sRetval iColumn
99568>>>>>                End
99568>>>>>>
99568>>>>>            End
99568>>>>>>
99568>>>>>        Loop
99569>>>>>>
99569>>>>>
99569>>>>>        If (bOpen = False) Begin
99571>>>>>            Close hTable
99572>>>>>        End
99572>>>>>>
99572>>>>>
99572>>>>>        Get StrSplitToArray sRetval "," to sOverlapFieldsArray
99573>>>>>
99573>>>>>        Function_Return sOverlapFieldsArray
99574>>>>>    End_Function
99575>>>>>
99575>>>>>    // Returns a struct array with all data types for the passed driver & dbtype.
99575>>>>>    Function UtilEnumerateColumnTypes String sDriverID Integer iDbType Returns tColumnType[]
99577>>>>>        tColumnType[] ColumnType
99577>>>>>        tColumnType[] ColumnType
99578>>>>>
99578>>>>>        Case Begin
99578>>>>>            Case (iDbType = EN_dbTypeDataFlex)
99580>>>>>                Get _UtilEnumerateDataFlexTypes to ColumnType
99581>>>>>                Case Break
99582>>>>>
99582>>>>>            Case (iDbType = EN_DbTypeDB2)
99585>>>>>                Get _UtilEnumerateDB2Types to ColumnType
99586>>>>>                Case Break
99587>>>>>
99587>>>>>            Case (iDbType = EN_DbTypeMSSQL)
99590>>>>>                Get _UtilEnumerateMSSQLTypes sDriverID to ColumnType
99591>>>>>                Case Break
99592>>>>>
99592>>>>>            Case (sDriverID = MDSMySQL)
99595>>>>>                Get _UtilEnumerateMySQLTypes to ColumnType
99596>>>>>                Case Break
99597>>>>>
99597>>>>>            Case (sDriverID = ORAFLEX)
99600>>>>>                Get _UtilEnumerateOracleTypes to ColumnType
99601>>>>>                Case Break
99602>>>>>
99602>>>>>            Case (sDriverID = MDSPgSQL)
99605>>>>>                Get _UtilEnumeratePostgreSQLTypes to ColumnType
99606>>>>>                Case Break
99607>>>>>        Case End
99607>>>>>
99607>>>>>        Function_Return ColumnType
99608>>>>>    End_Function
99609>>>>>
99609>>>>>    Function UtilEnumerateMSSQLODBCDrivers Returns String
99611>>>>>        Handle hoRegistry hoODBCDriverNames
99611>>>>>        Boolean bExists bKeyOpened
99611>>>>>        String sKey
99611>>>>>        String[] sDrivers
99612>>>>>        Integer iDriverNames iDriverName
99612>>>>>
99612>>>>>        Get Create (RefClass (cRegistry)) to hoRegistry
99613>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
99614>>>>>        Set pfAccessRights of hoRegistry to Key_Read
99615>>>>>        Move "SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers" to sKey
99616>>>>>        Get KeyExists of hoRegistry sKey to bExists
99617>>>>>        If (bExists) Begin
99619>>>>>            Get OpenKey of hoRegistry sKey to bKeyOpened
99620>>>>>            If (bKeyOpened) Begin
99622>>>>>                Get Create (RefClass (Array)) to hoODBCDriverNames
99623>>>>>                Get GetValues of hoRegistry hoODBCDriverNames to iDriverNames
99624>>>>>                If (iDriverNames > 0) Begin
99626>>>>>                    Move (ResizeArray (sDrivers, iDriverNames)) to sDrivers
99627>>>>>                    Decrement iDriverNames
99628>>>>>                    for iDriverName from 0 to iDriverNames
99634>>>>>>
99634>>>>>                        Get Value of hoODBCDriverNames iDriverName to sDrivers[iDriverName]
99635>>>>>                      Loop
99636>>>>>>
99636>>>>>                End
99636>>>>>>
99636>>>>>                Send CloseKey of hoRegistry
99637>>>>>            End
99637>>>>>>
99637>>>>>        End
99637>>>>>>
99637>>>>>        Send Destroy of hoRegistry
99638>>>>>
99638>>>>>        Function_Return sDrivers
99639>>>>>    End_Function
99640>>>>>
99640>>>>>    // DataFlex Embedded Database Data Types:
99640>>>>>    // Helper function for UtilEnumerateColumnTypes
99640>>>>>    Function _UtilEnumerateDataFlexTypes Returns tColumnType[]
99642>>>>>        tColumnType[] ColumnType
99642>>>>>        tColumnType[] ColumnType
99643>>>>>        Integer i
99643>>>>>
99643>>>>>        Move DF_ASCII           to ColumnType[i].iSQLType
99644>>>>>        Move "ASCII"            to ColumnType[i].sSQLType
99645>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
99646>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
99647>>>>>        Move "254"              to ColumnType[i].sPrecision
99648>>>>>        Increment i
99649>>>>>
99649>>>>>        Move DF_BCD             to ColumnType[i].iSQLType
99650>>>>>        Move "Numeric"          to ColumnType[i].sSQLType
99651>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
99652>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
99653>>>>>        Move "14.8"             to ColumnType[i].sPrecision
99654>>>>>        Increment i
99655>>>>>
99655>>>>>        Move DF_DATE            to ColumnType[i].iSQLType
99656>>>>>        Move "Date"             to ColumnType[i].sSQLType
99657>>>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
99658>>>>>        Move "Date"             to ColumnType[i].sDataFlexType
99659>>>>>        Move "6.0"              to ColumnType[i].sPrecision
99660>>>>>        Move True               to ColumnType[i].bCanEditSize
99661>>>>>        Increment i
99662>>>>>
99662>>>>>        Move DF_TEXT            to ColumnType[i].iSQLType
99663>>>>>        Move "Text"             to ColumnType[i].sSQLType
99664>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
99665>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
99666>>>>>        Move "16384"            to ColumnType[i].sPrecision
99667>>>>>        Increment i
99668>>>>>
99668>>>>>        Move DF_BINARY          to ColumnType[i].iSQLType
99669>>>>>        Move "Binary"           to ColumnType[i].sSQLType
99670>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
99671>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
99672>>>>>        Move "16384"            to ColumnType[i].sPrecision
99673>>>>>        Increment i
99674>>>>>
99674>>>>>        Move DF_DATETIME        to ColumnType[i].iSQLType
99675>>>>>        Move "DateTime"         to ColumnType[i].sSQLType
99676>>>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
99677>>>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
99678>>>>>        Move "23"               to ColumnType[i].sPrecision
99679>>>>>        Move True               to ColumnType[i].bCanEditSize
99680>>>>>        Increment i
99681>>>>>
99681>>>>>        Move DF_OVERLAP         to ColumnType[i].iSQLType
99682>>>>>        Move "Overlap"          to ColumnType[i].sSQLType
99683>>>>>        Move DF_OVERLAP         to ColumnType[i].iDataFlexType
99684>>>>>        Move "Overlap"          to ColumnType[i].sDataFlexType
99685>>>>>        Move "0.0"              to ColumnType[i].sPrecision
99686>>>>>
99686>>>>>        Function_Return ColumnType
99687>>>>>    End_Function
99688>>>>>
99688>>>>>    Function _UtilEnumerateDB2Types Returns tColumnType[]
99690>>>>>        tColumnType[] aColumnType
99690>>>>>        tColumnType[] aColumnType
99691>>>>>        Integer i
99691>>>>>
Including file: DB2_DRV_DriverDef.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\DB2_DRV_DriverDef.inc)
99691>>>>>>// Generated By The Database Update Framework
99691>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\DB2_DRV_DriverDef.xml
99691>>>>>>// Driver COLUMN DATA TYPES
99691>>>>>>//
99691>>>>>>// Created: 2018-03-14 23:46:34.033
99691>>>>>>
99691>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
99692>>>>>>            Move -5                                      to aColumnType[i].iSQLType
99693>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99694>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99695>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
99696>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99697>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
99698>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99699>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99700>>>>>>            Move 14                                      to aColumnType[i].sPrecision
99701>>>>>>            Increment i
99702>>>>>>
99702>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
99703>>>>>>            Move -98                                     to aColumnType[i].iSQLType
99704>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99705>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99706>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
99707>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99708>>>>>>            Move 2147483647                              to aColumnType[i].nMaxSize
99709>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
99710>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
99711>>>>>>            Move 2147483647                              to aColumnType[i].sPrecision
99712>>>>>>            Increment i
99713>>>>>>
99713>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
99714>>>>>>            Move 1                                       to aColumnType[i].iSQLType
99715>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99716>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99717>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
99718>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99719>>>>>>            Move 254                                     to aColumnType[i].nMaxSize
99720>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99721>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99722>>>>>>            Move 254                                     to aColumnType[i].sPrecision
99723>>>>>>            Increment i
99724>>>>>>
99724>>>>>>            Move "char for bit data"                     to aColumnType[i].sSQLType
99725>>>>>>            Move -2                                      to aColumnType[i].iSQLType
99726>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99727>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99728>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
99729>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99730>>>>>>            Move 254                                     to aColumnType[i].nMaxSize
99731>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99732>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99733>>>>>>            Move 254                                     to aColumnType[i].sPrecision
99734>>>>>>            Increment i
99735>>>>>>
99735>>>>>>            Move "clob"                                  to aColumnType[i].sSQLType
99736>>>>>>            Move -99                                     to aColumnType[i].iSQLType
99737>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99738>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99739>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
99740>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99741>>>>>>            Move 2147483647                              to aColumnType[i].nMaxSize
99742>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
99743>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
99744>>>>>>            Move 2147483647                              to aColumnType[i].sPrecision
99745>>>>>>            Increment i
99746>>>>>>
99746>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
99747>>>>>>            Move 91                                      to aColumnType[i].iSQLType
99748>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
99749>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99750>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
99751>>>>>>            Move 0                                       to aColumnType[i].iMinSize
99752>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
99753>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99754>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99755>>>>>>            Move 1                                       to aColumnType[i].sPrecision
99756>>>>>>            Increment i
99757>>>>>>
99757>>>>>>            Move "dbclob"                                to aColumnType[i].sSQLType
99758>>>>>>            Move -350                                    to aColumnType[i].iSQLType
99759>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99760>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99761>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
99762>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99763>>>>>>            Move 1073741823                              to aColumnType[i].nMaxSize
99764>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99765>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99766>>>>>>            Move 1073741823                              to aColumnType[i].sPrecision
99767>>>>>>            Increment i
99768>>>>>>
99768>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
99769>>>>>>            Move 3                                       to aColumnType[i].iSQLType
99770>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99771>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99772>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
99773>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99774>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
99775>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99776>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99777>>>>>>            Move 14                                      to aColumnType[i].sPrecision
99778>>>>>>            Increment i
99779>>>>>>
99779>>>>>>            Move "double"                                to aColumnType[i].sSQLType
99780>>>>>>            Move 8                                       to aColumnType[i].iSQLType
99781>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99782>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99783>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
99784>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99785>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
99786>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99787>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99788>>>>>>            Move 14                                      to aColumnType[i].sPrecision
99789>>>>>>            Increment i
99790>>>>>>
99790>>>>>>            Move "graphic"                               to aColumnType[i].sSQLType
99791>>>>>>            Move -95                                     to aColumnType[i].iSQLType
99792>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99793>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99794>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
99795>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99796>>>>>>            Move 127                                     to aColumnType[i].nMaxSize
99797>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99798>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99799>>>>>>            Move 127                                     to aColumnType[i].sPrecision
99800>>>>>>            Increment i
99801>>>>>>
99801>>>>>>            Move "integer"                               to aColumnType[i].sSQLType
99802>>>>>>            Move 4                                       to aColumnType[i].iSQLType
99803>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99804>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99805>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
99806>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99807>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
99808>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99809>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99810>>>>>>            Move 14                                      to aColumnType[i].sPrecision
99811>>>>>>            Increment i
99812>>>>>>
99812>>>>>>            Move "long varchar"                          to aColumnType[i].sSQLType
99813>>>>>>            Move -1                                      to aColumnType[i].iSQLType
99814>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99815>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99816>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
99817>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99818>>>>>>            Move 32000                                   to aColumnType[i].nMaxSize
99819>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99820>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99821>>>>>>            Move 32000                                   to aColumnType[i].sPrecision
99822>>>>>>            Increment i
99823>>>>>>
99823>>>>>>            Move "long varchar for bit data"             to aColumnType[i].sSQLType
99824>>>>>>            Move -4                                      to aColumnType[i].iSQLType
99825>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99826>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99827>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
99828>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99829>>>>>>            Move 32700                                   to aColumnType[i].nMaxSize
99830>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99831>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99832>>>>>>            Move 32700                                   to aColumnType[i].sPrecision
99833>>>>>>            Increment i
99834>>>>>>
99834>>>>>>            Move "long vargraphic"                       to aColumnType[i].sSQLType
99835>>>>>>            Move -97                                     to aColumnType[i].iSQLType
99836>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99837>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99838>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
99839>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99840>>>>>>            Move 16350                                   to aColumnType[i].nMaxSize
99841>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99842>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99843>>>>>>            Move 16350                                   to aColumnType[i].sPrecision
99844>>>>>>            Increment i
99845>>>>>>
99845>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
99846>>>>>>            Move 7                                       to aColumnType[i].iSQLType
99847>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99848>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99849>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
99850>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99851>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
99852>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99853>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99854>>>>>>            Move 14                                      to aColumnType[i].sPrecision
99855>>>>>>            Increment i
99856>>>>>>
99856>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
99857>>>>>>            Move 5                                       to aColumnType[i].iSQLType
99858>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99859>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99860>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
99861>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99862>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
99863>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99864>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99865>>>>>>            Move 14                                      to aColumnType[i].sPrecision
99866>>>>>>            Increment i
99867>>>>>>
99867>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
99868>>>>>>            Move 92                                      to aColumnType[i].iSQLType
99869>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
99870>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99871>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
99872>>>>>>            Move 0                                       to aColumnType[i].iMinSize
99873>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
99874>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99875>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99876>>>>>>            Move 1                                       to aColumnType[i].sPrecision
99877>>>>>>            Increment i
99878>>>>>>
99878>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
99879>>>>>>            Move 93                                      to aColumnType[i].iSQLType
99880>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
99881>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99882>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
99883>>>>>>            Move 0                                       to aColumnType[i].iMinSize
99884>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
99885>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99886>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99887>>>>>>            Move 1                                       to aColumnType[i].sPrecision
99888>>>>>>            Increment i
99889>>>>>>
99889>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
99890>>>>>>            Move 12                                      to aColumnType[i].iSQLType
99891>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99892>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99893>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
99894>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99895>>>>>>            Move 32672                                   to aColumnType[i].nMaxSize
99896>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99897>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99898>>>>>>            Move 32672                                   to aColumnType[i].sPrecision
99899>>>>>>            Increment i
99900>>>>>>
99900>>>>>>            Move "varchar for bit data"                  to aColumnType[i].sSQLType
99901>>>>>>            Move -3                                      to aColumnType[i].iSQLType
99902>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99903>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99904>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
99905>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99906>>>>>>            Move 32672                                   to aColumnType[i].nMaxSize
99907>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99908>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99909>>>>>>            Move 32672                                   to aColumnType[i].sPrecision
99910>>>>>>            Increment i
99911>>>>>>
99911>>>>>>            Move "vargraphic"                            to aColumnType[i].sSQLType
99912>>>>>>            Move -96                                     to aColumnType[i].iSQLType
99913>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99914>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99915>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
99916>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99917>>>>>>            Move 16336                                   to aColumnType[i].nMaxSize
99918>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99919>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99920>>>>>>            Move 16336                                   to aColumnType[i].sPrecision
99921>>>>>>            Increment i
99922>>>>>>
99922>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
99923>>>>>>            Move -370                                    to aColumnType[i].iSQLType
99924>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99925>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99926>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
99927>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99928>>>>>>            Move 2147483647                              to aColumnType[i].nMaxSize
99929>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
99930>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
99931>>>>>>            Move 2147483647                              to aColumnType[i].sPrecision
99932>>>>>>            Increment i
99933>>>>>>
99933>>>>>>
99933>>>>>//        Move SQL_DBCLOB         to ColumnType[i].iSQLType
99933>>>>>//        Move "DBCLOB"           to ColumnType[i].sSQLType
99933>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
99933>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
99933>>>>>//        Move "16384"            to ColumnType[i].sPrecision
99933>>>>>//        Increment i
99933>>>>>//
99933>>>>>//        Move SQL_BIGINT         to ColumnType[i].iSQLType
99933>>>>>//        Move "BIGINT"           to ColumnType[i].sSQLType
99933>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
99933>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
99933>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
99933>>>>>//        Increment i
99933>>>>>//
99933>>>>>//        Move SQL_BLOB           to ColumnType[i].iSQLType
99933>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
99933>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
99933>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
99933>>>>>//        Move "16384"            to ColumnType[i].sPrecision
99933>>>>>//        Increment i
99933>>>>>//
99933>>>>>//        Move SQL_CHAR           to ColumnType[i].iSQLType
99933>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
99933>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
99933>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
99933>>>>>//        Move "254"              to ColumnType[i].sPrecision
99933>>>>>//        Increment i
99933>>>>>//
99933>>>>>//        // ToDo: We need to change the sType when using this!
99933>>>>>//        Move SQL_CHARBIT            to ColumnType[i].iSQLType
99933>>>>>//        Move "CHAR FOR BIT DATA"    to ColumnType[i].sSQLType
99933>>>>>//        Move DF_BINARY              to ColumnType[i].iDataFlexType
99933>>>>>//        Move "Binary"               to ColumnType[i].sDataFlexType
99933>>>>>//        Move "254"                  to ColumnType[i].sPrecision
99933>>>>>//        Increment i
99933>>>>>//
99933>>>>>//        Move SQL_DATE           to ColumnType[i].iSQLType
99933>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
99933>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
99933>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
99933>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
99933>>>>>//        Move True               to ColumnType[i].bCanEditSize
99933>>>>>//        Increment i
99933>>>>>//
99933>>>>>//        Move SQL_CLOB           to ColumnType[i].iSQLType
99933>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
99933>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
99933>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
99933>>>>>//        Move "16384"            to ColumnType[i].sPrecision
99933>>>>>//        Increment i
99933>>>>>//
99933>>>>>//        Move SQL_DECIMAL        to ColumnType[i].iSQLType
99933>>>>>//        Move "DECIMAL"          to ColumnType[i].sSQLType
99933>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
99933>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
99933>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
99933>>>>>//        Increment i
99933>>>>>//
99933>>>>>//        Move SQL_DOUBLE         to ColumnType[i].iSQLType
99933>>>>>//        Move "DOUBLE"           to ColumnType[i].sSQLType
99933>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
99933>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
99933>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
99933>>>>>//        Increment i
99933>>>>>//
99933>>>>>//        Move SQL_FLOAT          to ColumnType[i].iSQLType
99933>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
99933>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
99933>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
99933>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
99933>>>>>//        Increment i
99933>>>>>//
99933>>>>>//        Move SQL_GRAPHIC        to ColumnType[i].iSQLType
99933>>>>>//        Move "GRAPHIC"          to ColumnType[i].sSQLType
99933>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
99933>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
99933>>>>>//        Move "255"              to ColumnType[i].sPrecision
99933>>>>>//        Increment i
99933>>>>>//
99933>>>>>//        Move SQL_INTEGER        to ColumnType[i].iSQLType
99933>>>>>//        Move "INTEGER"          to ColumnType[i].sSQLType
99933>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
99933>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
99933>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
99933>>>>>//        Increment i
99933>>>>>//
99933>>>>>//        Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
99933>>>>>//        Move "LONG VARCHAR"     to ColumnType[i].sSQLType
99933>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
99933>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
99933>>>>>//        Move "32000"            to ColumnType[i].sPrecision
99933>>>>>//        Increment i
99933>>>>>//
99933>>>>>//        Move SQL_LONGVARCHARBIT to ColumnType[i].iSQLType
99933>>>>>//        Move "LONG VARCHAR BIT" to ColumnType[i].sSQLType
99933>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
99933>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
99933>>>>>//        Move "32000"            to ColumnType[i].sPrecision
99933>>>>>//        Increment i
99933>>>>>//
99933>>>>>//        Move SQL_LONGVARGRAPHIC to ColumnType[i].iSQLType
99933>>>>>//        Move "LONG VARGRAPHIC"  to ColumnType[i].sSQLType
99933>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
99933>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
99933>>>>>//        Move "32000"            to ColumnType[i].sPrecision
99933>>>>>//        Increment i
99933>>>>>//
99933>>>>>//        Move SQL_NUMERIC        to ColumnType[i].iSQLType
99933>>>>>//        Move "NUMERIC"          to ColumnType[i].sSQLType
99933>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
99933>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
99933>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
99933>>>>>//        Increment i
99933>>>>>//
99933>>>>>//        Move SQL_REAL           to ColumnType[i].iSQLType
99933>>>>>//        Move "REAL"             to ColumnType[i].sSQLType
99933>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
99933>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
99933>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
99933>>>>>//        Increment i
99933>>>>>//
99933>>>>>//        Move SQL_SMALLINT       to ColumnType[i].iSQLType
99933>>>>>//        Move "SMALLINT"         to ColumnType[i].sSQLType
99933>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
99933>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
99933>>>>>//        Move "5.0"              to ColumnType[i].sPrecision
99933>>>>>//        Increment i
99933>>>>>//
99933>>>>>//        Move SQL_TIME           to ColumnType[i].iSQLType
99933>>>>>//        Move "TIME"             to ColumnType[i].sSQLType
99933>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
99933>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
99933>>>>>//        Move "19.0"             to ColumnType[i].sPrecision
99933>>>>>//        Move True               to ColumnType[i].bCanEditSize
99933>>>>>//        Increment i
99933>>>>>//
99933>>>>>//        Move SQL_TIMESTAMP      to ColumnType[i].iSQLType
99933>>>>>//        Move "TIMESTAMP"        to ColumnType[i].sSQLType
99933>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
99933>>>>>//        Move "DATETIME"         to ColumnType[i].sDataFlexType
99933>>>>>//        Move "23.6"             to ColumnType[i].sPrecision
99933>>>>>//        Move True               to ColumnType[i].bCanEditSize
99933>>>>>//        Increment i
99933>>>>>//
99933>>>>>//        Move SQL_VARCHAR        to ColumnType[i].iSQLType
99933>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
99933>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
99933>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
99933>>>>>//        Move "16384"            to ColumnType[i].sPrecision
99933>>>>>//        Increment i
99933>>>>>//
99933>>>>>//        // ToDo: We need to change the sType when using this!
99933>>>>>//        Move SQL_VARCHARBIT         to ColumnType[i].iSQLType
99933>>>>>//        Move "VARCHAR FOR BIT DATA" to ColumnType[i].sSQLType
99933>>>>>//        Move DF_TEXT                to ColumnType[i].iDataFlexType
99933>>>>>//        Move "TEXT"                 to ColumnType[i].sDataFlexType
99933>>>>>//        Move "16384"                to ColumnType[i].sPrecision
99933>>>>>//        Increment i
99933>>>>>//
99933>>>>>//        Move SQL_VARGRAPHIC     to ColumnType[i].iSQLType
99933>>>>>//        Move "VARGRAPHIC"       to ColumnType[i].sSQLType
99933>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
99933>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
99933>>>>>//        Move "16384"            to ColumnType[i].sPrecision
99933>>>>>//
99933>>>>>//        Move SQL_XML            to ColumnType[i].iSQLType
99933>>>>>//        Move "XML"              to ColumnType[i].sSQLType
99933>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
99933>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
99933>>>>>//        Move "16384"            to ColumnType[i].sPrecision
99933>>>>>
99933>>>>>        Function_Return aColumnType
99934>>>>>    End_Function
99935>>>>>
99935>>>>>    // Microsoft SQL Server Database Data Types:
99935>>>>>    // Helper function for UtilEnumerateColumnTypes
99935>>>>>    Function _UtilEnumerateMSSQLTypes String sDriverID Returns tColumnType[]
99937>>>>>        tColumnType[] aColumnType
99937>>>>>        tColumnType[] aColumnType
99938>>>>>        Integer i
99938>>>>>
99938>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
Including file: MSSQLDRV_DriverDef.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\MSSQLDRV_DriverDef.inc)
99940>>>>>>// Generated By The Database Update Framework
99940>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\bin\MSSQLDRV_DriverDef.xml
99940>>>>>>// Driver COLUMN DATA TYPES
99940>>>>>>//
99940>>>>>>// Created: 2018-03-15 00:00:57.024
99940>>>>>>
99940>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
99941>>>>>>            Move -5                                      to aColumnType[i].iSQLType
99942>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99943>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99944>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
99945>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99946>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
99947>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99948>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99949>>>>>>            Move 14                                      to aColumnType[i].sPrecision
99950>>>>>>            Increment i
99951>>>>>>
99951>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
99952>>>>>>            Move -2                                      to aColumnType[i].iSQLType
99953>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99954>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99955>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
99956>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99957>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
99958>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
99959>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
99960>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
99961>>>>>>            Increment i
99962>>>>>>
99962>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
99963>>>>>>            Move -7                                      to aColumnType[i].iSQLType
99964>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
99965>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99966>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
99967>>>>>>            Move 0                                       to aColumnType[i].iMinSize
99968>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
99969>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99970>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99971>>>>>>            Move 1                                       to aColumnType[i].sPrecision
99972>>>>>>            Increment i
99973>>>>>>
99973>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
99974>>>>>>            Move 1                                       to aColumnType[i].iSQLType
99975>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99976>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99977>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
99978>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99979>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
99980>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99981>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99982>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
99983>>>>>>            Increment i
99984>>>>>>
99984>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
99985>>>>>>            Move 91                                      to aColumnType[i].iSQLType
99986>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
99987>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99988>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
99989>>>>>>            Move 0                                       to aColumnType[i].iMinSize
99990>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
99991>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
99992>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
99993>>>>>>            Move 6                                       to aColumnType[i].sPrecision
99994>>>>>>            Increment i
99995>>>>>>
99995>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
99996>>>>>>            Move 93                                      to aColumnType[i].iSQLType
99997>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
99998>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99999>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
100000>>>>>>            Move -1                                      to aColumnType[i].iMinSize
100001>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
100002>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
100003>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
100004>>>>>>            Move 23                                      to aColumnType[i].sPrecision
100005>>>>>>            Increment i
100006>>>>>>
100006>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
100007>>>>>>            Move -200                                    to aColumnType[i].iSQLType
100008>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100009>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100010>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
100011>>>>>>            Move 23                                      to aColumnType[i].iMinSize
100012>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
100013>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
100014>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
100015>>>>>>            Move 23                                      to aColumnType[i].sPrecision
100016>>>>>>            Increment i
100017>>>>>>
100017>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
100018>>>>>>            Move -155                                    to aColumnType[i].iSQLType
100019>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100020>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100021>>>>>>            Move 34                                      to aColumnType[i].iDefaultSize
100022>>>>>>            Move 34                                      to aColumnType[i].iMinSize
100023>>>>>>            Move 34                                      to aColumnType[i].nMaxSize
100024>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
100025>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
100026>>>>>>            Move 34                                      to aColumnType[i].sPrecision
100027>>>>>>            Increment i
100028>>>>>>
100028>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
100029>>>>>>            Move 3                                       to aColumnType[i].iSQLType
100030>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100031>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100032>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
100033>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100034>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
100035>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
100036>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
100037>>>>>>            Move 14                                      to aColumnType[i].sPrecision
100038>>>>>>            Increment i
100039>>>>>>
100039>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
100040>>>>>>            Move 6                                       to aColumnType[i].iSQLType
100041>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100042>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100043>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
100044>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100045>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
100046>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
100047>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
100048>>>>>>            Move 14                                      to aColumnType[i].sPrecision
100049>>>>>>            Increment i
100050>>>>>>
100050>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
100051>>>>>>            Move -4                                      to aColumnType[i].iSQLType
100052>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100053>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100054>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
100055>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100056>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
100057>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
100058>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
100059>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
100060>>>>>>            Increment i
100061>>>>>>
100061>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
100062>>>>>>            Move 4                                       to aColumnType[i].iSQLType
100063>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100064>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100065>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
100066>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100067>>>>>>            Move 10                                      to aColumnType[i].nMaxSize
100068>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
100069>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
100070>>>>>>            Move 10                                      to aColumnType[i].sPrecision
100071>>>>>>            Increment i
100072>>>>>>
100072>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
100073>>>>>>            Move -204                                    to aColumnType[i].iSQLType
100074>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
100075>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100076>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
100077>>>>>>            Move 0                                       to aColumnType[i].iMinSize
100078>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
100079>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
100080>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
100081>>>>>>            Move 1                                       to aColumnType[i].sPrecision
100082>>>>>>            Increment i
100083>>>>>>
100083>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
100084>>>>>>            Move -8                                      to aColumnType[i].iSQLType
100085>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100086>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100087>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
100088>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100089>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
100090>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
100091>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
100092>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
100093>>>>>>            Increment i
100094>>>>>>
100094>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
100095>>>>>>            Move -10                                     to aColumnType[i].iSQLType
100096>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100097>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100098>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
100099>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100100>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
100101>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
100102>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
100103>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
100104>>>>>>            Increment i
100105>>>>>>
100105>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
100106>>>>>>            Move 2                                       to aColumnType[i].iSQLType
100107>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100108>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100109>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
100110>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100111>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
100112>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
100113>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
100114>>>>>>            Move 14                                      to aColumnType[i].sPrecision
100115>>>>>>            Increment i
100116>>>>>>
100116>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
100117>>>>>>            Move -9                                      to aColumnType[i].iSQLType
100118>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100119>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100120>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
100121>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100122>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
100123>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
100124>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
100125>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
100126>>>>>>            Increment i
100127>>>>>>
100127>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
100128>>>>>>            Move -202                                    to aColumnType[i].iSQLType
100129>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100130>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100131>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
100132>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100133>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
100134>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
100135>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
100136>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
100137>>>>>>            Increment i
100138>>>>>>
100138>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
100139>>>>>>            Move 7                                       to aColumnType[i].iSQLType
100140>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100141>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100142>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
100143>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100144>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
100145>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
100146>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
100147>>>>>>            Move 14                                      to aColumnType[i].sPrecision
100148>>>>>>            Increment i
100149>>>>>>
100149>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
100150>>>>>>            Move -206                                    to aColumnType[i].iSQLType
100151>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
100152>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100153>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
100154>>>>>>            Move 0                                       to aColumnType[i].iMinSize
100155>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
100156>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
100157>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
100158>>>>>>            Move 1                                       to aColumnType[i].sPrecision
100159>>>>>>            Increment i
100160>>>>>>
100160>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
100161>>>>>>            Move 5                                       to aColumnType[i].iSQLType
100162>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100163>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100164>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
100165>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100166>>>>>>            Move 5                                       to aColumnType[i].nMaxSize
100167>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
100168>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
100169>>>>>>            Move 5                                       to aColumnType[i].sPrecision
100170>>>>>>            Increment i
100171>>>>>>
100171>>>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
100172>>>>>>            Move -205                                    to aColumnType[i].iSQLType
100173>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
100174>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100175>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
100176>>>>>>            Move 0                                       to aColumnType[i].iMinSize
100177>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
100178>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
100179>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
100180>>>>>>            Move 1                                       to aColumnType[i].sPrecision
100181>>>>>>            Increment i
100182>>>>>>
100182>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
100183>>>>>>            Move -1                                      to aColumnType[i].iSQLType
100184>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100185>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100186>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
100187>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100188>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
100189>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
100190>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
100191>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
100192>>>>>>            Increment i
100193>>>>>>
100193>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
100194>>>>>>            Move -154                                    to aColumnType[i].iSQLType
100195>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100196>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100197>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
100198>>>>>>            Move 10                                      to aColumnType[i].iMinSize
100199>>>>>>            Move 19                                      to aColumnType[i].nMaxSize
100200>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
100201>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
100202>>>>>>            Move 19                                      to aColumnType[i].sPrecision
100203>>>>>>            Increment i
100204>>>>>>
100204>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
100205>>>>>>            Move -6                                      to aColumnType[i].iSQLType
100206>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100207>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100208>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
100209>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100210>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
100211>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
100212>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
100213>>>>>>            Move 3                                       to aColumnType[i].sPrecision
100214>>>>>>            Increment i
100215>>>>>>
100215>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
100216>>>>>>            Move -11                                     to aColumnType[i].iSQLType
100217>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
100218>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100219>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
100220>>>>>>            Move 0                                       to aColumnType[i].iMinSize
100221>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
100222>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
100223>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
100224>>>>>>            Move 1                                       to aColumnType[i].sPrecision
100225>>>>>>            Increment i
100226>>>>>>
100226>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
100227>>>>>>            Move -3                                      to aColumnType[i].iSQLType
100228>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100229>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100230>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
100231>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100232>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
100233>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
100234>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
100235>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
100236>>>>>>            Increment i
100237>>>>>>
100237>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
100238>>>>>>            Move -203                                    to aColumnType[i].iSQLType
100239>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100240>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100241>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
100242>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100243>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
100244>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
100245>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
100246>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
100247>>>>>>            Increment i
100248>>>>>>
100248>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
100249>>>>>>            Move 12                                      to aColumnType[i].iSQLType
100250>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100251>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100252>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
100253>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100254>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
100255>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
100256>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
100257>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
100258>>>>>>            Increment i
100259>>>>>>
100259>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
100260>>>>>>            Move -201                                    to aColumnType[i].iSQLType
100261>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100262>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100263>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
100264>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100265>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
100266>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
100267>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
100268>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
100269>>>>>>            Increment i
100270>>>>>>
100270>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
100271>>>>>>            Move -152                                    to aColumnType[i].iSQLType
100272>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100273>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100274>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
100275>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100276>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
100277>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
100278>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
100279>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
100280>>>>>>            Increment i
100281>>>>>>
100281>>>>>>
100281>>>>>            
100281>>>>>//            Move SQL_BIGINT         to ColumnType[i].iSQLType
100281>>>>>//            Move "bigint"           to ColumnType[i].sSQLType
100281>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
100281>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
100281>>>>>//            Move "14.0"             to ColumnType[i].sPrecision
100281>>>>>//            Move True               to ColumnType[i].bCanEditSize
100281>>>>>//            Increment i
100281>>>>>//
100281>>>>>//            Move SQL_BINARY         to ColumnType[i].iSQLType
100281>>>>>//            Move "binary"           to ColumnType[i].sSQLType
100281>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
100281>>>>>//            Move "Binary"           to ColumnType[i].sDataFlexType
100281>>>>>//            Move "8000"             to ColumnType[i].sPrecision
100281>>>>>//            Increment i
100281>>>>>//
100281>>>>>//            Move SQL_BIT            to ColumnType[i].iSQLType
100281>>>>>//            Move "bit"              to ColumnType[i].sSQLType
100281>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
100281>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
100281>>>>>//            Move "1.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
100281>>>>>//            Move True               to ColumnType[i].bCanEditSize
100281>>>>>//            Increment i
100281>>>>>//
100281>>>>>//            Move SQL_CHAR           to ColumnType[i].iSQLType
100281>>>>>//            Move "char"             to ColumnType[i].sSQLType
100281>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
100281>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
100281>>>>>//            Move "8000"             to ColumnType[i].sPrecision
100281>>>>>//            Increment i
100281>>>>>//
100281>>>>>//            Move SQL_DATE           to ColumnType[i].iSQLType
100281>>>>>//            Move "date"             to ColumnType[i].sSQLType
100281>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
100281>>>>>//            Move "Date"             to ColumnType[i].sDataFlexType
100281>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
100281>>>>>//            Move True               to ColumnType[i].bCanEditSize
100281>>>>>//            Increment i
100281>>>>>//
100281>>>>>//            Move SQL_DATETIME       to ColumnType[i].iSQLType
100281>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
100281>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
100281>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
100281>>>>>//            Move "23.3"             to ColumnType[i].sPrecision
100281>>>>>//            Move True               to ColumnType[i].bCanEditSize
100281>>>>>//            Increment i
100281>>>>>//
100281>>>>>//            Move SQL_TYPE_TIMESTAMP2 to ColumnType[i].iSQLType
100281>>>>>//            Move "datetime2"         to ColumnType[i].sSQLType
100281>>>>>//            Move DF_DATETIME         to ColumnType[i].iDataFlexType
100281>>>>>//            Move "DateTime"          to ColumnType[i].sDataFlexType
100281>>>>>//            Move "23.6"              to ColumnType[i].sPrecision
100281>>>>>//            Move True                to ColumnType[i].bCanEditSize
100281>>>>>//            Increment i
100281>>>>>//
100281>>>>>//            Move SQL_SS_TIMESTAMPOFFSET to ColumnType[i].iSQLType
100281>>>>>//            Move "datetimeoffset"       to ColumnType[i].sSQLType
100281>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
100281>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
100281>>>>>//            Move "34.0"                 to ColumnType[i].sPrecision
100281>>>>>//            Move True                   to ColumnType[i].bCanEditSize
100281>>>>>//            Increment i
100281>>>>>//
100281>>>>>//            Move SQL_DECIMAL        to ColumnType[i].iSQLType
100281>>>>>//            Move "decimal"          to ColumnType[i].sSQLType
100281>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
100281>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
100281>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
100281>>>>>//            Increment i
100281>>>>>//
100281>>>>>//            Move SQL_FLOAT          to ColumnType[i].iSQLType
100281>>>>>//            Move "float"            to ColumnType[i].sSQLType
100281>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
100281>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
100281>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
100281>>>>>//            Increment i
100281>>>>>//
100281>>>>>//            Move SQL_INTEGER        to ColumnType[i].iSQLType
100281>>>>>//            Move "int"              to ColumnType[i].sSQLType
100281>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
100281>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
100281>>>>>//            Move "8.0"              to ColumnType[i].sPrecision
100281>>>>>//            Move True               to ColumnType[i].bCanEditSize
100281>>>>>//            Increment i
100281>>>>>//
100281>>>>>//            Move SQL_TYPE_MONEY     to ColumnType[i].iSQLType
100281>>>>>//            Move "money"            to ColumnType[i].sSQLType
100281>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
100281>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
100281>>>>>//            Move "15.4"             to ColumnType[i].sPrecision // Studio 18.0 (!)
100281>>>>>//            Increment i
100281>>>>>//
100281>>>>>//            Move SQL_WCHAR          to ColumnType[i].iSQLType
100281>>>>>//            Move "nchar"            to ColumnType[i].sSQLType
100281>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
100281>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
100281>>>>>//            Move "4000"             to ColumnType[i].sPrecision
100281>>>>>//            Increment i
100281>>>>>//
100281>>>>>//            Move SQL_WLONGVARCHAR   to ColumnType[i].iSQLType
100281>>>>>//            Move "ntext"            to ColumnType[i].sSQLType
100281>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
100281>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
100281>>>>>//            Move "16384"            to ColumnType[i].sPrecision
100281>>>>>//            Increment i
100281>>>>>//
100281>>>>>//            Move SQL_NUMERIC        to ColumnType[i].iSQLType
100281>>>>>//            Move "numeric"          to ColumnType[i].sSQLType
100281>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
100281>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
100281>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
100281>>>>>//            Increment i
100281>>>>>//
100281>>>>>//            Move SQL_WVARCHAR       to ColumnType[i].iSQLType
100281>>>>>//            Move "nvarchar"         to ColumnType[i].sSQLType
100281>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
100281>>>>>//            Move "Text"             to ColumnType[i].sDataFlexType
100281>>>>>//            Move "4000"             to ColumnType[i].sPrecision
100281>>>>>//            Increment i
100281>>>>>//
100281>>>>>//            Move SQL_VARCHARMAX     to ColumnType[i].iSQLType
100281>>>>>//            Move "nvarchar(max)"    to ColumnType[i].sSQLType
100281>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
100281>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
100281>>>>>//            Move "16384"            to ColumnType[i].sPrecision
100281>>>>>//            Move True               to ColumnType[i].bCanEditSize
100281>>>>>//            Increment i
100281>>>>>//
100281>>>>>//            Move SQL_REAL           to ColumnType[i].iSQLType
100281>>>>>//            Move "real"             to ColumnType[i].sSQLType
100281>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
100281>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
100281>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
100281>>>>>//            Increment i
100281>>>>>//
100281>>>>>//            Move SQL_TYPE_SMALLDATETIME to ColumnType[i].iSQLType
100281>>>>>//            Move "smalldatetime"        to ColumnType[i].sSQLType
100281>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
100281>>>>>//            Move "DATETIME"             to ColumnType[i].sDataFlexType
100281>>>>>//            Move "23.0"                 to ColumnType[i].sPrecision
100281>>>>>//            Move True                   to ColumnType[i].bCanEditSize
100281>>>>>//            Increment i
100281>>>>>//
100281>>>>>//            Move SQL_SMALLINT       to ColumnType[i].iSQLType
100281>>>>>//            Move "smallint"         to ColumnType[i].sSQLType
100281>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
100281>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
100281>>>>>//            Move "4.0"              to ColumnType[i].sPrecision
100281>>>>>//            Move True               to ColumnType[i].bCanEditSize
100281>>>>>//            Increment i
100281>>>>>//
100281>>>>>//            Move SQL_TYPE_SMALLMONEY to ColumnType[i].iSQLType
100281>>>>>//            Move "smallmoney"        to ColumnType[i].sSQLType
100281>>>>>//            Move DF_BCD              to ColumnType[i].iDataFlexType
100281>>>>>//            Move "NUMERIC"           to ColumnType[i].sDataFlexType
100281>>>>>//            Move "10.0"              to ColumnType[i].sPrecision
100281>>>>>//            Increment i
100281>>>>>//
100281>>>>>//            Move SQL_TEXT           to ColumnType[i].iSQLType
100281>>>>>//            Move "text"             to ColumnType[i].sSQLType
100281>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
100281>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
100281>>>>>//            Move "8000"             to ColumnType[i].sPrecision
100281>>>>>//            Move True               to ColumnType[i].bCanEditSize
100281>>>>>//            Increment i
100281>>>>>//
100281>>>>>//            Move SQL_TIME           to ColumnType[i].iSQLType
100281>>>>>//            Move "time"             to ColumnType[i].sSQLType
100281>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
100281>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
100281>>>>>//            Move "19.0"             to ColumnType[i].sPrecision
100281>>>>>//            Move True               to ColumnType[i].bCanEditSize
100281>>>>>//            Increment i
100281>>>>>//
100281>>>>>//            Move SQL_TINYINT        to ColumnType[i].iSQLType
100281>>>>>//            Move "tinyint"          to ColumnType[i].sSQLType
100281>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
100281>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
100281>>>>>//            Move "2.0"              to ColumnType[i].sPrecision
100281>>>>>//            Move True               to ColumnType[i].bCanEditSize
100281>>>>>//            Increment i
100281>>>>>//
100281>>>>>//            Move SQL_GUID           to ColumnType[i].iSQLType
100281>>>>>//            Move "uniqueidentifier" to ColumnType[i].sSQLType
100281>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
100281>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
100281>>>>>//            Move "36"               to ColumnType[i].sPrecision
100281>>>>>//            Move True               to ColumnType[i].bCanEditSize
100281>>>>>//            Increment i
100281>>>>>//
100281>>>>>//            Move SQL_VARBINARY      to ColumnType[i].iSQLType
100281>>>>>//            Move "varbinary"        to ColumnType[i].sSQLType
100281>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
100281>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
100281>>>>>//            Move "16384"            to ColumnType[i].sPrecision
100281>>>>>//            Increment i
100281>>>>>//
100281>>>>>//            Move SQL_LONGVARBINARY  to ColumnType[i].iSQLType
100281>>>>>//            Move "varbinary(max)"   to ColumnType[i].sSQLType
100281>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
100281>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
100281>>>>>//            Move "16384"            to ColumnType[i].sPrecision
100281>>>>>//            Move True               to ColumnType[i].bCanEditSize
100281>>>>>//            Increment i
100281>>>>>//
100281>>>>>//            Move SQL_VARCHAR        to ColumnType[i].iSQLType
100281>>>>>//            Move "varchar"          to ColumnType[i].sSQLType
100281>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
100281>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
100281>>>>>//            Move "8000"             to ColumnType[i].sPrecision
100281>>>>>//            Increment i
100281>>>>>//
100281>>>>>//            Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
100281>>>>>//            Move "varchar(max)"     to ColumnType[i].sSQLType
100281>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
100281>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
100281>>>>>//            Move "16384"            to ColumnType[i].sPrecision
100281>>>>>//            Move True               to ColumnType[i].bCanEditSize
100281>>>>>//            Increment i
100281>>>>>//
100281>>>>>//            Move SQL_SS_XML         to ColumnType[i].iSQLType
100281>>>>>//            Move "xml"              to ColumnType[i].sSQLType
100281>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
100281>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
100281>>>>>//            Move "16384"            to ColumnType[i].sPrecision
100281>>>>>//            Increment i
100281>>>>>//
100281>>>>>//            Move SQL_TYPE_DATE      to ColumnType[i].iSQLType
100281>>>>>//            Move "DATE"             to ColumnType[i].sSQLType
100281>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
100281>>>>>//            Move "date"             to ColumnType[i].sDataFlexType
100281>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
100281>>>>>//            Move True               to ColumnType[i].bCanEditSize
100281>>>>>//            Increment i
100281>>>>>//
100281>>>>>//            Move SQL_TYPE_TIME      to ColumnType[i].iSQLType
100281>>>>>//            Move "time"             to ColumnType[i].sSQLType
100281>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
100281>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
100281>>>>>//            Move "8.7"              to ColumnType[i].sPrecision
100281>>>>>//            Move True               to ColumnType[i].bCanEditSize
100281>>>>>//            Increment i
100281>>>>>//
100281>>>>>//            Move SQL_TYPE_TIMESTAMP to ColumnType[i].iSQLType
100281>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
100281>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
100281>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
100281>>>>>//            Move "23.6"             to ColumnType[i].sPrecision
100281>>>>>//            Move True               to ColumnType[i].bCanEditSize
100281>>>>>//            Increment i
100281>>>>>
100281>>>>>        End
100281>>>>>>
100281>>>>>
100281>>>>>        // Mertech SQLFlex driver
100281>>>>>        If (sDriverID = SQLFLEX) Begin
100283>>>>>
Including file: sql_drv_DriverDef.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\sql_drv_DriverDef.inc)
100283>>>>>>// Generated By The Database Update Framework
100283>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\sql_drv_DriverDef.xml
100283>>>>>>// Driver COLUMN DATA TYPES
100283>>>>>>//
100283>>>>>>// Created: 2018-03-14 23:47:46.885
100283>>>>>>
100283>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
100284>>>>>>            Move -5                                      to aColumnType[i].iSQLType
100285>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100286>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100287>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
100288>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100289>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
100290>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
100291>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
100292>>>>>>            Move 14                                      to aColumnType[i].sPrecision
100293>>>>>>            Increment i
100294>>>>>>
100294>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
100295>>>>>>            Move -2                                      to aColumnType[i].iSQLType
100296>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100297>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100298>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
100299>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100300>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
100301>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
100302>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
100303>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
100304>>>>>>            Increment i
100305>>>>>>
100305>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
100306>>>>>>            Move -7                                      to aColumnType[i].iSQLType
100307>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
100308>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100309>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
100310>>>>>>            Move -1                                      to aColumnType[i].iMinSize
100311>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
100312>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
100313>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
100314>>>>>>            Move -1                                      to aColumnType[i].sPrecision
100315>>>>>>            Increment i
100316>>>>>>
100316>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
100317>>>>>>            Move 1                                       to aColumnType[i].iSQLType
100318>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100319>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100320>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
100321>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100322>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
100323>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
100324>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
100325>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
100326>>>>>>            Increment i
100327>>>>>>
100327>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
100328>>>>>>            Move 40                                      to aColumnType[i].iSQLType
100329>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
100330>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100331>>>>>>            Move 12                                      to aColumnType[i].iDefaultSize
100332>>>>>>            Move -1                                      to aColumnType[i].iMinSize
100333>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
100334>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
100335>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
100336>>>>>>            Move -1                                      to aColumnType[i].sPrecision
100337>>>>>>            Increment i
100338>>>>>>
100338>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
100339>>>>>>            Move 11                                      to aColumnType[i].iSQLType
100340>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100341>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100342>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
100343>>>>>>            Move 6                                       to aColumnType[i].iMinSize
100344>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
100345>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
100346>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
100347>>>>>>            Move 23                                      to aColumnType[i].sPrecision
100348>>>>>>            Increment i
100349>>>>>>
100349>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
100350>>>>>>            Move 42                                      to aColumnType[i].iSQLType
100351>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100352>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100353>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
100354>>>>>>            Move 6                                       to aColumnType[i].iMinSize
100355>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
100356>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
100357>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
100358>>>>>>            Move 23                                      to aColumnType[i].sPrecision
100359>>>>>>            Increment i
100360>>>>>>
100360>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
100361>>>>>>            Move 43                                      to aColumnType[i].iSQLType
100362>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100363>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100364>>>>>>            Move 12                                      to aColumnType[i].iDefaultSize
100365>>>>>>            Move 12                                      to aColumnType[i].iMinSize
100366>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
100367>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
100368>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
100369>>>>>>            Move 23                                      to aColumnType[i].sPrecision
100370>>>>>>            Increment i
100371>>>>>>
100371>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
100372>>>>>>            Move 3                                       to aColumnType[i].iSQLType
100373>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100374>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100375>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
100376>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100377>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
100378>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
100379>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
100380>>>>>>            Move 14                                      to aColumnType[i].sPrecision
100381>>>>>>            Increment i
100382>>>>>>
100382>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
100383>>>>>>            Move 6                                       to aColumnType[i].iSQLType
100384>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100385>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100386>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
100387>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100388>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
100389>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
100390>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
100391>>>>>>            Move 14                                      to aColumnType[i].sPrecision
100392>>>>>>            Increment i
100393>>>>>>
100393>>>>>>            Move "geography"                             to aColumnType[i].sSQLType
100394>>>>>>            Move 130                                     to aColumnType[i].iSQLType
100395>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
100396>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100397>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
100398>>>>>>            Move -1                                      to aColumnType[i].iMinSize
100399>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
100400>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
100401>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
100402>>>>>>            Move -1                                      to aColumnType[i].sPrecision
100403>>>>>>            Increment i
100404>>>>>>
100404>>>>>>            Move "geometry"                              to aColumnType[i].sSQLType
100405>>>>>>            Move 129                                     to aColumnType[i].iSQLType
100406>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
100407>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100408>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
100409>>>>>>            Move -1                                      to aColumnType[i].iMinSize
100410>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
100411>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
100412>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
100413>>>>>>            Move -1                                      to aColumnType[i].sPrecision
100414>>>>>>            Increment i
100415>>>>>>
100415>>>>>>            Move "hierarchyid"                           to aColumnType[i].sSQLType
100416>>>>>>            Move 128                                     to aColumnType[i].iSQLType
100417>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
100418>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100419>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
100420>>>>>>            Move -1                                      to aColumnType[i].iMinSize
100421>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
100422>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
100423>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
100424>>>>>>            Move -1                                      to aColumnType[i].sPrecision
100425>>>>>>            Increment i
100426>>>>>>
100426>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
100427>>>>>>            Move -4                                      to aColumnType[i].iSQLType
100428>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100429>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100430>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
100431>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100432>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
100433>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
100434>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
100435>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
100436>>>>>>            Increment i
100437>>>>>>
100437>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
100438>>>>>>            Move 4                                       to aColumnType[i].iSQLType
100439>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100440>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100441>>>>>>            Move 11                                      to aColumnType[i].iDefaultSize
100442>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100443>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
100444>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
100445>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
100446>>>>>>            Move 11                                      to aColumnType[i].sPrecision
100447>>>>>>            Increment i
100448>>>>>>
100448>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
100449>>>>>>            Move -8                                      to aColumnType[i].iSQLType
100450>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100451>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100452>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
100453>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100454>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
100455>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
100456>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
100457>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
100458>>>>>>            Increment i
100459>>>>>>
100459>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
100460>>>>>>            Move -10                                     to aColumnType[i].iSQLType
100461>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100462>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100463>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
100464>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100465>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
100466>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
100467>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
100468>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
100469>>>>>>            Increment i
100470>>>>>>
100470>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
100471>>>>>>            Move 2                                       to aColumnType[i].iSQLType
100472>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100473>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100474>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
100475>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100476>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
100477>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
100478>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
100479>>>>>>            Move 14                                      to aColumnType[i].sPrecision
100480>>>>>>            Increment i
100481>>>>>>
100481>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
100482>>>>>>            Move -9                                      to aColumnType[i].iSQLType
100483>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100484>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100485>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
100486>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100487>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
100488>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
100489>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
100490>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
100491>>>>>>            Increment i
100492>>>>>>
100492>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
100493>>>>>>            Move -100                                    to aColumnType[i].iSQLType
100494>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100495>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100496>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
100497>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100498>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
100499>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
100500>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
100501>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
100502>>>>>>            Increment i
100503>>>>>>
100503>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
100504>>>>>>            Move 7                                       to aColumnType[i].iSQLType
100505>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100506>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100507>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
100508>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100509>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
100510>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
100511>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
100512>>>>>>            Move 14                                      to aColumnType[i].sPrecision
100513>>>>>>            Increment i
100514>>>>>>
100514>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
100515>>>>>>            Move 58                                      to aColumnType[i].iSQLType
100516>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100517>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100518>>>>>>            Move 12                                      to aColumnType[i].iDefaultSize
100519>>>>>>            Move 12                                      to aColumnType[i].iMinSize
100520>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
100521>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
100522>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
100523>>>>>>            Move 23                                      to aColumnType[i].sPrecision
100524>>>>>>            Increment i
100525>>>>>>
100525>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
100526>>>>>>            Move 5                                       to aColumnType[i].iSQLType
100527>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100528>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100529>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
100530>>>>>>            Move -1                                      to aColumnType[i].iMinSize
100531>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
100532>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
100533>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
100534>>>>>>            Move 6                                       to aColumnType[i].sPrecision
100535>>>>>>            Increment i
100536>>>>>>
100536>>>>>>            Move "sql_variant"                           to aColumnType[i].sSQLType
100537>>>>>>            Move -150                                    to aColumnType[i].iSQLType
100538>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
100539>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100540>>>>>>            Move 8016                                    to aColumnType[i].iDefaultSize
100541>>>>>>            Move -1                                      to aColumnType[i].iMinSize
100542>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
100543>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
100544>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
100545>>>>>>            Move -1                                      to aColumnType[i].sPrecision
100546>>>>>>            Increment i
100547>>>>>>
100547>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
100548>>>>>>            Move -1                                      to aColumnType[i].iSQLType
100549>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100550>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100551>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
100552>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100553>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
100554>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
100555>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
100556>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
100557>>>>>>            Increment i
100558>>>>>>
100558>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
100559>>>>>>            Move 41                                      to aColumnType[i].iSQLType
100560>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100561>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100562>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
100563>>>>>>            Move 8                                       to aColumnType[i].iMinSize
100564>>>>>>            Move 16                                      to aColumnType[i].nMaxSize
100565>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
100566>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
100567>>>>>>            Move 16                                      to aColumnType[i].sPrecision
100568>>>>>>            Increment i
100569>>>>>>
100569>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
100570>>>>>>            Move 93                                      to aColumnType[i].iSQLType
100571>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
100572>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100573>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
100574>>>>>>            Move -1                                      to aColumnType[i].iMinSize
100575>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
100576>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
100577>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
100578>>>>>>            Move -1                                      to aColumnType[i].sPrecision
100579>>>>>>            Increment i
100580>>>>>>
100580>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
100581>>>>>>            Move -6                                      to aColumnType[i].iSQLType
100582>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100583>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100584>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
100585>>>>>>            Move -1                                      to aColumnType[i].iMinSize
100586>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
100587>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
100588>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
100589>>>>>>            Move 3                                       to aColumnType[i].sPrecision
100590>>>>>>            Increment i
100591>>>>>>
100591>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
100592>>>>>>            Move -11                                     to aColumnType[i].iSQLType
100593>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
100594>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100595>>>>>>            Move 38                                      to aColumnType[i].iDefaultSize
100596>>>>>>            Move -1                                      to aColumnType[i].iMinSize
100597>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
100598>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
100599>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
100600>>>>>>            Move -1                                      to aColumnType[i].sPrecision
100601>>>>>>            Increment i
100602>>>>>>
100602>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
100603>>>>>>            Move -3                                      to aColumnType[i].iSQLType
100604>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100605>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100606>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
100607>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100608>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
100609>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
100610>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
100611>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
100612>>>>>>            Increment i
100613>>>>>>
100613>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
100614>>>>>>            Move -98                                     to aColumnType[i].iSQLType
100615>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100616>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100617>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
100618>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100619>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
100620>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
100621>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
100622>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
100623>>>>>>            Increment i
100624>>>>>>
100624>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
100625>>>>>>            Move 12                                      to aColumnType[i].iSQLType
100626>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100627>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100628>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
100629>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100630>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
100631>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
100632>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
100633>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
100634>>>>>>            Increment i
100635>>>>>>
100635>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
100636>>>>>>            Move -99                                     to aColumnType[i].iSQLType
100637>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100638>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100639>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
100640>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100641>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
100642>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
100643>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
100644>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
100645>>>>>>            Increment i
100646>>>>>>
100646>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
100647>>>>>>            Move -370                                    to aColumnType[i].iSQLType
100648>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100649>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100650>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
100651>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100652>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
100653>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
100654>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
100655>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
100656>>>>>>            Increment i
100657>>>>>>
100657>>>>>>
100657>>>>>            
100657>>>>>//            Move eSQLServer_BIGINT  to ColumnType[i].iSQLType
100657>>>>>//            Move "BigInt"           to ColumnType[i].sSQLType
100657>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
100657>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
100657>>>>>//            Move "14.0"             to ColumnType[i].sPrecision
100657>>>>>//            Move True               to ColumnType[i].bCanEditSize
100657>>>>>//            Increment i
100657>>>>>//
100657>>>>>//            Move eSQLServer_BINARY  to ColumnType[i].iSQLType
100657>>>>>//            Move "Binary"           to ColumnType[i].sSQLType
100657>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
100657>>>>>//            Move "Binary"           to ColumnType[i].sDataFlexType
100657>>>>>//            Move "8000"             to ColumnType[i].sPrecision
100657>>>>>//            Increment i
100657>>>>>//
100657>>>>>//            Move eSQLServer_BIT     to ColumnType[i].iSQLType
100657>>>>>//            Move "Bit"              to ColumnType[i].sSQLType
100657>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
100657>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
100657>>>>>//            Move "1.0"              to ColumnType[i].sPrecision
100657>>>>>//            Move True               to ColumnType[i].bCanEditSize // In SQL allows 1, 0, or "NULL"
100657>>>>>//            Increment i
100657>>>>>//
100657>>>>>//            Move eSQLServer_CHAR    to ColumnType[i].iSQLType
100657>>>>>//            Move "Char"             to ColumnType[i].sSQLType
100657>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
100657>>>>>//            Move "Text"             to ColumnType[i].sDataFlexType
100657>>>>>//            Move "8000"             to ColumnType[i].sPrecision
100657>>>>>//            Increment i
100657>>>>>//
100657>>>>>//            Move eSQLServer_DATE    to ColumnType[i].iSQLType
100657>>>>>//            Move "Date"             to ColumnType[i].sSQLType
100657>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
100657>>>>>//            Move "Date"             to ColumnType[i].sDataFlexType
100657>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
100657>>>>>//            Move True               to ColumnType[i].bCanEditSize
100657>>>>>//            Increment i
100657>>>>>//
100657>>>>>//            Move eSQLServer_DATETIME    to ColumnType[i].iSQLType
100657>>>>>//            Move "DateTime"             to ColumnType[i].sSQLType
100657>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
100657>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
100657>>>>>//            Move "23.3"                 to ColumnType[i].sPrecision
100657>>>>>//            Move True                   to ColumnType[i].bCanEditSize
100657>>>>>//            Increment i
100657>>>>>//
100657>>>>>//            Move eSQLServer_DATETIME2   to ColumnType[i].iSQLType
100657>>>>>//            Move "DateTime2"            to ColumnType[i].sSQLType
100657>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
100657>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
100657>>>>>//            Move "23.6"                 to ColumnType[i].sPrecision
100657>>>>>//            Move True                   to ColumnType[i].bCanEditSize
100657>>>>>//            Increment i
100657>>>>>//
100657>>>>>//            Move eSQLServer_DATETIMEOFFSET  to ColumnType[i].iSQLType
100657>>>>>//            Move "DateTimeOffest"           to ColumnType[i].sSQLType
100657>>>>>//            Move DF_DATETIME                to ColumnType[i].iDataFlexType
100657>>>>>//            Move "DateTime"                 to ColumnType[i].sDataFlexType
100657>>>>>//            Move "23.0"                     to ColumnType[i].sPrecision
100657>>>>>//            Move True                       to ColumnType[i].bCanEditSize
100657>>>>>//            Increment i
100657>>>>>//
100657>>>>>//            Move eSQLServer_DECIMAL to ColumnType[i].iSQLType
100657>>>>>//            Move "Decimal"          to ColumnType[i].sSQLType
100657>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
100657>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
100657>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
100657>>>>>//            Increment i
100657>>>>>//
100657>>>>>//            Move eSQLServer_DOUBLE  to ColumnType[i].iSQLType
100657>>>>>//            Move "Double"           to ColumnType[i].sSQLType
100657>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
100657>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
100657>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
100657>>>>>//            Increment i
100657>>>>>//
100657>>>>>//            Move eSQLServer_FLOAT   to ColumnType[i].iSQLType
100657>>>>>//            Move "Float"            to ColumnType[i].sSQLType
100657>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
100657>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
100657>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
100657>>>>>//            Increment i
100657>>>>>//
100657>>>>>//            Move eSQLServer_INT     to ColumnType[i].iSQLType
100657>>>>>//            Move "Int"              to ColumnType[i].sSQLType
100657>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
100657>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
100657>>>>>//            Move "11.0"             to ColumnType[i].sPrecision
100657>>>>>//            Increment i
100657>>>>>//
100657>>>>>//            Move eSQLServer_NCHAR   to ColumnType[i].iSQLType
100657>>>>>//            Move "Nchar"            to ColumnType[i].sSQLType
100657>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
100657>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
100657>>>>>//            Move "4000"             to ColumnType[i].sPrecision
100657>>>>>//            Increment i
100657>>>>>//
100657>>>>>//            Move eSQLServer_NTEXT   to ColumnType[i].iSQLType
100657>>>>>//            Move "Ntext"            to ColumnType[i].sSQLType
100657>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
100657>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
100657>>>>>//            Move "16384"            to ColumnType[i].sPrecision
100657>>>>>//            Increment i
100657>>>>>//
100657>>>>>//            Move eSQLServer_NUMERIC to ColumnType[i].iSQLType
100657>>>>>//            Move "Numeric"          to ColumnType[i].sSQLType
100657>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
100657>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
100657>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
100657>>>>>//            Increment i
100657>>>>>//
100657>>>>>//            Move eSQLServer_NVARCHAR    to ColumnType[i].iSQLType
100657>>>>>//            Move "NvarChar"             to ColumnType[i].sSQLType
100657>>>>>//            Move DF_TEXT                to ColumnType[i].iDataFlexType
100657>>>>>//            Move "Text"                 to ColumnType[i].sDataFlexType
100657>>>>>//            Move "4000"                 to ColumnType[i].sPrecision
100657>>>>>//            Increment i
100657>>>>>//
100657>>>>>//            Move eSQLServer_NVARCHARMAX to ColumnType[i].iSQLType
100657>>>>>//            Move "NvarCharMax"          to ColumnType[i].sSQLType
100657>>>>>//            Move DF_TEXT                to ColumnType[i].iDataFlexType
100657>>>>>//            Move "Text"                 to ColumnType[i].sDataFlexType
100657>>>>>//            Move "16384"                to ColumnType[i].sPrecision
100657>>>>>//            Move True                   to ColumnType[i].bCanEditSize
100657>>>>>//            Increment i
100657>>>>>//
100657>>>>>//            Move eSQLServer_REAL    to ColumnType[i].iSQLType
100657>>>>>//            Move "Real"             to ColumnType[i].sSQLType
100657>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
100657>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
100657>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
100657>>>>>//            Increment i
100657>>>>>//
100657>>>>>//            Move eSQLServer_SMALLDATETIME   to ColumnType[i].iSQLType
100657>>>>>//            Move "SmallDateTime"            to ColumnType[i].sSQLType
100657>>>>>//            Move DF_DATETIME                to ColumnType[i].iDataFlexType
100657>>>>>//            Move "DATETIME"                 to ColumnType[i].sDataFlexType
100657>>>>>//            Move "23.0"                     to ColumnType[i].sPrecision
100657>>>>>//            Move True                       to ColumnType[i].bCanEditSize
100657>>>>>//            Increment i
100657>>>>>//
100657>>>>>//            Move eSQLServer_SMALLINT    to ColumnType[i].iSQLType
100657>>>>>//            Move "SmallInt"             to ColumnType[i].sSQLType
100657>>>>>//            Move DF_BCD                 to ColumnType[i].iDataFlexType
100657>>>>>//            Move "NUMERIC"              to ColumnType[i].sDataFlexType
100657>>>>>//            Move "6.0"                  to ColumnType[i].sPrecision
100657>>>>>//            Increment i
100657>>>>>//
100657>>>>>//            Move eSQLServer_TEXT    to ColumnType[i].iSQLType
100657>>>>>//            Move "Text"             to ColumnType[i].sSQLType
100657>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
100657>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
100657>>>>>//            Move "8000"             to ColumnType[i].sPrecision
100657>>>>>//            Move True               to ColumnType[i].bCanEditSize
100657>>>>>//            Increment i
100657>>>>>//
100657>>>>>//            Move eSQLServer_TIME    to ColumnType[i].iSQLType
100657>>>>>//            Move "Time"             to ColumnType[i].sSQLType
100657>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
100657>>>>>//            Move "Date"             to ColumnType[i].sDataFlexType
100657>>>>>//            Move "16.0"             to ColumnType[i].sPrecision
100657>>>>>//            Move True               to ColumnType[i].bCanEditSize
100657>>>>>//            Increment i
100657>>>>>//
100657>>>>>//            Move eSQLServer_TIMESTAMP   to ColumnType[i].iSQLType
100657>>>>>//            Move "TimeStamp"            to ColumnType[i].sSQLType
100657>>>>>//            Move DF_ASCII               to ColumnType[i].iDataFlexType
100657>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
100657>>>>>//            Move "8.0"                  to ColumnType[i].sPrecision
100657>>>>>//            Move True                   to ColumnType[i].bCanEditSize
100657>>>>>//            Increment i
100657>>>>>//
100657>>>>>//            Move eSQLServer_TINYINT to ColumnType[i].iSQLType
100657>>>>>//            Move "TinyInt"          to ColumnType[i].sSQLType
100657>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
100657>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
100657>>>>>//            Move "3.0"              to ColumnType[i].sPrecision
100657>>>>>//            Increment i
100657>>>>>//
100657>>>>>//            Move eSQLServer_GUID    to ColumnType[i].iSQLType
100657>>>>>//            Move "UniqueIdentifier" to ColumnType[i].sSQLType
100657>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
100657>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
100657>>>>>//            Move "38"               to ColumnType[i].sPrecision
100657>>>>>//            Move True               to ColumnType[i].bCanEditSize
100657>>>>>//            Increment i
100657>>>>>//
100657>>>>>//            Move eSQLServer_VARBINARY   to ColumnType[i].iSQLType
100657>>>>>//            Move "VarBinary"            to ColumnType[i].sSQLType
100657>>>>>//            Move DF_BINARY              to ColumnType[i].iDataFlexType
100657>>>>>//            Move "BINARY"               to ColumnType[i].sDataFlexType
100657>>>>>//            Move "8000"                 to ColumnType[i].sPrecision
100657>>>>>//            Increment i
100657>>>>>//
100657>>>>>//            Move eSQLServer_VARBINARYMAX to ColumnType[i].iSQLType
100657>>>>>//            Move "VarBinary(Max)"        to ColumnType[i].sSQLType
100657>>>>>//            Move DF_BINARY               to ColumnType[i].iDataFlexType
100657>>>>>//            Move "BINARY"                to ColumnType[i].sDataFlexType
100657>>>>>//            Move "16384"                 to ColumnType[i].sPrecision
100657>>>>>//            Move True                    to ColumnType[i].bCanEditSize
100657>>>>>//            Increment i
100657>>>>>//
100657>>>>>//            Move eSQLServer_VARCHAR to ColumnType[i].iSQLType
100657>>>>>//            Move "VarChar"          to ColumnType[i].sSQLType
100657>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
100657>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
100657>>>>>//            Move "8000"             to ColumnType[i].sPrecision
100657>>>>>//            Increment i
100657>>>>>//
100657>>>>>//            Move eSQLServer_VARCHARMAX  to ColumnType[i].iSQLType
100657>>>>>//            Move "VarChar(Max)"         to ColumnType[i].sSQLType
100657>>>>>//            Move DF_TEXT                to ColumnType[i].iDataFlexType
100657>>>>>//            Move "TEXT"                 to ColumnType[i].sDataFlexType
100657>>>>>//            Move "16384"                to ColumnType[i].sPrecision
100657>>>>>//            Move True                   to ColumnType[i].bCanEditSize
100657>>>>>//            Increment i
100657>>>>>//
100657>>>>>//            Move eSQLServer_SQLVARIANT  to ColumnType[i].iSQLType
100657>>>>>//            Move "SQL_Variant"          to ColumnType[i].sSQLType
100657>>>>>//            Move DF_BINARY              to ColumnType[i].iDataFlexType
100657>>>>>//            Move "Binary"               to ColumnType[i].sDataFlexType
100657>>>>>//            Move "8016"                 to ColumnType[i].sPrecision
100657>>>>>//            Move True                   to ColumnType[i].bCanEditSize
100657>>>>>//            Increment i
100657>>>>>//
100657>>>>>//            Move eSQLServer_XML     to ColumnType[i].iSQLType
100657>>>>>//            Move "XML"              to ColumnType[i].sSQLType
100657>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
100657>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
100657>>>>>//            Move "16384"            to ColumnType[i].sPrecision
100657>>>>>        End
100657>>>>>>
100657>>>>>
100657>>>>>        Function_Return aColumnType
100658>>>>>    End_Function
100659>>>>>
100659>>>>>    // MySQL Data Types
100659>>>>>    Function _UtilEnumerateMySQLTypes Returns tColumnType[]
100661>>>>>        tColumnType[] aColumnType
100661>>>>>        tColumnType[] aColumnType
100662>>>>>        Integer i
100662>>>>>        
Including file: mdsmysql_DriverDef.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\mdsmysql_DriverDef.inc)
100662>>>>>>// Generated By The Database Update Framework
100662>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdsmysql_DriverDef.xml
100662>>>>>>// Driver COLUMN DATA TYPES
100662>>>>>>//
100662>>>>>>// Created: 2018-03-14 23:46:49.593
100662>>>>>>
100662>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
100663>>>>>>            Move 8                                       to aColumnType[i].iSQLType
100664>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100665>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100666>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
100667>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100668>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
100669>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
100670>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
100671>>>>>>            Move 14                                      to aColumnType[i].sPrecision
100672>>>>>>            Increment i
100673>>>>>>
100673>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
100674>>>>>>            Move 16                                      to aColumnType[i].iSQLType
100675>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100676>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100677>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
100678>>>>>>            Move -1                                      to aColumnType[i].iMinSize
100679>>>>>>            Move 64                                      to aColumnType[i].nMaxSize
100680>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
100681>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
100682>>>>>>            Move 64                                      to aColumnType[i].sPrecision
100683>>>>>>            Increment i
100684>>>>>>
100684>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
100685>>>>>>            Move 252                                     to aColumnType[i].iSQLType
100686>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100687>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100688>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
100689>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100690>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
100691>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
100692>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
100693>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
100694>>>>>>            Increment i
100695>>>>>>
100695>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
100696>>>>>>            Move 254                                     to aColumnType[i].iSQLType
100697>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100698>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100699>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
100700>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100701>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
100702>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
100703>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
100704>>>>>>            Move 255                                     to aColumnType[i].sPrecision
100705>>>>>>            Increment i
100706>>>>>>
100706>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
100707>>>>>>            Move 10                                      to aColumnType[i].iSQLType
100708>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
100709>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100710>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
100711>>>>>>            Move -1                                      to aColumnType[i].iMinSize
100712>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
100713>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
100714>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
100715>>>>>>            Move 6                                       to aColumnType[i].sPrecision
100716>>>>>>            Increment i
100717>>>>>>
100717>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
100718>>>>>>            Move 12                                      to aColumnType[i].iSQLType
100719>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100720>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100721>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
100722>>>>>>            Move 6                                       to aColumnType[i].iMinSize
100723>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
100724>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
100725>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
100726>>>>>>            Move 23                                      to aColumnType[i].sPrecision
100727>>>>>>            Increment i
100728>>>>>>
100728>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
100729>>>>>>            Move 246                                     to aColumnType[i].iSQLType
100730>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100731>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100732>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
100733>>>>>>            Move -1                                      to aColumnType[i].iMinSize
100734>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
100735>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
100736>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
100737>>>>>>            Move 14                                      to aColumnType[i].sPrecision
100738>>>>>>            Increment i
100739>>>>>>
100739>>>>>>            Move "decimal-MySQL4"                        to aColumnType[i].sSQLType
100740>>>>>>            Move 0                                       to aColumnType[i].iSQLType
100741>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100742>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100743>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
100744>>>>>>            Move -1                                      to aColumnType[i].iMinSize
100745>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
100746>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
100747>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
100748>>>>>>            Move 14                                      to aColumnType[i].sPrecision
100749>>>>>>            Increment i
100750>>>>>>
100750>>>>>>            Move "double"                                to aColumnType[i].sSQLType
100751>>>>>>            Move 5                                       to aColumnType[i].iSQLType
100752>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100753>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100754>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
100755>>>>>>            Move -1                                      to aColumnType[i].iMinSize
100756>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
100757>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
100758>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
100759>>>>>>            Move 14                                      to aColumnType[i].sPrecision
100760>>>>>>            Increment i
100761>>>>>>
100761>>>>>>            Move "enum"                                  to aColumnType[i].sSQLType
100762>>>>>>            Move 247                                     to aColumnType[i].iSQLType
100763>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100764>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100765>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
100766>>>>>>            Move -1                                      to aColumnType[i].iMinSize
100767>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
100768>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
100769>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
100770>>>>>>            Move 255                                     to aColumnType[i].sPrecision
100771>>>>>>            Increment i
100772>>>>>>
100772>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
100773>>>>>>            Move 4                                       to aColumnType[i].iSQLType
100774>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100775>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100776>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
100777>>>>>>            Move -1                                      to aColumnType[i].iMinSize
100778>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
100779>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
100780>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
100781>>>>>>            Move 14                                      to aColumnType[i].sPrecision
100782>>>>>>            Increment i
100783>>>>>>
100783>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
100784>>>>>>            Move 3                                       to aColumnType[i].iSQLType
100785>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100786>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100787>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
100788>>>>>>            Move -1                                      to aColumnType[i].iMinSize
100789>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
100790>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
100791>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
100792>>>>>>            Move 11                                      to aColumnType[i].sPrecision
100793>>>>>>            Increment i
100794>>>>>>
100794>>>>>>            Move "longblob"                              to aColumnType[i].sSQLType
100795>>>>>>            Move 251                                     to aColumnType[i].iSQLType
100796>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100797>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100798>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
100799>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100800>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
100801>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
100802>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
100803>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
100804>>>>>>            Increment i
100805>>>>>>
100805>>>>>>            Move "longtext"                              to aColumnType[i].sSQLType
100806>>>>>>            Move -251                                    to aColumnType[i].iSQLType
100807>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100808>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100809>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
100810>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100811>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
100812>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
100813>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
100814>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
100815>>>>>>            Increment i
100816>>>>>>
100816>>>>>>            Move "mediumblob"                            to aColumnType[i].sSQLType
100817>>>>>>            Move 250                                     to aColumnType[i].iSQLType
100818>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100819>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100820>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
100821>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100822>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
100823>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
100824>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
100825>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
100826>>>>>>            Increment i
100827>>>>>>
100827>>>>>>            Move "mediumint"                             to aColumnType[i].sSQLType
100828>>>>>>            Move 9                                       to aColumnType[i].iSQLType
100829>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100830>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100831>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
100832>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100833>>>>>>            Move 9                                       to aColumnType[i].nMaxSize
100834>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
100835>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
100836>>>>>>            Move 9                                       to aColumnType[i].sPrecision
100837>>>>>>            Increment i
100838>>>>>>
100838>>>>>>            Move "mediumtext"                            to aColumnType[i].sSQLType
100839>>>>>>            Move -250                                    to aColumnType[i].iSQLType
100840>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100841>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100842>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
100843>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100844>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
100845>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
100846>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
100847>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
100848>>>>>>            Increment i
100849>>>>>>
100849>>>>>>            Move "set"                                   to aColumnType[i].sSQLType
100850>>>>>>            Move 248                                     to aColumnType[i].iSQLType
100851>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100852>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100853>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
100854>>>>>>            Move -1                                      to aColumnType[i].iMinSize
100855>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
100856>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
100857>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
100858>>>>>>            Move 255                                     to aColumnType[i].sPrecision
100859>>>>>>            Increment i
100860>>>>>>
100860>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
100861>>>>>>            Move 2                                       to aColumnType[i].iSQLType
100862>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100863>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100864>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
100865>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100866>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
100867>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
100868>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
100869>>>>>>            Move 6                                       to aColumnType[i].sPrecision
100870>>>>>>            Increment i
100871>>>>>>
100871>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
100872>>>>>>            Move -252                                    to aColumnType[i].iSQLType
100873>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100874>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100875>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
100876>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100877>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
100878>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
100879>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
100880>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
100881>>>>>>            Increment i
100882>>>>>>
100882>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
100883>>>>>>            Move 11                                      to aColumnType[i].iSQLType
100884>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
100885>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100886>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
100887>>>>>>            Move -1                                      to aColumnType[i].iMinSize
100888>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
100889>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
100890>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
100891>>>>>>            Move -1                                      to aColumnType[i].sPrecision
100892>>>>>>            Increment i
100893>>>>>>
100893>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
100894>>>>>>            Move 7                                       to aColumnType[i].iSQLType
100895>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100896>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100897>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
100898>>>>>>            Move 6                                       to aColumnType[i].iMinSize
100899>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
100900>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
100901>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
100902>>>>>>            Move 23                                      to aColumnType[i].sPrecision
100903>>>>>>            Increment i
100904>>>>>>
100904>>>>>>            Move "tinyblob"                              to aColumnType[i].sSQLType
100905>>>>>>            Move 249                                     to aColumnType[i].iSQLType
100906>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100907>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100908>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
100909>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100910>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
100911>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
100912>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
100913>>>>>>            Move 255                                     to aColumnType[i].sPrecision
100914>>>>>>            Increment i
100915>>>>>>
100915>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
100916>>>>>>            Move 1                                       to aColumnType[i].iSQLType
100917>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100918>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100919>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
100920>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100921>>>>>>            Move 4                                       to aColumnType[i].nMaxSize
100922>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
100923>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
100924>>>>>>            Move 4                                       to aColumnType[i].sPrecision
100925>>>>>>            Increment i
100926>>>>>>
100926>>>>>>            Move "tinytext"                              to aColumnType[i].sSQLType
100927>>>>>>            Move -249                                    to aColumnType[i].iSQLType
100928>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100929>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100930>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
100931>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100932>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
100933>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
100934>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
100935>>>>>>            Move 255                                     to aColumnType[i].sPrecision
100936>>>>>>            Increment i
100937>>>>>>
100937>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
100938>>>>>>            Move 253                                     to aColumnType[i].iSQLType
100939>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100940>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100941>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
100942>>>>>>            Move -1                                      to aColumnType[i].iMinSize
100943>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
100944>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
100945>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
100946>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
100947>>>>>>            Increment i
100948>>>>>>
100948>>>>>>            Move "year"                                  to aColumnType[i].sSQLType
100949>>>>>>            Move 13                                      to aColumnType[i].iSQLType
100950>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
100951>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100952>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
100953>>>>>>            Move -1                                      to aColumnType[i].iMinSize
100954>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
100955>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
100956>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
100957>>>>>>            Move -1                                      to aColumnType[i].sPrecision
100958>>>>>>            Increment i
100959>>>>>>
100959>>>>>>
100959>>>>>        
100959>>>>>//        Move eMySQL_LONGLONG    to ColumnType[i].iSQLType
100959>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
100959>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
100959>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
100959>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
100959>>>>>//        Increment i
100959>>>>>//
100959>>>>>//        Move eMySQL_BIT         to ColumnType[i].iSQLType
100959>>>>>//        Move "bit"              to ColumnType[i].sSQLType
100959>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
100959>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
100959>>>>>//        Move "4.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
100959>>>>>//        Move True               to ColumnType[i].bCanEditSize
100959>>>>>//        Increment i
100959>>>>>//
100959>>>>>//        Move eMySQL_BLOB        to ColumnType[i].iSQLType
100959>>>>>//        Move "blob"             to ColumnType[i].sSQLType
100959>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
100959>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
100959>>>>>//        Move "16384"            to ColumnType[i].sPrecision
100959>>>>>//        Increment i
100959>>>>>//
100959>>>>>//        Move eMySQL_STRING      to ColumnType[i].iSQLType
100959>>>>>//        Move "char"             to ColumnType[i].sSQLType
100959>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
100959>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
100959>>>>>//        Move "254"              to ColumnType[i].sPrecision
100959>>>>>//        Increment i
100959>>>>>//
100959>>>>>//        Move eMySQL_DATE        to ColumnType[i].iSQLType
100959>>>>>//        Move "date"             to ColumnType[i].sSQLType
100959>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
100959>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
100959>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
100959>>>>>//        Move True               to ColumnType[i].bCanEditSize
100959>>>>>//        Increment i
100959>>>>>//
100959>>>>>//        Move eMySQL_DATETIME    to ColumnType[i].iSQLType
100959>>>>>//        Move "datetime"         to ColumnType[i].sSQLType
100959>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
100959>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
100959>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
100959>>>>>//        Move True               to ColumnType[i].bCanEditSize
100959>>>>>//        Increment i
100959>>>>>//
100959>>>>>//        Move eMySQL_DECIMAL     to ColumnType[i].iSQLType
100959>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
100959>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
100959>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
100959>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
100959>>>>>//        Increment i
100959>>>>>//
100959>>>>>//        Move eMySQL_DOUBLE      to ColumnType[i].iSQLType
100959>>>>>//        Move "double"           to ColumnType[i].sSQLType
100959>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
100959>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
100959>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
100959>>>>>//        Increment i
100959>>>>>//
100959>>>>>//        Move eMySQL_ENUM        to ColumnType[i].iSQLType
100959>>>>>//        Move "enum"             to ColumnType[i].sSQLType
100959>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
100959>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
100959>>>>>//        Move "254"              to ColumnType[i].sPrecision
100959>>>>>//        Increment i
100959>>>>>//
100959>>>>>//        Move eMySQL_FLOAT       to ColumnType[i].iSQLType
100959>>>>>//        Move "float"            to ColumnType[i].sSQLType
100959>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
100959>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
100959>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
100959>>>>>//        Increment i
100959>>>>>//
100959>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
100959>>>>>//        Move "int"              to ColumnType[i].sSQLType
100959>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
100959>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
100959>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
100959>>>>>//        Increment i
100959>>>>>//
100959>>>>>//        Move eMySQL_LONG_BLOB   to ColumnType[i].iSQLType
100959>>>>>//        Move "longblob"         to ColumnType[i].sSQLType
100959>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
100959>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
100959>>>>>//        Move "16384"            to ColumnType[i].sPrecision
100959>>>>>//        Increment i
100959>>>>>//
100959>>>>>//        Move eMySQL_LONG_TEXT   to ColumnType[i].iSQLType
100959>>>>>//        Move "longtext"         to ColumnType[i].sSQLType
100959>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
100959>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
100959>>>>>//        Move "16384"            to ColumnType[i].sPrecision
100959>>>>>//        Increment i
100959>>>>>//
100959>>>>>//        Move eMySQL_MEDIUM_BLOB to ColumnType[i].iSQLType
100959>>>>>//        Move "mediumblob"       to ColumnType[i].sSQLType
100959>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
100959>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
100959>>>>>//        Move "16384"            to ColumnType[i].sPrecision
100959>>>>>//        Increment i
100959>>>>>//
100959>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
100959>>>>>//        Move "mediumint"        to ColumnType[i].sSQLType
100959>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
100959>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
100959>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
100959>>>>>//
100959>>>>>//        Move eMySQL_MEDIUM_TEXT to ColumnType[i].iSQLType
100959>>>>>//        Move "mediumtext"       to ColumnType[i].sSQLType
100959>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
100959>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
100959>>>>>//        Move "16384"            to ColumnType[i].sPrecision
100959>>>>>//        Increment i
100959>>>>>//
100959>>>>>//        Move eMySQL_SET         to ColumnType[i].iSQLType
100959>>>>>//        Move "set"              to ColumnType[i].sSQLType
100959>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
100959>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
100959>>>>>//        Move "254"              to ColumnType[i].sPrecision
100959>>>>>//        Increment i
100959>>>>>//
100959>>>>>//        Move eMySQL_SHORT       to ColumnType[i].iSQLType
100959>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
100959>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
100959>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
100959>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
100959>>>>>//        Increment i
100959>>>>>//
100959>>>>>//        Move eMySQL_TEXT        to ColumnType[i].iSQLType
100959>>>>>//        Move "text"             to ColumnType[i].sSQLType
100959>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
100959>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
100959>>>>>//        Move "16384"            to ColumnType[i].sPrecision
100959>>>>>//        Increment i
100959>>>>>//
100959>>>>>//        Move eMySQL_TIME        to ColumnType[i].iSQLType
100959>>>>>//        Move "time"             to ColumnType[i].sSQLType
100959>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
100959>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
100959>>>>>//        Move "10.0"             to ColumnType[i].sPrecision
100959>>>>>//        Move True               to ColumnType[i].bCanEditSize
100959>>>>>//        Increment i
100959>>>>>//
100959>>>>>//        Move eMySQL_TIMESTAMP   to ColumnType[i].iSQLType
100959>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
100959>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
100959>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
100959>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
100959>>>>>//        Move True               to ColumnType[i].bCanEditSize
100959>>>>>//        Increment i
100959>>>>>//
100959>>>>>//        Move eMySQL_TINY_BLOB   to ColumnType[i].iSQLType
100959>>>>>//        Move "tinyblob"         to ColumnType[i].sSQLType
100959>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
100959>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
100959>>>>>//        Move "254"              to ColumnType[i].sPrecision
100959>>>>>//        Increment i
100959>>>>>//
100959>>>>>//        Move eMySQL_TINY        to ColumnType[i].iSQLType
100959>>>>>//        Move "tinyint"          to ColumnType[i].sSQLType
100959>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
100959>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
100959>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
100959>>>>>//        Increment i
100959>>>>>//
100959>>>>>//        Move eMySQL_TINY_TEXT   to ColumnType[i].iSQLType
100959>>>>>//        Move "tinytext"         to ColumnType[i].sSQLType
100959>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
100959>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
100959>>>>>//        Move "254"              to ColumnType[i].sPrecision
100959>>>>>//        Increment i
100959>>>>>//
100959>>>>>//        Move eMySQL_VAR_STRING  to ColumnType[i].iSQLType
100959>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
100959>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
100959>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
100959>>>>>//        Move "16384"            to ColumnType[i].sPrecision
100959>>>>>//        Increment i
100959>>>>>//
100959>>>>>//        Move eMySQL_YEAR        to ColumnType[i].iSQLType
100959>>>>>//        Move "year"             to ColumnType[i].sSQLType
100959>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
100959>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
100959>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
100959>>>>>//        Move True               to ColumnType[i].bCanEditSize
100959>>>>>//        Increment i
100959>>>>>
100959>>>>>        Function_Return aColumnType
100960>>>>>    End_Function
100961>>>>>
100961>>>>>    // Oracle Data Types
100961>>>>>    Function _UtilEnumerateOracleTypes Returns tColumnType[]
100963>>>>>        tColumnType[] aColumnType
100963>>>>>        tColumnType[] aColumnType
100964>>>>>        Integer i
100964>>>>>        
Including file: ora_drv_DriverDef.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\ora_drv_DriverDef.inc)
100964>>>>>>// Generated By The Database Update Framework
100964>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\ora_drv_DriverDef.xml
100964>>>>>>// Driver COLUMN DATA TYPES
100964>>>>>>//
100964>>>>>>// Created: 2018-03-14 23:47:34.82
100964>>>>>>
100964>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
100965>>>>>>            Move 113                                     to aColumnType[i].iSQLType
100966>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100967>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100968>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
100969>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100970>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
100971>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
100972>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
100973>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
100974>>>>>>            Increment i
100975>>>>>>
100975>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
100976>>>>>>            Move 96                                      to aColumnType[i].iSQLType
100977>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100978>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100979>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
100980>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100981>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
100982>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
100983>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
100984>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
100985>>>>>>            Increment i
100986>>>>>>
100986>>>>>>            Move "clob"                                  to aColumnType[i].sSQLType
100987>>>>>>            Move 112                                     to aColumnType[i].iSQLType
100988>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100989>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100990>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
100991>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100992>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
100993>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
100994>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
100995>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
100996>>>>>>            Increment i
100997>>>>>>
100997>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
100998>>>>>>            Move 12                                      to aColumnType[i].iSQLType
100999>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
101000>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
101001>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
101002>>>>>>            Move 6                                       to aColumnType[i].iMinSize
101003>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
101004>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
101005>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
101006>>>>>>            Move 6                                       to aColumnType[i].sPrecision
101007>>>>>>            Increment i
101008>>>>>>
101008>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
101009>>>>>>            Move 4                                       to aColumnType[i].iSQLType
101010>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
101011>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
101012>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
101013>>>>>>            Move 1                                       to aColumnType[i].iMinSize
101014>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
101015>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
101016>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
101017>>>>>>            Move 14                                      to aColumnType[i].sPrecision
101018>>>>>>            Increment i
101019>>>>>>
101019>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
101020>>>>>>            Move 3                                       to aColumnType[i].iSQLType
101021>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
101022>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
101023>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
101024>>>>>>            Move 1                                       to aColumnType[i].iMinSize
101025>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
101026>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
101027>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
101028>>>>>>            Move 14                                      to aColumnType[i].sPrecision
101029>>>>>>            Increment i
101030>>>>>>
101030>>>>>>            Move "intervalds"                            to aColumnType[i].sSQLType
101031>>>>>>            Move 190                                     to aColumnType[i].iSQLType
101032>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
101033>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
101034>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
101035>>>>>>            Move -1                                      to aColumnType[i].iMinSize
101036>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
101037>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
101038>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
101039>>>>>>            Move -1                                      to aColumnType[i].sPrecision
101040>>>>>>            Increment i
101041>>>>>>
101041>>>>>>            Move "intervalym"                            to aColumnType[i].sSQLType
101042>>>>>>            Move 189                                     to aColumnType[i].iSQLType
101043>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
101044>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
101045>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
101046>>>>>>            Move -1                                      to aColumnType[i].iMinSize
101047>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
101048>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
101049>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
101050>>>>>>            Move -1                                      to aColumnType[i].sPrecision
101051>>>>>>            Increment i
101052>>>>>>
101052>>>>>>            Move "long"                                  to aColumnType[i].sSQLType
101053>>>>>>            Move 8                                       to aColumnType[i].iSQLType
101054>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
101055>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
101056>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
101057>>>>>>            Move 1                                       to aColumnType[i].iMinSize
101058>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
101059>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
101060>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
101061>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
101062>>>>>>            Increment i
101063>>>>>>
101063>>>>>>            Move "longraw"                               to aColumnType[i].sSQLType
101064>>>>>>            Move 24                                      to aColumnType[i].iSQLType
101065>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
101066>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
101067>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
101068>>>>>>            Move 1                                       to aColumnType[i].iMinSize
101069>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
101070>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
101071>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
101072>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
101073>>>>>>            Increment i
101074>>>>>>
101074>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
101075>>>>>>            Move 286                                     to aColumnType[i].iSQLType
101076>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
101077>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
101078>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
101079>>>>>>            Move 1                                       to aColumnType[i].iMinSize
101080>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
101081>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
101082>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
101083>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
101084>>>>>>            Increment i
101085>>>>>>
101085>>>>>>            Move "nclob"                                 to aColumnType[i].sSQLType
101086>>>>>>            Move 288                                     to aColumnType[i].iSQLType
101087>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
101088>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
101089>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
101090>>>>>>            Move 1                                       to aColumnType[i].iMinSize
101091>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
101092>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
101093>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
101094>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
101095>>>>>>            Increment i
101096>>>>>>
101096>>>>>>            Move "number"                                to aColumnType[i].sSQLType
101097>>>>>>            Move 2                                       to aColumnType[i].iSQLType
101098>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
101099>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
101100>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
101101>>>>>>            Move 1                                       to aColumnType[i].iMinSize
101102>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
101103>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
101104>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
101105>>>>>>            Move 14                                      to aColumnType[i].sPrecision
101106>>>>>>            Increment i
101107>>>>>>
101107>>>>>>            Move "nvarchar2"                             to aColumnType[i].sSQLType
101108>>>>>>            Move 287                                     to aColumnType[i].iSQLType
101109>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
101110>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
101111>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
101112>>>>>>            Move 1                                       to aColumnType[i].iMinSize
101113>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
101114>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
101115>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
101116>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
101117>>>>>>            Increment i
101118>>>>>>
101118>>>>>>            Move "raw"                                   to aColumnType[i].sSQLType
101119>>>>>>            Move 23                                      to aColumnType[i].iSQLType
101120>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
101121>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
101122>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
101123>>>>>>            Move 1                                       to aColumnType[i].iMinSize
101124>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
101125>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
101126>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
101127>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
101128>>>>>>            Increment i
101129>>>>>>
101129>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
101130>>>>>>            Move 187                                     to aColumnType[i].iSQLType
101131>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
101132>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
101133>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
101134>>>>>>            Move -1                                      to aColumnType[i].iMinSize
101135>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
101136>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
101137>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
101138>>>>>>            Move -1                                      to aColumnType[i].sPrecision
101139>>>>>>            Increment i
101140>>>>>>
101140>>>>>>            Move "timestampltz"                          to aColumnType[i].sSQLType
101141>>>>>>            Move 232                                     to aColumnType[i].iSQLType
101142>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
101143>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
101144>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
101145>>>>>>            Move -1                                      to aColumnType[i].iMinSize
101146>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
101147>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
101148>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
101149>>>>>>            Move -1                                      to aColumnType[i].sPrecision
101150>>>>>>            Increment i
101151>>>>>>
101151>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
101152>>>>>>            Move 188                                     to aColumnType[i].iSQLType
101153>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
101154>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
101155>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
101156>>>>>>            Move -1                                      to aColumnType[i].iMinSize
101157>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
101158>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
101159>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
101160>>>>>>            Move -1                                      to aColumnType[i].sPrecision
101161>>>>>>            Increment i
101162>>>>>>
101162>>>>>>            Move "varchar2"                              to aColumnType[i].sSQLType
101163>>>>>>            Move 1                                       to aColumnType[i].iSQLType
101164>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
101165>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
101166>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
101167>>>>>>            Move 1                                       to aColumnType[i].iMinSize
101168>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
101169>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
101170>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
101171>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
101172>>>>>>            Increment i
101173>>>>>>
101173>>>>>>
101173>>>>>        
101173>>>>>//        Move eOracle_BLOB       to ColumnType[i].iSQLType
101173>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
101173>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
101173>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
101173>>>>>//        Move "16384"            to ColumnType[i].sPrecision
101173>>>>>//        Increment i
101173>>>>>//
101173>>>>>//        Move eOracle_CHAR       to ColumnType[i].iSQLType
101173>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
101173>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
101173>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
101173>>>>>//        Move "2000"             to ColumnType[i].sPrecision
101173>>>>>//        Increment i
101173>>>>>//
101173>>>>>//        Move eOracle_CLOB       to ColumnType[i].iSQLType
101173>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
101173>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
101173>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
101173>>>>>//        Move "16384"            to ColumnType[i].sPrecision
101173>>>>>//        Increment i
101173>>>>>//
101173>>>>>//        Move eOracle_DATE       to ColumnType[i].iSQLType
101173>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
101173>>>>>//        Move DF_Date            to ColumnType[i].iDataFlexType
101173>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
101173>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
101173>>>>>//        Move True               to ColumnType[i].bCanEditSize
101173>>>>>//        Increment i
101173>>>>>//
101173>>>>>//        Move eOracle_FLOAT      to ColumnType[i].iSQLType
101173>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
101173>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
101173>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
101173>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
101173>>>>>//        Increment i
101173>>>>>//
101173>>>>>//        Move eOracle_INT        to ColumnType[i].iSQLType
101173>>>>>//        Move "INT"              to ColumnType[i].sSQLType
101173>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
101173>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
101173>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
101173>>>>>//        Increment i
101173>>>>>//
101173>>>>>//        Move eOracle_INTERVALDS to ColumnType[i].iSQLType
101173>>>>>//        Move "INTERVALDAYTOSEC" to ColumnType[i].sSQLType
101173>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
101173>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
101173>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
101173>>>>>//        Move True               to ColumnType[i].bCanEditSize
101173>>>>>//        Increment i
101173>>>>>//
101173>>>>>//        Move eOracle_INTERVALYM  to ColumnType[i].iSQLType
101173>>>>>//        Move "INTERVALYEARTOMON" to ColumnType[i].sSQLType
101173>>>>>//        Move DF_DATETIME         to ColumnType[i].iDataFlexType
101173>>>>>//        Move "DateTime"          to ColumnType[i].sDataFlexType
101173>>>>>//        Move "23.0"              to ColumnType[i].sPrecision
101173>>>>>//        Move True                to ColumnType[i].bCanEditSize
101173>>>>>//        Increment i
101173>>>>>//
101173>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
101173>>>>>//        Move "LONG"             to ColumnType[i].sSQLType
101173>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
101173>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
101173>>>>>//        Move "16384"            to ColumnType[i].sPrecision
101173>>>>>//        Increment i
101173>>>>>//
101173>>>>>//        Move eOracle_LONGRAW    to ColumnType[i].iSQLType
101173>>>>>//        Move "LONG RAW"         to ColumnType[i].sSQLType
101173>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
101173>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
101173>>>>>//        Move "16384"            to ColumnType[i].sPrecision
101173>>>>>//        Increment i
101173>>>>>//
101173>>>>>//        Move eOracle_NCHAR      to ColumnType[i].iSQLType
101173>>>>>//        Move "NCHAR"            to ColumnType[i].sSQLType
101173>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
101173>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
101173>>>>>//        Move "2000"             to ColumnType[i].sPrecision
101173>>>>>//        Increment i
101173>>>>>//
101173>>>>>//        Move eOracle_NCLOB      to ColumnType[i].iSQLType
101173>>>>>//        Move "NCLOB"            to ColumnType[i].sSQLType
101173>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
101173>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
101173>>>>>//        Move "16384"            to ColumnType[i].sPrecision
101173>>>>>//        Increment i
101173>>>>>//
101173>>>>>//        Move eOracle_NUMBER     to ColumnType[i].iSQLType
101173>>>>>//        Move "NUMBER"           to ColumnType[i].sSQLType
101173>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
101173>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
101173>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
101173>>>>>//        Increment i
101173>>>>>//
101173>>>>>//        Move eOracle_NVARCHAR2  to ColumnType[i].iSQLType
101173>>>>>//        Move "NVARCHAR2"        to ColumnType[i].sSQLType
101173>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
101173>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
101173>>>>>//        Move "4000"             to ColumnType[i].sPrecision
101173>>>>>//        Increment i
101173>>>>>//
101173>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
101173>>>>>//        Move "RAW"              to ColumnType[i].sSQLType
101173>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
101173>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
101173>>>>>//        Move "2000"             to ColumnType[i].sPrecision
101173>>>>>//        Increment i
101173>>>>>//
101173>>>>>//        Move eOracle_ROWID      to ColumnType[i].iSQLType
101173>>>>>//        Move "ROWID"            to ColumnType[i].sSQLType
101173>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
101173>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
101173>>>>>//        Move "16384"            to ColumnType[i].sPrecision
101173>>>>>//        Increment i
101173>>>>>//
101173>>>>>//        Move eOracle_TIMESTAMP  to ColumnType[i].iSQLType
101173>>>>>//        Move "TimeStamp"        to ColumnType[i].sSQLType
101173>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
101173>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
101173>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
101173>>>>>//        Move True               to ColumnType[i].bCanEditSize
101173>>>>>//        Increment i
101173>>>>>//
101173>>>>>//        Move eOracle_TIMESTAMPLTZ   to ColumnType[i].iSQLType
101173>>>>>//        Move "TIMESTAMPLOCALTZ"     to ColumnType[i].sSQLType
101173>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
101173>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
101173>>>>>//        Move "13.0"                 to ColumnType[i].sPrecision
101173>>>>>//        Move True                   to ColumnType[i].bCanEditSize
101173>>>>>//        Increment i
101173>>>>>//
101173>>>>>//        Move eOracle_TIMESTAMPTZ    to ColumnType[i].iSQLType
101173>>>>>//        Move "TIMEZONETIMEZONE"     to ColumnType[i].sSQLType
101173>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
101173>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
101173>>>>>//        Move "11.0"                 to ColumnType[i].sPrecision
101173>>>>>//        Move True                   to ColumnType[i].bCanEditSize
101173>>>>>//        Increment i
101173>>>>>//
101173>>>>>//        Move eOracle_VARCHAR2   to ColumnType[i].iSQLType
101173>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
101173>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
101173>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
101173>>>>>//        Move "16384"            to ColumnType[i].sPrecision
101173>>>>>
101173>>>>>        Function_Return aColumnType
101174>>>>>    End_Function
101175>>>>>
101175>>>>>    // PostgreSQL Data Types
101175>>>>>    Function _UtilEnumeratePostgreSQLTypes Returns tColumnType[]
101177>>>>>        tColumnType[] aColumnType
101177>>>>>        tColumnType[] aColumnType
101178>>>>>        Integer i
101178>>>>>        
Including file: mdspgsql_DriverDef.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\mdspgsql_DriverDef.inc)
101178>>>>>>// Generated By The Database Update Framework
101178>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdspgsql_DriverDef.xml
101178>>>>>>// Driver COLUMN DATA TYPES
101178>>>>>>//
101178>>>>>>// Created: 2018-03-14 23:47:02.984
101178>>>>>>
101178>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
101179>>>>>>            Move 20                                      to aColumnType[i].iSQLType
101180>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
101181>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
101182>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
101183>>>>>>            Move 1                                       to aColumnType[i].iMinSize
101184>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
101185>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
101186>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
101187>>>>>>            Move 14                                      to aColumnType[i].sPrecision
101188>>>>>>            Increment i
101189>>>>>>
101189>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
101190>>>>>>            Move 1560                                    to aColumnType[i].iSQLType
101191>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
101192>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
101193>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
101194>>>>>>            Move 1                                       to aColumnType[i].iMinSize
101195>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
101196>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
101197>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
101198>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
101199>>>>>>            Increment i
101200>>>>>>
101200>>>>>>            Move "boolean"                               to aColumnType[i].sSQLType
101201>>>>>>            Move 16                                      to aColumnType[i].iSQLType
101202>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
101203>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
101204>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
101205>>>>>>            Move -1                                      to aColumnType[i].iMinSize
101206>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
101207>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
101208>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
101209>>>>>>            Move -1                                      to aColumnType[i].sPrecision
101210>>>>>>            Increment i
101211>>>>>>
101211>>>>>>            Move "bytea"                                 to aColumnType[i].sSQLType
101212>>>>>>            Move 17                                      to aColumnType[i].iSQLType
101213>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
101214>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
101215>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
101216>>>>>>            Move 1                                       to aColumnType[i].iMinSize
101217>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
101218>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
101219>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
101220>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
101221>>>>>>            Increment i
101222>>>>>>
101222>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
101223>>>>>>            Move 18                                      to aColumnType[i].iSQLType
101224>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
101225>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
101226>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
101227>>>>>>            Move 1                                       to aColumnType[i].iMinSize
101228>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
101229>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
101230>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
101231>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
101232>>>>>>            Increment i
101233>>>>>>
101233>>>>>>            Move "citext"                                to aColumnType[i].sSQLType
101234>>>>>>            Move -25                                     to aColumnType[i].iSQLType
101235>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
101236>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
101237>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
101238>>>>>>            Move 1                                       to aColumnType[i].iMinSize
101239>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
101240>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
101241>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
101242>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
101243>>>>>>            Increment i
101244>>>>>>
101244>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
101245>>>>>>            Move 1082                                    to aColumnType[i].iSQLType
101246>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
101247>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
101248>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
101249>>>>>>            Move -1                                      to aColumnType[i].iMinSize
101250>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
101251>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
101252>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
101253>>>>>>            Move 6                                       to aColumnType[i].sPrecision
101254>>>>>>            Increment i
101255>>>>>>
101255>>>>>>            Move "double"                                to aColumnType[i].sSQLType
101256>>>>>>            Move 701                                     to aColumnType[i].iSQLType
101257>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
101258>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
101259>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
101260>>>>>>            Move 1                                       to aColumnType[i].iMinSize
101261>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
101262>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
101263>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
101264>>>>>>            Move 14                                      to aColumnType[i].sPrecision
101265>>>>>>            Increment i
101266>>>>>>
101266>>>>>>            Move "integer"                               to aColumnType[i].sSQLType
101267>>>>>>            Move 23                                      to aColumnType[i].iSQLType
101268>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
101269>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
101270>>>>>>            Move 11                                      to aColumnType[i].iDefaultSize
101271>>>>>>            Move 1                                       to aColumnType[i].iMinSize
101272>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
101273>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
101274>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
101275>>>>>>            Move 11                                      to aColumnType[i].sPrecision
101276>>>>>>            Increment i
101277>>>>>>
101277>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
101278>>>>>>            Move 790                                     to aColumnType[i].iSQLType
101279>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
101280>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
101281>>>>>>            Move 30                                      to aColumnType[i].iDefaultSize
101282>>>>>>            Move 1                                       to aColumnType[i].iMinSize
101283>>>>>>            Move 30                                      to aColumnType[i].nMaxSize
101284>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
101285>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
101286>>>>>>            Move 30                                      to aColumnType[i].sPrecision
101287>>>>>>            Increment i
101288>>>>>>
101288>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
101289>>>>>>            Move 1700                                    to aColumnType[i].iSQLType
101290>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
101291>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
101292>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
101293>>>>>>            Move 1                                       to aColumnType[i].iMinSize
101294>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
101295>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
101296>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
101297>>>>>>            Move 14                                      to aColumnType[i].sPrecision
101298>>>>>>            Increment i
101299>>>>>>
101299>>>>>>            Move "oid"                                   to aColumnType[i].sSQLType
101300>>>>>>            Move 26                                      to aColumnType[i].iSQLType
101301>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
101302>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
101303>>>>>>            Move 20                                      to aColumnType[i].iDefaultSize
101304>>>>>>            Move -1                                      to aColumnType[i].iMinSize
101305>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
101306>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
101307>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
101308>>>>>>            Move -1                                      to aColumnType[i].sPrecision
101309>>>>>>            Increment i
101310>>>>>>
101310>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
101311>>>>>>            Move 700                                     to aColumnType[i].iSQLType
101312>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
101313>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
101314>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
101315>>>>>>            Move 1                                       to aColumnType[i].iMinSize
101316>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
101317>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
101318>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
101319>>>>>>            Move 6                                       to aColumnType[i].sPrecision
101320>>>>>>            Increment i
101321>>>>>>
101321>>>>>>            Move "regproc"                               to aColumnType[i].sSQLType
101322>>>>>>            Move 24                                      to aColumnType[i].iSQLType
101323>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
101324>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
101325>>>>>>            Move 64                                      to aColumnType[i].iDefaultSize
101326>>>>>>            Move -1                                      to aColumnType[i].iMinSize
101327>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
101328>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
101329>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
101330>>>>>>            Move -1                                      to aColumnType[i].sPrecision
101331>>>>>>            Increment i
101332>>>>>>
101332>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
101333>>>>>>            Move 21                                      to aColumnType[i].iSQLType
101334>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
101335>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
101336>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
101337>>>>>>            Move 1                                       to aColumnType[i].iMinSize
101338>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
101339>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
101340>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
101341>>>>>>            Move 6                                       to aColumnType[i].sPrecision
101342>>>>>>            Increment i
101343>>>>>>
101343>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
101344>>>>>>            Move 25                                      to aColumnType[i].iSQLType
101345>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
101346>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
101347>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
101348>>>>>>            Move 1                                       to aColumnType[i].iMinSize
101349>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
101350>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
101351>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
101352>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
101353>>>>>>            Increment i
101354>>>>>>
101354>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
101355>>>>>>            Move 1083                                    to aColumnType[i].iSQLType
101356>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
101357>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
101358>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
101359>>>>>>            Move 8                                       to aColumnType[i].iMinSize
101360>>>>>>            Move 15                                      to aColumnType[i].nMaxSize
101361>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
101362>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
101363>>>>>>            Move 15                                      to aColumnType[i].sPrecision
101364>>>>>>            Increment i
101365>>>>>>
101365>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
101366>>>>>>            Move 1114                                    to aColumnType[i].iSQLType
101367>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
101368>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
101369>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
101370>>>>>>            Move -1                                      to aColumnType[i].iMinSize
101371>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
101372>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
101373>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
101374>>>>>>            Move -1                                      to aColumnType[i].sPrecision
101375>>>>>>            Increment i
101376>>>>>>
101376>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
101377>>>>>>            Move 1184                                    to aColumnType[i].iSQLType
101378>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
101379>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
101380>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
101381>>>>>>            Move -1                                      to aColumnType[i].iMinSize
101382>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
101383>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
101384>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
101385>>>>>>            Move -1                                      to aColumnType[i].sPrecision
101386>>>>>>            Increment i
101387>>>>>>
101387>>>>>>            Move "uuid"                                  to aColumnType[i].sSQLType
101388>>>>>>            Move 2950                                    to aColumnType[i].iSQLType
101389>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
101390>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
101391>>>>>>            Move 40                                      to aColumnType[i].iDefaultSize
101392>>>>>>            Move -1                                      to aColumnType[i].iMinSize
101393>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
101394>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
101395>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
101396>>>>>>            Move -1                                      to aColumnType[i].sPrecision
101397>>>>>>            Increment i
101398>>>>>>
101398>>>>>>            Move "varbit"                                to aColumnType[i].sSQLType
101399>>>>>>            Move 1562                                    to aColumnType[i].iSQLType
101400>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
101401>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
101402>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
101403>>>>>>            Move 1                                       to aColumnType[i].iMinSize
101404>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
101405>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
101406>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
101407>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
101408>>>>>>            Increment i
101409>>>>>>
101409>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
101410>>>>>>            Move 1043                                    to aColumnType[i].iSQLType
101411>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
101412>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
101413>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
101414>>>>>>            Move 1                                       to aColumnType[i].iMinSize
101415>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
101416>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
101417>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
101418>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
101419>>>>>>            Increment i
101420>>>>>>
101420>>>>>>
101420>>>>>        
101420>>>>>//        Move ePgSQL_INT8        to ColumnType[i].iSQLType
101420>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
101420>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
101420>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
101420>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
101420>>>>>//        Move True               to ColumnType[i].bCanEditSize
101420>>>>>//        Increment i
101420>>>>>//
101420>>>>>//        Move ePgSQL_BIT         to ColumnType[i].iSQLType
101420>>>>>//        Move "bit"              to ColumnType[i].sSQLType
101420>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
101420>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
101420>>>>>//        Move "16384"            to ColumnType[i].sPrecision
101420>>>>>//        Increment i
101420>>>>>//
101420>>>>>//        Move ePgSQL_BOOL        to ColumnType[i].iSQLType
101420>>>>>//        Move "boolean"          to ColumnType[i].sSQLType
101420>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
101420>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
101420>>>>>//        Move "1"                to ColumnType[i].sPrecision
101420>>>>>//        Increment i
101420>>>>>//
101420>>>>>//        Move ePgSQL_BYTEA       to ColumnType[i].iSQLType
101420>>>>>//        Move "bytea"            to ColumnType[i].sSQLType
101420>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
101420>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
101420>>>>>//        Move "16384"            to ColumnType[i].sPrecision
101420>>>>>//        Increment i
101420>>>>>//
101420>>>>>//        Move ePgSQL_CHAR        to ColumnType[i].iSQLType
101420>>>>>//        Move "char"             to ColumnType[i].sSQLType
101420>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
101420>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
101420>>>>>//        Move "2000"             to ColumnType[i].sPrecision
101420>>>>>//        Increment i
101420>>>>>//
101420>>>>>//        Move ePgSQL_CITEXT      to ColumnType[i].iSQLType
101420>>>>>//        Move "citext"           to ColumnType[i].sSQLType
101420>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
101420>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
101420>>>>>//        Move "254"              to ColumnType[i].sPrecision
101420>>>>>//        Increment i
101420>>>>>//
101420>>>>>//        Move ePgSQL_DATE        to ColumnType[i].iSQLType
101420>>>>>//        Move "date"             to ColumnType[i].sSQLType
101420>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
101420>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
101420>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
101420>>>>>//        Move True               to ColumnType[i].bCanEditSize
101420>>>>>//        Increment i
101420>>>>>//
101420>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
101420>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
101420>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
101420>>>>>//        Move "Decimal"          to ColumnType[i].sDataFlexType
101420>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
101420>>>>>//        Increment i
101420>>>>>//
101420>>>>>//        Move ePgSQL_FLOAT8      to ColumnType[i].iSQLType
101420>>>>>//        Move "double"           to ColumnType[i].sSQLType
101420>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
101420>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
101420>>>>>//        Move "22"               to ColumnType[i].sPrecision
101420>>>>>//        Increment i
101420>>>>>//
101420>>>>>//        Move ePgSQL_INT4        to ColumnType[i].iSQLType
101420>>>>>//        Move "integer"          to ColumnType[i].sSQLType
101420>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
101420>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
101420>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
101420>>>>>//        Increment i
101420>>>>>//
101420>>>>>//        Move ePgSQL_MONEY       to ColumnType[i].iSQLType
101420>>>>>//        Move "money"            to ColumnType[i].sSQLType
101420>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
101420>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
101420>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
101420>>>>>//        Increment i
101420>>>>>//
101420>>>>>//        Move ePgSQL_OID         to ColumnType[i].iSQLType
101420>>>>>//        Move "oid"              to ColumnType[i].sSQLType
101420>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
101420>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
101420>>>>>//        Move "16384"            to ColumnType[i].sPrecision
101420>>>>>//        Increment i
101420>>>>>//
101420>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
101420>>>>>//        Move "real"             to ColumnType[i].sSQLType
101420>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
101420>>>>>//        Move "Real"             to ColumnType[i].sDataFlexType
101420>>>>>//        Move "6.6"              to ColumnType[i].sPrecision
101420>>>>>//        Increment i
101420>>>>>//
101420>>>>>//        Move ePgSQL_REGPROC     to ColumnType[i].iSQLType
101420>>>>>//        Move "regproc"          to ColumnType[i].sSQLType
101420>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
101420>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
101420>>>>>//        Move "64"               to ColumnType[i].sPrecision
101420>>>>>//        Increment i
101420>>>>>//
101420>>>>>//        Move ePgSQL_INT2        to ColumnType[i].iSQLType
101420>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
101420>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
101420>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
101420>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
101420>>>>>//        Increment i
101420>>>>>//
101420>>>>>//        Move ePgSQL_TEXT        to ColumnType[i].iSQLType
101420>>>>>//        Move "text"             to ColumnType[i].sSQLType
101420>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
101420>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
101420>>>>>//        Move "16384"            to ColumnType[i].sPrecision
101420>>>>>//        Increment i
101420>>>>>//
101420>>>>>//        Move ePgSQL_TIME        to ColumnType[i].iSQLType
101420>>>>>//        Move "time"             to ColumnType[i].sSQLType
101420>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
101420>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
101420>>>>>//        Move "15.0"             to ColumnType[i].sPrecision
101420>>>>>//        Increment i
101420>>>>>//
101420>>>>>//        Move ePgSQL_TIMESTAMP   to ColumnType[i].iSQLType
101420>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
101420>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
101420>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
101420>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
101420>>>>>//        Move True               to ColumnType[i].bCanEditSize
101420>>>>>//        Increment i
101420>>>>>//
101420>>>>>//        Move ePgSQL_UUID        to ColumnType[i].iSQLType
101420>>>>>//        Move "uuid"             to ColumnType[i].sSQLType
101420>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
101420>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
101420>>>>>//        Move "40"               to ColumnType[i].sPrecision
101420>>>>>//        Move True               to ColumnType[i].bCanEditSize
101420>>>>>//        Increment i
101420>>>>>//
101420>>>>>//        Move ePgSQL_VARCHAR     to ColumnType[i].iSQLType
101420>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
101420>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
101420>>>>>//        Move "DF_TEXT"          to ColumnType[i].sDataFlexType
101420>>>>>//        Move "16384"            to ColumnType[i].sPrecision
101420>>>>>//        Increment i
101420>>>>>
101420>>>>>        Function_Return aColumnType
101421>>>>>    End_Function
101422>>>>>
101422>>>>>    // Internal usage. Use the UtilColumnTypeXXX functions instead.
101422>>>>>    Function _UtilColumnType String sDriverID Integer iDbType Integer iType String sType Boolean bIntegerInputType Returns tColumnType
101424>>>>>        Integer iValue iSize iCount iStart
101424>>>>>        tColumnType[] ColumnTypeArray
101424>>>>>        tColumnType[] ColumnTypeArray
101425>>>>>        tColumnType RetvalType
101425>>>>>        tColumnType RetvalType
101425>>>>>        String sValue
101425>>>>>        Boolean bFrameworkDataFlexType
101425>>>>>
101425>>>>>        Move "Undefined" to RetvalType.sSQLType
101426>>>>>        Move -1999       to RetvalType.iSQLType
101427>>>>>
101427>>>>>        Move 0 to iStart
101428>>>>>        Move (Uppercase(sType)) to sType
101429>>>>>        Move (iType <= -1490) to bFrameworkDataFlexType
101430>>>>>        If (bFrameworkDataFlexType = True) Begin
101432>>>>>            Get UtilDUFDataTypeToSqlTypeMapping sDriverID iDbType iType to RetvalType
101433>>>>>            Function_Return RetvalType
101434>>>>>        End
101434>>>>>>
101434>>>>>
101434>>>>>        Get UtilEnumerateColumnTypes sDriverID iDbType to ColumnTypeArray
101435>>>>>
101435>>>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
101436>>>>>        Decrement iSize
101437>>>>>
101437>>>>>        for iCount from iStart to iSize
101443>>>>>>
101443>>>>>            Move ColumnTypeArray[iCount].iSQLType to iValue
101444>>>>>            Move ColumnTypeArray[iCount].sSQLType to sValue
101445>>>>>            If (bIntegerInputType = True) Begin
101447>>>>>                If (iValue = iType) Begin
101449>>>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
101450>>>>>                    Move iType                                  to RetvalType.iSQLType
101451>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
101452>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
101453>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
101454>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
101455>>>>>                    Move iSize to iCount // We're done!
101456>>>>>                End
101456>>>>>>
101456>>>>>            End
101456>>>>>>
101456>>>>>            Else Begin
101457>>>>>                Move (Uppercase(sValue)) to sValue
101458>>>>>                If (sValue = sType) Begin
101460>>>>>                    Move sType                                  to RetvalType.sSQLType
101461>>>>>                    Move ColumnTypeArray[iCount].iSQLType       to RetvalType.iSQLType
101462>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
101463>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
101464>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
101465>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
101466>>>>>                    Move iSize to iCount // We're done!
101467>>>>>                End
101467>>>>>>
101467>>>>>            End
101467>>>>>>
101467>>>>>        Loop
101468>>>>>>
101468>>>>>
101468>>>>>        // If no match was found it was probably because it was a DataFlex standard type that was passed.
101468>>>>>        // In which case we search for a match in DataFlex standard types:
101468>>>>>        If (RetvalType.sSQLType = "Undefined") Begin
101470>>>>>            Get _UtilEnumerateDataFlexTypes to ColumnTypeArray
101471>>>>>            Move (SizeOfArray(ColumnTypeArray)) to iSize
101472>>>>>            Decrement iSize
101473>>>>>
101473>>>>>            for iCount from iStart to iSize
101479>>>>>>
101479>>>>>                Move ColumnTypeArray[iCount].iSQLType to iValue
101480>>>>>                Move ColumnTypeArray[iCount].sSQLType to sValue
101481>>>>>                If (iValue = iType) Begin
101483>>>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
101484>>>>>                    Move iType                                  to RetvalType.iSQLType
101485>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
101486>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
101487>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
101488>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
101489>>>>>                    Move iSize to iCount // We're done!
101490>>>>>                End
101490>>>>>>
101490>>>>>            Loop
101491>>>>>>
101491>>>>>        End
101491>>>>>>
101491>>>>>
101491>>>>>        Function_Return RetvalType
101492>>>>>    End_Function
101493>>>>>
101493>>>>>    Function _AllTablesToConvert Returns Integer[]
101495>>>>>        Integer[] aTableConvertExceptions iTablesArray
101497>>>>>        Handle hTable
101497>>>>>        Integer iIndex
101497>>>>>        String sTableName
101497>>>>>        Boolean bFlexErrs
101497>>>>>
101497>>>>>        // a) Get the exception table array the developer has specified
101497>>>>>        Get paTableConvertExceptions to aTableConvertExceptions
101498>>>>>
101498>>>>>        // b) Add CodeMast, CodeType & DbVersion to exceptions
101498>>>>>        Repeat
101498>>>>>>
101498>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
101501>>>>>            If (hTable <> 0) Begin
101503>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
101506>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
101507>>>>>                If (bFlexErrs = False) Begin
101509>>>>>                    If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "DBVERSION") Begin
101511>>>>>                        Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
101512>>>>>                        If (iIndex = -1) Begin
101514>>>>>                            Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
101515>>>>>                        End
101515>>>>>>
101515>>>>>                    End
101515>>>>>>
101515>>>>>                End
101515>>>>>>
101515>>>>>            End
101515>>>>>>
101515>>>>>        Until (hTable = 0)
101517>>>>>
101517>>>>>        Move 0 to hTable
101518>>>>>
101518>>>>>        // c) Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
101518>>>>>        Repeat
101518>>>>>>
101518>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
101521>>>>>            If (hTable > 0) Begin
101523>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
101526>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
101527>>>>>                If (bFlexErrs = False) Begin
101529>>>>>                    Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
101530>>>>>                    If (iIndex = -1) Begin
101532>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
101533>>>>>                    End
101533>>>>>>
101533>>>>>                End
101533>>>>>>
101533>>>>>            End
101533>>>>>>
101533>>>>>        Until (hTable = 0)
101535>>>>>
101535>>>>>        Function_Return iTablesArray
101536>>>>>    End_Function
101537>>>>>
101537>>>>>    Function _AllTablesDateCorrections Returns Integer[]
101539>>>>>        Integer[] aTableDateCorrectionExceptions iTablesArray
101541>>>>>        Handle hTable
101541>>>>>        Integer iIndex
101541>>>>>        String sTableName
101541>>>>>        Boolean bFlexErrs
101541>>>>>
101541>>>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
101542>>>>>        Move 0 to hTable
101543>>>>>
101543>>>>>        // Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
101543>>>>>        Repeat
101543>>>>>>
101543>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
101546>>>>>            If (hTable > 0) Begin
101548>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
101551>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
101552>>>>>                If (bFlexErrs = False) Begin
101554>>>>>                    Move (SearchArray(hTable, aTableDateCorrectionExceptions)) to iIndex
101555>>>>>                    If (iIndex = -1) Begin
101557>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
101558>>>>>                    End
101558>>>>>>
101558>>>>>                End
101558>>>>>>
101558>>>>>            End
101558>>>>>>
101558>>>>>        Until (hTable = 0)
101560>>>>>
101560>>>>>        Function_Return iTablesArray
101561>>>>>    End_Function
101562>>>>>
101562>>>>>    Function _AppendAPIColumn tAPIColumn[] aCurrent String sFieldName Integer iType Integer iLength Integer iPrecision Integer iOptions Returns tAPIColumn[]
101564>>>>>        tAPIColumn NewAPIColumn
101564>>>>>        tAPIColumn NewAPIColumn
101564>>>>>
101564>>>>>        Move sFieldName to NewAPIColumn.sFieldName
101565>>>>>        Move iType      to NewAPIColumn.iType
101566>>>>>        Move iLength    to NewAPIColumn.iLength
101567>>>>>        Move iPrecision to NewAPIColumn.iPrecision
101568>>>>>        Move iOptions   to NewAPIColumn.iOptions
101569>>>>>
101569>>>>>        Move NewAPIColumn to aCurrent[SizeOfArray(aCurrent)]
101570>>>>>
101570>>>>>        Function_Return aCurrent
101571>>>>>    End_Function
101572>>>>>
101572>>>>>    Function _UtilIndexAppendSegmentFieldNames tAPIIndexSegment[] APIIndexSegment Returns String
101574>>>>>        String sRetval sFieldName
101574>>>>>        Integer iCount iSize
101574>>>>>
101574>>>>>        Move (SizeOfArray(APIIndexSegment)) to iSize
101575>>>>>        Decrement iSize
101576>>>>>        for iCount from 0 to iSize
101582>>>>>>
101582>>>>>            Move APIIndexSegment[iCount].sFieldName to sFieldName
101583>>>>>            Move (sRetval * (String(sFieldName))) to sRetval
101584>>>>>        Loop
101585>>>>>>
101585>>>>>        Move (Trim(sRetval)) to sRetval
101586>>>>>
101586>>>>>        Function_Return sRetval
101587>>>>>    End_Function
101588>>>>>
101588>>>>>    // *** Miscellaneous other functions ***
101588>>>>>    // Some of which can be used by both "Sqlxxx" and "Apixxx" functions.
101588>>>>>    //
101588>>>>>
101588>>>>>    // Callback functionality used when e.g. calling driver functions directly.
101588>>>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
101590>>>>>        Integer iPerc
101590>>>>>        Number nReady nTotal
101590>>>>>
101590>>>>>        Send DoAdvance of ghoProgressBar
101591>>>>>
101591>>>>>        If (sCallback_Text contains "Copy records") Begin
101593>>>>>            Move CS_SQLCopyingData to sCallback_Text
101594>>>>>        End
101594>>>>>>
101594>>>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
101596>>>>>            Move (Replace("Dropping index", sCallback_Text, CS_SQLDeletingIndex)) to sCallback_Text
101597>>>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_SQLDeletingIndex)) to sCallback_Text
101598>>>>>        End
101598>>>>>>
101598>>>>>        If (sCallback_Text contains "Creating index") Begin
101600>>>>>            Move (Replace("Creating index", sCallback_Text, CS_SQLCreatingIndex)) to sCallback_Text
101601>>>>>        End
101601>>>>>>
101601>>>>>
101601>>>>>        Case Begin
101601>>>>>            Case (iCallback_Type = DF_Message_Text)
101603>>>>>//                Set Message_Text of ghoStatusPanel to sCallback_Text
101603>>>>>                Set Action_Text  of ghoStatusPanel to ""
101604>>>>>                Case Break
101605>>>>>            Case (iCallback_Type = DF_Message_Heading_1)
101608>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
101609>>>>>                Set Action_Text  of ghoStatusPanel to ""
101610>>>>>                Case Break
101611>>>>>            Case (iCallback_Type = DF_Message_Heading_2)
101614>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
101615>>>>>                Set Action_Text  of ghoStatusPanel to ""
101616>>>>>                Case Break
101617>>>>>            Case (iCallback_Type = DF_Message_Heading_3)
101620>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
101621>>>>>                Set Action_Text  of ghoStatusPanel to ""
101622>>>>>                Case Break
101623>>>>>            Case (iCallback_Type = DF_Message_Heading_4)
101626>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
101627>>>>>                Set Action_Text  of ghoStatusPanel to ""
101628>>>>>                Case Break
101629>>>>>            Case (iCallback_Type = DF_Message_Heading_5)
101632>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
101633>>>>>                Set Action_Text  of ghoStatusPanel to ""
101634>>>>>                Case Break
101635>>>>>            Case (iCallback_Type = DF_Message_Warning)
101638>>>>>                Send None
101639>>>>>                Case Break
101640>>>>>            Case (iCallback_Type = DF_Message_Progress_Title)
101643>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
101644>>>>>                Set Action_Text  of ghoStatusPanel to ""
101645>>>>>                Case Break
101646>>>>>            Case (iCallback_Type = DF_Message_Progress_Value)
101649>>>>>                //*** Interpret numbers
101649>>>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
101650>>>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
101651>>>>>                Move ((nReady / nTotal) * 100)                                                    to iPerc
101652>>>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% Done (Total Number of Records:") * String(nTotal) + ")")
101653>>>>>                Case Break
101654>>>>>            Case Else
101654>>>>>                Set Message_Text to ""
101655>>>>>                Set Action_Text  to ""
101656>>>>>        Case End
101656>>>>>
101656>>>>>        Send ProcessEvents of ghoStatusPanel
101657>>>>>        Function_Return False
101658>>>>>    End_Function
101659>>>>>
101659>>>>>    Procedure IncreaseSortBufferSize
101661>>>>>        String sNull
101661>>>>>        Integer iSortBufferSize
101661>>>>>        Boolean bBufferSet
101661>>>>>
101661>>>>>        Move "" to sNull
101662>>>>>        Move (1024 * 128) to iSortBufferSize
101663>>>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_SET_MAX_SORT_BUFFER Callback ghoDbUpdateHandler Passing sNull sNull iSortBufferSize Result bBufferSet
101668>>>>>
101668>>>>>    End_Procedure
101669>>>>>
101669>>>>>    Procedure SetAllIndexesToBatch Handle hTable Boolean bSetToBatch
101671>>>>>        Integer iLastIndex iIndex iNumSegments
101671>>>>>        Boolean bOK    
101671>>>>>        String sDriverID
101671>>>>>
101671>>>>>        If (hTable > 0) Begin
101673>>>>>            Get UtilDriverFromTableNumber hTable to sDriverID
101674>>>>>            Close hTable
101675>>>>>            Get OpenTableExclusive hTable to bOK
101676>>>>>            If (bOK = False) Begin
101678>>>>>                Function_Return False
101679>>>>>            End
101679>>>>>>
101679>>>>>            Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex   
101682>>>>>            Structure_Start hTable sDriverID
101683>>>>>                for iIndex from 1 to iLastIndex
101689>>>>>>
101689>>>>>                    Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
101692>>>>>                    If (iNumSegments > 0) Begin                     
101694>>>>>                        If (bSetToBatch = True) Begin
101696>>>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_BATCH
101699>>>>>                        End                 
101699>>>>>>
101699>>>>>                        Else Begin
101700>>>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_ONLINE
101703>>>>>                        End
101703>>>>>>
101703>>>>>                    End
101703>>>>>>
101703>>>>>                Loop
101704>>>>>>
101704>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
101706>>>>>        End
101706>>>>>>
101706>>>>>    End_Procedure
101707>>>>>
101707>>>>>    Function NextFreeFilelistSlot Returns Handle
101709>>>>>        Handle hTable
101709>>>>>
101709>>>>>        Move 0 to hTable
101710>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of hTable to hTable
101713>>>>>
101713>>>>>        Function_Return hTable
101714>>>>>    End_Function
101715>>>>>
101715>>>>>    // For debugging purposes. To print Sql statements as they are build...
101715>>>>>    Procedure DebugPrint String sStmt String sFileName
101717>>>>>        Integer iCh
101717>>>>>        Get Seq_Append_Output_Channel sFileName to iCh
101718>>>>>            Write channel iCh sStmt
101720>>>>>        Send Seq_Close_Channel iCh
101721>>>>>    End_Procedure
101722>>>>>
101722>>>>>    // Returns the integer number for the passed Driver ID that is
101722>>>>>    // needed by some database API calls.
101722>>>>>    Function DriverIndex String sDriverID Returns Integer
101724>>>>>        String  sCurrentDriver
101724>>>>>        Integer iNumberOfDrivers iDriver iCount
101724>>>>>
101724>>>>>        Move 0 to iDriver
101725>>>>>
101725>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
101728>>>>>        for iCount from 1 to iNumberOfDrivers
101734>>>>>>
101734>>>>>
101734>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
101737>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
101739>>>>>                Move iCount to iDriver
101740>>>>>            End
101740>>>>>>
101740>>>>>        Loop
101741>>>>>>
101741>>>>>
101741>>>>>        // In case it was not found, it wasn't loaded so we do that now.
101741>>>>>        If (iDriver = 0) Begin
101743>>>>>            Move False to Err
101744>>>>>            Load_Driver sDriverID
101745>>>>>            If (Err = False) Begin
101747>>>>>                Move 1 to iDriver
101748>>>>>            End
101748>>>>>>
101748>>>>>        End
101748>>>>>>
101748>>>>>
101748>>>>>        Function_Return iDriver
101749>>>>>    End_Function
101750>>>>>
101750>>>>>    // Returns TRUE if table is opened exclusive, otherwise FALSE
101750>>>>>    // Note: If run from the Studio, CodeMast & CodeType _is_ open by the Studio,
101750>>>>>    //       so in that case we "cheat" and report those tables were opened OK.
101750>>>>>    Function OpenTableExclusive Handle hTable Returns Boolean
101752>>>>>        Integer iMode
101752>>>>>        Boolean bOpened
101752>>>>>        String sTableName
101752>>>>>
101752>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
101753>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
101756>>>>>        If (bOpened) Begin
101758>>>>>            If (IsDebuggerPresent()) Begin
101760>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
101763>>>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
101765>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
101766>>>>>                    Function_Return True
101767>>>>>                End
101767>>>>>>
101767>>>>>            End
101767>>>>>>
101767>>>>>            Get_Attribute DF_FILE_OPEN_MODE of hTable to iMode
101770>>>>>            If (iMode=DF_EXCLUSIVE) Begin
101772>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
101773>>>>>                Function_Return True
101774>>>>>            End
101774>>>>>>
101774>>>>>            Close hTable
101775>>>>>        End
101775>>>>>>
101775>>>>>        Else Begin
101776>>>>>            Open hTable
101778>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
101781>>>>>            If (bOpened and IsDebuggerPresent()) Begin
101783>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
101786>>>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
101788>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
101789>>>>>                    Function_Return True
101790>>>>>                End
101790>>>>>>
101790>>>>>            End
101790>>>>>>
101790>>>>>
101790>>>>>        End
101790>>>>>>
101790>>>>>        
101790>>>>>        Close hTable
101791>>>>>        Open hTable Mode DF_EXCLUSIVE
101793>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
101796>>>>>
101796>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
101797>>>>>        Function_Return bOpened
101798>>>>>    End_Function
101799>>>>>
101799>>>>>    Function AutoConnectionIDLogin Returns Boolean
101801>>>>>        String sConnectionID sConnectionString sDriverID
101801>>>>>        Boolean bExists bOK bSQLDriver
101801>>>>>        Handle hoCLI hoDriver
101801>>>>>        Integer iRetval
101801>>>>>        tSQLConnection SQLConnection
101801>>>>>        tSQLConnection SQLConnection
101801>>>>>
101801>>>>>        Get psDriverID to sDriverID
101802>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
101803>>>>>        If (bSQLDriver = False) Begin
101805>>>>>            Function_Return True
101806>>>>>        End
101806>>>>>>
101806>>>>>
101806>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
101807>>>>>        Move SQLConnection.sDriverID                  to sDriverID
101808>>>>>        Move SQLConnection.sConnectionString          to sConnectionString
101809>>>>>        Get IsDAWSQLDriver sDriverID to bOK
101810>>>>>        If (bOK = True) Begin
101812>>>>>//            Get SQLLogin of ghoSQLConnectionHandler SQLConnection to bOK
101812>>>>>        End
101812>>>>>>
101812>>>>>        If (bOK = False) Begin
101814>>>>>            Get _MertechSQLManagerHandle to hoCLI
101815>>>>>            Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
101816>>>>>            Set psDriverID of hoDriver to SQLConnection.sDriverID
101817>>>>>            If (SQLConnection.sDriverID <> DATAFLEX_ID) Begin
101819>>>>>                Get DbLogin  of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
101820>>>>>                Send Destroy of hoDriver
101821>>>>>            End
101821>>>>>>
101821>>>>>            Function_Return False
101822>>>>>        End
101822>>>>>>
101822>>>>>
101822>>>>>        Move SQLConnection.sConnectionID to sConnectionID
101823>>>>>
101823>>>>>        Get IsConnectionID sConnectionID sDriverID to bExists
101824>>>>>        If (bExists = False) Begin
101826>>>>>            // We always start by deleting the current connection - if any - because the
101826>>>>>            // login details my have changed.
101826>>>>>            Get phoCLIHandler to hoCLI
101827>>>>>            Set psDriverID    of hoCLI to sDriverID
101828>>>>>            Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
101829>>>>>            Get UtilCreateConnectionID sConnectionID to bOk
101830>>>>>            If (bOk = False) Begin
101832>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be changed.")
101833>>>>>>
101833>>>>>                Function_Return False
101834>>>>>            End
101834>>>>>>
101834>>>>>            Move bOK to bExists
101835>>>>>        End
101835>>>>>>
101835>>>>>
101835>>>>>        Function_Return (bExists = True)
101836>>>>>    End_Function
101837>>>>>
101837>>>>>    // Scans to see if all tables can be opened exclusivly. I.e. that nobody else is running the application.
101837>>>>>    // Returns: False if nobody else is running
101837>>>>>    //          True if at least one table is open by another process (e.g. another user is running the application)
101837>>>>>    // N.B! Only works for Embedded DataFlex Tables! It will _not_ work for Sql tables because; these
101837>>>>>    //      tables are not locked as DataFlex tables are.
101837>>>>>    Function IsDatabaseInUse Returns Boolean
101839>>>>>        Handle  hTable
101839>>>>>        String  sRootName
101839>>>>>        Boolean bOpen bErr bAlias bOK bIsSQLTable bFlexErrs
101839>>>>>        Integer iCount iTables
101839>>>>>        
101839>>>>>        Move 0 to iTables
101840>>>>>        Set Action_Text of ghoStatusPanel to "Database in use check..."
101841>>>>>        Get AutoConnectionIDLogin to bOK
101842>>>>>        Get UtilFilelistNoOfTables to iTables
101843>>>>>        Set piPosition   of ghoProgressBar to 0
101844>>>>>        Set piAdvanceBy  of ghoProgressBar to 1      
101845>>>>>        Set piMaximum    of ghoProgressBar to iTables
101846>>>>>        Move 0 to hTable
101847>>>>>        Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
101850>>>>>        Move False to bErr
101851>>>>>        Send Ignore_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
101852>>>>>
101852>>>>>        Repeat
101852>>>>>>
101852>>>>>            Set piPosition of ghoProgressBar to iCount
101853>>>>>            Increment iCount
101854>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
101857>>>>>            Move (Uppercase(sRootName) = "FLEXERRS")  to bFlexErrs
101858>>>>>
101858>>>>>            // This test is only applicable for DataFlex embedded tables; so skip test if driver based table.
101858>>>>>            Get UtilTableIsSQLByRootName sRootName to bIsSQLTable
101859>>>>>            Move False to bOpen
101860>>>>>
101860>>>>>            // Don't bother about FlexErrs (Normally table 50)
101860>>>>>            If (bIsSQLTable = False and hTable <> 0 and bFlexErrs = False) Begin
101862>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
101863>>>>>                Open hTable
101865>>>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
101868>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
101869>>>>>                If (bOpen = True) Begin
101871>>>>>                    // We cannot open an Alias file exclusive as it will generate an error (4177 - "File in use")
101871>>>>>                    Get UtilTableIsAlias hTable to bAlias
101872>>>>>                    If (bAlias = False) Begin
101874>>>>>                        Close hTable
101875>>>>>                        Get OpenTableExclusive hTable to bOpen
101876>>>>>                        If (bOpen = False) Begin
101878>>>>>                            Move True to bErr
101879>>>>>                        End
101879>>>>>>
101879>>>>>                    End
101879>>>>>>
101879>>>>>                End
101879>>>>>>
101879>>>>>                Close hTable
101880>>>>>            End
101880>>>>>>
101880>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
101883>>>>>            If (bErr = True ) ;                Break
101886>>>>>        Until (not(hTable))
101888>>>>>
101888>>>>>        Set Action_Text of ghoStatusPanel to ""
101889>>>>>        Send Trap_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
101890>>>>>        Move False to Err
101891>>>>>
101891>>>>>        Function_Return bErr
101892>>>>>    End_Function
101893>>>>>
101893>>>>>    // Checks if the passed connection id exists in the CLI interface.
101893>>>>>    // This might be needed by API-methods when a connection id is to be used and
101893>>>>>    // the connection id hasn't been established with the driver's CLI interface.
101893>>>>>    // NOTE: Only applicable for DAW drivers.
101893>>>>>    Function IsConnectionID String sConnectionID String sDriverID Returns Boolean
101895>>>>>        String sID sConnString
101895>>>>>        Integer iDriver iNumConn iCount
101895>>>>>        Handle hoCLI
101895>>>>>        Boolean bOK
101895>>>>>
101895>>>>>        Get IsDAWSQLDriver sDriverID to bOK
101896>>>>>        If (bOK = False) Begin
101898>>>>>            Error DFERR_PROGRAM "Connection ID's can only be used with DAW drivers (not Mertech)."
101899>>>>>>
101899>>>>>            Function_Return False
101900>>>>>        End
101900>>>>>>
101900>>>>>
101900>>>>>        Move False to bOK
101901>>>>>        Get phoCLIHandler to hoCLI
101902>>>>>        If (hoCLI <> 0) Begin
101904>>>>>            Set psDriverID of hoCLI to sDriverID
101905>>>>>            Get DriverIndex of hoCLI sDriverID to iDriver
101906>>>>>
101906>>>>>            // If driver not loaded; load it.
101906>>>>>            If (iDriver = 0) Begin
101908>>>>>                Load_Driver sDriverID
101909>>>>>                Get DriverIndex sDriverID to iDriver
101910>>>>>            End
101910>>>>>>
101910>>>>>            If (iDriver <> 0) Begin
101912>>>>>                Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
101915>>>>>                Decrement iNumConn
101916>>>>>                for iCount from 0 to iNumConn
101922>>>>>>
101922>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iCount to sConnString
101925>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iCount to sID
101928>>>>>                    If (sID = sConnectionID) Begin
101930>>>>>                        Move True to bOK
101931>>>>>                    End
101931>>>>>>
101931>>>>>                Loop
101932>>>>>>
101932>>>>>            End
101932>>>>>>
101932>>>>>        End
101932>>>>>>
101932>>>>>
101932>>>>>        Function_Return bOK
101933>>>>>    End_Function
101934>>>>>
101934>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
101936>>>>>        Boolean bOK
101936>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
101937>>>>>        Function_Return bOK
101938>>>>>    End_Function
101939>>>>>
101939>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
101941>>>>>        Boolean bOK
101941>>>>>        Move False to bOK
101942>>>>>        Move (sDriverID = SQLFLEX or sDriverID = ORAFLEX or sDriverID = MDSPgSQL or sDriverID = MDSMySQL) to bOK
101943>>>>>        Function_Return bOK
101944>>>>>    End_Function
101945>>>>>
101945>>>>>    Function IsMSSQLDriver Returns Boolean
101947>>>>>        Integer iDriverIndex
101947>>>>>
101947>>>>>        Get DriverIndex MSSQLDRV_ID to iDriverIndex
101948>>>>>
101948>>>>>        Function_Return (iDriverIndex <> 0)
101949>>>>>    End_Function
101950>>>>>
101950>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
101950>>>>>    // attempt to load the driver.
101950>>>>>    // Returns true if the passed driver is SQL based.
101950>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
101952>>>>>        Boolean bOK
101952>>>>>
101952>>>>>        Get IsDAWSQLDriver sDriverID to bOK
101953>>>>>
101953>>>>>        If (bOK = False) Begin
101955>>>>>            Get IsMertechDriver sDriverID to bOK
101956>>>>>        End
101956>>>>>>
101956>>>>>
101956>>>>>        Function_Return bOK
101957>>>>>    End_Function
101958>>>>>
101958>>>>>    // *** Error Handler ***
101958>>>>>    //
101958>>>>>    // Note: If the cDbUpdateHandler & cDbUpdateVersion classes are used this error handler is _not_
101958>>>>>    //       used. Instead the Error_Report in the cDbUpdateHandler i used.
101958>>>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
101960>>>>>        Integer iSize iErrorMode
101960>>>>>        tSqlErrorArray aSqlErrorArray
101960>>>>>        tSqlErrorArray aSqlErrorArray
101960>>>>>
101960>>>>>        If (pbProcessingError(Self)) Begin
101962>>>>>            Procedure_Return
101963>>>>>        End
101963>>>>>>
101963>>>>>
101963>>>>>        Get Error_Report_Mode to iErrorMode
101964>>>>>        If (iErrorMode = DUF_ERROR_NO_REPORT) Begin
101966>>>>>            Procedure_Return
101967>>>>>        End
101967>>>>>>
101967>>>>>
101967>>>>>        Set pbProcessingError to True
101968>>>>>        Set pbSqlError to True
101969>>>>>        Get paSqlErrorArray      to aSqlErrorArray
101970>>>>>        Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iSize
101971>>>>>        Move sErrorText          to aSqlErrorArray.sSqlErrorArray[iSize]
101972>>>>>        Get psSQLStatementString to aSqlErrorArray.sSqlStatementArray[iSize]
101973>>>>>        Move iErrorNumber        to aSqlErrorArray.iSqlErrorArray[iSize]
101974>>>>>        Set paSqlErrorArray      to aSqlErrorArray
101975>>>>>        Set pbProcessingError to False
101976>>>>>    End_Procedure
101977>>>>>
101977>>>>>    // *** Miscellanous Helper Functions ***
101977>>>>>    //
101977>>>>>    // Helper function. Takes a DF_FILE_XXXX_NAME value as parameter and
101977>>>>>    // returns the table name only; stripped of any path or filename extension.
101977>>>>>    Function _TableNameOnly String sName Returns String
101979>>>>>        String sPath sExt
101979>>>>>
101979>>>>>        Get ParseFolderName sName to sPath
101980>>>>>        If (sPath <> "") Begin
101982>>>>>            Move (Replace(sPath, sName, "")) to sName
101983>>>>>        End
101983>>>>>>
101983>>>>>        Get ParseFileExtension sName to sExt
101984>>>>>        If (sExt <> "") Begin
101986>>>>>            Move (Replace(("." + sExt), sName, "")) to sName
101987>>>>>        End
101987>>>>>>
101987>>>>>
101987>>>>>        Function_Return sName
101988>>>>>    End_Function
101989>>>>>
101989>>>>>    // Removes any prefix to a table name.
101989>>>>>    // Example mssqldrv:mytable returns mytable
101989>>>>>    //         dbo.mytable returns mytable
101989>>>>>    Function _TableNoPrefix String sName Returns String
101991>>>>>        Integer iPos
101991>>>>>
101991>>>>>        Move (Pos(":", sName)) to iPos
101992>>>>>        If (iPos <> 0) Begin
101994>>>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
101995>>>>>        End
101995>>>>>>
101995>>>>>        Move (Pos(".", sName)) to iPos
101996>>>>>        If (iPos <> 0) Begin
101998>>>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
101999>>>>>        End
101999>>>>>>
101999>>>>>
101999>>>>>        Function_Return sName
102000>>>>>    End_Function
102001>>>>>
102001>>>>>    // Returns the first datapath found in the psDataPath property.
102001>>>>>    // The returned path always ends with a "\"
102001>>>>>    Function psDataPathFirstPart Returns String
102003>>>>>        String sDataPath
102003>>>>>        Integer iCount
102003>>>>>
102003>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
102004>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
102005>>>>>        If (iCount > 1) Begin
102007>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
102008>>>>>        End
102008>>>>>>
102008>>>>>        If (sDataPath <> "") Begin
102010>>>>>            Get vFolderFormat sDataPath to sDataPath
102011>>>>>        End
102011>>>>>>
102011>>>>>
102011>>>>>        Function_Return sDataPath
102012>>>>>    End_Function
102013>>>>>
102013>>>>>    Function psLogTextFileWithPath Returns String
102015>>>>>        String sFileName 
102015>>>>>        Handle hoLogFile
102015>>>>>        Get phoLogFile to hoLogFile
102016>>>>>        Get psLogTextFileWithPath of hoLogFile to sFileName
102017>>>>>        Function_Return sFileName
102018>>>>>    End_Function                     
102019>>>>>    
102019>>>>>    // *** Property Messages ***
102019>>>>>    //
102019>>>>>    // These "properties" are settings for the cSQLConnectionHandler class, but have been
102019>>>>>    // "duplicated" here so connection properties can be relayed to the ghoSQLConnectionHandler object
102019>>>>>    //
102019>>>>>
102019>>>>>    Function pSQLConnection Returns tSQLConnection
102021>>>>>        tSQLConnection SQLConnection
102021>>>>>        tSQLConnection SQLConnection
102021>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102023>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
102023>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102024>>>>>>
102024>>>>>            Function_Return
102025>>>>>        End
102025>>>>>>
102025>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
102026>>>>>        Function_Return SQLConnection
102027>>>>>    End_Function
102028>>>>>
102028>>>>>    // * Dummy function for the Studio's Code Explorer *
102028>>>>>    Function OTHER_CLASS_PROPERTIES Returns Boolean
102030>>>>>        Function_Return False
102031>>>>>    End_Function
102032>>>>>
102032>>>>>    Procedure Set psServer String sValue
102034>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102036>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
102036>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102037>>>>>>
102037>>>>>            Procedure_Return
102038>>>>>        End
102038>>>>>>
102038>>>>>        Set psServer of ghoSQLConnectionHandler to sValue
102039>>>>>    End_Procedure
102040>>>>>
102040>>>>>    Function psServer Returns String
102042>>>>>        String sValue
102042>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102044>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102045>>>>>>
102045>>>>>            Function_Return
102046>>>>>        End
102046>>>>>>
102046>>>>>        Get psServer of ghoSQLConnectionHandler to sValue
102047>>>>>        Function_Return sValue
102048>>>>>    End_Function
102049>>>>>
102049>>>>>    Procedure Set psDatabase String sValue
102051>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102053>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102054>>>>>>
102054>>>>>            Procedure_Return
102055>>>>>        End
102055>>>>>>
102055>>>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
102056>>>>>    End_Procedure
102057>>>>>
102057>>>>>    Function psDatabase Returns String
102059>>>>>        String sValue
102059>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102061>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102062>>>>>>
102062>>>>>            Function_Return
102063>>>>>        End
102063>>>>>>
102063>>>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
102064>>>>>        Function_Return sValue
102065>>>>>    End_Function
102066>>>>>
102066>>>>>    Procedure Set psUserID String sValue
102068>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102070>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102071>>>>>>
102071>>>>>            Function_Return
102072>>>>>        End
102072>>>>>>
102072>>>>>        Set psUserID of ghoSQLConnectionHandler to sValue
102073>>>>>    End_Procedure
102074>>>>>
102074>>>>>    Function psUserID Returns String
102076>>>>>        String sValue
102076>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102078>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102079>>>>>>
102079>>>>>            Function_Return
102080>>>>>        End
102080>>>>>>
102080>>>>>        Get psUserID of ghoSQLConnectionHandler to sValue
102081>>>>>        Function_Return sValue
102082>>>>>    End_Function
102083>>>>>
102083>>>>>    Procedure Set psPassword String sValue
102085>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102087>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102088>>>>>>
102088>>>>>            Procedure_Return
102089>>>>>        End
102089>>>>>>
102089>>>>>        Set psPassword of ghoSQLConnectionHandler to sValue
102090>>>>>    End_Procedure
102091>>>>>
102091>>>>>    Function psPassword Returns String
102093>>>>>        String sValue
102093>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102095>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102096>>>>>>
102096>>>>>            Function_Return
102097>>>>>        End
102097>>>>>>
102097>>>>>        Get psPassword of ghoSQLConnectionHandler to sValue
102098>>>>>        Function_Return sValue
102099>>>>>    End_Function
102100>>>>>
102100>>>>>    Procedure Set pbTrusted Boolean bValue
102102>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102104>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102105>>>>>>
102105>>>>>            Procedure_Return
102106>>>>>        End
102106>>>>>>
102106>>>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
102107>>>>>    End_Procedure
102108>>>>>
102108>>>>>    Function pbTrusted Returns Boolean
102110>>>>>        Boolean bValue
102110>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102112>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102113>>>>>>
102113>>>>>            Function_Return
102114>>>>>        End
102114>>>>>>
102114>>>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
102115>>>>>        Function_Return bValue
102116>>>>>    End_Function
102117>>>>>
102117>>>>>    Procedure Set pbSilentLogin Boolean bValue
102119>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102121>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102122>>>>>>
102122>>>>>            Procedure_Return
102123>>>>>        End
102123>>>>>>
102123>>>>>        Set pbSilentLogin of ghoSQLConnectionHandler to bValue
102124>>>>>    End_Procedure
102125>>>>>
102125>>>>>    Function pbSilentLogin Returns Boolean
102127>>>>>        Boolean bValue
102127>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102129>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102130>>>>>>
102130>>>>>            Function_Return
102131>>>>>        End
102131>>>>>>
102131>>>>>        Get pbSilentLogin of ghoSQLConnectionHandler to bValue
102132>>>>>        Function_Return bValue
102133>>>>>    End_Function
102134>>>>>
102134>>>>>    Procedure Set psConnectionID String sValue
102136>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102138>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102139>>>>>>
102139>>>>>            Procedure_Return
102140>>>>>        End
102140>>>>>>
102140>>>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
102141>>>>>    End_Procedure
102142>>>>>
102142>>>>>    Function psConnectionID Returns String
102144>>>>>        String sValue
102144>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102146>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102147>>>>>>
102147>>>>>            Function_Return
102148>>>>>        End
102148>>>>>>
102148>>>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
102149>>>>>        Function_Return sValue
102150>>>>>    End_Function
102151>>>>>
102151>>>>>    Procedure Set psConnectionString String sValue
102153>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102155>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102156>>>>>>
102156>>>>>            Procedure_Return
102157>>>>>        End
102157>>>>>>
102157>>>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
102158>>>>>    End_Procedure
102159>>>>>
102159>>>>>    Function psConnectionString Returns String
102161>>>>>        String sValue
102161>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102163>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102164>>>>>>
102164>>>>>            Function_Return
102165>>>>>        End
102165>>>>>>
102165>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
102166>>>>>        Function_Return sValue
102167>>>>>    End_Function
102168>>>>>
102168>>>>>    // The normal connection string looks something like this;
102168>>>>>    // SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
102168>>>>>    // ...and the full connection string looks like this;
102168>>>>>    // DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
102168>>>>>    Function psFullConnectionString Returns String
102170>>>>>        String sConnectionID sConnectionString
102170>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102172>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102173>>>>>>
102173>>>>>            Function_Return
102174>>>>>        End
102174>>>>>>
102174>>>>>        Get psConnectionID     of ghoSQLConnectionHandler to sConnectionID
102175>>>>>        Move (Trim(sConnectionID)) to sConnectionID
102176>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sConnectionString
102177>>>>>        Function_Return (CS_SQLConnectionIDText * sConnectionID + "," * String(sConnectionString))
102178>>>>>    End_Function
102179>>>>>
102179>>>>>    Function piConnectionOptions Returns Integer
102181>>>>>        Integer iValue
102181>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102183>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102184>>>>>>
102184>>>>>            Function_Return
102185>>>>>        End
102185>>>>>>
102185>>>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
102186>>>>>        Function_Return iValue
102187>>>>>    End_Function
102188>>>>>
102188>>>>>    Procedure Set psSchema String sValue
102190>>>>>        tSQLConnection SQLConnection
102190>>>>>        tSQLConnection SQLConnection
102190>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102192>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102193>>>>>>
102193>>>>>            Procedure_Return
102194>>>>>        End
102194>>>>>>
102194>>>>>        Set psSchema of ghoSQLConnectionHandler to sValue
102195>>>>>    End_Procedure
102196>>>>>
102196>>>>>    Function psSchema Returns String
102198>>>>>        String sRetval
102198>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102200>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102201>>>>>>
102201>>>>>            Function_Return
102202>>>>>        End
102202>>>>>>
102202>>>>>        Get psSchema of ghoSQLConnectionHandler to sRetval
102203>>>>>        Function_Return sRetval
102204>>>>>    End_Function
102205>>>>>
102205>>>>>    Procedure Set psBaseTableSpace String sValue
102207>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102209>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102210>>>>>>
102210>>>>>            Procedure_Return
102211>>>>>        End
102211>>>>>>
102211>>>>>        Set psBaseTableSpace of ghoSQLConnectionHandler to sValue
102212>>>>>    End_Procedure
102213>>>>>
102213>>>>>    Function psBaseTableSpace Returns String
102215>>>>>        String sRetval
102215>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102217>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102218>>>>>>
102218>>>>>            Function_Return
102219>>>>>        End
102219>>>>>>
102219>>>>>        Get psBaseTableSpace of ghoSQLConnectionHandler to sRetval
102220>>>>>        Function_Return sRetval
102221>>>>>    End_Function
102222>>>>>
102222>>>>>    Procedure Set psLongTableSpace String sValue
102224>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102226>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102227>>>>>>
102227>>>>>            Procedure_Return
102228>>>>>        End
102228>>>>>>
102228>>>>>        Set psLongTableSpace of ghoSQLConnectionHandler to sValue
102229>>>>>    End_Procedure
102230>>>>>
102230>>>>>    Function psLongTableSpace Returns String
102232>>>>>        String sRetval
102232>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102234>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102235>>>>>>
102235>>>>>            Function_Return
102236>>>>>        End
102236>>>>>>
102236>>>>>        Get psLongTableSpace of ghoSQLConnectionHandler to sRetval
102237>>>>>        Function_Return sRetval
102238>>>>>    End_Function
102239>>>>>
102239>>>>>    Procedure Set psIndexTableSpace String sValue
102241>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102243>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102244>>>>>>
102244>>>>>            Procedure_Return
102245>>>>>        End
102245>>>>>>
102245>>>>>        Set psIndexTableSpace of ghoSQLConnectionHandler to sValue
102246>>>>>    End_Procedure
102247>>>>>
102247>>>>>    Function psIndexTableSpace Returns String
102249>>>>>        String sRetval
102249>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102251>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102252>>>>>>
102252>>>>>            Function_Return
102253>>>>>        End
102253>>>>>>
102253>>>>>        Get psIndexTableSpace of ghoSQLConnectionHandler to sRetval
102254>>>>>        Function_Return sRetval
102255>>>>>    End_Function
102256>>>>>
102256>>>>>    Procedure Set pbUseConnectionID Boolean bState
102258>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102260>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102261>>>>>>
102261>>>>>            Procedure_Return
102262>>>>>        End
102262>>>>>>
102262>>>>>        Set pbUseConnectionID of ghoSQLConnectionHandler to bState
102263>>>>>    End_Procedure
102264>>>>>
102264>>>>>    Function pbUseConnectionID Returns Boolean
102266>>>>>        Boolean bState
102266>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102268>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102269>>>>>>
102269>>>>>            Function_Return
102270>>>>>        End
102270>>>>>>
102270>>>>>        Get pbUseConnectionID of ghoSQLConnectionHandler to bState
102271>>>>>        Function_Return bState
102272>>>>>    End_Function
102273>>>>>
102273>>>>>    Procedure Set pbToANSI Boolean bState
102275>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102277>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102278>>>>>>
102278>>>>>            Procedure_Return
102279>>>>>        End
102279>>>>>>
102279>>>>>        Set pbToANSI of ghoSQLConnectionHandler to bState
102280>>>>>    End_Procedure
102281>>>>>
102281>>>>>    Function pbToANSI Returns Boolean
102283>>>>>        Boolean bState
102283>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102285>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102286>>>>>>
102286>>>>>            Function_Return
102287>>>>>        End
102287>>>>>>
102287>>>>>        Get pbToANSI of ghoSQLConnectionHandler to bState
102288>>>>>        Function_Return bState
102289>>>>>    End_Function
102290>>>>>
102290>>>>>    Procedure Set pbRecnum Boolean bState
102292>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102294>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102295>>>>>>
102295>>>>>            Procedure_Return
102296>>>>>        End
102296>>>>>>
102296>>>>>        Set pbRecnum of ghoSQLConnectionHandler to bState
102297>>>>>    End_Procedure
102298>>>>>
102298>>>>>    Function pbRecnum Returns Boolean
102300>>>>>        Boolean bState
102300>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102302>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102303>>>>>>
102303>>>>>            Function_Return
102304>>>>>        End
102304>>>>>>
102304>>>>>        Get pbRecnum of ghoSQLConnectionHandler to bState
102305>>>>>        Function_Return bState
102306>>>>>    End_Function
102307>>>>>
102307>>>>>    Procedure Set pbCopyData Boolean bState
102309>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102311>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102312>>>>>>
102312>>>>>            Procedure_Return
102313>>>>>        End
102313>>>>>>
102313>>>>>        Set pbCopyData of ghoSQLConnectionHandler to bState
102314>>>>>    End_Procedure
102315>>>>>
102315>>>>>    Function pbCopyData Returns Boolean
102317>>>>>        Boolean bState
102317>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102319>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102320>>>>>>
102320>>>>>            Function_Return
102321>>>>>        End
102321>>>>>>
102321>>>>>        Get pbCopyData of ghoSQLConnectionHandler to bState
102322>>>>>        Function_Return bState
102323>>>>>    End_Function
102324>>>>>
102324>>>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
102326>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102328>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102329>>>>>>
102329>>>>>            Procedure_Return
102330>>>>>        End
102330>>>>>>
102330>>>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
102331>>>>>    End_Procedure
102332>>>>>
102332>>>>>    Function pbApiTableUpdateAuto Returns Boolean
102334>>>>>        Boolean bState
102334>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102336>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102337>>>>>>
102337>>>>>            Function_Return
102338>>>>>        End
102338>>>>>>
102338>>>>>        Get pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
102339>>>>>        Function_Return bState
102340>>>>>    End_Function
102341>>>>>
102341>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
102343>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102345>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102346>>>>>>
102346>>>>>            Procedure_Return
102347>>>>>        End
102347>>>>>>
102347>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
102348>>>>>    End_Procedure
102349>>>>>
102349>>>>>    Function pbCompareDate_DateTime Returns Boolean
102351>>>>>        Boolean bState
102351>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102353>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102354>>>>>>
102354>>>>>            Function_Return
102355>>>>>        End
102355>>>>>>
102355>>>>>        Get pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
102356>>>>>        Function_Return bState
102357>>>>>    End_Function
102358>>>>>
102358>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
102360>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102362>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102363>>>>>>
102363>>>>>            Procedure_Return
102364>>>>>        End
102364>>>>>>
102364>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
102365>>>>>    End_Procedure
102366>>>>>
102366>>>>>    Function pbCompareIndexAscending Returns Boolean
102368>>>>>        Boolean bState
102368>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102370>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102371>>>>>>
102371>>>>>            Function_Return
102372>>>>>        End
102372>>>>>>
102372>>>>>        Get pbCompareIndexAscending of ghoSQLConnectionHandler to bState
102373>>>>>        Function_Return bState
102374>>>>>    End_Function
102375>>>>>
102375>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
102377>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102379>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102380>>>>>>
102380>>>>>            Procedure_Return
102381>>>>>        End
102381>>>>>>
102381>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
102382>>>>>    End_Procedure
102383>>>>>
102383>>>>>    Function pbCompareIndexUppercase Returns Boolean
102385>>>>>        Boolean bState
102385>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102387>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
102388>>>>>>
102388>>>>>            Function_Return
102389>>>>>        End
102389>>>>>>
102389>>>>>        Get pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
102390>>>>>        Function_Return bState
102391>>>>>    End_Function
102392>>>>>
102392>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
102394>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102396>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
102397>>>>>>
102397>>>>>            Procedure_Return
102398>>>>>        End
102398>>>>>>
102398>>>>>        Set psDriverDefaultValueASCII of ghoSQLConnectionHandler to sValue
102399>>>>>    End_Procedure
102400>>>>>
102400>>>>>    Function psDriverDefaultValueASCII Returns String
102402>>>>>        String sRetval
102402>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102404>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
102405>>>>>>
102405>>>>>            Function_Return
102406>>>>>        End
102406>>>>>>
102406>>>>>        Get psDriverDefaultValueASCII of ghoSQLConnectionHandler to sRetval
102407>>>>>        Function_Return sRetval
102408>>>>>    End_Function
102409>>>>>
102409>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
102411>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102413>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
102414>>>>>>
102414>>>>>            Procedure_Return
102415>>>>>        End
102415>>>>>>
102415>>>>>        Set psDriverDefaultValueBinary of ghoSQLConnectionHandler to sValue
102416>>>>>    End_Procedure
102417>>>>>
102417>>>>>    Function psDriverDefaultValueBinary Returns String
102419>>>>>        String sRetval
102419>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102421>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
102422>>>>>>
102422>>>>>            Function_Return
102423>>>>>        End
102423>>>>>>
102423>>>>>        Get psDriverDefaultValueBinary of ghoSQLConnectionHandler to sRetval
102424>>>>>        Function_Return sRetval
102425>>>>>    End_Function
102426>>>>>
102426>>>>>    Procedure Set psDriverDefaultValueDate String sValue
102428>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102430>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
102431>>>>>>
102431>>>>>            Procedure_Return
102432>>>>>        End
102432>>>>>>
102432>>>>>        Set psDriverDefaultValueDate of ghoSQLConnectionHandler to sValue
102433>>>>>    End_Procedure
102434>>>>>
102434>>>>>    Function psDriverDefaultValueDate Returns String
102436>>>>>        String sRetval
102436>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102438>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
102439>>>>>>
102439>>>>>            Function_Return
102440>>>>>        End
102440>>>>>>
102440>>>>>        Get psDriverDefaultValueDate of ghoSQLConnectionHandler to sRetval
102441>>>>>        Function_Return sRetval
102442>>>>>    End_Function
102443>>>>>
102443>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
102445>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102447>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
102448>>>>>>
102448>>>>>            Procedure_Return
102449>>>>>        End
102449>>>>>>
102449>>>>>        Set psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sValue
102450>>>>>    End_Procedure
102451>>>>>
102451>>>>>    Function psDriverDefaultValueDateTime Returns String
102453>>>>>        String sRetval
102453>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102455>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
102456>>>>>>
102456>>>>>            Function_Return
102457>>>>>        End
102457>>>>>>
102457>>>>>        Get psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sRetval
102458>>>>>        Function_Return sRetval
102459>>>>>    End_Function
102460>>>>>
102460>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
102462>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102464>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
102465>>>>>>
102465>>>>>            Procedure_Return
102466>>>>>        End
102466>>>>>>
102466>>>>>        Set psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sValue
102467>>>>>    End_Procedure
102468>>>>>
102468>>>>>    Function psDriverDefaultValueNumeric Returns String
102470>>>>>        String sRetval
102470>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102472>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
102473>>>>>>
102473>>>>>            Function_Return
102474>>>>>        End
102474>>>>>>
102474>>>>>        Get psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sRetval
102475>>>>>        Function_Return sRetval
102476>>>>>    End_Function
102477>>>>>
102477>>>>>    Procedure Set psDriverDefaultValueText String sValue
102479>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102481>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
102482>>>>>>
102482>>>>>            Procedure_Return
102483>>>>>        End
102483>>>>>>
102483>>>>>        Set psDriverDefaultValueText of ghoSQLConnectionHandler to sValue
102484>>>>>    End_Procedure
102485>>>>>
102485>>>>>    Function psDriverDefaultValueText Returns String
102487>>>>>        String sRetval
102487>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102489>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
102490>>>>>>
102490>>>>>            Function_Return
102491>>>>>        End
102491>>>>>>
102491>>>>>        Get psDriverDefaultValueText of ghoSQLConnectionHandler to sRetval
102492>>>>>        Function_Return sRetval
102493>>>>>    End_Function
102494>>>>>
102494>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
102496>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102498>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
102499>>>>>>
102499>>>>>            Procedure_Return
102500>>>>>        End
102500>>>>>>
102500>>>>>        Set pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
102501>>>>>    End_Procedure
102502>>>>>
102502>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
102504>>>>>        Boolean bState
102504>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102506>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
102507>>>>>>
102507>>>>>            Function_Return
102508>>>>>        End
102508>>>>>>
102508>>>>>        Get pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
102509>>>>>        Function_Return bState
102510>>>>>    End_Function
102511>>>>>
102511>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
102513>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102515>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
102516>>>>>>
102516>>>>>            Procedure_Return
102517>>>>>        End
102517>>>>>>
102517>>>>>        Set pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
102518>>>>>    End_Procedure
102519>>>>>
102519>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
102521>>>>>        Boolean bState
102521>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102523>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
102524>>>>>>
102524>>>>>            Function_Return
102525>>>>>        End
102525>>>>>>
102525>>>>>        Get pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
102526>>>>>        Function_Return bState
102527>>>>>    End_Function
102528>>>>>
102528>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
102530>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102532>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
102533>>>>>>
102533>>>>>            Procedure_Return
102534>>>>>        End
102534>>>>>>
102534>>>>>        Set pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
102535>>>>>    End_Procedure
102536>>>>>
102536>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
102538>>>>>        Boolean bState
102538>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102540>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
102541>>>>>>
102541>>>>>            Function_Return
102542>>>>>        End
102542>>>>>>
102542>>>>>        Get pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
102543>>>>>        Function_Return bState
102544>>>>>    End_Function
102545>>>>>
102545>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
102547>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102549>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
102550>>>>>>
102550>>>>>            Procedure_Return
102551>>>>>        End
102551>>>>>>
102551>>>>>        Set pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
102552>>>>>    End_Procedure
102553>>>>>
102553>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
102555>>>>>        Boolean bState
102555>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102557>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
102558>>>>>>
102558>>>>>            Function_Return
102559>>>>>        End
102559>>>>>>
102559>>>>>        Get pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
102560>>>>>        Function_Return bState
102561>>>>>    End_Function
102562>>>>>
102562>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
102564>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102566>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
102567>>>>>>
102567>>>>>            Procedure_Return
102568>>>>>        End
102568>>>>>>
102568>>>>>        Set pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
102569>>>>>    End_Procedure
102570>>>>>
102570>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
102572>>>>>        Boolean bState
102572>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102574>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
102575>>>>>>
102575>>>>>            Function_Return
102576>>>>>        End
102576>>>>>>
102576>>>>>        Get pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
102577>>>>>        Function_Return bState
102578>>>>>    End_Function
102579>>>>>
102579>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
102581>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102583>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
102584>>>>>>
102584>>>>>            Procedure_Return
102585>>>>>        End
102585>>>>>>
102585>>>>>        Set pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
102586>>>>>    End_Procedure
102587>>>>>
102587>>>>>    Function pbDriverDefaultNullableText Returns Boolean
102589>>>>>        Boolean bState
102589>>>>>        If (ghoSQLConnectionHandler = 0) Begin
102591>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
102592>>>>>>
102592>>>>>            Function_Return
102593>>>>>        End
102593>>>>>>
102593>>>>>        Get pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
102594>>>>>        Function_Return bState
102595>>>>>    End_Function
102596>>>>>
102596>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
102596>>>>>    //       the psDriverID *must* be the first property that gets changed!
102596>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
102596>>>>>    //       for a connection string has the wrong format for that driver.
102596>>>>>    Procedure Set psDriverID String sValue
102598>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
102599>>>>>        Delegate Set psDriverID to sValue
102601>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
102602>>>>>        Set psDriverID of ghoSQLConnectionHandler to sValue
102603>>>>>    End_Procedure
102604>>>>>
102604>>>>>    Function psDriverID Returns String
102606>>>>>        String sDriverID
102606>>>>>
102606>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
102607>>>>>        // This should get it from the parent object (when using the cDbUpdateHandler class)
102607>>>>>        Delegate Get psDriverID to sDriverID
102609>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
102610>>>>>        Move False to Err
102611>>>>>
102611>>>>>        // ...and in case it didn't use property of this class. Then the library is
102611>>>>>        // probably used as "utilites" from a special made program and
102611>>>>>        // the ghoSQLConnectionHandler must have been setup
102611>>>>>        If (sDriverID = "") Begin
102613>>>>>            Get psDriverID of ghoSQLConnectionHandler to sDriverID
102614>>>>>        End
102614>>>>>>
102614>>>>>        Function_Return sDriverID
102615>>>>>    End_Function
102616>>>>>
102616>>>>>    Procedure Set piDbType Integer iValue
102618>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
102619>>>>>        Delegate Set piDbType to iValue
102621>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
102622>>>>>        Set piDbType of ghoSQLConnectionHandler to iValue
102623>>>>>    End_Procedure
102624>>>>>
102624>>>>>    Function piDbType Returns String
102626>>>>>        Integer iRetval
102626>>>>>
102626>>>>>//        Move False to Err
102626>>>>>//        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
102626>>>>>        // This should get it from the parent object (when using the cDbUpdateHandler class)
102626>>>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
102626>>>>>//        Delegate Get piDbType to iRetval
102626>>>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
102626>>>>>//        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
102626>>>>>
102626>>>>>        // ...and in case it didn't use property of this class. Then the library is
102626>>>>>        // probably used as "utilites" from a special made program and
102626>>>>>        // the ghoSQLConnectionHandler must have been setup
102626>>>>>//        If (Err = True) Begin
102626>>>>>            Get piDbType of ghoSQLConnectionHandler to iRetval
102627>>>>>//        End
102627>>>>>
102627>>>>>//        Move False to Err
102627>>>>>        Function_Return iRetval
102628>>>>>    End_Function
102629>>>>>
102629>>>>>    Function phoLogFile Returns Handle
102631>>>>>        Handle hoLogFile
102631>>>>>
102631>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
102632>>>>>        Delegate Get phoLogFile to hoLogFile
102634>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
102635>>>>>
102635>>>>>        Function_Return hoLogFile
102636>>>>>    End_Function
102637>>>>>
102637>>>>>    Function pnCurrentVersionUpdate Returns Number
102639>>>>>        Number nCurrentVersionUpdate
102639>>>>>
102639>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
102640>>>>>        Delegate Get pnCurrentVersionUpdate to nCurrentVersionUpdate
102642>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
102643>>>>>
102643>>>>>        Function_Return nCurrentVersionUpdate
102644>>>>>    End_Function
102645>>>>>
102645>>>>>    Procedure LogError String sText Boolean bError
102647>>>>>        Handle hoLogFile
102647>>>>>        Number nCurrentVersionUpdate
102647>>>>>
102647>>>>>        Get phoLogFile to hoLogFile
102648>>>>>        If (hoLogFile = 0) Begin
102650>>>>>            Procedure_Return
102651>>>>>        End
102651>>>>>>
102651>>>>>        Get pnCurrentVersionUpdate to nCurrentVersionUpdate
102652>>>>>
102652>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
102653>>>>>        Send LogError of hoLogFile nCurrentVersionUpdate 0 sText 0 bError
102654>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
102655>>>>>    End_Procedure
102656>>>>>
102656>>>>>    Function pbContinueOnError Returns Boolean
102658>>>>>        Boolean bContinueOnError
102658>>>>>        If (ghoDbUpdateHandler > 0) Begin
102660>>>>>            Get pbContinueOnError of ghoDbUpdateHandler to bContinueOnError
102661>>>>>        End
102661>>>>>>
102661>>>>>        Function_Return bContinueOnError
102662>>>>>    End_Function
102663>>>>>
102663>>>>>    Function psCollation Returns String
102665>>>>>        String sCollation
102665>>>>>        If (ghoDbUpdateHandler > 0) Begin
102667>>>>>            Get psCollation of ghoDbUpdateHandler to sCollation
102668>>>>>        End
102668>>>>>>
102668>>>>>        Function_Return sCollation
102669>>>>>    End_Function
102670>>>>>
102670>>>>>
102670>>>>>    Function StrToFieldNumber Integer iFile String sField Returns Integer
102672>>>>>        Integer iMax iPos
102672>>>>>        String sName
102672>>>>>
102672>>>>>        Move (Lowercase(sField)) to sField
102673>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iMax
102676>>>>>        for iPos from 0 to iMax
102682>>>>>>
102682>>>>>            Get_Attribute DF_FIELD_NAME of iFile iPos to sName
102685>>>>>            Move (Lowercase(sName)) to sName
102686>>>>>            If (sName = sField) Begin
102688>>>>>                Function_Return iPos
102689>>>>>            End
102689>>>>>>
102689>>>>>        Loop
102690>>>>>>
102690>>>>>        Function_Return -1
102691>>>>>    End_Function
102692>>>>>
102692>>>>>
102692>>>>>    // * Dummy function for the Studio's Code Explorer *
102692>>>>>    Function PRIVATE_SUB_FUNCTIONS Returns Boolean
102694>>>>>        Function_Return False
102695>>>>>    End_Function
102696>>>>>
102696>>>>>    // When dropping columns on some SQL back-ends they doesn't reclaim the space taken up by the columns dropped.
102696>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
102696>>>>>    // the new rows added after the alter statement. to get around this you need to create a clustered
102696>>>>>    // index on the table _or_ rebuild the clustered Index if it already has one. Rebuilding the index
102696>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
102696>>>>>    //   ALTER TABLE MyTable
102696>>>>>    //       REBUILD
102696>>>>>    Function _SqlUtilRemoveTableColumnMSSQL String sTableName String sColumnName Returns Boolean
102698>>>>>        Boolean bOK
102698>>>>>
102698>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
102700>>>>>            Function_Return False
102701>>>>>        End
102701>>>>>>
102701>>>>>
102701>>>>>        SQLIncludeScriptFile ..\Scripts\DropConstraintAndColumnNameMSSQL.sql as DropConstraintAndColumnNameMSSQL.sql
102701>>>>>        Get _SqlUtilRemoveTableColumnByScript "DropConstraintAndColumnNameMSSQL.sql" sTableName sColumnName to bOK
102702>>>>>
102702>>>>>        Function_Return (bOK = True)
102703>>>>>    End_Function
102704>>>>>
102704>>>>>
102704>>>>>    // *** Helper functions with compiled sql script code ***
102704>>>>>    //
102704>>>>>    // When dropping columns SQL Sever does not reclaim the space taken up by the columns dropped.
102704>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
102704>>>>>    // the new rows added after the alter statement. To get around this you need to create a clustered
102704>>>>>    // index on the table or rebuild the clustered Index if it already has one. Rebuilding the index
102704>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
102704>>>>>    //   ALTER TABLE MyTable
102704>>>>>    //       REBUILD
102704>>>>>    Function _SqlUtilRemoveTableColumnByScript String sMemScriptFile String sTableName String sColumnName Returns Boolean
102706>>>>>        tSQLScriptArray SQLScriptArray
102706>>>>>        tSQLScriptArray SQLScriptArray
102706>>>>>        String sDriverID
102706>>>>>        Boolean bOK
102706>>>>>        Integer iSize iCount
102706>>>>>
102706>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
102708>>>>>            Function_Return False
102709>>>>>        End
102709>>>>>>
102709>>>>>
102709>>>>>        Get psDriverID to sDriverID
102710>>>>>        Get SqlUtilReadResource sMemScriptFile to SQLScriptArray
102711>>>>>        If (SQLScriptArray.bError = True) Begin
102713>>>>>            Function_Return False
102714>>>>>        End
102714>>>>>>
102714>>>>>
102714>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
102715>>>>>        Decrement iSize
102716>>>>>
102716>>>>>        for iCount from 0 to iSize
102722>>>>>>
102722>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "TABLE_NAME_XXX") Begin
102724>>>>>                Move (Replaces("TABLE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sTableName))) to SQLScriptArray.sSQLScriptArray[iCount]
102725>>>>>            End
102725>>>>>>
102725>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLUMN_NAME_XXX") Begin
102727>>>>>                Move (Replaces("COLUMN_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sColumnName))) to SQLScriptArray.sSQLScriptArray[iCount]
102728>>>>>            End
102728>>>>>>
102728>>>>>        Loop
102729>>>>>>
102729>>>>>
102729>>>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
102730>>>>>
102730>>>>>        Function_Return (bOK = True)
102731>>>>>    End_Function
102732>>>>>
102732>>>>>    // *** Helper functions for Mertech Drivers ***
102732>>>>>    // Created to not clutter up the standard function code with lots of #IFDEF's
102732>>>>>    // and commands that the Studio editor knows nothing about.
102732>>>>>    Function _MertechDeleteTDFile String sTableName Returns Integer
102734>>>>>        Integer iRetval
102734>>>>>        String sPath
102734>>>>>
102734>>>>>            SQL_GET_LOCAL_TD_PATH to sPath
102748>>>>>>
102748>>>>>        If (sPath = "" or sTableName = "") Begin
102750>>>>>            Function_Return 0
102751>>>>>        End
102751>>>>>>
102751>>>>>
102751>>>>>        Get vFolderFormat sPath to sPath
102752>>>>>        Get vDeleteFile (sPath + String(sTableName) + ".td") to iRetval
102753>>>>>        Function_Return iRetval
102754>>>>>    End_Function
102755>>>>>
102755>>>>>    Function _MertechSqlUtilCreateIntFile Handle hTable String sDataPath String sPhysicalFileName Returns Boolean
102757>>>>>        Move False to Err
102758>>>>>            Set_Attribute DF_FILE_SUPPRESS_SERVERNAME_OUTPUT   of hTable to False
102761>>>>>            Set_Attribute DF_FILE_SUPPRESS_DATABASENAME_OUTPUT of hTable to False
102764>>>>>            Set_Attribute DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT   of hTable to False
102767>>>>>            OUTPUT_INT_FILE for hTable to (sDataPath + sPhysicalFileName)
102788>>>>>>
102788>>>>>        Function_Return (Err = False)
102789>>>>>    End_Function
102790>>>>>
102790>>>>>    Function _MertechEnumerateSQLFlexServers Returns String[]
102792>>>>>        Integer iNumItems iCount
102792>>>>>        String[] sReturnArray
102793>>>>>        String sServer
102793>>>>>
102793>>>>>        Get SQL_AVAILABLE_SQL_SERVERS to iNumItems
102794>>>>>        For iCount from 1 to iNumItems
102800>>>>>>
102800>>>>>            Get SQL_AVAILABLE_SQL_SERVER_NAME iCount to sServer
102801>>>>>            Move sServer to sReturnArray[iCount -1]
102802>>>>>        Loop
102803>>>>>>
102803>>>>>
102803>>>>>        Function_Return sReturnArray
102804>>>>>    End_Function
102805>>>>>
102805>>>>>    Function _MertechEnumerateORAFLEXServers Returns String[]
102807>>>>>        String[] sReturnArray
102808>>>>>        String sServer
102808>>>>>
102808>>>>>        GET_CURRENT_SQL_SERVER to sServer
102828>>>>>>
102828>>>>>        Move sServer to sReturnArray[0]
102829>>>>>
102829>>>>>        Function_Return sReturnArray
102830>>>>>    End_Function
102831>>>>>
102831>>>>>    Function _MertechSQLConnect String sDriverID String sServer String sUserID String sPassword Returns Handle
102833>>>>>        Handle hoSQLHandler hoSQLConnect
102833>>>>>
102833>>>>>        Move 0 to hoSQLConnect
102834>>>>>            Get _MertechSQLManagerHandle to hoSQLHandler
102835>>>>>            Get SQLConnect of hoSqlHandler sDriverID sServer sUserID sPassword to hoSQLConnect
102836>>>>>
102836>>>>>        Function_Return hoSQLConnect
102837>>>>>    End_Function
102838>>>>>
102838>>>>>    // Returns the handle of the Mertech SQL handler.
102838>>>>>    // It also ensures that the correct Server & Database attributes are set both for
102838>>>>>    // embedded SQL calls and "normal" database commands like e.g. "Open".
102838>>>>>    Function _MertechSQLManagerHandle Returns Handle
102840>>>>>        Handle hoSQLHandler
102840>>>>>        String sDriverID sServer sDatabase
102840>>>>>
102840>>>>>        Move 0 to hoSQLHandler
102841>>>>>        Get psDriverID to sDriverID
102842>>>>>        Get psServer   to sServer
102843>>>>>        Get psDatabase to sDatabase
102844>>>>>        // This command is used to set the server to be used when opening tables
102844>>>>>        SET_CURRENT_SQL_SERVER            to sServer
102863>>>>>>
102863>>>>>        // This command is used to specify which server to use for embedded SQL statements,
102863>>>>>        // but it has been constructed rather studidly as only constants and not variables
102863>>>>>        // are allowed...
102863>>>>>        If (sDriverID = MDSPgSQL) Begin
102865>>>>>            SET_CURRENT_SQL_SERVER_CONNECTION of MDSPgSQL to sServer
102881>>>>>        End
102881>>>>>>
102881>>>>>        If (sDriverID = MDSMySQL) Begin
102883>>>>>            SET_CURRENT_SQL_SERVER_CONNECTION of MDSMySQL to sServer
102899>>>>>        End
102899>>>>>>
102899>>>>>        If (sDriverID = ORAFLEX) Begin
102901>>>>>            SET_CURRENT_SQL_SERVER_CONNECTION of ORAFLEX to sServer
102917>>>>>        End
102917>>>>>>
102917>>>>>        If (sDriverID = SQLFLEX) Begin
102919>>>>>            SET_CURRENT_SQL_SERVER_CONNECTION of SQLFLEX to sServer
102935>>>>>        End
102935>>>>>>
102935>>>>>
102935>>>>>        // This command is used to specify which database is used for SQL statements only.
102935>>>>>        SQL_USE_DATABASE sDatabase
102949>>>>>>
102949>>>>>        SET_DATABASE_NAME to sDatabase
102963>>>>>>
102963>>>>>
102963>>>>>        Get phoSQLManagerMT to hoSQLHandler
102964>>>>>
102964>>>>>        Function_Return hoSQLHandler
102965>>>>>    End_Function
102966>>>>>
102966>>>>>    // For Mertech drivers we cannot use Structure_Start/End. Instead we must use
102966>>>>>    // macro-commands <sigh!>
102966>>>>>    // Note: The function sets the Err flag.
102966>>>>>    Function _MertechApiTableConvertToSQL Handle hTable String sRootName String sDatabase String sDriverID String sBaseTableSpace String sIndexTableSpace Boolean bCopyData Returns Boolean
102968>>>>>        Move False to Err
102969>>>>>
102969>>>>>            MERTECH_WARNING_MESSAGE Disabled
102978>>>>>>
102978>>>>>            SET_DATABASE_NAME to sDatabase
102992>>>>>>
102992>>>>>            If (sBaseTableSpace <> "") Begin
102994>>>>>                SET_DEFAULT_TABLESPACE to sBaseTableSpace
103007>>>>>>
103007>>>>>            End
103007>>>>>>
103007>>>>>            If (sIndexTableSpace <> "") Begin
103009>>>>>                SET_DEFAULT_INDEX_TABLESPACE to sIndexTableSpace
103022>>>>>>
103022>>>>>            End
103022>>>>>>
103022>>>>>            CREATE_TABLE_FROM_DAT_FILE hTable DF_STRUCTEND_OPT_FORCE_NOT_NULL sRootName
103044>>>>>>
103044>>>>>            If (bCopyData = True) Begin
103046>>>>>                COPY_DATA sRootName to (sDriverID + ":" + sRootName) CALLBACK (Callback(Self))
103061>>>>>>
103061>>>>>            End
103061>>>>>>
103061>>>>>
103061>>>>>        Function_Return (Err = False)
103062>>>>>    End_Function
103063>>>>>
103063>>>>>End_Class
103064>>>Use MSSqldrv.pkg
103064>>>Use db2_drv.pkg
103064>>>Use odbc_drv.pkg
103064>>>
103064>>>Object oDatabaseSelection_sl is a ModalPanel
103066>>>    Set Label to "SQL Database Selection"
103067>>>    Set Size to 121 183
103068>>>    Set piMinSize to 89 170
103069>>>    Set Location to 2 2
103070>>>    Set Border_Style to Border_Thick
103071>>>
103071>>>    Property String[] psTheData
103073>>>
103073>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
103075>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
103077>>>        End_Object
103078>>>    End
103078>>>>
103078>>>
103078>>>    Object oSelList is a cCJGridPromptList
103080>>>        Set Size to 89 167
103081>>>        Set Location to 6 6
103082>>>        Set peAnchors to anAll
103083>>>        Set pbAllowColumnRemove to False
103084>>>        Set pbUseAlternateRowBackgroundColor to True
103085>>>        Set pbGrayIfDisable to False
103086>>>        Set pbHeaderReorders to False
103087>>>        Set pbHeaderSelectsColumn to False
103088>>>        Set pbHeaderTogglesDirection to False
103089>>>        Set pbShadeSortColumn to False
103090>>>        Set piFocusCellBackColor to clDkGray
103091>>>
103091>>>        Object oName is a cCJGridColumn
103093>>>            Set piWidth to 334
103094>>>            Set psCaption to "Database Name"
103095>>>        End_Object
103096>>>
103096>>>        Procedure Activating
103099>>>            tDataSourceRow[] MyData
103099>>>            tDataSourceRow[] MyData
103100>>>            Handle hoDataSource
103100>>>            String[] sTheData
103101>>>            Integer iCount iSize
103101>>>
103101>>>            Send Cursor_Wait of Cursor_Control
103102>>>            Forward Send Activating
103104>>>
103104>>>            Get psTheData to sTheData
103105>>>            Move (SizeOfArray(sTheData)) to iSize
103106>>>            Decrement iSize
103107>>>            For iCount from 0 to iSize
103113>>>>
103113>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
103114>>>            Loop
103115>>>>
103115>>>
103115>>>            Get phoDataSource to hoDataSource
103116>>>            Send InitializeData of hoDataSource MyData
103117>>>            Send Cursor_Ready of Cursor_Control
103118>>>        End_Procedure
103119>>>
103119>>>    End_Object
103120>>>
103120>>>    Object oOK_Btn is a Button
103122>>>        Set Label    to "&OK"
103123>>>        Set Location to 100 68
103124>>>        Set peAnchors To anBottomRight
103125>>>
103125>>>        Procedure OnClick
103128>>>            Send Ok of oSelList
103129>>>        End_Procedure
103130>>>
103130>>>    End_Object
103131>>>
103131>>>    Object oCancel_Btn is a Button
103133>>>        Set Label    to "&Cancel"
103134>>>        Set Location to 100 123
103135>>>        Set peAnchors to anBottomRight
103136>>>
103136>>>        Procedure OnClick
103139>>>            Send Close_Panel
103140>>>        End_Procedure
103141>>>
103141>>>    End_Object
103142>>>
103142>>>    Procedure Page Integer iPageObject
103145>>>        Set Icon to "DatabaseLookup.ico"
103146>>>        Forward Send Page iPageObject
103148>>>    End_Procedure
103149>>>
103149>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
103150>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
103151>>>End_Object
103152>        Use SQLDatabaseBackup.dg
Including file: SQLDatabaseBackup.dg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\SQLDatabaseBackup.dg)
103152>>>// Note: At the bottom of this package there's a general purpose access method for this dialog.
103152>>>Use Windows.pkg
103152>>>Use vWin32fh.pkg
103152>>>
103152>>>Object oSQLDatabaseBackup_dg is a ModalPanel
103154>>>    Set Size to 104 298
103155>>>    Set Label to "SQL Database Backup"
103156>>>    Set piMinSize to 89 211
103157>>>    Set Location to 2 4
103158>>>    Set Border_Style To Border_Thick
103159>>>
103159>>>    Property Boolean pbOK False
103161>>>    Property String  psDatabase
103163>>>    Property String  psPath
103165>>>    Property String  psBackupName
103167>>>
103167>>>    Object oDatabase_fm is a Form
103169>>>        Set Size to 13 204
103170>>>        Set Location to 14 71
103171>>>        Set Label_Justification_Mode to JMode_Right
103172>>>        Set Label_Col_Offset to 2
103173>>>        Set Label to "Database Name"
103174>>>        Set Enabled_State to False
103175>>>        Set peAnchors to anTopLeftRight
103176>>>
103176>>>        Procedure Page Integer iPageObject
103179>>>            String sValue
103179>>>            Get psDatabase of ghoDbUpdateFunctionLibrary to sValue
103180>>>            Set Value to sValue
103181>>>            Set psDatabase to sValue
103182>>>            Forward Send Page iPageObject
103184>>>        End_Procedure
103185>>>
103185>>>    End_Object
103186>>>
103186>>>    Object oBackupName_fm is a Form
103188>>>        Set Size to 13 204
103189>>>        Set Location to 29 71
103190>>>        Set Label_Justification_Mode to JMode_Right
103191>>>        Set Label_Col_Offset to 2
103192>>>        Set Label to "Backup Name"
103193>>>        Set peAnchors to anTopLeftRight
103194>>>
103194>>>        Procedure Page Integer iPageObject
103197>>>            String sValue
103197>>>            Get psDatabase of ghoDbUpdateFunctionLibrary to sValue
103198>>>            Set Value to sValue
103199>>>            Forward Send Page iPageObject
103201>>>        End_Procedure
103202>>>
103202>>>        Procedure OnChange
103205>>>            String sValue
103205>>>            Get Value to sValue
103206>>>            Set psBackupName to sValue
103207>>>        End_Procedure
103208>>>
103208>>>    End_Object
103209>>>
103209>>>    Object oUseDefaultBackupFolder_cb is a CheckBox
103211>>>        Set Size to 10 50
103212>>>        Set Location to 50 71
103213>>>        Set Label to "Use Default SQL Backup Folder"
103214>>>        Set Checked_State to True
103215>>>
103215>>>        Procedure OnChange
103218>>>            Boolean bChecked
103218>>>            Get Checked_State to bChecked
103219>>>            Set Enabled_State of oPath_fm to (bChecked = False)
103220>>>        End_Procedure
103221>>>
103221>>>    End_Object
103222>>>
103222>>>    Object oPath_fm is a Form
103224>>>        Set Size to 13 204
103225>>>        Set Location to 62 71
103226>>>        Set Label_Justification_Mode to JMode_Right
103227>>>        Set Label_Col_Offset to 2
103228>>>        Set Label to "Path"
103229>>>        Set Prompt_Button_Mode to PB_PromptOn
103230>>>        Set peAnchors to anTopLeftRight
103231>>>        Set Enabled_State to False
103232>>>
103232>>>        Procedure Page Integer iPageObject
103235>>>            String sValue
103235>>>            Get psDataPathFirstPart of ghoDbUpdateFunctionLibrary to sValue
103236>>>            Get vFolderFormat sValue to sValue
103237>>>            Move (sValue + "Backup") to sValue
103238>>>            Set Value to sValue
103239>>>            Forward Send Page iPageObject
103241>>>        End_Procedure
103242>>>
103242>>>        Procedure Prompt
103245>>>            String sPath sFileMask sRetval
103245>>>
103245>>>            Get Value to sPath
103246>>>            Move "Database Backup files (*.bak)|*.bak" to sFileMask
103247>>>            Get vSelect_File sFileMask "Please select a .bak file" sPath to sRetval
103248>>>            If (sRetval <> "") Begin
103250>>>                Get ParseFolderName sRetval to sPath
103251>>>                If (Right(sPath, 1) ="\") Begin
103253>>>                    Move (Left(sPath, Length(sPath) -1)) to sPath
103254>>>                End
103254>>>>
103254>>>                Set Value to sPath
103255>>>            End
103255>>>>
103255>>>        End_Procedure
103256>>>
103256>>>        Procedure OnChange
103259>>>            String sValue
103259>>>            Get Value to sValue
103260>>>            Set psPath to sValue
103261>>>        End_Procedure
103262>>>
103262>>>    End_Object
103263>>>
103263>>>    Object oOK_Btn is a Button
103265>>>        Set Label    to "&OK"
103266>>>        Set Location to 81 169
103267>>>        Set peAnchors to anBottomRight
103268>>>
103268>>>        Procedure OnClick
103271>>>            Set pbOK to True
103272>>>            Send Close_Panel
103273>>>        End_Procedure
103274>>>
103274>>>    End_Object
103275>>>
103275>>>    Object oCancel_Btn is a Button
103277>>>        Set Label    to "&Cancel"
103278>>>        Set Location to 81 224
103279>>>        Set peAnchors to anBottomRight
103280>>>
103280>>>        Procedure OnClick
103283>>>            Set pbOK to False
103284>>>            Send Close_Panel
103285>>>        End_Procedure
103286>>>
103286>>>    End_Object
103287>>>
103287>>>    Object oButton1 is a Button
103289>>>        Set Size to 14 96
103290>>>        Set Location to 80 32
103291>>>        Set Label to "Enum table types"
103292>>>
103292>>>        Procedure OnClick
103295>>>            String sDriverID
103295>>>            tSQLConnection SQLConnection
103295>>>            tSQLConnection SQLConnection
103295>>>            Get pSQLConnection of ghoDbUpdateFunctionLibrary to SQLConnection
103296>>>            Send ShowAllTablesAndColumns SQLConnection.sDriverID SQLConnection.sConnectionString
103297>>>        End_Procedure
103298>>>
103298>>>        Procedure ShowAllTablesAndColumns String sDriver String sLogin
103301>>>            Handle hoCLIHandler
103301>>>            Integer iNumTables iTableCount
103301>>>
103301>>>            Get Create U_cCLIHandler to hoCLIhandler
103302>>>            If (hoCLIHandler > 0) Begin
103304>>>                Set psDriverID of hoCLIHandler to sDriver
103305>>>                Get EnumerateTables of hoCLIHandler sLogin to iNumTables
103306>>>                For iTableCount from 1 to iNumTables
103312>>>>
103312>>>                    Show (TableName(hoCLIHandler, iTableCount)) "; "
103314>>>                    Show (SchemaName(hoCLIHandler, iTableCount)) "; "
103316>>>                    Show (TableType(hoCLIHandler, iTableCount)) "; "
103318>>>                    Showln (TableComment(hoCLIHandler, iTableCount))
103320>>>//                    Get EnumerateColumns of hoCLIHandler sLogin (TableName(hoCLIHandler, iTableCount)) to iNumColumns
103320>>>//                    For iColumnCount from 1 to iNumColumns
103320>>>//                        Showln " " (ColumnName(hoCLIHandler, iColumnCount))
103320>>>//                    Loop
103320>>>                    Showln
103321>>>                Loop
103322>>>>
103322>>>                Send Destroy of hoCLIHandler
103323>>>            End
103323>>>>
103323>>>        End_Procedure
103324>>>
103324>>>    End_Object
103325>>>
103325>>>    Procedure Page Integer iPageObject
103328>>>        Set Icon to "DdBackup.ico"
103329>>>        Forward Send Page iPageObject
103331>>>    End_Procedure
103332>>>
103332>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
103333>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
103334>>>
103334>>>End_Object
103335>>>
103335>>>// *** General purpose access method for this dialog ***
103335>>>Function MakeSQLDatabaseBackup Returns Boolean
103338>>>    Handle ho
103338>>>    Boolean bOK bDefault
103338>>>    String sDatabase sPath sBackupName
103338>>>
103338>>>    Move (oSQLDatabaseBackup_dg(Self)) to ho
103339>>>    Set pbOK of ho to False
103340>>>    Send Popup of ho
103341>>>
103341>>>    Get pbOk of ho to bOK
103342>>>    If (bOK = True) Begin
103344>>>        Get Value of (oDatabase_fm(ho))   to sDatabase
103345>>>        Get Value of (oBackupName_fm(ho)) to sBackupName
103346>>>        Get Checked_State of (oUseDefaultBackupFolder_cb(ho)) to bDefault
103347>>>        If (bDefault = False) Begin
103349>>>            Get Value of (oPath_fm(ho)) to sPath
103350>>>        End
103350>>>>
103350>>>        Get SqlDatabaseBackupToDisk of ghoDbUpdateFunctionLibrary sDatabase sBackupName sPath True to bOK
103351>>>    End
103351>>>>
103351>>>
103351>>>    Function_Return bOK
103352>>>End_Function
103353>        Use SQLConnections.vw
Including file: SQLConnections.vw    (C:\Projects\DF18\DbUpdateFramework\AppSrc\SQLConnections.vw)
103353>>>Use Windows.pkg
103353>>>Use DFClient.pkg
103353>>>Use cDbScrollingContainer.pkg
Including file: cDbScrollingContainer.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cDbScrollingContainer.pkg)
103353>>>>>// Provides support for db aware scrolling containers.
103353>>>>>// Scrolling containers is provided by creating two objects,
103353>>>>>// a host (dbScrollingContainer) and a scrolling clientarea (dbScrollingClientArea)
103353>>>>>// The host has no public interface, you just drop the object. It should have only one child object
103353>>>>>// and that should be a scrolling client-area. If it is not, it is an error. It is also considered
103353>>>>>// an error to place a scrolling client area in any object other than a scrolling container.
103353>>>>>
103353>>>>>Use DFClient.pkg
103353>>>>>Use cScrollingContainerMixin.pkg
Including file: cScrollingContainerMixin.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cScrollingContainerMixin.pkg)
103353>>>>>>>// Mixin classes for scrolling container support:
103353>>>>>>>// cScrollingContainerMixin & cScrollingClientAreaMixin
103353>>>>>>>// These are used by cSrollingContainer / cScrollingClientArea and
103353>>>>>>>// dbScrollingContainer / dbScrollingClientArea.
103353>>>>>>>// The scrolling container has no public interface, you just drop the object. It should have only one child object
103353>>>>>>>// and that should be a scrolling client-area. If it is not, it is an error. It is also considered
103353>>>>>>>// an error to place a scrolling client area in any object other than a scrolling container.
103353>>>>>>>
103353>>>>>>>Use Windows.pkg
103353>>>>>>>Use Winuser.pkg
103353>>>>>>>Use tWinStructs.pkg
103353>>>>>>>
103353>>>>>>>Register_Function pbTabbedWorkspaces Returns Boolean
103353>>>>>>>Register_Function pbCenterTabbedViews Returns Boolean
103353>>>>>>>// support for the scrolling client area mixin object.
103353>>>>>>>
103353>>>>>>>Class cScrollingClientAreaMixin is a Mixin
103354>>>>>>>    
103354>>>>>>>    Procedure Define_cScrollingClientAreaMixin
103356>>>>>>>
103356>>>>>>>        Set pbSizeToClientArea to False // should already be set to this, but just in case.
103357>>>>>>>        Set Border_Style to Border_None
103358>>>>>>>        
103358>>>>>>>        Property Boolean pbAutoScroll True
103359>>>>>>>        Property Boolean pbAutoScrollFocus True
103360>>>>>>>        Property Integer piAutoScrollMarginX 5
103361>>>>>>>        Property Integer piAutoScrollMarginY 5
103362>>>>>>>        Property Integer piAutoScrollMinX 0
103363>>>>>>>        Property Integer piAutoScrollMinY 0
103364>>>>>>>        Property Boolean pbShowDisabledScrollBar False 
103365>>>>>>>        
103365>>>>>>>        
103365>>>>>>>        Property Integer piLineScrollUnit  5 // minimum scrolling unit for line up/down and mouse wheel
103366>>>>>>>        Property Integer piMinimumHeight 0 // the minimum height that doesn't need scrolling
103367>>>>>>>        Property Integer piMinimumWidth 0 //(the minimum width that doesn't need scrolling
103368>>>>>>>        // keeps track of scrolling
103368>>>>>>>        Property Integer piCurrentVertScrolled 0
103369>>>>>>>        Property Integer piCurrentHorzScrolled 0
103370>>>>>>>        Property Integer piWheelDelta 0               // internal, accumulates mouse wheel clicks
103371>>>>>>>        Delegate Set phoScrollingClientArea to Self
103373>>>>>>>
103373>>>>>>>        // set this true to make this a tabbed workspace view (design time)
103373>>>>>>>        Property Boolean pbTabWorkspaceView False
103374>>>>>>>        // set this false to stop auto-determination of pbTabWorkspaceView (design time)
103374>>>>>>>        Property Boolean pbAutoSetTabWorkspaceView True
103375>>>>>>>    End_Procedure
103376>>>>>>>
103376>>>>>>>    // low level event sent from windows.
103376>>>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
103378>>>>>>>        Integer iWheelDelta iKeys iDelta iClicks
103378>>>>>>>        Move (low(abs(wParam))) to iKeys           // any keys down when pressed
103379>>>>>>>        Move (hi(abs(wParam))) to iDelta           // number of click units
103380>>>>>>>        If (wParam<0) Begin
103382>>>>>>>            Move (-iDelta) to iDelta     // can be up or down
103383>>>>>>>        End
103383>>>>>>>>
103383>>>>>>>        Get  piWheelDelta to iWheelDelta           // Current accumulated micro clicks
103384>>>>>>>        Move (iWheelDelta+iDelta) to iWheelDelta
103385>>>>>>>        // C_WHEELDATA is 120 as defined by MS as the delta to react to. Once click is usually 120
103385>>>>>>>        Move (iWheelDelta/C_WHEELDELTA) to iClicks // Number of clicks to react to
103386>>>>>>>        Set  piWheelDelta to (mod(iWheelDelta,C_WHEELDELTA)) // remainder unused microclicks
103387>>>>>>>        // If we have enough Clicks send OnMouseWheel
103387>>>>>>>        If (iClicks<>0) Begin
103389>>>>>>>            Send OnMouseWheel iClicks iKeys
103390>>>>>>>        End
103390>>>>>>>>
103390>>>>>>>        // tell windows that we've handled the event.    
103390>>>>>>>        Set Windows_Override_State to True    
103391>>>>>>>    End_Procedure
103392>>>>>>>
103392>>>>>>>
103392>>>>>>>    // should be sent by DF message OnWMMouseWheel , which is sent by WM_MOUSEWHEEL
103392>>>>>>>    Procedure OnMouseWheel Integer iClicks Integer iKey
103394>>>>>>>        Integer iLineScrollUnit
103394>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
103395>>>>>>>        Send VScroll (-iClicks*iLineScrollUnit*2) // (If(iClicks>0,False,True)) (abs(iClicks))
103396>>>>>>>    End_Procedure
103397>>>>>>>
103397>>>>>>>    // should be sent by WM_VSCROLL
103397>>>>>>>    Procedure SetVScrollbox Integer iType Integer iNewPos
103399>>>>>>>        Boolean bOk
103399>>>>>>>        tWinScrollInfo ScrollInfo
103399>>>>>>>        tWinScrollInfo ScrollInfo
103399>>>>>>>        Integer iLineScrollUnit
103399>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
103400>>>>>>>        Get GetScrollBarInfo True (&ScrollInfo) to bOk
103401>>>>>>>        If bOk Begin 
103403>>>>>>>            
103403>>>>>>>            Case Begin
103403>>>>>>>                Case (iType=SB_PAGEDOWN) 
103405>>>>>>>                    Send VScroll ScrollInfo.nPage
103406>>>>>>>                    Case Break
103407>>>>>>>                    
103407>>>>>>>                Case (iType=SB_PAGEUP) 
103410>>>>>>>                    Send VScroll (-ScrollInfo.nPage)
103411>>>>>>>                    Case Break
103412>>>>>>>                    
103412>>>>>>>                Case (iType=SB_LINEDOWN) 
103415>>>>>>>                    Send VScroll iLineScrollUnit
103416>>>>>>>                    Case Break
103417>>>>>>>                    
103417>>>>>>>                Case (iType=SB_LINEUP) 
103420>>>>>>>                    Send VScroll (-iLineScrollUnit)
103421>>>>>>>                    Case Break
103422>>>>>>>    
103422>>>>>>>                Case (iType=SB_BOTTOM) 
103425>>>>>>>                    Send VScroll (ScrollInfo.nMax-ScrollInfo.nPos)
103426>>>>>>>                    Case Break
103427>>>>>>>    
103427>>>>>>>                Case (iType=SB_Top) 
103430>>>>>>>                    Send VScroll (-ScrollInfo.nPos)
103431>>>>>>>                    Case Break
103432>>>>>>>                    
103432>>>>>>>                Case (iType=SB_THUMBPOSITION) 
103435>>>>>>>                    Case Break
103436>>>>>>>    
103436>>>>>>>                Case (iType=SB_THUMBTRACK) 
103439>>>>>>>                    Send VScroll (ScrollInfo.nTrackPos-ScrollInfo.nPos)
103440>>>>>>>                    Case Break
103441>>>>>>>            Case End
103441>>>>>>>        End
103441>>>>>>>>
103441>>>>>>>    End_Procedure
103442>>>>>>>    
103442>>>>>>>    // should be sent by WM_HSCROLL
103442>>>>>>>    Procedure SetHScrollbox Integer iType Integer iNewPos
103444>>>>>>>        Boolean bOk
103444>>>>>>>        tWinScrollInfo ScrollInfo
103444>>>>>>>        tWinScrollInfo ScrollInfo
103444>>>>>>>        Integer iLineScrollUnit
103444>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
103445>>>>>>>        Get GetScrollBarInfo False (&ScrollInfo) to bOk
103446>>>>>>>        If bOk Begin 
103448>>>>>>>            
103448>>>>>>>            Case Begin
103448>>>>>>>                Case (iType=SB_PAGEDOWN) 
103450>>>>>>>                    Send hScroll ScrollInfo.nPage
103451>>>>>>>                    Case Break
103452>>>>>>>                    
103452>>>>>>>                Case (iType=SB_PAGEUP) 
103455>>>>>>>                    Send hScroll (-ScrollInfo.nPage)
103456>>>>>>>                    Case Break
103457>>>>>>>                    
103457>>>>>>>                Case (iType=SB_LINEDOWN) 
103460>>>>>>>                    Send hScroll iLineScrollUnit
103461>>>>>>>                    Case Break
103462>>>>>>>                    
103462>>>>>>>                Case (iType=SB_LINEUP) 
103465>>>>>>>                    Send hScroll (-iLineScrollUnit)
103466>>>>>>>                    Case Break
103467>>>>>>>    
103467>>>>>>>                Case (iType=SB_BOTTOM) 
103470>>>>>>>                    Send hScroll (ScrollInfo.nMax-ScrollInfo.nPos)
103471>>>>>>>                    Case Break
103472>>>>>>>    
103472>>>>>>>                Case (iType=SB_Top) 
103475>>>>>>>                    Send hScroll (-ScrollInfo.nPos)
103476>>>>>>>                    Case Break
103477>>>>>>>                    
103477>>>>>>>                Case (iType=SB_THUMBPOSITION) 
103480>>>>>>>                    Case Break
103481>>>>>>>    
103481>>>>>>>                Case (iType=SB_THUMBTRACK) 
103484>>>>>>>                    Send hScroll (ScrollInfo.nTrackPos-ScrollInfo.nPos)
103485>>>>>>>                    Case Break
103486>>>>>>>            Case End
103486>>>>>>>        End
103486>>>>>>>>
103486>>>>>>>    End_Procedure
103487>>>>>>>    
103487>>>>>>>    
103487>>>>>>>    // this calls SetScrollInfo with proper info
103487>>>>>>>    Procedure SetScrollBarInfo Boolean bVert Integer iRangeMin Integer iRangeMax Integer iPageSize
103489>>>>>>>        tWinScrollInfo ScrollInfo
103489>>>>>>>        tWinScrollInfo ScrollInfo
103489>>>>>>>        Integer iVoid
103489>>>>>>>        Handle hWnd
103489>>>>>>>        Boolean bShow
103489>>>>>>>
103489>>>>>>>        Delegate Get Window_Handle to hWnd
103491>>>>>>>        If (hWnd <> 0) Begin        
103493>>>>>>>            Move (SizeOfType (tWinScrollInfo)) to ScrollInfo.cbSize
103494>>>>>>>             
103494>>>>>>>            Move (SIF_RANGE ior SIF_POS ior SIF_PAGE ) to ScrollInfo.fMask
103495>>>>>>>            Get pbShowDisabledScrollBar to bShow
103496>>>>>>>            If bShow Begin
103498>>>>>>>                Move (ScrollInfo.fMask ior SIF_DISABLENOSCROLL) to ScrollInfo.fMask
103499>>>>>>>            End
103499>>>>>>>>
103499>>>>>>>            Move iRangeMin to ScrollInfo.nMin
103500>>>>>>>            Move iRangeMax to ScrollInfo.nMax
103501>>>>>>>            Move iPageSize to ScrollInfo.nPage
103502>>>>>>>            Move 0 to ScrollInfo.nPos
103503>>>>>>>            Move (SetScrollInfo (hWnd, If(bVert,SB_VERT,SB_HORZ), AddressOf (ScrollInfo), True)) to iVoid
103504>>>>>>>
103504>>>>>>>        End
103504>>>>>>>>
103504>>>>>>>    End_Procedure // 
103505>>>>>>>    
103505>>>>>>>    // this wraps GetScrollInfo
103505>>>>>>>    Function GetScrollBarInfo Boolean bVert tWinScrollInfo ByRef ScrollInfo Returns Boolean
103507>>>>>>>        Boolean bOk
103507>>>>>>>        Handle hWnd
103507>>>>>>>
103507>>>>>>>        Delegate Get Window_Handle to hWnd
103509>>>>>>>        If (hWnd <> 0) Begin        
103511>>>>>>>            Move (SizeOfType (tWinScrollInfo)) to ScrollInfo.cbSize
103512>>>>>>>            Move (SIF_ALL) to ScrollInfo.fMask
103513>>>>>>>            Move (GetScrollInfo (hWnd, If(bVert,SB_VERT,SB_HORZ), AddressOf (ScrollInfo))) to bOk
103514>>>>>>>        End
103514>>>>>>>>
103514>>>>>>>        Function_Return bOk
103515>>>>>>>    End_Function
103516>>>>>>>
103516>>>>>>>    // this wraps SetScrollPos
103516>>>>>>>    Procedure SetScrollBarPosInfo Boolean bVert Integer iPos
103518>>>>>>>        Integer iVoid
103518>>>>>>>        Handle hWnd
103518>>>>>>>
103518>>>>>>>        Delegate Get Window_Handle to hWnd
103520>>>>>>>        If (hWnd <> 0) Begin        
103522>>>>>>>            Move (SetScrollPos(hWnd, If(bVert,SB_VERT,SB_HORZ), iPos, True)) to iVoid
103523>>>>>>>        End
103523>>>>>>>>
103523>>>>>>>    End_Procedure
103524>>>>>>>
103524>>>>>>>    // scrolling containers don't do anhcors. However, this gets called every time the parent's
103524>>>>>>>    // guiSize changes. We can use that to scroll or resize the scrolling client as needed.
103524>>>>>>>    Procedure DoapplyAnchors Integer Arg1 Integer Arg2
103526>>>>>>>         Send ScrollClientArea
103527>>>>>>>    End_Procedure
103528>>>>>>>
103528>>>>>>>    // augment to handle the scrolling area initialization.
103528>>>>>>>    Procedure Add_Focus Handle hoParent
103530>>>>>>>        Forward Send Add_Focus hoParent
103532>>>>>>>        // at this the scrolling container and client area should both be paged. 
103532>>>>>>>        // child objects ae also paged with initial anchors applied
103532>>>>>>>        Send CalculateAutoScrollMinimums
103533>>>>>>>    End_Procedure
103534>>>>>>>    
103534>>>>>>>    Procedure Page Integer iPage
103536>>>>>>>        Forward Send Page iPage
103538>>>>>>>        If iPage Begin
103540>>>>>>>            // at this the scrolling container and client area should both be paged
103540>>>>>>>            // but the child controls are not paged. We don't want scrollbars when
103540>>>>>>>            // the child items are paged (else they may get anchored oddly) 
103540>>>>>>>            // Prior to 19.0 these were set in Add_focus which meant that the child objects were
103540>>>>>>>            // already paged with scrollbars present. This would result in scrollbars appearing
103540>>>>>>>            // before they were really needed. This should be more accurate
103540>>>>>>>            Send SetScrollBarInfo True 0 0 0
103541>>>>>>>            Send SetScrollBarInfo False 0 0 0
103542>>>>>>>        End
103542>>>>>>>>
103542>>>>>>>    End_Procedure
103543>>>>>>>
103543>>>>>>>    // determine scrolling minimums and set the client area as required.
103543>>>>>>>    
103543>>>>>>>    Procedure CalculateAutoScrollMinimums
103545>>>>>>>        Integer iMinX iMinY iSiz iLoc iMargin
103545>>>>>>>        Integer iAutoMinX iAutoMinY
103545>>>>>>>        Boolean bAutoScroll
103545>>>>>>>        Handle hoNext hoFirst
103545>>>>>>>        
103545>>>>>>>        Get pbAutoScroll to bAutoScroll
103546>>>>>>>        Get piAutoScrollMinX to iAutoMinX
103547>>>>>>>        Get piAutoScrollMinY to iAutoMinY
103548>>>>>>>        Get DialogToGui iAutoMinY iAutoMinX to iSiz
103549>>>>>>>        Move (Hi(iSiz)) to iAutoMinY
103550>>>>>>>        Move (Low(iSiz)) to iAutoMinX
103551>>>>>>>        Set piMinimumHeight to iAutoMinY
103552>>>>>>>        Set piMinimumWidth to iAutoMinX
103553>>>>>>>        
103553>>>>>>>        If (bAutoScroll and (iAutoMinX=0 or iAutoMinY=0)) Begin
103555>>>>>>>        
103555>>>>>>>            Get Next_Level to hoFirst
103556>>>>>>>            Move hoFirst to hoNext
103557>>>>>>>            If (hoFirst) Begin
103559>>>>>>>                Repeat
103559>>>>>>>>
103559>>>>>>>                    Get GuiWindowSize of hoNext to iSiz
103560>>>>>>>                    Get GuiLocation of hoNext to iLoc
103561>>>>>>>                    Move (Hi(iLoc)+Hi(iSiz) max iMinY) to iMinY
103562>>>>>>>                    Move (Low(iLoc)+Low(iSiz) max iMinX) to iMinx
103563>>>>>>>                    Get Next_Focus of hoNext to hoNext
103564>>>>>>>                Until (hoNext=0 or hoNext=hoFirst)
103566>>>>>>>
103566>>>>>>>                If (iAutoMinY=0) Begin
103568>>>>>>>                    Get piAutoScrollMarginY to iMargin
103569>>>>>>>                    Set piMinimumHeight to (iMinY+iMargin)
103570>>>>>>>                End
103570>>>>>>>>
103570>>>>>>>
103570>>>>>>>                If (iAutoMinX=0) Begin
103572>>>>>>>                    Get piAutoScrollMarginX to iMargin
103573>>>>>>>                    Set piMinimumWidth to (iMinX+iMargin)
103574>>>>>>>
103574>>>>>>>                End
103574>>>>>>>>
103574>>>>>>>            End
103574>>>>>>>>
103574>>>>>>>        End
103574>>>>>>>>
103574>>>>>>>        
103574>>>>>>>        // before setting the client area, unset all anchors so DoApplyAnchors will not do anything
103574>>>>>>>        Broadcast Set pbAnchorCreated to False
103576>>>>>>>        Send ScrollClientArea
103577>>>>>>>        // after the scroll set up, reinitialize all anchors.
103577>>>>>>>        Broadcast Send DoCreateAnchors
103579>>>>>>>    End_Procedure
103580>>>>>>>    
103580>>>>>>>    // Scroll the client area and adjust the client area size as needed. This does all the
103580>>>>>>>    // work of scrolling.
103580>>>>>>>    
103580>>>>>>>    Procedure ScrollClientArea
103582>>>>>>>        Integer iSiz
103582>>>>>>>        Integer iHeight iHCur iHCuriDelta iOrig iRange bOk
103582>>>>>>>        Integer iWidth iWCur iWDelta iWOrig
103582>>>>>>>        Integer iSzY iSzX iLocX iLocY
103582>>>>>>>        
103582>>>>>>>        Delegate Get GuiClientSize to iSiz
103584>>>>>>>        Move (Hi(iSiz)) to iHeight
103585>>>>>>>        Move (Low(iSiz)) to iWidth
103586>>>>>>>
103586>>>>>>>        // Vertical scrolling
103586>>>>>>>        
103586>>>>>>>        Get piMinimumHeight to iOrig
103587>>>>>>>        Get piMinimumWidth to iWOrig
103588>>>>>>>        
103588>>>>>>>        If (iOrig<>0 or iWOrig<>0) Begin
103590>>>>>>>        
103590>>>>>>>            If (iOrig<>0) Begin
103592>>>>>>>                Get piCurrentVertScrolled to iHCur
103593>>>>>>>                // If the size got bigger and we've scrolled, we want to scroll up        
103593>>>>>>>                If (iHCur<>0 and (iHCur+iHeight>iOrig)) Begin
103595>>>>>>>                    Move (iOrig-iHeight max 0) to iHCur
103596>>>>>>>                    Set piCurrentVertScrolled to iHCur
103597>>>>>>>                End
103597>>>>>>>>
103597>>>>>>>                If (iHCur<>0 or iOrig>iHeight) Begin
103599>>>>>>>                    Send SetScrollBarInfo True 0 iOrig (iHeight min iOrig)
103600>>>>>>>                    Send SetScrollBarPosInfo True iHCur 
103601>>>>>>>                End
103601>>>>>>>>
103601>>>>>>>                Else Begin
103602>>>>>>>                    Send SetScrollBarInfo True 0 0 0 //iOrig (iHeight min iOrig)
103603>>>>>>>                End
103603>>>>>>>>
103603>>>>>>>            End
103603>>>>>>>>
103603>>>>>>>                
103603>>>>>>>            // Horiz scrolling
103603>>>>>>>            
103603>>>>>>>            Get piCurrentHorzScrolled to iWCur
103604>>>>>>>    //        If (iWCur<>0) Begin
103604>>>>>>>                // If the size got bigger and we've scrolled, we want to scroll left        
103604>>>>>>>                If (iWCur<>0 and (iWCur+iWidth>iWOrig)) Begin
103606>>>>>>>                    Move (iWOrig-iWidth max 0) to iWCur
103607>>>>>>>                    Set piCurrentHorzScrolled to iWCur
103608>>>>>>>                End
103608>>>>>>>>
103608>>>>>>>                If (iWCur<>0 or iWOrig>iWidth) Begin
103610>>>>>>>                    Send SetScrollBarInfo False 0 iWOrig (iWidth min iWOrig)
103611>>>>>>>                    Send SetScrollBarPosInfo False iWCur 
103612>>>>>>>                End
103612>>>>>>>>
103612>>>>>>>                Else Begin
103613>>>>>>>                    Send SetScrollBarInfo False 0 0 0 
103614>>>>>>>                End
103614>>>>>>>>
103614>>>>>>>    //        End
103614>>>>>>>        End
103614>>>>>>>>
103614>>>>>>>        
103614>>>>>>>        // this could change depending on scrollbars appearing or not    
103614>>>>>>>        Delegate Get GuiClientSize to iSiz
103616>>>>>>>        
103616>>>>>>>        // size of container is the the minimum allowed size (if scrolling is needed)
103616>>>>>>>        // or it is the actual size of the container (if scrolling not needed and it is bigger)
103616>>>>>>>        // This is required to make anchors work sensibly 
103616>>>>>>>        Move (hi(iSiz) max iOrig) to iSzY
103617>>>>>>>        Move (low(iSiz) max iWOrig) to iSzX
103618>>>>>>>        Move (-iHCur) to iLocY
103619>>>>>>>        Move (-iWCur) to iLocX
103620>>>>>>>
103620>>>>>>>        // Allow chance to make modifications
103620>>>>>>>        Send AdjustSizesLocs (&iSzY) (&iSzX) (&iLocY) (&iLocX)
103621>>>>>>>
103621>>>>>>>        Set GuiSize to iSzY iSzX
103622>>>>>>>        // if we've scrolled, we need to reposition the container
103622>>>>>>>        Set GuiLocation to iLocY iLocX  
103623>>>>>>>    End_Procedure
103624>>>>>>>
103624>>>>>>>    // note that scrolling never changes the size of the scrolling client.
103624>>>>>>>    // this way, it does not interfere with anchors.
103624>>>>>>>    
103624>>>>>>>    Procedure VScroll Integer iDelta
103626>>>>>>>        Integer iHeight iCur iOrig iSiz 
103626>>>>>>>        Delegate Get GuiClientSize to iSiz
103628>>>>>>>        Move (hi(iSiz)) to iHeight
103629>>>>>>>        Get piCurrentVertScrolled to iCur
103630>>>>>>>        Get piMinimumHeight to iOrig
103631>>>>>>>        If (iOrig=0 or  Hi(iSiz)>=iOrig) Begin
103633>>>>>>>            Procedure_Return
103634>>>>>>>        End
103634>>>>>>>>
103634>>>>>>>        // make sure delta is within range  
103634>>>>>>>        If (iDelta+iCur<0) Begin
103636>>>>>>>            Move (-iCur) to iDelta
103637>>>>>>>        End
103637>>>>>>>>
103637>>>>>>>        Else If (iDelta+iCur>iOrig - iHeight) Begin
103640>>>>>>>            Move (iOrig - iHeight - iCur) to iDelta
103641>>>>>>>        End
103641>>>>>>>>
103641>>>>>>>        If (iDelta=0) Procedure_Return
103644>>>>>>>        
103644>>>>>>>        Move (iCur + iDelta) to iCur 
103645>>>>>>>        Set piCurrentVertScrolled to iCur 
103646>>>>>>>        Send SetScrollBarPosInfo True iCur 
103647>>>>>>>        Get GuiLocation to iSiz
103648>>>>>>>        Set GuiLocation to (cast(hi(iSiz),Short)-iDelta) (cast(low(iSiz),Short))
103649>>>>>>>        Send ScrollClientArea
103650>>>>>>>    End_Procedure
103651>>>>>>>    
103651>>>>>>>    
103651>>>>>>>    Procedure HScroll Integer iDelta
103653>>>>>>>        Integer iHeight iCur iOrig iSiz
103653>>>>>>>        Delegate Get GuiClientSize to iSiz
103655>>>>>>>        Move (low(iSiz)) to iHeight
103656>>>>>>>        Get piCurrentHorzScrolled to iCur
103657>>>>>>>        Get piMinimumWidth to iOrig
103658>>>>>>>        If (iOrig=0 or  low(iSiz)>=iOrig) Begin
103660>>>>>>>            Procedure_Return
103661>>>>>>>        End
103661>>>>>>>>
103661>>>>>>>        If (iDelta+iCur<0) Begin
103663>>>>>>>            Move (-iCur) to iDelta
103664>>>>>>>        End
103664>>>>>>>>
103664>>>>>>>        Else If (iDelta+iCur>iOrig - iHeight) Begin
103667>>>>>>>            Move (iOrig - iHeight - iCur) to iDelta
103668>>>>>>>        End
103668>>>>>>>>
103668>>>>>>>        If (iDelta=0) Procedure_Return
103671>>>>>>>        
103671>>>>>>>        Move (iCur + iDelta) to iCur 
103672>>>>>>>        Set piCurrentHorzScrolled to iCur 
103673>>>>>>>        Send SetScrollBarPosInfo False iCur 
103674>>>>>>>        Get GuiLocation to iSiz
103675>>>>>>>        Set GuiLocation to (cast(hi(iSiz),Short)) (cast(low(iSiz),Short) -iDelta)
103676>>>>>>>        Send ScrollClientArea
103677>>>>>>>    End_Procedure
103678>>>>>>>    
103678>>>>>>>    // make sure client is a 0,0
103678>>>>>>>    Procedure ScrollHome
103680>>>>>>>        Send SetVScrollbox SB_TOP 0
103681>>>>>>>        Send SetHScrollbox SB_TOP 0
103682>>>>>>>    End_Procedure
103683>>>>>>>
103683>>>>>>>    // get relative GUI location of this object to the parent one passed.
103683>>>>>>>    Procedure LocationRelativeTo Handle hoContainer Handle hoControl Integer ByRef iLocY Integer ByRef iLocX
103685>>>>>>>        Integer ivoid
103685>>>>>>>        tWinRect Rect0 Rect1
103685>>>>>>>        tWinRect Rect0 Rect1
103685>>>>>>>        Move (GetWindowRect(window_handle(hoContainer),addressof(Rect0))) to ivoid
103686>>>>>>>        Move (GetWindowRect(window_handle(hoControl),addressof(Rect1))) to ivoid
103687>>>>>>>        Move ((Rect1.top) - (Rect0.top)) to iLocY
103688>>>>>>>        Move ((rect1.left) - (rect0.left)) to iLocX
103689>>>>>>>    End_Procedure
103690>>>>>>>    
103690>>>>>>>    // This scrolls this object into visual range. 
103690>>>>>>>    Procedure ScrollObjectInRange Handle hoControl
103692>>>>>>>        Handle hoScrollingContainer
103692>>>>>>>        Integer iCurrentVertScrolled iCurrentHorzScrolled
103692>>>>>>>        Integer iViewHeight iViewWidth
103692>>>>>>>        Integer iRelLocHeight iRelLocWidth
103692>>>>>>>        Integer iSize iControlHeight iControlWidth
103692>>>>>>>        Integer iScroll
103692>>>>>>>        Integer iMarginX iMarginY
103692>>>>>>>        Integer iScrollingContainerWindowSize iScrollingContainerClientSize
103692>>>>>>>        
103692>>>>>>>        Get piAutoScrollMarginX to iMarginX
103693>>>>>>>        Get piAutoScrollMarginY to iMarginY
103694>>>>>>>        
103694>>>>>>>        // the scrolling container 
103694>>>>>>>        Move Self to hoScrollingContainer
103695>>>>>>>        // the amount the SC is currently scrolled
103695>>>>>>>        Get piCurrentVertScrolled of hoScrollingContainer to iCurrentVertScrolled
103696>>>>>>>        Get piCurrentHorzScrolled of hoScrollingContainer to iCurrentHorzScrolled
103697>>>>>>>        
103697>>>>>>>        // size of view's client area (this is the viewport area)
103697>>>>>>>        Get GuiClientSize of (Parent(hoScrollingContainer)) to iSize
103698>>>>>>>        Move (hi(iSize)) to iViewHeight
103699>>>>>>>        Move (low(iSize)) to iViewWidth
103700>>>>>>>        
103700>>>>>>>        // get this object's location relative to the scrolling container
103700>>>>>>>        Send LocationRelativeTo hoScrollingContainer hoControl (&iRelLocHeight) (&iRelLocWidth)
103701>>>>>>>
103701>>>>>>>        // we expect that the client size is the window size but just in case
103701>>>>>>>        Get GuiWindowSize of hoScrollingContainer to iScrollingContainerWindowSize
103702>>>>>>>        Get GuiClientSize of hoScrollingContainer to iScrollingContainerClientSize
103703>>>>>>>        Move (iRelLocHeight - (Hi(iScrollingContainerWindowSize)-Hi(iScrollingContainerClientSize))) to iRelLocHeight 
103704>>>>>>>        Move (iRelLocWidth - (Low(iScrollingContainerWindowSize)-Low(iScrollingContainerClientSize))) to iRelLocWidth
103705>>>>>>>        
103705>>>>>>>        // the outer size of the control object
103705>>>>>>>        Get GUIWindowSize of hoControl to iSize
103706>>>>>>>        Move (hi(iSize)) to iControlHeight
103707>>>>>>>        Move (low(iSize)) to iControlWidth
103708>>>>>>>        
103708>>>>>>>        // the general idea is to make the control fully visible but to scroll as little as possible.
103708>>>>>>>
103708>>>>>>>        // Vertical Scroll
103708>>>>>>>        
103708>>>>>>>        // Vertical Scroll down
103708>>>>>>>        // if the bottom of the control plus a bottom margin does not fit make it fit at the bottom
103708>>>>>>>        If (iRelLocHeight + iControlHeight + iMarginY - iCurrentVertScrolled >iViewHeight) Begin
103710>>>>>>>           
103710>>>>>>>           // set scroll amount so that the bottom of the control is visible  
103710>>>>>>>           Move (iRelLocHeight + iControlHeight + iMarginY - iCurrentVertScrolled - iViewHeight ) to iScroll
103711>>>>>>>           
103711>>>>>>>           // See if this amount, scrolls the top out of range. If so just scroll enough so that the
103711>>>>>>>           // top of the object appears at the bottom 
103711>>>>>>>           If (iRelLocHeight - iCurrentVertScrolled < iScroll) Begin
103713>>>>>>>               Move (iRelLocHeight + iMarginY  - iCurrentVertScrolled - iViewHeight  ) to iScroll
103714>>>>>>>           End
103714>>>>>>>>
103714>>>>>>>           // if the scroll amnt is negative it's best to just keep it where it is.
103714>>>>>>>           If (iScroll>0) Begin
103716>>>>>>>                Send VScroll of hoScrollingContainer iScroll
103717>>>>>>>           End
103717>>>>>>>>
103717>>>>>>>        End
103717>>>>>>>>
103717>>>>>>>        // else vertical scroll up 
103717>>>>>>>        // We scroll if the top of the object is not visible.  
103717>>>>>>>        Else If (iRelLocHeight + iMarginY < iCurrentVertScrolled) Begin
103720>>>>>>>            // if we scroll we will scroll enough to see the top of the object.
103720>>>>>>>            Move (iRelLocHeight -iMarginY - iCurrentVertScrolled ) to iScroll
103721>>>>>>>            If (iScroll<0) Begin
103723>>>>>>>                Send VScroll of hoScrollingContainer (iScroll max (-iCurrentVertScrolled))
103724>>>>>>>            End
103724>>>>>>>>
103724>>>>>>>        End
103724>>>>>>>>
103724>>>>>>>
103724>>>>>>>        // Horizonal Scroll
103724>>>>>>>        
103724>>>>>>>        // if the right side of the control does not fit, scroll it so it fits
103724>>>>>>>        If (iRelLocWidth + iControlWidth + iMarginX - iCurrentHorzScrolled >iViewWidth) Begin
103726>>>>>>>           Move (iRelLocWidth + iControlWidth + iMarginX - iCurrentHorzScrolled - iViewWidth ) to iScroll
103727>>>>>>>           If (iRelLocWidth - iCurrentHorzScrolled - iScroll<0) Begin
103729>>>>>>>               Move (iRelLocWidth  - iCurrentHorzScrolled - iMarginX ) to iScroll
103730>>>>>>>           End
103730>>>>>>>>
103730>>>>>>>           If (iScroll>0) Begin
103732>>>>>>>                Send HScroll of hoScrollingContainer iScroll
103733>>>>>>>           End
103733>>>>>>>>
103733>>>>>>>        End
103733>>>>>>>>
103733>>>>>>>        If (iRelLocWidth - iMarginX  - iCurrentHorzScrolled <0) Begin
103735>>>>>>>            // if this can fit by moving all the way to left, do so.
103735>>>>>>>            If (iRelLocWidth + iControlWidth + iMarginX <= iViewWidth) Begin
103737>>>>>>>                Move (-iCurrentHorzScrolled) to iScroll
103738>>>>>>>            End
103738>>>>>>>>
103738>>>>>>>            Else Begin
103739>>>>>>>                Move (iRelLocWidth - iCurrentHorzScrolled - iMarginX) to iScroll
103740>>>>>>>            End
103740>>>>>>>>
103740>>>>>>>            If (iScroll<0) Begin
103742>>>>>>>                Send HScroll of hoScrollingContainer (iScroll max (-iCurrentHorzScrolled))
103743>>>>>>>            End
103743>>>>>>>>
103743>>>>>>>        End
103743>>>>>>>>
103743>>>>>>>
103743>>>>>>>
103743>>>>>>>    End_Procedure
103744>>>>>>>
103744>>>>>>>    // when we receive this message, we might need to scroll to bring the new focus in to view.
103744>>>>>>>    Procedure NotifyFocusSetInContainer Handle hoControl
103746>>>>>>>        Boolean bScrollOnFocus
103746>>>>>>>        Get pbAutoScrollFocus to bScrollOnFocus
103747>>>>>>>        If bScrollOnFocus Begin
103749>>>>>>>            Send ScrollObjectInRange hoControl
103750>>>>>>>        End
103750>>>>>>>>
103750>>>>>>>        Delegate Send NotifyFocusSetInContainer hoControl
103752>>>>>>>    End_Procedure
103753>>>>>>>
103753>>>>>>>
103753>>>>>>>    Function CenterTabWorkspaceView Returns Boolean
103755>>>>>>>        Boolean bCenter
103755>>>>>>>        Get pbCenterTabbedViews of ghoCommandBars to bCenter
103756>>>>>>>        Function_Return bCenter
103757>>>>>>>    End_Function
103758>>>>>>>    
103758>>>>>>>    Procedure AdjustSizesLocs Integer ByRef iHeight Integer ByRef iWidth Integer ByRef iLocY Integer ByRef iLocX
103760>>>>>>>        Boolean bTabWorkspaceView
103760>>>>>>>        Get pbTabWorkspaceView to bTabWorkspaceView 
103761>>>>>>>        If bTabWorkspaceView Begin
103763>>>>>>>            Send AdjustTabWorkspaceView (&iHeight) (&iWidth) (&iLocY) (&iLocX)
103764>>>>>>>        End
103764>>>>>>>>
103764>>>>>>>    End_Procedure
103765>>>>>>>    
103765>>>>>>>    Function ParentView Returns Handle
103767>>>>>>>        Function_Return (Parent(Parent(Self)))
103768>>>>>>>    End_Function
103769>>>>>>>    
103769>>>>>>>    Procedure AdjustTabWorkspaceView Integer ByRef iHeight Integer ByRef iWidth Integer ByRef iLocY Integer ByRef iLocX
103771>>>>>>>        Integer iSize iMax iDiff
103771>>>>>>>        Handle hoView
103771>>>>>>>        Boolean bCenter bModal
103771>>>>>>>        Get ParentView to hoView
103772>>>>>>>        Get Block_Mouse_State of hoView to bModal
103773>>>>>>>        If not bModal Begin
103775>>>>>>>            Get CenterTabWorkspaceView to bCenter
103776>>>>>>>            Get GuiSize of hoView to iSize
103777>>>>>>>            Get piMaxSize of hoView to iMax
103778>>>>>>>            Get DialogToGui (Hi(iMax)) (Low(iMax)) to iMax
103779>>>>>>>            If (Low(iMax) and Low(iMax)<=Low(isize)) Begin
103781>>>>>>>                If bCenter Begin
103783>>>>>>>                    Move ((Low(iSize)-Low(iMax))/2) to iLocX
103784>>>>>>>                End
103784>>>>>>>>
103784>>>>>>>                Move (Low(iMax)) to iWidth
103785>>>>>>>            End
103785>>>>>>>>
103785>>>>>>>            If (Hi(iMax) and Hi(iMax)<=Hi(iSize)) Begin
103787>>>>>>>                If bCenter Begin
103789>>>>>>>                    Move ((Hi(iSize)-Hi(iMax))/2) to iLocY
103790>>>>>>>                    Move (iLocy min 25) to  iLocY
103791>>>>>>>                End
103791>>>>>>>>
103791>>>>>>>                Move (Hi(imax)) to iHeight
103792>>>>>>>            End
103792>>>>>>>>
103792>>>>>>>        End
103792>>>>>>>>
103792>>>>>>>    End_Procedure
103793>>>>>>>
103793>>>>>>>    // Automatically determine if this is a scrolling tabbed workspace view
103793>>>>>>>    // If determines this by checking pbAutoSetTabWorkspaceView is set (it can be
103793>>>>>>>    // set to stop this), if we have a global commandbar object and we are using tabbed
103793>>>>>>>    // workspaces. We also make sure that the expected view object is a framework view class
103793>>>>>>>    // This should almost always yield the right answer.
103793>>>>>>>    // This is called by the scrolling container's end_constructor
103793>>>>>>>    Procedure AutoSetTabWorkspaceView
103795>>>>>>>        Boolean bTabView bIsView bAutoSetTabWorkspaceView
103795>>>>>>>        Handle hoParent
103795>>>>>>>        Integer iSize
103795>>>>>>>        Get pbAutoSetTabWorkspaceView to bAutoSetTabWorkspaceView  
103796>>>>>>>        If (ghoCommandBars and bAutoSetTabWorkspaceView) Begin
103798>>>>>>>            Get pbTabbedWorkspaces of ghoCommandBars to bTabView
103799>>>>>>>            // not that pbTabbedWorkspaces is a designtime only property. You can not
103799>>>>>>>            // change this after the commandbar is paged.
103799>>>>>>>            If (bTabView) Begin
103801>>>>>>>                Get ParentView to hoParent
103802>>>>>>>                Get IsObjectOfClass of hoParent (RefClass(MdiDialog)) to bIsView
103803>>>>>>>                If (bIsView) Begin
103805>>>>>>>                    // set this as a tab workspace view
103805>>>>>>>                    Set pbTabWorkspaceView to True
103806>>>>>>>                    // when tab workspaces are enabled we always enable auto-scrolling
103806>>>>>>>                    // when tab workspaces are not enabled, pbScroll is whatever it is
103806>>>>>>>                    Set pbAutoScroll to True
103807>>>>>>>                    
103807>>>>>>>//                    // if piMaxSize is not set, we will do it for you by setting it
103807>>>>>>>//                    // to the current size.
103807>>>>>>>//                    Get piMaxSize of hoParent to iSize
103807>>>>>>>//                    If (iSize=0) Begin
103807>>>>>>>//                        Get Size of hoParent to iSize
103807>>>>>>>//                        Set piMaxSize of hoParent to (Hi(iSize)) (Low(iSize))
103807>>>>>>>//                    End
103807>>>>>>>                End
103807>>>>>>>>
103807>>>>>>>            End
103807>>>>>>>>
103807>>>>>>>        End
103807>>>>>>>>
103807>>>>>>>    End_Procedure
103808>>>>>>>
103808>>>>>>>End_Class
103809>>>>>>>
103809>>>>>>>// Container scrolling class support. Nothing in here is public
103809>>>>>>>Class cScrollingContainerMixin is a Mixin
103810>>>>>>>
103810>>>>>>>    Procedure Define_cScrollingContainerMixin
103812>>>>>>>        Forward Set Border_Style to Border_None
103814>>>>>>>        Set pbSizeToClientArea to False // scrollbars and clientsize do not mix
103815>>>>>>>        Forward Set peAnchors to anAll
103817>>>>>>>
103817>>>>>>>        // forcing scrollbars right away seems to make painting better
103817>>>>>>>        Set Window_Style WS_HSCROLL to True
103818>>>>>>>        Set Window_Style WS_VSCROLL to True
103819>>>>>>>
103819>>>>>>>        Property Handle phoScrollingClientArea 0
103820>>>>>>>    End_Procedure
103821>>>>>>>    
103821>>>>>>>    // if anchors are changed, it will not work. We won't let that happen
103821>>>>>>>    Procedure Set peAnchors Integer eAnchors
103823>>>>>>>    End_Procedure
103824>>>>>>>
103824>>>>>>>    // if a border style is set, it will not work. We won't let that happen
103824>>>>>>>    Procedure Set Border_Style Integer eStyle
103826>>>>>>>    End_Procedure
103827>>>>>>>
103827>>>>>>>    // redirect scrollbar events and wheel events to the scrolling client area
103827>>>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
103829>>>>>>>        Handle hoClient
103829>>>>>>>        Get phoScrollingClientArea to hoClient
103830>>>>>>>        If hoClient Begin
103832>>>>>>>           Send OnMouseWheel of hoClient wParam lParam
103833>>>>>>>        End
103833>>>>>>>>
103833>>>>>>>    End_Procedure
103834>>>>>>>
103834>>>>>>>    // should be sent by WM_VSCROLL
103834>>>>>>>    Procedure SetVScrollbox Integer iType Integer iNewPos
103836>>>>>>>        Handle hoClient
103836>>>>>>>        Get phoScrollingClientArea to hoClient
103837>>>>>>>        If hoClient Begin
103839>>>>>>>           Send SetVScrollbox of hoClient iType iNewPos
103840>>>>>>>        End
103840>>>>>>>>
103840>>>>>>>    End_Procedure
103841>>>>>>>
103841>>>>>>>    // should be sent by WM_HSCROLL
103841>>>>>>>    Procedure SetHScrollbox Integer iType Integer iNewPos
103843>>>>>>>        Handle hoClient
103843>>>>>>>        Get phoScrollingClientArea to hoClient
103844>>>>>>>        If hoClient Begin
103846>>>>>>>           Send SetHScrollbox of hoClient iType iNewPos
103847>>>>>>>        End
103847>>>>>>>>
103847>>>>>>>    End_Procedure
103848>>>>>>>
103848>>>>>>>    // augmented to adjust its size to the size of the parent client area.
103848>>>>>>>    // After this is set, anchors will handle any further resizing.
103848>>>>>>>    Procedure Page Integer iState
103850>>>>>>>        Integer iSiz iHeight iWidth
103850>>>>>>>        Integer iTop iBottom iLeft iRight iFontSize
103850>>>>>>>        Boolean bGroup
103850>>>>>>>        Handle hoClient
103850>>>>>>>        If (iState =1) Begin
103852>>>>>>>            Delegate Get Window_Style BS_GROUPBOX to bGroup
103854>>>>>>>            // We have special code to support groups because they
103854>>>>>>>            // draw a border inside of the client rectangle
103854>>>>>>>            If bGroup Begin
103856>>>>>>>                Get Physical_FontSize to iFontSize
103857>>>>>>>                Move (Hi(iFontSize)) to iTop
103858>>>>>>>                Move 2 to iLeft
103859>>>>>>>                Move 2 to iRight
103860>>>>>>>                Move 2 to iBottom
103861>>>>>>>            End
103861>>>>>>>>
103861>>>>>>>            // We use GetContainerClientSize instead of GuiClientSize because
103861>>>>>>>            // GetContainerClientSize has a special augmentation in tab pages that
103861>>>>>>>            // makes anchors work properly with unpaged tab-pages
103861>>>>>>>            Delegate Get GetContainerClientSize to iSiz
103863>>>>>>>            Set GuiSize to (Hi(iSiz)-(iTop+iBottom)) (Low(iSiz)-(iLeft+iRight))
103864>>>>>>>            Set GuiLocation to iTop iLeft
103865>>>>>>>            Send Adjust_Logicals
103866>>>>>>>        End
103866>>>>>>>>
103866>>>>>>>        Forward Send Page iState
103868>>>>>>>    End_Procedure
103869>>>>>>>    
103869>>>>>>>    Procedure End_Construct_Object 
103871>>>>>>>        Handle hoClient
103871>>>>>>>        Forward Send End_Construct_Object
103873>>>>>>>        Get phoScrollingClientArea to hoClient
103874>>>>>>>        If (hoClient) Begin
103876>>>>>>>            Send AutoSetTabWorkspaceView of hoClient
103877>>>>>>>        End
103877>>>>>>>>
103877>>>>>>>    End_Procedure
103878>>>>>>>
103878>>>>>>>End_Class
103879>>>>>>>
103879>>>>>
103879>>>>>Class cDbScrollingClientArea is a dbContainer3d
103880>>>>>    Import_Class_Protocol cScrollingClientAreaMixin
103881>>>>>    Procedure Construct_Object
103883>>>>>        Forward Send Construct_Object
103885>>>>>        Send Define_cScrollingClientAreaMixin
103886>>>>>    End_Procedure
103887>>>>>End_Class
103888>>>>>
103888>>>>>
103888>>>>>
103888>>>>>Class cDbScrollingContainer is a dbContainer3d
103889>>>>>    Import_Class_Protocol cScrollingContainerMixin
103890>>>>>    Procedure Construct_Object
103892>>>>>        Forward Send Construct_Object
103894>>>>>        Send Define_cScrollingContainerMixin
103895>>>>>    End_Procedure
103896>>>>>End_Class
103897>>>Use cDbUpdateFunctionLibrary.pkg
103897>>>Use cButtonDPI.pkg
Including file: cButtonDPI.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cButtonDPI.pkg)
103897>>>>>Use cButton.pkg
Including file: cButton.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cButton.pkg)
103897>>>>>>>//****************************************************************************
103897>>>>>>>// $Module type: Package
103897>>>>>>>// $Module name: cButton.pkg
103897>>>>>>>//
103897>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
103897>>>>>>>// Copyright (c) 2012 RDC Tools International
103897>>>>>>>// E-mail      : support@rdctools.com
103897>>>>>>>// Web-site    : http://www.rdctools.com
103897>>>>>>>//
103897>>>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
103897>>>>>>>//
103897>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
103897>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
103897>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
103897>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
103897>>>>>>>// in the help folder for more details.
103897>>>>>>>//
103897>>>>>>>//****************************************************************************
103897>>>>>>>Use Windows.pkg
103897>>>>>>>Use Enclient.pkg
103897>>>>>>>Use errornum.inc
103897>>>>>>>
103897>>>>>>>Class cButtonIdleHandler is a cIdleHandler
103898>>>>>>>    Procedure Construct_Object
103900>>>>>>>        Forward Send Construct_Object
103902>>>>>>>
103902>>>>>>>    End_Procedure
103903>>>>>>>
103903>>>>>>>    Procedure OnIdle
103905>>>>>>>        Delegate Send DoEnable
103907>>>>>>>    End_Procedure
103908>>>>>>>
103908>>>>>>>End_Class
103909>>>>>>>
103909>>>>>>>Class cButton is a Button
103910>>>>>>>
103910>>>>>>>    Procedure Construct_Object
103912>>>>>>>        Forward Send Construct_Object
103914>>>>>>>
103914>>>>>>>//#IF (Required_FMAC_Version < 17)
103914>>>>>>>//        Set Typeface to "Segoe UI"
103914>>>>>>>//        Set FontSize to 18 0
103914>>>>>>>//#ENDIF
103914>>>>>>>
103914>>>>>>>        Property Boolean pbAutoEnable False
103915>>>>>>>
103915>>>>>>>        Object oButtonIdleHandler is a cButtonIdleHandler
103917>>>>>>>        End_Object
103918>>>>>>>    End_Procedure
103919>>>>>>>
103919>>>>>>>    Procedure End_Construct_Object
103921>>>>>>>        String sTooltip sStatus_Help
103921>>>>>>>
103921>>>>>>>        Forward Send End_Construct_Object
103923>>>>>>>
103923>>>>>>>        Get psToolTip   to sTooltip
103924>>>>>>>        Get Status_Help to sStatus_Help
103925>>>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
103927>>>>>>>            Set psToolTip to sStatus_Help
103928>>>>>>>        End
103928>>>>>>>>
103928>>>>>>>        Set pbEnabled of oButtonIdleHandler to (pbAutoEnable(Self))
103929>>>>>>>    End_Procedure
103930>>>>>>>
103930>>>>>>>    Procedure DoEnable
103932>>>>>>>        Boolean bAutoEnable bHasRecord
103932>>>>>>>        Handle hoDD
103932>>>>>>>        Get pbAutoEnable to bAutoEnable
103933>>>>>>>        If (bAutoEnable = False) Begin
103935>>>>>>>            Procedure_Return
103936>>>>>>>        End
103936>>>>>>>>
103936>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
103937>>>>>>>        Move (Main_DD(Self)) to hoDD
103938>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
103939>>>>>>>        If (hoDD <> 0) Begin
103941>>>>>>>            Get HasRecord of hoDD to bHasRecord
103942>>>>>>>        End
103942>>>>>>>>
103942>>>>>>>        Set Enabled_State to (bHasRecord = True)
103943>>>>>>>    End_Procedure
103944>>>>>>>
103944>>>>>>>    // Enable the idle handler timer when the button is activated
103944>>>>>>>    Procedure Activating
103946>>>>>>>       Forward Send Activating
103948>>>>>>>       Set pbEnabled of oButtonIdleHandler to True
103949>>>>>>>    End_Procedure
103950>>>>>>>
103950>>>>>>>    // Disable the idle handler when the button is deactivated
103950>>>>>>>    Procedure Deactivating
103952>>>>>>>       Set pbEnabled of oButtonIdleHandler to False
103953>>>>>>>       Forward Send Deactivating
103955>>>>>>>    End_Procedure
103956>>>>>>>
103956>>>>>>>End_Class
103957>>>>>
103957>>>>>// Button class that automatically shows the correct icon size for the current DPI-setting:
103957>>>>>Class cButtonDPI is a cButton
103958>>>>>    Procedure Construct_Object
103960>>>>>        Integer iIconSize
103960>>>>>        Forward Send Construct_Object
103962>>>>>        Get GetCorrectIconSize to iIconSize
103963>>>>>        Set piImageSize to iIconSize
103964>>>>>        Set piImageMarginLeft to 10
103965>>>>>    End_Procedure
103966>>>>>
103966>>>>>    // Returns: DPI setting as an integer.
103966>>>>>    //  Normal DPI setting: iDPI=96  is "Normal setting" 100%
103966>>>>>    //                      iDPI=120 is "Medium setting" 125%
103966>>>>>    //                      iDPI= 144 is "Large setting" 150%
103966>>>>>    Function GetCurrentDPI Returns Integer
103968>>>>>        Handle hDC
103968>>>>>        Integer iPixelsX
103968>>>>>        Move (GetDC(0)) to hDC
103969>>>>>        Move (GetDeviceCaps(hDC, LOGPIXELSX)) to iPixelsX
103970>>>>>        Move (ReleaseDC(0, hDC)) to hDC
103971>>>>>        Function_Return iPixelsX
103972>>>>>    End_Function
103973>>>>>
103973>>>>>    Function GetCorrectIconSize Returns Integer
103975>>>>>        Integer iPixelsX iIndex iSize
103975>>>>>        Integer[] iaSizes
103976>>>>>
103976>>>>>        Move 16 to iaSizes[0]
103977>>>>>        Move 24 to iaSizes[1]
103978>>>>>        Move 32 to iaSizes[2]
103979>>>>>        Move 48 to iaSizes[3]
103980>>>>>        Move 64 to iaSizes[4]
103981>>>>>
103981>>>>>        Get piImageSize to iSize  // the "100%" size
103982>>>>>        Move (SearchArray(iSize,iaSizes)) to iIndex
103983>>>>>        Move (0 max iIndex) to iIndex
103984>>>>>        Get GetCurrentDPI to iPixelsX
103985>>>>>        // Use a Case Statement here. Wherever we jump in we will continue onwards, regardless of whether
103985>>>>>        // we match the remaining Case statements or not. So list our Cases in reverse order, meaning we
103985>>>>>        // will increment iIndex as many times as we need here.
103985>>>>>        Case Begin
103985>>>>>            Case (iPixelsX > 144)
103987>>>>>                Increment iIndex
103988>>>>>            Case (iPixelsX = 144)
103991>>>>>                Increment iIndex
103992>>>>>            Case (iPixelsX = 120)
103995>>>>>                Increment iIndex
103996>>>>>        Case End
103996>>>>>        Move (iIndex min 4) to iIndex
103997>>>>>        Function_Return iaSizes[iIndex]
103998>>>>>    End_Function
103999>>>>>
103999>>>>>    Procedure Set psToolTip String sToolTip
104001>>>>>        String sStatusHelp
104001>>>>>
104001>>>>>        Get Status_Help to sStatusHelp
104002>>>>>        If (sStatusHelp = "") Begin
104004>>>>>            Set Status_Help to sToolTip
104005>>>>>        End
104005>>>>>>
104005>>>>>
104005>>>>>        Forward Set psToolTip to sToolTip
104007>>>>>    End_Function
104008>>>>>
104008>>>>>End_Class
104009>>>Use DatabaseSelection.dg
104009>>>Use ServerSelection.dg
Including file: ServerSelection.dg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\ServerSelection.dg)
104009>>>>>Use Windows.pkg
104009>>>>>Use cCJGridPromptList.pkg
104009>>>>>Use cDbUpdateFunctionLibrary.pkg
104009>>>>>Use MSSqldrv.pkg
104009>>>>>Use db2_drv.pkg
104009>>>>>Use odbc_drv.pkg
104009>>>>>
104009>>>>>Object oServerSelection_sl is a ModalPanel
104011>>>>>    Set Size to 148 274
104012>>>>>    Set Label to "Database Server/DSN Selection"
104013>>>>>    Set piMinSize to 89 211
104014>>>>>    Set Location to 2 2
104015>>>>>    Set Border_Style to Border_Thick
104016>>>>>
104016>>>>>    Property String[] psTheData
104018>>>>>
104018>>>>>    Object oSelList is a cCJGridPromptList
104020>>>>>        Set Size to 115 264
104021>>>>>        Set Location to 6 6
104022>>>>>        Set peAnchors to anAll
104023>>>>>        Set pbAllowColumnRemove to False
104024>>>>>        Set pbUseAlternateRowBackgroundColor to True
104025>>>>>        Set pbGrayIfDisable to False
104026>>>>>        Set pbHeaderReorders to False
104027>>>>>        Set pbHeaderSelectsColumn to False
104028>>>>>        Set pbHeaderTogglesDirection to False
104029>>>>>        Set pbShadeSortColumn to False
104030>>>>>        Set piFocusCellBackColor to clDkGray
104031>>>>>
104031>>>>>        Object oName is a cCJGridColumn
104033>>>>>            Set piWidth to 528
104034>>>>>            Set psCaption to "Name"
104035>>>>>        End_Object
104036>>>>>
104036>>>>>        Procedure Activating
104039>>>>>            tDataSourceRow[] MyData
104039>>>>>            tDataSourceRow[] MyData
104040>>>>>            Handle hoDataSource
104040>>>>>            String[] sTheData
104041>>>>>            Integer iCount iSize
104041>>>>>
104041>>>>>            Send Cursor_Wait of Cursor_Control
104042>>>>>            Get psTheData to sTheData
104043>>>>>            Move (SizeOfArray(sTheData)) to iSize
104044>>>>>            Decrement iSize
104045>>>>>            For iCount from 0 to iSize
104051>>>>>>
104051>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
104052>>>>>            Loop
104053>>>>>>
104053>>>>>
104053>>>>>            Forward Send Activating
104055>>>>>
104055>>>>>            Get phoDataSource to hoDataSource
104056>>>>>            Send InitializeData of hoDataSource MyData
104057>>>>>            Send Cursor_Ready of Cursor_Control
104058>>>>>        End_Procedure
104059>>>>>
104059>>>>>    End_Object
104060>>>>>
104060>>>>>    Object oOK_Btn is a Button
104062>>>>>        Set Label    to "&OK"
104063>>>>>        Set Location to 130 165
104064>>>>>        Set peAnchors To anBottomRight
104065>>>>>
104065>>>>>        Procedure OnClick
104068>>>>>            Send Ok of oSelList
104069>>>>>        End_Procedure
104070>>>>>
104070>>>>>    End_Object
104071>>>>>
104071>>>>>    Object oCancel_Btn is a Button
104073>>>>>        Set Label    to "&Cancel"
104074>>>>>        Set Location to 130 220
104075>>>>>        Set peAnchors to anBottomRight
104076>>>>>
104076>>>>>        Procedure OnClick
104079>>>>>            Send Close_Panel
104080>>>>>        End_Procedure
104081>>>>>
104081>>>>>    End_Object
104082>>>>>
104082>>>>>    Procedure Page Integer iPageObject
104085>>>>>        Set Icon to "ServerLookup.ico"
104086>>>>>        Forward Send Page iPageObject
104088>>>>>    End_Procedure
104089>>>>>
104089>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
104090>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
104091>>>>>End_Object
104092>>>Use SQLConnections.dg
Including file: SQLConnections.dg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\SQLConnections.dg)
104092>>>>>Use Windows.pkg
104092>>>>>Use cCJGridPromptList.pkg
104092>>>>>Use cDbUpdateFunctionLibrary.pkg
104092>>>>>Use MSSqldrv.pkg
104092>>>>>Use db2_drv.pkg
104092>>>>>Use odbc_drv.pkg
104092>>>>>
104092>>>>>Object oSQLConnections is a ModalPanel
104094>>>>>    Set Label to "SQL Connections"
104095>>>>>    Set Size to 121 185
104096>>>>>    Set piMinSize to 89 185
104097>>>>>    Set Location to 2 2
104098>>>>>    Set Border_Style to Border_Thick
104099>>>>>
104099>>>>>    Property String[] psTheData
104101>>>>>
104101>>>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
104103>>>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
104105>>>>>        End_Object
104106>>>>>    End
104106>>>>>>
104106>>>>>
104106>>>>>    Object oSelListSQLConnections is a cCJGridPromptList
104108>>>>>        Set Size to 90 167
104109>>>>>        Set Location to 6 6
104110>>>>>        Set peAnchors to anAll
104111>>>>>        Set pbAllowColumnRemove to False
104112>>>>>        Set pbUseAlternateRowBackgroundColor to True
104113>>>>>        Set pbGrayIfDisable to False
104114>>>>>        Set pbHeaderReorders to False
104115>>>>>        Set pbHeaderSelectsColumn to False
104116>>>>>        Set pbHeaderTogglesDirection to False
104117>>>>>        Set pbShadeSortColumn to False
104118>>>>>        Set piFocusCellBackColor to clDkGray
104119>>>>>
104119>>>>>        Object oName is a cCJGridColumn
104121>>>>>            Set piWidth to 223
104122>>>>>            Set psCaption to "SQL Connection"
104123>>>>>        End_Object
104124>>>>>
104124>>>>>        Object oDriverID is a cCJGridColumn
104126>>>>>            Set piWidth to 111
104127>>>>>            Set psCaption to "Driver ID"
104128>>>>>        End_Object
104129>>>>>
104129>>>>>        Procedure Activating
104132>>>>>            tDataSourceRow[] MyData
104132>>>>>            tDataSourceRow[] MyData
104133>>>>>            Handle hoDataSource
104133>>>>>            String[] sTheData
104134>>>>>            Integer iCount iSize iPos
104134>>>>>            String sDriverID sConnectionID sValue
104134>>>>>
104134>>>>>            Send Cursor_Wait of Cursor_Control
104135>>>>>            Forward Send Activating
104137>>>>>
104137>>>>>            Get psTheData to sTheData
104138>>>>>            Move (SizeOfArray(sTheData)) to iSize
104139>>>>>            Decrement iSize
104140>>>>>            For iCount from 0 to iSize
104146>>>>>>
104146>>>>>                Move sTheData[iCount] to sValue
104147>>>>>                Move (Pos("|", sValue)) to iPos
104148>>>>>                Move (Left(sValue, (iPos -1)))     to sConnectionID
104149>>>>>                Move (Mid(sValue, 999, (iPos +1))) to sDriverID
104150>>>>>                Move sConnectionID to MyData[iCount].sValue[0]
104151>>>>>                Move sDriverID     to MyData[iCount].sValue[1]
104152>>>>>            Loop
104153>>>>>>
104153>>>>>
104153>>>>>            Get phoDataSource to hoDataSource
104154>>>>>            Send InitializeData of hoDataSource MyData
104155>>>>>            Send Cursor_Ready of Cursor_Control
104156>>>>>        End_Procedure
104157>>>>>
104157>>>>>    End_Object
104158>>>>>
104158>>>>>    Object oOK_Btn is a Button
104160>>>>>        Set Label    to "&OK"
104161>>>>>        Set Location to 101 68
104162>>>>>        Set peAnchors to anBottomRight
104163>>>>>
104163>>>>>        Procedure OnClick
104166>>>>>            Send Ok of oSelListSQLConnections
104167>>>>>        End_Procedure
104168>>>>>
104168>>>>>    End_Object
104169>>>>>
104169>>>>>    Object oCancel_Btn is a Button
104171>>>>>        Set Label    to "&Cancel"
104172>>>>>        Set Location to 101 123
104173>>>>>        Set peAnchors to anBottomRight
104174>>>>>
104174>>>>>        Procedure OnClick
104177>>>>>            Send Close_Panel
104178>>>>>        End_Procedure
104179>>>>>
104179>>>>>    End_Object
104180>>>>>
104180>>>>>    Procedure Page Integer iPageObject
104183>>>>>        Set Icon to "SQLConnections.ico"
104184>>>>>        Forward Send Page iPageObject
104186>>>>>    End_Procedure
104187>>>>>
104187>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
104188>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
104189>>>>>End_Object
104190>>>
104190>>>Activate_View Activate_oSQLConnections_vw for oSQLConnections_vw
104200>>>>
104200>>>Object oSQLConnections_vw is a dbView
104202>>>    Set Border_Style to Border_Thick
104203>>>    Set Size to 251 427
104204>>>    Set Location to 2 2
104205>>>    Set Label to "SQL Connections"
104206>>>    Set pbAutoActivate to True
104207>>>    Set Icon to "SQLConnections.ico"
104208>>>
104208>>>    Object oScrollingContainer1 is a cDbScrollingContainer
104210>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
104212>>>
104212>>>            Object oCurrentSettings_grp is a Group
104214>>>                Set Size to 232 402
104215>>>                Set Location to 6 12
104216>>>                Set Label to "Current Connection Settings"
104217>>>                Set peAnchors to anAll
104218>>>
104218>>>                Object oConnectionID_fm is a Form
104220>>>                    Set Size to 13 100
104221>>>                    Set Location to 12 68
104222>>>                    Set Label to "Connection ID"
104223>>>                    Set Label_Col_Offset to 2
104224>>>                    Set Label_Justification_Mode to JMode_Right
104225>>>                    Set Prompt_Button_Mode to PB_PromptOn
104226>>>                    Set Prompt_Object to (oSQLConnections(Self))
104227>>>
104227>>>                    Procedure Prompt
104230>>>                        String[] sTheData
104231>>>                        String sCurrentVal sNewVal
104231>>>                        Handle hoIniFile ho
104231>>>                        Integer iSize iCount
104231>>>                        tSQLConnection[] SQLConnectionArray
104231>>>                        tSQLConnection[] SQLConnectionArray
104232>>>
104232>>>                        Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to hoIniFile
104233>>>                        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
104234>>>                        Move (SizeOfArray(SQLConnectionArray)) to iSize
104235>>>                        Decrement iSize
104236>>>                        For iCount from 0 to iSize
104242>>>>
104242>>>                            Move (SQLConnectionArray[iCount].sConnectionID + "|" + SQLConnectionArray[iCount].sDriverID) to sTheData[iCount]
104243>>>                        Loop
104244>>>>
104244>>>
104244>>>                        Get Value to sCurrentVal
104245>>>                        Get Prompt_Object to ho
104246>>>                        Set psTheData     of ho to sTheData
104247>>>
104247>>>                        Forward Send Prompt
104249>>>                        Get Value to sNewVal
104250>>>                        If (sCurrentVal <> sNewVal) Begin
104252>>>                            Send Cursor_Wait of Cursor_Control
104253>>>                            Set psConnectionID of ghoSQLConnectionHandler to sNewVal
104254>>>                            Broadcast Recursive Send Refresh of (phoMainPanel(ghoApplication))
104256>>>                            Send Cursor_Ready of Cursor_Control
104257>>>                            Send KeyAction of oTestLogin_btn
104258>>>                        End
104258>>>>
104258>>>                    End_Procedure
104259>>>
104259>>>                    Procedure Refresh
104262>>>                        String sValue
104262>>>                        Get psConnectionID of ghoSQLConnectionHandler to sValue
104263>>>                        Set Value to sValue
104264>>>                    End_Procedure
104265>>>
104265>>>                End_Object
104266>>>
104266>>>                Object oDatabase_fm is a Form
104268>>>                    Set Size to 13 91
104269>>>                    Set Location to 27 222
104270>>>                    Set Label to "Database"
104271>>>                    Set Label_Col_Offset to 2
104272>>>                    Set Label_Justification_Mode to JMode_Right
104273>>>                    Set Prompt_Button_Mode to PB_PromptOn
104274>>>                    Set Prompt_Object to (oDatabaseSelection_sl(Self))
104275>>>                    Set peAnchors to anNone
104276>>>                    Set Entry_State to False
104277>>>
104277>>>                    Procedure Refresh
104280>>>                        String sDatabase
104280>>>
104280>>>                        Get psDatabase of ghoSQLConnectionHandler to sDatabase
104281>>>                        Set Value to sDatabase
104282>>>                    End_Procedure
104283>>>
104283>>>                    Procedure Prompt
104286>>>                        String[] sTheData
104287>>>                        Handle ho
104287>>>                        String sDriverID
104287>>>
104287>>>                        Get Value of oDriverID_cf to sDriverID
104288>>>                        Get SqlUtilEnumerateDatabases of ghoDbUpdateFunctionLibrary sDriverID to sTheData
104289>>>
104289>>>                        Get Prompt_Object to ho
104290>>>                        Set psTheData of ho to sTheData
104291>>>
104291>>>                        Forward Send Prompt
104293>>>                    End_Procedure
104294>>>
104294>>>                    Procedure OnChange
104297>>>                        String sValue sOrgValue
104297>>>                        Get Value to sValue
104298>>>                        Get psDatabase of ghoSQLConnectionHandler to sOrgValue
104299>>>                        If (Uppercase(Trim(sValue)) <> Uppercase(Trim(sOrgValue))) Begin
104301>>>                            Set psDatabase of ghoSQLConnectionHandler to sValue
104302>>>                            Get psConnectionString of ghoSQLConnectionHandler to sValue
104303>>>                            Set Value of oConnectionString_fm to sValue
104304>>>                        End
104304>>>>
104304>>>                    End_Procedure
104305>>>
104305>>>                End_Object
104306>>>
104306>>>                Object oTrusted_cb is a CheckBox
104308>>>                    Set Size to 10 50
104309>>>                    Set Location to 45 68
104310>>>                    Set Label to "Use Trusted Connection"
104311>>>
104311>>>                    Procedure Refresh
104314>>>                        Boolean bValue
104314>>>                        Get pbTrusted of ghoSQLConnectionHandler to bValue
104315>>>                        Set Checked_State to bValue
104316>>>                    End_Procedure
104317>>>
104317>>>                    Procedure OnChange
104320>>>                        Boolean bChecked
104320>>>
104320>>>                        Get Checked_State to bChecked
104321>>>                        Set Enabled_State of oUserID_fm   to (bChecked = False)
104322>>>                        Set Enabled_State of oPassword_fm to (bChecked = False)
104323>>>                    End_Procedure
104324>>>
104324>>>                End_Object
104325>>>
104325>>>                Object oUserID_fm is a Form
104327>>>                    Set Size to 13 100
104328>>>                    Set Location to 57 68
104329>>>                    Set Label to "UserID"
104330>>>                    Set Label_Col_Offset to 2
104331>>>                    Set Label_Justification_Mode to JMode_Right
104332>>>
104332>>>                    Procedure Refresh
104335>>>                        String sValue
104335>>>                        Get psUserID of ghoSQLConnectionHandler to sValue
104336>>>                        Set Value to sValue
104337>>>                    End_Procedure
104338>>>
104338>>>                End_Object
104339>>>
104339>>>                Object oPassword_fm is a Form
104341>>>                    Set Size to 13 91
104342>>>                    Set Location to 57 222
104343>>>                    Set Label to "Password"
104344>>>                    Set Label_Col_Offset to 2
104345>>>                    Set Label_Justification_Mode to JMode_Right
104346>>>                    // Set psToolTip to "Note: The password form does _not_ have it's password state set to True because the view is for testing purposes only. And we can see the password - if set - from the connection string as well."
104346>>>                    Set psToolTip to "Press the 'Toggle Password' button to reveal the password"
104347>>>                    Set Password_State to True
104348>>>
104348>>>                    Procedure Refresh
104351>>>                        String sValue
104351>>>                        Get psPassword of ghoSQLConnectionHandler to sValue
104352>>>                        Set Value to sValue
104353>>>                    End_Procedure
104354>>>
104354>>>                End_Object
104355>>>
104355>>>                Object oViewPassword_btn is a cButtonDPI
104357>>>                    Set Size to 13 19
104358>>>                    Set Location to 57 317
104359>>>                    Set psToolTip to "Toggle password"
104360>>>
104360>>>                    Property String psImageL "PasswordView.ico"
104362>>>                    Property String psImageU "PasswordViewUnlock.ico"
104364>>>                    Set psImage to (psImageL(Self))
104365>>>                    Set piImageMarginLeft to 4
104366>>>
104366>>>                    Procedure OnClick
104369>>>                        Boolean bState
104369>>>                        Get Password_State of oPassword_fm item 0 to bState
104370>>>                        Send Page_Object   of oPassword_fm False
104371>>>                        Set Password_State of oPassword_fm item 0 to (not(bState))
104372>>>                        Send Page_Object   of oPassword_fm True
104373>>>                        Set psImage to (If(bState = False, psImageL(Self), psImageU(Self)))
104374>>>                    End_Procedure
104375>>>
104375>>>                End_Object
104376>>>
104376>>>                Object oConnectionString_fm is a Form
104378>>>                    Set Size to 13 328
104379>>>                    Set Location to 82 68
104380>>>                    Set Label to "Connection String"
104381>>>                    Set Label_Col_Offset to 2
104382>>>                    Set Label_Justification_Mode to JMode_Right
104383>>>                    Set peAnchors to anTopLeftRight
104384>>>                    Set Enabled_State to False
104385>>>
104385>>>                    Procedure Refresh
104388>>>                        String sValue
104388>>>                        tSQLConnection SQLConnection
104388>>>                        tSQLConnection SQLConnection
104388>>>
104388>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
104389>>>                        Move (Replace(("PWD=" + SQLConnection.sPassword), SQLConnection.sConnectionString, "PWD=***")) to sValue
104390>>>                        Set Value to sValue
104391>>>                    End_Procedure
104392>>>
104392>>>                End_Object
104393>>>
104393>>>                Object oTestLogin_btn is a cButtonDPI
104395>>>                    Set Size to 13 51
104396>>>                    Set Location to 57 340
104397>>>                    Set Label to "Test Login"
104398>>>                    Set peAnchors to anNone
104399>>>                    Set MultiLineState to True
104400>>>                    Set psToolTip to "Changes the connection string with any changes made and tries to login to the server with the connection string."
104401>>>                    Set FontWeight to fw_Bold
104402>>>                    Set psImage to "ActionLoginBlack.ico"
104403>>>                    Set piImageMarginLeft to 4
104404>>>
104404>>>                    Procedure OnClick
104407>>>                        tSQLConnection SQLConnection
104407>>>                        tSQLConnection SQLConnection
104407>>>                        String sServer sDatabase sDriverID sUserID sPassword sConnectionID sConnectionString
104407>>>                        Boolean bTrusted bMertechDriver bLoginSuccessful
104407>>>                        Integer iDriverID
104407>>>                        Handle hoDriver
104407>>>
104407>>>                        Get Value of oDriverID_cf        to SQLConnection.sDriverID
104408>>>                        Get Value of oConnectionID_fm    to SQLConnection.sConnectionID
104409>>>                        Get Value of oServer_fm          to SQLConnection.sServer
104410>>>                        Get Value of oDatabase_fm        to SQLConnection.sDatabase
104411>>>                        Get Checked_State of oTrusted_cb to SQLConnection.bTrusted
104412>>>                        Get Value of oUserID_fm          to SQLConnection.sUserID
104413>>>                        Get Value of oPassword_fm        to SQLConnection.sPassword
104414>>>
104414>>>                        Get ConstructConnectionString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
104415>>>
104415>>>                        Get DriverIndex of ghoSQLConnectionHandler SQLConnection.sDriverID to iDriverID
104416>>>                        If (iDriverID = 0) Begin
104418>>>                            Send Info_Box ("The driver" * SQLConnection.sDriverID * "could not be loaded. Is the driver installed? And equally imporant; Is the corresponding database server or client software installed?")
104419>>>                            Procedure_Return
104420>>>                        End
104420>>>>
104420>>>
104420>>>                        Get IsMertechDriver of ghoSQLConnectionHandler SQLConnection.sDriverID to bMertechDriver
104421>>>                        If (bMertechDriver = False) Begin
104423>>>                            Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to True
104426>>>                        End
104426>>>>
104426>>>
104426>>>                        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
104427>>>                        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
104428>>>                        Set psDriverID of hoDriver to SQLConnection.sDriverID
104429>>>                        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bLoginSuccessful
104430>>>                        Send Destroy   of hoDriver
104431>>>
104431>>>                        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
104432>>>                        If (LastErr <> CLIERR_LOGIN_UNSUCCESSFUL) Begin
104434>>>                            Move (Replace(("PWD=" + SQLConnection.sPassword), sConnectionString, "PWD=***")) to sConnectionString
104435>>>                            Set Value of oConnectionString_fm to sConnectionString
104436>>>                            Send Info_Box "Login Successful!"
104437>>>                        End
104437>>>>
104437>>>                        Else Begin
104438>>>                            Send Info_Box "Nope, that didn't work. Login failed."
104439>>>                        End
104439>>>>
104439>>>                        Broadcast Recursive Send Combo_Fill_List of (Client_Id(phoMainPanel(ghoApplication)))
104441>>>                        Move 0 to LastErr
104442>>>                    End_Procedure
104443>>>
104443>>>                End_Object
104444>>>
104444>>>                Object oInfo_tb is a TextBox
104446>>>                    Set Auto_Size_State to False
104447>>>                    Set Size to 18 303
104448>>>                    Set Location to 106 8
104449>>>                    Set Label to "Note: The above settings was read from the SQLConnections.ini file when the object was created and are properties of the 'ghoSQLConnectionHandler' object."
104450>>>                    Set Justification_Mode to JMode_Left
104451>>>                    Set FontItalics to True
104452>>>                End_Object
104453>>>
104453>>>                Object oDriverID_cf is a ComboForm
104455>>>                    Set Size to 11 91
104456>>>                    Set Location to 13 222
104457>>>                    Set Label_Col_Offset to 2
104458>>>                    Set Label_Justification_Mode to JMode_Right
104459>>>                    Set Label to "Driver ID"
104460>>>                    Set Entry_State to False
104461>>>                    Set Enabled_State to False
104462>>>
104462>>>                    Procedure Combo_Fill_List
104465>>>                        Send Combo_Add_Item MSSQLDRV_ID
104466>>>                        Send Combo_Add_Item DB2_DRV_ID
104467>>>                        Send Combo_Add_Item ODBC_DRV_ID
104468>>>                        Send Combo_Add_Item SQLFLEX
104469>>>                        Send Combo_Add_Item MDSDB2
104470>>>                        Send Combo_Add_Item MDSMySQL
104471>>>                        Send Combo_Add_Item MDSPgSQL
104472>>>                        Send Combo_Add_Item ORAFLEX
104473>>>                    End_Procedure
104474>>>
104474>>>                    Procedure OnChange
104477>>>                        String sValue sOrgValue
104477>>>                        Boolean bEnabled bChecked
104477>>>
104477>>>                        Get Value to sValue
104478>>>                        Get psDriverID of ghoSQLConnectionHandler to sOrgValue
104479>>>                        If (sValue <> "" and sValue <> sOrgValue and sValue <> "None") Begin
104481>>>                            Set psDriverID of ghoSQLConnectionHandler to sValue
104482>>>                        End
104482>>>>
104482>>>                        Move (sValue <> "None") to bEnabled
104483>>>                        Broadcast Set Enabled_State of (Parent(Self)) to bEnabled
104485>>>                        Set Enabled_State to False
104486>>>                        Set Enabled_State of oConnectionString_fm to False
104487>>>                        Set Enabled_State of oDatabase_fm to (sValue <> DB2_DRV_ID)
104488>>>
104488>>>                        Get Checked_State of oTrusted_cb  to bChecked
104489>>>                        Set Enabled_State of oUserID_fm   to (bChecked = False)
104490>>>                        Set Enabled_State of oPassword_fm to (bChecked = False)
104491>>>                    End_Procedure
104492>>>
104492>>>                    Procedure Refresh
104495>>>                        String sValue
104495>>>
104495>>>                        Get psDriverID of ghoSQLConnectionHandler to sValue
104496>>>                        Set Value to sValue
104497>>>                    End_Procedure
104498>>>
104498>>>                End_Object
104499>>>
104499>>>                Object oServer_fm is a Form
104501>>>                    Set Size to 13 100
104502>>>                    Set Location to 27 68
104503>>>                    Set Label to "Server"
104504>>>                    Set Label_Col_Offset to 2
104505>>>                    Set Label_Justification_Mode to JMode_Right
104506>>>                    Set Prompt_Button_Mode to PB_PromptOn
104507>>>                    Set Prompt_Object to (oServerSelection_sl(Self))
104508>>>
104508>>>                    Procedure Refresh
104511>>>                        String sValue
104511>>>                        Get psServer of ghoSQLConnectionHandler to sValue
104512>>>                        Set Value to sValue
104513>>>                    End_Procedure
104514>>>
104514>>>                    Procedure Prompt
104517>>>                        String[] sTheData
104518>>>                        String sDriverID
104518>>>                        Handle ho
104518>>>
104518>>>                        Send Cursor_Wait of Cursor_Control
104519>>>                        Get Prompt_Object to ho
104520>>>                        Get Value of oDriverID_cf to sDriverID
104521>>>                        Get SqlUtilEnumerateServers of ghoDbUpdateFunctionLibrary sDriverID 2 to sTheData
104522>>>                        Set psTheData of ho to sTheData
104523>>>                        Send Cursor_Ready of Cursor_Control
104524>>>
104524>>>                        Forward Send Prompt
104526>>>                    End_Procedure
104527>>>
104527>>>                End_Object
104528>>>
104528>>>                Object oRunSQLConnectionsProgram_btn is a cButtonDPI
104530>>>                    Set Size to 21 81
104531>>>                    Set Location to 106 317
104532>>>                    Set Label to "SQL Connections"
104533>>>                    Set peAnchors to anNone
104534>>>                    Set MultiLineState to True
104535>>>                    Set psImage to "SQLConnections.ico"
104536>>>
104536>>>                    Procedure OnClick
104539>>>                        Runprogram Background "SQLConnections.exe"
104540>>>                    End_Procedure
104541>>>
104541>>>                End_Object
104542>>>
104542>>>                Object oGetCollation_btn is a Button
104544>>>                    Set Size to 27 91
104545>>>                    Set Location to 154 38
104546>>>                    Set Label to 'Get Database Collation'
104547>>>                
104547>>>                    Procedure OnClick
104550>>>                        String sCollation sDatabase
104550>>>                        Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase 
104551>>>                        Get SqlDatabaseCollationQuery of ghoDbUpdateFunctionLibrary sDatabase to sCollation 
104552>>>                        Set Value of oGetCollation_fm to sCollation
104553>>>                    End_Procedure
104554>>>                
104554>>>                End_Object
104555>>>
104555>>>                Object oGetCollation_fm is a Form
104557>>>                    Set Size to 13 148
104558>>>                    Set Location to 162 143
104559>>>                    Set Label to "Current SQL Collation Name"
104560>>>                    Set Label_Col_Offset to 0
104561>>>                    Set Label_Row_Offset to 1
104562>>>                    Set Label_Justification_Mode to JMode_Top
104563>>>                End_Object
104564>>>        
104564>>>                Object oSetCollation_btn is a Button
104566>>>                    Set Size to 27 91
104567>>>                    Set Location to 188 38
104568>>>                    Set Label to "Set Database Collation"
104569>>>                
104569>>>                    Procedure OnClick
104572>>>                        String sCollation sDatabase sErrorText
104572>>>                        Boolean bOK
104572>>>                        Integer iRetval  
104572>>>                        tSqlErrorArray aSqlErrorArray
104572>>>                        tSqlErrorArray aSqlErrorArray
104572>>>                        
104572>>>                        Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase  
104573>>>                        Get Value of oSetCollation_fm to sCollation
104574>>>                        Get YesNo_Box ("This will permanently change SQL collation for the selected database:" * String(sDatabase) * "Are you sure you want to do this?") to iRetval
104575>>>                        If (iRetval <> MBR_Yes) Begin
104577>>>                            Procedure_Return
104578>>>                        End
104578>>>>
104578>>>                        Get SqlDatabaseCollationChange of ghoDbUpdateFunctionLibrary sDatabase sCollation to bOK
104579>>>                        If (bOK = True) Begin
104581>>>                            Send Info_Box ("Changing the collation for database:" * String(sDatabase) * "was successful.")
104582>>>                        End
104582>>>>
104582>>>                        Else Begin                   
104583>>>                            Get paSqlErrorArray of ghoDbUpdateFunctionLibrary to aSqlErrorArray
104584>>>                            Move ("Embedded SQL Statement:" * String(aSqlErrorArray.sSqlStatementArray[0])) to sErrorText
104585>>>                            Move (sErrorText + "\n")                  to sErrorText
104586>>>                            Move (sErrorText + "\n" + "SQL Error:" * String(aSqlErrorArray.sSqlErrorArray[0])) to sErrorText
104587>>>                            Send Info_Box ("Changing the collation for database:" * String(sDatabase) * "failed." + "\n" + sErrorText)
104588>>>                        End
104588>>>>
104588>>>
104588>>>                    End_Procedure
104589>>>                
104589>>>                End_Object
104590>>>
104590>>>                Object oSetCollation_fm is a Form
104592>>>                    Set Size to 13 148
104593>>>                    Set Location to 197 143
104594>>>                    Set Label to "New SQL Collation Name"
104595>>>                    Set Label_Col_Offset to 0
104596>>>                    Set Label_Row_Offset to 1
104597>>>                    Set Label_Justification_Mode to JMode_Top
104598>>>                End_Object
104599>>>
104599>>>                Procedure Page Integer iPageObject
104602>>>                    Broadcast Recursive Send Refresh of (phoMainPanel(ghoApplication))
104604>>>                    Forward Send Page iPageObject
104606>>>                End_Procedure
104607>>>
104607>>>            End_Object
104608>>>
104608>>>        End_Object
104609>>>        
104609>>>    End_Object
104610>>>
104610>>>End_Object
104611>        Use SQLFunctions.vw
Including file: SQLFunctions.vw    (C:\Projects\DF18\DbUpdateFramework\AppSrc\SQLFunctions.vw)
104611>>>Use Windows.pkg
104611>>>Use DFClient.pkg
104611>>>Use Dfspnfrm.pkg
104611>>>Use cDbScrollingContainer.pkg
104611>>>Use cButtonDPI.pkg
104611>>>Use cDbUpdateFunctionLibrary.pkg
104611>>>Use SQLDatabaseBackup.dg
104611>>>
104611>>>Activate_View Activate_oSQLFunctions_vw for oSQLFunctions_vw
104621>>>>
104621>>>Object oSQLFunctions_vw is a dbView
104623>>>    Set Border_Style to Border_Thick
104624>>>    Set Size to 260 426
104625>>>    Set Location to -4 2
104626>>>    Set Label to "Functions"
104627>>>    Set pbAutoActivate to True
104628>>>    Set Icon to "SqlBlack.ico"
104629>>>
104629>>>    Procedure OnSetFocus
104632>>>        String sValue
104632>>>        tSQLConnection SQLConnection
104632>>>        tSQLConnection SQLConnection
104632>>>
104632>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
104633>>>        Set Value of oSQLDatabase_fm to SQLConnection.sDatabase
104634>>>        Move (Replace(("PWD=" + SQLConnection.sPassword), SQLConnection.sConnectionString, "PWD=***")) to sValue
104635>>>        Set Value of oSQLConnectionString_fm to sValue
104636>>>    End_Procedure
104637>>>
104637>>>    Object oScrollingContainer1 is a cDbScrollingContainer
104639>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
104641>>>
104641>>>            Object oSQLFunctionTests_grp is a Group
104643>>>                Set Size to 243 402
104644>>>                Set Location to 7 12
104645>>>                Set Label to "Tests: Change SQL Database with Specialized SQL Functions"
104646>>>                Set peAnchors to anAll
104647>>>
104647>>>                Object oSQLConnectionString_fm is a Form
104649>>>                    Set Size to 13 375
104650>>>                    Set Location to 23 14
104651>>>                    Set Label to "Current Connection String Settings:"
104652>>>                    Set Label_Col_Offset to 0
104653>>>                    Set Label_Justification_Mode to JMode_Top
104654>>>                    Set peAnchors to anTopLeftRight
104655>>>                    Set Enabled_State to False
104656>>>                    Set Label_Row_Offset to 1
104657>>>                End_Object
104658>>>
104658>>>                Object oSQLDatabase_fm is a Form
104660>>>                    Set Size to 13 86
104661>>>                    Set Location to 50 14
104662>>>                    Set Label to "Database:"
104663>>>                    Set Label_Col_Offset to 0
104664>>>                    Set Label_Justification_Mode to JMode_Top
104665>>>                    Set Label_Row_Offset to 1
104666>>>                    Set FontWeight to fw_Bold
104667>>>                    Set Enabled_State to False
104668>>>                End_Object
104669>>>
104669>>>                Object oDriverID2_cf is a ComboForm
104671>>>                    Set Size to 11 91
104672>>>                    Set Location to 50 121
104673>>>                    Set Label_Col_Offset to 0
104674>>>                    Set Label_Justification_Mode to JMode_Top
104675>>>                    Set Label to "Driver ID:"
104676>>>                    Set Entry_State to False
104677>>>                    Set Enabled_State to False
104678>>>                    Set Label_Row_Offset to 1
104679>>>
104679>>>                    Procedure Combo_Fill_List
104682>>>                        Send Combo_Add_Item MSSQLDRV_ID
104683>>>                        Send Combo_Add_Item DB2_DRV_ID
104684>>>                        Send Combo_Add_Item ODBC_DRV_ID
104685>>>                        Send Combo_Add_Item SQLFLEX
104686>>>                        Send Combo_Add_Item MDSDB2
104687>>>                        Send Combo_Add_Item MDSMySQL
104688>>>                        Send Combo_Add_Item MDSPgSQL
104689>>>                        Send Combo_Add_Item ORAFLEX
104690>>>                    End_Procedure
104691>>>
104691>>>                    Procedure Refresh
104694>>>                        String sValue
104694>>>
104694>>>                        Get psDriverID of ghoSQLConnectionHandler to sValue
104695>>>                        Set Value to sValue
104696>>>                    End_Procedure
104697>>>
104697>>>                End_Object
104698>>>
104698>>>                Object oBackupSQLDatabase_btn is a cButtonDPI
104700>>>                    Set Size to 14 109
104701>>>                    Set Location to 49 220
104702>>>                    Set Label to "Backup MS-SQL Database"
104703>>>                    Set psImage to "DdBackup.ico"
104704>>>
104704>>>                    Procedure OnClick
104707>>>                        Boolean bOK
104707>>>
104707>>>                        // SQLDatabaseBackup dialog:
104707>>>                        Get MakeSQLDatabaseBackup to bOK
104708>>>
104708>>>                        If (bOK = True) Begin
104710>>>                            Send Info_Box "The backup of the database was successful!"
104711>>>                        End
104711>>>>
104711>>>                        Else Begin
104712>>>                            Send Info_Box "The database was not backup up"
104713>>>                        End
104713>>>>
104713>>>                    End_Procedure
104714>>>
104714>>>                End_Object
104715>>>
104715>>>                Object oDatabaseInfo_tb is a TextBox
104717>>>                    Set Auto_Size_State to False
104718>>>                    Set Size to 25 96
104719>>>                    Set Location to 64 14
104720>>>                    Set Label to "(Change database on the SQL Connections tabpage)"
104721>>>                    Set Justification_Mode to JMode_Left
104722>>>                End_Object
104723>>>
104723>>>                Object oSQLInfo_tb is a TextBox
104725>>>                    Set Auto_Size_State to False
104726>>>                    Set Size to 37 270
104727>>>                    Set Location to 76 118
104728>>>                    Set Label to "Note: The DataFlex database API is NOT used here. Instead all is done with specialized embedded SQL (ESQL) funtions from the cDbUpdateFunctionLibrary. This is because an API 'Structure_End' command could drop and rebuild the whole table (!). That can take a long time..."
104729>>>                    Set Justification_Mode to JMode_Left
104730>>>                End_Object
104731>>>
104731>>>                Object oSQLTableName_cf is a ComboForm
104733>>>                    Set Size to 11 96
104734>>>                    Set Location to 106 14
104735>>>                    Set Label_Col_Offset to 0
104736>>>                    Set Label_Justification_Mode to JMode_Top
104737>>>                    Set Label to "Select Table:"
104738>>>                    Set Label_Row_Offset to 1
104739>>>                    Set Entry_State to False
104740>>>
104740>>>                    Procedure OnDropDown
104743>>>                        Send DoCombo_Fill_List
104744>>>                    End_Procedure
104745>>>
104745>>>                    Procedure OnCloseUp
104748>>>                        Send Delete_Data of oSQLColumnName_cf
104749>>>                    End_Procedure
104750>>>
104750>>>                    Procedure DoCombo_Fill_List
104753>>>                        String[] sTablesArray
104754>>>                        String sDriverID
104754>>>                        Integer iCount iSize
104754>>>
104754>>>                        Send Delete_Data
104755>>>                        Get Value of oDriverID2_cf to sDriverID
104756>>>                        Get SQLUtilEnumerateTables of ghoDbUpdateFunctionLibrary sDriverID to sTablesArray
104757>>>                        Move (SizeOfArray(sTablesArray)) to iSize
104758>>>                        Decrement iSize
104759>>>                        For iCount from 0 to iSize
104765>>>>
104765>>>                            Send Combo_Add_Item sTablesArray[iCount]
104766>>>                        Loop
104767>>>>
104767>>>                    End_Procedure
104768>>>
104768>>>                    // DataFlex bug. It has been here as long as I can remember and _never_ seems to be fixed :-(
104768>>>                    // Augmented Value function.
104768>>>                    // We need to use Wincombo_x messages. Probably due to sync reasons.
104768>>>                    // When e.g. OnCloseUp is fired the data_value still holds the old value.
104768>>>                    Function Value Integer iItem Returns String
104771>>>                        String sValue
104771>>>                        Get WinCombo_Current_Item      to iItem
104772>>>                        Get WinCombo_Value item iItem  to sValue
104773>>>                        Function_Return sValue
104774>>>                    End_Function
104775>>>
104775>>>                End_Object
104776>>>
104776>>>                Object oSQLColumnName_cf is a ComboForm
104778>>>                    Set Size to 11 96
104779>>>                    Set Location to 134 14
104780>>>                    Set Label_Col_Offset to 0
104781>>>                    Set Label_Justification_Mode to JMode_Top
104782>>>                    Set Label to "Select Column:"
104783>>>                    Set Label_Row_Offset to 1
104784>>>                    Set Entry_State to False
104785>>>
104785>>>                    Procedure DoCombo_Fill_List
104788>>>                        String[] sColumnsArray
104789>>>                        String sTableName sDriverID
104789>>>                        Integer iCount iSize
104789>>>
104789>>>                        Send Delete_Data
104790>>>                        Get Value of oDriverID2_cf    to sDriverID
104791>>>                        Get Value of oSQLTableName_cf to sTableName
104792>>>                        Get SQLUtilEnumerateColumns of ghoDbUpdateFunctionLibrary sDriverID sTableName to sColumnsArray
104793>>>                        Move (SizeOfArray(sColumnsArray)) to iSize
104794>>>                        Decrement iSize
104795>>>                        For iCount from 0 to iSize
104801>>>>
104801>>>                            Send Combo_Add_Item sColumnsArray[iCount]
104802>>>                        Loop
104803>>>>
104803>>>                        If (iSize > 1) Begin
104805>>>                            Set Current_Item to 1
104806>>>                        End
104806>>>>
104806>>>                    End_Procedure
104807>>>
104807>>>                    Procedure OnDropDown
104810>>>                        Send DoCombo_Fill_List
104811>>>                    End_Procedure
104812>>>                End_Object
104813>>>
104813>>>                Object oSQLRenameColumnTo_fm is a Form
104815>>>                    Set Size to 13 96
104816>>>                    Set Location to 133 116
104817>>>                    Set Label_Col_Offset to 0
104818>>>                    Set Label_Justification_Mode to JMode_Top
104819>>>                    Set Label to "Rename Column To:"
104820>>>                    Set Label_Row_Offset to 1
104821>>>                    Set Value to "NewColumnName"
104822>>>                End_Object
104823>>>
104823>>>                Object oSQLRenameColumn_btn is a cButtonDPI
104825>>>                    Set Size to 13 69
104826>>>                    Set Location to 133 220
104827>>>                    Set Label to "Rename Column"
104828>>>                    Set psToolTip to "Test of SQLColumnRename function"
104829>>>                    Set MultiLineState to True
104830>>>
104830>>>                    Procedure OnClick
104833>>>                        Boolean bOk
104833>>>                        Handle hTable
104833>>>                        String sTableName sColumnName sNewColumnName sDriverID
104833>>>
104833>>>                        Get Value of oSQLTableName_cf to sTableName
104834>>>                        If (sTableName = "") Begin
104836>>>                            Send Info_Box "You need to select a table first..."
104837>>>                            Procedure_Return
104838>>>                        End
104838>>>>
104838>>>                        Get Value of oSQLColumnName_cf to sColumnName
104839>>>                        If (Uppercase(sColumnName) = "RECNUM" or sColumnName = "") Begin
104841>>>                            Send Info_Box "You need to select a column (and 'RECNUM' cannot be used)"
104842>>>                            Procedure_Return
104843>>>                        End
104843>>>>
104843>>>                        Get Value of oSQLRenameColumnTo_fm to sNewColumnName
104844>>>                        If (Trim(sNewColumnName) = "") Begin
104846>>>                            Send Info_Box "You need to enter a column name to rename to..."
104847>>>                            Procedure_Return
104848>>>                        End
104848>>>>
104848>>>
104848>>>                        Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
104849>>>                        If (hTable = 0) Begin
104851>>>                            Send Info_Box "Sorry, no free fileslot in filelist.cfg could be found. Cannot continue changing table."
104852>>>                            Procedure_Return
104853>>>                        End
104853>>>>
104853>>>
104853>>>                        Get Value of oDriverID2_cf to sDriverID
104854>>>                        Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
104855>>>                        Get SqlColumnRenameByTableName of ghoDbUpdateFunctionLibrary sTableName sColumnName sNewColumnName to bOk
104856>>>                        If (bOk = True) Begin
104858>>>                            // Better delete the combo values after a successful rename as it looks odd to show the old column name...
104858>>>                            Send Delete_Data of oSQLColumnName_cf
104859>>>                            Send Info_Box ("Column" * sColumnName + ", was successfully renamed to" * sNewColumnName * "for table:" * sTableName)
104860>>>                        End
104860>>>>
104860>>>                        Else Begin
104861>>>                            Send Info_Box "Nope, that didn't work..."
104862>>>                        End
104862>>>>
104862>>>
104862>>>                    End_Procedure
104863>>>
104863>>>                End_Object
104864>>>
104864>>>                Object oSQLRemoveColumn_btn is a cButtonDPI
104866>>>                    Set Size to 13 91
104867>>>                    Set Location to 133 297
104868>>>                    Set Label to "Drop Column"
104869>>>                    Set MultiLineState to True
104870>>>                    Set psToolTip to "Test of SQLColumnRemove function"
104871>>>                    Set psImage to "DeleteColumn.ico"
104872>>>
104872>>>                    Procedure OnClick
104875>>>                        Boolean bOk
104875>>>                        String sTableName sColumnName sDriverID
104875>>>                        Integer iRetval
104875>>>
104875>>>                        Get Value of oDriverID2_cf              to sDriverID
104876>>>                        Get Value of oSQLTableName_cf           to sTableName
104877>>>                        Get Value of oSQLColumnName_cf          to sColumnName
104878>>>
104878>>>                        If (sTableName = "" or sColumnName = "") Begin
104880>>>                            Send Info_Box "You first need to select a table and a column."
104881>>>                            Procedure_Return
104882>>>                        End
104882>>>>
104882>>>
104882>>>                        Get YesNo_Box ("This will remove (drop) the column named:" * sColumnName * "from table:" * sTableName + ". Are you sure?") to iRetval
104883>>>                        If (iRetval <> MBR_Yes) Begin
104885>>>                            Procedure_Return
104886>>>                        End
104886>>>>
104886>>>
104886>>>                        Get SqlColumnRemoveByTableName of ghoDbUpdateFunctionLibrary sTableName sColumnName to bOk
104887>>>
104887>>>                        If (bOk = True) Begin
104889>>>                            // Better delete the combo values after a successful operation as it looks odd to show the old column name...
104889>>>                            Send Delete_Data of oSQLColumnName_cf
104890>>>                            Send Info_Box ("Column" * sColumnName + ", was successfully removed")
104891>>>                        End
104891>>>>
104891>>>                        Else Begin
104892>>>                            Send Info_Box ("The column could NOT be removed. Either the column" * sColumnName * "doesn't exists or the current Database is incorrect?")
104893>>>                            Procedure_Return
104894>>>                        End
104894>>>>
104894>>>
104894>>>                    End_Procedure
104895>>>
104895>>>                End_Object
104896>>>
104896>>>                Object oSQLAddColumnName_fm is a Form
104898>>>                    Set Size to 13 96
104899>>>                    Set Location to 177 14
104900>>>                    Set Label_Col_Offset to 0
104901>>>                    Set Label_Justification_Mode to JMode_Top
104902>>>                    Set Label to "Column Name:"
104903>>>                    Set Label_Row_Offset to 1
104904>>>                    Set Value to "NewColumn"
104905>>>                End_Object
104906>>>
104906>>>                Object oSQLColumnType_cf is a ComboForm
104908>>>                    Set Size to 11 96
104909>>>                    Set Location to 178 116
104910>>>                    Set Label_Col_Offset to 0
104911>>>                    Set Label_Justification_Mode to JMode_Top
104912>>>                    Set Label_Row_Offset to 1
104913>>>                    Set Label to "Type:"
104914>>>                    Set Entry_State to False
104915>>>
104915>>>                    Procedure Combo_Fill_List
104918>>>                        tColumnType[] ColumnTypeArray
104918>>>                        tColumnType[] ColumnTypeArray
104919>>>                        Integer iSize iCount iDbType
104919>>>                        String sDriverID
104919>>>
104919>>>                        Send Delete_Data
104920>>>                        Get Value of oDriverID2_cf to sDriverID
104921>>>                        Get piDbType of ghoDbUpdateFunctionLibrary to iDbType
104922>>>                        Get UtilEnumerateColumnTypes of ghoDbUpdateFunctionLibrary sDriverID iDbType to ColumnTypeArray
104923>>>                        Move (SizeOfArray(ColumnTypeArray)) to iSize
104924>>>                        Decrement iSize
104925>>>                        For iCount from 0 to iSize
104931>>>>
104931>>>                            Send Combo_Add_Item ColumnTypeArray[iCount].sSQLType
104932>>>                        Loop
104933>>>>
104933>>>                        If (iSize > 0) Begin
104935>>>                            Set Value to ColumnTypeArray[0].sSQLType
104936>>>                        End
104936>>>>
104936>>>                    End_Procedure
104937>>>
104937>>>                    Procedure OnChange
104940>>>                        Integer iType iSize iDec
104940>>>                        tSQLConnection SQLConnection
104940>>>                        tSQLConnection SQLConnection
104940>>>                        Boolean bFixed
104940>>>
104940>>>                        Get SelectedType to iType
104941>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
104942>>>                        Get UtilColumnTypePrecisionSize of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType iType to iSize
104943>>>                        Get UtilColumnTypePrecisionDec  of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType iType to iDec
104944>>>                        Get UtilColumnTypeFixed         of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType iType to bFixed
104945>>>
104945>>>                        Set Enabled_State of oSQLLength_sf   to (bFixed = False)
104946>>>                        Set Enabled_State of oSQLDecimals_sf to (bFixed = False)
104947>>>                        Set Value         of oSQLLength_sf   to iSize
104948>>>                        If (iDec = 0) Begin
104950>>>                            Set Value     of oSQLDecimals_sf to ""
104951>>>                        End
104951>>>>
104951>>>                        Else Begin
104952>>>                            Set Value     of oSQLDecimals_sf to iDec
104953>>>                        End
104953>>>>
104953>>>                        If (bFixed = False) Begin
104955>>>                            Set Enabled_State of oSQLDecimals_sf to (iDec <> 0)
104956>>>                        End
104956>>>>
104956>>>                    End_Procedure
104957>>>
104957>>>                    Function SelectedType Returns Integer
104960>>>                        String sValue sDriverID
104960>>>                        Integer iType iDbType
104960>>>
104960>>>                        Get Value to sValue
104961>>>                        Get psDriverID of ghoSQLConnectionHandler to sDriverID
104962>>>                        Get piDbType   of ghoSQLConnectionHandler to iDbType
104963>>>                        Get UtilColumnTypeToInteger of ghoDbUpdateFunctionLibrary sDriverID iDbType sValue to iType
104964>>>
104964>>>                        Function_Return iType
104965>>>                    End_Function
104966>>>
104966>>>                End_Object
104967>>>
104967>>>                Object oSQLAddColumn_btn is a cButtonDPI
104969>>>                    Set Size to 13 69
104970>>>                    Set Location to 177 220
104971>>>                    Set Label to "Add Column"
104972>>>                    Set MultiLineState to True
104973>>>                    Set psToolTip to "Test of SQLColumnAdd function"
104974>>>                    Set psImage to "AddColumn.ico"
104975>>>
104975>>>                    Procedure OnClick
104978>>>                        Boolean bOk bInitialize
104978>>>                        Handle hTable
104978>>>                        String sTableName sColumnName sType sColumnValue sDriverID
104978>>>                        Integer iType iLength iDecimals
104978>>>
104978>>>                        Get Value of oDriverID2_cf              to sDriverID
104979>>>                        Get Value of oSQLTableName_cf           to sTableName
104980>>>                        Get Value of oSQLAddColumnName_fm       to sColumnName
104981>>>                        Get SelectedType  of oSQLColumnType_cf  to iType
104982>>>                        Get Value         of oSQLColumnType_cf  to sType
104983>>>                        Get Checked_State of oSQLInitializeColumnValue_cb to bInitialize
104984>>>                        Get Value         of oSQLColumnValue_fm to sColumnValue
104985>>>                        Get Value         of oSQLLength_sf      to iLength
104986>>>                        Get Value         of oSQLDecimals_sf    to iDecimals
104987>>>
104987>>>                        If (sTableName <> "") Begin
104989>>>                            Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
104990>>>                            If (hTable = 0) Begin
104992>>>                                Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
104993>>>                            End
104993>>>>
104993>>>                        End
104993>>>>
104993>>>                        If (hTable = 0) Begin
104995>>>                            Send Info_Box "You first need to select a table before you can add a column to it."
104996>>>                            Procedure_Return
104997>>>                        End
104997>>>>
104997>>>                        If (sColumnName = "") Begin
104999>>>                            Send Info_Box "You need to enter a column name"
105000>>>                            Procedure_Return
105001>>>                        End
105001>>>>
105001>>>
105001>>>                        Get SqlColumnAddByTableName of ghoDbUpdateFunctionLibrary sTableName sColumnName iType iLength iDecimals bInitialize sColumnValue to bOk
105002>>>
105002>>>                        If (bOk = True) Begin
105004>>>                            Send Info_Box ("New column" * sColumnName * sType * String(iLength) + ", was successfully added to" * sTableName)
105005>>>                        End
105005>>>>
105005>>>                        Else Begin
105006>>>                            Send Info_Box ("The column could NOT be added. Either column" * sColumnName * "already exists or the current Database is incorrect?")
105007>>>                            Procedure_Return
105008>>>                        End
105008>>>>
105008>>>
105008>>>                    End_Procedure
105009>>>
105009>>>                End_Object
105010>>>
105010>>>//                Object oTest_btn is a cButtonDPI
105010>>>//                    Set Size to 13 92
105010>>>//                    Set Location to 177 298
105010>>>//                    Set Label to "Test SQL script button"
105010>>>//
105010>>>//                    Procedure OnClick
105010>>>//                        Boolean bOK
105010>>>//                        String sTableName sColumnName
105010>>>//
105010>>>//                        Get Value of oSQLTableName_cf      to sTableName
105010>>>//                        Get Value of oSQLAddColumnName_fm  to sColumnName
105010>>>////                        Get SqlUtilDefaultConstraintsMSSQL of ghoDbUpdateFunctionLibrary sTableName sColumnName to bOK
105010>>>//
105010>>>//                    End_Procedure
105010>>>//
105010>>>//                End_Object
105010>>>
105010>>>                Object oSQLLength_sf is a SpinForm
105012>>>                    Set Label to "Length:"
105013>>>                    Set Size to 13 40
105014>>>                    Set Location to 202 16
105015>>>                    Set Label_Col_Offset to 0
105016>>>                    Set Label_Justification_Mode to JMode_Top
105017>>>                    Set Label_Row_Offset to 1
105018>>>                    Set Value to "10"
105019>>>                    Set Maximum_Position to 500
105020>>>                    Set Minimum_Position to 1
105021>>>                End_Object
105022>>>
105022>>>                Object oSQLDecimals_sf is a SpinForm
105024>>>                    Set Label to "Decimals:"
105025>>>                    Set Size to 13 33
105026>>>                    Set Location to 202 60
105027>>>                    Set Label_Col_Offset to 0
105028>>>                    Set Label_Justification_Mode to JMode_Top
105029>>>                    Set Label_Row_Offset to 1
105030>>>                    Set Value to "0"
105031>>>                    Set Maximum_Position to 16
105032>>>                    Set Minimum_Position to 1
105033>>>                End_Object
105034>>>
105034>>>                Object oSQLInitializeColumnValue_cb is a CheckBox
105036>>>                    Set Size to 10 50
105037>>>                    Set Location to 203 116
105038>>>                    Set Label to "Initialize Column Value"
105039>>>
105039>>>                    Procedure OnChange
105042>>>                        Boolean bChecked
105042>>>
105042>>>                        Get Checked_State to bChecked
105043>>>                        Set Enabled_State of oSQLColumnValue_fm to bChecked
105044>>>                    End_Procedure
105045>>>
105045>>>                End_Object
105046>>>
105046>>>                Object oSQLColumnValue_fm is a Form
105048>>>                    Set Size to 13 96
105049>>>                    Set Location to 218 116
105050>>>                    Set Label_Col_Offset to 2
105051>>>                    Set Label_Justification_Mode to JMode_Right
105052>>>                    Set Label to "Column Value"
105053>>>                    Set psToolTip to "When a new column is added the new column can be initialized with a value for all existing records."
105054>>>                    Set Enabled_State to False
105055>>>                End_Object
105056>>>
105056>>>                Object oEnumRelations_btn is a cButtonDPI
105058>>>                    Set Size to 13 91
105059>>>                    Set Location to 116 297
105060>>>                    Set Label to "Test Enum SQL Relations"
105061>>>
105061>>>                    Procedure OnClick
105064>>>                        tSQLRelation[] SQLRelationArray
105064>>>                        tSQLRelation[] SQLRelationArray
105065>>>                        String sTableName sDriverID
105065>>>                        Integer iSize iCount
105065>>>
105065>>>                        Get Value of oDriverID2_cf to sDriverID
105066>>>                        Get Value of oSQLTableName_cf to sTableName
105067>>>                        Get SqlUtilEnumerateRelations of ghoDbUpdateFunctionLibrary sTableName sDriverID to SQLRelationArray
105068>>>                        Move (SizeOfArray(SQLRelationArray)) to iSize
105069>>>                        Decrement iSize
105070>>>                        For iCount from 0 to iSize
105076>>>>
105076>>>                            Showln "Tablename.FieldName = " SQLRelationArray[iCount].sFileName "." SQLRelationArray[iCount].sFieldName " Number: " SQLRelationArray[iCount].iFileNumber "." SQLRelationArray[iCount].iFieldNumber
105085>>>                        Loop
105086>>>>
105086>>>                        If (iSize < 1) Begin
105088>>>                            Send Info_Box ("No SQL Foreign keys found for table:" * sTableName)
105089>>>                        End
105089>>>>
105089>>>
105089>>>                    End_Procedure
105090>>>
105090>>>                End_Object
105091>>>
105091>>>                Object oEnumerateLoggedInUsers is a cButtonDPI
105093>>>                    Set Size to 13 101
105094>>>                    Set Location to 177 297
105095>>>                    Set Label to "Enumerate Logged In Users"
105096>>>
105096>>>                    Procedure OnClick
105099>>>                        tSQLLoggedInUser[] SQLLoggedInUser
105099>>>                        tSQLLoggedInUser[] SQLLoggedInUser
105100>>>                        String sDriverID sDatabase
105100>>>                        Integer iSize iCount
105100>>>
105100>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
105101>>>                        Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase
105102>>>                        Get SqlUtilEnumerateLoggedInUsers of ghoDbUpdateFunctionLibrary sDriverID sDatabase to SQLLoggedInUser
105103>>>                        Move (SizeOfArray(SQLLoggedInUser)) to iSize
105104>>>                        Decrement iSize
105105>>>
105105>>>                        Showln "SQL User Name" " and Program:"
105108>>>                        For iCount from 0 to iSize
105114>>>>
105114>>>                            Showln SQLLoggedInUser[iCount].sUser " " SQLLoggedInUser[iCount].sProgram
105118>>>                        Loop
105119>>>>
105119>>>                    End_Procedure
105120>>>
105120>>>                End_Object
105121>>>
105121>>>                Object oEnumerateTablesAndViews is a cButtonDPI
105123>>>                    Set Size to 13 101
105124>>>                    Set Location to 193 297
105125>>>                    Set Label to "Is Table or View?"
105126>>>
105126>>>                    Procedure OnClick
105129>>>                        String sDriverID sTableName
105129>>>                        Handle hTable
105129>>>                        Boolean bViewTableType
105129>>>
105129>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
105130>>>                        Get Value of oSQLTableName_cf to sTableName
105131>>>                        Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
105132>>>                        If (hTable = 0) Begin
105134>>>                            Procedure_Return
105135>>>                        End
105135>>>>
105135>>>                        Get SQLUtilTableIsViewType of ghoDbUpdateFunctionLibrary sDriverID hTable to bViewTableType
105136>>>                        Send Info_Box ("The table" * sTableName * "is a" * If(bViewTableType = True, "View Table Type", "Standard Table (not view)"))
105137>>>                    End_Procedure
105138>>>
105138>>>                End_Object
105139>>>
105139>>>            End_Object
105140>>>
105140>>>        End_Object
105141>>>
105141>>>    End_Object
105142>>>
105142>>>End_Object
105143>        Use APIFunctions.vw
Including file: APIFunctions.vw    (C:\Projects\DF18\DbUpdateFramework\AppSrc\APIFunctions.vw)
105143>>>Use Windows.pkg
105143>>>Use DFClient.pkg
105143>>>Use Dfspnfrm.pkg
105143>>>Use Dfline.pkg
105143>>>Use cDbScrollingContainer.pkg
105143>>>Use cButtonDPI.pkg
105143>>>Use cDbUpdateFunctionLibrary.pkg
105143>>>
105143>>>Define CI_Table1_FileNo for 401
105143>>>Define CI_View1_FileNo  for 402
105143>>>
105143>>>Activate_View Activate_oAPIFunctions_vw for oAPIFunctions_vw
105153>>>>
105153>>>Object oAPIFunctions_vw is a dbView
105155>>>    Set Border_Style to Border_Thick
105156>>>    Set Size to 237 424
105157>>>    Set Location to 2 2
105158>>>    Set Label to "API Functions"
105159>>>    Set pbAutoActivate to True
105160>>>    Set Icon to "APIFunctions.ico"
105161>>>
105161>>>    Property String psTableName ""
105163>>>
105163>>>    Procedure OnSetFocus
105166>>>        String sValue
105166>>>        tSQLConnection SQLConnection
105166>>>        tSQLConnection SQLConnection
105166>>>
105166>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
105167>>>        Set Value of oApiDatabase_fm to SQLConnection.sDatabase
105168>>>        Move (Replace(("PWD=" + SQLConnection.sPassword), SQLConnection.sConnectionString, "PWD=***")) to sValue
105169>>>        Set Value of oApiConnectionString_fm to sValue
105170>>>    End_Procedure
105171>>>
105171>>>    Object oScrollingContainer1 is a cDbScrollingContainer
105173>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
105175>>>
105175>>>            Object oApiFunctions_grp is a Group
105177>>>                Set Size to 222 402
105178>>>                Set Location to 6 12
105179>>>                Set Label to "Tests: Change MS-SQL Database with Database API Functions"
105180>>>                Set peAnchors to anAll
105181>>>
105181>>>                Object oApiConnectionString_fm is a Form
105183>>>                    Set Size to 13 368
105184>>>                    Set Location to 23 14
105185>>>                    Set Label to "Current Connection String Settings:"
105186>>>                    Set Label_Col_Offset to 0
105187>>>                    Set Label_Justification_Mode to JMode_Top
105188>>>                    Set peAnchors to anTopLeftRight
105189>>>                    Set Enabled_State to False
105190>>>                    Set Label_Row_Offset to 1
105191>>>                End_Object
105192>>>
105192>>>                Object oApiDatabase_fm is a Form
105194>>>                    Set Size to 13 86
105195>>>                    Set Location to 50 14
105196>>>                    Set Label to "Database:"
105197>>>                    Set Label_Col_Offset to 0
105198>>>                    Set Label_Justification_Mode to JMode_Top
105199>>>                    Set Label_Row_Offset to 1
105200>>>                    Set Enabled_State to False
105201>>>                    Set FontWeight to fw_Bold
105202>>>//                    Set Label_FontWeight to fw_Bold
105202>>>
105202>>>                    Procedure Page Integer iPageObject
105205>>>                        String sValue
105205>>>                        Get psDatabase of ghoSQLConnectionHandler to sValue
105206>>>                        Set Value to sValue
105207>>>
105207>>>                        Forward Send Page iPageObject
105209>>>                    End_Procedure
105210>>>
105210>>>                End_Object
105211>>>
105211>>>                Object oDriverID3_cf is a ComboForm
105213>>>                    Set Size to 11 91
105214>>>                    Set Location to 51 121
105215>>>                    Set Label_Col_Offset to 0
105216>>>                    Set Label_Justification_Mode to JMode_Top
105217>>>                    Set Label to "Driver ID:"
105218>>>                    Set Entry_State to False
105219>>>                    Set Enabled_State to False
105220>>>                    Set Label_Row_Offset to 1
105221>>>                    Set Enabled_State to False
105222>>>
105222>>>                    Procedure Combo_Fill_List
105225>>>                        Send Combo_Add_Item MSSQLDRV_ID
105226>>>                        Send Combo_Add_Item DB2_DRV_ID
105227>>>                        Send Combo_Add_Item ODBC_DRV_ID
105228>>>                        Send Combo_Add_Item SQLFLEX
105229>>>                        Send Combo_Add_Item MDSDB2
105230>>>                        Send Combo_Add_Item MDSMySQL
105231>>>                        Send Combo_Add_Item MDSPgSQL
105232>>>                        Send Combo_Add_Item ORAFLEX
105233>>>                    End_Procedure
105234>>>
105234>>>                    Procedure Refresh
105237>>>                        String sValue
105237>>>
105237>>>                        Get psDriverID of ghoSQLConnectionHandler to sValue
105238>>>                        Set Value to sValue
105239>>>                    End_Procedure
105240>>>
105240>>>                End_Object
105241>>>
105241>>>                Object oDatabaseInfo_tb is a TextBox
105243>>>                    Set Auto_Size_State to False
105244>>>                    Set Size to 25 96
105245>>>                    Set Location to 64 14
105246>>>                    Set Label to "(Change database on the SQL Connections tabpage)"
105247>>>                    Set Justification_Mode to JMode_Left
105248>>>                End_Object
105249>>>
105249>>>                Object oApiTableName_fm is a Form
105251>>>                    Set Size to 13 77
105252>>>                    Set Location to 114 14
105253>>>                    Set Label_Col_Offset to 0
105254>>>                    Set Label_Justification_Mode to JMode_Top
105255>>>                    Set Label to "Table Name:"
105256>>>                    Set Label_Row_Offset to 1
105257>>>                    Set Value to "NewTable"
105258>>>                    Procedure OnChange
105261>>>                        String sValue
105261>>>                        Get Value to sValue
105262>>>                        Set psTableName to sValue
105263>>>                    End_Procedure
105264>>>                    Send OnChange
105265>>>                End_Object
105266>>>
105266>>>                Object oApiAddNewTable_btn is a cButtonDPI
105268>>>                    Set Size to 13 69
105269>>>                    Set Location to 114 271
105270>>>                    Set Label to "Add Table"
105271>>>                    Set MultiLineState to True
105272>>>                    Set psImage to "ActionAddTable.ico"
105273>>>
105273>>>                    Procedure OnClick
105276>>>                        Boolean bOk
105276>>>                        Handle hTable
105276>>>                        String sTableName sDriverID
105276>>>
105276>>>                        Get Value of oDriverID3_cf to sDriverID
105277>>>                        Get Value of oApiTableName_fm to sTableName
105278>>>                        Move (Trim(sTableName)) to sTableName
105279>>>                        If (sTableName = "") Begin
105281>>>                            Send Info_Box "You first need to enter a table name."
105282>>>                            Procedure_Return
105283>>>                        End
105283>>>>
105283>>>
105283>>>                        Send Cursor_Wait of Cursor_Control
105284>>>                        Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
105285>>>                        Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
105286>>>                        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True to bOk
105287>>>                        If (bOk = True) Begin
105289>>>                            Send Info_Box ("Test table" * sTableName * "was successfully created and put in filelist slot:" * String(hTable))
105290>>>                        End
105290>>>>
105290>>>                        Else Begin
105291>>>                            Send Cursor_Ready of Cursor_Control
105292>>>                            Send Info_Box ("Nope, the test table" * sTableName * "could not be created, or does it already exist?") "Error"
105293>>>                            Procedure_Return
105294>>>                        End
105294>>>>
105294>>>
105294>>>                    End_Procedure
105295>>>
105295>>>                End_Object
105296>>>
105296>>>                Object oApiAddColumn_fm is a Form
105298>>>                    Set Size to 13 77
105299>>>                    Set Location to 141 14
105300>>>                    Set Label_Col_Offset to 0
105301>>>                    Set Label_Justification_Mode to JMode_Top
105302>>>                    Set Label to "Column Name:"
105303>>>                    Set Label_Row_Offset to 1
105304>>>                    Set Value to "NewColumn"
105305>>>                End_Object
105306>>>
105306>>>                Object oApiColumnType_cf is a ComboForm
105308>>>                    Set Size to 11 85
105309>>>                    Set Location to 142 96
105310>>>                    Set Label_Col_Offset to 0
105311>>>                    Set Label_Justification_Mode to JMode_Top
105312>>>                    Set Label_Row_Offset to 1
105313>>>                    Set Label to "Type:"
105314>>>                    Set Entry_State to False
105315>>>
105315>>>                    Procedure Combo_Fill_List
105318>>>                        tColumnType[] ColumnTypeArray
105318>>>                        tColumnType[] ColumnTypeArray
105319>>>                        Integer iSize iCount
105319>>>
105319>>>                        Send Delete_Data
105320>>>                        Get UtilEnumerateColumnTypes of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex to ColumnTypeArray
105321>>>                        Move (SizeOfArray(ColumnTypeArray)) to iSize
105322>>>                        Decrement iSize
105323>>>                        For iCount from 0 to iSize
105329>>>>
105329>>>                            Send Combo_Add_Item ColumnTypeArray[iCount].sSQLType
105330>>>                        Loop
105331>>>>
105331>>>                        Set Value to ColumnTypeArray[0].sSQLType
105332>>>                    End_Procedure
105333>>>
105333>>>                    Procedure OnChange
105336>>>                        Integer iType iSize iDec
105336>>>                        tSQLConnection SQLConnection
105336>>>                        tSQLConnection SQLConnection
105336>>>                        Boolean bFixed
105336>>>
105336>>>                        Get SelectedType to iType
105337>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
105338>>>                        Get UtilColumnTypePrecisionSize of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iType to iSize
105339>>>                        Get UtilColumnTypePrecisionDec  of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iType to iDec
105340>>>                        Get UtilColumnTypeFixed         of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iType to bFixed
105341>>>
105341>>>                        Set Enabled_State of oApiLength_sf   to (bFixed = False)
105342>>>                        Set Enabled_State of oApiDecimals_sf to (bFixed = False)
105343>>>                        Set Value         of oApiLength_sf   to iSize
105344>>>                        If (iDec = 0) Begin
105346>>>                            Set Value     of oApiDecimals_sf to ""
105347>>>                        End
105347>>>>
105347>>>                        Else Begin
105348>>>                            Set Value     of oApiDecimals_sf to iDec
105349>>>                        End
105349>>>>
105349>>>                        If (bFixed = False) Begin
105351>>>                            Set Enabled_State of oApiDecimals_sf to (iDec <> 0)
105352>>>                        End
105352>>>>
105352>>>                    End_Procedure
105353>>>
105353>>>                    Function SelectedType Returns Integer
105356>>>                        String sValue
105356>>>                        Integer iType
105356>>>
105356>>>                        Get Value to sValue
105357>>>                        Get UtilColumnTypeToInteger of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex sValue to iType
105358>>>
105358>>>                        Function_Return iType
105359>>>                    End_Function
105360>>>
105360>>>                End_Object
105361>>>
105361>>>                Object oApiLength_sf is a SpinForm
105363>>>                    Set Label to "Length:"
105364>>>                    Set Size to 13 35
105365>>>                    Set Location to 141 186
105366>>>                    Set Label_Col_Offset to 0
105367>>>                    Set Label_Justification_Mode to JMode_Top
105368>>>                    Set Label_Row_Offset to 1
105369>>>                    Set Value to "10"
105370>>>                    Set Maximum_Position to 500
105371>>>                    Set Minimum_Position to 1
105372>>>                End_Object
105373>>>
105373>>>                Object oApiDecimals_sf is a SpinForm
105375>>>                    Set Label to "Decimals:"
105376>>>                    Set Size to 13 33
105377>>>                    Set Location to 141 225
105378>>>                    Set Label_Col_Offset to 0
105379>>>                    Set Label_Justification_Mode to JMode_Top
105380>>>                    Set Label_Row_Offset to 1
105381>>>                    Set Value to "0"
105382>>>                    Set Maximum_Position to 16
105383>>>                    Set Minimum_Position to 1
105384>>>                End_Object
105385>>>
105385>>>                Object oApiAddColumn_btn is a cButtonDPI
105387>>>                    Set Size to 13 69
105388>>>                    Set Location to 141 271
105389>>>                    Set Label to "Add Column"
105390>>>                    Set MultiLineState to True
105391>>>                    Set psToolTip to "ApiColumnAdd function"
105392>>>                    Set psImage to "ActionAddColumn.ico"
105393>>>
105393>>>                    Procedure OnClick
105396>>>                        Boolean bOk
105396>>>                        Handle hTable
105396>>>                        String sTableName sColumnName sType sDriverID
105396>>>                        Integer iType iLength iDecimals
105396>>>
105396>>>                        Get Value of oDriverID3_cf            to sDriverID
105397>>>                        Get Value of oApiTableName_fm         to sTableName
105398>>>                        Get Value of oApiAddColumn_fm         to sColumnName
105399>>>                        Get SelectedType of oApiColumnType_cf to iType
105400>>>                        Get Value        of oApiLength_sf     to iLength
105401>>>                        Get Value        of oApiDecimals_sf   to iDecimals
105402>>>
105402>>>                        Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
105403>>>                        Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
105404>>>                        If (hTable = 0) Begin
105406>>>                            Send Info_Box "You first need to create the new table by pressing the 'Create New Table...' button, before you can add a column to it."
105407>>>                            Procedure_Return
105408>>>                        End
105408>>>>
105408>>>                        If (sColumnName = "") Begin
105410>>>                            Send Info_Box "You need to enter a column name"
105411>>>                            Procedure_Return
105412>>>                        End
105412>>>>
105412>>>
105412>>>                        Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable sColumnName iType iLength iDecimals to bOk
105413>>>                        If (bOk = True) Begin
105415>>>                            Send Info_Box ("Column" * sColumnName * sType * String(iLength) + ", was successfully added to" * sTableName * "(at filelist slot:" * String(hTable) + ")")
105416>>>                        End
105416>>>>
105416>>>                        Else Begin
105417>>>                            Send Info_Box ("The column could NOT be added. Either column" * sColumnName * "already exists or the current Database is incorrect?")
105418>>>                            Procedure_Return
105419>>>                        End
105419>>>>
105419>>>
105419>>>                    End_Procedure
105420>>>
105420>>>                End_Object
105421>>>
105421>>>                Object oApiAddTableAndColumns_btn is a cButtonDPI
105423>>>                    Set Size to 26 77
105424>>>                    Set Location to 184 14
105425>>>                    Set Label to "Create 'New' Table with Three Columns"
105426>>>                    Set MultiLineState to True
105427>>>                    Set psImage to "ActionAddTable.ico"
105428>>>
105428>>>                    Procedure OnClick
105431>>>                        Boolean bOk
105431>>>                        Handle hTable
105431>>>                        String sTableName sDriverID
105431>>>
105431>>>                        Get Value of oDriverID3_cf to sDriverID
105432>>>                        Get Value of oApiTableName_fm to sTableName
105433>>>                        Move (Trim(sTableName)) to sTableName
105434>>>                        If (sTableName = "") Begin
105436>>>                            Send Info_Box "You first need to enter a table name."
105437>>>                            Procedure_Return
105438>>>                        End
105438>>>>
105438>>>
105438>>>                        Send Cursor_Wait of Cursor_Control
105439>>>                        Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
105440>>>
105440>>>                        Set psDriverID       of ghoDbUpdateFunctionLibrary to sDriverID
105441>>>                        Get ApiTableCreate   of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True to bOk
105442>>>                        If (bOk = True) Begin
105444>>>                            Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable "Col1Ascii"   DF_ASCII 10 0 to bOk
105445>>>                            Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable "Col2Date"    DF_DATE   6 0 to bOk
105446>>>                            Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable "Col3Numeric" DF_BCD    6 2 to bOk
105447>>>                        End
105447>>>>
105447>>>                        Send Cursor_Ready of Cursor_Control
105448>>>
105448>>>                        If (bOk = True) Begin
105450>>>                            Send Info_Box ("Test table" * sTableName * "with Columns: 'Col1 ASCII 10', 'Col2 Date' and 'Col3 Numeric 6,2' was successfully created and put in filelist slot:" * String(CI_Table1_FileNo))
105451>>>                        End
105451>>>>
105451>>>                        Else Begin
105452>>>                            Send Cursor_Ready of Cursor_Control
105453>>>                            Send Info_Box ("Nope, the test table" * sTableName * "could not be created") "Error"
105454>>>                            Procedure_Return
105455>>>                        End
105455>>>>
105455>>>
105455>>>                    End_Procedure
105456>>>
105456>>>                End_Object
105457>>>
105457>>>                Object oApiRemoveTable_btn is a cButtonDPI
105459>>>                    Set Size to 26 77
105460>>>                    Set Location to 184 96
105461>>>                    Set Label to "Remove 'New' Table"
105462>>>                    Set psImage to "ActionDeleteTable.ico"
105463>>>                    Set MultiLineState to True
105464>>>
105464>>>                    Procedure OnClick
105467>>>                        Boolean bOk
105467>>>                        Integer iRetval
105467>>>                        Handle hTable
105467>>>                        String sTableName sDriverID
105467>>>
105467>>>                        Get Value of oDriverID3_cf to sDriverID
105468>>>                        Get Value of oApiTableName_fm to sTableName
105469>>>                        Get YesNo_Box ("Are you sure you want to PERMANENTLY DELETE the table named:" * String(sTableName) + "?") to iRetval
105470>>>                        If (iRetval = MBR_Yes) Begin
105472>>>                            Send Cursor_Wait of Cursor_Control
105473>>>                            Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
105474>>>                            Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
105475>>>                            Get ApiTableRemove of ghoDbUpdateFunctionLibrary hTable to bOk
105476>>>                            Send Cursor_Ready of Cursor_Control
105477>>>                            If (bOk = True) Begin
105479>>>                                Send Info_Box "Table removed"
105480>>>                            End
105480>>>>
105480>>>                            Else Begin
105481>>>                                Send Info_Box "Nope, that didnt' work. Either the table doesn't exist or your rights aren't sufficient."
105482>>>                            End
105482>>>>
105482>>>                        End
105482>>>>
105482>>>                    End_Procedure
105483>>>
105483>>>                End_Object
105484>>>
105484>>>                Object oLineControl1 is a LineControl
105486>>>                    Set Size to 2 387
105487>>>                    Set Location to 96 6
105488>>>                    Set peAnchors to anTopLeftRight
105489>>>                End_Object
105490>>>
105490>>>                Object oLineControl2 is a LineControl
105492>>>                    Set Size to 3 248
105493>>>                    Set Location to 171 9
105494>>>                End_Object
105495>>>
105495>>>            End_Object
105496>>>
105496>>>        End_Object
105497>>>
105497>>>    End_Object
105498>>>
105498>>>End_Object
105499>        Use UtilFunctions.vw
Including file: UtilFunctions.vw    (C:\Projects\DF18\DbUpdateFramework\AppSrc\UtilFunctions.vw)
105499>>>Use Windows.pkg
105499>>>Use DFClient.pkg
105499>>>Use Dfline.pkg
105499>>>Use cDbScrollingContainer.pkg
105499>>>Use cButtonDPI.pkg
105499>>>Use cDbUpdateFunctionLibrary.pkg
105499>>>Use Dftreevw.pkg
105499>>>Use Working.pkg
Including file: Working.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\Working.pkg)
105499>>>>>// COPYRIGHT (c) 2003-2017 RDC Tools International
105499>>>>>//
105499>>>>>// This program is free software; you can redistribute it and/or
105499>>>>>// modify it under the terms of the GNU General Public License
105499>>>>>// as published by the Free Software Foundation; version 2
105499>>>>>// of the License.
105499>>>>>
105499>>>>>// This program is distributed in the hope that it will be useful,
105499>>>>>// but WITHOUT ANY WARRANTY; without even the implied warranty of
105499>>>>>// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
105499>>>>>// GNU General Public License for more details.
105499>>>>>
105499>>>>>// You should have received a copy of the GNU General Public License
105499>>>>>// along with this program; (See the GPL.txt file in the Help directory) if not, write to the Free Software
105499>>>>>// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
105499>>>>>Use Windows.pkg
105499>>>>>
105499>>>>>Object oWorkingMessagePanel is a ToolPanel
105501>>>>>    Set Label    to "Working"
105502>>>>>    Set Size to 48 150
105503>>>>>    Set Locate_Mode to CENTER_ON_PARENT
105504>>>>>    Set Popup_State to True
105505>>>>>
105505>>>>>    Object oWorkingMessage is a Textbox
105507>>>>>        Set Label to "Working message..."
105508>>>>>        Set Location to 15 5
105509>>>>>        Set Size to 27 123
105510>>>>>        Set Auto_Size_State to False
105511>>>>>        Set Justification_Mode to JMode_Center
105512>>>>>        Set FontWeight to fw_Bold
105513>>>>>    End_Object
105514>>>>>
105514>>>>>End_Object
105515>>>>>
105515>>>>>Procedure StartWorkingMessage Global String sText
105517>>>>>    Send Close_Panel of (oWorkingMessagePanel(Self))
105518>>>>>    Set Label  of (oWorkingMessage(oWorkingMessagePanel(Self))) to sText
105519>>>>>    Send Popup of (oWorkingMessagePanel(Self))
105520>>>>>End_Procedure
105521>>>>>
105521>>>>>Procedure StopWorkingMessage Global
105523>>>>>    Send Close_Panel of (oWorkingMessagePanel(Self))
105524>>>>>End_Procedure
105525>>>Use DUFStatusPanel.pkg
105525>>>Use cCharTranslate.pkg
Including file: cCharTranslate.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCharTranslate.pkg)
105525>>>>>Use Variant.pkg
105525>>>>>Use CharTranslate.pkg
105525>>>>>
105525>>>>>// special for UTF16, which is really not a code page at all
105525>>>>>Define CP_UTF16 for -1
105525>>>>>
105525>>>>>Class cCharTranslate is a cObject
105526>>>>>
105526>>>>>
105526>>>>>    // ==========================================================================================
105526>>>>>    // UTF16 functions that allow you to move between a char (UTF8, ANS, OEM) and a UTF16 buffer
105526>>>>>    // ==========================================================================================
105526>>>>>
105526>>>>>    // converts from buffer of encoded eCharType to a new UTF16 buffer
105526>>>>>    
105526>>>>>    // note: Utf16FromBuffer with eCharType of CP_OEM can replace OEMToUTF16Buffer
105526>>>>>    Function Utf16FromBuffer  Address pMultiCharBuffer Integer eCharType Integer ByRef iLen Returns Address
105528>>>>>        Address pWideBuf
105528>>>>>        Integer iWideBufLen iStrLen
105528>>>>>        Move 0 to pWideBuf
105529>>>>>        Move 0 to iLen
105530>>>>>        If (pMultiCharBuffer) Begin
105532>>>>>            Move (CStringLength(pMultiCharBuffer)) to iStrLen
105533>>>>>            If (iStrLen) Begin
105535>>>>>                Move (MultiToWideBuffer(eCharType,pMultiCharBuffer, iStrLen, AddressOf(pWideBuf))) to iLen
105536>>>>>                If (iLen=0) Begin
105538>>>>>                    Function_Return 0
105539>>>>>                End
105539>>>>>>
105539>>>>>            End
105539>>>>>>
105539>>>>>        End
105539>>>>>>
105539>>>>>        Function_Return pWideBuf
105540>>>>>    End_Function
105541>>>>>    
105541>>>>>    Function Utf16FromStr String sValue Integer eCharType Integer ByRef iLen Returns Address
105543>>>>>        Address aValue
105543>>>>>        Get Utf16FromBuffer (AddressOf(sValue)) eCharType (&iLen) to aValue
105544>>>>>        Function_Return aValue
105545>>>>>    End_Function
105546>>>>>    
105546>>>>>    // converts from utf16 buffer to a new buffer of encoded eCharType
105546>>>>>    
105546>>>>>    // note: Utf16ToBuffer with eCharType of CP_OEM can replace UTFtoOEMBuffer
105546>>>>>    Function Utf16ToBuffer Address pWideBuf Integer eCharType Integer iLen Returns Address
105548>>>>>        Address pRetBuf
105548>>>>>        Integer iRetBufLen
105548>>>>>        Move 0 to pRetBuf
105549>>>>>        If (pWideBuf and iLen) Begin
105551>>>>>            Move (WideToMultiBuffer(eCharType,pWideBuf,iLen,AddressOf(pRetBuf))) to iRetBufLen
105552>>>>>            If (iRetBufLen=0) Begin
105554>>>>>                Function_Return 0
105555>>>>>            End
105555>>>>>>
105555>>>>>        End
105555>>>>>>
105555>>>>>        Function_Return pRetBuf
105556>>>>>    End_Function
105557>>>>>    
105557>>>>>    Function Utf16ToStr Address pWideBuf Integer eCharType Integer iLen Returns String
105559>>>>>        String sValue
105559>>>>>        Address aValue
105559>>>>>        Boolean bOk
105559>>>>>        Get Utf16ToBuffer pWideBuf eCharType iLen to aValue
105560>>>>>        If (not(ValidStringBufferLength(aValue))) Begin
105562>>>>>            Error DFERR_PROGRAM "Buffer exceeds maximum string size"
105563>>>>>>
105563>>>>>        End
105563>>>>>>
105563>>>>>        Move aValue to sValue
105564>>>>>        Move (Free(aValue)) to bOk
105565>>>>>        Function_Return sValue    
105566>>>>>    End_Function
105567>>>>>    
105567>>>>>
105567>>>>>    // ==========================================================================================
105567>>>>>    // UTF8 functions that allow you to move between a UTF8 buffer and other single char OEM/ASNI
105567>>>>>    // ==========================================================================================
105567>>>>>
105567>>>>>    
105567>>>>>    Function Utf8FromBuffer Address pMultiCharBuffer Integer eCharType Returns Address
105569>>>>>        Address pWideBuf
105569>>>>>        Address pUtf8Buf
105569>>>>>        Integer iLen iMultiBufLen
105569>>>>>        Boolean bOk
105569>>>>>        Get Utf16FromBuffer pMultiCharBuffer eCharType (&iLen) to pWideBuf
105570>>>>>        If (iLen=0) Begin
105572>>>>>            Function_Return 0
105573>>>>>        End
105573>>>>>>
105573>>>>>        Move 0 to pUtf8Buf
105574>>>>>        Move (WideToMultiBuffer(CP_UTF8,pWideBuf,iLen,AddressOf(pUtf8Buf))) to iMultiBufLen
105575>>>>>        Move (Free(pWideBuf)) to bOk
105576>>>>>        Function_Return pUtf8Buf
105577>>>>>    End_Function
105578>>>>>    
105578>>>>>    Function Utf8FromStr String sValue Integer eCharType Returns Address
105580>>>>>        Address aValue
105580>>>>>        Get Utf8FromBuffer (AddressOf(sValue)) eCharType to aValue
105581>>>>>        Function_Return aValue
105582>>>>>    End_Function
105583>>>>>    
105583>>>>>    Function Utf8ToBuffer Address pMultiCharBuffer Integer eCharType Returns Address
105585>>>>>        Address pRetBuf pWideBuf
105585>>>>>        Integer iWideBufLen
105585>>>>>        Integer iRetBufLen
105585>>>>>        Boolean bOk
105585>>>>>        Get Utf16FromBuffer pMultiCharBuffer CP_UTF8 (&iWideBufLen) to pWideBuf
105586>>>>>        If (iWideBufLen=0) Begin
105588>>>>>            Function_Return 0
105589>>>>>        End
105589>>>>>>
105589>>>>>        Move 0 to pRetBuf
105590>>>>>        Move (WideToMultiBuffer(eCharType,pWideBuf,iWideBufLen,AddressOf(pRetBuf))) to iRetBufLen
105591>>>>>        Move (Free(pWideBuf)) to bOk
105592>>>>>        Function_Return pRetBuf
105593>>>>>    End_Function
105594>>>>>    
105594>>>>>    Function Utf8ToStr Address pWideBuf Integer eCharType Returns String
105596>>>>>        String sValue
105596>>>>>        Address aValue
105596>>>>>        Boolean bOk
105596>>>>>        Get Utf8ToBuffer pWideBuf eCharType to aValue
105597>>>>>        If (not(ValidStringBufferLength(aValue))) Begin
105599>>>>>            Error DFERR_PROGRAM "Buffer exceeds maximum string size"
105600>>>>>>
105600>>>>>        End
105600>>>>>>
105600>>>>>        Move aValue to sValue
105601>>>>>        Move (Free(aValue)) to bOk
105602>>>>>        Function_Return sValue    
105603>>>>>    End_Function
105604>>>>>
105604>>>>>    // ==========================================================================================
105604>>>>>    // Variant functions that allow you to move between a variant string (wide char) and other
105604>>>>>    // buffer and string types. Normally a Move vVar to sVar does a OEM/Unicode translation. These
105604>>>>>    // allow you translate to other formats (UTF8, OEM and ANSI)
105604>>>>>    // ==========================================================================================
105604>>>>>    
105604>>>>>    // Create data buffer from variant string. data buffer is encoded by eCharType
105604>>>>>    Function VariantStrToBuffer Variant vValue Integer eCharType Returns Address
105606>>>>>        Address aBSTR pRetStr
105606>>>>>        Integer iLen iBufLen
105606>>>>>        Boolean bOk
105606>>>>>        Move 0 to pRetStr
105607>>>>>        Get VariantStringLength vValue to iLen
105608>>>>>        If (iLen) Begin
105610>>>>>            Move (DeRefDw(AddressOf(vValue),8)) to aBSTR
105611>>>>>            Move (WideToMultiBuffer(eCharType,aBSTR,iLen,AddressOf(pRetStr))) to iBufLen
105612>>>>>        End
105612>>>>>>
105612>>>>>        Function_Return pRetStr
105613>>>>>    End_Function
105614>>>>>    
105614>>>>>    // Create string from variant string. data buffer is encoded by eCharType
105614>>>>>    
105614>>>>>    Function VariantStrToStr Variant vValue Integer eCharType Returns String
105616>>>>>        String sValue
105616>>>>>        Address aValue
105616>>>>>        Boolean bOk
105616>>>>>        Get VariantStrToBuffer vValue eCharType to aValue
105617>>>>>        If (not(ValidStringBufferLength(aValue))) Begin
105619>>>>>            Error DFERR_PROGRAM "Buffer exceeds maximum string size"
105620>>>>>>
105620>>>>>        End
105620>>>>>>
105620>>>>>        Move aValue to sValue
105621>>>>>        Move (Free(aValue)) to bOk
105622>>>>>        Function_Return sValue    
105623>>>>>    End_Function
105624>>>>>    
105624>>>>>    // Create variant string from data buffer. data buffer is encoded by eCharType
105624>>>>>    
105624>>>>>    Function VariantStrFromBuffer Address aSource Integer eCodeType Returns Variant
105626>>>>>        Variant vValue
105626>>>>>        Address pvValue
105626>>>>>        Boolean bOk
105626>>>>>        Address pWStr
105626>>>>>        Move "" to vValue
105627>>>>>        If (aSource) Begin
105629>>>>>            //Initialize pWstr variable so it has the correct type and AddressOf will return a proper pointer
105629>>>>>            Move 0 to pWStr
105630>>>>>            //Convert the Ansi string to Unicode
105630>>>>>            Get MultiToWideBuffer eCodeType aSource (CStringLength(aSource)) (AddressOf(pWStr)) to bOk
105631>>>>>            //Initialize vValue variable so it has the correct type and AddressOf will return a proper pointer
105631>>>>>            Move 0 to vValue
105632>>>>>            Move (AddressOf(vValue)) to pvValue
105633>>>>>            //Change the Variant type to VT_BSTR
105633>>>>>            Move (StoreDw(pvValue,0,OLE_VT_Bstr)) to bOk
105634>>>>>            //Allocate a proper COM BSTR, assign the Unicode string, and store the BSTR in the Variant variable
105634>>>>>            Move (StoreDw(pvValue,8,SysAllocString(pWStr))) to bOk
105635>>>>>            //Now clear up the Unicode string, the Variant owns a BSTR copy of the string
105635>>>>>            Move (Free(pWStr)) to bOk
105636>>>>>        End
105636>>>>>>
105636>>>>>        Function_Return vValue
105637>>>>>    End_Function
105638>>>>>    
105638>>>>>    // Create variant string from data string. data string is encoded by eCharType
105638>>>>>    
105638>>>>>    Function VariantStrFromStr String sValue Integer eCodeType Returns Variant
105640>>>>>        Variant vValue
105640>>>>>        Get VariantStrFromBuffer (AddressOf(sValue)) eCodeType to vValue
105641>>>>>        Function_Return vValue
105642>>>>>    End_Function    
105643>>>>>    
105643>>>>>    // Create buffer of utf16 data from variant. 
105643>>>>>    // Returns newly created memory address and length (by reference)
105643>>>>>    Function VariantStrToUTF16 Variant vValue Integer ByRef iLen Returns Address
105645>>>>>        Address aBSTR pRetStr
105645>>>>>        Boolean bOk
105645>>>>>        Move 0 to pRetStr
105646>>>>>        Get VariantStringLength vValue to iLen
105647>>>>>        If (iLen) Begin
105649>>>>>            Move (DeRefDw(AddressOf(vValue),8)) to aBSTR
105650>>>>>            Move (Alloc(iLen+1 * 2)) to pRetStr
105651>>>>>            Move (CopyMemory(pRetStr,aBSTR,(iLen+1 * 2))) to bOk
105652>>>>>        End
105652>>>>>>
105652>>>>>        Function_Return pRetStr
105653>>>>>    End_Function
105654>>>>>    
105654>>>>>    // Create variant from buffer of utf16 data
105654>>>>>    Function VariantStrFromUTF16 Address aSource Returns Variant
105656>>>>>        Variant vValue
105656>>>>>        Address pvValue
105656>>>>>        Boolean bOk
105656>>>>>        Move "" to vValue
105657>>>>>        If (aSource) Begin
105659>>>>>            //Initialize pWstr variable so it has the correct type and AddressOf will return a proper pointer
105659>>>>>            //Initialize vValue variable so it has the correct type and AddressOf will return a proper pointer
105659>>>>>            Move 0 to vValue
105660>>>>>            Move (AddressOf(vValue)) to pvValue
105661>>>>>            //Change the Variant type to VT_BSTR
105661>>>>>            Move (StoreDw(pvValue,0,OLE_VT_Bstr)) to bOk
105662>>>>>            //Allocate a proper COM BSTR, assign the Unicode string, and store the BSTR in the Variant variable
105662>>>>>            Move (StoreDw(pvValue,8,SysAllocString(aSource))) to bOk
105663>>>>>        End
105663>>>>>>
105663>>>>>        Function_Return vValue
105664>>>>>    End_Function
105665>>>>>    
105665>>>>>    // Create Uchar array from variant string. 
105665>>>>>    // Data buffer is encoded by eCharType
105665>>>>>    Function VariantStrToUCharArray Variant vValue Integer eCharType Returns UChar[]
105667>>>>>        Address aBSTR pRetStr
105667>>>>>        Integer iLen iBufLen
105667>>>>>        Boolean bOk
105667>>>>>        UChar[] UC1
105668>>>>>        Move 0 to pRetStr
105669>>>>>        Get VariantStringLength vValue to iLen
105670>>>>>        If (iLen) Begin
105672>>>>>            Move (DeRefDw(AddressOf(vValue),8)) to aBSTR
105673>>>>>            If (eCharType=CP_UTF16) Begin
105675>>>>>                Move (iLen*2) to iBufLen
105676>>>>>                Move (ResizeArray(UC1,iBufLen)) to UC1
105677>>>>>                Move (MemCopy(AddressOf(UC1),aBSTR,iBufLen)) to bOk
105678>>>>>            End
105678>>>>>>
105678>>>>>            Else Begin
105679>>>>>                Move (WideToMultiBuffer(eCharType,aBSTR,iLen,AddressOf(pRetStr))) to iBufLen
105680>>>>>                Move (ResizeArray(UC1,iBufLen)) to UC1
105681>>>>>                Move (MemCopy(AddressOf(UC1),pRetStr,iBufLen)) to bOk
105682>>>>>                Move (Free(pRetStr)) to bOk
105683>>>>>            End
105683>>>>>>
105683>>>>>        End
105683>>>>>>
105683>>>>>        Function_Return UC1
105684>>>>>    End_Function
105685>>>>>    
105685>>>>>    // Create variant string from UChar array. data is encoded by eCharType
105685>>>>>    Function VariantStrFromUCharArray UChar[] ucSource Integer eCodeType Returns Variant
105687>>>>>        Variant vValue
105687>>>>>        Address pvValue
105687>>>>>        Boolean bOk
105687>>>>>        Address pWStr
105687>>>>>        Move "" to vValue
105688>>>>>
105688>>>>>        //Initialize pWstr variable so it has the correct type and AddressOf will return a proper pointer
105688>>>>>        Move 0 to pWStr
105689>>>>>        //Convert the Ansi string to Unicode
105689>>>>>        If (eCodeType=CP_UTF16) Begin
105691>>>>>            Move 0 to ucSource[SizeOfArray(ucSource)]
105692>>>>>            Move 0 to ucSource[SizeOfArray(ucSource)]
105693>>>>>            Move (AddressOf(ucSource)) to pWStr
105694>>>>>        End
105694>>>>>>
105694>>>>>        Else Begin
105695>>>>>            Get MultiToWideBuffer eCodeType (AddressOf(ucSource)) (SizeOfArray(ucSource)) (AddressOf(pWStr)) to bOk
105696>>>>>        End
105696>>>>>>
105696>>>>>        //Initialize vValue variable so it has the correct type and AddressOf will return a proper pointer
105696>>>>>        Move 0 to vValue
105697>>>>>        Move (AddressOf(vValue)) to pvValue
105698>>>>>        //Change the Variant type to VT_BSTR
105698>>>>>        Move (StoreDw(pvValue,0,OLE_VT_Bstr)) to bOk
105699>>>>>        //Allocate a proper COM BSTR, assign the Unicode string, and store the BSTR in the Variant variable
105699>>>>>        Move (StoreDw(pvValue,8,SysAllocString(pWStr))) to bOk
105700>>>>>        //Now clear up the Unicode string, the Variant owns a BSTR copy of the string
105700>>>>>        If (eCodeType<>CP_UTF16) Begin
105702>>>>>            Move (Free(pWStr)) to bOk
105703>>>>>        End
105703>>>>>>
105703>>>>>        Function_Return vValue
105704>>>>>    End_Function
105705>>>>>
105705>>>>>
105705>>>>>    // ==========================================================================================
105705>>>>>    // UChar array conversions. Converts a passed uchar array with from-encoding to
105705>>>>>    // a new UChar array with to-encoding
105705>>>>>    // ==========================================================================================
105705>>>>>    
105705>>>>>    Function ConvertUCharArray UChar[] UCharData Integer iFromCP Integer iToCP Returns UChar[]
105707>>>>>        Address aFromBuf aToBuf
105707>>>>>        Integer iBytes iChars
105707>>>>>        Boolean bOk
105707>>>>>
105707>>>>>        Move (SizeOfArray(UCharData)) to iBytes
105708>>>>>        If (iFromCP=iToCP or iBytes=0) Begin
105710>>>>>            Function_Return UCharData
105711>>>>>        End
105711>>>>>>
105711>>>>>
105711>>>>>        If (iFromCP<>CP_UTF16) Begin
105713>>>>>            Move 0 to UCharData[iBytes] // extend to make sure we have 0 at end
105714>>>>>            Get Utf16FromBuffer (AddressOf(UCharData)) iFromCP (&iChars) to aFromBuf
105715>>>>>        End
105715>>>>>>
105715>>>>>        Else Begin
105716>>>>>            Move (iBytes/2) to iChars // if from is utf16
105717>>>>>        End
105717>>>>>>
105717>>>>>        
105717>>>>>        If (iToCP<>CP_UTF16) Begin
105719>>>>>            If (iFromCP=CP_UTF16) Begin
105721>>>>>                Get Utf16ToBuffer (AddressOf(UCharData)) iToCP iChars to aToBuf
105722>>>>>            End
105722>>>>>>
105722>>>>>            Else Begin
105723>>>>>                Get Utf16ToBuffer aFromBuf iToCP iChars to aToBuf
105724>>>>>                Move (Free(aFromBuf)) to bOk
105725>>>>>            End
105725>>>>>>
105725>>>>>            Move (CStringLength(aToBuf)) to iBytes
105726>>>>>        End
105726>>>>>>
105726>>>>>        Else Begin
105727>>>>>            Move (iChars*2) to iBytes
105728>>>>>            Move aFromBuf to aToBuf
105729>>>>>        End
105729>>>>>>
105729>>>>>        Move (ResizeArray(UCharData,iBytes)) to UCharData
105730>>>>>        Move (MemCopy(AddressOf(UCharData),aToBuf,iBytes)) to bOk
105731>>>>>        Move (Free(aToBuf)) to bOk
105732>>>>>        Function_Return UCharData
105733>>>>>    End_Function
105734>>>>>    
105734>>>>>
105734>>>>>    // ==========================================================================================
105734>>>>>    // Base64 Encoding functions that allow you to encode to and decode from strings and 
105734>>>>>    // Variant strings. Binary data is always buffer
105734>>>>>    // ==========================================================================================
105734>>>>> 
105734>>>>>    Function Base64EncodeToStr Address pBinaryData Integer iBinaryLen Returns String
105736>>>>>        Address pBase64
105736>>>>>        String sResult
105736>>>>>        Integer iVoid iMax
105736>>>>>        Get_Argument_Size to iMax
105737>>>>>        Move (Base64Encode(pBinaryData, iBinaryLen)) to pBase64
105738>>>>>        If (iMax<CStringLength(pBase64)) Begin
105740>>>>>            Error DFERR_PROGRAM "Base64 encoded string exceeds max string size"
105741>>>>>>
105741>>>>>        End
105741>>>>>>
105741>>>>>        Move pBase64 to sResult
105742>>>>>        Move (Free(pBase64)) to iVoid    
105743>>>>>        Function_Return sResult    
105744>>>>>    End_Function
105745>>>>>    
105745>>>>>    Function Base64DecodeFromStr String sBase64 Integer ByRef iBinaryLen Returns Address
105747>>>>>        Address pBinaryData
105747>>>>>        String sBinary
105747>>>>>        Integer iVoid
105747>>>>>        Move (Base64Decode(AddressOf(sBase64), &iBinaryLen)) to pBinaryData
105748>>>>>        Function_Return pBinaryData
105749>>>>>    End_Function
105750>>>>>    
105750>>>>>    Function Base64EncodeToVariantStr Address pBinaryData Integer iBinaryLen Returns Variant
105752>>>>>        Address aBase64
105752>>>>>        Variant vVar
105752>>>>>        Integer iBase64Len iVoid
105752>>>>>        If (pBinaryData and iBinaryLen) Begin
105754>>>>>            Move (Base64Encode(pBinaryData,iBinaryLen)) to aBase64
105755>>>>>            Get  VariantStrFromBuffer aBase64 CP_ACP to vVar
105756>>>>>            Move (Free(aBase64)) to iVoid
105757>>>>>        End
105757>>>>>>
105757>>>>>        Function_Return vVar
105758>>>>>    End_Function
105759>>>>>    
105759>>>>>    Function Base64DecodeFromVariantStr Variant vBase64Str Integer ByRef iBinaryLen Returns Address
105761>>>>>        Address aBase64 pBinaryData
105761>>>>>        Integer iVoid
105761>>>>>        Move 0 to iBinaryLen
105762>>>>>        Get VariantStrToBuffer vBase64Str CP_ACP to aBase64
105763>>>>>        If (aBase64) Begin
105765>>>>>            Move (Base64Decode(aBase64,&iBinaryLen)) to pBinaryData
105766>>>>>            Move (Free(aBase64)) to iVoid
105767>>>>>        End
105767>>>>>>
105767>>>>>        Function_Return pBinaryData
105768>>>>>    End_Function
105769>>>>>
105769>>>>>    // base 64 Encode from Uchar array to a Uchar array
105769>>>>>    Function Base64EncodeUCharArray UChar[] UCharData Returns UChar[]
105771>>>>>        Address aBase64
105771>>>>>        Integer iLen
105771>>>>>        Boolean bOk
105771>>>>>        
105771>>>>>        Move (SizeOfArray(UCharData)) to iLen
105772>>>>>        If (iLen) Begin
105774>>>>>            Move (Base64Encode(AddressOf(UCharData), iLen)) to aBase64
105775>>>>>            Move (CStringLength(aBase64)) to iLen
105776>>>>>            Move (ResizeArray(UCharData,iLen)) to UCharData
105777>>>>>            Move (MemCopy(AddressOf(UCharData),aBase64,iLen)) to bOk
105778>>>>>            Move (Free(aBase64)) to bOk    
105779>>>>>        End
105779>>>>>>
105779>>>>>        Function_Return UCharData    
105780>>>>>    End_Function
105781>>>>>    
105781>>>>>    // base 64 Decode from Uchar array to a Uchar array
105781>>>>>    Function Base64DecodeUCharArray UChar[] UCharData Returns UChar[]
105783>>>>>        Address aData
105783>>>>>        Integer iLen
105783>>>>>        Boolean bOk
105783>>>>>        
105783>>>>>        Move (SizeOfArray(UCharData)) to iLen
105784>>>>>        If (iLen) Begin
105786>>>>>            Move 0 to UCharData[iLen]
105787>>>>>            Move (Base64Decode(AddressOf(UCharData),&iLen)) to aData
105788>>>>>            Move (ResizeArray(UCharData,iLen)) to UCharData
105789>>>>>            Move (MemCopy(AddressOf(UCharData),aData,iLen)) to bOk
105790>>>>>            Move (Free(aData)) to bOk    
105791>>>>>        End
105791>>>>>>
105791>>>>>        Function_Return UCharData
105792>>>>>    End_Function
105793>>>>>
105793>>>>>End_Class
105794>>>>>
105794>>>
105794>>>Struct tFilelistDUF
105794>>>    Integer iFileNumber
105794>>>    String sLogicalName
105794>>>    String sRootName
105794>>>    String sDisplayName
105794>>>End_Struct
105794>>>
105794>>>Activate_View Activate_oUtilFunctions_vw for oUtilFunctions_vw
105804>>>>
105804>>>Object oUtilFunctions_vw is a dbView
105806>>>    Set Border_Style to Border_Thick
105807>>>    Set Size to 268 428
105808>>>    Set Location to 2 1
105809>>>    Set Label to "Utility Functions"
105810>>>    Set pbAutoActivate to True
105811>>>    Set Icon to "TestTools.ico"
105812>>>    Set pbAcceptDropFiles to True
105813>>>
105813>>>    Object oScrollingContainer1 is a cDbScrollingContainer
105815>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
105817>>>
105817>>>            Object oSQL_grp is a Group
105819>>>                Set Size to 88 402
105820>>>                Set Location to 7 12
105821>>>                Set Label to "Run SQL Database Scripts Embedded as Resources"
105822>>>                Set peAnchors to anTopLeftRight
105823>>>
105823>>>                Object oCreateOrderEntry_btn is a cButtonDPI
105825>>>                    Set Size to 14 219
105826>>>                    Set Location to 13 13
105827>>>                    Set Label to "Create New SQL Database [OrderEntry] Complete with Data"
105828>>>                    Set psToolTip to "Creates the full Order Entry Sample database from the DataFlex samples complete with data with the name: [OrderEntry]"
105829>>>                    Set psImage to "ActionCreateDatabase.ico"
105830>>>
105830>>>                    Procedure OnClick
105833>>>                        String sInfoText sDriverID
105833>>>                        Boolean bOK
105833>>>                        TimeSpan tsTotalQueryTime
105833>>>                        Integer iRetval
105833>>>
105833>>>                        // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
105833>>>                        // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
105833>>>                        SQLIncludeScriptFile ..\Scripts\CreateOrderEntry.sql as CreateOrderEntry.sql
105833>>>                        Get YesNo_Box "This will run the 'CreateOrderEntry.sql' script from the 'Script' workspace folder which will create the [OrderEntry] database from the DataFlex samples for Microsoft SQL Server, complete with data. If it exists it will first be dropped, then re-created and populated with new data. Continue?" to iRetval
105834>>>                        If (iRetval <> MBR_Yes) Begin
105836>>>                            Procedure_Return
105837>>>                        End
105837>>>>
105837>>>
105837>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
105838>>>                        If (sDriverID <> MSSQLDRV_ID) Begin
105840>>>                            Send Info_Box "You need to have a Microsoft SQL Server connection active for this to work. Please adjust and try again."
105841>>>                            Procedure_Return
105842>>>                        End
105842>>>>
105842>>>
105842>>>                        Send StartWorkingMessage "Executing SQL Script. Please wait..."
105843>>>                        Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateOrderEntry.sql" MSSQLDRV_ID False to bOK
105844>>>                        Send StopWorkingMessage
105845>>>
105845>>>                        If (bOK = True) Begin
105847>>>                            Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
105848>>>                            Move ("Success! DataFlex Order Entry Sample Database was created as [OrderEntry]. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
105849>>>                        End
105849>>>>
105849>>>
105849>>>                        Else Begin
105850>>>                            Send UtilShowErrorList of ghoDbUpdateFunctionLibrary
105851>>>                            Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
105852>>>                        End
105852>>>>
105852>>>
105852>>>                        Send Info_Box sInfoText
105853>>>                    End_Procedure
105854>>>
105854>>>                End_Object
105855>>>
105855>>>                Object oCreateNorthWind_btn is a cButtonDPI
105857>>>                    Set Size to 14 219
105858>>>                    Set Location to 33 13
105859>>>                    Set Label to "Create New SQL Database [NorthWind] Complete with Data"
105860>>>                    Set psToolTip to "Creates the full NorthWind Sample database from the DataFlex samples complete with data with the name: [NorthWind]"
105861>>>                    Set psImage to "ActionCreateDatabase.ico"
105862>>>
105862>>>                    Procedure OnClick
105865>>>                        String sInfoText sDriverID
105865>>>                        Boolean bOK
105865>>>                        TimeSpan tsTotalQueryTime
105865>>>                        Integer iRetval
105865>>>
105865>>>                        // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
105865>>>                        // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
105865>>>                        SQLIncludeScriptFile ..\Scripts\CreateNorthWindDatabase.sql as CreateNorthWindDatabase.sql
105865>>>
105865>>>                        Get YesNo_Box "This will run the 'CreateNorthWindDatabase.sql' script from the 'Script' workspace folder and it will create the [NorthWind] sample database in Microsoft SQL Server, complete with data. If it exists it will first be dropped, then re-created and populated with new data. Continue?" to iRetval
105866>>>                        If (iRetval <> MBR_Yes) Begin
105868>>>                            Procedure_Return
105869>>>                        End
105869>>>>
105869>>>
105869>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
105870>>>                        If (sDriverID <> MSSQLDRV_ID) Begin
105872>>>                            Send Info_Box "You need to have a Microsoft SQL Server connection active for this to work. Please adjust and try again."
105873>>>                            Procedure_Return
105874>>>                        End
105874>>>>
105874>>>
105874>>>                        Send StartWorkingMessage "Executing SQL Script. Please wait..."
105875>>>                        Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateNorthWindDatabase.sql" MSSQLDRV_ID False to bOK
105876>>>                        Send StopWorkingMessage
105877>>>
105877>>>                        If (bOK = True) Begin
105879>>>                            Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
105880>>>                            Move ("Success! The Northwind Sample Database was created as [NorthWind]. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
105881>>>                        End
105881>>>>
105881>>>
105881>>>                        Else Begin
105882>>>                            Send UtilShowErrorList of ghoDbUpdateFunctionLibrary
105883>>>                            Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
105884>>>                        End
105884>>>>
105884>>>
105884>>>                        Send Info_Box sInfoText
105885>>>                    End_Procedure
105886>>>
105886>>>                End_Object
105887>>>
105887>>>                Object oCreateFullChinookDatabase_btn is a cButtonDPI
105889>>>                    Set Size to 14 219
105890>>>                    Set Location to 53 13
105891>>>                    Set Label to "Create New SQL Database [Chinook] Complete with Data"
105892>>>                    Set psToolTip to "Creates the Chinook demo database complete with data in Microsoft SQL Server. Note: If it exists it will first be dropped then recreated. Note: These scripts were part of Data Access Europe's '' training class."
105893>>>                    Set psImage to "ActionCreateDatabase.ico"
105894>>>
105894>>>                    Procedure OnClick
105897>>>                        String sInfoText sDriverID
105897>>>                        Boolean bOK
105897>>>                        TimeSpan tsTotalQueryTime
105897>>>                        Integer iRetval
105897>>>
105897>>>                        // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
105897>>>                        // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
105897>>>                        SQLIncludeScriptFile ..\Scripts\CreateChinookDatabase.sql as CreateChinookDatabase.sql
105897>>>
105897>>>                        Get YesNo_Box "This will run the 'CreateChinookDatabase.sql' script from the 'Script' workspace folder which will create the [Chinook] sample database complete with data. If it exists it will first be dropped, then re-created and populated with new data.\n\nContinue?" to iRetval
105898>>>                        If (iRetval <> MBR_Yes) Begin
105900>>>                            Procedure_Return
105901>>>                        End
105901>>>>
105901>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
105902>>>                        If (sDriverID <> MSSQLDRV_ID) Begin
105904>>>                            Send Info_Box "You need to have a Microsoft SQL Server connection active for this to work. Please adjust and try again."
105905>>>                            Procedure_Return
105906>>>                        End
105906>>>>
105906>>>
105906>>>                        Send StartWorkingMessage "Executing SQL Script. Please wait..."
105907>>>
105907>>>                        Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateChinookDatabase.sql" MSSQLDRV_ID False to bOK
105908>>>
105908>>>                        Send StopWorkingMessage
105909>>>                        If (bOK = True) Begin
105911>>>                            Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
105912>>>                            Move ("Success! The script was run OK. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
105913>>>                        End
105913>>>>
105913>>>
105913>>>                        Else Begin
105914>>>                            Send UtilShowErrorList of ghoDbUpdateFunctionLibrary
105915>>>                            Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
105916>>>                        End
105916>>>>
105916>>>
105916>>>                        Send Info_Box sInfoText
105917>>>                    End_Procedure
105918>>>
105918>>>                End_Object
105919>>>
105919>>>                Object oInfo_tb is a TextBox
105921>>>                    Set Auto_Size_State to False
105922>>>                    Set Size to 25 158
105923>>>                    Set Location to 53 238
105924>>>                    Set Label to "Note: The Chinook script was provided by Data Access Europe as part of their 'Web Touch Training' course."
105925>>>                    Set Justification_Mode to JMode_Left
105926>>>                    Set peAnchors to anTopLeftRight
105927>>>                End_Object
105928>>>
105928>>>        //  This will choke the computer so don't try it!
105928>>>        //        Object oCreateAdventureWorksDatabase_btn is a cButtonDPI
105928>>>        //            Set Size to 14 312
105928>>>        //            Set Location to 97 45
105928>>>        //            Set Label to "Create [AdventureWorks] Database and Populate with Data"
105928>>>        //            Set psToolTip to "Creates the Adenture Works database complete with data in Microsoft SQL Server. Note: If it exists it will first be dropped then recreated."
105928>>>        //
105928>>>        //            Procedure OnClick
105928>>>        //                String sInfoText
105928>>>        //                Boolean bOK
105928>>>        //                TimeSpan tsTotalQueryTime
105928>>>        //                Integer iRetval
105928>>>        //
105928>>>        //                // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
105928>>>        //                // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
105928>>>        ////                SQLIncludeScriptFile ..\Scripts\CreateAdventureWorks.sql as CreateAdventureWorks.sql
105928>>>        //Procedure_Return
105928>>>        //                Get YesNo_Box "This will create the [AdventurWorks] sample database complete with data. If it exists it will first be dropped, then re-created and populated with new data.\n\nContinue?" to iRetval
105928>>>        //                If (iRetval <> MBR_Yes) Begin
105928>>>        //                    Procedure_Return
105928>>>        //                End
105928>>>        //
105928>>>        //                Send StartWorkingMessage "Executing SQL Script. Please wait..."
105928>>>        //                Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateAdventureWorks.sql" MSSQLDRV_ID False to bOK
105928>>>        //                Send StopWorkingMessage
105928>>>        //
105928>>>        //                If (bOK = True) Begin
105928>>>        //                    Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
105928>>>        //                    Move ("Success! The script was run OK. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
105928>>>        //                End
105928>>>        //
105928>>>        //                Else Begin
105928>>>        //                    Send UtilShowErrorList of ghoDbUpdateFunctionLibrary
105928>>>        //                    Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
105928>>>        //                End
105928>>>        //
105928>>>        //                Send Info_Box sInfoText
105928>>>        //            End_Procedure
105928>>>        //
105928>>>        //        End_Object
105928>>>
105928>>>            End_Object
105929>>>
105929>>>            Object oChangeIntFiles_grp is a Group
105931>>>                Set Size to 65 402
105932>>>                Set Location to 102 12
105933>>>                Set Label to "Change Old .int files to use Connection ID's"
105934>>>                Set peAnchors to anTopLeftRight
105935>>>
105935>>>                Object oSelectDataPath_fm is a Form
105937>>>                    Set Size to 13 300
105938>>>                    Set Location to 22 13
105939>>>                    Set Label to "Select path to a Data folder with .int files (Select one '.int' file):"
105940>>>                    Set Label_Col_Offset to 0
105941>>>                    Set Label_Row_Offset to 1
105942>>>                    Set Label_Justification_Mode to JMode_Top
105943>>>
105943>>>                    // This is very strange but for some reason the tooltip is _not_ displayed if PB_PromptOn is set...
105943>>>        //            Set Prompt_Button_Mode to PB_PromptOn
105943>>>                    Set psToolTip to "You can use this if you have .int files that currently have content like; 'SERVER=xxx; DATABASE=yyy' et.al. and you need to change them to use a connection ID like; 'SERVER_NAME DFCONNID=MyConnID'"
105944>>>                    Set peAnchors to anTopLeftRight
105945>>>
105945>>>                    Procedure Prompt
105948>>>                        String sPath sFileMask sRetval
105948>>>
105948>>>                        Get psDataPathFirstPart to sPath
105949>>>                        Move "Database intermediate files (*.int)|*.int" to sFileMask
105950>>>                        Get vSelect_File sFileMask "Please select an .int file from the data folder" sPath to sRetval
105951>>>                        If (sRetval <> "") Begin
105953>>>                            Get ParseFolderName sRetval to sPath
105954>>>                            If (Right(sPath, 1) ="\") Begin
105956>>>                                Move (Left(sPath, Length(sPath) -1)) to sPath
105957>>>                            End
105957>>>>
105957>>>                            Set Value to sPath
105958>>>                        End
105958>>>>
105958>>>                    End_Procedure
105959>>>
105959>>>                    // Returns the first datapath found in the psDataPath property.
105959>>>                    // The returned path always ends with a "\"
105959>>>                    Function psDataPathFirstPart Returns String
105962>>>                        String sDataPath
105962>>>                        Integer iCount
105962>>>
105962>>>                        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
105963>>>                        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
105964>>>                        If (iCount > 1) Begin
105966>>>                            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
105967>>>                        End
105967>>>>
105967>>>                        If (sDataPath <> "") Begin
105969>>>                            Get vFolderFormat sDataPath to sDataPath
105970>>>                        End
105970>>>>
105970>>>
105970>>>                        Function_Return sDataPath
105971>>>                    End_Function
105972>>>
105972>>>                End_Object
105973>>>
105973>>>                Object oSelectFolder_btn is a cButtonDPI
105975>>>                    Set Size to 13 73
105976>>>                    Set Location to 22 320
105977>>>                    Set Label to "Select Folder"
105978>>>                    Set psToolTip to "Please select an .int file from the data folder"
105979>>>                    Set peAnchors to anTopRight
105980>>>                    Set psImage to "ActionOpen.ico"
105981>>>
105981>>>                    Procedure OnClick
105984>>>                        Send Prompt to oSelectDataPath_fm
105985>>>                    End_Procedure
105986>>>
105986>>>                End_Object
105987>>>
105987>>>                Object oConnectionID_fm is a Form
105989>>>                    Set Size to 13 111
105990>>>                    Set Location to 38 202
105991>>>                    Set Label_Col_Offset to 2
105992>>>                    Set Label_Justification_Mode to JMode_Right
105993>>>                    Set Label to "Change to DFConnID:"
105994>>>                    Set psToolTip to "Please enter your Connection ID (DFCONNID=) that should replace the SERVER_NAME settings for all .int files in the selected folder."
105995>>>                    Set peAnchors to anTopRight
105996>>>                End_Object
105997>>>
105997>>>                Object oChangeAllIntFiles_btn is a cButtonDPI
105999>>>                    Set Size to 13 65
106000>>>                    Set Location to 38 320
106001>>>                    Set Label to "GO !"
106002>>>                    Set psToolTip to "Changes or updates all .int files in the selected folder - except for DAW driver .int files (MSSQL_DRV.int, DB2_DRV.int & ODBC_DRV.int) - to use 'SERVER_NAME DFCONNID=xxx'"
106003>>>                    Set FontWeight to fw_Bold
106004>>>                    Set peAnchors to anTopRight
106005>>>
106005>>>                    Procedure OnClick
106008>>>                        String sDataPath sConnectionID
106008>>>                        Boolean bExists bActive
106008>>>                        Integer iRetval
106008>>>
106008>>>                        Get Value of oSelectDataPath_fm to sDataPath
106009>>>                        Get vFolderExists sDataPath to bExists
106010>>>                        If (bExists = False) Begin
106012>>>                            Send Info_Box ("The data folder doesn't exist!\n" + sDataPath)
106013>>>                            Procedure_Return
106014>>>                        End
106014>>>>
106014>>>                        Get Value of oConnectionID_fm to sConnectionID
106015>>>                        Move (Trim(sConnectionID)) to sConnectionID
106016>>>                        If (sConnectionID = "") Begin
106018>>>                            Send Info_Box "You need to specify a Connection_ID to use for the .int files."
106019>>>                            Procedure_Return
106020>>>                        End
106020>>>>
106020>>>
106020>>>                        Get YesNo_Box ("Do you want to change all .int files in folder:\n" + sDataPath + "\n\nTo use 'DFCONNID=" + sConnectionID +"' ?") to iRetval
106021>>>                        If (iRetval <> MBR_Yes) Begin
106023>>>                            Procedure_Return
106024>>>                        End
106024>>>>
106024>>>                        Get YesNo_Box "All '.CCH' files will first be deleted. Continue?" to iRetval
106025>>>                        If (iRetval <> MBR_Yes) Begin
106027>>>                            Procedure_Return
106028>>>                        End
106028>>>>
106028>>>
106028>>>                        Get vDeleteFile (sDataPath + "\*.cch") to iRetval
106029>>>                        If (iRetval <> 0) Begin
106031>>>                            Send Info_Box "Could not delete .cch files!"
106032>>>                            Procedure_Return
106033>>>                        End
106033>>>>
106033>>>
106033>>>                        Send Initialize_StatusPanel of ghoStatusPanel "The Database Update Framework" "Changing Connection ID's in .int files" ""
106034>>>                        Send Start_StatusPanel of ghoStatusPanel
106035>>>                        Send SqlUtilChangeIntFilesToConnectionIDs of ghoDbUpdateFunctionLibrary sDataPath sConnectionID True
106036>>>
106036>>>                        Get Active_State of ghoStatusPanel to bActive
106037>>>                        If (bActive = False) Begin
106039>>>                            Send Info_Box "Process interupted..."
106040>>>                        End
106040>>>>
106040>>>                        Else Begin
106041>>>                            Send Stop_StatusPanel of ghoStatusPanel
106042>>>                            Send Info_Box "Ready! All .int files changed."
106043>>>                        End
106043>>>>
106043>>>                    End_Procedure
106044>>>
106044>>>                End_Object
106045>>>
106045>>>            End_Object
106046>>>
106046>>>            Object oRemoveFilelistDriverIDs_grp is a Group
106048>>>                Set Size to 82 402
106049>>>                Set Location to 175 12
106050>>>                Set Label to "Remove Database Identifications"
106051>>>                Set peAnchors to anAll
106052>>>//                Set TextColor to clGreen
106052>>>//
106052>>>//                Procedure Page Integer iPage
106052>>>//                    Integer ia iz
106052>>>//                    Forward Send Page iPage
106052>>>//                    Move 0 to iz
106052>>>//                    Move (AddressOf(iz)) to ia
106052>>>//                    Move (SetWindowTheme(Window_Handle(Self),ia,ia)) to iPage
106052>>>//                End_Procedure
106052>>>
106052>>>                Object oFilelistPath_fm is a Form
106054>>>                    Set Size to 13 299
106055>>>                    Set Location to 22 13
106056>>>                    Set Label to "Path and Filelist.cfg Name:"
106057>>>                    Set Label_Col_Offset to 0
106058>>>                    Set Label_Row_Offset to 1
106059>>>                    Set Label_Justification_Mode to JMode_Top
106060>>>
106060>>>                    // This is very strange but for some reason the tooltip is _not_ displayed if PB_PromptOn is set...
106060>>>        //            Set Prompt_Button_Mode to PB_PromptOn
106060>>>                    Set psToolTip to "You can use this if you have entries in a Filelist.cfg with driver prefixes like 'MSSQLDRV;Customer' and you need to remove them all."
106061>>>                    Set peAnchors to anTopLeftRight
106062>>>
106062>>>                    Procedure Prompt
106065>>>                        String sFileName sPath sFileMask sRetval
106065>>>
106065>>>                        Get Value to sFileName
106066>>>                        Get ParseFolderName sFileName to sPath
106067>>>                        Move "Filelist.cfg files (*.cfg)|*.cfg" to sFileMask
106068>>>                        Get vSelect_File sFileMask "Please select a Filelist.cft file" sPath to sRetval
106069>>>                        If (sRetval <> "") Begin
106071>>>                            Set Value to sRetval
106072>>>                            Set_Attribute DF_FILELIST_NAME to sRetval
106075>>>                        End
106075>>>>
106075>>>                    End_Procedure
106076>>>
106076>>>                    Procedure OnCreate
106079>>>                        String sFilelist
106079>>>                        Get_Attribute DF_FILELIST_NAME to sFilelist
106082>>>                        Set Value to sFilelist
106083>>>                    End_Procedure
106084>>>                    Send OnCreate
106085>>>
106085>>>                End_Object
106086>>>
106086>>>                Object oSelectFilelist_btn is a cButtonDPI
106088>>>                    Set Size to 13 73
106089>>>                    Set Location to 22 319
106090>>>                    Set Label to "Select Filelist.cfg"
106091>>>                    Set psToolTip to "Please select a Filelist.cfg file to be changed"
106092>>>                    Set peAnchors to anTopRight
106093>>>
106093>>>                    Procedure OnClick
106096>>>                        Send Prompt to oFilelistPath_fm
106097>>>                    End_Procedure
106098>>>
106098>>>                End_Object
106099>>>
106099>>>                Object oInfo_tb is a TextBox
106101>>>                    Set Size to 9 207
106102>>>                    Set Location to 40 138
106103>>>                    Set Label to "Remove ALL database identifications from Filelist.cfg:"
106104>>>                    Set peAnchors to anTopRight
106105>>>                End_Object
106106>>>
106106>>>                Object oChangeFilelist_btn is a cButtonDPI
106108>>>                    Set Size to 13 65
106109>>>                    Set Location to 38 319
106110>>>                    Set Label to "GO !"
106111>>>                    Set FontWeight to fw_Bold
106112>>>                    Set peAnchors to anTopRight
106113>>>
106113>>>                    Procedure OnClick
106116>>>                        String sFileList
106116>>>                        Integer iRetval iCount
106116>>>                        Boolean bExits
106116>>>
106116>>>                        Get Value of oFilelistPath_fm to sFileList
106117>>>                        Get vFilePathExists sFileList to bExits
106118>>>                        If (bExits = False) Begin
106120>>>                            Send Info_Box ("Sorry, the Filelist.cfg does not exist;\n" + sFileList)
106121>>>                            Procedure_Return
106122>>>                        End
106122>>>>
106122>>>
106122>>>                        Get YesNo_Box ("Are you sure you want to remove all driver identifications for the following Filelist.cfg?\n" + sFileList) to iRetval
106123>>>                        If (iRetval <> MBR_Yes) Begin
106125>>>                            Procedure_Return
106126>>>                        End
106126>>>>
106126>>>                        Send Cursor_Wait of Cursor_Control
106127>>>
106127>>>                        Get SqlUtilFilelistRemoveDriverInfo of ghoDbUpdateFunctionLibrary sFileList to iCount
106128>>>
106128>>>                        Send Cursor_Ready of Cursor_Control
106129>>>                        If (iCount <> 0) Begin
106131>>>                            Send Info_Box ("Ready!" * String(iCount) * "Filelist entries adjusted.")
106132>>>                        End
106132>>>>
106132>>>                        Else Begin
106133>>>                            Send Info_Box "Ready. No driver based Filelist entries found."
106134>>>                        End
106134>>>>
106134>>>
106134>>>                    End_Procedure
106135>>>
106135>>>                End_Object
106136>>>
106136>>>                Object oPrintFilelist_btn is a cButtonDPI
106138>>>                    Set Size to 14 76
106139>>>                    Set Location to 61 307
106140>>>                    Set Label to "Print Filelist.cfg"
106141>>>                    Set psToolTip to "Writes the content of Filelist.cfg to a textfile and shows the textfile in Notepad."
106142>>>                    Set psImage to "ActionDocument.ico"
106143>>>
106143>>>                    Property Integer piSortOrder 0 // Property gets set by the radio group object.
106145>>>
106145>>>                    // Custom array sort function.
106145>>>                    // iSortOrder = 0 -> Filelist number order
106145>>>                    // iSortOrder = 1 -> Logical name order
106145>>>                    // iSortOrder = 2 -> Root name order
106145>>>                    // iSortOrder = 3 -> Display name order
106145>>>                    Function CompareSortFilelist tFilelistDUF FilelistDUF1 tFilelistDUF FilelistDUF2 Returns Integer
106148>>>                        Integer iSortOrder
106148>>>
106148>>>                        Get piSortOrder to iSortOrder
106149>>>
106149>>>                        Case Begin
106149>>>                            Case (iSortOrder = 0)
106151>>>                                If (FilelistDUF1.iFileNumber  > FilelistDUF2.iFileNumber) Begin
106153>>>                                    Function_Return (GT)
106154>>>                                End
106154>>>>
106154>>>                                If (FilelistDUF1.iFileNumber  < FilelistDUF2.iFileNumber) Begin
106156>>>                                    Function_Return (LT)
106157>>>                                End
106157>>>>
106157>>>                                Function_Return (EQ)
106158>>>                            Case (iSortOrder = 1)
106161>>>                                If (Uppercase(FilelistDUF1.sLogicalName) > Uppercase(FilelistDUF2.sLogicalName)) Begin
106163>>>                                    Function_Return (GT)
106164>>>                                End
106164>>>>
106164>>>                                If (Uppercase(FilelistDUF1.sLogicalName) < Uppercase(FilelistDUF2.sLogicalName)) Begin
106166>>>                                    Function_Return (LT)
106167>>>                                End
106167>>>>
106167>>>                                Function_Return (EQ)
106168>>>                            Case (iSortOrder = 2)
106171>>>                                If (Uppercase(FilelistDUF1.sRootName)    > Uppercase(FilelistDUF2.sRootName)) Begin
106173>>>                                    Function_Return (GT)
106174>>>                                End
106174>>>>
106174>>>                                If (Uppercase(FilelistDUF1.sRootName)    < Uppercase(FilelistDUF2.sRootName)) Begin
106176>>>                                    Function_Return (LT)
106177>>>                                End
106177>>>>
106177>>>                                Function_Return (EQ)
106178>>>                            Case (iSortOrder = 3)
106181>>>                                If (Uppercase(FilelistDUF1.sDisplayName) > Uppercase(FilelistDUF2.sDisplayName)) Begin
106183>>>                                    Function_Return (GT)
106184>>>                                End
106184>>>>
106184>>>                                If (Uppercase(FilelistDUF1.sDisplayName) < Uppercase(FilelistDUF2.sDisplayName)) Begin
106186>>>                                    Function_Return (LT)
106187>>>                                End
106187>>>>
106187>>>                                Function_Return (EQ)
106188>>>                        Case End
106188>>>
106188>>>                    End_Function
106189>>>
106189>>>                    Procedure OnClick
106192>>>                        String sFileList sRootName sLogicalName sDisplayName sPath sOutputName sTable sExt
106192>>>                        Integer iCh iCount iSize
106192>>>                        Handle hTable
106192>>>                        tFilelistDUF[] FilelistDUFArray FilelistDUFSorted
106192>>>                        tFilelistDUF[] FilelistDUFArray FilelistDUFSorted
106194>>>
106194>>>                        Get Value of oFilelistPath_fm to sFileList
106195>>>                        Move (Trim(sFileList)) to sFileList
106196>>>                        If (sFileList = "") Begin
106198>>>                            Send Info_Box "You need to select a Filelist.cfg file first"
106199>>>                            Procedure_Return
106200>>>                        End
106200>>>>
106200>>>
106200>>>                        Get ParseFolderName sFileList to sPath
106201>>>                        Get vFolderFormat sPath to sPath
106202>>>                        Get ParseFileName sFileList to sOutputName
106203>>>                        Get ParseFileExtension sFileList to sExt
106204>>>                        Move (Replace(sExt, sOutputName, "")) to sOutputName
106205>>>                        Move (sOutputName + "txt")           to sOutputName
106206>>>                        Get Seq_Open_Output_Channel (sPath + sOutputName) to iCh
106207>>>                        If (iCh < 0) Begin
106209>>>                            Procedure_Return
106210>>>                        End
106210>>>>
106210>>>
106210>>>                        Move 0 to hTable
106211>>>                        Writeln channel iCh sFileList
106214>>>                        Writeln channel iCh "[Table No:]            [LogicalName:]        [RootName:]                             [DisplayName:]"
106217>>>                        Writeln channel iCh "==================================================================================================="
106220>>>                        Writeln channel iCh
106222>>>
106222>>>                        Move 0 to iCount
106223>>>                        Repeat
106223>>>>
106223>>>                            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
106226>>>                            If (hTable > 0) Begin
106228>>>                                Move hTable                                  to FilelistDUFArray[iCount].iFileNumber
106229>>>                                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to FilelistDUFArray[iCount].sLogicalName
106232>>>                                Get_Attribute DF_FILE_ROOT_NAME    of hTable to FilelistDUFArray[iCount].sRootName
106235>>>                                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to FilelistDUFArray[iCount].sDisplayName
106238>>>                                Increment iCount
106239>>>                            End
106239>>>>
106239>>>                        Until (hTable = 0)
106241>>>
106241>>>                        Move (SortArray(FilelistDUFArray, Self, (RefFunc(CompareSortFilelist)))) to FilelistDUFSorted
106242>>>                        Move (SizeOfArray(FilelistDUFSorted)) to iSize
106243>>>                        Decrement iSize
106244>>>
106244>>>                        For iCount from 0 to iSize
106250>>>>
106250>>>                            Move FilelistDUFSorted[iCount].iFileNumber  to hTable
106251>>>                            Move FilelistDUFSorted[iCount].sLogicalName to sLogicalName
106252>>>                            Move FilelistDUFSorted[iCount].sRootName    to sRootName
106253>>>                            Move FilelistDUFSorted[iCount].sDisplayName to sDisplayName
106254>>>
106254>>>                            Get PadLeft (String(hTable))        09 to sTable
106255>>>                            Get PadLeft (String(sLogicalName)) (27 - Length(sTable))       to sLogicalName
106256>>>                            Get PadLeft (String(sRootName))    (46 - Length(sLogicalName)) to sRootName
106257>>>                            Get PadLeft (String(sDisplayName)) (72 - Length(sRootName))    to sDisplayName
106258>>>
106258>>>                            Writeln channel iCh sTable (ToANSI(sRootName)) (ToANSI(sLogicalName)) (ToANSI(sDisplayName))
106264>>>                        Loop
106265>>>>
106265>>>
106265>>>                        Writeln channel iCh "==================================================================================================="
106268>>>                        Writeln channel iCh "Total Number of Tables in Filelist.cfg: " (iSize + 1)
106272>>>                        Close_Output
106273>>>
106273>>>                        Send vShellExecute "open" sOutputName "" sPath
106274>>>                    End_Procedure
106275>>>
106275>>>                    Function PadLeft String sString Integer iLength String sOptChar Returns String
106278>>>                        String sChar
106278>>>
106278>>>                        If (Num_Arguments >= 3) Begin
106280>>>                            Move sOptChar to sChar
106281>>>                        End
106281>>>>
106281>>>                        Else Begin
106282>>>                            Move " " to sChar
106283>>>                        End
106283>>>>
106283>>>
106283>>>                        While (Length(sString) < iLength)
106287>>>                            Move (sChar + sString) to sString
106288>>>                        Loop
106289>>>>
106289>>>
106289>>>                        Function_Return sString
106290>>>                    End_Function
106291>>>
106291>>>                End_Object
106292>>>
106292>>>                Object oOutput_rg is a RadioGroup
106294>>>                    Set Location to 53 13
106295>>>                    Set Size to 25 288
106296>>>                    Set Label to "Filelist Output Order"
106297>>>
106297>>>                    Object oRadio1 is a Radio
106299>>>                        Set Label to "Filelist Number"
106300>>>                        Set Size to 10 61
106301>>>                        Set Location to 10 7
106302>>>                    End_Object
106303>>>
106303>>>                    Object oRadio2 is a Radio
106305>>>                        Set Label to "Logical Name"
106306>>>                        Set Size to 10 61
106307>>>                        Set Location to 10 77
106308>>>                    End_Object
106309>>>
106309>>>                    Object oRadio3 is a Radio
106311>>>                        Set Label to "Root Name"
106312>>>                        Set Size to 10 61
106313>>>                        Set Location to 10 147
106314>>>                    End_Object
106315>>>
106315>>>                    Object oRadio4 is a Radio
106317>>>                        Set Label to "Display Name"
106318>>>                        Set Size to 10 62
106319>>>                        Set Location to 10 213
106320>>>                    End_Object
106321>>>
106321>>>                    Procedure Notify_Select_State Integer iToItem Integer iFromItem
106324>>>                        Forward Send Notify_Select_State iToItem iFromItem
106326>>>                        Set piSortOrder of oPrintFilelist_btn to iToItem
106327>>>                    End_Procedure
106328>>>
106328>>>                End_Object
106329>>>
106329>>>            End_Object
106330>>>
106330>>>        End_Object
106331>>>
106331>>>    End_Object
106332>>>
106332>>>    Procedure OnFileDropped String sFilename Boolean bLast
106335>>>        String sTest
106335>>>        Forward Send OnFileDropped sFilename bLast
106337>>>        If (bLast = True) Begin
106339>>>            Get ParseFileName sFilename to sTest
106340>>>            If (Uppercase(sTest) <> "FILELIST.CFG") Begin
106342>>>                Send Info_Box "Sorry, only Filist.cfg files can be dropped here..."
106343>>>                Procedure_Return
106344>>>            End
106344>>>>
106344>>>            Set Value of oFilelistPath_fm to sFilename
106345>>>        End
106345>>>>
106345>>>    End_Procedure
106346>>>
106346>>>End_Object
106347>
106347>        Procedure Activate_About
106350>            Send DoAbout "" "" ("Copyright 2016-2018" * psCompany(ghoApplication)) "Author: Nils Svedmyr" "DbUpdateFrameworkDF19.bmp" "E-mail: mailto:support@rdctools.com" "Web-site: www.rdctools.com"
106351>        End_Procedure
106352>
106352>        On_Key Key_Ctrl+Key_Tab           Send Switch_Prior_View
106353>        On_Key Key_Ctrl+Key_Shift+Key_Tab Send Switch_Next_View
106354>        On_Key Key_Ctrl+Key_W             Send Close_Panel
106355>    End_Object
106356>
106356>    // Note that we have overriden the cHtmlHelp "GetHelpFile" function
106356>    // in the oHtmlHelp object, so we need to explitetly send the message
106356>    // to that object.
106356>    Procedure ShowProgramHelp
106359>        Send DoDisplayKeyword of oHtmlHelp "DbUpdateFrameworkTests" //"cDbUpdateFunctionLibrary"
106360>    End_Procedure
106361>
106361>    On_Key Key_F1 Send ShowProgramHelp
106362>End_Object
106363>
106363>// We do this to activate the first view:
106363>Send Activate_oSQLConnections_vw of (Client_Id(phoMainPanel(ghoApplication)))
106364>Start_UI
106365>
Including Resources...
Summary
Memory Available: 2147483646
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 55562
Total Resources: 7
Total Commands : 106364
Total Windows  : 1
Total Pages    : 1
Static Data    : 805567
Message area   : 665710
Total Blocks   : 77519
