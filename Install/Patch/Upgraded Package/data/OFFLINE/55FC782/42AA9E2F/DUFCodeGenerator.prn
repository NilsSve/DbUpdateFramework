Compiling Program: C:\Projects\DF18\DbUpdateFramework\AppSrc\DUFCodeGenerator.src
Memory Available: 2147483646
1>Use DFAllEnt.pkg
Using pre-compiled package DFALLENT.PKG
Including file: dfallent.pkd    (C:\Program Files (x86)\DataFlex 19.0\Pkg\dfallent.pkd)
79228>Use cCJStandardCommandBarSystem.pkg
Including file: cCJStandardCommandBarSystem.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJStandardCommandBarSystem.pkg)
79228>>>// these are all the packages used in a standard MDI menubar/toolbar system
79228>>>
79228>>>Use cCJCommandBarSystem.pkg
79228>>>Use cCJStandardMenuItemClasses.pkg
Including file: cCJStandardMenuItemClasses.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJStandardMenuItemClasses.pkg)
79228>>>>>Use Dfpanel.pkg
79228>>>>>Use cCJCommandBarSystem.pkg
79228>>>>>Use LanguageText.pkg
79228>>>>>
79228>>>>>
79228>>>>>Class cCJUndoMenuItem is a cCJMenuItem
79229>>>>>    
79229>>>>>    Procedure Construct_Object
79231>>>>>        Forward Send Construct_Object
79233>>>>>        Set psCaption   to C_$CaptionUndo
79234>>>>>        Set psToolTip to C_$ToolTipUndo
79235>>>>>        Set psDescription to C_$DescUndo
79236>>>>>        Set psImage to "ActionUndo.ico"
79237>>>>>        Set pbActiveUpdate to True
79238>>>>>        Set psCategory to C_$CategoryEdit
79239>>>>>        Set psShortcut to C_$Key_Ctrl_Z
79240>>>>>    End_Procedure
79241>>>>>
79241>>>>>    Procedure OnExecute Variant vCommandBarControl
79243>>>>>        Send Undo of (focus(Self))
79244>>>>>    End_Procedure
79245>>>>>    
79245>>>>>    Function IsEnabled Returns Boolean
79247>>>>>        Boolean bEnabled
79247>>>>>        Get CanUndo of (Focus(Self)) to bEnabled
79248>>>>>        Function_Return bEnabled
79249>>>>>    End_Function
79250>>>>>         
79250>>>>>End_Class
79251>>>>>
79251>>>>>
79251>>>>>Class cCJDeleteEditMenuItem is a cCJMenuItem
79252>>>>>    
79252>>>>>    Procedure Construct_Object
79254>>>>>        Forward Send Construct_Object
79256>>>>>        Set psCaption   to C_$CaptionDelete
79257>>>>>        Set psToolTip to C_$ToolTipDelete
79258>>>>>        Set psDescription to C_$DescDelete
79259>>>>>        Set psImage to "actionDelete.ico"
79260>>>>>        Set psShortcut to C_$Key_Delete
79261>>>>>        Set pbActiveUpdate to True
79262>>>>>        Set psCategory to C_$CategoryEdit
79263>>>>>    End_Procedure
79264>>>>>
79264>>>>>
79264>>>>>    Procedure OnExecute Variant vCommandBarControl
79266>>>>>        Send Delete of (focus(Self))
79267>>>>>    End_Procedure
79268>>>>>    
79268>>>>>    Function IsEnabled Returns Boolean
79270>>>>>        Boolean bEnabled
79270>>>>>        Get CanDelete of (Focus(Self)) to bEnabled
79271>>>>>        Function_Return bEnabled
79272>>>>>    End_Function
79273>>>>>         
79273>>>>>End_Class
79274>>>>>
79274>>>>>
79274>>>>>Class cCJCutMenuItem is a cCJMenuItem
79275>>>>>    
79275>>>>>    Procedure Construct_Object
79277>>>>>        Forward Send Construct_Object
79279>>>>>        Set psCaption   to C_$CaptionCut
79280>>>>>        Set psToolTip to C_$TooltipCut
79281>>>>>        Set psDescription to C_$DescCut
79282>>>>>        Set psImage to "actionCut.ico"
79283>>>>>        Set psShortcut to C_$Key_Ctrl_X
79284>>>>>        Set pbActiveUpdate to True
79285>>>>>        Set psCategory to C_$CategoryEdit
79286>>>>>    End_Procedure
79287>>>>>
79287>>>>>
79287>>>>>    Procedure OnExecute Variant vCommandBarControl
79289>>>>>        Send Cut of (focus(Self))
79290>>>>>    End_Procedure
79291>>>>>    
79291>>>>>    Function IsEnabled Returns Boolean
79293>>>>>        Boolean bEnabled
79293>>>>>        Get CanCut of (Focus(Self)) to bEnabled
79294>>>>>        Function_Return bEnabled
79295>>>>>    End_Function
79296>>>>>         
79296>>>>>End_Class
79297>>>>>
79297>>>>>
79297>>>>>Class cCJCopyMenuItem is a cCJMenuItem
79298>>>>>    
79298>>>>>    Procedure Construct_Object
79300>>>>>        Forward Send Construct_Object
79302>>>>>        Set psCaption   to C_$CaptionCopy
79303>>>>>        Set psToolTip to C_$ToolTipCopy
79304>>>>>        Set psDescription to C_$DescCopy
79305>>>>>        Set psImage to "actionCopy.ico"
79306>>>>>        Set psShortcut to C_$Key_Ctrl_C
79307>>>>>        Set pbActiveUpdate to True
79308>>>>>        Set psCategory to C_$CategoryEdit
79309>>>>>    End_Procedure
79310>>>>>
79310>>>>>
79310>>>>>    Procedure OnExecute Variant vCommandBarControl
79312>>>>>        Send Copy of (focus(Self))
79313>>>>>    End_Procedure
79314>>>>>    
79314>>>>>    Function IsEnabled Returns Boolean
79316>>>>>        Boolean bEnabled
79316>>>>>        Get CanCopy of (Focus(Self)) to bEnabled
79317>>>>>        Function_Return bEnabled
79318>>>>>    End_Function
79319>>>>>         
79319>>>>>End_Class
79320>>>>>
79320>>>>>
79320>>>>>Class cCJPasteMenuItem is a cCJMenuItem
79321>>>>>    
79321>>>>>    Procedure Construct_Object
79323>>>>>        Forward Send Construct_Object
79325>>>>>        Set psCaption   to C_$CaptionPaste
79326>>>>>        Set psToolTip to C_$ToolTipPaste
79327>>>>>        Set psDescription to C_$DescPaste
79328>>>>>        Set psImage to "actionPaste.ico"
79329>>>>>        Set pbActiveUpdate to True
79330>>>>>        Set psShortcut to C_$Key_Ctrl_V
79331>>>>>        Set psCategory to C_$CategoryEdit
79332>>>>>    End_Procedure
79333>>>>>
79333>>>>>
79333>>>>>    Procedure OnExecute Variant vCommandBarControl
79335>>>>>        Send Paste of (focus(Self))
79336>>>>>    End_Procedure
79337>>>>>    
79337>>>>>    Function IsEnabled Returns Boolean
79339>>>>>        Boolean bEnabled
79339>>>>>        Get CanPaste of (Focus(Self)) to bEnabled
79340>>>>>        Function_Return bEnabled
79341>>>>>    End_Function
79342>>>>>         
79342>>>>>End_Class
79343>>>>>
79343>>>>>Class cCJSelectAllMenuItem is a cCJMenuItem
79344>>>>>    
79344>>>>>    Procedure Construct_Object
79346>>>>>        Forward Send Construct_Object
79348>>>>>        Set psCaption   to C_$CaptionSelectAll
79349>>>>>        Set psToolTip to C_$ToolTipSelectAll
79350>>>>>        Set psDescription to C_$DescSelectAll
79351>>>>>        Set pbActiveUpdate to True
79352>>>>>        Set psShortcut to C_$Key_Ctrl_A
79353>>>>>        Set psCategory to C_$CategoryEdit
79354>>>>>    End_Procedure
79355>>>>>
79355>>>>>
79355>>>>>    Procedure OnExecute Variant vCommandBarControl
79357>>>>>        Send Select_All of (focus(Self))
79358>>>>>    End_Procedure
79359>>>>>    
79359>>>>>    Function IsEnabled Returns Boolean
79361>>>>>        Boolean bEnabled
79361>>>>>        Get CanSelect of (Focus(Self)) to bEnabled
79362>>>>>        Function_Return bEnabled
79363>>>>>    End_Function
79364>>>>>         
79364>>>>>End_Class
79365>>>>>
79365>>>>> 
79365>>>>>Class cCJExitMenuItem is a cCJMenuItem
79366>>>>>
79366>>>>>    Procedure Construct_Object
79368>>>>>        Forward Send Construct_Object
79370>>>>>        Set psCaption to C_$CaptionExit
79371>>>>>        Set psToolTip to C_$ToolTipExit
79372>>>>>        Set psDescription to C_$ToolTipExit
79373>>>>>        Set psShortcut to C_$Key_Alt_F4
79374>>>>>        Set psCategory to C_$CategoryFile
79375>>>>>    End_Procedure
79376>>>>>
79376>>>>>    Procedure OnExecute Variant vCommandBarControl
79378>>>>>        Send Exit_Application of Desktop
79379>>>>>    End_Procedure
79380>>>>>
79380>>>>>End_Class           
79381>>>>>
79381>>>>>Class cCJHelpMenuItem is a cCJMenuItem    
79382>>>>>
79382>>>>>    Procedure Construct_Object
79384>>>>>        Forward Send Construct_Object
79386>>>>>        Set psCaption to C_$CaptionHelp
79387>>>>>        Set psDescription to C_$ToolTipHelp
79388>>>>>        Set psToolTip to C_$DescHelp
79389>>>>>        Set psImage to "ActionHelp.ico"
79390>>>>>        Set psShortcut to "F1"
79391>>>>>        Set psCategory to C_$CategoryHelp
79392>>>>>    End_Procedure
79393>>>>>    
79393>>>>>    Procedure OnExecute Variant vCommandBarControl
79395>>>>>        Send Help of (Focus(Self))
79396>>>>>    End_Procedure
79397>>>>>
79397>>>>>End_Class
79398>>>>>
79398>>>>>Class cCJStatusbarMenuItem is a cCJMenuItem
79399>>>>>
79399>>>>>    Procedure Construct_Object
79401>>>>>        Forward Send Construct_Object
79403>>>>>        Set psCaption to C_$CaptionAddStatusbar
79404>>>>>        Set psToolTip to C_$ToolTipAddStatusbar
79405>>>>>        Set psDescription to  C_$DescAddStatusbar
79406>>>>>        Set psCategory to C_$CategoryWindow
79407>>>>>    End_Procedure
79408>>>>>
79408>>>>>    Procedure OnExecute Variant vCommandBarControl
79410>>>>>        Handle hoCommandBars hoClientArea
79410>>>>>        Get CommandBarSystemObject to hoCommandBars
79411>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79412>>>>>        If hoClientArea Begin
79414>>>>>            // the clientarea's parent panel has message
79414>>>>>            Send Toggle_StatusBar of (Parent(hoClientArea))
79415>>>>>        End
79415>>>>>>
79415>>>>>    End_Procedure
79416>>>>>
79416>>>>>     Function IsChecked Returns Boolean
79418>>>>>        Boolean bOn
79418>>>>>        Handle hoCommandBars hoClientArea
79418>>>>>        Get CommandBarSystemObject to hoCommandBars
79419>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79420>>>>>        If hoClientArea Begin
79422>>>>>            // the clientarea's parent panel has message
79422>>>>>            Get StatusBar_State of (Parent(hoClientArea)) to bOn
79423>>>>>        End
79423>>>>>>
79423>>>>>        Function_Return bOn
79424>>>>>     End_Function
79425>>>>>End_Class
79426>>>>>
79426>>>>>Class cCJAutoArrangeIconsMenuItem is a cCJMenuItem
79427>>>>>
79427>>>>>    Procedure Construct_Object
79429>>>>>        Forward Send Construct_Object
79431>>>>>        Set psCaption to C_$CaptionAutoArrangeIcons
79432>>>>>        Set psToolTip to C_$ToolTipAutoArrangeIcons
79433>>>>>        Set psDescription to C_$DescAutoArrangeIcons
79434>>>>>        Set psCategory to C_$CategoryWindow
79435>>>>>    End_Procedure
79436>>>>>
79436>>>>>    Procedure OnExecute Variant vCommandBarControl
79438>>>>>        Handle hoCommandBars hoClientArea
79438>>>>>        Get CommandBarSystemObject to hoCommandBars
79439>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79440>>>>>        If hoClientArea Begin
79442>>>>>            // the clientarea's parent panel has message
79442>>>>>            Send Toggle_Auto_Arrange_Icons of (Parent(hoClientArea))
79443>>>>>        End
79443>>>>>>
79443>>>>>    End_Procedure
79444>>>>>    
79444>>>>>     Function IsChecked Returns Boolean
79446>>>>>        Boolean bOn
79446>>>>>        Handle hoCommandBars hoClientArea
79446>>>>>        Get CommandBarSystemObject to hoCommandBars
79447>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79448>>>>>        If hoClientArea Begin
79450>>>>>            // the clientarea's parent panel has message
79450>>>>>            Get Auto_Arrange_Icons_State of (Parent(hoClientArea)) to bOn
79451>>>>>        End
79451>>>>>>
79451>>>>>        Function_Return bOn
79452>>>>>     End_Function
79453>>>>>End_Class
79454>>>>>
79454>>>>>Class cCJRestoreMenusMenuItem is a cCJMenuItem
79455>>>>>
79455>>>>>    Procedure Construct_Object
79457>>>>>        Forward Send Construct_Object
79459>>>>>        Set psCaption to C_$CaptionRestoreMenus
79460>>>>>        Set psToolTip to C_$ToolTipRestoreMenus
79461>>>>>        Set psDescription to C_$DescRestoreMenus
79462>>>>>        Set psCategory to C_$CategoryWindow
79463>>>>>    End_Procedure
79464>>>>>
79464>>>>>    Procedure OnExecute Variant vCommandBarControl
79466>>>>>        Handle hoCommandBars
79466>>>>>        Get CommandBarSystemObject to hoCommandBars
79467>>>>>        Send RestoreLayout of hoCommandBars
79468>>>>>    End_Procedure
79469>>>>>    
79469>>>>>End_Class
79470>>>>>
79470>>>>>Class cCJCascadeMenuItem is a cCJMenuItem
79471>>>>>
79471>>>>>    Procedure Construct_Object
79473>>>>>        Forward Send Construct_Object
79475>>>>>        Set psCaption to C_$CaptionCascade
79476>>>>>        Set psToolTip to C_$ToolTipCascade
79477>>>>>        Set psDescription to  C_$DescCascade
79478>>>>>        Set psImage to "ActionCascade.ico"
79479>>>>>        Set psCategory to C_$CategoryWindow
79480>>>>>    End_Procedure
79481>>>>>    
79481>>>>>    Procedure OnExecute Variant vCommandBarControl
79483>>>>>        Handle hoCommandBars hoClientArea
79483>>>>>        Get CommandBarSystemObject to hoCommandBars
79484>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79485>>>>>        If hoClientArea Begin
79487>>>>>            Send Cascade_Windows of hoClientArea
79488>>>>>        End
79488>>>>>>
79488>>>>>    End_Procedure
79489>>>>>End_Class
79490>>>>>
79490>>>>>Class cCJTileHorizontally is a cCJMenuItem
79491>>>>>
79491>>>>>    Procedure Construct_Object
79493>>>>>        Forward Send Construct_Object
79495>>>>>        Set psCaption to C_$CaptionTileHorizontally 
79496>>>>>        Set psToolTip to C_$ToolTipTileHorizontally  
79497>>>>>        Set psDescription to  C_$DescTileHorizontally
79498>>>>>        Set psImage to "ActionTileHorizontally.ico"
79499>>>>>        Set psCategory to C_$CategoryWindow
79500>>>>>    End_Procedure
79501>>>>>
79501>>>>>    Procedure OnExecute Variant vCommandBarControl
79503>>>>>        Handle hoCommandBars hoClientArea
79503>>>>>        Get CommandBarSystemObject to hoCommandBars
79504>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79505>>>>>        If hoClientArea Begin
79507>>>>>            Send Tile_Windows_Horizontal of hoClientArea
79508>>>>>        End
79508>>>>>>
79508>>>>>    End_Procedure
79509>>>>>End_Class
79510>>>>>
79510>>>>>Class cCJTileVertically is a cCJMenuItem
79511>>>>>
79511>>>>>    Procedure Construct_Object
79513>>>>>        Forward Send Construct_Object
79515>>>>>        Set psCaption to C_$CaptionTileVertically  
79516>>>>>        Set psToolTip to C_$ToolTipTileVertically
79517>>>>>        Set psDescription to  C_$DescTileVertically
79518>>>>>        Set psImage to "ActionTileVertically.ico"
79519>>>>>        Set psCategory to C_$CategoryWindow
79520>>>>>    End_Procedure
79521>>>>>
79521>>>>>    Procedure OnExecute Variant vCommandBarControl
79523>>>>>        Handle hoCommandBars hoClientArea
79523>>>>>        Get CommandBarSystemObject to hoCommandBars
79524>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79525>>>>>        If hoClientArea Begin
79527>>>>>            Send Tile_Windows_Vertical of hoClientArea
79528>>>>>        End
79528>>>>>>
79528>>>>>    End_Procedure
79529>>>>>End_Class
79530>>>>>
79530>>>>>Class cCJMinimizeWindowsMenuItem is a cCJMenuItem
79531>>>>>
79531>>>>>    Procedure Construct_Object
79533>>>>>        Forward Send Construct_Object
79535>>>>>        Set psCaption to C_$CaptionMinimizeWindows 
79536>>>>>        Set psToolTip to C_$ToolTipMinimizeWindows
79537>>>>>        Set psDescription to  C_$DescMinimizeWindows
79538>>>>>        Set psCategory to C_$CategoryWindow
79539>>>>>    End_Procedure
79540>>>>>
79540>>>>>    Procedure OnExecute Variant vCommandBarControl
79542>>>>>        Handle hoCommandBars hoClientArea
79542>>>>>        Get CommandBarSystemObject to hoCommandBars
79543>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79544>>>>>        If hoClientArea Begin
79546>>>>>            // the clientarea's parent panel has message
79546>>>>>            Send Minimize_all_Windows of (Parent(hoClientArea))
79547>>>>>        End
79547>>>>>>
79547>>>>>    End_Procedure
79548>>>>>End_Class
79549>>>>>
79549>>>>>
79549>>>>>Class cCJRestoreWindowsMenuItem is a cCJMenuItem
79550>>>>>
79550>>>>>    Procedure Construct_Object
79552>>>>>        Forward Send Construct_Object
79554>>>>>        Set psCaption to C_$CaptionRestoreWindows
79555>>>>>        Set psToolTip to C_$ToolTipRestoreWindows
79556>>>>>        Set psDescription to  C_$DescRestoreWindows
79557>>>>>        Set psCategory to C_$CategoryWindow
79558>>>>>    End_Procedure
79559>>>>>
79559>>>>>    Procedure OnExecute Variant vCommandBarControl
79561>>>>>        Handle hoCommandBars hoClientArea
79561>>>>>        Get CommandBarSystemObject to hoCommandBars
79562>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79563>>>>>        If hoClientArea Begin
79565>>>>>            // the clientarea's parent panel has message
79565>>>>>            Send Restore_all_Windows of (Parent(hoClientArea))
79566>>>>>        End
79566>>>>>>
79566>>>>>    End_Procedure
79567>>>>>End_Class
79568>>>>>
79568>>>>>Class cCJArrangeIconsMenuItem is a cCJMenuItem
79569>>>>>
79569>>>>>    Procedure Construct_Object
79571>>>>>        Forward Send Construct_Object
79573>>>>>        Set psCaption to C_$CaptionArrangeIcons  
79574>>>>>        Set psToolTip to C_$ToolTipArrangeIcons
79575>>>>>        Set psDescription to  C_$DescArrangeIcons
79576>>>>>        Set psCategory to C_$CategoryWindow
79577>>>>>    End_Procedure
79578>>>>>
79578>>>>>    Procedure OnExecute Variant vCommandBarControl
79580>>>>>        Handle hoCommandBars hoClientArea
79580>>>>>        Get CommandBarSystemObject to hoCommandBars
79581>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79582>>>>>        If hoClientArea Begin
79584>>>>>            Send Arrange_Icons of hoClientArea
79585>>>>>        End
79585>>>>>>
79585>>>>>    End_Procedure
79586>>>>>
79586>>>>>End_Class
79587>>>>>    
79587>>>Use cCJAboutMenuItem.pkg
Including file: cCJAboutMenuItem.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJAboutMenuItem.pkg)
79587>>>>>Use cCJCommandBarSystem.pkg
79587>>>>>Use LanguageText.pkg
79587>>>>>
79587>>>>>// It is expected that if you use this class that you provide an about object that is
79587>>>>>// activated via activate_about such as DfAbout.pkg. We don't use this for you automatically
79587>>>>>// because you may wish to create your own custom about package.
79587>>>>>
79587>>>>>Class cCJAboutMenuItem is a cCJMenuItem    
79588>>>>>
79588>>>>>    Procedure Construct_Object
79590>>>>>        Forward Send Construct_Object
79592>>>>>        Set psCaption to C_$CaptionAbout
79593>>>>>        Set psDescription to C_$ToolTipAbout
79594>>>>>        Set psToolTip to C_$DescAbout
79595>>>>>        Set psImage to "ActionAbout.ico"
79596>>>>>        Set psCategory to C_$CategoryHelp
79597>>>>>    End_Procedure
79598>>>>>    
79598>>>>>    Procedure OnExecute Variant vCommandBarControl
79600>>>>>        Handle hoCommandBars hoClientArea
79600>>>>>        Get CommandBarSystemObject to hoCommandBars
79601>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79602>>>>>        If hoClientArea Begin
79604>>>>>            Send Activate_About of hoClientArea
79605>>>>>        End
79605>>>>>>
79605>>>>>    End_Procedure
79606>>>>>
79606>>>>>End_Class
79607>>>>>
79607>>>>>
79607>>>Use cCJDeoMenuItemClasses.pkg
79607>>>Use cCJMDIWindowsMenuItem.pkg
Including file: cCJMDIWindowsMenuItem.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJMDIWindowsMenuItem.pkg)
79607>>>>>Use cCJCommandBarSystem.pkg
79607>>>>>
79607>>>>>Register_Function Client_ID Returns Integer
79607>>>>>
79607>>>>>// only used by cCJMDIWIndowsMenuItem
79607>>>>>Class cCJMDIWindowItem is a cCJMenuItem
79608>>>>>
79608>>>>>    Procedure Construct_Object
79610>>>>>        Forward Send Construct_Object
79612>>>>>        Property Handle phWindow 0 // object id of view
79613>>>>>        Set pbControlFlagNoMovable to True
79614>>>>>        Set pbActiveUpdate to True
79615>>>>>    End_Procedure
79616>>>>>    
79616>>>>>    Procedure OnExecute Variant vCommandBarControl
79618>>>>>        Handle hWindow
79618>>>>>        Get phWindow to hWindow
79619>>>>>        Send Activate_View of hWindow
79620>>>>>    End_Procedure
79621>>>>>    
79621>>>>>End_Class                
79622>>>>>
79622>>>>>
79622>>>>>Class cCJMDIWindowsMenuItem is a cCJMenuItem
79623>>>>>    
79623>>>>>    Procedure Construct_Object
79625>>>>>        Forward Send Construct_Object
79627>>>>>        Property Handle[] phArrayOfWindows
79628>>>>>        Set peControlType to xtpControlPopup
79629>>>>>        Set psCategory to C_$CategoryWindow
79630>>>>>    End_Procedure
79631>>>>>    
79631>>>>>     // This adds MDI windows to the existing menu items.
79631>>>>>     // This removes any existing windows menus and always adds a new set to the end
79631>>>>>
79631>>>>>     Procedure OnPopupInit Variant vCommandBarControl Handle hCommandBarControls
79633>>>>>        Handle  hClientArea hView
79633>>>>>        String  sLabel
79633>>>>>        Integer i iWindows
79633>>>>>        Handle[] hArrayOfWindows
79634>>>>>        Variant vItem
79634>>>>>        
79634>>>>>        // delete all windows actions and menu items. Assume we have an array of DF action objects for the windows
79634>>>>>        // also assume that destroying an action removes all menu instances of that action
79634>>>>>        Get phArrayOfWindows to hArrayOfWindows
79635>>>>>        Move (SizeOfArray(hArrayOfWindows)) to iWindows
79636>>>>>        For i from 0 to (iWindows-1)
79642>>>>>>
79642>>>>>            Send Destroy of hArrayOfWindows[i] // assume this removes all menu items of this action
79643>>>>>        Loop
79644>>>>>>
79644>>>>>        Move (ResizeArray(hArrayOfWindows,0)) to hArrayOfWindows
79645>>>>>
79645>>>>>        // Add all views to this menu. Create the action and add the item
79645>>>>>        Move 0 to i
79646>>>>>        Get Client_Id to hClientArea // object id of client area
79647>>>>>        If (hClientArea > 0) Begin
79649>>>>>            Get Next_Mdi_Dialog of hClientArea True to hView // find first view
79650>>>>>            While (hView <> 0)
79654>>>>>                If (Active_State(hView)) Begin
79656>>>>>                    // create the action
79656>>>>>                    Get Create U_cCJMDIWindowItem to hArrayOfWindows[i]
79657>>>>>                    Get Label of hView to sLabel // caption bar (name) of view
79658>>>>>                    Set psCaption of hArrayOfWindows[i] to sLabel
79659>>>>>                    Set psDescription of hArrayOfWindows[i] to ("Make this view (" - trim(sLabel) - ") the active window.")
79660>>>>>                    If (current_scope(desktop)=hView and View_mode(hView)<>VIEWMODE_ICONIZE) Begin
79662>>>>>                        Set pbChecked of hArrayOfWindows[i] to True
79663>>>>>                    End
79663>>>>>>
79663>>>>>                    Set phWindow of hArrayOfWindows[i] to hView // used by custom OnExecute
79664>>>>>                    If (i=0) Begin
79666>>>>>                        Set pbControlBeginGroup of hArrayOfWindows[i] to True
79667>>>>>                    End
79667>>>>>>
79667>>>>>                    // Create a menu item for this action
79667>>>>>                    Get AddDynamicControl of hArrayOfWindows[i] hCommandBarControls to vItem
79668>>>>>                    Increment i
79669>>>>>                End
79669>>>>>>
79669>>>>>                Get Next_Mdi_Dialog of hClientArea False to hView // find next
79670>>>>>            Loop
79671>>>>>>
79671>>>>>        End
79671>>>>>>
79671>>>>>
79671>>>>>        Set phArrayOfWindows to hArrayOfWindows
79672>>>>>
79672>>>>>     End_Procedure
79673>>>>>     
79673>>>>>End_Class
79674>>>>>
79674>Use cCJCommandBarSystem.pkg
79674>Use Dferror.pkg
79674>Use Colr_dlg.pkg
Including file: Colr_dlg.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\Colr_dlg.pkg)
79674>>>//************************************************************************
79674>>>//--- Colr_Dlg.pkg
79674>>>//
79674>>>// Copyright (c) 1983-1997 Data Access Corporation, Miami Florida,
79674>>>// All rights reserved.
79674>>>// DataFlex is a registered trademark of Data Access Corporation.
79674>>>//
79674>>>//************************************************************************
79674>>>//  Description:
79674>>>//      Provides a DataFlex class that acts as a wrapper to the Windows'
79674>>>//      Color-Dialog
79674>>>//
79674>>>//  Author: Stuart W. Booth
79674>>>// 07/23/96 JJT - New Class names
79674>>>// 09/05/02 SWB - Reworked the class to derive from cObject (with embedded
79674>>>//                Array for Custom Colors). General code cleanup.
79674>>>//************************************************************************
79674>>>
79674>>>Use VDFBase.pkg
79674>>>Use DLL.pkg
79674>>>Use RGB.pkg
79674>>>Use GlobalFunctionsProcedures.pkg
79674>>>
79674>>>
79674>>>External_Function ChooseColor 'ChooseColorA' COMDLG32.dll Pointer lpCC Returns DWord
79675>>>
79675>>>TYPE CHOOSECOLOR
79675>>>    Field CHOOSECOLOR.lStructSize    as DWORD
79675>>>    Field CHOOSECOLOR.hWndOwner      as HANDLE
79675>>>    Field CHOOSECOLOR.hInstance      as HANDLE
79675>>>    Field CHOOSECOLOR.rgbResult      as DWORD
79675>>>    Field CHOOSECOLOR.lpCustColors   as POINTER
79675>>>    Field CHOOSECOLOR.flags          as DWORD
79675>>>    Field CHOOSECOLOR.lCustData      as DWORD
79675>>>    Field CHOOSECOLOR.lpfnHook       as DWORD
79675>>>    Field CHOOSECOLOR.lpTemplateName as POINTER
79675>>>END_TYPE
79675>>>
79675>>>Class ColorDialog Is a cObject
79676>>>    Procedure Construct_Object
79678>>>        Integer iLoop
79678>>>        Handle hoCustomColors
79678>>>
79678>>>        Forward Send Construct_Object
79680>>>
79680>>>        Property Boolean FullOpen_State        True
79681>>>        Property Boolean PreventFullOpen_State False
79682>>>        Property Boolean SelectedColor_State   True
79683>>>        Property Integer SelectedColor         0
79684>>>
79684>>>        Property Handle phoCustomColors (Create(self, U_Array)) // create an array to hold the custom colors
79685>>>
79685>>>        // Set all custom colors to white...
79685>>>        Get phoCustomColors To hoCustomColors
79686>>>        For iLoop From 0 To 15
79692>>>>
79692>>>            Set Value of hoCustomColors iLoop To clWhite
79693>>>        Loop
79694>>>>
79694>>>
79694>>>    End_Procedure
79695>>>
79695>>>    Procedure Set Custom_Color Integer iItem Integer rgbColor
79697>>>        Set Value of (phoCustomColors(self)) iItem To rgbColor
79698>>>    End_Procedure
79699>>>
79699>>>    Function Custom_Color Integer iItem Returns Integer
79701>>>        Function_Return (Integer_Value(phoCustomColors(self), iItem))
79702>>>    End_Function
79703>>>
79703>>>    Procedure AssignCustomColors Handle hoSourceColorDialog
79705>>>        // Copies the custom colors from another ColorDialog instance
79705>>>        Integer iColor
79705>>>
79705>>>        For iColor From 0 To 15
79711>>>>
79711>>>            Set Custom_Color iColor To (Value(hoSourceColorDialog, iColor))
79712>>>        Loop
79713>>>>
79713>>>    End_Procedure
79714>>>
79714>>>    Function Value Integer iItem Returns String
79716>>>        // Provides support for the AssignCustomColors procedure, which requires
79716>>>        // that a "Get Value" interface is supported
79716>>>        Function_Return (Custom_Color(self, iItem))
79717>>>    End_Function
79718>>>
79718>>>    Function OwnerHandle returns handle
79720>>>        Handle hWnd
79720>>>        Handle hoObj
79720>>>        Get Focus of desktop to hoObj // start with the focus
79721>>>        Move (gOwnerWindowHandle(hoObj)) to hWnd // global function finds the right handle for us
79722>>>        function_return hWnd
79723>>>    End_Function
79724>>>
79724>>>    Function Show_Dialog Returns Boolean
79726>>>        //Shows the dialog. Returns True if the OK button was clicked.
79726>>>        Handle hContainer hoCustomColors
79726>>>        Boolean bSelected bFullOpen bNoOpen bSelColor
79726>>>        Integer rgbColor iFlags iLoop
79726>>>        String sCC sColors
79726>>>
79726>>>        //Delegate Get Container_Handle To hContainer
79726>>>        Get OwnerHandle To hContainer
79727>>>
79727>>>        Get phoCustomColors To hoCustomColors
79728>>>        ZeroType CHOOSECOLOR To sCC
79729>>>
79729>>>        Move '' To sColors
79730>>>        For iLoop from 0 To 15
79736>>>>
79736>>>            Get Value of hoCustomColors iLoop To rgbColor
79737>>>            Move (sColors + DWORDToBytes(rgbColor)) To sColors
79738>>>        Loop
79739>>>>
79739>>>
79739>>>        Get FullOpen_State        To bFullOpen
79740>>>        Get PreventFullOpen_State To bNoOpen
79741>>>        Get SelectedColor_State   To bSelColor
79742>>>        Get SelectedColor         To rgbColor
79743>>>
79743>>>        Move 0 To iFlags
79744>>>        If bFullOpen Move (iFlags +CC_FULLOPEN)        To iFlags
79747>>>        If bNoOpen   Move (iFlags +CC_PREVENTFULLOPEN) To iFlags
79750>>>        If bSelColor Move (iFlags +CC_RGBINIT)         To iFlags
79753>>>
79753>>>        Put CHOOSECOLOR_size     To sCC At CHOOSECOLOR.lStructSize
79754>>>        Put hContainer           To sCC At CHOOSECOLOR.hWndOWner
79755>>>        Put rgbColor             To sCC At CHOOSECOLOR.rgbResult
79756>>>        Put (AddressOf(sColors)) To sCC At CHOOSECOLOR.lpCustColors
79757>>>        Put iFlags               To sCC At CHOOSECOLOR.flags
79758>>>
79758>>>        Move (ChooseColor(AddressOf(sCC))) To bSelected
79759>>>
79759>>>        If bSelected Begin
79761>>>            For iLoop from 0 To 15
79767>>>>
79767>>>                Move (BytesToDword(sColors, iLoop *4 +1)) To rgbColor
79768>>>                Set Value of hoCustomColors iLoop To rgbColor
79769>>>            Loop
79770>>>>
79770>>>            GetBuff From sCC At CHOOSECOLOR.rgbResult To rgbColor
79771>>>            Set SelectedColor To rgbColor
79772>>>        End
79772>>>>
79772>>>        Function_Return bSelected
79773>>>    End_Function
79774>>>
79774>>>End_Class
79775>Use Cursor.pkg
79775>Use cDbUpdateHandler.pkg
Including file: cDbUpdateHandler.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateHandler.pkg)
79775>>>//****************************************************************************
79775>>>// $Module type: Class
79775>>>// $Module name: cDbUpdateHandler
79775>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
79775>>>// Web-site    : http://www.rdctools.com
79775>>>// Created     : 2016-09-27 @ 09:33 (Military date format: YY-MM-DD)
79775>>>//
79775>>>// Purpose     : A framework for doing automated code based updates of a database from within
79775>>>//               a program, when it is started.
79775>>>//
79775>>>// Description : Place _one_ object of this class right after the cApplication object.
79775>>>//               Then inside this object place a series of cDbUpdateVersion objects
79775>>>//               as childs. One child object for each new database update.
79775>>>//
79775>>>//               - OnPreUpdate is a pre-processing event called
79775>>>//               before any database changes are started.
79775>>>//               - OnPostUpdate is a post-processing event called after all
79775>>>//               database changes have taken place.
79775>>>//
79775>>>// Note        : If tables have been opened prior to an object of this class
79775>>>//               (e.g. in the cApplication object), those tables will be closed.
79775>>>//               In that case you need to use the OnPostUpdate hook event to re-open
79775>>>//               tables after the last update has finished.
79775>>>//
79775>>>// Security    : Before an update is attempted; three things are checked to ensure the
79775>>>//               database is not in use. Aka nobody else is running the application.
79775>>>//               - All tables are tested for "Open in Exclusive_Mode"
79775>>>//               - The DataFlex license User Count is checked - cannot be more than 1, unless the
79775>>>//                 pbCheckDataFlexUserCount is set to False (Default = True)
79775>>>//               - A special user count file ("DbUpdateUserCount.ucf") is created in the Programs
79775>>>//                 folder and a bit-lock is performed for each start of the application and this
79775>>>//                 user counter is checked before an update is attempted.
79775>>>//                 Important: Even if it seems like both garters & suspenders are used to guard
79775>>>//                            against the database being "in use", there is no such guarantee! The
79775>>>//                            database could e.g. be open in "Microsoft SQL Server Management Studio"
79775>>>//                            and there is no way of telling. SO BE CAUTIOUS before attempting an update!
79775>>>//                 A second "user count file" is also used - "DbUpdateLock.ucf". It is used to
79775>>>//                 lock everybody else out (with a Stop box) while the database is being updated. The lock will
79775>>>//                 automatically be released after the update is completed.
79775>>>//
79775>>>//
79775>>>// Usage       :  Use cDbUpdateHandler.pkg
79775>>>//                Object oDatabaseUpdateHandler is a cDbUpdateHandler
79775>>>//                    // Declare the table that contains a "database version" field.
79775>>>//                    Declare_Datafile Sys
79775>>>//                    // Either one of these syntaxes is fine:
79775>>>//                    Set Data_File_Field to File_Field Sys.DbUpdateVersion
79775>>>//                    Set Data_File_Field to (RefTable(Sys)) (RefTable(Sys.DbUpdateVersion))
79775>>>//
79775>>>//                    // Don't forget to increase the pnVersionNumber property for each
79775>>>//                    // cDbUpdateVersion object!
79775>>>//                    // The VersionTableColumn field/column specified above will be updated automatically
79775>>>//                    // with the value of pnVersionNumber after each update has been finished.
79775>>>//                    Object oVersionUpdate1.1 is a cDbUpdateVersion
79775>>>//                        Set pnVersionNumber to 1.1
79775>>>//                        Use VersionUpdate1_1.pkg
79775>>>//                    End_Object
79775>>>//
79775>>>//                    Object oVersionUpdate1.2 is a cDbUpdateVersion
79775>>>//                        Set pnVersionNumber to 1.2
79775>>>//                        Use VersionUpdate1_2.pkg
79775>>>//                    End_Object
79775>>>//
79775>>>//                End_Object
79775>>>//
79775>>>//
79775>>>// $Rev History:
79775>>>//    2016-09-27  Module header created
79775>>>//    2016-09-28  Removed the Master/Alias logic. All update code must
79775>>>//                take place before any tables have been opened, or errors
79775>>>//                could occur if the client database is out of sync with the
79775>>>//                compiled program.
79775>>>//                Added user counting checks + lockout while database is being
79775>>>//                updated.
79775>>>//    2016-10-03  Changed the class name from cDatabaseUpdateHandler to cDbUpdateHandler,
79775>>>//                as it is more in line with the child class cDbUpdateVersion name.
79775>>>//    2016-10-06  Moved constant declarations, structs etc. to separate cDbUpdateHandler.inc file
79775>>>//****************************************************************************
79775>>>Use VdfBase.pkg
79775>>>Use DUFStatusPanel.pkg
Including file: DUFStatusPanel.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\DUFStatusPanel.pkg)
79775>>>>>// StatPnl.pkg - creates the standard status_panel object.
79775>>>>>//
79775>>>>>//
79775>>>>>// This is the default Status Panel object used by any of the Visual DataFlex classes that
79775>>>>>// invoke the standard status panel. The standard has always been that the package name
79775>>>>>// is StatPnl.pkg and the name of the object is Status_Panel. As of 12.0, there are major
79775>>>>>// changes in the way the status panel operates The Sentinel based external status panel used in
79775>>>>>// prior revisions has been replace with status panel that is part of the application.
79775>>>>>// This should work much better and faster than the old sentinel based solution.
79775>>>>>// While the way this operates has changed, the interface has not and therefore this should work
79775>>>>>// with most applications.
79775>>>>>//
79775>>>>>// As of 12.0, we have added a global handle that contains the object ID of this status panel.
79775>>>>>// This variable ghoStatusPanel can be used in place of the object name Status_Panel. This provides
79775>>>>>// a cleaner more robust interface.
79775>>>>>//
79775>>>>>//
79775>>>>>// Compatibility Note:
79775>>>>>//
79775>>>>>// When used in the standard way, this change will require no changes. A developer will only need to
79775>>>>>// change their code if they've modified the sentinel program, which was a difficult thing to do.
79775>>>>>//
79775>>>>>// If for some reason you application will not work using this as a replacement for the old status
79775>>>>>// panel, you've probably done something special with the old status-panel. If you don't want to
79775>>>>>// figure out how to use the new one and you want to continue using the old one you are going to need
79775>>>>>// to add some code to include the old status panel in your application. Add the following to your project (your src).
79775>>>>>//
79775>>>>>// Use StatPnl.pkg    // Make sure you load the new status panel object first. this is not optional!
79775>>>>>// Use OldStatPnl.pkg // load the old status panel. Status_Panel is now this old object
79775>>>>>//
79775>>>>>// If you do this, you will lose access to the new status-panel via Status_Panel. However, you
79775>>>>>// can still access the new object via the ghoStatusPanel handle.
79775>>>>>//
79775>>>>>//
79775>>>>>// Creating your own Status Panel objects
79775>>>>>//
79775>>>>>// If a developer wishes to create a custom panel, they should use this package as their template.
79775>>>>>// This panel can be visually modeled and changed any way you wish. Just save your new custom panel
79775>>>>>// with a different file and object name and direct your status panel request to the new object.
79775>>>>>//
79775>>>>>// If the new panel changes the interface and updates objects that are not currently defined, you
79775>>>>>// want to make sure you send the message ProcessEvents after you've updated the object. This allows
79775>>>>>// the object to paint when inside of a tight loop. For example, if you wanted to add a progress
79775>>>>>// bar (cProgressBar) you would want to Send ProcessEvents after you update the progress bar.
79775>>>>>// e.g.
79775>>>>>//       Procedure UpdateStatusBar
79775>>>>>//           Send DoAdvance of oProgressBar
79775>>>>>//           Send ProcessEvents
79775>>>>>//       End_Procedure
79775>>>>>//
79775>>>>>// of course, if you use the standard interfaces in status bar and your forward send these
79775>>>>>// messages this will be done for you.
79775>>>>>//
79775>>>>>// the standard Interface for status panels are:
79775>>>>>//
79775>>>>>// Send Initialize_StatusPanel - initializes values for caption, title & message
79775>>>>>// Send Start_StatusPanel      - start the status panel
79775>>>>>// Send Stop_StatusPanel       - stop the status panel
79775>>>>>// Send Update_StatusPanel     - update the status panel's action area
79775>>>>>// Get  Check_StatusPanel      - check for cancel (if cancel or pbCancel is set, close the panel)
79775>>>>>//
79775>>>>>// Get/Set Caption_Text - updates the caption bar
79775>>>>>// Get/Set Title_Text   - updates the title area
79775>>>>>// Get/Set Message_Text - updates the Message area
79775>>>>>// Get/Set Action_Text  - updates the action area
79775>>>>>// Get/Set Button_Text  - updates the button area
79775>>>>>//
79775>>>>>// Get/Set Allow_cancel_state - determines if panel can be canceled
79775>>>>>// Send EnableCancelButton - code you should provide to enable/disable cancel button
79775>>>>>//
79775>>>>>// ghoStatusPanel - global handle that points to the standard status panel.
79775>>>>>Use cProcessStatusPanel.pkg
79775>>>>>Use cCJSkinFramework.pkg
Including file: cCJSkinFramework.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJSkinFramework.pkg)
79775>>>>>>>Use windows.pkg
79775>>>>>>>Use cCJComSkinFramework.pkg
Including file: cCJComSkinFramework.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJComSkinFramework.pkg)
79775>>>>>>>>>// DataFlex COM proxy classes generated from C:\Program Files (x86)\Codejock Software\ActiveX\Xtreme SuitePro ActiveX v17.3.0\Bin\Codejock.SkinFramework.v17.3.0.ocx
79775>>>>>>>>>Use FlexCom20.pkg
79775>>>>>>>>>
79775>>>>>>>>>// Changes to Imported package
79775>>>>>>>>>//     OLEXTPxx to XTPxx
79775>>>>>>>>>//     OLExtpxx to xtpxx
79775>>>>>>>>>//     OLESkinFramework to SkinFramework
79775>>>>>>>>>//     OLESTDxxx and OLEXPxxxx to STD/XP
79775>>>>>>>>>//     cCom classes to cCJ
79775>>>>>>>>>//     cCJAutomationObject back to cComAutomationObject
79775>>>>>>>>>//     cCJActiveXControl back to cComActiveXControl
79775>>>>>>>>>//     cCJSkinFramework to cCJComSkinFramework
79775>>>>>>>>>//     Use statements as noted below (classes moved to these files)
79775>>>>>>>>>//     Set classlibrary of all cComAutomation objects to Windows (for class doc)
79775>>>>>>>>>
79775>>>>>>>>>// These have been extracted from this class and moved into seperate packages
79775>>>>>>>>>// because other Codejock classes use these.
79775>>>>>>>>>Use cCJColorManager.pkg     // cCJColorManager
79775>>>>>>>>>
79775>>>>>>>>>Define SkinFrameworkApplyOptions for Integer
79775>>>>>>>>>    Define xtpSkinApplyMetrics for 1
79775>>>>>>>>>    Define xtpSkinApplyFrame for 2
79775>>>>>>>>>    Define xtpSkinApplyColors for 4
79775>>>>>>>>>    Define xtpSkinApplyMenus for 8
79775>>>>>>>>>
79775>>>>>>>>>// CLSID: {AFA0E6A1-28D7-4F2C-87A7-7266367B4655}
79775>>>>>>>>>// Dispatch interface for SkinFramework Control
79775>>>>>>>>>Class cCJ_DSkinFramework is a Mixin
79776>>>>>>>>>
79776>>>>>>>>>    Function ComApplyOptions Returns SkinFrameworkApplyOptions
79778>>>>>>>>>        SkinFrameworkApplyOptions retVal
79778>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to retVal
79779>>>>>>>>>        Function_Return retVal
79780>>>>>>>>>    End_Function
79781>>>>>>>>>
79781>>>>>>>>>    Procedure Set ComApplyOptions SkinFrameworkApplyOptions value
79783>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to value
79784>>>>>>>>>    End_Procedure
79785>>>>>>>>>
79785>>>>>>>>>    Function ComAutoApplyNewWindows Returns Boolean
79787>>>>>>>>>        Boolean retVal
79787>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to retVal
79788>>>>>>>>>        Function_Return retVal
79789>>>>>>>>>    End_Function
79790>>>>>>>>>
79790>>>>>>>>>    Procedure Set ComAutoApplyNewWindows Boolean value
79792>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to value
79793>>>>>>>>>    End_Procedure
79794>>>>>>>>>
79794>>>>>>>>>    Function ComAutoApplyNewThreads Returns Boolean
79796>>>>>>>>>        Boolean retVal
79796>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to retVal
79797>>>>>>>>>        Function_Return retVal
79798>>>>>>>>>    End_Function
79799>>>>>>>>>
79799>>>>>>>>>    Procedure Set ComAutoApplyNewThreads Boolean value
79801>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to value
79802>>>>>>>>>    End_Procedure
79803>>>>>>>>>
79803>>>>>>>>>    Function ComLoadSkin String llResourcePath String llIniFileName Returns Boolean
79805>>>>>>>>>        Handle hDispatchDriver
79805>>>>>>>>>        Boolean retVal
79805>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
79806>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
79807>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
79808>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
79809>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_BOOL to retVal
79810>>>>>>>>>        Function_Return retVal
79811>>>>>>>>>    End_Function
79812>>>>>>>>>
79812>>>>>>>>>    Procedure ComApplyWindow OLE_HANDLE llhWnd
79814>>>>>>>>>        Handle hDispatchDriver
79814>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
79815>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
79816>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
79817>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 3 OLE_VT_VOID
79818>>>>>>>>>    End_Procedure
79819>>>>>>>>>
79819>>>>>>>>>    Procedure ComEnableThemeDialogTexture OLE_HANDLE llhWnd Integer llFlags
79821>>>>>>>>>        Handle hDispatchDriver
79821>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
79822>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
79823>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
79824>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llFlags
79825>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 4 OLE_VT_VOID
79826>>>>>>>>>    End_Procedure
79827>>>>>>>>>
79827>>>>>>>>>    Procedure ComRemoveWindow OLE_HANDLE llhWnd
79829>>>>>>>>>        Handle hDispatchDriver
79829>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
79830>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
79831>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
79832>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 6 OLE_VT_VOID
79833>>>>>>>>>    End_Procedure
79834>>>>>>>>>
79834>>>>>>>>>    Procedure ComRemoveAllWindows
79836>>>>>>>>>        Handle hDispatchDriver
79836>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
79837>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 7 OLE_VT_VOID
79838>>>>>>>>>    End_Procedure
79839>>>>>>>>>
79839>>>>>>>>>    Procedure ComAddWindowClass String llClassName String llBaseClassName
79841>>>>>>>>>        Handle hDispatchDriver
79841>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
79842>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
79843>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
79844>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llBaseClassName
79845>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 8 OLE_VT_VOID
79846>>>>>>>>>    End_Procedure
79847>>>>>>>>>
79847>>>>>>>>>    Procedure ComRemoveWindowClass String llClassName
79849>>>>>>>>>        Handle hDispatchDriver
79849>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
79850>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
79851>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
79852>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 9 OLE_VT_VOID
79853>>>>>>>>>    End_Procedure
79854>>>>>>>>>
79854>>>>>>>>>    Function ComEnumerateSkinDirectory String llPath Boolean llRecursive Returns Variant
79856>>>>>>>>>        Handle hDispatchDriver
79856>>>>>>>>>        Variant retVal
79856>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
79857>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
79858>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
79859>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BOOL llRecursive
79860>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 11 OLE_VT_DISPATCH to retVal
79861>>>>>>>>>        Function_Return retVal
79862>>>>>>>>>    End_Function
79863>>>>>>>>>
79863>>>>>>>>>    Function ComEnumerateSkinFile String llPath Returns Variant
79865>>>>>>>>>        Handle hDispatchDriver
79865>>>>>>>>>        Variant retVal
79865>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
79866>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
79867>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
79868>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 12 OLE_VT_DISPATCH to retVal
79869>>>>>>>>>        Function_Return retVal
79870>>>>>>>>>    End_Function
79871>>>>>>>>>
79871>>>>>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
79873>>>>>>>>>        Handle hDispatchDriver
79873>>>>>>>>>        OLE_COLOR retVal
79873>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
79874>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
79875>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
79876>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 14 OLE_VT_I4 to retVal
79877>>>>>>>>>        Function_Return retVal
79878>>>>>>>>>    End_Function
79879>>>>>>>>>
79879>>>>>>>>>    Procedure ComExcludeModule String llModuleName
79881>>>>>>>>>        Handle hDispatchDriver
79881>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
79882>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
79883>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llModuleName
79884>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 15 OLE_VT_VOID
79885>>>>>>>>>    End_Procedure
79886>>>>>>>>>
79886>>>>>>>>>    Function ComCreateSchema String llResourcePath String llIniFileName Returns Variant
79888>>>>>>>>>        Handle hDispatchDriver
79888>>>>>>>>>        Variant retVal
79888>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
79889>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
79890>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
79891>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
79892>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 16 OLE_VT_DISPATCH to retVal
79893>>>>>>>>>        Function_Return retVal
79894>>>>>>>>>    End_Function
79895>>>>>>>>>
79895>>>>>>>>>    Procedure ComSetWindowTheme OLE_HANDLE llhWnd Variant llSchema
79897>>>>>>>>>        Handle hDispatchDriver
79897>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
79898>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
79899>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
79900>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llSchema
79901>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 17 OLE_VT_VOID
79902>>>>>>>>>    End_Procedure
79903>>>>>>>>>
79903>>>>>>>>>    Procedure ComAboutBox
79905>>>>>>>>>        Handle hDispatchDriver
79905>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
79906>>>>>>>>>        Send InvokeComMethod to hDispatchDriver -552 OLE_VT_VOID
79907>>>>>>>>>    End_Procedure
79908>>>>>>>>>End_Class
79909>>>>>>>>>
79909>>>>>>>>>// CLSID: {40217CB8-4463-4030-B324-AC6A8075FEC8}
79909>>>>>>>>>// Event interface for SkinFramework Control
79909>>>>>>>>>Class cCJ_DSkinFrameworkEvents is a Mixin
79910>>>>>>>>>
79910>>>>>>>>>    Procedure RegisterComEvents
79912>>>>>>>>>    End_Procedure
79913>>>>>>>>>End_Class
79914>>>>>>>>>
79914>>>>>>>>>// CoClass
79914>>>>>>>>>// ProgID: Codejock.SkinFramework.17.3.0
79914>>>>>>>>>// CLSID: {DE67160B-9A3E-4EA6-846E-8C9A72F9F203}
79914>>>>>>>>>// SkinFramework Control
79914>>>>>>>>>Class cCJComSkinFramework is a cComActiveXControl
79915>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFramework
79916>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFrameworkEvents
79917>>>>>>>>>
79917>>>>>>>>>    Procedure Construct_Object
79919>>>>>>>>>        Forward Send Construct_Object
79921>>>>>>>>>        Set psProgID to "{DE67160B-9A3E-4EA6-846E-8C9A72F9F203}"
79922>>>>>>>>>        Set psEventId to "{40217CB8-4463-4030-B324-AC6A8075FEC8}"
79923>>>>>>>>>        Set psLicenseKey to ("Skin Framework Control Copyright (c) 1998-2016 Codejock Software"+ Character(13)+ Character(10)+;                             "PRODUCT-ID: Codejock.SkinFramework.ActiveX.v17.3"+ Character(13)+ Character(10)+;                             "VALIDATE-CODE: GGE-OLD-QQR-EJS")
79924>>>>>>>>>        Set peAutoCreate to acAutoCreate
79925>>>>>>>>>    End_Procedure
79926>>>>>>>>>End_Class
79927>>>>>>>>>
79927>>>>>>>>>// CLSID: {06E8A85B-70E4-4F71-A0FC-D1D5658C7E17}
79927>>>>>>>>>// SkinFramework Global Settings
79927>>>>>>>>>Class cCJISkinFrameworkGlobalSettings is a Mixin
79928>>>>>>>>>
79928>>>>>>>>>    Function ComLicense Returns String
79930>>>>>>>>>        String retVal
79930>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to retVal
79931>>>>>>>>>        Function_Return retVal
79932>>>>>>>>>    End_Function
79933>>>>>>>>>
79933>>>>>>>>>    Procedure Set ComLicense String value
79935>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to value
79936>>>>>>>>>    End_Procedure
79937>>>>>>>>>
79937>>>>>>>>>    Function ComTitle Returns String
79939>>>>>>>>>        String retVal
79939>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to retVal
79940>>>>>>>>>        Function_Return retVal
79941>>>>>>>>>    End_Function
79942>>>>>>>>>
79942>>>>>>>>>    Procedure Set ComTitle String value
79944>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to value
79945>>>>>>>>>    End_Procedure
79946>>>>>>>>>
79946>>>>>>>>>    Function ComVersion Returns String
79948>>>>>>>>>        Handle hDispatchDriver
79948>>>>>>>>>        String retVal
79948>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
79949>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 104 OLE_VT_BSTR to retVal
79950>>>>>>>>>        Function_Return retVal
79951>>>>>>>>>    End_Function
79952>>>>>>>>>
79952>>>>>>>>>    Function ComUnicode Returns Boolean
79954>>>>>>>>>        Handle hDispatchDriver
79954>>>>>>>>>        Boolean retVal
79954>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
79955>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 105 OLE_VT_BOOL to retVal
79956>>>>>>>>>        Function_Return retVal
79957>>>>>>>>>    End_Function
79958>>>>>>>>>
79958>>>>>>>>>    Function ComOcxPath Returns String
79960>>>>>>>>>        Handle hDispatchDriver
79960>>>>>>>>>        String retVal
79960>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
79961>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 106 OLE_VT_BSTR to retVal
79962>>>>>>>>>        Function_Return retVal
79963>>>>>>>>>    End_Function
79964>>>>>>>>>End_Class
79965>>>>>>>>>
79965>>>>>>>>>// CoClass
79965>>>>>>>>>// ProgID: Codejock.SkinFrameworkGlobalSettings.17.3.0
79965>>>>>>>>>// CLSID: {C4136A4A-67FD-4FC1-BA62-A715B4D60808}
79965>>>>>>>>>// SkinFramework Global Settings
79965>>>>>>>>>Class cCJComSkinFrameworkGlobalSettings is a cComAutomationObject
79966>>>>>>>>>    Import_Class_Protocol cCJISkinFrameworkGlobalSettings
79967>>>>>>>>>
79967>>>>>>>>>    Procedure Construct_Object
79969>>>>>>>>>        Forward Send Construct_Object
79971>>>>>>>>>        Set psProgID to "{C4136A4A-67FD-4FC1-BA62-A715B4D60808}"
79972>>>>>>>>>        Set peAutoCreate to acNoAutoCreate
79973>>>>>>>>>    End_Procedure
79974>>>>>>>>>End_Class
79975>>>>>>>>>
79975>>>>>>>>>// CLSID: {27E4AC9B-4A2D-4FBB-A782-BD76BEFA4345}
79975>>>>>>>>>Class cCJSkinIniFile is a cComAutomationObject
79976>>>>>>>>>
79976>>>>>>>>>    Function ComColorScheme Returns String
79978>>>>>>>>>        String retVal
79978>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
79979>>>>>>>>>        Function_Return retVal
79980>>>>>>>>>    End_Function
79981>>>>>>>>>
79981>>>>>>>>>    Procedure Set ComColorScheme String value
79983>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
79984>>>>>>>>>    End_Procedure
79985>>>>>>>>>
79985>>>>>>>>>    Function ComFontSize Returns String
79987>>>>>>>>>        String retVal
79987>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
79988>>>>>>>>>        Function_Return retVal
79989>>>>>>>>>    End_Function
79990>>>>>>>>>
79990>>>>>>>>>    Procedure Set ComFontSize String value
79992>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
79993>>>>>>>>>    End_Procedure
79994>>>>>>>>>
79994>>>>>>>>>    Function ComIniFileName Returns String
79996>>>>>>>>>        String retVal
79996>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to retVal
79997>>>>>>>>>        Function_Return retVal
79998>>>>>>>>>    End_Function
79999>>>>>>>>>
79999>>>>>>>>>    Procedure Set ComIniFileName String value
80001>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to value
80002>>>>>>>>>    End_Procedure
80003>>>>>>>>>End_Class
80004>>>>>>>>>
80004>>>>>>>>>// CLSID: {5005F22B-A30E-4B12-B142-E97F62A927A6}
80004>>>>>>>>>Class cCJSkinDescription is a cComAutomationObject
80005>>>>>>>>>
80005>>>>>>>>>    Function ComName Returns String
80007>>>>>>>>>        String retVal
80007>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
80008>>>>>>>>>        Function_Return retVal
80009>>>>>>>>>    End_Function
80010>>>>>>>>>
80010>>>>>>>>>    Procedure Set ComName String value
80012>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
80013>>>>>>>>>    End_Procedure
80014>>>>>>>>>
80014>>>>>>>>>    Function ComPath Returns String
80016>>>>>>>>>        String retVal
80016>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
80017>>>>>>>>>        Function_Return retVal
80018>>>>>>>>>    End_Function
80019>>>>>>>>>
80019>>>>>>>>>    Procedure Set ComPath String value
80021>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
80022>>>>>>>>>    End_Procedure
80023>>>>>>>>>
80023>>>>>>>>>    Function ComCount Returns Integer
80025>>>>>>>>>        Handle hDispatchDriver
80025>>>>>>>>>        Integer retVal
80025>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80026>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
80027>>>>>>>>>        Function_Return retVal
80028>>>>>>>>>    End_Function
80029>>>>>>>>>
80029>>>>>>>>>    Function ComIniFile Integer llIndex Returns Variant
80031>>>>>>>>>        Handle hDispatchDriver
80031>>>>>>>>>        Variant retVal
80031>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80032>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
80033>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
80034>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
80035>>>>>>>>>        Function_Return retVal
80036>>>>>>>>>    End_Function
80037>>>>>>>>>
80037>>>>>>>>>    Function Com_NewEnum Returns Variant
80039>>>>>>>>>        Handle hDispatchDriver
80039>>>>>>>>>        Variant retVal
80039>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80040>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
80041>>>>>>>>>        Function_Return retVal
80042>>>>>>>>>    End_Function
80043>>>>>>>>>End_Class
80044>>>>>>>>>
80044>>>>>>>>>// CLSID: {C4367A33-2A7C-4CC6-BF0C-C50383B34B51}
80044>>>>>>>>>Class cCJSkinDescriptions is a cComAutomationObject
80045>>>>>>>>>
80045>>>>>>>>>    Function ComCount Returns Integer
80047>>>>>>>>>        Handle hDispatchDriver
80047>>>>>>>>>        Integer retVal
80047>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80048>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
80049>>>>>>>>>        Function_Return retVal
80050>>>>>>>>>    End_Function
80051>>>>>>>>>
80051>>>>>>>>>    Function ComSkin Integer llIndex Returns Variant
80053>>>>>>>>>        Handle hDispatchDriver
80053>>>>>>>>>        Variant retVal
80053>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80054>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
80055>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
80056>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
80057>>>>>>>>>        Function_Return retVal
80058>>>>>>>>>    End_Function
80059>>>>>>>>>
80059>>>>>>>>>    Function Com_NewEnum Returns Variant
80061>>>>>>>>>        Handle hDispatchDriver
80061>>>>>>>>>        Variant retVal
80061>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80062>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
80063>>>>>>>>>        Function_Return retVal
80064>>>>>>>>>    End_Function
80065>>>>>>>>>End_Class
80066>>>>>>>>>
80066>>>>>>>>>// CLSID: {128507E0-C56F-43C0-BCF1-8193B35FE4C4}
80066>>>>>>>>>Class cCJSkinSchema is a cComAutomationObject
80067>>>>>>>>>End_Class
80068>>>>>>>Use cApplication.pkg
80068>>>>>>>
80068>>>>>>>Struct tSkinInformation
80068>>>>>>>    String sName     // description of the skin
80068>>>>>>>    String sSkinfile // file path. Can be relative or full
80068>>>>>>>    String sSkinIni  // section name
80068>>>>>>>End_Struct
80068>>>>>>>
80068>>>>>>>
80068>>>>>>>Class cCJSkinFramework is a cCJComSkinFramework
80069>>>>>>>    
80069>>>>>>>    Procedure Construct_Object
80071>>>>>>>        Forward Send Construct_Object
80073>>>>>>>        
80073>>>>>>>        Property String psSkinFile ""
80074>>>>>>>        Property String psSkinIni ""
80075>>>>>>>        Property Boolean pbLoadPreference False
80076>>>>>>>        
80076>>>>>>>        Set peAutoCreate to acAutoCreate
80077>>>>>>>        
80077>>>>>>>        Move Self to ghoSkinFramework
80078>>>>>>>    End_Procedure
80079>>>>>>>    
80079>>>>>>>    // return the default skin path, which is the programs directory.
80079>>>>>>>    // This requires an application object.
80079>>>>>>>    // If you want to different skin path, override this.
80079>>>>>>>    Function SkinPath Returns String
80081>>>>>>>        String sPath sPaths
80081>>>>>>>        Handle hoWorkspace
80081>>>>>>>        If ghoApplication Begin
80083>>>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
80084>>>>>>>            Get psProgramPath of hoWorkspace to sPaths
80085>>>>>>>            Get PathAtIndex of hoWorkspace sPaths 1 to sPath
80086>>>>>>>        End
80086>>>>>>>>
80086>>>>>>>        Else Begin
80087>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
80088>>>>>>>>
80088>>>>>>>        End
80088>>>>>>>>
80088>>>>>>>        Function_Return sPath
80089>>>>>>>    End_Function
80090>>>>>>>    
80090>>>>>>>    // Returns the Qualified name of psSkinFile. If the file is already qualified it just
80090>>>>>>>    // returns itself. If it is not, it uses SkinPath to get the path.
80090>>>>>>>    Function SkinQFile Returns String
80092>>>>>>>        String sFile sPath sSep
80092>>>>>>>        Boolean bQualified
80092>>>>>>>        Get psSkinFile to sFile
80093>>>>>>>        If not (IsFileNameQualified(sFile)) Begin
80095>>>>>>>            Get SkinPath to sPath
80096>>>>>>>            Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
80097>>>>>>>            Move (sPath - sSep - sFile) to sFile
80098>>>>>>>        End
80098>>>>>>>>
80098>>>>>>>        Function_Return sFile
80099>>>>>>>    End_Function
80100>>>>>>>        
80100>>>>>>>    // defines the default VDF window class mapping.    
80100>>>>>>>    Procedure OnAddVDFWindowClasses
80102>>>>>>>        Send ComAddWindowClass "DFlistbox"               "ListBox"
80103>>>>>>>        Send ComAddWindowClass "DFentry"                 "Edit"
80104>>>>>>>        Send ComAddWindowClass "DFtextbox"               "Edit"
80105>>>>>>>        Send ComAddWindowClass "DFRichEditCtrl"          "Edit"
80106>>>>>>>        Send ComAddWindowClass "DFcombobox"              "ComboBox"
80107>>>>>>>        Send ComAddWindowClass "DFformlist"              "Edit"
80108>>>>>>>        Send ComAddWindowClass "DFFormListHeader"        "SysHeader32"
80109>>>>>>>        Send ComAddWindowClass "DFbutton"                "Button"
80110>>>>>>>        Send ComAddWindowClass "HPromptBtn"              "Button"
80111>>>>>>>        Send ComAddWindowClass "Hspinbtn"                "msctls_updown32"
80112>>>>>>>        Send ComAddWindowClass "DFSysTabControl32"       "SysTabControl32"
80113>>>>>>>        Send ComAddWindowClass "DFMDIClient"             "MDIClient" 
80114>>>>>>>        Send ComAddWindowClass "DFedit"                  "edit"
80115>>>>>>>        Send ComAddWindowClass "DFlistedit"              "edit"
80116>>>>>>>        Send ComAddWindowClass "DFscrollbar"             "scrollbar"
80117>>>>>>>        Send ComAddWindowClass "DFgroup"                 "Button"
80118>>>>>>>        Send ComAddWindowClass "DFComboGrid"             "ComboBox"
80119>>>>>>>        // External class
80119>>>>>>>        Send ComAddWindowClass "cVdfAnimation"           "SysAnimate32"
80120>>>>>>>        Send ComAddWindowClass "cVdfProgressBar"         "msctls_progress32"
80121>>>>>>>        Send ComAddWindowClass "cVdfStatusBar"           "msctls_statusbar32"
80122>>>>>>>        Send ComAddWindowClass "cVdfToolbar"             "ToolbarWindow32"
80123>>>>>>>        Send ComAddWindowClass "cObsoleteVdfProgressBar" "msctls_progress32"
80124>>>>>>>        Send ComAddWindowClass "cVdfTrackBar"            "msctls_trackbar32"
80125>>>>>>>        Send ComAddWindowClass "cObsoleteBasicStatusBar" "msctls_statusbar32"
80126>>>>>>>        Send ComAddWindowClass "cVdfTreeView"            "SysTreeView32"
80127>>>>>>>    End_Procedure
80128>>>>>>>    
80128>>>>>>>    // Used to support developer designed class mappings (e.g. COM controls)
80128>>>>>>>    Procedure OnAddCustomWindowClasses
80130>>>>>>>    End_Procedure
80131>>>>>>>
80131>>>>>>>    // called when object is created during end_construct_object.
80131>>>>>>>    Procedure OnCreate
80133>>>>>>>        Integer iOpts
80133>>>>>>>        Boolean bUseWindowsFont
80133>>>>>>>        Forward Send OnCreate
80135>>>>>>>        
80135>>>>>>>        // if we are using the windows fonts we will disable the apply metrics which
80135>>>>>>>        // never really looked good anyway. This test only exists or legacy purposes
80135>>>>>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
80136>>>>>>>        If bUseWindowsFont Begin
80138>>>>>>>            Get ComApplyOptions to iOpts
80139>>>>>>>            Set ComApplyOptions to (RemoveBitValue(xtpSkinApplyMetrics, iOpts))
80140>>>>>>>        End
80140>>>>>>>>
80140>>>>>>>
80140>>>>>>>        // this works around a CJ issue where skins applied to other threads causes an exception upon close down. 
80140>>>>>>>        // We saw this with our mssql driver but it could occur elsewhere. This has been reported in the CJ newsgroup
80140>>>>>>>        // and this was the suggested workaround.
80140>>>>>>>        Set ComAutoApplyNewThreads to False
80141>>>>>>>
80141>>>>>>>        Send OnAddVDFWindowClasses
80142>>>>>>>        Send OnAddCustomWindowClasses
80143>>>>>>>        
80143>>>>>>>        // if preferences are used, it will set psSkinFile and psSkinIni
80143>>>>>>>        If (pbLoadPreference(Self)) Begin
80145>>>>>>>            Send LoadSkinPreference
80146>>>>>>>        End
80146>>>>>>>>
80146>>>>>>>        // if a skin file name exists, we apply the skin.    
80146>>>>>>>        If (psSkinFile(Self)<>"") Begin
80148>>>>>>>            Send ApplySkin
80149>>>>>>>        End        
80149>>>>>>>>
80149>>>>>>>    End_Procedure
80150>>>>>>>    
80150>>>>>>>    // called by framework as part of application exit.
80150>>>>>>>    Procedure Broadcast_Notify_Exit_Application
80152>>>>>>>        Send Notify_Exit_Application
80153>>>>>>>    End_Procedure // Notify_Exit_Application
80154>>>>>>>
80154>>>>>>>    Procedure Notify_Exit_Application
80156>>>>>>>        If (pbLoadPreference(Self)) Begin
80158>>>>>>>            Send SaveSkinPreference
80159>>>>>>>        End
80159>>>>>>>>
80159>>>>>>>    End_Procedure
80160>>>>>>>
80160>>>>>>>    Procedure NotifyPreApplySkin
80162>>>>>>>        Broadcast Send OnPreApplySkin of Desktop True       
80164>>>>>>>    End_Procedure
80165>>>>>>>
80165>>>>>>>    Procedure NotifyPostApplySkin
80167>>>>>>>        Broadcast Send OnPostApplySkin of Desktop True       
80169>>>>>>>    End_Procedure
80170>>>>>>>    
80170>>>>>>>    // returns an array of all skins in the path. If path is "", use the default path.
80170>>>>>>>    // If the default path is used, returns the file names as relative names, else use full path.
80170>>>>>>>    Function EnumerateSkins String sPath Boolean bRecursive Returns tSkinInformation[]
80172>>>>>>>        tSkinInformation[] Skins
80172>>>>>>>        tSkinInformation[] Skins
80173>>>>>>>        String sSkinName sSkinFile sDefaultPath sSep
80173>>>>>>>        Variant vSkinDescriptions vSkinDescription vSkinIniFile
80173>>>>>>>        Handle hSkinDescriptions hSkinDescription hSkinIniFile
80173>>>>>>>        Integer iSkinsCount iSkinFilesCount iNumSkins iNumSkinFiles iArrayItem
80173>>>>>>>        Integer iPos iDfltLen
80173>>>>>>>        Boolean bUseRelativePath
80173>>>>>>>        
80173>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
80174>>>>>>>        
80174>>>>>>>        Get SkinPath to sDefaultPath
80175>>>>>>>        If (sPath="") Begin
80177>>>>>>>            Move sDefaultPath to sPath
80178>>>>>>>        End
80178>>>>>>>>
80178>>>>>>>        Move (Uppercase(sDefaultPath)) to sDefaultPath
80179>>>>>>>        Move (Length(sDefaultPath)) to iDfltLen
80180>>>>>>>        Move (sDefaultPath=Uppercase(sPath)) to bUseRelativePath
80181>>>>>>>
80181>>>>>>>        Get ComEnumerateSkinDirectory sPath bRecursive to vSkinDescriptions
80182>>>>>>>        If (not(IsNullComObject(vSkinDescriptions))) Begin
80184>>>>>>>
80184>>>>>>>            Get Create U_cCJSkinDescriptions to hSkinDescriptions
80185>>>>>>>            Get Create U_cCJSkinDescription to hSkinDescription
80186>>>>>>>            Get Create U_cCJSkinIniFile to hSkinIniFile
80187>>>>>>>            
80187>>>>>>>            Set pvComObject of hSkinDescriptions to vSkinDescriptions
80188>>>>>>>            Get ComCount of hSkinDescriptions to iNumSkinFiles
80189>>>>>>>            
80189>>>>>>>            For iSkinFilesCount from 0 to (iNumSkinFiles-1)
80195>>>>>>>>
80195>>>>>>>                Get ComSkin of hSkinDescriptions iSkinFilesCount to vSkinDescription
80196>>>>>>>                Set pvComObject of hSkinDescription to vSkinDescription
80197>>>>>>>
80197>>>>>>>                Get ComCount of hSkinDescription to iNumSkins
80198>>>>>>>                    
80198>>>>>>>                For iSkinsCount from 0 to (iNumSkins-1)
80204>>>>>>>>
80204>>>>>>>                    Get ComIniFile of hSkinDescription iSkinsCount to vSkinIniFile
80205>>>>>>>                    Set pvComObject of hSkinIniFile to vSkinIniFile
80206>>>>>>>
80206>>>>>>>                    Get ComName of hSkinDescription to Skins[iArrayItem].sName
80207>>>>>>>                    Get ComPath of hSkinDescription to sSkinFile
80208>>>>>>>                    If bUseRelativePath Begin
80210>>>>>>>                        Move (pos(sDefaultPath,uppercase(sSkinFile))) to iPos
80211>>>>>>>                        If iPos Begin
80213>>>>>>>                            Move (Remove(sSkinFile,iPos,iDfltLen)) to sSkinFile   
80214>>>>>>>                            While (Left(sSkinFile,1)=sSep)
80218>>>>>>>                                Move (Remove(sSkinFile,1,1)) to sSkinFile   
80219>>>>>>>                            Loop                         
80220>>>>>>>>
80220>>>>>>>                        End
80220>>>>>>>>
80220>>>>>>>                    End
80220>>>>>>>>
80220>>>>>>>                    Move sSkinFile to Skins[iArrayItem].sSkinfile
80221>>>>>>>                    Get ComIniFileName of hSkinIniFile to Skins[iArrayItem].sSkinIni
80222>>>>>>>
80222>>>>>>>                    Increment iArrayItem
80223>>>>>>>                Loop
80224>>>>>>>>
80224>>>>>>>            Loop
80225>>>>>>>>
80225>>>>>>>                            
80225>>>>>>>            Send Destroy of hSkinDescriptions
80226>>>>>>>            Send Destroy of hSkinDescription
80227>>>>>>>            Send Destroy of hSkinIniFile
80228>>>>>>>                
80228>>>>>>>        End
80228>>>>>>>>
80228>>>>>>>        Function_Return Skins
80229>>>>>>>    End_Function 
80230>>>>>>>    
80230>>>>>>>    // Save the skin preference. This requires an application object.
80230>>>>>>>    // Only do this if the application object allows it. 
80230>>>>>>>    // This is called during startup if pbLoadPreference is True
80230>>>>>>>    // Suitable for override
80230>>>>>>>    Procedure SaveSkinPreference 
80232>>>>>>>        String sSkin sIni
80232>>>>>>>        If ghoApplication Begin
80234>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
80236>>>>>>>                Get psSkinFile to sSkin
80237>>>>>>>                Get psSkinIni to sIni
80238>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinFile" sSkin
80239>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinIni" sIni
80240>>>>>>>            End
80240>>>>>>>>
80240>>>>>>>        End
80240>>>>>>>>
80240>>>>>>>        Else Begin
80241>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
80242>>>>>>>>
80242>>>>>>>        End
80242>>>>>>>>
80242>>>>>>>    End_Procedure
80243>>>>>>>
80243>>>>>>>    // Load the skin preference. This requires an application object.
80243>>>>>>>    // Only do this if the application object allows it. 
80243>>>>>>>    // This is called during startup if pbLoadPreference is True
80243>>>>>>>    // Suitable for override
80243>>>>>>>    Procedure LoadSkinPreference 
80245>>>>>>>        String sSkin sIni
80245>>>>>>>        Boolean bExists
80245>>>>>>>        If ghoApplication Begin
80247>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
80249>>>>>>>                Get ValueExists of ghoApplication "Preferences" "SkinFile" to bExists
80250>>>>>>>                If bExists Begin
80252>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinFile" "" to sSkin
80253>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinIni" "" to sIni
80254>>>>>>>                    Set psSkinFile to sSkin
80255>>>>>>>                    Set psSkinIni to sIni
80256>>>>>>>                End
80256>>>>>>>>
80256>>>>>>>            End
80256>>>>>>>>
80256>>>>>>>        End
80256>>>>>>>>
80256>>>>>>>        Else Begin
80257>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
80258>>>>>>>>
80258>>>>>>>        End
80258>>>>>>>>
80258>>>>>>>    End_Procedure
80259>>>>>>>
80259>>>>>>>    // Can be called to apply the current skin.
80259>>>>>>>    Procedure ApplySkin
80261>>>>>>>        Boolean bOk
80261>>>>>>>        String sSkin sIni
80261>>>>>>>        If (IsComObjectCreated(Self)) Begin
80263>>>>>>>            Get SkinQFile to sSkin
80264>>>>>>>            Get psSkinIni to sIni
80265>>>>>>>            
80265>>>>>>>            Send NotifyPreApplySkin
80266>>>>>>>            // when skins are used we don't want to use built in Visual Styles
80266>>>>>>>            Send EnableVisualStyles of Desktop (sSkin="")
80267>>>>>>>            Get ComLoadSkin sSkin sIni to bOK
80268>>>>>>>            If (sSkin<>"" and not(bOk)) Begin
80270>>>>>>>                // if not ok, no skin was appied. Enable visual styles
80270>>>>>>>                Send EnableVisualStyles of Desktop True
80271>>>>>>>            End
80271>>>>>>>>
80271>>>>>>>            Send NotifyPostApplySkin
80272>>>>>>>        End
80272>>>>>>>>
80272>>>>>>>    End_Procedure
80273>>>>>>>
80273>>>>>>>
80273>>>>>>>End_Class
80274>>>>>Use cProgressBar.pkg
Including file: cProgressBar.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cProgressBar.pkg)
80274>>>>>>>Use Windows.pkg
80274>>>>>>>Use cWinControl.pkg
80274>>>>>>>Use CommCtrl.pkg
80274>>>>>>>
80274>>>>>>>Type tPbRange
80274>>>>>>>    Field tPbRange.iLow  as DWord
80274>>>>>>>    Field tPbRange.iHigh as DWord
80274>>>>>>>End_Type
80274>>>>>>>
80274>>>>>>>//{ OverrideProperty=pbEnabled DesignTime=False }
80274>>>>>>>Class cProgressBar is a cWinControl
80275>>>>>>>
80275>>>>>>>    Procedure Construct_Object
80277>>>>>>>        Forward Send Construct_Object
80279>>>>>>>        Property Integer private_piMinimum
80280>>>>>>>        Property Integer private_piMaximum   100
80281>>>>>>>        Property Integer private_piAdvanceBy 10
80282>>>>>>>        Property Integer private_piPosition
80283>>>>>>>        Property Integer private_pbVertical  False
80284>>>>>>>        Property Integer private_pbSmooth    False
80285>>>>>>>        Property Integer private_piBackColor clDefault
80286>>>>>>>        Property Integer private_piBarColor  clDefault
80287>>>>>>>
80287>>>>>>>        Send Define_ToolTip_Support_Mixin
80288>>>>>>>
80288>>>>>>>        Set External_Class_Name 'cVdfProgressBar' To 'msctls_progress32'
80289>>>>>>>        Set Focus_Mode to NonFocusable
80290>>>>>>>        Set Skip_State to True
80291>>>>>>>        Set pbUseFormWindowHandle to False     // Must come after Define_ToolTip_Support_Mixin
80292>>>>>>>    End_Procedure
80293>>>>>>>
80293>>>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
80294>>>>>>>
80294>>>>>>>    Procedure Set piMinimum Integer iMin
80296>>>>>>>        Integer iMax
80296>>>>>>>
80296>>>>>>>        Set private_piMinimum to iMin
80297>>>>>>>        Get private_piMaximum To iMax
80298>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
80299>>>>>>>    End_Procedure
80300>>>>>>>    Function piMinimum Returns Integer
80302>>>>>>>        If (Window_Handle(self)) Function_Return (WindowsMessage(PBM_GETRANGE, 1, 0))
80305>>>>>>>        Else Function_Return (private_piMinimum(self))
80307>>>>>>>    End_Function
80308>>>>>>>
80308>>>>>>>    Procedure Set piMaximum Integer iMax
80310>>>>>>>        Integer iMin
80310>>>>>>>
80310>>>>>>>        Set private_piMaximum to iMax
80311>>>>>>>        Get private_piMinimum To iMin
80312>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
80313>>>>>>>    End_Procedure
80314>>>>>>>    Function piMaximum Returns Integer
80316>>>>>>>        If (Window_Handle(self)) Function_Return (WindowsMessage(PBM_GETRANGE, 0, 0))
80319>>>>>>>        Else Function_Return (private_piMaximum(self))
80321>>>>>>>    End_Function
80322>>>>>>>
80322>>>>>>>    Procedure Set piAdvanceBy Integer iAdvanceBy
80324>>>>>>>        Set private_piAdvanceBy To iAdvanceBy
80325>>>>>>>        Send Windows_Message PBM_SETSTEP iAdvanceBy 0
80326>>>>>>>    End_Procedure
80327>>>>>>>    Function piAdvanceBy Returns Integer
80329>>>>>>>        Function_Return (private_piAdvanceBy(self))
80330>>>>>>>    End_Function
80331>>>>>>>
80331>>>>>>>    Procedure Set piPosition Integer iPos
80333>>>>>>>        Set private_piPosition To iPos
80334>>>>>>>        Send Windows_Message PBM_SETPOS iPos 0
80335>>>>>>>    End_Procedure
80336>>>>>>>
80336>>>>>>>    Function piPosition Returns Integer
80338>>>>>>>        If (Window_Handle(self)) Function_Return (WindowsMessage(PBM_GETPOS, 0, 0))
80341>>>>>>>        Else Function_Return (private_piPosition(self))
80343>>>>>>>    End_Function
80344>>>>>>>
80344>>>>>>>    Procedure Set pbVertical Boolean bVertical
80346>>>>>>>        If (private_pbVertical(self) <> bVertical) Begin
80348>>>>>>>            Set private_pbVertical To bVertical
80349>>>>>>>           Send DoRecreateWindow
80350>>>>>>>        End
80350>>>>>>>>
80350>>>>>>>    End_Procedure
80351>>>>>>>
80351>>>>>>>    Function pbVertical Returns Boolean
80353>>>>>>>        Function_Return (private_pbVertical(self))
80354>>>>>>>    End_Function
80355>>>>>>>
80355>>>>>>>    Procedure Set pbSmooth Boolean bSmooth
80357>>>>>>>        If (private_pbSmooth(self) <> bSmooth) Begin
80359>>>>>>>           Set private_pbSmooth To bSmooth
80360>>>>>>>           Send DoRecreateWindow
80361>>>>>>>        End
80361>>>>>>>>
80361>>>>>>>    End_Procedure
80362>>>>>>>    Function pbSmooth Returns Boolean
80364>>>>>>>        Function_Return (private_pbSmooth(self))
80365>>>>>>>    End_Function
80366>>>>>>>
80366>>>>>>>    Procedure Set piBackColor Integer rgbColor
80368>>>>>>>        Set private_piBackColor To rgbColor
80369>>>>>>>        Send Windows_Message PBM_SETBKCOLOR 0 rgbColor
80370>>>>>>>    End_Procedure
80371>>>>>>>    Function piBackColor Returns Integer
80373>>>>>>>        Function_Return (private_piBackColor(self))
80374>>>>>>>    End_Function
80375>>>>>>>
80375>>>>>>>    Procedure Set piBarColor Integer rgbColor
80377>>>>>>>        Set private_piBarColor To rgbColor
80378>>>>>>>        Send Windows_Message PBM_SETBARCOLOR 0 rgbColor
80379>>>>>>>    End_Procedure
80380>>>>>>>    Function piBarColor Returns Integer
80382>>>>>>>        Function_Return (private_piBarColor(self))
80383>>>>>>>    End_Function
80384>>>>>>>
80384>>>>>>>    Procedure DoAdvance
80386>>>>>>>        Send Windows_Message PBM_STEPIT 0 0
80387>>>>>>>    End_procedure
80388>>>>>>>
80388>>>>>>>    Procedure DoAdvanceBy  Integer iAdvanceBy
80390>>>>>>>        Send Windows_Message PBM_DELTAPOS iAdvanceBy 0
80391>>>>>>>    End_procedure
80392>>>>>>>
80392>>>>>>>    Procedure private_DoInitWindow
80394>>>>>>>        Set piBarColor  To (private_piBarColor(self))
80395>>>>>>>        Set piBackColor To (private_piBackColor(self))
80396>>>>>>>        Set piAdvanceBy To (private_piAdvanceBy(self))
80397>>>>>>>        Set piMinimum   To (private_piMinimum(self))
80398>>>>>>>        Set piMaximum   To (private_piMaximum(self))
80399>>>>>>>        Set piPosition  To (private_piPosition(self))
80400>>>>>>>    End_Procedure
80401>>>>>>>
80401>>>>>>>    Procedure Page_Object Integer iState
80403>>>>>>>        Handle hWnd
80403>>>>>>>
80403>>>>>>>        Get Window_Handle To hWnd
80404>>>>>>>        If (hWnd=0 and iState) Begin
80406>>>>>>>            Set Window_Style To PBS_VERTICAL (private_pbVertical(self))
80407>>>>>>>            Set Window_Style To PBS_SMOOTH   (private_pbSmooth(self))
80408>>>>>>>            Forward Send Page_Object True
80410>>>>>>>        End
80410>>>>>>>>
80410>>>>>>>        Else Forward Send Page_Object iState
80413>>>>>>>     
80413>>>>>>>        // Handle tooltip support....
80413>>>>>>>        If (iState = 0) Begin
80415>>>>>>>            Send RequestDeleteToolTip
80416>>>>>>>        End 
80416>>>>>>>>
80416>>>>>>>        Else Begin
80417>>>>>>>            Send RequestAddToolTip
80418>>>>>>>        End
80418>>>>>>>>
80418>>>>>>>    End_Procedure
80419>>>>>>>
80419>>>>>>>    Procedure Page Integer iState
80421>>>>>>>        Forward Send Page iState
80423>>>>>>>        If (iState =1) Send private_DoInitWindow
80426>>>>>>>    End_Procedure
80427>>>>>>>
80427>>>>>>>    // Called by Page_Object. Handles tooltip creation. We use a dedicated
80427>>>>>>>    // method to perform AddToolTip because it is often the case that Page_Object
80427>>>>>>>    // is implemented in a mixin class.
80427>>>>>>>    Procedure RequestAddToolTip
80429>>>>>>>        Send AddToolTip
80430>>>>>>>    End_Procedure  // RequestAddToolTip
80431>>>>>>>
80431>>>>>>>
80431>>>>>>>    // Called by Page_Object. Handles tooltip removal. 
80431>>>>>>>    Procedure RequestDeleteToolTip
80433>>>>>>>        Send DeleteToolTip
80434>>>>>>>    End_Procedure // RequestDeleteToolTip
80435>>>>>>>End_Class
80436>>>>>Use Windows.pkg
80436>>>>>
80436>>>>>
80436>>>>>    Global_Variable Handle ghoProgressBar // will contain the ID of the embedded progress bar.
80436>>>>>
80436>>>>>    Global_Variable Handle ghoProgressBarOverall // will contain the ID of the embedded progress bar with overall results
80436>>>>>
80436>>>>>Object Status_Panel is a cProcessStatusPanel
80438>>>>>    Set Size to 148 222
80439>>>>>    Set Border_Style to Border_Dialog
80440>>>>>//    Set Sysmenu_Icon to False
80440>>>>>//    Set Icon to "DbUpdateFrameworkdf19.ico" 
80440>>>>>    Set Icon to "Default.ico"
80441>>>>>    Move Self to ghoStatusPanel // this can be used throughout the applicaton to access this object
80442>>>>>
80442>>>>>    Property Boolean Cancel_Button_Visible_State True
80444>>>>>
80444>>>>>    Procedure Activate
80447>>>>>        Integer iSizeBefore
80447>>>>>        Get GuiSize to iSizeBefore
80448>>>>>        Forward Send Activate
80450>>>>>        Set GuiSize to (Hi(iSizeBefore)) (Low(iSizeBefore))
80451>>>>>    End_Procedure
80452>>>>>
80452>>>>>    Procedure End_Construct_Object
80455>>>>>        Forward Send End_Construct_Object
80457>>>>>        Set Label of oTitleTxt      to ""
80458>>>>>        Set Label of oTableNameTxt  to ""
80459>>>>>        Set Label of oMessageTxt    to ""
80460>>>>>        Set Label of oActionTxt     to ""
80461>>>>>    End_Procedure
80462>>>>>
80462>>>>>    Object oTitleTxt is a TextBox
80464>>>>>        Set Location to 5 21
80465>>>>>        Set Size to 8 179
80466>>>>>        Set Auto_Size_State to False
80467>>>>>        Set Justification_Mode  to jMode_Center
80468>>>>>        Set Label to "This is the Title Text"
80469>>>>>    End_Object
80470>>>>>
80470>>>>>    Object oTableNameTxt is a TextBox
80472>>>>>        Set Size to 19 204
80473>>>>>        Set Location to 18 9
80474>>>>>        Set Auto_Size_State to False
80475>>>>>        Set Justification_Mode to JMode_Left
80476>>>>>        Set Label to "This is the TableName Text"
80477>>>>>    End_Object
80478>>>>>
80478>>>>>    Object oMessageTxt is a TextBox
80480>>>>>        Set Location to 39 9
80481>>>>>        Set Size to 19 204
80482>>>>>        Set Auto_Size_State to False
80483>>>>>        Set Justification_Mode to JMode_Left
80484>>>>>        Set Label to "This is the Message text"
80485>>>>>    End_Object
80486>>>>>
80486>>>>>    Object oActionTxt is a TextBox
80488>>>>>        Set Size to 16 204
80489>>>>>        Set Location to 60 9
80490>>>>>        Set Auto_Size_State to False
80491>>>>>        Set Justification_Mode to JMode_Left
80492>>>>>        Set Label to "This is the Action Text"
80493>>>>>    End_Object
80494>>>>>
80494>>>>>    Object oStopButton is a Button
80496>>>>>        Set Location to 120 82
80497>>>>>        Set Label to C_$Cancel
80498>>>>>
80498>>>>>        Procedure OnClick
80501>>>>>            Send Close_panel
80502>>>>>        End_Procedure
80503>>>>>
80503>>>>>    End_Object
80504>>>>>
80504>>>>>    Object oPercentage_tb is a TextBox
80506>>>>>        Set Location to 74 196
80507>>>>>        Set Size to 10 25
80508>>>>>//        Set Label to "% Done"
80508>>>>>    End_Object
80509>>>>>
80509>>>>>    Object oCopyRight is a TextBox
80511>>>>>        Set Location to 137 21
80512>>>>>        Set Size to 9 197
80513>>>>>        Set FontPointHeight to 8
80514>>>>>        Set Auto_Size_State to False
80515>>>>>        Set Justification_Mode  to jMode_Center
80516>>>>>        Set Label to "Copyright 2001-2018 RDC Tools International"
80517>>>>>    End_Object
80518>>>>>
80518>>>>>    Object oProgressBar is a cProgressBar
80520>>>>>        Set Size to 10 179
80521>>>>>        Set Location to 83 22
80522>>>>>        Set pbVisible to True // default
80523>>>>>        Move Self to ghoProgressBar // this can be used throughout your application to access the progress bar
80524>>>>>    End_Object
80525>>>>>
80525>>>>>    Procedure Set Progress_Bar_Visible_State Boolean bVisible
80528>>>>>        Set pbVisible of ghoProgressBar to bVisible
80529>>>>>    End_Procedure
80530>>>>>
80530>>>>>    Function Progress_Bar_Visible_State Returns Boolean
80533>>>>>        Boolean bVisible
80533>>>>>        Get pbVisible of ghoProgressBar to bVisible
80534>>>>>        Function_Return (bVisible)
80535>>>>>    End_Function
80536>>>>>
80536>>>>>    Object oProgressBarOverall is a cProgressBar
80538>>>>>        Set Size to 10 179
80539>>>>>        Set Location to 104 22
80540>>>>>        Set pbVisible to True // default
80541>>>>>        Move Self to ghoProgressBarOverall // this can be used throughout your application to access the progress bar
80542>>>>>    End_Object
80543>>>>>
80543>>>>>    Object oOverallProgress_tb is a TextBox
80545>>>>>        Set Size to 10 65
80546>>>>>        Set Location to 95 24
80547>>>>>        Set Label to "Overall Progress"
80548>>>>>    End_Object
80549>>>>>
80549>>>>>    Procedure Set Progress_Bar_Overall_Visible_State Boolean bVisible
80552>>>>>        Set pbVisible of ghoProgressBarOverall to bVisible
80553>>>>>    End_Procedure
80554>>>>>
80554>>>>>    Function Progress_Bar_Overall_Visible_State Returns Boolean
80557>>>>>        Boolean bVisible
80557>>>>>        Get pbVisible of ghoProgressBarOverall to bVisible
80558>>>>>        Function_Return (bVisible)
80559>>>>>    End_Function
80560>>>>>
80560>>>>>    // These messages bind the standard cProcessStatusPanel interface to the actual
80560>>>>>    // objects defined within this instance of the status panel.
80560>>>>>
80560>>>>>    // note: all of the messages that change text should be forwarded
80560>>>>>    // as the forwarded messages allows the panel to paint when in a tight loop
80560>>>>>
80560>>>>>    Procedure Set Message_Text String sText
80563>>>>>        Set Label of oMessageTxt to sText
80564>>>>>        Forward Set Message_Text to sText
80566>>>>>    End_Procedure
80567>>>>>
80567>>>>>    Function Message_Text Returns String
80570>>>>>        Function_Return (Label(oMessageTxt))
80571>>>>>    End_Function
80572>>>>>
80572>>>>>    Procedure Set Action_Text String sText
80575>>>>>        Set Label of oActionTxt to sText
80576>>>>>        Forward Set Action_Text to sText
80578>>>>>    End_Procedure
80579>>>>>
80579>>>>>    Function Action_Text Returns String
80582>>>>>        Function_Return (Label(oActionTxt))
80583>>>>>    End_Function
80584>>>>>
80584>>>>>    Procedure Set Button_Text String sText
80587>>>>>        Set Label of oStopButton to sText
80588>>>>>        Forward Set Button_Text to sText
80590>>>>>    End_Procedure
80591>>>>>
80591>>>>>    Function Button_Text Returns String
80594>>>>>        Function_Return (Label(oStopButton))
80595>>>>>    End_Function
80596>>>>>
80596>>>>>    Procedure Set Title_Text String sText
80599>>>>>        Set Label of oTitleTxt to sText
80600>>>>>        Forward Set Title_Text to sText
80602>>>>>    End_Procedure
80603>>>>>
80603>>>>>    Function Title_Text Returns String
80606>>>>>        Function_Return (Label(oTitleTxt))
80607>>>>>    End_Function
80608>>>>>
80608>>>>>    Procedure Set TableName_Text String sText
80611>>>>>        Set Label of oTableNameTxt to sText
80612>>>>>    End_Procedure
80613>>>>>
80613>>>>>    Function TableName_Text Returns String
80616>>>>>        Function_Return (Label(oTableNameTxt))
80617>>>>>    End_Function
80618>>>>>
80618>>>>>    Procedure Set License_Text String sText
80621>>>>>//        Set Label of oLicense_txt to sText
80621>>>>>    End_Procedure
80622>>>>>
80622>>>>>    // gets called when status panel is activated passing whether a button
80622>>>>>    // should appear
80622>>>>>    Procedure EnableCancelButton Boolean bEnable
80625>>>>>        Boolean bVisible
80625>>>>>        Get Cancel_Button_Visible_State to bVisible
80626>>>>>        If (bEnable = False) Begin
80628>>>>>            Set Visible_State of oStopButton to bVisible
80629>>>>>        End
80629>>>>>>
80629>>>>>        Set Enabled_State of oStopButton to bEnable
80630>>>>>    End_Procedure
80631>>>>>
80631>>>>>    Procedure Reset_StatusPanel
80634>>>>>        Set Allow_Cancel_State of ghoStatusPanel to True
80635>>>>>        Set Cancel_Button_Visible_State of ghoStatusPanel to True
80636>>>>>        Set Progress_Bar_Visible_State  of ghoStatusPanel to True
80637>>>>>        Set Progress_Bar_Overall_Visible_State of ghoProgressBarOverall to False
80638>>>>>    End_Procedure
80639>>>>>
80639>>>>>//    Object oProgressBar is a cProgressBar
80639>>>>>//        Move Self to ghoProgressBar
80639>>>>>//        Set Location to 1 25
80639>>>>>//        Set Size to 9 173
80639>>>>>//        Set piMinimum        to 0
80639>>>>>//        Set piMaximum        to 2000
80639>>>>>//        Set piAdvanceBy      to 100
80639>>>>>//        Set pbSmooth to True
80639>>>>>//
80639>>>>>//        // For some weird reason the application skin makes the coloring of the progressbar
80639>>>>>//        // to malfunction. By telling the CodeJock SkinFramework to skip this object, the
80639>>>>>//        // color will show correctly.
80639>>>>>//        Procedure Page Integer iPageObject
80639>>>>>//            Handle hWin
80639>>>>>//            Forward Send Page iPageObject
80639>>>>>//            If (ghoSkinFramework <> 0) Begin
80639>>>>>//                Get Window_Handle to hWin
80639>>>>>//                Send ComRemoveWindow of ghoSkinFramework hWin
80639>>>>>//            End
80639>>>>>//        End_Procedure
80639>>>>>//    End_Object
80639>>>>>
80639>>>>>End_Object
80640>>>>>
80640>>>Use seq_chnl.pkg
80640>>>Use Datadict.pkg
80640>>>Use cDbUpdateHandler.inc // Contains cDbUpdateHandler class constants, structs etc.
Including file: cDbUpdateHandler.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateHandler.inc)
80640>>>>>// Constant declarations, structs etc. for the cDbUdpateHandler class.
80640>>>>>//
80640>>>>>Use VdfBase.pkg
80640>>>>>Use cApplication.pkg
80640>>>>>Use seq_chnl.pkg
80640>>>>>Use vWin32fh.pkg
Including file: vWin32fh.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\vWin32fh.pkg)
80640>>>>>>>// This code is part of VDF GUIdance
80640>>>>>>>// Visit us @ http://www.vdf-guidance.com
80640>>>>>>>// e-Mail us @ info@vdf-guidance.com
80640>>>>>>>// VDF GUIdance is a mutual project of
80640>>>>>>>// Frank Vandervelpen - Vandervelpen Systems and
80640>>>>>>>// Wil van Antwerpen  - Antwise Solutions
80640>>>>>>>// All software source code should be used <<AS IS>> without any warranty.
80640>>>>>>>//
80640>>>>>>>//
80640>>>>>>>// *** Windows 32bit file handling wrapper class ***
80640>>>>>>>//
80640>>>>>>>
80640>>>>>>>// 05-09-2000 **WvA: Changed namingconvention of all classes and methods to new standard
80640>>>>>>>//                   This may be painfull for some of you, but it was really needed as it was
80640>>>>>>>//                   getting messy. The "vs" -prefix we used before was confusing and could
80640>>>>>>>//                   unintentionally have been interpreted as "Vdf-GUIdance String".
80640>>>>>>>//
80640>>>>>>>// The used naming-convention is:
80640>>>>>>>//     - a prefix of "vWin32_" for every external function declaration
80640>>>>>>>//     - a prefix of the letter "v" for the full API name for the vdf-wrapper function.
80640>>>>>>>//
80640>>>>>>>// By using this we are guarding ourselves for conflicts with variable declarations
80640>>>>>>>// of DataAccess in the future.
80640>>>>>>>// Or at least almost as the letter "v" is now also synonym for variant (duh~!)
80640>>>>>>>//
80640>>>>>>>// mm-dd-yyyy Author Description
80640>>>>>>>//
80640>>>>>>>//                   vSHGetFolderPath added to retrieve the new shell folders
80640>>>>>>>//                   vGetWindowsDirectory
80640>>>>>>>//
80640>>>>>>>//                   vGetTempFileName
80640>>>>>>>//                   vGetTempPath
80640>>>>>>>// 11-17-2001 **WvA: Removed User Interface Error popups such as Error handling.
80640>>>>>>>//                   This is an absolute need for WebApp. We expect you to handle the
80640>>>>>>>//                   error in your application anyways. Changed this for:
80640>>>>>>>//                   vDeleteFile, vCopyFile, vMoveFile and vRenameFile
80640>>>>>>>// 03-02-2002 **WvA: vRemoveDirectory added
80640>>>>>>>// 03-11-2002 **WvA: The parameter lpdword in the external function declaration for
80640>>>>>>>//                   vWin32_SHBrowsForFolder can cause compiler errors.
80640>>>>>>>//                   It is renamed too avoid this.
80640>>>>>>>// 11-11-2002 **WvA: Codecleanup, vcSelectFile_Dialog is now cvSelectFile_Dialog, its
80640>>>>>>>//                   function vSelectedFileName is now just SelectedFileName
80640>>>>>>>//                   Removed the local keyword in the variable declarations
80640>>>>>>>// 10-17-2003 **WvA: Cleaned up function vSelect_File and added code to destroy the dynamically
80640>>>>>>>//                   created file-open dialog
80640>>>>>>>// 02-12-2004 **WvA: Allan Ankerstjeme pointed me into a bug for the vCreateTempFileInPath
80640>>>>>>>//                   in that it didn't exactly return the correct filename of the file created.
80640>>>>>>>//                   This has now been taken care of.
80640>>>>>>>// 02-19-2004 **WvA: Removed all API declarations from the package itself to improve readability
80640>>>>>>>//                   These declarations are now included from the vWin32fh header file.
80640>>>>>>>// 02-19-2004 **WvA: Changed the default way in which the standard file handling works
80640>>>>>>>//                   Before today one could always undo the operation, as of now you cannot as
80640>>>>>>>//                   the default was a silly one using unnecessary resources (mainly diskspace)
80640>>>>>>>//                   Since i don't really expect someone to use that feature it has been removed.
80640>>>>>>>//                   One can however restore to the old way of handling by simply calling the
80640>>>>>>>//                   vWin32fhCompatibilityMode procedure ONE time before accessing any of the
80640>>>>>>>//                   filehandling operations
80640>>>>>>>// 02-19-2004 **WvA: The functions ParseFolderName, ParseFileName and ParseFileExtenstion added
80640>>>>>>>//                   as well as the StringFromRightOfChar function.
80640>>>>>>>// 02-19-2004 **WvA: sfoFormatDisk function added which can use to format a floppydisk
80640>>>>>>>//                   DISABLED now as testing shows that it does not work as advertised...
80640>>>>>>>// 02-20-2004 **WvA: The function vDDE_Error_Handler didn't pass the errornumber on to the DDE_Error_To_String function
80640>>>>>>>//                   Moved the hardcoded strings from vDDE_Error_Handler to define declarations for easier translation later on.
80640>>>>>>>// 09-10-2004 **WvA: Added the ToAnsi function to the fileoperations method so that
80640>>>>>>>//                   extended characters are treated ok too.
80640>>>>>>>//                   Reported by Flemming from
80640>>>>>>>// 12-17-2004 **WvA: Changed vFilePathExists to be global, reported by Peter van Mil
80640>>>>>>>// 12-28-2004 **WvA: WebApp compatibility added by introducing compiler directives
80640>>>>>>>// 03-10-2006 **WvA: Added more CSIDL types to our header file for use with the vSHGetFolderPath function
80640>>>>>>>// 01-02-2007 **WvA: Set NoChangeDir_State on vSelect_File and vSelectSaveFile to True but changed it back due to side effects.
80640>>>>>>>//                   Added vSelectSavefile function to create a file save dialog
80640>>>>>>>//                   Fixed ParseFolderName which was horribly broken (thanks for the reports)
80640>>>>>>>//                   Added vParentPath function to retrieve the parent "node" of a path
80640>>>>>>>// 01-04-2008 **WvA: Fixed vCreateTempFileInPath as the function wasn't working
80640>>>>>>>// 10-04-2009 **WvA: Added vshCreateDirectoryEx from Micheal Mullan, moved filedialogs to cvFileDialogs.pkg
80640>>>>>>>// 01-11-2010 **WvA: Added vWin32_APIFilesize as supplied by Renato Villa, to get the filesize of the specified file. See http://support.dataaccess.com/forums/showthread.php?t=41982
80640>>>>>>>// 10-02-2011 **WvA: Added vCSIDL_SYSTEMX86, courtesy of Ola Eldoy for pointing this out and providing the define statement.
80640>>>>>>>// 20-12-2012 **WvA: Default behavior on copy/move is now to autocreate subfolders, tip by Frank Cheng
80640>>>>>>>// 29-09-2014 **WvA: Added function vFolderFileCount to count the number of files in a folder, add vCSIDL_PROGRAM_FILESx86
80640>>>>>>>// 04-10-2014 **WvA: Added extra checks on vFilePathExists and vFolderExists courtesy of Nils Svedmyr
80640>>>>>>>
80640>>>>>>>//Use Case.mac
80640>>>>>>>Use File_Dlg.pkg      // Contains OpenDialog class definition
80640>>>>>>>Use cvFileDialogs.pkg
Including file: cvFileDialogs.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cvFileDialogs.pkg)
80640>>>>>>>>>//***************************************************************************
80640>>>>>>>>>//*
80640>>>>>>>>>//* Class:        cvSaveAsDialog
80640>>>>>>>>>//* Package Name: cvFileDialogs.pkg
80640>>>>>>>>>//*
80640>>>>>>>>>//***************************************************************************
80640>>>>>>>>>
80640>>>>>>>>>Use File_dlg.pkg
80640>>>>>>>>>
80640>>>>>>>>>// *WvA: 13-01-1999 Created
80640>>>>>>>>>// The Class cSelectFile_Dialog is created to support the function Select_File
80640>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
80640>>>>>>>>>// file_name.
80640>>>>>>>>>Class cvSelectFile_Dialog Is An OpenDialog
80641>>>>>>>>>
80641>>>>>>>>>  Procedure Construct_Object Integer iImage_Id
80643>>>>>>>>>    Forward Send Construct_Object iImage_Id
80645>>>>>>>>>    Set HideReadOnly_State To True
80646>>>>>>>>>  End_Procedure // Construct_Object
80647>>>>>>>>>
80647>>>>>>>>>  Function SelectedFileName Returns String
80649>>>>>>>>>    String sFileName
80649>>>>>>>>>    Move "" To sFileName
80650>>>>>>>>>    If (Show_Dialog(Self)) Begin
80652>>>>>>>>>      Move (RTrim(File_Name(Self))) To sFileName
80653>>>>>>>>>    End
80653>>>>>>>>>>
80653>>>>>>>>>    Function_Return sFileName
80654>>>>>>>>>  End_Function // SelectedFileName
80655>>>>>>>>>End_Class // cvSelectFile_Dialog
80656>>>>>>>>>
80656>>>>>>>>>
80656>>>>>>>>>// *WvA: 13-01-1999 Created
80656>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
80656>>>>>>>>>// file_name. Returns '' if the user didn't make a selection.
80656>>>>>>>>>// **WvA: 17-10-2003 Cleaned up and added code to destroy the dynamically created
80656>>>>>>>>>//                   file-open dialog
80656>>>>>>>>>Function vSelect_File Global String sSupportedFileTypes String sCaptionText String sInitialFolder Returns String
80658>>>>>>>>>  String sSelectedFile
80658>>>>>>>>>  Integer hoOpenFileDialog
80658>>>>>>>>>
80658>>>>>>>>>  Object oOpenFileDialog Is A cvSelectFile_Dialog
80660>>>>>>>>>
80660>>>>>>>>>    Set Dialog_Caption    To sCaptionText
80661>>>>>>>>>    Set Filter_String     To sSupportedFileTypes
80662>>>>>>>>>    Set Initial_Folder    To sInitialFolder
80663>>>>>>>>>
80663>>>>>>>>>    Move Self       To hoOpenFileDialog
80664>>>>>>>>>  End_Object // oOpenFileDialog
80665>>>>>>>>>
80665>>>>>>>>>  Get SelectedFileName Of hoOpenFileDialog To sSelectedFile
80666>>>>>>>>>  Send Destroy_Object To hoOpenFileDialog
80667>>>>>>>>>  Function_Return sSelectedFile
80668>>>>>>>>>End_Function // vSelect_File
80669>>>>>>>>>
80669>>>>>>>>>
80669>>>>>>>>>Class cvSaveAsDialog is a SaveAsDialog
80670>>>>>>>>>
80670>>>>>>>>>  Procedure Construct_Object
80672>>>>>>>>>    Forward Send Construct_Object
80674>>>>>>>>>    Set HideReadOnly_State To True
80675>>>>>>>>>  End_Procedure // Construct_Object
80676>>>>>>>>>
80676>>>>>>>>>  Function SelectedFileName Returns String
80678>>>>>>>>>    String sFileName
80678>>>>>>>>>    Move "" To sFileName
80679>>>>>>>>>    If (Show_Dialog(Self)) Begin
80681>>>>>>>>>      Move (RTrim(File_Name(Self))) To sFileName
80682>>>>>>>>>    End
80682>>>>>>>>>>
80682>>>>>>>>>    Function_Return sFileName
80683>>>>>>>>>  End_Function // SelectedFileName
80684>>>>>>>>>
80684>>>>>>>>>End_Class // cvSaveAsDialog
80685>>>>>>>>>
80685>>>>>>>>>// Added optional default filename as suggested by Nils
80685>>>>>>>>>Function vSelectSaveFile Global String sSupportedFileTypes String sCaptionText String sInitialFolder String sDefaultFileName Returns String
80687>>>>>>>>>  String sSelectedFile
80687>>>>>>>>>  Integer hoDialog
80687>>>>>>>>>
80687>>>>>>>>>  Move "" To sSelectedFile
80688>>>>>>>>>  Get Create U_cvSaveAsDialog To hoDialog
80689>>>>>>>>>  If (hoDialog) Begin
80691>>>>>>>>>    //Set NoChangeDir_State Of hoDialog To True
80691>>>>>>>>>    Set Dialog_Caption    Of hoDialog To sCaptionText
80692>>>>>>>>>    Set Filter_String     Of hoDialog To sSupportedFileTypes
80693>>>>>>>>>    Set Initial_Folder    Of hoDialog To sInitialFolder
80694>>>>>>>>>    If (Num_Arguments = 4) Begin
80696>>>>>>>>>      Set File_Title        of hoDialog to sDefaultFileName
80697>>>>>>>>>    End
80697>>>>>>>>>>
80697>>>>>>>>>    Get SelectedFileName  Of hoDialog To sSelectedFile
80698>>>>>>>>>    Send Destroy Of hoDialog
80699>>>>>>>>>  End
80699>>>>>>>>>>
80699>>>>>>>>>  Function_Return sSelectedFile
80700>>>>>>>>>End_Function // vSelectSaveFile
80701>>>>>>>Use Seq_chnl.pkg
80701>>>>>>>
80701>>>>>>>Use Windows.pkg
80701>>>>>>>//Use Dferror
80701>>>>>>>Use Dll.pkg
80701>>>>>>>Use vWin32fh.h       // Header file with WinAPI declarations
Including file: vwin32fh.h    (C:\Projects\DF18\DbUpdateFramework\AppSrc\vwin32fh.h)
80701>>>>>>>>>//TH-Header
80701>>>>>>>>>//*****************************************************************************************
80701>>>>>>>>>// Copyright (c)  2004 KURANT Project
80701>>>>>>>>>// All rights reserved.
80701>>>>>>>>>//
80701>>>>>>>>>// $FileName    : G:\Projects\vWin32fh\vWin32fh.h
80701>>>>>>>>>// $ProjectName : Windows 32 bits file handling
80701>>>>>>>>>// $Authors     : Wil van Antwerpen
80701>>>>>>>>>// $Created     : 19.02.2004  19:25
80701>>>>>>>>>// $Type        : BSD (as in do with it whatever you like)
80701>>>>>>>>>//
80701>>>>>>>>>// Contents:
80701>>>>>>>>>//  This file contains the Windows API external function call definitions and
80701>>>>>>>>>//  constants as they are used in the vWin32fh package.
80701>>>>>>>>>//*****************************************************************************************
80701>>>>>>>>>//TH-RevisionStart
80701>>>>>>>>>//TH-RevisionEnd
80701>>>>>>>>>
80701>>>>>>>>>Define CS_DDE_ERR_FILE_NOT_FOUND  For "The specified file was not found.\n"
80701>>>>>>>>>Define CS_DDE_ERR_PATH_NOT_FOUND  For "The specified path was not found.\n"
80701>>>>>>>>>Define CS_DDE_ERR_BAD_FORMAT      For "The .EXE file is invalid.\n"
80701>>>>>>>>>Define CS_DDE_ERR_ACCESSDENIED    For "The operating system denied access to the specified file.\n"
80701>>>>>>>>>Define CS_DDE_ERR_ASSOCINCOMPLETE For "The filename association is incomplete or invalid.\n"
80701>>>>>>>>>Define CS_DDE_ERR_DDEBUSY         For "The DDE transaction could not be completed because other DDE\ntransactions were being processed.\n"
80701>>>>>>>>>Define CS_DDE_ERR_DDEFAIL         For "The DDE transaction failed.\n"
80701>>>>>>>>>Define CS_DDE_ERR_DDETIMEOUT      For "The DDE transaction could not be completed,\nbecause the request timed out.\n"
80701>>>>>>>>>Define CS_DDE_ERR_DLLNOTFOUND     For "The specified dynamic-link library was not found.\n"
80701>>>>>>>>>Define CS_DDE_ERR_NOASSOC         For "There is no application associated with the given filename extension.\n"
80701>>>>>>>>>Define CS_DDE_ERR_OOM             For "There is not enough free memory available to complete the operation.\n"
80701>>>>>>>>>Define CS_DDE_ERR_PNF             For "The specified path was not found.\n"
80701>>>>>>>>>Define CS_DDE_ERR_SHARE           For "A sharing violation occurred.\n"
80701>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE1   For "Unknown DDE-error occurred.\nErrornumber"
80701>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
80701>>>>>>>>>Define CS_DDE_ERR_HANDL_PAKTC     For "\nPress a key to continue...\n\n"
80701>>>>>>>>>Define CS_DDE_ERR_HANDL_CAPTION   For "a DDE-error occurred"
80701>>>>>>>>>
80701>>>>>>>>>
80701>>>>>>>>>Define vMax_Path     For |CI260
80701>>>>>>>>>Define vMinChar      For |CI$80
80701>>>>>>>>>Define vMaxChar      For |CI$7F
80701>>>>>>>>>Define vMinShort     For |CI$8000
80701>>>>>>>>>Define vMaxShort     For |CI$7FFF
80701>>>>>>>>>Define vMinLong      For |CI$80000000
80701>>>>>>>>>Define vMaxLong      For |CI$7FFFFFFF
80701>>>>>>>>>Define vMaxByte      For |CI$FF
80701>>>>>>>>>Define vMaxWord      For |CI$FFFF
80701>>>>>>>>>Define vMaxDword     For |CI$FFFFFFFF
80701>>>>>>>>>
80701>>>>>>>>>
80701>>>>>>>>>
80701>>>>>>>>>// For FindFirstFile
80701>>>>>>>>>Define vINVALID_HANDLE_VALUE   For |CI-1
80701>>>>>>>>>Define vINVALID_FILE_SIZE      For |CI$FFFFFFFF
80701>>>>>>>>>Define vERROR_NO_MORE_FILES    For |CI18
80701>>>>>>>>>
80701>>>>>>>>>// The defines below can be used to find out what kind of error has occurred if
80701>>>>>>>>>// the API-call ShellExecute is used.
80701>>>>>>>>>Define vERROR_FILE_NOT_FOUND   For |CI0002
80701>>>>>>>>>Define vERROR_PATH_NOT_FOUND   For |CI0003
80701>>>>>>>>>Define vERROR_BAD_FORMAT       For |CI0011
80701>>>>>>>>>Define vSE_ERR_ACCESSDENIED    For |CI0005
80701>>>>>>>>>Define vSE_ERR_ASSOCINCOMPLETE For |CI0027
80701>>>>>>>>>Define vSE_ERR_DDEBUSY         For |CI0030
80701>>>>>>>>>Define vSE_ERR_DDEFAIL         For |CI0029
80701>>>>>>>>>Define vSE_ERR_DDETIMEOUT      For |CI0028
80701>>>>>>>>>Define vSE_ERR_DLLNOTFOUND     For |CI0032
80701>>>>>>>>>Define vSE_ERR_FNF             For |CI0002
80701>>>>>>>>>Define vSE_ERR_NOASSOC         For |CI0031
80701>>>>>>>>>Define vSE_ERR_OOM             For |CI0008
80701>>>>>>>>>Define vSE_ERR_PNF             For |CI0003
80701>>>>>>>>>Define vSE_ERR_SHARE           For |CI0026
80701>>>>>>>>>
80701>>>>>>>>>
80701>>>>>>>>>// C-Structure
80701>>>>>>>>>//typedef struct _browseinfo {
80701>>>>>>>>>//    HWND hwndOwner;
80701>>>>>>>>>//    LPCITEMIDLIST pidlRoot;
80701>>>>>>>>>//    LPSTR pszDisplayName;
80701>>>>>>>>>//    LPCSTR lpszTitle;
80701>>>>>>>>>//    UINT ulFlags;
80701>>>>>>>>>//    BFFCALLBACK lpfn;
80701>>>>>>>>>//    LPARAM lParam;
80701>>>>>>>>>//    int iImage;
80701>>>>>>>>>//} BROWSEINFO, *PBROWSEINFO, *LPBROWSEINFO;
80701>>>>>>>>>
80701>>>>>>>>>//declare C structure struct_browseinfo
80701>>>>>>>>>//as documented in MSDN under Windows Shell API
80701>>>>>>>>>Type vtBrowseInfo
80701>>>>>>>>>  Field vtBrowseInfo.hWndOwner      as Handle
80701>>>>>>>>>  Field vtBrowseInfo.pIDLRoot       as Pointer
80701>>>>>>>>>  Field vtBrowseInfo.pszDisplayName as Pointer
80701>>>>>>>>>  Field vtBrowseInfo.lpszTitle      as Pointer
80701>>>>>>>>>  Field vtBrowseInfo.ulFlags        as dWord
80701>>>>>>>>>  Field vtBrowseInfo.lpfnCallback   as Pointer
80701>>>>>>>>>  Field vtBrowseInfo.lParam         as dWord
80701>>>>>>>>>  Field vtBrowseInfo.iImage         as dWord
80701>>>>>>>>>End_Type // tBrowseInfo
80701>>>>>>>>>
80701>>>>>>>>>// Browsing for directory.
80701>>>>>>>>>Define vBIF_RETURNONLYFSDIRS   For |CI$0001  // For finding a folder to start document searching
80701>>>>>>>>>Define vBIF_DONTGOBELOWDOMAIN  For |CI$0002  // For starting the Find Computer
80701>>>>>>>>>Define vBIF_STATUSTEXT         For |CI$0004  // Includes a status area in the dialog box.
80701>>>>>>>>>                                            // The callback function can set the status text by
80701>>>>>>>>>                                            // sending messages to the dialog box.
80701>>>>>>>>>Define vBIF_RETURNFSANCESTORS  For |CI$0008  // Only returns file system ancestors.
80701>>>>>>>>>
80701>>>>>>>>>Define vBIF_BROWSEFORCOMPUTER  For |CI$1000  // Browsing for Computers.
80701>>>>>>>>>Define vBIF_BROWSEFORPRINTER   For |CI$2000  // Browsing for Printers
80701>>>>>>>>>
80701>>>>>>>>>// message from browser
80701>>>>>>>>>//Define BFFM_INITIALIZED        1
80701>>>>>>>>>//Define BFFM_SELCHANGED         2
80701>>>>>>>>>
80701>>>>>>>>>// messages to browser
80701>>>>>>>>>//Define BFFM_SETSTATUSTEXT      (WM_USER + 100)
80701>>>>>>>>>//Define BFFM_ENABLEOK           (WM_USER + 101)
80701>>>>>>>>>//Define BFFM_SETSELECTION       (WM_USER + 102)
80701>>>>>>>>>
80701>>>>>>>>>
80701>>>>>>>>>External_function vWin32_SHBrowseForFolder "SHBrowseForFolder" shell32.dll ;  Pointer lpsBrowseInfo Returns dWord
80702>>>>>>>>>
80702>>>>>>>>>External_function vWin32_SHGetPathFromIDList "SHGetPathFromIDList" shell32.dll ;  Pointer pidList Pointer lpBuffer Returns dWord
80703>>>>>>>>>
80703>>>>>>>>>External_function vWin32_CoTaskMemFree "CoTaskMemFree" ole32.dll Pointer pV Returns Integer
80704>>>>>>>>>
80704>>>>>>>>>
80704>>>>>>>>>
80704>>>>>>>>>
80704>>>>>>>>>Type vtSecurity_attributes
80704>>>>>>>>>  Field vtSecurity_attributes.nLength        as dWord
80704>>>>>>>>>  Field vtSecurity_attributes.lpDescriptor   as Pointer
80704>>>>>>>>>  Field vtSecurity_attributes.bInheritHandle as Integer
80704>>>>>>>>>End_Type // vtSecurity_attributes
80704>>>>>>>>>
80704>>>>>>>>>//nLength:
80704>>>>>>>>>// Specifies the size, in bytes, of this structure. Set this value to the size of the
80704>>>>>>>>>// SECURITY_ATTRIBUTES structure.
80704>>>>>>>>>// Windows NT: Some functions that use the SECURITY_ATTRIBUTES structure do not verify the
80704>>>>>>>>>// value of the nLength member. However, an application should still set it properly.
80704>>>>>>>>>// That ensures current, future, and cross-platform compatibility.
80704>>>>>>>>>//
80704>>>>>>>>>//lpSecurityDescriptor:
80704>>>>>>>>>// Points to a security descriptor for the object that controls the sharing of it.
80704>>>>>>>>>// If NULL is specified for this member, the object may be assigned the default security
80704>>>>>>>>>// descriptor of the calling process.
80704>>>>>>>>>//
80704>>>>>>>>>//bInheritHandle:
80704>>>>>>>>>// Specifies whether the returned handle is inherited when a new process is created.
80704>>>>>>>>>// If this member is TRUE, the new process inherits the handle.
80704>>>>>>>>>
80704>>>>>>>>>
80704>>>>>>>>>// BOOL CreateDirectory(
80704>>>>>>>>>//    LPCTSTR lpPathName,
80704>>>>>>>>>//    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // pointer to a security descriptor
80704>>>>>>>>>//   );
80704>>>>>>>>>//
80704>>>>>>>>>// lpPathName
80704>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
80704>>>>>>>>>//  to be created.
80704>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
80704>>>>>>>>>//  This limit is related to how the CreateDirectory function parses paths.
80704>>>>>>>>>// lpSecurityAttributes
80704>>>>>>>>>//  Pointer to a SECURITY_ATTRIBUTES structure als called a security descriptor that
80704>>>>>>>>>//  determines whether the returned handle can be inherited by child processes.
80704>>>>>>>>>//  If lpSecurityAttributes is NULL, the handle cannot be inherited.
80704>>>>>>>>>// Returns:
80704>>>>>>>>>//  If the function succeeds, the return value is nonzero.
80704>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
80704>>>>>>>>>External_function vWin32_CreateDirectory "CreateDirectoryA" kernel32.dll ;  Pointer lpPathName Pointer lpSecurity_Attributes Returns Integer
80705>>>>>>>>>
80705>>>>>>>>>
80705>>>>>>>>>// lpPathName
80705>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
80705>>>>>>>>>//  to be removed.
80705>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
80705>>>>>>>>>// Returns:
80705>>>>>>>>>//  If the function succeeds, the return value is nonzero.
80705>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
80705>>>>>>>>>External_function vWin32_RemoveDirectory "RemoveDirectoryA" kernel32.dll ;  Pointer lpPathName Returns Integer
80706>>>>>>>>>
80706>>>>>>>>>
80706>>>>>>>>>
80706>>>>>>>>>// The ShellExecute function opens or prints a specified file. The file can be an
80706>>>>>>>>>// executable file or a document file.
80706>>>>>>>>>//
80706>>>>>>>>>// Operation can be one of the following:
80706>>>>>>>>>//    "OPEN"  The function opens the file specified by lpFile.
80706>>>>>>>>>//            The file can be an executable file or a document file.
80706>>>>>>>>>//            The file can be a folder to open.
80706>>>>>>>>>//    "PRINT" The function prints the file specified by lpFile.
80706>>>>>>>>>//            The file should be a document file. If the file is an executable file,
80706>>>>>>>>>//            the function opens the file, as if "open" had been specified.
80706>>>>>>>>>//  "EXPLORE" The function explores the folder specified by lpFile.
80706>>>>>>>>>//
80706>>>>>>>>>// Return Values:
80706>>>>>>>>>//
80706>>>>>>>>>// If the function succeeds, the return value is the instance handle of the application that
80706>>>>>>>>>// was run, or the handle of a dynamic data exchange (DDE) server application.
80706>>>>>>>>>// If the function fails, the return value is an error value that is less than or equal to 32.
80706>>>>>>>>>//
80706>>>>>>>>>// The following table lists these error values:
80706>>>>>>>>>// Public Const ERROR_FILE_NOT_FOUND = 2&
80706>>>>>>>>>// Public Const ERROR_PATH_NOT_FOUND = 3&
80706>>>>>>>>>// Public Const ERROR_BAD_FORMAT = 11&
80706>>>>>>>>>// Public Const SE_ERR_ACCESSDENIED = 5
80706>>>>>>>>>// Public Const SE_ERR_ASSOCINCOMPLETE = 27
80706>>>>>>>>>// Public Const SE_ERR_DDEBUSY = 30
80706>>>>>>>>>// Public Const SE_ERR_DDEFAIL = 29
80706>>>>>>>>>// Public Const SE_ERR_DDETIMEOUT = 28
80706>>>>>>>>>// Public Const SE_ERR_DLLNOTFOUND = 32
80706>>>>>>>>>// Public Const SE_ERR_FNF = 2
80706>>>>>>>>>// Public Const SE_ERR_NOASSOC = 31
80706>>>>>>>>>// Public Const SE_ERR_OOM = 8
80706>>>>>>>>>// Public Const SE_ERR_PNF = 3
80706>>>>>>>>>// Public Const SE_ERR_SHARE = 26
80706>>>>>>>>>
80706>>>>>>>>>
80706>>>>>>>>>
80706>>>>>>>>>// Code to open the program that is associated with the selected file.
80706>>>>>>>>>//
80706>>>>>>>>>// External function call used in Procedure DoStartDocument
80706>>>>>>>>>External_function vWin32_ShellExecute "ShellExecuteA" shell32.dll ;  Handle hWnd ;  Pointer lpOperation ;  Pointer lpFile ;  Pointer lpParameters ;  Pointer lpDirectory ;  Dword iShowCmd Returns Handle
80707>>>>>>>>>
80707>>>>>>>>>
80707>>>>>>>>>
80707>>>>>>>>>
80707>>>>>>>>>
80707>>>>>>>>>                                          // Must be freed using SHFreeNameMappings
80707>>>>>>>>>
80707>>>>>>>>>Type vtShFileOpStruct
80707>>>>>>>>>  Field vtShFileOpStruct.hWnd                   as Handle
80707>>>>>>>>>  Field vtShFileOpStruct.wFunc                  as Integer
80707>>>>>>>>>  Field vtShFileOpStruct.pFrom                  as Pointer
80707>>>>>>>>>  Field vtShFileOpStruct.pTo                    as Pointer
80707>>>>>>>>>  Field vtShFileOpStruct.fFlags                 as Short
80707>>>>>>>>>  Field vtShFileOpStruct.fAnyOperationsAborted  as Short
80707>>>>>>>>>  Field vtShFileOpStruct.hNameMappings          as Pointer
80707>>>>>>>>>  Field vtShFileOpStruct.lpszProgressTitle      as Pointer // only used if FOF_SIMPLEPROGRESS
80707>>>>>>>>>End_Type // tShFileOpStruct
80707>>>>>>>>>
80707>>>>>>>>>// hwnd
80707>>>>>>>>>//   Handle of the dialog box to use to display information about the status of the operation.
80707>>>>>>>>>
80707>>>>>>>>>// wFunc
80707>>>>>>>>>//   Operation to perform. This member can be one of the following values:
80707>>>>>>>>>//     FO_COPY     Copies the files specified by pFrom to the location specified by pTo.
80707>>>>>>>>>//     FO_DELETE   Deletes the files specified by pFrom (pTo is ignored).
80707>>>>>>>>>//     FO_MOVE     Moves the files specified by pFrom to the location specified by pTo.
80707>>>>>>>>>//     FO_RENAME   Renames the files specified by pFrom.
80707>>>>>>>>>
80707>>>>>>>>>// pFrom
80707>>>>>>>>>//   Pointer to a buffer that specifies one or more source file names. Multiple names must
80707>>>>>>>>>//   be null-separated. The list of names must be double null-terminated.
80707>>>>>>>>>
80707>>>>>>>>>// pTo
80707>>>>>>>>>//   Pointer to a buffer that contains the name of the destination file or directory. The
80707>>>>>>>>>//   buffer can contain mutiple destination file names if the fFlags member specifies
80707>>>>>>>>>//   FOF_MULTIDESTFILES. Multiple names must be null-separated. The list of names must be
80707>>>>>>>>>//   double null-terminated.
80707>>>>>>>>>
80707>>>>>>>>>// fAnyOperationsAborted
80707>>>>>>>>>//   Value that receives TRUE if the user aborted any file operations before they
80707>>>>>>>>>//   were completed or FALSE otherwise.
80707>>>>>>>>>
80707>>>>>>>>>
80707>>>>>>>>>// Performs a copy, move, rename, or delete operation on a file system object.
80707>>>>>>>>>// This can be a file or a folder.
80707>>>>>>>>>// With thanks to Andrew S Kaplan
80707>>>>>>>>>External_function vWin32_SHFileOperation "SHFileOperationA" Shell32.dll ;        Pointer lpFileOp Returns Integer
80708>>>>>>>>>
80708>>>>>>>>>
80708>>>>>>>>>// Thanks To Oliver Nelson for posting this code on the newsgroups
80708>>>>>>>>>External_function vWin32_GetWindowsDirectory "GetWindowsDirectoryA" kernel32.dll ;                           Pointer lpBuffer Integer nSize Returns Integer
80709>>>>>>>>>
80709>>>>>>>>>
80709>>>>>>>>>
80709>>>>>>>>>// Courtesy Of Vincent Oorsprong
80709>>>>>>>>>//External_Function vWin32_GetTempFileName "GetTempFileNameA" Kernel32.Dll ;
80709>>>>>>>>>//   Pointer lpPathName ;
80709>>>>>>>>>//   Pointer lpPrefixString ;
80709>>>>>>>>>//   Integer uUnique ;
80709>>>>>>>>>//   Pointer lpTempFileName ;
80709>>>>>>>>>//   Returns Integer
80709>>>>>>>>>// **WvA: 28-04-2005 Changed string parameter type into pointers
80709>>>>>>>>>External_function vWin32_GetTempFileName "GetTempFileNameA" kernel32.dll Pointer lpsPath ;        Pointer lpsPrefix Integer iUnique Pointer pLoad Returns Integer
80710>>>>>>>>>
80710>>>>>>>>>External_function vWin32_GetTempPath "GetTempPathA" Kernel32.Dll ;   Dword nBufferLength ;   Pointer lpBuffer ;   Returns Integer
80711>>>>>>>>>
80711>>>>>>>>>External_function vWin32_DeleteFile "DeleteFileA" Kernel32.Dll ;   Pointer lpFileName ;   Returns Integer
80712>>>>>>>>>                  
80712>>>>>>>>>// from:
80712>>>>>>>>>// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/shell/reference/enums/csidl.asp
80712>>>>>>>>>//
80712>>>>>>>>>Define vCSIDL_FLAG_CREATE       For |CI$8000 // IE5+, use this to create a special folder
80712>>>>>>>>>Define vCSIDL_ADMIN_TOOLS       For |CI$0030 // IE5+, The file system directory that is used to store administrative tools for an individual user
80712>>>>>>>>>Define vCSIDL_ALT_STARTUP       For |CI$001D // The file system directory that corresponds to the user's nonlocalized Startup program group
80712>>>>>>>>>Define vCSIDL_APPDATA           For |CI$001A // Version 4.71. The file system directory that serves as a common repository for application-specific data. A typical path is C:\Documents and Settings\<username>\Application Data
80712>>>>>>>>>Define vCSIDL_BITBUCKET         For |CI$000A // The virtual folder containing the objects in the user's Recycle Bin
80712>>>>>>>>>Define vCSIDL_CDBURN_AREA       For |CI$003B // IE6+ The file system directory acting as a staging area for files waiting to be written to CD. A typical path is C:\Documents and Settings\<username>\Local Settings\Application Data\Microsoft\CD Burning
80712>>>>>>>>>Define vCSIDL_COMMON_ADMINTOOLS For |CI$002F // IE5+ The file system directory containing administrative tools for all users of the computer
80712>>>>>>>>>Define vCSIDL_COMMON_ALTSTARTUP For |CI$001E // The file system directory that corresponds to the nonlocalized Startup program group for all users
80712>>>>>>>>>Define vCSIDL_COMMON_APPDATA    For |CI$0023 // IE5+ The file system directory containing application data for all users. A typical path is C:\Documents and Settings\All Users\Application Data
80712>>>>>>>>>Define vCSIDL_COMMON_DESKTOPDIRECTORY for |CI$0019 // WinNT+ Only, The file system directory that contains files and folders that appear on the desktop for all users. A typical path is C:\Documents and Settings\All Users\Desktop
80712>>>>>>>>>Define vCSIDL_COMMON_DOCUMENTS  For |CI$002E // IE5+ The file system directory that contains documents that are common to all users. A typical paths is C:\Documents and Settings\All Users\Documents
80712>>>>>>>>>Define vCSIDL_COMMON_FAVORITES  For |CI$001F // The file system directory that serves as a common repository for favorite items common to all users
80712>>>>>>>>>Define vCSIDL_COMMON_MUSIC      For |CI$0035 // IE6+ The file system directory that serves as a repository for music files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Music
80712>>>>>>>>>Define vCSIDL_COMMON_PICTURES   For |CI$0036 // The file system directory that serves as a repository for image files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Pictures
80712>>>>>>>>>Define vCSIDL_COMMON_PROGRAMS   For |CI$0017 // WinNT+ The file system directory that contains the directories for the common program groups that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs
80712>>>>>>>>>Define vCSIDL_COMMON_STARTMENU  For |CI$0016 // WinNT+ The file system directory that contains the programs and folders that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu
80712>>>>>>>>>Define vCSIDL_COMMON_STARTUP    For |CI$0018 // WinNT+ The file system directory that contains the programs that appear in the Startup folder for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs\Startup
80712>>>>>>>>>Define vCSIDL_COMMON_TEMPLATES  For |CI$002D // WinNT+ The file system directory that contains the templates that are available to all users. A typical path is C:\Documents and Settings\All Users\Templates
80712>>>>>>>>>Define vCSIDL_COMMON_VIDEO      For |CI$0037 // IE6+ The file system directory that serves as a repository for video files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Videos
80712>>>>>>>>>Define vCSIDL_COMPUTERSNEARME   For |CI$003D // The folder representing other machines in your workgroup
80712>>>>>>>>>Define vCSIDL_CONNECTIONS       For |CI$0031 // The virtual folder representing Network Connections, containing network and dial-up connections
80712>>>>>>>>>Define vCSIDL_CONTROLS          For |CI$0003 // The virtual folder containing icons for the Control Panel applications
80712>>>>>>>>>Define vCSIDL_COOKIES           For |CI$0021 // The file system directory that serves as a common repository for Internet cookies. A typical path is C:\Documents and Settings\username\Cookies
80712>>>>>>>>>Define vCSIDL_DESKTOP           For |CI$0000 // The virtual folder representing the Windows desktop, the root of the namespace
80712>>>>>>>>>Define vCSIDL_DESKTOPDIRECTORY  For |CI$0010 // The file system directory used to physically store file objects on the desktop (not to be confused with the desktop folder itself). A typical path is C:\Documents and Settings\username\Desktop
80712>>>>>>>>>Define vCSIDL_DRIVES            For |CI$0011 // The virtual folder representing My Computer, containing everything on the local computer: storage devices, printers, and Control Panel. The folder may also contain mapped network drives
80712>>>>>>>>>Define vCSIDL_FAVORITES         For |CI$0006 // The file system directory that serves as a common repository for the user's favorite items. A typical path is C:\Documents and Settings\username\Favorites
80712>>>>>>>>>Define vCSIDL_FONTS             For |CI$0014 // A virtual folder containing fonts. A typical path is C:\Windows\Fonts
80712>>>>>>>>>Define vCSIDL_HISTORY           For |CI$0022 // The file system directory that serves as a common repository for Internet history items
80712>>>>>>>>>Define vCSIDL_INTERNET          For |CI$0001 // A virtual folder representing the Internet
80712>>>>>>>>>Define vCSIDL_INTERNET_CACHE    For |CI$0020 // Comctl4.72+, The file system directory that serves as a common repository for temporary Internet files. A typical path is C:\Documents and Settings\username\Local Settings\Temporary Internet Files
80712>>>>>>>>>Define vCSIDL_LOCAL_APPDATA     For |CI$001C // IE5+ The file system directory that serves as a data repository for local (nonroaming) applications. A typical path is C:\Documents and Settings\username\Local Settings\Application Data
80712>>>>>>>>>Define vCSIDL_MYDOCUMENTS       For |CI$000C // IE6+ The virtual folder representing the My Documents desktop item
80712>>>>>>>>>Define vCSIDL_MYMUSIC           For |CI$000D // The file system directory that serves as a common repository for music files. A typical path is C:\Documents and Settings\User\My Documents\My Music
80712>>>>>>>>>Define vCSIDL_MYPICTURES        For |CI$0027 // IE5+ The file system directory that serves as a common repository for image files. A typical path is C:\Documents and Settings\username\My Documents\My Pictures
80712>>>>>>>>>Define vCSIDL_MYVIDEO           For |CI$000E // IE6+ The file system directory that serves as a common repository for video files. A typical path is C:\Documents and Settings\username\My Documents\My Videos
80712>>>>>>>>>Define vCSIDL_NETHOOD           For |CI$0013 // A file system directory containing the link objects that may exist in the My Network Places virtual folder. It is not the same as CSIDL_NETWORK, which represents the network namespace root. A typical path is C:\Documents and Settings\username\NetHood
80712>>>>>>>>>Define vCSIDL_NETWORK           For |CI$0012 // A virtual folder representing Network Neighborhood, the root of the network namespace hierarchy
80712>>>>>>>>>Define vCSIDL_PERSONAL          For |CI$0005 // (Documents folder) IE6 The virtual folder representing the My Documents desktop item.
80712>>>>>>>>>                                             // This is equivalent to CSIDL_MYDOCUMENTS. Previous to Version 6.0. The file system directory used to physically store a user's common repository of documents. A typical path is C:\Documents and Settings\username\My Documents
80712>>>>>>>>>Define vCSIDL_PHOTOALBUMS       For |CI$0045 // Vista+ The virtual folder used to store photo albums, typically username\My Pictures\Photo Albums
80712>>>>>>>>>Define vCSIDL_PLAYLISTS         For |CI$003F // Vista+ The virtual folder used to store play albums, typically username\My Music\Playlists
80712>>>>>>>>>Define vCSIDL_PRINTERS          For |CI$0004 // The virtual folder containing installed printers
80712>>>>>>>>>Define vCSIDL_PRINTHOOD         For |CI$001B // The file system directory that contains the link objects that can exist in the Printers virtual folder. A typical path is C:\Documents and Settings\username\PrintHood
80712>>>>>>>>>Define vCSIDL_PROFILE           For |CI$0028 // IE5+ The user's profile folder. A typical path is C:\Documents and Settings\username
80712>>>>>>>>>Define vCSIDL_PROGRAM_FILES     For |CI$0026 // IE5+ The Program Files folder. A typical path is C:\Program Files
80712>>>>>>>>>Define vCSIDL_PROGRAM_FILESx86  for |CI$002A // The Program Files folder for x86 programs. A typical path is C:\Program Files (x86)
80712>>>>>>>>>Define vCSIDL_PROGRAM_FILES_COMMON For |CI$002B // IE5+, WinNT+ A folder for components that are shared across applications. A typical path is C:\Program Files\Common
80712>>>>>>>>>Define vCSIDL_PROGRAMS          For |CI$0002 // The file system directory that contains the user's program groups (which are themselves file system directories). A typical path is C:\Documents and Settings\username\Start Menu\Programs
80712>>>>>>>>>Define vCSIDL_RECENT            For |CI$0008 // The file system directory that contains shortcuts to the user's most recently used documents. A typical path is C:\Documents and Settings\username\My Recent Documents
80712>>>>>>>>>Define vCSIDL_RESOURCES         For |CI$0038 // undocumented
80712>>>>>>>>>Define vCSIDL_SAMPLE_MUSIC      For |CI$0040 // Vista+, The file system directory that contains sample music. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Music
80712>>>>>>>>>Define vCSIDL_SAMPLE_PLAYLISTS  For |CI$0041 // Vista+, The file system directory that contains sample playlists. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Playlists
80712>>>>>>>>>Define vCSIDL_SAMPLE_PICTURES   For |CI$0042 // Vista+, The file system directory that contains sample pictures. A typical path is C:\Documents and Settings\username\My Documents\My Pictures\Sample Pictures
80712>>>>>>>>>Define vCSIDL_SAMPLE_VIDEOS     For |CI$0043 // Vista+, The file system directory that contains sample videos. A typical path is C:\Documents and Settings\username\My Documents\My Videos\Sample Videos
80712>>>>>>>>>Define vCSIDL_SENDTO            For |CI$0009 // The file system directory that contains Send To menu items. A typical path is C:\Documents and Settings\username\SendTo
80712>>>>>>>>>Define vCSIDL_STARTMENU         For |CI$000B // The file system directory containing Start menu items. A typical path is C:\Documents and Settings\username\Start Menu
80712>>>>>>>>>Define vCSIDL_STARTUP           For |CI$0007 // The file system directory that corresponds to the user's Startup program group. The system starts these programs whenever any user logs onto Windows NT or starts Windows 95. A typical path is C:\Documents and Settings\username\Start Menu\Programs\Startup
80712>>>>>>>>>Define vCSIDL_SYSTEM            For |CI$0025 // The Windows System folder. A typical path is C:\Windows\System32
80712>>>>>>>>>Define vCSIDL_SYSTEMX86         For |CI$0029 //
80712>>>>>>>>>Define vCSIDL_TEMPLATES         For |CI$0015 // The file system directory that serves as a common repository for document templates. A typical path is C:\Documents and Settings\username\Templates
80712>>>>>>>>>Define vCSIDL_WINDOWS           For |CI$0024 // The Windows directory or SYSROOT. This corresponds to the %windir% or %SYSTEMROOT% environment variables. A typical path is C:\Windows
80712>>>>>>>>>
80712>>>>>>>>>
80712>>>>>>>>>//HRESULT SHGetFolderPath(
80712>>>>>>>>>//    HWND hwndOwner,
80712>>>>>>>>>//    int nFolder,
80712>>>>>>>>>//    HANDLE hToken,
80712>>>>>>>>>//    DWORD dwFlags,
80712>>>>>>>>>//    LPTSTR pszPath
80712>>>>>>>>>//);
80712>>>>>>>>>// This function is a superset of SHGetSpecialFolderPath, included with earlier versions of
80712>>>>>>>>>// the shell. It is implemented in a redistributable DLL, SHFolder.dll, that also simulates
80712>>>>>>>>>// many of the new shell folders on older platforms such as Windows 95, Windows 98, and
80712>>>>>>>>>// Windows NT 4.0. This DLL always calls the current platform's version of this function.
80712>>>>>>>>>// If that fails, it will try to simulate the appropriate behavior.
80712>>>>>>>>>//
80712>>>>>>>>>External_function vWin32_SHGetFolderPath "SHGetFolderPathA" SHFolder.Dll ;   Pointer hWnd ;   Integer nFolder ;   Pointer hToken ;   DWord   dwFlags ;   Pointer lpszPath ;   Returns Integer
80713>>>>>>>>>
80713>>>>>>>>>
80713>>>>>>>>>
80713>>>>>>>>>Type vWin32_Find_Data
80713>>>>>>>>>  Field vWin32_Find_Data.dwFileAttributes As Dword
80713>>>>>>>>>  Field vWin32_Find_Data.ftCreationLowDateTime As Dword
80713>>>>>>>>>  Field vWin32_Find_Data.ftCreationHighDateTime As Dword
80713>>>>>>>>>  Field vWin32_Find_Data.ftLastAccessLowDateTime As dword
80713>>>>>>>>>  Field vWin32_Find_Data.ftLastAccessHighDateTime As Dword
80713>>>>>>>>>  Field vWin32_Find_Data.ftLastWriteLowDateTime As Dword
80713>>>>>>>>>  Field vWin32_Find_Data.ftLastWriteHighDateTime As Dword
80713>>>>>>>>>  Field vWin32_Find_Data.nFileSizeHigh As Dword
80713>>>>>>>>>  Field vWin32_Find_Data.nFileSizeLow As Dword
80713>>>>>>>>>  Field vWin32_Find_Data.dwReserved0 As Dword
80713>>>>>>>>>  Field vWin32_Find_Data.dwReserved1 As Dword
80713>>>>>>>>>  Field vWin32_Find_Data.cFileName As Char vMax_Path
80713>>>>>>>>>  Field vWin32_Find_Data.cAlternateFileName As Char 14
80713>>>>>>>>>End_Type // vWin32_Find_Data
80713>>>>>>>>>
80713>>>>>>>>>// Courtesy Of Vincent Oorsprong
80713>>>>>>>>>// lpFileName      : address of name of file to search for
80713>>>>>>>>>// lpFindFileData  : address of returned information
80713>>>>>>>>>External_function vWin32_FindFirstFile "FindFirstFileA"  Kernel32.dll Pointer lpFileName ;          Pointer lpFindFileData Returns Handle
80714>>>>>>>>>
80714>>>>>>>>>// Courtesy Of Vincent Oorsprong
80714>>>>>>>>>// hFindFile       : handle of search
80714>>>>>>>>>// lpFindFileData  : address of structure for data on found file
80714>>>>>>>>>External_function vWin32_FindNextFile "FindNextFileA" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
80715>>>>>>>>>
80715>>>>>>>>>// Courtesy Of Vincent Oorsprong
80715>>>>>>>>>//  hFindFile      : file search handle
80715>>>>>>>>>External_function vWin32_FindClose "FindClose" Kernel32.dll Handle hFindFile Returns Integer
80716>>>>>>>>>
80716>>>>>>>>>
80716>>>>>>>>>
80716>>>>>>>>>Type vFileTime
80716>>>>>>>>>  Field vFileTime.dwLowDateTime As Dword
80716>>>>>>>>>  Field vFileTime.dwHighDateTime As Dword
80716>>>>>>>>>End_Type // vFileTime
80716>>>>>>>>>
80716>>>>>>>>>
80716>>>>>>>>>Type vSystemTime
80716>>>>>>>>>  Field vSystemTime.wYear As Word
80716>>>>>>>>>  Field vSystemTime.wMonth As Word
80716>>>>>>>>>  Field vSystemTime.wDayOfWeek As Word
80716>>>>>>>>>  Field vSystemTime.wDay As Word
80716>>>>>>>>>  Field vSystemTime.wHour As Word
80716>>>>>>>>>  Field vSystemTime.wMinute As Word
80716>>>>>>>>>  Field vSystemTime.wSecond As Word
80716>>>>>>>>>  Field vSystemTime.wMilliSeconds As Word
80716>>>>>>>>>End_Type // vSystemTime
80716>>>>>>>>>
80716>>>>>>>>>
80716>>>>>>>>>// Courtesy Of Vincent Oorsprong
80716>>>>>>>>>//  lpFileTime     : pointer to file time to convert
80716>>>>>>>>>//  lpSystemTime   : pointer to structure to receive system time
80716>>>>>>>>>External_function vWin32_FileTimeToSystemTime "FileTimeToSystemTime" Kernel32.Dll ;          Pointer lpFileTime Pointer lpsystemTime Returns Integer
80717>>>>>>>>>
80717>>>>>>>>>// Courtesy Of Vincent Oorsprong
80717>>>>>>>>>// This function formats the time in a picture-string passed
80717>>>>>>>>>//
80717>>>>>>>>>// Picture      Meaning
80717>>>>>>>>>//    h         Hours with no leading zero for single-digit hours; 12-hour clock
80717>>>>>>>>>//    hh        Hours with leading zero for single-digit hours; 12-hour clock
80717>>>>>>>>>//    H         Hours with no leading zero for single-digit hours; 24-hour clock
80717>>>>>>>>>//    HH        Hours with leading zero for single-digit hours; 24-hour clock
80717>>>>>>>>>//    m         Minutes with no leading zero for single-digit minutes
80717>>>>>>>>>//    mm        Minutes with leading zero for single-digit minutes
80717>>>>>>>>>//    s         Seconds with no leading zero for single-digit seconds
80717>>>>>>>>>//    ss        Seconds with leading zero for single-digit seconds
80717>>>>>>>>>//    t         One character time marker string, such as A or P
80717>>>>>>>>>//    tt        Multicharacter time marker string, such as AM or PM
80717>>>>>>>>>//
80717>>>>>>>>>// For example, to get the time string  "11:29:40 PM"
80717>>>>>>>>>//    use the following picture string: "hh" : "mm" : "ss tt"
80717>>>>>>>>>
80717>>>>>>>>>External_function vWin32_GetTimeFormat "GetTimeFormatA" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpTimeStr ;  Integer cchTime Returns Integer
80718>>>>>>>>>
80718>>>>>>>>>
80718>>>>>>>>>// Courtesy Of Vincent Oorsprong
80718>>>>>>>>>// This function formats the date in a picture-string passed
80718>>>>>>>>>//
80718>>>>>>>>>// Picture      Meaning
80718>>>>>>>>>//    d         Day of month as digits with no leading zero for single-digit days.
80718>>>>>>>>>//    dd        Day of month as digits with leading zero for single-digit days.
80718>>>>>>>>>//    ddd       Day of week as a three-letter abbreviation. The function uses the
80718>>>>>>>>>//              LOCALE_SABBREVOAYMAME value associated with the specified locale.
80718>>>>>>>>>//    dddd      Day of week as its full name. The function uses the LOCALE_SDAYNAME
80718>>>>>>>>>//              value associated with the specified locale.
80718>>>>>>>>>//    M         Month as digits with no leading zero for single-digit months.
80718>>>>>>>>>//    MM        Month as digits with leading zero for single-digit months.
80718>>>>>>>>>//    MMM       Month as a three-letter abbreviation. The function uses the
80718>>>>>>>>>//              LOCALE_SABBREVMONTHNAME value associated with the specified locale.
80718>>>>>>>>>//    MMMM      Month as its full name. The function uses the LOCALE_SMONTHNAME value
80718>>>>>>>>>//              associated with the specified locale.
80718>>>>>>>>>//    y         Year as last two digits, but with no leading zero for years less than 10.
80718>>>>>>>>>//    yy        Year as last two digits, but with leading zero for years less than 10.
80718>>>>>>>>>//    yyyy      Year represented hy full four digits.
80718>>>>>>>>>//    gg        Period/era string. The function uses the CAL_SERASTRING value associated
80718>>>>>>>>>//              with the specified locale. This element is ignored if the date to be formatted
80718>>>>>>>>>//              does not have an associated era or period string.
80718>>>>>>>>>// For example, to get the date string  "Wed, Aug 31 94"
80718>>>>>>>>>// use the following picture string:    "ddd","MMM dd yy"
80718>>>>>>>>>
80718>>>>>>>>>External_function vWin32_GetDateFormat "GetDateFormatA" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpDateStr ;  Integer cchDate Returns Integer
80719>>>>>>>>>
80719>>>>>>>>>Define LOCALE_NOUSEROVERRIDE    For |CI$80000000  //  do not use user overrides
80719>>>>>>>>>Define TIME_NOMIHUTESORSECONDS  For |CI$0000000l  //  do not use minutes or seconds
80719>>>>>>>>>Define TIME_NOSECONDS           For |CI$00000002  //  do not use seconds
80719>>>>>>>>>Define TIME_NOTIMEMARKER        For |CI$00000004  //  do not use time marker
80719>>>>>>>>>Define TIME_FORCE24HOURFORMAT   For |CI$00000008  //  always use 24 hour format
80719>>>>>>>>>
80719>>>>>>>>>//  Date Flags for GetDateFormatW.
80719>>>>>>>>>//
80719>>>>>>>>>Define DATE_SHORTDATE           For |CI$0000000l  //  use short date picture
80719>>>>>>>>>Define DATE_LONGDATE            For |CI$00000002  //  use long date picture
80719>>>>>>>>>Define DATE_USE_ALT_CALENDAR    For |CI$00000004  //  use alternate calendar (if any)
80719>>>>>>>>>
80719>>>>>>>>>
80719>>>>>>>>>External_function vWin32_SetLastError "SetLastError" Kernel32.Dll Dword dwLastError Returns Integer
80720>>>>>>>>>
80720>>>>>>>>>
80720>>>>>>>>>// **WvA: 20-02-2004
80720>>>>>>>>>// While i was testing the format capabilities i stumbled over a very
80720>>>>>>>>>// weird problem where it looks like that the integer value gets somehow translated
80720>>>>>>>>>// incorrectly into an unsigned integer.
80720>>>>>>>>>// I don't have the time to dive into this.. so added a workaround (and removed it again)
80720>>>>>>>>>// It does smell a bit fishy though
80720>>>>>>>>>// Tested it with the same results on both VDF7 and VDF9.1
80720>>>>>>>>>
80720>>>>>>>>>Define SHFMT_ID_DEFAULT        For |CI$0000FFFF // The default format ID
80720>>>>>>>>>Define SHFMT_OPT_DEFAULT       For |CI$00000000 // The default "Quick Format" option.
80720>>>>>>>>>Define SHFMT_OPT_FULL          For |CI$00000001 // Deselects the "Quick Format" option, providing a full format instead. This is useful when an unformatted disk is detected.
80720>>>>>>>>>Define SHFMT_OPT_SYSONLY       For |CI$00000002 // Selects the "Create an MS-DOS startup disk" option, creating a system boot disk.
80720>>>>>>>>>
80720>>>>>>>>>// Possible errors that can be returned by the shellformat function
80720>>>>>>>>>Define SHFMT_ERROR             For (|CI$FFFFFFFF+1) // An error occurred during the last format or no drive parameter passed. This does not indicate that the disk is unformatable.
80720>>>>>>>>>Define SHFMT_CANCEL            For (|CI$FFFFFFFE+1) // The last format was canceled.
80720>>>>>>>>>Define SHFMT_NOFORMAT          For (|CI$FFFFFFFD+1) // The drive cannot be formatted.
80720>>>>>>>>>                                                
80720>>>>>>>>>
80720>>>>>>>>> // Courtesy Of Steve Walter,
80720>>>>>>>>> // USA Software, Inc
80720>>>>>>>>> // Format a disk
80720>>>>>>>>> // Called By:  Move (vWin32_ShFormatDrive(hWnd,0,$FFFF,1)) To dwReturn
80720>>>>>>>>>External_function vWin32_ShFormatDrive "SHFormatDrive" shell32.dll Handle hWnd ;         Integer iDrive Integer iFormatID Integer iOptions Returns DWORD
80721>>>>>>>>>
80721>>>>>>>>>// Michael Mullan.  I Wanted to create all the folders in one statement...
80721>>>>>>>>>
80721>>>>>>>>>// SHCreateDirectoryEx
80721>>>>>>>>>
80721>>>>>>>>>//    Note  This function is available through Microsoft Windows XP Service Pack 2 (SP2) and Windows Server 2003.
80721>>>>>>>>>//    It might be altered or unavailable in subsequent versions of Windows.
80721>>>>>>>>>//
80721>>>>>>>>>//    This function creates a file system folder whose fully qualified path is given by pszPath. If one or more
80721>>>>>>>>>//    of the intermediate folders do not exist, they are created as well. SHCreateDirectoryEx also verifies that
80721>>>>>>>>>//    the files are visible. If they are not visible, expect one of the following:
80721>>>>>>>>>//
80721>>>>>>>>>//        * If hwnd is set to a valid window handle, a message box is displayed warning the user that he or she
80721>>>>>>>>>//        might not be able to access the files. If the user chooses not to proceed, the function returns
80721>>>>>>>>>//        ERROR_CANCELLED.
80721>>>>>>>>>//        * If hwnd is set to NULL, no user interface is displayed and the function returns ERROR_CANCELLED.
80721>>>>>>>>>
80721>>>>>>>>>//        Returns ERROR_SUCCESS if successful. If the operation fails, other error codes can be returned,
80721>>>>>>>>>//        including those listed here. For values not specifically listed, see System Error Codes.
80721>>>>>>>>>//      161  ERROR_BAD_PATHNAME                The pszPath parameter was set to a relative path.
80721>>>>>>>>>//      206  ERROR_FILENAME_EXCED_RANGE     The path pointed to by pszPath is too long.
80721>>>>>>>>>//      3    ERROR_PATH_NOT_FOUND            The system cannot find the path pointed to by pszPath. The path may contain an invalid entry.
80721>>>>>>>>>//      80   ERROR_FILE_EXISTS                The directory exists.
80721>>>>>>>>>//      183  ERROR_ALREADY_EXISTS            The directory exists.
80721>>>>>>>>>//      1223 ERROR_CANCELLED                The user canceled the operation.
80721>>>>>>>>>
80721>>>>>>>>>//        int SHCreateDirectoryEx(
80721>>>>>>>>>//            HWND hwnd,
80721>>>>>>>>>//            LPCTSTR pszPath,
80721>>>>>>>>>//            const SECURITY_ATTRIBUTES *psa
80721>>>>>>>>>//        );
80721>>>>>>>>>
80721>>>>>>>>>External_function vWin32_SHCreateDirectoryEx "SHCreateDirectoryExA" shell32.dll Handle hWnd;                  pointer pszPath  Pointer lpSecurity_Attributes Returns Integer
80722>>>>>>>
80722>>>>>>>
80722>>>>>>>
80722>>>>>>>
80722>>>>>>>
80722>>>>>>>//
80722>>>>>>>// Gets the string from the right of the last sStopChar in sFrom
80722>>>>>>>// If sStopChar has no occurences in the string an empty string is
80722>>>>>>>// returned.
80722>>>>>>>Function StringFromRightOfChar Global String sFrom String sStopChar Returns String
80724>>>>>>>  String  sRetVal
80724>>>>>>>  String  sChar
80724>>>>>>>  Integer iLength
80724>>>>>>>  Integer iPos
80724>>>>>>>  Boolean bStopChar
80724>>>>>>>  Move "" To sRetval
80725>>>>>>>  Move (Length(sFrom)) To iLength
80726>>>>>>>  If ((iLength>0) And (Pos(sStopChar,sFrom) <> 0)) Begin
80728>>>>>>>    Move iLength   To iPos
80729>>>>>>>    Move (False)   To bStopChar
80730>>>>>>>    While Not bStopChar
80734>>>>>>>      Move (Mid(sFrom,1,iPos)) To sChar
80735>>>>>>>      Decrement iPos
80736>>>>>>>      If ((sChar=sStopChar) Or (iPos<1)) Begin
80738>>>>>>>        Move (True) To bStopChar
80739>>>>>>>      End
80739>>>>>>>>
80739>>>>>>>      Else Begin
80740>>>>>>>        Move (sChar+sRetVal) To sRetVal
80741>>>>>>>      End
80741>>>>>>>>
80741>>>>>>>    Loop
80742>>>>>>>>
80742>>>>>>>  End
80742>>>>>>>>
80742>>>>>>>  Function_Return sRetVal
80743>>>>>>>End_Function // StringFromRightOfChar
80744>>>>>>>
80744>>>>>>>
80744>>>>>>>// Pre:  sFileName contains the complete path of the file.
80744>>>>>>>// Post: returns the complete path of the file.
80744>>>>>>>// This function is inspired on function SEQ_ExtractPathFromFileName of Sture Andersen.
80744>>>>>>>Function ParseFolderName Global String sFileName Returns String
80746>>>>>>>  String sFile
80746>>>>>>>  String sFolderName
80746>>>>>>>  String sDirSep // this is "\" for windows, or "/" for unix
80746>>>>>>>  MOve "" To sFolderName
80747>>>>>>>  Move (sysconf(SYSCONF_DIR_SEPARATOR)) To sDirSep
80748>>>>>>>  If sDirSep In sFileName Begin
80750>>>>>>>    Move (StringFromRightOfChar(sFileName,sDirSep)) To sFile
80751>>>>>>>    Move (Replace(sFile,sFileName,"")) To sFolderName
80752>>>>>>>  End
80752>>>>>>>>
80752>>>>>>>  Else If ":" In sFileName Begin
80755>>>>>>>    Move (StringFromRightOfChar(sFileName,":")) To sFile
80756>>>>>>>    Move (Replace(sFile,sFileName,"")) To sFolderName
80757>>>>>>>  End
80757>>>>>>>>
80757>>>>>>>  Function_Return sFolderName
80758>>>>>>>End_Function // ParseFolderName
80759>>>>>>>
80759>>>>>>>
80759>>>>>>>// Pre:  sFileName contains the complete path of the file.
80759>>>>>>>// post: The returned filename has it's path removed, but will have a extension
80759>>>>>>>Function ParseFileName Global String sFileName Returns String
80761>>>>>>>  String sFolderName
80761>>>>>>>  String sDirSep // this is "\" for windows, or "/" for unix
80761>>>>>>>  Move (sysconf(SYSCONF_DIR_SEPARATOR)) To sDirSep
80762>>>>>>>  Get ParseFolderName sFileName To sFolderName
80763>>>>>>>  If (sFolderName <> "") Begin
80765>>>>>>>    Move (Replace(sFolderName,sFileName,"")) to sFileName
80766>>>>>>>  End
80766>>>>>>>>
80766>>>>>>>  Move (Replace(sDirSep,sFileName,"")) To sFileName
80767>>>>>>>  Function_Return sFilename
80768>>>>>>>End_Function // ParseFileName
80769>>>>>>>
80769>>>>>>>
80769>>>>>>>// Pre:  sFileName may contain the complete path of the file.
80769>>>>>>>//       or contain multiple dots in the filename, so temp.gif.bak will
80769>>>>>>>//       return "bak" as the extension and not "gif"
80769>>>>>>>// Post: returns the extension only, this extension can be a valid unixlike extension
80769>>>>>>>//       such as "html" or "java"
80769>>>>>>>Function ParseFileExtension Global String sFileName Returns String
80771>>>>>>>  String  sFileExtension
80771>>>>>>>  Get StringFromRightOfChar sFileName "." To sFileExtension
80772>>>>>>>  Function_Return sFileExtension
80773>>>>>>>End_Function // ParseFileExtension
80774>>>>>>>
80774>>>>>>>
80774>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
80774>>>>>>>
80774>>>>>>>
80774>>>>>>>Function DDE_Error_To_String Integer iErrorID Returns String
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
80776>>>>>>>  String sMessage
80776>>>>>>>  Case Begin
80776>>>>>>>    Case (iErrorID = vERROR_FILE_NOT_FOUND)
80778>>>>>>>      Move CS_DDE_ERR_FILE_NOT_FOUND To sMessage
80779>>>>>>>      Case Break
80780>>>>>>>    Case (iErrorID = vERROR_PATH_NOT_FOUND)
80783>>>>>>>      Move CS_DDE_ERR_PATH_NOT_FOUND To sMessage
80784>>>>>>>      Case Break
80785>>>>>>>    Case (iErrorID = vERROR_BAD_FORMAT)
80788>>>>>>>      Move CS_DDE_ERR_BAD_FORMAT To sMessage
80789>>>>>>>      Case Break
80790>>>>>>>    Case (iErrorID = vSE_ERR_ACCESSDENIED)
80793>>>>>>>      Move CS_DDE_ERR_ACCESSDENIED To sMessage
80794>>>>>>>      Case Break
80795>>>>>>>    Case (iErrorID = vSE_ERR_ASSOCINCOMPLETE)
80798>>>>>>>      Move CS_DDE_ERR_ASSOCINCOMPLETE To sMessage
80799>>>>>>>      Case Break
80800>>>>>>>    Case (iErrorID = vSE_ERR_DDEBUSY)
80803>>>>>>>      Move CS_DDE_ERR_DDEBUSY To sMessage
80804>>>>>>>      Case Break
80805>>>>>>>    Case (iErrorID = vSE_ERR_DDEFAIL)
80808>>>>>>>      Move CS_DDE_ERR_DDEFAIL To sMessage
80809>>>>>>>      Case Break
80810>>>>>>>    Case (iErrorID = vSE_ERR_DDETIMEOUT)
80813>>>>>>>      Move CS_DDE_ERR_DDETIMEOUT To sMessage
80814>>>>>>>      Case Break
80815>>>>>>>    Case (iErrorID = vSE_ERR_DLLNOTFOUND)
80818>>>>>>>      Move CS_DDE_ERR_DLLNOTFOUND To sMessage
80819>>>>>>>      Case Break
80820>>>>>>>    Case (iErrorID = vSE_ERR_NOASSOC)
80823>>>>>>>      Move CS_DDE_ERR_NOASSOC To sMessage
80824>>>>>>>      Case Break
80825>>>>>>>    Case ((iErrorID = vSE_ERR_OOM) Or (iErrorID = 0))
80828>>>>>>>      Move CS_DDE_ERR_OOM To sMessage
80829>>>>>>>      Case Break
80830>>>>>>>    Case (iErrorID = vSE_ERR_PNF)
80833>>>>>>>      Move CS_DDE_ERR_PNF To sMessage
80834>>>>>>>      Case Break
80835>>>>>>>    Case (iErrorID = vSE_ERR_SHARE)
80838>>>>>>>      Move CS_DDE_ERR_SHARE To sMessage
80839>>>>>>>      Case Break
80840>>>>>>>    Case Else
80840>>>>>>>      Move CS_DDE_ERR_UNKNOWN_LINE1 To sMessage
80841>>>>>>>      Move (sMessage*Trim(iErrorID)*CS_DDE_ERR_UNKNOWN_LINE2) To sMessage
80842>>>>>>>      Case Break
80843>>>>>>>  Case End
80843>>>>>>>  Function_Return sMessage
80844>>>>>>>End_Function // DDE_Error_To_String
80845>>>>>>>
80845>>>>>>>
80845>>>>>>>Procedure vDDE_Error_Handler Integer iErrorID
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
80847>>>>>>>  String sMessage
80847>>>>>>>  Get DDE_Error_To_String iErrorID To sMessage
80848>>>>>>>  Append sMessage CS_DDE_ERR_HANDL_PAKTC //  "Press a key to continue..."
80849>>>>>>>  Send Stop_Box sMessage CS_DDE_ERR_HANDL_CAPTION
80850>>>>>>>End_Procedure // vDDE_Error_Handler hInstance
80851>>>>>>>
80851>>>>>>>
80851>>>>>>>// Does the directory exist? - No = 0, Yes = 1
80851>>>>>>>// This also works with UNC path encoding and wildcards
80851>>>>>>>Function vFolderExists Global String sFolderName Returns Integer
80853>>>>>>>  String  sFolder sTmp
80853>>>>>>>  Integer bFolderExists iCh
80853>>>>>>>
80853>>>>>>>  // 2013-09-29 NGS Check for empty folder name and convert to ANSI
80853>>>>>>>  Move (ToANSI(Trim(sFolderName))) to sFolderName
80854>>>>>>>  If (sFolderName = "") Begin
80856>>>>>>>    Function_Return False
80857>>>>>>>  End
80857>>>>>>>>
80857>>>>>>>
80857>>>>>>>  Move dfTrue To bFolderExists
80858>>>>>>>  Move "dir:" To sFolder
80859>>>>>>>  Append sFolder sFolderName
80860>>>>>>>  Get Seq_New_Channel To iCh  // get free channel for input
80861>>>>>>>  Direct_Input Channel iCh sFolder
80863>>>>>>>    Repeat
80863>>>>>>>>
80863>>>>>>>      Readln Channel iCh sTmp
80865>>>>>>>      If (Trim(sTmp)="") Begin
80867>>>>>>>        Move False to bFolderExists
80868>>>>>>>      End
80868>>>>>>>>
80868>>>>>>>      Else Begin
80869>>>>>>>        Move True to bFolderExists
80870>>>>>>>        Move True to SeqEof // end loop
80871>>>>>>>        End
80871>>>>>>>>
80871>>>>>>>    Until (seqeof)
80873>>>>>>>  Close_Input Channel iCh
80875>>>>>>>  Send Seq_Release_Channel iCh
80876>>>>>>>  Function_Return bFolderExists
80877>>>>>>>End_Function  // vFolderExists
80878>>>>>>>
80878>>>>>>>
80878>>>>>>>// returns folder name if a folder was selected, otherwise returns ""
80878>>>>>>>Function vSHBrowseForFolder Global String sDialogTitle Returns String
80880>>>>>>>  String sFolder sBrowseInfo sTitle
80880>>>>>>>  Pointer lpItemIdList lpsFolder lpsBrowseInfo lpsTitle
80880>>>>>>>  Integer iFolderSelected iRetval
80880>>>>>>>
80880>>>>>>>  // fill string variable with null characters
80880>>>>>>>  ZeroType vtBrowseInfo To sBrowseInfo
80881>>>>>>>
80881>>>>>>>  If (sDialogTitle<>"") Begin
80883>>>>>>>    Move sDialogTitle To sTitle
80884>>>>>>>    // Torben Lund suggested converting the string with toansi. Doing it like that
80884>>>>>>>    // disables showing some commonly used ascii characters like ascii 137 ()
80884>>>>>>>    // These chars are correctly shown if no toansi is used.
80884>>>>>>>    // I can imagine that he wanted to path to be ANSI, but as long as it isa just
80884>>>>>>>    // selected it will always be valid.
80884>>>>>>>    Move (AddressOf(sTitle)) to lpsTitle
80885>>>>>>>    Put lpsTitle To sBrowseInfo At vtBrowseInfo.lpszTitle
80886>>>>>>>  End
80886>>>>>>>>
80886>>>>>>>
80886>>>>>>>  Put vBIF_RETURNONLYFSDIRS To sBrowseInfo At vtBrowseInfo.ulFlags
80887>>>>>>>
80887>>>>>>>  // Torben Lund added line below. Move handle of focus object to structure before
80887>>>>>>>  // calling function. Otherwise, the folderdialog will be started as a seperate task.
80887>>>>>>>  Put (window_handle(focus(desktop))) To sBrowseInfo At vtBrowseInfo.hWndOwner
80888>>>>>>>
80888>>>>>>>  Move (AddressOf(sBrowseInfo)) to lpsBrowseInfo
80889>>>>>>>
80889>>>>>>>  // null 128 chars into var (make space)
80889>>>>>>>  Move (Repeat(Character(0), vMAX_PATH)) To sFolder
80890>>>>>>>  Move (AddressOf(sFolder)) to lpsFolder
80891>>>>>>>
80891>>>>>>>  // select folder
80891>>>>>>>  Move (vWin32_SHBrowseForFolder(lpsBrowseInfo)) To lpItemIdList
80892>>>>>>>  // get selected folder name
80892>>>>>>>  Move (vWin32_SHGetPathFromIDList(lpItemIdList, lpsFolder)) To iFolderSelected
80893>>>>>>>
80893>>>>>>>  // release memory resources that are used by the ItemIdList
80893>>>>>>>  Move (vWin32_CoTaskMemFree(lpItemIdList)) To iRetval
80894>>>>>>>
80894>>>>>>>  If (iFolderSelected<>0) Begin
80896>>>>>>>    Function_Return (CString(sFolder))
80897>>>>>>>  End
80897>>>>>>>>
80897>>>>>>>  Else Begin
80898>>>>>>>    Function_Return ""
80899>>>>>>>  End
80899>>>>>>>>
80899>>>>>>>End_Function // vSHBrowseForFolder
80900>>>>>>>
80900>>>>>>>
80900>>>>>>>// returns 0 if the folder is created.
80900>>>>>>>//         1 if the API-call returned an error.
80900>>>>>>>Function vCreateDirectory Global String sNewFolder Returns Integer
80902>>>>>>>  String  sFolder sSA
80902>>>>>>>  Pointer lpsFolder lpsSecurity_Attributes lpDescriptor
80902>>>>>>>  Integer iRetval bFolderCreated bInheritHandle
80902>>>>>>>
80902>>>>>>>  Move (False) To bFolderCreated
80903>>>>>>>  // fill string variable with null characters
80903>>>>>>>  ZeroType vtSecurity_attributes To sSA
80904>>>>>>>
80904>>>>>>>  // null MAX_PATH chars into var (make space)
80904>>>>>>>  Move (Repeat(Character(0), vMAX_PATH)) To sFolder
80905>>>>>>>
80905>>>>>>>  If (sNewFolder <> "") Begin
80907>>>>>>>
80907>>>>>>>    Move dfTrue To  bInheritHandle
80908>>>>>>>    // Setting this to NULL is already done by the zerotype command
80908>>>>>>>    // Move NULL   To  lpDescriptor
80908>>>>>>>    Put (length(sSA))   To sSA At vtSecurity_attributes.nLength
80909>>>>>>>    //Put lpDescriptor To sSA at vtSecurity_attributes.lpDescriptor
80909>>>>>>>    Put bInheritHandle To sSA At vtSecurity_attributes.bInheritHandle
80910>>>>>>>
80910>>>>>>>    Move (AddressOf(sSA)) to lpsSecurity_Attributes
80911>>>>>>>
80911>>>>>>>    //
80911>>>>>>>    Move sNewFolder To sFolder
80912>>>>>>>    Move (AddressOf(sFolder)) to lpsFolder
80913>>>>>>>    Move (vWin32_CreateDirectory(lpsFolder, lpsSecurity_Attributes)) To bFolderCreated
80914>>>>>>>  End
80914>>>>>>>>
80914>>>>>>>
80914>>>>>>>  If (not(bFolderCreated)) Begin
80916>>>>>>>    Move 1 to iRetVal
80917>>>>>>>  End
80917>>>>>>>>
80917>>>>>>>  Function_Return iRetVal
80918>>>>>>>End_Function // vCreateDirectory
80919>>>>>>>
80919>>>>>>>
80919>>>>>>>// **WvA: 03-02-2002 Function created.
80919>>>>>>>// With this function one can remove a directory.
80919>>>>>>>// returns 0 if the folder is removed.
80919>>>>>>>//         1 if the API-call returned an error (Use GetLastError API to get the details)
80919>>>>>>>//         2 if the folder did not exist
80919>>>>>>>//         3 if the sFolder parameter passed is equal to ""
80919>>>>>>>Function vRemoveDirectory Global String sFolder Returns Integer
80921>>>>>>>  String  sPath
80921>>>>>>>  Pointer lpsPath
80921>>>>>>>  Integer iRetval bRemoved
80921>>>>>>>
80921>>>>>>>  Move (False) To bRemoved
80922>>>>>>>  Move 0 To iRetVal
80923>>>>>>>  Move (Trim(sFolder)) To sFolder
80924>>>>>>>  If (sFolder="") Begin
80926>>>>>>>    Move 3 To iRetVal
80927>>>>>>>  End
80927>>>>>>>>
80927>>>>>>>  If (vFolderExists(sFolder)=False) Begin
80929>>>>>>>    Move 2 To iRetVal
80930>>>>>>>  End
80930>>>>>>>>
80930>>>>>>>  If (iRetVal=0) Begin
80932>>>>>>>    // null MAX_PATH chars into var (make space)
80932>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) To sPath
80933>>>>>>>    //
80933>>>>>>>    Move (Insert(sFolder,sPath,1)) To sPath
80934>>>>>>>    Move (AddressOf(sPath)) to lpsPath
80935>>>>>>>    Move (vWin32_RemoveDirectory(lpsPath)) To bRemoved
80936>>>>>>>  End
80936>>>>>>>>
80936>>>>>>>
80936>>>>>>>  If ((iRetVal=0) And (bRemoved=False)) Begin
80938>>>>>>>    Move 1 To iRetVal
80939>>>>>>>  End
80939>>>>>>>>
80939>>>>>>>  Function_Return iRetVal
80940>>>>>>>End_Function // vRemoveDirectory
80941>>>>>>>
80941>>>>>>>
80941>>>>>>>
80941>>>>>>>// This function informs the user that he entered a yet unknown folder and
80941>>>>>>>// asks if he/she wants to create the folder (Yes/No)
80941>>>>>>>// Choice: "Yes" - this creates the folder
80941>>>>>>>//                 if successful, the function returns false
80941>>>>>>>//                 else it will be true.
80941>>>>>>>// Choice: "No"  - returns TRUE, This allows the programmer to take action
80941>>>>>>>//                 For example: to stop a save
80941>>>>>>>// Precondition: A foldername must be entered. We do not check for empty paths
80941>>>>>>>// This function returns a non-zero value if the folder isn't created afterwards
80941>>>>>>>Function vVerifyNewFolder Global String sFolderName Returns Integer
80943>>>>>>>  Integer bIsNotValid
80943>>>>>>>  Integer iUsers_Choice
80943>>>>>>>  String  sMessage
80943>>>>>>>
80943>>>>>>>  If (vFolderExists(sFolderName) Eq 0) Begin
80945>>>>>>>    Move "The folder '" To sMessage
80946>>>>>>>    Append sMessage sFolderName
80947>>>>>>>    Append sMessage "' does not yet exist,\n"
80948>>>>>>>    Append sMessage "Do you want to create it now?"
80949>>>>>>>    Get YesNo_Box sMessage "Confirm" MB_DefButton1 To iUsers_Choice
80950>>>>>>>    Case Begin
80950>>>>>>>      Case (iUsers_Choice = MBR_Yes)
80952>>>>>>>        Move (vCreateDirectory(sFolderName)) To bIsNotValid
80953>>>>>>>        If bIsNotValid Begin
80955>>>>>>>          Move "An error occurred while trying to create folder '" To sMessage
80956>>>>>>>          Append sMessage sFolderName "'.\n\n"
80958>>>>>>>          Send Info_Box sMessage "Info"
80959>>>>>>>          End
80959>>>>>>>>
80959>>>>>>>        Case Break
80960>>>>>>>      Case (iUsers_Choice = MBR_No)
80963>>>>>>>        Move dfTrue To bIsNotValid // Cancel the save
80964>>>>>>>        Case Break
80965>>>>>>>    Case End
80965>>>>>>>  End
80965>>>>>>>>
80965>>>>>>>  Function_Return bIsNotValid
80966>>>>>>>End_Function // vVerifyNewFolder
80967>>>>>>>
80967>>>>>>>
80967>>>>>>>// This will perform an operation on a file (e.g. open) with the application
80967>>>>>>>// registered in the Windows Registry to open that type of file (via its extension)
80967>>>>>>>// sOperation would be "OPEN" (it could also be "PRINT" etc).
80967>>>>>>>Procedure vShellExecute global String sOperation String sDocument String sParameters String sPath
80969>>>>>>>  Handle  hInstance hWnd
80969>>>>>>>  Pointer lpsOperation
80969>>>>>>>  Pointer lpsDocument
80969>>>>>>>  Pointer lpsParameters
80969>>>>>>>  Pointer lpsPath
80969>>>>>>>  // remove any leading/trailing spaces in the string
80969>>>>>>>  Move (Trim(sDocument)) To sDocument
80970>>>>>>>  Move (Trim(sPath))     To sPath
80971>>>>>>>  // Make the strings readable for windows API, by converting them to null-terminated
80971>>>>>>>  Append sOperation   (Character(0))
80972>>>>>>>  Append sDocument    (Character(0))
80973>>>>>>>  Append sParameters  (Character(0))
80974>>>>>>>  Append sPath        (Character(0))
80975>>>>>>>  // Connect the corresponding pointers to the strings
80975>>>>>>>  Move (AddressOf(sOperation))  to lpsOperation
80976>>>>>>>  Move (AddressOf(sDocument))   to lpsDocument
80977>>>>>>>  Move (AddressOf(sParameters)) To lpsParameters
80978>>>>>>>  Move (AddressOf(sPath))       to lpsPath
80979>>>>>>>
80979>>>>>>>  Get Window_Handle To hWnd
80980>>>>>>>  Move (vWin32_ShellExecute (hWnd, lpsOperation, lpsDocument, lpsParameters, lpsPath, 1)) To hInstance
80981>>>>>>>  If (hInstance <= 32) Begin
80983>>>>>>>    Send vDDE_Error_Handler hInstance
80984>>>>>>>  End
80984>>>>>>>>
80984>>>>>>>End_Procedure // vShellExecute
80985>>>>>>>
80985>>>>>>>
80985>>>>>>>Class cShellFileOperations Is a Array
80986>>>>>>>
80986>>>>>>>  Procedure Construct_Object
80988>>>>>>>    Forward Send Construct_Object
80990>>>>>>>    Property Integer piDeleteFlags 0
80991>>>>>>>    Property Integer piCopyFlags   0
80992>>>>>>>    Property Integer piMoveFlags   0
80993>>>>>>>    Property Integer piRenameFlags 0
80994>>>>>>>
80994>>>>>>>    Set piDeleteFlags To (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
80995>>>>>>>    Set piCopyFlags   To (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR Ior vFOF_NOCONFIRMATION)
80996>>>>>>>    Set piMoveFlags   To (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR iOr vFOF_NOCONFIRMATION)
80997>>>>>>>    Set piRenameFlags To (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
80998>>>>>>>  End_Procedure // Construct_Object
80999>>>>>>>
80999>>>>>>>
80999>>>>>>>  // This function uses the shell API to perform a file operation on the
80999>>>>>>>  // files supplied.
80999>>>>>>>  //
80999>>>>>>>  Function FileOperation String sSource String sDestination Integer iOperation Integer iFlags Returns Integer
81001>>>>>>>    String   sShFileOp
81001>>>>>>>    Pointer  lpShFileOp
81001>>>>>>>    Pointer  lpsSource
81001>>>>>>>    Pointer  lpsDestination
81001>>>>>>>    Integer  iRetVal
81001>>>>>>>    Integer  bUserAbort
81001>>>>>>>
81001>>>>>>>    ZeroType vtShFileOpStruct To sShFileOp
81002>>>>>>>    Move (ToAnsi(sSource)+Character(0)+Character(0))      To sSource
81003>>>>>>>    Move (ToAnsi(sDestination)+Character(0)+Character(0)) To sDestination
81004>>>>>>>    Move (AddressOf(sSource))    To lpsSource
81005>>>>>>>    If iOperation Ne vFO_DELETE Begin
81007>>>>>>>      Move (AddressOf(sDestination))      To lpsDestination
81008>>>>>>>      Put lpsDestination To sShFileOp At vtShFileOpStruct.pTo
81009>>>>>>>    End
81009>>>>>>>>
81009>>>>>>>
81009>>>>>>>    Put iOperation     To sShFileOp At vtShFileOpStruct.wFunc
81010>>>>>>>    Put lpsSource      To sShFileOp At vtShFileOpStruct.pFrom
81011>>>>>>>    Put iFlags         To sShFileOp At vtShFileOpStruct.fFlags
81012>>>>>>>
81012>>>>>>>    Move (AddressOf(sShFileOp)) to lpShFileOp
81013>>>>>>>
81013>>>>>>>    Move (vWin32_SHFileOperation(lpShFileOp)) To iRetVal
81014>>>>>>>    GetBuff From sShFileOp At vtShFileOpStruct.fAnyOperationsAborted To bUserAbort
81015>>>>>>>    If (bUserAbort <> 0) Begin
81017>>>>>>>      Move 80 To iRetVal  // file Operation Aborted by USER
81018>>>>>>>    End
81018>>>>>>>>
81018>>>>>>>    Function_Return (iRetVal)
81019>>>>>>>  End_Function // FileOperation
81020>>>>>>>
81020>>>>>>>
81020>>>>>>>  Function sfoDeleteFile String sFileName Returns Integer
81022>>>>>>>    Integer  iRetVal
81022>>>>>>>    Integer  iFlags
81022>>>>>>>
81022>>>>>>>    Get piDeleteFlags To iFlags
81023>>>>>>>    Get FileOperation sFileName "" vFO_DELETE iFlags To iRetVal
81024>>>>>>>    Function_Return iRetVal
81025>>>>>>>  End_Function // sfoDeleteFile
81026>>>>>>>
81026>>>>>>>
81026>>>>>>>  Function sfoCopyFile String sSource String sDestination Returns Integer
81028>>>>>>>    Integer  iRetVal
81028>>>>>>>    Integer  iFlags
81028>>>>>>>
81028>>>>>>>    Get piCopyFlags To iFlags
81029>>>>>>>    Get FileOperation sSource sDestination vFO_COPY iFlags To iRetVal
81030>>>>>>>    Function_Return iRetVal
81031>>>>>>>  End_Function // sfoCopyFile
81032>>>>>>>
81032>>>>>>>
81032>>>>>>>  Function sfoMoveFile String sSource String sDestination Returns Integer
81034>>>>>>>    Integer  iRetVal
81034>>>>>>>    Integer  iFlags
81034>>>>>>>
81034>>>>>>>    Get piMoveFlags To iFlags
81035>>>>>>>    Get FileOperation sSource sDestination vFO_MOVE iFlags To iRetVal
81036>>>>>>>    Function_Return iRetVal
81037>>>>>>>  End_Function // sfoMoveFile
81038>>>>>>>
81038>>>>>>>
81038>>>>>>>  // Rename a file or folder
81038>>>>>>>  // Returns a nonzero value if the operation failed.
81038>>>>>>>  Function sfoRenameFile String sSource String sDestination Returns Integer
81040>>>>>>>    Integer  iRetVal
81040>>>>>>>    Integer  iFlags
81040>>>>>>>
81040>>>>>>>    Get piRenameFlags To iFlags
81041>>>>>>>    Get FileOperation sSource sDestination vFO_RENAME iFlags To iRetVal
81042>>>>>>>    Function_Return iRetVal
81043>>>>>>>  End_Function // sfoRenameFile
81044>>>>>>>
81044>>>>>>>  // Courtesy Of Steve Walter
81044>>>>>>>  // Requires Windows 2000 and up according to msdn but it was
81044>>>>>>>  //  in fact available before that as an unpublished API call
81044>>>>>>>  //  a little google search shows that this was already available
81044>>>>>>>  //  in windows 95 and NT
81044>>>>>>>  //
81044>>>>>>>  // The format is controlled by the dialog interface.
81044>>>>>>>  // That is, the user must click the OK button To actually Begin the format
81044>>>>>>>  // the format cannot be started programmatically.
81044>>>>>>>  // An alternative to this functionality would be to use a controlpanel
81044>>>>>>>  //  http://www.vdf-guidance.com/ContribPage.asp?Page=PKGCLSDFCPLAPP&ContribRecId=93
81044>>>>>>>  //
81044>>>>>>>  // hWnd = The windows handle of the object from which the format Function
81044>>>>>>>  //        is called.
81044>>>>>>>  // To Get this,
81044>>>>>>>  //          use:  Get Window_Handle Of <object>
81044>>>>>>>  //          For instance, in this app, we're going to use the Report_Panel:
81044>>>>>>>  //                  Get Window_Handle Of (Report_Panel(Main(Self))) To hWind
81044>>>>>>>  //
81044>>>>>>>  // sDrive = The drive letter. At this moment only A and B are valid
81044>>>>>>>  //
81044>>>>>>>  // iOptions = Format options.
81044>>>>>>>  //  SHFMT_OPT_DEFAULT = Quick format
81044>>>>>>>  //  SHFMT_OPT_FULL    = Full Format
81044>>>>>>>  //  SHFMT_OPT_SYSONLY = System only
81044>>>>>>>  //  3                 = Full format with system. (unsupported)
81044>>>>>>>  //
81044>>>>>>>  // Return Values:
81044>>>>>>>  //  SHFMT_ERROR    = Error on format or no drive specified.
81044>>>>>>>  //  SHFMT_CANCEL   = Format cancelled by user.
81044>>>>>>>  //  SHFMT_NOFORMAT = Drive is not formatable.
81044>>>>>>>  //
81044>>>>>>>  //
81044>>>>>>>  // *** ATTENTION: This function has been disabled as it doesn't
81044>>>>>>>  //                seem to work, i must have made a silly mistake
81044>>>>>>>  //                somewhere.
81044>>>>>>>  //
81044>>>>>>>  Function sfoFormatDisk String sDrive Integer iOptions Returns DWORD
81046>>>>>>>    Handle   hWnd
81046>>>>>>>    Integer  iObj
81046>>>>>>>    DWORD    dwReturnVal
81046>>>>>>>    Integer iDrive
81046>>>>>>>
81046>>>>>>>    Function_Return (1) // STOP HERE
81047>>>>>>>
81047>>>>>>>    Move (Trim(sDrive)) To sDrive
81048>>>>>>>    If ( sDrive <> '' ) Begin
81050>>>>>>>      If ( sDrive contains ':' ) Begin
81052>>>>>>>        Move (Replace(':',sDrive,'')) to sDrive
81053>>>>>>>      End
81053>>>>>>>>
81053>>>>>>>      If (not( 'AB' contains sDrive )) Begin
81055>>>>>>>         Function_Return (SHFMT_NOFORMAT)
81056>>>>>>>      End
81056>>>>>>>>
81056>>>>>>>      If ( sDrive = 'A') Begin
81058>>>>>>>        Move 0 to iDrive
81059>>>>>>>      End
81059>>>>>>>>
81059>>>>>>>      Else If ( sDrive = 'B') Begin
81062>>>>>>>        Move 1 to iDrive
81063>>>>>>>      End
81063>>>>>>>>
81063>>>>>>>      // Window_Handle Of Desktop equals to 0
81063>>>>>>>
81063>>>>>>>      Get focus Of desktop To iObj
81064>>>>>>>      If (iObj>desktop) ;          Get Container_Handle Of iObj To hWnd
81067>>>>>>>      While (hWnd=0 And iObj<>Desktop)
81071>>>>>>>          Get Parent Of iObj To iObj
81072>>>>>>>          Get Container_Handle Of iObj To hWnd
81073>>>>>>>      End
81074>>>>>>>>
81074>>>>>>>
81074>>>>>>>      //Showln "hWnd = " hWnd " iDrive " iDrive " iOptions " iOptions
81074>>>>>>>      Move (vWin32_ShFormatDrive(hWnd, iDrive, SHFMT_ID_DEFAULT, iOptions)) To dwReturnVal
81075>>>>>>>    End
81075>>>>>>>>
81075>>>>>>>    Else Begin
81076>>>>>>>      Move (SHFMT_ERROR) To dwReturnVal
81077>>>>>>>    End
81077>>>>>>>>
81077>>>>>>>    Function_Return dwReturnVal
81078>>>>>>>  End_Function // sfoFormatDisk
81079>>>>>>>
81079>>>>>>>  //Example:
81079>>>>>>>  // Get sfoFormatDisk 'A' 0 To dReturnVal    // Formats drive A in QuickFormat
81079>>>>>>>  //                                          mode.
81079>>>>>>>
81079>>>>>>>End_Class // cShellFileOperations
81080>>>>>>>
81080>>>>>>>
81080>>>>>>>Object oShellFileOperations Is a cShellFileOperations
81082>>>>>>>End_Object // oShellFileOperations
81083>>>>>>>
81083>>>>>>>
81083>>>>>>>// Restore to the old way of working with the shell file operations.
81083>>>>>>>// or.. to put lay man terms, allow any of the operations vDeleteFile
81083>>>>>>>// vCopyFile/vMoveFile/vRenameFile to have an UNDO
81083>>>>>>>Procedure vWin32fhCompatibilityMode
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
81085>>>>>>>  Integer hoSFO
81085>>>>>>>  Integer iFlags
81085>>>>>>>
81085>>>>>>>  Move (vFOF_SILENT Ior vFOF_NOCONFIRMATION Ior vFOF_ALLOWUNDO) To iFlags
81086>>>>>>>  Move (oShellFileOperations(Self)) To hoSFO
81087>>>>>>>
81087>>>>>>>  Set piDeleteFlags Of hoSFO To iFlags
81088>>>>>>>  Set piCopyFlags   Of hoSFO To iFlags
81089>>>>>>>  Set piMoveFlags   Of hoSFO To iFlags
81090>>>>>>>  Set piRenameFlags Of hoSFO To iFlags
81091>>>>>>>End_Procedure // vWin32fhCompatibilityMode
81092>>>>>>>
81092>>>>>>>
81092>>>>>>>Function vDeleteFile Global String sFileName Returns Integer
81094>>>>>>>  Integer  iRetVal
81094>>>>>>>
81094>>>>>>>  Get sfoDeleteFile Of (oShellFileOperations(Self)) sFileName To iRetVal
81095>>>>>>>  Function_Return iRetVal
81096>>>>>>>End_Function // vDeleteFile
81097>>>>>>>
81097>>>>>>>
81097>>>>>>>Function vCopyFile Global String sSource String sDestination Returns Integer
81099>>>>>>>  Integer  iRetVal
81099>>>>>>>
81099>>>>>>>  Get sfoCopyFile Of (oShellFileOperations(Self)) sSource sDestination To iRetVal
81100>>>>>>>  Function_Return iRetVal
81101>>>>>>>End_Function // vCopyFile
81102>>>>>>>
81102>>>>>>>
81102>>>>>>>Function vMoveFile Global String sSource String sDestination Returns Integer
81104>>>>>>>  Integer  iRetVal
81104>>>>>>>
81104>>>>>>>  Get sfoMoveFile Of (oShellFileOperations(Self)) sSource sDestination To iRetVal
81105>>>>>>>  Function_Return iRetVal
81106>>>>>>>End_Function // vMoveFile
81107>>>>>>>
81107>>>>>>>
81107>>>>>>>// Rename a file or folder
81107>>>>>>>// Returns a nonzero value if the operation failed.
81107>>>>>>>Function vRenameFile Global String sSource String sDestination Returns Integer
81109>>>>>>>  Integer  iRetVal
81109>>>>>>>
81109>>>>>>>  Get sfoRenameFile Of (oShellFileOperations(Self)) sSource sDestination To iRetVal
81110>>>>>>>  Function_Return iRetVal
81111>>>>>>>End_Function // vRenameFile
81112>>>>>>>
81112>>>>>>>
81112>>>>>>>
81112>>>>>>>Function vGetWindowsDirectory Returns String
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
81114>>>>>>>  String  sDirectory
81114>>>>>>>  Pointer lpDirectory
81114>>>>>>>  Integer iVoid
81114>>>>>>>
81114>>>>>>>  ZeroString vMAX_PATH To sDirectory
81115>>>>>>>  Move (AddressOf(sDirectory)) to lpDirectory
81116>>>>>>>
81116>>>>>>>  Move (vWin32_GetWindowsDirectory(lpDirectory, vMAX_PATH)) To iVoid
81117>>>>>>>  Function_Return (CString(sDirectory))  // **WvA: Changed to CString()
81118>>>>>>>End_Function // vGetWindowsDirectory
81119>>>>>>>
81119>>>>>>>
81119>>>>>>>
81119>>>>>>>
81119>>>>>>>// Courtesy of Marco Kuipers
81119>>>>>>>Function vMakeTempFile Returns String
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
81121>>>>>>>    Integer iRetval
81121>>>>>>>    String  sTempPath sTempFileName sPrefixString
81121>>>>>>>    Pointer lpTempPath lpTempFileName lpPrefixString
81121>>>>>>>
81121>>>>>>>    Move (Repeat (Character (0), 255)) To sTempPath
81122>>>>>>>    Move (AddressOf(sTempPath)) to lpTempPath
81123>>>>>>>    Move (vWin32_GetTempPath (255, lpTempPath)) To iRetVal
81124>>>>>>>
81124>>>>>>>    If (sTempPath = "") Begin
81126>>>>>>>       Get_Current_Directory To sTempPath
81127>>>>>>>    End
81127>>>>>>>>
81127>>>>>>>    Move (pad(sTempPath,vMax_Path-14)) To sTempPath // *WvA: 28-04-2005 Quote from msdn: The string cannot be longer than MAX_PATH-14 characters.
81128>>>>>>>    Move (Repeat (Character (0), 255)) To sTempFileName
81129>>>>>>>    Move (AddressOf(sTempFileName)) To lpTempFileName
81130>>>>>>>    Move ("tmp"+character(0)) To sPrefixString // **WvA: 28-04-2005 Added a null
81131>>>>>>>    Move (AddressOf(sPrefixString)) To lpPrefixString
81132>>>>>>>    Move (AddressOf(sTempPath)) to lpTempPath
81133>>>>>>>    Move (vWin32_GetTempFileName (lpTempPath, lpPrefixString, 0, lpTempFileName)) To iRetval
81134>>>>>>>    If (iRetval = 0) Begin  // **WvA: 28-04-2005 Changed condition, the api call returns 0 if an error occurs
81136>>>>>>>        Move "" To sTempFileName
81137>>>>>>>    End
81137>>>>>>>>
81137>>>>>>>
81137>>>>>>>    Function_Return (Cstring(sTempFileName)) // **WvA: 28-04-2005 Cstring added
81138>>>>>>>End_Function // vMakeTempFile
81139>>>>>>>
81139>>>>>>>
81139>>>>>>>// This function creates a uniquely named temporary file in folder sPath
81139>>>>>>>// The file created will have a prefix based on the first 3 characters in sPrefix
81139>>>>>>>// Note that you will have to cleanup the tempfile yourself as the function
81139>>>>>>>// does not take care of that.
81139>>>>>>>Function vCreateTempFileInPath String sPath String sPrefix Returns String
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
81141>>>>>>>    String sTempFileName
81141>>>>>>>    Integer iRetVal
81141>>>>>>>    Pointer lpTempFileName
81141>>>>>>>    Pointer lpPath
81141>>>>>>>    Pointer lpPrefix
81141>>>>>>>
81141>>>>>>>    Move (ToAnsi(sPath)+Character(0))   To sPath
81142>>>>>>>    Move (ToAnsi(sPrefix)+Character(0)) To sPrefix
81143>>>>>>>    Move (pad("", vMAX_PATH)) To sTempFileName
81144>>>>>>>    Move (AddressOf(sTempFileName)) To lpTempFileName
81145>>>>>>>    Move (AddressOf(sPath))         To lpPath
81146>>>>>>>    Move (AddressOf(sPrefix))       to lpPrefix
81147>>>>>>>
81147>>>>>>>    Move (vWin32_GetTempFileName(lpPath, lpPrefix, 0, lpTempFileName)) To iRetVal
81148>>>>>>>    Move (Trim(Cstring(sTempFileName))) To sTempFileName
81149>>>>>>>    Function_Return sTempFileName
81150>>>>>>>End_Function // vCreateTempFileInPath
81151>>>>>>>
81151>>>>>>>//
81151>>>>>>>// Get a specific shell folder for example to get the desktop folder
81151>>>>>>>// simply call this function and pass it vCSIDL_DESKTOP
81151>>>>>>>//
81151>>>>>>>Function vSHGetFolderPath Integer eFolder Returns String
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
81153>>>>>>>  String  sFolder
81153>>>>>>>  Integer iVoid
81153>>>>>>>  Pointer lpsFolder
81153>>>>>>>  Handle  hWnd
81153>>>>>>>  Move (Window_Handle(focus(desktop))) To hWnd
81154>>>>>>>
81154>>>>>>>  Move (Repeat(Character(0), vMAX_PATH)) To sFolder
81155>>>>>>>  Move (AddressOf(sFolder)) To lpsFolder
81156>>>>>>>
81156>>>>>>>  Move (vWin32_SHGetFolderPath(hWnd,eFolder, 0, 0,lpsFolder)) To iVoid
81157>>>>>>>  Function_Return (CString(sFolder))
81158>>>>>>>End_Function // vSHGetFolderPath
81159>>>>>>>
81159>>>>>>>
81159>>>>>>>
81159>>>>>>>// Courtesy Of Vincent Oorsprong
81159>>>>>>>Function vConvertFileDateTime Global Dword dwLowDateTime Dword dwHighDateTime Returns String
81161>>>>>>>  String  sftTime sSystemTime sFormattedTime sFormattedDate
81161>>>>>>>  Pointer lpsftTime lpsSystemTime lpsFormattedTime lpsFormattedDate
81161>>>>>>>  Integer iSuccess iLenCcTime iDataLength iLenCcDate
81161>>>>>>>
81161>>>>>>>  ZeroType vFileTime  To sftTime
81162>>>>>>>  Put dwLowDateTime  To sftTime At vFileTime.dwLowDateTime
81163>>>>>>>  Put dwHighDateTime To sftTime At vFileTime.dwHighDateTime
81164>>>>>>>  Move (AddressOf(sftTime)) to lpsftTime
81165>>>>>>>
81165>>>>>>>  ZeroType vSystemTime To sSystemTime
81166>>>>>>>  Move (AddressOf(sSystemTime)) To lpsSystemTime
81167>>>>>>>
81167>>>>>>>  Move (vWin32_FileTimeToSystemTime (lpsftTime, lpsSystemTime)) To iSuccess
81168>>>>>>>  If iSuccess Eq DfTrue Begin
81170>>>>>>>    ZeroString 255 To sFormattedTime
81171>>>>>>>    Move (AddressOf(sFormattedTime)) To lpsFormattedTime
81172>>>>>>>    Length sFormattedTime To iLenCcTime
81173>>>>>>>>
81173>>>>>>>    Move (vWin32_GetTimeFormat (LOCALE_USER_DEFAULT, 0, lpsSystemTime, 0, ;                             lpsFormattedTime, iLenCcTime)) To iDataLength
81174>>>>>>>    ZeroString 255 To sFormattedDate
81175>>>>>>>    Move (AddressOf(sFormattedDate)) to lpsFormattedDate
81176>>>>>>>    Move (Length(sFormattedDate)) to iLenCcDate
81177>>>>>>>    Move (vWin32_GetDateFormat (LOCALE_USER_DEFAULT, 0, lpsSystemTime, 0, ;                             lpsFormattedDate, iLenCcDate)) To iDataLength
81178>>>>>>>    Function_Return (Cstring (sFormattedDate)  * Cstring (sFormattedTime))
81179>>>>>>>  End // iSuccess
81179>>>>>>>>
81179>>>>>>>End_Function // vConvertFileDateTime
81180>>>>>>>
81180>>>>>>>
81180>>>>>>>// **WvA Removed, See the cFileSet class for an alternative
81180>>>>>>>//Procedure DoBrowseDir String sFilePath
81180>>>>>>>//End_Procedure // DoBrowseDir
81180>>>>>>>
81180>>>>>>>// **WvA:
81180>>>>>>>// A windows replacement for the standard function FileExists.
81180>>>>>>>// This version will also return (true) for a file when it is open by an application.
81180>>>>>>>// Note that you can apply normal windows mask-signs in the filename such as * and ?
81180>>>>>>>// Example: Get vFilePathExists "C:\config.sy?"
81180>>>>>>>// This will return true if you have a file matching these conditions. (aka config.sys)
81180>>>>>>>Function vFilePathExists Global String sFilePathMask Returns Integer
81182>>>>>>>  String  sWin32FindData
81182>>>>>>>  String  sDirSep
81182>>>>>>>  Pointer lpsFilePathMask lpsWin32FindData
81182>>>>>>>  Handle  hFindFile
81182>>>>>>>  Integer iVoid
81182>>>>>>>
81182>>>>>>>  Move vINVALID_HANDLE_VALUE To hFindFile
81183>>>>>>>  Move (ToANSI(trim(sFilePathMask))) To sFilePathMask
81184>>>>>>>
81184>>>>>>>  If (length(sFilePathMask)>0) Begin
81186>>>>>>>    // 2014-09-29 NGS Remove any trailing dir separators, as they make the function fail.
81186>>>>>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
81187>>>>>>>    While (Right(sFilePathMask, 1) = sDirSep)
81191>>>>>>>      Move (Left(sFilePathMask, Length(sFilePathMask) -1)) to sFilePathMask
81192>>>>>>>    Loop
81193>>>>>>>>
81193>>>>>>>
81193>>>>>>>    Move (AddressOf(sFilePathMask)) To lpsFilePathMask
81194>>>>>>>    ZeroType vWin32_Find_Data To sWin32FindData
81195>>>>>>>    Move (AddressOf(sWin32FindData)) to lpswin32FindData
81196>>>>>>>    Move (vWin32_FindFirstFile (lpsFilePathMask, lpsWin32FindData)) To hFindFile
81197>>>>>>>    Move (vWin32_FindClose (hFindFile)) To iVoid
81198>>>>>>>  End
81198>>>>>>>>
81198>>>>>>>  Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
81199>>>>>>>End_Function // vFilePathExists
81200>>>>>>>
81200>>>>>>>
81200>>>>>>>// **WvA
81200>>>>>>>// Formats a foldername by first trimming it and after that by sticking a
81200>>>>>>>// directory separator (/\) to the end if it doesn't have one there already.
81200>>>>>>>// The folder may contain a drive letter or UNC encoding.
81200>>>>>>>Function vFolderFormat Global String sFolderName Returns String
81202>>>>>>>  String sDirSep
81202>>>>>>>  Move (sysconf(SYSCONF_DIR_SEPARATOR)) To sDirSep  // normally \ (backslash)
81203>>>>>>>  Move (Trim(sFolderName)) To sFolderName
81204>>>>>>>  If (Right(sFolderName,1)<>sDirSep) Begin
81206>>>>>>>    Move (sFolderName+sDirSep) To sFolderName
81207>>>>>>>  End
81207>>>>>>>>
81207>>>>>>>  Function_Return sFolderName
81208>>>>>>>End_Function // vFolderFormat
81209>>>>>>>//
81209>>>>>>>// Returns the amount of files in the folder (if it exists)
81209>>>>>>>// Returns -1 if folder doesn't exist.
81209>>>>>>>// The files "." and ".." are not counted.
81209>>>>>>>//
81209>>>>>>>Function vFolderFileCount Global String sFolderName Returns Integer
81211>>>>>>>  Boolean bFound
81211>>>>>>>  Handle  hFindFile
81211>>>>>>>  Integer iCount  iVoid
81211>>>>>>>  Integer iSuccess
81211>>>>>>>  Pointer lpsFolderName lpsWin32FindData
81211>>>>>>>  String  sWin32FindData
81211>>>>>>>  String  sFileName
81211>>>>>>>
81211>>>>>>>  Move -1 To iCount
81212>>>>>>>  Get vFolderFormat sFolderName To sFolderName
81213>>>>>>>  Move (sFolderName+"*") To sFolderName // match any filename in the folder
81214>>>>>>>  Move (AddressOf(sFolderName)) To lpsFolderName
81215>>>>>>>  ZeroType vWin32_Find_Data To sWin32FindData
81216>>>>>>>  Move (AddressOf(sWin32FindData)) to lpswin32FindData
81217>>>>>>>  Move (vWin32_FindFirstFile (lpsFolderName, lpsWin32FindData)) To hFindFile
81218>>>>>>>  Move (hFindFile<>vINVALID_HANDLE_VALUE) To bFound
81219>>>>>>>  If (bFound) Begin
81221>>>>>>>    Move 0 to iCount
81222>>>>>>>  End
81222>>>>>>>>
81222>>>>>>>  While (bFound)
81226>>>>>>>    Increment iCount
81227>>>>>>>    GetBuff_String From sWin32FindData At vWin32_Find_Data.cFileName To sFileName
81228>>>>>>>    If (sFileName="." or sFileName="..") Begin
81230>>>>>>>        Decrement iCount
81231>>>>>>>    End
81231>>>>>>>>
81231>>>>>>>    Move (vWin32_FindNextFile(hFindFile, lpsWin32FindData)) To iSuccess
81232>>>>>>>    Move (iSuccess<>0) To bFound
81233>>>>>>>  Loop
81234>>>>>>>>
81234>>>>>>>  Move (vWin32_FindClose (hFindFile)) To iVoid
81235>>>>>>>  Function_Return iCount
81236>>>>>>>End_Function // vFolderFileCount
81237>>>>>>>
81237>>>>>>>
81237>>>>>>>//
81237>>>>>>>// Gets the parent path of the currently supplied path
81237>>>>>>>// Returns "" when we are at the root folder.
81237>>>>>>>//
81237>>>>>>>Function vParentPath Global String sPath Returns String
81239>>>>>>>  String sStrip
81239>>>>>>>  Integer iLength
81239>>>>>>>
81239>>>>>>>  If (Right(sPath,1)="\") Begin
81241>>>>>>>    Move (Left(sPath,Length(sPath)-1)) To sPath
81242>>>>>>>  End
81242>>>>>>>>
81242>>>>>>>  If (Pos("\",sPath)) Begin
81244>>>>>>>    Move (StringFromRightOfChar(sPath,"\")) to sStrip
81245>>>>>>>    Move (Length(sStrip)) to iLength
81246>>>>>>>    Move (Left(sPath, (Length(sPath) - iLength -1))) to sPath
81247>>>>>>>//    Move (Replace(sStrip,sPath,"")) To sPath
81247>>>>>>>  End
81247>>>>>>>>
81247>>>>>>>  Else Begin
81248>>>>>>>    Move "" To sPath
81249>>>>>>>  End
81249>>>>>>>>
81249>>>>>>>  Function_Return sPath
81250>>>>>>>End_Function // vParentPath
81251>>>>>>>
81251>>>>>>>// Create the folder, including intermediate directories.
81251>>>>>>>// Don't panic if the folder already exists.
81251>>>>>>>// Michael Mullan June 2009.
81251>>>>>>>Function vshCreateDirectoryEX Global String sNewFolder Returns Integer
81253>>>>>>>  String  sFolder sSA
81253>>>>>>>  Pointer lpsFolder lpsSecurity_Attributes
81253>>>>>>>  Integer iRetval bFolderCreated bInheritHandle
81253>>>>>>>  Move (False) to bFolderCreated
81254>>>>>>>  // fill string variable with null characters
81254>>>>>>>  ZeroType vtSecurity_attributes to sSA
81255>>>>>>>  // null MAX_PATH chars into var (make space)
81255>>>>>>>  Move (Repeat(Character(0), vMAX_PATH)) to sFolder
81256>>>>>>>  If (sNewFolder <> "") Begin
81258>>>>>>>    Move dfTrue to  bInheritHandle
81259>>>>>>>    // Setting this to NULL is already done by the zerotype command
81259>>>>>>>    // Move NULL   To  lpDescriptor
81259>>>>>>>    Put (length(sSA))   to sSA At vtSecurity_attributes.nLength
81260>>>>>>>    //Put lpDescriptor To sSA at vtSecurity_attributes.lpDescriptor
81260>>>>>>>    Put bInheritHandle to sSA At vtSecurity_attributes.bInheritHandle
81261>>>>>>>    Move (AddressOf(sSA)) to lpsSecurity_Attributes
81262>>>>>>>    //
81262>>>>>>>    Move sNewFolder to sFolder
81263>>>>>>>    Move (AddressOf(sFolder)) to lpsFolder
81264>>>>>>>    Move (vWin32_SHCreateDirectoryEx(0,lpsFolder, lpsSecurity_Attributes)) to bFolderCreated
81265>>>>>>>  End
81265>>>>>>>>
81265>>>>>>>
81265>>>>>>>  If (bFolderCreated <> 0) Begin
81267>>>>>>>    Move 1 to iRetVal
81268>>>>>>>
81268>>>>>>>    If (bFolderCreated = 161 ) Begin
81270>>>>>>>        Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_BAD_PATHNAME)")
81271>>>>>>>>
81271>>>>>>>    End
81271>>>>>>>>
81271>>>>>>>    Else If (bFolderCreated = 206 ) Begin
81274>>>>>>>        Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_FILENAME_EXCED_RANGE)")
81275>>>>>>>>
81275>>>>>>>    End
81275>>>>>>>>
81275>>>>>>>    Else If (bFolderCreated = 3   ) Begin
81278>>>>>>>        Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_PATH_NOT_FOUND)")
81279>>>>>>>>
81279>>>>>>>    End
81279>>>>>>>>
81279>>>>>>>    Else If (bFolderCreated = 80  ) Begin
81282>>>>>>>        Move 0 to iRetval // "ERROR_FILE_EXISTS"     not really an error
81283>>>>>>>    End
81283>>>>>>>>
81283>>>>>>>    Else If (bFolderCreated = 183 ) Begin
81286>>>>>>>        Move 0 to iRetval //  "ERROR_ALREADY_EXISTS"     not really an error
81287>>>>>>>    End
81287>>>>>>>>
81287>>>>>>>    Else If (bFolderCreated = 1223) Begin
81290>>>>>>>        Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_CANCELLED)")
81291>>>>>>>>
81291>>>>>>>    End
81291>>>>>>>>
81291>>>>>>>    Else Begin
81292>>>>>>>        Error DFERR_OPERATOR ("Folder Creation Error # " + String(bfoldercreated) + "\n" + sNewFolder + "(FILE_CREATION_ERROR)")
81293>>>>>>>>
81293>>>>>>>    End
81293>>>>>>>>
81293>>>>>>>  End
81293>>>>>>>>
81293>>>>>>>  Function_Return iRetVal
81294>>>>>>>End_Function // vshCreateDirectoryEX
81295>>>>>>>
81295>>>>>>>
81295>>>>>>>Function vWin32_APIFileSize Global string sFileName returns integer
81297>>>>>>>     dWord dwFileSizeHigh dwFileSizeLow
81297>>>>>>>     integer iFileSize iVoid
81297>>>>>>>     handle hFindFile
81297>>>>>>>     pointer lpsFilePath lpsWin32FindData
81297>>>>>>>     string sWin32FindData
81297>>>>>>>
81297>>>>>>>     Move (AddressOf(sFileName)) to lpsFilePath
81298>>>>>>>
81298>>>>>>>     ZeroType vWin32_Find_Data to sWin32FindData
81299>>>>>>>     Move (AddressOf(sWin32FindData)) to lpsWin32FindData
81300>>>>>>>
81300>>>>>>>     move (vWin32_FindFirstFile (lpsFilePath, lpsWin32FindData)) to hFindFile
81301>>>>>>>     if (hFindFile<>vINVALID_HANDLE_VALUE) begin
81303>>>>>>>         GetBuff From sWin32FindData At vWin32_Find_Data.nFileSizeHigh To dwFileSizeHigh
81304>>>>>>>         GetBuff From sWin32FindData At vWin32_Find_Data.nFileSizeLow To dwFileSizeLow
81305>>>>>>>     end
81305>>>>>>>>
81305>>>>>>>     move (vWin32_FindClose (hFindFile)) to iVoid
81306>>>>>>>
81306>>>>>>>     Move ((dwFileSizeHigh * vMaxDword) + dwFileSizeLow) to iFileSize
81307>>>>>>>
81307>>>>>>>     function_return iFileSize
81308>>>>>>>End_Function  // vWin32_APIFileSize
81309>>>>>>>
81309>>>>>>>
81309>>>>>Use DUFLanguageConstants.inc
Including file: DUFLanguageConstants.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\DUFLanguageConstants.inc)
81309>>>>>>>//
81309>>>>>>>// *** The Database Update Framework Include file ***
81309>>>>>>>// Language constant declarations for all classes included in "DUF - The Database Update Framework"
81309>>>>>>>// They have all been placed in this central spot to make translations to various languages more convenient.
81309>>>>>>>//
81309>>>>>>>//
81309>>>>>>>Use LanguageText.Pkg
81309>>>>>>>
81309>>>>>>>// *** cSQLConnectionsIniFile Class Language Constants ***
81309>>>>>>>//
81309>>>>>>>    Define CS_DUF_DuplicateConnectionIDPre  for "Cannot register connection ID"
81309>>>>>>>    Define CS_DUF_DuplicateConnectionIDPost for "This ID already exists."
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>// *** cSQLConnectionsHandler Class Language Constants ***
81309>>>>>>>//
81309>>>>>>>    Define CS_DUF_SetupErrorcConnection  for "Cannot login to the database server as the cConnection hasn't been setup properly. Can't continue. Program will now exit."
81309>>>>>>>    Define CS_DUF_CannotLoginToServer    for "Could not login to the database server. Can't continue. Program will now exit."
81309>>>>>>>    Define CS_DUF_ErrorText              for "\n\nError Text:"
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>// *** cDbUpdateFunctionLibrary Class Language Constants ***
81309>>>>>>>//
81309>>>>>>>    Define CS_SQLConnectError       for "SQL error. Could not connect to the SQL database manager"
81309>>>>>>>    Define CS_SQLAttachError        for "Could not attach to the database:"
81309>>>>>>>    Define CS_SQLDeletingIndex      for "Deleting index"
81309>>>>>>>    Define CS_SQLCopyingData        for "Copying data"
81309>>>>>>>    Define CS_SQLCreatingIndex      for "Creating index"
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>// *** cDbUpdateVersion Class Language Constants ***
81309>>>>>>>//
81309>>>>>>>    Define CS_UpdateVersion     for "Updating database"
81309>>>>>>>    Define CS_UpdateFromVersion for "from version"
81309>>>>>>>    Define CS_UpdateToVersion   for "to version:"
81309>>>>>>>    Define CS_DbUpdateTableMissing for "Cannot open the 'DbVersion' table that is used when updating the database! Cannot continue!"
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>// *** cDbUpdateHandler.inc Class Language Constants ***
81309>>>>>>>//
81309>>>>>>>    Define CS_DatabaseInUseShort  for "There are others using the application/database. Are you sure you still want to update the database?"
81309>>>>>>>    Define CS_DatabaseNeedsUpdate for ("The database needs to be updated." + "\n\nATTENTION! The database may not be in use while this work is performed. Make sure that nobody else is using the application before clicking 'Yes' below.\n\n" + "Start update now?")
81309>>>>>>>    Define CS_HeaderUpdateText    for "Important!"
81309>>>>>>>    Define CS_DatabaseInUseText   for "There are others using the application/database or at least one table could NOT be opened exclusively. Please close all other applications using the database and try again. The Application will now close."
81309>>>>>>>    Define CS_WorkingHeaderText   for "Working!"
81309>>>>>>>    Define CS_WorkingUpdateText   for "The database is being updated. Please wait..."
81309>>>>>>>    Define CS_DatabaseUpdatedText for "Ready! The database was updated."
81309>>>>>>>    Define CS_DatabaseCheckedText for "Ready! The database was checked but no updates was needed."
81309>>>>>>>    Define CS_DbUpdatedErrorText  for "One or more errors occured while the database was updated. Please check the logfile.\n\nThe program will now close."
81309>>>>>>>    Define CS_UpdateInProgressTxt for ("System locked!\n\nThe database is being updated. Please try again later...\n\n" * "The program will now close.")
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>>>
81309>>>>>
81309>>>>>Struct tDbVersionInfo
81309>>>>>    Number nVersionNumber
81309>>>>>    Handle hObject
81309>>>>>End_Struct
81309>>>>>
81309>>>>>Struct tDbUpdateError
81309>>>>>    Number nUpdateVersion
81309>>>>>    Integer iError
81309>>>>>    String  sErrorText
81309>>>>>    Integer iErrorLine
81309>>>>>    Boolean bError  
81309>>>>>    Handle  hTable
81309>>>>>    Integer iField
81309>>>>>    Boolean bShortFormat
81309>>>>>End_Struct
81309>>>>>
81309>>>>>//  DF_FILE_ALIAS_DEFAULT if no master or alias
81309>>>>>//  DF_FILE_IS_MASTER if master
81309>>>>>//  DF_FILE_IS_ALIAS if alias
81309>>>>>Struct tDbUpdateHandlerMasterAlias
81309>>>>>    Handle hTable
81309>>>>>    Integer iMode
81309>>>>>End_Struct
81309>>>>>
81309>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
81309>>>>>Enumeration_List
81309>>>>>    Define DUF_ERROR_REPORT    // Report Error on screen
81309>>>>>    Define DUF_ERROR_NO_REPORT // Show no Error..
81309>>>>>End_Enumeration_List
81309>>>>>
81309>>>>>    Define DATAFLEX_ID for "DATAFLEX"
81309>>>>>
81309>>>>>// Global handle to a cDatabaseUpdateHandler object that can be used to
81309>>>>>// communicate with the object from anywhere in a program.
81309>>>>>    Global_Variable Handle ghoDbUpdateHandler
81309>>>>>
81309>>>>>// NOTE: If the DbVersion table should _not_ be used and you
81309>>>>>// instead set the "Set Data_File_Field to (RefTable(MyTable)) (RefTable(MyTable.DbUpdateVersion))"
81309>>>>>// in the cDbUpdateHandler object; Add a "Define DUF_Use_DbVersion" to your code,
81309>>>>>// _before_ the "Use cDbUpdateHandler.pkg" line.
81309>>>>>    Declare_Datafile DbVersion
Including file: DbVersion.fd    (C:\Projects\DF18\DbUpdateFramework\DDSrc\DbVersion.fd)
81309>>>Use cDbUpdateLogFile.pkg
Including file: cDbUpdateLogFile.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateLogFile.pkg)
81309>>>>>//****************************************************************************
81309>>>>>// $Module type: Class
81309>>>>>// $Module name: cDbUpdateLogFile
81309>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
81309>>>>>// Web-site    : http://www.rdctools.com
81309>>>>>// Created     : 2016-10-05 @ 18:58 (Military date format: YY-MM-DD)
81309>>>>>//
81309>>>>>// Description : This logic was moved from the cDbUpdateHandler class so that it would
81309>>>>>//               be easier to change to where errors/status messages are written/saved. As it is less likely
81309>>>>>//               that this class is to change; each developer can decide if the errors instead
81309>>>>>//               should be saved to a database table, or something entirely different.
81309>>>>>//               The default is to write the errors to a Ascii-file in the Data folder.
81309>>>>>//
81309>>>>>// $Rev History:
81309>>>>>//    2016-10-05  Module header created
81309>>>>>//****************************************************************************
81309>>>>>Use UI
81309>>>>>Use vWin32fh.pkg
81309>>>>>
81309>>>>>
81309>>>>>    Define CS_DatabaseUpdateFramework for " ***  The Database Update Framework (DUF) ***"
81309>>>>>
81309>>>>>Define CS_SuccessfulUpdate for "The database was updated successfully!"
81309>>>>>
81309>>>>>Class cDbUpdateLogFile is a cObject
81310>>>>>
81310>>>>>    Procedure Construct_Object
81312>>>>>        Forward Send Construct_Object
81314>>>>>
81314>>>>>        // Error handling:
81314>>>>>        Property tDbUpdateError[] paDbUpdateErrorArray
81315>>>>>        Property Integer piChannel -1
81316>>>>>
81316>>>>>        // This property is set by the cDbUpdateHandler object,
81316>>>>>        // when the update process starts.
81316>>>>>        Property DateTime pdtUpdateStart
81317>>>>>
81317>>>>>        // Gets set to False if the log contains data
81317>>>>>        Property Boolean pbEmptyLogFile True
81318>>>>>        
81318>>>>>        // Gets set to True after the error log header text
81318>>>>>        // has been written.
81318>>>>>        Property Boolean pbHeaderWritten False
81319>>>>>
81319>>>>>        // If all activities should be logged- not just errors.
81319>>>>>        Property Boolean pbVerboseState False
81320>>>>>
81320>>>>>        // File name for the error log where all errors
81320>>>>>        // after a run is written to (appended).
81320>>>>>        // It is saved in the Data folder.
81320>>>>>        Property String psLogTextFile   "DUFUpdateLog.txt"
81321>>>>>        Property String psEditorProgram "Notepad.exe"
81322>>>>>
81322>>>>>        Property Boolean pbUseDataTable False
81323>>>>>
81323>>>>>        // If true an error will be written to file immediately when
81323>>>>>        // it occurs. This can be handy if a large update generates a lots
81323>>>>>        // of errors and the application crasches before finished, thus
81323>>>>>        // the errors will not be written.
81323>>>>>        Property Boolean pbQuickWrite True
81324>>>>>    End_Procedure
81325>>>>>
81325>>>>>    Procedure End_Construct_Object
81327>>>>>        Forward Send End_Construct_Object
81329>>>>>
81329>>>>>    End_Procedure
81330>>>>>
81330>>>>>    Procedure LogError Number nVersion Integer iError String sErrorText Integer iErrorLine Boolean bError Boolean bShortFormatIn
81332>>>>>        tDbUpdateError[] DbUpdateErrorArray DbUpdateErrorArrayEmpty
81332>>>>>        tDbUpdateError[] DbUpdateErrorArray DbUpdateErrorArrayEmpty
81334>>>>>        Boolean bQuickWrite bShortFormat
81334>>>>>        Integer iSize
81334>>>>>        Handle hCurrentTable
81334>>>>>        Integer iCurrentField
81334>>>>>        
81334>>>>>        Move False to bShortFormat
81335>>>>>        If (num_arguments > 5) Begin
81337>>>>>            Move bShortFormatIn to bShortFormat
81338>>>>>        End
81338>>>>>>
81338>>>>>        // Only do once.
81338>>>>>        If (pbHeaderWritten(Self) = False) Begin
81340>>>>>            Send WriteHeaderData
81341>>>>>            Set pbHeaderWritten to True
81342>>>>>        End
81342>>>>>>
81342>>>>>
81342>>>>>        Get Private.phCurrentTable to hCurrentTable
81343>>>>>        Get Private.piCurrentField to iCurrentField
81344>>>>>
81344>>>>>        Get paDbUpdateErrorArray to DbUpdateErrorArray
81345>>>>>        Move (SizeOfArray(DbUpdateErrorArray)) to iSize
81346>>>>>        Move nVersion      to DbUpdateErrorArray[iSize].nUpdateVersion
81347>>>>>        Move iError        to DbUpdateErrorArray[iSize].iError
81348>>>>>        Move iErrorLine    to DbUpdateErrorArray[iSize].iErrorLine
81349>>>>>        Move True          to DbUpdateErrorArray[iSize].bError
81350>>>>>        Move sErrorText    to DbUpdateErrorArray[iSize].sErrorText
81351>>>>>        Move hCurrentTable to DbUpdateErrorArray[iSize].hTable
81352>>>>>        Move iCurrentField to DbUpdateErrorArray[iSize].iField  
81353>>>>>        Move bShortFormat  to DbUpdateErrorArray[iSize].bShortFormat
81354>>>>>
81354>>>>>        If (bError = False) Begin
81356>>>>>            Move False to DbUpdateErrorArray[iSize].bError
81357>>>>>        End
81357>>>>>>
81357>>>>>        Set paDbUpdateErrorArray to DbUpdateErrorArray
81358>>>>>
81358>>>>>        If (pbUseDataTable(Self) = True) Begin
81360>>>>>            If (pbQuickWrite(Self) = True) Begin
81362>>>>>                Send OnWriteRow_DataTable
81363>>>>>                // If we are writing error for error flush the
81363>>>>>                // error array when latest error has been written.
81363>>>>>                Set paDbUpdateErrorArray to DbUpdateErrorArrayEmpty
81364>>>>>            End
81364>>>>>>
81364>>>>>            Procedure_Return
81365>>>>>        End
81365>>>>>>
81365>>>>>        Else Begin
81366>>>>>            If (pbQuickWrite(Self) = True) Begin
81368>>>>>                Send WriteErrorLog
81369>>>>>                // Flush the error log array
81369>>>>>                Set paDbUpdateErrorArray to DbUpdateErrorArrayEmpty
81370>>>>>            End
81370>>>>>>
81370>>>>>        End
81370>>>>>>
81370>>>>>
81370>>>>>    End_Procedure
81371>>>>>
81371>>>>>    // Hook procedure for writing header text prior starting the update work to
81371>>>>>    // a database table. This does nothing by default.
81371>>>>>    // Don't forget to Open your "error log table" first (!) as all
81371>>>>>    // tables have been closed at this stage. Put anything
81371>>>>>    // you want to indicate that the update process is just started.
81371>>>>>    Procedure OnWriteHeader_DataTable DateTime dtUpdateStart
81373>>>>>        Delegate Send OnErrorWriteHeader_DataTable dtUpdateStart
81375>>>>>    End_Procedure
81376>>>>>
81376>>>>>    Procedure OnWriteRow_DataTable
81378>>>>>        tDbUpdateError[] DbUpdateErrorArray
81378>>>>>        tDbUpdateError[] DbUpdateErrorArray
81379>>>>>        Get paDbUpdateErrorArray to DbUpdateErrorArray
81380>>>>>        If (SizeOfArray(DbUpdateErrorArray) > 0) Begin
81382>>>>>            Delegate Send OnErrorWriteRow_DataTable DbUpdateErrorArray
81384>>>>>        End
81384>>>>>>
81384>>>>>    End_Procedure
81385>>>>>
81385>>>>>    Function psLogTextFileWithPath Returns String
81387>>>>>        String sPath sFileName sFullFileName
81387>>>>>        
81387>>>>>        Get psDataPathFirstPart to sPath
81388>>>>>        Get psLogTextFile to sFileName
81389>>>>>        Move (sPath + sFileName) to sFullFileName
81390>>>>>        Function_Return sFullFileName
81391>>>>>    End_Function                     
81392>>>>>    
81392>>>>>    Procedure WriteHeaderData
81394>>>>>        String sPath sFileName
81394>>>>>        Integer iCh iSize
81394>>>>>        Boolean bQuickWrite
81394>>>>>        DateTime dtUpdateStart
81394>>>>>
81394>>>>>        Move (CurrentDateTime()) to dtUpdateStart
81395>>>>>        If (pbUseDataTable(Self) = True) Begin
81397>>>>>            Send OnWriteHeader_DataTable dtUpdateStart
81398>>>>>            Procedure_Return
81399>>>>>        End
81399>>>>>>
81399>>>>>
81399>>>>>        Get piChannel to iCh
81400>>>>>        If (iCh < 0) Begin
81402>>>>>            Get Seq_New_Channel to iCh
81403>>>>>            If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
81405>>>>>                Error DFERR_PROGRAM "No free channel for writing output!"
81406>>>>>>
81406>>>>>                Procedure_Return
81407>>>>>            End
81407>>>>>>
81407>>>>>            Set piChannel to iCh
81408>>>>>        End
81408>>>>>>
81408>>>>>
81408>>>>>        Get psLogTextFileWithPath to sFileName
81409>>>>>        Get vWin32_APIFileSize sFileName to iSize
81410>>>>>        Get pbQuickWrite to bQuickWrite
81411>>>>>        
81411>>>>>        If (bQuickWrite = True) Begin
81413>>>>>            Append_Output channel iCh sFileName
81415>>>>>                If (bQuickWrite = True) Begin
81417>>>>>                    If (iSize = 0) Begin
81419>>>>>                        Writeln channel iCh CS_DatabaseUpdateFramework
81422>>>>>                        Set pbEmptyLogFile to False
81423>>>>>                    End
81423>>>>>>
81423>>>>>                    Writeln channel iCh
81425>>>>>                    Writeln channel iCh ("Database Update Started:      " + String(dtUpdateStart))
81428>>>>>                End
81428>>>>>>
81428>>>>>            Close_Output channel iCh
81430>>>>>        End
81430>>>>>>
81430>>>>>    End_Procedure
81431>>>>>
81431>>>>>    // Returns the first datapath found in the psDataPath property.
81431>>>>>    // The returned path always ends with a "\"
81431>>>>>    Function psDataPathFirstPart Returns String
81433>>>>>        String sDataPath
81433>>>>>        Integer iCount
81433>>>>>
81433>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
81434>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
81435>>>>>        If (iCount > 1) Begin
81437>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
81438>>>>>        End
81438>>>>>>
81438>>>>>        If (sDataPath <> "") Begin
81440>>>>>            Get vFolderFormat sDataPath to sDataPath
81441>>>>>        End
81441>>>>>>
81441>>>>>
81441>>>>>        Function_Return sDataPath
81442>>>>>    End_Function
81443>>>>>
81443>>>>>    // Called from the cDbUpdateHandler object after all updates have been done.
81443>>>>>    Procedure WriteErrorLog
81445>>>>>        tDbUpdateError[] aDbUpdateErrorArray
81445>>>>>        tDbUpdateError[] aDbUpdateErrorArray
81446>>>>>        String sPath sFileName sErrorNo sVersion sErrorText sText
81446>>>>>        Integer iCount iSize iCh iError iErrorLine iField
81446>>>>>        Boolean bUseDataTable bQuickWrite bError
81446>>>>>        DateTime dtUpdateStart dtUpdateEnd
81446>>>>>        TimeSpan tsElapsed
81446>>>>>        Number nVersion                                  
81446>>>>>        Handle hTable
81446>>>>>
81446>>>>>        If (pbHeaderWritten(Self) = False) Begin
81448>>>>>            Send WriteHeaderData
81449>>>>>            Set pbHeaderWritten to True
81450>>>>>        End
81450>>>>>>
81450>>>>>
81450>>>>>        Get pbUseDataTable to bUseDataTable
81451>>>>>        If (bUseDataTable = True) Begin
81453>>>>>            Send OnWriteRow_DataTable
81454>>>>>            Procedure_Return
81455>>>>>        End
81455>>>>>>
81455>>>>>
81455>>>>>        Get piChannel to iCh
81456>>>>>        If (iCh < 0) Begin
81458>>>>>            Get Seq_New_Channel to iCh
81459>>>>>            If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
81461>>>>>                Error DFERR_PROGRAM "No free channel for writing output!"
81462>>>>>>
81462>>>>>                Procedure_Return
81463>>>>>            End
81463>>>>>>
81463>>>>>            Set piChannel to iCh
81464>>>>>        End
81464>>>>>>
81464>>>>>
81464>>>>>        Get psLogTextFileWithPath to sFileName
81465>>>>>
81465>>>>>        Get paDbUpdateErrorArray to aDbUpdateErrorArray
81466>>>>>        Move (SizeOfArray(aDbUpdateErrorArray)) to iSize
81467>>>>>        Decrement iSize
81468>>>>>
81468>>>>>        Get pdtUpdateStart to dtUpdateStart
81469>>>>>        Move (CurrentDateTime()) to dtUpdateEnd
81470>>>>>        Move (dtUpdateEnd - dtUpdateStart) to tsElapsed
81471>>>>>        Get pbQuickWrite to bQuickWrite
81472>>>>>
81472>>>>>        Append_Output channel iCh sFileName
81474>>>>>        If (bQuickWrite = True and iSize < 0) Begin
81476>>>>>            Writeln channel iCh ("Database Update Finished:  " + String(dtUpdateEnd) * "Time Elapsed:" * String(tsElapsed))
81479>>>>>        End
81479>>>>>>
81479>>>>>        Else If (bQuickWrite = False) Begin
81482>>>>>            Writeln channel iCh
81484>>>>>            Writeln channel iCh ("Database Update Started:" * String(dtUpdateStart) * "and finished at:" * String(dtUpdateEnd) * "Time Elapsed:" * String(tsElapsed))
81487>>>>>        End   
81487>>>>>>
81487>>>>>        If (iSize >= 0) Begin
81489>>>>>            If (aDbUpdateErrorArray[0].bShortFormat = False) Begin
81491>>>>>                Writeln channel iCh "[Err No:] [pnVersionNumber:] [Status Text:]"
81494>>>>>            End
81494>>>>>>
81494>>>>>        End
81494>>>>>>
81494>>>>>
81494>>>>>        For iCount from 0 to iSize  
81500>>>>>>
81500>>>>>            Move aDbUpdateErrorArray[iCount].iError         to iError
81501>>>>>            Move aDbUpdateErrorArray[iCount].nUpdateVersion to nVersion
81502>>>>>            Move aDbUpdateErrorArray[iCount].sErrorText     to sErrorText
81503>>>>>            Move aDbUpdateErrorArray[iCount].iErrorLine     to iErrorLine  
81504>>>>>            Move aDbUpdateErrorArray[iCount].hTable         to hTable
81505>>>>>            Move aDbUpdateErrorArray[iCount].iField         to iField
81506>>>>>            
81506>>>>>            Get PadLeft (String(iError)) 8 to sErrorNo
81507>>>>>            If (aDbUpdateErrorArray[iCount].bError = True) Begin
81509>>>>>                Get PadLeft (String(nVersion)) (27 - Length(sErrorNo)) to sVersion
81510>>>>>                Move (sErrorNo + sVersion + "   " + sErrorText * "[ErrLine:" * String(iErrorLine) + "]" + "    (Table.Field:" * String(hTable) + "." + String(iField) + ")") to sText
81511>>>>>            End
81511>>>>>>
81511>>>>>            Else Begin
81512>>>>>                Get PadLeft (String(nVersion)) 27 to sVersion
81513>>>>>                Move (sVersion + "   " + sErrorText) to sText
81514>>>>>            End
81514>>>>>>
81514>>>>>            Writeln channel iCh sText
81517>>>>>            If (sText contains CS_SuccessfulUpdate) Begin
81519>>>>>                Writeln channel iCh
81521>>>>>            End
81521>>>>>>
81521>>>>>        Loop
81522>>>>>>
81522>>>>>        Close_Output channel iCh
81524>>>>>
81524>>>>>        Send Seq_Release_Channel iCh
81525>>>>>        Set piChannel to -1
81526>>>>>
81526>>>>>    End_Procedure
81527>>>>>
81527>>>>>    // The character to pad is optional. If nothing, spaces are used.
81527>>>>>    // Example:
81527>>>>>    // Move (PadLeft(45672,10,"0")) to sString -> "0000045672"
81527>>>>>    //  or:
81527>>>>>    // Move (PadLeft("Test",10)) to sString -> " Test"
81527>>>>>    // Courtesy of Pieter van Dieren. Collected from DAWs' Newsgroups.
81527>>>>>    Function PadLeft String sString Integer iLength String sOptChar Returns String
81529>>>>>        String sChar
81529>>>>>
81529>>>>>        If (Num_Arguments >= 3) Begin
81531>>>>>            Move sOptChar to sChar
81532>>>>>        End
81532>>>>>>
81532>>>>>        Else Begin
81533>>>>>            Move " " to sChar
81534>>>>>        End
81534>>>>>>
81534>>>>>
81534>>>>>        While (Length(sString) < iLength)
81538>>>>>            Move (sChar + sString) to sString
81539>>>>>        Loop
81540>>>>>>
81540>>>>>
81540>>>>>        Function_Return sString
81541>>>>>    End_Function
81542>>>>>
81542>>>>>    Procedure ShowErrorLog
81544>>>>>        String sPath sFileName
81544>>>>>        Boolean bExists
81544>>>>>
81544>>>>>        Get psLogTextFileWithPath to sFileName
81545>>>>>        Get vFilePathExists sFileName to bExists
81546>>>>>        If (bExists = True) Begin
81548>>>>>            // Runprogram Background (psEditorProgram(Self)) (sPath + sFileName)
81548>>>>>            Runprogram Shell Background sFileName
81549>>>>>        End
81549>>>>>>
81549>>>>>        Else Begin
81550>>>>>            Send Info_Box ("Could not locate the log file:\n\n" + String(sFileName))
81551>>>>>        End
81551>>>>>>
81551>>>>>    End_Procedure
81552>>>>>
81552>>>>>End_Class
81553>>>Use cDbUpdateVersion.pkg
Including file: cDbUpdateVersion.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateVersion.pkg)
81553>>>>>//****************************************************************************
81553>>>>>// $Module type: Class
81553>>>>>// $Module name: cDbUpdateVersion
81553>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
81553>>>>>// Web-site    : http://www.rdctools.com
81553>>>>>// Created     : 2016-09-27 @ 09:33 (Military date format: YY-MM-DD)
81553>>>>>//
81553>>>>>// Description : Child class to cDbUpdateHandler.
81553>>>>>//               Put an object of this class inside the global ghoDbUpdateHandler object.
81553>>>>>//               Set the pnVersionNumber to a version number.
81553>>>>>//               Inside the cDbUpdateVersion object put a "Use MyNewDbUpdatePackage.pkg"
81553>>>>>//               Add one cVersion object for each update of the database to the ghoDbUpdateHandler object.
81553>>>>>//               Place your code in the "OnUpdate" event that alters the database.
81553>>>>>//
81553>>>>>// $Rev History:
81553>>>>>//    2016-09-27  Module header created
81553>>>>>//****************************************************************************
81553>>>>>Use UI
81553>>>>>Use DUFLanguageConstants.inc
81553>>>>>Use cDbUpdateFunctionLibrary.pkg
Including file: cDbUpdateFunctionLibrary.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.pkg)
81553>>>>>>>//****************************************************************************
81553>>>>>>>// $Module type: Class
81553>>>>>>>// $Module name: cDbUpdateFunctionLibrary
81553>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
81553>>>>>>>// Web-site    : http://www.rdctools.com
81553>>>>>>>// Created     : 2014-09-05 @ 09:50 (Military date format: YY-MM-DD)
81553>>>>>>>//
81553>>>>>>>// Description : The class consists of a function library for database manipulations, aka make changes to a database.
81553>>>>>>>//               It has top level functions that uses the DataFlex db API, _but_ also specialized
81553>>>>>>>//               functions to make db changes to Sql databases with the DAW & Mertech drivers,
81553>>>>>>>//               with the help of Sql-scripts.
81553>>>>>>>//
81553>>>>>>>// $Rev History:
81553>>>>>>>//    2014-09-05  Module header created
81553>>>>>>>//
81553>>>>>>>//****************************************************************************
81553>>>>>>>Use cApplication.pkg
81553>>>>>>>Use seq_chnl.pkg
81553>>>>>>>Use GlobalFunctionsProcedures.pkg
81553>>>>>>>Use Datadict.pkg                        // Declaration of DF_FILE_SQL_TABLE_NAME
81553>>>>>>>Use DUFStatusPanel.pkg
81553>>>>>>>Use cDbUpdateFunctionLibrary.inc        // Various constant definitions, structs etc.
Including file: cDbUpdateFunctionLibrary.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.inc)
81553>>>>>>>>>Use DUFLanguageConstants.inc
81553>>>>>>>>>
81553>>>>>>>>>Register_Function paSQLQueryMessages Returns String[]
81553>>>>>>>>>Register_Procedure Set paSQLQueryMessages String[] aSQLQueryMessages
81553>>>>>>>>>
81553>>>>>>>>>// Global handle to a cDatabaseUpdateHandler object
81553>>>>>>>>>
81553>>>>>>>>>
81553>>>>>>>>>
81553>>>>>>>>>    Define CS_OEM_Txt for "OEM"
81553>>>>>>>>>
81553>>>>>>>>>    Define CS_ANSI_Txt for "ANSI"
81553>>>>>>>>>
81553>>>>>>>>>    Define CS_DFCONNID for "DFCONNID"
81553>>>>>>>>>
81553>>>>>>>>>    Define CS_SERVER for "SERVER"
81553>>>>>>>>>
81553>>>>>>>>>    Define CS_SERVER_NAME for "SERVER_NAME"
81553>>>>>>>>>
81553>>>>>>>>>    Define CS_DRIVER_NAME for "DRIVER_NAME"
81553>>>>>>>>>
81553>>>>>>>>>    Define CS_DATABASE_NAME for "DATABASE_NAME"
81553>>>>>>>>>
81553>>>>>>>>>    Define CS_SCHEMA_NAME for "SCHEMA_NAME"
81553>>>>>>>>>
81553>>>>>>>>>    Define CS_TABLE_CHARACTER_FORMAT for "TABLE_CHARACTER_FORMAT"
81553>>>>>>>>>
81553>>>>>>>>>    Define CS_USE_DUMMY_ZERO_DATE for "USE_DUMMY_ZERO_DATE"
81553>>>>>>>>>
81553>>>>>>>>>    Define CS_SYSTEM_FILE for "SYSTEM_FILE"
81553>>>>>>>>>
81553>>>>>>>>>    Define CS_RECNUM_TABLE for "RECNUM_TABLE"
81553>>>>>>>>>
81553>>>>>>>>>    Define CS_PRIMARY_INDEX for "PRIMARY_INDEX"
81553>>>>>>>>>
81553>>>>>>>>>    Define CS_INDEX_NUMBER for "INDEX_NUMBER"
81553>>>>>>>>>
81553>>>>>>>>>    Define CS_INDEX_NAME for "INDEX_NAME"
81553>>>>>>>>>
81553>>>>>>>>>    Define CS_DUFLowestAllowedDateValue for "01/01/1753"
81553>>>>>>>>>    Define CS_DUFLowestSQLDateValue     for "1753-01-01"
81553>>>>>>>>>
81553>>>>>>>>>
81553>>>>>>>>>    Global_Variable Handle ghoDbUpdateFunctionLibrary
81553>>>>>>>>>
81553>>>>>>>>>Struct tSQLScriptArray
81553>>>>>>>>>    Boolean bError
81553>>>>>>>>>    Boolean bArgumentSizeChanged
81553>>>>>>>>>    Integer iOrgArgumentSize
81553>>>>>>>>>    String[] sSQLScriptArray
81553>>>>>>>>>End_Struct
81553>>>>>>>>>
81553>>>>>>>>>Struct tSqlErrorArray
81553>>>>>>>>>    String[]  sSqlErrorArray
81553>>>>>>>>>    String[]  sSqlStatementArray
81553>>>>>>>>>    Integer[] iSqlErrorArray
81553>>>>>>>>>End_Struct
81553>>>>>>>>>
81553>>>>>>>>>Struct tSqlColumnNew
81553>>>>>>>>>    String  sBaseColumnName
81553>>>>>>>>>    String  sBaseTableName
81553>>>>>>>>>    String  sLabel
81553>>>>>>>>>    Integer iSqlType
81553>>>>>>>>>    Integer iSize
81553>>>>>>>>>    Integer iPrecision
81553>>>>>>>>>    Integer iDFType
81553>>>>>>>>>    Integer iDFNativeType
81553>>>>>>>>>End_Struct
81553>>>>>>>>>
81553>>>>>>>>>Struct tColumnType
81553>>>>>>>>>    String  sSQLType
81553>>>>>>>>>    Integer iSQLType
81553>>>>>>>>>    Boolean bCanEditSize
81553>>>>>>>>>    Integer iDefaultSize
81553>>>>>>>>>    Integer iMinSize
81553>>>>>>>>>    Number  nMaxSize
81553>>>>>>>>>    String  sDataFlexType
81553>>>>>>>>>    Integer iDataFlexType
81553>>>>>>>>>    Boolean bNativeDataType
81553>>>>>>>>>    String  sPrecision
81553>>>>>>>>>End_Struct
81553>>>>>>>>>
81553>>>>>>>>>// Used to store/retreive SQL keywords in a struct array.
81553>>>>>>>>>// Various SQL back-ends can have slightly different
81553>>>>>>>>>// keywords.
81553>>>>>>>>>Struct tSQLKeyWords
81553>>>>>>>>>    Integer iSQLWord
81553>>>>>>>>>    Integer iSQLDbType
81553>>>>>>>>>    String  sSQLPhrase // Can be more than one word.
81553>>>>>>>>>End_Struct
81553>>>>>>>>>
81553>>>>>>>>>Struct tSQLRelation
81553>>>>>>>>>    Integer iFileNumber
81553>>>>>>>>>    Integer iFieldNumber
81553>>>>>>>>>    String  sFileName
81553>>>>>>>>>    String  sFieldName
81553>>>>>>>>>End_Struct
81553>>>>>>>>>
81553>>>>>>>>>Struct tSQLLoggedInUser
81553>>>>>>>>>    String sUser
81553>>>>>>>>>    String sProgram
81553>>>>>>>>>End_Struct
81553>>>>>>>>>
81553>>>>>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
81553>>>>>>>>>
81553>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
81553>>>>>>>>>// They can have slightly different SQL keywords.
81553>>>>>>>>>// Note: If a new type is added to the list,
81553>>>>>>>>>//       the struct array xxx must be adjusted
81553>>>>>>>>>//       so that it is filled with all SQL
81553>>>>>>>>>//       keywords for that new type.
81553>>>>>>>>>Enum_List
81553>>>>>>>>>    Define EN_DbTypeMSSQL
81553>>>>>>>>>    Define EN_DbTypeMySQL
81553>>>>>>>>>    Define EN_DbTypeOracle
81553>>>>>>>>>    Define EN_DbTypeDB2
81553>>>>>>>>>    Define EN_DbTypePostgre
81553>>>>>>>>>    Define EN_DbTypeDataFlex // Embedded database.
81553>>>>>>>>>End_Enum_List
81553>>>>>>>>>
81553>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
81553>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
81553>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
81553>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
81553>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
81553>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
81553>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
81553>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
81553>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
81553>>>>>>>>>
81553>>>>>>>>>// We need to re-define the standard constants because several driver constants
81553>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
81553>>>>>>>>>// e.g. creating a column with embedded SQL (ESQL).
81553>>>>>>>>>Enum_List
81553>>>>>>>>>    Define DF_ASCII_DUF     for -1500 // All of these are DF_xxx constant values - 1500
81553>>>>>>>>>    Define DF_BCD_DUF       for -1499
81553>>>>>>>>>    Define DF_DATE_DUF      for -1498
81553>>>>>>>>>    Define DF_TEXT_DUF      for -1495
81553>>>>>>>>>    Define DF_BINARY_DUF    for -1494
81553>>>>>>>>>    Define DF_DATETIME_DUF  for -1493
81553>>>>>>>>>End_Enum_List
81553>>>>>>>>>
81553>>>>>>>>>    Define SQL_TEXT for (DF_TEXT + 1024)
81553>>>>>>>>>
81553>>>>>>>>>Define SQL_CHARBIT          for (DF_BINARY + 1024)
81553>>>>>>>>>Define SQL_LONGVARCHARBIT   for (DF_BINARY + 1025)
81553>>>>>>>>>Define SQL_VARCHARBIT       for (DF_BINARY + 1026)
81553>>>>>>>>>
81553>>>>>>>>>// These are not defined pre DF 18:
81553>>>>>>>>>    Define SQL_VARCHARMAX for (-201)
81553>>>>>>>>>    Define SQL_TYPE_MONEY for (-204)
81553>>>>>>>>>    Define SQL_TYPE_SMALLMONEY for (-205)
81553>>>>>>>>>    Define SQL_TYPE_SMALLDATETIME for (-206)
81553>>>>>>>>>
81553>>>>>>>>>Struct tSQLIntTableInfo
81553>>>>>>>>>    String sDriverName
81553>>>>>>>>>    String sServerName
81553>>>>>>>>>    String sDatabaseName
81553>>>>>>>>>    String sSchemaName
81553>>>>>>>>>    Boolean bRecnumTable
81553>>>>>>>>>    Integer iPrimaryIndex
81553>>>>>>>>>    Integer iGenerateRecordIdMethod  // RIM_NONE, RIM_IDENTITY_COLUMN,  RIM_DISPENSER_TABLE, RIM_EXTERNAL
81553>>>>>>>>>    String sTableCharacterFormat
81553>>>>>>>>>    Boolean bUseDummyZeroDate
81553>>>>>>>>>    Integer iFileDummyUpdateColumn // Init value to -1 if not exists (value can be in range 1 - number of columns)
81553>>>>>>>>>    Integer iFileBlockSize         // Init value to -1 if not exists
81553>>>>>>>>>    Integer iFileMaxRowsFetched    // Init value to -1 if not exists
81553>>>>>>>>>    Integer iFileGetRidAfterCreate // Init value to -1. But is boolean!
81553>>>>>>>>>    Integer iFileJitBinding        // Init value to -1. But is boolean!
81553>>>>>>>>>    String sRefindAfterSave        // Yes or No (how to handle?)
81553>>>>>>>>>    String sSystemFile             // Yes or No (how to handle?)
81553>>>>>>>>>    String sFileIndexTablespace
81553>>>>>>>>>    String sFileLongTablespace
81553>>>>>>>>>    String sTableTablespace
81553>>>>>>>>>End_Struct
81553>>>>>>>>>
81553>>>>>>>>>Struct tSQLIntColumnInfo
81553>>>>>>>>>    Integer iFieldNumber
81553>>>>>>>>>    Integer iFieldIndex
81553>>>>>>>>>    Integer iFieldRelatedFile
81553>>>>>>>>>    Integer iFieldRelatedField
81553>>>>>>>>>    Integer iIndexNumber
81553>>>>>>>>>    Integer iIndexNumberSegments
81553>>>>>>>>>    Integer iIndexSegmentField1
81553>>>>>>>>>    Integer iIndexSegmentField2
81553>>>>>>>>>    Integer iIndexSegmentFieldn
81553>>>>>>>>>    String  sIndexName
81553>>>>>>>>>End_Struct
81553>>>>>>>>>
81553>>>>>>>>>Struct tAPIColumn
81553>>>>>>>>>    Integer iFieldNumber
81553>>>>>>>>>    String  sFieldName
81553>>>>>>>>>    Integer iType
81553>>>>>>>>>    String  sType
81553>>>>>>>>>    Integer iLength
81553>>>>>>>>>    Integer iPrecision
81553>>>>>>>>>    Integer iOptions
81553>>>>>>>>>    Boolean bIsSQLType
81553>>>>>>>>>    Boolean bAllowNULL 
81553>>>>>>>>>    String  sDefaultValue
81553>>>>>>>>>    Boolean bShouldChange
81553>>>>>>>>>    Boolean bCancel
81553>>>>>>>>>    Boolean bError
81553>>>>>>>>>End_Struct
81553>>>>>>>>>
81553>>>>>>>>>Struct tAPIColumnCompare
81553>>>>>>>>>    Integer iFieldNumber
81553>>>>>>>>>    // FROM database:
81553>>>>>>>>>    Boolean bExistsFrom
81553>>>>>>>>>    String  sFieldNameFrom
81553>>>>>>>>>    Integer iTypeFrom
81553>>>>>>>>>    String  sTypeFrom
81553>>>>>>>>>    Integer iLengthFrom
81553>>>>>>>>>    Integer iPrecisionFrom
81553>>>>>>>>>    Integer iOptionsFrom
81553>>>>>>>>>    Boolean bIsSQLTypeFrom
81553>>>>>>>>>    Boolean bAllowNULLFrom
81553>>>>>>>>>    String  sDefaultValueFrom
81553>>>>>>>>>    Boolean bShouldChangeFrom
81553>>>>>>>>>    Boolean bCancelFrom
81553>>>>>>>>>    Boolean bErrorFrom 
81553>>>>>>>>>    // TO database:
81553>>>>>>>>>    Boolean bExistsTo
81553>>>>>>>>>    Integer iFieldNumberTo
81553>>>>>>>>>    String  sFieldNameTo
81553>>>>>>>>>    Integer iTypeTo
81553>>>>>>>>>    String  sTypeTo
81553>>>>>>>>>    Integer iLengthTo
81553>>>>>>>>>    Integer iPrecisionTo
81553>>>>>>>>>    Integer iOptionsTo
81553>>>>>>>>>    Boolean bIsSQLTypeTo
81553>>>>>>>>>    Boolean bAllowNULLTo
81553>>>>>>>>>    String  sDefaultValueTo
81553>>>>>>>>>    Boolean bShouldChangeTo
81553>>>>>>>>>    Boolean bCancelTo
81553>>>>>>>>>    Boolean bErrorTo
81553>>>>>>>>>End_Struct
81553>>>>>>>>>
81553>>>>>>>>>Struct tAPIRelation
81553>>>>>>>>>    Handle  hTableFrom
81553>>>>>>>>>    Integer iColumnFrom
81553>>>>>>>>>    Handle  hTableTo
81553>>>>>>>>>    Integer iColumnTo
81553>>>>>>>>>    String  sLogicalNameFrom
81553>>>>>>>>>    String  sLogicalNameTo
81553>>>>>>>>>    String  sFieldNameFrom
81553>>>>>>>>>    String  sFieldNameTo
81553>>>>>>>>>    Boolean bShouldChange
81553>>>>>>>>>    Boolean bCancel
81553>>>>>>>>>    Boolean bError
81553>>>>>>>>>End_Struct
81553>>>>>>>>>
81553>>>>>>>>>Struct tAPIRelationCompare
81553>>>>>>>>>    // Common:
81553>>>>>>>>>    Handle  hTableFrom
81553>>>>>>>>>    Integer iColumnFrom
81553>>>>>>>>>    Handle  hTableTo
81553>>>>>>>>>    Integer iColumnTo
81553>>>>>>>>>    // FROM database:
81553>>>>>>>>>    Boolean bExistsFrom
81553>>>>>>>>>    String  sLogicalNameFrom_From
81553>>>>>>>>>    String  sLogicalNameTo_From
81553>>>>>>>>>    String  sFieldNameFrom_From
81553>>>>>>>>>    String  sFieldNameTo_From
81553>>>>>>>>>    Boolean bShouldChange_From
81553>>>>>>>>>    Boolean bCancel_From
81553>>>>>>>>>    Boolean bError_From
81553>>>>>>>>>    // TO database:
81553>>>>>>>>>    Boolean bExistsTo
81553>>>>>>>>>    String  sLogicalNameFrom_To
81553>>>>>>>>>    String  sLogicalNameTo_To
81553>>>>>>>>>    String  sFieldNameFrom_To
81553>>>>>>>>>    String  sFieldNameTo_To
81553>>>>>>>>>    Boolean bShouldChange_To
81553>>>>>>>>>    Boolean bCancel_To
81553>>>>>>>>>    Boolean bError_To
81553>>>>>>>>>End_Struct
81553>>>>>>>>>
81553>>>>>>>>>Struct tAPIIndexSegment
81553>>>>>>>>>    Integer iFieldNumber
81553>>>>>>>>>    String  sFieldName
81553>>>>>>>>>    Boolean bUppercase
81553>>>>>>>>>    Boolean bAscending
81553>>>>>>>>>    Boolean bShouldChange
81553>>>>>>>>>    Boolean bCancel
81553>>>>>>>>>    Boolean bError
81553>>>>>>>>>End_Struct
81553>>>>>>>>>
81553>>>>>>>>>Struct tAPIIndex
81553>>>>>>>>>    Integer iIndexNumber
81553>>>>>>>>>    Integer iPrimaryIndex
81553>>>>>>>>>    String  sSQLIndexName
81553>>>>>>>>>    Integer iSQLIndexType
81553>>>>>>>>>    Boolean bIsSQLClustered
81553>>>>>>>>>    Boolean bIsSQLPrimaryKey
81553>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
81553>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
81553>>>>>>>>>    Boolean bShouldChange
81553>>>>>>>>>    Boolean bCancel
81553>>>>>>>>>    Boolean bError
81553>>>>>>>>>End_Struct
81553>>>>>>>>>
81553>>>>>>>>>Struct tAPIIndexCompare
81553>>>>>>>>>    // Common:
81553>>>>>>>>>    Integer iIndexNumber
81553>>>>>>>>>    // FROM database:
81553>>>>>>>>>    Boolean bExistsFrom
81553>>>>>>>>>    Integer iPrimaryIndexFrom
81553>>>>>>>>>    String  sSQLIndexNameFrom
81553>>>>>>>>>    Integer iSQLIndexTypeFrom
81553>>>>>>>>>    Boolean bIsSQLClusteredFrom
81553>>>>>>>>>    Boolean bIsSQLPrimaryKeyFrom
81553>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
81553>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
81553>>>>>>>>>    Boolean bShouldChangeFrom
81553>>>>>>>>>    Boolean bCancelFrom
81553>>>>>>>>>    Boolean bErrorFrom
81553>>>>>>>>>    // TO database:
81553>>>>>>>>>    Boolean bExistsTo
81553>>>>>>>>>    Integer iPrimaryIndexTo
81553>>>>>>>>>    String  sSQLIndexNameTo
81553>>>>>>>>>    Integer iSQLIndexTypeTo
81553>>>>>>>>>    Boolean bIsSQLClusteredTo
81553>>>>>>>>>    Boolean bIsSQLPrimaryKeyTo
81553>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
81553>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
81553>>>>>>>>>    Boolean bShouldChangeTo
81553>>>>>>>>>    Boolean bCancelTo
81553>>>>>>>>>    Boolean bErrorTo
81553>>>>>>>>>End_Struct
81553>>>>>>>>>
81553>>>>>>>>>Struct tAPITableNameInfo
81553>>>>>>>>>    Integer iTableNumber
81553>>>>>>>>>    String  sRootName
81553>>>>>>>>>    String  sLogicalName
81553>>>>>>>>>    String  sDisplayName
81553>>>>>>>>>    String  sDriverID
81553>>>>>>>>>    Boolean bIsAlias
81553>>>>>>>>>    Boolean bIsSQL  
81553>>>>>>>>>    Boolean bIsSystemFile
81553>>>>>>>>>    Boolean bShouldChange
81553>>>>>>>>>    Boolean bCancel
81553>>>>>>>>>    Boolean bError
81553>>>>>>>>>End_Struct
81553>>>>>>>>>
81553>>>>>>>>>Struct tAPITableNameInfoCompare
81553>>>>>>>>>    Integer iTableNumber
81553>>>>>>>>>    // FROM
81553>>>>>>>>>    Boolean bExistsFrom
81553>>>>>>>>>    String  sRootNameFrom
81553>>>>>>>>>    String  sLogicalNameFrom
81553>>>>>>>>>    String  sDisplayNameFrom
81553>>>>>>>>>    String  sDriverIDFrom
81553>>>>>>>>>    Boolean bIsAliasFrom
81553>>>>>>>>>    Boolean bIsSQLFrom
81553>>>>>>>>>    Boolean bIsSystemFileFrom
81553>>>>>>>>>    // TO database:
81553>>>>>>>>>    Boolean bExistsTo
81553>>>>>>>>>    String  sRootNameTo
81553>>>>>>>>>    String  sLogicalNameTo
81553>>>>>>>>>    String  sDisplayNameTo
81553>>>>>>>>>    String  sDriverIDTo
81553>>>>>>>>>    Boolean bIsAliasTo
81553>>>>>>>>>    Boolean bIsSQLTo
81553>>>>>>>>>    Boolean bIsSystemFileTo // *** Implement!
81553>>>>>>>>>    Boolean bShouldChange
81553>>>>>>>>>    Boolean bCancel
81553>>>>>>>>>    Boolean bError
81553>>>>>>>>>End_Struct
81553>>>>>>>>>
81553>>>>>>>>>Struct tAPITable
81553>>>>>>>>>    Handle hTable
81553>>>>>>>>>    Boolean bFromTable
81553>>>>>>>>>    Boolean bToTable
81553>>>>>>>>>    tAPITableNameInfo ApiTableInfo
81553>>>>>>>>>    tAPITableNameInfo ApiTableInfo
81553>>>>>>>>>    tAPIColumn[]      aApiColumns
81553>>>>>>>>>    tAPIColumn[]      aApiColumns
81553>>>>>>>>>    tAPIIndex[]       aApiIndexes
81553>>>>>>>>>    tAPIIndex[]       aApiIndexes
81553>>>>>>>>>    tAPIRelation[]    aApiRelations
81553>>>>>>>>>    tAPIRelation[]    aApiRelations
81553>>>>>>>>>    Boolean bShouldChange
81553>>>>>>>>>    Boolean bCancel
81553>>>>>>>>>    Boolean bError
81553>>>>>>>>>End_Struct
81553>>>>>>>>>
81553>>>>>>>>>Struct tAPITableCompare
81553>>>>>>>>>    Handle hTable
81553>>>>>>>>>    // FROM database:
81553>>>>>>>>>    Boolean bExistsFrom
81553>>>>>>>>>    // TO database:
81553>>>>>>>>>    Boolean bExistsTo
81553>>>>>>>>>    // Both:
81553>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
81553>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
81553>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
81553>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
81553>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
81553>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
81553>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
81553>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
81553>>>>>>>>>    Boolean bShouldChange   // Not implemented yet (!)
81553>>>>>>>>>    Boolean bCancel         // User cancel
81553>>>>>>>>>    Boolean bError          // Error occured while collecting data
81553>>>>>>>>>End_Struct
81553>>>>>>>>>
81553>>>>>>>>>
81553>>>>>>>>>Struct tAPITableBooleans  
81553>>>>>>>>>    Boolean bApiTableUpdateAuto
81553>>>>>>>>>    Boolean bCompareDate_DateTime
81553>>>>>>>>>    Boolean bCompareIndexAscending
81553>>>>>>>>>    Boolean bCompareIndexUppercase
81553>>>>>>>>>    Boolean bCompareFilelistUppercase
81553>>>>>>>>>End_Struct
81553>>>>>>>>>
81553>>>>>>>>>Define C_tAPIColumn_None for 0
81553>>>>>>>>>Define C_tAPIColumn_Identity for 1
81553>>>>>>>>>
81553>>>>>>>>>// SQL Key-Word Constants:
81553>>>>>>>>>// Used by the _SqlFindKeyWord function to return a proper keyword depending on the backend SQL,
81553>>>>>>>>>// i.e. one of the EN_DbTypeXXX members from the Enum_list above.
81553>>>>>>>>>// E.g. the CI_SQLAlterTable is only defined once, but the _SqlFindKeyWord function can return
81553>>>>>>>>>// different wording content depending on the EN_xxx value also passed to the function.
81553>>>>>>>>>Enum_List
81553>>>>>>>>>    Define CI_SQLAlterDatabase         //for "ALTER DATABASE"          
81553>>>>>>>>>    Define CI_SQLSingle_User           //for "SINGLE_USER"
81553>>>>>>>>>    Define CI_SQLMulti_User            //for "USER_USER"
81553>>>>>>>>>    Define CI_SQLRollback              //for "ROLLBACK"
81553>>>>>>>>>    Define CI_SQLIMMEDIATE             //for "IMMEDIATE"
81553>>>>>>>>>    Define CI_SQLAlterTable            //for "ALTER TABLE"
81553>>>>>>>>>    Define CI_SQLAlterColumn           //for "ALTER COLUMN"
81553>>>>>>>>>    Define CI_SQLRenameColumn          //for "RENAME COLUMN"
81553>>>>>>>>>    Define CI_SQLColumn                //for "COLUMN"
81553>>>>>>>>>    Define CI_SQLSelect                //for "SELECT"
81553>>>>>>>>>    Define CI_SQLWhere                 //for "WHERE"
81553>>>>>>>>>    Define CI_SQLInfoSchema            //for "INFORMATION_SCHEMA.COLUMNS"
81553>>>>>>>>>    Define CI_SQLTable_Name            //for "TABLE_NAME"
81553>>>>>>>>>    Define CI_SQLTable                 //for "TABLE"
81553>>>>>>>>>    Define CI_SQLSys                   //for "SYS"
81553>>>>>>>>>    Define CI_SQLSp_Help               //for "SP_HELP"
81553>>>>>>>>>    Define CI_SQLFrom                  //for "FROM"
81553>>>>>>>>>    Define CI_SQLAdd                   //for "ADD"
81553>>>>>>>>>    Define CI_SQLDropColumn            //for "DROP"
81553>>>>>>>>>    Define CI_SQLCreateDatabase        //for "CREATE DATABASE"
81553>>>>>>>>>    Define CI_SQLDatabaseCollation     //for "COLLATE"
81553>>>>>>>>>    Define CI_SQLCreateTable           //for "CREATE TABLE"
81553>>>>>>>>>    Define CI_SQLDropTable             //for "DROP TABLE"
81553>>>>>>>>>    Define CI_SQLCreateView            //for "CREATE VIEW"
81553>>>>>>>>>    Define CI_SQLRenameTable           //for "RENAME TABLE"
81553>>>>>>>>>//    Define CI_SQLSelectFromWhereName   //for "SELECT name from [master].[dbo].[sysdatabases] where name"
81553>>>>>>>>>    Define CI_SQLDropView              //for "DROP VIEW"
81553>>>>>>>>>    Define CI_SQLSetNoCountOn          //for "SET NOCOUNT ON"
81553>>>>>>>>>    Define CI_SQLTo                    //for "TO"
81553>>>>>>>>>    Define CI_SQLGO                    //for "GO"
81553>>>>>>>>>    Define CI_SQLUse                   //for "USE"
81553>>>>>>>>>    Define CI_SQLDBO                   //for "DBO"
81553>>>>>>>>>
81553>>>>>>>>>    Define CI_SQLName                  //for "NAME"
81553>>>>>>>>>    Define CI_SQLMaster                //for "MASTER"
81553>>>>>>>>>    Define CI_SQLDatabases             //for "DATABASES"
81553>>>>>>>>>    Define CI_SQLSysIndexes            //for "SYS.INDEXES"
81553>>>>>>>>>    Define CI_SQLObjectID              //for "OBJECT_ID"
81553>>>>>>>>>    Define CI_SQLID                    //for "ID"
81553>>>>>>>>>    Define CI_SQLAND                   //for "AND"
81553>>>>>>>>>    Define CI_SQLUpdate                //for "UPDATE"
81553>>>>>>>>>    Define CI_SQLSet                   //for "SET"
81553>>>>>>>>>    Define CI_SQLWith                  //for "WITH"
81553>>>>>>>>>    Define CI_SQLNotNull               //for "NOT NULL"
81553>>>>>>>>>End_Enum_List
81553>>>>>>>>>
81553>>>>>>>Use cDbUpdateFunctionLibrary_Mixin.pkg  // Properties used by the cDbUpdateFunctionLibrary class.
Including file: cDbUpdateFunctionLibrary_Mixin.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary_Mixin.pkg)
81553>>>>>>>>>// *** Mixin Class For the cDbUpdateFunctionLibrary Class ***
81553>>>>>>>>>//
81553>>>>>>>>>// We need to create a mixin class for the library.
81553>>>>>>>>>// Why? Because we import the library to the cDbUpdateVersion class; that imports
81553>>>>>>>>>// all messages (functions & procedures) but all Properties are "lost", aka not imported by
81553>>>>>>>>>// the Import_Class_Protocol command. So we need a way to create our properties somewhere else...
81553>>>>>>>>>// Note: This class should _not_ have a construct_object defined.
81553>>>>>>>>>//
81553>>>>>>>>>Use VdfBase.pkg
81553>>>>>>>>>Use WinUuid.pkg
Including file: WinUuid.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\WinUuid.pkg)
81553>>>>>>>>>>>External_Function WinAPI_UuidCreate "UuidCreate" Rpcrt4.dll Address Uuid Returns Integer
81554>>>>>>>>>>>External_Function WinAPI_UuidToString  "UuidToStringA" Rpcrt4.dll Address aUuid Address lpUUIDString Returns Integer
81555>>>>>>>>>>>External_Function WinAPI_UuidCreateSequential "UuidCreateSequential" Rpcrt4.dll Address aUuid Returns Integer
81556>>>>>>>>>>>External_Function WinAPI_RpcStringFree "RpcStringFreeA" Rpcrt4.dll Address pStr Returns Integer
81557>>>>>>>>>>>
81557>>>>>>>>>>>// RandomHexUUID:
81557>>>>>>>>>>>
81557>>>>>>>>>>>// Returns a 'random' Universally Unique Identifier string as a 32 digit hex number.
81557>>>>>>>>>>>Function RandomHexUUID Global Returns String
81559>>>>>>>>>>>    Address pUUID pUUIDStr
81559>>>>>>>>>>>    Integer iRetval iOffset iChar
81559>>>>>>>>>>>    String sUUID sKey
81559>>>>>>>>>>>    
81559>>>>>>>>>>>    Move (Alloc(16)) to pUUID
81560>>>>>>>>>>>    
81560>>>>>>>>>>>    Move (WinAPI_UuidCreate (pUUID)) to iRetval
81561>>>>>>>>>>>    
81561>>>>>>>>>>>    If (iRetval = 0) Begin
81563>>>>>>>>>>>        Move 0 to pUUIDStr
81564>>>>>>>>>>>        
81564>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
81565>>>>>>>>>>>        If (iRetval = 0) Begin
81567>>>>>>>>>>>            Move pUUIDStr to sUUID
81568>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
81569>>>>>>>>>>> 
81569>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
81570>>>>>>>>>>>        End
81570>>>>>>>>>>>>
81570>>>>>>>>>>>    End
81570>>>>>>>>>>>>
81570>>>>>>>>>>>    
81570>>>>>>>>>>>    Move (Free(pUUID)) to iRetval 
81571>>>>>>>>>>>    
81571>>>>>>>>>>>    Function_Return sUUID
81572>>>>>>>>>>>End_Function
81573>>>>>>>>>>>
81573>>>>>>>>>>>
81573>>>>>>>>>>>// SeqHexUUID:
81573>>>>>>>>>>>
81573>>>>>>>>>>>// Returns a sequential Universally Unique Identifier string as a 32 digit hex number.
81573>>>>>>>>>>>Function SeqHexUUID Global Returns String    
81575>>>>>>>>>>>    Address pUUID pUUIDStr
81575>>>>>>>>>>>    Integer iRetval iOffset iChar
81575>>>>>>>>>>>    String sUUID sKey
81575>>>>>>>>>>>    
81575>>>>>>>>>>>    Move (Alloc(16)) to pUUID
81576>>>>>>>>>>>    
81576>>>>>>>>>>>    Move (WinAPI_UuidCreateSequential (pUUID)) to iRetval
81577>>>>>>>>>>>    
81577>>>>>>>>>>>    If (iRetval = 0) Begin
81579>>>>>>>>>>>        Move 0 to pUUIDStr
81580>>>>>>>>>>>        
81580>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
81581>>>>>>>>>>>        If (iRetval = 0) Begin
81583>>>>>>>>>>>            Move pUUIDStr to sUUID
81584>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
81585>>>>>>>>>>> 
81585>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
81586>>>>>>>>>>>        End
81586>>>>>>>>>>>>
81586>>>>>>>>>>>    End
81586>>>>>>>>>>>>
81586>>>>>>>>>>>    
81586>>>>>>>>>>>    Move (Free(pUUID)) to iRetval 
81587>>>>>>>>>>>    
81587>>>>>>>>>>>    Function_Return sUUID
81588>>>>>>>>>>>End_Function
81589>>>>>>>>>Use cli.pkg
81589>>>>>>>>>Use sql.pkg
81589>>>>>>>>>Use MSSqldrv.pkg
Including file: MSSqldrv.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\MSSqldrv.pkg)
81589>>>>>>>>>>>//*****************************************************************************
81589>>>>>>>>>>>//*** MSSQLDRV.PKG                                                          ***
81589>>>>>>>>>>>//***                                                                       ***
81589>>>>>>>>>>>//*** Author: Ben Weijers                                                   ***
81589>>>>>>>>>>>//***         Data Access Nederland                                         ***
81589>>>>>>>>>>>//***         29 June 1998                                                  ***
81589>>>>>>>>>>>//***                                                                       ***
81589>>>>>>>>>>>//***                                                                       ***
81589>>>>>>>>>>>//*** Purpose:                                                              ***
81589>>>>>>>>>>>//***   Package that declares MS SQL driver constants and functions.        ***
81589>>>>>>>>>>>//****                                                                      ***
81589>>>>>>>>>>>//***   This package can be used by developers who want to add Data Access  ***
81589>>>>>>>>>>>//***   MS SQL Client specific code to a DataFlex application.              ***
81589>>>>>>>>>>>//***   Updated:  June 4th 2012 (Current CK build: 5.1.0.96)                ***
81589>>>>>>>>>>>//***             Changed EnumerateServers function to use the highest      ***
81589>>>>>>>>>>>//***             available SQL Server client driver.                       ***
81589>>>>>>>>>>>//***             Moved SQL Server client constants from cli.pkg to         ***
81589>>>>>>>>>>>//***             mssqldrv.pkg                                              ***
81589>>>>>>>>>>>//***   Updated:  November 6th 2013 (Current CK build: 6.0.0.19)            ***
81589>>>>>>>>>>>//***             Added constants for SQL Server specific native types      ***
81589>>>>>>>>>>>//***             ( var...(max) types, money types, datetime types)         ***
81589>>>>>>>>>>>//*****************************************************************************
81589>>>>>>>>>>>
81589>>>>>>>>>>>Use Cli.pkg
81589>>>>>>>>>>>Use SQL.pkg
81589>>>>>>>>>>>
81589>>>>>>>>>>>//*** Driver Indentification
81589>>>>>>>>>>>
81589>>>>>>>>>>>//*** Error number constants
81589>>>>>>>>>>>
81589>>>>>>>>>>>
81589>>>>>>>>>>>//*** Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
81589>>>>>>>>>>>
81589>>>>>>>>>>>
81589>>>>>>>>>>>
81589>>>>>>>>>>>
81589>>>>>>>>>>>
81589>>>>>>>>>>>
81589>>>>>>>>>>>// SQL Server spcific types. 
81589>>>>>>>>>>>Define SQL_SS_TIMESTAMPOFFSET   for   (-155) //SQL server datetimeoffset type */
81589>>>>>>>>>>>Define SQL_SS_TIME2             for   (-154) //SQL server time type */
81589>>>>>>>>>>>Define SQL_SS_XML               for   (-152) //SQL server xml type */
81589>>>>>>>>>>>Define SQL_SS_VARIANT           for   (-150) //SQL server variant type */
81589>>>>>>>>>>>
81589>>>>>>>>>>>// SQL Server spcific types. 
81589>>>>>>>>>>>Define SQL_TYPE_TIMESTAMP2      for   (-200) //SQL server datetime2 type */
81589>>>>>>>>>>>Define SQL_VARCHARMAX           for   (-201) //SQL server varchar(max) type */
81589>>>>>>>>>>>Define SQL_WVARCHARMAX          for   (-202) //SQL server wvarchar(max) type */
81589>>>>>>>>>>>Define SQL_VARBINARYMAX         for   (-203) //SQL server varbinary(max) type */
81589>>>>>>>>>>>Define SQL_TYPE_MONEY           for   (-204) //SQL server money type */
81589>>>>>>>>>>>Define SQL_TYPE_SMALLMONEY      for   (-205) //SQL server smallmoney type */
81589>>>>>>>>>>>Define SQL_TYPE_SMALLDATETIME   for   (-206) //SQL server smalldatetype type */
81589>>>>>>>>>>>
81589>>>>>>>>>>>
81589>>>>>>>>>>>//*****************************************************************************
81589>>>>>>>>>>>//*** MSSQL_SetConstraint <FileNum> <ConstraintText>                        ***
81589>>>>>>>>>>>//***                                                                       ***
81589>>>>>>>>>>>//***   Setup a constraint for a file.                                      ***
81589>>>>>>>>>>>//*****************************************************************************
81589>>>>>>>>>>>
81589>>>>>>>>>>>
81589>>>>>>>>>>>
81589>>>>>>>>>>>Class cMSSQLHandler Is A cCLIHandler
81590>>>>>>>>>>>
81590>>>>>>>>>>>    Procedure Construct_Object
81592>>>>>>>>>>>        Forward Send Construct_Object
81594>>>>>>>>>>>
81594>>>>>>>>>>>        Set psDriverID To MSSQLDRV_ID
81595>>>>>>>>>>>    End_Procedure // Construct_Object
81596>>>>>>>>>>>
81596>>>>>>>>>>>
81596>>>>>>>>>>>
81596>>>>>>>>>>>    //***
81596>>>>>>>>>>>    //*** Function: ExtractList
81596>>>>>>>>>>>    //*** Purpose : Extract the list from the out connect string.
81596>>>>>>>>>>>    //***
81596>>>>>>>>>>>
81596>>>>>>>>>>>    Function ExtractList String sOutConnStr Integer hoStore Returns Integer
81598>>>>>>>>>>>        Local String  sItem
81598>>>>>>>>>>>        Local Integer iStart
81598>>>>>>>>>>>        Local Integer iEnd
81598>>>>>>>>>>>
81598>>>>>>>>>>>        If (hoStore = 0) ;            Move Current_object To hoStore
81601>>>>>>>>>>>
81601>>>>>>>>>>>        Send Delete_Data To hoStore
81602>>>>>>>>>>>        Move (Pos("{", sOutConnStr)) To iStart
81603>>>>>>>>>>>        While (iStart > 0)
81607>>>>>>>>>>>            Move (Right(sOutConnStr, Length(sOutConnStr) - iStart)) To sOutConnStr
81608>>>>>>>>>>>            If (Left(sOutConnStr, 1) = "}") ;                Move 0 To iStart
81611>>>>>>>>>>>            Else Begin
81612>>>>>>>>>>>                Move (Pos(",", sOutConnStr)) To iStart
81613>>>>>>>>>>>                Move (Pos("}", sOutConnStr)) To iEnd
81614>>>>>>>>>>>                If ((iStart = 0) Or (iEnd < iStart)) ;                    Move iEnd To iStart
81617>>>>>>>>>>>
81617>>>>>>>>>>>                If (iStart > 0) ;                    Set Value Of hoStore Item (Item_Count(Current_Object)) To (Left(sOutConnStr, iStart - 1))
81620>>>>>>>>>>>
81620>>>>>>>>>>>                If (iStart = iEnd) ;                    Move 0 To iStart
81623>>>>>>>>>>>            End
81623>>>>>>>>>>>>
81623>>>>>>>>>>>        Loop
81624>>>>>>>>>>>>
81624>>>>>>>>>>>
81624>>>>>>>>>>>        Function_Return (Item_Count(hoStore))
81625>>>>>>>>>>>    End_Procedure // ExtractList
81626>>>>>>>>>>>
81626>>>>>>>>>>>
81626>>>>>>>>>>>
81626>>>>>>>>>>>    //***
81626>>>>>>>>>>>    //*** Function: BrowseConnect
81626>>>>>>>>>>>    //*** Purpose : Call the driver's browse connect function
81626>>>>>>>>>>>    //***
81626>>>>>>>>>>>
81626>>>>>>>>>>>    Function BrowseConnect String sInConnStr Returns String
81628>>>>>>>>>>>        Local String  sDriver
81628>>>>>>>>>>>        Local String  sOutConnStr
81628>>>>>>>>>>>        Local Integer iArg
81628>>>>>>>>>>>        Local Integer iRetval
81628>>>>>>>>>>>
81628>>>>>>>>>>>        Get psDriverID To sDriver
81629>>>>>>>>>>>        If (sDriver <> "") Begin
81631>>>>>>>>>>>            Move (Repeat(" ", 8192)) To sOutConnStr
81632>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
81637>>>>>>>>>>>        End
81637>>>>>>>>>>>>
81637>>>>>>>>>>>
81637>>>>>>>>>>>        Function_Return sOutConnStr
81638>>>>>>>>>>>    End_Function// BrowseConnect
81639>>>>>>>>>>>
81639>>>>>>>>>>>
81639>>>>>>>>>>>    Function BrowseConnectLocal String sInConnStr Returns String
81641>>>>>>>>>>>        Local String  sDriver
81641>>>>>>>>>>>        Local String  sOutConnStr
81641>>>>>>>>>>>        Local Integer iArg
81641>>>>>>>>>>>        Local Integer iRetval
81641>>>>>>>>>>>        
81641>>>>>>>>>>>        Move 1 to iArg // Browses only local
81642>>>>>>>>>>>
81642>>>>>>>>>>>        Get psDriverID to sDriver
81643>>>>>>>>>>>        If (sDriver <> "") Begin
81645>>>>>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
81646>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
81651>>>>>>>>>>>        End
81651>>>>>>>>>>>>
81651>>>>>>>>>>>
81651>>>>>>>>>>>        Function_Return sOutConnStr
81652>>>>>>>>>>>    End_Function// BrowseConnect
81653>>>>>>>>>>>
81653>>>>>>>>>>>
81653>>>>>>>>>>>    Function DriverIndex String sDriver Returns Integer
81655>>>>>>>>>>>    
81655>>>>>>>>>>>        Local String  sCurrentDriver
81655>>>>>>>>>>>        Local Integer iNumberOfDrivers iDriver iCount
81655>>>>>>>>>>>    
81655>>>>>>>>>>>        Move 0 to iDriver
81656>>>>>>>>>>>    
81656>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
81659>>>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
81665>>>>>>>>>>>>
81665>>>>>>>>>>>    
81665>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
81668>>>>>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriver) ) Begin
81670>>>>>>>>>>>                Move iCount to iDriver
81671>>>>>>>>>>>            End
81671>>>>>>>>>>>>
81671>>>>>>>>>>>        Loop
81672>>>>>>>>>>>>
81672>>>>>>>>>>>    
81672>>>>>>>>>>>        Function_Return iDriver
81673>>>>>>>>>>>    
81673>>>>>>>>>>>    End_Function 
81674>>>>>>>>>>>
81674>>>>>>>>>>>    Function EnumerateServersNetworkOrLocal Integer iNetworkLocal  Returns Integer
81676>>>>>>>>>>>        
81676>>>>>>>>>>>        Local String  sServerList
81676>>>>>>>>>>>        Local Integer iNumServers
81676>>>>>>>>>>>        Local Integer iDriver
81676>>>>>>>>>>>        Local Integer iClientVersion
81676>>>>>>>>>>>        Local String  sDriver
81676>>>>>>>>>>>        
81676>>>>>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
81677>>>>>>>>>>>
81677>>>>>>>>>>>        If (iDriver) Begin
81679>>>>>>>>>>>                
81679>>>>>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
81682>>>>>>>>>>>            
81682>>>>>>>>>>>            Case Begin
81682>>>>>>>>>>>    
81682>>>>>>>>>>>                Case (iClientVersion = SQLSERVER2016CLIENT)
81684>>>>>>>>>>>                    Move SQLSERVER2016DRVRSTR to sDriver
81685>>>>>>>>>>>                    Case Break
81686>>>>>>>>>>>    
81686>>>>>>>>>>>                Case (iClientVersion = SQLSERVER2014CLIENT)
81689>>>>>>>>>>>                    Move SQLSERVER2014DRVRSTR to sDriver
81690>>>>>>>>>>>                    Case Break
81691>>>>>>>>>>>            
81691>>>>>>>>>>>                Case (iClientVersion = SQLSERVER2012CLIENT)
81694>>>>>>>>>>>                    Move SQLSERVER2012DRVRSTR to sDriver
81695>>>>>>>>>>>                    Case Break
81696>>>>>>>>>>>    
81696>>>>>>>>>>>                Case (iClientVersion = SQLSERVER2008CLIENT)
81699>>>>>>>>>>>                    Move SQLSERVER2008DRVRSTR to sDriver
81700>>>>>>>>>>>                    Case Break
81701>>>>>>>>>>>    
81701>>>>>>>>>>>                Case (iClientVersion = SQLSERVER2005CLIENT)
81704>>>>>>>>>>>                    Move SQLSERVER2005DRVRSTR to sDriver
81705>>>>>>>>>>>                    Case Break
81706>>>>>>>>>>>            
81706>>>>>>>>>>>                Case (iClientVersion = SQLSERVER2000CLIENT)
81709>>>>>>>>>>>                    Move SQLSERVER2000DRVRSTR to sDriver
81710>>>>>>>>>>>                    Case Break
81711>>>>>>>>>>>            
81711>>>>>>>>>>>                Case Else
81711>>>>>>>>>>>                    Move SQLSERVER2000DRVRSTR to sDriver
81712>>>>>>>>>>>            
81712>>>>>>>>>>>            Case End
81712>>>>>>>>>>>    
81712>>>>>>>>>>>            Move ("DRIVER={" + sDriver + "};") to sDriver
81713>>>>>>>>>>>            If (iNetworkLocal = 0) Begin
81715>>>>>>>>>>>                Get BrowseConnect sDriver to sServerList
81716>>>>>>>>>>>            End
81716>>>>>>>>>>>>
81716>>>>>>>>>>>            Else Begin
81717>>>>>>>>>>>                Get BrowseConnectLocal sDriver to sServerList
81718>>>>>>>>>>>            End
81718>>>>>>>>>>>>
81718>>>>>>>>>>>            Get ExtractList sServerList Current_object to iNumServers
81719>>>>>>>>>>>        End
81719>>>>>>>>>>>>
81719>>>>>>>>>>>        
81719>>>>>>>>>>>        Function_Return iNumServers
81720>>>>>>>>>>>        
81720>>>>>>>>>>>    End_Function
81721>>>>>>>>>>>
81721>>>>>>>>>>>    //***
81721>>>>>>>>>>>    //*** Procedure: EnumerateServers
81721>>>>>>>>>>>    //*** Purpose  : Enumerate the available SQL Server database servers
81721>>>>>>>>>>>    //***            This function will return all SQL Server instances on the network. 
81721>>>>>>>>>>>    //***            This may take a long time. 
81721>>>>>>>>>>>    //***            To enumerate only local SQL Server instances use EnumerateServersLocal 
81721>>>>>>>>>>>    Function EnumerateServers Returns Integer
81723>>>>>>>>>>>
81723>>>>>>>>>>>        Local Integer iNumServers
81723>>>>>>>>>>>        Local Integer iNetworkLocal
81723>>>>>>>>>>>        
81723>>>>>>>>>>>        Move 0 to iNetworkLocal // 0 = enumerate network servers
81724>>>>>>>>>>>        
81724>>>>>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
81725>>>>>>>>>>>        
81725>>>>>>>>>>>        Function_Return iNumServers
81726>>>>>>>>>>>        
81726>>>>>>>>>>>    End_Function
81727>>>>>>>>>>>
81727>>>>>>>>>>>
81727>>>>>>>>>>>    //***
81727>>>>>>>>>>>    //*** Procedure: EnumerateServersLocal
81727>>>>>>>>>>>    //*** Purpose  : Enumerate the available SQL Server database servers
81727>>>>>>>>>>>    //***            This function will return only return SQL Server instance on the local machine
81727>>>>>>>>>>>    //***            To enumerate all SQL Server instances in a network use EnumerateServers
81727>>>>>>>>>>>    Function EnumerateServersLocal Returns Integer
81729>>>>>>>>>>>
81729>>>>>>>>>>>        Local Integer iNumServers
81729>>>>>>>>>>>        Local Integer iNetworkLocal
81729>>>>>>>>>>>        
81729>>>>>>>>>>>        Move 1 to iNetworkLocal // 1 = enumerate local servers
81730>>>>>>>>>>>        
81730>>>>>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
81731>>>>>>>>>>>        
81731>>>>>>>>>>>        Function_Return iNumServers
81732>>>>>>>>>>>        
81732>>>>>>>>>>>    End_Function
81733>>>>>>>>>>>
81733>>>>>>>>>>>    
81733>>>>>>>>>>>
81733>>>>>>>>>>>    //***
81733>>>>>>>>>>>    //*** Function: EnumerateDatabases
81733>>>>>>>>>>>    //*** Purpose : Enumerate database in a given server.
81733>>>>>>>>>>>    //***
81733>>>>>>>>>>>
81733>>>>>>>>>>>    Function EnumerateDatabases String sServer String sUser String sPassWord Returns Integer
81735>>>>>>>>>>>        Local Integer hoSQL
81735>>>>>>>>>>>        Local String  sConnect
81735>>>>>>>>>>>        Local String  sDatabase
81735>>>>>>>>>>>        Local Integer hdbc
81735>>>>>>>>>>>        Local Integer hstmt
81735>>>>>>>>>>>        Local Integer iFetchResult
81735>>>>>>>>>>>
81735>>>>>>>>>>>        If (Num_Arguments < 3) ;            Move "" To sPassWord
81738>>>>>>>>>>>        If (Num_Arguments < 2) ;            Move "" To sUser
81741>>>>>>>>>>>
81741>>>>>>>>>>>        If (sUser <> "") ;            Move ("SERVER=" + Trim(sServer) + ";UID=" + Trim(sUser) + ";PWD=" + Trim(sPassword) + ";") To sConnect
81744>>>>>>>>>>>        Else ;            Move ("SERVER=" + Trim(sServer) + ";Trusted_Connection=yes") To sConnect
81746>>>>>>>>>>>
81746>>>>>>>>>>>        Object oEnumDBSQLmanager Is A cSQLHandleManager
81748>>>>>>>>>>>            Move Current_Object To hoSQL
81749>>>>>>>>>>>        End_Object // oEnumDBSQLManager
81750>>>>>>>>>>>
81750>>>>>>>>>>>        If (hoSQL <> 0) Begin
81752>>>>>>>>>>>            Get SQLConnect Of hoSQL "MSSQLDRV" sConnect To hdbc
81753>>>>>>>>>>>            If (hdbc <> 0) Begin
81755>>>>>>>>>>>                Get SQLOpen Of hdbc To hstmt
81756>>>>>>>>>>>                If (hstmt <> 0) Begin
81758>>>>>>>>>>>                    //*** We could do a direct select on the sysdatabases table but we use
81758>>>>>>>>>>>                    //*** the stored procedure sp_database instead. SQL Server recommends this
81758>>>>>>>>>>>                    //*** approach in case meta data might change, the stored procedure will
81758>>>>>>>>>>>                    //*** stay the same.
81758>>>>>>>>>>>                    Send SQLSetProcedureName To hstmt "sp_databases"
81759>>>>>>>>>>>                    Send SQLCall To hstmt
81760>>>>>>>>>>>                    Repeat
81760>>>>>>>>>>>>
81760>>>>>>>>>>>                        Get SQLFetch Of hstmt To iFetchResult
81761>>>>>>>>>>>                        If (iFetchResult <> 0) Begin
81763>>>>>>>>>>>                            Get SQLColumnValue Of hstmt 1 To sDatabase
81764>>>>>>>>>>>                            Set Value Item (Item_Count(Current_Object)) To sDatabase
81765>>>>>>>>>>>                        End
81765>>>>>>>>>>>>
81765>>>>>>>>>>>                    Until (iFetchResult = 0)
81767>>>>>>>>>>>
81767>>>>>>>>>>>                    Send SQLClose To hstmt
81768>>>>>>>>>>>                End
81768>>>>>>>>>>>>
81768>>>>>>>>>>>                Send SQLDisconnect To hdbc
81769>>>>>>>>>>>            End
81769>>>>>>>>>>>>
81769>>>>>>>>>>>        End
81769>>>>>>>>>>>>
81769>>>>>>>>>>>        Send Destroy_Object To hoSQL
81770>>>>>>>>>>>
81770>>>>>>>>>>>        Function_return (Item_Count(Current_Object))
81771>>>>>>>>>>>    End_Function // EnumerateDatabases
81772>>>>>>>>>>>
81772>>>>>>>>>>>
81772>>>>>>>>>>>    Function SqlServerClientVersionName Integer iClientVersion  Returns String
81774>>>>>>>>>>>        
81774>>>>>>>>>>>        Local String  sSqlServerClientVersionName
81774>>>>>>>>>>>        
81774>>>>>>>>>>>            
81774>>>>>>>>>>>        Case Begin
81774>>>>>>>>>>>
81774>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
81776>>>>>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
81777>>>>>>>>>>>                Case Break
81778>>>>>>>>>>>
81778>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
81781>>>>>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
81782>>>>>>>>>>>                Case Break
81783>>>>>>>>>>>        
81783>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
81786>>>>>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
81787>>>>>>>>>>>                Case Break
81788>>>>>>>>>>>
81788>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
81791>>>>>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
81792>>>>>>>>>>>                Case Break
81793>>>>>>>>>>>
81793>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
81796>>>>>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
81797>>>>>>>>>>>                Case Break
81798>>>>>>>>>>>        
81798>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
81801>>>>>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
81802>>>>>>>>>>>                Case Break
81803>>>>>>>>>>>        
81803>>>>>>>>>>>            Case Else
81803>>>>>>>>>>>                Move SQLSERVERUNKNOWNCLIENTNAME to sSqlServerClientVersionName
81804>>>>>>>>>>>        
81804>>>>>>>>>>>        Case End
81804>>>>>>>>>>>    
81804>>>>>>>>>>>        
81804>>>>>>>>>>>        Function_Return sSqlServerClientVersionName
81805>>>>>>>>>>>        
81805>>>>>>>>>>>    End_Function
81806>>>>>>>>>>>
81806>>>>>>>>>>>
81806>>>>>>>>>>>End_Class // cMSSQLHandler
81807>>>>>>>>>>>
81807>>>>>>>>>Use db2_drv.pkg
Including file: db2_drv.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\db2_drv.pkg)
81807>>>>>>>>>>>//*****************************************************************************
81807>>>>>>>>>>>//*** DB2_DRV.PKG                                                           ***
81807>>>>>>>>>>>//***                                                                       ***
81807>>>>>>>>>>>//*** Author: Ben Weijers                                                   ***
81807>>>>>>>>>>>//***         Data Access Nederland                                         ***
81807>>>>>>>>>>>//***         30 July 1998                                                  ***
81807>>>>>>>>>>>//***                                                                       ***
81807>>>>>>>>>>>//*** Last updated: May 2, 2007                                                                      ***
81807>>>>>>>>>>>//***                                                                       ***
81807>>>>>>>>>>>//*** Purpose:                                                              ***
81807>>>>>>>>>>>//***   Package that declares DB2 driver constants and functions.           ***
81807>>>>>>>>>>>//****                                                                      ***
81807>>>>>>>>>>>//***   This package can be used by developers who want to add DB2 driver   ***
81807>>>>>>>>>>>//***   specific code to a DataFlex application.                            ***
81807>>>>>>>>>>>//*****************************************************************************
81807>>>>>>>>>>>
81807>>>>>>>>>>>Use Cli.pkg
81807>>>>>>>>>>>
81807>>>>>>>>>>>//*** Driver attributes
81807>>>>>>>>>>>
81807>>>>>>>>>>>
81807>>>>>>>>>>>//*** Driver Indentification
81807>>>>>>>>>>>
81807>>>>>>>>>>>//*** Error number constants
81807>>>>>>>>>>>
81807>>>>>>>>>>>//*** Call driver function identifiers
81807>>>>>>>>>>>
81807>>>>>>>>>>>// DB2 specific data types
81807>>>>>>>>>>>Define SQL_CLOB           for   (-99)  
81807>>>>>>>>>>>Define SQL_BLOB           for   (-98)  
81807>>>>>>>>>>>Define SQL_XML            for   (-370) 
81807>>>>>>>>>>>// DB2 Graphic types are Unicode types
81807>>>>>>>>>>>Define SQL_GRAPHIC        for   (-95)  
81807>>>>>>>>>>>Define SQL_VARGRAPHIC     for   (-96)  
81807>>>>>>>>>>>Define SQL_LONGVARGRAPHIC for   (-97)  
81807>>>>>>>>>>>Define SQL_DBCLOB         for   (-350) 
81807>>>>>>>>>>>
81807>>>>>>>>>>>
81807>>>>>>>>>>>//*** Extra DB2 commands
81807>>>>>>>>>>>
81807>>>>>>>>>>>
81807>>>>>>>>>>>//*****************************************************************************
81807>>>>>>>>>>>//*** DB2_CheckTrigger <NewState>                                           ***
81807>>>>>>>>>>>//***                                                                       ***
81807>>>>>>>>>>>//*** This command will set the trigger check at open on or off.            ***
81807>>>>>>>>>>>//*****************************************************************************
81807>>>>>>>>>>>
81807>>>>>>>>>>>
81807>>>>>>>>>>>
81807>>>>>>>>>>>//*****************************************************************************
81807>>>>>>>>>>>//*** DB2_SetConstraint <FileNum> <ConstraintText>                          ***
81807>>>>>>>>>>>//***                                                                       ***
81807>>>>>>>>>>>//***   Setup a constraint for a file.                                      ***
81807>>>>>>>>>>>//*****************************************************************************
81807>>>>>>>>>>>
81807>>>>>>>>>>>
81807>>>>>>>>>>>
81807>>>>>>>>>>>Class cDB2Handler Is A cCLIHandler
81808>>>>>>>>>>>
81808>>>>>>>>>>>    Procedure Construct_Object
81810>>>>>>>>>>>        Forward Send Construct_Object
81812>>>>>>>>>>>
81812>>>>>>>>>>>        Set psDriverID To DB2_DRV_ID
81813>>>>>>>>>>>    End_Procedure // Construct_Object
81814>>>>>>>>>>>
81814>>>>>>>>>>>
81814>>>>>>>>>>>
81814>>>>>>>>>>>    //***
81814>>>>>>>>>>>    //*** Procedure: SeedDataSources
81814>>>>>>>>>>>    //*** Purpose  : Reset the datasource list to the beginning
81814>>>>>>>>>>>    //***
81814>>>>>>>>>>>
81814>>>>>>>>>>>    Procedure SeedDataSources
81816>>>>>>>>>>>        Local String  sDriver
81816>>>>>>>>>>>        Local String  sVoid
81816>>>>>>>>>>>        Local Integer iRetval
81816>>>>>>>>>>>
81816>>>>>>>>>>>        Get psDriverID To sDriver
81817>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid SQL_FETCH_ALL Result iRetval
81824>>>>>>>>>>>    End_Procedure // SeedDataSources
81825>>>>>>>>>>>
81825>>>>>>>>>>>
81825>>>>>>>>>>>
81825>>>>>>>>>>>    //***
81825>>>>>>>>>>>    //*** Function: DataSources
81825>>>>>>>>>>>    //*** Purpose : Call the driver's data sources function
81825>>>>>>>>>>>    //***
81825>>>>>>>>>>>
81825>>>>>>>>>>>    Function DataSources Returns String
81827>>>>>>>>>>>        Local String  sDriver
81827>>>>>>>>>>>        Local String  sDataSource
81827>>>>>>>>>>>        Local String  sDescription
81827>>>>>>>>>>>        Local Integer iLength
81827>>>>>>>>>>>        Local Integer iRetval
81827>>>>>>>>>>>
81827>>>>>>>>>>>        Get psDriverID To sDriver
81828>>>>>>>>>>>        If (sDriver <> "") Begin
81830>>>>>>>>>>>            Move 8192 To iLength
81831>>>>>>>>>>>            Move (Repeat(" ", iLength)) To sDataSource
81832>>>>>>>>>>>            Move (Repeat(" ", iLength)) To sDescription
81833>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
81838>>>>>>>>>>>        End
81838>>>>>>>>>>>>
81838>>>>>>>>>>>
81838>>>>>>>>>>>        If (sDataSource <> "" Or sDescription <> "") ;            Function_Return (sDataSource + "," +  sDescription)
81841>>>>>>>>>>>        Else ;            Function_Return ""
81843>>>>>>>>>>>    End_Function// DataSources
81844>>>>>>>>>>>
81844>>>>>>>>>>>End_Class // cODBCHandler
81845>>>>>>>>>>>
81845>>>>>>>>>>>
81845>>>>>>>>>Use odbc_drv.pkg
Including file: odbc_drv.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\odbc_drv.pkg)
81845>>>>>>>>>>>//*****************************************************************************
81845>>>>>>>>>>>//*** ODBC_DRV.PKG                                                          ***
81845>>>>>>>>>>>//***                                                                       ***
81845>>>>>>>>>>>//*** Author: Ben Weijers                                                   ***
81845>>>>>>>>>>>//***         Data Access Nederland                                         ***
81845>>>>>>>>>>>//***         3 February 1998                                               ***
81845>>>>>>>>>>>//***                                                                       ***
81845>>>>>>>>>>>//*** Last updated: May 2, 2007                                                                      ***
81845>>>>>>>>>>>//***                                                                       ***
81845>>>>>>>>>>>//*** Purpose:                                                              ***
81845>>>>>>>>>>>//***   Package that declares ODBC driver constants and functions.          ***
81845>>>>>>>>>>>//****                                                                      ***
81845>>>>>>>>>>>//***   This package can be used by developers who want to add Data Access  ***
81845>>>>>>>>>>>//***   ODBC Client specific code to a DataFlex application.                ***
81845>>>>>>>>>>>//*****************************************************************************
81845>>>>>>>>>>>
81845>>>>>>>>>>>Use Cli.pkg
81845>>>>>>>>>>>
81845>>>>>>>>>>>//*** Driver Indentification
81845>>>>>>>>>>>
81845>>>>>>>>>>>//*** Error number constants
81845>>>>>>>>>>>
81845>>>>>>>>>>>//*** Call driver function identifiers
81845>>>>>>>>>>>
81845>>>>>>>>>>>//*** Extra ODBC commands
81845>>>>>>>>>>>
81845>>>>>>>>>>>
81845>>>>>>>>>>>//*****************************************************************************
81845>>>>>>>>>>>//*** ODBCManage                                                            ***
81845>>>>>>>>>>>//***                                                                       ***
81845>>>>>>>>>>>//*** Start the ODBC manager.                                               ***
81845>>>>>>>>>>>//*****************************************************************************
81845>>>>>>>>>>>
81845>>>>>>>>>>>
81845>>>>>>>>>>>
81845>>>>>>>>>>>//*****************************************************************************
81845>>>>>>>>>>>//*** ODBCNumberOfDataSources To <NumDSN>                                   ***
81845>>>>>>>>>>>//***                                                                       ***
81845>>>>>>>>>>>//*** Returns the number of data sources.                                   ***
81845>>>>>>>>>>>//*****************************************************************************
81845>>>>>>>>>>>
81845>>>>>>>>>>>
81845>>>>>>>>>>>//*****************************************************************************
81845>>>>>>>>>>>//*** ODBCDSNName <DSNNumber> To <DSNName>                                  ***
81845>>>>>>>>>>>//***                                                                       ***
81845>>>>>>>>>>>//*** Returns the name of the data source.                                  ***
81845>>>>>>>>>>>//*****************************************************************************
81845>>>>>>>>>>>
81845>>>>>>>>>>>
81845>>>>>>>>>>>//*****************************************************************************
81845>>>>>>>>>>>//*** ODBCEnumerateTables <DSNName> To <TableNum>                           ***
81845>>>>>>>>>>>//***                                                                       ***
81845>>>>>>>>>>>//*** Builds internal table array and returns the number of tables in the   ***
81845>>>>>>>>>>>//*** DSN.                                                                  ***
81845>>>>>>>>>>>//*****************************************************************************
81845>>>>>>>>>>>
81845>>>>>>>>>>>
81845>>>>>>>>>>>//*****************************************************************************
81845>>>>>>>>>>>//*** ODBCTableName <TableNum> To <TableName>                               ***
81845>>>>>>>>>>>//***                                                                       ***
81845>>>>>>>>>>>//*** Returns the name of the table.                                        ***
81845>>>>>>>>>>>//*****************************************************************************
81845>>>>>>>>>>>
81845>>>>>>>>>>>
81845>>>>>>>>>>>//*****************************************************************************
81845>>>>>>>>>>>//*** ODBCSchemaName <TableNum> To <SchemaName>                             ***
81845>>>>>>>>>>>//***                                                                       ***
81845>>>>>>>>>>>//*** Returns the schema name of the table.                                 ***
81845>>>>>>>>>>>//*****************************************************************************
81845>>>>>>>>>>>
81845>>>>>>>>>>>
81845>>>>>>>>>>>//*****************************************************************************
81845>>>>>>>>>>>//*** ODBCNumberOfFields <DSNName> <TableName> To <NumDSN>                  ***
81845>>>>>>>>>>>//***                                                                       ***
81845>>>>>>>>>>>//*** Returns the number of fields.                                         ***
81845>>>>>>>>>>>//*****************************************************************************
81845>>>>>>>>>>>
81845>>>>>>>>>>>
81845>>>>>>>>>>>//*****************************************************************************
81845>>>>>>>>>>>//*** ODBCFieldName <FieldNumber> To <FieldName>                            ***
81845>>>>>>>>>>>//***                                                                       ***
81845>>>>>>>>>>>//*** Returns the name of the field.                                  ***
81845>>>>>>>>>>>//*****************************************************************************
81845>>>>>>>>>>>
81845>>>>>>>>>>>
81845>>>>>>>>>>>
81845>>>>>>>>>>>//*****************************************************************************
81845>>>>>>>>>>>//*** ODBC_SetConstraint <FileNum> <ConstraintText>                         ***
81845>>>>>>>>>>>//***                                                                       ***
81845>>>>>>>>>>>//***   Setup a constraint for a file.                                      ***
81845>>>>>>>>>>>//*****************************************************************************
81845>>>>>>>>>>>
81845>>>>>>>>>>>
81845>>>>>>>>>>>
81845>>>>>>>>>>>Class cODBCHandler Is A cCLIHandler
81846>>>>>>>>>>>
81846>>>>>>>>>>>    Procedure Construct_Object
81848>>>>>>>>>>>        Forward Send Construct_Object
81850>>>>>>>>>>>
81850>>>>>>>>>>>        Set psDriverID To ODBC_DRV_ID
81851>>>>>>>>>>>    End_Procedure // Construct_Object
81852>>>>>>>>>>>
81852>>>>>>>>>>>
81852>>>>>>>>>>>
81852>>>>>>>>>>>    //***
81852>>>>>>>>>>>    //*** Procedure Set: DataSourceType
81852>>>>>>>>>>>    //*** Purpose      : Setup the type of data sources returned by the datasources function
81852>>>>>>>>>>>    //***
81852>>>>>>>>>>>
81852>>>>>>>>>>>    Procedure Set DataSourceType Integer iNewType
81854>>>>>>>>>>>        Local String  sDriver
81854>>>>>>>>>>>        Local String  sVoid
81854>>>>>>>>>>>        Local Integer iRetval
81854>>>>>>>>>>>
81854>>>>>>>>>>>        Get psDriverID To sDriver
81855>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid iNewType Result iRetval
81862>>>>>>>>>>>    End_Procedure // Set DataSourceType
81863>>>>>>>>>>>
81863>>>>>>>>>>>
81863>>>>>>>>>>>
81863>>>>>>>>>>>    //***
81863>>>>>>>>>>>    //*** Function: DataSources
81863>>>>>>>>>>>    //*** Purpose : Call the driver's data sources function
81863>>>>>>>>>>>    //***
81863>>>>>>>>>>>
81863>>>>>>>>>>>    Function DataSources Returns String
81865>>>>>>>>>>>        Local String  sDriver
81865>>>>>>>>>>>        Local String  sDataSource
81865>>>>>>>>>>>        Local String  sDescription
81865>>>>>>>>>>>        Local Integer iLength
81865>>>>>>>>>>>        Local Integer iRetval
81865>>>>>>>>>>>
81865>>>>>>>>>>>        Get psDriverID To sDriver
81866>>>>>>>>>>>        If (sDriver <> "") Begin
81868>>>>>>>>>>>            Move 8192 To iLength
81869>>>>>>>>>>>            Move (Repeat(" ", iLength)) To sDataSource
81870>>>>>>>>>>>            Move (Repeat(" ", iLength)) To sDescription
81871>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
81876>>>>>>>>>>>        End
81876>>>>>>>>>>>>
81876>>>>>>>>>>>
81876>>>>>>>>>>>        If (sDataSource <> "" Or sDescription <> "") ;            Function_Return (sDataSource + "," +  sDescription)
81879>>>>>>>>>>>        Else ;            Function_Return ""
81881>>>>>>>>>>>    End_Function// DataSources
81882>>>>>>>>>>>
81882>>>>>>>>>>>End_Class // cODBCHandler
81883>>>>>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (C:\Program Files (x86)\DataFlex 19.0\Pkg\DFBTRDRV.PKG)
81883>>>>>>>>>>>//****************************************************************************
81883>>>>>>>>>>>//
81883>>>>>>>>>>>// $File name  : DFBTRDRV.PKG
81883>>>>>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
81883>>>>>>>>>>>// Notice      : This package contains constants and commands, used to call
81883>>>>>>>>>>>//               specific functions in the DFBTRDRV.
81883>>>>>>>>>>>// $Author(s)  : Eddy Kleinjan
81883>>>>>>>>>>>//
81883>>>>>>>>>>>// $System     : DataFlex Connectivity Kit for Pervasive.SQL
81883>>>>>>>>>>>// Created     : 01-07-97 @ 12:00:00
81883>>>>>>>>>>>//
81883>>>>>>>>>>>// Changed     : 04-04-2001.
81883>>>>>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.145
81883>>>>>>>>>>>//
81883>>>>>>>>>>>// Changed     : June 6, 2001
81883>>>>>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.148
81883>>>>>>>>>>>//
81883>>>>>>>>>>>//               Added DFBTR_DDF_OWNER command.
81883>>>>>>>>>>>//
81883>>>>>>>>>>>// Changed     : June 12, 2001
81883>>>>>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.149
81883>>>>>>>>>>>//
81883>>>>>>>>>>>//               Added DF_FIELD_IS_NULL and DF_FIELD_NULL_ALLOWED attributes
81883>>>>>>>>>>>//
81883>>>>>>>>>>>// Changed     : August 4, 2004
81883>>>>>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 3.0.0.1
81883>>>>>>>>>>>//
81883>>>>>>>>>>>//               Added cDfbtrdrvHandler class.
81883>>>>>>>>>>>//               New functions in this class:
81883>>>>>>>>>>>//                  Function CKRevision Returns String
81883>>>>>>>>>>>//                  Function CkUsesUri Returns Integer
81883>>>>>>>>>>>//                  Function PSQLRequesterVersionInfo Integer iFileNum Returns String
81883>>>>>>>>>>>//                  Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
81883>>>>>>>>>>>//                  Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
81883>>>>>>>>>>>//
81883>>>>>>>>>>>// Changed     : September 30, 2005
81883>>>>>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 3.0.0.14
81883>>>>>>>>>>>//
81883>>>>>>>>>>>//               Bugfix: Prevent compiler errors when no (df)error.pkg is used
81883>>>>>>>>>>>//****************************************************************************
81883>>>>>>>>>>>Use Ui
81883>>>>>>>>>>>//
81883>>>>>>>>>>>// Driver Indentification
81883>>>>>>>>>>>//
81883>>>>>>>>>>>
81883>>>>>>>>>>>//*** Driver attributes
81883>>>>>>>>>>>//
81883>>>>>>>>>>>// Call_Driver functions ID's
81883>>>>>>>>>>>//
81883>>>>>>>>>>>//
81883>>>>>>>>>>>// DFBTRFN_CONVERT_FILE options
81883>>>>>>>>>>>//
81883>>>>>>>>>>>
81883>>>>>>>>>>>//
81883>>>>>>>>>>>// DFBTRFN_SET_OWNER options
81883>>>>>>>>>>>//
81883>>>>>>>>>>>
81883>>>>>>>>>>>//
81883>>>>>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
81883>>>>>>>>>>>//
81883>>>>>>>>>>>
81883>>>>>>>>>>>
81883>>>>>>>>>>>//
81883>>>>>>>>>>>// Command to create all vars which may be needed
81883>>>>>>>>>>>// in other commands.
81883>>>>>>>>>>>//
81883>>>>>>>>>>>
81883>>>>>>>>>>>
81883>>>>>>>>>>>
81883>>>>>>>>>>>//
81883>>>>>>>>>>>// Command to set the owner of a Btrieve file.
81883>>>>>>>>>>>// File must have been opened.
81883>>>>>>>>>>>// Filenumber needs to be passed.
81883>>>>>>>>>>>// To clear set the owner to "".
81883>>>>>>>>>>>// Examples:
81883>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
81883>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
81883>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
81883>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
81883>>>>>>>>>>>// To clear:
81883>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
81883>>>>>>>>>>>//
81883>>>>>>>>>>>
81883>>>>>>>>>>>
81883>>>>>>>>>>>
81883>>>>>>>>>>>//
81883>>>>>>>>>>>// Command to parse DFBTR_SET_OWNVER
81883>>>>>>>>>>>// options.
81883>>>>>>>>>>>//
81883>>>>>>>>>>>
81883>>>>>>>>>>>
81883>>>>>>>>>>>
81883>>>>>>>>>>>//
81883>>>>>>>>>>>// Command to parse for Callback
81883>>>>>>>>>>>//
81883>>>>>>>>>>>
81883>>>>>>>>>>>
81883>>>>>>>>>>>
81883>>>>>>>>>>>//
81883>>>>>>>>>>>// Command to clear the owner of a Btrieve file.
81883>>>>>>>>>>>// File must have been opened.
81883>>>>>>>>>>>// Filenumber needs to be passed.
81883>>>>>>>>>>>// Examples:
81883>>>>>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
81883>>>>>>>>>>>//
81883>>>>>>>>>>>
81883>>>>>>>>>>>
81883>>>>>>>>>>>
81883>>>>>>>>>>>//
81883>>>>>>>>>>>// Command to add a owner name to the internal list of ownernames
81883>>>>>>>>>>>// which will be tries when opening files.
81883>>>>>>>>>>>//
81883>>>>>>>>>>>
81883>>>>>>>>>>>
81883>>>>>>>>>>>
81883>>>>>>>>>>>//
81883>>>>>>>>>>>// Command to remove all owners from the internal list of ownernames
81883>>>>>>>>>>>//
81883>>>>>>>>>>>
81883>>>>>>>>>>>
81883>>>>>>>>>>>//
81883>>>>>>>>>>>// Command to set the owner name to be used when opening the DDF files.
81883>>>>>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
81883>>>>>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
81883>>>>>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
81883>>>>>>>>>>>//
81883>>>>>>>>>>>
81883>>>>>>>>>>>//
81883>>>>>>>>>>>// Command to change the transaction type.
81883>>>>>>>>>>>// Valid types are:
81883>>>>>>>>>>>//     DFBTRTT_NONE
81883>>>>>>>>>>>//     DFBTRTT_EXCLUSIVE
81883>>>>>>>>>>>//     DFBTRTT_CONCURRENT
81883>>>>>>>>>>>//
81883>>>>>>>>>>>//
81883>>>>>>>>>>>
81883>>>>>>>>>>>
81883>>>>>>>>>>>
81883>>>>>>>>>>>//
81883>>>>>>>>>>>// Command to get the current transaction type.
81883>>>>>>>>>>>//
81883>>>>>>>>>>>
81883>>>>>>>>>>>//
81883>>>>>>>>>>>// Command to set explicit_locking
81883>>>>>>>>>>>//
81883>>>>>>>>>>>
81883>>>>>>>>>>>//
81883>>>>>>>>>>>// Command to get explicit locking
81883>>>>>>>>>>>//
81883>>>>>>>>>>>
81883>>>>>>>>>>>//
81883>>>>>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
81883>>>>>>>>>>>//
81883>>>>>>>>>>>
81883>>>>>>>>>>>//
81883>>>>>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
81883>>>>>>>>>>>//
81883>>>>>>>>>>>
81883>>>>>>>>>>>//*****************************************************************************
81883>>>>>>>>>>>//*** Class  : cDfbtrdrvHandler                                                  ***
81883>>>>>>>>>>>//*** Purpose: An instance of this class can be used as a broker object to  ***
81883>>>>>>>>>>>//***          call several Dfbtrdrv releated methods.                           ***
81883>>>>>>>>>>>//*****************************************************************************
81883>>>>>>>>>>>
81883>>>>>>>>>>>Class cDFBtrDrvHandler Is An Array
81884>>>>>>>>>>>
81884>>>>>>>>>>>    Procedure Construct_Object Integer iImage
81886>>>>>>>>>>>        Forward Send Construct_object iImage
81888>>>>>>>>>>>
81888>>>>>>>>>>>        Property String  psDriverID       Public "DFBTRDRV"
81889>>>>>>>>>>>    End_Procedure // Construct_Object
81890>>>>>>>>>>>
81890>>>>>>>>>>>
81890>>>>>>>>>>>
81890>>>>>>>>>>>    //***
81890>>>>>>>>>>>    //*** Function: CKRevsion
81890>>>>>>>>>>>    //*** Purpose : The revsion of a Dfbtrdrv Connectivity Kit
81890>>>>>>>>>>>    //***
81890>>>>>>>>>>>
81890>>>>>>>>>>>    Function CKRevision Returns String
81892>>>>>>>>>>>        Local String  sDriverID
81892>>>>>>>>>>>        Local String  sRevision
81892>>>>>>>>>>>        Local String  sVoid
81892>>>>>>>>>>>        Local Integer iRetval
81892>>>>>>>>>>>
81892>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
81892>>>>>>>>>>>        // This error would otherwise be raised when we have an older
81892>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
81892>>>>>>>>>>>        Send Ignore_error To Error_object_Id 20491
81893>>>>>>>>>>>        Get psDriverID To sDriverID
81894>>>>>>>>>>>        Move (Repeat(" ", 255)) To sRevision
81895>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
81900>>>>>>>>>>>        Send Trap_Error To Error_object_Id 20491
81901>>>>>>>>>>>        If (Trim(sRevision) = "") Begin
81903>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
81903>>>>>>>>>>>            Move "0.0.0.0" To sRevision
81904>>>>>>>>>>>        End
81904>>>>>>>>>>>>
81904>>>>>>>>>>>        Function_Return sRevision
81905>>>>>>>>>>>    End_Function // CKRevision
81906>>>>>>>>>>>
81906>>>>>>>>>>>    Function CkUsesUri Returns Integer
81908>>>>>>>>>>>        Local String  sDriverID
81908>>>>>>>>>>>        Local String  sVoid1
81908>>>>>>>>>>>        Local String  sVoid2
81908>>>>>>>>>>>        Local Integer iRetval
81908>>>>>>>>>>>
81908>>>>>>>>>>>        Get psDriverID To sDriverID
81909>>>>>>>>>>>
81909>>>>>>>>>>>        Move 0 To iRetval
81910>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
81910>>>>>>>>>>>        // This error would otherwise be raised when we have an older
81910>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
81910>>>>>>>>>>>        Send Ignore_error To Error_object_Id 20491
81911>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
81916>>>>>>>>>>>        Send Trap_Error To Error_object_Id 20491
81917>>>>>>>>>>>
81917>>>>>>>>>>>        Function_Return iRetval
81918>>>>>>>>>>>    End_Function // CKUsesUri
81919>>>>>>>>>>>
81919>>>>>>>>>>>
81919>>>>>>>>>>>
81919>>>>>>>>>>>    //***
81919>>>>>>>>>>>    //*** Function: ExtractPartFromRevsion
81919>>>>>>>>>>>    //*** Purpose : Extarct the Nth part of a a.b.c.d revsion string.
81919>>>>>>>>>>>    //***
81919>>>>>>>>>>>    //*** Returns : The part version number or -1 if there is no such part number.
81919>>>>>>>>>>>    //***
81919>>>>>>>>>>>
81919>>>>>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
81921>>>>>>>>>>>        Local Integer iPartRev
81921>>>>>>>>>>>        Local Integer iCurrentPart
81921>>>>>>>>>>>        Local Integer iSeparatorPos
81921>>>>>>>>>>>
81921>>>>>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
81924>>>>>>>>>>>
81924>>>>>>>>>>>        Move 0 To iCurrentPart
81925>>>>>>>>>>>        Repeat
81925>>>>>>>>>>>>
81925>>>>>>>>>>>            Move (Pos(".", sRevision)) To iSeparatorPos
81926>>>>>>>>>>>            If (iSeparatorPos > 0) Begin
81928>>>>>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) To iPartRev
81929>>>>>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) To sRevision
81930>>>>>>>>>>>                Increment iCurrentPart
81931>>>>>>>>>>>            End
81931>>>>>>>>>>>>
81931>>>>>>>>>>>            Else If (sRevision <> "") Begin
81934>>>>>>>>>>>                Move sRevision To iPartRev
81935>>>>>>>>>>>                Move "" To sRevision
81936>>>>>>>>>>>                Increment iCurrentPart
81937>>>>>>>>>>>            End
81937>>>>>>>>>>>>
81937>>>>>>>>>>>            Else ;                Move -1 To iPartRev
81939>>>>>>>>>>>        Until (iCurrentPart >= iPartNum Or iPartRev = -1)
81941>>>>>>>>>>>
81941>>>>>>>>>>>        Function_Return iPartRev
81942>>>>>>>>>>>    End_Function // EcxtractPartFromRevision
81943>>>>>>>>>>>
81943>>>>>>>>>>>
81943>>>>>>>>>>>
81943>>>>>>>>>>>    //***
81943>>>>>>>>>>>    //*** Function: CKMajorRevision
81943>>>>>>>>>>>    //*** Purpose : Returns the major revision of the CK
81943>>>>>>>>>>>    //***
81943>>>>>>>>>>>
81943>>>>>>>>>>>    Function CKMajorRevision Returns Integer
81945>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
81946>>>>>>>>>>>    End_Function // CKMajorRevision
81947>>>>>>>>>>>
81947>>>>>>>>>>>
81947>>>>>>>>>>>
81947>>>>>>>>>>>    //***
81947>>>>>>>>>>>    //*** Function: CKMinorRevision
81947>>>>>>>>>>>    //*** Purpose : Returns the minor revision of the CK
81947>>>>>>>>>>>    //***
81947>>>>>>>>>>>
81947>>>>>>>>>>>    Function CKMinorRevision Returns Integer
81949>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
81950>>>>>>>>>>>    End_Function // CKMinorRevision
81951>>>>>>>>>>>
81951>>>>>>>>>>>
81951>>>>>>>>>>>
81951>>>>>>>>>>>    //***
81951>>>>>>>>>>>    //*** Function: CKReleaseRevision
81951>>>>>>>>>>>    //*** Purpose : Returns the release revision of the CK
81951>>>>>>>>>>>    //***
81951>>>>>>>>>>>
81951>>>>>>>>>>>    Function CKReleaseRevision Returns Integer
81953>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
81954>>>>>>>>>>>    End_Function // CKReleaseRevision
81955>>>>>>>>>>>
81955>>>>>>>>>>>
81955>>>>>>>>>>>
81955>>>>>>>>>>>    //***
81955>>>>>>>>>>>    //*** Function: CKBuildRevision
81955>>>>>>>>>>>    //*** Purpose : Returns the major revision of the CK
81955>>>>>>>>>>>    //***
81955>>>>>>>>>>>
81955>>>>>>>>>>>    Function CKBuildRevision Returns Integer
81957>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
81958>>>>>>>>>>>    End_Function // CKBuildRevision
81959>>>>>>>>>>>
81959>>>>>>>>>>>
81959>>>>>>>>>>>
81959>>>>>>>>>>>    //***
81959>>>>>>>>>>>    //*** Function: IsMinimalRevision
81959>>>>>>>>>>>    //*** Purpose : Determines if the CK conforms to a passed minimal revsion.
81959>>>>>>>>>>>    //***
81959>>>>>>>>>>>
81959>>>>>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
81961>>>>>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_return (TRUE)
81964>>>>>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
81967>>>>>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_return (TRUE)
81970>>>>>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
81973>>>>>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_return (TRUE)
81976>>>>>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) And iBuild <= CKBuildRevision(Current_object)) ;                    Function_return (TRUE)
81980>>>>>>>>>>>            End
81980>>>>>>>>>>>>
81980>>>>>>>>>>>        End
81980>>>>>>>>>>>>
81980>>>>>>>>>>>
81980>>>>>>>>>>>        Function_Return (FALSE)
81981>>>>>>>>>>>    End_Function // IsMinimalRevision
81982>>>>>>>>>>>
81982>>>>>>>>>>>    //   Functions to query the Pervasive.SQL version:
81982>>>>>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
81982>>>>>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
81982>>>>>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
81982>>>>>>>>>>>    //
81982>>>>>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
81982>>>>>>>>>>>    //   in the following format:
81982>>>>>>>>>>>    //       <version>.<revision>.<type>
81982>>>>>>>>>>>    //   possible values for <type>:
81982>>>>>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
81982>>>>>>>>>>>    //         server using Workgroup authentication mode
81982>>>>>>>>>>>    //       C for client cache engine
81982>>>>>>>>>>>    //       D for DOS workstation
81982>>>>>>>>>>>    //       N for client Requester
81982>>>>>>>>>>>    //       S for NetWare server
81982>>>>>>>>>>>    //       T for 32-bit Windows server engine
81982>>>>>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
81982>>>>>>>>>>>    //
81982>>>>>>>>>>>    //   example:
81982>>>>>>>>>>>    //       8.50.T
81982>>>>>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
81982>>>>>>>>>>>    //   32-bits Windows server.
81982>>>>>>>>>>>    //
81982>>>>>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
81982>>>>>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
81982>>>>>>>>>>>    //
81982>>>>>>>>>>>    //   If the version information is not available or can not be obtained
81982>>>>>>>>>>>    //   the functions will return "0.0.0"
81982>>>>>>>>>>>
81982>>>>>>>>>>>
81982>>>>>>>>>>>    //***
81982>>>>>>>>>>>    //*** Function: PSQLRequesterVersionInfo
81982>>>>>>>>>>>    //*** Purpose : Returns the version information of the
81982>>>>>>>>>>>    //***           Pervasive.SQL Client requester.
81982>>>>>>>>>>>
81982>>>>>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
81984>>>>>>>>>>>
81984>>>>>>>>>>>        Local String  sDriverID
81984>>>>>>>>>>>        Local String  sVersion
81984>>>>>>>>>>>        Local String  sVoid
81984>>>>>>>>>>>        Local Integer iRetval
81984>>>>>>>>>>>
81984>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
81984>>>>>>>>>>>        // This error would otherwise be raised when we have an older
81984>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
81984>>>>>>>>>>>        Send Ignore_error To Error_object_Id 20491
81985>>>>>>>>>>>        Get psDriverID To sDriverID
81986>>>>>>>>>>>        Move (Repeat(" ", 255)) To sVersion
81987>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
81992>>>>>>>>>>>        Send Trap_Error To Error_object_Id 20491
81993>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
81995>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
81995>>>>>>>>>>>            Move "0.0.0" To sVersion
81996>>>>>>>>>>>        End
81996>>>>>>>>>>>>
81996>>>>>>>>>>>        Function_Return sVersion
81997>>>>>>>>>>>    End_Function //  PSQLRequesterVersion
81998>>>>>>>>>>>
81998>>>>>>>>>>>    //***
81998>>>>>>>>>>>    //*** Function: PSQLLocalEngineVersionInfo
81998>>>>>>>>>>>    //*** Purpose : Returns the version information of the
81998>>>>>>>>>>>    //***           Pervasive.SQL Local Engine
81998>>>>>>>>>>>
81998>>>>>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
82000>>>>>>>>>>>
82000>>>>>>>>>>>        Local String  sDriverID
82000>>>>>>>>>>>        Local String  sVersion
82000>>>>>>>>>>>        Local String  sVoid
82000>>>>>>>>>>>        Local Integer iRetval
82000>>>>>>>>>>>
82000>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
82000>>>>>>>>>>>        // This error would otherwise be raised when we have an older
82000>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
82000>>>>>>>>>>>        Send Ignore_error To Error_object_Id 20491
82001>>>>>>>>>>>        Get psDriverID To sDriverID
82002>>>>>>>>>>>        Move (Repeat(" ", 255)) To sVersion
82003>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
82008>>>>>>>>>>>        Send Trap_Error To Error_object_Id 20491
82009>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
82011>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
82011>>>>>>>>>>>            Move "0.0.0" To sVersion
82012>>>>>>>>>>>        End
82012>>>>>>>>>>>>
82012>>>>>>>>>>>        Function_Return sVersion
82013>>>>>>>>>>>    End_Function //  PSQLLocalEngineVersion
82014>>>>>>>>>>>
82014>>>>>>>>>>>    //***
82014>>>>>>>>>>>    //*** Function: PSQLServerEngineVersionInfo
82014>>>>>>>>>>>    //*** Purpose : Returns the version information of the
82014>>>>>>>>>>>    //***           Pervasive.SQL Server Engine
82014>>>>>>>>>>>
82014>>>>>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
82016>>>>>>>>>>>
82016>>>>>>>>>>>        Local String  sDriverID
82016>>>>>>>>>>>        Local String  sVersion
82016>>>>>>>>>>>        Local String  sVoid
82016>>>>>>>>>>>        Local Integer iRetval
82016>>>>>>>>>>>
82016>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
82016>>>>>>>>>>>        // This error would otherwise be raised when we have an older
82016>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
82016>>>>>>>>>>>        Send Ignore_error To Error_object_Id 20491
82017>>>>>>>>>>>        Get psDriverID To sDriverID
82018>>>>>>>>>>>        Move (Repeat(" ", 255)) To sVersion
82019>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
82024>>>>>>>>>>>        Send Trap_Error To Error_object_Id 20491
82025>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
82027>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
82027>>>>>>>>>>>            Move "0.0.0" To sVersion
82028>>>>>>>>>>>        End
82028>>>>>>>>>>>>
82028>>>>>>>>>>>        Function_Return sVersion
82029>>>>>>>>>>>    End_Function //  PSQLServerEngineVersion
82030>>>>>>>>>>>
82030>>>>>>>>>>>End_Class // cDfbtrdrvHandler
82031>>>>>>>>>>>
82031>>>>>>>>>Use cDbUpdateFunctionLibrary.inc
82031>>>>>>>>>Use cSQLConnectionIniFile.inc
Including file: cSQLConnectionIniFile.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.inc)
82031>>>>>>>>>>>//****************************************************************************
82031>>>>>>>>>>>// $Module type: Include file
82031>>>>>>>>>>>// $Module name: cSQLConnectionIniFile.inc
82031>>>>>>>>>>>//
82031>>>>>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
82031>>>>>>>>>>>// Copyright (c) 2012 RDC Tools International
82031>>>>>>>>>>>// E-mail      : support@rdctools.com
82031>>>>>>>>>>>// Web-site    : http://www.rdctools.com
82031>>>>>>>>>>>//
82031>>>>>>>>>>>// Created     : 2017-01-18 @ 13:04 (Military date format - Year-Month-Day)
82031>>>>>>>>>>>//
82031>>>>>>>>>>>// Note        : Header file with constant declarations for the cSQLConnectionIniFile class.
82031>>>>>>>>>>>//
82031>>>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
82031>>>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
82031>>>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
82031>>>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
82031>>>>>>>>>>>// in the help folder for more details.
82031>>>>>>>>>>>//
82031>>>>>>>>>>>Use Winkern.pkg
82031>>>>>>>>>>>Use cIniFile.pkg
82031>>>>>>>>>>>Use cCryptographer.pkg
Including file: cCryptographer.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCryptographer.pkg)
82031>>>>>>>>>>>>>Use VdfBase.pkg
82031>>>>>>>>>>>>>
82031>>>>>>>>>>>>>Use CryptographerConstants.pkg
Including file: CryptographerConstants.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\CryptographerConstants.pkg)
82031>>>>>>>>>>>>>>>//                                      
82031>>>>>>>>>>>>>>>// File    : CryptographerConstants.pkg
82031>>>>>>>>>>>>>>>//
82031>>>>>>>>>>>>>>>//   Author  : Ulbe Stellema
82031>>>>>>>>>>>>>>>//             Data Access Worldwide
82031>>>>>>>>>>>>>>>//
82031>>>>>>>>>>>>>>>//   Date    : October 4, 2009
82031>>>>>>>>>>>>>>>//
82031>>>>>>>>>>>>>>>
82031>>>>>>>>>>>>>>>
82031>>>>>>>>>>>>>>>
82031>>>>>>>>>>>>>>>// Algorithm classes
82031>>>>>>>>>>>>>>>Define ALG_CLASS_ANY                    for |CI$00000000 // (0)
82031>>>>>>>>>>>>>>>Define ALG_CLASS_SIGNATURE              for |CI$00002000 // (1 << 13)
82031>>>>>>>>>>>>>>>Define ALG_CLASS_MSG_ENCRYPT            for |CI$00004000 // (2 << 13)
82031>>>>>>>>>>>>>>>Define ALG_CLASS_DATA_ENCRYPT           for |CI$00006000 // (3 << 13)
82031>>>>>>>>>>>>>>>Define ALG_CLASS_HASH                   for |CI$00008000 // (4 << 13)
82031>>>>>>>>>>>>>>>Define ALG_CLASS_KEY_EXCHANGE           for |CI$0000A000 // (5 << 13)
82031>>>>>>>>>>>>>>>Define ALG_CLASS_ALL                    for |CI$0000E000 // (7 << 13)
82031>>>>>>>>>>>>>>>
82031>>>>>>>>>>>>>>>// Algorithm types
82031>>>>>>>>>>>>>>>Define ALG_TYPE_ANY                     for |CI$00000000 // (0)
82031>>>>>>>>>>>>>>>Define ALG_TYPE_DSS                     for |CI$00000200 // (1 << 9)
82031>>>>>>>>>>>>>>>Define ALG_TYPE_RSA                     for |CI$00000400 // (2 << 9)
82031>>>>>>>>>>>>>>>Define ALG_TYPE_BLOCK                   for |CI$00000600 // (3 << 9)
82031>>>>>>>>>>>>>>>Define ALG_TYPE_STREAM                  for |CI$00000800 // (4 << 9)
82031>>>>>>>>>>>>>>>Define ALG_TYPE_DH                      for |CI$00000A00 // (5 << 9)
82031>>>>>>>>>>>>>>>Define ALG_TYPE_SECURECHANNEL           for |CI$00000C00 // (6 << 9)
82031>>>>>>>>>>>>>>>
82031>>>>>>>>>>>>>>>// Generic sub-ids
82031>>>>>>>>>>>>>>>Define ALG_SID_ANY                      for |CI$00000000 // (0)
82031>>>>>>>>>>>>>>>
82031>>>>>>>>>>>>>>>// RSA sub-ids
82031>>>>>>>>>>>>>>>Define ALG_SID_RSA_ANY                  for 0
82031>>>>>>>>>>>>>>>Define ALG_SID_RSA_PKCS                 for 1
82031>>>>>>>>>>>>>>>Define ALG_SID_RSA_MSATWORK             for 2
82031>>>>>>>>>>>>>>>Define ALG_SID_RSA_ENTRUST              for 3
82031>>>>>>>>>>>>>>>Define ALG_SID_RSA_PGP                  for 4
82031>>>>>>>>>>>>>>>
82031>>>>>>>>>>>>>>>// DSS sub-ids
82031>>>>>>>>>>>>>>>Define ALG_SID_DSS_ANY                  for 0
82031>>>>>>>>>>>>>>>Define ALG_SID_DSS_PKCS                 for 1
82031>>>>>>>>>>>>>>>Define ALG_SID_DSS_DMS                  for 2
82031>>>>>>>>>>>>>>>
82031>>>>>>>>>>>>>>>// DES sub_ids
82031>>>>>>>>>>>>>>>Define ALG_SID_DES                      for 1
82031>>>>>>>>>>>>>>>Define ALG_SID_3DES                     for 3
82031>>>>>>>>>>>>>>>Define ALG_SID_DESX                     for 4
82031>>>>>>>>>>>>>>>Define ALG_SID_IDEA                     for 5
82031>>>>>>>>>>>>>>>Define ALG_SID_CAST                     for 6
82031>>>>>>>>>>>>>>>Define ALG_SID_SAFERSK64                for 7
82031>>>>>>>>>>>>>>>Define ALG_SID_SAFERSK128               for 8
82031>>>>>>>>>>>>>>>Define ALG_SID_3DES_112                 for 9
82031>>>>>>>>>>>>>>>Define ALG_SID_CYLINK_MEK               for 12
82031>>>>>>>>>>>>>>>Define ALG_SID_RC5                      for 13
82031>>>>>>>>>>>>>>>Define ALG_SID_AES_128                  for 14
82031>>>>>>>>>>>>>>>Define ALG_SID_AES_192                  for 15
82031>>>>>>>>>>>>>>>Define ALG_SID_AES_256                  for 16
82031>>>>>>>>>>>>>>>Define ALG_SID_AES                      for 17
82031>>>>>>>>>>>>>>>
82031>>>>>>>>>>>>>>>// Fortezza sub-ids
82031>>>>>>>>>>>>>>>Define ALG_SID_SKIPJACK                 for 10
82031>>>>>>>>>>>>>>>Define ALG_SID_TEK                      for 11
82031>>>>>>>>>>>>>>>
82031>>>>>>>>>>>>>>>// RC2 sub-ids
82031>>>>>>>>>>>>>>>Define ALG_SID_RC2                      for 2
82031>>>>>>>>>>>>>>>
82031>>>>>>>>>>>>>>>// Stream cipher sub-ids
82031>>>>>>>>>>>>>>>Define ALG_SID_RC4                      for 1
82031>>>>>>>>>>>>>>>Define ALG_SID_SEAL                     for 2
82031>>>>>>>>>>>>>>>
82031>>>>>>>>>>>>>>>// Diffie-Hellman sub-ids
82031>>>>>>>>>>>>>>>Define ALG_SID_DH_SANDF                 for 1
82031>>>>>>>>>>>>>>>Define ALG_SID_DH_EPHEM                 for 2
82031>>>>>>>>>>>>>>>Define ALG_SID_AGREED_KEY_ANY           for 3
82031>>>>>>>>>>>>>>>Define ALG_SID_KEA                      for 4
82031>>>>>>>>>>>>>>>
82031>>>>>>>>>>>>>>>// Hash sub ids
82031>>>>>>>>>>>>>>>Define ALG_SID_MD2                      for 1
82031>>>>>>>>>>>>>>>Define ALG_SID_MD4                      for 2
82031>>>>>>>>>>>>>>>Define ALG_SID_MD5                      for 3
82031>>>>>>>>>>>>>>>Define ALG_SID_SHA                      for 4
82031>>>>>>>>>>>>>>>Define ALG_SID_SHA1                     for 4
82031>>>>>>>>>>>>>>>Define ALG_SID_MAC                      for 5
82031>>>>>>>>>>>>>>>Define ALG_SID_RIPEMD                   for 6
82031>>>>>>>>>>>>>>>Define ALG_SID_RIPEMD160                for 7
82031>>>>>>>>>>>>>>>Define ALG_SID_SSL3SHAMD5               for 8
82031>>>>>>>>>>>>>>>Define ALG_SID_HMAC                     for 9
82031>>>>>>>>>>>>>>>Define ALG_SID_TLS1PRF                  for 10
82031>>>>>>>>>>>>>>>Define ALG_SID_HASH_REPLACE_OWF         for 11
82031>>>>>>>>>>>>>>>Define ALG_SID_SHA_256                  for 12
82031>>>>>>>>>>>>>>>Define ALG_SID_SHA_384                  for 13
82031>>>>>>>>>>>>>>>Define ALG_SID_SHA_512                  for 14
82031>>>>>>>>>>>>>>>
82031>>>>>>>>>>>>>>>// secure channel sub ids
82031>>>>>>>>>>>>>>>Define ALG_SID_SSL3_MASTER              for 1
82031>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MASTER_HASH     for 2
82031>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MAC_KEY         for 3
82031>>>>>>>>>>>>>>>Define ALG_SID_PCT1_MASTER              for 4
82031>>>>>>>>>>>>>>>Define ALG_SID_SSL2_MASTER              for 5
82031>>>>>>>>>>>>>>>Define ALG_SID_TLS1_MASTER              for 6
82031>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_ENC_KEY         for 7
82031>>>>>>>>>>>>>>>
82031>>>>>>>>>>>>>>>// algorithm identifier definitions
82031>>>>>>>>>>>>>>>Define CALG_MD2                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD2)
82031>>>>>>>>>>>>>>>Define CALG_MD4                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD4)
82031>>>>>>>>>>>>>>>Define CALG_MD5                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD5)
82031>>>>>>>>>>>>>>>Define CALG_SHA                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA)
82031>>>>>>>>>>>>>>>Define CALG_SHA1                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA1)
82031>>>>>>>>>>>>>>>Define CALG_MAC                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MAC)
82031>>>>>>>>>>>>>>>Define CALG_RSA_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
82031>>>>>>>>>>>>>>>Define CALG_DSS_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_DSS ior ALG_SID_DSS_ANY)
82031>>>>>>>>>>>>>>>Define CALG_NO_SIGN                     for (ALG_CLASS_SIGNATURE ior ALG_TYPE_ANY ior ALG_SID_ANY)
82031>>>>>>>>>>>>>>>Define CALG_RSA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
82031>>>>>>>>>>>>>>>Define CALG_DES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DES)
82031>>>>>>>>>>>>>>>Define CALG_3DES_112                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES_112)
82031>>>>>>>>>>>>>>>Define CALG_3DES                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES)
82031>>>>>>>>>>>>>>>Define CALG_DESX                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DESX)
82031>>>>>>>>>>>>>>>Define CALG_RC2                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC2)
82031>>>>>>>>>>>>>>>Define CALG_RC4                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_RC4)
82031>>>>>>>>>>>>>>>Define CALG_SEAL                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_SEAL)
82031>>>>>>>>>>>>>>>Define CALG_DH_SF                       for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_SANDF)
82031>>>>>>>>>>>>>>>Define CALG_DH_EPHEM                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_EPHEM)
82031>>>>>>>>>>>>>>>Define CALG_AGREEDKEY_ANY               for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_AGREED_KEY_ANY)
82031>>>>>>>>>>>>>>>Define CALG_KEA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_KEA)
82031>>>>>>>>>>>>>>>Define CALG_HUGHES_MD5                  for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_ANY ior ALG_SID_MD5)
82031>>>>>>>>>>>>>>>Define CALG_SKIPJACK                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_SKIPJACK)
82031>>>>>>>>>>>>>>>Define CALG_TEK                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_TEK)
82031>>>>>>>>>>>>>>>Define CALG_CYLINK_MEK                  for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_CYLINK_MEK)
82031>>>>>>>>>>>>>>>Define CALG_SSL3_SHAMD5                 for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SSL3SHAMD5)
82031>>>>>>>>>>>>>>>Define CALG_SSL3_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL3_MASTER)
82031>>>>>>>>>>>>>>>Define CALG_SCHANNEL_MASTER_HASH        for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MASTER_HASH)
82031>>>>>>>>>>>>>>>Define CALG_SCHANNEL_MAC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MAC_KEY)
82031>>>>>>>>>>>>>>>Define CALG_SCHANNEL_ENC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_ENC_KEY)
82031>>>>>>>>>>>>>>>Define CALG_PCT1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_PCT1_MASTER)
82031>>>>>>>>>>>>>>>Define CALG_SSL2_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL2_MASTER)
82031>>>>>>>>>>>>>>>Define CALG_TLS1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_TLS1_MASTER)
82031>>>>>>>>>>>>>>>Define CALG_RC5                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC5)
82031>>>>>>>>>>>>>>>Define CALG_HMAC                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HMAC)
82031>>>>>>>>>>>>>>>Define CALG_TLS1PRF                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_TLS1PRF)
82031>>>>>>>>>>>>>>>Define CALG_HASH_REPLACE_OWF            for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HASH_REPLACE_OWF)
82031>>>>>>>>>>>>>>>Define CALG_AES_128                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_128)
82031>>>>>>>>>>>>>>>Define CALG_AES_192                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_192)
82031>>>>>>>>>>>>>>>Define CALG_AES_256                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_256)
82031>>>>>>>>>>>>>>>Define CALG_AES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES)
82031>>>>>>>>>>>>>>>Define CALG_SHA_256                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_256)
82031>>>>>>>>>>>>>>>Define CALG_SHA_384                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_384)
82031>>>>>>>>>>>>>>>Define CALG_SHA_512                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_512)
82031>>>>>>>>>>>>>>>
82031>>>>>>>>>>>>>>>// Providers
82031>>>>>>>>>>>>>>>Define MS_DEF_PROV                      for "Microsoft Base Cryptographic Provider v1.0"
82031>>>>>>>>>>>>>>>Define MS_ENHANCED_PROV                 for "Microsoft Enhanced Cryptographic Provider v1.0"
82031>>>>>>>>>>>>>>>Define MS_STRONG_PROV                   for "Microsoft Strong Cryptographic Provider"
82031>>>>>>>>>>>>>>>Define MS_DEF_RSA_SIG_PROV              for "Microsoft RSA Signature Cryptographic Provider"
82031>>>>>>>>>>>>>>>Define MS_DEF_RSA_SCHANNEL_PROV         for "Microsoft RSA SChannel Cryptographic Provider"
82031>>>>>>>>>>>>>>>Define MS_DEF_DSS_PROV                  for "Microsoft Base DSS Cryptographic Provider"
82031>>>>>>>>>>>>>>>Define MS_DEF_DSS_DH_PROV               for "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
82031>>>>>>>>>>>>>>>Define MS_ENH_DSS_DH_PROV               for "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
82031>>>>>>>>>>>>>>>Define MS_DEF_DH_SCHANNEL_PROV          for "Microsoft DH SChannel Cryptographic Provider"
82031>>>>>>>>>>>>>>>Define MS_SCARD_PROV                    for "Microsoft Base Smart Card Crypto Provider"
82031>>>>>>>>>>>>>>>Define MS_ENH_RSA_AES_PROV              for "Microsoft Enhanced RSA and AES Cryptographic Provider"
82031>>>>>>>>>>>>>>>
82031>>>>>>>>>>>>>>>// dwFlags definitions for CryptAcquireContext
82031>>>>>>>>>>>>>>>Define CRYPT_VERIFYCONTEXT              for |CI$F0000000
82031>>>>>>>>>>>>>>>Define CRYPT_NEWKEYSET                  for |CI$00000008
82031>>>>>>>>>>>>>>>Define CRYPT_DELETEKEYSET               for |CI$00000010
82031>>>>>>>>>>>>>>>Define CRYPT_MACHINE_KEYSET             for |CI$00000020
82031>>>>>>>>>>>>>>>Define CRYPT_SILENT                     for |CI$00000040
82031>>>>>>>>>>>>>>>
82031>>>>>>>>>>>>>>>// dwFlag definitions for CryptGenKey
82031>>>>>>>>>>>>>>>Define CRYPT_EXPORTABLE                 for |CI$00000001
82031>>>>>>>>>>>>>>>Define CRYPT_USER_PROTECTED             for |CI$00000002
82031>>>>>>>>>>>>>>>Define CRYPT_CREATE_SALT                for |CI$00000004
82031>>>>>>>>>>>>>>>Define CRYPT_UPDATE_KEY                 for |CI$00000008
82031>>>>>>>>>>>>>>>Define CRYPT_NO_SALT                    for |CI$00000010
82031>>>>>>>>>>>>>>>Define CRYPT_PREGEN                     for |CI$00000040
82031>>>>>>>>>>>>>>>Define CRYPT_RECIPIENT                  for |CI$00000010
82031>>>>>>>>>>>>>>>Define CRYPT_INITIATOR                  for |CI$00000040
82031>>>>>>>>>>>>>>>Define CRYPT_ONLINE                     for |CI$00000080
82031>>>>>>>>>>>>>>>Define CRYPT_SF                         for |CI$00000100
82031>>>>>>>>>>>>>>>Define CRYPT_CREATE_IV                  for |CI$00000200
82031>>>>>>>>>>>>>>>Define CRYPT_KEK                        for |CI$00000400
82031>>>>>>>>>>>>>>>Define CRYPT_DATA_KEY                   for |CI$00000800
82031>>>>>>>>>>>>>>>Define CRYPT_VOLATILE                   for |CI$00001000
82031>>>>>>>>>>>>>>>Define CRYPT_SGCKEY                     for |CI$00002000
82031>>>>>>>>>>>>>>>Define CRYPT_ARCHIVABLE                 for |CI$00004000
82031>>>>>>>>>>>>>>>
82031>>>>>>>>>>>>>>>// Provider types
82031>>>>>>>>>>>>>>>Define PROV_RSA_FULL                    for 1
82031>>>>>>>>>>>>>>>Define PROV_RSA_SIG                     for 2
82031>>>>>>>>>>>>>>>Define PROV_DSS                         for 3
82031>>>>>>>>>>>>>>>Define PROV_FORTEZZA                    for 4
82031>>>>>>>>>>>>>>>Define PROV_MS_EXCHANGE                 for 5
82031>>>>>>>>>>>>>>>Define PROV_SSL                         for 6
82031>>>>>>>>>>>>>>>Define PROV_RSA_SCHANNEL                for 12
82031>>>>>>>>>>>>>>>Define PROV_DSS_DH                      for 13
82031>>>>>>>>>>>>>>>Define PROV_EC_ECDSA_SIG                for 14
82031>>>>>>>>>>>>>>>Define PROV_EC_ECNRA_SIG                for 15
82031>>>>>>>>>>>>>>>Define PROV_EC_ECDSA_FULL               for 16
82031>>>>>>>>>>>>>>>Define PROV_EC_ECNRA_FULL               for 17
82031>>>>>>>>>>>>>>>Define PROV_DH_SCHANNEL                 for 18
82031>>>>>>>>>>>>>>>Define PROV_SPYRUS_LYNKS                for 20
82031>>>>>>>>>>>>>>>Define PROV_RNG                         for 21
82031>>>>>>>>>>>>>>>Define PROV_INTEL_SEC                   for 22
82031>>>>>>>>>>>>>>>Define PROV_REPLACE_OWF                 for 23
82031>>>>>>>>>>>>>>>Define PROV_RSA_AES                     for 24
82031>>>>>>>>>>>>>>>
82031>>>>>>>>>>>>>>>// KP_MODE
82031>>>>>>>>>>>>>>>// KP_MODE
82031>>>>>>>>>>>>>>>Define CRYPT_MODE_CBC                   for 1       // Cipher block chaining
82031>>>>>>>>>>>>>>>Define CRYPT_MODE_ECB                   for 2       // Electronic code book
82031>>>>>>>>>>>>>>>Define CRYPT_MODE_OFB                   for 3       // Output feedback mode
82031>>>>>>>>>>>>>>>Define CRYPT_MODE_CFB                   for 4       // Cipher feedback mode
82031>>>>>>>>>>>>>>>Define CRYPT_MODE_CTS                   for 5       // Ciphertext stealing mode
82031>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCI                  for 6       // ANSI CBC Interleaved
82031>>>>>>>>>>>>>>>Define CRYPT_MODE_CFBP                  for 7       // ANSI CFB Pipelined
82031>>>>>>>>>>>>>>>Define CRYPT_MODE_OFBP                  for 8       // ANSI OFB Pipelined
82031>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFM                for 9       // ANSI CBC + OF Masking
82031>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFMI               for 10      // ANSI CBC + OFM Interleaved
82031>>>>>>>>>>>>>>>
82031>>>>>>>>>>>>>>>// dwParam definitions for CryptGetKeyParam
82031>>>>>>>>>>>>>>>Define KP_IV                            for 1       // Initialization vector
82031>>>>>>>>>>>>>>>Define KP_SALT                          for 2       // Salt value
82031>>>>>>>>>>>>>>>Define KP_PADDING                       for 3       // Padding values
82031>>>>>>>>>>>>>>>Define KP_MODE                          for 4       // Mode of the cipher
82031>>>>>>>>>>>>>>>Define KP_MODE_BITS                     for 5       // Number of bits to feedback
82031>>>>>>>>>>>>>>>Define KP_PERMISSIONS                   for 6       // Key permissions DWORD
82031>>>>>>>>>>>>>>>Define KP_ALGID                         for 7       // Key algorithm
82031>>>>>>>>>>>>>>>Define KP_BLOCKLEN                      for 8       // Block size of the cipher
82031>>>>>>>>>>>>>>>Define KP_KEYLEN                        for 9       // Length of key in bits
82031>>>>>>>>>>>>>>>Define KP_SALT_EX                       for 10      // Length of salt in bytes
82031>>>>>>>>>>>>>>>Define KP_P                             for 11      // DSS/Diffie-Hellman P value
82031>>>>>>>>>>>>>>>Define KP_G                             for 12      // DSS/Diffie-Hellman G value
82031>>>>>>>>>>>>>>>Define KP_Q                             for 13      // DSS Q value
82031>>>>>>>>>>>>>>>Define KP_X                             for 14      // Diffie-Hellman X value
82031>>>>>>>>>>>>>>>Define KP_Y                             for 15      // Y value
82031>>>>>>>>>>>>>>>Define KP_RA                            for 16      // Fortezza RA value
82031>>>>>>>>>>>>>>>Define KP_RB                            for 17      // Fortezza RB value
82031>>>>>>>>>>>>>>>Define KP_INFO                          for 18      // for putting information into an RSA envelope
82031>>>>>>>>>>>>>>>Define KP_EFFECTIVE_KEYLEN              for 19      // setting and getting RC2 effective key length
82031>>>>>>>>>>>>>>>Define KP_SCHANNEL_ALG                  for 20      // for setting the Secure Channel algorithms
82031>>>>>>>>>>>>>>>Define KP_CLIENT_RANDOM                 for 21      // for setting the Secure Channel client random data
82031>>>>>>>>>>>>>>>Define KP_SERVER_RANDOM                 for 22      // for setting the Secure Channel server random data
82031>>>>>>>>>>>>>>>Define KP_RP                            for 23
82031>>>>>>>>>>>>>>>Define KP_PRECOMP_MD5                   for 24
82031>>>>>>>>>>>>>>>Define KP_PRECOMP_SHA                   for 25
82031>>>>>>>>>>>>>>>Define KP_CERTIFICATE                   for 26      // for setting Secure Channel certificate data (PCT1)
82031>>>>>>>>>>>>>>>Define KP_CLEAR_KEY                     for 27      // for setting Secure Channel clear key data (PCT1)
82031>>>>>>>>>>>>>>>Define KP_PUB_EX_LEN                    for 28
82031>>>>>>>>>>>>>>>Define KP_PUB_EX_VAL                    for 29
82031>>>>>>>>>>>>>>>Define KP_KEYVAL                        for 30
82031>>>>>>>>>>>>>>>Define KP_ADMIN_PIN                     for 31
82031>>>>>>>>>>>>>>>Define KP_KEYEXCHANGE_PIN               for 32
82031>>>>>>>>>>>>>>>Define KP_SIGNATURE_PIN                 for 33
82031>>>>>>>>>>>>>>>Define KP_PREHASH                       for 34
82031>>>>>>>>>>>>>>>Define KP_ROUNDS                        for 35
82031>>>>>>>>>>>>>>>Define KP_OAEP_PARAMS                   for 36      // for setting OAEP params on RSA keys
82031>>>>>>>>>>>>>>>Define KP_CMS_KEY_INFO                  for 37
82031>>>>>>>>>>>>>>>Define KP_CMS_DH_KEY_INFO               for 38
82031>>>>>>>>>>>>>>>Define KP_PUB_PARAMS                    for 39      // for setting public parameters
82031>>>>>>>>>>>>>>>Define KP_VERIFY_PARAMS                 for 40      // for verifying DSA and DH parameters
82031>>>>>>>>>>>>>>>Define KP_HIGHEST_VERSION               for 41      // for TLS protocol version setting
82031>>>>>>>>>>>>>>>Define KP_GET_USE_COUNT                 for 42      // for use with PP_CRYPT_COUNT_KEY_USE contexts
82031>>>>>>>>>>>>>>>
82031>>>>>>>>>>>>>>>// dwParam definitions for CryptGetHashParam
82031>>>>>>>>>>>>>>>Define HP_ALGID                         for |CI$0001  // Hash algorithm
82031>>>>>>>>>>>>>>>Define HP_HASHVAL                       for |CI$0002  // Hash value
82031>>>>>>>>>>>>>>>Define HP_HASHSIZE                      for |CI$0004  // Hash value size
82031>>>>>>>>>>>>>>>Define HP_HMAC_INFO                     for |CI$0005  // information for creating an HMA
82031>>>>>>>>>>>>>>>
82031>>>>>>>>>>>>>>>// key BLOB types
82031>>>>>>>>>>>>>>>Define KEYSTATEBLOB                     for |CI$0C
82031>>>>>>>>>>>>>>>Define OPAQUEKEYBLOB                    for |CI$09
82031>>>>>>>>>>>>>>>Define PLAINTEXTKEYBLOB                 for |CI$08
82031>>>>>>>>>>>>>>>Define PRIVATEKEYBLOB                   for |CI$07
82031>>>>>>>>>>>>>>>Define PUBLICKEYBLOB                    for |CI$06
82031>>>>>>>>>>>>>>>Define PUBLICKEYBLOBEX                  for |CI$0A
82031>>>>>>>>>>>>>>>Define SIMPLEBLOB                       for |CI$01
82031>>>>>>>>>>>>>>>Define SYMMETRICWRAPKEYBLOB             for |CI$0B
82031>>>>>>>>>>>>>>>
82031>>>>>>>>>>>>>>>Define CUR_BLOB_VERSION                 for 2
82031>>>>>>>>>>>>>>>
82031>>>>>>>>>>>>>>>//  Structure cryptimportkey
82031>>>>>>>>>>>>>>>Struct PUBLICKEYSTRUC
82031>>>>>>>>>>>>>>>    UChar    bType
82031>>>>>>>>>>>>>>>    UChar    bVersion
82031>>>>>>>>>>>>>>>    UShort   reserved
82031>>>>>>>>>>>>>>>    UInteger aiKeyAlg
82031>>>>>>>>>>>>>>>End_Struct
82031>>>>>>>>>>>>>>>
82031>>>>>>>>>>>>>>>Struct tPLAINTEXTKEYBLOB
82031>>>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
82031>>>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
82031>>>>>>>>>>>>>>>    UInteger       dwKeySize
82031>>>>>>>>>>>>>>>//    UChar[]        rgbKeyData
82031>>>>>>>>>>>>>>>End_Struct
82031>>>>>>>>>>>>>>>
82031>>>>>>>>>>>>>>>
82031>>>>>>>>>>>>>>>
82031>>>>>>>>>>>>>>>//  Structure for specifying the inner and outer strings when calculating HMAC hash (use with CryptSetHashParam)
82031>>>>>>>>>>>>>>>Struct HMAC_INFO
82031>>>>>>>>>>>>>>>    UInteger HashAlgid
82031>>>>>>>>>>>>>>>    Pointer pbInnerString
82031>>>>>>>>>>>>>>>    DWord cbInnerString
82031>>>>>>>>>>>>>>>    Pointer pbOuterString
82031>>>>>>>>>>>>>>>    DWord cbOuterString
82031>>>>>>>>>>>>>>>End_Struct
82031>>>>>>>>>>>>>>>
82031>>>>>>>>>>>>>>>
82031>>>>>>>>>>>>>>>External_Function CryptAcquireContext "CryptAcquireContextA" advapi32.dll ;    Pointer phProv ;    Pointer szContainer ;    Pointer szProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
82032>>>>>>>>>>>>>>>
82032>>>>>>>>>>>>>>>External_Function CryptReleaseContext "CryptReleaseContext" advapi32.dll ;    Handle hProv ;    Integer dwFlags ;    Returns Boolean
82033>>>>>>>>>>>>>>>
82033>>>>>>>>>>>>>>>External_Function CryptCreateHash "CryptCreateHash" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hKey ;    Integer dwFlags ;    Pointer phHash ;    Returns Boolean
82034>>>>>>>>>>>>>>>
82034>>>>>>>>>>>>>>>External_Function CryptDestroyHash "CryptDestroyHash" advapi32.dll ;    Handle hHash ;    Returns Boolean
82035>>>>>>>>>>>>>>>
82035>>>>>>>>>>>>>>>External_Function CryptHashData "CryptHashData" advapi32.dll ;    Handle hHash ;    Pointer pbData ;    Integer dwDataLen ;    Integer dwFlags ;    Returns Boolean
82036>>>>>>>>>>>>>>>
82036>>>>>>>>>>>>>>>External_Function CryptDeriveKey "CryptDeriveKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hBaseData ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
82037>>>>>>>>>>>>>>>
82037>>>>>>>>>>>>>>>External_Function CryptGetHashParam "CryptGetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    DWord dwFlags ;    Returns Integer
82038>>>>>>>>>>>>>>>
82038>>>>>>>>>>>>>>>External_Function CryptDestroyKey "CryptDestroyKey" advapi32.dll ;    Handle hKey ;    Returns Boolean
82039>>>>>>>>>>>>>>>
82039>>>>>>>>>>>>>>>External_Function CryptImportKey "CryptImportKey" advapi32.dll ;    Handle hProv ;    Pointer pbData ;    Integer dwDataLen ;    Handle hPubKey ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
82040>>>>>>>>>>>>>>>
82040>>>>>>>>>>>>>>>External_Function CryptGetKeyParam "CryptGetKeyParam" advapi32.dll ;    Handle hKey ;    Integer dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwFlags ;    Returns Boolean
82041>>>>>>>>>>>>>>>    
82041>>>>>>>>>>>>>>>External_Function CryptSetKeyParam "CryptSetKeyParam" advapi32.dll ;    Handle   hKey ;    UInteger dwParam ;    Pointer  pbdata ;    UInteger dwFlags ;    Returns  Boolean
82042>>>>>>>>>>>>>>>
82042>>>>>>>>>>>>>>>External_Function CryptEncrypt "CryptEncrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwBufLen ;    Returns Boolean
82043>>>>>>>>>>>>>>>
82043>>>>>>>>>>>>>>>External_Function CryptDecrypt "CryptDecrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
82044>>>>>>>>>>>>>>>
82044>>>>>>>>>>>>>>>External_Function CryptGenRandom "CryptGenRandom" advapi32.dll ;    Handle hProv ;    DWord dwLen ;    Pointer pbBuffer ;    Returns Boolean
82045>>>>>>>>>>>>>>>    
82045>>>>>>>>>>>>>>>External_Function CryptSetHashParam "CryptSetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Integer dwFlags ;    Returns Boolean
82046>>>>>>>>>>>>>>>    
82046>>>>>>>>>>>>>
82046>>>>>>>>>>>>>Class cCryptographer is a cObject
82047>>>>>>>>>>>>>    
82047>>>>>>>>>>>>>    // Procedure : Construct_Object
82047>>>>>>>>>>>>>    // Purpose   : Object constructor
82047>>>>>>>>>>>>>    Procedure Construct_Object
82049>>>>>>>>>>>>>        Forward Send Construct_Object
82051>>>>>>>>>>>>>
82051>>>>>>>>>>>>>        Property String     psProvider  MS_ENHANCED_PROV
82052>>>>>>>>>>>>>        Property Integer    piProvider  PROV_RSA_FULL
82053>>>>>>>>>>>>>        Property Integer    piCipher    CALG_RC4
82054>>>>>>>>>>>>>        Property Integer    piHash      CALG_MD5
82055>>>>>>>>>>>>>        
82055>>>>>>>>>>>>>        // Private properties
82055>>>>>>>>>>>>>        Property Handle     Private_phProv
82056>>>>>>>>>>>>>    End_Procedure
82057>>>>>>>>>>>>>    
82057>>>>>>>>>>>>>    
82057>>>>>>>>>>>>>    // Function : AcquireContext
82057>>>>>>>>>>>>>    // Purpose  : Acquire key container handle
82057>>>>>>>>>>>>>    Function AcquireContext Returns Handle
82059>>>>>>>>>>>>>        Integer iProvider
82059>>>>>>>>>>>>>        String sProvider
82059>>>>>>>>>>>>>        Handle hProv
82059>>>>>>>>>>>>>        Boolean bOk
82059>>>>>>>>>>>>>        Address addrProv
82059>>>>>>>>>>>>>        
82059>>>>>>>>>>>>>        Move 0 to hProv
82060>>>>>>>>>>>>>        Get piProvider to iProvider
82061>>>>>>>>>>>>>        Get psProvider to sProvider
82062>>>>>>>>>>>>>        
82062>>>>>>>>>>>>>        //  Determine address to be passed as provider
82062>>>>>>>>>>>>>        If (Trim(sProvider) <> "") Begin
82064>>>>>>>>>>>>>            Move (AddressOf(sProvider)) to addrProv
82065>>>>>>>>>>>>>        End
82065>>>>>>>>>>>>>>
82065>>>>>>>>>>>>>        Else Begin
82066>>>>>>>>>>>>>            Move 0 to addrProv
82067>>>>>>>>>>>>>        End
82067>>>>>>>>>>>>>>
82067>>>>>>>>>>>>>        
82067>>>>>>>>>>>>>        //  Acquire Crypto Context
82067>>>>>>>>>>>>>        Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_VERIFYCONTEXT)) to bOk
82068>>>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
82070>>>>>>>>>>>>>            Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_NEWKEYSET ior CRYPT_VERIFYCONTEXT)) to bOk
82071>>>>>>>>>>>>>        End
82071>>>>>>>>>>>>>>
82071>>>>>>>>>>>>>        
82071>>>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
82073>>>>>>>>>>>>>            // Fallback to original
82073>>>>>>>>>>>>>            Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,0)) to bOk
82074>>>>>>>>>>>>>            
82074>>>>>>>>>>>>>            If (not(bOk) or hProv = 0) Begin
82076>>>>>>>>>>>>>                Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_NEWKEYSET)) to bOk
82077>>>>>>>>>>>>>            End
82077>>>>>>>>>>>>>>
82077>>>>>>>>>>>>>        End
82077>>>>>>>>>>>>>>
82077>>>>>>>>>>>>>        Set Private_phProv to hProv
82078>>>>>>>>>>>>>        
82078>>>>>>>>>>>>>        Function_Return hProv
82079>>>>>>>>>>>>>    End_Function
82080>>>>>>>>>>>>>    
82080>>>>>>>>>>>>>    // Function : ReleaseContext
82080>>>>>>>>>>>>>    // Purpose  : Releases key container handle
82080>>>>>>>>>>>>>    Function ReleaseContext Handle hProv Returns Boolean
82082>>>>>>>>>>>>>        Function_Return (CryptReleaseContext(hProv,0))
82083>>>>>>>>>>>>>    End_Function
82084>>>>>>>>>>>>>    
82084>>>>>>>>>>>>>    // Function : CreateHash
82084>>>>>>>>>>>>>    // Purpose  : Creates hash object
82084>>>>>>>>>>>>>    Function CreateHash Handle hProv Returns Handle
82086>>>>>>>>>>>>>        Integer iAlgorithm
82086>>>>>>>>>>>>>        Handle hHash
82086>>>>>>>>>>>>>        Boolean bOk
82086>>>>>>>>>>>>>        
82086>>>>>>>>>>>>>        Move 0 to hHash
82087>>>>>>>>>>>>>        Get piHash to iAlgorithm
82088>>>>>>>>>>>>>        Move (CryptCreateHash(hProv,iAlgorithm,0,0,AddressOf(hHash))) to bOk
82089>>>>>>>>>>>>>        
82089>>>>>>>>>>>>>        Function_Return hHash
82090>>>>>>>>>>>>>    End_Function
82091>>>>>>>>>>>>>    
82091>>>>>>>>>>>>>    // Function : DestroyHash
82091>>>>>>>>>>>>>    // Purpose  : Destroys the hash object
82091>>>>>>>>>>>>>    Function DestroyHash Handle hHash Returns Boolean
82093>>>>>>>>>>>>>        Function_Return (CryptDestroyHash(hHash))
82094>>>>>>>>>>>>>    End_Function
82095>>>>>>>>>>>>>    
82095>>>>>>>>>>>>>    // Function : HashData
82095>>>>>>>>>>>>>    // Purpose  : Adds data to hash object
82095>>>>>>>>>>>>>    Function HashData Handle hHash String sData Returns Boolean
82097>>>>>>>>>>>>>        Function_Return (CryptHashData(hHash,AddressOf(sData),Length(sData),0))
82098>>>>>>>>>>>>>    End_Function
82099>>>>>>>>>>>>>    
82099>>>>>>>>>>>>>    // Function : DeriveKey
82099>>>>>>>>>>>>>    // Purpose  : Generates session key
82099>>>>>>>>>>>>>    Function DeriveKey Handle hProv Handle hHash Returns Handle
82101>>>>>>>>>>>>>        Integer iAlgorithm
82101>>>>>>>>>>>>>        Handle hKey
82101>>>>>>>>>>>>>        Boolean bOk
82101>>>>>>>>>>>>>        
82101>>>>>>>>>>>>>        Move 0 to hKey
82102>>>>>>>>>>>>>        Get piCipher to iAlgorithm
82103>>>>>>>>>>>>>        Move (CryptDeriveKey(hProv,iAlgorithm,hHash,CRYPT_EXPORTABLE,AddressOf(hKey))) to bOk
82104>>>>>>>>>>>>>        
82104>>>>>>>>>>>>>        Function_Return hKey
82105>>>>>>>>>>>>>    End_Function
82106>>>>>>>>>>>>>    
82106>>>>>>>>>>>>>    // Function : ImportPlainTextKey
82106>>>>>>>>>>>>>    // Purpose  : Imports a plain text key
82106>>>>>>>>>>>>>    Function ImportPlainTextKey Handle hProv UChar[] ucaKey Returns Handle
82108>>>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
82108>>>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
82108>>>>>>>>>>>>>        Boolean   bSuccess
82108>>>>>>>>>>>>>        Handle    hKey
82108>>>>>>>>>>>>>        Integer   iHeadSize iKeySize
82108>>>>>>>>>>>>>        UChar[]   ucaKeyblob
82109>>>>>>>>>>>>>        Integer iVoid
82109>>>>>>>>>>>>>    
82109>>>>>>>>>>>>>        Move (SizeOfType(tPLAINTEXTKEYBLOB)) to iHeadSize
82110>>>>>>>>>>>>>        Move (SizeOfArray(ucaKey)) to iKeySize
82111>>>>>>>>>>>>>    
82111>>>>>>>>>>>>>        Move PLAINTEXTKEYBLOB to blobhead.hdr.bType
82112>>>>>>>>>>>>>        Move CUR_BLOB_VERSION   to blobhead.hdr.bVersion
82113>>>>>>>>>>>>>        Get piCipher            to blobhead.hdr.aiKeyAlg
82114>>>>>>>>>>>>>        Move iKeySize           to blobhead.dwKeySize
82115>>>>>>>>>>>>>    
82115>>>>>>>>>>>>>        Move (ResizeArray(ucaKeyblob, iHeadSize)) to ucaKeyblob
82116>>>>>>>>>>>>>        Move (CopyMemory(AddressOf(ucaKeyblob), AddressOf(blobhead), iHeadSize)) to iVoid
82117>>>>>>>>>>>>>        Move (AppendArray(ucaKeyblob, ucaKey)) to ucaKeyblob
82118>>>>>>>>>>>>>    
82118>>>>>>>>>>>>>        Move 0 to hKey
82119>>>>>>>>>>>>>        Move (CryptImportKey(hProv, AddressOf(ucaKeyblob), SizeOfArray(ucaKeyblob), 0, 0, AddressOf(hKey))) to bSuccess
82120>>>>>>>>>>>>>        If (not(bSuccess)) Begin 
82122>>>>>>>>>>>>>            Move (ShowLastError()) to iVoid
82123>>>>>>>>>>>>>        End
82123>>>>>>>>>>>>>>
82123>>>>>>>>>>>>>    
82123>>>>>>>>>>>>>        Function_Return hKey
82124>>>>>>>>>>>>>    End_Function
82125>>>>>>>>>>>>>
82125>>>>>>>>>>>>>    // Function : DestroyKey
82125>>>>>>>>>>>>>    // Purpose  : Destroys the key
82125>>>>>>>>>>>>>    Function DestroyKey Handle hKey Returns Boolean
82127>>>>>>>>>>>>>        Function_Return (CryptDestroyKey(hKey))
82128>>>>>>>>>>>>>    End_Function
82129>>>>>>>>>>>>>    
82129>>>>>>>>>>>>>    // Function : KeyParameter
82129>>>>>>>>>>>>>    // Purpose  : Retrieves key data
82129>>>>>>>>>>>>>    Function KeyParameter Handle hKey Integer iQuery Returns Integer
82131>>>>>>>>>>>>>        Integer iBuffer iLen
82131>>>>>>>>>>>>>        Boolean bOk
82131>>>>>>>>>>>>>        
82131>>>>>>>>>>>>>        Move (SizeOfType(Integer)) to iLen
82132>>>>>>>>>>>>>        Move (CryptGetKeyParam(hKey,iQuery,AddressOf(iBuffer),AddressOf(iLen),0)) to bOk
82133>>>>>>>>>>>>>        Function_Return iBuffer
82134>>>>>>>>>>>>>    End_Function
82135>>>>>>>>>>>>>    
82135>>>>>>>>>>>>>    // Function : HashValue
82135>>>>>>>>>>>>>    // Purpose  : Retrieves a hash value
82135>>>>>>>>>>>>>    Function HashValue Handle lhHash Returns String
82137>>>>>>>>>>>>>        Pointer lpSize
82137>>>>>>>>>>>>>        Pointer lpHash
82137>>>>>>>>>>>>>        String  lsSize
82137>>>>>>>>>>>>>        String  lsHash
82137>>>>>>>>>>>>>        Integer liResult
82137>>>>>>>>>>>>>
82137>>>>>>>>>>>>>        Move (Repeat(Character(0),4)) to lsSize
82138>>>>>>>>>>>>>        GetAddress of lsSize to lpSize
82139>>>>>>>>>>>>>
82139>>>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,0,lpSize,0)) to liResult
82140>>>>>>>>>>>>>        If (liResult = 0) Function_Return ""
82143>>>>>>>>>>>>>
82143>>>>>>>>>>>>>        Move (Repeat(Character(0),BytesTodWord(lsSize,1))) to lsHash
82144>>>>>>>>>>>>>        GetAddress of lsHash to lpHash
82145>>>>>>>>>>>>>
82145>>>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,lpHash,lpSize,0)) to liResult
82146>>>>>>>>>>>>>        If (liResult = 0) Function_Return ""
82149>>>>>>>>>>>>>
82149>>>>>>>>>>>>>        Function_Return lsHash
82150>>>>>>>>>>>>>    End_Function  // HashValue
82151>>>>>>>>>>>>>    
82151>>>>>>>>>>>>>            
82151>>>>>>>>>>>>>    // Function : Encrypt
82151>>>>>>>>>>>>>    // Purpose  : Encrypts data
82151>>>>>>>>>>>>>    Function Encrypt String sPassword String sData Returns String
82153>>>>>>>>>>>>>        Handle hProv hHash hKey
82153>>>>>>>>>>>>>        Integer iAlgorithm iDataLen iCipherLen iErr
82153>>>>>>>>>>>>>        Boolean bOk
82153>>>>>>>>>>>>>        
82153>>>>>>>>>>>>>        Get AcquireContext to hProv
82154>>>>>>>>>>>>>        If (hProv) Begin
82156>>>>>>>>>>>>>            Get CreateHash hProv to hHash
82157>>>>>>>>>>>>>            If (hHash) Begin
82159>>>>>>>>>>>>>                Get HashData hHash sPassword to bOk
82160>>>>>>>>>>>>>                If (bOk) Begin
82162>>>>>>>>>>>>>                    Get piCipher to iAlgorithm
82163>>>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
82164>>>>>>>>>>>>>                End // If (bOk) Begin            
82164>>>>>>>>>>>>>>
82164>>>>>>>>>>>>>                Get DestroyHash hHash to bOk
82165>>>>>>>>>>>>>            End // If (hHash) Begin
82165>>>>>>>>>>>>>>
82165>>>>>>>>>>>>>            
82165>>>>>>>>>>>>>            If (hKey) Begin
82167>>>>>>>>>>>>>                //  First call to determine resulting data size
82167>>>>>>>>>>>>>                Move (Length(sData)) to iDataLen
82168>>>>>>>>>>>>>                Move (Length(sData)) to iCipherLen
82169>>>>>>>>>>>>>                Move (CryptEncrypt(hKey, 0, True, 0, 0, AddressOf(iCipherLen), iDataLen)) to bOk
82170>>>>>>>>>>>>>                
82170>>>>>>>>>>>>>                //  Reserve space in string
82170>>>>>>>>>>>>>                If (iDataLen < iCipherLen) Begin
82172>>>>>>>>>>>>>                    Move (sData + Repeat(" ", iCipherLen - iDataLen)) to sData
82173>>>>>>>>>>>>>                End
82173>>>>>>>>>>>>>>
82173>>>>>>>>>>>>>                
82173>>>>>>>>>>>>>                //  Call to really decrypt
82173>>>>>>>>>>>>>                Move (CryptEncrypt(hKey,0,True,0,AddressOf(sData),AddressOf(iDataLen),Length(sData))) to bOk
82174>>>>>>>>>>>>>                //If (not(bOk)) Begin
82174>>>>>>>>>>>>>                    //Move "" to sData
82174>>>>>>>>>>>>>                    //Move (GetLastError()) to iErr
82174>>>>>>>>>>>>>                //End
82174>>>>>>>>>>>>>                
82174>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
82175>>>>>>>>>>>>>            End // If (hKey) Begin
82175>>>>>>>>>>>>>>
82175>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
82176>>>>>>>>>>>>>        End // If (hProv) Begin
82176>>>>>>>>>>>>>>
82176>>>>>>>>>>>>>        Function_Return sData
82177>>>>>>>>>>>>>    End_Function
82178>>>>>>>>>>>>>    
82178>>>>>>>>>>>>>    // Function : Decrypt
82178>>>>>>>>>>>>>    // Purpose  : Decrypts data
82178>>>>>>>>>>>>>    Function Decrypt String sPassword String sData Returns String
82180>>>>>>>>>>>>>        Handle hProv hHash hKey
82180>>>>>>>>>>>>>        Integer iAlgorithm iDataLen
82180>>>>>>>>>>>>>        Boolean bOk
82180>>>>>>>>>>>>>        
82180>>>>>>>>>>>>>        Get AcquireContext to hProv
82181>>>>>>>>>>>>>        If (hProv) Begin
82183>>>>>>>>>>>>>            Get CreateHash hProv to hHash
82184>>>>>>>>>>>>>            If (hHash) Begin
82186>>>>>>>>>>>>>                Get HashData hHash sPassword to bOk
82187>>>>>>>>>>>>>                If (bOk) Begin
82189>>>>>>>>>>>>>                    Get piCipher to iAlgorithm
82190>>>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
82191>>>>>>>>>>>>>                End // If (bOk) Begin            
82191>>>>>>>>>>>>>>
82191>>>>>>>>>>>>>                Get DestroyHash hHash to bOk
82192>>>>>>>>>>>>>            End // If (hHash) Begin
82192>>>>>>>>>>>>>>
82192>>>>>>>>>>>>>            
82192>>>>>>>>>>>>>            If (hKey) Begin
82194>>>>>>>>>>>>>                Move (Length(sData)) to iDataLen
82195>>>>>>>>>>>>>                Move (CryptDecrypt(hKey,0,True,0,AddressOf(sData),AddressOf(iDataLen))) to bOk
82196>>>>>>>>>>>>>                //If (bOk = False) Move "" to sData
82196>>>>>>>>>>>>>                
82196>>>>>>>>>>>>>                //  Resulting dat can be shorter as the input string, in that case we shorten the result string
82196>>>>>>>>>>>>>                If (Length(sData) > iDataLen) Begin
82198>>>>>>>>>>>>>                    Move (Left(sData, iDataLen)) to sData
82199>>>>>>>>>>>>>                End
82199>>>>>>>>>>>>>>
82199>>>>>>>>>>>>>                
82199>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
82200>>>>>>>>>>>>>            End // If (hKey) Begin
82200>>>>>>>>>>>>>>
82200>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
82201>>>>>>>>>>>>>        End // If (hProv) Begin
82201>>>>>>>>>>>>>>
82201>>>>>>>>>>>>>        Function_Return sData
82202>>>>>>>>>>>>>    End_Function
82203>>>>>>>>>>>>>    
82203>>>>>>>>>>>>>    //  Function : GenerateRandom
82203>>>>>>>>>>>>>    //  Purpose  : Generates random data.
82203>>>>>>>>>>>>>    Function GenerateRandom Integer iBytes Returns UChar[]
82205>>>>>>>>>>>>>        Handle hProv
82205>>>>>>>>>>>>>        UChar[] uaResult
82206>>>>>>>>>>>>>        Boolean bRes
82206>>>>>>>>>>>>>        
82206>>>>>>>>>>>>>        Get AcquireContext to hProv
82207>>>>>>>>>>>>>        
82207>>>>>>>>>>>>>        Move (ResizeArray(uaResult, iBytes)) to uaResult
82208>>>>>>>>>>>>>        Move (CryptGenRandom(hProv, iBytes, AddressOf(uaResult))) to bRes
82209>>>>>>>>>>>>>        
82209>>>>>>>>>>>>>        Get ReleaseContext hProv to bRes
82210>>>>>>>>>>>>>        
82210>>>>>>>>>>>>>        Function_Return uaResult
82211>>>>>>>>>>>>>    End_Function
82212>>>>>>>>>>>>>    
82212>>>>>>>>>>>>>    //  Function : GenerateRandomString
82212>>>>>>>>>>>>>    //  Purpose  : Generates random data and does a base64 encoding to properly present it as a string.
82212>>>>>>>>>>>>>    Function GenerateRandomString Integer iLenght Returns String
82214>>>>>>>>>>>>>        String sResult
82214>>>>>>>>>>>>>        UChar[] aData
82215>>>>>>>>>>>>>        Address pBase64
82215>>>>>>>>>>>>>        Integer iVoid
82215>>>>>>>>>>>>>
82215>>>>>>>>>>>>>        Get GenerateRandom iLenght to aData
82216>>>>>>>>>>>>>        
82216>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(aData), iLenght)) to pBase64
82217>>>>>>>>>>>>>        Move pBase64 to sResult
82218>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid    
82219>>>>>>>>>>>>>        
82219>>>>>>>>>>>>>        Function_Return (Left(sResult, iLenght))
82220>>>>>>>>>>>>>    End_Function
82221>>>>>>>>>>>>>
82221>>>>>>>>>>>>>End_Class
82222>>>>>>>>>>>Use Base64Functions.pkg
Including file: Base64Functions.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\Base64Functions.pkg)
82222>>>>>>>>>>>>>//> This package enables base64 encoding and decoding of strings:
82222>>>>>>>>>>>>>//>
82222>>>>>>>>>>>>>//>     Get EncodeString of oBase64Functions sValue to sValue
82222>>>>>>>>>>>>>//>     Get DecodeString of oBase64Functions sValue to sValue
82222>>>>>>>>>>>>>//>
82222>>>>>>>>>>>>>//> Remember to set the "max argument size" if dealing with very large
82222>>>>>>>>>>>>>//> strings.
82222>>>>>>>>>>>>>//>
82222>>>>>>>>>>>>>//> For 17.1 and later the functionality of this package is based on two functions (Base64Encode and
82222>>>>>>>>>>>>>//> Base64Decode) that are built into the runtime.
82222>>>>>>>>>>>>>//>
82222>>>>>>>>>>>>>//> But for versions up to and including 17.0 it's based on the vdfBase64.dll file that was obtained
82222>>>>>>>>>>>>>//> from DAE that have kindly allowed me to distribute it to other DF developers. Programs including
82222>>>>>>>>>>>>>//> this package will give off an error on start-up if vdfBase64.dll is not found in the /bin folder
82222>>>>>>>>>>>>>//> if the VDF runtime. You will find the DLL in the /programs folder of the StureApsPublicLib workspace
82222>>>>>>>>>>>>>
82222>>>>>>>>>>>>>Use VdfBase.pkg
82222>>>>>>>>>>>>>
82222>>>>>>>>>>>>>// Functions in vdfBase64.dll
82222>>>>>>>>>>>>>External_Function xxBase64Encode "vdfbase64Encode" vdfBase64.dll Pointer pBuffer Returns Integer
82223>>>>>>>>>>>>>External_Function xxBase64Decode "vdfbase64Decode" vdfBase64.dll Pointer pBuffer Returns Integer
82224>>>>>>>>>>>>>External_Function xxBase64Free   "vdfbase64Free"   vdfBase64.dll Pointer pBuffer Returns Integer
82225>>>>>>>>>>>>>
82225>>>>>>>>>>>>>// Structure
82225>>>>>>>>>>>>>Struct txxfBase64Buffer
82225>>>>>>>>>>>>>    Pointer pData
82225>>>>>>>>>>>>>    Integer iLength
82225>>>>>>>>>>>>>End_Struct
82225>>>>>>>>>>>>>
82225>>>>>>>>>>>>>Global_Variable Integer oBase64Functions
82225>>>>>>>>>>>>>
82225>>>>>>>>>>>>>Object _oBase64Functions is a cObject
82227>>>>>>>>>>>>>    Move Self to oBase64Functions
82228>>>>>>>>>>>>>
82228>>>>>>>>>>>>>
82228>>>>>>>>>>>>>    Function EncodeString String sValue Returns String
82231>>>>>>>>>>>>>        Address pBase64
82231>>>>>>>>>>>>>        String sResult
82231>>>>>>>>>>>>>        Integer iVoid
82231>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(sValue), Length(sValue))) to pBase64
82232>>>>>>>>>>>>>        Move pBase64 to sResult
82233>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
82234>>>>>>>>>>>>>        Function_Return sResult
82235>>>>>>>>>>>>>    End_Function
82236>>>>>>>>>>>>>
82236>>>>>>>>>>>>>    Function DecodeString String sValue Returns String
82239>>>>>>>>>>>>>        Address pBinary
82239>>>>>>>>>>>>>        String sBinary
82239>>>>>>>>>>>>>        Integer iVoid iLen
82239>>>>>>>>>>>>>        Move (Base64Decode(AddressOf(sValue), &iLen)) to pBinary
82240>>>>>>>>>>>>>        Move (Repeat(Character(0), iLen)) to sBinary
82241>>>>>>>>>>>>>        Move (MemCopy(AddressOf(sBinary), pBinary, iLen)) to iVoid
82242>>>>>>>>>>>>>        Move (Free(pBinary)) to iVoid
82243>>>>>>>>>>>>>        Function_Return sBinary
82244>>>>>>>>>>>>>    End_Function
82245>>>>>>>>>>>>>
82245>>>>>>>>>>>>>End_Object
82246>>>>>>>>>>>Use MSSqldrv.pkg
82246>>>>>>>>>>>Use db2_drv.pkg
82246>>>>>>>>>>>Use odbc_drv.pkg
82246>>>>>>>>>>>Use vWin32fh.pkg
82246>>>>>>>>>>>
82246>>>>>>>>>>>Use DUFLanguageConstants.inc
82246>>>>>>>>>>>Use MertechDUF.pkg
Including file: MertechDUF.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\MertechDUF.pkg)
82246>>>>>>>>>>>>>//
82246>>>>>>>>>>>>>// Use of Mertech drivers:
82246>>>>>>>>>>>>>// Put the line "Define DUF_Use_Mertech_Drivers in YOUR code prior the "Use" statement for this package if using Mertech drivers!
82246>>>>>>>>>>>>>// And put the line right before the "Use cDbUpdateHandler.pkg" line.
82246>>>>>>>>>>>>>//Define DUF_Use_Mertech_Drivers
82246>>>>>>>>>>>>>//
#REM DO ~ USE MERTECH.INC
82246>>>>>>>>>>>>>// MySQL Data Types
82246>>>>>>>>>>>>>Define eMySQL_DECIMAL                               for 0
82246>>>>>>>>>>>>>Define eMySQL_TINY                                  for 1
82246>>>>>>>>>>>>>Define eMySQL_SHORT                                 for 2
82246>>>>>>>>>>>>>Define eMySQL_LONG                                  for 3
82246>>>>>>>>>>>>>Define eMySQL_FLOAT                                 for 4
82246>>>>>>>>>>>>>Define eMySQL_DOUBLE                                for 5
82246>>>>>>>>>>>>>Define eMySQL_NULL                                  for 6
82246>>>>>>>>>>>>>Define eMySQL_TIMESTAMP                             for 7
82246>>>>>>>>>>>>>Define eMySQL_LONGLONG                              for 8
82246>>>>>>>>>>>>>Define eMySQL_INT24                                 for 9
82246>>>>>>>>>>>>>Define eMySQL_DATE                                  for 10
82246>>>>>>>>>>>>>Define eMySQL_TIME                                  for 11
82246>>>>>>>>>>>>>Define eMySQL_DATETIME                              for 12
82246>>>>>>>>>>>>>Define eMySQL_YEAR                                  for 13
82246>>>>>>>>>>>>>Define eMySQL_NEWDATE                               for 14
82246>>>>>>>>>>>>>Define eMySQL_BIT                                   for 16
82246>>>>>>>>>>>>>Define eMySQL_NEWDECIMAL                            for 246
82246>>>>>>>>>>>>>Define eMySQL_ENUM                                  for 247
82246>>>>>>>>>>>>>Define eMySQL_SET                                   for 248
82246>>>>>>>>>>>>>Define eMySQL_TINY_BLOB                             for 249
82246>>>>>>>>>>>>>Define eMySQL_MEDIUM_BLOB                           for 250
82246>>>>>>>>>>>>>Define eMySQL_LONG_BLOB                             for 251
82246>>>>>>>>>>>>>Define eMySQL_BLOB                                  for 252
82246>>>>>>>>>>>>>Define eMySQL_VAR_STRING                            for 253
82246>>>>>>>>>>>>>Define eMySQL_STRING                                for 254
82246>>>>>>>>>>>>>Define eMySQL_TINY_TEXT                             for -249
82246>>>>>>>>>>>>>Define eMySQL_MEDIUM_TEXT                           for -250
82246>>>>>>>>>>>>>Define eMySQL_LONG_TEXT                             for -251
82246>>>>>>>>>>>>>Define eMySQL_TEXT                                  for -252
82246>>>>>>>>>>>>>
82246>>>>>>>>>>>>>// Oracle Data Types
82246>>>>>>>>>>>>>Define eOracle_VARCHAR2                             for   1
82246>>>>>>>>>>>>>Define eOracle_NUMBER                               for   2
82246>>>>>>>>>>>>>Define eOracle_INT                                  for   3
82246>>>>>>>>>>>>>Define eOracle_FLOAT                                for   4
82246>>>>>>>>>>>>>Define eOracle_STRING                               for   5
82246>>>>>>>>>>>>>Define eOracle_LONG                                 for   8
82246>>>>>>>>>>>>>Define eOracle_ROWID                                for  11
82246>>>>>>>>>>>>>Define eOracle_DATE                                 for  12
82246>>>>>>>>>>>>>Define eOracle_RAW                                  for  23
82246>>>>>>>>>>>>>Define eOracle_LONGRAW                              for  24
82246>>>>>>>>>>>>>Define eOracle_CHAR                                 for  96
82246>>>>>>>>>>>>>Define eOracle_MSLABEL                              for 106
82246>>>>>>>>>>>>>Define eOracle_CLOB                                 for 112
82246>>>>>>>>>>>>>Define eOracle_BLOB                                 for 113
82246>>>>>>>>>>>>>Define eOracle_TIMESTAMP                            for 187
82246>>>>>>>>>>>>>Define eOracle_TIMESTAMPTZ                          for 188
82246>>>>>>>>>>>>>Define eOracle_INTERVALYM                           for 189
82246>>>>>>>>>>>>>Define eOracle_INTERVALDS                           for 190
82246>>>>>>>>>>>>>Define eOracle_TIMESTAMPLTZ                         for 232
82246>>>>>>>>>>>>>Define eOracle_NCHAR                                for 286
82246>>>>>>>>>>>>>Define eOracle_NVARCHAR2                            for 287
82246>>>>>>>>>>>>>Define eOracle_NCLOB                                for 288
82246>>>>>>>>>>>>>
82246>>>>>>>>>>>>>// PostgreSQL Data Types
82246>>>>>>>>>>>>>Define ePgSQL_CIRCLE                                for  718
82246>>>>>>>>>>>>>Define ePgSQL_MONEY                                 for  790
82246>>>>>>>>>>>>>Define ePgSQL_BOOL                                  for   16
82246>>>>>>>>>>>>>Define ePgSQL_BYTEA                                 for   17
82246>>>>>>>>>>>>>Define ePgSQL_CHAR                                  for   18
82246>>>>>>>>>>>>>Define ePgSQL_INT2                                  for   21
82246>>>>>>>>>>>>>Define ePgSQL_INT4                                  for   23
82246>>>>>>>>>>>>>Define ePgSQL_REGPROC                               for   24
82246>>>>>>>>>>>>>Define ePgSQL_REGPROCEDURE                          for 2202
82246>>>>>>>>>>>>>Define ePgSQL_REGOPER                               for 2203
82246>>>>>>>>>>>>>Define ePgSQL_REGOPERATOR                           for 2204
82246>>>>>>>>>>>>>Define ePgSQL_REGCLASS                              for 2205
82246>>>>>>>>>>>>>Define ePgSQL_REGTYPE                               for 2206
82246>>>>>>>>>>>>>Define ePgSQL_TEXT                                  for   25
82246>>>>>>>>>>>>>Define ePgSQL_CITEXT                                for  -25
82246>>>>>>>>>>>>>Define ePgSQL_OID                                   for   26
82246>>>>>>>>>>>>>Define ePgSQL_TID                                   for   27
82246>>>>>>>>>>>>>Define ePgSQL_XID                                   for   28
82246>>>>>>>>>>>>>Define ePgSQL_CID                                   for   29
82246>>>>>>>>>>>>>Define ePgSQL_XML                                   for  142
82246>>>>>>>>>>>>>Define ePgSQL_BPCHAR                                for 1042
82246>>>>>>>>>>>>>Define ePgSQL_VARCHAR                               for 1043
82246>>>>>>>>>>>>>Define ePgSQL_INT8                                  for   20
82246>>>>>>>>>>>>>Define ePgSQL_PATH                                  for  602
82246>>>>>>>>>>>>>Define ePgSQL_FLOAT4                                for  700
82246>>>>>>>>>>>>>Define ePgSQL_FLOAT8                                for  701
82246>>>>>>>>>>>>>Define ePgSQL_ABSTIME                               for  702
82246>>>>>>>>>>>>>Define ePgSQL_RELTIME                               for  703
82246>>>>>>>>>>>>>Define ePgSQL_TINTERVAL                             for  704
82246>>>>>>>>>>>>>Define ePgSQL_POINT                                 for  600
82246>>>>>>>>>>>>>Define ePgSQL_LINE                                  for  628
82246>>>>>>>>>>>>>Define ePgSQL_LSEG                                  for  601
82246>>>>>>>>>>>>>Define ePgSQL_BOX                                   for  603
82246>>>>>>>>>>>>>Define ePgSQL_POLYGON                               for  604
82246>>>>>>>>>>>>>Define ePgSQL_ACLITEM                               for 1033
82246>>>>>>>>>>>>>Define ePgSQL_MACADDR                               for  829
82246>>>>>>>>>>>>>Define ePgSQL_INET                                  for  869
82246>>>>>>>>>>>>>Define ePgSQL_CIDR                                  for  650
82246>>>>>>>>>>>>>Define ePgSQL_TIMESTAMP                             for 1114
82246>>>>>>>>>>>>>Define ePgSQL_DATE                                  for 1082
82246>>>>>>>>>>>>>Define ePgSQL_TIME                                  for 1083
82246>>>>>>>>>>>>>Define ePgSQL_TIMESTAMPTZ                           for 1184
82246>>>>>>>>>>>>>Define ePgSQL_INTERVAL                              for 1186
82246>>>>>>>>>>>>>Define ePgSQL_NUMERIC                               for 1700
82246>>>>>>>>>>>>>Define ePgSQL_TIMETZ                                for 1266
82246>>>>>>>>>>>>>Define ePgSQL_BIT                                   for 1560
82246>>>>>>>>>>>>>Define ePgSQL_VARBIT                                for 1562
82246>>>>>>>>>>>>>Define ePgSQL_UUID                                  for 2950
82246>>>>>>>>>>>>>
82246>>>>>>>>>>>>>// SQL Server Data Types
82246>>>>>>>>>>>>>Define eSQLServer_NA                                for    0
82246>>>>>>>>>>>>>Define eSQLServer_CHAR                              for    1
82246>>>>>>>>>>>>>Define eSQLServer_NUMERIC                           for    2
82246>>>>>>>>>>>>>Define eSQLServer_DECIMAL                           for    3
82246>>>>>>>>>>>>>Define eSQLServer_INT                               for    4
82246>>>>>>>>>>>>>Define eSQLServer_SMALLINT                          for    5
82246>>>>>>>>>>>>>Define eSQLServer_FLOAT                             for    6
82246>>>>>>>>>>>>>Define eSQLServer_REAL                              for    7
82246>>>>>>>>>>>>>Define eSQLServer_DOUBLE                            for    8
82246>>>>>>>>>>>>>Define eSQLServer_DATETIME                          for   11
82246>>>>>>>>>>>>>Define eSQLServer_VARCHAR                           for   12
82246>>>>>>>>>>>>>Define eSQLServer_DATE                              for   40
82246>>>>>>>>>>>>>Define eSQLServer_TIME                              for   41
82246>>>>>>>>>>>>>Define eSQLServer_DATETIME2                         for   42
82246>>>>>>>>>>>>>Define eSQLServer_DATETIMEOFFSET                    for   43
82246>>>>>>>>>>>>>Define eSQLServer_SMALLDATETIME                     for   58
82246>>>>>>>>>>>>>Define eSQLServer_TIMESTAMP                         for   93
82246>>>>>>>>>>>>>Define eSQLServer_HIERARCHYID                       for  128
82246>>>>>>>>>>>>>Define eSQLServer_GEOMETRY                          for  129
82246>>>>>>>>>>>>>Define eSQLServer_GEOGRAPHY                         for  130
82246>>>>>>>>>>>>>Define eSQLServer_TEXT                              for   -1
82246>>>>>>>>>>>>>Define eSQLServer_BINARY                            for   -2
82246>>>>>>>>>>>>>Define eSQLServer_VARBINARY                         for   -3
82246>>>>>>>>>>>>>Define eSQLServer_IMAGE                             for   -4
82246>>>>>>>>>>>>>Define eSQLServer_BIGINT                            for   -5
82246>>>>>>>>>>>>>Define eSQLServer_TINYINT                           for   -6
82246>>>>>>>>>>>>>Define eSQLServer_BIT                               for   -7
82246>>>>>>>>>>>>>Define eSQLServer_NCHAR                             for   -8
82246>>>>>>>>>>>>>Define eSQLServer_NVARCHAR                          for   -9
82246>>>>>>>>>>>>>Define eSQLServer_NTEXT                             for  -10
82246>>>>>>>>>>>>>Define eSQLServer_GUID                              for  -11
82246>>>>>>>>>>>>>Define eSQLServer_VARBINARYMAX                      for  -98
82246>>>>>>>>>>>>>Define eSQLServer_VARCHARMAX                        for  -99
82246>>>>>>>>>>>>>Define eSQLServer_NVARCHARMAX                       for -100
82246>>>>>>>>>>>>>Define eSQLServer_SQLVARIANT                        for -150
82246>>>>>>>>>>>>>Define eSQLServer_XML                               for -370
82246>>>>>>>>>>>>>
82246>>>>>>>>>>>>>Use cDbUpdateFunctionLibrary.inc
82246>>>>>>>>>>>
82246>>>>>>>>>>>// This needs to be after Mertech drivers are defined.
82246>>>>>>>>>>>Use cDbUpdateFunctionLibrary_Mixin.pkg
82246>>>>>>>>>>>
82246>>>>>>>>>>>
82246>>>>>>>>>>>    Define SQLFLEX   for "SQL_DRV"
82246>>>>>>>>>>>
82246>>>>>>>>>>>    Define MDSPgSQL  for "MDSPGSQL"
82246>>>>>>>>>>>
82246>>>>>>>>>>>    Define MDSMySQL  for "MDSMYSQL"
82246>>>>>>>>>>>
82246>>>>>>>>>>>    Define ORAFLEX   for "ORA_DRV"
82246>>>>>>>>>>>
82246>>>>>>>>>>>
82246>>>>>>>>>>>// SQLConnection.ini constants:
82246>>>>>>>>>>>    Define CS_SQLConnectionIDText       for "DFConnectionId"
82246>>>>>>>>>>>Define CS_SQLIniFileName                for "SQLConnections.ini"
82246>>>>>>>>>>>Define CS_SQLDF19IniFileName            for "DFConnId.ini"
82246>>>>>>>>>>>Define CS_SQLIniConnectionSection       for "SQL Connections" // Obsolete!
82246>>>>>>>>>>>Define CS_SQLIniSectionName             for "Connection"
82246>>>>>>>>>>>
82246>>>>>>>>>>>// DF 19 ini-file settings:
82246>>>>>>>>>>>Define CS_SQLIniConnectionIdKeyword     for "Id"
82246>>>>>>>>>>>Define CS_SQLIniDriverKeyword           for "Driver"
82246>>>>>>>>>>>Define CS_SQLIniConnectionKeyWord       for "Connection"
82246>>>>>>>>>>>Define CS_SQLIniUIDKeyword              for "UID"
82246>>>>>>>>>>>Define CS_SQLIniPWDKeyword              for "PWD"
82246>>>>>>>>>>>Define CS_SQLIniDFPWDKeyword            for "DFPWD"
82246>>>>>>>>>>>Define CS_SQLIniServerKeyword           for "SERVER"
82246>>>>>>>>>>>Define CS_SQLIniDSNKeyword              for "DSN"
82246>>>>>>>>>>>Define CS_SQLIniDatabaseKeyword         for "DATABASE"
82246>>>>>>>>>>>Define CS_SQLIniTrustedKeyword          for "Trusted_Connection"
82246>>>>>>>>>>>
82246>>>>>>>>>>>// Database Update Framework extended settings:
82246>>>>>>>>>>>Define CS_SQLIniDbTypeKeyword           for "DbType"
82246>>>>>>>>>>>Define CS_SQLIniSchemaKeyword           for "Schema"
82246>>>>>>>>>>>Define CS_SQLIniBaseTableSpaceKeyword   for "Base Table Space"
82246>>>>>>>>>>>Define CS_SQLIniLongTableSpaceKeyword   for "Long Table Space"
82246>>>>>>>>>>>Define CS_SQLIniIndexTableSpaceKeyword  for "Index Table Space"
82246>>>>>>>>>>>Define CS_SQLIniSilentLoginKeyword      for "Silent Login"
82246>>>>>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"      // For compatability with DF19.
82246>>>>>>>>>>>
82246>>>>>>>>>>>Define CS_SQLIniConnectionPWD           for "PWD"
82246>>>>>>>>>>>Define CS_SQLIniConnectionYes           for "Yes"
82246>>>>>>>>>>>Define CS_SQLIniConnectionNo            for "No"
82246>>>>>>>>>>>
82246>>>>>>>>>>>Struct tSQLConnection
82246>>>>>>>>>>>    Boolean bEnabled                // 1. There can only be one active/enabled connection at a time.
82246>>>>>>>>>>>    String sConnectionID            // 2. The name of the connection ID.
82246>>>>>>>>>>>    Integer iDbType                 // 3. Database type; "MS-SQL Server", "DB2", "Oracle", "MySQL", "PostgreSQL"
82246>>>>>>>>>>>    String sDriverID                // 4. Name of the driver. E.g. "MSSQLDRV", "DB2_DRV" or "ODBC_DRV".
82246>>>>>>>>>>>    String sServer                  // 5. SQL Server/DSN/ODBC source name. (In DF19 this is the "sString" member of the tConnection struct.)
82246>>>>>>>>>>>    String sDatabase                // 6. SQL Database
82246>>>>>>>>>>>    String sConnectionString        // 7. Full connection string as is needed by e.g. the login command.
82246>>>>>>>>>>>    Boolean bTrusted                // 8. Trusted connection (then is UID & PWD not used)
82246>>>>>>>>>>>    String sUserID                  // 9. User ID
82246>>>>>>>>>>>    String sPassword                // 10. Password
82246>>>>>>>>>>>    String sSchema                  // 11. DB2 (and perhaps ODBC specific)
82246>>>>>>>>>>>    String sBaseTableSpace          // 12. DB2 specific
82246>>>>>>>>>>>    String sLongTableSpace          // 13. DB2 specific
82246>>>>>>>>>>>    String sIndexTableSpace         // 14. DB2 specific
82246>>>>>>>>>>>    Boolean bSilentLogin            // 15. True=Silent login. (i.e. don't show Database login dialog if database login to fails). Same as driver "Options" parameter.
82246>>>>>>>>>>>    Boolean bError                  // 16. Set to true on error.
82246>>>>>>>>>>>    Boolean bDAWConnection          // 17. True if a DFConnId.ini file (from DAW) has been used instead of a DUF SQLConnections.ini file.
82246>>>>>>>>>>>//    Boolean bDisabled               // 17. For compatability with DF19 Managed Connections only. Not used by DUF (Database Update Framework).
82246>>>>>>>>>>>//    Integer iDriverIndex            // 18. For compatability with DF19 Managed Connections only. Not used by DUF (Database Update Framework).
82246>>>>>>>>>>>End_Struct
82246>>>>>>>>>
82246>>>>>>>>>Class cDbUpdateFunctionLibrary_Mixin is a Mixin
82247>>>>>>>>>    Procedure CreateDbUpdateLibraryProperties
82249>>>>>>>>>        Handle hoSQLManagerMT
82249>>>>>>>>>
82249>>>>>>>>>        Property String Private.psUseDatabase ""
82250>>>>>>>>>
82250>>>>>>>>>//        { Visibility=Private }
82250>>>>>>>>>        // These are used by the Error routine to show the Table# & Field# if something goes wrong:
82250>>>>>>>>>        Property Handle  Private.phCurrentTable 0
82251>>>>>>>>>        Property Integer Private.piCurrentField 0
82252>>>>>>>>>
82252>>>>>>>>>        Property Handle phoCLIHandler      (Create(Self,RefClass(cCLIHandler)))
82253>>>>>>>>>        Property Handle phoSQLManager      (Create(Self,RefClass(cSQLHandleManager)))
82254>>>>>>>>>
82254>>>>>>>>>        Property Handle phoSQLManagerMT
82255>>>>>>>>>
82255>>>>>>>>>        Property Handle phoMSSQLHandler    (Create(Self,RefClass(cMSSQLHandler)))
82256>>>>>>>>>        Property Handle phoDB2SQLHandler   (Create(Self,RefClass(cDB2Handler)))
82257>>>>>>>>>        Property Handle phoODBCSQLHandler  (Create(Self,RefClass(cODBCHandler)))
82258>>>>>>>>>        Property Handle phoSQLConnectionHandler 0
82259>>>>>>>>>        Property tSQLKeyWords[] paSQLKeywordArray
82260>>>>>>>>>
82260>>>>>>>>>        Property Boolean pbHandleQueryErrors True
82261>>>>>>>>>
82261>>>>>>>>>        Property tSqlColumnNew[] paQueryColumns
82262>>>>>>>>>        Property String[] paSQLFetchResults
82263>>>>>>>>>
82263>>>>>>>>>        // Error handling     
82263>>>>>>>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT        
82264>>>>>>>>>        Property Boolean pbSqlError False
82265>>>>>>>>>        Property tSqlErrorArray paSqlErrorArray
82266>>>>>>>>>        Property Boolean pbProcessingError False
82267>>>>>>>>>
82267>>>>>>>>>        // Statistics on query
82267>>>>>>>>>        Property TimeSpan ptsTotalQueryTime
82268>>>>>>>>>        Property TimeSpan ptsQueryExec
82269>>>>>>>>>        Property TimeSpan ptsFetchResults
82270>>>>>>>>>        Property Integer piColumns 0
82271>>>>>>>>>        Property Integer piRows 0
82272>>>>>>>>>        Property Integer piRowType 0
82273>>>>>>>>>        Property String[] paQueryMessages
82274>>>>>>>>>        Property String psSQLStatementString
82275>>>>>>>>>
82275>>>>>>>>>        Property Integer[] paTableConvertExceptions
82276>>>>>>>>>
82276>>>>>>>>>        Property Integer[] paTableDateCorrectionExceptions
82277>>>>>>>>>
82277>>>>>>>>>        // Number of SQL statements (chunks) to be executed when executing a really big
82277>>>>>>>>>        // SQL file that has been compiled into the program. It is way faster to divide
82277>>>>>>>>>        // the statements in smaller chunks than to execute them all at the same time.
82277>>>>>>>>>        Property Integer piChunkMax 500
82278>>>>>>>>>
82278>>>>>>>>>        // Fill the paSQLKeywordArray array with values;
82278>>>>>>>>>        Send SetupSQLKeywordArray
82279>>>>>>>>>    End_Procedure
82280>>>>>>>>>
82280>>>>>>>>>    // Custom array find function. It compares both the iSQLWord & iSQLDbType params.
82280>>>>>>>>>    Function CompareFindSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
82282>>>>>>>>>        If (SQLKeywords1.iSQLWord = SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType = SQLKeywords2.iSQLDbType) Begin
82284>>>>>>>>>            Function_Return (EQ)
82285>>>>>>>>>        End
82285>>>>>>>>>>
82285>>>>>>>>>        Function_Return (GT)
82286>>>>>>>>>    End_Function
82287>>>>>>>>>
82287>>>>>>>>>    // Custom array sort function. It compares both the iSQLWord & iSQLDbType params.
82287>>>>>>>>>    Function CompareSortSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
82289>>>>>>>>>        If (SQLKeywords1.iSQLWord   < SQLKeywords2.iSQLWord) ;            Function_Return (LT)
82292>>>>>>>>>        If (SQLKeywords1.iSQLWord   > SQLKeywords2.iSQLWord) ;            Function_Return (GT)
82295>>>>>>>>>        If (SQLKeywords1.iSQLDbType < SQLKeywords2.iSQLDbType) ;            Function_Return (LT)
82298>>>>>>>>>        If (SQLKeywords1.iSQLDbType > SQLKeywords2.iSQLDbType) ;            Function_Return (GT)
82301>>>>>>>>>
82301>>>>>>>>>        Function_Return (EQ)
82302>>>>>>>>>    End_Function
82303>>>>>>>>>
82303>>>>>>>>>    Procedure Add_Element Integer iSQLKeywordConstant Integer iEN_dbType String sSQLKeyword
82305>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
82305>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
82306>>>>>>>>>        Integer iSize
82306>>>>>>>>>
82306>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
82307>>>>>>>>>        Move (SizeOfArray(SQLKeywordArray)) to iSize
82308>>>>>>>>>        Move iSQLKeywordConstant to SQLKeywordArray[iSize].iSQLWord
82309>>>>>>>>>        Move iEN_dbType          to SQLKeywordArray[iSize].iSQLDbType
82310>>>>>>>>>        Move sSQLKeyword         to SQLKeywordArray[iSize].sSQLPhrase
82311>>>>>>>>>
82311>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
82312>>>>>>>>>    End_Procedure
82313>>>>>>>>>
82313>>>>>>>>>    // Creates a struct array with all SQL keywords
82313>>>>>>>>>    // for all EN_xxx SQL back-ends. Various back-ends can
82313>>>>>>>>>    // have slightly different wording.
82313>>>>>>>>>    // If a new EN_dbTypexxx type is added; additions
82313>>>>>>>>>    // needs to be done for every keyword group below.
82313>>>>>>>>>    Procedure SetupSQLKeywordArray
82315>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
82315>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
82317>>>>>>>>>
82317>>>>>>>>>        // This should only be called once; but in case it is
82317>>>>>>>>>        // we delete the array first.
82317>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
82318>>>>>>>>>
82318>>>>>>>>>        // ToDo: *** Not all SQL Key-words has been checked for other backends than MS-SQL ***
82318>>>>>>>>>        //
82318>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMSSQL    "ALTER DATABASE"
82319>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMySQL    "ALTER DATABASE"
82320>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeOracle   "ALTER DATABASE"
82321>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeDB2      "ALTER DATABASE"
82322>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypePostgre  "ALTER DATABASE"  
82323>>>>>>>>>        
82323>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMSSQL    "SINGLE_USER"
82324>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMySQL    "SINGLE_USER"
82325>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeOracle   "SINGLE_USER"
82326>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeDB2      "SINGLE_USER"
82327>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypePostgre  "SINGLE_USER"  
82328>>>>>>>>>        
82328>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMSSQL    "MULTI_USER"
82329>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMySQL    "MULTI_USER"
82330>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeOracle   "MULTI_USER"
82331>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeDB2      "MULTI_USER"
82332>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypePostgre  "MULTI_USER"  
82333>>>>>>>>>        
82333>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMSSQL    "ROLLBACK"
82334>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMySQL    "ROLLBACK"
82335>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeOracle   "ROLLBACK"
82336>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeDB2      "ROLLBACK"
82337>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypePostgre  "ROLLBACK"  
82338>>>>>>>>>        
82338>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMSSQL    "IMMEDIATE"
82339>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMySQL    "IMMEDIATE"
82340>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeOracle   "IMMEDIATE"
82341>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeDB2      "IMMEDIATE"
82342>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypePostgre  "IMMEDIATE"  
82343>>>>>>>>>        
82343>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMSSQL    "ALTER TABLE"
82344>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMySQL    "ALTER TABLE"
82345>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeOracle   "ALTER TABLE"
82346>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeDB2      "ALTER TABLE"
82347>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypePostgre  "ALTER TABLE"
82348>>>>>>>>>
82348>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMSSQL           "ADD"
82349>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMySQL           "ADD"
82350>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeOracle          "ADD"
82351>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeDB2             "ADD"
82352>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypePostgre         "ADD"
82353>>>>>>>>>
82353>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMSSQL        "UPDATE"
82354>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMySQL        "UPDATE"
82355>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeOracle       "UPDATE"
82356>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeDB2          "UPDATE"
82357>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypePostgre      "UPDATE"
82358>>>>>>>>>
82358>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMSSQL       "NOT NULL"
82359>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMySQL       "NOT NULL"
82360>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeOracle      "" // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
82361>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeDB2         "DEFAULT NOT NULL"
82362>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypePostgre     "NOT NULL"
82363>>>>>>>>>
82363>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMSSQL           "SET"
82364>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMySQL           "SET"
82365>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeOracle          "SET"
82366>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeDB2             "SET"
82367>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypePostgre         "SET"
82368>>>>>>>>>
82368>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMSSQL          "WITH"
82369>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMySQL          "WITH"
82370>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeOracle         "WITH"
82371>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeDB2            "WITH"
82372>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypePostgre        "WITH"
82373>>>>>>>>>
82373>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMSSQL    "CREATE DATABASE"
82374>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMySQL    "CREATE DATABASE"
82375>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeOracle   "CREATE DATABASE"
82376>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeDB2      "CREATE DATABASE"
82377>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypePostgre  "CREATE DATABASE"
82378>>>>>>>>>
82378>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMSSQL    "COLLATE"
82379>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMySQL    "COLLATE"
82380>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeOracle   "COLLATE"
82381>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeDB2      "COLLATE"
82382>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypePostgre  "COLLATE"
82383>>>>>>>>>
82383>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMSSQL    "CREATE VIEW"
82384>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMySQL    "CREATE VIEW"
82385>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeOracle   "CREATE VIEW"
82386>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeDB2      "CREATE VIEW"
82387>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypePostgre  "CREATE VIEW"
82388>>>>>>>>>
82388>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMSSQL      "DROP VIEW"
82389>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMySQL      "DROP VIEW"
82390>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeOracle     "DROP VIEW"
82391>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeDB2        "DROP VIEW"
82392>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypePostgre    "DROP VIEW"
82393>>>>>>>>>
82393>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMSSQL   "CREATE TABLE"
82394>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMySQL   "CREATE TABLE"
82395>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeOracle  "CREATE TABLE"
82396>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeDB2     "CREATE TABLE"
82397>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypePostgre "CREATE TABLE"
82398>>>>>>>>>
82398>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMSSQL     "DROP TABLE"
82399>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMySQL     "DROP TABLE"
82400>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeOracle    "DROP TABLE"
82401>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeDB2       "DROP TABLE"
82402>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypePostgre   "DROP TABLE"
82403>>>>>>>>>
82403>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMSSQL   "EXEC sp_rename"
82404>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMySQL   "RENAME TABLE"
82405>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeOracle  "RENAME TABLE"
82406>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeDB2     "RENAME TABLE"
82407>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypePostgre "RENAME TO"
82408>>>>>>>>>
82408>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMSSQL    "DROP COLUMN"
82409>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMySQL    "DROP COLUMN"
82410>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeOracle   "DROP COLUMN"
82411>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeDB2      "DROP COLUMN"
82412>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypePostgre  "DROP COLUMN"
82413>>>>>>>>>
82413>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMSSQL        "COLUMN"
82414>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMySQL        "COLUMN"
82415>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeOracle       "COLUMN"
82416>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeDB2          "COLUMN"
82417>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypePostgre      "COLUMN"
82418>>>>>>>>>
82418>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMSSQL   "ALTER COLUMN"
82419>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMySQL   "MODIFY"
82420>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeOracle  "MODIFY"
82421>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeDB2     "ALTER COLUMN"
82422>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypePostgre "ALTER COLUMN"
82423>>>>>>>>>
82423>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMSSQL   "EXEC sp_RENAME"
82424>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMySQL   "CHANGE"
82425>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeOracle  "RENAME COLUMN"
82426>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeDB2     "RENAME COLUMN"
82427>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypePostgre "RENAME COLUMN"
82428>>>>>>>>>
82428>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMSSQL        "SELECT"
82429>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMySQL        "SELECT"
82430>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeOracle       "SELECT"
82431>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeDB2          "SELECT"
82432>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypePostgre      "SELECT"
82433>>>>>>>>>
82433>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMSSQL         "WHERE"
82434>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMySQL         "WHERE"
82435>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeOracle        "WHERE"
82436>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeDB2           "WHERE"
82437>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypePostgre       "WHERE"
82438>>>>>>>>>
82438>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMSSQL          "FROM"
82439>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMySQL          "FROM"
82440>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeOracle         "FROM"
82441>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeDB2            "FROM"
82442>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypePostgre        "FROM"
82443>>>>>>>>>
82443>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMSSQL    "INFORMATION_SCHEMA.COLUMNS"
82444>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMySQL    "INFORMATION_SCHEMA.COLUMNS"
82445>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeOracle   "INFORMATION_SCHEMA.COLUMNS"
82446>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeDB2      "INFORMATION_SCHEMA.COLUMNS"
82447>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypePostgre  "INFORMATION_SCHEMA.COLUMNS"
82448>>>>>>>>>
82448>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMSSQL    "TABLE_NAME"
82449>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMySQL    "TABLE_NAME"
82450>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeOracle   "TABLE_NAME"
82451>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeDB2      "TABLE_NAME"
82452>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypePostgre  "TABLE_NAME"
82453>>>>>>>>>
82453>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMSSQL         "TABLE"
82454>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMySQL         "TABLE"
82455>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeOracle        "TABLE"
82456>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeDB2           "TABLE"
82457>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypePostgre       "TABLE"
82458>>>>>>>>>
82458>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMSSQL           "SYS"
82459>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMySQL           "SYS"
82460>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeOracle          "SYS"
82461>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeDB2             "SYS"
82462>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypePostgre         "SYS"
82463>>>>>>>>>
82463>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMSSQL       "SP_HELP"
82464>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMySQL       "SP_HELP"
82465>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeOracle      "SP_HELP"
82466>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeDB2         "SP_HELP"
82467>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypePostgre     "SP_HELP"
82468>>>>>>>>>
82468>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMSSQL      "SET NOCOUNT ON"
82469>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMySQL      "SET NOCOUNT ON"
82470>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeOracle     "SET NOCOUNT ON"
82471>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeDB2        "SET NOCOUNT ON"
82472>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypePostgre    "SET NOCOUNT ON"
82473>>>>>>>>>
82473>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMSSQL            "TO"
82474>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMySQL            "TO"
82475>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeOracle           "TO"
82476>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeDB2              "TO"
82477>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypePostgre          "TO"
82478>>>>>>>>>
82478>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMSSQL            "GO"
82479>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMySQL            "GO"
82480>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeOracle           "GO"
82481>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeDB2              "GO"
82482>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypePostgre          "GO"
82483>>>>>>>>>
82483>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMSSQL           "USE"
82484>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMySQL           "USE"
82485>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeOracle          "USE"
82486>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeDB2             "USE"
82487>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypePostgre         "USE"
82488>>>>>>>>>
82488>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMSSQL           "dbo"
82489>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMySQL           "dbo"
82490>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeOracle          "dbo"
82491>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeDB2             "dbo"
82492>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypePostgre         "dbo"
82493>>>>>>>>>
82493>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMSSQL        "MASTER"
82494>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMySQL        "MASTER"
82495>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeOracle       "MASTER"
82496>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeDB2          "MASTER"
82497>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypePostgre      "MASTER"
82498>>>>>>>>>
82498>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMSSQL          "NAME"
82499>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMySQL          "NAME"
82500>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeOracle         "NAME"
82501>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeDB2            "NAME"
82502>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypePostgre        "NAME"
82503>>>>>>>>>
82503>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMSSQL     "DATABASES"
82504>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMySQL     "DATABASES"
82505>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeOracle    "DATABASES"
82506>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeDB2       "DATABASES"
82507>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypePostgre   "DATABASES"
82508>>>>>>>>>
82508>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMSSQL    "SYS.INDEXES"
82509>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMySQL    "SYS.INDEXES"
82510>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeOracle   "SYS.INDEXES"
82511>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeDB2      "SYS.INDEXES"
82512>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypePostgre  "SYS.INDEXES"
82513>>>>>>>>>
82513>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMSSQL      "OBJECT_ID"
82514>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMySQL      "OBJECT_ID"
82515>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeOracle     "OBJECT_ID"
82516>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeDB2        "OBJECT_ID"
82517>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypePostgre    "OBJECT_ID"
82518>>>>>>>>>
82518>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMSSQL            "ID"
82519>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMySQL            "ID"
82520>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeOracle           "ID"
82521>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeDB2              "ID"
82522>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypePostgre          "ID"
82523>>>>>>>>>
82523>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMSSQL           "AND"
82524>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMySQL           "AND"
82525>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeOracle          "AND"
82526>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeDB2             "AND"
82527>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypePostgre         "AND"
82528>>>>>>>>>
82528>>>>>>>>>        // In case we didn't put the above in order (and we don't need to); we sort the struct array.
82528>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
82529>>>>>>>>>        Move (SortArray(SQLKeywordArray, Self, (RefFunc(CompareSortSQLKeyWords)))) to SQLKeywordArraySorted
82530>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArraySorted
82531>>>>>>>>>
82531>>>>>>>>>    End_Procedure
82532>>>>>>>>>
82532>>>>>>>>>End_Class
82533>>>>>>>Use cSQLConnectionHandler.pkg
Including file: cSQLConnectionHandler.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cSQLConnectionHandler.pkg)
82533>>>>>>>>>//****************************************************************************
82533>>>>>>>>>// $Module type: Class
82533>>>>>>>>>// $Module name: cSQLConnectionHandler.pkg
82533>>>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
82533>>>>>>>>>// Web-site    : http://www.rdctools.com
82533>>>>>>>>>// Created     : 2015-08-11 @ 16:02 (Military date format: YY-MM-DD)
82533>>>>>>>>>//
82533>>>>>>>>>// Description : A handler class for using CLI connection ID's to login to a database server.
82533>>>>>>>>>//
82533>>>>>>>>>// $Rev History:
82533>>>>>>>>>//    2015-08-11  Module header created
82533>>>>>>>>>//    2016-09-26  Changed name of the objecthandle from ghoCreateConnectionID to ghoSQLConnectionHandler.
82533>>>>>>>>>//                Added a new structure for passing connection data back & forth.
82533>>>>>>>>>//                Added better error handling.
82533>>>>>>>>>//                Added a decompose message for the connection string.
82533>>>>>>>>>//    2017-01-09  Added support for Mertech drivers
82533>>>>>>>>>//                Big overhaul to comply better with "Managed Connections" (DF 19)
82533>>>>>>>>>//                These changes make the class compatible with DFConnId.ini (can read/write DAW connection ini-files)
82533>>>>>>>>>//    2017-02-12  Reworked the whole connection property interface.
82533>>>>>>>>>//                Now there is one struct property that is the at cencter of a connection.
82533>>>>>>>>>//****************************************************************************
82533>>>>>>>>>Use cli.pkg
82533>>>>>>>>>Use MSSqldrv.pkg
82533>>>>>>>>>Use db2_drv.pkg
82533>>>>>>>>>Use odbc_drv.pkg
82533>>>>>>>>>Use cSQLConnectionIniFile.pkg
Including file: cSQLConnectionIniFile.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.pkg)
82533>>>>>>>>>>>//****************************************************************************
82533>>>>>>>>>>>// $Module type: Class
82533>>>>>>>>>>>// $Module name: cSQLConnectionIniFile.pkg
82533>>>>>>>>>>>//
82533>>>>>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
82533>>>>>>>>>>>// Copyright (c) 2012 RDC Tools International
82533>>>>>>>>>>>// E-mail      : support@rdctools.com
82533>>>>>>>>>>>// Web-site    : http://www.rdctools.com
82533>>>>>>>>>>>//
82533>>>>>>>>>>>// Created     : 2012-09-20 @ 18:04 (Military date format - Year-Month-Day)
82533>>>>>>>>>>>//
82533>>>>>>>>>>>// Note        : The file must be USEd after declaration of the ghoApplication object, as it uses
82533>>>>>>>>>>>//               properties of that object.
82533>>>>>>>>>>>//
82533>>>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
82533>>>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
82533>>>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
82533>>>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
82533>>>>>>>>>>>// in the help folder for more details.
82533>>>>>>>>>>>//
82533>>>>>>>>>>>Use cSQLConnectionIniFile.inc
82533>>>>>>>>>>>Use cDbUpdateDatabaseDriver.pkg
Including file: cDbUpdateDatabaseDriver.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateDatabaseDriver.pkg)
82533>>>>>>>>>>>>>Use cSQLConnectionIniFile.inc
82533>>>>>>>>>>>>>
82533>>>>>>>>>>>>>Class cDbUpdateGenericDatabaseDriver is a cObject
82534>>>>>>>>>>>>>    Procedure Construct_Object
82536>>>>>>>>>>>>>        Forward Send Construct_Object
82538>>>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
82539>>>>>>>>>>>>>    End_Procedure
82540>>>>>>>>>>>>>
82540>>>>>>>>>>>>>    Function ServerKeyword Returns String
82542>>>>>>>>>>>>>        Function_Return CS_SQLIniDSNKeyword
82543>>>>>>>>>>>>>    End_Function
82544>>>>>>>>>>>>>
82544>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
82546>>>>>>>>>>>>>        String sConnect
82546>>>>>>>>>>>>>
82546>>>>>>>>>>>>>        Move (sConnect * ServerKeyword(Self) + "=" + sServer) to sConnect
82547>>>>>>>>>>>>>        If (sDatabase <> "") Begin
82549>>>>>>>>>>>>>            Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
82550>>>>>>>>>>>>>        End
82550>>>>>>>>>>>>>>
82550>>>>>>>>>>>>>        If (bTrusted = True) Begin
82552>>>>>>>>>>>>>            Move (sConnect * ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
82553>>>>>>>>>>>>>        End
82553>>>>>>>>>>>>>>
82553>>>>>>>>>>>>>        Else Begin
82554>>>>>>>>>>>>>            Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
82555>>>>>>>>>>>>>        End
82555>>>>>>>>>>>>>>
82555>>>>>>>>>>>>>        Function_Return sConnect
82556>>>>>>>>>>>>>    End_Function
82557>>>>>>>>>>>>>
82557>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
82559>>>>>>>>>>>>>        Boolean bLoginSuccessful
82559>>>>>>>>>>>>>        String sDriverID
82559>>>>>>>>>>>>>
82559>>>>>>>>>>>>>        Get psDriverID to sDriverID
82560>>>>>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
82562>>>>>>>>>>>>>            Function_Return True
82563>>>>>>>>>>>>>        End
82563>>>>>>>>>>>>>>
82563>>>>>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
82564>>>>>>>>>>>>>        If (bTrusted = False) Begin
82566>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID
82568>>>>>>>>>>>>>        End
82568>>>>>>>>>>>>>>
82568>>>>>>>>>>>>>        Else Begin
82569>>>>>>>>>>>>>            Login sConnectionString "" "" sDriverID
82571>>>>>>>>>>>>>        End
82571>>>>>>>>>>>>>>
82571>>>>>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
82572>>>>>>>>>>>>>        Function_Return bLoginSuccessful
82573>>>>>>>>>>>>>    End_Function
82574>>>>>>>>>>>>>End_Class
82575>>>>>>>>>>>>>
82575>>>>>>>>>>>>>Class cDbUpdateMSSQLDriver is a cDbUpdateGenericDatabaseDriver
82576>>>>>>>>>>>>>    Function ServerKeyword Returns String
82578>>>>>>>>>>>>>        Function_Return CS_SQLIniServerKeyword
82579>>>>>>>>>>>>>    End_Function
82580>>>>>>>>>>>>>End_Class
82581>>>>>>>>>>>>>
82581>>>>>>>>>>>>>Class cDbUpdateODBCDriver is a cDbUpdateGenericDatabaseDriver
82582>>>>>>>>>>>>>End_Class
82583>>>>>>>>>>>>>
82583>>>>>>>>>>>>>Class cDbUpdateDB2Driver is a cDbUpdateGenericDatabaseDriver
82584>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
82586>>>>>>>>>>>>>        Boolean bLoginSuccessful
82586>>>>>>>>>>>>>        String sDriverID
82586>>>>>>>>>>>>>
82586>>>>>>>>>>>>>        Move False to Err
82587>>>>>>>>>>>>>        Get psDriverID to sDriverID
82588>>>>>>>>>>>>>        If (not(Uppercase(sServer) contains "DSN")) Begin
82590>>>>>>>>>>>>>            Move ("DSN=" + sServer) to sServer
82591>>>>>>>>>>>>>        End
82591>>>>>>>>>>>>>>
82591>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
82593>>>>>>>>>>>>>
82593>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
82594>>>>>>>>>>>>>        Function_Return bLoginSuccessful
82595>>>>>>>>>>>>>    End_Function
82596>>>>>>>>>>>>>End_Class
82597>>>>>>>>>>>>>
82597>>>>>>>>>>>>>Class cDbUpdateDataFlexDriver is a cDbUpdateGenericDatabaseDriver
82598>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
82600>>>>>>>>>>>>>        Function_Return ""
82601>>>>>>>>>>>>>    End_Function
82602>>>>>>>>>>>>>End_Class
82603>>>>>>>>>>>>>
82603>>>>>>>>>>>>>Class cDbUpdateSQLFLEXDriver is a cDbUpdateGenericDatabaseDriver
82604>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
82606>>>>>>>>>>>>>        Boolean bLoginSuccessful
82606>>>>>>>>>>>>>        String sDriverID
82606>>>>>>>>>>>>>
82606>>>>>>>>>>>>>        Get psDriverID to sDriverID
82607>>>>>>>>>>>>>        //For the Mertech driver, using the Err indicator is the sanctioned way
82607>>>>>>>>>>>>>        Move False to Err
82608>>>>>>>>>>>>>        If (bTrusted = False) Begin
82610>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID
82612>>>>>>>>>>>>>        End
82612>>>>>>>>>>>>>>
82612>>>>>>>>>>>>>        Else Begin
82613>>>>>>>>>>>>>            Login sServer "" "" sDriverID
82615>>>>>>>>>>>>>        End
82615>>>>>>>>>>>>>>
82615>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
82616>>>>>>>>>>>>>
82616>>>>>>>>>>>>>        Function_Return bLoginSuccessful
82617>>>>>>>>>>>>>    End_Function
82618>>>>>>>>>>>>>End_Class
82619>>>>>>>>>>>>>
82619>>>>>>>>>>>>>Class cDbUpdateORAFLEXDriver is a cDbUpdateGenericDatabaseDriver
82620>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
82622>>>>>>>>>>>>>        Boolean bLoginSuccessful
82622>>>>>>>>>>>>>        String sDriverID
82622>>>>>>>>>>>>>        Integer iPos
82622>>>>>>>>>>>>>
82622>>>>>>>>>>>>>        Get psDriverID to sDriverID
82623>>>>>>>>>>>>>        Move (Pos("/", sServer)) to iPos
82624>>>>>>>>>>>>>        If (iPos = 0) Begin
82626>>>>>>>>>>>>>            If (sDatabase <> "") Begin
82628>>>>>>>>>>>>>                Move (sServer + "/" + sDatabase) to sServer
82629>>>>>>>>>>>>>            End
82629>>>>>>>>>>>>>>
82629>>>>>>>>>>>>>        End
82629>>>>>>>>>>>>>>
82629>>>>>>>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
82629>>>>>>>>>>>>>        Move False to Err
82630>>>>>>>>>>>>>        // For Oracle I don't believe "Trusted" doesn't exist.
82630>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
82632>>>>>>>>>>>>>
82632>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
82633>>>>>>>>>>>>>        Function_Return bLoginSuccessful
82634>>>>>>>>>>>>>    End_Function
82635>>>>>>>>>>>>>End_Class
82636>>>>>>>>>>>>>
82636>>>>>>>>>>>>>Class cDbUpdateMDSMySQLDriver is a cDbUpdateGenericDatabaseDriver
82637>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
82639>>>>>>>>>>>>>        Boolean bLoginSuccessful
82639>>>>>>>>>>>>>        String sDriverID
82639>>>>>>>>>>>>>
82639>>>>>>>>>>>>>        Get psDriverID to sDriverID
82640>>>>>>>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
82640>>>>>>>>>>>>>        Move False to Err
82641>>>>>>>>>>>>>        If (bTrusted = False) Begin
82643>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID
82645>>>>>>>>>>>>>        End
82645>>>>>>>>>>>>>>
82645>>>>>>>>>>>>>        Else Begin
82646>>>>>>>>>>>>>            Login sServer "" "" sDriverID
82648>>>>>>>>>>>>>        End
82648>>>>>>>>>>>>>>
82648>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
82649>>>>>>>>>>>>>        Function_Return bLoginSuccessful
82650>>>>>>>>>>>>>    End_Function
82651>>>>>>>>>>>>>End_Class
82652>>>>>>>>>>>>>
82652>>>>>>>>>>>>>Class cDbUpdateMDSPgSQLDriver is a cDbUpdateGenericDatabaseDriver
82653>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
82655>>>>>>>>>>>>>        Boolean bLoginSuccessful
82655>>>>>>>>>>>>>        String sDriverID
82655>>>>>>>>>>>>>
82655>>>>>>>>>>>>>        Get psDriverID to sDriverID
82656>>>>>>>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
82656>>>>>>>>>>>>>        Move False to Err
82657>>>>>>>>>>>>>        If (bTrusted = False) Begin
82659>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID
82661>>>>>>>>>>>>>        End
82661>>>>>>>>>>>>>>
82661>>>>>>>>>>>>>        Else Begin
82662>>>>>>>>>>>>>            Login sServer "" "" sDriverID
82664>>>>>>>>>>>>>        End
82664>>>>>>>>>>>>>>
82664>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
82665>>>>>>>>>>>>>        Function_Return bLoginSuccessful
82666>>>>>>>>>>>>>    End_Function
82667>>>>>>>>>>>>>End_Class
82668>>>>>>>>>>>>>
82668>>>>>>>>>>>>>Class cDbUpdateDatabaseDriver is a cObject
82669>>>>>>>>>>>>>    Procedure Construct_Object
82671>>>>>>>>>>>>>        Forward Send Construct_Object
82673>>>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
82674>>>>>>>>>>>>>        Property Handle phoDriverSpecificObject
82675>>>>>>>>>>>>>    End_Procedure
82676>>>>>>>>>>>>>
82676>>>>>>>>>>>>>    Function CreateDriver Returns Handle
82678>>>>>>>>>>>>>        String sDriverID
82678>>>>>>>>>>>>>        Handle hoDriver hcDriverClass
82678>>>>>>>>>>>>>
82678>>>>>>>>>>>>>        Get psDriverID to sDriverID
82679>>>>>>>>>>>>>        Case Begin
82679>>>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
82681>>>>>>>>>>>>>                Move (RefClass(cDbUpdateMSSQLDriver))    to hcDriverClass
82682>>>>>>>>>>>>>                Case Break
82683>>>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
82686>>>>>>>>>>>>>                Move (RefClass(cDbUpdateODBCDriver))     to hcDriverClass
82687>>>>>>>>>>>>>                Case Break
82688>>>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
82691>>>>>>>>>>>>>                Move (RefClass(cDbUpdateDB2Driver))      to hcDriverClass
82692>>>>>>>>>>>>>                Case Break
82693>>>>>>>>>>>>>            Case (sDriverID = SQLFLEX)
82696>>>>>>>>>>>>>                Move (RefClass(cDbUpdateSQLFLEXDriver))  to hcDriverClass
82697>>>>>>>>>>>>>                Case Break
82698>>>>>>>>>>>>>            Case (sDriverID = ORAFLEX)
82701>>>>>>>>>>>>>                Move (RefClass(cDbUpdateORAFLEXDriver))  to hcDriverClass
82702>>>>>>>>>>>>>                Case Break
82703>>>>>>>>>>>>>            Case (sDriverID = MDSPgSQL)
82706>>>>>>>>>>>>>                Move (RefClass(cDbUpdateMDSPgSQLDriver)) to hcDriverClass
82707>>>>>>>>>>>>>                Case Break
82708>>>>>>>>>>>>>            Case (sDriverID = MDSMySQL)
82711>>>>>>>>>>>>>                Move (RefClass(cDbUpdateMDSMySQLDriver)) to hcDriverClass
82712>>>>>>>>>>>>>                Case Break
82713>>>>>>>>>>>>>            // DATAFLEX_ID = Default driver
82713>>>>>>>>>>>>>            Case Else
82713>>>>>>>>>>>>>                Move (RefClass(cDbUpdateDataFlexDriver)) to hcDriverClass
82714>>>>>>>>>>>>>                Move DATAFLEX_ID to sDriverID
82715>>>>>>>>>>>>>        Case End
82715>>>>>>>>>>>>>
82715>>>>>>>>>>>>>        Get Create hcDriverClass to hoDriver
82716>>>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
82717>>>>>>>>>>>>>        Set phoDriverSpecificObject to hoDriver
82718>>>>>>>>>>>>>
82718>>>>>>>>>>>>>        Function_Return hoDriver
82719>>>>>>>>>>>>>    End_Procedure
82720>>>>>>>>>>>>>
82720>>>>>>>>>>>>>    Procedure DestroyDriver
82722>>>>>>>>>>>>>        If (phoDriverSpecificObject(Self)) Begin
82724>>>>>>>>>>>>>            Send Destroy of (phoDriverSpecificObject(Self))
82725>>>>>>>>>>>>>        End
82725>>>>>>>>>>>>>>
82725>>>>>>>>>>>>>    End_Procedure
82726>>>>>>>>>>>>>
82726>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
82728>>>>>>>>>>>>>        String sConnect
82728>>>>>>>>>>>>>        Handle hoDriver
82728>>>>>>>>>>>>>
82728>>>>>>>>>>>>>        Get CreateDriver to hoDriver
82729>>>>>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
82730>>>>>>>>>>>>>        Send DestroyDriver
82731>>>>>>>>>>>>>        Function_Return sConnect
82732>>>>>>>>>>>>>    End_Function
82733>>>>>>>>>>>>>
82733>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
82735>>>>>>>>>>>>>        Boolean bLoginSuccessful
82735>>>>>>>>>>>>>        Handle hoDriver
82735>>>>>>>>>>>>>
82735>>>>>>>>>>>>>        Get CreateDriver to hoDriver
82736>>>>>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
82737>>>>>>>>>>>>>        Send DestroyDriver
82738>>>>>>>>>>>>>        Function_Return bLoginSuccessful
82739>>>>>>>>>>>>>    End_Function
82740>>>>>>>>>>>>>
82740>>>>>>>>>>>>>End_Class
82741>>>>>>>>>>>
82741>>>>>>>>>>>Class cSQLConnectionIniFile is a cIniFile
82742>>>>>>>>>>>    Procedure Construct_Object
82744>>>>>>>>>>>        Forward Send Construct_Object
82746>>>>>>>>>>>
82746>>>>>>>>>>>        Property String Private_psIniFilePath
82747>>>>>>>>>>>        Property String Private_psIniFileName CS_SQLIniFileName
82748>>>>>>>>>>>        Property String psIniSectionName (CS_SQLIniSectionName + "1")
82749>>>>>>>>>>>
82749>>>>>>>>>>>//        { Visibility=Private }
82749>>>>>>>>>>>        Property Boolean pbDFConnId False
82750>>>>>>>>>>>
82750>>>>>>>>>>>        // We use Base64 coding instead of the cCryptographer class because the
82750>>>>>>>>>>>        // password will get scrambled while writing/reading to/from the ini-file.
82750>>>>>>>>>>>//        { Visibility=Public }
82750>>>>>>>>>>>//        // *** You really want to change this value! ***
82750>>>>>>>>>>>//        Property String psHashString "zx!2139(LI0+?ips7433"
82750>>>>>>>>>>>
82750>>>>>>>>>>>    End_Procedure
82751>>>>>>>>>>>
82751>>>>>>>>>>>    Procedure End_Construct_Object
82753>>>>>>>>>>>        Forward Send End_Construct_Object
82755>>>>>>>>>>>    End_Procedure
82756>>>>>>>>>>>
82756>>>>>>>>>>>    Procedure Set psIniFilePath String sPath
82758>>>>>>>>>>>        String sIniFile
82758>>>>>>>>>>>        Get vFolderFormat sPath to sPath
82759>>>>>>>>>>>        Set private_psIniFilePath to sPath
82760>>>>>>>>>>>        Get psIniFileName to sIniFile
82761>>>>>>>>>>>        Set psFileName to (sPath + sIniFile)
82762>>>>>>>>>>>    End_Procedure
82763>>>>>>>>>>>
82763>>>>>>>>>>>    Function psIniFilePath Returns String
82765>>>>>>>>>>>        Function_Return (private_psIniFilePath(Self))
82766>>>>>>>>>>>    End_Function
82767>>>>>>>>>>>
82767>>>>>>>>>>>    Procedure Set psIniFileName String sFileName
82769>>>>>>>>>>>        String sPath
82769>>>>>>>>>>>        Get psIniFilePath to sPath
82770>>>>>>>>>>>        Set psFileName to (sPath + sFileName)
82771>>>>>>>>>>>        Set private_psIniFileName to sFileName
82772>>>>>>>>>>>    End_Procedure
82773>>>>>>>>>>>
82773>>>>>>>>>>>    Function psIniFileName Returns String
82775>>>>>>>>>>>        Function_Return (private_psIniFileName(Self))
82776>>>>>>>>>>>    End_Function
82777>>>>>>>>>>>
82777>>>>>>>>>>>    // *** Generalized messages to Get & Set values of the ini file.
82777>>>>>>>>>>>    // Sets a value in the program's ini file (write)
82777>>>>>>>>>>>    // Pass a section name, the value name parameter and the value itself to be written.
82777>>>>>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
82779>>>>>>>>>>>        String sIniFile sPath
82779>>>>>>>>>>>
82779>>>>>>>>>>>        Get psIniFilePath to sPath
82780>>>>>>>>>>>        Get psIniFileName to sIniFile
82781>>>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
82782>>>>>>>>>>>        Set psFileName to sIniFile
82783>>>>>>>>>>>        Send WriteString sSection sValueName sValue
82784>>>>>>>>>>>    End_Procedure
82785>>>>>>>>>>>
82785>>>>>>>>>>>    // Get a value from program's ini-file (read)
82785>>>>>>>>>>>    // Pass a section name and the name of the value parameter & a default value.
82785>>>>>>>>>>>    // Returns the value
82785>>>>>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
82787>>>>>>>>>>>        String sValue sIniFile sPath
82787>>>>>>>>>>>
82787>>>>>>>>>>>        Get psIniFilePath to sPath
82788>>>>>>>>>>>        Get psIniFileName to sIniFile
82789>>>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
82790>>>>>>>>>>>        Set psFileName to sIniFile
82791>>>>>>>>>>>        Get ReadString sSection sValueName sDefaultValue to sValue
82792>>>>>>>>>>>
82792>>>>>>>>>>>        Function_Return sValue
82793>>>>>>>>>>>    End_Function
82794>>>>>>>>>>>
82794>>>>>>>>>>>    // Sort function that first sorts on bEnabled & then on the connection string.
82794>>>>>>>>>>>    Function SortActiveFirst tSQLConnection SQLConnectionRow1 tSQLConnection SQLConnectionRow2 Returns Integer
82796>>>>>>>>>>>        If (SQLConnectionRow1.bEnabled > SQLConnectionRow2.bEnabled) ;            Function_Return (LT)
82799>>>>>>>>>>>        If (SQLConnectionRow1.bEnabled < SQLConnectionRow2.bEnabled) ;            Function_Return (GT)
82802>>>>>>>>>>>
82802>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionID < SQLConnectionRow2.sConnectionID) ;            Function_Return (LT)
82805>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionID > SQLConnectionRow2.sConnectionID) ;            Function_Return (GT)
82808>>>>>>>>>>>
82808>>>>>>>>>>>        If (SQLConnectionRow1.iDbType < SQLConnectionRow2.iDbType) ;            Function_Return (LT)
82811>>>>>>>>>>>        If (SQLConnectionRow1.iDbType > SQLConnectionRow2.iDbType) ;            Function_Return (GT)
82814>>>>>>>>>>>
82814>>>>>>>>>>>        If (SQLConnectionRow1.sServer < SQLConnectionRow2.sServer) ;            Function_Return (LT)
82817>>>>>>>>>>>        If (SQLConnectionRow1.sServer > SQLConnectionRow2.sServer) ;            Function_Return (GT)
82820>>>>>>>>>>>
82820>>>>>>>>>>>        If (SQLConnectionRow1.sDatabase < SQLConnectionRow2.sDatabase) ;            Function_Return (LT)
82823>>>>>>>>>>>        If (SQLConnectionRow1.sDatabase > SQLConnectionRow2.sDatabase) ;            Function_Return (GT)
82826>>>>>>>>>>>
82826>>>>>>>>>>>        If (SQLConnectionRow1.sDriverID < SQLConnectionRow2.sDriverID) ;            Function_Return (LT)
82829>>>>>>>>>>>        If (SQLConnectionRow1.sDriverID > SQLConnectionRow2.sDriverID) ;            Function_Return (GT)
82832>>>>>>>>>>>
82832>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionString < SQLConnectionRow2.sConnectionString) ;            Function_Return (LT)
82835>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionString > SQLConnectionRow2.sConnectionString) ;            Function_Return (GT)
82838>>>>>>>>>>>
82838>>>>>>>>>>>        Function_Return (EQ)
82839>>>>>>>>>>>    End_Function
82840>>>>>>>>>>>
82840>>>>>>>>>>>    Function SQLIniFileNumberOfConnections Returns Integer
82842>>>>>>>>>>>        Handle hoSections
82842>>>>>>>>>>>        Integer iItems
82842>>>>>>>>>>>
82842>>>>>>>>>>>        Send ReadSections hoSections
82843>>>>>>>>>>>        Move (Item_Count(hoSections)) to iItems
82844>>>>>>>>>>>        Function_Return iItems
82845>>>>>>>>>>>    End_Function
82846>>>>>>>>>>>
82846>>>>>>>>>>>    // The normal connection string looks something like this;
82846>>>>>>>>>>>    // "SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
82846>>>>>>>>>>>    // ...but the full connection string looks like this;
82846>>>>>>>>>>>    // "DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
82846>>>>>>>>>>>//    Function SQLIniFileAddConnection String sFullConnectionString Returns Boolean
82846>>>>>>>>>>>//        String sSection
82846>>>>>>>>>>>//        Integer iCount
82846>>>>>>>>>>>//
82846>>>>>>>>>>>//        Move False to Err
82846>>>>>>>>>>>//        Get psIniSectionName to sSection
82846>>>>>>>>>>>//        Get SQLIniFileNumberOfConnections to iCount
82846>>>>>>>>>>>//        Increment iCount
82846>>>>>>>>>>>//        Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to sFullConnectionString
82846>>>>>>>>>>>//
82846>>>>>>>>>>>//        Function_Return (Err = False)
82846>>>>>>>>>>>//    End_Function
82846>>>>>>>>>>>
82846>>>>>>>>>>>    Function SQLIniFileDeleteAllConnections Returns Boolean
82848>>>>>>>>>>>        Integer iCount
82848>>>>>>>>>>>        Boolean bExists
82848>>>>>>>>>>>        String sSection
82848>>>>>>>>>>>
82848>>>>>>>>>>>        Move False to Err
82849>>>>>>>>>>>        Move 1 to iCount
82850>>>>>>>>>>>        Get psIniSectionName to sSection
82851>>>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
82852>>>>>>>>>>>        While (bExists = True)
82856>>>>>>>>>>>            Send DeleteSection (CS_SQLIniSectionName + String(iCount))
82857>>>>>>>>>>>            Increment iCount
82858>>>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
82859>>>>>>>>>>>        Loop
82860>>>>>>>>>>>>
82860>>>>>>>>>>>        Function_Return (Err = False)
82861>>>>>>>>>>>    End_Function
82862>>>>>>>>>>>
82862>>>>>>>>>>>    Function SQLIniFileDeleteConnection Integer iItem Returns Boolean
82864>>>>>>>>>>>        Integer iCount
82864>>>>>>>>>>>        String sSection
82864>>>>>>>>>>>        Boolean bExists
82864>>>>>>>>>>>
82864>>>>>>>>>>>        Move False to Err
82865>>>>>>>>>>>        Move 1 to iCount
82866>>>>>>>>>>>        Get psIniSectionName to sSection
82867>>>>>>>>>>>        Get KeyExists sSection CS_SQLIniConnectionIdKeyword to bExists
82868>>>>>>>>>>>        While (bExists = True)
82872>>>>>>>>>>>            If (iCount = iItem) Begin
82874>>>>>>>>>>>                Send DeleteSection sSection
82875>>>>>>>>>>>//                Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to ""
82875>>>>>>>>>>>                Move 9999 to iCount // Just some ridiculously high number to get out of the loop as we're done.
82876>>>>>>>>>>>            End
82876>>>>>>>>>>>>
82876>>>>>>>>>>>            Increment iCount
82877>>>>>>>>>>>            Get KeyExists sSection (CS_SQLIniSectionName + String(iCount)) to bExists
82878>>>>>>>>>>>        Loop
82879>>>>>>>>>>>>
82879>>>>>>>>>>>
82879>>>>>>>>>>>        Function_Return (Err = False)
82880>>>>>>>>>>>    End_Function
82881>>>>>>>>>>>
82881>>>>>>>>>>>    // Returns all connection details for the passed Connection ID as a tSQLConnection
82881>>>>>>>>>>>    // If it fails the returned struct member SQLConnection.bError = True.
82881>>>>>>>>>>>    Function SQLIniFileConnectionID String sConnectionID Returns tSQLConnection
82883>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
82883>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
82884>>>>>>>>>>>        tSQLConnection   SQLConnection
82884>>>>>>>>>>>        tSQLConnection   SQLConnection
82884>>>>>>>>>>>        Integer iIndex
82884>>>>>>>>>>>
82884>>>>>>>>>>>        Get SQLIniFileConnectionIDIndex sConnectionID to iIndex
82885>>>>>>>>>>>        If (iIndex = -1) Begin
82887>>>>>>>>>>>            Move True to SQLConnection.bError
82888>>>>>>>>>>>            Function_Return SQLConnection
82889>>>>>>>>>>>        End
82889>>>>>>>>>>>>
82889>>>>>>>>>>>
82889>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
82890>>>>>>>>>>>        Move SQLConnectionsArray[iIndex -1] to SQLConnection
82891>>>>>>>>>>>
82891>>>>>>>>>>>        Function_Return SQLConnection
82892>>>>>>>>>>>    End_Function
82893>>>>>>>>>>>
82893>>>>>>>>>>>    // Returns -1 if the passed connection ID was not found, else the item number.
82893>>>>>>>>>>>    Function SQLIniFileConnectionIDIndex String sConnectionID Returns Integer
82895>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
82895>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
82896>>>>>>>>>>>        Integer iRetval iCount iSize
82896>>>>>>>>>>>        String sValue
82896>>>>>>>>>>>        Boolean bExists
82896>>>>>>>>>>>
82896>>>>>>>>>>>        Move -1 to iRetval
82897>>>>>>>>>>>
82897>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
82898>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
82899>>>>>>>>>>>        Decrement iSize
82900>>>>>>>>>>>        For iCount from 0 to iSize
82906>>>>>>>>>>>>
82906>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
82907>>>>>>>>>>>            Move (Uppercase(sValue) = Uppercase(sConnectionID)) to bExists
82908>>>>>>>>>>>            If (bExists) Begin
82910>>>>>>>>>>>                Move (iCount + 1) to iRetval // The [ConnectionX] keys are one-based (starts at 1) but the loop starts at zero.
82911>>>>>>>>>>>                Move iSize to iCount         // We're done!
82912>>>>>>>>>>>            End
82912>>>>>>>>>>>>
82912>>>>>>>>>>>        Loop
82913>>>>>>>>>>>>
82913>>>>>>>>>>>
82913>>>>>>>>>>>        Function_Return iRetval
82914>>>>>>>>>>>    End_Function
82915>>>>>>>>>>>
82915>>>>>>>>>>>    // Checks if the passed sConnectionID exists more than once in the passed struct array.
82915>>>>>>>>>>>    // Used to check that ConnectionID's are unique.
82915>>>>>>>>>>>    Function IsConnectionIDDuplicate String sConnectionID Returns Boolean
82917>>>>>>>>>>>        Integer iCount iSize iItems
82917>>>>>>>>>>>        String sValue
82917>>>>>>>>>>>        Boolean bExists
82917>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
82917>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
82918>>>>>>>>>>>
82918>>>>>>>>>>>        Move 0 to iItems
82919>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
82920>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
82921>>>>>>>>>>>        Decrement iSize
82922>>>>>>>>>>>        For iCount from 0 to iSize
82928>>>>>>>>>>>>
82928>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
82929>>>>>>>>>>>            Move (sValue = sConnectionID) to bExists
82930>>>>>>>>>>>            If (bExists) Begin
82932>>>>>>>>>>>                Increment iItems
82933>>>>>>>>>>>            End
82933>>>>>>>>>>>>
82933>>>>>>>>>>>        Loop
82934>>>>>>>>>>>>
82934>>>>>>>>>>>
82934>>>>>>>>>>>        Function_Return (iItems > 1)
82935>>>>>>>>>>>    End_Function
82936>>>>>>>>>>>
82936>>>>>>>>>>>    // To update the SQLConnections.ini file with a new default Connection ID.
82936>>>>>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
82938>>>>>>>>>>>        Boolean bOK
82938>>>>>>>>>>>        Integer iSize iCount
82938>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
82938>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
82939>>>>>>>>>>>        tSQLConnection SQLConnection
82939>>>>>>>>>>>        tSQLConnection SQLConnection
82939>>>>>>>>>>>        String sConnectionString
82939>>>>>>>>>>>
82939>>>>>>>>>>>        Move False to Err
82940>>>>>>>>>>>        Get psConnectionString to sConnectionString
82941>>>>>>>>>>>
82941>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
82942>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
82943>>>>>>>>>>>        Decrement iSize
82944>>>>>>>>>>>        // Set all current connection to inactive.
82944>>>>>>>>>>>        For iCount from 0 to iSize
82950>>>>>>>>>>>>
82950>>>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
82951>>>>>>>>>>>        Loop
82952>>>>>>>>>>>>
82952>>>>>>>>>>>
82952>>>>>>>>>>>        Get SQLIniFileConnectionID sConnectionID to SQLConnection
82953>>>>>>>>>>>        Move True              to SQLConnection.bEnabled
82954>>>>>>>>>>>        Move sConnectionString to SQLConnection.sConnectionString
82955>>>>>>>>>>>        Move (InsertInArray(SQLConnectionsArray, 0, SQLConnection)) to SQLConnectionsArray
82956>>>>>>>>>>>        Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
82957>>>>>>>>>>>
82957>>>>>>>>>>>        Function_Return (bOK = True)
82958>>>>>>>>>>>    End_Function
82959>>>>>>>>>>>
82959>>>>>>>>>>>    // Used for updating an existing connection with new data.
82959>>>>>>>>>>>    // Returns True if successful.
82959>>>>>>>>>>>    Function SQLIniFileUpdateConnection tSQLConnection SQLConnection Returns Boolean
82961>>>>>>>>>>>        Boolean bOK
82961>>>>>>>>>>>        Integer iItem iSize iCount
82961>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
82961>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
82962>>>>>>>>>>>
82962>>>>>>>>>>>        Move False to Err
82963>>>>>>>>>>>        Move -1 to iItem
82964>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
82965>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
82966>>>>>>>>>>>        Decrement iSize
82967>>>>>>>>>>>        // Set all current connection to inactive.
82967>>>>>>>>>>>        For iCount from 0 to iSize
82973>>>>>>>>>>>>
82973>>>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
82974>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sConnectionID = SQLConnection.sConnectionID) Begin
82976>>>>>>>>>>>                Move iCount to iItem
82977>>>>>>>>>>>            End
82977>>>>>>>>>>>>
82977>>>>>>>>>>>        Loop
82978>>>>>>>>>>>>
82978>>>>>>>>>>>
82978>>>>>>>>>>>        If (iItem <> -1) Begin
82980>>>>>>>>>>>            Move True to SQLConnection.bEnabled
82981>>>>>>>>>>>            Move SQLConnection to SQLConnectionsArray[iItem]
82982>>>>>>>>>>>            Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
82983>>>>>>>>>>>        End
82983>>>>>>>>>>>>
82983>>>>>>>>>>>
82983>>>>>>>>>>>        Function_Return (bOK = True)
82984>>>>>>>>>>>    End_Function
82985>>>>>>>>>>>
82985>>>>>>>>>>>    Function SQLIniFileReadConnections Returns tSQLConnection[]
82987>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
82987>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
82988>>>>>>>>>>>        String sSection sValue
82988>>>>>>>>>>>        Integer iCount
82988>>>>>>>>>>>        Boolean bExists bEnabled
82988>>>>>>>>>>>
82988>>>>>>>>>>>        Get psIniSectionName to sSection
82989>>>>>>>>>>>        Get SectionExists sSection to bExists
82990>>>>>>>>>>>        If (bExists = False) Begin
82992>>>>>>>>>>>            Function_Return SQLConnectionsArray
82993>>>>>>>>>>>        End
82993>>>>>>>>>>>>
82993>>>>>>>>>>>        Get SectionExists CS_SQLIniConnectionSection to bExists
82994>>>>>>>>>>>        If (bExists = True) Begin
82996>>>>>>>>>>>            Error DFERR_PROGRAM "Sorry, the format for the SQLConnections.ini file has been changed and this file has the old format that is no longer valid and thus cannot be read. You need to re-enter your connection(s)."
82997>>>>>>>>>>>>
82997>>>>>>>>>>>        End
82997>>>>>>>>>>>>
82997>>>>>>>>>>>
82997>>>>>>>>>>>        Move 1 to iCount // The section name "[ConnectionXX]" starts with "1"
82998>>>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
82999>>>>>>>>>>>
82999>>>>>>>>>>>        While (bExists = True)
83003>>>>>>>>>>>            // We always put the enabled/active connection at the top
83003>>>>>>>>>>>            Move (iCount = 1) to bEnabled
83004>>>>>>>>>>>            Move bEnabled to SQLConnectionsArray[iCount].bEnabled
83005>>>>>>>>>>>
83005>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionIdKeyword ""        to SQLConnectionsArray[iCount].sConnectionID
83006>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDriverKeyword       ""        to SQLConnectionsArray[iCount].sDriverID
83007>>>>>>>>>>>
83007>>>>>>>>>>>            // The iDbType might be missing from the ini-file. This is e.g. the case when a DAW Managed Connection "DFConnId.ini" file is read.
83007>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDbTypeKeyword       "99"      to sValue
83008>>>>>>>>>>>            If (sValue = "99") Begin
83010>>>>>>>>>>>                Get SqlUtilDbTypeFromDriver SQLConnectionsArray[iCount].sDriverID to sValue
83011>>>>>>>>>>>            End
83011>>>>>>>>>>>>
83011>>>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].iDbType
83012>>>>>>>>>>>
83012>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionKeyWord   ""        to SQLConnectionsArray[iCount].sConnectionString
83013>>>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnectionsArray[iCount].sServer
83014>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
83016>>>>>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDSNKeyword +"=")   to SQLConnectionsArray[iCount].sServer
83017>>>>>>>>>>>            End
83017>>>>>>>>>>>>
83017>>>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnectionsArray[iCount].sDatabase
83018>>>>>>>>>>>
83018>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniTrustedKeyword      ""        to sValue
83019>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bTrusted
83020>>>>>>>>>>>
83020>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniUIDKeyword          ""        to SQLConnectionsArray[iCount].sUserID
83021>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDFPWDKeyword        ""        to sValue
83022>>>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
83024>>>>>>>>>>>                Get DecryptPassword sValue to sValue
83025>>>>>>>>>>>            End
83025>>>>>>>>>>>>
83025>>>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].sPassword
83026>>>>>>>>>>>
83026>>>>>>>>>>>            // Here we reconstruct the connection string to be complete with all params;
83026>>>>>>>>>>>            Get ConstructConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                          SQLConnectionsArray[iCount].bTrusted SQLConnectionsArray[iCount].sUserID SQLConnectionsArray[iCount].sPassword ;                                          to SQLConnectionsArray[iCount].sConnectionString
83027>>>>>>>>>>>
83027>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSchemaKeyword          ""     to SQLConnectionsArray[iCount].sSchema
83028>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniBaseTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sBaseTableSpace
83029>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniLongTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sLongTableSpace
83030>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniIndexTableSpaceKeyword ""     to SQLConnectionsArray[iCount].sIndexTableSpace
83031>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSilentLoginKeyword     ""     to SQLConnectionsArray[iCount].bSilentLogin
83032>>>>>>>>>>>//            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDisabledKeyword        ""     to SQLConnectionsArray[iCount].bDisabled
83032>>>>>>>>>>>
83032>>>>>>>>>>>            Increment iCount
83033>>>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
83034>>>>>>>>>>>        Loop
83035>>>>>>>>>>>>
83035>>>>>>>>>>>
83035>>>>>>>>>>>        // Lastly, we remove the very first array item as it is empty (we started at 1 because that is the first [Connection#])
83035>>>>>>>>>>>        If (SizeOfArray(SQLConnectionsArray) > 0) Begin
83037>>>>>>>>>>>            Move (RemoveFromArray(SQLConnectionsArray, 0)) to SQLConnectionsArray
83038>>>>>>>>>>>        End
83038>>>>>>>>>>>>
83038>>>>>>>>>>>
83038>>>>>>>>>>>        Function_Return SQLConnectionsArray
83039>>>>>>>>>>>    End_Function
83040>>>>>>>>>>>
83040>>>>>>>>>>>    Function SQLIniFileWriteConnections tSQLConnection[] SQLConnectionsArray Returns Boolean
83042>>>>>>>>>>>        Integer iCount iSize
83042>>>>>>>>>>>        Boolean bOK
83042>>>>>>>>>>>        String sConnectionString sSection sValue
83042>>>>>>>>>>>
83042>>>>>>>>>>>        // First we need to _remove_ all current connections in the ini-file, we
83042>>>>>>>>>>>        // do that by setting their values to "".
83042>>>>>>>>>>>        Move 0 to iCount
83043>>>>>>>>>>>        Get SQLIniFileDeleteAllConnections to bOK
83044>>>>>>>>>>>        If (bOK = False) Begin
83046>>>>>>>>>>>            Function_Return False
83047>>>>>>>>>>>        End
83047>>>>>>>>>>>>
83047>>>>>>>>>>>
83047>>>>>>>>>>>        Move False to Err
83048>>>>>>>>>>>        Get psIniSectionName to sSection
83049>>>>>>>>>>>        // Sorting will make sure we have the active connection record as the first connection item in the ini-file.
83049>>>>>>>>>>>        Move (SortArray(SQLConnectionsArray, Self, (RefFunc(SortActiveFirst)))) to SQLConnectionsArray
83050>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
83051>>>>>>>>>>>        Decrement iSize
83052>>>>>>>>>>>
83052>>>>>>>>>>>        For iCount from 0 to iSize
83058>>>>>>>>>>>>
83058>>>>>>>>>>>            // DF 19 compatible settings:
83058>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionIdKeyword   to SQLConnectionsArray[iCount].sConnectionID
83059>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDriverKeyword         to SQLConnectionsArray[iCount].sDriverID
83060>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniUIDKeyword            to SQLConnectionsArray[iCount].sUserID
83061>>>>>>>>>>>
83061>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sPassword to sValue
83062>>>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
83064>>>>>>>>>>>                Get EncryptPassword sValue to sValue
83065>>>>>>>>>>>            End
83065>>>>>>>>>>>>
83065>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDFPWDKeyword          to sValue
83066>>>>>>>>>>>
83066>>>>>>>>>>>            If (SQLConnectionsArray[iCount].bTrusted = True) Begin
83068>>>>>>>>>>>                Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniTrustedKeyword    to CS_SQLIniConnectionYes
83069>>>>>>>>>>>            End
83069>>>>>>>>>>>>
83069>>>>>>>>>>>
83069>>>>>>>>>>>            Get ConstructShortConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                            to SQLConnectionsArray[iCount].sConnectionString
83070>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionKeyWord     to SQLConnectionsArray[iCount].sConnectionString
83071>>>>>>>>>>>
83071>>>>>>>>>>>            // The Database Update Framework extended settings:
83071>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDbTypeKeyword          to SQLConnectionsArray[iCount].iDbType
83072>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSchemaKeyword          to SQLConnectionsArray[iCount].sSchema
83073>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniBaseTableSpaceKeyword  to SQLConnectionsArray[iCount].sBaseTableSpace
83074>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniLongTableSpaceKeyword  to SQLConnectionsArray[iCount].sLongTableSpace
83075>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniIndexTableSpaceKeyword to SQLConnectionsArray[iCount].sIndexTableSpace
83076>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSilentLoginKeyword     to SQLConnectionsArray[iCount].bSilentLogin
83077>>>>>>>>>>>        Loop
83078>>>>>>>>>>>>
83078>>>>>>>>>>>
83078>>>>>>>>>>>        Function_Return (bOK and Err = False)
83079>>>>>>>>>>>    End_Function
83080>>>>>>>>>>>
83080>>>>>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
83080>>>>>>>>>>>    //
83080>>>>>>>>>>>    // SQL utility function that returns a database type (string) constant
83080>>>>>>>>>>>    // corresponding to the passed iDbType.
83080>>>>>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
83082>>>>>>>>>>>        String sRetval
83082>>>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
83084>>>>>>>>>>>            Move CS_dbTypeMSSQL to sRetval
83085>>>>>>>>>>>        End
83085>>>>>>>>>>>>
83085>>>>>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
83087>>>>>>>>>>>            Move CS_dbTypeMySQL to sRetval
83088>>>>>>>>>>>        End
83088>>>>>>>>>>>>
83088>>>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
83090>>>>>>>>>>>            Move CS_dbTypeOracle to sRetval
83091>>>>>>>>>>>        End
83091>>>>>>>>>>>>
83091>>>>>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
83093>>>>>>>>>>>            Move CS_dbTypeDB2 to sRetval
83094>>>>>>>>>>>        End
83094>>>>>>>>>>>>
83094>>>>>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
83096>>>>>>>>>>>            Move CS_dbTypePostgre to sRetval
83097>>>>>>>>>>>        End
83097>>>>>>>>>>>>
83097>>>>>>>>>>>        Function_Return sRetval
83098>>>>>>>>>>>    End_Function
83099>>>>>>>>>>>
83099>>>>>>>>>>>    // SQL utility function that returns a database type constant (integer)
83099>>>>>>>>>>>    // corresponding to the passed sDbType string constant.
83099>>>>>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType  Returns Integer
83101>>>>>>>>>>>        Integer iRetval
83101>>>>>>>>>>>        If (sDbType = CS_dbTypeMSSQL) Begin
83103>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
83104>>>>>>>>>>>        End
83104>>>>>>>>>>>>
83104>>>>>>>>>>>        If (sDbType = CS_dbTypeMySQL) Begin
83106>>>>>>>>>>>            Move EN_dbTypeMySQL to iRetval
83107>>>>>>>>>>>        End
83107>>>>>>>>>>>>
83107>>>>>>>>>>>        If (sDbType = CS_dbTypeOracle) Begin
83109>>>>>>>>>>>            Move EN_dbTypeOracle to iRetval
83110>>>>>>>>>>>        End
83110>>>>>>>>>>>>
83110>>>>>>>>>>>        If (sDbType = CS_dbTypeDB2) Begin
83112>>>>>>>>>>>            Move EN_dbTypeDB2 to iRetval
83113>>>>>>>>>>>        End
83113>>>>>>>>>>>>
83113>>>>>>>>>>>        If (sDbType = CS_dbTypePostgre) Begin
83115>>>>>>>>>>>            Move EN_dbTypePostgre to iRetval
83116>>>>>>>>>>>        End
83116>>>>>>>>>>>>
83116>>>>>>>>>>>        Function_Return iRetval
83117>>>>>>>>>>>    End_Function
83118>>>>>>>>>>>
83118>>>>>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
83118>>>>>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
83118>>>>>>>>>>>    // the SQL Connection program's grid.
83118>>>>>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
83120>>>>>>>>>>>        String sRetval
83120>>>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
83122>>>>>>>>>>>            Move "EN_dbTypeMSSQL" to sRetval
83123>>>>>>>>>>>        End
83123>>>>>>>>>>>>
83123>>>>>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
83125>>>>>>>>>>>            Move "EN_dbTypeMySQL" to sRetval
83126>>>>>>>>>>>        End
83126>>>>>>>>>>>>
83126>>>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
83128>>>>>>>>>>>            Move "EN_dbTypeOracle" to sRetval
83129>>>>>>>>>>>        End
83129>>>>>>>>>>>>
83129>>>>>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
83131>>>>>>>>>>>            Move "EN_dbTypeDB2" to sRetval
83132>>>>>>>>>>>        End
83132>>>>>>>>>>>>
83132>>>>>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
83134>>>>>>>>>>>            Move "EN_dbTypePostgre" to sRetval
83135>>>>>>>>>>>        End
83135>>>>>>>>>>>>
83135>>>>>>>>>>>        Function_Return sRetval
83136>>>>>>>>>>>    End_Function
83137>>>>>>>>>>>
83137>>>>>>>>>>>    // Pass a driver id and the function will return
83137>>>>>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
83137>>>>>>>>>>>    // quite work and always returns "MS SQL Server"
83137>>>>>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
83139>>>>>>>>>>>        Integer iRetval
83139>>>>>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
83141>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
83142>>>>>>>>>>>        End
83142>>>>>>>>>>>>
83142>>>>>>>>>>>        If (sDriverID = SQLFLEX) Begin
83144>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
83145>>>>>>>>>>>        End
83145>>>>>>>>>>>>
83145>>>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
83147>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
83148>>>>>>>>>>>        End
83148>>>>>>>>>>>>
83148>>>>>>>>>>>        If (sDriverID = MDSMySQL) Begin
83150>>>>>>>>>>>            Move EN_dbTypeMySQL to iRetval
83151>>>>>>>>>>>        End
83151>>>>>>>>>>>>
83151>>>>>>>>>>>        If (sDriverID = ORAFLEX) Begin
83153>>>>>>>>>>>            Move EN_dbTypeOracle to iRetval
83154>>>>>>>>>>>        End
83154>>>>>>>>>>>>
83154>>>>>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
83156>>>>>>>>>>>            Move EN_dbTypeDB2 to iRetval
83157>>>>>>>>>>>        End
83157>>>>>>>>>>>>
83157>>>>>>>>>>>        If (sDriverID = MDSPgSQL) Begin
83159>>>>>>>>>>>            Move EN_dbTypePostgre to iRetval
83160>>>>>>>>>>>        End
83160>>>>>>>>>>>>
83160>>>>>>>>>>>        Function_Return iRetval
83161>>>>>>>>>>>    End_Function
83162>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
83162>>>>>>>>>>>>
83162>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
83164>>>>>>>>>>>>    Integer iStart iEnd
83164>>>>>>>>>>>>    String sRetval
83164>>>>>>>>>>>>
83164>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
83165>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
83166>>>>>>>>>>>>    If (iStart = 0) Begin
83168>>>>>>>>>>>>        Function_Return ""
83169>>>>>>>>>>>>    End
83169>>>>>>>>>>>>>
83169>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
83170>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
83171>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
83173>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
83174>>>>>>>>>>>>    End
83174>>>>>>>>>>>>>
83174>>>>>>>>>>>>    Else Begin
83175>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
83176>>>>>>>>>>>>    End
83176>>>>>>>>>>>>>
83176>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
83178>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
83179>>>>>>>>>>>>        Decrement iEnd
83180>>>>>>>>>>>>    End
83180>>>>>>>>>>>>>
83180>>>>>>>>>>>>    If (iEnd <> 0) Begin
83182>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
83183>>>>>>>>>>>>    End
83183>>>>>>>>>>>>>
83183>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
83184>>>>>>>>>>>>
83184>>>>>>>>>>>>    Function_Return (Trim(sRetval))
83185>>>>>>>>>>>>End_Function
83186>>>>>>>>>>>>
83186>>>>>>>>>>>>
83186>>>>>>>>>>>
83186>>>>>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
83188>>>>>>>>>>>        String sConnect
83188>>>>>>>>>>>        Handle hoDriver
83188>>>>>>>>>>>
83188>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
83189>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
83190>>>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
83191>>>>>>>>>>>        Send Destroy   of hoDriver
83192>>>>>>>>>>>
83192>>>>>>>>>>>//        Case Begin
83192>>>>>>>>>>>//            Case (sDriverID = MSSQLDRV_ID)
83192>>>>>>>>>>>//                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
83192>>>>>>>>>>>//                If (sDatabase <> "") Begin
83192>>>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
83192>>>>>>>>>>>//                End
83192>>>>>>>>>>>//                If (bTrusted = True) Begin
83192>>>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
83192>>>>>>>>>>>//                End
83192>>>>>>>>>>>//                Else Begin
83192>>>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
83192>>>>>>>>>>>//                End
83192>>>>>>>>>>>//                Case Break
83192>>>>>>>>>>>//
83192>>>>>>>>>>>//            Case (sDriverID = ODBC_DRV_ID)
83192>>>>>>>>>>>//                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
83192>>>>>>>>>>>//                If (sDatabase <> "") Begin
83192>>>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
83192>>>>>>>>>>>//                End
83192>>>>>>>>>>>//                If (bTrusted = True) Begin
83192>>>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
83192>>>>>>>>>>>//                End
83192>>>>>>>>>>>//                Else Begin
83192>>>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
83192>>>>>>>>>>>//                End
83192>>>>>>>>>>>//                Case Break
83192>>>>>>>>>>>//
83192>>>>>>>>>>>//            Case (sDriverID = DB2_DRV_ID)
83192>>>>>>>>>>>//                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
83192>>>>>>>>>>>////                If (sDatabase <> "") Begin
83192>>>>>>>>>>>////                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
83192>>>>>>>>>>>////                End
83192>>>>>>>>>>>////                If (bTrusted = True) Begin
83192>>>>>>>>>>>////                    Move (sConnect * ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
83192>>>>>>>>>>>////                End
83192>>>>>>>>>>>////                Else Begin
83192>>>>>>>>>>>//                Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
83192>>>>>>>>>>>////                End
83192>>>>>>>>>>>//                Case Break
83192>>>>>>>>>>>//
83192>>>>>>>>>>>//            Case (sDriverID = SQLFLEX)
83192>>>>>>>>>>>//                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
83192>>>>>>>>>>>//                If (sDatabase <> "") Begin
83192>>>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
83192>>>>>>>>>>>//                End
83192>>>>>>>>>>>//                If (bTrusted = True) Begin
83192>>>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
83192>>>>>>>>>>>//                End
83192>>>>>>>>>>>//                Else Begin
83192>>>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
83192>>>>>>>>>>>//                End
83192>>>>>>>>>>>//                Case Break
83192>>>>>>>>>>>//
83192>>>>>>>>>>>//            Case (sDriverID = ORAFLEX)
83192>>>>>>>>>>>//                If (sDatabase <> "" and (not(sServer contains "/"))) Begin
83192>>>>>>>>>>>//                    Move (sServer + "/" + sDatabase)                  to sServer
83192>>>>>>>>>>>//                End
83192>>>>>>>>>>>//                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
83192>>>>>>>>>>>//                Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
83192>>>>>>>>>>>//                Case Break
83192>>>>>>>>>>>//
83192>>>>>>>>>>>//            Case (sDriverID = MDSPgSQL)
83192>>>>>>>>>>>//                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
83192>>>>>>>>>>>//                If (sDatabase <> "") Begin
83192>>>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
83192>>>>>>>>>>>//                End
83192>>>>>>>>>>>//                Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
83192>>>>>>>>>>>//                Case Break
83192>>>>>>>>>>>//
83192>>>>>>>>>>>//            Case (sDriverID = MDSMySQL)
83192>>>>>>>>>>>//                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
83192>>>>>>>>>>>//                If (sDatabase <> "") Begin
83192>>>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
83192>>>>>>>>>>>//                End
83192>>>>>>>>>>>//                Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
83192>>>>>>>>>>>//                Case Break
83192>>>>>>>>>>>//
83192>>>>>>>>>>>//            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
83192>>>>>>>>>>>//                Break
83192>>>>>>>>>>>//
83192>>>>>>>>>>>//            Case Else
83192>>>>>>>>>>>//                Move "" to sConnect
83192>>>>>>>>>>>//        Case End
83192>>>>>>>>>>>
83192>>>>>>>>>>>        Function_Return sConnect
83193>>>>>>>>>>>    End_Function
83194>>>>>>>>>>>
83194>>>>>>>>>>>    // Short connection string used when writing to ini-file. This is to be compatible with DF19 DFConnId.ini files that uses this short format.
83194>>>>>>>>>>>    Function ConstructShortConnectionString String sDriverID String sServer String sDatabase Returns String
83196>>>>>>>>>>>        String sConnect
83196>>>>>>>>>>>
83196>>>>>>>>>>>        Case Begin
83196>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID or sDriverID = SQLFLEX)
83198>>>>>>>>>>>                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
83199>>>>>>>>>>>                If (sDatabase <> "") Begin
83201>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
83202>>>>>>>>>>>                End
83202>>>>>>>>>>>>
83202>>>>>>>>>>>                Case Break
83203>>>>>>>>>>>
83203>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
83206>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
83207>>>>>>>>>>>                If (sDatabase <> "") Begin
83209>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
83210>>>>>>>>>>>                End
83210>>>>>>>>>>>>
83210>>>>>>>>>>>                Case Break
83211>>>>>>>>>>>
83211>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
83214>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
83215>>>>>>>>>>>                If (sDatabase <> "") Begin
83217>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
83218>>>>>>>>>>>                End
83218>>>>>>>>>>>>
83218>>>>>>>>>>>                Case Break
83219>>>>>>>>>>>
83219>>>>>>>>>>>            Case (sDriverID = ORAFLEX)
83222>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
83223>>>>>>>>>>>                If (sDatabase <> "") Begin
83225>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
83226>>>>>>>>>>>                End
83226>>>>>>>>>>>>
83226>>>>>>>>>>>                Case Break
83227>>>>>>>>>>>
83227>>>>>>>>>>>            Case (sDriverID = MDSPgSQL)
83230>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
83231>>>>>>>>>>>                If (sDatabase <> "") Begin
83233>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
83234>>>>>>>>>>>                End
83234>>>>>>>>>>>>
83234>>>>>>>>>>>                Case Break
83235>>>>>>>>>>>
83235>>>>>>>>>>>            Case (sDriverID = MDSMySQL)
83238>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
83239>>>>>>>>>>>                If (sDatabase <> "") Begin
83241>>>>>>>>>>>                    Move (sConnect * ";" +CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
83242>>>>>>>>>>>                End
83242>>>>>>>>>>>>
83242>>>>>>>>>>>                Case Break
83243>>>>>>>>>>>
83243>>>>>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
83246>>>>>>>>>>>                Break
83247>>>>>>>>>>>
83247>>>>>>>>>>>            Case Else
83247>>>>>>>>>>>                Move "" to sConnect
83248>>>>>>>>>>>        Case End
83248>>>>>>>>>>>
83248>>>>>>>>>>>        Function_Return sConnect
83249>>>>>>>>>>>    End_Function
83250>>>>>>>>>>>
83250>>>>>>>>>>>    // Use Base64
83250>>>>>>>>>>>    Function EncryptPassword String sPassword Returns String
83252>>>>>>>>>>>        String sRetval
83252>>>>>>>>>>>//        Handle hoCryptographer
83252>>>>>>>>>>>//
83252>>>>>>>>>>>//        Get psHashString to sHashString
83252>>>>>>>>>>>//        Get Create (RefClass(cCryptographer)) to hoCryptographer
83252>>>>>>>>>>>//        Set psProvider of hoCryptographer to MS_ENHANCED_PROV
83252>>>>>>>>>>>//        Get Encrypt of hoCryptographer sHashString sPassword to sRetval
83252>>>>>>>>>>>//
83252>>>>>>>>>>>//        Send Destroy of hoCryptographer
83252>>>>>>>>>>>          Get EncodeString of oBase64Functions sPassword to sRetval
83253>>>>>>>>>>>        Function_Return sRetval
83254>>>>>>>>>>>    End_Function
83255>>>>>>>>>>>
83255>>>>>>>>>>>    Function DecryptPassword String sPassword Returns String
83257>>>>>>>>>>>        String sRetval
83257>>>>>>>>>>>//        Handle hoCryptographer
83257>>>>>>>>>>>//
83257>>>>>>>>>>>//        Get psHashString to sHashString
83257>>>>>>>>>>>//        Get Create (RefClass(cCryptographer)) to hoCryptographer
83257>>>>>>>>>>>//        Set psProvider of hoCryptographer to MS_ENHANCED_PROV
83257>>>>>>>>>>>//        Get Decrypt of hoCryptographer sHashString sPassword to sRetval
83257>>>>>>>>>>>//
83257>>>>>>>>>>>//        Send Destroy of hoCryptographer
83257>>>>>>>>>>>          Get DecodeString of oBase64Functions sPassword to sRetval
83258>>>>>>>>>>>
83258>>>>>>>>>>>        Function_Return sRetval
83259>>>>>>>>>>>    End_Function
83260>>>>>>>>>>>
83260>>>>>>>>>>>    // Returns the full path of the Application (no trailing "\")
83260>>>>>>>>>>>    Function ApplicationPath Returns String
83262>>>>>>>>>>>        String sApplicationFileName sPath
83262>>>>>>>>>>>        Integer iNumChars iRetval
83262>>>>>>>>>>>
83262>>>>>>>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
83263>>>>>>>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
83264>>>>>>>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
83265>>>>>>>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
83266>>>>>>>>>>>        Move (CString(sApplicationFileName)) to sPath
83267>>>>>>>>>>>
83267>>>>>>>>>>>        Function_Return sPath
83268>>>>>>>>>>>    End_Function
83269>>>>>>>>>>>
83269>>>>>>>>>>>End_Class
83270>>>>>>>>>Use cDbUpdateDatabaseDriver.pkg
83270>>>>>>>>>
83270>>>>>>>>>// The cConnection class is the new SQL connections class for DF 19.
83270>>>>>>>>>// If an object of the cConnection class hasn't been instantiated we use a "dummy" class in its place.
83270>>>>>>>>>
83270>>>>>>>>>// We're making references to this object handle so we need it defined
83270>>>>>>>>>// here as well as for the cDbUpdateHandler class
83270>>>>>>>>>
83270>>>>>>>>>    Global_Variable Handle ghoSQLConnectionHandler
83270>>>>>>>>>
83270>>>>>>>>>Class cSQLConnectionHandler is a cObject
83271>>>>>>>>>
83271>>>>>>>>>    Procedure Construct_Object
83273>>>>>>>>>        Forward Send Construct_Object
83275>>>>>>>>>        Move Self to ghoSQLConnectionHandler
83276>>>>>>>>>
83276>>>>>>>>>        Property Handle phoSQLConnectionIniFile (Create(Self,RefClass(cSQLConnectionIniFile)))
83277>>>>>>>>>
83277>>>>>>>>>        // These properties are used by the cDbUpdateVersion and cDbUpdateFunctionLibrary classes,
83277>>>>>>>>>        // but put here so they can be set/get in both class objects. Those classes has "relay"
83277>>>>>>>>>        // methods to this class.
83277>>>>>>>>>        Property Boolean pbUseConnectionID True
83278>>>>>>>>>        Property Boolean pbToANSI          True
83279>>>>>>>>>        Property Boolean pbRecnum          True
83280>>>>>>>>>        Property Boolean pbCopyData        True
83281>>>>>>>>>        Property Boolean pbApiTableUpdateAuto    False
83282>>>>>>>>>        Property Boolean pbCompareDate_DateTime  False
83283>>>>>>>>>        Property Boolean pbCompareIndexAscending False
83284>>>>>>>>>        Property Boolean pbCompareIndexUppercase False
83285>>>>>>>>>
83285>>>>>>>>>        // Driver default value settings:
83285>>>>>>>>>        // Note: When the object is created the corresponding values
83285>>>>>>>>>        // from the driver .int files are read.
83285>>>>>>>>>        // Sample: Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of {driverNumber} to {StringVariable}
83285>>>>>>>>>        Property String psDriverDefaultValueASCII    ""
83286>>>>>>>>>        Property String psDriverDefaultValueBinary   ""
83287>>>>>>>>>        Property String psDriverDefaultValueDate     ""
83288>>>>>>>>>        Property String psDriverDefaultValueDateTime ""
83289>>>>>>>>>        Property String psDriverDefaultValueNumeric  ""
83290>>>>>>>>>        Property String psDriverDefaultValueText     ""
83291>>>>>>>>>
83291>>>>>>>>>        // Driver "nullability" settings:
83291>>>>>>>>>        // Note: When the object is created the corresponding values
83291>>>>>>>>>        // from the driver .int files are read.
83291>>>>>>>>>        // Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII of {driverNumber} to {BooleanVariable}
83291>>>>>>>>>        Property Boolean pbDriverDefaultNullableASCII    False
83292>>>>>>>>>        Property Boolean pbDriverDefaultNullableBinary   False
83293>>>>>>>>>        Property Boolean pbDriverDefaultNullableDate     False
83294>>>>>>>>>        Property Boolean pbDriverDefaultNullableDateTime False
83295>>>>>>>>>        Property Boolean pbDriverDefaultNullableNumeric  False
83296>>>>>>>>>        Property Boolean pbDriverDefaultNullableText     False
83297>>>>>>>>>
83297>>>>>>>>>        // *** This is the central point of connection data for the Database Update Framework ***
83297>>>>>>>>>        //     It is private because the get/set version also updates the DAW/Mertech
83297>>>>>>>>>        //     driver interfaces.
83297>>>>>>>>>        //     There are also procedure/function pairs to set/get individual data members
83297>>>>>>>>>        //     of the struct they are all routed throu this struct property.
83297>>>>>>>>>        Property tSQLConnection Private.pSQLConnection
83298>>>>>>>>>
83298>>>>>>>>>    End_Procedure
83299>>>>>>>>>
83299>>>>>>>>>    Procedure End_Construct_Object
83301>>>>>>>>>        Boolean bReadSettings
83301>>>>>>>>>        tSQLConnection SQLConnection
83301>>>>>>>>>        tSQLConnection SQLConnection
83301>>>>>>>>>
83301>>>>>>>>>        Forward Send End_Construct_Object
83303>>>>>>>>>
83303>>>>>>>>>        // Now is the time to read and apply SQL connection settings.
83303>>>>>>>>>        Get SetupSQLConnection True True to SQLConnection
83304>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
83305>>>>>>>>>    End_Procedure
83306>>>>>>>>>
83306>>>>>>>>>    // *** Properties ***
83306>>>>>>>>>    // All connection related "properties" (get/set pairs) are really done by changing the
83306>>>>>>>>>    // private.pSQLConnection struct connection property. These "properties" are
83306>>>>>>>>>    // merely here for conveniance.
83306>>>>>>>>>    //
83306>>>>>>>>>    // The pSQLConnection get/set are here so we have a "central hub"
83306>>>>>>>>>    // where we update data to/from the DAW & Mertech driver interfaces and this framework.
83306>>>>>>>>>    // This struct property contains all the connection data.
83306>>>>>>>>>    //
83306>>>>>>>>>    Procedure Set pSQLConnection tSQLConnection SQLConnection
83308>>>>>>>>>        Boolean bIsDaw bOK
83308>>>>>>>>>
83308>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
83309>>>>>>>>>
83309>>>>>>>>>        // When starting a program we might not have a connection id yet:
83309>>>>>>>>>        If (SQLConnection.sConnectionID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
83311>>>>>>>>>            Procedure_Return
83312>>>>>>>>>        End
83312>>>>>>>>>>
83312>>>>>>>>>
83312>>>>>>>>>        // If a DAW DFConnId.ini file was read instead of the DUF SQLConnections.ini file we should by now
83312>>>>>>>>>        // be logged in already and don't want to do it again.
83312>>>>>>>>>        If (SQLConnection.bDAWConnection = False) Begin
83314>>>>>>>>>            // After we have set the class property we need to tell the DAW/Mertech
83314>>>>>>>>>            // driver interfaces about the change & make a new login.
83314>>>>>>>>>            Get SQLLogin SQLConnection to bOK
83315>>>>>>>>>            If (bOK = False) Begin
83317>>>>>>>>>                Error DFERR_PROGRAM "Login error."
83318>>>>>>>>>>
83318>>>>>>>>>            End
83318>>>>>>>>>>
83318>>>>>>>>>        End
83318>>>>>>>>>>
83318>>>>>>>>>
83318>>>>>>>>>        // Now is the time to setup our driver default values by reading the driver .int file:
83318>>>>>>>>>        Send SetupDriverDefaults SQLConnection.sDriverID
83319>>>>>>>>>
83319>>>>>>>>>    End_Procedure
83320>>>>>>>>>
83320>>>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
83320>>>>>>>>>    // attempt to load the driver.
83320>>>>>>>>>    // Returns true if the passed driver is SQL based.
83320>>>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
83322>>>>>>>>>        Boolean bOK
83322>>>>>>>>>
83322>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
83323>>>>>>>>>        If (bOK = False) Begin
83325>>>>>>>>>            Get IsMertechDriver sDriverID to bOK
83326>>>>>>>>>        End
83326>>>>>>>>>>
83326>>>>>>>>>
83326>>>>>>>>>        Function_Return bOK
83327>>>>>>>>>    End_Function
83328>>>>>>>>>
83328>>>>>>>>>    // Reads the driver .int file and sets class properties of the cDbUpdateFunctionLibrary accordingly.
83328>>>>>>>>>    Procedure SetupDriverDefaults String sDriverID
83330>>>>>>>>>        String sAttributeValue
83330>>>>>>>>>        Integer iDriverID
83330>>>>>>>>>        Boolean bNULL bSQLDriver
83330>>>>>>>>>
83330>>>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
83331>>>>>>>>>        If (bSQLDriver = False) Begin
83333>>>>>>>>>            Procedure_Return
83334>>>>>>>>>        End
83334>>>>>>>>>>
83334>>>>>>>>>
83334>>>>>>>>>        Get DriverIndex sDriverID to iDriverID
83335>>>>>>>>>
83335>>>>>>>>>        // Driver default values for various data types:
83335>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_ASCII of iDriverID      to sAttributeValue
83338>>>>>>>>>        Set psDriverDefaultValueASCII                                   to sAttributeValue
83339>>>>>>>>>
83339>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_BINARY of iDriverID     to sAttributeValue
83342>>>>>>>>>        Set psDriverDefaultValueBinary                                  to sAttributeValue
83343>>>>>>>>>
83343>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATE of iDriverID       to sAttributeValue
83346>>>>>>>>>        Set psDriverDefaultValueDate                                    to sAttributeValue
83347>>>>>>>>>
83347>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATETIME of iDriverID   to sAttributeValue
83350>>>>>>>>>        Set psDriverDefaultValueDateTime                                to sAttributeValue
83351>>>>>>>>>
83351>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of iDriverID    to sAttributeValue
83354>>>>>>>>>        Set psDriverDefaultValueNumeric                                 to sAttributeValue
83355>>>>>>>>>
83355>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_TEXT of iDriverID       to sAttributeValue
83358>>>>>>>>>        Set psDriverDefaultValueText                                    to sAttributeValue
83359>>>>>>>>>
83359>>>>>>>>>        // The default setting for the "nullability" of newly created ASCII columns.
83359>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII      of iDriverID to bNULL
83362>>>>>>>>>        Set pbDriverDefaultNullableASCII to bNULL
83363>>>>>>>>>
83363>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_BINARY     of iDriverID to bNULL
83366>>>>>>>>>        Set pbDriverDefaultNullableBinary to bNULL
83367>>>>>>>>>
83367>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATE       of iDriverID to bNULL
83370>>>>>>>>>        Set pbDriverDefaultNullableDate to bNULL
83371>>>>>>>>>
83371>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATETIME   of iDriverID to bNULL
83374>>>>>>>>>        Set pbDriverDefaultNullableDateTime to bNULL
83375>>>>>>>>>
83375>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_NUMERIC    of iDriverID to bNULL
83378>>>>>>>>>        Set pbDriverDefaultNullableNumeric to bNULL
83379>>>>>>>>>
83379>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_TEXT       of iDriverID to bNULL
83382>>>>>>>>>        Set pbDriverDefaultNullableText to bNULL
83383>>>>>>>>>
83383>>>>>>>>>    End_Procedure
83384>>>>>>>>>
83384>>>>>>>>>    Function SQLLogin tSQLConnection SQLConnection Returns Boolean
83386>>>>>>>>>        Boolean bOK bIsDaw bIsMertech bTrusted
83386>>>>>>>>>        String sConnectionString sServer sDatabase sUserId sPassword sDriverID
83386>>>>>>>>>        Handle hoErrorObj hoDriver hoIniFile
83386>>>>>>>>>        Integer iDriverID
83386>>>>>>>>>
83386>>>>>>>>>        Move False to bOK
83387>>>>>>>>>
83387>>>>>>>>>        Get IsDAWSQLDriver SQLConnection.sDriverID to bIsDaw
83388>>>>>>>>>        If (bIsDaw = False) Begin
83390>>>>>>>>>            Get IsMertechDriver SQLConnection.sDriverID to bIsMertech
83391>>>>>>>>>            If (bIsMertech = False) Begin
83393>>>>>>>>>                Function_Return False
83394>>>>>>>>>            End
83394>>>>>>>>>>
83394>>>>>>>>>        End
83394>>>>>>>>>>
83394>>>>>>>>>
83394>>>>>>>>>        Move Error_Object_Id to hoErrorObj
83395>>>>>>>>>        Move Self to Error_Object_Id
83396>>>>>>>>>
83396>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
83397>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
83398>>>>>>>>>        Get DriverIndex SQLConnection.sDriverID to iDriverID
83399>>>>>>>>>        If (iDriverID = 0) Begin
83401>>>>>>>>>            Move hoErrorObj to Error_Object_Id
83402>>>>>>>>>            Function_Return False
83403>>>>>>>>>        End
83403>>>>>>>>>>
83403>>>>>>>>>
83403>>>>>>>>>        // There's a bug in Mertech drivers creating "an Exception error" in the debugger (probably will crash an application too.)
83403>>>>>>>>>        If (bIsMertech = False) Begin
83405>>>>>>>>>            Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to SQLConnection.bSilentLogin
83408>>>>>>>>>        End
83408>>>>>>>>>>
83408>>>>>>>>>
83408>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
83409>>>>>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
83410>>>>>>>>>        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
83411>>>>>>>>>        Send Destroy   of hoDriver
83412>>>>>>>>>        Move hoErrorObj to Error_Object_Id
83413>>>>>>>>>
83413>>>>>>>>>        Function_Return bOK
83414>>>>>>>>>    End_Function
83415>>>>>>>>>
83415>>>>>>>>>    Function pSQLConnection Returns tSQLConnection
83417>>>>>>>>>        tSQLConnection SQLConnection
83417>>>>>>>>>        tSQLConnection SQLConnection
83417>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83418>>>>>>>>>        Function_Return SQLConnection
83419>>>>>>>>>    End_Function
83420>>>>>>>>>
83420>>>>>>>>>    Procedure Set psConnectionID String sValue
83422>>>>>>>>>        tSQLConnection SQLConnection
83422>>>>>>>>>        tSQLConnection SQLConnection
83422>>>>>>>>>
83422>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83423>>>>>>>>>        If (SQLConnection.sConnectionID = "") Begin
83425>>>>>>>>>            Move sValue to SQLConnection.sConnectionID
83426>>>>>>>>>        End
83426>>>>>>>>>>
83426>>>>>>>>>
83426>>>>>>>>>        // Else we might want to change the current connection ID
83426>>>>>>>>>        Else If (SQLConnection.sConnectionID <> "" and SQLConnection.sConnectionID <> sValue) Begin
83429>>>>>>>>>            Move False to Err
83430>>>>>>>>>            Logout SQLConnection.sDriverID
83431>>>>>>>>>            // This will also make a login to the new server.
83431>>>>>>>>>            Get SQLIniFileConnectionID of (phoSQLConnectionIniFile(Self)) sValue to SQLConnection
83432>>>>>>>>>        End
83432>>>>>>>>>>
83432>>>>>>>>>        Set pSQLConnection to SQLConnection
83433>>>>>>>>>    End_Procedure
83434>>>>>>>>>
83434>>>>>>>>>    Function psConnectionID Returns String
83436>>>>>>>>>        tSQLConnection SQLConnection
83436>>>>>>>>>        tSQLConnection SQLConnection
83436>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83437>>>>>>>>>        Function_Return SQLConnection.sConnectionID
83438>>>>>>>>>    End_Procedure
83439>>>>>>>>>
83439>>>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
83439>>>>>>>>>    //       the psDriverID *must* be the first property that is changed!
83439>>>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
83439>>>>>>>>>    //       for a connection string has the wrong format for that driver.
83439>>>>>>>>>    Procedure Set psDriverID String sValue
83441>>>>>>>>>        tSQLConnection SQLConnection
83441>>>>>>>>>        tSQLConnection SQLConnection
83441>>>>>>>>>        Get pSQLConnection to SQLConnection
83442>>>>>>>>>        Move sValue        to SQLConnection.sDriverID
83443>>>>>>>>>        Set pSQLConnection to SQLConnection
83444>>>>>>>>>        If (sValue <> DATAFLEX_ID) Begin
83446>>>>>>>>>            Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
83447>>>>>>>>>        End
83447>>>>>>>>>>
83447>>>>>>>>>    End_Procedure
83448>>>>>>>>>
83448>>>>>>>>>    Function psDriverID Returns String
83450>>>>>>>>>        tSQLConnection SQLConnection
83450>>>>>>>>>        tSQLConnection SQLConnection
83450>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83451>>>>>>>>>        If (SQLConnection.sDriverID = "") Begin
83453>>>>>>>>>            Move DATAFLEX_ID to SQLConnection.sDriverID // Default is the DataFlex driver.
83454>>>>>>>>>        End
83454>>>>>>>>>>
83454>>>>>>>>>        Function_Return SQLConnection.sDriverID
83455>>>>>>>>>    End_Function
83456>>>>>>>>>
83456>>>>>>>>>    Procedure Set psConnectionString String sValue
83458>>>>>>>>>        tSQLConnection SQLConnection
83458>>>>>>>>>        tSQLConnection SQLConnection
83458>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83459>>>>>>>>>        Move sValue        to SQLConnection.sConnectionString
83460>>>>>>>>>        Set pSQLConnection to SQLConnection
83461>>>>>>>>>    End_Procedure
83462>>>>>>>>>
83462>>>>>>>>>    Function psConnectionString Returns String
83464>>>>>>>>>        tSQLConnection SQLConnection
83464>>>>>>>>>        tSQLConnection SQLConnection
83464>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83465>>>>>>>>>        Function_Return SQLConnection.sConnectionString
83466>>>>>>>>>    End_Function
83467>>>>>>>>>
83467>>>>>>>>>    Procedure Set psServer String sValue
83469>>>>>>>>>        tSQLConnection SQLConnection
83469>>>>>>>>>        tSQLConnection SQLConnection
83469>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83470>>>>>>>>>        Move sValue        to SQLConnection.sServer
83471>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
83472>>>>>>>>>        Set pSQLConnection to SQLConnection
83473>>>>>>>>>    End_Procedure
83474>>>>>>>>>
83474>>>>>>>>>    Function psServer Returns String
83476>>>>>>>>>        tSQLConnection SQLConnection
83476>>>>>>>>>        tSQLConnection SQLConnection
83476>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83477>>>>>>>>>        Function_Return SQLConnection.sServer
83478>>>>>>>>>    End_Function
83479>>>>>>>>>
83479>>>>>>>>>    Procedure Set psDatabase String sValue
83481>>>>>>>>>        tSQLConnection SQLConnection
83481>>>>>>>>>        tSQLConnection SQLConnection
83481>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83482>>>>>>>>>        Move sValue        to SQLConnection.sDatabase
83483>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
83484>>>>>>>>>        Set pSQLConnection to SQLConnection
83485>>>>>>>>>    End_Procedure
83486>>>>>>>>>
83486>>>>>>>>>    Function psDatabase Returns String
83488>>>>>>>>>        tSQLConnection SQLConnection
83488>>>>>>>>>        tSQLConnection SQLConnection
83488>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83489>>>>>>>>>        Function_Return SQLConnection.sDatabase
83490>>>>>>>>>    End_Function
83491>>>>>>>>>
83491>>>>>>>>>    Procedure Set psUserID String sValue
83493>>>>>>>>>        tSQLConnection SQLConnection
83493>>>>>>>>>        tSQLConnection SQLConnection
83493>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83494>>>>>>>>>        Move sValue        to SQLConnection.sUserID
83495>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
83496>>>>>>>>>        Set pSQLConnection to SQLConnection
83497>>>>>>>>>    End_Procedure
83498>>>>>>>>>
83498>>>>>>>>>    Function psUserID Returns String
83500>>>>>>>>>        tSQLConnection SQLConnection
83500>>>>>>>>>        tSQLConnection SQLConnection
83500>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83501>>>>>>>>>        Function_Return SQLConnection.sUserID
83502>>>>>>>>>    End_Function
83503>>>>>>>>>
83503>>>>>>>>>    // This is the uncrypted password
83503>>>>>>>>>    Procedure Set psPassword String sValue
83505>>>>>>>>>        tSQLConnection SQLConnection
83505>>>>>>>>>        tSQLConnection SQLConnection
83505>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83506>>>>>>>>>        Move sValue        to SQLConnection.sPassword
83507>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
83508>>>>>>>>>        Set pSQLConnection to SQLConnection
83509>>>>>>>>>    End_Procedure
83510>>>>>>>>>
83510>>>>>>>>>    Function psPassword Returns String
83512>>>>>>>>>        tSQLConnection SQLConnection
83512>>>>>>>>>        tSQLConnection SQLConnection
83512>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83513>>>>>>>>>        Function_Return SQLConnection.sPassword
83514>>>>>>>>>    End_Function
83515>>>>>>>>>
83515>>>>>>>>>    Procedure Set pbTrusted Boolean bValue
83517>>>>>>>>>        tSQLConnection SQLConnection
83517>>>>>>>>>        tSQLConnection SQLConnection
83517>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83518>>>>>>>>>        Move bValue        to SQLConnection.bTrusted
83519>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
83520>>>>>>>>>        Set pSQLConnection to SQLConnection
83521>>>>>>>>>    End_Procedure
83522>>>>>>>>>
83522>>>>>>>>>    Function pbTrusted Returns Boolean
83524>>>>>>>>>        tSQLConnection SQLConnection
83524>>>>>>>>>        tSQLConnection SQLConnection
83524>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83525>>>>>>>>>        Function_Return SQLConnection.bTrusted
83526>>>>>>>>>    End_Function
83527>>>>>>>>>
83527>>>>>>>>>    // *** All of these properties are special to the Database Update Framework ***
83527>>>>>>>>>    //     Thus they are not propagated to the DAW/Mertech classes and that is why
83527>>>>>>>>>    //     the Private.pSQLConnection property is set instead of the going throu
83527>>>>>>>>>    //     the central pSQLConnection "hub".
83527>>>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
83529>>>>>>>>>        tSQLConnection SQLConnection
83529>>>>>>>>>        tSQLConnection SQLConnection
83529>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83530>>>>>>>>>        Move bValue to SQLConnection.bTrusted
83531>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
83532>>>>>>>>>    End_Procedure
83533>>>>>>>>>
83533>>>>>>>>>    Function pbSilentLogin Returns Boolean
83535>>>>>>>>>        tSQLConnection SQLConnection
83535>>>>>>>>>        tSQLConnection SQLConnection
83535>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83536>>>>>>>>>        Function_Return SQLConnection.bSilentLogin
83537>>>>>>>>>    End_Function
83538>>>>>>>>>
83538>>>>>>>>>    Procedure Set piDbType Integer iValue
83540>>>>>>>>>        tSQLConnection SQLConnection
83540>>>>>>>>>        tSQLConnection SQLConnection
83540>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83541>>>>>>>>>        Move iValue to SQLConnection.iDbType
83542>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
83543>>>>>>>>>    End_Procedure
83544>>>>>>>>>
83544>>>>>>>>>    Function piDbType Returns Integer
83546>>>>>>>>>        tSQLConnection SQLConnection
83546>>>>>>>>>        tSQLConnection SQLConnection
83546>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83547>>>>>>>>>        Function_Return SQLConnection.iDbType
83548>>>>>>>>>    End_Function
83549>>>>>>>>>
83549>>>>>>>>>    Procedure Set psBaseTableSpace String sValue
83551>>>>>>>>>        tSQLConnection SQLConnection
83551>>>>>>>>>        tSQLConnection SQLConnection
83551>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83552>>>>>>>>>        Move sValue to SQLConnection.sBaseTableSpace
83553>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
83554>>>>>>>>>    End_Procedure
83555>>>>>>>>>
83555>>>>>>>>>    Function psBaseTableSpace Returns String
83557>>>>>>>>>        tSQLConnection SQLConnection
83557>>>>>>>>>        tSQLConnection SQLConnection
83557>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83558>>>>>>>>>        Function_Return SQLConnection.sBaseTableSpace
83559>>>>>>>>>    End_Function
83560>>>>>>>>>
83560>>>>>>>>>    Procedure Set psIndexTableSpace String sValue
83562>>>>>>>>>        tSQLConnection SQLConnection
83562>>>>>>>>>        tSQLConnection SQLConnection
83562>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83563>>>>>>>>>        Move sValue to SQLConnection.sIndexTableSpace
83564>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
83565>>>>>>>>>    End_Procedure
83566>>>>>>>>>
83566>>>>>>>>>    Function psIndexTableSpace Returns String
83568>>>>>>>>>        tSQLConnection SQLConnection
83568>>>>>>>>>        tSQLConnection SQLConnection
83568>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83569>>>>>>>>>        Function_Return SQLConnection.sIndexTableSpace
83570>>>>>>>>>    End_Function
83571>>>>>>>>>
83571>>>>>>>>>    Procedure Set psLongTableSpace String sValue
83573>>>>>>>>>        tSQLConnection SQLConnection
83573>>>>>>>>>        tSQLConnection SQLConnection
83573>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83574>>>>>>>>>        Move sValue to SQLConnection.sLongTableSpace
83575>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
83576>>>>>>>>>    End_Procedure
83577>>>>>>>>>
83577>>>>>>>>>    Function psLongTableSpace Returns String
83579>>>>>>>>>        tSQLConnection SQLConnection
83579>>>>>>>>>        tSQLConnection SQLConnection
83579>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83580>>>>>>>>>        Function_Return SQLConnection.sLongTableSpace
83581>>>>>>>>>    End_Function
83582>>>>>>>>>
83582>>>>>>>>>    Procedure Set psSchema String sValue
83584>>>>>>>>>        tSQLConnection SQLConnection
83584>>>>>>>>>        tSQLConnection SQLConnection
83584>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83585>>>>>>>>>        Move sValue to SQLConnection.sSchema
83586>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
83587>>>>>>>>>    End_Procedure
83588>>>>>>>>>
83588>>>>>>>>>    Function psSchema Returns String
83590>>>>>>>>>        tSQLConnection SQLConnection
83590>>>>>>>>>        tSQLConnection SQLConnection
83590>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83591>>>>>>>>>        Function_Return SQLConnection.sSchema
83592>>>>>>>>>    End_Function
83593>>>>>>>>>
83593>>>>>>>>>    Procedure Set pbEnabled Boolean bValue
83595>>>>>>>>>        tSQLConnection SQLConnection
83595>>>>>>>>>        tSQLConnection SQLConnection
83595>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83596>>>>>>>>>        Move bValue to SQLConnection.bEnabled
83597>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
83598>>>>>>>>>    End_Procedure
83599>>>>>>>>>
83599>>>>>>>>>    Function pbEnabled Returns Boolean
83601>>>>>>>>>        tSQLConnection SQLConnection
83601>>>>>>>>>        tSQLConnection SQLConnection
83601>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83602>>>>>>>>>        Function_Return SQLConnection.bEnabled
83603>>>>>>>>>    End_Function
83604>>>>>>>>>
83604>>>>>>>>>
83604>>>>>>>>>    // ************************************
83604>>>>>>>>>    Function SetupSQLConnection Boolean bReadDFConnSettings Boolean bReadSQLConnections Returns tSQLConnection
83606>>>>>>>>>        tSQLConnection SQLConnection
83606>>>>>>>>>        tSQLConnection SQLConnection
83606>>>>>>>>>
83606>>>>>>>>>        // If this object was created by the cDbUpdateHandler class we will
83606>>>>>>>>>        // deferr reading SQL connection values until later.
83606>>>>>>>>>        If (bReadDFConnSettings = True) Begin
83608>>>>>>>>>            // This is the new SQL login logic for DF 19 and up; "Managed Connections"
83608>>>>>>>>>            If (ghoConnection > 0) Begin
83610>>>>>>>>>                Get ReadcConnections to SQLConnection
83611>>>>>>>>>            End
83611>>>>>>>>>>
83611>>>>>>>>>
83611>>>>>>>>>            // In addition to the above; there might be other values set even if a cConnection
83611>>>>>>>>>            // object is used.
83611>>>>>>>>>            If (bReadSQLConnections = True) Begin
83613>>>>>>>>>                Get ReadSQLConnectionsIniSettings to SQLConnection
83614>>>>>>>>>            End
83614>>>>>>>>>>
83614>>>>>>>>>        End
83614>>>>>>>>>>
83614>>>>>>>>>
83614>>>>>>>>>        Function_Return SQLConnection
83615>>>>>>>>>    End_Function
83616>>>>>>>>>
83616>>>>>>>>>    // This is for the new cConnection class used by DF 19 and up (only).
83616>>>>>>>>>    Function ReadcConnections Returns tSQLConnection
83618>>>>>>>>>        tConnection Connection
83618>>>>>>>>>        tConnection Connection
83618>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
83618>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
83618>>>>>>>>>        Integer iRetval iDbType
83618>>>>>>>>>        Boolean bOK bEnabled bConnected
83618>>>>>>>>>        String sConnectionID sSchema
83618>>>>>>>>>
83618>>>>>>>>>            tConnection[] Connections
83618>>>>>>>>>            tConnection[] Connections
83619>>>>>>>>>            // - If the DF 19 cConnection class has been used in the cApplication object
83619>>>>>>>>>            // - and there are multiple connection id's defined for the same driver. This is
83619>>>>>>>>>            //   because otherwise we can't possibly know which connection id to use... So
83619>>>>>>>>>            //   we then generate an error and abort the program...
83619>>>>>>>>>            Get IsSinglecConnection (&sConnectionID) to bOK
83620>>>>>>>>>            If (bOK = False) Begin
83622>>>>>>>>>                Error DFERR_PROGRAM ("Programming error. The psConnectionID must be set in the cDbUpdateVersion object when a cConnect object is used in the cApplication object, and there are multiple connections defined. Program will now exit!")
83623>>>>>>>>>>
83623>>>>>>>>>                Abort
83624>>>>>>>>>>
83624>>>>>>>>>            End
83624>>>>>>>>>>
83624>>>>>>>>>            If (sConnectionID = "") Begin
83626>>>>>>>>>                Get ConnectionIDs of ghoConnection to Connections
83627>>>>>>>>>                If (SizeOfArray(Connections) > 0) Begin
83629>>>>>>>>>                    Move Connections[0].sId to sConnectionID
83630>>>>>>>>>                End
83630>>>>>>>>>>
83630>>>>>>>>>            End
83630>>>>>>>>>>
83630>>>>>>>>>
83630>>>>>>>>>            Move 0 to iRetval
83631>>>>>>>>>            // DAW DF19 connection info:
83631>>>>>>>>>            // We first check that the connection is OK:
83631>>>>>>>>>            Get ConnectionIdIndex of ghoConnection sConnectionID to iRetval
83632>>>>>>>>>            // It might happen that no connection has been setup although the object exists, in case we do nothing.
83632>>>>>>>>>            If (iRetval = -1) Begin
83634>>>>>>>>>                Function_Return SQLConnectionEmpty
83635>>>>>>>>>            End
83635>>>>>>>>>>
83635>>>>>>>>>
83635>>>>>>>>>            If (sConnectionID <> "") Begin
83637>>>>>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
83638>>>>>>>>>            End
83638>>>>>>>>>>
83638>>>>>>>>>            If (Connection.sId = "") Begin
83640>>>>>>>>>                Move True to SQLConnectionEmpty.bError
83641>>>>>>>>>                Function_Return SQLConnectionEmpty
83642>>>>>>>>>            End
83642>>>>>>>>>>
83642>>>>>>>>>
83642>>>>>>>>>            // DUF connection info struct property:
83642>>>>>>>>>            Get Private.pSQLConnection                       to SQLConnection
83643>>>>>>>>>
83643>>>>>>>>>            Move Connection.sId to sConnectionID
83644>>>>>>>>>            Get IsConnectionIdLoggedIn of ghoConnection sConnectionID to bConnected
83645>>>>>>>>>
83645>>>>>>>>>            If (bConnected = False) Begin
83647>>>>>>>>>                Get LoginConnectionId of ghoConnection sConnectionID to iRetval
83648>>>>>>>>>                If (iRetval <> 0) Begin
83650>>>>>>>>>                    Send UserError CS_DUF_CannotLoginToServer
83651>>>>>>>>>                    Send Exit_Application
83652>>>>>>>>>                End
83652>>>>>>>>>>
83652>>>>>>>>>                Move True                                   to SQLConnection.bDAWConnection
83653>>>>>>>>>                // We need to get the DAW connection info again as it might have
83653>>>>>>>>>                // been changed in the DAW db login dialog.
83653>>>>>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
83654>>>>>>>>>            End
83654>>>>>>>>>>
83654>>>>>>>>>
83654>>>>>>>>>            Move True                                        to SQLConnection.bEnabled
83655>>>>>>>>>            Move Connection.bTrustedConnection               to SQLConnection.bTrusted
83656>>>>>>>>>
83656>>>>>>>>>            // Not used in DUF:
83656>>>>>>>>>            // Move Connection.iDriverIndex                    to SQLConnection.iDriverIndex
83656>>>>>>>>>
83656>>>>>>>>>            Move (If(Connection.iOptions = 0, False, True))  to SQLConnection.bSilentLogin
83657>>>>>>>>>            Move Connection.sConnectionString                to SQLConnection.sConnectionString
83658>>>>>>>>>            Move Connection.sDriver                          to SQLConnection.sDriverID
83659>>>>>>>>>            Move Connection.sId                              to SQLConnection.sConnectionID
83660>>>>>>>>>            Move Connection.sUID                             to SQLConnection.sUserID
83661>>>>>>>>>            Move Connection.sPWD                             to SQLConnection.sPassword
83662>>>>>>>>>
83662>>>>>>>>>            // Not used in DUF:
83662>>>>>>>>>            // Move Connection.sSection to SQLConnection.xxx
83662>>>>>>>>>
83662>>>>>>>>>            // The rest of the properties of the SQLConnection struct should have been
83662>>>>>>>>>            // setup in the cDbUpdateHandler object, and we should be able to reach them through delegation:
83662>>>>>>>>>            If (Connection.sDriver <> ODBC_DRV_ID) Begin
83664>>>>>>>>>                Get ParseKeyWord Connection.sString CS_SQLIniServerKeyword to SQLConnection.sServer
83665>>>>>>>>>            End
83665>>>>>>>>>>
83665>>>>>>>>>            If (Connection.sDriver = ODBC_DRV_ID) Begin
83667>>>>>>>>>                Get ParseKeyWord Connection.sString CS_SQLIniDSNKeyword    to SQLConnection.sServer
83668>>>>>>>>>            End
83668>>>>>>>>>>
83668>>>>>>>>>            Get ParseKeyWord Connection.sString CS_SQLIniDatabaseKeyword   to SQLConnection.sDatabase
83669>>>>>>>>>
83669>>>>>>>>>            // The DbType is a bit special. If the piDbType has _not_ been setup in object code we try to derave
83669>>>>>>>>>            // the value from the driver id:
83669>>>>>>>>>            Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(Self)) Connection.sDriver to SQLConnection.iDbType
83670>>>>>>>>>            // ...but in case it has been explicitly set in the object we use that value.
83670>>>>>>>>>            Get piDbType                                     to iDbType
83671>>>>>>>>>            If (iDbType <> SQLConnection.iDbType) Begin
83673>>>>>>>>>                Move iDbType to SQLConnection.iDbType
83674>>>>>>>>>            End
83674>>>>>>>>>>
83674>>>>>>>>>            Get psBaseTableSpace                             to SQLConnection.sBaseTableSpace
83675>>>>>>>>>            Get psLongTableSpace                             to SQLConnection.sLongTableSpace
83676>>>>>>>>>            Get psIndexTableSpace                            to SQLConnection.sIndexTableSpace
83677>>>>>>>>>            Get psSchema                                     to SQLConnection.sSchema
83678>>>>>>>>>
83678>>>>>>>>>            // We finally set the struct property to the newly fetched values.
83678>>>>>>>>>            Set pSQLConnection to SQLConnection
83679>>>>>>>>>
83679>>>>>>>>>        Function_Return SQLConnection
83680>>>>>>>>>    End_Function
83681>>>>>>>>>
83681>>>>>>>>>    // Returns True if the psConnectionID has been set in the cDbUpateHandler object,
83681>>>>>>>>>    // or the DAW cConnect array of registered connection only contains one active/enabled
83681>>>>>>>>>    // connection id for a particular driver.
83681>>>>>>>>>    // So either the psConnectionID or the psDriverID can have been set in the cDbUpdateHandler
83681>>>>>>>>>    // object. We can then match a connection id from the DAW cConnect class array.
83681>>>>>>>>>    // Returns False if there are multiple connections that are enabled or the psConnectionID has
83681>>>>>>>>>    // been set in the cDbUpdateHandler object but it cannot be found amongst the registered
83681>>>>>>>>>    // connections of the DAW cConnect class.
83681>>>>>>>>>    Function IsSinglecConnection String ByRef sConnectionID Returns Boolean
83683>>>>>>>>>        tConnection[] ConnIdArray
83683>>>>>>>>>        tConnection[] ConnIdArray
83684>>>>>>>>>        Integer iCount iSize iConnectionIDCounter
83684>>>>>>>>>        Boolean bEnabled bFound
83684>>>>>>>>>        String sConnectionID2 sDriverID sDriverConn
83684>>>>>>>>>
83684>>>>>>>>>        Move False to bFound
83685>>>>>>>>>        If (ghoConnection > 0) Begin
83687>>>>>>>>>
83687>>>>>>>>>            // The property of the cDbUpdateHandler container object
83687>>>>>>>>>            Get psDriverID to sDriverID
83688>>>>>>>>>
83688>>>>>>>>>            Move 0 to iConnectionIDCounter
83689>>>>>>>>>            // This is the the DAW cConnect array with all registered connection id's.
83689>>>>>>>>>                Get ConnectionIDs of ghoConnection to ConnIdArray
83690>>>>>>>>>            Move (SizeOfArray(ConnIdArray)) to iSize
83691>>>>>>>>>            Decrement iSize
83692>>>>>>>>>            For iCount from 0 to iSize
83698>>>>>>>>>>
83698>>>>>>>>>                Move ConnIdArray[iCount].sDriver to sDriverConn
83699>>>>>>>>>                Move ConnIdArray[iCount].sId to sConnectionID2
83700>>>>>>>>>                Move (ConnIdArray[iCount].bDisabled = False) to bEnabled
83701>>>>>>>>>                // If no psConnectionID specified in the cDbUpdateHandler, we check if there is a driver
83701>>>>>>>>>                // connection in the DAW cConnect object _and_ that there is only one!
83701>>>>>>>>>                If (sConnectionID = "") Begin
83703>>>>>>>>>                    Move (sDriverID = sDriverConn and bEnabled = True) to bFound
83704>>>>>>>>>                End
83704>>>>>>>>>>
83704>>>>>>>>>                Else Begin
83705>>>>>>>>>                    If (Uppercase(sConnectionID) = Uppercase(sConnectionID2)) Begin
83707>>>>>>>>>                        Move iSize to iCount // Then we've found what we were looking for and we're out of here...
83708>>>>>>>>>                    End
83708>>>>>>>>>>
83708>>>>>>>>>                End
83708>>>>>>>>>>
83708>>>>>>>>>
83708>>>>>>>>>                If (bFound = True) Begin
83710>>>>>>>>>                    Increment iConnectionIDCounter
83711>>>>>>>>>                End
83711>>>>>>>>>>
83711>>>>>>>>>            Loop
83712>>>>>>>>>>
83712>>>>>>>>>            Move (iConnectionIDCounter <= 1 and sDriverConn <> "" and sConnectionID2 <> "") to bFound
83713>>>>>>>>>            If (bFound = True) Begin
83715>>>>>>>>>                Move sConnectionID2 to sConnectionID
83716>>>>>>>>>            End
83716>>>>>>>>>>
83716>>>>>>>>>        End
83716>>>>>>>>>>
83716>>>>>>>>>
83716>>>>>>>>>        // Special case; a cConnection object has been setup in the cApplication,
83716>>>>>>>>>        // but no DFConn.ini record has been created.
83716>>>>>>>>>        If (iSize = -1) Begin
83718>>>>>>>>>            Move True to bFound
83719>>>>>>>>>        End
83719>>>>>>>>>>
83719>>>>>>>>>
83719>>>>>>>>>        Function_Return bFound
83720>>>>>>>>>    End_Function
83721>>>>>>>>>
83721>>>>>>>>>    // Send on object creation to read the default connection string settings, and
83721>>>>>>>>>    // create a connection to the server.
83721>>>>>>>>>    Function ReadSQLConnectionsIniSettings Returns tSQLConnection
83723>>>>>>>>>        String sPath sFileName sPassword
83723>>>>>>>>>        Boolean bExists
83723>>>>>>>>>        tSQLConnection[] SQLConnectionArray
83723>>>>>>>>>        tSQLConnection[] SQLConnectionArray
83724>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
83724>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
83724>>>>>>>>>        Handle hoIniFile
83724>>>>>>>>>        Integer iSize iCount
83724>>>>>>>>>
83724>>>>>>>>>        Get psIniFilePath to sPath
83725>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
83726>>>>>>>>>        If (sPath = "") Begin
83728>>>>>>>>>            Get ApplicationPath of hoIniFile to sPath
83729>>>>>>>>>            Set psIniFilePath   of hoIniFile to sPath
83730>>>>>>>>>        End
83730>>>>>>>>>>
83730>>>>>>>>>        Get vFolderFormat sPath to sPath
83731>>>>>>>>>        Get psIniFileName to sFileName
83732>>>>>>>>>        Get vFilePathExists (sPath + sFileName) to bExists
83733>>>>>>>>>
83733>>>>>>>>>        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
83734>>>>>>>>>        Move (SizeOfArray(SQLConnectionArray)) to iSize
83735>>>>>>>>>        If (iSize = 0) Begin
83737>>>>>>>>>            // This may have been set by the "ReadcConnections" function,
83737>>>>>>>>>            // if a cConnection object has been setup for DataFlex 19 or later
83737>>>>>>>>>            // in the cApplication object.
83737>>>>>>>>>            Get pSQLConnection to SQLConnection
83738>>>>>>>>>            If (SQLConnection.sConnectionID = "") Begin
83740>>>>>>>>>                Function_Return SQLConnectionEmpty
83741>>>>>>>>>            End
83741>>>>>>>>>>
83741>>>>>>>>>            Move SQLConnection to SQLConnectionArray[0]
83742>>>>>>>>>        End
83742>>>>>>>>>>
83742>>>>>>>>>
83742>>>>>>>>>        // The first connection should be the one that is active, but just in case...
83742>>>>>>>>>        Decrement iSize
83743>>>>>>>>>        For iCount from 0 to iSize
83749>>>>>>>>>>
83749>>>>>>>>>            Move SQLConnectionArray[iCount] to SQLConnection
83750>>>>>>>>>            If (SQLConnection.bEnabled = True) Begin
83752>>>>>>>>>                Move iSize to iCount // We've found the enabled item, so we're out of here.
83753>>>>>>>>>            End
83753>>>>>>>>>>
83753>>>>>>>>>        Loop
83754>>>>>>>>>>
83754>>>>>>>>>
83754>>>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID ;             SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted ;             SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bSilentLogin
83755>>>>>>>>>
83755>>>>>>>>>        Set pSQLConnection to SQLConnection
83756>>>>>>>>>        Send AutoSetConnectionID
83757>>>>>>>>>
83757>>>>>>>>>        Function_Return SQLConnection
83758>>>>>>>>>    End_Function
83759>>>>>>>>>
83759>>>>>>>>>    Procedure Set psIniFilePath String sPath
83761>>>>>>>>>        Set psIniFilePath of (phoSQLConnectionIniFile(Self)) to sPath
83762>>>>>>>>>    End_Procedure
83763>>>>>>>>>
83763>>>>>>>>>    Function psIniFilePath Returns String
83765>>>>>>>>>        String sRetval
83765>>>>>>>>>        Get psIniFilePath of (phoSQLConnectionIniFile(Self)) to sRetval
83766>>>>>>>>>        Function_Return sRetval
83767>>>>>>>>>    End_Function
83768>>>>>>>>>
83768>>>>>>>>>    Procedure Set psIniFileName String sFileName
83770>>>>>>>>>        Set psIniFileName of (phoSQLConnectionIniFile(Self)) to sFileName
83771>>>>>>>>>    End_Procedure
83772>>>>>>>>>
83772>>>>>>>>>    Function psIniFileName Returns String
83774>>>>>>>>>        String sRetval
83774>>>>>>>>>        Get psIniFileName of (phoSQLConnectionIniFile(Self)) to sRetval
83775>>>>>>>>>        Function_Return sRetval
83776>>>>>>>>>    End_Function
83777>>>>>>>>>
83777>>>>>>>>>    // We use Base64 coding instead of the cCryptographer class because the
83777>>>>>>>>>    // password will get scrambled while writing/reading to/from the ini-file.
83777>>>>>>>>>//    { MethodType=Property Category="Behavior" InitialValue="zx!2139(LI0+?ips7433"}
83777>>>>>>>>>//    Procedure Set psHashString String sHashString
83777>>>>>>>>>//        Set psHashString of (phoSQLConnectionIniFile(Self)) to sHashString
83777>>>>>>>>>//    End_Procedure
83777>>>>>>>>>//
83777>>>>>>>>>//    Function psHashString Returns String
83777>>>>>>>>>//        String sRetval
83777>>>>>>>>>//        Get psHashString of (phoSQLConnectionIniFile(Self)) to sRetval
83777>>>>>>>>>//        Function_Return sRetval
83777>>>>>>>>>//    End_Function
83777>>>>>>>>>
83777>>>>>>>>>    Procedure Set psIniSectionName String sSection
83779>>>>>>>>>        Set psIniSectionName of (phoSQLConnectionIniFile(Self)) to sSection
83780>>>>>>>>>    End_Procedure
83781>>>>>>>>>
83781>>>>>>>>>    Function psIniSectionName Returns String
83783>>>>>>>>>        String sRetval
83783>>>>>>>>>        Get psIniSectionName of (phoSQLConnectionIniFile(Self)) to sRetval
83784>>>>>>>>>        Function_Return sRetval
83785>>>>>>>>>    End_Function
83786>>>>>>>>>
83786>>>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
83788>>>>>>>>>        Handle ho
83788>>>>>>>>>        Get phoSQLConnectionIniFile to ho
83789>>>>>>>>>        Set IniFileValue of ho to sSection sValueName sValue
83790>>>>>>>>>    End_Procedure
83791>>>>>>>>>
83791>>>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
83793>>>>>>>>>        Handle ho
83793>>>>>>>>>        String sRetval
83793>>>>>>>>>        Get phoSQLConnectionIniFile to ho
83794>>>>>>>>>        Get IniFileValue of ho sSection sValueName sDefaultValue to sRetval
83795>>>>>>>>>        Function_Return sRetval
83796>>>>>>>>>    End_Function
83797>>>>>>>>>
83797>>>>>>>>>    Function SectionExists String sSection Returns Boolean
83799>>>>>>>>>        Handle ho
83799>>>>>>>>>        Boolean bRetval
83799>>>>>>>>>        Get phoSQLConnectionIniFile to ho
83800>>>>>>>>>        Get SectionExists of ho sSection to bRetval
83801>>>>>>>>>        Function_Return bRetval
83802>>>>>>>>>    End_Function
83803>>>>>>>>>
83803>>>>>>>>>    Function KeyExists String sSection String sKey Returns Boolean
83805>>>>>>>>>        Handle ho
83805>>>>>>>>>        Boolean bRetval
83805>>>>>>>>>        Get phoSQLConnectionIniFile to ho
83806>>>>>>>>>        Get KeyExists of ho sSection sKey to bRetval
83807>>>>>>>>>        Function_Return bRetval
83808>>>>>>>>>    End_Function
83809>>>>>>>>>
83809>>>>>>>>>    Function EncryptPassword String sPassword Returns String
83811>>>>>>>>>        Handle ho
83811>>>>>>>>>        String sRetval
83811>>>>>>>>>        Get phoSQLConnectionIniFile to ho
83812>>>>>>>>>        Get EncryptPassword of ho sPassword to sRetval
83813>>>>>>>>>        Function_Return sRetval
83814>>>>>>>>>    End_Function
83815>>>>>>>>>
83815>>>>>>>>>    Function DecryptPassword String sPassword Returns String
83817>>>>>>>>>        Handle ho
83817>>>>>>>>>        String sRetval
83817>>>>>>>>>        Get phoSQLConnectionIniFile to ho
83818>>>>>>>>>        Get DecryptPassword of ho sPassword to sRetval
83819>>>>>>>>>        Function_Return sRetval
83820>>>>>>>>>    End_Function
83821>>>>>>>>>
83821>>>>>>>>>    // *** Main Connection Message ***
83821>>>>>>>>>    // It will create a Connection ID for the passed driver.
83821>>>>>>>>>    // It will also set the psDriverID & psConnectionID of this class.
83821>>>>>>>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent
83823>>>>>>>>>        Handle hoDriver
83823>>>>>>>>>        String sConnectionString sError
83823>>>>>>>>>        Boolean bLoginSuccessful
83823>>>>>>>>>
83823>>>>>>>>>        Get ConstructConnectionString sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnectionString
83824>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
83825>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
83826>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
83827>>>>>>>>>        If (bLoginSuccessful = False) Begin
83829>>>>>>>>>            Error DFERR_PROGRAM (CS_DUF_CannotLoginToServer * CS_DUF_ErrorText * String(sError) + "\nConnectionID = " * sConnectionID + "\nConnection String = " * sConnectionString)
83830>>>>>>>>>>
83830>>>>>>>>>            Send Exit_Application
83831>>>>>>>>>        End
83831>>>>>>>>>>
83831>>>>>>>>>        Send Destroy of hoDriver
83832>>>>>>>>>
83832>>>>>>>>>    End_Procedure
83833>>>>>>>>>
83833>>>>>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
83835>>>>>>>>>        Integer iRetval
83835>>>>>>>>>        Handle hoCLI
83835>>>>>>>>>        String sDriverID
83835>>>>>>>>>
83835>>>>>>>>>        Get psDriverID to sDriverID
83836>>>>>>>>>        Get Create (Refclass(cCLIHandler)) to hoCLI
83837>>>>>>>>>        If (hoCLI <> 0) Begin
83839>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
83840>>>>>>>>>            Get RedirectConnection of hoCLI sOldConnection sNewConnection to iRetval
83841>>>>>>>>>            Send Destroy of hoCLI
83842>>>>>>>>>        End
83842>>>>>>>>>>
83842>>>>>>>>>
83842>>>>>>>>>        Function_Return iRetval
83843>>>>>>>>>    End_Function
83844>>>>>>>>>
83844>>>>>>>>>    Procedure CreateConnParamsFromConnectionString String sDriverID String sConnectionString
83846>>>>>>>>>        String sServer sDatabase sUserID sPassword
83846>>>>>>>>>        tSQLConnection SQLConnection
83846>>>>>>>>>        tSQLConnection SQLConnection
83846>>>>>>>>>
83846>>>>>>>>>        Set psDriverID to sDriverID
83847>>>>>>>>>        Get DeComposeConnectionString sDriverID sConnectionString to SQLConnection
83848>>>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID SQLConnection.sServer;                                 SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted
83849>>>>>>>>>    End_Procedure
83850>>>>>>>>>
83850>>>>>>>>>    // This is needed when e.g. the connection id we have specified in the program code
83850>>>>>>>>>    // also exists in e.g. the MSSQLDRV.ini file (can either be local in the Data folder
83850>>>>>>>>>    // or the one in the DataFlex Bin folder.)
83850>>>>>>>>>    // We then need to delete the current one before creating a new one.
83850>>>>>>>>>    // This is because the parameters may differ between the program code and the
83850>>>>>>>>>    // MSSQLDRV.ini file in a deployed environment. Also DataFlex will generate an error
83850>>>>>>>>>    // when one tries to create a Connection ID that already exists.
83850>>>>>>>>>    Procedure RemoveExistingConnectionID String sDriverID String sConnectionID
83852>>>>>>>>>        Integer iResult iDriver iNumConn iConn
83852>>>>>>>>>        Handle hoCLI
83852>>>>>>>>>        String sID
83852>>>>>>>>>
83852>>>>>>>>>        If (sDriverID = "" or sConnectionID = "") Begin
83854>>>>>>>>>            Procedure_Return
83855>>>>>>>>>        End
83855>>>>>>>>>>
83855>>>>>>>>>
83855>>>>>>>>>        Move 0 to iResult
83856>>>>>>>>>        Get Create U_cCLIHandler to hoCLI
83857>>>>>>>>>        If (hoCLI <> 0) Begin
83859>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
83860>>>>>>>>>            Get DriverIndex sDriverID to iDriver
83861>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
83864>>>>>>>>>            Decrement iNumConn
83865>>>>>>>>>            For iConn from 0 to iNumConn
83871>>>>>>>>>>
83871>>>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
83874>>>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
83876>>>>>>>>>                    Get DeleteConnectionID of hoCLI sConnectionID -1 to iResult
83877>>>>>>>>>                End
83877>>>>>>>>>>
83877>>>>>>>>>            Loop
83878>>>>>>>>>>
83878>>>>>>>>>            Send Destroy of hoCLI
83879>>>>>>>>>        End
83879>>>>>>>>>>
83879>>>>>>>>>
83879>>>>>>>>>    End_Procedure
83880>>>>>>>>>
83880>>>>>>>>>    Function ExistingConnectionSettings String sDriverID String sConnectionID Returns tSQLConnection
83882>>>>>>>>>        Integer iResult iDriver iNumConn iConn
83882>>>>>>>>>        Handle hoCLI
83882>>>>>>>>>        String sID sConnectionString sVal sDatabase
83882>>>>>>>>>        tSQLConnection SQLConnection
83882>>>>>>>>>        tSQLConnection SQLConnection
83882>>>>>>>>>        Boolean bTrusted
83882>>>>>>>>>
83882>>>>>>>>>        Move 0 to iResult
83883>>>>>>>>>        Get Create U_cCLIHandler to hoCLI
83884>>>>>>>>>        If (hoCLI <> 0) Begin
83886>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
83887>>>>>>>>>            Get DriverIndex sDriverID to iDriver
83888>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
83891>>>>>>>>>            Decrement iNumConn
83892>>>>>>>>>            For iConn from 0 to iNumConn
83898>>>>>>>>>>
83898>>>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
83901>>>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
83903>>>>>>>>>                    Move sDriverID                                                      to SQLConnection.sDriverID      // For completeness only...
83904>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn              to SQLConnection.sConnectionID  // For completeness only...
83907>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iConn       to sConnectionString
83910>>>>>>>>>                    Move sConnectionString                                              to SQLConnection.sConnectionString
83911>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_OPTIONS of iDriver iConn      to SQLConnection.bSilentLogin
83914>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnection.sServer
83915>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnection.sDatabase
83916>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to SQLConnection.sUserID
83917>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to SQLConnection.sPassword
83918>>>>>>>>>
83918>>>>>>>>>                    Case Begin
83918>>>>>>>>>                        Case (sDriverID = MSSQLDRV_ID)
83920>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=") to sVal
83921>>>>>>>>>                            Move (If(Uppercase(sVal) = Uppercase(CS_SQLIniConnectionYes), True, False)) to bTrusted
83922>>>>>>>>>                            Move bTrusted                                               to SQLConnection.bTrusted
83923>>>>>>>>>                            Case Break
83924>>>>>>>>>                        Case (sDriverID = DB2_DRV_ID)
83927>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
83928>>>>>>>>>                            Case Break
83929>>>>>>>>>                        Case (sDriverID = ODBC_DRV_ID)
83932>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
83933>>>>>>>>>                            Case Break
83934>>>>>>>>>                        Case (sDriverID = SQLFLEX)
83937>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
83938>>>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
83939>>>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
83941>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
83942>>>>>>>>>                            End
83942>>>>>>>>>>
83942>>>>>>>>>                            Else Begin
83943>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
83944>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
83945>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
83946>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
83947>>>>>>>>>                            End
83947>>>>>>>>>>
83947>>>>>>>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
83948>>>>>>>>>                            Case Break
83949>>>>>>>>>                        Case (sDriverID = MDSMySQL)
83952>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
83953>>>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
83954>>>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
83956>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
83957>>>>>>>>>                            End
83957>>>>>>>>>>
83957>>>>>>>>>                            Else Begin
83958>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
83959>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
83960>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
83961>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
83962>>>>>>>>>                            End
83962>>>>>>>>>>
83962>>>>>>>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
83963>>>>>>>>>                            Case Break
83964>>>>>>>>>                        Case (sDriverID = MDSPgSQL)
83967>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
83968>>>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
83969>>>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
83971>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
83972>>>>>>>>>                            End
83972>>>>>>>>>>
83972>>>>>>>>>                            Else Begin
83973>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
83974>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
83975>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
83976>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
83977>>>>>>>>>                            End
83977>>>>>>>>>>
83977>>>>>>>>>                            Move sConnectionString                                                to SQLConnection.sConnectionString
83978>>>>>>>>>                            Case Break
83979>>>>>>>>>
83979>>>>>>>>>                        Case (sDriverID = ORAFLEX)
83982>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to SQLConnection.sServer
83983>>>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)         to sConnectionString
83984>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
83985>>>>>>>>>                            If (sDatabase <> "" and (not(SQLConnection.sServer contains "/"))) Begin
83987>>>>>>>>>                                Move (SQLConnection.sServer + "/" + sDatabase)                  to SQLConnection.sServer
83988>>>>>>>>>                            End
83988>>>>>>>>>>
83988>>>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
83990>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
83991>>>>>>>>>                            End
83991>>>>>>>>>>
83991>>>>>>>>>                            Else Begin
83992>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
83993>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
83994>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
83995>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
83996>>>>>>>>>                            End
83996>>>>>>>>>>
83996>>>>>>>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
83997>>>>>>>>>                            Case Break
83998>>>>>>>>>                        Case Else
83998>>>>>>>>>                            Error ("Wrong driver ID passed:" * sDriverID)
83999>>>>>>>>>>
83999>>>>>>>>>                            Case Break
84000>>>>>>>>>                    Case End
84000>>>>>>>>>                End
84000>>>>>>>>>>
84000>>>>>>>>>            Loop
84001>>>>>>>>>>
84001>>>>>>>>>            Send Destroy of hoCLI
84002>>>>>>>>>        End
84002>>>>>>>>>>
84002>>>>>>>>>
84002>>>>>>>>>        Function_Return SQLConnection
84003>>>>>>>>>    End_Function
84004>>>>>>>>>
84004>>>>>>>>>    Function DriverIndex String sDriverID Returns Integer
84006>>>>>>>>>        String  sCurrentDriver
84006>>>>>>>>>        Integer iNumberOfDrivers iDriver iCount
84006>>>>>>>>>
84006>>>>>>>>>        Move 0 to iDriver
84007>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
84010>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
84016>>>>>>>>>>
84016>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
84019>>>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
84021>>>>>>>>>                Function_Return iCount
84022>>>>>>>>>            End
84022>>>>>>>>>>
84022>>>>>>>>>        Loop
84023>>>>>>>>>>
84023>>>>>>>>>
84023>>>>>>>>>        // If driver not previously loaded; attempt to do so now.
84023>>>>>>>>>        If (iDriver = 0) Begin
84025>>>>>>>>>            Move 0 to LastErr
84026>>>>>>>>>            Load_Driver sDriverID
84027>>>>>>>>>            // If driver could not be loaded.
84027>>>>>>>>>            If (LastErr = 4255) Begin
84029>>>>>>>>>                Move 0 to iCount
84030>>>>>>>>>            End
84030>>>>>>>>>>
84030>>>>>>>>>            Function_Return iCount
84031>>>>>>>>>        End
84031>>>>>>>>>>
84031>>>>>>>>>        Function_Return 0
84032>>>>>>>>>    End_Function
84033>>>>>>>>>
84033>>>>>>>>>    // This will update connection settings of the cCLIHandler object with that passed struct values.
84033>>>>>>>>>    Procedure UpdateConnectionString tSQLConnection SQLConnection
84035>>>>>>>>>        String sDriverID sConnectionID sServer sDatabase sUserID sPassword
84035>>>>>>>>>        Boolean bTrusted bSilent
84035>>>>>>>>>
84035>>>>>>>>>        Move SQLConnection.sDriverID     to sDriverID
84036>>>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
84037>>>>>>>>>        Move SQLConnection.sServer       to sServer
84038>>>>>>>>>        Move SQLConnection.sDatabase     to sDatabase
84039>>>>>>>>>        Move SQLConnection.bTrusted      to bTrusted
84040>>>>>>>>>        Move SQLConnection.sUserID       to sUserID
84041>>>>>>>>>        Move SQLConnection.sPassword     to sPassword
84042>>>>>>>>>        Move SQLConnection.bSilentLogin  to bSilent
84043>>>>>>>>>
84043>>>>>>>>>        Send CreateSQLConnection sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent
84044>>>>>>>>>        // Note that this message will first delete the current ConnectionID if it exists; which is needed by the cCLIHandler logic.
84044>>>>>>>>>        Send AutoSetConnectionID
84045>>>>>>>>>    End_Procedure
84046>>>>>>>>>
84046>>>>>>>>>    // Called when the object is constructed.
84046>>>>>>>>>    // It will check the psDriverID for a ConnectionID and save it
84046>>>>>>>>>    // as psConnectionID property. It is later used whenever a login to
84046>>>>>>>>>    // the database is needed.
84046>>>>>>>>>    Procedure AutoSetConnectionID
84048>>>>>>>>>        String sConnectionID sDriverID sConnectionString
84048>>>>>>>>>        Integer iDriver iRetval
84048>>>>>>>>>        Handle hoCLI
84048>>>>>>>>>        Boolean bOK bSilent bMertechDriver
84048>>>>>>>>>
84048>>>>>>>>>        Get pbSilentLogin      to bSilent
84049>>>>>>>>>        Get psConnectionID     to sConnectionID
84050>>>>>>>>>        Get psConnectionString to sConnectionString
84051>>>>>>>>>        // Get the driver Connection ID string & set the psConnectionString property.
84051>>>>>>>>>        Get psDriverID to sDriverID
84052>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84053>>>>>>>>>        If (bOK = False) Begin
84055>>>>>>>>>            Procedure_Return
84056>>>>>>>>>        End
84056>>>>>>>>>>
84056>>>>>>>>>
84056>>>>>>>>>        // Mertech drivers can't use connection ID's.
84056>>>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
84057>>>>>>>>>        If (bMertechDriver = True) Begin
84059>>>>>>>>>            // This ensures that the correct Server & Database attributes are set both for
84059>>>>>>>>>            // embedded SQL calls and "normal" database commands like e.g. "Open".
84059>>>>>>>>>            Get _MertechSQLManagerHandle to hoCLI
84060>>>>>>>>>            Procedure_Return
84061>>>>>>>>>        End
84061>>>>>>>>>>
84061>>>>>>>>>
84061>>>>>>>>>        Get DriverIndex sDriverID          to iDriver
84062>>>>>>>>>        // If driver not loaded; load it.
84062>>>>>>>>>        If (iDriver = 0) Begin
84064>>>>>>>>>            Load_Driver sDriverID
84065>>>>>>>>>            Get DriverIndex sDriverID      to iDriver
84066>>>>>>>>>        End
84066>>>>>>>>>>
84066>>>>>>>>>        // This shouldn't be possible; unless the driver.dll file is missing or something...
84066>>>>>>>>>        If (iDriver = 0) Begin
84068>>>>>>>>>            Error DFERR_PROGRAM ("The database driver could not be loaded! Connection to database failed." * sDriverID)
84069>>>>>>>>>>
84069>>>>>>>>>            Procedure_Return
84070>>>>>>>>>        End
84070>>>>>>>>>>
84070>>>>>>>>>
84070>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
84071>>>>>>>>>        Set psDriverID of hoCLI            to sDriverID
84072>>>>>>>>>        // Delete the connection first; in case it exists
84072>>>>>>>>>        Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
84073>>>>>>>>>        Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to iRetval
84074>>>>>>>>>
84074>>>>>>>>>        Send Destroy of hoCLI
84075>>>>>>>>>    End_Procedure
84076>>>>>>>>>
84076>>>>>>>>>    // Returns the handle of the Mertech SQL handler.
84076>>>>>>>>>    // It also ensures that the correct Server & Database attributes are set both for
84076>>>>>>>>>    // embedded SQL calls and "normal" database commands like e.g. "Open".
84076>>>>>>>>>    // Note: This does _not_ return a proper CLI handler handle as it is not in this class.
84076>>>>>>>>>    //       So the return value is of no use! But we don't need the handle for this class.
84076>>>>>>>>>    Function _MertechSQLManagerHandle Returns Handle
84078>>>>>>>>>        Handle hoSQLHandler
84078>>>>>>>>>        String sDriverID sServer sDatabase
84078>>>>>>>>>
84078>>>>>>>>>        Move 0 to hoSQLHandler
84079>>>>>>>>>        Get psDriverID to sDriverID
84080>>>>>>>>>        Get psServer   to sServer
84081>>>>>>>>>        Get psDatabase to sDatabase
84082>>>>>>>>>
84082>>>>>>>>>        Function_Return hoSQLHandler
84083>>>>>>>>>    End_Function
84084>>>>>>>>>
84084>>>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
84086>>>>>>>>>        Boolean bOK bMertechDriver
84086>>>>>>>>>
84086>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
84087>>>>>>>>>
84087>>>>>>>>>        If (bOK = False) Begin
84089>>>>>>>>>            Get IsMertechDriver sDriverID to bOK
84090>>>>>>>>>        End
84090>>>>>>>>>>
84090>>>>>>>>>
84090>>>>>>>>>        If (bOK = False) Begin
84092>>>>>>>>>            Get IsMertechDriver sDriverID to bMertechDriver
84093>>>>>>>>>            If (bMertechDriver = True) Begin
84095>>>>>>>>>                Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID, ODBC_DRV_ID, SQLFLEX, ORAFLEX, MDSPgSQL or MDSMYSQL"
84096>>>>>>>>>>
84096>>>>>>>>>            End
84096>>>>>>>>>>
84096>>>>>>>>>            Else Begin
84097>>>>>>>>>                Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID or ODBC_DRV_ID"
84098>>>>>>>>>>
84098>>>>>>>>>            End
84098>>>>>>>>>>
84098>>>>>>>>>            Function_Return False
84099>>>>>>>>>        End
84099>>>>>>>>>>
84099>>>>>>>>>
84099>>>>>>>>>        Function_Return True
84100>>>>>>>>>    End_Function
84101>>>>>>>>>
84101>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
84103>>>>>>>>>        Boolean bOK
84103>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
84104>>>>>>>>>        Function_Return bOK
84105>>>>>>>>>    End_Function
84106>>>>>>>>>
84106>>>>>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
84108>>>>>>>>>        Boolean bOK
84108>>>>>>>>>        Move False to bOK
84109>>>>>>>>>        Function_Return bOK
84110>>>>>>>>>    End_Function
84111>>>>>>>>>
84111>>>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
84113>>>>>>>>>        Handle hoIniFile
84113>>>>>>>>>        String sConnect
84113>>>>>>>>>
84113>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
84114>>>>>>>>>        Get ConstructConnectionString of hoIniFile sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnect
84115>>>>>>>>>
84115>>>>>>>>>        Function_Return sConnect
84116>>>>>>>>>    End_Function
84117>>>>>>>>>
84117>>>>>>>>>    // Sample sConnString: "SERVER=(local)\SQLEXPRESS;UID=dbuser;PWD=secret;DATABASE=OrderEntry;, 0"
84117>>>>>>>>>    // Pass a complete driver connection string
84117>>>>>>>>>    // Returns the following as a struct:
84117>>>>>>>>>    //   sServer, sDatabase, sUser, sPassword & True if Trusted_Connection is used.
84117>>>>>>>>>    // Finally also returns a boolean TRUE if trusted_connection=yes, else false is returned.
84117>>>>>>>>>    //
84117>>>>>>>>>    Function DeComposeConnectionString String sDriverID String sConnectionString Returns tSQLConnection
84119>>>>>>>>>        tSQLConnection SQLConnection
84119>>>>>>>>>        tSQLConnection SQLConnection
84119>>>>>>>>>        String sValue sConnectionID sServer sDatabase sUserID sPassword
84119>>>>>>>>>        Boolean bTrusted bSilent bOK
84119>>>>>>>>>        Integer iPos
84119>>>>>>>>>
84119>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84120>>>>>>>>>        If (bOK = False) Begin
84122>>>>>>>>>            Function_Return SQLConnection
84123>>>>>>>>>        End
84123>>>>>>>>>>
84123>>>>>>>>>
84123>>>>>>>>>        Move False to bTrusted
84124>>>>>>>>>        Move False to bSilent
84125>>>>>>>>>
84125>>>>>>>>>        Case Begin
84125>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
84127>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
84128>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
84129>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
84130>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
84131>>>>>>>>>                If (bTrusted = False) Begin
84133>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
84134>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
84135>>>>>>>>>                End
84135>>>>>>>>>>
84135>>>>>>>>>                Case Break
84136>>>>>>>>>
84136>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
84139>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
84140>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
84141>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
84142>>>>>>>>>                If (bTrusted = False) Begin
84144>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
84145>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
84146>>>>>>>>>                End
84146>>>>>>>>>>
84146>>>>>>>>>                Case Break
84147>>>>>>>>>
84147>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
84150>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
84151>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
84152>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
84153>>>>>>>>>                Case Break
84154>>>>>>>>>
84154>>>>>>>>>            Case (sDriverID = SQLFLEX)
84157>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
84158>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
84159>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
84160>>>>>>>>>                If (bTrusted = False) Begin
84162>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
84163>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
84164>>>>>>>>>                End
84164>>>>>>>>>>
84164>>>>>>>>>                Case Break
84165>>>>>>>>>
84165>>>>>>>>>            Case (sDriverID = ORAFLEX)
84168>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
84169>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
84170>>>>>>>>>                If (sDatabase <> "" and (not(sServer contains "/"))) Begin
84172>>>>>>>>>                    Move (sServer + "/" + sDatabase)                                to sServer
84173>>>>>>>>>                End
84173>>>>>>>>>>
84173>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
84174>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
84175>>>>>>>>>                Case Break
84176>>>>>>>>>
84176>>>>>>>>>            Case (sDriverID = MDSPgSQL)
84179>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
84180>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
84181>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
84182>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
84183>>>>>>>>>                Case Break
84184>>>>>>>>>
84184>>>>>>>>>            Case (sDriverID = MDSMySQL)
84187>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
84188>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
84189>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
84190>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
84191>>>>>>>>>                Case Break
84192>>>>>>>>>
84192>>>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
84195>>>>>>>>>                Break
84196>>>>>>>>>        Case End
84196>>>>>>>>>
84196>>>>>>>>>        Get ParseKeyWord sConnectionString (Uppercase(CS_SQLConnectionIDText))  to sConnectionID
84197>>>>>>>>>
84197>>>>>>>>>        // bSilent?
84197>>>>>>>>>        Move (Pos(",0", sConnectionString))                                     to iPos
84198>>>>>>>>>        If (iPos = 0) Begin
84200>>>>>>>>>            Move (Pos(",1", sConnectionString))                                 to iPos
84201>>>>>>>>>        End
84201>>>>>>>>>>
84201>>>>>>>>>        If (iPos = 0) Begin
84203>>>>>>>>>            Move "0"                                                            to sValue
84204>>>>>>>>>        End
84204>>>>>>>>>>
84204>>>>>>>>>        Else Begin
84205>>>>>>>>>            Move (Mid(sConnectionString, 1, (iPos +1)))                         to sValue
84206>>>>>>>>>        End
84206>>>>>>>>>>
84206>>>>>>>>>        Move (If(sValue = 1, True, False))                                      to bSilent
84207>>>>>>>>>
84207>>>>>>>>>        Move (Trim(sDriverID))                                                  to SQLConnection.sDriverID
84208>>>>>>>>>        Move (Trim(sConnectionID))                                              to SQLConnection.sConnectionID
84209>>>>>>>>>        Move (Trim(sConnectionString))                                          to SQLConnection.sConnectionString
84210>>>>>>>>>        Move (Trim(sServer))                                                    to SQLConnection.sServer
84211>>>>>>>>>        Move (Trim(sDatabase))                                                  to SQLConnection.sDatabase
84212>>>>>>>>>        Move bTrusted                                                           to SQLConnection.bTrusted
84213>>>>>>>>>        Move (Trim(sUserID))                                                    to SQLConnection.sUserID
84214>>>>>>>>>        Move (Trim(sPassword))                                                  to SQLConnection.sPassword
84215>>>>>>>>>        Move bSilent                                                            to SQLConnection.bSilentLogin
84216>>>>>>>>>
84216>>>>>>>>>        Function_Return SQLConnection
84217>>>>>>>>>    End_Function
84218>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
84218>>>>>>>>>>
84218>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
84220>>>>>>>>>>    Integer iStart iEnd
84220>>>>>>>>>>    String sRetval
84220>>>>>>>>>>
84220>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
84221>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
84222>>>>>>>>>>    If (iStart = 0) Begin
84224>>>>>>>>>>        Function_Return ""
84225>>>>>>>>>>    End
84225>>>>>>>>>>>
84225>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
84226>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
84227>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
84229>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
84230>>>>>>>>>>    End
84230>>>>>>>>>>>
84230>>>>>>>>>>    Else Begin
84231>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
84232>>>>>>>>>>    End
84232>>>>>>>>>>>
84232>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
84234>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
84235>>>>>>>>>>        Decrement iEnd
84236>>>>>>>>>>    End
84236>>>>>>>>>>>
84236>>>>>>>>>>    If (iEnd <> 0) Begin
84238>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
84239>>>>>>>>>>    End
84239>>>>>>>>>>>
84239>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
84240>>>>>>>>>>
84240>>>>>>>>>>    Function_Return (Trim(sRetval))
84241>>>>>>>>>>End_Function
84242>>>>>>>>>>
84242>>>>>>>>>>
84242>>>>>>>>>
84242>>>>>>>>>    // To update the SQLSettings.ini file with updated connection data (SQLConnection struct data).
84242>>>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
84244>>>>>>>>>        Handle ho
84244>>>>>>>>>        Integer iIndex
84244>>>>>>>>>        Boolean bRetval bOK
84244>>>>>>>>>        tSQLConnection SQLConnection
84244>>>>>>>>>        tSQLConnection SQLConnection
84244>>>>>>>>>
84244>>>>>>>>>        Get pSQLConnection to SQLConnection
84245>>>>>>>>>        Get phoSQLConnectionIniFile to ho
84246>>>>>>>>>        Get SQLIniFileConnectionIDIndex of ho sConnectionID to iIndex
84247>>>>>>>>>        If (iIndex = -1) Begin
84249>>>>>>>>>            Function_Return False
84250>>>>>>>>>        End
84250>>>>>>>>>>
84250>>>>>>>>>
84250>>>>>>>>>        Get SQLIniFileUpdateConnection of ho SQLConnection to bRetval
84251>>>>>>>>>        Send UpdateConnectionString of ghoSQLConnectionHandler SQLConnection
84252>>>>>>>>>        If (ghoConnection > 0) Begin
84254>>>>>>>>>            Get ConnectionIdIndex of ghoConnection SQLConnection.sConnectionID to iIndex
84255>>>>>>>>>            If (iIndex <> -1) Begin
84257>>>>>>>>>                Get RedirectConnectionId of ghoConnection SQLConnection.sConnectionID (SQLConnection.sServer + ";" + CS_SQLIniDatabaseKeyword + "=" + SQLConnection.sDatabase) SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted True to bOK
84258>>>>>>>>>            End
84258>>>>>>>>>>
84258>>>>>>>>>        End
84258>>>>>>>>>>
84258>>>>>>>>>
84258>>>>>>>>>        Function_Return bRetval
84259>>>>>>>>>    End_Function
84260>>>>>>>>>
84260>>>>>>>>>End_Class
84261>>>>>>>Use vWin32fh.pkg
84261>>>>>>>
84261>>>>>>>//
84261>>>>>>>Class cDbUpdateFunctionLibrary is a cObject
84262>>>>>>>    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
Including file: ParseKeyWord.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
84263>>>>>>>>
84263>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
84265>>>>>>>>    Integer iStart iEnd
84265>>>>>>>>    String sRetval
84265>>>>>>>>
84265>>>>>>>>    Move (Trim(sConnect)) to sConnect
84266>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
84267>>>>>>>>    If (iStart = 0) Begin
84269>>>>>>>>        Function_Return ""
84270>>>>>>>>    End
84270>>>>>>>>>
84270>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
84271>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
84272>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
84274>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
84275>>>>>>>>    End
84275>>>>>>>>>
84275>>>>>>>>    Else Begin
84276>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
84277>>>>>>>>    End
84277>>>>>>>>>
84277>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
84279>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
84280>>>>>>>>        Decrement iEnd
84281>>>>>>>>    End
84281>>>>>>>>>
84281>>>>>>>>    If (iEnd <> 0) Begin
84283>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
84284>>>>>>>>    End
84284>>>>>>>>>
84284>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
84285>>>>>>>>
84285>>>>>>>>    Function_Return (Trim(sRetval))
84286>>>>>>>>End_Function
84287>>>>>>>>
84287>>>>>>>>
84287>>>>>>>
84287>>>>>>>    Procedure Construct_Object
84289>>>>>>>        Handle ho
84289>>>>>>>        Forward Send Construct_Object
84291>>>>>>>
84291>>>>>>>        Move Self to ghoDbUpdateFunctionLibrary
84292>>>>>>>
84292>>>>>>>        Send CreateDbUpdateLibraryProperties
84293>>>>>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
84293>>>>>>>        // we will create one as it is used for all ConnectionID, ConnectionString
84293>>>>>>>        // etc settings.
84293>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
84295>>>>>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
84296>>>>>>>            Set phoSQLConnectionHandler to ho
84297>>>>>>>        End
84297>>>>>>>>
84297>>>>>>>
84297>>>>>>>    End_Procedure
84298>>>>>>>
84298>>>>>>>    Procedure End_Construct_Object
84300>>>>>>>        Forward Send End_Construct_Object
84302>>>>>>>    End_Procedure
84303>>>>>>>
84303>>>>>>>    // *** SQL Messages for making changes to the SQL back-end ***
84303>>>>>>>    //
84303>>>>>>>    // * Dummy function for the Studio's Code Explorer *
84303>>>>>>>    Function SQL_DATABASE_FUNCTIONS Returns Boolean
84305>>>>>>>        Function_Return False
84306>>>>>>>    End_Function
84307>>>>>>>
84307>>>>>>>    // Function for creating a new *Database*.
84307>>>>>>>    // Note: This is for creating SQL DATABASES - not tables!
84307>>>>>>>    // Returns True if successful.
84307>>>>>>>    // ToDo: Only works for MS-SQL...
84307>>>>>>>    Function SqlDatabaseCreate String sDriverID String sDatabase Boolean bUpdateConnectionString Boolean bPermanantly Returns Boolean
84309>>>>>>>        String sSQL sSQL1 sConnectionID sConnectionString 
84309>>>>>>>        String sCreateDatabaseKeyWord sSelectFromWhereName sCollation sCollateKeyWord
84309>>>>>>>        Handle hConnection hStmt hoSQLManager
84309>>>>>>>        Integer iFetchResult iDbType
84309>>>>>>>        Boolean bOK bMertechDriver
84309>>>>>>>
84309>>>>>>>        Get piDbType to iDbType
84310>>>>>>>        If (iDbType <> EN_DbTypeMSSQL) Begin
84312>>>>>>>            Error DFERR_PROGRAM "Sorry, the SqlDatabaseCreate function is currently only supported for MS-SQL"
84313>>>>>>>>
84313>>>>>>>            Function_Return False
84314>>>>>>>        End
84314>>>>>>>>
84314>>>>>>>
84314>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
84315>>>>>>>        If (bMertechDriver = False) Begin
84317>>>>>>>            Get phoSQLManager to hoSQLManager
84318>>>>>>>        End
84318>>>>>>>>
84318>>>>>>>        Else Begin
84319>>>>>>>            Get _MertechSQLManagerHandle to hoSQLManager
84320>>>>>>>        End
84320>>>>>>>>
84320>>>>>>>        
84320>>>>>>>        Get psConnectionID     to sConnectionID
84321>>>>>>>        Get psConnectionString to sConnectionString
84322>>>>>>>        Move 0 to LastErr
84323>>>>>>>
84323>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84324>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
84325>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84326>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
84328>>>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
84329>>>>>>>>
84329>>>>>>>            Function_Return False
84330>>>>>>>        End
84330>>>>>>>>
84330>>>>>>>
84330>>>>>>>        Get SqlOpen of hConnection to hStmt
84331>>>>>>>
84331>>>>>>>        If (hStmt = 0) Begin
84333>>>>>>>            Send SqlDisconnect of hoSQLManager
84334>>>>>>>            Error DFERR_PROGRAM CS_SQLConnectError
84335>>>>>>>>
84335>>>>>>>            Function_Return False
84336>>>>>>>        End
84336>>>>>>>>
84336>>>>>>>
84336>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateDatabase to sCreateDatabaseKeyWord
84337>>>>>>>        Get _SqlSelectFromWhereName to sSelectFromWhereName
84338>>>>>>>        Move (sSelectFromWhereName + "='" + sDatabase + "'") to sSQL 
84339>>>>>>>        
84339>>>>>>>        // Check if database exists
84339>>>>>>>        Send SqlExecDirect of hStmt sSQL
84340>>>>>>>        Get SqlFetch of hStmt to iFetchResult
84341>>>>>>>        Send SqlClose of hStmt
84342>>>>>>>        Send SqlDisconnect of hConnection
84343>>>>>>>
84343>>>>>>>        // If database already exists we're out of here!
84343>>>>>>>        // Note that we return True as this is not an error.
84343>>>>>>>        If (iFetchResult > 0) Begin
84345>>>>>>>            Function_Return True
84346>>>>>>>        End
84346>>>>>>>>
84346>>>>>>>
84346>>>>>>>        // Database doesn't exist, create it.
84346>>>>>>>        If (iFetchResult = 0) Begin
84348>>>>>>>            Move (sCreateDatabaseKeyWord + " [" + sDatabase + "]") to sSQL1
84349>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84350>>>>>>>
84350>>>>>>>            Get psCollation to sCollation
84351>>>>>>>            If (sCollation <> "") Begin
84353>>>>>>>                Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
84354>>>>>>>                Move (sSQL1 * String(sCollateKeyWord) * String(sCollation)) to sSQL1
84355>>>>>>>            End
84355>>>>>>>>
84355>>>>>>>
84355>>>>>>>            Send SqlUtilExecuteQuery sSQL1 sDriverID
84356>>>>>>>
84356>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84357>>>>>>>            If (LastErr = CLIERR_GENERAL_ERROR) Begin
84359>>>>>>>               Function_Return False
84360>>>>>>>            End
84360>>>>>>>>
84360>>>>>>>
84360>>>>>>>            // We need to wait a short time for Sql to finish, especially Windows to write the new file to disk.
84360>>>>>>>            Sleep 1
84361>>>>>>>            Send SqlUtilExecuteQuery sSQL sDriverID
84362>>>>>>>        End
84362>>>>>>>>
84362>>>>>>>
84362>>>>>>>        // If used in e.g. the cDbUpdteHandler we want to change the login database name to
84362>>>>>>>        // the one we just created.
84362>>>>>>>        If (bUpdateConnectionString = True) Begin
84364>>>>>>>            Set psDatabase to sDatabase
84365>>>>>>>            //...and perhaps also the SQLConnections.ini file setting.
84365>>>>>>>            If (bPermanantly = True) Begin
84367>>>>>>>                If (ghoSQLConnectionHandler <> 0) Begin
84369>>>>>>>                    Get SQLIniFileSetDefaultConnection of ghoSQLConnectionHandler sConnectionID to bOK
84370>>>>>>>                End
84370>>>>>>>>
84370>>>>>>>            End
84370>>>>>>>>
84370>>>>>>>        End
84370>>>>>>>>
84370>>>>>>>
84370>>>>>>>        Function_Return (Err = False)
84371>>>>>>>    End_Function
84372>>>>>>>
84372>>>>>>>    // Backs up an SQL database to a folder of choice. If no path is passed the SQL default backup folder
84372>>>>>>>    // will be used.
84372>>>>>>>    Function SqlDatabaseBackupToDisk String sDatabase String sBackupName String sPath Boolean bShowProg Returns Boolean
84374>>>>>>>        Boolean bOK bExists bShowProgress
84374>>>>>>>        String sStatement sDriverID
84374>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84374>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84374>>>>>>>        Integer iDbType
84374>>>>>>>
84374>>>>>>>        If (sDatabase = "") Begin
84376>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
84377>>>>>>>>
84377>>>>>>>            Function_Return False
84378>>>>>>>        End
84378>>>>>>>>
84378>>>>>>>        If (sBackupName = "") Begin
84380>>>>>>>            Error DFERR_PROGRAM "The database backup name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
84381>>>>>>>>
84381>>>>>>>            Function_Return False
84382>>>>>>>        End
84382>>>>>>>>
84382>>>>>>>
84382>>>>>>>        // Create backup-folder if it doesn't exist
84382>>>>>>>        Get vFolderExists sPath to bExists
84383>>>>>>>        If (bExists = False) Begin
84385>>>>>>>            Get vCreateDirectory sPath to bOK
84386>>>>>>>            If (bOK = False) Begin
84388>>>>>>>                Error DFERR_PROGRAM ("Could not create database backup folder:" * sPath)
84389>>>>>>>>
84389>>>>>>>                Function_Return False
84390>>>>>>>            End
84390>>>>>>>>
84390>>>>>>>        End
84390>>>>>>>>
84390>>>>>>>        // Make sure the path ends with a back-slash
84390>>>>>>>        If (sPath <> "") Begin
84392>>>>>>>            Get vFolderFormat sPath to sPath
84393>>>>>>>        End
84393>>>>>>>>
84393>>>>>>>
84393>>>>>>>        Get psDriverID to sDriverID
84394>>>>>>>        Get piDbType   to iDbType
84395>>>>>>>        If (num_arguments > 3) Begin
84397>>>>>>>            Move bShowProg to bShowProgress
84398>>>>>>>        End
84398>>>>>>>>
84398>>>>>>>
84398>>>>>>>        Case Begin
84398>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
84400>>>>>>>                SQLIncludeScriptFile ..\Scripts\BackupMSSQLDatabase.sql as BackupMSSQLDatabase.sql
84400>>>>>>>                SQLIncludeScriptFile ..\Scripts\GetPercentageBackupCompletionMSSQL.sql as GetPercentageBackupCompletionMSSQL.sql
84400>>>>>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "BackupMSSQLDatabase.sql" sDriverID False to SQLScriptArray
84401>>>>>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "GetPercentageBackupCompletionMSSQL.sql" sDriverID False to SQLScriptArrayPercentReady
84402>>>>>>>
84402>>>>>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
84403>>>>>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase))   to sStatement
84404>>>>>>>                Move (Replaces("BACKUP_PATH_XXX",   sStatement, sPath))       to sStatement
84405>>>>>>>                Move (Replaces("BACKUP_NAME_XXX",   sStatement, sBackupName)) to sStatement
84406>>>>>>>                Move sStatement to SQLScriptArray.sSQLScriptArray[0]
84407>>>>>>>                Get SqlUtilExecuteEmbeddedScript of ghoDbUpdateFunctionLibrary SQLScriptArray sDriverID False "" bShowProgress to bOK
84408>>>>>>>                Case Break
84409>>>>>>>            Case Else
84409>>>>>>>                Send Info_Box ("The SqlUtilBackupDatabaseToDisk function is currently not implemented for the driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and add a little ESQL code snippet to make it work for that driver! Thanks for helping out.")
84410>>>>>>>        Case End
84410>>>>>>>
84410>>>>>>>        Function_Return bOK
84411>>>>>>>    End_Function
84412>>>>>>>
84412>>>>>>>    Function SqlDatabaseCollationQuery String sDatabase Returns String
84414>>>>>>>        Boolean bOK bExists 
84414>>>>>>>        String sStatement sDriverID sRetval sPrevious
84414>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84414>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84414>>>>>>>        Integer iDbType iRows iFetchResult iColumn
84414>>>>>>>        Handle hoSQLHandler hoSQLConnect hstmt 
84414>>>>>>>        tSQLConnection SQLConnection
84414>>>>>>>        tSQLConnection SQLConnection
84414>>>>>>>
84414>>>>>>>        If (sDatabase = "") Begin
84416>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilDatabaseCollation' function"
84417>>>>>>>>
84417>>>>>>>            Function_Return False
84418>>>>>>>        End
84418>>>>>>>>
84418>>>>>>>        
84418>>>>>>>        Move "" to sRetval
84419>>>>>>>        Get psDriverID to sDriverID
84420>>>>>>>        Get piDbType   to iDbType
84421>>>>>>>
84421>>>>>>>        Case Begin
84421>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
84423>>>>>>>                SQLIncludeScriptFile ..\Scripts\QueryMSSQLCollation.sql as QueryMSSQLCollation.sql
84423>>>>>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "QueryMSSQLCollation.sql" sDriverID False to SQLScriptArray
84424>>>>>>>
84424>>>>>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
84425>>>>>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase)) to sStatement
84426>>>>>>>                Get phoSQLManager to hoSQLHandler
84427>>>>>>>        
84427>>>>>>>                If (hoSQLHandler <> 0) Begin
84429>>>>>>>                    Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
84430>>>>>>>                    Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
84431>>>>>>>        
84431>>>>>>>                    If (hoSQLConnect <> 0) Begin
84433>>>>>>>                        Get SQLOpen of hoSQLConnect to hstmt
84434>>>>>>>                        If (hstmt <> 0) Begin
84436>>>>>>>                            Send SqlExecDirect of hstmt sStatement
84437>>>>>>>                            Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
84438>>>>>>>                            Get SQLFetch of hstmt to iFetchResult
84439>>>>>>>                            If (iFetchResult <> 0) Begin
84441>>>>>>>                                Get SQLColumnValue of hstmt 2 to sRetval // Column 1 = Database Name, 2 = Collation Name.
84442>>>>>>>                            End
84442>>>>>>>>
84442>>>>>>>                            Send SQLClose of hstmt
84443>>>>>>>                        End
84443>>>>>>>>
84443>>>>>>>                        Send SQLDisconnect of hoSQLConnect
84444>>>>>>>                    End
84444>>>>>>>>
84444>>>>>>>                End
84444>>>>>>>>
84444>>>>>>>                Case Break
84445>>>>>>>            Case Else
84445>>>>>>>                Send Info_Box ("The SqlDatabaseCollationQuery function is currently not implemented for the driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and add a little ESQL code snippet to make it work for that driver! Thanks for helping out.")
84446>>>>>>>        Case End
84446>>>>>>>
84446>>>>>>>        Function_Return sRetval
84447>>>>>>>    End_Function
84448>>>>>>>
84448>>>>>>>    Function SqlDatabaseCollationChange String sDatabase String sSQLCollation Returns Boolean
84450>>>>>>>        Boolean bOK bExists bMertechDriver
84450>>>>>>>        String sDriverID sSQL sSQL1 sConnectionID sConnectionString sSet sWith
84450>>>>>>>        String sAlterDatabaseKeyWord sCollateKeyWord sSQLCollationCheck sSingle_User sMulti_User sRollback sImmediate
84450>>>>>>>        Handle hConnection hStmt hoSQLManager
84450>>>>>>>        Integer iFetchResult iDbType
84450>>>>>>>
84450>>>>>>>        If (sDatabase = "") Begin
84452>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
84453>>>>>>>>
84453>>>>>>>            Function_Return False
84454>>>>>>>        End
84454>>>>>>>>
84454>>>>>>>        
84454>>>>>>>        If (sSQLCollation = "") Begin
84456>>>>>>>            Error DFERR_PROGRAM "The SQL Collation name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
84457>>>>>>>>
84457>>>>>>>            Function_Return False
84458>>>>>>>        End
84458>>>>>>>>
84458>>>>>>>        
84458>>>>>>>        Get psDriverID to sDriverID
84459>>>>>>>        Get piDbType   to iDbType
84460>>>>>>>
84460>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
84461>>>>>>>        If (bMertechDriver = False) Begin
84463>>>>>>>            Get phoSQLManager to hoSQLManager
84464>>>>>>>        End
84464>>>>>>>>
84464>>>>>>>        Else Begin
84465>>>>>>>            Get _MertechSQLManagerHandle to hoSQLManager
84466>>>>>>>        End
84466>>>>>>>>
84466>>>>>>>        
84466>>>>>>>        Get psConnectionID     to sConnectionID
84467>>>>>>>        Get psConnectionString to sConnectionString
84468>>>>>>>        Move 0 to LastErr
84469>>>>>>>
84469>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84470>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
84471>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84472>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
84474>>>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
84475>>>>>>>>
84475>>>>>>>            Function_Return False
84476>>>>>>>        End
84476>>>>>>>>
84476>>>>>>>
84476>>>>>>>        Get SqlOpen of hConnection to hStmt
84477>>>>>>>
84477>>>>>>>        If (hStmt = 0) Begin
84479>>>>>>>            Send SqlDisconnect of hoSQLManager
84480>>>>>>>            Error DFERR_PROGRAM CS_SQLConnectError
84481>>>>>>>>
84481>>>>>>>            Function_Return False
84482>>>>>>>        End
84482>>>>>>>>
84482>>>>>>>        
84482>>>>>>>        // Check if collation already exists   
84482>>>>>>>        Get SqlDatabaseCollationQuery sDatabase to sSQLCollationCheck
84483>>>>>>>        // If the current collate is the same as the new; do nothing.
84483>>>>>>>        If (sSQLCollation = sSQLCollationCheck) Begin
84485>>>>>>>            Function_Return True
84486>>>>>>>        End
84486>>>>>>>>
84486>>>>>>>            
84486>>>>>>>        Get _SqlFindKeyWord CI_SQLSet               to sSet
84487>>>>>>>        Get _SqlFindKeyWord CI_SQLWith              to sWith
84488>>>>>>>        Get _SqlFindKeyWord CI_SQLSingle_User       to sSingle_User
84489>>>>>>>        Get _SqlFindKeyWord CI_SQLMulti_User        to sMulti_User
84490>>>>>>>        Get _SqlFindKeyWord CI_SQLRollback          to sRollback
84491>>>>>>>        Get _SqlFindKeyWord CI_SQLIMMEDIATE         to sImmediate
84492>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterDatabase     to sAlterDatabaseKeyWord
84493>>>>>>>        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
84494>>>>>>>        
84494>>>>>>>        // MS-SQL Syntax:
84494>>>>>>>        // ALTER DATABASE [database] SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
84494>>>>>>>        // ALTER DATABASE [database] COLLATE SQL_1xCompat_CP850_CI_AS;
84494>>>>>>>        // ALTER DATABASE [database] SET MULTI_USER;
84494>>>>>>>        Move (              sAlterDatabaseKeyWord  * String(sDatabase) * String(sSet) * String(sSingle_User) * String(sWith) * String(sRollback) * String(sImmediate)) to sSQL
84495>>>>>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
84496>>>>>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sSet) * String(sMulti_User)) to sSQL
84497>>>>>>>//        Move (sAlterDatabaseKeyWord * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL 
84497>>>>>>>        
84497>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84498>>>>>>>        Send SqlUtilExecuteQuery sSQL sDriverID False
84499>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84500>>>>>>>        If (LastErr = CLIERR_GENERAL_ERROR) Begin
84502>>>>>>>           Function_Return False
84503>>>>>>>        End
84503>>>>>>>>
84503>>>>>>>
84503>>>>>>>        Function_Return (Err = False)
84504>>>>>>>    End_Function
84505>>>>>>>
84505>>>>>>>    // * Dummy function for the Studio's Code Explorer *
84505>>>>>>>    Function SQL_TABLE_FUNCTIONS Returns Boolean
84507>>>>>>>        Function_Return False
84508>>>>>>>    End_Function
84509>>>>>>>    // Converts from SQL to Embedded (DataFlex .dat files).
84509>>>>>>>    // To convert from SQL -> SQL (e.g. from Oracle - > MS SQL)
84509>>>>>>>    //   first use SQLTableConvertToEmbedded in one cDbUpdateVersion object,
84509>>>>>>>    //   and then use the ApiTableConvertToSQL method in a second cDbUpdateVersion object.
84509>>>>>>>    // Note: To convert an embedded table to SQL use ApiTableConvertToSQL.
84509>>>>>>>    Function SqlTableConvertToEmbedded Handle hTable Boolean bCpyDat Returns Boolean
84511>>>>>>>        Handle hToTable
84511>>>>>>>        Boolean bOK bExists bOpened bMertechDriver bCopyData
84511>>>>>>>        String sDriverID sPhysicalName sRootName sDisplayName
84511>>>>>>>        tSQLConnection SQLConnection
84511>>>>>>>        tSQLConnection SQLConnection
84511>>>>>>>        Integer iPos iMaxRecords
84511>>>>>>>
84511>>>>>>>        Get psDriverID to sDriverID
84512>>>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
84513>>>>>>>        If (bExists = False) Begin
84515>>>>>>>            Function_Return False
84516>>>>>>>        End
84516>>>>>>>>
84516>>>>>>>
84516>>>>>>>        If (num_arguments > 1) Begin
84518>>>>>>>            Move bCpyDat to bCopyData
84519>>>>>>>        End
84519>>>>>>>>
84519>>>>>>>        Else Begin
84520>>>>>>>            Move False to bCopyData
84521>>>>>>>        End
84521>>>>>>>>
84521>>>>>>>
84521>>>>>>>        Open hTable
84523>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
84526>>>>>>>        If (bOpened = False) Begin
84528>>>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
84529>>>>>>>>
84529>>>>>>>            Function_Return False
84530>>>>>>>        End
84530>>>>>>>>
84530>>>>>>>        Move 0 to hToTable
84531>>>>>>>
84531>>>>>>>        Move 16711679 to iMaxRecords
84532>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
84535>>>>>>>        Move (Pos(".", sDisplayName)) to iPos
84536>>>>>>>        If (iPos > 0) Begin
84538>>>>>>>            Move (Mid(sDisplayName, 200, (iPos +1))) to sDisplayName
84539>>>>>>>        End
84539>>>>>>>>
84539>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
84542>>>>>>>        Get _TableNameOnly sRootName                 to sRootName
84543>>>>>>>        Move (sRootName + ".dat")                    to sPhysicalName
84544>>>>>>>
84544>>>>>>>        If (ghoProgressBar <> 0) Begin
84546>>>>>>>            Send DoAdvance of ghoProgressBar
84547>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to Embedded - Table:" * String(sRootName) * "Number:" * String(hTable))
84548>>>>>>>        End
84548>>>>>>>>
84548>>>>>>>
84548>>>>>>>        Move False to Err
84549>>>>>>>
84549>>>>>>>        Structure_Start hToTable DATAFLEX_ID
84550>>>>>>>            Structure_Copy hTable to hToTable
84551>>>>>>>
84551>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
84554>>>>>>>            Set_Attribute DF_FILE_REUSE_DELETED of hToTable to DF_FILE_DELETED_REUSE
84557>>>>>>>            Set_Attribute DF_FILE_MULTIUSER     of hToTable to DF_FILE_USER_MULTI
84560>>>>>>>            Set_Attribute DF_FILE_TRANSACTION   of hToTable to DF_FILE_TRANSACTION_CLIENT_ATOMIC
84563>>>>>>>            Set_Attribute DF_FILE_MAX_RECORDS   of hToTable to iMaxRecords
84566>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
84567>>>>>>>
84567>>>>>>>        Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
84569>>>>>>>
84569>>>>>>>        Set Action_Text of ghoStatusPanel to ""
84570>>>>>>>        Move (not(Err)) to bOK
84571>>>>>>>        If (bOK = True and bCopyData = True) Begin
84573>>>>>>>            Get ApiTableCopyData hTable sPhysicalName sRootName DATAFLEX_ID to bOK
84574>>>>>>>        End
84574>>>>>>>>
84574>>>>>>>
84574>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
84575>>>>>>>        If (bMertechDriver = True) Begin
84577>>>>>>>            Open hTable
84579>>>>>>>        End
84579>>>>>>>>
84579>>>>>>>
84579>>>>>>>        // This must be after copying data...
84579>>>>>>>        If (Err = False) Begin
84581>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
84584>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
84587>>>>>>>        End
84587>>>>>>>>
84587>>>>>>>        Move (not(Err)) to bOK
84588>>>>>>>
84588>>>>>>>        Function_Return (bOK = True)
84589>>>>>>>    End_Function
84590>>>>>>>
84590>>>>>>>    // Creates an SQL Table at the SQL end by its filelist number;
84590>>>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
84590>>>>>>>    Function SqlTableCreate Integer hTable Returns Boolean
84592>>>>>>>        String sTableName sSQLString sPath sCreateTable sDriverID
84592>>>>>>>        Integer iDbType
84592>>>>>>>        Boolean bExists
84592>>>>>>>
84592>>>>>>>        Get psDriverID to sDriverID
84593>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84594>>>>>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
84595>>>>>>>        If (bExists = True) Begin
84597>>>>>>>            Function_Return False
84598>>>>>>>        End
84598>>>>>>>>
84598>>>>>>>
84598>>>>>>>        Get psDataPathFirstPart to sPath
84599>>>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
84600>>>>>>>
84600>>>>>>>        Get piDbType to iDbType
84601>>>>>>>        Get _SqlProperTableName sTableName to sTableName
84602>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
84603>>>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
84604>>>>>>>
84604>>>>>>>        Move False to Err
84605>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84606>>>>>>>
84606>>>>>>>        Function_Return (Err = False)
84607>>>>>>>    End_Function
84608>>>>>>>
84608>>>>>>>    // Same as SqlTableCreate but creates an SQL Table at the SQL end by a table name;
84608>>>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
84608>>>>>>>    Function SqlTableCreateByTableName String sTableName  Returns Boolean
84610>>>>>>>        String sSQLString sPath sCreateTable sDriverID
84610>>>>>>>        Integer iDbType
84610>>>>>>>        Boolean bExists
84610>>>>>>>
84610>>>>>>>        Get psDriverID to sDriverID
84611>>>>>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
84612>>>>>>>        If (bExists = True) Begin
84614>>>>>>>            Function_Return False
84615>>>>>>>        End
84615>>>>>>>>
84615>>>>>>>
84615>>>>>>>        Get psDataPathFirstPart to sPath
84616>>>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
84617>>>>>>>        If (bExists = True) Begin
84619>>>>>>>            // ToDo: What should we do if an .int file already exists?
84619>>>>>>>        End
84619>>>>>>>>
84619>>>>>>>
84619>>>>>>>        Get piDbType to iDbType
84620>>>>>>>        Get _SqlProperTableName sTableName to sTableName
84621>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
84622>>>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
84623>>>>>>>
84623>>>>>>>        Move False to Err
84624>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84625>>>>>>>
84625>>>>>>>        Function_Return (Err = False)
84626>>>>>>>    End_Function
84627>>>>>>>
84627>>>>>>>    // First deletes the data cache file and then drops the passed SQL table.
84627>>>>>>>    // Note: The table needs to exist in filelist.cfg, and it must be possible to open it,
84627>>>>>>>    //       else try using the SqlTableRemoveByTableName message.
84627>>>>>>>    Function SqlTableRemove Integer hTable Returns Boolean
84629>>>>>>>        String sSQLString sPath sDropTable sTableName sDriverID
84629>>>>>>>        Integer iRetval iDbType
84629>>>>>>>        Boolean bExists bMertechDriver bOK
84629>>>>>>>
84629>>>>>>>        Get psDriverID to sDriverID
84630>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
84631>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84632>>>>>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
84633>>>>>>>        If (bExists = False) Begin
84635>>>>>>>            Function_Return False
84636>>>>>>>        End
84636>>>>>>>>
84636>>>>>>>
84636>>>>>>>        Get psDataPathFirstPart to sPath
84637>>>>>>>        Get UtilDeleteCacheFile sTableName to iRetval
84638>>>>>>>
84638>>>>>>>        Get piDbType to iDbType
84639>>>>>>>        Get _SqlProperTableName sTableName to sTableName
84640>>>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
84641>>>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
84642>>>>>>>
84642>>>>>>>        Move False to Err
84643>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84644>>>>>>>
84644>>>>>>>        // We also need to remove the cache-file since the table has been changed
84644>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
84645>>>>>>>
84645>>>>>>>        Function_Return (Err = False)
84646>>>>>>>    End_Function
84647>>>>>>>
84647>>>>>>>    // First deletes the data cache file and then drops the passed data table.
84647>>>>>>>    Function SqlTableRemoveByTableName String sTableName Returns Boolean
84649>>>>>>>        String sSQLString sPath sDropTable sVal sSchema sDriverID
84649>>>>>>>        Integer iRetval iDbType
84649>>>>>>>        Boolean bMertechDriver bOK
84649>>>>>>>
84649>>>>>>>        Get psDriverID to sDriverID
84650>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
84651>>>>>>>        Get psDataPathFirstPart to sPath
84652>>>>>>>        Get UtilDeleteCacheFile sTableName to iRetval
84653>>>>>>>
84653>>>>>>>        Get piDbType to iDbType
84654>>>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
84655>>>>>>>        Get psSchema to sSchema
84656>>>>>>>        If (sSchema = "") Begin
84658>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
84659>>>>>>>        End
84659>>>>>>>>
84659>>>>>>>        Move (Uppercase(sTableName)) to sVal
84660>>>>>>>        If (not(sVal contains (sSchema + "."))) Begin
84662>>>>>>>            Move (Lowercase(sSchema) + "." + sTableName) to sTableName
84663>>>>>>>        End
84663>>>>>>>>
84663>>>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
84664>>>>>>>
84664>>>>>>>        Move False to Err
84665>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84666>>>>>>>
84666>>>>>>>        // We also need to remove the cache-file since the table has been changed
84666>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
84667>>>>>>>
84667>>>>>>>        Function_Return (Err = False)
84668>>>>>>>    End_Function
84669>>>>>>>
84669>>>>>>>    // *** Sql View Messages ***
84669>>>>>>>
84669>>>>>>>    // First deletes the data cache file and then drops the passed Sql data view.
84669>>>>>>>    Function SqlViewRemove String sDataView Returns Boolean
84671>>>>>>>        String sDriverID sSQLString sDropViewKeyWord
84671>>>>>>>        Integer iRetval
84671>>>>>>>        Boolean bMertechDriver bOK
84671>>>>>>>
84671>>>>>>>        Get psDriverID to sDriverID
84672>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
84673>>>>>>>        Get UtilDeleteCacheFile sDataView to iRetval
84674>>>>>>>
84674>>>>>>>        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
84675>>>>>>>        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
84676>>>>>>>        Set psSQLStatementString to sSQLString
84677>>>>>>>
84677>>>>>>>        // As we don't check if the view exist or not, it might happen
84677>>>>>>>        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
84677>>>>>>>        Move False to Err
84678>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84679>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84680>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84681>>>>>>>        Move 0 to LastErr
84682>>>>>>>
84682>>>>>>>        // We also need to remove the cache-file since the table has been changed
84682>>>>>>>        Get UtilDeleteCacheFile sDataView to bOK
84683>>>>>>>
84683>>>>>>>        Function_Return (Err = False)
84684>>>>>>>    End_Function
84685>>>>>>>
84685>>>>>>>    Function SqlTableRename Handle hTable String sCurrentTableName String sNewtTableName Returns Boolean
84687>>>>>>>        Boolean bOK
84687>>>>>>>        Integer iDbType
84687>>>>>>>        String sDriverID sAlterTable sRenameTable sSQLTo sSQLString
84687>>>>>>>
84687>>>>>>>        Get psDriverID to sDriverID
84688>>>>>>>        Get piDbType   to iDbType
84689>>>>>>>
84689>>>>>>>        Case Begin
84689>>>>>>>            Case (iDbType = EN_DbTypeDB2)
84691>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84692>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84693>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * sNewtTableName) to sSQLString
84694>>>>>>>            Break
84695>>>>>>>
84695>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
84698>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84699>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84700>>>>>>>                Move (sRenameTable * "'" - sCurrentTableName - "', '" - sNewtTableName - "'") to sSQLString
84701>>>>>>>            Break
84702>>>>>>>
84702>>>>>>>            Case (iDbType = EN_DbTypeOracle)
84705>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84706>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84707>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * sNewtTableName) to sSQLString
84708>>>>>>>            Break
84709>>>>>>>
84709>>>>>>>            Case (iDbType = EN_DbTypePostgre)
84712>>>>>>>                Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
84713>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84714>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84715>>>>>>>                Move (sAlterTable * sCurrentTableName * sRenameTable * sSQLTo * sNewtTableName) to sSQLString
84716>>>>>>>            Break
84717>>>>>>>
84717>>>>>>>            Case (iDbType = EN_DbTypeMySQL)
84720>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84721>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84722>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * sNewtTableName) to sSQLString
84723>>>>>>>            Break
84724>>>>>>>        Case End
84724>>>>>>>
84724>>>>>>>        Move False to Err
84725>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84726>>>>>>>        Move (Err = False) to bOK
84727>>>>>>>
84727>>>>>>>        Function_Return bOK
84728>>>>>>>    End_Function
84729>>>>>>>
84729>>>>>>>    // * Dummy function for the Studio's Code Explorer *
84729>>>>>>>    Function SQL_COLUMN_FUNCTIONS Returns Boolean
84731>>>>>>>        Function_Return False
84732>>>>>>>    End_Function
84733>>>>>>>
84733>>>>>>>    // Sample: Get SqlColumnAdd MyTable.File_Number "NewColumnName" True "InitValue" DF_ASCII_DUF 35
84733>>>>>>>    Function SqlColumnAdd Integer hTable String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
84735>>>>>>>        Integer iLength iDecimals
84735>>>>>>>        String sColumnValue
84735>>>>>>>        String sTableName sDriverID
84735>>>>>>>        Boolean bOK bInitializeValue
84735>>>>>>>
84735>>>>>>>        Get psDriverID to sDriverID
84736>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84737>>>>>>>        If (bOK = False) Begin
84739>>>>>>>            Function_Return False
84740>>>>>>>        End
84740>>>>>>>>
84740>>>>>>>
84740>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84741>>>>>>>        If (sTableName = "") Begin
84743>>>>>>>            Function_Return False
84744>>>>>>>        End
84744>>>>>>>>
84744>>>>>>>
84744>>>>>>>        If (num_arguments > 3) Begin
84746>>>>>>>            Move iLen     to iLength
84747>>>>>>>            Move iDec     to iDecimals
84748>>>>>>>            Move bInitVal to bInitializeValue
84749>>>>>>>            Move sColVal  to sColumnValue
84750>>>>>>>        End
84750>>>>>>>>
84750>>>>>>>
84750>>>>>>>        Get SqlColumnAddByTableName sTableName sColumnName iDataType iLen iDecimals bInitializeValue sColumnValue to bOK
84751>>>>>>>
84751>>>>>>>        Function_Return (bOK = True)
84752>>>>>>>    End_Function
84753>>>>>>>
84753>>>>>>>    // Sample: Get SqlColumnAddByTableName "MyTable" "NewColumnName" DF_ASCII_DUF 35 0 True "InitValue"
84753>>>>>>>    Function SqlColumnAddByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
84755>>>>>>>        Integer iDbType iLength iDecimals iDriver
84755>>>>>>>        String sStmt sAlterTable sAddColumn sVal sDataType sLengthAndDecimals sColumnValue
84755>>>>>>>        String sDriverID sNotNull
84755>>>>>>>        Boolean bOK bInitializeValue bRetval bFixed bDriverIgnoreErrorState
84755>>>>>>>        Handle hTable
84755>>>>>>>
84755>>>>>>>        Get psDriverID to sDriverID
84756>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84757>>>>>>>        If (bOK = False) Begin
84759>>>>>>>            Function_Return False
84760>>>>>>>        End
84760>>>>>>>>
84760>>>>>>>
84760>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
84761>>>>>>>        If (hTable = 0) Begin
84763>>>>>>>            Get NextFreeFilelistSlot to hTable
84764>>>>>>>        End
84764>>>>>>>>
84764>>>>>>>
84764>>>>>>>        Get piDbType to iDbType
84765>>>>>>>        // If a field/column already exists; we just ignore the request to not add unneccesary errors to the log.
84765>>>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
84766>>>>>>>        If (Uppercase(sVal) = Uppercase(sColumnName)) Begin
84768>>>>>>>            Function_Return False
84769>>>>>>>        End
84769>>>>>>>>
84769>>>>>>>
84769>>>>>>>        Get DriverIndex sDriverID to iDriver
84770>>>>>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84773>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
84776>>>>>>>
84776>>>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
84777>>>>>>>        If (num_arguments > 3) Begin
84779>>>>>>>            Move iLen     to iLength
84780>>>>>>>            Move iDec     to iDecimals
84781>>>>>>>            Move bInitVal to bInitializeValue
84782>>>>>>>            Move sColVal  to sColumnValue
84783>>>>>>>        End
84783>>>>>>>>
84783>>>>>>>
84783>>>>>>>        Get _SqlProperTableName sTableName   to sTableName
84784>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
84785>>>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
84786>>>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
84787>>>>>>>
84787>>>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
84788>>>>>>>        If (bFixed = False) Begin
84790>>>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
84791>>>>>>>        End
84791>>>>>>>>
84791>>>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
84792>>>>>>>
84792>>>>>>>        Move False to Err
84793>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84794>>>>>>>
84794>>>>>>>        If (bInitializeValue = True and Err = False) Begin
84796>>>>>>>            Get SQLColumnUpdateValue hTable sColumnName sColumnValue to bRetval
84797>>>>>>>        End
84797>>>>>>>>
84797>>>>>>>
84797>>>>>>>        If (Err = False) Begin
84799>>>>>>>            Get SqlUtilAdjustAuxFiles hTable sTableName sColumnName to bOK
84800>>>>>>>        End
84800>>>>>>>>
84800>>>>>>>
84800>>>>>>>        Move (not(Err)) to bRetval
84801>>>>>>>
84801>>>>>>>        // We also need to remove the cache-file since the table has been changed
84801>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
84802>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84805>>>>>>>
84805>>>>>>>        Function_Return bRetval
84806>>>>>>>    End_Function
84807>>>>>>>
84807>>>>>>>    // To update all current rows for a table column with a common value.
84807>>>>>>>    Function SqlColumnUpdateValue Handle hTable String sColumnName String sColumnValue Returns Boolean
84809>>>>>>>        String sDriverID sTableName sUpdate sSet sNoCountOn sStmt
84809>>>>>>>        Boolean bRetval bSQLDriver
84809>>>>>>>        Integer iCurrErr
84809>>>>>>>
84809>>>>>>>        Move False to bRetval
84810>>>>>>>        Get psDriverID to sDriverID
84811>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
84812>>>>>>>        If (bSQLDriver = False) Begin
84814>>>>>>>            Function_Return bRetval
84815>>>>>>>        End
84815>>>>>>>>
84815>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84816>>>>>>>
84816>>>>>>>        Move Err to iCurrErr
84817>>>>>>>        Move False to Err
84818>>>>>>>        Get _SqlFindKeyWord CI_SQLUpdate       to sUpdate
84819>>>>>>>        Get _SqlFindKeyWord CI_SQLSet          to sSet
84820>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountOn
84821>>>>>>>        Move (sNoCountOn * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
84822>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84823>>>>>>>        Move (Err = False) to bRetval
84824>>>>>>>        Move iCurrErr to Err
84825>>>>>>>
84825>>>>>>>        Function_Return bRetval
84826>>>>>>>    End_Function
84827>>>>>>>
84827>>>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
84827>>>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
84827>>>>>>>    Function SqlColumnChange Handle hTable String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
84829>>>>>>>        String sDriverID sTableName
84829>>>>>>>        Boolean bOK
84829>>>>>>>
84829>>>>>>>        Get psDriverID to sDriverID
84830>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84831>>>>>>>        If (bOK = False) Begin
84833>>>>>>>            Function_Return False
84834>>>>>>>        End
84834>>>>>>>>
84834>>>>>>>
84834>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84835>>>>>>>        Get SqlColumnChangeByTableName sTableName sColumnName iDataType iLen iDec to bOK
84836>>>>>>>
84836>>>>>>>        Function_Return (Err = False)
84837>>>>>>>    End_Function
84838>>>>>>>
84838>>>>>>>    // Same as SqlColumnChange but instead of passing a filelist number; pass the table name as a string.
84838>>>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
84838>>>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
84838>>>>>>>    Function SqlColumnChangeByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
84840>>>>>>>        Integer iDbType iLength iDecimals
84840>>>>>>>        String sDriverID sStmt sAlterTable sAlterColumn sDataType sLengthAndDecimals sNotNull
84840>>>>>>>        Boolean bExists bOK bFixed
84840>>>>>>>        Handle hTable
84840>>>>>>>
84840>>>>>>>        Get psDriverID to sDriverID
84841>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84842>>>>>>>        If (bOK = False) Begin
84844>>>>>>>            Function_Return False
84845>>>>>>>        End
84845>>>>>>>>
84845>>>>>>>
84845>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
84846>>>>>>>        If (hTable = 0) Begin
84848>>>>>>>            Get NextFreeFilelistSlot to hTable
84849>>>>>>>        End
84849>>>>>>>>
84849>>>>>>>        Get SQLUtilColumnExists sTableName sColumnName to bExists
84850>>>>>>>        If (bExists = True) Begin
84852>>>>>>>            Function_Return False
84853>>>>>>>        End
84853>>>>>>>>
84853>>>>>>>
84853>>>>>>>        If (num_arguments > 3) Begin
84855>>>>>>>            Move iLen to iLength
84856>>>>>>>        End
84856>>>>>>>>
84856>>>>>>>        If (num_arguments > 4) Begin
84858>>>>>>>            Move iDec to iDecimals
84859>>>>>>>        End
84859>>>>>>>>
84859>>>>>>>
84859>>>>>>>        Get piDbType to iDbType
84860>>>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
84861>>>>>>>
84861>>>>>>>        Move False to Err
84862>>>>>>>        Get _SqlProperTableName sTableName    to sTableName
84863>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
84864>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterColumn to sAlterColumn
84865>>>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
84866>>>>>>>
84866>>>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
84867>>>>>>>        If (bFixed = False) Begin
84869>>>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
84870>>>>>>>        End
84870>>>>>>>>
84870>>>>>>>
84870>>>>>>>        Move (sAlterTable * sTableName * sAlterColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
84871>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84872>>>>>>>
84872>>>>>>>        // We also need to remove the cache-file since the table has been changed
84872>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
84873>>>>>>>
84873>>>>>>>        Function_Return (Err = False)
84874>>>>>>>    End_Function
84875>>>>>>>
84875>>>>>>>    Function SqlColumnDefaultValue Handle hTable Integer iColumn String sValue Returns Boolean
84877>>>>>>>        Boolean bOK bErr bIsSQLDriver
84877>>>>>>>        String sDriverID  
84877>>>>>>>        Integer iDataType
84877>>>>>>>
84877>>>>>>>        Get psDriverID to sDriverID
84878>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
84879>>>>>>>        If (bIsSQLDriver = False) Begin
84881>>>>>>>            Function_Return False
84882>>>>>>>        End
84882>>>>>>>>
84882>>>>>>>
84882>>>>>>>        Move Err to bErr
84883>>>>>>>        Move False to bErr
84884>>>>>>>
84884>>>>>>>        // There seems to be a problem with the ODBC_DRV driver that sometimes
84884>>>>>>>        // inserts randomly character(10) and spaces, so we correct from that here:
84884>>>>>>>        Move (Replaces(Character(10), Trim(sValue), "")) to sValue
84885>>>>>>>        Get_Attribute DF_FIELD_TYPE of hTable iColumn to iDataType 
84888>>>>>>>        If (iDataType = DF_BCD and Left(sValue, 1 <> "[")) Begin
84890>>>>>>>            Move ("[" + String(sValue) + "]") to sValue
84891>>>>>>>        End
84891>>>>>>>>
84891>>>>>>>        
84891>>>>>>>        Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sValue
84894>>>>>>>        Move (not(Err)) to bOK
84895>>>>>>>        Move bErr to Err
84896>>>>>>>
84896>>>>>>>        Function_Return bOK
84897>>>>>>>    End_Function
84898>>>>>>>
84898>>>>>>>    Function SqlColumnNullable Handle hTable Integer iColumn Boolean bNullable Returns Boolean
84900>>>>>>>        Boolean bOK bErr bCurrentState bOpen bIsSQLDriver
84900>>>>>>>        String sDriverID
84900>>>>>>>
84900>>>>>>>        Get psDriverID to sDriverID
84901>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
84902>>>>>>>        If (bIsSQLDriver = False) Begin
84904>>>>>>>            Function_Return False
84905>>>>>>>        End
84905>>>>>>>>
84905>>>>>>>
84905>>>>>>>        Move Err to bErr
84906>>>>>>>        Move False to bErr
84907>>>>>>>        Get_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bCurrentState
84910>>>>>>>        If (bNullable = bCurrentState) Begin
84912>>>>>>>            Function_Return True
84913>>>>>>>        End
84913>>>>>>>>
84913>>>>>>>
84913>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
84916>>>>>>>        If (bOpen = False) Begin
84918>>>>>>>            Get AutoConnectionIDLogin to bOK
84919>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
84920>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
84921>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84922>>>>>>>            Open hTable
84924>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
84925>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
84926>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84927>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
84930>>>>>>>        End
84930>>>>>>>>
84930>>>>>>>        If (bOpen = True) Begin
84932>>>>>>>            Structure_Start hTable sDriverID
84933>>>>>>>                Set_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bNullable
84936>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
84937>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
84939>>>>>>>            Set Action_Text of ghoStatusPanel to ""
84940>>>>>>>        End
84940>>>>>>>>
84940>>>>>>>
84940>>>>>>>        Move (not(Err)) to bOK
84941>>>>>>>        Move bErr to Err
84942>>>>>>>
84942>>>>>>>        Function_Return bOK
84943>>>>>>>    End_Function
84944>>>>>>>
84944>>>>>>>    // Drop column by its table handle
84944>>>>>>>    Function SqlColumnRemove Handle hTable String sColumnName Returns Boolean
84946>>>>>>>        String sDriverID sTableName
84946>>>>>>>        Boolean bOK
84946>>>>>>>
84946>>>>>>>        Get psDriverID to sDriverID
84947>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84948>>>>>>>        If (bOK = False) Begin
84950>>>>>>>            Function_Return False
84951>>>>>>>        End
84951>>>>>>>>
84951>>>>>>>
84951>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84952>>>>>>>        If (sTableName = "") Begin
84954>>>>>>>            Function_Return False
84955>>>>>>>        End
84955>>>>>>>>
84955>>>>>>>
84955>>>>>>>        Get SqlColumnRemoveByTableName sTableName sColumnName to bOK
84956>>>>>>>
84956>>>>>>>        Function_Return (bOK = True)
84957>>>>>>>    End_Function
84958>>>>>>>
84958>>>>>>>    // Drop column by its table name as a string.
84958>>>>>>>    Function SqlColumnRemoveByTableName String sTableName String sColumnName Returns Boolean
84960>>>>>>>        Integer iDbType iDriver
84960>>>>>>>        String sDriverID sStmt sAlterTable sDropColumn
84960>>>>>>>        Boolean bExists bOK bRetval bDriverIgnoreErrorState
84960>>>>>>>        Handle hTable
84960>>>>>>>
84960>>>>>>>        Get psDriverID to sDriverID
84961>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84962>>>>>>>        If (bOK = False) Begin
84964>>>>>>>            Function_Return False
84965>>>>>>>        End
84965>>>>>>>>
84965>>>>>>>
84965>>>>>>>        Get DriverIndex sDriverID to iDriver
84966>>>>>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84969>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
84972>>>>>>>
84972>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
84973>>>>>>>        If (hTable <> 0) Begin
84975>>>>>>>            Get SQLUtilColumnExists sTableName sColumnName to bExists
84976>>>>>>>            If (bExists = False) Begin
84978>>>>>>>                Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84981>>>>>>>                Function_Return False
84982>>>>>>>            End
84982>>>>>>>>
84982>>>>>>>        End
84982>>>>>>>>
84982>>>>>>>
84982>>>>>>>        Get piDbType to iDbType
84983>>>>>>>        If (iDbType = EN_DbTypeMSSQL) Begin
84985>>>>>>>            Get _SqlUtilRemoveTableColumnMSSQL sTableName sColumnName to bOK
84986>>>>>>>            Get UtilDeleteCacheFile sTableName to bOK
84987>>>>>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84990>>>>>>>            Function_Return bOK
84991>>>>>>>        End
84991>>>>>>>>
84991>>>>>>>
84991>>>>>>>        Move False to Err
84992>>>>>>>        Get _SqlProperTableName sTableName    to sTableName
84993>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
84994>>>>>>>        Get _SqlFindKeyWord CI_SQLDropColumn  to sDropColumn
84995>>>>>>>
84995>>>>>>>        Move (sAlterTable * sTableName * sDropColumn * sColumnName) to sStmt
84996>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84997>>>>>>>        Move (not(Err)) to bRetval
84998>>>>>>>
84998>>>>>>>        // We also need to remove the cache-file since the table has been changed
84998>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
84999>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85002>>>>>>>
85002>>>>>>>        Function_Return bRetval
85003>>>>>>>    End_Function
85004>>>>>>>
85004>>>>>>>    // Rename a field/column by table handle (filelist number)
85004>>>>>>>    Function SqlColumnRename Integer hTable String sColumnName String sNewColumnName Returns Boolean
85006>>>>>>>        String sDriverID sTableName
85006>>>>>>>        Boolean bOK
85006>>>>>>>
85006>>>>>>>        Get psDriverID to sDriverID
85007>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85008>>>>>>>        If (bOK = False) Begin
85010>>>>>>>            Function_Return False
85011>>>>>>>        End
85011>>>>>>>>
85011>>>>>>>
85011>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85012>>>>>>>        Get SqlColumnRenameByTableName sTableName sColumnName sNewColumnName to bOK
85013>>>>>>>
85013>>>>>>>        Function_Return (Err = False)
85014>>>>>>>    End_Function
85015>>>>>>>
85015>>>>>>>    // Rename a field/column by table name.
85015>>>>>>>    Function SqlColumnRenameByTableName String sTableName String sColumnName String sNewColumnName Returns Boolean
85017>>>>>>>        Integer iDbType iDataType
85017>>>>>>>        String sDriverID sStmt sAlterTable sRenameColumn sVal sColumnKeyWord sOrgTableName sDatabase sDataType
85017>>>>>>>        Boolean bOK bRetval
85017>>>>>>>        Handle hTable
85017>>>>>>>
85017>>>>>>>        Move sTableName to sOrgTableName
85018>>>>>>>        Get psDriverID to sDriverID
85019>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85020>>>>>>>        If (bOK = False) Begin
85022>>>>>>>            Function_Return False
85023>>>>>>>        End
85023>>>>>>>>
85023>>>>>>>
85023>>>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
85024>>>>>>>        If (sVal = "") Begin
85026>>>>>>>            Function_Return False
85027>>>>>>>        End
85027>>>>>>>>
85027>>>>>>>
85027>>>>>>>        Get piDbType to iDbType
85028>>>>>>>        Get _SqlFindKeyWord CI_SQLColumn       to sColumnKeyWord
85029>>>>>>>        Get _SqlProperTableName sTableName     to sTableName
85030>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable   to sAlterTable
85031>>>>>>>        Get _SqlFindKeyWord CI_SQLRenameColumn to sRenameColumn
85032>>>>>>>
85032>>>>>>>        Case Begin
85032>>>>>>>            Case (iDbType = EN_dbTypeMSSQL)
85034>>>>>>>                Move (sRenameColumn * "'" + sTableName + "." + sColumnName + "'," * "'" + sNewColumnName + "'," * "'" + sColumnKeyWord + "'") to sStmt
85035>>>>>>>                Case Break
85036>>>>>>>            // Alter table "SYS"."Customer" rename column "Comments" to "NewColumnName"
85036>>>>>>>            Case (iDbType = EN_dbTypeOracle)
85039>>>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
85040>>>>>>>                Case Break
85041>>>>>>>            // ALTER TABLE Schema.TableName RENAME COLUMN "deptnumb" TO "deptnum"
85041>>>>>>>            Case (iDbType = EN_dbTypeDB2)
85044>>>>>>>                Move (sAlterTable *  sTableName * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
85045>>>>>>>                Case Break
85046>>>>>>>            // ALTER TABLE "Customer" RENAME COLUMN "Comments" TO "NewColumnName"
85046>>>>>>>            Case (iDbType = EN_dbTypePostgre)
85049>>>>>>>                Move sOrgTableName to sTableName
85050>>>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
85051>>>>>>>                Case Break
85052>>>>>>>            Case (iDbType = EN_dbTypeMySQL)
85055>>>>>>>                // ALTER TABLE orderentry.customer CHANGE Comments NewColumnName text // Note: The last token is the column type!
85055>>>>>>>                Move sOrgTableName to sTableName
85056>>>>>>>                Get psDatabase to sDatabase
85057>>>>>>>                Get UtilTableNameToHandle sTableName to hTable
85058>>>>>>>                If (hTable = 0) Begin
85060>>>>>>>                    Get UtilTableOpen hTable sTableName DF_SHARE to bOK
85061>>>>>>>                    If (bOK = False) Begin
85063>>>>>>>                        Function_Return False
85064>>>>>>>                    End
85064>>>>>>>>
85064>>>>>>>                    Get NextFreeFilelistSlot to hTable
85065>>>>>>>                End
85065>>>>>>>>
85065>>>>>>>                Else Begin
85066>>>>>>>                    Open hTable
85068>>>>>>>                End
85068>>>>>>>>
85068>>>>>>>                Get SQLColumnType sDriverID hTable sTableName sColumnName to iDataType
85069>>>>>>>                Get UtilColumnTypeToString sDriverID iDbType iDataType    to sDataType
85070>>>>>>>                Move (sAlterTable * sDatabase + "." + sTableName * sRenameColumn * sColumnName * sNewColumnName * sDataType) to sStmt
85071>>>>>>>                Case Break
85072>>>>>>>            Case Else
85072>>>>>>>                Move (sAlterTable * "'" + sTableName + "'" * sRenameColumn * "'" + sTableName + "." + sColumnName + "'" * "TO" * "'" + sNewColumnName + "'") to sStmt
85073>>>>>>>        Case End
85073>>>>>>>
85073>>>>>>>        Move False to Err
85074>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85075>>>>>>>        Move (Err = False) to bRetval
85076>>>>>>>        // We also need to remove the cache-file since the table has been changed
85076>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
85077>>>>>>>
85077>>>>>>>        Function_Return bRetval
85078>>>>>>>    End_Function
85079>>>>>>>
85079>>>>>>>    Function SqlColumnType String sDriverID Handle hTable String sTableName String sColumnName Returns Integer
85081>>>>>>>        Handle hoSQLHandler hSQLConnect hStmt
85081>>>>>>>        Boolean bMertechDriver
85081>>>>>>>        Integer iNumCols iCount iDataType
85081>>>>>>>        String sValue
85081>>>>>>>
85081>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
85082>>>>>>>        If (bMertechDriver = False) Begin
85084>>>>>>>            Get phoSQLManager to hoSQLHandler
85085>>>>>>>        End
85085>>>>>>>>
85085>>>>>>>        Else Begin
85086>>>>>>>            Get _MertechSQLManagerHandle to hoSQLHandler
85087>>>>>>>        End
85087>>>>>>>>
85087>>>>>>>
85087>>>>>>>        Get SQLFileConnect of hoSQLHandler hTable to hSQLConnect
85088>>>>>>>        If (hSQLConnect <> 0) Begin
85090>>>>>>>            Get SQLOpen of hSQLConnect to hStmt
85091>>>>>>>            If (hStmt <> 0) Begin
85093>>>>>>>                Send SQLExecDirect of hStmt ("select * from" * sTableName)
85094>>>>>>>
85094>>>>>>>                Get SQLStmtAttribute of hStmt SQLSTMTATTRIB_COLUMNCOUNT to iNumCols
85095>>>>>>>                For iCount from 1 to iNumCols
85101>>>>>>>>
85101>>>>>>>                    Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_LABEL to sValue
85102>>>>>>>                    If (Lowercase(sValue) = Lowercase(sColumnName)) Begin
85104>>>>>>>                        Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_SQLTYPE to iDataType
85105>>>>>>>                        Move iNumCols to iCount // We're out of here
85106>>>>>>>                    End
85106>>>>>>>>
85106>>>>>>>                Loop
85107>>>>>>>>
85107>>>>>>>
85107>>>>>>>                Send SQLClose of hStmt
85108>>>>>>>            End
85108>>>>>>>>
85108>>>>>>>            Send SQLDisconnect of hSQLConnect
85109>>>>>>>        End
85109>>>>>>>>
85109>>>>>>>
85109>>>>>>>        Function_Return iDataType
85110>>>>>>>    End_Function
85111>>>>>>>
85111>>>>>>>    // * Dummy function for the Studio's Code Explorer *
85111>>>>>>>    Function SQL_EXECUTE_FUNCTIONS Returns Boolean
85113>>>>>>>        Function_Return False
85114>>>>>>>    End_Function
85115>>>>>>>
85115>>>>>>>    Procedure SqlUtilExecuteQuery String sStmt String sDriverID Boolean bShowProgr
85117>>>>>>>        String sConnectionString sMessage
85117>>>>>>>        Handle hoSqlHandler hoSQLConnect hoStmt hoError
85117>>>>>>>        Integer i iMsgs iFetchResult iRowType iRows iErr iMessage iLastErr
85117>>>>>>>        String[] sMsg aSQLQueryMessages aSQLFetchResults
85120>>>>>>>        DateTime dtQueryExecStart dtQueryExecEnd dtFetchStart dtFetchEnd
85120>>>>>>>        TimeSpan tsQuery tsFetch
85120>>>>>>>        tSqlErrorArray aSqlErrorArray
85120>>>>>>>        tSqlErrorArray aSqlErrorArray
85120>>>>>>>        Boolean bOK bMertechDriver bShowProgress
85120>>>>>>>        tSQLConnection SQLConnection
85120>>>>>>>        tSQLConnection SQLConnection
85120>>>>>>>
85120>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85121>>>>>>>        If (bOK = False) Begin
85123>>>>>>>            Procedure_Return
85124>>>>>>>        End
85124>>>>>>>>
85124>>>>>>>
85124>>>>>>>        If (num_arguments > 2) Begin
85126>>>>>>>            Move bShowProgr to bShowProgress
85127>>>>>>>        End
85127>>>>>>>>
85127>>>>>>>
85127>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85128>>>>>>>
85128>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
85129>>>>>>>        If (bMertechDriver = True) Begin
85131>>>>>>>            Get _MertechSQLConnect sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
85132>>>>>>>        End
85132>>>>>>>>
85132>>>>>>>        If (bMertechDriver = False) Begin
85134>>>>>>>            Get phoSQLManager to hoSqlHandler
85135>>>>>>>            Send SqlSetConnect of hoSqlHandler sDriverID SQLConnection.sConnectionString
85136>>>>>>>            Get SqlConnect     of hoSqlHandler "" "" to hoSQLConnect
85137>>>>>>>        End
85137>>>>>>>>
85137>>>>>>>
85137>>>>>>>        If (hoSQLConnect <> 0) Begin
85139>>>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
85140>>>>>>>            If (hoStmt <> 0) Begin
85142>>>>>>>                // record starting date/time stamp
85142>>>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
85143>>>>>>>                // turn on error handling if enabled
85143>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
85145>>>>>>>                    Set pbSqlError to False
85146>>>>>>>                    Set paSqlErrorArray to aSqlErrorArray
85147>>>>>>>                    Move Error_Object_Id to hoError 
85148>>>>>>>                    If (ghoDbUpdateHandler <> 0) Begin
85150>>>>>>>                        Move ghoDbUpdateHandler to Error_Object_Id
85151>>>>>>>                    End                                           
85151>>>>>>>>
85151>>>>>>>                    Else Begin
85152>>>>>>>                        Move Self to Error_Object_Id
85153>>>>>>>                    End
85153>>>>>>>>
85153>>>>>>>                End
85153>>>>>>>>
85153>>>>>>>
85153>>>>>>>                // Before we execute the statement; save it so we can display the faulty statement in the error log.
85153>>>>>>>                Set psSQLStatementString to sStmt 
85154>>>>>>>                Send Cursor_Wait of Cursor_Control
85155>>>>>>>                Send SqlExecDirect of hoStmt sStmt
85156>>>>>>>                Send Cursor_Ready of Cursor_Control
85157>>>>>>>
85157>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
85159>>>>>>>                    Move hoError to Error_Object_Id
85160>>>>>>>                End
85160>>>>>>>>
85160>>>>>>>
85160>>>>>>>                Move 0 to iMsgs
85161>>>>>>>                // ToDo: There seems to be some issues with this code and Mertech drivers that makes
85161>>>>>>>                // the debugger crash in some cases like an error in the ESQL statement; so we exclude it for now.
85161>>>>>>>                If (bMertechDriver = False) Begin
85163>>>>>>>                    Move Err to iErr
85164>>>>>>>                    Move LastErr to iLastErr
85165>>>>>>>                    Get SqlStmtAttribute of hoStmt SQLSTMTATTRIB_NUMMESSAGES   to iMsgs
85166>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT      to iRows
85167>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
85168>>>>>>>                    Send _SqlColumnInfo hoStmt
85169>>>>>>>                    Send Ignore_Error of Error_Object_Id 12289
85170>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85171>>>>>>>                    Repeat
85171>>>>>>>>
85171>>>>>>>                        Get SqlFetch of hoStmt to iFetchResult
85172>>>>>>>                        If (iFetchResult <> 0) Begin
85174>>>>>>>                            Get SQLColumnValue of hoStmt 1 to aSQLFetchResults[SizeOfArray(aSQLFetchResults)]
85175>>>>>>>                        End
85175>>>>>>>>
85175>>>>>>>                    Until (iFetchResult = 0)
85177>>>>>>>                    Send Trap_Error of Error_Object_Id 12289
85178>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
85179>>>>>>>                    Move iErr to Err
85180>>>>>>>                    Move iLastErr to LastErr
85181>>>>>>>                    Set paSQLFetchResults to aSQLFetchResults
85182>>>>>>>                End
85182>>>>>>>>
85182>>>>>>>
85182>>>>>>>                Set piRows    to iRows
85183>>>>>>>                Set piRowType to iRowType
85184>>>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
85185>>>>>>>                Move (CurrentDateTime()) to dtFetchStart
85186>>>>>>>
85186>>>>>>>                If (iMsgs <> 0) Begin
85188>>>>>>>                    If (ghoDbUpdateHandler > 0) Begin
85190>>>>>>>                        Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
85191>>>>>>>                    End
85191>>>>>>>>
85191>>>>>>>                    For i from 1 to iMsgs
85197>>>>>>>>
85197>>>>>>>                        Get SqlGetMessage of hoStmt i to sMessage
85198>>>>>>>                        Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
85199>>>>>>>                        If (bShowProgress = True) Begin
85201>>>>>>>                            If (Active_State(ghoStatusPanel)) Begin
85203>>>>>>>                                Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
85204>>>>>>>                            End
85204>>>>>>>>
85204>>>>>>>                            Else Begin
85205>>>>>>>                                Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
85207>>>>>>>                            End
85207>>>>>>>>
85207>>>>>>>                        End
85207>>>>>>>>
85207>>>>>>>                        Move sMessage to sMsg[SizeOfArray(sMsg)]
85208>>>>>>>                        Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
85209>>>>>>>                    Loop
85210>>>>>>>>
85210>>>>>>>                    If (ghoDbUpdateHandler > 0) Begin
85212>>>>>>>                        Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
85213>>>>>>>                    End
85213>>>>>>>>
85213>>>>>>>                    Set paQueryMessages to sMsg
85214>>>>>>>                End 
85214>>>>>>>>
85214>>>>>>>                Else Begin
85215>>>>>>>                    If (bShowProgress = True) Begin
85217>>>>>>>                        Get paSqlErrorArray to aSqlErrorArray
85218>>>>>>>                        If (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) Begin
85220>>>>>>>                            Move (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) to iMsgs
85221>>>>>>>                            Decrement iMsgs
85222>>>>>>>                            For i from 0 to iMsgs
85228>>>>>>>>
85228>>>>>>>                                Showln "Embedded SQL Statement: " aSqlErrorArray.sSqlStatementArray[i]
85231>>>>>>>                                Showln "SQL Error Message     : " aSqlErrorArray.sSqlErrorArray[i]
85234>>>>>>>                            Loop
85235>>>>>>>>
85235>>>>>>>                        End
85235>>>>>>>>
85235>>>>>>>                    End
85235>>>>>>>>
85235>>>>>>>                End
85235>>>>>>>>
85235>>>>>>>                Move (CurrentDateTime()) to dtFetchEnd
85236>>>>>>>            End
85236>>>>>>>>
85236>>>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
85237>>>>>>>            Move (dtFetchStart - dtFetchEnd) to tsFetch
85238>>>>>>>            Set ptsQueryExec to tsQuery
85239>>>>>>>            Set ptsFetchResults to tsFetch
85240>>>>>>>            Send SqlClose of hoStmt
85241>>>>>>>        End
85241>>>>>>>>
85241>>>>>>>
85241>>>>>>>        Send SqlDisconnect of hoSQLConnect
85242>>>>>>>    End_Procedure
85243>>>>>>>
85243>>>>>>>    // *** Main message for executing an SQL script that has been compiled into the program as a resource ***
85243>>>>>>>    // Use the SQLIncludeScriptFile command to include an SQL script into the program.
85243>>>>>>>    // Returns False if no error occured.
85243>>>>>>>    Function SqlUtilExecuteResource String sMemFileName String sDriverID Boolean bCreateScriptFile Boolean bShowProgr Returns Boolean
85245>>>>>>>        Boolean bOK bShowProgress
85245>>>>>>>        tSQLScriptArray SQLScriptArray
85245>>>>>>>        tSQLScriptArray SQLScriptArray
85245>>>>>>>        DateTime dtTotalQueryStart dtTotalQueryEnd
85245>>>>>>>        TimeSpan tsTotalTime
85245>>>>>>>
85245>>>>>>>        Move (CurrentDateTime()) to dtTotalQueryStart
85246>>>>>>>        Get SqlUtilReadResource sMemFileName to SQLScriptArray
85247>>>>>>>        If (SQLScriptArray.bError = True) Begin
85249>>>>>>>            Function_Return False
85250>>>>>>>        End
85250>>>>>>>>
85250>>>>>>>
85250>>>>>>>        If (num_arguments > 3) Begin
85252>>>>>>>            Move bShowProgr to bShowProgress
85253>>>>>>>        End
85253>>>>>>>>
85253>>>>>>>
85253>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85254>>>>>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID bCreateScriptFile sMemFileName bShowProgress to bOK
85255>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
85256>>>>>>>
85256>>>>>>>        If (SQLScriptArray.bArgumentSizeChanged = True) Begin
85258>>>>>>>            Set_Argument_Size SQLScriptArray.iOrgArgumentSize
85259>>>>>>>>
85259>>>>>>>        End
85259>>>>>>>>
85259>>>>>>>
85259>>>>>>>        Move (CurrentDateTime()) to dtTotalQueryEnd
85260>>>>>>>        Move (dtTotalQueryEnd - dtTotalQueryStart) to tsTotalTime
85261>>>>>>>        Set ptsTotalQueryTime to tsTotalTime
85262>>>>>>>
85262>>>>>>>        Function_Return bOK
85263>>>>>>>    End_Procedure
85264>>>>>>>
85264>>>>>>>    // Reads a SQL script file that has been compiled into the .exe program as a resource.
85264>>>>>>>    // Pass: The memory resource reference and a boolean True if you want to create the file on disk (in the Home folder).
85264>>>>>>>    // Returns: A tSQLScriptArray Struct with the Sql script as an uChar Array will be returned along with the a bError boolean.
85264>>>>>>>    Function SqlUtilReadResource String sMemFileName Returns tSQLScriptArray
85266>>>>>>>        Integer iChannel iArgumentSize iCount
85266>>>>>>>        Number nByteCount
85266>>>>>>>        String sSQLScript
85266>>>>>>>        tSQLScriptArray SqlScriptArray
85266>>>>>>>        tSQLScriptArray SqlScriptArray
85266>>>>>>>        UChar[] uCharData
85267>>>>>>>
85267>>>>>>>        Move False to Err
85268>>>>>>>        Get Seq_New_Channel to iChannel
85269>>>>>>>        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
85271>>>>>>>            Error DFERR_PROGRAM 'No channel available...'
85272>>>>>>>>
85272>>>>>>>            Move True to SqlScriptArray.bError
85273>>>>>>>            Function_Return SqlScriptArray
85274>>>>>>>        End
85274>>>>>>>>
85274>>>>>>>
85274>>>>>>>        // First decide the size of the script
85274>>>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
85276>>>>>>>        Read_Block channel iChannel uCharData -1 // -1 means that all data should be read.
85278>>>>>>>        Close_Input channel iChannel
85280>>>>>>>
85280>>>>>>>        Move (SizeOfArray(uCharData)) to nByteCount
85281>>>>>>>        If (nByteCount  < 1) Begin
85283>>>>>>>            Send Seq_Release_Channel iChannel
85284>>>>>>>            Move True to SqlScriptArray.bError
85285>>>>>>>            Function_Return SqlScriptArray
85286>>>>>>>        End
85286>>>>>>>>
85286>>>>>>>
85286>>>>>>>        // If necessary change the string argument_size
85286>>>>>>>        Get_Argument_Size to iArgumentSize
85287>>>>>>>        If (nByteCount >= iArgumentSize) Begin
85289>>>>>>>            Move (nByteCount + 2048) to nByteCount
85290>>>>>>>            Set_Argument_Size nByteCount // Set new argument size just a bit higher than "needed" for overhead margin.
85291>>>>>>>>
85291>>>>>>>            Move True          to SqlScriptArray.bArgumentSizeChanged
85292>>>>>>>            Move iArgumentSize to SqlScriptArray.iOrgArgumentSize
85293>>>>>>>        End
85293>>>>>>>>
85293>>>>>>>        Else Begin
85294>>>>>>>            Move False to SqlScriptArray.bArgumentSizeChanged
85295>>>>>>>        End
85295>>>>>>>>
85295>>>>>>>
85295>>>>>>>        // Read the script file from memory line-by-line
85295>>>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
85297>>>>>>>            Move 0 to iCount
85298>>>>>>>            Repeat
85298>>>>>>>>
85298>>>>>>>                Readln channel iChannel sSQLScript
85300>>>>>>>                Move sSQLScript to SqlScriptArray.sSQLScriptArray[iCount]
85301>>>>>>>                Increment iCount
85302>>>>>>>            Until (SeqEof = True)
85304>>>>>>>        Close_Input channel iChannel
85306>>>>>>>        Send Seq_Release_Channel iChannel
85307>>>>>>>
85307>>>>>>>        // Finally "sanitize" the script by removing all comments.
85307>>>>>>>        Get _SqlUtilSanitizeScript SqlScriptArray to SqlScriptArray
85308>>>>>>>
85308>>>>>>>        Function_Return SqlScriptArray
85309>>>>>>>    End_Function
85310>>>>>>>
85310>>>>>>>    Function SqlUtilExecuteEmbeddedScript tSQLScriptArray SQLScriptArray String sDriverID Boolean bCreateScriptFile String sMemFileName Boolean bShowProgr Returns Boolean
85312>>>>>>>        String sSQLVal sStmt sCR sGOKeyWord sNoCountKeyWord sMessage sExportFile
85312>>>>>>>        Handle hoSql hoSQLConnect hoStmt hoError
85312>>>>>>>        Integer i iMsgs iRows iRowType iCount iChunkCounter iChunkMax iOut iNextSet iMessage
85312>>>>>>>        String[] sMsg aSQLQueryMessages
85314>>>>>>>        DateTime dtQueryExecStart dtQueryExecEnd
85314>>>>>>>        TimeSpan tsQuery
85314>>>>>>>        tSqlErrorArray aSqlErrorArray
85314>>>>>>>        tSqlErrorArray aSqlErrorArray
85314>>>>>>>        tSQLConnection SQLConnection
85314>>>>>>>        tSQLConnection SQLConnection
85314>>>>>>>        Boolean bMertechDriver bShowProgress
85314>>>>>>>
85314>>>>>>>        If (num_arguments > 4) Begin
85316>>>>>>>            Move bShowProgr to bShowProgress
85317>>>>>>>        End
85317>>>>>>>>
85317>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
85318>>>>>>>        If (bMertechDriver = False) Begin
85320>>>>>>>            Get phoSQLManager to hoSql
85321>>>>>>>        End
85321>>>>>>>>
85321>>>>>>>        Else Begin
85322>>>>>>>            Get _MertechSQLManagerHandle to hoSql
85323>>>>>>>        End
85323>>>>>>>>
85323>>>>>>>
85323>>>>>>>        Get _SqlFindKeyWord CI_SQLGO to sGOKeyWord
85324>>>>>>>        // There seems to be a problem to pass strings when their value gets really big, aka
85324>>>>>>>        // above the argument_size level. It isn't clear when these problems starts but sooner
85324>>>>>>>        // or later SqlExecDirect stops working correctly with no error messages!
85324>>>>>>>        // To guard from this we set a max number of lines (iChunkMax) that can be processed
85324>>>>>>>        // at a time. Testing with the Create Chinook Database script; 500 seems like a number that works fine.
85324>>>>>>>        // A bonus of this is that it turns out that it is actually faster to run in chunks!
85324>>>>>>>        Get piChunkMax to iChunkMax
85325>>>>>>>        Move 0 to iChunkCounter
85326>>>>>>>        Move "" to sStmt
85327>>>>>>>
85327>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
85328>>>>>>>        Move (Character(13) + Character(10)) to sCR
85329>>>>>>>
85329>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85330>>>>>>>
85330>>>>>>>        If (bMertechDriver = True) Begin
85332>>>>>>>            Get _MertechSQLConnect sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
85333>>>>>>>        End
85333>>>>>>>>
85333>>>>>>>        If (bMertechDriver = False) Begin
85335>>>>>>>            Get phoSQLManager  to hoSQL
85336>>>>>>>            Send SqlSetConnect of hoSQL sDriverID SQLConnection.sConnectionString
85337>>>>>>>            Get SqlConnect     of hoSQL "" "" to hoSQLConnect
85338>>>>>>>        End
85338>>>>>>>>
85338>>>>>>>
85338>>>>>>>        If (hoSQLConnect <> 0) Begin
85340>>>>>>>            Move False to Err
85341>>>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
85342>>>>>>>            If (hoStmt <> 0) Begin
85344>>>>>>>
85344>>>>>>>                // If the embedded resource should be written as a script file to disk:
85344>>>>>>>                If (bCreateScriptFile = True) Begin
85346>>>>>>>                    Get psHome of (phoWorkspace(ghoApplication)) to sExportFile
85347>>>>>>>                    Get vFolderFormat sExportFile to sExportFile
85348>>>>>>>                    Move (sExportFile + sMemFileName) to sExportFile
85349>>>>>>>                    Get Seq_New_Channel to iOut
85350>>>>>>>                    If (iOut <> DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
85352>>>>>>>                        Direct_Output channel iOut sExportFile
85354>>>>>>>                    End
85354>>>>>>>>
85354>>>>>>>                End
85354>>>>>>>>
85354>>>>>>>
85354>>>>>>>                // Record starting date/time stamp
85354>>>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
85355>>>>>>>                // Turn on error handling if enabled
85355>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
85357>>>>>>>                    Set pbSqlError to False
85358>>>>>>>                    Set paSqlErrorArray to aSqlErrorArray
85359>>>>>>>                    Move Error_Object_Id to hoError
85360>>>>>>>                    Move Self to Error_Object_Id
85361>>>>>>>                End
85361>>>>>>>>
85361>>>>>>>
85361>>>>>>>                Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iRows
85362>>>>>>>                Decrement iRows
85363>>>>>>>                Move (sNoCountKeyWord + sCR) to sStmt
85364>>>>>>>
85364>>>>>>>                For iCount from 0 to iRows
85370>>>>>>>>
85370>>>>>>>                    Move (SQLScriptArray.sSQLScriptArray[iCount]) to sSQLVal
85371>>>>>>>
85371>>>>>>>                    If (Uppercase(sSQLVal) <> sGOKeyWord) Begin
85373>>>>>>>                        If (sSQLVal <> "") Begin
85375>>>>>>>                            Move (sSQLVal + sCR) to sSQLVal
85376>>>>>>>                        End
85376>>>>>>>>
85376>>>>>>>                        Move (Append(sStmt, (sSQLVal))) to sStmt
85377>>>>>>>                    End
85377>>>>>>>>
85377>>>>>>>
85377>>>>>>>                    // - Each time we encounter a "GO" statement we execute it,
85377>>>>>>>                    // or if at the very end of the script.
85377>>>>>>>                    If (Uppercase(sSQLVal) = sGOKeyWord or iChunkCounter >= iChunkMax or iCount = iRows) Begin
85379>>>>>>>
85379>>>>>>>                        // - It turns out it can be at least 10 times faster to execute SQL statements in chunks,
85379>>>>>>>                        // instead of all in one go.
85379>>>>>>>                        Send SqlExecDirect of hoStmt sStmt
85380>>>>>>>
85380>>>>>>>                        If (bCreateScriptFile = True) Begin
85382>>>>>>>                            Write channel iOut sStmt
85384>>>>>>>                        End
85384>>>>>>>>
85384>>>>>>>                        Move "" to sStmt
85385>>>>>>>                        Move 0 to iChunkCounter
85386>>>>>>>                    End
85386>>>>>>>>
85386>>>>>>>                    Increment iChunkCounter
85387>>>>>>>                Loop
85388>>>>>>>>
85388>>>>>>>
85388>>>>>>>                Repeat
85388>>>>>>>>
85388>>>>>>>                    If (pbHandleQueryErrors(Self)) Begin
85390>>>>>>>                        Move hoError to Error_Object_Id
85391>>>>>>>                    End
85391>>>>>>>>
85391>>>>>>>                    Move (CurrentDateTime()) to dtQueryExecEnd
85392>>>>>>>
85392>>>>>>>                    Send _SqlColumnInfo hoStmt
85393>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT to iRows
85394>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
85395>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_NUMMESSAGES to iMsgs
85396>>>>>>>                    Set piRows    to iRows
85397>>>>>>>                    Set piRowType to iRowType
85398>>>>>>>
85398>>>>>>>                    If (iMsgs <> 0) Begin
85400>>>>>>>                        If (ghoDbUpdateHandler > 0) Begin
85402>>>>>>>                            Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
85403>>>>>>>                        End
85403>>>>>>>>
85403>>>>>>>                        For i from 1 to iMsgs
85409>>>>>>>>
85409>>>>>>>                            Get SqlGetMessage of hoStmt i to sMessage
85410>>>>>>>                            Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
85411>>>>>>>                            If (bShowProgress = True) Begin
85413>>>>>>>                                If (Active_State(ghoStatusPanel)) Begin
85415>>>>>>>                                    Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
85416>>>>>>>                                End
85416>>>>>>>>
85416>>>>>>>                                Else Begin
85417>>>>>>>                                    Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
85419>>>>>>>                                End
85419>>>>>>>>
85419>>>>>>>                            End
85419>>>>>>>>
85419>>>>>>>                            Move sMessage to sMsg[SizeOfArray(sMsg)]
85420>>>>>>>                            Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
85421>>>>>>>                        Loop
85422>>>>>>>>
85422>>>>>>>
85422>>>>>>>
85422>>>>>>>                        If (ghoDbUpdateHandler > 0) Begin
85424>>>>>>>                            Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
85425>>>>>>>                        End
85425>>>>>>>>
85425>>>>>>>                        Set paQueryMessages to sMsg
85426>>>>>>>                    End
85426>>>>>>>>
85426>>>>>>>
85426>>>>>>>                    Get SQLNextResultSet of hoStmt to iNextSet
85427>>>>>>>                Until (iNextSet = 0)
85429>>>>>>>
85429>>>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
85430>>>>>>>            End
85430>>>>>>>>
85430>>>>>>>
85430>>>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
85431>>>>>>>            Set ptsQueryExec to tsQuery
85432>>>>>>>            Send SqlClose of hoStmt
85433>>>>>>>
85433>>>>>>>            If (bCreateScriptFile = True) Begin
85435>>>>>>>                Close_Output channel iOut
85437>>>>>>>                Send Seq_Release_Channel iOut
85438>>>>>>>            End
85438>>>>>>>>
85438>>>>>>>        End
85438>>>>>>>>
85438>>>>>>>        Send SqlDisconnect of hoSQLConnect
85439>>>>>>>
85439>>>>>>>        Function_Return (hoSQLConnect <> 0 and Err = False)
85440>>>>>>>    End_Function
85441>>>>>>>
85441>>>>>>>    // * Dummy function for the Studio's Code Explorer *
85441>>>>>>>    Function SQL_UTILITY_FUNCTIONS Returns Boolean
85443>>>>>>>        Function_Return False
85444>>>>>>>    End_Function
85445>>>>>>>
85445>>>>>>>    // Does three things with auxilirary files;
85445>>>>>>>    // 1) Deletes the cache file in the first Data folder of the psDataPath property as the table at the SQL end has been changed.
85445>>>>>>>    // 2) Adds the sColumnName to the TableName.tag file in the first Data folder of the psDataPath property
85445>>>>>>>    // 3) Creates a new TableName.fd file if the DdSrc folder is available (if this is a development environment)
85445>>>>>>>    Function SqlUtilAdjustAuxFiles Handle hTable String sTableName String sColumnName Returns Boolean
85447>>>>>>>        String sDataPath sDDSrcPath sDriverID
85447>>>>>>>        Boolean bOK bExists bMertechDriver
85447>>>>>>>        Integer iCount iCh iPos
85447>>>>>>>
85447>>>>>>>        // If table name equals e.g. "dbo.MyTable" we need to remove the prefix.
85447>>>>>>>        If (sTableName contains ".") Begin
85449>>>>>>>            Move (Pos(".", sTableName)) to iPos
85450>>>>>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
85451>>>>>>>        End
85451>>>>>>>>
85451>>>>>>>
85451>>>>>>>        Get psDriverID to sDriverID
85452>>>>>>>        Get psDataPathFirstPart to sDataPath
85453>>>>>>>        Get vFolderExists sDataPath to bOK
85454>>>>>>>        If (bOK = False) Begin
85456>>>>>>>            Error DFERR_PROGRAM "Function SqlUtilAdjustAuxFiles; psDataPath not found!"
85457>>>>>>>>
85457>>>>>>>            Function_Return False
85458>>>>>>>        End
85458>>>>>>>>
85458>>>>>>>
85458>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
85459>>>>>>>        // First delete the cache file:
85459>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
85460>>>>>>>
85460>>>>>>>        Get Seq_New_Channel to iCh
85461>>>>>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
85463>>>>>>>            Function_Return False
85464>>>>>>>        End
85464>>>>>>>>
85464>>>>>>>
85464>>>>>>>        Get vFilePathExists (sDataPath + sTableName + ".tag") to bExists
85465>>>>>>>        If (bExists = False) Begin
85467>>>>>>>            Function_Return False
85468>>>>>>>        End
85468>>>>>>>>
85468>>>>>>>
85468>>>>>>>        // Add the new column name to the .tag file:
85468>>>>>>>        Append_Output channel iCh (sDataPath + sTableName + ".tag")
85470>>>>>>>            Writeln channel iCh sColumnName
85473>>>>>>>        Close_Output
85474>>>>>>>
85474>>>>>>>        // If in development environment; output new .fd file:
85474>>>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
85475>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
85476>>>>>>>        If (iCount > 1) Begin
85478>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
85479>>>>>>>        End
85479>>>>>>>>
85479>>>>>>>        Get vFolderExists sDDSrcPath to bExists
85480>>>>>>>        If (bExists = True) Begin
85482>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
85483>>>>>>>            Move False to Err
85484>>>>>>>            Get AutoConnectionIDLogin to bOK
85485>>>>>>>            If (hTable <> 0) Begin
85487>>>>>>>                Open hTable
85489>>>>>>>            End
85489>>>>>>>>
85489>>>>>>>            Else Begin
85490>>>>>>>                Get UtilTableOpen hTable sTableName DF_SHARE to bOK
85491>>>>>>>            End
85491>>>>>>>>
85491>>>>>>>
85491>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOK
85494>>>>>>>            If (bOK = True) Begin
85496>>>>>>>                Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
85498>>>>>>>            End
85498>>>>>>>>
85498>>>>>>>            If (Err = True) Begin
85500>>>>>>>                Move False to bOK
85501>>>>>>>            End
85501>>>>>>>>
85501>>>>>>>        End
85501>>>>>>>>
85501>>>>>>>
85501>>>>>>>        Function_Return (bOK = True)
85502>>>>>>>    End_Function
85503>>>>>>>
85503>>>>>>>    // Message for changing .int files to use connection ID's
85503>>>>>>>    //
85503>>>>>>>    // Changes all ".int" files for the passed sDataPath to use a sConnectionID,
85503>>>>>>>    // OR changes an existing connection id to a new id.
85503>>>>>>>    // Pass the full path to the data folder and the name of the connection id (string value).
85503>>>>>>>    // Pass a True for the bShowResult parameter to show work in progress (showln's).
85503>>>>>>>    Procedure SqlUtilChangeIntFilesToConnectionIDs String sDataPath String sConnectionID Boolean bShowResult
85505>>>>>>>        String sFileName sDriverID sDriverFile sConnectionString
85505>>>>>>>        String[] sFilesData
85506>>>>>>>        Boolean bOK bCancel
85506>>>>>>>        Integer iSize iCount
85506>>>>>>>
85506>>>>>>>        Get SqlUtilEnumerateIntFiles sDataPath to sFilesData
85507>>>>>>>        Move (SizeOfArray(sFilesData))    to iSize
85508>>>>>>>        If (iSize = 0) Begin
85510>>>>>>>            If (ghoStatusPanel <> 0) Begin
85512>>>>>>>                If (Active_State(ghoStatusPanel)) Begin
85514>>>>>>>                    Send Stop_StatusPanel of ghoStatusPanel
85515>>>>>>>                End
85515>>>>>>>>
85515>>>>>>>            End
85515>>>>>>>>
85515>>>>>>>            Send Info_Box "No .int files found! Nothing was changed."
85516>>>>>>>            Procedure_Return
85517>>>>>>>        End
85517>>>>>>>>
85517>>>>>>>
85517>>>>>>>        Move (Trim(sConnectionID)) to sConnectionID
85518>>>>>>>        Get vFolderFormat sDataPath to sDataPath
85519>>>>>>>        Decrement iSize
85520>>>>>>>        For iCount from 0 to iSize
85526>>>>>>>>
85526>>>>>>>            Move sFilesData[iCount] to sFileName
85527>>>>>>>            // This makes sure that we also can change an existing connection id to something new:
85527>>>>>>>            Get UtilChangeSourceCodeLine (sDataPath + sFileName) CS_SERVER_NAME (CS_SERVER_NAME * CS_DFCONNID + "=" + sConnectionID) bShowResult to bOK
85528>>>>>>>            If (ghoStatusPanel <> 0) Begin
85530>>>>>>>                If (Active_State(ghoStatusPanel)) Begin
85532>>>>>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
85533>>>>>>>                    If (bCancel = True) Begin
85535>>>>>>>                        Send Deactivate of ghoStatusPanel
85536>>>>>>>                        Procedure_Return
85537>>>>>>>                    End
85537>>>>>>>>
85537>>>>>>>                End
85537>>>>>>>>
85537>>>>>>>            End
85537>>>>>>>>
85537>>>>>>>        Loop
85538>>>>>>>>
85538>>>>>>>
85538>>>>>>>        Get psDriverID to sDriverID
85539>>>>>>>
85539>>>>>>>         // Finally also change the driver file e.g. MSSQLDRV.int file in the Data folder in case it has a "DFconnectionID xxxxID,SERVER..."
85539>>>>>>>        Move "" to sFileName
85540>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
85542>>>>>>>            Move "MSSQLDrv.int" to sFileName
85543>>>>>>>        End
85543>>>>>>>>
85543>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
85545>>>>>>>            Move "DB2_Drv.int" to sFileName
85546>>>>>>>        End
85546>>>>>>>>
85546>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
85548>>>>>>>            Move "ODBC_Drv.int" to sFileName
85549>>>>>>>        End
85549>>>>>>>>
85549>>>>>>>        If (sFileName <> "") Begin
85551>>>>>>>            Move "" to sDriverFile
85552>>>>>>>            Get_File_Path sFileName to sDriverFile
85553>>>>>>>            If (sDriverFile <> "") Begin
85555>>>>>>>                Get psConnectionString to sConnectionString
85556>>>>>>>                Get UtilChangeSourceCodeLine sDriverFile CS_SQLConnectionIDText (CS_SQLConnectionIDText * String(sConnectionID) + "," * String(sConnectionString) * String(",0")) bShowResult to bOK
85557>>>>>>>            End
85557>>>>>>>>
85557>>>>>>>        End
85557>>>>>>>>
85557>>>>>>>    End_Procedure
85558>>>>>>>
85558>>>>>>>    // Checks if the database exists in SQL. Returns = True if it does.
85558>>>>>>>    Function SqlUtilCheckIfDatabaseExists String sDatabase Returns Boolean
85560>>>>>>>        String[] sDatabaseArray
85561>>>>>>>        String sVal sServer sDriverID
85561>>>>>>>        Integer iCount iSize iPos
85561>>>>>>>        Boolean bExists
85561>>>>>>>        tSQLConnection SQLConnection
85561>>>>>>>        tSQLConnection SQLConnection
85561>>>>>>>
85561>>>>>>>        Move False to bExists
85562>>>>>>>        Get psDriverID to sDriverID
85563>>>>>>>        // DB2 doesn't need to have a "Database" name, so we always return True.
85563>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
85565>>>>>>>            Function_Return bExists
85566>>>>>>>        End
85566>>>>>>>>
85566>>>>>>>
85566>>>>>>>        Get SqlUtilEnumerateDatabases sDriverID to sDatabaseArray
85567>>>>>>>        If (SizeOfArray(sDatabaseArray) = 0) Begin
85569>>>>>>>            Function_Return False
85570>>>>>>>        End
85570>>>>>>>>
85570>>>>>>>
85570>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85571>>>>>>>        Get ParseKeyWord SQLConnection.sConnectionString (CS_SQLIniDSNKeyword + "=") to sServer
85572>>>>>>>        If (sServer contains "/") Begin
85574>>>>>>>            Move (Pos("/", sServer)) to iPos
85575>>>>>>>            Move (Mid(sServer, 999, (iPos +1)))                        to sDatabase
85576>>>>>>>        End
85576>>>>>>>>
85576>>>>>>>
85576>>>>>>>        Move (SizeOfArray(sDatabaseArray)) to iSize
85577>>>>>>>        Decrement iSize
85578>>>>>>>        For iCount from 0 to iSize
85584>>>>>>>>
85584>>>>>>>            Move sDatabaseArray[iCount] to sVal
85585>>>>>>>            If (Uppercase(sVal) = Uppercase(sDatabase)) Begin
85587>>>>>>>                Move True to bExists
85588>>>>>>>            End
85588>>>>>>>>
85588>>>>>>>        Loop
85589>>>>>>>>
85589>>>>>>>
85589>>>>>>>        Function_Return bExists
85590>>>>>>>    End_Function
85591>>>>>>>
85591>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
85591>>>>>>>    Function SqlUtilCheckIfTableHandleExists Handle hTable String sDriverID Returns Boolean
85593>>>>>>>        String sTableName sVal
85593>>>>>>>        Boolean bExists
85593>>>>>>>        String[] sTablesArray
85594>>>>>>>        Integer iSize iCount
85594>>>>>>>
85594>>>>>>>        Move False to bExists
85595>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85596>>>>>>>        Get SqlUtilEnumerateTables sDriverID to sTablesArray
85597>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
85598>>>>>>>        Decrement iSize
85599>>>>>>>        For iCount from 0 to iSize
85605>>>>>>>>
85605>>>>>>>            Move sTablesArray[iCount] to sVal
85606>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
85608>>>>>>>                Move True to bExists
85609>>>>>>>                Move iSize to iCount // We're done!
85610>>>>>>>            End
85610>>>>>>>>
85610>>>>>>>        Loop
85611>>>>>>>>
85611>>>>>>>
85611>>>>>>>        Function_Return bExists
85612>>>>>>>    End_Function
85613>>>>>>>
85613>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
85613>>>>>>>    Function SqlUtilCheckIfTableNameExists String sTableName String sDriverID Returns Boolean
85615>>>>>>>        String sVal
85615>>>>>>>        Boolean bExists
85615>>>>>>>        String[] sTablesArray
85616>>>>>>>        Integer iSize iCount
85616>>>>>>>
85616>>>>>>>        Move False to bExists
85617>>>>>>>        Get SqlUtilEnumerateTables sDriverID to sTablesArray
85618>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
85619>>>>>>>        Decrement iSize
85620>>>>>>>        For iCount from 0 to iSize
85626>>>>>>>>
85626>>>>>>>            Move sTablesArray[iCount] to sVal
85627>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
85629>>>>>>>                Move True to bExists
85630>>>>>>>                Move iSize to iCount // We're done!
85631>>>>>>>            End
85631>>>>>>>>
85631>>>>>>>        Loop
85632>>>>>>>>
85632>>>>>>>
85632>>>>>>>        Function_Return bExists
85633>>>>>>>    End_Function
85634>>>>>>>
85634>>>>>>>    // ToDo: This index name function needs to be finished...
85634>>>>>>>    Function SqlUtilCheckIfIndexNameExists Handle hTable String sIndexName Returns Boolean
85636>>>>>>>        String sSchema sTableName sDriverID
85636>>>>>>>        Boolean bExists
85636>>>>>>>
85636>>>>>>>        Get psDriverID to sDriverID
85637>>>>>>>        Get psSchema to sSchema
85638>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85639>>>>>>>
85639>>>>>>>        Function_Return bExists
85640>>>>>>>    End_Function
85641>>>>>>>
85641>>>>>>>    // Checks if a column/field name exists in a SQL table definition
85641>>>>>>>    // Returns True if it does
85641>>>>>>>    // Sample:
85641>>>>>>>    //   Get SQLUtilColumnExists "MySQLTable" "MyColumnName" to bExists
85641>>>>>>>    Function SqlUtilColumnExists String sTableName String sFieldName Returns Boolean
85643>>>>>>>        Integer iNumColumns iColumn
85643>>>>>>>        String sColumn sDriverID
85643>>>>>>>        String[] sColumnsArray
85644>>>>>>>        Boolean bExists bOK
85644>>>>>>>
85644>>>>>>>        Move False to bExists
85645>>>>>>>        Get AutoConnectionIDLogin to bOK
85646>>>>>>>        Get psDriverID to sDriverID
85647>>>>>>>
85647>>>>>>>        Get SqlUtilEnumerateColumns sDriverID sTableName to sColumnsArray
85648>>>>>>>        Move (SizeOfArray(sColumnsArray)) to iNumColumns
85649>>>>>>>        Decrement iNumColumns
85650>>>>>>>        For iColumn from 0 to iNumColumns
85656>>>>>>>>
85656>>>>>>>            Move sColumnsArray[iColumn] to sColumn
85657>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
85659>>>>>>>                Move True to bExists
85660>>>>>>>                Move iNumColumns to iColumn // We're out of here
85661>>>>>>>            End
85661>>>>>>>>
85661>>>>>>>        Loop
85662>>>>>>>>
85662>>>>>>>
85662>>>>>>>        Function_Return bExists
85663>>>>>>>    End_Function
85664>>>>>>>
85664>>>>>>>    Function SqlUtilConvertColumnTypesToSQL2008 Handle hTable Returns Boolean
85666>>>>>>>        Integer iNumColumns iColumn iDFType iNativeType
85666>>>>>>>        Boolean bOpened bOK
85666>>>>>>>        String sColumnName sNativeTypeName
85666>>>>>>>
85666>>>>>>>        Get AutoConnectionIDLogin to bOK
85667>>>>>>>        Get OpenTableExclusive hTable to bOK
85668>>>>>>>        If (bOK = False) Begin
85670>>>>>>>            Function_Return False
85671>>>>>>>        End
85671>>>>>>>>
85671>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
85674>>>>>>>        If (bOpened = False) Begin
85676>>>>>>>            Error DFERR_PROGRAM ("Function SQLUtilConvertColumnTypesToSQL2008; Could not open table" * String(hTable))
85677>>>>>>>>
85677>>>>>>>            Function_Return False
85678>>>>>>>        End
85678>>>>>>>>
85678>>>>>>>
85678>>>>>>>        Move False to Err
85679>>>>>>>
85679>>>>>>>        Structure_Start hTable
85680>>>>>>>            Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
85683>>>>>>>
85683>>>>>>>            For iColumn from 1 to iNumColumns
85689>>>>>>>>
85689>>>>>>>                Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iDfType
85692>>>>>>>                Get_Attribute DF_FIELD_NAME             of hTable iColumn to sColumnName
85695>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iNativeType
85698>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE_Name of hTable iColumn to sNativeTypeName
85701>>>>>>>
85701>>>>>>>                Case Begin
85701>>>>>>>                    Case (iDFType = DF_DATE)
85703>>>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
85705>>>>>>>                            // Convert datetime to date
85705>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_DATE
85708>>>>>>>                        End
85708>>>>>>>>
85708>>>>>>>                        Case Break
85709>>>>>>>                    Case (iDFType = DF_DATETIME)
85712>>>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
85714>>>>>>>                            // Convert datetime to datetime2
85714>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_TIMESTAMP2
85717>>>>>>>                        End
85717>>>>>>>>
85717>>>>>>>                        Case Break
85718>>>>>>>                    Case (iDFType = DF_ASCII)
85721>>>>>>>                        If (iNativeType = SQL_CHAR) Begin
85723>>>>>>>                            // Convert char to varchar
85723>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
85726>>>>>>>                        End
85726>>>>>>>>
85726>>>>>>>                        Case Break
85727>>>>>>>                    Case (iDFType = DF_TEXT)
85730>>>>>>>                        If (iNativeType = SQL_LONGVARCHAR) Begin
85732>>>>>>>                            // Convert text to varchar(max)
85732>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
85735>>>>>>>                        End
85735>>>>>>>>
85735>>>>>>>                        Case Break
85736>>>>>>>                    Case (iDFType = DF_BINARY)
85739>>>>>>>                        If (iNativeType = SQL_LONGVARBINARY) Begin
85741>>>>>>>                            // Convert image to varbinary(max)
85741>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARBINARY
85744>>>>>>>                        End
85744>>>>>>>>
85744>>>>>>>                        Case Break
85745>>>>>>>                Case End
85745>>>>>>>            Loop
85746>>>>>>>>
85746>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
85747>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85749>>>>>>>
85749>>>>>>>        Set Action_Text of ghoStatusPanel to ""
85750>>>>>>>        Function_Return (Err = False)
85751>>>>>>>    End_Function
85752>>>>>>>
85752>>>>>>>
85752>>>>>>>    // Will create an SQL table with the passed sTableName & sColumnName as Numeric 4.2 to keep
85752>>>>>>>    // the DbUpdateVersion database revision in.
85752>>>>>>>    // Also pass the file number of the current (embedded?) table number used in development.
85752>>>>>>>    // It will first create the SQL Table & column, then create the .int file and change Filelist.cfg
85752>>>>>>>    Function SqlUtilCreateDbVersionTable Handle hTable String sColumnName String sDriverID Returns Boolean
85754>>>>>>>        Boolean bOK bOpened
85754>>>>>>>        String sTableName sDataType sAlterTable sAddColumn sLengthAndDecimals sStmt
85754>>>>>>>
85754>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
85757>>>>>>>        Get _TableNameOnly sTableName to sTableName
85758>>>>>>>        If (sTableName = "") Begin
85760>>>>>>>            Function_Return False
85761>>>>>>>        End
85761>>>>>>>>
85761>>>>>>>
85761>>>>>>>        // This just creates the table and a "dummy" column.
85761>>>>>>>        Get SqlTableCreate hTable sDriverID to bOK
85762>>>>>>>        If (bOK = False) Begin
85764>>>>>>>            Function_Return False
85765>>>>>>>        End
85765>>>>>>>>
85765>>>>>>>
85765>>>>>>>        Close hTable
85766>>>>>>>        Move False to Err
85767>>>>>>>
85767>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
85768>>>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
85769>>>>>>>        Move "Decimal" to sDataType
85770>>>>>>>        Get _SqlFormatLengthAndDecimalAsString 4 2 to sLengthAndDecimals
85771>>>>>>>
85771>>>>>>>        // Adds the "sColumnName" passed to the function
85771>>>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals) to sStmt
85772>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85773>>>>>>>
85773>>>>>>>        // Now we can delete the dummy column:
85773>>>>>>>        Get SqlColumnRemoveByTableName sTableName "Dummy" to bOK
85774>>>>>>>
85774>>>>>>>        // Finally, we attach to the newly created table.
85774>>>>>>>        If (Err = False) Begin
85776>>>>>>>            Get ApiTableAttachToSQL hTable True to bOK
85777>>>>>>>        End
85777>>>>>>>>
85777>>>>>>>        Open hTable
85779>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
85782>>>>>>>
85782>>>>>>>        Function_Return (Err = False and bOK = True and bOpened = True)
85783>>>>>>>    End_Function
85784>>>>>>>
85784>>>>>>>    // The table must already exist in the filelist for this function to work.
85784>>>>>>>    // It creates a rudimentary .int file in the first Data folder of the psDataPath property.
85784>>>>>>>    Function SqlUtilCreateIntFile Handle hTable String sDriverID String sConnectionID Boolean bAnsi Boolean bSysFile Returns Boolean
85786>>>>>>>        Boolean bOK bExists bUseConnectionID bMertech
85786>>>>>>>        String sDataPath sRootName sLogicalName sPhysicalFileName sConnectionString sDatabaseName sSchemaName sANSI_OEM
85786>>>>>>>        String[] sIndexArray
85787>>>>>>>        Integer iCount iCh iSize
85787>>>>>>>
85787>>>>>>>        Move (Trim(sConnectionID) <> "") to bUseConnectionID
85788>>>>>>>        Get psConnectionString to sConnectionString
85789>>>>>>>
85789>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
85790>>>>>>>        If (bANSI = False) Begin
85792>>>>>>>            Move CS_OEM_Txt to sANSI_OEM
85793>>>>>>>        End
85793>>>>>>>>
85793>>>>>>>
85793>>>>>>>        Get psDataPathFirstPart to sDataPath
85794>>>>>>>        Get vFolderExists sDataPath to bOK
85795>>>>>>>        If (bOK = False) Begin
85797>>>>>>>            Error DFERR_PROGRAM "Function SqlUtilCreateIntFile; psDataPath not found!"
85798>>>>>>>>
85798>>>>>>>            Function_Return False
85799>>>>>>>        End
85799>>>>>>>>
85799>>>>>>>        Get vFolderFormat sDataPath to sDataPath
85800>>>>>>>
85800>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85803>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
85806>>>>>>>        Get _TableNameOnly sRootName to sDatabaseName
85807>>>>>>>        Move sLogicalName  to sPhysicalFileName
85808>>>>>>>        Move (sPhysicalFileName + ".int") to sPhysicalFileName
85809>>>>>>>
85809>>>>>>>        Get IsMertechDriver sDriverID to bMertech
85810>>>>>>>        If (bMertech = True) Begin
85812>>>>>>>            // This should not be called here. Instead it is called by the SqlUtilUpdateIntFile!
85812>>>>>>>            // Else it will create an error in the error log (although it won't do anything...)
85812>>>>>>>            // Get _MertechSqlUtilCreateIntFile hTable sDataPath sPhysicalFileName to bOK
85812>>>>>>>            Function_Return (bOK = True)
85813>>>>>>>        End
85813>>>>>>>>
85813>>>>>>>
85813>>>>>>>        Get psSchema hTable to sSchemaName
85814>>>>>>>        If (sSchemaName = "") Begin
85816>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchemaName
85817>>>>>>>        End
85817>>>>>>>>
85817>>>>>>>
85817>>>>>>>        // If the .int file already exists; we rename it to "FileName" + ".bak"
85817>>>>>>>        Get vFilePathExists (sDataPath + sPhysicalFileName) to bExists
85818>>>>>>>        If (bExists = True) Begin
85820>>>>>>>            Get vRenameFile (sDataPath + sPhysicalFileName) (sDataPath + sPhysicalFileName + ".bak") to bOK
85821>>>>>>>        End
85821>>>>>>>>
85821>>>>>>>
85821>>>>>>>        Get UtilDeleteCacheFile sRootName to bOK
85822>>>>>>>        Get SqlUtilEnumerateIndexes sRootName sDriverID to sIndexArray
85823>>>>>>>
85823>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sPhysicalFileName) to iCh
85824>>>>>>>            Writeln channel iCh CS_DRIVER_NAME     " " sDriverID
85829>>>>>>>            If (bUseConnectionID = True) Begin
85831>>>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_DFCONNID "=" sConnectionID
85838>>>>>>>            End
85838>>>>>>>>
85838>>>>>>>            Else Begin
85839>>>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_SERVER "=" sConnectionString
85846>>>>>>>            End
85846>>>>>>>>
85846>>>>>>>            Writeln channel iCh CS_DATABASE_NAME          " " sDatabaseName
85851>>>>>>>            Writeln channel iCh CS_SCHEMA_NAME            " " (Lowercase(sSchemaName))
85856>>>>>>>            // There seems to be a new order how these are set from DF19.
85856>>>>>>>            If (bSysFile = True) Begin
85858>>>>>>>                Writeln channel iCh CS_RECNUM_TABLE       " " "NO"
85863>>>>>>>            End
85863>>>>>>>>
85863>>>>>>>            Writeln channel iCh CS_TABLE_CHARACTER_FORMAT " " sANSI_OEM
85868>>>>>>>            Writeln channel iCh CS_USE_DUMMY_ZERO_DATE    " " "YES" // ToDo: We maybe need to paramerize this setting?
85873>>>>>>>            If (bSysFile = True) Begin
85875>>>>>>>                Writeln channel iCh CS_SYSTEM_FILE        " " "YES"
85880>>>>>>>            End
85880>>>>>>>>
85880>>>>>>>
85880>>>>>>>            If (bSysFile = False) Begin
85882>>>>>>>                Move (SizeOfArray(sIndexArray)) to iSize
85883>>>>>>>                Move (SortArray(sIndexArray)) to sIndexArray
85884>>>>>>>                If (iSize > 0) Begin
85886>>>>>>>                    Writeln channel iCh (CS_PRIMARY_INDEX * String("0"))
85889>>>>>>>                    Writeln channel iCh // Just an empty line
85891>>>>>>>                End
85891>>>>>>>>
85891>>>>>>>                Decrement iSize
85892>>>>>>>                For iCount from 0 to iSize
85898>>>>>>>>
85898>>>>>>>                    Writeln channel iCh (CS_INDEX_NUMBER * String(iCount))
85901>>>>>>>                    Writeln channel iCh (CS_INDEX_NAME   * String(sIndexArray[iCount]))
85904>>>>>>>                    Writeln channel iCh
85906>>>>>>>                Loop
85907>>>>>>>>
85907>>>>>>>            End
85907>>>>>>>>
85907>>>>>>>        Send Seq_Close_Channel iCh
85908>>>>>>>
85908>>>>>>>        // Wait a sec for Windows to finish writing the file:
85908>>>>>>>        Sleep 1
85909>>>>>>>
85909>>>>>>>        Function_Return (bOK = True)
85910>>>>>>>    End_Function
85911>>>>>>>
85911>>>>>>>    // Returns a handle to the SQL server associated with the passed driver ID.
85911>>>>>>>    // Pass e.g. the psServer property to determine the current connection server.
85911>>>>>>>    // Returns a handle to the database connection, or a zero (0) if it fails.
85911>>>>>>>    // This handle can be used to obtain attributes about the server, such as default
85911>>>>>>>    // column types.
85911>>>>>>>    Function SqlUtilDatabaseHandle String sDriverID String sServer Returns Handle
85913>>>>>>>        Handle hDatabase
85913>>>>>>>        Integer iDriver iServers iCount
85913>>>>>>>        String sValue
85913>>>>>>>
85913>>>>>>>        If (sServer = "") Begin
85915>>>>>>>            Function_Return 0
85916>>>>>>>        End
85916>>>>>>>>
85916>>>>>>>
85916>>>>>>>        Get DriverIndex sDriverID to iDriver
85917>>>>>>>        If (iDriver = 0) Begin
85919>>>>>>>            Function_Return 0
85920>>>>>>>        End
85920>>>>>>>>
85920>>>>>>>
85920>>>>>>>        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iServers
85923>>>>>>>        For iCount from 1 to iServers
85929>>>>>>>>
85929>>>>>>>            Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
85932>>>>>>>            If (Uppercase(sValue) contains Uppercase(sServer)) Begin
85934>>>>>>>                Get_Attribute DF_DATABASE_ID of iDriver iCount to hDatabase
85937>>>>>>>            End
85937>>>>>>>>
85937>>>>>>>        Loop
85938>>>>>>>>
85938>>>>>>>
85938>>>>>>>        Function_Return hDatabase
85939>>>>>>>    End_Function
85940>>>>>>>
85940>>>>>>>//    Function UtilIsFilelistEntryDriverBased Integer hTable String sDriverID Returns Boolean
85940>>>>>>>//        String sRootName
85940>>>>>>>//        Boolean bOK
85940>>>>>>>//
85940>>>>>>>//        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
85940>>>>>>>//        Move (sRootName contains sDriverID) to bOK
85940>>>>>>>//
85940>>>>>>>//        Function_Return bOK
85940>>>>>>>//    End_Function
85940>>>>>>>
85940>>>>>>>//    Function UtilFilelistAddDriverInfo Integer hTable Returns Boolean
85940>>>>>>>//        String sDriverID sRootName sDisplayName sSchema sVal
85940>>>>>>>//        Integer iDbType
85940>>>>>>>//        Boolean bOK
85940>>>>>>>//
85940>>>>>>>//        Get UtilIsFilelistEntryDriverBased to bOK
85940>>>>>>>//        If (bOK = True) Begin
85940>>>>>>>//            Function_Return False
85940>>>>>>>//        End
85940>>>>>>>//
85940>>>>>>>//        Get psDriverID to sDriverID
85940>>>>>>>//        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85940>>>>>>>//        Move (sDriverID + ":" + sRootName)           to sRootName
85940>>>>>>>//        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85940>>>>>>>//
85940>>>>>>>//        Get psDriverID to sDriverID
85940>>>>>>>//        Get piDbType   to iDbType
85940>>>>>>>//        Get psSchema   to sSchema
85940>>>>>>>//        If (sSchema = "") Begin
85940>>>>>>>//            Get _SqlFindKeyWord CI_SQLDBO to sSchema
85940>>>>>>>//        End
85940>>>>>>>//
85940>>>>>>>//        Move (Uppercase(sDisplayName)) to sVal
85940>>>>>>>//        If (not(sVal contains (sSchema + "."))) Begin
85940>>>>>>>//            If (iDbType = EN_dbTypeDB2) Begin
85940>>>>>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
85940>>>>>>>//            End
85940>>>>>>>//            Else Begin
85940>>>>>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
85940>>>>>>>//            End
85940>>>>>>>//        End
85940>>>>>>>//
85940>>>>>>>//        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85940>>>>>>>//        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85940>>>>>>>//
85940>>>>>>>//        Function_Return True
85940>>>>>>>//    End_Function
85940>>>>>>>
85940>>>>>>>    // Removes all driver identifications (e.g. "MSSQLDRV;MyTable" or "MyTable.MSSQLDRV"
85940>>>>>>>    // from the passed filelist.
85940>>>>>>>    // Returns the number of tables affected.
85940>>>>>>>    Function SqlUtilFilelistRemoveDriverInfo String sFilelist Returns Integer
85942>>>>>>>        String sCurrentFileList sRootName sDisplayName sLogicalName sVal
85942>>>>>>>        Integer iRetval
85942>>>>>>>        Handle hTable
85942>>>>>>>
85942>>>>>>>        // We first save the current filelist as the passed filelist name
85942>>>>>>>        // may come from another workspace, to restore it when we're ready.
85942>>>>>>>        Get_Attribute DF_FILELIST_NAME to sCurrentFileList
85945>>>>>>>        Set_Attribute DF_FILELIST_NAME to sFilelist
85948>>>>>>>        Move 0 to hTable
85949>>>>>>>        Move 0 to iRetval
85950>>>>>>>
85950>>>>>>>        Repeat
85950>>>>>>>>
85950>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
85953>>>>>>>            If (hTable <> 0) Begin
85955>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85958>>>>>>>                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85961>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
85964>>>>>>>                Move (Uppercase(sRootName)) to sVal
85965>>>>>>>                If (sVal contains MSSQLDRV_ID or sVal contains DB2_DRV_ID or sVal contains ODBC_DRV_ID) Begin
85967>>>>>>>                    // Prefixes:
85967>>>>>>>                    Move (Replace((MSSQLDRV_ID + ":"), sRootName, "")) to sRootName
85968>>>>>>>                    Move (Replace((DB2_DRV_ID  + ":"), sRootName, "")) to sRootName
85969>>>>>>>                    Move (Replace((ODBC_DRV_ID + ":"), sRootName, "")) to sRootName
85970>>>>>>>                    // Suffixes:
85970>>>>>>>                    Move (Replace(("." + MSSQLDRV_ID), sRootName, "")) to sRootName
85971>>>>>>>                    Move (Replace(("." + DB2_DRV_ID),  sRootName, "")) to sRootName
85972>>>>>>>                    Move (Replace(("." + ODBC_DRV_ID), sRootName, "")) to sRootName
85973>>>>>>>
85973>>>>>>>                    // Change Filelist entry:
85973>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable          to sRootName
85976>>>>>>>
85976>>>>>>>                    Move (Lowercase(sDisplayName)) to sVal
85977>>>>>>>                    If (sVal contains "dbo.") Begin
85979>>>>>>>                        Move (Replace("dbo.", sDisplayName, ""))       to sDisplayName
85980>>>>>>>
85980>>>>>>>                        // Change Filelist entry:
85980>>>>>>>                        Set_Attribute DF_FILE_DISPLAY_NAME of hTable   to sDisplayName
85983>>>>>>>                    End
85983>>>>>>>>
85983>>>>>>>                    Increment iRetval
85984>>>>>>>                End
85984>>>>>>>>
85984>>>>>>>            End
85984>>>>>>>>
85984>>>>>>>        Until (hTable = 0)
85986>>>>>>>
85986>>>>>>>        Set_Attribute DF_FILELIST_NAME to sCurrentFileList
85989>>>>>>>
85989>>>>>>>        Function_Return iRetval
85990>>>>>>>    End_Function
85991>>>>>>>
85991>>>>>>>    // To open all Sql based tables in Filelist.cfg
85991>>>>>>>    Procedure SqlUtilOpenAllTables
85993>>>>>>>        Handle hTable
85993>>>>>>>        String sRoot sDriverID
85993>>>>>>>        Boolean bOK
85993>>>>>>>
85993>>>>>>>        Move 0 to hTable
85994>>>>>>>        Move "" to sDriverID
85995>>>>>>>        Get AutoConnectionIDLogin to bOK
85996>>>>>>>
85996>>>>>>>        Repeat
85996>>>>>>>>
85996>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
85999>>>>>>>            If (hTable > 0) Begin
86001>>>>>>>                Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
86004>>>>>>>                If (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) Begin
86006>>>>>>>                    Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
86009>>>>>>>                    If (Uppercase(sRoot) contains ".INT" or Uppercase(sRoot) contains MSSQLDRV_ID or Uppercase(sRoot) contains DB2_DRV_ID or Uppercase(sRoot) contains ODBC_DRV_ID) Begin
86011>>>>>>>                        Open hTable
86013>>>>>>>                    End
86013>>>>>>>>
86013>>>>>>>                End
86013>>>>>>>>
86013>>>>>>>            End
86013>>>>>>>>
86013>>>>>>>
86013>>>>>>>        Until (hTable = 0)
86015>>>>>>>    End_Procedure
86016>>>>>>>
86016>>>>>>>//    Function SqlUtilSchemaName Handle hTable Returns String
86016>>>>>>>//        String sRetval sDriverID
86016>>>>>>>//        String sTableName
86016>>>>>>>//        Integer iDbType iIndex
86016>>>>>>>//        Boolean bOK
86016>>>>>>>//
86016>>>>>>>//        Get psDriverID to sDriverID
86016>>>>>>>//        Get _SqlCheckCurrentDriver sDriverID to bOK
86016>>>>>>>//        If (hTable = 0 or bOK = False) Begin
86016>>>>>>>//            Function_Return ""
86016>>>>>>>//        End
86016>>>>>>>//
86016>>>>>>>//        Move False to Err
86016>>>>>>>//        Get UtilTableHandleToString hTable to sTableName
86016>>>>>>>//        Get piDbType to iDbType
86016>>>>>>>//        Get _SqlUtilEnumerateTableIndex sTableName sDriverID to iIndex
86016>>>>>>>//        If (iIndex = -1) Begin
86016>>>>>>>//            Function_Return ""
86016>>>>>>>//        End
86016>>>>>>>//
86016>>>>>>>//        Function_Return sRetval
86016>>>>>>>//    End_Function
86016>>>>>>>
86016>>>>>>>    // Checks if the passed Table;
86016>>>>>>>    // 1) Already has a Filelist entry that points to SQL and
86016>>>>>>>    // 2) It has an .int file.
86016>>>>>>>    // If both is True it should already be connected to SQL
86016>>>>>>>    Function SqlUtilTableIsAttached String sDriverID Handle hTable Returns Boolean
86018>>>>>>>        Boolean bExists bRootName
86018>>>>>>>        String sRootName sDataPath
86018>>>>>>>
86018>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86021>>>>>>>        Move (sRootName contains sDriverID) to bRootName
86022>>>>>>>
86022>>>>>>>        Get psDataPathFirstPart to sDataPath
86023>>>>>>>        Get vFolderExists sDataPath to bExists
86024>>>>>>>        If (bExists = False) Begin
86026>>>>>>>            // If the path doesn't exist it cannot have an .int file and we're done, although it shouldn't happen.
86026>>>>>>>            Function_Return False
86027>>>>>>>        End
86027>>>>>>>>
86027>>>>>>>
86027>>>>>>>        Get vFolderFormat sDataPath to sDataPath
86028>>>>>>>        Get _TableNameOnly sRootName to sRootName
86029>>>>>>>        Get vFilePathExists (sDataPath + sRootName + ".int") to bExists
86030>>>>>>>
86030>>>>>>>        Function_Return (bRootName = True and bExists = True)
86031>>>>>>>    End_Function
86032>>>>>>>
86032>>>>>>>    Function SqlUtilTableIsViewType String sDriverID Handle hTable Returns Boolean
86034>>>>>>>        Boolean bViewTableType bOpen bOK
86034>>>>>>>        Integer iTableCount iNumTables
86034>>>>>>>        String sTableName sOwner sTableType sEnumTableName sEnumSchemaName
86034>>>>>>>        Handle hoCliHandler
86034>>>>>>>        tSQLConnection SQLConnection
86034>>>>>>>        tSQLConnection SQLConnection
86034>>>>>>>
86034>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
86037>>>>>>>        If (bOpen = False) Begin
86039>>>>>>>            Get AutoConnectionIDLogin to bOK
86040>>>>>>>            Open hTable
86042>>>>>>>        End
86042>>>>>>>>
86042>>>>>>>
86042>>>>>>>        Get pSQLConnection to SQLConnection
86043>>>>>>>        Get phoCLIHandler to hoCliHandler
86044>>>>>>>        Set psDriverID of hoCliHandler to sDriverID
86045>>>>>>>
86045>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
86048>>>>>>>        Get _TableNameOnly sTableName to sTableName
86049>>>>>>>        Get_Attribute DF_FILE_OWNER     of hTable to sOwner
86052>>>>>>>        Get EnumerateTables of hoCliHandler SQLConnection.sConnectionString to iNumTables
86053>>>>>>>
86053>>>>>>>        For iTableCount from 1 to iNumTables
86059>>>>>>>>
86059>>>>>>>            Get TableName  of hoCliHandler iTableCount to sEnumTableName
86060>>>>>>>            Get SchemaName of hoCliHandler iTableCount to sEnumSchemaName
86061>>>>>>>            If ((Uppercase(sEnumTableName)  = Uppercase(sTableName)) and (Uppercase(sEnumSchemaName) = Uppercase(sOwner))) Begin
86063>>>>>>>                Get TableType of hoCliHandler iTableCount to sTableType
86064>>>>>>>                Move iNumTables to iTableCount // We're done.
86065>>>>>>>            End
86065>>>>>>>>
86065>>>>>>>        Loop
86066>>>>>>>>
86066>>>>>>>
86066>>>>>>>        Move (sTableType = "VIEW") to bViewTableType
86067>>>>>>>        If (bOpen = False) Begin
86069>>>>>>>            Close hTable
86070>>>>>>>        End
86070>>>>>>>>
86070>>>>>>>
86070>>>>>>>        Function_Return bViewTableType
86071>>>>>>>    End_Function
86072>>>>>>>
86072>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
86072>>>>>>>    //
86072>>>>>>>    // SQL utility function that returns a database type (string) constant
86072>>>>>>>    // corresponding to the passed iDbType.
86072>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
86074>>>>>>>        String sRetval
86074>>>>>>>        Get SqlUtilDbTypeToString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
86075>>>>>>>        Function_Return sRetval
86076>>>>>>>    End_Function
86077>>>>>>>
86077>>>>>>>    // SQL utility function that returns a database type constant (integer)
86077>>>>>>>    // corresponding to the passed sDbType string constant.
86077>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType Returns Integer
86079>>>>>>>        Integer iRetval
86079>>>>>>>        Get SqlUtilDbTypeToInteger of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDbType to iRetval
86080>>>>>>>        Function_Return iRetval
86081>>>>>>>    End_Function
86082>>>>>>>
86082>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
86082>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
86082>>>>>>>    // the SQL Connection program's grid.
86082>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
86084>>>>>>>        String sRetval
86084>>>>>>>        Get SqlUtilDbTypeIntegerToStringConstant of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
86085>>>>>>>        Function_Return sRetval
86086>>>>>>>    End_Function
86087>>>>>>>
86087>>>>>>>    // Pass a driver name as a string and the function will return
86087>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
86087>>>>>>>    // quite work and always returns "MS SQL Server"
86087>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
86089>>>>>>>        Integer iRetval
86089>>>>>>>        Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverID to iRetval
86090>>>>>>>        Function_Return iRetval
86091>>>>>>>    End_Function
86092>>>>>>>
86092>>>>>>>    // Returns a temp table name that consists of the RootName, an underscore and as much of a GUID
86092>>>>>>>    // that "fits" in the max allowed length for table names.
86092>>>>>>>    // Max number of characters allowed for table names;
86092>>>>>>>    // IBM DB2      = 128
86092>>>>>>>    // MS-SQL       = 128
86092>>>>>>>    // Oracle       = 128 (Version 12.2 and later. 30 characters for earlier versions)
86092>>>>>>>    // MySQL        = 64
86092>>>>>>>    // PostgreSQL   = 64
86092>>>>>>>    Function SqlUtilGUIDTempTableName String sRootName Returns String
86094>>>>>>>        String sGUIDName
86094>>>>>>>        Integer iDbType iLength
86094>>>>>>>
86094>>>>>>>        Get piDbType to iDbType
86095>>>>>>>        Move (RandomHexUUID()) to sGUIDName
86096>>>>>>>        Move (sRootName + "_" + sGUIDName) to sGUIDName
86097>>>>>>>        Move (Length(sGUIDName)) to iLength
86098>>>>>>>
86098>>>>>>>        Case Begin
86098>>>>>>>            Case (iDbType = EN_DbTypeDB2)
86100>>>>>>>            If (iLength > 128) Begin
86102>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
86103>>>>>>>            End
86103>>>>>>>>
86103>>>>>>>            Case Break
86104>>>>>>>
86104>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
86107>>>>>>>            If (iLength > 128) Begin
86109>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
86110>>>>>>>            End
86110>>>>>>>>
86110>>>>>>>            Case Break
86111>>>>>>>
86111>>>>>>>            Case (iDbType = EN_DbTypeOracle) // Note: We assume an Oracle version of 12.2 or later.
86114>>>>>>>            If (iLength > 128) Begin
86116>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
86117>>>>>>>            End
86117>>>>>>>>
86117>>>>>>>            Case Break
86118>>>>>>>
86118>>>>>>>            Case (iDbType = EN_DbTypeMySQL)
86121>>>>>>>            If (iLength > 64) Begin
86123>>>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
86124>>>>>>>            End
86124>>>>>>>>
86124>>>>>>>            Case Break
86125>>>>>>>
86125>>>>>>>            Case (iDbType = EN_DbTypePostgre)
86128>>>>>>>            If (iLength > 64) Begin
86130>>>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
86131>>>>>>>            End
86131>>>>>>>>
86131>>>>>>>        Case End
86131>>>>>>>
86131>>>>>>>        Function_Return sGUIDName
86132>>>>>>>    End_Function
86133>>>>>>>
86133>>>>>>>    // Reads a resource that has been embedded by the compiler and writes it to disk.
86133>>>>>>>    // Pass the memory resource file reference and the filename to be created,
86133>>>>>>>    // including full path.
86133>>>>>>>    Procedure SqlUtilCreateFileFromMemory String sMemFileName String sFileName
86135>>>>>>>        String sText
86135>>>>>>>        Integer iCh iSize iArgSize
86135>>>>>>>
86135>>>>>>>        Move ("Resource:" + sMemFileName) to sMemFileName
86136>>>>>>>        Get Seq_Open_Input_Channel sMemFileName to iCh
86137>>>>>>>            Get_Channel_Size iCh to iSize
86138>>>>>>>            Get_Argument_Size to iArgSize
86139>>>>>>>            If (iSize > iArgSize) Begin
86141>>>>>>>                Set_Argument_Size iSize
86142>>>>>>>>
86142>>>>>>>            End
86142>>>>>>>>
86142>>>>>>>            Read_Block channel iCh sText iSize
86144>>>>>>>        Send Seq_Close_Channel iCh
86145>>>>>>>
86145>>>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
86146>>>>>>>            Write channel iCh sText
86148>>>>>>>        Send Seq_Close_Channel iCh
86149>>>>>>>
86149>>>>>>>        If (iSize <> iArgSize) Begin
86151>>>>>>>            Set_Argument_Size iArgSize
86152>>>>>>>>
86152>>>>>>>        End
86152>>>>>>>>
86152>>>>>>>
86152>>>>>>>        // Wait for file to be written to disk.
86152>>>>>>>        Sleep 2
86153>>>>>>>    End_Procedure
86154>>>>>>>
86154>>>>>>>    Function SqlUtilDefaultNullValue String sDriverID Integer iDbType Integer iDataType Returns String
86156>>>>>>>        String sNotNull sRetval sDefaultValue
86156>>>>>>>        Boolean bOK
86156>>>>>>>
86156>>>>>>>        Get IsSQLDriver sDriverID to bOK
86157>>>>>>>        If (bOK = False) Begin
86159>>>>>>>            Function_Return ""
86160>>>>>>>        End
86160>>>>>>>>
86160>>>>>>>
86160>>>>>>>        Get UtilDataTypeDefaultValue sDriverID iDbType iDataType to sDefaultValue
86161>>>>>>>        Get _SqlFindKeyWord CI_SQLNotNull to sNotNull
86162>>>>>>>
86162>>>>>>>        Case Begin
86162>>>>>>>            Case (iDbType = EN_dbTypeMSSQL)
86164>>>>>>>                Move ("DEFAULT" * String(sDefaultValue) * String(sNotNull)) to sRetval
86165>>>>>>>                Case Break
86166>>>>>>>            Case (iDbType = EN_dbTypeMySQL)
86169>>>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
86170>>>>>>>                Case Break
86171>>>>>>>            Case (iDbType = EN_dbTypePostgre)
86174>>>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
86175>>>>>>>                Case Break
86176>>>>>>>            Case (iDbType = EN_dbTypeDB2)
86179>>>>>>>                Move (String(sNotNull))                                     to sRetval
86180>>>>>>>                Case Break
86181>>>>>>>
86181>>>>>>>            // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
86181>>>>>>>            // ToDo: We need to look deeper into how Oracle handles NULL
86181>>>>>>>            Case (iDbType = EN_dbTypeOracle)
86184>>>>>>>                Move  ""                                                    to sRetval
86185>>>>>>>                Case Break
86186>>>>>>>
86186>>>>>>>            Case Else
86186>>>>>>>                Move  ""                                                    to sRetval
86187>>>>>>>        Case End
86187>>>>>>>
86187>>>>>>>        Function_Return sRetval
86188>>>>>>>    End_Function
86189>>>>>>>
86189>>>>>>>    Function SqlUtilUpdateIntFile Integer hTable Returns Boolean
86191>>>>>>>        String sOrgFormat sNewFormat sRootName sDatabaseName sPhysicalFileName sDriverID sDataPath
86191>>>>>>>        Boolean bOpened bOK bMertech
86191>>>>>>>
86191>>>>>>>        // For some reason this .int file update screws up of CodeMast & CodeType .int files
86191>>>>>>>        // which makes the program unable to run because they can't be opened.
86191>>>>>>>        // ToDo: This needs further investigation but for now we just skip CodeMast & CodeType .int files update...
86191>>>>>>>        // Also note that there is another helper function "UtilTableCreateCodeMastCodeTypeIntFiles" to create
86191>>>>>>>        // proper .int files for the two tables.
86191>>>>>>>        If (Uppercase(sDatabaseName) = "CODETYPE" or Uppercase(sDatabaseName) = "CODEMAST") Begin
86193>>>>>>>            Function_Return True
86194>>>>>>>        End
86194>>>>>>>>
86194>>>>>>>
86194>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86197>>>>>>>        Get _TableNameOnly sRootName to sDatabaseName
86198>>>>>>>        Move CS_OEM_Txt  to sOrgFormat
86199>>>>>>>        Move CS_ANSI_Txt to sNewFormat
86200>>>>>>>        Get AutoConnectionIDLogin to bOK
86201>>>>>>>
86201>>>>>>>        // It seems this can be called to quickly; causing a 13001 error "Cannot open cache file for write"
86201>>>>>>>        Sleep 2
86202>>>>>>>        Get OpenTableExclusive hTable to bOpened
86203>>>>>>>        If (bOpened = False) Begin
86205>>>>>>>            Function_Return False
86206>>>>>>>        End
86206>>>>>>>>
86206>>>>>>>
86206>>>>>>>        Get psDriverID to sDriverID
86207>>>>>>>        Get IsMertechDriver sDriverID to bMertech
86208>>>>>>>        If (bMertech = True) Begin
86210>>>>>>>            Get psDataPathFirstPart to sDataPath
86211>>>>>>>            Get vFolderExists sDataPath to bOK
86212>>>>>>>            If (bOK = False) Begin
86214>>>>>>>                Error DFERR_PROGRAM "Function SqlUtilUpdateIntFile; psDataPath not found!"
86215>>>>>>>>
86215>>>>>>>                Function_Return False
86216>>>>>>>            End
86216>>>>>>>>
86216>>>>>>>            Get vFolderFormat sDataPath to sDataPath
86217>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86220>>>>>>>            Get _TableNameOnly sRootName to sDatabaseName
86221>>>>>>>            Move sDatabaseName to sPhysicalFileName
86222>>>>>>>            Move (sPhysicalFileName + ".int") to sPhysicalFileName
86223>>>>>>>            Get _MertechSqlUtilCreateIntFile hTable sDataPath sPhysicalFileName to bOK
86224>>>>>>>            Function_Return (bOK = True)
86225>>>>>>>        End
86225>>>>>>>>
86225>>>>>>>
86225>>>>>>>        Move False to Err
86226>>>>>>>        Get_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
86229>>>>>>>        Move (Uppercase(sOrgFormat)) to sOrgFormat
86230>>>>>>>        // Lets swap the OEM/ANSI format, just to make a change in Structure_Start below (and back),
86230>>>>>>>        // to "touch" the table so the driver feels there has been a change and updates the .int file.
86230>>>>>>>        Move (If(sOrgFormat = CS_OEM_Txt, CS_ANSI_Txt, CS_OEM_Txt)) to sNewFormat
86231>>>>>>>
86231>>>>>>>        If (hTable > 0) Begin
86233>>>>>>>            Structure_Start hTable
86234>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
86237>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
86240>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86242>>>>>>>        End
86242>>>>>>>>
86242>>>>>>>        Else Begin
86243>>>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
86246>>>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
86249>>>>>>>        End
86249>>>>>>>>
86249>>>>>>>        Function_Return (Err = False)
86250>>>>>>>    End_Function
86251>>>>>>>
86251>>>>>>>    Function SqlProcedureArrayMertech String sStmt String sArgument Returns String[]
86253>>>>>>>        String[] sReturnArray
86254>>>>>>>        String sValue sUserID sPassword
86254>>>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
86254>>>>>>>        Integer iFetchResult iRetval
86254>>>>>>>        tSQLConnection SQLConnection
86254>>>>>>>        tSQLConnection SQLConnection
86254>>>>>>>
86254>>>>>>>        Get _MertechSQLManagerHandle to hoSQLHandler
86255>>>>>>>        If (hoSQLHandler <> 0) Begin
86257>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86258>>>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
86259>>>>>>>            If (hoSQLConnect <> 0) Begin
86261>>>>>>>                Get SQLOpen of hoSQLConnect to hStmt
86262>>>>>>>                If (hStmt <> 0) Begin
86264>>>>>>>                    Send SQLSetProcedureName of hStmt sStmt
86265>>>>>>>                    If (sArgument <> "") Begin
86267>>>>>>>                        Send SqlSetArgument  of hStmt 1 sArgument
86268>>>>>>>                    End
86268>>>>>>>>
86268>>>>>>>                    Send SQLCall of hStmt
86269>>>>>>>
86269>>>>>>>                    Get SqlReturnValue       of hStmt to iRetval
86270>>>>>>>                    If (iRetval = 0) Begin
86272>>>>>>>                        Repeat
86272>>>>>>>>
86272>>>>>>>                            Get SQLFetch of hStmt to iFetchResult
86273>>>>>>>                            If (iFetchResult <> 0) Begin
86275>>>>>>>                                Get SQLColumnValue of hStmt 1 to sValue
86276>>>>>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
86277>>>>>>>                            End
86277>>>>>>>>
86277>>>>>>>                        Until (iFetchResult = 0)
86279>>>>>>>                        Send SQLClose of hStmt
86280>>>>>>>                    End
86280>>>>>>>>
86280>>>>>>>                End
86280>>>>>>>>
86280>>>>>>>                Send SQLDisconnect of hoSQLConnect
86281>>>>>>>            End
86281>>>>>>>>
86281>>>>>>>        End
86281>>>>>>>>
86281>>>>>>>
86281>>>>>>>        Function_Return sReturnArray
86282>>>>>>>    End_Function
86283>>>>>>>
86283>>>>>>>    // * Dummy function for the Studio's Code Explorer *
86283>>>>>>>    Function SQL_ENUMERATION_FUNCTIONS Returns Boolean
86285>>>>>>>        Function_Return False
86286>>>>>>>    End_Function
86287>>>>>>>
86287>>>>>>>    // Enumerate SQL Servers.
86287>>>>>>>    // Pass a driver id. Returns a string array.
86287>>>>>>>    // The iDataSourceType (iDatSrcType) parameter is optional and is for the ODBC driver only.
86287>>>>>>>    // Note: Returns servers for MSSQLDRV; else data-sources on the machine.
86287>>>>>>>    Function SqlUtilEnumerateServers String sDriverID Integer iDatSrcType Returns String[]
86289>>>>>>>        String[] sReturnArray
86290>>>>>>>        Handle hoSQLHandler
86290>>>>>>>        String sServer
86290>>>>>>>        Integer iCount iNumItems iDataSourceType
86290>>>>>>>
86290>>>>>>>        If (num_arguments > 1) Begin
86292>>>>>>>            Move iDatSrcType to iDataSourceType
86293>>>>>>>        End
86293>>>>>>>>
86293>>>>>>>
86293>>>>>>>        Case Begin
86293>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
86295>>>>>>>                Get phoMSSQLHandler to hoSQLHandler
86296>>>>>>>                // Not sure why, but this doesn't seem to work with the updated DAW MSSQLDRV driver.
86296>>>>>>>//                #IFNDEF get_ComparetConnectionById
86296>>>>>>>//                    Get EnumerateServers of hoSQLHandler to iNumItems
86296>>>>>>>//                #ELSE
86296>>>>>>>//                    Get EnumerateServersLocal of hoSQLHandler to iNumItems
86296>>>>>>>//                    If (iNumItems = 0) Begin
86296>>>>>>>                        Get EnumerateServers of hoSQLHandler to iNumItems
86297>>>>>>>//                    End
86297>>>>>>>//                #ENDIF
86297>>>>>>>                For iCount from 0 to (iNumItems - 1)
86303>>>>>>>>
86303>>>>>>>                    Get String_Value of hoSQLHandler item iCount to sServer
86304>>>>>>>                    Move (Trim(sServer)) to sReturnArray[iCount]
86305>>>>>>>                Loop
86306>>>>>>>>
86306>>>>>>>                Case Break
86307>>>>>>>
86307>>>>>>>            Case (sDriverID = DB2_DRV_ID)
86310>>>>>>>                Get phoDB2SQLHandler to hoSQLHandler
86311>>>>>>>                Send SeedDataSources of hoSQLHandler
86312>>>>>>>                Move 0 to iCount
86313>>>>>>>                Repeat
86313>>>>>>>>
86313>>>>>>>                    Get DataSources of hoSQLHandler to sServer
86314>>>>>>>                    If (sServer <> "") Begin
86316>>>>>>>                        Move (Replace(",", sServer, "")) to sServer
86317>>>>>>>                        Move sServer to sReturnArray[iCount]
86318>>>>>>>                    End
86318>>>>>>>>
86318>>>>>>>                    Increment iCount
86319>>>>>>>                Until (sServer = "")
86321>>>>>>>                Case Break
86322>>>>>>>
86322>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
86325>>>>>>>                Get phoODBCSQLHandler to hoSQLHandler
86326>>>>>>>                Set DataSourceType of hoSQLHandler to iDataSourceType
86327>>>>>>>                Move 0 to iCount
86328>>>>>>>                Repeat
86328>>>>>>>>
86328>>>>>>>                    Get DataSources of hoSQLHandler to sServer
86329>>>>>>>                    If (sServer <> "") Begin
86331>>>>>>>                        Move (Replace(",", sServer, ", ")) to sServer
86332>>>>>>>                        Move sServer to sReturnArray[iCount]
86333>>>>>>>                    End
86333>>>>>>>>
86333>>>>>>>                    Increment iCount
86334>>>>>>>                Until (sServer = "")
86336>>>>>>>                Case Break
86337>>>>>>>
86337>>>>>>>            Case (sDriverID = SQLFLEX)
86340>>>>>>>                Get _MertechEnumerateSQLFlexServers to sReturnArray
86341>>>>>>>                Case Break
86342>>>>>>>
86342>>>>>>>            Case (sDriverID = ORAFLEX)
86345>>>>>>>                Get _MertechEnumerateORAFLEXServers to sReturnArray
86346>>>>>>>                Case Break
86347>>>>>>>
86347>>>>>>>            // There appearantly is no way to enumerate servers for this backend.
86347>>>>>>>            Case (sDriverID = MDSPgSQL)
86350>>>>>>>                Move "localhost" to sReturnArray[0]
86351>>>>>>>                Case Break
86352>>>>>>>
86352>>>>>>>            // There appearantly is no way to enumerate servers for this backend.
86352>>>>>>>            Case (sDriverID = MDSMySQL)
86355>>>>>>>                Move "localhost" to sReturnArray[0]
86356>>>>>>>                Case Break
86357>>>>>>>
86357>>>>>>>            Case Else
86357>>>>>>>                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateServers function"
86358>>>>>>>>
86358>>>>>>>        Case End
86358>>>>>>>
86358>>>>>>>        Function_Return sReturnArray
86359>>>>>>>    End_Function
86360>>>>>>>
86360>>>>>>>    // Returns all databases as a string array for the passed driver id.
86360>>>>>>>    Function SqlUtilEnumerateDatabases String sDriverID Returns String[]
86362>>>>>>>        String[] sReturnArray
86363>>>>>>>        Boolean bOK
86363>>>>>>>
86363>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
86364>>>>>>>        If (bOK = False) Begin
86366>>>>>>>            Function_Return sReturnArray
86367>>>>>>>        End
86367>>>>>>>>
86367>>>>>>>
86367>>>>>>>        Case Begin
86367>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
86369>>>>>>>                Get _SqlDatabasesArrayMSSQL to sReturnArray
86370>>>>>>>                Case Break
86371>>>>>>>            Case (sDriverID = DB2_DRV_ID)
86374>>>>>>>                Get _SqlDatabasesArrayDB2 to sReturnArray
86375>>>>>>>                Case Break
86376>>>>>>>
86376>>>>>>>            // Enumeration of ODBC databases should be irrelevant as the database
86376>>>>>>>            // should have been specified when the ODBC source was setup with the ODBC manager.
86376>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
86379>>>>>>>                Case Break
86380>>>>>>>
86380>>>>>>>            Case (sDriverID = SQLFLEX)
86383>>>>>>>                Get SqlProcedureArrayMertech "sp_databases" "" to sReturnArray
86384>>>>>>>                Case Break
86385>>>>>>>
86385>>>>>>>            Case (sDriverID = MDSPgSQL)
86388>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT datname FROM pg_database" to sReturnArray
86389>>>>>>>                Case Break
86390>>>>>>>
86390>>>>>>>            Case (sDriverID = MDSMySQL)
86393>>>>>>>                Get SqlEnumerateEsqlMertech "show databases" to sReturnArray
86394>>>>>>>                Case Break
86395>>>>>>>
86395>>>>>>>            Case (sDriverID = ORAFLEX)
86398>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT NAME FROM v$database" to sReturnArray
86399>>>>>>>                Case Break
86400>>>>>>>
86400>>>>>>>            Case Else
86400>>>>>>>                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateDatabases function"
86401>>>>>>>>
86401>>>>>>>        Case End
86401>>>>>>>
86401>>>>>>>        Function_Return sReturnArray
86402>>>>>>>    End_Function
86403>>>>>>>
86403>>>>>>>    // Returns all table spaces as a string array for the passed driver id.
86403>>>>>>>    Function SqlUtilEnumerateTableSpaces String sDriverID Returns String[]
86405>>>>>>>        String[] sReturnArray
86406>>>>>>>        Boolean bOK
86406>>>>>>>
86406>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
86407>>>>>>>        If (bOK = False) Begin
86409>>>>>>>            Function_Return sReturnArray
86410>>>>>>>        End
86410>>>>>>>>
86410>>>>>>>
86410>>>>>>>        Case Begin
86410>>>>>>>            Case (sDriverID = DB2_DRV_ID)
86412>>>>>>>                Get SqlEnumerateEsqlDAW "select tablespace_name from dba_tablespaces" 1 to sReturnArray
86413>>>>>>>                Case Break
86414>>>>>>>
86414>>>>>>>            Case (sDriverID = MDSPgSQL)
86417>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT spcname FROM pg_tablespace" 1 to sReturnArray
86418>>>>>>>                Case Break
86419>>>>>>>
86419>>>>>>>            Case (sDriverID = ORAFLEX)
86422>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT TABLESPACE_NAME FROM USER_TABLESPACES" 1 to sReturnArray
86423>>>>>>>                Case Break
86424>>>>>>>
86424>>>>>>>            Case Else
86424>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateTableSpaces function."
86425>>>>>>>>
86425>>>>>>>                Case Break
86426>>>>>>>        Case End
86426>>>>>>>
86426>>>>>>>        Function_Return sReturnArray
86427>>>>>>>    End_Function
86428>>>>>>>
86428>>>>>>>    // Returns all schemas as a string array for the passed driver id.
86428>>>>>>>    Function SqlUtilEnumerateSchemas String sDriverID Returns String[]
86430>>>>>>>        String[] sReturnArray
86431>>>>>>>        Boolean bOK
86431>>>>>>>
86431>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
86432>>>>>>>        If (bOK = False) Begin
86434>>>>>>>            Function_Return sReturnArray
86435>>>>>>>        End
86435>>>>>>>>
86435>>>>>>>
86435>>>>>>>        Case Begin
86435>>>>>>>            Case (sDriverID = DB2_DRV_ID)
86437>>>>>>>                Get SqlEnumerateEsqlDAW "select schemaname from syscat.schemata" 1 to sReturnArray
86438>>>>>>>                Case Break
86439>>>>>>>
86439>>>>>>>            Case (sDriverID = MDSPgSQL)
86442>>>>>>>                Get SqlEnumerateEsqlMertech "select schema_name from information_schema.schemata" 1 to sReturnArray
86443>>>>>>>                Case Break
86444>>>>>>>
86444>>>>>>>            Case (sDriverID = ORAFLEX)
86447>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT username from dba_users WHERE default_tablespace not in ('SYSTEM','SYSAUX')" 1 to sReturnArray
86448>>>>>>>                Case Break
86449>>>>>>>
86449>>>>>>>            Case Else
86449>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateSchemas function."
86450>>>>>>>>
86450>>>>>>>                Case Break
86451>>>>>>>        Case End
86451>>>>>>>
86451>>>>>>>        Function_Return sReturnArray
86452>>>>>>>    End_Function
86453>>>>>>>
86453>>>>>>>    // Returns a string array with all tables for the current database.
86453>>>>>>>    Function SqlUtilEnumerateTables String sDriverID Returns String[]
86455>>>>>>>        String[] sReturnArray sArray
86457>>>>>>>        String sDatabase sConnectionString sSelect sSchema
86457>>>>>>>        Integer iSize iCount
86457>>>>>>>        Boolean bOK
86457>>>>>>>
86457>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
86459>>>>>>>            Function_Return sArray
86460>>>>>>>        End
86460>>>>>>>>
86460>>>>>>>
86460>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
86461>>>>>>>        If (bOK = False) Begin
86463>>>>>>>            Function_Return sReturnArray
86464>>>>>>>        End
86464>>>>>>>>
86464>>>>>>>
86464>>>>>>>        Get psConnectionString to sConnectionString
86465>>>>>>>        Get psDatabase to sDatabase
86466>>>>>>>        Get psSchema   to sSchema
86467>>>>>>>
86467>>>>>>>        Case Begin
86467>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
86469>>>>>>>                Get _SqlTableArrayDAW to sReturnArray
86470>>>>>>>                Case Break
86471>>>>>>>
86471>>>>>>>            Case (sDriverID = DB2_DRV_ID)
86474>>>>>>>                Get _SqlTableArrayDAW to sReturnArray
86475>>>>>>>                Case Break
86476>>>>>>>
86476>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
86479>>>>>>>                Get _SqlTableArrayDAW to sReturnArray
86480>>>>>>>                Case Break
86481>>>>>>>
86481>>>>>>>            Case (sDriverID = SQLFLEX)
86484>>>>>>>                Move ("SELECT TABLE_NAME FROM" * sDatabase + ".INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE != 'VIEW'") to sSelect
86485>>>>>>>                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
86486>>>>>>>                Case Break
86487>>>>>>>
86487>>>>>>>            Case (sDriverID = MDSMySQL)
86490>>>>>>>                Move ("SELECT TABLE_NAME from INFORMATION_SCHEMA.TABLES where TABLE_SCHEMA = '" + sDatabase + "' and TABLE_TYPE = 'BASE TABLE' order by TABLE_NAME") to sSelect
86491>>>>>>>                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
86492>>>>>>>                Case Break
86493>>>>>>>
86493>>>>>>>            Case (sDriverID = MDSPgSQL)
86496>>>>>>>                Move "select tablename, schemaname from pg_catalog.pg_tables order by tablename"  to sSelect
86497>>>>>>>                Get SqlEnumerateEsqlMertech sSelect "" to sReturnArray
86498>>>>>>>                Case Break
86499>>>>>>>
86499>>>>>>>            Case (sDriverID = ORAFLEX)
86502>>>>>>>                Move "SELECT table_name from user_tables" to sSelect
86503>>>>>>>                Get SqlEnumerateEsqlMertech sSelect to sArray
86504>>>>>>>                Move (SizeOfArray(sArray)) to iSize
86505>>>>>>>                Decrement iSize
86506>>>>>>>                For iCount from 0 to iSize
86512>>>>>>>>
86512>>>>>>>                    If (not(sArray[iCount] contains "$")) Begin
86514>>>>>>>                        Move sArray[iCount] to sReturnArray[SizeOfArray(sReturnArray)]
86515>>>>>>>                    End
86515>>>>>>>>
86515>>>>>>>                Loop
86516>>>>>>>>
86516>>>>>>>                Case Break
86517>>>>>>>
86517>>>>>>>            Case Else
86517>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateTables function."
86518>>>>>>>>
86518>>>>>>>                Case Break
86519>>>>>>>        Case End
86519>>>>>>>
86519>>>>>>>        Function_Return sReturnArray
86520>>>>>>>    End_Function
86521>>>>>>>
86521>>>>>>>    // Returns a string array with all table columns/fields for the passed table handle and driver id.
86521>>>>>>>    Function SqlUtilEnumerateColumns String sDriverID String sTableName Returns String[]
86523>>>>>>>        String[] sReturnArray
86524>>>>>>>        String sConnectionString sSelect sSchema
86524>>>>>>>        Boolean bOK
86524>>>>>>>
86524>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
86525>>>>>>>        If (bOK = False) Begin
86527>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
86528>>>>>>>>
86528>>>>>>>            Function_Return sReturnArray
86529>>>>>>>        End
86529>>>>>>>>
86529>>>>>>>
86529>>>>>>>        Get psConnectionString to sConnectionString
86530>>>>>>>        Get psSchema to sSchema
86531>>>>>>>
86531>>>>>>>        Case Begin
86531>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
86533>>>>>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
86534>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
86535>>>>>>>                Case Break
86536>>>>>>>
86536>>>>>>>            Case (sDriverID = DB2_DRV_ID)
86539>>>>>>>                Move ("SELECT colname from syscat.columns WHERE tabschema = '" + sSchema + "'" * "AND tabname = '" + sTableName + "'") to sSelect
86540>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
86541>>>>>>>                Case Break
86542>>>>>>>
86542>>>>>>>            Case (sDriverID = SQLFLEX)
86545>>>>>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
86546>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
86547>>>>>>>                Case Break
86548>>>>>>>
86548>>>>>>>            Case (sDriverID = MDSMySQL)
86551>>>>>>>                Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
86552>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
86553>>>>>>>                Case Break
86554>>>>>>>
86554>>>>>>>            Case (sDriverID = MDSPgSQL)
86557>>>>>>>                Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
86558>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
86559>>>>>>>                Case Break
86560>>>>>>>
86560>>>>>>>            Case (sDriverID = ORAFLEX)
86563>>>>>>>                Move ("SELECT column_name from user_tab_cols WHERE table_name = '" + sTableName + "'") to sSelect
86564>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
86565>>>>>>>                Case Break
86566>>>>>>>
86566>>>>>>>            Case Else
86566>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateColumns function."
86567>>>>>>>>
86567>>>>>>>                Case Break
86568>>>>>>>        Case End
86568>>>>>>>
86568>>>>>>>        Function_Return sReturnArray
86569>>>>>>>    End_Function
86570>>>>>>>
86570>>>>>>>
86570>>>>>>>    // Returns a string array with all table indexes for the passed table handle and driver id.
86570>>>>>>>    Function SqlUtilEnumerateIndexes String sTableName String sDriverID Returns String[]
86572>>>>>>>        String[] sReturnArray sReturnArray2
86574>>>>>>>        String sConnectionString sSelect sSchema
86574>>>>>>>        Boolean bOK
86574>>>>>>>        Integer iCount iSize
86574>>>>>>>
86574>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
86575>>>>>>>        If (bOK = False) Begin
86577>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
86578>>>>>>>>
86578>>>>>>>            Function_Return sReturnArray
86579>>>>>>>        End
86579>>>>>>>>
86579>>>>>>>
86579>>>>>>>        Get psConnectionString to sConnectionString
86580>>>>>>>        Get psSchema to sSchema
86581>>>>>>>
86581>>>>>>>        Case Begin
86581>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
86583>>>>>>>                Move ("select * from sys.indexes where object_id = (select object_id from sys.objects where name = '" + sTableName + "')") to sSelect
86584>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
86585>>>>>>>                Case Break
86586>>>>>>>
86586>>>>>>>            Case (sDriverID = DB2_DRV_ID)
86589>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
86590>>>>>>>>
86590>>>>>>>//                Move () to sSelect
86590>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
86590>>>>>>>                Case Break
86591>>>>>>>
86591>>>>>>>            Case (sDriverID = SQLFLEX)
86594>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
86595>>>>>>>>
86595>>>>>>>//                Move () to sSelect
86595>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
86595>>>>>>>                Case Break
86596>>>>>>>
86596>>>>>>>            Case (sDriverID = MDSMySQL)
86599>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
86600>>>>>>>>
86600>>>>>>>//                Move () to sSelect
86600>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
86600>>>>>>>                Case Break
86601>>>>>>>
86601>>>>>>>            Case (sDriverID = MDSPgSQL)
86604>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
86605>>>>>>>>
86605>>>>>>>//                Move () to sSelect
86605>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
86605>>>>>>>                Case Break
86606>>>>>>>
86606>>>>>>>            Case (sDriverID = ORAFLEX)
86609>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
86610>>>>>>>>
86610>>>>>>>//                Move () to sSelect
86610>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
86610>>>>>>>                Case Break
86611>>>>>>>
86611>>>>>>>            Case Else
86611>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateIndexes function."
86612>>>>>>>>
86612>>>>>>>                Case Break
86613>>>>>>>        Case End
86613>>>>>>>
86613>>>>>>>        Move (SizeOfArray(sReturnArray)) to iSize
86614>>>>>>>        Decrement iSize
86615>>>>>>>        For iCount from 0 to iSize
86621>>>>>>>>
86621>>>>>>>            If (Trim(sReturnArray[iCount]) <> "") Begin
86623>>>>>>>                Move sReturnArray[iCount] to sReturnArray2[SizeOfArray(sReturnArray2)]
86624>>>>>>>            End
86624>>>>>>>>
86624>>>>>>>        Loop
86625>>>>>>>>
86625>>>>>>>
86625>>>>>>>        Function_Return sReturnArray2
86626>>>>>>>    End_Function
86627>>>>>>>
86627>>>>>>>    // Returns a string array with all table names the passed table handle has relation ships with.
86627>>>>>>>    // The format of the array is "TableName.FieldName"
86627>>>>>>>    Function SqlUtilEnumerateRelations String sTableName String sDriverID Returns tSQLRelation[]
86629>>>>>>>        String[] sFileNameArray sFieldNameArray
86631>>>>>>>        tSQLRelation[] sRelationsArray
86631>>>>>>>        tSQLRelation[] sRelationsArray
86632>>>>>>>        String sConnectionString sSelect sSchema sFileName sFieldName
86632>>>>>>>        Boolean bOK
86632>>>>>>>        Integer iCount iSize iLength
86632>>>>>>>
86632>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
86633>>>>>>>        If (bOK = False) Begin
86635>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
86636>>>>>>>>
86636>>>>>>>            Function_Return sRelationsArray
86637>>>>>>>        End
86637>>>>>>>>
86637>>>>>>>
86637>>>>>>>        Get psConnectionString to sConnectionString
86638>>>>>>>        Get psSchema to sSchema
86639>>>>>>>
86639>>>>>>>        Case Begin
86639>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
86641>>>>>>>                Move ("SELECT object_name(parent_object_id), object_name(referenced_object_id), name from sys.foreign_keys WHERE parent_object_id = object_id( '" + sTableName + "')") to sSelect
86642>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sFileNameArray
86643>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
86644>>>>>>>                Case Break
86645>>>>>>>
86645>>>>>>>            Case (sDriverID = DB2_DRV_ID)
86648>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
86649>>>>>>>>
86649>>>>>>>//                Move () to sSelect
86649>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
86649>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
86649>>>>>>>                Case Break
86650>>>>>>>
86650>>>>>>>            Case (sDriverID = SQLFLEX)
86653>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
86654>>>>>>>>
86654>>>>>>>//                Move () to sSelect
86654>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
86654>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
86654>>>>>>>                Case Break
86655>>>>>>>
86655>>>>>>>            Case (sDriverID = MDSMySQL)
86658>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
86659>>>>>>>>
86659>>>>>>>//                Move () to sSelect
86659>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
86659>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
86659>>>>>>>                Case Break
86660>>>>>>>
86660>>>>>>>            Case (sDriverID = MDSPgSQL)
86663>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
86664>>>>>>>>
86664>>>>>>>//                Move () to sSelect
86664>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
86664>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
86664>>>>>>>                Case Break
86665>>>>>>>
86665>>>>>>>            Case (sDriverID = ORAFLEX)
86668>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
86669>>>>>>>>
86669>>>>>>>//                Move () to sSelect
86669>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
86669>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
86669>>>>>>>                Case Break
86670>>>>>>>
86670>>>>>>>            Case Else
86670>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to the SqlUtilEnumerateRelations function."
86671>>>>>>>>
86671>>>>>>>                Case Break
86672>>>>>>>        Case End
86672>>>>>>>
86672>>>>>>>        Move (Length(sTableName)) to iLength
86673>>>>>>>        Move (iLength + 4)        to iLength // The related to field key has the format "FK_TableName + FieldName"
86674>>>>>>>        Move (SizeOfArray(sFileNameArray)) to iSize
86675>>>>>>>        Decrement iSize
86676>>>>>>>        For iCount from 0 to iSize
86682>>>>>>>>
86682>>>>>>>            If (Trim(sFileNameArray[iCount]) <> "") Begin
86684>>>>>>>                Move sFileNameArray[iCount]         to sFileName
86685>>>>>>>                Move sFieldNameArray[iCount]        to sFieldName
86686>>>>>>>                Move (Mid(sFieldName, 99, iLength)) to sFieldName
86687>>>>>>>                Move sFileName  to sRelationsArray[iCount].sFileName
86688>>>>>>>                Move sFieldName to sRelationsArray[iCount].sFieldName
86689>>>>>>>            End
86689>>>>>>>>
86689>>>>>>>        Loop
86690>>>>>>>>
86690>>>>>>>
86690>>>>>>>        Function_Return sRelationsArray
86691>>>>>>>    End_Function
86692>>>>>>>
86692>>>>>>>    Function SqlUtilEnumerateLoggedInUsers String sDriverID String sDatabase Returns tSQLLoggedInUser[]
86694>>>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
86694>>>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
86695>>>>>>>        String[] sUsers sPrograms
86697>>>>>>>        String sSelect
86697>>>>>>>        Integer iSize iCount
86697>>>>>>>
86697>>>>>>>        Case Begin
86697>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
86699>>>>>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
86700>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sUsers
86701>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sPrograms
86702>>>>>>>                Case Break
86703>>>>>>>            Case (sDriverID = SQLFLEX)
86706>>>>>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
86707>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sUsers
86708>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 2 to sPrograms
86709>>>>>>>                Case Break
86710>>>>>>>            Case Else
86710>>>>>>>                Error DFERR_PROGRAM ("Not implemented yet for this driver (" + sDriverID + ")")
86711>>>>>>>>
86711>>>>>>>        Case End
86711>>>>>>>
86711>>>>>>>        Move (SizeOfArray(sUsers)) to iSize
86712>>>>>>>        Decrement iSize
86713>>>>>>>        For iCount from 0 to iSize
86719>>>>>>>>
86719>>>>>>>            Move sUsers[iCount]    to SQLLoggedInUser[iCount].sUser
86720>>>>>>>            Move sPrograms[iCount] to SQLLoggedInUser[iCount].sProgram
86721>>>>>>>        Loop
86722>>>>>>>>
86722>>>>>>>
86722>>>>>>>        Function_Return SQLLoggedInUser
86723>>>>>>>    End_Function
86724>>>>>>>
86724>>>>>>>    // Returns an array with all ".int" files for the passed sDataPath, _except_ for the driver .int files;
86724>>>>>>>    // "MSSQLDRV.int", "DB2_DRV.int" & "ODBC_DRV.int".
86724>>>>>>>    Function SqlUtilEnumerateIntFiles String sDataPath Returns String[]
86726>>>>>>>        String[] sFilesData
86727>>>>>>>        Boolean bExists
86727>>>>>>>        Integer iCh
86727>>>>>>>        String sFileName sExt
86727>>>>>>>
86727>>>>>>>        Get vFolderExists sDataPath to bExists
86728>>>>>>>        If (bExists = True) Begin
86730>>>>>>>            Move (ToANSI(Trim(sDataPath))) to sDataPath
86731>>>>>>>            Move ("dir:" + sDataPath)      to sDataPath
86732>>>>>>>            Get Seq_New_Channel to iCh  // get free channel for input
86733>>>>>>>            Direct_Input channel iCh sDataPath
86735>>>>>>>                Repeat
86735>>>>>>>>
86735>>>>>>>                    Readln channel iCh sFileName
86737>>>>>>>                    Get ParseFileExtension sFileName to sExt
86738>>>>>>>                    If (Uppercase(sExt) = "INT") Begin
86740>>>>>>>                        If (not(Uppercase(sFileName) contains "MSSQLDRV" and Uppercase(sFileName) contains "DB2_DRV" and Uppercase(sFileName) contains "ODBC_DRV")) Begin
86742>>>>>>>                            Move sFileName to sFilesData[SizeOfArray(sFilesData)]
86743>>>>>>>                        End
86743>>>>>>>>
86743>>>>>>>                    End
86743>>>>>>>>
86743>>>>>>>                Until (SeqEof = True)
86745>>>>>>>            Close_Input channel iCh
86747>>>>>>>        End
86747>>>>>>>>
86747>>>>>>>        Function_Return sFilesData
86748>>>>>>>    End_Function
86749>>>>>>>
86749>>>>>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
86749>>>>>>>    // for DAW drivers.
86749>>>>>>>    // Returns: A string array.
86749>>>>>>>    Function SqlEnumerateEsqlDAW String sStmt Integer iColumn Returns String[]
86751>>>>>>>        String[] sReturnArray
86752>>>>>>>        String sValue sPrevious
86752>>>>>>>        Handle hoSQLHandler hoSQLConnect hstmt
86752>>>>>>>        Integer iFetchResult iRows
86752>>>>>>>        tSQLConnection SQLConnection
86752>>>>>>>        tSQLConnection SQLConnection
86752>>>>>>>
86752>>>>>>>        Get phoSQLManager to hoSQLHandler
86753>>>>>>>
86753>>>>>>>        If (hoSQLHandler <> 0) Begin
86755>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86756>>>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
86757>>>>>>>
86757>>>>>>>            If (hoSQLConnect <> 0) Begin
86759>>>>>>>                Get SQLOpen of hoSQLConnect to hstmt
86760>>>>>>>                If (hstmt <> 0) Begin
86762>>>>>>>                    Send SqlExecDirect of hstmt sStmt
86763>>>>>>>                    Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
86764>>>>>>>                    Repeat
86764>>>>>>>>
86764>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
86765>>>>>>>                        If (iFetchResult <> 0) Begin
86767>>>>>>>                            Get SQLColumnValue of hstmt iColumn to sValue
86768>>>>>>>                            If (sValue <> sPrevious) Begin
86770>>>>>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
86771>>>>>>>                            End
86771>>>>>>>>
86771>>>>>>>                            Move sValue to sPrevious
86772>>>>>>>                        End
86772>>>>>>>>
86772>>>>>>>                    Until (iFetchResult = 0)
86774>>>>>>>                    Send SQLClose of hstmt
86775>>>>>>>                End
86775>>>>>>>>
86775>>>>>>>                Send SQLDisconnect of hoSQLConnect
86776>>>>>>>            End
86776>>>>>>>>
86776>>>>>>>        End
86776>>>>>>>>
86776>>>>>>>
86776>>>>>>>        Function_Return sReturnArray
86777>>>>>>>    End_Function
86778>>>>>>>
86778>>>>>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
86778>>>>>>>    // for Mertech drivers.
86778>>>>>>>    // Returns: A string array.
86778>>>>>>>    Function SqlEnumerateEsqlMertech String sStmt Returns String[]
86780>>>>>>>        String[] sReturnArray
86781>>>>>>>        String sValue sUserID sPassword
86781>>>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
86781>>>>>>>        Integer iFetchResult iRows
86781>>>>>>>        tSQLConnection SQLConnection
86781>>>>>>>        tSQLConnection SQLConnection
86781>>>>>>>
86781>>>>>>>        Get _MertechSQLManagerHandle to hoSQLHandler
86782>>>>>>>
86782>>>>>>>        If (hoSQLHandler <> 0) Begin
86784>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86785>>>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
86786>>>>>>>
86786>>>>>>>            If (hoSQLConnect <> 0) Begin
86788>>>>>>>                Get SQLOpen of hoSQLConnect to hStmt
86789>>>>>>>                If (hStmt <> 0) Begin
86791>>>>>>>                    Send SqlExecDirect of hStmt sStmt
86792>>>>>>>                    Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_ROWCOUNT to iRows
86793>>>>>>>                    Repeat
86793>>>>>>>>
86793>>>>>>>                        Get SQLFetch of hStmt to iFetchResult
86794>>>>>>>                        If (iFetchResult <> 0) Begin
86796>>>>>>>                            Get SQLColumnValue of hStmt 1 to sValue
86797>>>>>>>                            Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
86798>>>>>>>                        End
86798>>>>>>>>
86798>>>>>>>                    Until (iFetchResult = 0)
86800>>>>>>>                    Send SQLClose of hStmt
86801>>>>>>>                End
86801>>>>>>>>
86801>>>>>>>                Send SQLDisconnect of hoSQLConnect
86802>>>>>>>            End
86802>>>>>>>>
86802>>>>>>>        End
86802>>>>>>>>
86802>>>>>>>
86802>>>>>>>        Function_Return sReturnArray
86803>>>>>>>    End_Function
86804>>>>>>>
86804>>>>>>>    // * Dummy function for the Studio's Code Explorer *
86804>>>>>>>    Function PRIVATE_SQL_SUB_FUNCTIONS Returns Boolean
86806>>>>>>>        Function_Return False
86807>>>>>>>    End_Function
86808>>>>>>>
86808>>>>>>>    // Returns the index for the passed sTableName
86808>>>>>>>    // Returns >= 0 if successful. It is e.g. needed to get the SchemaName for a table.
86808>>>>>>>    Function _SqlUtilEnumerateTableIndex String sTableName String sDriverID Returns Integer
86810>>>>>>>        Integer iIndex iSize iCount
86810>>>>>>>        String[] sTablesArray
86811>>>>>>>        String sVal sConnectionString
86811>>>>>>>
86811>>>>>>>        Move -1 to iIndex
86812>>>>>>>        Get psConnectionString to sConnectionString
86813>>>>>>>        Get SqlUtilEnumerateTables sDriverID to sTablesArray
86814>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
86815>>>>>>>        Decrement iSize
86816>>>>>>>        For iCount from 0 to iSize
86822>>>>>>>>
86822>>>>>>>            Move sTablesArray[iCount] to sVal
86823>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
86825>>>>>>>                Move iCount to iIndex // We found it!
86826>>>>>>>                Move iSize to iCount  // End the loop
86827>>>>>>>            End
86827>>>>>>>>
86827>>>>>>>        Loop
86828>>>>>>>>
86828>>>>>>>
86828>>>>>>>        Function_Return iIndex
86829>>>>>>>    End_Function
86830>>>>>>>
86830>>>>>>>    // Helper function that builds a string like;
86830>>>>>>>    // "SELECT name from [Master].[sys].[databases] where name"
86830>>>>>>>    Function _SqlSelectFromWhereName Returns String
86832>>>>>>>        String sRetval sSelect sName sFrom sMaster sSys sDatabases sWhere sDBO
86832>>>>>>>
86832>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect       to sSelect
86833>>>>>>>        Get _SqlFindKeyWord CI_SQLName         to sName
86834>>>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBO
86835>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom         to sFrom
86836>>>>>>>        Get _SqlFindKeyWord CI_SQLMaster       to sMaster
86837>>>>>>>        Get _SqlFindKeyWord CI_SQLSys          to sSys
86838>>>>>>>        Get _SqlFindKeyWord CI_SQLDatabases    to sDatabases
86839>>>>>>>        Get _SqlFindKeyWord CI_SQLWhere        to sWhere
86840>>>>>>>        Move (sSelect * sName * sFrom * "[" + sMaster + "].[" + sDBO + "].[" + sSys + sDatabases + "]" * sWhere * sName) to sRetval
86841>>>>>>>        Function_Return sRetval
86842>>>>>>>    End_Function
86843>>>>>>>
86843>>>>>>>    // Helper function to create a SQL statement like;
86843>>>>>>>    // "SELECT * FROM SYS.INDEXES WHERE NAME = MyIndexName AND OBJECT_ID = OBJECT_ID([MySchmaName].[MyTableName])"
86843>>>>>>>    // Used for checking if an index exists.
86843>>>>>>>    Function _SqlQueryIfIndexExists String sSchemaName String sTableName String sIndexName Returns String
86845>>>>>>>        String sRetval sSelect sFrom sSysIndexes sWhere sObjectID sAnd sName
86845>>>>>>>
86845>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect to sSelect
86846>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom to sFrom
86847>>>>>>>        Get _SqlFindKeyWord CI_SQLSysIndexes to sSysIndexes
86848>>>>>>>        Get _SqlFindKeyWord CI_SQLWhere to sWhere
86849>>>>>>>        Get _SqlFindKeyWord CI_SQLObjectID to sObjectID
86850>>>>>>>        Get _SqlFindKeyWord CI_SQLAND to sAnd
86851>>>>>>>        Get _SqlFindKeyWord CI_SQLName to sName
86852>>>>>>>
86852>>>>>>>        Move (sSelect * String("*") * sFrom * sSysIndexes * sWhere * sName * "=" * sIndexName * sAnd * sObjectID * "=([" + sSchemaName + "].[" + sTableName + "])") to sRetval
86853>>>>>>>
86853>>>>>>>        Function_Return sRetval
86854>>>>>>>    End_Function
86855>>>>>>>
86855>>>>>>>    // Formats a columns iLenght & iDecimal parameters as SQL expects them in a string.
86855>>>>>>>    // E.g. (4,2), where 4 is the iLength and 2 the iDecimals param.
86855>>>>>>>    Function _SqlFormatLengthAndDecimalAsString Integer iLength Integer iDecimals Returns String
86857>>>>>>>        String sRetval
86857>>>>>>>        If (iLength <> 0) Begin
86859>>>>>>>            Move ("(" + String(iLength)) to sRetval
86860>>>>>>>            If (iDecimals <> 0) Begin
86862>>>>>>>                Move (sRetval + "," + String(iDecimals)) to sRetval
86863>>>>>>>            End
86863>>>>>>>>
86863>>>>>>>            Move (sRetval + ")") to sRetval
86864>>>>>>>        End
86864>>>>>>>>
86864>>>>>>>        Function_Return sRetval
86865>>>>>>>    End_Function
86866>>>>>>>
86866>>>>>>>    Procedure _SqlColumnInfo Handle hoStmt
86868>>>>>>>        Integer i iCols iItem
86868>>>>>>>        tSqlColumnNew[] aQueryColumns
86868>>>>>>>        tSqlColumnNew[] aQueryColumns
86869>>>>>>>
86869>>>>>>>        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
86870>>>>>>>        For i from 1 to iCols
86876>>>>>>>>
86876>>>>>>>            Move (SizeOfArray(aQueryColumns)) to iItem
86877>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASECOLUMNNAME to aQueryColumns[iItem].sBaseColumnName
86878>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASETABLENAME  to aQueryColumns[iItem].sBaseTableName
86879>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_LABEL          to aQueryColumns[iItem].sLabel
86880>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SQLTYPE        to aQueryColumns[iItem].iSqlType
86881>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_DFTYPE         to aQueryColumns[iItem].iDFType
86882>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SIZE           to aQueryColumns[iItem].iSize
86883>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_PRECISION      to aQueryColumns[iItem].iPrecision
86884>>>>>>>        Loop
86885>>>>>>>>
86885>>>>>>>        Set piColumns to iCols
86886>>>>>>>        Set paQueryColumns to aQueryColumns
86887>>>>>>>    End_Procedure
86888>>>>>>>
86888>>>>>>>    // Checks that the passed sDriverID is defined.
86888>>>>>>>    // Also checks if the driver has been loaded; else it gets loaded.
86888>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
86890>>>>>>>        Boolean bOK
86890>>>>>>>        Integer iDriver
86890>>>>>>>
86890>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
86892>>>>>>>            Function_Return False
86893>>>>>>>        End
86893>>>>>>>>
86893>>>>>>>
86893>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
86894>>>>>>>
86894>>>>>>>        If (bOK = False) Begin
86896>>>>>>>            Get IsMertechDriver sDriverID to bOK
86897>>>>>>>        End
86897>>>>>>>>
86897>>>>>>>
86897>>>>>>>        If (bOK = False) Begin
86899>>>>>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV, DB2_DRV, ODBC_DRV, SQLFLEX, ORAFLEX, MDSPgSQL or MDSMySQL"
86900>>>>>>>>
86900>>>>>>>            Function_Return False
86901>>>>>>>        End
86901>>>>>>>>
86901>>>>>>>
86901>>>>>>>        Get DriverIndex sDriverID to iDriver
86902>>>>>>>        If (iDriver = 0) Begin
86904>>>>>>>            Load_Driver sDriverID
86905>>>>>>>        End
86905>>>>>>>>
86905>>>>>>>
86905>>>>>>>        Function_Return True
86906>>>>>>>    End_Function
86907>>>>>>>
86907>>>>>>>    // Checks that the length parameter has been passed correctly.
86907>>>>>>>    // This is only of concern for certain SQL data types.
86907>>>>>>>    Function _SqlCheckLengthParamForDataType Integer iDataType Integer iLen Returns Boolean
86909>>>>>>>        Integer iLength
86909>>>>>>>        Boolean bOK bCheckTypeLength
86909>>>>>>>
86909>>>>>>>        If (num_arguments > 1) Begin
86911>>>>>>>            Move iLen to iLength
86912>>>>>>>        End
86912>>>>>>>>
86912>>>>>>>        Move (iDataType = SQL_DECIMAL   or iDataType = SQL_NUMERIC or iDataType = SQL_FLOAT   or iDataType = SQL_INTEGER or;              iDataType = SQL_VARBINARY or iDataType = SQL_BINARY  or iDataType = SQL_VARCHAR or iDataType = SQL_CHAR or;              iDataType = SQL_BIGINT    or iDataType = SQL_REAL) to bCheckTypeLength
86913>>>>>>>
86913>>>>>>>        If (bCheckTypeLength = True) Begin
86915>>>>>>>            Move (iLength > 0) to bOK
86916>>>>>>>        End
86916>>>>>>>>
86916>>>>>>>
86916>>>>>>>        Function_Return (bOK = True)
86917>>>>>>>    End_Function
86918>>>>>>>
86918>>>>>>>    Function _SqlProperTableName String sTableName Returns String
86920>>>>>>>        String sVal sSchema sDriverID
86920>>>>>>>        Integer iDbType
86920>>>>>>>
86920>>>>>>>        If (Trim(sTableName) = "") Begin
86922>>>>>>>            Function_Return ""
86923>>>>>>>        End
86923>>>>>>>>
86923>>>>>>>
86923>>>>>>>        Get psDriverID to sDriverID
86924>>>>>>>        Get piDbType   to iDbType
86925>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
86927>>>>>>>            Get psUserID to sSchema
86928>>>>>>>            // Not sure about this uppercasing but it seems like Oracle wants that?
86928>>>>>>>            Move (Uppercase(sSchema)) to sSchema
86929>>>>>>>            Move ('"' + sSchema + '"."' + sTableName + '"') to sTableName
86930>>>>>>>            Function_Return sTableName
86931>>>>>>>        End
86931>>>>>>>>
86931>>>>>>>        If (iDbType = EN_DbTypeMySQL) Begin
86933>>>>>>>            Get psDatabase to sVal
86934>>>>>>>            Move (sVal + "." + sTableName) to sTableName
86935>>>>>>>            Function_Return sTableName
86936>>>>>>>        End
86936>>>>>>>>
86936>>>>>>>        If (iDbType = EN_DbTypePostgre) Begin
86938>>>>>>>            Move ('"' + sTableName + '"') to sTableName
86939>>>>>>>            Function_Return sTableName
86940>>>>>>>        End
86940>>>>>>>>
86940>>>>>>>
86940>>>>>>>        Get psSchema to sSchema
86941>>>>>>>        If (sSchema = "") Begin
86943>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
86944>>>>>>>        End
86944>>>>>>>>
86944>>>>>>>
86944>>>>>>>        Move (Uppercase(sTableName)) to sVal
86945>>>>>>>        If (not(sVal contains (sSchema + "."))) Begin
86947>>>>>>>            If (iDbType = EN_dbTypeDB2) Begin
86949>>>>>>>                Move (Lowercase(sSchema) + "." + sTableName) to sTableName
86950>>>>>>>            End
86950>>>>>>>>
86950>>>>>>>            Else Begin
86951>>>>>>>                Move (sSchema + "." + sTableName) to sTableName
86952>>>>>>>            End
86952>>>>>>>>
86952>>>>>>>        End
86952>>>>>>>>
86952>>>>>>>
86952>>>>>>>        Function_Return sTableName
86953>>>>>>>    End_Function
86954>>>>>>>
86954>>>>>>>    // SQL column names can be case-sensitive. This function is used to check that
86954>>>>>>>    // the passed sFieldName has the correct spelling.
86954>>>>>>>    // Used with Embedded SQL statement calls.
86954>>>>>>>    // If the spelling or fieldname doesn't exist, the return value is "" (blank).
86954>>>>>>>    Function _SqlFindColumnName String sTableName String sColumnName Returns String
86956>>>>>>>        String sRetval sValue sDriverID
86956>>>>>>>        String[] sColumnNamesArray
86957>>>>>>>        Integer iCount iColumns
86957>>>>>>>
86957>>>>>>>        Move "" to sRetval
86958>>>>>>>        Get psDriverID to sDriverID
86959>>>>>>>        Get SqlUtilEnumerateColumns sDriverID sTableName to sColumnNamesArray
86960>>>>>>>        Move (SizeOfArray(sColumnNamesArray)) to iColumns
86961>>>>>>>        Decrement iColumns
86962>>>>>>>
86962>>>>>>>        For iCount from 0 to iColumns
86968>>>>>>>>
86968>>>>>>>            Move sColumnNamesArray[iCount] to sValue
86969>>>>>>>            If (Uppercase(sColumnName) = Uppercase(sValue)) Begin
86971>>>>>>>                Move sValue to sRetval
86972>>>>>>>                Move iColumns to iCount // We're done.
86973>>>>>>>            End
86973>>>>>>>>
86973>>>>>>>        Loop
86974>>>>>>>>
86974>>>>>>>
86974>>>>>>>        Function_Return sRetval
86975>>>>>>>    End_Function
86976>>>>>>>
86976>>>>>>>    Function _SqlDatabasesArrayMSSQL Returns String[]
86978>>>>>>>        String[] sReturnArray
86979>>>>>>>        Handle hoSQLHandler
86979>>>>>>>        Integer iCount iSize iItem
86979>>>>>>>        String sServer sUser sPassword
86979>>>>>>>        tSQLConnection SQLConnection
86979>>>>>>>        tSQLConnection SQLConnection
86979>>>>>>>
86979>>>>>>>        Get phoMSSQLHandler to hoSQLHandler
86980>>>>>>>        Send Delete_Data    of hoSQLHandler
86981>>>>>>>        Get pSQLConnection  of ghoSQLConnectionHandler to SQLConnection
86982>>>>>>>
86982>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
86983>>>>>>>        Get EnumerateDatabases of hoSQLHandler SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to iSize
86984>>>>>>>        Decrement iSize
86985>>>>>>>
86985>>>>>>>        For iCount from 0 to iSize
86991>>>>>>>>
86991>>>>>>>            Get String_Value of hoSQLHandler item iCount to sServer
86992>>>>>>>            Move (Trim(sServer)) to sReturnArray[iItem]
86993>>>>>>>            Increment iItem
86994>>>>>>>        Loop
86995>>>>>>>>
86995>>>>>>>
86995>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
86996>>>>>>>
86996>>>>>>>        Function_Return sReturnArray
86997>>>>>>>    End_Function
86998>>>>>>>
86998>>>>>>>    Function _SqlTableArrayDAW Returns String[]
87000>>>>>>>        String[] sReturnArray
87001>>>>>>>        String sTable sTableType sSchema sDefSchema sComment sTableKeyWord sSysKeyWord
87001>>>>>>>        Handle hoSQLHandler
87001>>>>>>>        Integer iCount iSize iItem
87001>>>>>>>        Boolean bOK
87001>>>>>>>        tSQLConnection SQLConnection
87001>>>>>>>        tSQLConnection SQLConnection
87001>>>>>>>
87001>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
87002>>>>>>>        If (SQLConnection.sConnectionString = "") Begin
87004>>>>>>>            Function_Return sReturnArray
87005>>>>>>>        End
87005>>>>>>>>
87005>>>>>>>
87005>>>>>>>        Move SQLConnection.sSchema      to sDefSchema
87006>>>>>>>        Move (Uppercase(sDefSchema))    to sDefSchema
87007>>>>>>>        Get _SqlFindKeyWord CI_SQLTable to sTableKeyWord
87008>>>>>>>        Get _SqlFindKeyWord CI_SQLSys   to sSysKeyWord
87009>>>>>>>
87009>>>>>>>        Get phoCLIHandler to hoSQLHandler
87010>>>>>>>        Set psDriverID    of hoSQLHandler to SQLConnection.sDriverID
87011>>>>>>>        Send Delete_Data  of hoSQLHandler
87012>>>>>>>
87012>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
87013>>>>>>>        Get EnumerateTables of hoSQLHandler SQLConnection.sConnectionString to iSize
87014>>>>>>>        Move False to Err
87015>>>>>>>        Decrement iSize
87016>>>>>>>
87016>>>>>>>        For iCount from 0 to iSize
87022>>>>>>>>
87022>>>>>>>            Get TableName    of hoSQLHandler iCount to sTable
87023>>>>>>>            Get TableType    of hoSQLHandler iCount to sTableType
87024>>>>>>>            Get SchemaName   of hoSQLHandler iCount to sSchema
87025>>>>>>>            Get TableComment of hoSQLHandler iCount to sComment
87026>>>>>>>            Move (Trim(sTable)) to sTable
87027>>>>>>>            If (SQLConnection.sDriverID = DB2_DRV_ID) Begin
87029>>>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) = sDefSchema) to bOK
87030>>>>>>>            End
87030>>>>>>>>
87030>>>>>>>            Else Begin
87031>>>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) <> sSysKeyWord and Uppercase(sSchema) <> "SYSTOOLS") to bOK
87032>>>>>>>            End
87032>>>>>>>>
87032>>>>>>>            If (bOK = True) Begin
87034>>>>>>>                Move sTable to sReturnArray[iItem]
87035>>>>>>>                Increment iItem
87036>>>>>>>            End
87036>>>>>>>>
87036>>>>>>>        Loop
87037>>>>>>>>
87037>>>>>>>
87037>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
87038>>>>>>>
87038>>>>>>>        Function_Return sReturnArray
87039>>>>>>>    End_Function
87040>>>>>>>
87040>>>>>>>    Function _SqlProcedureArrayDAW String sStmt String sArgument Returns String[]
87042>>>>>>>        String[] sReturnArray
87043>>>>>>>        String sValue
87043>>>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
87043>>>>>>>        Integer iRetval iCols iFetchResult
87043>>>>>>>        tSQLConnection SQLConnection
87043>>>>>>>        tSQLConnection SQLConnection
87043>>>>>>>
87043>>>>>>>        Get phoSQLManager to hoSQLHandler
87044>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
87045>>>>>>>        Get SqlConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
87046>>>>>>>
87046>>>>>>>        If (hoSQLConnect <> 0) Begin
87048>>>>>>>            Get SqlOpen of hoSQLConnect to hStmt
87049>>>>>>>            If (hStmt <> 0) Begin
87051>>>>>>>                Send SqlSetProcedurename of hStmt sStmt
87052>>>>>>>                If (sArgument <> "") Begin
87054>>>>>>>                    Send SqlSetArgument  of hStmt 1 sArgument
87055>>>>>>>                End
87055>>>>>>>>
87055>>>>>>>
87055>>>>>>>                Send SqlCall             of hStmt
87056>>>>>>>                Get SqlReturnValue       of hStmt to iRetval
87057>>>>>>>                If (iRetval = 0) Begin
87059>>>>>>>                    Repeat
87059>>>>>>>>
87059>>>>>>>                        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
87060>>>>>>>                        If (iCols > 0) Begin
87062>>>>>>>                            Repeat
87062>>>>>>>>
87062>>>>>>>                                Get SqlFetch of hStmt to iFetchResult
87063>>>>>>>                                If (iFetchResult <> 0) Begin
87065>>>>>>>                                    Get SqlColumnValue of hStmt 1 to sValue
87066>>>>>>>                                    Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)]
87067>>>>>>>                                End
87067>>>>>>>>
87067>>>>>>>                            Until (iFetchResult = 0)
87069>>>>>>>                        End
87069>>>>>>>>
87069>>>>>>>                        Get SqlNextResultSet of hStmt to iRetval
87070>>>>>>>                    Until (iRetval = 0)
87072>>>>>>>                    Send SqlClose of hStmt
87073>>>>>>>                End
87073>>>>>>>>
87073>>>>>>>            End
87073>>>>>>>>
87073>>>>>>>            Send SqlDisconnect of hoSQLConnect
87074>>>>>>>        End
87074>>>>>>>>
87074>>>>>>>        Function_Return sReturnArray
87075>>>>>>>    End_Function
87076>>>>>>>
87076>>>>>>>    Function _SqlDatabasesArrayDB2 Returns String[]
87078>>>>>>>        String[] sReturnArray
87079>>>>>>>        String sDataSource
87079>>>>>>>        Handle hoSQLHandler
87079>>>>>>>        Integer iItem
87079>>>>>>>
87079>>>>>>>        Get phoDB2SQLHandler to hoSQLHandler
87080>>>>>>>        Send SeedDataSources of hoSQLHandler
87081>>>>>>>
87081>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
87082>>>>>>>
87082>>>>>>>        Repeat
87082>>>>>>>>
87082>>>>>>>            Get DataSources of hoSQLHandler to sDataSource
87083>>>>>>>            Move (Replaces(",", sDataSource, "")) to sDataSource
87084>>>>>>>            Move (Trim(sDataSource)) to sReturnArray[iItem]
87085>>>>>>>            Increment iItem
87086>>>>>>>        Until (sDataSource = "")
87088>>>>>>>
87088>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
87089>>>>>>>
87089>>>>>>>        Function_Return sReturnArray
87090>>>>>>>    End_Function
87091>>>>>>>
87091>>>>>>>    Function _SqlDatabasesArrayODBC Returns String[]
87093>>>>>>>        String[] sReturnArray
87094>>>>>>>        String sDataSource
87094>>>>>>>        Handle hoSQLHandler
87094>>>>>>>        Integer iItem
87094>>>>>>>
87094>>>>>>>        Get phoODBCSQLHandler to hoSQLHandler
87095>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
87096>>>>>>>
87096>>>>>>>        Send SeedDataSources of hoSQLHandler
87097>>>>>>>
87097>>>>>>>        Repeat
87097>>>>>>>>
87097>>>>>>>            Get DataSources of hoSQLHandler to sDataSource
87098>>>>>>>            If (Trim(sDataSource) <> "" and not(sDataSource contains "*.")) Begin
87100>>>>>>>                Move (Trim(sDataSource)) to sReturnArray[iItem]
87101>>>>>>>                Increment iItem
87102>>>>>>>            End
87102>>>>>>>>
87102>>>>>>>        Until (sDataSource = "")
87104>>>>>>>
87104>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
87105>>>>>>>
87105>>>>>>>        Function_Return sReturnArray
87106>>>>>>>    End_Function
87107>>>>>>>
87107>>>>>>>    // We might have a split Sql script where the info about which database to use is
87107>>>>>>>    // put on top of the Sql script, we then need to save it to be able to retrieve it later and
87107>>>>>>>    // insert it for scriplets to come after the first one.
87107>>>>>>>    Function _SqlFormatStatement String sStmt Returns String
87109>>>>>>>        String sUseDatabase sTmp sUseKeyWord sCreateViewKeyWord sDBOKeyWord sNoCountKeyWord sDriverID
87109>>>>>>>        Integer iStart iEnd iDbType
87109>>>>>>>        Boolean bOK
87109>>>>>>>
87109>>>>>>>        Get piDbType to iDbType
87110>>>>>>>        Get psDriverID to sDriverID
87111>>>>>>>        Get _SqlFindKeyWord CI_SQLUse          to sUseKeyWord
87112>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
87113>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateView   to sCreateViewKeyWord
87114>>>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBOKeyWord
87115>>>>>>>        Move (Replaces(" ", sStmt, "")) to sTmp
87116>>>>>>>        If (Uppercase(sTmp) contains (sUseKeyWord +"[")) Begin
87118>>>>>>>            Move (Pos("[", (Uppercase(sTmp)))) to iStart
87119>>>>>>>            Move (Pos("]", sTmp)) to iEnd
87120>>>>>>>            Move (Mid(sTmp, (iEnd -iStart +1), iStart)) to sUseDatabase
87121>>>>>>>            Move (sUseKeyWord * sUseDatabase + " ") to sUseDatabase
87122>>>>>>>            Set Private.psUseDatabase to sUseDatabase
87123>>>>>>>        End
87123>>>>>>>>
87123>>>>>>>        Else Begin
87124>>>>>>>            Move (Uppercase(sStmt)) to sTmp
87125>>>>>>>
87125>>>>>>>            // A "Create View" statement _must_ be the very first words in a Sql statement.
87125>>>>>>>            If (not(sTmp contains sCreateViewKeyWord)) Begin
87127>>>>>>>                Get Private.psUseDatabase to sUseDatabase
87128>>>>>>>                Move (Insert(sUseDatabase, sStmt, 1)) to sStmt
87129>>>>>>>            End
87129>>>>>>>>
87129>>>>>>>
87129>>>>>>>            // This is a bit special to place here but was done so because it was easier that way.
87129>>>>>>>            // We will get an error when trying to create a view if it already exists.
87129>>>>>>>            // So to avoid such errors; we first remove it & then recreate it.
87129>>>>>>>            Else If (sTmp contains sCreateViewKeyWord) Begin
87132>>>>>>>                // Make sure we only have one space between statements/words.
87132>>>>>>>                Move (Replaces("  ", sTmp, " ")) to sTmp
87133>>>>>>>                Move (Replace(sCreateViewKeyWord, sTmp, "")) to sTmp
87134>>>>>>>                Move (Trim(sTmp)) to sTmp
87135>>>>>>>                Move (Pos(" ", sTmp)) to iEnd
87136>>>>>>>                Move (Left(sTmp, iEnd)) to sTmp
87137>>>>>>>                If ((not(sTmp contains ("[" + sDBOKeyWord + "]."))) and (not(sTmp contains (sDBOKeyWord + ".")))) Begin
87139>>>>>>>                    Move (sDBOKeyWord + "." + Trim(sTmp)) to sTmp
87140>>>>>>>                End
87140>>>>>>>>
87140>>>>>>>                Move (Trim(sTmp)) to sTmp
87141>>>>>>>                // Remove data view as it already exists!
87141>>>>>>>                Get SqlViewRemove sDriverID sTmp to bOK
87142>>>>>>>            End
87142>>>>>>>>
87142>>>>>>>        End
87142>>>>>>>>
87142>>>>>>>
87142>>>>>>>        Function_Return sStmt
87143>>>>>>>    End_Function
87144>>>>>>>
87144>>>>>>>    // Returns the proper Sql language key word(s) for the passed SQL key-word constant
87144>>>>>>>    Function _SqlFindKeyWord Integer iSQLKeywordConstant Returns String
87146>>>>>>>        String sRetval
87146>>>>>>>        Integer iDbType iIndex
87146>>>>>>>        tSQLKeyWords[] SQLKeywordArray
87146>>>>>>>        tSQLKeyWords[] SQLKeywordArray
87147>>>>>>>        tSQLKeyWords   SQLKeyWords
87147>>>>>>>        tSQLKeyWords   SQLKeyWords
87147>>>>>>>
87147>>>>>>>        // Sql back-end type. E.g. MS-SQL, MySQL, Oracle, DB2...
87147>>>>>>>        Get piDbType to iDbType
87148>>>>>>>        Move iDbType             to SQLKeyWords.iSQLDbType
87149>>>>>>>        Move iSQLKeywordConstant to SQLKeyWords.iSQLWord
87150>>>>>>>
87150>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
87151>>>>>>>        Move (SearchArray(SQLKeyWords, SQLKeywordArray, Self, RefFunc(CompareFindSQLKeyWords))) to iIndex
87152>>>>>>>        Move SQLKeywordArray[iIndex].sSQLPhrase to sRetval
87153>>>>>>>
87153>>>>>>>        Function_Return sRetval
87154>>>>>>>    End_Function
87155>>>>>>>
87155>>>>>>>    // Function will "clean/sanitize" the script by removing all comments and blank lines.
87155>>>>>>>    Function _SqlUtilSanitizeScript tSQLScriptArray SqlScriptArray Returns tSQLScriptArray[]
87157>>>>>>>        String[] sSQLScriptArray
87158>>>>>>>        String sText sLine sTmp sCommentStart sCommentEnd sDashComment
87158>>>>>>>        Integer iSize iCount
87158>>>>>>>        Boolean bCommentStart bCommentEnd bDashComment
87158>>>>>>>
87158>>>>>>>        Move False to bCommentStart
87159>>>>>>>        Move False to bCommentEnd
87160>>>>>>>        Move False to bDashComment
87161>>>>>>>        Move "/*"  to sCommentStart   // These are the standard comment start & stop tokens...
87162>>>>>>>        Move "*/"  to sCommentEnd
87163>>>>>>>        Move "--"  to sDashComment    // ...but a comment can also start with two dashes "--".
87164>>>>>>>
87164>>>>>>>        Move (SizeOfArray(SqlScriptArray.sSQLScriptArray)) to iSize
87165>>>>>>>        Decrement iSize
87166>>>>>>>        Move "" to sText
87167>>>>>>>
87167>>>>>>>        For iCount from 0 to iSize
87173>>>>>>>>
87173>>>>>>>            Move SqlScriptArray.sSQLScriptArray[iCount] to sLine
87174>>>>>>>            Move (Trim(sLine)) to sTmp
87175>>>>>>>            If (sTmp <> "") Begin
87177>>>>>>>                Move (Left(sTmp, 2) = sDashComment) to bDashComment
87178>>>>>>>                If (bCommentStart = False) Begin
87180>>>>>>>                    Move (Left(sTmp, 2) = sCommentStart) to bCommentStart
87181>>>>>>>                    If (bCommentStart = False) Begin
87183>>>>>>>                    End
87183>>>>>>>>
87183>>>>>>>                End
87183>>>>>>>>
87183>>>>>>>                Move (sTmp contains sCommentEnd) to bCommentEnd
87184>>>>>>>                If (bCommentEnd = True) Begin
87186>>>>>>>                    Move False to bCommentStart
87187>>>>>>>                End
87187>>>>>>>>
87187>>>>>>>                If (bDashComment = False and bCommentStart = False and bCommentEnd = False) Begin
87189>>>>>>>                    Move sLine to sSQLScriptArray[SizeOfArray(sSQLScriptArray)]
87190>>>>>>>                End
87190>>>>>>>>
87190>>>>>>>            End
87190>>>>>>>>
87190>>>>>>>        Loop
87191>>>>>>>>
87191>>>>>>>
87191>>>>>>>        // Update the retval struct array:
87191>>>>>>>        Move sSQLScriptArray to SqlScriptArray.sSQLScriptArray
87192>>>>>>>        Function_Return SqlScriptArray
87193>>>>>>>    End_Function
87194>>>>>>>
87194>>>>>>>
87194>>>>>>>    // *** Database API Functions: ***
87194>>>>>>>    // Instead of using Sql Scripts (ESQL), we can opt to use the DataFlex Database API's to
87194>>>>>>>    // make changes/updates to the database.
87194>>>>>>>
87194>>>>>>>    // * Dummy function for the Studio's Code Explorer *
87194>>>>>>>    Function API_TABLE_FUNCTIONS Returns Boolean
87196>>>>>>>        Function_Return False
87197>>>>>>>    End_Function
87198>>>>>>>
87198>>>>>>>    // This might not do what you think - Here's what it does:
87198>>>>>>>    // It checks that the passed hTable TableName in filelist.cfg is exactly the same as at the SQL back-end.
87198>>>>>>>    // If that is True; it creates an .int file for it and changes Filelist.cfg to point
87198>>>>>>>    // to the SQL table.
87198>>>>>>>    // Typical usage for this function is when an entry exists in the Filelist for a table and the table
87198>>>>>>>    // already exists in SQL.
87198>>>>>>>    // This is a bit fiddly as the DF_FILE_PHYSICAL_NAME attribute can only be set inside a
87198>>>>>>>    // Structure_Start ... Structure_End operation when creating a NEW table. Thus it cannot be set when
87198>>>>>>>    // restructuring an existing table.
87198>>>>>>>    Function ApiTableAttachToSql Handle hTable Boolean bUseConnID Returns Boolean
87200>>>>>>>        Boolean bExists bOpened bOK bSystemFile bMertechDriver bUseConnectionID bIsAlias
87200>>>>>>>        String sDriverID sConnectionID sConnectionString sDisplayName sRootName sLogicalName sPhysicalName sSchema
87200>>>>>>>        Handle hToTable
87200>>>>>>>        Integer iPos
87200>>>>>>>
87200>>>>>>>        Move True to bUseConnectionID
87201>>>>>>>        If (num_arguments > 1) Begin
87203>>>>>>>            Move bUseConnID to bUseConnectionID
87204>>>>>>>        End
87204>>>>>>>>
87204>>>>>>>
87204>>>>>>>        Get psDriverID to sDriverID
87205>>>>>>>        // If the table doesn't exist on the SQL back-end we do nothing.
87205>>>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
87206>>>>>>>        If (bExists = False) Begin
87208>>>>>>>            Function_Return False
87209>>>>>>>        End
87209>>>>>>>>
87209>>>>>>>
87209>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
87210>>>>>>>
87210>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
87211>>>>>>>        If (bOK = False) Begin
87213>>>>>>>            Function_Return False
87214>>>>>>>        End
87214>>>>>>>>
87214>>>>>>>
87214>>>>>>>        // Then we need to check that the function hasn't been called before; which in case
87214>>>>>>>        // we do nothing
87214>>>>>>>        Get SQLUtilTableIsAttached sDriverID hTable to bExists
87215>>>>>>>        If (bExists = True) Begin
87217>>>>>>>            Function_Return False
87218>>>>>>>        End
87218>>>>>>>>
87218>>>>>>>
87218>>>>>>>        Get psConnectionID     to sConnectionID
87219>>>>>>>        Get psConnectionString to sConnectionString
87220>>>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
87222>>>>>>>            Error DFERR_PROGRAM ("An SQL connection has NOT been setup correctly. Could not attach table:" * String(hTable) * "to SQL")
87223>>>>>>>>
87223>>>>>>>            Function_Return False
87224>>>>>>>        End
87224>>>>>>>>
87224>>>>>>>
87224>>>>>>>        Set Private.phCurrentTable to hTable
87225>>>>>>>        Get psSchema to sSchema
87226>>>>>>>        If (sSchema = "") Begin
87228>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
87229>>>>>>>        End
87229>>>>>>>>
87229>>>>>>>
87229>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
87230>>>>>>>
87230>>>>>>>        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
87230>>>>>>>        // was a programmer's error and we adjust for it here.
87230>>>>>>>        If (bMertechDriver = True) Begin
87232>>>>>>>            Move False to bUseConnectionID
87233>>>>>>>        End
87233>>>>>>>>
87233>>>>>>>
87233>>>>>>>        // If we should use a connection id we need to check it exists;
87233>>>>>>>        // else we create it before attempting creating the table
87233>>>>>>>        If (bUseConnectionID = True) Begin
87235>>>>>>>            Get AutoConnectionIDLogin to bOK
87236>>>>>>>            If (bOk = False) Begin
87238>>>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
87239>>>>>>>>
87239>>>>>>>                Function_Return False
87240>>>>>>>            End
87240>>>>>>>>
87240>>>>>>>        End
87240>>>>>>>>
87240>>>>>>>
87240>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
87243>>>>>>>        Get _TableNameOnly sRootName to sRootName
87244>>>>>>>        If (sRootName = "") Begin
87246>>>>>>>            Function_Return False
87247>>>>>>>        End
87247>>>>>>>>
87247>>>>>>>        Move (sRootName + ".int")                    to sPhysicalName
87248>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
87251>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
87254>>>>>>>
87254>>>>>>>        // We don't want to change the display name if it starts with an ampersand ("@"),
87254>>>>>>>        // because then the table should not be visible to users.
87254>>>>>>>        Move (Pos("@", sDisplayName)) to iPos
87255>>>>>>>        If (iPos <> 1) Begin
87257>>>>>>>            If (sDisplayName contains ".") Begin
87259>>>>>>>                Move (Pos(".", sDisplayName)) to iPos
87260>>>>>>>                Move (Mid(sDisplayName, 200 ,(iPos + 1))) to sDisplayName
87261>>>>>>>                Move (sSchema + "." + sDisplayName)       to sDisplayName
87262>>>>>>>            End
87262>>>>>>>>
87262>>>>>>>            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
87264>>>>>>>                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
87265>>>>>>>            End
87265>>>>>>>>
87265>>>>>>>        End
87265>>>>>>>>
87265>>>>>>>
87265>>>>>>>        If (bIsAlias = False) Begin
87267>>>>>>>            Get OpenTableExclusive hTable to bOpened
87268>>>>>>>            If (bOpened = False) Begin
87270>>>>>>>                Error DFERR_PROGRAM ("Function ApiTableAttachToSQL - Could not open table number:" * String(hTable) * sLogicalName)
87271>>>>>>>>
87271>>>>>>>                Function_Return False
87272>>>>>>>            End
87272>>>>>>>>
87272>>>>>>>        End
87272>>>>>>>>
87272>>>>>>>
87272>>>>>>>        If (ghoProgressBar <> 0) Begin
87274>>>>>>>            Send DoAdvance of ghoProgressBar
87275>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Attaching to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable) * "to SQL")
87276>>>>>>>        End
87276>>>>>>>>
87276>>>>>>>        // Note: The hToTable will get changed by the Structure_xxx command...
87276>>>>>>>        Move hTable to hToTable
87277>>>>>>>        Move False to Err
87278>>>>>>>
87278>>>>>>>        // We now create a stub .int file and after Structure_end and also change the Filelist.cfg,
87278>>>>>>>        // then we do a pseudo .int file change with the "SqlUtilUpdateIntFile" function. After that we have
87278>>>>>>>        // a proper and updated .int file.
87278>>>>>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemFile
87281>>>>>>>        Get SqlUtilCreateIntFile hTable sDriverID sConnectionID True bSystemFile to bOK
87282>>>>>>>
87282>>>>>>>        If (bIsAlias = False) Begin
87284>>>>>>>            Structure_Start hToTable sDriverID
87285>>>>>>>                Set Private.phCurrentTable to hTable
87286>>>>>>>                If (bUseConnectionID = True) Begin
87288>>>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to (CS_DFCONNID + "=" + sConnectionID)
87291>>>>>>>                End
87291>>>>>>>>
87291>>>>>>>                Else Begin
87292>>>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to sConnectionString
87295>>>>>>>                End
87295>>>>>>>>
87295>>>>>>>                Set_Attribute DF_FILE_OWNER         of hToTable to (Lowercase(sSchema))
87298>>>>>>>                // For unknown reason the above sometimes triggers an error and it doesn't help to try to trap the error; so we cheat...
87298>>>>>>>                Move False to Err
87299>>>>>>>                Move 0 to LastErr
87300>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
87301>>>>>>>            Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87303>>>>>>>            Set Action_Text of ghoStatusPanel to ""
87304>>>>>>>        End
87304>>>>>>>>
87304>>>>>>>
87304>>>>>>>        Move (not(Err)) to bOK
87305>>>>>>>        If (bOK = True) Begin
87307>>>>>>>            // The attributes set above will always trigger an error
87307>>>>>>>            // We also adjust the Filelist entries
87307>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to (sDriverID + ":" + sRootName)
87310>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
87313>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
87316>>>>>>>
87316>>>>>>>            // This updates the .int file to make it up-to-date with the SQL back-end.
87316>>>>>>>            Get SqlUtilUpdateIntFile hTable to bOK
87317>>>>>>>        End
87317>>>>>>>>
87317>>>>>>>
87317>>>>>>>        Function_Return (bOK = True)
87318>>>>>>>    End_Function
87319>>>>>>>
87319>>>>>>>    // Sample usage:
87319>>>>>>>    //    Get ApiTableChangeAttribute SysInfo.File_Number DF_FILE_IS_SYSTEM_FILE True to bOK
87319>>>>>>>    //    Get ApiTableChangeAttribute OrderHea.File_Number DF_FILE_REUSE_DELETED DF_FILE_DELETED_NOREUSE to bOK
87319>>>>>>>    Function ApiTableChangeAttribute Handle hTable Integer iAttribute Integer iValue Returns Boolean
87321>>>>>>>        Boolean bOK bIsSQLTable
87321>>>>>>>
87321>>>>>>>        Get AutoConnectionIDLogin to bOK
87322>>>>>>>        Move False to Err
87323>>>>>>>        Get OpenTableExclusive hTable to bOK
87324>>>>>>>        If (bOK = False) Begin
87326>>>>>>>            Function_Return False
87327>>>>>>>        End 
87327>>>>>>>>
87327>>>>>>>        
87327>>>>>>>        // ToDo: Add to all table change functions!
87327>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
87328>>>>>>>            If (bIsSQLTable = True) Begin
87330>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
87333>>>>>>>            End
87333>>>>>>>>
87333>>>>>>>        
87333>>>>>>>        Set Private.phCurrentTable to hTable
87334>>>>>>>        Structure_Start hTable
87335>>>>>>>            Set_Attribute iAttribute of hTable to iValue
87338>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87339>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87341>>>>>>>
87341>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87342>>>>>>>        Function_Return (Err = False)
87343>>>>>>>    End_Function
87344>>>>>>>
87344>>>>>>>    // To use a filelist slot for the passed FileName, TableName & DisplayName,
87344>>>>>>>    // or to change the filelist slot names.
87344>>>>>>>    Function ApiTableChangeFileListSlot String sRootName String sLogicalName String sDisplayName Handle hTable String sDriverID Returns Boolean
87346>>>>>>>        Boolean bExists
87346>>>>>>>
87346>>>>>>>        Move False to Err
87347>>>>>>>        Get UtilTableNumberIsInUse hTable to bExists
87348>>>>>>>        If (bExists = False) Begin
87350>>>>>>>            Function_Return False
87351>>>>>>>        End
87351>>>>>>>>
87351>>>>>>>
87351>>>>>>>        If (ghoProgressBar <> 0) Begin
87353>>>>>>>            Send DoAdvance of ghoProgressBar
87354>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Changing Filelist slot for Table:" * String(sLogicalName) * "Number:" * String(hTable))
87355>>>>>>>        End
87355>>>>>>>>
87355>>>>>>>        // If all strings are empty it means that we should remove this entry from filelist.
87355>>>>>>>        If (sRootName = "" and sLogicalName = "" and sDisplayName = "") Begin
87357>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
87360>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
87363>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
87366>>>>>>>            Function_Return (Err = False) // And we're done.
87367>>>>>>>        End
87367>>>>>>>>
87367>>>>>>>
87367>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
87369>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
87372>>>>>>>        End
87372>>>>>>>>
87372>>>>>>>        Else Begin
87373>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
87376>>>>>>>        End
87376>>>>>>>>
87376>>>>>>>
87376>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
87379>>>>>>>
87379>>>>>>>        If (sDriverID <> DATAFLEX_ID and not(Uppercase(sDisplayName) contains "DBO.")) Begin
87381>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ("dbo." + sDisplayName)
87384>>>>>>>        End
87384>>>>>>>>
87384>>>>>>>        Else Begin
87385>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
87388>>>>>>>        End
87388>>>>>>>>
87388>>>>>>>
87388>>>>>>>        Function_Return (Err = False)
87389>>>>>>>    End_Function
87390>>>>>>>
87390>>>>>>>    Function ApiTableChangeRecordLength Handle hTable Integer iRecordLength Returns Boolean
87392>>>>>>>        Boolean bOK
87392>>>>>>>
87392>>>>>>>        Get AutoConnectionIDLogin to bOK
87393>>>>>>>        Move False to Err
87394>>>>>>>        Get OpenTableExclusive hTable to bOK
87395>>>>>>>        If (bOK = False) Begin
87397>>>>>>>            Function_Return False
87398>>>>>>>        End
87398>>>>>>>>
87398>>>>>>>
87398>>>>>>>        Set Private.phCurrentTable to hTable
87399>>>>>>>        Structure_Start hTable
87400>>>>>>>            Set_Attribute DF_FILE_RECORD_LENGTH of hTable to iRecordLength
87403>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87404>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87406>>>>>>>
87406>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87407>>>>>>>        Function_Return (Err = False)
87408>>>>>>>    End_Function
87409>>>>>>>
87409>>>>>>>    Function ApiTableChangeRelation Handle hTable Handle hToTable Integer iFromField Integer iToField Returns Boolean
87411>>>>>>>        Boolean bOK
87411>>>>>>>
87411>>>>>>>        Move False to Err
87412>>>>>>>        Get AutoConnectionIDLogin to bOK
87413>>>>>>>        Open hToTable
87415>>>>>>>        Get OpenTableExclusive hTable to bOK
87416>>>>>>>        If (bOK = False) Begin
87418>>>>>>>            Function_Return False
87419>>>>>>>        End
87419>>>>>>>>
87419>>>>>>>
87419>>>>>>>        Set Private.phCurrentTable to hTable
87420>>>>>>>        Structure_Start hTable
87421>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE  of hTable iFromField to hToTable
87424>>>>>>>            Set_Attribute DF_FIELD_RELATED_FIELD of hTable iFromField to iToField
87427>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87428>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87430>>>>>>>
87430>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87431>>>>>>>        Function_Return (Err = False)
87432>>>>>>>    End_Function
87433>>>>>>>
87433>>>>>>>    Procedure ApiTableConvertAllAddException Integer hTable
87435>>>>>>>        Integer[] aTableConvertExceptions
87436>>>>>>>        Get paTableConvertExceptions to aTableConvertExceptions
87437>>>>>>>        Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
87438>>>>>>>        Set paTableConvertExceptions to aTableConvertExceptions
87439>>>>>>>    End_Procedure
87440>>>>>>>
87440>>>>>>>    Procedure ApiTableDateCorrectionAddException Integer hTable
87442>>>>>>>        Integer[] aTableDateCorrectionExceptions
87443>>>>>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
87444>>>>>>>        Move hTable to aTableDateCorrectionExceptions[SizeOfArray(aTableDateCorrectionExceptions)]
87445>>>>>>>        Set paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
87446>>>>>>>    End_Procedure
87447>>>>>>>
87447>>>>>>>    Procedure ApiTableConvertALLToSql
87449>>>>>>>        Integer[] iTablesArray
87450>>>>>>>        Integer iSize iCount
87450>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
87450>>>>>>>        String sDriverID
87450>>>>>>>
87450>>>>>>>        Get psDriverID to sDriverID
87451>>>>>>>        Get pbUseConnectionID to bUseConnectionID
87452>>>>>>>        Get pbToANSI          to bToANSI
87453>>>>>>>        Get pbRecnum          to bRecnum
87454>>>>>>>        Get pbCopyData        to bCopyData
87455>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
87457>>>>>>>            Get pbContinueOnError to bContinueOnError
87458>>>>>>>        End
87458>>>>>>>>
87458>>>>>>>
87458>>>>>>>        Get _AllTablesToConvert to iTablesArray
87459>>>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
87460>>>>>>>        Set pbVisible   of ghoProgressBarOverall to True
87461>>>>>>>        Set piPosition  of ghoProgressBarOverall to 0
87462>>>>>>>        Set piAdvanceBy of ghoProgressBarOverall to 1
87463>>>>>>>        Set piMaximum   of ghoProgressBarOverall to iSize
87464>>>>>>>
87464>>>>>>>        Decrement iSize
87465>>>>>>>        For iCount from 0 to iSize
87471>>>>>>>>
87471>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
87472>>>>>>>            Get ApiTableConvertToSQL_Ex iTablesArray[iCount] sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
87473>>>>>>>            // Probably the right logic here is to just continue trying to convert every table even
87473>>>>>>>            // if there was an error converting one table...
87473>>>>>>>            //If (bContinueOnError = False and bOK = False) Break
87473>>>>>>>        Loop
87474>>>>>>>>
87474>>>>>>>
87474>>>>>>>    End_Procedure
87475>>>>>>>
87475>>>>>>>    Procedure ApiTableAttachALLToSql
87477>>>>>>>        Integer[] iTablesArray
87478>>>>>>>        Integer iSize iCount
87478>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
87478>>>>>>>        String sDriverID
87478>>>>>>>
87478>>>>>>>        Get psDriverID to sDriverID
87479>>>>>>>        Get pbUseConnectionID to bUseConnectionID
87480>>>>>>>        Get pbToANSI          to bToANSI
87481>>>>>>>        Get pbRecnum          to bRecnum
87482>>>>>>>        Get pbCopyData        to bCopyData
87483>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
87485>>>>>>>            Get pbContinueOnError to bContinueOnError
87486>>>>>>>        End
87486>>>>>>>>
87486>>>>>>>
87486>>>>>>>        Get _AllTablesToConvert to iTablesArray
87487>>>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
87488>>>>>>>        Decrement iSize
87489>>>>>>>        For iCount from 0 to iSize
87495>>>>>>>>
87495>>>>>>>            Get ApiTableAttachToSQL iTablesArray[iCount] bUseConnectionID to bOK
87496>>>>>>>        Loop
87497>>>>>>>>
87497>>>>>>>
87497>>>>>>>    End_Procedure      
87498>>>>>>>    
87498>>>>>>>    // Subfunction to the ApiTableUpdate function (et al)
87498>>>>>>>    Function _UtilTableCheckChangeFilelistNames tAPITableNameInfo APITableNameInfoFrom Boolean bIsSQLTableTo Returns Boolean
87500>>>>>>>        Handle hTable 
87500>>>>>>>        String sRootNameTo sLogicalNameTo sDisplayNameTo sConnectionID
87500>>>>>>>        Boolean bIsSQLTableFrom bTableExists bSameTableNames bANSI bOK
87500>>>>>>>        
87500>>>>>>>        Get ApiTableFilelistNamesCompare True APITableNameInfoFrom to bSameTableNames
87501>>>>>>>        If (bSameTableNames = True) Begin
87503>>>>>>>            Function_Return True
87504>>>>>>>        End 
87504>>>>>>>>
87504>>>>>>>        
87504>>>>>>>        Move True to bOK
87505>>>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable  
87506>>>>>>>        Set Private.phCurrentTable              to hTable
87507>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME         of hTable to APITableNameInfoFrom.sRootName
87510>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME      of hTable to APITableNameInfoFrom.sLogicalName
87513>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME      of hTable to APITableNameInfoFrom.sDisplayName
87516>>>>>>>        
87516>>>>>>>        If (APITableNameInfoFrom.bIsSQL = True) Begin
87518>>>>>>>            Get psConnectionID to sConnectionID
87519>>>>>>>            Get UtilTableExists hTable to bTableExists
87520>>>>>>>            If (bTableExists = True) Begin  
87522>>>>>>>                Get SqlUtilUpdateIntFile hTable to bOK
87523>>>>>>>            End
87523>>>>>>>>
87523>>>>>>>            Else Begin
87524>>>>>>>                Get pbToANSI to bANSI 
87525>>>>>>>                Get SqlUtilCreateIntFile hTable APITableNameInfoFrom.sDriverID sConnectionID bANSI False to bOK
87526>>>>>>>            End
87526>>>>>>>>
87526>>>>>>>        End
87526>>>>>>>>
87526>>>>>>>
87526>>>>>>>        Function_Return bOK
87527>>>>>>>    End_Function
87528>>>>>>>
87528>>>>>>>    Function ApiTableConvertToSql_Ex Handle hTable String sDriverID Boolean bUseConnectionID Boolean bToAnsi Boolean bRecnum Boolean bCopyData Returns Boolean
87530>>>>>>>        Handle hToTable hoLogFile
87530>>>>>>>        Boolean bOK bExists bOpened bMertechDriver bDAWDriver bContinueOnError bIsAlias
87530>>>>>>>        String sPhysicalName sRootName sLogicalName sDisplayName sConnectionID sConnectionString
87530>>>>>>>        String sANSI_OEM sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace sDatabase sGUIDName sWarning
87530>>>>>>>        tSQLConnection SQLConnection
87530>>>>>>>        tSQLConnection SQLConnection
87530>>>>>>>        
87530>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
87531>>>>>>>        // If this is an Alias file there is nothing to convert to SQL.
87531>>>>>>>        // Instead we change the Filelist.cfg by adding the driver id to the rootname and create an .int file
87531>>>>>>>        If (bIsAlias = True) Begin
87533>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
87536>>>>>>>            If (sDriverID <> DATAFLEX_ID and not(sRootName contains ":")) Begin
87538>>>>>>>                Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
87541>>>>>>>                Get psConnectionID to sConnectionID
87542>>>>>>>                Get SqlUtilCreateIntFile hTable sDriverID sConnectionID True False to bOK
87543>>>>>>>            End
87543>>>>>>>>
87543>>>>>>>            Function_Return True
87544>>>>>>>        End
87544>>>>>>>>
87544>>>>>>>
87544>>>>>>>        Set Private.phCurrentTable to hTable
87545>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
87548>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
87551>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
87554>>>>>>>
87554>>>>>>>        If (ghoProgressBar <> 0) Begin
87556>>>>>>>            Send DoAdvance of ghoProgressBar
87557>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(sLogicalName))
87558>>>>>>>        End
87558>>>>>>>>
87558>>>>>>>
87558>>>>>>>        // Marco Kuipers suggestion;
87558>>>>>>>        // If Filelist.cfg points to an embedded .dat table and the table already exists as
87558>>>>>>>        // an SQL table; rename the SQL table by adding a GUID at the end, then convert the
87558>>>>>>>        // table again.
87558>>>>>>>        Get UtilTableIsSQL hTable to bOK
87559>>>>>>>        If (bOK = False) Begin
87561>>>>>>>            Get SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
87562>>>>>>>            If (bExists = True) Begin
87564>>>>>>>                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
87565>>>>>>>                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
87566>>>>>>>                Get phoLogFile to hoLogFile
87567>>>>>>>                If (hoLogFile <> 0) Begin
87569>>>>>>>                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The existing SQL table was renamed to:" * String(sGUIDName) * "and then converted again.") to sWarning
87570>>>>>>>                    Send LogError sWarning False
87571>>>>>>>                End
87571>>>>>>>>
87571>>>>>>>                Else Begin
87572>>>>>>>                    Error DFERR_PROGRAM sWarning
87573>>>>>>>>
87573>>>>>>>                End
87573>>>>>>>>
87573>>>>>>>            End
87573>>>>>>>>
87573>>>>>>>        End
87573>>>>>>>>
87573>>>>>>>
87573>>>>>>>        // Does the rootname contain a driver?
87573>>>>>>>        If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
87575>>>>>>>            // Does the table already exist as an SQL table?
87575>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
87576>>>>>>>            // It can happen that the table is missing from Filelist.cfg but still
87576>>>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
87576>>>>>>>            If (bExists = False) Begin
87578>>>>>>>                Get SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
87579>>>>>>>            End
87579>>>>>>>>
87579>>>>>>>            If (bExists = True) Begin
87581>>>>>>>                Set TableName_Text of ghoStatusPanel to ""
87582>>>>>>>                Function_Return False
87583>>>>>>>            End
87583>>>>>>>>
87583>>>>>>>        End
87583>>>>>>>>
87583>>>>>>>        Move (If(bToAnsi = True, CS_ANSI_Txt, CS_OEM_Txt)) to sANSI_OEM
87584>>>>>>>
87584>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWDriver
87585>>>>>>>        // Mertech drivers don't use Connection ID's; so if bUseConnectionID was
87585>>>>>>>        // passed as True, we adjust for that here.
87585>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
87586>>>>>>>        If (bMertechDriver = True and bUseConnectionID = True) Begin
87588>>>>>>>            Move False to bUseConnectionID
87589>>>>>>>        End
87589>>>>>>>>
87589>>>>>>>
87589>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
87590>>>>>>>        Move SQLConnection.sSchema           to sSchema
87591>>>>>>>        If (sSchema = "") Begin
87593>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO    to sSchema
87594>>>>>>>            Move (Lowercase(sSchema))        to sSchema
87595>>>>>>>        End
87595>>>>>>>>
87595>>>>>>>
87595>>>>>>>        If (sDriverID = ORAFLEX) Begin
87597>>>>>>>            Move SQLConnection.sUserID       to sSchema
87598>>>>>>>        End
87598>>>>>>>>
87598>>>>>>>
87598>>>>>>>        Move SQLConnection.sDatabase         to sDatabase
87599>>>>>>>        Move SQLConnection.sConnectionID     to sConnectionID
87600>>>>>>>        Move SQLConnection.sConnectionString to sConnectionString
87601>>>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
87603>>>>>>>            Error DFERR_PROGRAM ("The SQL connection info has NOT been setup. Could not convert table:" * String(hTable) * "to SQL")
87604>>>>>>>>
87604>>>>>>>            Function_Return False
87605>>>>>>>        End
87605>>>>>>>>
87605>>>>>>>
87605>>>>>>>        Get AutoConnectionIDLogin to bOK
87606>>>>>>>        Open hTable
87608>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
87611>>>>>>>        If (bOpened = False) Begin
87613>>>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
87614>>>>>>>>
87614>>>>>>>            Function_Return False
87615>>>>>>>        End
87615>>>>>>>>
87615>>>>>>>
87615>>>>>>>        If (ghoProgressBar <> 0) Begin
87617>>>>>>>            Send DoAdvance of ghoProgressBar
87618>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable))
87619>>>>>>>        End
87619>>>>>>>>
87619>>>>>>>
87619>>>>>>>        Move 0 to hToTable
87620>>>>>>>        Get _TableNameOnly sRootName                 to sRootName
87621>>>>>>>        Move (sRootName + ".int")                    to sPhysicalName
87622>>>>>>>
87622>>>>>>>        Case Begin
87622>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
87624>>>>>>>                Case Break
87625>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
87628>>>>>>>                Case Break
87629>>>>>>>            Case (sDriverID = DB2_DRV_ID)
87632>>>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
87633>>>>>>>                Move SQLConnection.sLongTableSpace  to sLongTableSpace
87634>>>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
87635>>>>>>>                Case Break
87636>>>>>>>            Case (sDriverID = ORAFLEX)
87639>>>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
87640>>>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
87641>>>>>>>                Case Break
87642>>>>>>>            Case (sDriverID = MDSMySQL)
87645>>>>>>>                Case Break
87646>>>>>>>            Case (sDriverID = MDSPgSQL)
87649>>>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
87650>>>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
87651>>>>>>>                Case Break
87652>>>>>>>            Case (sDriverID = DATAFLEX_ID)
87655>>>>>>>                Case Break
87656>>>>>>>            Case Else
87656>>>>>>>                Error DFERR_PROGRAM "Wrong database driver passed to the 'ApiTableConvertToSQL_Ex' function."
87657>>>>>>>>
87657>>>>>>>                Case Break
87658>>>>>>>        Case End
87658>>>>>>>
87658>>>>>>>        Move False to Err
87659>>>>>>>
87659>>>>>>>        If (bIsAlias = False) Begin
87661>>>>>>>
87661>>>>>>>            If (bMertechDriver = True) Begin
87663>>>>>>>                // Note: This function also sets the Err flag.
87663>>>>>>>                Get _MertechApiTableConvertToSQL hTable sRootName sDatabase sDriverID sBaseTableSpace sIndexTableSpace bCopyData to bOK
87664>>>>>>>            End
87664>>>>>>>>
87664>>>>>>>
87664>>>>>>>            If (bMertechDriver = False) Begin
87666>>>>>>>                Structure_Start hToTable sDriverID
87667>>>>>>>                    Structure_Copy hTable to hToTable
87668>>>>>>>
87668>>>>>>>                    Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
87671>>>>>>>
87671>>>>>>>                    If (sDriverID <> DATAFLEX_ID) Begin
87673>>>>>>>                        If (bUseConnectionID = True) Begin
87675>>>>>>>                            Set_Attribute DF_FILE_LOGIN     of hToTable to (CS_DFCONNID + "=" + sConnectionID)
87678>>>>>>>                        End
87678>>>>>>>>
87678>>>>>>>                        Else Begin
87679>>>>>>>                            Set_Attribute DF_FILE_LOGIN     of hToTable to sConnectionString
87682>>>>>>>                        End
87682>>>>>>>>
87682>>>>>>>
87682>>>>>>>                        Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT   of hToTable to sANSI_OEM
87685>>>>>>>                        Set_Attribute DF_FILE_RECNUM_TABLE             of hToTable to bRecnum
87688>>>>>>>
87688>>>>>>>                        If (sSchema <> "") Begin
87690>>>>>>>                            Set_Attribute DF_FILE_OWNER                of hToTable to sSchema
87693>>>>>>>                        End
87693>>>>>>>>
87693>>>>>>>
87693>>>>>>>                        If (sDriverID = DB2_DRV_ID) Begin
87695>>>>>>>                            If (sLongTableSpace <> "") Begin
87697>>>>>>>                                Set_Attribute DF_FILE_LONG_TABLESPACE  of hToTable to sLongTableSpace
87700>>>>>>>                            End
87700>>>>>>>>
87700>>>>>>>                            If (sBaseTableSpace <> "") Begin
87702>>>>>>>                                Set_Attribute DF_FILE_TABLE_TABLESPACE of hToTable to sBaseTableSpace
87705>>>>>>>                            End
87705>>>>>>>>
87705>>>>>>>                            If (sIndexTableSpace <> "") Begin
87707>>>>>>>                                Set_Attribute DF_FILE_INDEX_TABLESPACE of hToTable to sIndexTableSpace
87710>>>>>>>                            End
87710>>>>>>>>
87710>>>>>>>                        End
87710>>>>>>>>
87710>>>>>>>                    End
87710>>>>>>>>
87710>>>>>>>
87710>>>>>>>                    Set Action_Text of ghoStatusPanel to "Restructures table..."
87711>>>>>>>                Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87713>>>>>>>                Set Action_Text of ghoStatusPanel to ""
87714>>>>>>>            End
87714>>>>>>>>
87714>>>>>>>
87714>>>>>>>            Move (not(Err)) to bOK
87715>>>>>>>            If (bOK = True and bCopyData = True and bMertechDriver = False) Begin
87717>>>>>>>                If (bIsAlias = False) Begin
87719>>>>>>>                    Get ApiTableCopyData hTable sPhysicalName sRootName sDriverID to bOK
87720>>>>>>>                    If (ghoDbUpdateHandler > 0) Begin
87722>>>>>>>                        Get pbContinueOnError to bContinueOnError
87723>>>>>>>                    End
87723>>>>>>>>
87723>>>>>>>                    // If the data copy failed we will keep the newly created SQL table but
87723>>>>>>>                    // rename it by adding a GUID at the end of the table name
87723>>>>>>>                    // - or as much as "fit" because different SQL back-ends have
87723>>>>>>>                    // different rules how long a table name can be.
87723>>>>>>>                    // The new table will probably contain data but something went
87723>>>>>>>                    // wrong while converting the data from embedded to SQL.
87723>>>>>>>                    If (bOK = False and bContinueOnError = False) Begin
87725>>>>>>>                        Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
87726>>>>>>>                        Get SqlTableRename hTable sLogicalName sGUIDName to bOK
87727>>>>>>>                        Error DFERR_PROGRAM ("Copying of data failed. The SQL table:" * sLogicalName * "was renamed to:" * String(sGUIDName))
87728>>>>>>>>
87728>>>>>>>                    End
87728>>>>>>>>
87728>>>>>>>                End
87728>>>>>>>>
87728>>>>>>>            End
87728>>>>>>>>
87728>>>>>>>        End
87728>>>>>>>>
87728>>>>>>>
87728>>>>>>>        If (bMertechDriver = True) Begin
87730>>>>>>>            Open hTable
87732>>>>>>>        End
87732>>>>>>>>
87732>>>>>>>
87732>>>>>>>        // This must be after copying data...
87732>>>>>>>        If (Err = False) Begin
87734>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
87737>>>>>>>            // We also adjust the display name by prefixing it by the schema name;
87737>>>>>>>            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
87739>>>>>>>                // The max length for the display_name is 31 characters...
87739>>>>>>>                If (Length(sSchema + "." + sDisplayName) < 31) Begin
87741>>>>>>>                    Set_Attribute DF_FILE_DISPLAY_NAME of hTable to (Lowercase(sSchema) + "." + sDisplayName)
87744>>>>>>>                End
87744>>>>>>>>
87744>>>>>>>            End
87744>>>>>>>>
87744>>>>>>>        End
87744>>>>>>>>
87744>>>>>>>
87744>>>>>>>        Close hTable
87745>>>>>>>        Move (not(Err)) to bOK
87746>>>>>>>        Function_Return (bOK = True)
87747>>>>>>>    End_Function
87748>>>>>>>
87748>>>>>>>    // Calls a driver function directly to copy data from one table to another (table structures needs to be the same).
87748>>>>>>>    // It will first drop all indicies, copy the data and then recreate indicies.
87748>>>>>>>    // An error log file with the sRootname + ".err" will be created in the Data folder.
87748>>>>>>>    Function ApiTableCopyData Integer hFromTable String sPhysicalName String sRootName String sDriverID Returns Boolean
87750>>>>>>>        Boolean bOpened bOK
87750>>>>>>>        Integer hToTable iIndex iRetval iVoid iOrgFreq
87750>>>>>>>        String sErrorFile sEmpty sPath
87750>>>>>>>
87750>>>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of 0 to hToTable
87753>>>>>>>        Get AutoConnectionIDLogin to bOK
87754>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
87756>>>>>>>            Send IncreaseSortBufferSize
87757>>>>>>>//            Send SetAllIndexesToBatch hToTable
87757>>>>>>>        End
87757>>>>>>>>
87757>>>>>>>
87757>>>>>>>        Move False to Err
87758>>>>>>>        Open sPhysicalName as hToTable
87760>>>>>>>        Get_Attribute DF_FILE_OPENED of hToTable to bOpened
87763>>>>>>>        If (bOpened = False) Begin
87765>>>>>>>            Function_Return False
87766>>>>>>>        End
87766>>>>>>>>
87766>>>>>>>
87766>>>>>>>        If (ghoStatusPanel <> 0) Begin
87768>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Copying Data for Table:" * sRootName * "Number:" * String(hFromTable))
87769>>>>>>>            Set piMinimum of ghoProgressBar to 0 
87770>>>>>>>            Set piMaximum of ghoProgressBar to 100 // 100%
87771>>>>>>>        End
87771>>>>>>>>
87771>>>>>>>
87771>>>>>>>        Move "" to sEmpty
87772>>>>>>>        Move False to Err
87773>>>>>>>        Move True to bOK
87774>>>>>>>        Set Private.phCurrentTable to hToTable
87775>>>>>>>
87775>>>>>>>        // No need to get the record identifier
87775>>>>>>>        Set_Attribute DF_FILE_GET_RID_AFTER_CREATE of hToTable to False        
87778>>>>>>>        Get_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
87781>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
87783>>>>>>>            // Remove all indices to speed up copying of data:
87783>>>>>>>            Call_Driver hToTable sDriverID Function CLI_DROPINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
87788>>>>>>>            If (iRetval <> 0) Begin
87790>>>>>>>                Error DFERR_PROGRAM ("Failed dropping indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
87791>>>>>>>>
87791>>>>>>>                Function_Return False
87792>>>>>>>            End
87792>>>>>>>>
87792>>>>>>>        End
87792>>>>>>>>
87792>>>>>>>
87792>>>>>>>        Move (sRootName + ".err") to sErrorFile
87793>>>>>>>        Move 0 to iIndex
87794>>>>>>>        Move False to Err
87795>>>>>>>        
87795>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
87797>>>>>>>            Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to 10
87800>>>>>>>            Call_Driver hToTable sDriverID Function CLI_BCP CallBack ghoDbUpdateHandler Passing iIndex sEmpty hFromTable Result iRetval
87805>>>>>>>            If (iRetval <> 0) Begin
87807>>>>>>>                Error DFERR_PROGRAM ("Failed copying data for table Number:" * String(hToTable) * "Name:" * String(sRootName))
87808>>>>>>>>
87808>>>>>>>                Function_Return False
87809>>>>>>>            End
87809>>>>>>>>
87809>>>>>>>        End 
87809>>>>>>>>
87809>>>>>>>        Else Begin
87810>>>>>>>            Copy_Records hFromTable to hToTable using 0 Callback ghoDbUpdateHandler
87813>>>>>>>        End
87813>>>>>>>>
87813>>>>>>>
87813>>>>>>>        If (Err = False) Begin
87815>>>>>>>            Get psHome of (phoWorkspace(ghoApplication)) to sPath
87816>>>>>>>            Get vDeleteFile (sPath + sErrorFile) to iRetval
87817>>>>>>>        End
87817>>>>>>>>
87817>>>>>>>
87817>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
87819>>>>>>>            // Recreate indices:
87819>>>>>>>            Call_Driver hToTable sDriverID Function CLI_CREATEINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
87824>>>>>>>            If (iRetval <> 0) Begin
87826>>>>>>>                Error DFERR_PROGRAM ("Failed creating indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
87827>>>>>>>>
87827>>>>>>>                Function_Return False
87828>>>>>>>            End
87828>>>>>>>>
87828>>>>>>>        End
87828>>>>>>>>
87828>>>>>>>
87828>>>>>>>        Close hToTable
87829>>>>>>>        Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
87832>>>>>>>
87832>>>>>>>        If (bOK = True) Begin
87834>>>>>>>            Move (not(Err)) to bOK
87835>>>>>>>        End
87835>>>>>>>>
87835>>>>>>>
87835>>>>>>>        If (ghoStatusPanel <> 0) Begin
87837>>>>>>>            Set TableName_Text of ghoStatusPanel to ""
87838>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
87839>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
87840>>>>>>>        End
87840>>>>>>>>
87840>>>>>>>
87840>>>>>>>        Function_Return (bOK = True)
87841>>>>>>>    End_Function
87842>>>>>>>
87842>>>>>>>    // The bANSI parameter's default value = True, meaning a table in ANSI format will be created.
87842>>>>>>>    // i.e. DF_FILE_TABLE_CHARACTER_FORMAT {"OEM"|"ANSI"}
87842>>>>>>>    Function ApiTableCreate Handle hTable String sRootName String sDisplayName String sLogicalName Boolean bUseConnectionID Boolean bANSI Boolean bRecnum tAPIColumn[] aColumnIn Returns Boolean
87844>>>>>>>        Handle hFile
87844>>>>>>>        String sConnectionID sPhysicalFile sANSI_OEM sVal sSchema sOriginalDriverID sDriverID sTableName
87844>>>>>>>        Integer iColumn iIdentityType iDataType iDbType iCount iSize
87844>>>>>>>        Boolean bOk bExists bSqlDriver bMertechDriver bDeleteDummy bExistsInFilelist bSysFile
87844>>>>>>>        tSQLConnection SQLConnection
87844>>>>>>>        tSQLConnection SQLConnection
87844>>>>>>>        tAPIColumn[] aColumns
87844>>>>>>>        tAPIColumn[] aColumns
87845>>>>>>>        tColumnType ColumnType
87845>>>>>>>        tColumnType ColumnType
87845>>>>>>>
87845>>>>>>>        // First check if the passed filenumber already exists; in case we do nothing
87845>>>>>>>        Get UtilTableExists hTable to bOk
87846>>>>>>>        If (bOk = True) Begin
87848>>>>>>>            Function_Return False
87849>>>>>>>        End
87849>>>>>>>>
87849>>>>>>>
87849>>>>>>>        Set Private.phCurrentTable to hTable
87850>>>>>>>        Move sLogicalName to sTableName
87851>>>>>>>        If (ghoProgressBar <> 0) Begin
87853>>>>>>>            Send DoAdvance of ghoProgressBar
87854>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Creating Table:" * String(sTableName) * "Number:" * String(hTable) * String(sLogicalName))
87855>>>>>>>        End
87855>>>>>>>>
87855>>>>>>>
87855>>>>>>>        Get UtilTableLogicalNameIsInUse sTableName to bExistsInFilelist
87856>>>>>>>        Get psDriverID to sDriverID
87857>>>>>>>        Get IsSQLDriver sDriverID to bSqlDriver
87858>>>>>>>        Get piDbType to iDbType
87859>>>>>>>
87859>>>>>>>        // If no columns passed in, we need to create a "dummy" column
87859>>>>>>>        Move False to bDeleteDummy
87860>>>>>>>        If (Num_Arguments = 8) Begin
87862>>>>>>>            Move aColumnIn to aColumns
87863>>>>>>>        End
87863>>>>>>>>
87863>>>>>>>        If ((SizeOfArray(aColumns)) = 0) Begin
87865>>>>>>>            Get UtilDFDataTypeToSqlTypeMapping sDriverID iDbType DF_BCD to ColumnType
87866>>>>>>>            Move ColumnType.iSQLType to iDataType
87867>>>>>>>            If (bRecnum = False) Begin
87869>>>>>>>                Move C_tAPIColumn_Identity to iIdentityType
87870>>>>>>>            End
87870>>>>>>>>
87870>>>>>>>            Else Begin
87871>>>>>>>                Move C_tAPIColumn_None     to iIdentityType
87872>>>>>>>            End
87872>>>>>>>>
87872>>>>>>>            Get _AppendAPIColumn aColumns "temp" iDataType 10 0 iIdentityType to aColumns
87873>>>>>>>            Move True to bDeleteDummy
87874>>>>>>>        End
87874>>>>>>>>
87874>>>>>>>
87874>>>>>>>        // If columns have been passed as an array we need to check if an identity column
87874>>>>>>>        // has been specified (aColumns[iCounter].iOptions = C_tAPIColumn_Identity), and
87874>>>>>>>        // if so auto-set the bRecnum to FALSE. This is because else there would be
87874>>>>>>>        // two identity columns and SQL doesn't like that and throws an error.
87874>>>>>>>        If (bRecnum = True and (SizeOfArray(aColumns)) <> 0) Begin
87876>>>>>>>            Move (SizeOfArray(aColumns)) to iSize
87877>>>>>>>            Decrement iSize
87878>>>>>>>            for iCount from 0 to iSize
87884>>>>>>>>
87884>>>>>>>                If (aColumns[iCount].iOptions = C_tAPIColumn_Identity) Begin
87886>>>>>>>                    Move False to bRecnum
87887>>>>>>>                    Move iSize to iCount
87888>>>>>>>                End
87888>>>>>>>>
87888>>>>>>>            Loop
87889>>>>>>>>
87889>>>>>>>        End
87889>>>>>>>>
87889>>>>>>>
87889>>>>>>>        // If this is a SQL based driver we also check if the table exists
87889>>>>>>>        // in the SQL back end; in case we do nothing.
87889>>>>>>>        If (bSqlDriver = True) Begin
87891>>>>>>>            // Get all connection properties
87891>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
87892>>>>>>>            Move SQLConnection.sSchema to sSchema
87893>>>>>>>            If (sSchema = "") Begin
87895>>>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
87896>>>>>>>            End
87896>>>>>>>>
87896>>>>>>>
87896>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
87897>>>>>>>            // It can happen that the table is missing from Filelist.cfg but still
87897>>>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
87897>>>>>>>            If (bExists = False) Begin
87899>>>>>>>                Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
87900>>>>>>>            End
87900>>>>>>>>
87900>>>>>>>            // If the table exists on the SQL back-end but not in Filelist.cfg,
87900>>>>>>>            // we will just add it to Filelist.cfg
87900>>>>>>>            If (bExists = True) Begin
87902>>>>>>>                If (bExistsInFilelist = False) Begin
87904>>>>>>>                    If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
87906>>>>>>>                        Move (sDriverID + ":" + sRootName) to sRootName
87907>>>>>>>                    End
87907>>>>>>>>
87907>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
87910>>>>>>>                    Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
87913>>>>>>>                    Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
87916>>>>>>>                    Move False to bSysFile
87917>>>>>>>                    Get SqlUtilCreateIntFile hTable sDriverID SQLConnection.sConnectionID bANSI bSysFile to bOK
87918>>>>>>>                End
87918>>>>>>>>
87918>>>>>>>                Function_Return False
87919>>>>>>>            End
87919>>>>>>>>
87919>>>>>>>        End
87919>>>>>>>>
87919>>>>>>>
87919>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
87920>>>>>>>        If (num_arguments > 6) Begin
87922>>>>>>>            If (bANSI = False) Begin
87924>>>>>>>                Move CS_OEM_Txt to sANSI_OEM
87925>>>>>>>            End
87925>>>>>>>>
87925>>>>>>>        End
87925>>>>>>>>
87925>>>>>>>
87925>>>>>>>        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
87925>>>>>>>        // is a programmer's error and we auto-correct for it here.
87925>>>>>>>        // This is also a bit messy. If a Mertech driver is used and we want to create a new table,
87925>>>>>>>        // we first need to create it as embedded (DataFlex) and then convert it to SQL (!)
87925>>>>>>>        // So we set the driver ID temporarily to "DataFlex" to get the table created as embedded and later
87925>>>>>>>        // set it back and use a Mertech function to convert it to SQL.
87925>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
87926>>>>>>>        If (bMertechDriver = True) Begin
87928>>>>>>>            If (bUseConnectionID = True) Begin
87930>>>>>>>                Move False to bUseConnectionID
87931>>>>>>>            End
87931>>>>>>>>
87931>>>>>>>            Move sDriverID to sOriginalDriverID
87932>>>>>>>            Move DATAFLEX_ID to sDriverID
87933>>>>>>>        End
87933>>>>>>>>
87933>>>>>>>
87933>>>>>>>        Move False to Err
87934>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
87936>>>>>>>            Move sRootName to sPhysicalFile
87937>>>>>>>        End
87937>>>>>>>>
87937>>>>>>>
87937>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
87939>>>>>>>            Move SQLConnection.sConnectionID to sConnectionID
87940>>>>>>>
87940>>>>>>>            // If DAW driver and we should use a connection id we need to
87940>>>>>>>            // check if the connection ID exists; else we create it before attempting creating the table
87940>>>>>>>            If (bMertechDriver = False and bUseConnectionID = True) Begin
87942>>>>>>>                Get IsConnectionID sConnectionID sDriverID to bExists
87943>>>>>>>                If (bExists = False) Begin
87945>>>>>>>                    Get UtilCreateConnectionID sConnectionID to bOk
87946>>>>>>>                    If (bOk = False) Begin
87948>>>>>>>                        Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
87949>>>>>>>>
87949>>>>>>>                        Function_Return False
87950>>>>>>>                    End
87950>>>>>>>>
87950>>>>>>>                End
87950>>>>>>>>
87950>>>>>>>            End
87950>>>>>>>>
87950>>>>>>>
87950>>>>>>>            If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
87952>>>>>>>                Move (sTableName + ".int") to sPhysicalFile
87953>>>>>>>            End
87953>>>>>>>>
87953>>>>>>>            Else Begin
87954>>>>>>>                Move (sRootName + ".int") to sPhysicalFile
87955>>>>>>>            End
87955>>>>>>>>
87955>>>>>>>            Move (Uppercase(sDisplayName)) to sVal
87956>>>>>>>            If (not(sVal contains (sSchema + "."))) Begin
87958>>>>>>>                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
87959>>>>>>>            End
87959>>>>>>>>
87959>>>>>>>        End
87959>>>>>>>>
87959>>>>>>>        Move False to Err
87960>>>>>>>        Move 0 to hFile
87961>>>>>>>
87961>>>>>>>        Structure_Start hFile sDriverID
87962>>>>>>>            If (sDriverID <> DATAFLEX_ID) Begin
87964>>>>>>>                If (bUseConnectionID = True) Begin
87966>>>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to (CS_DFCONNID + "=" + sConnectionID)
87969>>>>>>>                End
87969>>>>>>>>
87969>>>>>>>                Else Begin
87970>>>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to SQLConnection.sConnectionString
87973>>>>>>>                End
87973>>>>>>>>
87973>>>>>>>                Set_Attribute DF_FILE_TABLE_NAME               of hFile to sTableName
87976>>>>>>>                Set_Attribute DF_FILE_USE_DUMMY_ZERO_DATE      of hFile to True
87979>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT   of hFile to sANSI_OEM
87982>>>>>>>                Set_Attribute DF_FILE_RECNUM_TABLE             of hFile to bRecnum
87985>>>>>>>
87985>>>>>>>                If (sSchema <> "") Begin
87987>>>>>>>                    Set_Attribute DF_FILE_OWNER                of hFile to sSchema
87990>>>>>>>                End
87990>>>>>>>>
87990>>>>>>>
87990>>>>>>>                If (sDriverID = DB2_DRV_ID) Begin
87992>>>>>>>                    If (SQLConnection.sLongTableSpace <> "") Begin
87994>>>>>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hFile to SQLConnection.sLongTableSpace
87997>>>>>>>                    End
87997>>>>>>>>
87997>>>>>>>                End
87997>>>>>>>>
87997>>>>>>>                If (sDriverID = DB2_DRV_ID or sDriverID = ORAFLEX or sDriverID = MDSPgSQL) Begin
87999>>>>>>>                    If (SQLConnection.sBaseTableSpace <> "") Begin
88001>>>>>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hFile to SQLConnection.sBaseTableSpace
88004>>>>>>>                    End
88004>>>>>>>>
88004>>>>>>>                    If (SQLConnection.sIndexTableSpace <> "") Begin
88006>>>>>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hFile to SQLConnection.sIndexTableSpace
88009>>>>>>>                    End
88009>>>>>>>>
88009>>>>>>>                End
88009>>>>>>>>
88009>>>>>>>            End
88009>>>>>>>>
88009>>>>>>>
88009>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hFile to sPhysicalFile
88012>>>>>>>            Get ApiColumnsAddToTable hFile aColumns True to bOk
88013>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88014>>>>>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88016>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88017>>>>>>>
88017>>>>>>>        // If Mertech driver we convert the newly created embedded table (DataFlex) to SQL
88017>>>>>>>        If (bMertechDriver = True) Begin
88019>>>>>>>            Move sOriginalDriverID to sDriverID
88020>>>>>>>            If (not(sVal contains (sSchema + "."))) Begin
88022>>>>>>>                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
88023>>>>>>>            End
88023>>>>>>>>
88023>>>>>>>            // Note: This function also sets the Err flag.
88023>>>>>>>            Get _MertechApiTableConvertToSQL hTable sRootName SQLConnection.sDatabase sDriverID SQLConnection.sBaseTableSpace SQLConnection.sIndexTableSpace False to bOK
88024>>>>>>>        End
88024>>>>>>>>
88024>>>>>>>
88024>>>>>>>        Move (not(Err)) to bOK
88025>>>>>>>        If (bOk = True) Begin
88027>>>>>>>            If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
88029>>>>>>>                Move (sDriverID + ":" + sRootName) to sRootName
88030>>>>>>>            End
88030>>>>>>>>
88030>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
88033>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
88036>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
88039>>>>>>>
88039>>>>>>>            // Lastly we remove the temporary column we created above, if all went well.
88039>>>>>>>            If (bDeleteDummy) Begin
88041>>>>>>>                Get ApiColumnRemove hTable "temp" to bOk
88042>>>>>>>            End
88042>>>>>>>>
88042>>>>>>>        End
88042>>>>>>>>
88042>>>>>>>
88042>>>>>>>        Close hTable
88043>>>>>>>        Function_Return (bOK = True)
88044>>>>>>>    End_Function
88045>>>>>>>
88045>>>>>>>    Function ApiTableCreateAlias String sFileName String sDisplayName String sAliasName Integer iFilelistSlot Returns Boolean
88047>>>>>>>        Move False to Err
88048>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of iFilelistSlot to sFileName
88051>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of iFilelistSlot to sDisplayName
88054>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of iFilelistSlot to sAliasName
88057>>>>>>>
88057>>>>>>>        Function_Return (Err = False)
88058>>>>>>>    End_Function
88059>>>>>>>
88059>>>>>>>    // ToDo: Needs to be revised
88059>>>>>>>    Procedure ApiTableCreateFromDEF String sPath String sFileName String sTableName String sDisplayName Integer iFilelistSlot
88061>>>>>>>        Handle hTable
88061>>>>>>>        String sDEFName sDataPath
88061>>>>>>>        Boolean bExists
88061>>>>>>>
88061>>>>>>>        // Do nothing if MSSQL Driver.
88061>>>>>>>//        Get IsMSSQLDriver to bExists
88061>>>>>>>//        If (bExists = True) Begin
88061>>>>>>>//            Procedure_Return
88061>>>>>>>//        End
88061>>>>>>>
88061>>>>>>>        Get psDataPathFirstPart to sDataPath
88062>>>>>>>        Get vFilePathExists (sDataPath + sFileName + ".dat") to bExists
88063>>>>>>>        If (bExists = True) Begin
88065>>>>>>>            // We also needs to check if it is an Alias file, in case the sFileName.dat exists, but it may
88065>>>>>>>            // still be missing from the filelist and needs to be added.
88065>>>>>>>            Get UtilTableNumberIsInUse iFilelistSlot to bExists
88066>>>>>>>            If (bExists = True) Begin
88068>>>>>>>                Procedure_Return
88069>>>>>>>            End
88069>>>>>>>>
88069>>>>>>>            // Do _not_ use the DEF file if an alias, it will overwrite the base table data.
88069>>>>>>>            Else Begin
88070>>>>>>>                Set_Attribute DF_FILE_ROOT_NAME    of iFilelistSlot to sFileName
88073>>>>>>>                Set_Attribute DF_FILE_LOGICAL_NAME of iFilelistSlot to sTableName
88076>>>>>>>                Set_Attribute DF_FILE_DISPLAY_NAME of iFilelistSlot to sDisplayName
88079>>>>>>>                Procedure_Return
88080>>>>>>>            End
88080>>>>>>>>
88080>>>>>>>        End
88080>>>>>>>>
88080>>>>>>>
88080>>>>>>>        Move (sPath + sFileName + ".def") to sDEFName
88081>>>>>>>        Move 0 to hTable
88082>>>>>>>        Move False to Err
88083>>>>>>>
88083>>>>>>>        Structure_Start hTable DATAFLEX_ID
88084>>>>>>>            Load_Def sDEFName Onto hTable
88085>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hTable to sFileName
88088>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88089>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88091>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88092>>>>>>>
88092>>>>>>>        Move iFilelistSlot to hTable
88093>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sFileName
88096>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
88099>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
88102>>>>>>>
88102>>>>>>>    End_Procedure
88103>>>>>>>
88103>>>>>>>    Function ApiTableMoveToFileSlot Integer iFromFileSlot Integer iToFileSlot String sDriverID Returns Boolean
88105>>>>>>>        Boolean bTmp bErr bOK
88105>>>>>>>        String sTableName sDisplayName sFileName
88105>>>>>>>
88105>>>>>>>        // We preserve the value of the Err flag, by saving its current state and resetting it before end of function.
88105>>>>>>>        Move Err to bTmp
88106>>>>>>>        Move False to Err
88107>>>>>>>
88107>>>>>>>        Get AutoConnectionIDLogin to bOK
88108>>>>>>>        // First get the info for the current filelist slot:
88108>>>>>>>        Open iFromFileSlot
88110>>>>>>>        Get_Attribute DF_FILE_OPENED of iFromFileSlot to bOK
88113>>>>>>>        If (bOK = True) Begin
88115>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to sFileName
88118>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to sTableName
88121>>>>>>>            Get_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to sDisplayName
88124>>>>>>>
88124>>>>>>>            //...then move it.
88124>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iToFileSlot to sFileName
88127>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iToFileSlot to sTableName
88130>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iToFileSlot to sDisplayName
88133>>>>>>>
88133>>>>>>>            //...and finally remove the old filelist values.
88133>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to ""
88136>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to ""
88139>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to ""
88142>>>>>>>        End
88142>>>>>>>>
88142>>>>>>>        Close iFromFileSlot
88143>>>>>>>
88143>>>>>>>        Move Err to bErr
88144>>>>>>>        Move bTmp to Err
88145>>>>>>>        Function_Return (bErr = False)
88146>>>>>>>    End_Function
88147>>>>>>>
88147>>>>>>>    Function ApiTableRelate Handle hTableFrom Handle hTableTo Integer iColumnFrom Integer iColumnTo Returns Boolean
88149>>>>>>>        Handle hTable
88149>>>>>>>        Boolean bOK
88149>>>>>>>        String sDriverID
88149>>>>>>>
88149>>>>>>>        Get AutoConnectionIDLogin to bOK
88150>>>>>>>        Move False to Err
88151>>>>>>>        Open hTableFrom Mode DF_EXCLUSIVE
88153>>>>>>>        If (hTableTo > 0) Begin
88155>>>>>>>            Open hTableTo
88157>>>>>>>        End
88157>>>>>>>>
88157>>>>>>>        Move hTableFrom to hTable
88158>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88161>>>>>>>        Set Private.phCurrentTable to hTable
88162>>>>>>>
88162>>>>>>>        Structure_Start hTable sDriverID            
88163>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumnFrom to hTableTo
88166>>>>>>>            If (iColumnTo <> 0) Begin
88168>>>>>>>                Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumnFrom to iColumnTo
88171>>>>>>>            End
88171>>>>>>>>
88171>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88172>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88174>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88175>>>>>>>
88175>>>>>>>        If (hTableTo > 0) Begin
88177>>>>>>>            Close hTableTo
88178>>>>>>>        End
88178>>>>>>>>
88178>>>>>>>
88178>>>>>>>        Function_Return (Err = False)
88179>>>>>>>    End_Function
88180>>>>>>>
88180>>>>>>>    // Removes the passed table name completely from disk, filelist (& Sql Server if an Sql-driver)
88180>>>>>>>    Function ApiTableRemove Handle hTable Returns Boolean
88182>>>>>>>        String sTableName sDriverID
88182>>>>>>>        Boolean bOk
88182>>>>>>>        String sDataPath
88182>>>>>>>
88182>>>>>>>        Get AutoConnectionIDLogin to bOK
88183>>>>>>>        Move False to Err
88184>>>>>>>        Get psDriverID to sDriverID
88185>>>>>>>        Get UtilTableHandleToString hTable sDriverID to sTableName
88186>>>>>>>        If (sTableName = "") Begin
88188>>>>>>>            Function_Return False
88189>>>>>>>        End
88189>>>>>>>>
88189>>>>>>>
88189>>>>>>>        Set Private.phCurrentTable to hTable
88190>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
88191>>>>>>>        Delete_db sTableName
88192>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
88193>>>>>>>
88193>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
88195>>>>>>>            Get SqlTableRemoveByTableName sDriverID sTableName to bOk
88196>>>>>>>            Get psDataPathFirstPart to sDataPath
88197>>>>>>>            Get vDeleteFile (sDataPath + sTableName + ".int") to bOk
88198>>>>>>>        End
88198>>>>>>>>
88198>>>>>>>        // Also remove table from filelist.cfg in case the physical file didn't exist.
88198>>>>>>>        If (hTable <> 0) Begin
88200>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
88203>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
88206>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
88209>>>>>>>        End
88209>>>>>>>>
88209>>>>>>>
88209>>>>>>>        Close hTable
88210>>>>>>>        Function_Return (hTable <> 0)
88211>>>>>>>    End_Function
88212>>>>>>>
88212>>>>>>>    Function ApiTableRemoveRelation Handle hTableTo Integer iColumn Returns Boolean
88214>>>>>>>        Handle hTable
88214>>>>>>>        Boolean bOK
88214>>>>>>>
88214>>>>>>>        Get AutoConnectionIDLogin to bOK
88215>>>>>>>        Move False to Err
88216>>>>>>>        Open hTableTo Mode DF_EXCLUSIVE
88218>>>>>>>        Move hTableTo to hTable
88219>>>>>>>
88219>>>>>>>        Structure_Start hTable
88220>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to 0
88223>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88224>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88226>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88227>>>>>>>
88227>>>>>>>        Close hTableTo
88228>>>>>>>        Function_Return (Err = False)
88229>>>>>>>    End_Function
88230>>>>>>>
88230>>>>>>>    Function ApiTableRename Integer hTable String sRootName String sDisplayName String sLogicalName Returns Boolean
88232>>>>>>>        String sPhysicalName sRootNameTo sLogicalNameTo sDataPath sDriverID sSchema sPhysicalNameTo
88232>>>>>>>        Boolean bOK bExists bOpened     
88232>>>>>>>        tAPITableNameInfo APITableNameInfo
88232>>>>>>>        tAPITableNameInfo APITableNameInfo
88232>>>>>>>        
88232>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
88235>>>>>>>        If (bOpened = False) Begin
88237>>>>>>>            Get OpenTableExclusive hTable to bOpened
88238>>>>>>>            If (bOpened = False) Begin
88240>>>>>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
88241>>>>>>>                Function_Return False
88242>>>>>>>            End
88242>>>>>>>>
88242>>>>>>>        End
88242>>>>>>>>
88242>>>>>>>
88242>>>>>>>        Set Private.phCurrentTable to hTable
88243>>>>>>>        Move hTable         to APITableNameInfo.iTableNumber
88244>>>>>>>        Move sRootName      to APITableNameInfo.sRootName
88245>>>>>>>        Move sLogicalName   to APITableNameInfo.sLogicalName
88246>>>>>>>        Move sDisplayName   to APITableNameInfo.sDisplayName
88247>>>>>>>        Get ApiTableFilelistNamesCompare True APITableNameInfo to bExists
88248>>>>>>>        If (bExists = True) Begin
88250>>>>>>>            Function_Return True
88251>>>>>>>        End
88251>>>>>>>>
88251>>>>>>>        
88251>>>>>>>        Set Private.phCurrentTable to hTable
88252>>>>>>>        Move False to Err  
88253>>>>>>>        Get psDataPathFirstPart to sDataPath
88254>>>>>>>        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName
88257>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
88260>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
88263>>>>>>>
88263>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88266>>>>>>>        Close hTable
88267>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
88269>>>>>>>            Get vFilePathExists (sDataPath + sRootNameTo + ".dat") to bExists
88270>>>>>>>            If (bExists = True) Begin
88272>>>>>>>                If (Uppercase(sRootName) <> Uppercase(sRootNameTo)) Begin
88274>>>>>>>                    Copy_db (sDataPath + sRootNameTo) to (sDataPath + sRootName)
88277>>>>>>>                    // We need a short break here before attempting to delete the physical old files or Windows
88277>>>>>>>                    // might report "File in use..." and the deletion will fail.
88277>>>>>>>                    Sleep 2
88278>>>>>>>                    Get vDeleteFile (sDataPath + sRootNameTo + ".*") to bOK
88279>>>>>>>                End
88279>>>>>>>>
88279>>>>>>>            End
88279>>>>>>>>
88279>>>>>>>        End
88279>>>>>>>>
88279>>>>>>>
88279>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin           
88281>>>>>>>            If (not(sPhysicalName contains ".")) Begin
88283>>>>>>>                Move (sPhysicalName + String(".int")) to sPhysicalName
88284>>>>>>>            End
88284>>>>>>>>
88284>>>>>>>            
88284>>>>>>>            // Change the table name in the .int file to the new table new:
88284>>>>>>>            Get UtilChangeSourceCodeLine (sDataPath + sPhysicalName) (CS_DATABASE_NAME * String(sLogicalNameTo)) (CS_DATABASE_NAME * String(sLogicalName)) False to bOK
88285>>>>>>>            If (bOK = False) Begin
88287>>>>>>>                Function_Return False
88288>>>>>>>            End
88288>>>>>>>>
88288>>>>>>>            
88288>>>>>>>            // Change table name at the SQL side:
88288>>>>>>>            Get psSchema to sSchema
88289>>>>>>>            Get SqlTableRename hTable sLogicalNameTo sLogicalName to bOK 
88290>>>>>>>            
88290>>>>>>>            Get _TableNameOnly sRootName to sPhysicalNameTo
88291>>>>>>>            // Remove cache file and Rename the physical file names:
88291>>>>>>>            Get vDeleteFile (sDataPath + sPhysicalNameTo + ".cch")                                  to bOK 
88292>>>>>>>            Get vRenameFile (sDataPath + sPhysicalName)            (sDataPath + sRootName + ".int") to bOK
88293>>>>>>>            Get vRenameFile (sDataPath + sPhysicalNameTo + ".tag") (sDataPath + sRootName + ".tag") to bOK
88294>>>>>>>            Move (sDriverID + ":" + sRootName) to sRootName         
88295>>>>>>>            If (not(sDisplayName contains ".")) Begin
88297>>>>>>>                Move (sSchema + "." + sDisplayName) to sDisplayName
88298>>>>>>>            End
88298>>>>>>>>
88298>>>>>>>        End
88298>>>>>>>>
88298>>>>>>>
88298>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
88301>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
88304>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
88307>>>>>>>
88307>>>>>>>        Function_Return (Err = False)
88308>>>>>>>    End_Function
88309>>>>>>>
88309>>>>>>>    Function ApiTableRenameAlias Integer hTable String sDisplayName String sLogicalName Returns Boolean
88311>>>>>>>        Move False to Err
88312>>>>>>>        Set Private.phCurrentTable to hTable
88313>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
88316>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
88319>>>>>>>
88319>>>>>>>        Function_Return (Err = False)
88320>>>>>>>    End_Function
88321>>>>>>>
88321>>>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
88321>>>>>>>    // Note that it first removes any driver prefixes in the rootname.
88321>>>>>>>    Function ApiTableFilelistNamesCompare Boolean bCompareFilelistUppercase tAPITableNameInfo APITableInfo Returns Boolean
88323>>>>>>>        String sRootNameFrom sRootNameTo sDisplayNameTo sLogicalNameTo
88323>>>>>>>        Handle hTable
88323>>>>>>>        Boolean bIsSame
88323>>>>>>>
88323>>>>>>>        Move APITableInfo.iTableNumber      to hTable
88324>>>>>>>        Get _TableNameOnly APITableInfo.sRootName     to sRootNameFrom
88325>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
88328>>>>>>>        Get _TableNoPrefix sRootNameTo                to sRootNameTo
88329>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
88332>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayNameTo
88335>>>>>>>        Get _TableNoPrefix sDisplayNameTo             to sDisplayNameTo
88336>>>>>>>
88336>>>>>>>        If (bCompareFilelistUppercase = True) Begin
88338>>>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(APITableInfo.sLogicalName) = Uppercase(sLogicalNameTo) and ;                  Uppercase(APITableInfo.sDisplayName) = Uppercase(sDisplayNameTo)) to bIsSame
88339>>>>>>>        End
88339>>>>>>>>
88339>>>>>>>        Else Begin
88340>>>>>>>            Move (sRootNameFrom = sRootNameTo and APITableInfo.sLogicalName = sLogicalNameTo and APITableInfo.sDisplayName = sDisplayNameTo) to bIsSame
88341>>>>>>>        End
88341>>>>>>>>
88341>>>>>>>
88341>>>>>>>        Function_Return bIsSame
88342>>>>>>>    End_Function
88343>>>>>>>    
88343>>>>>>>    // Note: This table update function does _not_ convert an embedded table to SQL. Use function ApiTableConvertToSQL first for that.
88343>>>>>>>    Function ApiTableUpdate tAPITableNameInfo APITableNameInfoFrom tAPIColumn[] aColumnsFrom tAPIIndex[] aIndexesFrom tAPIRelation[] aRelationsFrom Returns Boolean
88345>>>>>>>        Handle hFile hTable
88345>>>>>>>        String sTableName sLogicalName sDisplayName
88345>>>>>>>        String sConnectionID sVal sSchema sOriginalDriverID sDriverIDFrom sDriverIDTo sRootName
88345>>>>>>>        Integer iColumn iDbType
88345>>>>>>>        Boolean bOk bExists bMertechDriver bExistsInFilelist bOpened bApiTableUpdateAuto
88345>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase bTableExists
88345>>>>>>>        Boolean bIsSame bSameTableNames bFilelistError bIsAliasFrom bIsAliasTo bIsSQLTableFrom bIsSQLTableTo
88345>>>>>>>        tSQLConnection SQLConnection
88345>>>>>>>        tSQLConnection SQLConnection
88345>>>>>>>        tAPITable      APITableFrom APITableTo
88345>>>>>>>        tAPITable      APITableFrom APITableTo
88345>>>>>>>        tColumnType    ColumnType
88345>>>>>>>        tColumnType    ColumnType
88345>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
88345>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
88346>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
88346>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
88347>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
88347>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
88348>>>>>>>
88348>>>>>>>        // We don't allow update of the framework's DbVersion table.
88348>>>>>>>        If (Lowercase(sTableName) = "dbversion") Begin
88350>>>>>>>            Function_Return False
88351>>>>>>>        End
88351>>>>>>>>
88351>>>>>>>        
88351>>>>>>>        Move APITableNameInfoFrom.sDriverID     to sDriverIDFrom
88352>>>>>>>        Get piDbType                            to iDbType
88353>>>>>>>        Get pbRecnum                            to bRecnum
88354>>>>>>>        Get pbToANSI                            to bToANSI
88355>>>>>>>        Get pbCopyData                          to bCopyData
88356>>>>>>>        Get pbApiTableUpdateAuto                to bApiTableUpdateAuto
88357>>>>>>>        Get pbCompareDate_DateTime              to bCompareDate_DateTime
88358>>>>>>>        Get pbCompareIndexAscending             to bCompareIndexAscending
88359>>>>>>>        Get pbCompareIndexUppercase             to bCompareIndexUppercase   
88360>>>>>>>        Get IsMertechDriver sDriverIDFrom       to bMertechDriver
88361>>>>>>>        Get pbUseConnectionID                   to bUseConnectionID
88362>>>>>>>        If (bMertechDriver = True and bUseConnectionID = True) Begin
88364>>>>>>>            Move False                          to bUseConnectionID
88365>>>>>>>        End
88365>>>>>>>>
88365>>>>>>>
88365>>>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
88366>>>>>>>        Set Private.phCurrentTable              to hTable
88367>>>>>>>        Get UtilTableExists  hTable             to bTableExists     
88368>>>>>>>        
88368>>>>>>>        If (ghoProgressBar <> 0) Begin
88370>>>>>>>            Send DoAdvance of ghoProgressBar
88371>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
88372>>>>>>>        End
88372>>>>>>>>
88372>>>>>>>
88372>>>>>>>        Move APITableNameInfoFrom.bIsAlias      to bIsAliasFrom
88373>>>>>>>        Move APITableNameInfoFrom.bIsSQL        to bIsSQLTableFrom
88374>>>>>>>        Get UtilDriverFromTableNumber hTable    to sDriverIDTo
88375>>>>>>>        Get UtilTableIsSQL   hTable             to bIsSQLTableTo
88376>>>>>>>        Move True                               to APITableFrom.bFromTable
88377>>>>>>>        Move hTable                             to APITableFrom.hTable
88378>>>>>>>        Move APITableNameInfoFrom               to APITableFrom.ApiTableInfo
88379>>>>>>>        Move aColumnsFrom                       to APITableFrom.aApiColumns
88380>>>>>>>        Move aIndexesFrom                       to APITableFrom.aApiIndexes
88381>>>>>>>        Move aRelationsFrom                     to APITableFrom.aApiRelations
88382>>>>>>>        
88382>>>>>>>        If (bTableExists = True) Begin
88384>>>>>>>            Get OpenTableExclusive hTable to bOpened
88385>>>>>>>            If (bOpened = False) Begin
88387>>>>>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
88388>>>>>>>                Function_Return False
88389>>>>>>>            End
88389>>>>>>>>
88389>>>>>>>            Get UtilTableStructFill hTable False                                                        to APITableTo
88390>>>>>>>            Get UtilColumnCombineFromAndToArrays APITableFrom.aApiColumns     APITableTo.aApiColumns    to aAPIColumnCompare
88391>>>>>>>            Get UtilIndexCombineFromAndToArrays  APITableFrom.aApiIndexes     APITableTo.aApiIndexes    to aAPIIndexCompare
88392>>>>>>>            Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations  to aAPIRelationCompare
88393>>>>>>>        End
88393>>>>>>>>
88393>>>>>>>        
88393>>>>>>>        Move False to Err
88394>>>>>>>        Case Begin
88394>>>>>>>            // Alias table:
88394>>>>>>>            Case (bIsAliasFrom = True)
88396>>>>>>>                Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
88397>>>>>>>                Case Break
88398>>>>>>>            
88398>>>>>>>            // New Table:
88398>>>>>>>            Case (bTableExists = False)
88401>>>>>>>                Get ApiTableCreate      hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName bUseConnectionID bToANSI bRecnum aColumnsFrom to bOk
88402>>>>>>>                Get UtilIndexesUpdate   hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
88403>>>>>>>                Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
88404>>>>>>>                Case Break
88405>>>>>>>    
88405>>>>>>>            // Update table:    
88405>>>>>>>            Case (bTableExists = True)
88408>>>>>>>                Get UtilTableCompare APITableFrom APITableTo False (&bFilelistError) to bIsSame
88409>>>>>>>                If (bIsSame = True) Begin
88411>>>>>>>                    Case Break
88412>>>>>>>                End
88412>>>>>>>>
88412>>>>>>>                If (bFilelistError = True) Begin
88414>>>>>>>                    Get ApiTableRename hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName to bOk
88415>>>>>>>                    If (bOk = False) Begin
88417>>>>>>>                        Case Break
88418>>>>>>>                    End
88418>>>>>>>>
88418>>>>>>>                End
88418>>>>>>>>
88418>>>>>>>
88418>>>>>>>                If (ghoProgressBar <> 0) Begin
88420>>>>>>>                    Send DoAdvance of ghoProgressBar
88421>>>>>>>                    Set TableName_Text of ghoStatusPanel to ("Updating Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
88422>>>>>>>                End
88422>>>>>>>>
88422>>>>>>>        
88422>>>>>>>                // Columns:            
88422>>>>>>>                Move True to bOk
88423>>>>>>>                Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
88424>>>>>>>                If (bIsSame = False) Begin
88426>>>>>>>                    Get ApiColumnsUpdate sDriverIDFrom hTable bIsSQLTableFrom APITableFrom.aApiColumns APITableTo.aApiColumns bCompareDate_DateTime to bOk
88427>>>>>>>                End
88427>>>>>>>>
88427>>>>>>>                If (bOk = False) Begin
88429>>>>>>>                    Case Break
88430>>>>>>>                End
88430>>>>>>>>
88430>>>>>>>
88430>>>>>>>                // Indexes:
88430>>>>>>>                Get UtilIndexesCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
88431>>>>>>>                If (bIsSame = False) Begin
88433>>>>>>>                    Get UtilIndexesUpdate hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
88434>>>>>>>                End
88434>>>>>>>>
88434>>>>>>>                
88434>>>>>>>                // Relations:
88434>>>>>>>                Get UtilRelationsCompare hTable aAPIRelationCompare to bIsSame
88435>>>>>>>                If (bIsSame = False) Begin
88437>>>>>>>                    Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
88438>>>>>>>                    If (bOk = False) Begin
88440>>>>>>>                        Case Break
88441>>>>>>>                    End
88441>>>>>>>>
88441>>>>>>>                End                                                               
88441>>>>>>>>
88441>>>>>>>                
88441>>>>>>>                // Filelist Names:
88441>>>>>>>                Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
88442>>>>>>>                Case Break
88443>>>>>>>
88443>>>>>>>            Case Else
88443>>>>>>>                Error DFERR_PROGRAM "Unknown Case structure exit in Function ApiTableUpdate"
88444>>>>>>>>
88444>>>>>>>                Move False to bOk
88445>>>>>>>        Case End                     
88445>>>>>>>
88445>>>>>>>        Close hTable
88446>>>>>>>        Set TableName_Text of ghoStatusPanel to ""
88447>>>>>>>
88447>>>>>>>        Function_Return (bOK = True)
88448>>>>>>>    End_Function
88449>>>>>>>    
88449>>>>>>>    // Replaces all date values with CS_DUFLowestAllowedDateValue for all tables in Filelist.cfg,
88449>>>>>>>    // _except_ those tables that has been excluded with the "ApiTableDateCorrectionAddException" message.
88449>>>>>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.               
88449>>>>>>>    // This is for prepairing embedded tables (*.dat) before an SQL conversion.
88449>>>>>>>    //
88449>>>>>>>    // The root of the problem is the following:
88449>>>>>>>    // The data type Date in SQL has a range of accepted values from 01-01-0001 through 12-31-9999
88449>>>>>>>    // while the data type DateTime has a range of accepted values from 01-01-1753 through 12-31-9999
88449>>>>>>>    // So if you happen to have a Date from before 1753, or an empty / NULL value - this will be outside 
88449>>>>>>>    // the range that DateTime can handle and if you then try to change a Date column to a DateTime,
88449>>>>>>>    // an SQL error will be thrown;
88449>>>>>>>    // "The conversion of a date data type to a datetime data type resulted in an out-of-range value".
88449>>>>>>>    Function ApiTableFixAllDateBogusValues Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
88451>>>>>>>        Boolean bOK bIsAlias bIsSQL
88451>>>>>>>        Integer iCount iSize iDateSize iItems
88451>>>>>>>        Handle hTable                        
88451>>>>>>>        String sLogicalName
88451>>>>>>>        Integer[] aTablesToCheck aDateFields
88453>>>>>>>        
88453>>>>>>>        Get _AllTablesDateCorrections to aTablesToCheck
88454>>>>>>>        Move (SizeOfArray(aTablesToCheck)) to iSize
88455>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
88456>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
88457>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
88458>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
88459>>>>>>>
88459>>>>>>>        Move True to bOK
88460>>>>>>>        Decrement iSize
88461>>>>>>>        for iCount from 0 to iSize
88467>>>>>>>>
88467>>>>>>>            Move aTablesToCheck[iCount] to hTable 
88468>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
88469>>>>>>>            Get UtilTableIsAlias hTable to bIsAlias
88470>>>>>>>            Get UtilTableIsSql   hTable to bIsSQL
88471>>>>>>>            
88471>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
88474>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Processing Table Number:" * String(hTable) * "Name:" * String(sLogicalName))
88475>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
88476>>>>>>>
88476>>>>>>>            If (bIsAlias = False and bIsSQL = False) Begin
88478>>>>>>>                Get UtilCheckForDateFields hTable to aDateFields
88479>>>>>>>                Move (SizeOfArray(aDateFields)) to iDateSize
88480>>>>>>>                If (iDateSize > 0) Begin
88482>>>>>>>                    Get UtilTableCorrectBogusDateValues hTable aDateFields bFixZeroDates bResetIndexesToOnLine to bOK
88483>>>>>>>                    Close hTable                                     
88484>>>>>>>                End
88484>>>>>>>>
88484>>>>>>>            End  
88484>>>>>>>>
88484>>>>>>>        Loop
88485>>>>>>>>
88485>>>>>>>        
88485>>>>>>>        Close DF_ALL
88486>>>>>>>        Function_Return bOK
88487>>>>>>>    End_Function
88488>>>>>>>    
88488>>>>>>>    // Returns all fields of type Date or DateTime in an integer array with the field numbers.
88488>>>>>>>    Function UtilCheckForDateFields Handle hTable Returns Integer[]
88490>>>>>>>        Integer[] aDateFields aDateFieldsEmpty
88492>>>>>>>        Integer iField iSize iCount iType
88492>>>>>>>        Boolean bOpen
88492>>>>>>>        
88492>>>>>>>        Open hTable
88494>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
88497>>>>>>>        If (bOpen = False) Begin  
88499>>>>>>>            Error ("Table could not be opened." * String(hTable))
88500>>>>>>>>
88500>>>>>>>            Function_Return aDateFieldsEmpty
88501>>>>>>>        End                                 
88501>>>>>>>>
88501>>>>>>>        
88501>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iSize
88504>>>>>>>        for iCount from 1 to iSize
88510>>>>>>>>
88510>>>>>>>            Get_Attribute DF_FIELD_TYPE of hTable iCount to iType
88513>>>>>>>            If (iType = DF_DATE or iType = DF_DATETIME) Begin
88515>>>>>>>                Move iCount to aDateFields[SizeOfArray(aDateFields)]
88516>>>>>>>            End
88516>>>>>>>>
88516>>>>>>>        Loop
88517>>>>>>>>
88517>>>>>>>        
88517>>>>>>>        Function_Return aDateFields
88518>>>>>>>    End_Function         
88519>>>>>>>        
88519>>>>>>>    // Loops through all records for the passed hTable, and checks that all Date values
88519>>>>>>>    // for the passed aDateFields array are OK. Else the Data value is set to CS_DUFLowestAllowedDateValue
88519>>>>>>>    // and the record is saved  
88519>>>>>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed. 
88519>>>>>>>    // Note: It first sets all indexes to BATCH and reset them at the end.
88519>>>>>>>    Function UtilTableCorrectBogusDateValues Handle hTable Integer[] aDateFields Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
88521>>>>>>>        Integer iSize iCount iField iRecord iRetval iTotalRecords iDateFormat
88521>>>>>>>        String sValue    
88521>>>>>>>        Boolean bCancel bFound bOK bChange bOpened bSaveChanges
88521>>>>>>>        Date dDate dDateMin 
88521>>>>>>>        Integer[] iaChangeField
88522>>>>>>>        
88522>>>>>>>        // The CS_DUFLowestAllowedDateValue is defined as "01/01/1753", so we first set the 
88522>>>>>>>        // date format to "USA" = "MM/DD/YYYY"
88522>>>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
88525>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_USA
88528>>>>>>>        
88528>>>>>>>        Send SetAllIndexesToBatch hTable True
88529>>>>>>>        Open hTable                               
88531>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
88534>>>>>>>        If (bOpened = False) Begin
88536>>>>>>>            Function_Return False
88537>>>>>>>        End                      
88537>>>>>>>>
88537>>>>>>>        
88537>>>>>>>        Set Private.phCurrentTable to hTable
88538>>>>>>>        Move 0 to iRecord
88539>>>>>>>        Move (SizeOfArray(aDateFields)) to iSize
88540>>>>>>>        Decrement iSize
88541>>>>>>>        
88541>>>>>>>        Get_Attribute DF_FILE_RECORDS_USED of hTable to iTotalRecords
88544>>>>>>>        Set piPosition   of ghoProgressBar to 0
88545>>>>>>>        Set piAdvanceBy  of ghoProgressBar to 100
88546>>>>>>>        Set piMaximum    of ghoProgressBar to iTotalRecords
88547>>>>>>>        Move CS_DUFLowestAllowedDateValue  to dDateMin
88548>>>>>>>        Move False to Err
88549>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88550>>>>>>>        
88550>>>>>>>        Clear hTable     
88551>>>>>>>        Repeat
88551>>>>>>>>
88551>>>>>>>            Vfind hTable 0 GT
88553>>>>>>>            Move Found to bFound
88554>>>>>>>            If (bFound = True) Begin    
88556>>>>>>>                Move False to bSaveChanges   
88557>>>>>>>                Move (ResizeArray(iaChangeField, 0)) to iaChangeField 
88558>>>>>>>                Move (SizeOfArray(aDateFields)) to iSize
88559>>>>>>>                Decrement iSize
88560>>>>>>>                for iCount from 0 to iSize   
88566>>>>>>>>
88566>>>>>>>                    Move aDateFields[iCount] to iField
88567>>>>>>>                    Get_Field_Value hTable iField to dDate
88570>>>>>>>                    If (bFixZeroDates = True) Begin
88572>>>>>>>                        Move (dDate = 0 or dDate < dDateMin) to bChange
88573>>>>>>>                    End 
88573>>>>>>>>
88573>>>>>>>                    Else Begin
88574>>>>>>>                        Move (dDate <> 0 and dDate < dDateMin) to bChange
88575>>>>>>>                    End
88575>>>>>>>>
88575>>>>>>>                    If (bChange = True) Begin      
88577>>>>>>>                        Move iField to iaChangeField[SizeOfArray(iaChangeField)]            
88578>>>>>>>                    End
88578>>>>>>>>
88578>>>>>>>                Loop       
88579>>>>>>>>
88579>>>>>>>                
88579>>>>>>>                // Only change Date fields that needs to be changed.
88579>>>>>>>                If (SizeOfArray(iaChangeField)) Begin
88581>>>>>>>                    Reread hTable 
88585>>>>>>>                        Move (SizeOfArray(iaChangeField)) to iSize
88586>>>>>>>                        Decrement iSize      
88587>>>>>>>                        for iCount from 0 to iSize
88593>>>>>>>>
88593>>>>>>>                            Move iaChangeField[iCount] to iField
88594>>>>>>>                            Set Private.piCurrentField to iField
88595>>>>>>>                            Set_Field_Value hTable iField to dDateMin  
88598>>>>>>>                        Loop
88599>>>>>>>>
88599>>>>>>>                        Move False to Err
88600>>>>>>>                        SaveRecord hTable
88601>>>>>>>                    Unlock
88602>>>>>>>>
88602>>>>>>>                End
88602>>>>>>>>
88602>>>>>>>                
88602>>>>>>>                Increment iRecord
88603>>>>>>>                // Increment the StatusPanel counter and check the
88603>>>>>>>                // cancel status every 100 records rather than every
88603>>>>>>>                // record, it's way faster.
88603>>>>>>>                If (Mod(iRecord, 100) = 0) Begin
88605>>>>>>>                    Send DoAdvance of ghoProgressBar
88606>>>>>>>                    Set Action_Text of ghoStatusPanel to ("Record:" * String(iRecord))
88607>>>>>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
88608>>>>>>>                End 
88608>>>>>>>>
88608>>>>>>>            End
88608>>>>>>>>
88608>>>>>>>        Until (bFound = False)
88610>>>>>>>                
88610>>>>>>>        Set_Attribute DF_DATE_FORMAT to iDateFormat   
88613>>>>>>>        If (bResetIndexesToOnLine = True) Begin
88615>>>>>>>            Send SetAllIndexesToBatch hTable False
88616>>>>>>>        End
88616>>>>>>>>
88616>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88617>>>>>>>        
88617>>>>>>>        Function_Return (Err = False)
88618>>>>>>>    End_Function 
88619>>>>>>>        
88619>>>>>>>
88619>>>>>>>    // * Dummy function for the Studio's Code Explorer *
88619>>>>>>>    Function API_COLUMN_FUNCTIONS Returns Boolean
88621>>>>>>>        Function_Return False
88622>>>>>>>    End_Function
88623>>>>>>>
88623>>>>>>>    // Adds a column name to the passed table number.
88623>>>>>>>    Function ApiColumnAdd Handle hTable String sFieldName Integer iType Integer iLength Integer iPrec Boolean bInitVal String sColVal Returns Boolean
88625>>>>>>>        Integer iColumn iCount iFile iPrecision
88625>>>>>>>        Boolean bExists bOK bInitializeValue bRetval
88625>>>>>>>        String sDdSrcPath sTableName sColumnValue
88625>>>>>>>
88625>>>>>>>        Get UtilColumnExists hTable sFieldName to bExists
88626>>>>>>>        Move False to Err
88627>>>>>>>        If (bExists = True) Begin
88629>>>>>>>            Function_Return False
88630>>>>>>>        End
88630>>>>>>>>
88630>>>>>>>        If (num_arguments > 4) Begin
88632>>>>>>>            Move iPrec to iPrecision
88633>>>>>>>        End
88633>>>>>>>>
88633>>>>>>>        If (num_arguments > 6) Begin
88635>>>>>>>            Move bInitVal to bInitializeValue
88636>>>>>>>            Move sColVal  to sColumnValue
88637>>>>>>>        End
88637>>>>>>>>
88637>>>>>>>        If (iType < -1490) Begin
88639>>>>>>>            Move (iType + 1500) to iType
88640>>>>>>>        End
88640>>>>>>>>
88640>>>>>>>
88640>>>>>>>        Get AutoConnectionIDLogin to bOK
88641>>>>>>>        Move False to Err
88642>>>>>>>        // Structure_start will change the value of hTable...
88642>>>>>>>        Move hTable to iFile
88643>>>>>>>        Open iFile Mode DF_EXCLUSIVE
88645>>>>>>>
88645>>>>>>>        Set Private.phCurrentTable to hTable
88646>>>>>>>        Structure_Start iFile
88647>>>>>>>            Move 0 to iColumn
88648>>>>>>>            Set Private.piCurrentField to iColumn
88649>>>>>>>            Create_Field hTable At iColumn
88650>>>>>>>            Set_Attribute DF_FIELD_NAME      of iFile iColumn to sFieldName
88653>>>>>>>            Set_Attribute DF_FIELD_TYPE      of iFile iColumn to iType
88656>>>>>>>            Set_Attribute DF_FIELD_LENGTH    of iFile iColumn to (iLength + iPrecision)
88659>>>>>>>            Set_Attribute DF_FIELD_PRECISION of iFile iColumn to iPrecision
88662>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88663>>>>>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88665>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88666>>>>>>>
88666>>>>>>>        // If in development environment; create .fd file:
88666>>>>>>>        Open hTable
88668>>>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
88669>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
88670>>>>>>>        If (iCount > 1) Begin
88672>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
88673>>>>>>>        End
88673>>>>>>>>
88673>>>>>>>        Get vFolderExists sDDSrcPath to bExists
88674>>>>>>>        If (bExists = True) Begin
88676>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
88677>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
88680>>>>>>>            Get _TableNameOnly sTableName to sTableName
88681>>>>>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
88683>>>>>>>        End
88683>>>>>>>>
88683>>>>>>>
88683>>>>>>>        // Check for a default value
88683>>>>>>>        If (bInitializeValue = True and sColumnValue <> "" and Err = False) Begin
88685>>>>>>>            Get ApiColumnUpdateValue hTable sFieldName sColumnValue to bRetval
88686>>>>>>>        End
88686>>>>>>>>
88686>>>>>>>        Close hTable
88687>>>>>>>
88687>>>>>>>        Function_Return (Err = False)
88688>>>>>>>    End_Function
88689>>>>>>>
88689>>>>>>>    // Adds a column name to the passed table number.
88689>>>>>>>    Function ApiColumnInsert Handle hTable Integer iColumn String sFieldName Integer iType Integer iLength Integer iPrec Boolean bIsSQLType Returns Boolean
88691>>>>>>>        Integer iCount iFile iPrecision iNumberOfFields
88691>>>>>>>        Boolean bExists bOK bInitializeValue bRetval bIsDateType
88691>>>>>>>        String sDdSrcPath sTableName sColumnValue
88691>>>>>>>
88691>>>>>>>        Get UtilColumnExists hTable sFieldName to bExists
88692>>>>>>>        Move False to Err
88693>>>>>>>        If (bExists = True) Begin
88695>>>>>>>            Function_Return False
88696>>>>>>>        End
88696>>>>>>>>
88696>>>>>>>        If (num_arguments > 4) Begin
88698>>>>>>>            Move iPrec to iPrecision
88699>>>>>>>        End
88699>>>>>>>>
88699>>>>>>>        If (iType < -1490) Begin
88701>>>>>>>            Move (iType + 1500) to iType
88702>>>>>>>        End
88702>>>>>>>>
88702>>>>>>>
88702>>>>>>>        Get AutoConnectionIDLogin to bOK
88703>>>>>>>        Move False to Err
88704>>>>>>>        // Structure_start will change the value of hTable...
88704>>>>>>>        Move hTable to iFile
88705>>>>>>>        Get OpenTableExclusive iFile to bOK
88706>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iNumberOfFields
88709>>>>>>>        
88709>>>>>>>        // If the passed column number is higher than the current number of fields
88709>>>>>>>        // in the table, this means we should _not_ insert a field but rather add
88709>>>>>>>        // a new field to the end:
88709>>>>>>>        If (iColumn > iNumberOfFields) Begin
88711>>>>>>>            Move 0 to iColumn
88712>>>>>>>        End
88712>>>>>>>>
88712>>>>>>>
88712>>>>>>>        Set Private.phCurrentTable to hTable
88713>>>>>>>        Set Private.piCurrentField to iColumn
88714>>>>>>>
88714>>>>>>>        Structure_Start iFile
88715>>>>>>>            Create_Field iFile At iColumn
88716>>>>>>>            Set_Attribute DF_FIELD_NAME            of iFile iColumn to sFieldName
88719>>>>>>>            If (bIsSQLType = False) Begin
88721>>>>>>>                Set_Attribute DF_FIELD_TYPE        of iFile iColumn to iType
88724>>>>>>>            End 
88724>>>>>>>>
88724>>>>>>>            Else Begin
88725>>>>>>>                Set_Attribute DF_FIELD_NATIVE_TYPE of iFile iColumn to iType
88728>>>>>>>            End
88728>>>>>>>>
88728>>>>>>>            Get UtilColumnIsDateType iType False to bIsDateType
88729>>>>>>>            If (bIsDateType = False) Begin
88731>>>>>>>                Set_Attribute DF_FIELD_LENGTH       of iFile iColumn to (iLength + iPrecision)
88734>>>>>>>                Set_Attribute DF_FIELD_PRECISION    of iFile iColumn to iPrecision
88737>>>>>>>            End
88737>>>>>>>>
88737>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88738>>>>>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88740>>>>>>>
88740>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88741>>>>>>>        // If in development environment; create .fd file:
88741>>>>>>>        Open hTable
88743>>>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
88744>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
88745>>>>>>>        If (iCount > 1) Begin
88747>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
88748>>>>>>>        End
88748>>>>>>>>
88748>>>>>>>        Get vFolderExists sDDSrcPath to bExists
88749>>>>>>>        If (bExists = True) Begin
88751>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
88752>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
88755>>>>>>>            Get _TableNameOnly sTableName to sTableName
88756>>>>>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
88758>>>>>>>        End
88758>>>>>>>>
88758>>>>>>>
88758>>>>>>>        // Check for a default value
88758>>>>>>>        Close hTable
88759>>>>>>>
88759>>>>>>>        Function_Return (Err = False)
88760>>>>>>>    End_Function
88761>>>>>>>
88761>>>>>>>//    Function ApiColumnAddMultiple Handle hTable tAPIColumn[] aColumns Returns Boolean
88761>>>>>>>//        Integer iColumn iCount iFile
88761>>>>>>>//        Boolean bExists bOK
88761>>>>>>>//        String sDdSrcPath sTableName
88761>>>>>>>//
88761>>>>>>>//        Get AutoConnectionIDLogin to bOK
88761>>>>>>>//        Move False to Err
88761>>>>>>>//
88761>>>>>>>//        // Structure_start will change the value of hTable...
88761>>>>>>>//        Move hTable to iFile
88761>>>>>>>//        Open iFile Mode DF_EXCLUSIVE
88761>>>>>>>//
88761>>>>>>>//        Structure_Start iFile
88761>>>>>>>//            Send ApiColumnsAddToTable iFile aColumns False
88761>>>>>>>//        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88761>>>>>>>//
88761>>>>>>>//        // If in development environment; create .fd file:
88761>>>>>>>//        Open hTable
88761>>>>>>>//        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
88761>>>>>>>//        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
88761>>>>>>>//        If (iCount > 1) Begin
88761>>>>>>>//            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
88761>>>>>>>//        End
88761>>>>>>>//        Get vFolderExists sDDSrcPath to bExists
88761>>>>>>>//        If (bExists = True) Begin
88761>>>>>>>//            Get vFolderFormat sDDSrcPath to sDDSrcPath
88761>>>>>>>//            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
88761>>>>>>>//            Get _TableNameOnly sTableName to sTableName
88761>>>>>>>//            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
88761>>>>>>>//        End
88761>>>>>>>//        Close hTable
88761>>>>>>>//
88761>>>>>>>//        Function_Return (Err = False)
88761>>>>>>>//    End_Function
88761>>>>>>>
88761>>>>>>>    // To update all records for a table column with a fixed value.
88761>>>>>>>    Function ApiColumnUpdateValue Handle hTable String sFieldName String sColumnValue Returns Boolean
88763>>>>>>>        Integer iRecs iCurrErr iField iRecord
88763>>>>>>>        Boolean bRetval bOpen
88763>>>>>>>
88763>>>>>>>        Move 0 to iRecs
88764>>>>>>>        Move False to bRetval
88765>>>>>>>        Move Err to iCurrErr
88766>>>>>>>        Move False to Err
88767>>>>>>>
88767>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
88770>>>>>>>        If (bOpen = False) Begin
88772>>>>>>>            Open hTable
88774>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
88777>>>>>>>            If (bOpen = False) Begin
88779>>>>>>>                Function_Return bRetval
88780>>>>>>>            End
88780>>>>>>>>
88780>>>>>>>        End
88780>>>>>>>>
88780>>>>>>>
88780>>>>>>>        Field_Map hTable sFieldName to iField
88782>>>>>>>        If (iField <> 0) Begin
88784>>>>>>>            Set Private.phCurrentTable to hTable
88785>>>>>>>            Set Private.piCurrentField to iField
88786>>>>>>>            Clear hTable
88787>>>>>>>            Repeat
88787>>>>>>>>
88787>>>>>>>                Vfind hTable 0 GT
88789>>>>>>>                If (Found) Begin
88791>>>>>>>                    If (ghoStatusPanel <> 0) Begin
88793>>>>>>>                        Get_Field_Value hTable 0 to iRecord
88796>>>>>>>                        Send Update_StatusPanel of ghoStatusPanel (CS_UpdateVersion * String(iRecord))
88797>>>>>>>                    End
88797>>>>>>>>
88797>>>>>>>                    Reread hTable
88801>>>>>>>                        Set_Field_Value hTable iField to sColumnValue
88804>>>>>>>                        SaveRecord hTable
88805>>>>>>>                    Unlock
88806>>>>>>>>
88806>>>>>>>                End
88806>>>>>>>>
88806>>>>>>>           Until (not(Found))
88808>>>>>>>        End
88808>>>>>>>>
88808>>>>>>>
88808>>>>>>>        Move (Err = False) to bRetval
88809>>>>>>>        Move iCurrErr to Err
88810>>>>>>>
88810>>>>>>>        Function_Return bRetval
88811>>>>>>>    End_Function
88812>>>>>>>    
88812>>>>>>>    // Note: This can only be used from within a Structure_Start/End construct.
88812>>>>>>>    Function ApiColumnsAddToTable Handle hTable tAPIColumn[] aColumns Boolean bCreating Returns Boolean
88814>>>>>>>        Integer iCount iSize iColumn iType iDataFlexType iIndex iDbType
88814>>>>>>>        Boolean bFieldExists bNativeType bIsSQLDriver bIsDAWSqlDriver bIsSqlTable bRecnumTable bIsOpen bIsDateType
88814>>>>>>>        String sFieldName sDriverID sTableName sDefaultValue
88814>>>>>>>
88814>>>>>>>//        Set Private.phCurrentTable to hTable
88814>>>>>>>        Get psDriverID to sDriverID
88815>>>>>>>        Get piDbType to iDbType
88816>>>>>>>        Get UtilTableHandleToString hTable to sTableName
88817>>>>>>>        Get IsSQLDriver    sDriverID to bIsSQLDriver
88818>>>>>>>        Get IsDAWSQLDriver sDriverID to bIsDAWSqlDriver
88819>>>>>>>        Get UtilTableIsSQL hTable to bIsSqlTable
88820>>>>>>>        If (bIsSqlTable = False and bCreating = True and bIsSQLDriver = True) Begin
88822>>>>>>>            Move True to bIsSqlTable
88823>>>>>>>        End
88823>>>>>>>>
88823>>>>>>>        Move False to bIsOpen
88824>>>>>>>        If (hTable > 0) Begin
88826>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
88829>>>>>>>        End
88829>>>>>>>>
88829>>>>>>>        If (bIsOpen = True) Begin
88831>>>>>>>            Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
88834>>>>>>>        End
88834>>>>>>>>
88834>>>>>>>        Else Begin        
88835>>>>>>>            Get pbRecnum to bRecnumTable
88836>>>>>>>        End
88836>>>>>>>>
88836>>>>>>>        
88836>>>>>>>        Move False to Err
88837>>>>>>>        Move (SizeOfArray(aColumns)) to iSize
88838>>>>>>>        Decrement iSize
88839>>>>>>>        for iCount from 0 to iSize
88845>>>>>>>>
88845>>>>>>>            Move aColumns[iCount].sFieldName to sFieldName
88846>>>>>>>            If (hTable > 0) Begin
88848>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88849>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88850>>>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn to sFieldName
88853>>>>>>>                Move (Trim(sFieldName) <> "") to bFieldExists
88854>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
88855>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88856>>>>>>>            End
88856>>>>>>>>
88856>>>>>>>            Else Begin
88857>>>>>>>                Move False to bFieldExists
88858>>>>>>>            End
88858>>>>>>>>
88858>>>>>>>
88858>>>>>>>            If (bFieldExists = False) Begin
88860>>>>>>>                Move 0 to iColumn
88861>>>>>>>                Create_Field hTable At iColumn
88862>>>>>>>            End
88862>>>>>>>>
88862>>>>>>>            Else Begin
88863>>>>>>>                Move iCount to iColumn
88864>>>>>>>            End
88864>>>>>>>>
88864>>>>>>>
88864>>>>>>>            Set Private.piCurrentField to iColumn
88865>>>>>>>
88865>>>>>>>            Move                                        iColumn to aColumns[iCount].iFieldNumber
88866>>>>>>>            Set_Attribute DF_FIELD_NAME       of hTable iColumn to aColumns[iCount].sFieldName
88869>>>>>>>
88869>>>>>>>            Move aColumns[iCount].iType to iType
88870>>>>>>>            Move (not(iType < -1490)) to bNativeType
88871>>>>>>>            If (iType < -1490) Begin
88873>>>>>>>                Move (iType + 1500) to iType
88874>>>>>>>            End
88874>>>>>>>>
88874>>>>>>>
88874>>>>>>>            If (bIsSqlTable = True) Begin
88876>>>>>>>                If (aColumns[iCount].bIsSQLType = True) Begin
88878>>>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iDataFlexType
88879>>>>>>>                    Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iDataFlexType
88882>>>>>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iType  
88885>>>>>>>                    Set_Attribute DF_FIELD_NULL_ALLOWED  of hTable iColumn to aColumns[iCount].bAllowNULL
88888>>>>>>>                    
88888>>>>>>>                    Move aColumns[iCount].sDefaultValue                    to sDefaultValue
88889>>>>>>>                    If (iDataFlexType = DF_BCD and Left(sDefaultValue, 1 <> "[")) Begin
88891>>>>>>>                        Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
88892>>>>>>>                    End
88892>>>>>>>>
88892>>>>>>>                    Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sDefaultValue 
88895>>>>>>>                
88895>>>>>>>                End
88895>>>>>>>>
88895>>>>>>>                Else Begin
88896>>>>>>>                    Set_Attribute DF_FIELD_TYPE        of hTable iColumn to iType
88899>>>>>>>                End
88899>>>>>>>>
88899>>>>>>>            End
88899>>>>>>>>
88899>>>>>>>            Else Begin
88900>>>>>>>                If (bCreating = False) Begin
88902>>>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iType
88903>>>>>>>                End
88903>>>>>>>>
88903>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iColumn to iType
88906>>>>>>>            End
88906>>>>>>>>
88906>>>>>>>            
88906>>>>>>>            Get UtilColumnIsDateType iType bIsSqlTable to bIsDateType
88907>>>>>>>            If (bIsDateType = False) Begin
88909>>>>>>>                Set_Attribute DF_FIELD_LENGTH     of hTable iColumn to aColumns[iCount].iLength
88912>>>>>>>                Set_Attribute DF_FIELD_PRECISION  of hTable iColumn to aColumns[iCount].iPrecision
88915>>>>>>>            End
88915>>>>>>>>
88915>>>>>>>
88915>>>>>>>            If (aColumns[iCount].iOptions iand C_tAPIColumn_Identity) Begin
88917>>>>>>>                Move 0 to iIndex
88918>>>>>>>                Create_Index hTable at iIndex
88919>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to 1
88922>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD   of hTable iIndex 1 to iColumn
88925>>>>>>>                Set_Attribute DF_FILE_PRIMARY_INDEX    of hTable iIndex to 1
88928>>>>>>>
88928>>>>>>>                // If we have an identity table - we must create a primary_key table.
88928>>>>>>>                If (bIsSqlTable = True) Begin
88930>>>>>>>                    Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to True
88933>>>>>>>                    Set_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to True
88936>>>>>>>                End
88936>>>>>>>>
88936>>>>>>>            End
88936>>>>>>>>
88936>>>>>>>        Loop             
88937>>>>>>>>
88937>>>>>>>        
88937>>>>>>>        Function_Return (Err = False)
88938>>>>>>>    End_Function
88939>>>>>>>
88939>>>>>>>    // Changes a field type, length and precision for the passed table number and field name
88939>>>>>>>    Function ApiColumnChange Handle hTable String sFieldNameFrom Integer iTypeFrom Integer iLengthFrom Integer iPrec Returns Boolean
88941>>>>>>>        Integer iColumn iPrecFrom iTypeTo iLengthTo iPrecTo
88941>>>>>>>        Boolean bOK bIsSqlTable
88941>>>>>>>        String sFieldNameTo
88941>>>>>>>
88941>>>>>>>        If (num_arguments > 4) Begin
88943>>>>>>>            Move iPrec to iPrecFrom
88944>>>>>>>        End
88944>>>>>>>>
88944>>>>>>>        If (iTypeFrom < -1490) Begin
88946>>>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
88947>>>>>>>        End
88947>>>>>>>>
88947>>>>>>>
88947>>>>>>>        Get AutoConnectionIDLogin to bOK
88948>>>>>>>        Move False to Err
88949>>>>>>>        Get OpenTableExclusive hTable to bOK
88950>>>>>>>        If (bOK = False) Begin
88952>>>>>>>            Function_Return False
88953>>>>>>>        End
88953>>>>>>>>
88953>>>>>>>
88953>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88954>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88955>>>>>>>        Field_Map hTable sFieldNameFrom to iColumn
88957>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88958>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88959>>>>>>>        If (Err = True) Begin
88961>>>>>>>            Function_Return False
88962>>>>>>>        End
88962>>>>>>>>
88962>>>>>>>
88962>>>>>>>        Get_Attribute DF_FIELD_NAME                  of hTable iColumn to sFieldNameTo
88965>>>>>>>        Get UtilTableIsSQL hTable to bIsSqlTable
88966>>>>>>>        If (bIsSqlTable = False) Begin
88968>>>>>>>            Get_Attribute DF_FIELD_TYPE              of hTable iColumn to iTypeTo
88971>>>>>>>        End
88971>>>>>>>>
88971>>>>>>>        Else Begin
88972>>>>>>>            Get_Attribute DF_FIELD_NATIVE_TYPE       of hTable iColumn to iTypeTo
88975>>>>>>>        End
88975>>>>>>>>
88975>>>>>>>        // Let the driver decide the other values;
88975>>>>>>>        Get_Attribute DF_FIELD_LENGTH                of hTable iColumn to iLengthTo
88978>>>>>>>        Get_Attribute DF_FIELD_PRECISION             of hTable iColumn to iPrecTo
88981>>>>>>>
88981>>>>>>>        If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo) Begin
88983>>>>>>>            Function_Return False
88984>>>>>>>        End
88984>>>>>>>>
88984>>>>>>>
88984>>>>>>>        Set Private.phCurrentTable to hTable
88985>>>>>>>        Set Private.piCurrentField to iColumn
88986>>>>>>>
88986>>>>>>>        Structure_Start hTable
88987>>>>>>>            Set_Attribute DF_FIELD_NAME              of hTable iColumn to sFieldNameFrom
88990>>>>>>>            If (bIsSqlTable = False) Begin
88992>>>>>>>                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
88995>>>>>>>            End
88995>>>>>>>>
88995>>>>>>>            Else Begin
88996>>>>>>>                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
88999>>>>>>>                Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iTypeFrom
89002>>>>>>>            End
89002>>>>>>>>
89002>>>>>>>            Set_Attribute DF_FIELD_LENGTH            of hTable iColumn to iLengthFrom
89005>>>>>>>            Set_Attribute DF_FIELD_PRECISION         of hTable iColumn to iPrecFrom
89008>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89009>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89011>>>>>>>
89011>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89012>>>>>>>        Function_Return (Err = False)
89013>>>>>>>    End_Function
89014>>>>>>>
89014>>>>>>>    // Changes a field type, length and precision for the passed table number and field name
89014>>>>>>>    Function ApiColumnChangeByColumnNumber String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo String sFieldNameFrom Integer iColumn Integer iTypeFrom Integer iLengthFrom Integer iPrec Integer iOpt Returns Boolean
89016>>>>>>>        Integer iPrecFrom iTypeTo iLengthTo iPrecTo iDbType iOptionFrom iOptionTo iDataFlexType iIndex
89016>>>>>>>        Boolean bOK bCompareDate_DateTime bSkip bRecnumTable bIsSameDataType
89016>>>>>>>        String sFieldNameTo sDriverIDTo
89016>>>>>>>        tColumnType ColumnType
89016>>>>>>>        tColumnType ColumnType
89016>>>>>>>        
89016>>>>>>>        Get pbCompareDate_DateTime to bCompareDate_DateTime
89017>>>>>>>        Get piDbType to iDbType
89018>>>>>>>        If (num_arguments > 4) Begin
89020>>>>>>>            Move iPrec to iPrecFrom
89021>>>>>>>            Move iOpt  to iOptionFrom
89022>>>>>>>        End
89022>>>>>>>>
89022>>>>>>>        If (iTypeFrom < -1490) Begin
89024>>>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
89025>>>>>>>        End
89025>>>>>>>>
89025>>>>>>>
89025>>>>>>>        Get AutoConnectionIDLogin to bOK
89026>>>>>>>        Move False to Err   
89027>>>>>>>        Close hTable
89028>>>>>>>        Get OpenTableExclusive hTable to bOK
89029>>>>>>>        If (bOK = False) Begin
89031>>>>>>>            Function_Return False
89032>>>>>>>        End 
89032>>>>>>>>
89032>>>>>>>
89032>>>>>>>        Get_Attribute DF_FILE_DRIVER                of hTable         to sDriverIDTo
89035>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE          of hTable         to bRecnumTable
89038>>>>>>>        Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iTypeTo iLengthTo to iDataFlexType
89039>>>>>>>        Get_Attribute DF_FIELD_NAME                 of hTable iColumn to sFieldNameTo 
89042>>>>>>>
89042>>>>>>>        If (bIsSQLTableTo = True) Begin
89044>>>>>>>            Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iTypeTo
89047>>>>>>>        End
89047>>>>>>>>
89047>>>>>>>        Else Begin
89048>>>>>>>            Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iTypeTo
89051>>>>>>>        End
89051>>>>>>>>
89051>>>>>>>
89051>>>>>>>        Get_Attribute DF_FIELD_LENGTH               of hTable iColumn to iLengthTo
89054>>>>>>>        Get_Attribute DF_FIELD_PRECISION            of hTable iColumn to iPrecTo
89057>>>>>>>            Get_Attribute DF_FIELD_IS_IDENTITY      of hTable iColumn to iOptionTo 
89060>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
89060>>>>>>>        // data types between Embedded and SQL, else we can't compare the data types.
89060>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
89062>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeFrom
89063>>>>>>>        End
89063>>>>>>>>
89063>>>>>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
89066>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeTo
89067>>>>>>>        End
89067>>>>>>>>
89067>>>>>>>        Move (iTypeFrom = iTypeTo) to bIsSameDataType
89068>>>>>>>
89068>>>>>>>        If (bCompareDate_DateTime = False) Begin
89070>>>>>>>            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkip
89071>>>>>>>            If (bSkip = True) Begin
89073>>>>>>>                If (sFieldNameFrom = sFieldNameTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
89075>>>>>>>                    Function_Return True
89076>>>>>>>                End
89076>>>>>>>>
89076>>>>>>>            End
89076>>>>>>>>
89076>>>>>>>        End
89076>>>>>>>>
89076>>>>>>>        Else If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
89079>>>>>>>            Function_Return True
89080>>>>>>>        End
89080>>>>>>>>
89080>>>>>>>
89080>>>>>>>        Set Private.phCurrentTable to hTable
89081>>>>>>>        Set Private.piCurrentField to iColumn
89082>>>>>>>       
89082>>>>>>>        Structure_Start hTable                                               
89083>>>>>>>            If (sFieldNameFrom <> sFieldNameTo) Begin
89085>>>>>>>                Set_Attribute DF_FIELD_NAME             of hTable iColumn to sFieldNameFrom
89088>>>>>>>            End
89088>>>>>>>>
89088>>>>>>>            
89088>>>>>>>            If (bIsSameDataType = False) Begin
89090>>>>>>>                Set_Attribute DF_FIELD_TYPE             of hTable iColumn to iDataFlexType
89093>>>>>>>                If (bIsSQLTableTo = True) Begin
89095>>>>>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE  of hTable iColumn to iTypeFrom
89098>>>>>>>                End
89098>>>>>>>>
89098>>>>>>>            End                                         
89098>>>>>>>>
89098>>>>>>>            
89098>>>>>>>            If (iLengthFrom <> iLengthTo) Begin
89100>>>>>>>                Set_Attribute DF_FIELD_LENGTH           of hTable iColumn to iLengthFrom
89103>>>>>>>            End
89103>>>>>>>>
89103>>>>>>>            If (iPrecFrom <> iPrecTo) Begin
89105>>>>>>>                Set_Attribute DF_FIELD_PRECISION        of hTable iColumn to iPrecFrom
89108>>>>>>>            End
89108>>>>>>>>
89108>>>>>>>
89108>>>>>>>            If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
89110>>>>>>>                // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
89110>>>>>>>                If (bRecnumTable = True) Begin
89112>>>>>>>                    Set_Attribute DF_FILE_RECNUM_TABLE  of hTable to False
89115>>>>>>>                End
89115>>>>>>>>
89115>>>>>>>
89115>>>>>>>                // We might need to create an index here.
89115>>>>>>>                // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
89115>>>>>>>                // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
89115>>>>>>>                // index update checking logic.
89115>>>>>>>                Get_Attribute DF_FIELD_INDEX               of hTable iColumn to iIndex
89118>>>>>>>                If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
89120>>>>>>>                    Create_Index hTable At iIndex
89121>>>>>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex   to 1
89124>>>>>>>                End
89124>>>>>>>>
89124>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD       of hTable iIndex 1 to iColumn
89127>>>>>>>                Set_Attribute DF_FILE_PRIMARY_INDEX        of hTable          to iIndex
89130>>>>>>>                    Set_Attribute DF_FIELD_IS_IDENTITY     of hTable iColumn  to True
89133>>>>>>>                If (bIsSQLTableTo = True) Begin
89135>>>>>>>                    Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex   to True
89138>>>>>>>                End
89138>>>>>>>>
89138>>>>>>>            End
89138>>>>>>>>
89138>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89139>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89141>>>>>>>
89141>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89142>>>>>>>        Function_Return (Err = False)
89143>>>>>>>    End_Function
89144>>>>>>>
89144>>>>>>>    Function ApiColumnChangeMainIndex Handle hTable Integer iIndex Integer iColumn Returns Boolean
89146>>>>>>>        Boolean bOK
89146>>>>>>>
89146>>>>>>>        Get AutoConnectionIDLogin to bOK
89147>>>>>>>        Move False to Err
89148>>>>>>>        Get OpenTableExclusive hTable to bOK
89149>>>>>>>        If (bOK = False) Begin
89151>>>>>>>            Function_Return False
89152>>>>>>>        End
89152>>>>>>>>
89152>>>>>>>
89152>>>>>>>        Structure_Start hTable
89153>>>>>>>            Set_Attribute DF_FIELD_INDEX of hTable iColumn to iIndex
89156>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89157>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89159>>>>>>>
89159>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89160>>>>>>>        Function_Return (Err = False)
89161>>>>>>>    End_Function
89162>>>>>>>
89162>>>>>>>    // To move an existing field to another position in a table.
89162>>>>>>>    Function ApiColumnMove Handle hTable Integer iOld Integer iNew Boolean bIsSQLType Returns Boolean
89164>>>>>>>        String sColumn sDriverID
89164>>>>>>>        Integer iType iSQLType iLength iPrecision iDbType
89164>>>>>>>        Boolean bOK bIsDate
89164>>>>>>>        
89164>>>>>>>        Close hTable
89165>>>>>>>        Get AutoConnectionIDLogin to bOK
89166>>>>>>>        Get OpenTableExclusive hTable to bOK
89167>>>>>>>        If (bOK = False) Begin
89169>>>>>>>            Function_Return False
89170>>>>>>>        End
89170>>>>>>>>
89170>>>>>>>        
89170>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89173>>>>>>>        If (sDriverID = DFBTRDRV_ID) Begin
89175>>>>>>>            Error DFERR_PROGRAM "Function 'ColumnMove' is not supported for the Pervasive database."
89176>>>>>>>>
89176>>>>>>>            Function_Return False
89177>>>>>>>        End
89177>>>>>>>>
89177>>>>>>>        
89177>>>>>>>        Get_Attribute DF_FIELD_NAME of hTable iOld to sColumn
89180>>>>>>>        Get_Attribute DF_FIELD_TYPE of hTable iOld to iType
89183>>>>>>>
89183>>>>>>>        Set Private.phCurrentTable to hTable
89184>>>>>>>        Set Private.piCurrentField to iOld
89185>>>>>>>
89185>>>>>>>        Get UtilColumnIsDateType iType bIsSQLType to bIsDate
89186>>>>>>>        If (bIsDate = False) Begin
89188>>>>>>>            Get_Attribute DF_FIELD_LENGTH    of hTable iOld to iLength
89191>>>>>>>            Get_Attribute DF_FIELD_PRECISION of hTable iOld to iPrecision
89194>>>>>>>        End  
89194>>>>>>>>
89194>>>>>>>        Else Begin
89195>>>>>>>            Move 6 to iLength 
89196>>>>>>>            Move 0 to iPrecision
89197>>>>>>>        End
89197>>>>>>>>
89197>>>>>>>
89197>>>>>>>        Move False to Err
89198>>>>>>>
89198>>>>>>>        Structure_Start hTable
89199>>>>>>>            Delete_Field hTable iOld
89200>>>>>>>            Create_Field hTable At iNew
89201>>>>>>>            Set_Attribute DF_FIELD_NAME of hTable iNew to sColumn 
89204>>>>>>>            
89204>>>>>>>            If (bIsSQLType = False) Begin
89206>>>>>>>                Set_Attribute DF_FIELD_TYPE        of hTable iNew to iType
89209>>>>>>>            End 
89209>>>>>>>>
89209>>>>>>>            Else Begin
89210>>>>>>>                Set_Attribute DF_FIELD_TYPE        of hTable iNew to iType
89213>>>>>>>//                Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iNew to iSQLType  
89213>>>>>>>            End
89213>>>>>>>>
89213>>>>>>>            
89213>>>>>>>            If (bIsDate = False) Begin
89215>>>>>>>                Set_Attribute DF_FIELD_LENGTH    of hTable iNew to iLength
89218>>>>>>>                Set_Attribute DF_FIELD_PRECISION of hTable iNew to iPrecision
89221>>>>>>>            End
89221>>>>>>>>
89221>>>>>>>
89221>>>>>>>            Set_Attribute DF_FIELD_OLD_NUMBER of hTable iNew to iOld
89224>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89225>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89227>>>>>>>
89227>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89228>>>>>>>        Function_Return (Err = False)
89229>>>>>>>    End_Function
89230>>>>>>>
89230>>>>>>>    // Deletes a column name for the passed table number (and column number).
89230>>>>>>>    Function ApiColumnRemove Handle hTable String sFieldName Returns Boolean
89232>>>>>>>        Integer iColumn
89232>>>>>>>        Boolean bOK
89232>>>>>>>
89232>>>>>>>        Get AutoConnectionIDLogin to bOK
89233>>>>>>>        Move False to Err
89234>>>>>>>        Close hTable
89235>>>>>>>        Get OpenTableExclusive hTable to bOK
89236>>>>>>>        If (bOK = False) Begin
89238>>>>>>>            Function_Return False
89239>>>>>>>        End
89239>>>>>>>>
89239>>>>>>>
89239>>>>>>>        If (not(Err)) Begin 
89241>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89242>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
89243>>>>>>>            Field_Map hTable sFieldName to iColumn
89245>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
89246>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
89247>>>>>>>            If (Err = True) Begin
89249>>>>>>>                Function_Return False
89250>>>>>>>            End
89250>>>>>>>>
89250>>>>>>>            Move False to Err
89251>>>>>>>
89251>>>>>>>            Set Private.phCurrentTable to hTable
89252>>>>>>>            Set Private.piCurrentField to iColumn
89253>>>>>>>        
89253>>>>>>>            Structure_Start hTable
89254>>>>>>>                Delete_Field hTable iColumn
89255>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
89256>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89258>>>>>>>            Set Action_Text of ghoStatusPanel to ""
89259>>>>>>>        End
89259>>>>>>>>
89259>>>>>>>        Else Begin
89260>>>>>>>            Error DFERR_PROGRAM ("The table number:" * String(hTable) * "could not be opened exclusiv. This indicates the table is in use!")
89261>>>>>>>>
89261>>>>>>>        End
89261>>>>>>>>
89261>>>>>>>
89261>>>>>>>        Function_Return (Err = False)
89262>>>>>>>    End_Function
89263>>>>>>>
89263>>>>>>>    // Renames a field for the passed table number & old field name & new field name
89263>>>>>>>    // Returns True if no errors occured.
89263>>>>>>>    // Sample usage:
89263>>>>>>>    //   Get ColumnRename Quote.File_Number "ID#" "ID" to bOK
89263>>>>>>>    Function ApiColumnRename Integer hTable String sOldFieldName String sNewFieldName Returns Boolean
89265>>>>>>>        Integer iField
89265>>>>>>>        Boolean bOK bExists bIsOpen
89265>>>>>>>
89265>>>>>>>        Get UtilColumnExists hTable sNewFieldName to bExists
89266>>>>>>>        If (bExists = True) Begin
89268>>>>>>>            Function_Return False
89269>>>>>>>        End
89269>>>>>>>>
89269>>>>>>>        
89269>>>>>>>        // Note: The Field_Map command does _not_ work if the table has been
89269>>>>>>>        //       opened exclusively, so we first open it in normal mode.
89269>>>>>>>        Close hTable
89270>>>>>>>        Open hTable                
89272>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89275>>>>>>>        If (bIsOpen = False) Begin
89277>>>>>>>            Function_Return False
89278>>>>>>>        End
89278>>>>>>>>
89278>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89279>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
89280>>>>>>>        Field_Map hTable sOldFieldName to iField   
89282>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
89283>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89284>>>>>>>        
89284>>>>>>>        Get AutoConnectionIDLogin to bOK
89285>>>>>>>        Get OpenTableExclusive hTable to bOK
89286>>>>>>>        If (bOK = False) Begin
89288>>>>>>>            Function_Return False
89289>>>>>>>        End
89289>>>>>>>>
89289>>>>>>>
89289>>>>>>>        Move False to Err
89290>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
89291>>>>>>>        Set Private.phCurrentTable to hTable
89292>>>>>>>        Set Private.piCurrentField to iField
89293>>>>>>>
89293>>>>>>>        If (iField > 0) Begin
89295>>>>>>>            Structure_Start hTable
89296>>>>>>>                Set_Attribute DF_FIELD_NAME of hTable iField to sNewFieldName
89299>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
89300>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89302>>>>>>>        End
89302>>>>>>>>
89302>>>>>>>        Else Begin
89303>>>>>>>            Move 0 to LastErr
89304>>>>>>>            Move False to Err
89305>>>>>>>        End
89305>>>>>>>>
89305>>>>>>>
89305>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89306>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
89307>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89308>>>>>>>
89308>>>>>>>        Function_Return (Err = False)
89309>>>>>>>    End_Function  
89310>>>>>>>    
89310>>>>>>>    Function UtilColumnsCheckForInserts Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[] 
89312>>>>>>>        tAPIColumnCompare[] aAPIColumnsToInsert
89312>>>>>>>        tAPIColumnCompare[] aAPIColumnsToInsert
89313>>>>>>>        Integer iSize iCount iItem iFieldTo iNumberOfFieldsTo
89313>>>>>>>        Boolean bRenameField bExists
89313>>>>>>>        
89313>>>>>>>        Open hTable
89315>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89316>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
89317>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize       
89318>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumberOfFieldsTo  
89321>>>>>>>        Move (iSize min iNumberOfFieldsTo) to iSize
89322>>>>>>>        Decrement iSize
89323>>>>>>>        for iCount from 0 to iSize    
89329>>>>>>>>
89329>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
89331>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89332>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
89333>>>>>>>
89333>>>>>>>                Field_Map hTable aAPIColumnCompare[iCount].sFieldNameFrom to iFieldTo
89335>>>>>>>                If (iFieldTo = 0) Begin 
89337>>>>>>>                    Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount] to bRenameField
89338>>>>>>>                    Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to bExists
89339>>>>>>>                    If (bRenameField = False and bExists = False) Begin
89341>>>>>>>                        Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToInsert[iItem].iFieldNumber 
89342>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToInsert[iItem].sFieldNameFrom
89343>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to aAPIColumnsToInsert[iItem].iTypeFrom 
89344>>>>>>>                        Move aAPIColumnCompare[iCount].sTypeFrom        to aAPIColumnsToInsert[iItem].sTypeFrom
89345>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to aAPIColumnsToInsert[iItem].iLengthFrom
89346>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to aAPIColumnsToInsert[iItem].iPrecisionFrom
89347>>>>>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeFrom   to aAPIColumnsToInsert[iItem].bIsSQLTypeFrom
89348>>>>>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeTo     to aAPIColumnsToInsert[iItem].bIsSQLTypeTo
89349>>>>>>>                        Move True                                       to aAPIColumnsToInsert[iItem].bExistsFrom
89350>>>>>>>                        Move False                                      to aAPIColumnsToInsert[iItem].bExistsTo
89351>>>>>>>                        Increment iItem
89352>>>>>>>                    End
89352>>>>>>>>
89352>>>>>>>                End
89352>>>>>>>>
89352>>>>>>>            End
89352>>>>>>>>
89352>>>>>>>        Loop
89353>>>>>>>>
89353>>>>>>>        
89353>>>>>>>        Move False to Err
89354>>>>>>>        Move 0 to LastErr
89355>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89356>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
89357>>>>>>>        Function_Return aAPIColumnsToInsert
89358>>>>>>>    End_Function   
89359>>>>>>>    
89359>>>>>>>    Function UtilColumnsInsert Handle hTable tAPIColumnCompare[] aAPIColumnsToInsert Returns Boolean
89361>>>>>>>        Integer iSize iCount
89361>>>>>>>        Boolean bOK                             
89361>>>>>>>        tAPIColumn[] aColumnsTo 
89361>>>>>>>        tAPIColumn[] aColumnsTo 
89362>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
89362>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
89363>>>>>>>
89363>>>>>>>        Move (SizeOfArray(aAPIColumnsToInsert)) to iSize
89364>>>>>>>        If (iSize = 0) Begin
89366>>>>>>>            Function_Return True
89367>>>>>>>        End                     
89367>>>>>>>>
89367>>>>>>>        
89367>>>>>>>        Move False to Err
89368>>>>>>>        Decrement iSize
89369>>>>>>>        for iCount from 0 to iSize
89375>>>>>>>>
89375>>>>>>>            Get ApiColumnInsert hTable aAPIColumnsToInsert[iCount].iFieldNumber aAPIColumnsToInsert[iCount].sFieldNameFrom aAPIColumnsToInsert[iCount].iTypeFrom aAPIColumnsToInsert[iCount].iLengthFrom aAPIColumnsToInsert[iCount].iPrecisionFrom aAPIColumnsToInsert[iCount].bIsSQLTypeFrom to bOK
89376>>>>>>>        Loop
89377>>>>>>>>
89377>>>>>>>        
89377>>>>>>>        Function_Return bOK
89378>>>>>>>    End_Function
89379>>>>>>>    
89379>>>>>>>    // Returns a struct array with fields that has the same names but different field numbers.
89379>>>>>>>    Function UtilColumnsCheckForMoves Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[] 
89381>>>>>>>        tAPIColumnCompare[] aAPIColumnsToMove
89381>>>>>>>        tAPIColumnCompare[] aAPIColumnsToMove
89382>>>>>>>        Integer iSize iCount iItem iFieldTo
89382>>>>>>>        
89382>>>>>>>        Open hTable
89384>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89385>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
89386>>>>>>>
89386>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize       
89387>>>>>>>        Decrement iSize
89388>>>>>>>        for iCount from 0 to iSize    
89394>>>>>>>>
89394>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
89396>>>>>>>                Field_Map hTable aAPIColumnCompare[iCount].sFieldNameFrom to iFieldTo
89398>>>>>>>                If (iFieldTo > 0) Begin
89400>>>>>>>                    Move aAPIColumnCompare[iCount].iFieldNumber to aAPIColumnsToMove[iItem].iFieldNumber 
89401>>>>>>>                    Move iFieldTo                               to aAPIColumnsToMove[iItem].iFieldNumberTo 
89402>>>>>>>                    Increment iItem
89403>>>>>>>                End
89403>>>>>>>>
89403>>>>>>>            End
89403>>>>>>>>
89403>>>>>>>        Loop
89404>>>>>>>>
89404>>>>>>>        
89404>>>>>>>        Move False to Err
89405>>>>>>>        Move 0 to LastErr
89406>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89407>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
89408>>>>>>>        Function_Return aAPIColumnsToMove
89409>>>>>>>    End_Function   
89410>>>>>>>    
89410>>>>>>>    Function UtilColumnsMove Handle hTable tAPIColumnCompare[] aAPIColumnsToMove Returns Boolean
89412>>>>>>>        Integer iSize iCount
89412>>>>>>>        Boolean bOK                             
89412>>>>>>>        tAPIColumn[] aColumnsTo 
89412>>>>>>>        tAPIColumn[] aColumnsTo 
89413>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
89413>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
89414>>>>>>>
89414>>>>>>>        Move (SizeOfArray(aAPIColumnsToMove)) to iSize
89415>>>>>>>        If (iSize = 0) Begin
89417>>>>>>>            Function_Return True
89418>>>>>>>        End                     
89418>>>>>>>>
89418>>>>>>>        
89418>>>>>>>        Move False to Err
89419>>>>>>>        Decrement iSize
89420>>>>>>>        for iCount from 0 to iSize
89426>>>>>>>>
89426>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89427>>>>>>>            If (aAPIColumnsToMove[iCount].bExistsFrom = True and aAPIColumnsToMove[iCount].bExistsTo = True) Begin
89429>>>>>>>                Get ApiColumnMove hTable aAPIColumnsToMove[iCount].iFieldNumberTo aAPIColumnsToMove[iCount].iFieldNumber aAPIColumnsToMove[iCount].bIsSQLTypeFrom to bOK
89430>>>>>>>            End
89430>>>>>>>>
89430>>>>>>>        Loop
89431>>>>>>>>
89431>>>>>>>        
89431>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89432>>>>>>>        Function_Return bOK
89433>>>>>>>    End_Function
89434>>>>>>>
89434>>>>>>>    // Checks if the "FROM" and "TO" database field is the same _except_ for the field name.
89434>>>>>>>    // We then assume this field should be renamed.
89434>>>>>>>//    Function UtilColumCheckRename Handle hTable tAPIColumnCompare aAPIColumnCompare Returns Boolean
89434>>>>>>>//        Boolean bDifferentFieldNames bShouldBeRenamed        
89434>>>>>>>//        
89434>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89434>>>>>>>//        Move (Uppercase(aAPIColumnCompare.sFieldNameFrom) <> Uppercase(aAPIColumnCompare.sFieldNameTo)) to bDifferentFieldNames
89434>>>>>>>//        
89434>>>>>>>//        If (bDifferentFieldNames = True) Begin
89434>>>>>>>//            Move (aAPIColumnCompare.iFieldNumber = aAPIColumnCompare.iFieldNumberTo) to bShouldBeRenamed
89434>>>>>>>//            If (bShouldBeRenamed = False) Begin
89434>>>>>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
89434>>>>>>>//                Function_Return False
89434>>>>>>>//            End
89434>>>>>>>//        
89434>>>>>>>//            Move (aAPIColumnCompare.iTypeFrom = aAPIColumnCompare.iTypeTo) to bShouldBeRenamed
89434>>>>>>>//            If (bShouldBeRenamed = False) Begin
89434>>>>>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
89434>>>>>>>//                Function_Return False
89434>>>>>>>//            End
89434>>>>>>>//        
89434>>>>>>>//            Move (aAPIColumnCompare.iLengthFrom = aAPIColumnCompare.iLengthTo) to bShouldBeRenamed
89434>>>>>>>//            If (bShouldBeRenamed = False) Begin
89434>>>>>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
89434>>>>>>>//                Function_Return False
89434>>>>>>>//            End
89434>>>>>>>//        
89434>>>>>>>//            Move (aAPIColumnCompare.iPrecisionFrom = aAPIColumnCompare.iPrecisionTo) to bShouldBeRenamed
89434>>>>>>>//            If (bShouldBeRenamed = False) Begin
89434>>>>>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
89434>>>>>>>//                Function_Return False
89434>>>>>>>//            End
89434>>>>>>>//        End
89434>>>>>>>//    
89434>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
89434>>>>>>>//        Function_Return True
89434>>>>>>>//    End_Function                   
89434>>>>>>>    
89434>>>>>>>    // Takes a tAPIColumnCompare struct as parameter and returns True if;
89434>>>>>>>    // - Field Numbers, Data Types, Lengths and Precisions are all equal.
89434>>>>>>>    // - The "FROM" field name is <> "TO" field name
89434>>>>>>>    // - The "FROM" field name also exists in the "TO" table; or the "TO" is part
89434>>>>>>>    //   of the "FROM" field name. E.g. "FROM" = LATEST_REPL_COST_DATE, "TO" = Latest_Repl_Cos would results in a TRUE.
89434>>>>>>>    Function UtilColumnShouldBeRenamed tAPIColumnCompare aAPIColumnCompare Returns Boolean
89436>>>>>>>        Boolean bExists bShouldRename
89436>>>>>>>        String sFieldNameFrom sFieldNameTo
89436>>>>>>>        
89436>>>>>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameFrom)) to sFieldNameFrom
89437>>>>>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameTo))   to sFieldNameTo  
89438>>>>>>>        If (sFieldNameFrom = sFieldNameTo) Begin
89440>>>>>>>            Function_Return False
89441>>>>>>>        End
89441>>>>>>>>
89441>>>>>>>        
89441>>>>>>>        Move (aAPIColumnCompare.bExistsFrom    = aAPIColumnCompare.bExistsTo      and ;              aAPIColumnCompare.iFieldNumber   = aAPIColumnCompare.iFieldNumberTo and ;              aAPIColumnCompare.iTypeFrom      = aAPIColumnCompare.iTypeTo        and ;              aAPIColumnCompare.iLengthFrom    = aAPIColumnCompare.iLengthTo      and ;              aAPIColumnCompare.iPrecisionFrom = aAPIColumnCompare.iPrecisionTo   and ;              aAPIColumnCompare.iOptionsFrom   = aAPIColumnCompare.iOptionsTo) to bShouldRename
89442>>>>>>>        If (bShouldRename = False) Begin
89444>>>>>>>            Function_Return False
89445>>>>>>>        End                      
89445>>>>>>>>
89445>>>>>>>        
89445>>>>>>>        If (sFieldNameFrom contains sFieldNameTo) Begin
89447>>>>>>>            Function_Return True
89448>>>>>>>        End
89448>>>>>>>>
89448>>>>>>>        
89448>>>>>>>        Function_Return bShouldRename
89449>>>>>>>    End_Function
89450>>>>>>>    
89450>>>>>>>    Function UtilColumnExistsWithOtherNumber tAPIColumnCompare[] aAPIColumnCompare Integer iColumn Returns Boolean
89452>>>>>>>        Boolean bExists
89452>>>>>>>        Integer iCount iSize
89452>>>>>>>        String sFieldNameFrom
89452>>>>>>>        
89452>>>>>>>        Move (Uppercase(aAPIColumnCompare[iColumn].sFieldNameFrom)) to sFieldNameFrom
89453>>>>>>>        
89453>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
89454>>>>>>>        Decrement iSize
89455>>>>>>>        for iCount from 0 to iSize
89461>>>>>>>>
89461>>>>>>>            // We're only interested in fields other than the passed field/column number:
89461>>>>>>>            If ((iCount +1) <> iColumn) Begin
89463>>>>>>>                If (Uppercase(aAPIColumnCompare[iCount].sFieldNameTo) = sFieldNameFrom) Begin
89465>>>>>>>                    Move True to bExists 
89466>>>>>>>                End  
89466>>>>>>>>
89466>>>>>>>                Else If (sFieldNameFrom contains Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
89469>>>>>>>                    Move True to bExists 
89470>>>>>>>                End
89470>>>>>>>>
89470>>>>>>>            End
89470>>>>>>>>
89470>>>>>>>        Loop
89471>>>>>>>>
89471>>>>>>>        
89471>>>>>>>        Function_Return bExists 
89472>>>>>>>    End_Function
89473>>>>>>>    
89473>>>>>>>    Function UtilColumnsCheckForRenames Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[] 
89475>>>>>>>        tAPIColumnCompare[] aAPIColumnsToRename
89475>>>>>>>        tAPIColumnCompare[] aAPIColumnsToRename
89476>>>>>>>        Integer iSize iCount iItem iFieldTo iNumberOfFieldsTo
89476>>>>>>>        Boolean bRenameField
89476>>>>>>>        
89476>>>>>>>        Open hTable
89478>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumberOfFieldsTo
89481>>>>>>>        Move 0 to iItem
89482>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize                    
89483>>>>>>>        Move (iSize min iNumberOfFieldsTo)    to iSize
89484>>>>>>>        Decrement iSize
89485>>>>>>>        for iCount from 0 to iSize    
89491>>>>>>>>
89491>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
89493>>>>>>>                Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount] to bRenameField
89494>>>>>>>                If (bRenameField = True) Begin
89496>>>>>>>                    Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToRename[iItem].iFieldNumber 
89497>>>>>>>                    Move iFieldTo                                   to aAPIColumnsToRename[iItem].iFieldNumberTo 
89498>>>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToRename[iItem].sFieldNameFrom
89499>>>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameTo     to aAPIColumnsToRename[iItem].sFieldNameTo
89500>>>>>>>                    Increment iItem
89501>>>>>>>                End
89501>>>>>>>>
89501>>>>>>>            End
89501>>>>>>>>
89501>>>>>>>        Loop
89502>>>>>>>>
89502>>>>>>>        
89502>>>>>>>        Move False to Err
89503>>>>>>>        Move 0 to LastErr
89504>>>>>>>        Function_Return aAPIColumnsToRename
89505>>>>>>>    End_Function   
89506>>>>>>>    
89506>>>>>>>    Function UtilColumnsRename Handle hTable tAPIColumnCompare[] aAPIColumnsToRename Returns Boolean
89508>>>>>>>        Integer iSize iCount
89508>>>>>>>        Boolean bOK                             
89508>>>>>>>        tAPIColumn[] aColumnsTo 
89508>>>>>>>        tAPIColumn[] aColumnsTo 
89509>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
89509>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
89510>>>>>>>
89510>>>>>>>        Move (SizeOfArray(aAPIColumnsToRename)) to iSize
89511>>>>>>>        If (iSize = 0) Begin
89513>>>>>>>            Function_Return True
89514>>>>>>>        End                     
89514>>>>>>>>
89514>>>>>>>        
89514>>>>>>>        Move False to Err
89515>>>>>>>        Decrement iSize
89516>>>>>>>        For iCount from 0 to iSize
89522>>>>>>>>
89522>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89523>>>>>>>            Get ApiColumnRename hTable aAPIColumnsToRename[iCount].sFieldNameTo aAPIColumnsToRename[iCount].sFieldNameFrom to bOK 
89524>>>>>>>        Loop
89525>>>>>>>>
89525>>>>>>>        
89525>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89526>>>>>>>        Function_Return bOK
89527>>>>>>>    End_Function
89528>>>>>>>
89528>>>>>>>    Function UtilColumnIsDateType Integer iType Boolean bIsSQLTableTo Returns Boolean
89530>>>>>>>        Boolean bDateType
89530>>>>>>>        
89530>>>>>>>        If (bIsSQLTableTo = True) Begin
89532>>>>>>>            Move (iType = SQL_TYPE_DATE or iType = SQL_TYPE_TIMESTAMP or iType = SQL_TYPE_TIMESTAMP2) to bDateType
89533>>>>>>>        End 
89533>>>>>>>>
89533>>>>>>>        Else Begin
89534>>>>>>>            Move (iType = DF_DATE or iType = DF_DATETIME) to bDateType
89535>>>>>>>        End
89535>>>>>>>>
89535>>>>>>>    
89535>>>>>>>        Function_Return bDateType
89536>>>>>>>    End_Function
89537>>>>>>>    
89537>>>>>>>    Function ApiColumnsUpdate String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo Boolean bCompareDate_DateTime Returns Boolean
89539>>>>>>>        Integer iCount iSize iColumn iTypeFrom iTypeTo iDataFlexType iIndex iLengthFrom iLengthTo iPrecisionFrom iPrecisionTo iOptionFrom iOptionTo iDbType
89539>>>>>>>        Handle hFile
89539>>>>>>>        Boolean bFieldExistsFrom bFieldExistsTo bShouldMove bIsSQLDriver bIsSame bOK bSkip
89539>>>>>>>        Boolean bRecnum bIsSQLTableTo bOpened bRecnumTable bIsOpen bSkipTypeChange bIsDateType
89539>>>>>>>        String sFieldNameFrom sFieldNameTo sDriverIDTo sDefaultValue
89539>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns
89539>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns
89543>>>>>>>        tColumnType ColumnType
89543>>>>>>>        tColumnType ColumnType
89543>>>>>>>
89543>>>>>>>        Move False to Err
89544>>>>>>>        Close hTable
89545>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
89546>>>>>>>        If (bIsOpen = False) Begin
89548>>>>>>>            Error DFERR_PROGRAM ("Function 'ApiColumnsUpdate'. Can't open table number:" * String(hTable))
89549>>>>>>>>
89549>>>>>>>            Function_Return False
89550>>>>>>>        End
89550>>>>>>>>
89550>>>>>>>
89550>>>>>>>        Get piDbType to iDbType
89551>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
89554>>>>>>>        Get IsSQLDriver sDriverIDFrom to bIsSQLDriver
89555>>>>>>>        Get UtilTableIsSQL hTable     to bIsSQLTableTo
89556>>>>>>>        If (bIsSQLTableTo = False) Begin
89558>>>>>>>            Move DATAFLEX_ID to sDriverIDTo
89559>>>>>>>        End
89559>>>>>>>>
89559>>>>>>>        Else Begin          
89560>>>>>>>            Get_Attribute DF_FILE_DRIVER of hTable to sDriverIDTo
89563>>>>>>>        End
89563>>>>>>>>
89563>>>>>>>        
89563>>>>>>>        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
89564>>>>>>>        
89564>>>>>>>        // Before we start to change the table we need to do three things;
89564>>>>>>>        // 1) Insert any new fields
89564>>>>>>>        Get UtilColumnsCheckForInserts hTable aAPIColumnCompare to aApiInsertColumns
89565>>>>>>>        If (SizeOfArray(aApiInsertColumns)) Begin
89567>>>>>>>            Get UtilColumnsInsert hTable aApiInsertColumns to bOK
89568>>>>>>>            If (bOK = False) Begin
89570>>>>>>>                Function_Return False
89571>>>>>>>            End                  
89571>>>>>>>>
89571>>>>>>>            // Update info with changes made.
89571>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
89572>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
89573>>>>>>>        End
89573>>>>>>>>
89573>>>>>>>        
89573>>>>>>>        // 2) Rename fields
89573>>>>>>>        Get UtilColumnsCheckForRenames hTable aAPIColumnCompare to aAPIRenameColumns
89574>>>>>>>        If (SizeOfArray(aAPIRenameColumns)) Begin
89576>>>>>>>            Get UtilColumnsRename hTable aAPIRenameColumns to bOK
89577>>>>>>>            If (bOK = False) Begin
89579>>>>>>>                Function_Return False
89580>>>>>>>            End
89580>>>>>>>>
89580>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
89581>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
89582>>>>>>>        End
89582>>>>>>>>
89582>>>>>>>
89582>>>>>>>        // 3) Move fields with same names
89582>>>>>>>        Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIMoveColumns
89583>>>>>>>        If (SizeOfArray(aAPIMoveColumns)) Begin
89585>>>>>>>            Get UtilColumnsMove hTable aAPIMoveColumns to bOK
89586>>>>>>>            If (bOK = False) Begin
89588>>>>>>>                Function_Return False
89589>>>>>>>            End
89589>>>>>>>>
89589>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
89590>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
89591>>>>>>>        End
89591>>>>>>>>
89591>>>>>>>        
89591>>>>>>>        // If any of the fields were changed by "Insert", "Rename" or "Move", we need to compare the fields again: 
89591>>>>>>>        If (SizeOfArray(aApiInsertColumns) or SizeOfArray(aAPIRenameColumns) or SizeOfArray(aAPIMoveColumns)) Begin
89593>>>>>>>            Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
89594>>>>>>>            If (bIsSame = True) Begin
89596>>>>>>>                Function_Return True
89597>>>>>>>            End
89597>>>>>>>>
89597>>>>>>>        End
89597>>>>>>>>
89597>>>>>>>        
89597>>>>>>>        // We can now continue to make standard field changes:
89597>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
89598>>>>>>>        Set Private.phCurrentTable to hTable
89599>>>>>>>        Move hTable to hFile
89600>>>>>>>        Structure_Start hFile sDriverIDTo
89601>>>>>>>
89601>>>>>>>            Move (SizeOfArray(aAPIColumnCompare)) to iSize
89602>>>>>>>            Decrement iSize
89603>>>>>>>            For iCount from 0 to iSize
89609>>>>>>>>
89609>>>>>>>                Send DoAdvance of ghoProgressBar
89610>>>>>>>                                
89610>>>>>>>                Move aAPIColumnCompare[iCount].bExistsFrom          to bFieldExistsFrom
89611>>>>>>>                If (bFieldExistsFrom = True) Begin
89613>>>>>>>                    Move aAPIColumnCompare[iCount].bExistsTo        to bFieldExistsTo
89614>>>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameFrom   to sFieldNameFrom
89615>>>>>>>                    Move aAPIColumnCompare[iCount].iFieldNumber     to iColumn              
89616>>>>>>>                    Set Private.piCurrentField                      to iColumn
89617>>>>>>>                    Move aAPIColumnCompare[iCount].iLengthFrom      to iLengthFrom                                   
89618>>>>>>>                    Move aAPIColumnCompare[iCount].iPrecisionFrom   to iPrecisionFrom
89619>>>>>>>                    Move aAPIColumnCompare[iCount].iOptionsFrom     to iOptionFrom
89620>>>>>>>                    
89620>>>>>>>                    Move aAPIColumnCompare[iCount].iTypeFrom        to iTypeFrom
89621>>>>>>>//                    Get UtilDFDataTypeToSqlTypeMapping sDriverIDFrom iDbType iTypeFrom to ColumnType
89621>>>>>>>//                    Move ColumnType.iDataFlexType                   to iDataFlexType
89621>>>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iDataFlexType
89622>>>>>>>                    If (iTypeFrom < -1490) Begin
89624>>>>>>>                        Move (iTypeFrom + 1500)                     to iTypeFrom
89625>>>>>>>                    End
89625>>>>>>>>
89625>>>>>>>    
89625>>>>>>>                    // If one of the two tables are SQL and the other Embedded we need to "translate"
89625>>>>>>>                    // data types between Embedded and SQL, else we can't compare the data types.
89625>>>>>>>                    If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
89627>>>>>>>                        Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeFrom
89628>>>>>>>                    End
89628>>>>>>>>
89628>>>>>>>                    Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
89631>>>>>>>                        Get UtilSqlColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeTo
89632>>>>>>>                    End
89632>>>>>>>>
89632>>>>>>>                    
89632>>>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameTo to sFieldNameTo
89633>>>>>>>                    Move aAPIColumnCompare[iCount].iLengthTo    to iLengthTo
89634>>>>>>>                    Move aAPIColumnCompare[iCount].iPrecisionTo to iPrecisionTo
89635>>>>>>>                    Move aAPIColumnCompare[iCount].iOptionsTo   to iOptionTo
89636>>>>>>>                    Move aAPIColumnCompare[iCount].iTypeTo      to iTypeTo
89637>>>>>>>                    
89637>>>>>>>                    Move False to bSkipTypeChange
89638>>>>>>>                    If (bCompareDate_DateTime = False) Begin
89640>>>>>>>                        Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkipTypeChange
89641>>>>>>>                    End
89641>>>>>>>>
89641>>>>>>>                    
89641>>>>>>>                    If (bFieldExistsTo = False) Begin 
89643>>>>>>>                        Move 0 to iColumn
89644>>>>>>>                        Create_Field hFile At iColumn
89645>>>>>>>                        Set Private.piCurrentField to iColumn
89646>>>>>>>                    End
89646>>>>>>>>
89646>>>>>>>                    
89646>>>>>>>                    If (sFieldNameFrom <> sFieldNameTo) Begin
89648>>>>>>>                        Set_Attribute DF_FIELD_NAME of hFile iColumn to sFieldNameFrom
89651>>>>>>>                    End                   
89651>>>>>>>>
89651>>>>>>>                    
89651>>>>>>>                    If (bIsSQLTableFrom = True and aAPIColumnCompare[iCount].iOptionsFrom <> C_tAPIColumn_Identity) Begin
89653>>>>>>>                        Set_Attribute DF_FIELD_NULL_ALLOWED  of hFile iColumn to aAPIColumnCompare[iCount].bAllowNULLFrom
89656>>>>>>>                        Move aAPIColumnCompare[iCount].sDefaultValueFrom to sDefaultValue
89657>>>>>>>                        If (iDataFlexType = DF_BCD and Left(sDefaultValue, 1 <> "[")) Begin
89659>>>>>>>                            Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
89660>>>>>>>                        End
89660>>>>>>>>
89660>>>>>>>                        Set_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefaultValue
89663>>>>>>>                    End
89663>>>>>>>>
89663>>>>>>>                    
89663>>>>>>>                    If (bSkipTypeChange = False) Begin
89665>>>>>>>                        If (iTypeFrom <> iTypeTo) Begin 
89667>>>>>>>                            If (bIsSQLTableTo = True) Begin
89669>>>>>>>                                Set_Attribute DF_FIELD_NATIVE_TYPE   of hFile iColumn to iTypeFrom
89672>>>>>>>                            End
89672>>>>>>>>
89672>>>>>>>                            Else Begin
89673>>>>>>>                                Set_Attribute DF_FIELD_TYPE          of hFile iColumn to iDataFlexType
89676>>>>>>>                            End
89676>>>>>>>>
89676>>>>>>>                        End
89676>>>>>>>>
89676>>>>>>>                    End
89676>>>>>>>>
89676>>>>>>>                    
89676>>>>>>>                    Get UtilColumnIsDateType iTypeFrom bIsSQLTableTo to bIsDateType   
89677>>>>>>>                    // We can't set the length or precision for Date type columns (they are fixed).
89677>>>>>>>                    If (bIsDateType = False) Begin
89679>>>>>>>                        If (iLengthFrom <> iLengthTo) Begin
89681>>>>>>>                            Set_Attribute DF_FIELD_LENGTH of hFile iColumn to iLengthFrom
89684>>>>>>>                        End
89684>>>>>>>>
89684>>>>>>>                        If (iPrecisionFrom <> iPrecisionTo) Begin
89686>>>>>>>                            Set_Attribute DF_FIELD_PRECISION of hFile iColumn to iPrecisionFrom
89689>>>>>>>                        End
89689>>>>>>>>
89689>>>>>>>                    End
89689>>>>>>>>
89689>>>>>>>    
89689>>>>>>>                    If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
89691>>>>>>>                        // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
89691>>>>>>>                        If (bRecnumTable = True) Begin
89693>>>>>>>                            Set_Attribute DF_FILE_RECNUM_TABLE of hTable to False
89696>>>>>>>                        End
89696>>>>>>>>
89696>>>>>>>    
89696>>>>>>>                        // We might need to create an index here.
89696>>>>>>>                        // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
89696>>>>>>>                        // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
89696>>>>>>>                        // index update checking logic.
89696>>>>>>>                        Get_Attribute DF_FIELD_INDEX           of hFile iColumn to iIndex
89699>>>>>>>                        If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
89701>>>>>>>                            Create_Index hFile at iIndex
89702>>>>>>>                            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hFile iIndex to 1
89705>>>>>>>                        End
89705>>>>>>>>
89705>>>>>>>
89705>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_FIELD   of hFile iIndex 1 to iColumn
89708>>>>>>>                        Set_Attribute DF_FILE_PRIMARY_INDEX    of hFile          to iIndex
89711>>>>>>>                            // Note: The order of these two are crucial!
89711>>>>>>>                            Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hFile iIndex to True
89714>>>>>>>                            Set_Attribute DF_FIELD_IS_IDENTITY of hFile iColumn    to True
89717>>>>>>>                    End
89717>>>>>>>>
89717>>>>>>>                End
89717>>>>>>>>
89717>>>>>>>            Loop 
89718>>>>>>>>
89718>>>>>>>        
89718>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89719>>>>>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89721>>>>>>>
89721>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89722>>>>>>>        Function_Return (Err = False)
89723>>>>>>>    End_Function
89724>>>>>>>
89724>>>>>>>    // * Dummy function for the Studio's Code Explorer *
89724>>>>>>>    Function API_INDEX_FUNCTIONS Returns Boolean
89726>>>>>>>        Function_Return False
89727>>>>>>>    End_Function
89728>>>>>>>
89728>>>>>>>    // Get ApiIndexCreate Customers.File_Number 1 2 0 1 -1 -1 -1 -1 -1 -1 -1 -1 to bOK
89728>>>>>>>    // Note: the "-1" can be left out as this function is overloaded to make it easier to call.
89728>>>>>>>    // Note: This doesn't set Descending attributes - Use function IndexChangeDirection to do that.
89728>>>>>>>    Function ApiIndexCreate Handle hTable Integer iIndex Integer iSegments Integer iSgmnt1 Integer iSgmnt2 Integer iSgmnt3 Integer iSgmnt4 Integer iSgmnt5 Integer iSgmnt6 Integer iSgmnt7 Integer iSgmnt8 Integer iSgmnt9 Integer iSgmnt10 Returns Boolean
89730>>>>>>>        Integer iTableNo iSegment1 iSegment2 iSegment3 iSegment4 iSegment5 iSegment6 iSegment7 iSegment8 iSegment9 iSegment10
89730>>>>>>>        String sDriverID
89730>>>>>>>        Boolean bOK
89730>>>>>>>
89730>>>>>>>        Get AutoConnectionIDLogin to bOK
89731>>>>>>>        Move -1 to iSegment1
89732>>>>>>>        Move -1 to iSegment2
89733>>>>>>>        Move -1 to iSegment3
89734>>>>>>>        Move -1 to iSegment4
89735>>>>>>>        Move -1 to iSegment5
89736>>>>>>>        Move -1 to iSegment6
89737>>>>>>>        Move -1 to iSegment7
89738>>>>>>>        Move -1 to iSegment8
89739>>>>>>>        Move -1 to iSegment9
89740>>>>>>>        Move -1 to iSegment10
89741>>>>>>>
89741>>>>>>>        If (num_arguments > 3) Begin
89743>>>>>>>            Move iSgmnt1 to iSegment1
89744>>>>>>>        End
89744>>>>>>>>
89744>>>>>>>        If (num_arguments > 4) Begin
89746>>>>>>>            Move iSgmnt2 to iSegment2
89747>>>>>>>        End
89747>>>>>>>>
89747>>>>>>>        If (num_arguments > 5) Begin
89749>>>>>>>            Move iSgmnt3 to iSegment3
89750>>>>>>>        End
89750>>>>>>>>
89750>>>>>>>        If (num_arguments > 6) Begin
89752>>>>>>>            Move iSgmnt4 to iSegment4
89753>>>>>>>        End
89753>>>>>>>>
89753>>>>>>>        If (num_arguments > 7) Begin
89755>>>>>>>            Move iSgmnt5 to iSegment5
89756>>>>>>>        End
89756>>>>>>>>
89756>>>>>>>        If (num_arguments > 8) Begin
89758>>>>>>>            Move iSgmnt6 to iSegment6
89759>>>>>>>        End
89759>>>>>>>>
89759>>>>>>>        If (num_arguments > 9) Begin
89761>>>>>>>            Move iSgmnt7 to iSegment7
89762>>>>>>>        End
89762>>>>>>>>
89762>>>>>>>        If (num_arguments > 10) Begin
89764>>>>>>>            Move iSgmnt8 to iSegment8
89765>>>>>>>        End
89765>>>>>>>>
89765>>>>>>>        If (num_arguments > 11) Begin
89767>>>>>>>            Move iSgmnt9 to iSegment9
89768>>>>>>>        End
89768>>>>>>>>
89768>>>>>>>        If (num_arguments > 12) Begin
89770>>>>>>>            Move iSgmnt10 to iSegment10
89771>>>>>>>        End
89771>>>>>>>>
89771>>>>>>>
89771>>>>>>>        Move False to Err
89772>>>>>>>        Move hTable to iTableNo
89773>>>>>>>        Get OpenTableExclusive hTable to bOK
89774>>>>>>>        If (bOK = False) Begin
89776>>>>>>>            Function_Return False
89777>>>>>>>        End
89777>>>>>>>>
89777>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89780>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89781>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
89782>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
89783>>>>>>>
89783>>>>>>>        // We start by deleting the index
89783>>>>>>>        Structure_Start hTable sDriverID
89784>>>>>>>            Delete_Index iTableNo iIndex
89785>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89786>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89788>>>>>>>
89788>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89789>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
89790>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
89791>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89792>>>>>>>        Move False to Err 
89793>>>>>>>        Move 0 to LastErr
89794>>>>>>>        Move iTableNo to hTable
89795>>>>>>>        Get OpenTableExclusive hTable to bOK
89796>>>>>>>        If (bOK = False) Begin
89798>>>>>>>            Function_Return False
89799>>>>>>>        End
89799>>>>>>>>
89799>>>>>>>
89799>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
89800>>>>>>>        Structure_Start hTable sDriverID
89801>>>>>>>            Create_Index hTable At iIndex
89802>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iSegments
89805>>>>>>>
89805>>>>>>>            If (iSgmnt1 <> -1) Begin
89807>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 1 to iSegment1
89810>>>>>>>            End
89810>>>>>>>>
89810>>>>>>>            If (iSegment2 <> -1) Begin
89812>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 2 to iSegment2
89815>>>>>>>            End
89815>>>>>>>>
89815>>>>>>>            If (iSegment3 <> -1) Begin
89817>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 3 to iSegment3
89820>>>>>>>            End
89820>>>>>>>>
89820>>>>>>>            If (iSegment4 <> -1) Begin
89822>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 4 to iSegment4
89825>>>>>>>            End
89825>>>>>>>>
89825>>>>>>>            If (iSegment5 <> -1) Begin
89827>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 5 to iSegment5
89830>>>>>>>            End
89830>>>>>>>>
89830>>>>>>>            If (iSegment6 <> -1) Begin
89832>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 6 to iSegment6
89835>>>>>>>            End
89835>>>>>>>>
89835>>>>>>>            If (iSegment7 <> -1) Begin
89837>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 7 to iSegment7
89840>>>>>>>            End
89840>>>>>>>>
89840>>>>>>>            If (iSegment8 <> -1) Begin
89842>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 8 to iSegment8
89845>>>>>>>            End
89845>>>>>>>>
89845>>>>>>>            If (iSegment9 <> -1) Begin
89847>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 9 to iSegment9
89850>>>>>>>            End
89850>>>>>>>>
89850>>>>>>>            If (iSegment10 <> -1) Begin
89852>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 10 to iSegment10
89855>>>>>>>            End
89855>>>>>>>>
89855>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89856>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89858>>>>>>>
89858>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89859>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
89860>>>>>>>
89860>>>>>>>        Function_Return (Err = False)
89861>>>>>>>    End_Function
89862>>>>>>>
89862>>>>>>>    Function APIIndexCreateByFieldNames Handle hTable tAPIIndex APIIndex tAPIIndex[] APIIndexTo tAPIIndexSegment[] aIndexSegments Returns Boolean
89864>>>>>>>        String[] aFields
89865>>>>>>>        Integer iCount iSegmentsFrom iFieldFrom iFieldTo iSegmentsTo iSQLIndexType iLastIndex iTableNo iSQLIndexTo
89865>>>>>>>        String sDriverID sSQLIndexName sTableName
89865>>>>>>>        Boolean bOK bIsSQLTable bIsOpen bIsSQLPrimaryKey bIsSQLClustered bIsSQLTemporaryIndex bExists
89865>>>>>>>
89865>>>>>>>        Move (SizeOfArray(aIndexSegments)) to iSegmentsFrom
89866>>>>>>>        If (iSegmentsFrom = 0) Begin
89868>>>>>>>            Function_Return False
89869>>>>>>>        End
89869>>>>>>>>
89869>>>>>>>
89869>>>>>>>        Get AutoConnectionIDLogin to bOK
89870>>>>>>>        Move False to Err
89871>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
89872>>>>>>>        If (bIsOpen = False) Begin
89874>>>>>>>            Function_Return False
89875>>>>>>>        End
89875>>>>>>>>
89875>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89878>>>>>>>        Get UtilTableIsSql hTable to bIsSQLTable   
89879>>>>>>>        
89879>>>>>>>        Move 0     to iSegmentsTo    
89880>>>>>>>        Move 0     to iSQLIndexType 
89881>>>>>>>        Move ""    to sSQLIndexName
89882>>>>>>>        Move False to bIsSQLTemporaryIndex 
89883>>>>>>>        Move False to bIsSQLPrimaryKey
89884>>>>>>>        Move False to bIsSQLClustered
89885>>>>>>>        
89885>>>>>>>//        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable                               to iLastIndex
89885>>>>>>>//        If (APIIndex.iIndexNumber <= iLastIndex) Begin
89885>>>>>>>//            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber      to iSegmentsTo
89885>>>>>>>//            If (bIsSQLTable = True) Begin
89885>>>>>>>//                Get_Attribute DF_INDEX_NAME of hTable APIIndex.iIndexNumber             to sSQLIndexName
89885>>>>>>>//                #IF (Required_RT_Version > 17)                                    
89885>>>>>>>//                Get_Attribute DF_INDEX_SQL_TYPE of hTable APIIndex.iIndexNumber         to iSQLIndexType
89885>>>>>>>//                Move (iSQLIndexType = DF_INDEX_TEMPORARY)                               to bIsSQLTemporaryIndex
89885>>>>>>>//                Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber  to bIsSQLPrimaryKey
89885>>>>>>>//                Get_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber  to bIsSQLClustered
89885>>>>>>>//                #ENDIF
89885>>>>>>>//            End
89885>>>>>>>//        End
89885>>>>>>>        
89885>>>>>>>        Move hTable to iTableNo 
89886>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber to bExists
89889>>>>>>>        If (bExists = True) Begin
89891>>>>>>>            Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber to bIsSQLPrimaryKey
89894>>>>>>>            If (bIsSQLPrimaryKey = False) Begin
89896>>>>>>>                // We start by deleting the index, if it exists
89896>>>>>>>                Structure_Start iTableNo sDriverID
89897>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89898>>>>>>>                    Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
89899>>>>>>>                    Delete_Index iTableNo APIIndex.iIndexNumber
89900>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
89901>>>>>>>                    Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
89902>>>>>>>                    Set Action_Text of ghoStatusPanel to "Restructures table..."
89903>>>>>>>                Structure_End iTableNo DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89905>>>>>>>                Set Action_Text of ghoStatusPanel to ""
89906>>>>>>>                
89906>>>>>>>                Get OpenTableExclusive hTable to bOK
89907>>>>>>>                If (bOK = False) Begin
89909>>>>>>>                    Function_Return False
89910>>>>>>>                End
89910>>>>>>>>
89910>>>>>>>            End
89910>>>>>>>>
89910>>>>>>>        End
89910>>>>>>>>
89910>>>>>>>        
89910>>>>>>>        Move hTable to iTableNo
89911>>>>>>>        Move False to Err
89912>>>>>>>        Move 0 to LastErr 
89913>>>>>>>
89913>>>>>>>        // Note: If the SQL index type = DF_INDEX_TEMPORARY, we _must_ set the DF_INDEX_SQL_TYPE 
89913>>>>>>>        //       _outside_ the Structure_Start/End construct.
89913>>>>>>>//        Move False to bIsSQLTemporaryIndex
89913>>>>>>>//        #IF (Required_RT_Version > 17)                                    
89913>>>>>>>//            If (bIsSQLTemporaryIndex = True and APIIndex.iIndexNumber <= iLastIndex) Begin
89913>>>>>>>//                If (APIIndex.iSQLIndexType <> iSQLIndexType) Begin
89913>>>>>>>//                    Set_Attribute DF_INDEX_SQL_TYPE of hTable APIIndex.iIndexNumber to APIIndex.iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
89913>>>>>>>//                End
89913>>>>>>>//            End
89913>>>>>>>//        #ENDIF
89913>>>>>>>        
89913>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89914>>>>>>>        Structure_Start hTable sDriverID
89915>>>>>>>            If (bIsSQLPrimaryKey = False) Begin
89917>>>>>>>                Create_Index hTable At APIIndex.iIndexNumber
89918>>>>>>>            End
89918>>>>>>>>
89918>>>>>>>
89918>>>>>>>//            If (bIsSQLTable = True) Begin                                                         
89918>>>>>>>//                // In case the SQL Index name already exists for another index number; we temporarily rename that index name;
89918>>>>>>>//                Get UtilIndexSQLIndexNameExists iTableNo APIIndex.iIndexNumber APIIndex.sSQLIndexName APIIndexTo to iSQLIndexTo
89918>>>>>>>//                If (iSQLIndexTo > 0) Begin   
89918>>>>>>>//                    Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
89918>>>>>>>//                    Set_Attribute DF_INDEX_NAME of hTable iSQLIndexTo to (sTableName + String("001") + String(iSQLIndexTo))
89918>>>>>>>//                End
89918>>>>>>>//                Set_Attribute DF_INDEX_NAME of hTable APIIndex.iIndexNumber to APIIndex.sSQLIndexName
89918>>>>>>>//            End
89918>>>>>>>            
89918>>>>>>>            If (bIsSQLTable = True) Begin // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
89920>>>>>>>                Set_Attribute DF_INDEX_SQL_TYPE        of hTable APIIndex.iIndexNumber to APIIndex.iSQLIndexType 
89923>>>>>>>                Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLPrimaryKey
89926>>>>>>>                Set_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLClustered
89929>>>>>>>            End
89929>>>>>>>>
89929>>>>>>>                
89929>>>>>>>                If (iSegmentsFrom <> iSegmentsTo) Begin
89931>>>>>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber to iSegmentsFrom
89934>>>>>>>            End
89934>>>>>>>>
89934>>>>>>>            
89934>>>>>>>            for iCount from 0 to (iSegmentsFrom -1)
89940>>>>>>>>
89940>>>>>>>                Move aIndexSegments[iCount].iFieldNumber to iFieldFrom   
89941>>>>>>>                If (iFieldFrom <> -1 ) Begin
89943>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable APIIndex.iIndexNumber (iCount +1) to iFieldFrom
89946>>>>>>>                End
89946>>>>>>>>
89946>>>>>>>            Loop                         
89947>>>>>>>>
89947>>>>>>>                
89947>>>>>>>            // If more segments existed; remove them
89947>>>>>>>//            If (iSegmentsTo > iSegmentsFrom) Begin
89947>>>>>>>//                for iCount from iSegmentsFrom to iSegmentsTo
89947>>>>>>>//                          Get ApiIndexDeleteSegment hTable APIIndex.iIndexNumber iCount to bOK
89947>>>>>>>//                Loop
89947>>>>>>>//                  Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber to iSegmentsFrom
89947>>>>>>>//            End
89947>>>>>>>                
89947>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89948>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89950>>>>>>>
89950>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89951>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89952>>>>>>>        
89952>>>>>>>        Function_Return (Err = False)
89953>>>>>>>    End_Function 
89954>>>>>>>    
89954>>>>>>>    // Checks if an SQL Index name for the "FROM" database already exists in the TO database,
89954>>>>>>>    // but with another Index number. We can then not rename the SQL index name for the TO database table.
89954>>>>>>>    Function UtilIndexSQLIndexNameExists Handle hTable Integer iIndexNumberFrom String sSQLIndexNameFrom tAPIIndex[] APIIndexTo Returns Integer
89956>>>>>>>        Integer iSize iCount iIndexNumberTo
89956>>>>>>>        String sSQLIndexNameTo
89956>>>>>>>        Integer iRetVal
89956>>>>>>>        
89956>>>>>>>        Move 0 to iRetVal     
89957>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndexNumberFrom to iRetVal
89960>>>>>>>        If (iRetVal = 0) Begin
89962>>>>>>>            Function_Return 0
89963>>>>>>>        End
89963>>>>>>>>
89963>>>>>>>        Move (SizeOfArray(APIIndexTo)) to iSize
89964>>>>>>>        Decrement iSize
89965>>>>>>>        for iCount from 0 to iSize
89971>>>>>>>>
89971>>>>>>>            If (Uppercase(sSQLIndexNameFrom) = Uppercase(APIIndexTo[iCount].sSQLIndexName)) Begin
89973>>>>>>>                If (iIndexNumberFrom <> APIIndexTo[iCount].iIndexNumber) Begin
89975>>>>>>>                    Move APIIndexTo[iCount].iIndexNumber to iRetVal
89976>>>>>>>                End
89976>>>>>>>>
89976>>>>>>>            End
89976>>>>>>>>
89976>>>>>>>        Loop
89977>>>>>>>>
89977>>>>>>>        
89977>>>>>>>        Function_Return iRetVal
89978>>>>>>>    End_Function   
89979>>>>>>>    
89979>>>>>>>    Function ApiIndexDeleteSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
89981>>>>>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
89981>>>>>>>    
89981>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89984>>>>>>>        If (iSegment = iNumSegments) Begin
89986>>>>>>>//            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89986>>>>>>>        End
89986>>>>>>>>
89986>>>>>>>    
89986>>>>>>>        Else If (iSegment > 0 and iSegment < iNumSegments) Begin
89989>>>>>>>            for iCurSegment from iSegment to (iNumSegments - 1)
89995>>>>>>>>
89995>>>>>>>                //*** Move index segment attributes
89995>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
89998>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
90001>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
90004>>>>>>>    
90004>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment to iSegmentCase
90007>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment to iSegmentDirection
90010>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment to iSegmentColumn
90013>>>>>>>            Loop
90014>>>>>>>>
90014>>>>>>>    
90014>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
90017>>>>>>>        End
90017>>>>>>>>
90017>>>>>>>    
90017>>>>>>>    End_Procedure
90018>>>>>>>
90018>>>>>>>    Function APIIndexRemoveAllIndexes Handle hTable tAPIIndex[] APIIndex Returns Boolean
90020>>>>>>>        String[] aFields
90021>>>>>>>        Integer iCount iSize iIndex 
90021>>>>>>>        String sDriverID
90021>>>>>>>        Boolean bOK bIsSQLTable bIsOpen bIsSQLPrimaryKey
90021>>>>>>>
90021>>>>>>>        Move (SizeOfArray(APIIndex)) to iSize
90022>>>>>>>        If (iSize = 0) Begin
90024>>>>>>>            Function_Return True
90025>>>>>>>        End
90025>>>>>>>>
90025>>>>>>>
90025>>>>>>>        Get AutoConnectionIDLogin to bOK
90026>>>>>>>        Move False to Err
90027>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90030>>>>>>>        If (bIsOpen = False) Begin
90032>>>>>>>            Get OpenTableExclusive hTable to bIsOpen
90033>>>>>>>            If (bIsOpen = False) Begin
90035>>>>>>>                Function_Return False
90036>>>>>>>            End
90036>>>>>>>>
90036>>>>>>>        End    
90036>>>>>>>>
90036>>>>>>>        
90036>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
90039>>>>>>>        Get UtilTableIsSql hTable to bIsSQLTable
90040>>>>>>>
90040>>>>>>>        Move False to Err
90041>>>>>>>        Move 0 to LastErr             
90042>>>>>>>        Decrement iSize
90043>>>>>>>
90043>>>>>>>        Structure_Start hTable sDriverID
90044>>>>>>>            for iCount from 0 to iSize
90050>>>>>>>>
90050>>>>>>>//                Move False to bIsSQLPrimaryKey
90050>>>>>>>//                #IF ((Required_RT_Version * 10 + Required_RT_Revision) > 180)   // DF 18.1 and up
90050>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90050>>>>>>>//                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex[iCount].iIndexNumber to bIsSQLPrimaryKey
90050>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
90050>>>>>>>//                #ENDIF
90050>>>>>>>                // We can't delete if this is a primary key index:
90050>>>>>>>//                If (bIsSQLPrimaryKey = False) Begin
90050>>>>>>>                    Move APIIndex[iCount].iIndexNumber to iIndex
90051>>>>>>>                    Delete_Index hTable iIndex
90052>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
90052>>>>>>>//                End
90052>>>>>>>            Loop
90053>>>>>>>>
90053>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
90054>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
90056>>>>>>>//        Move False to Err
90056>>>>>>>        Move 0 to LastErr
90057>>>>>>>
90057>>>>>>>        Set Action_Text of ghoStatusPanel to ""
90058>>>>>>>        Function_Return (Err = False)
90059>>>>>>>    End_Function
90060>>>>>>>
90060>>>>>>>    Function ApiIndexChangeDirection Handle hTable Integer iIndex Integer iSegment Integer iDirection Returns Boolean
90062>>>>>>>        Boolean bOK
90062>>>>>>>
90062>>>>>>>        Get AutoConnectionIDLogin to bOK
90063>>>>>>>        Move False to Err
90064>>>>>>>        Get OpenTableExclusive hTable to bOK
90065>>>>>>>        If (bOK = False) Begin
90067>>>>>>>            Function_Return False
90068>>>>>>>        End
90068>>>>>>>>
90068>>>>>>>        Structure_Start hTable
90069>>>>>>>            Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to iDirection
90072>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
90073>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
90075>>>>>>>
90075>>>>>>>        Set Action_Text of ghoStatusPanel to ""
90076>>>>>>>        Function_Return (Err = False)
90077>>>>>>>    End_Function
90078>>>>>>>
90078>>>>>>>    Function ApiIndexChangeUppercase Handle hTable Integer iIndex Integer iSegment Boolean bUppercase Returns Boolean
90080>>>>>>>        Integer iCase
90080>>>>>>>        Boolean bOK
90080>>>>>>>
90080>>>>>>>        If (bUppercase = True) Begin
90082>>>>>>>            Move DF_CASE_IGNORED to iCase
90083>>>>>>>        End
90083>>>>>>>>
90083>>>>>>>        Else Begin
90084>>>>>>>            Move DF_CASE_USED to iCase
90085>>>>>>>        End
90085>>>>>>>>
90085>>>>>>>
90085>>>>>>>        Get AutoConnectionIDLogin to bOK
90086>>>>>>>        Move False to Err
90087>>>>>>>        Get OpenTableExclusive hTable to bOK
90088>>>>>>>        If (bOK = False) Begin
90090>>>>>>>            Function_Return False
90091>>>>>>>        End
90091>>>>>>>>
90091>>>>>>>        Structure_Start hTable
90092>>>>>>>            Set_Attribute DF_INDEX_SEGMENT_CASE of hTable iIndex iSegment to iCase
90095>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
90096>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
90098>>>>>>>
90098>>>>>>>        Set Action_Text of ghoStatusPanel to ""
90099>>>>>>>        Function_Return (Err = False)
90100>>>>>>>    End_Function
90101>>>>>>>
90101>>>>>>>    // To delete an index
90101>>>>>>>    Function ApiIndexRemove Handle hTable Integer iIndex Returns Boolean
90103>>>>>>>        Integer iTableNo iNumSegments
90103>>>>>>>        String sDriverID
90103>>>>>>>        Boolean bOK
90103>>>>>>>
90103>>>>>>>        Get AutoConnectionIDLogin to bOK
90104>>>>>>>        Move False to Err
90105>>>>>>>        Move hTable to iTableNo
90106>>>>>>>        Get OpenTableExclusive hTable to bOK
90107>>>>>>>        If (bOK = False) Begin
90109>>>>>>>            Function_Return False
90110>>>>>>>        End
90110>>>>>>>>
90110>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
90113>>>>>>>
90113>>>>>>>        // Check to see if the index exists or not...
90113>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
90116>>>>>>>        If (iNumSegments = 0) Begin
90118>>>>>>>            Function_Return False
90119>>>>>>>        End
90119>>>>>>>>
90119>>>>>>>
90119>>>>>>>        Structure_Start hTable sDriverID
90120>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
90121>>>>>>>            Delete_Index iTableNo iIndex
90122>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
90123>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
90124>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
90126>>>>>>>
90126>>>>>>>        Set Action_Text of ghoStatusPanel to ""
90127>>>>>>>        Function_Return (Err = False)
90128>>>>>>>    End_Function
90129>>>>>>>
90129>>>>>>>    // Delete an Index Segment
90129>>>>>>>    Function ApiIndexRemoveSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
90131>>>>>>>        Boolean bOK bSQLDriver bIndexTemporary
90131>>>>>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
90131>>>>>>>        Integer iIndexType
90131>>>>>>>        String sDriverID
90131>>>>>>>
90131>>>>>>>        Get AutoConnectionIDLogin to bOK
90132>>>>>>>        Move False to Err
90133>>>>>>>
90133>>>>>>>        Get OpenTableExclusive hTable to bOK
90134>>>>>>>        If (bOK = False) Begin
90136>>>>>>>            Function_Return False
90137>>>>>>>        End
90137>>>>>>>>
90137>>>>>>>
90137>>>>>>>        // Check to see if the index exists or not...
90137>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
90140>>>>>>>        If (iNumSegments = 0) Begin
90142>>>>>>>            Function_Return False
90143>>>>>>>        End
90143>>>>>>>>
90143>>>>>>>
90143>>>>>>>        Move False to bIndexTemporary
90144>>>>>>>        Get psDriverID to sDriverID
90145>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
90146>>>>>>>        If (bSQLDriver) Begin
90148>>>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
90151>>>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
90154>>>>>>>                Move True to bIndexTemporary
90155>>>>>>>        End
90155>>>>>>>>
90155>>>>>>>
90155>>>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
90155>>>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
90157>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
90160>>>>>>>            If (iSegment = iNumSegments) Begin
90162>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
90165>>>>>>>            End
90165>>>>>>>>
90165>>>>>>>            Else If (iSegment > 0 and iSegment < iNumSegments) Begin
90168>>>>>>>                For iCurSegment from iSegment to (iNumSegments - 1)
90174>>>>>>>>
90174>>>>>>>                    //*** Move index segment attributes
90174>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
90177>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
90180>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
90183>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
90186>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
90189>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
90192>>>>>>>                Loop
90193>>>>>>>>
90193>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
90196>>>>>>>            End
90196>>>>>>>>
90196>>>>>>>        End
90196>>>>>>>>
90196>>>>>>>
90196>>>>>>>        Else Begin
90197>>>>>>>           Structure_Start hTable
90198>>>>>>>               Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
90201>>>>>>>               If (iSegment = iNumSegments) Begin
90203>>>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
90206>>>>>>>               End
90206>>>>>>>>
90206>>>>>>>               Else If (iSegment > 0 and iSegment < iNumSegments) Begin
90209>>>>>>>                   for iCurSegment from iSegment to (iNumSegments - 1)
90215>>>>>>>>
90215>>>>>>>                       //*** Move index segment attributes
90215>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
90218>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
90221>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
90224>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
90227>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
90230>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
90233>>>>>>>                   Loop
90234>>>>>>>>
90234>>>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
90237>>>>>>>               End
90237>>>>>>>>
90237>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
90238>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
90240>>>>>>>            Set Action_Text of ghoStatusPanel to ""
90241>>>>>>>        End
90241>>>>>>>>
90241>>>>>>>
90241>>>>>>>        Function_Return (Err = False)
90242>>>>>>>    End_Function
90243>>>>>>>
90243>>>>>>>    // Add/Insert an Index Segment
90243>>>>>>>    Function ApiIndexInsertSegment Handle hTable Integer iIndex Integer iSegment Integer iSegmentColumn Integer iSegmentCase Integer iSegmentDirection Returns Boolean
90245>>>>>>>        Boolean bOK bSQLDriver bIndexTemporary
90245>>>>>>>        Integer iNumSegments iCurSegment iCurSegmentColumn iCurSegmentCase iCurSegmentDirection
90245>>>>>>>        Integer iIndexType
90245>>>>>>>        String sDriverId
90245>>>>>>>
90245>>>>>>>        Get AutoConnectionIDLogin to bOK
90246>>>>>>>        Move False to Err
90247>>>>>>>
90247>>>>>>>        Get OpenTableExclusive hTable to bOK
90248>>>>>>>        If (bOK = False) Begin
90250>>>>>>>            Function_Return False
90251>>>>>>>        End
90251>>>>>>>>
90251>>>>>>>
90251>>>>>>>        Move False to bIndexTemporary
90252>>>>>>>        // Check to see if the index exists or not...
90252>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
90255>>>>>>>        If (iNumSegments = 0) Begin
90257>>>>>>>            Function_Return False
90258>>>>>>>        End
90258>>>>>>>>
90258>>>>>>>
90258>>>>>>>        Get psDriverID to sDriverID
90259>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
90260>>>>>>>        If (bSQLDriver) Begin
90262>>>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
90265>>>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
90268>>>>>>>                Move True to bIndexTemporary
90269>>>>>>>        End
90269>>>>>>>>
90269>>>>>>>
90269>>>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
90269>>>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
90271>>>>>>>           Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
90274>>>>>>>
90274>>>>>>>           If (iSegment > iNumSegments) Begin
90276>>>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
90279>>>>>>>               Move (iNumSegments + 1) to iCurSegment
90280>>>>>>>           End
90280>>>>>>>>
90280>>>>>>>           Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
90283>>>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
90286>>>>>>>               Move iNumSegments to iCurSegment
90287>>>>>>>
90287>>>>>>>               While (iCurSegment > iSegment)
90291>>>>>>>                   //*** Move index segment attributes
90291>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iCurSegmentCase
90294>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iCurSegmentDirection
90297>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
90300>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iCurSegmentCase
90303>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iCurSegmentDirection
90306>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iCurSegmentColumn
90309>>>>>>>                   Decrement iCurSegment
90310>>>>>>>               End
90311>>>>>>>>
90311>>>>>>>
90311>>>>>>>               //*** Now set new segment attributes
90311>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
90314>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
90317>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
90320>>>>>>>           End
90320>>>>>>>>
90320>>>>>>>        End
90320>>>>>>>>
90320>>>>>>>
90320>>>>>>>        Else Begin
90321>>>>>>>           Structure_Start hTable
90322>>>>>>>              Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
90325>>>>>>>
90325>>>>>>>              If (iSegment > iNumSegments) Begin
90327>>>>>>>                  Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
90330>>>>>>>                  Move (iNumSegments + 1) to iCurSegment
90331>>>>>>>              End
90331>>>>>>>>
90331>>>>>>>              Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
90334>>>>>>>                  Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
90337>>>>>>>                  Move iNumSegments to iCurSegment
90338>>>>>>>
90338>>>>>>>                  While (iCurSegment > iSegment)
90342>>>>>>>                      //*** Move index segment attributes
90342>>>>>>>                      Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iSegmentCase
90345>>>>>>>                      Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iSegmentDirection
90348>>>>>>>                      Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
90351>>>>>>>                      Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
90354>>>>>>>                      Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
90357>>>>>>>                      Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
90360>>>>>>>                      Decrement iCurSegment
90361>>>>>>>                  End
90362>>>>>>>>
90362>>>>>>>
90362>>>>>>>                  //*** Now set new segment attributes
90362>>>>>>>                  Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
90365>>>>>>>                  Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
90368>>>>>>>                  Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
90371>>>>>>>              End
90371>>>>>>>>
90371>>>>>>>              Set Action_Text of ghoStatusPanel to "Restructures table..."
90372>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
90374>>>>>>>            Set Action_Text of ghoStatusPanel to ""
90375>>>>>>>        End
90375>>>>>>>>
90375>>>>>>>
90375>>>>>>>        Function_Return (Err = False)
90376>>>>>>>    End_Function
90377>>>>>>>
90377>>>>>>>    Function API_TABLE_UTILITY_FUNCTIONS Returns Boolean
90379>>>>>>>        Function_Return False
90380>>>>>>>    End_Function
90381>>>>>>>
90381>>>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
90381>>>>>>>    // Note that it first removes any driver prefixes in the rootname.
90381>>>>>>>    Function UtilTableInfoCompare Boolean bCompareFilelistUppercase tAPITableNameInfoCompare APITableInfoCompare Returns Boolean
90383>>>>>>>        Boolean bIsSame
90383>>>>>>>        String sRootNameFrom sRootNameTo sLogicalNameFrom sLogicalNameTo sDisplayNameFrom sDisplayNameTo
90383>>>>>>>
90383>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameFrom    to sRootNameFrom
90384>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameTo      to sRootNameTo
90385>>>>>>>        Move APITableInfoCompare.sLogicalNameFrom               to sLogicalNameFrom
90386>>>>>>>        Move APITableInfoCompare.sLogicalNameTo                 to sLogicalNameTo
90387>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameFrom to sDisplayNameFrom
90388>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameTo   to sDisplayNameTo
90389>>>>>>>
90389>>>>>>>        If (bCompareFilelistUppercase = True) Begin
90391>>>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(sLogicalNameFrom) = Uppercase(sLogicalNameTo)) to bIsSame
90392>>>>>>>        End
90392>>>>>>>>
90392>>>>>>>        Else Begin
90393>>>>>>>            Move (sRootNameFrom = sRootNameTo and sLogicalNameFrom = sLogicalNameTo and sDisplayNameFrom = sDisplayNameTo) to bIsSame
90394>>>>>>>        End  
90394>>>>>>>>
90394>>>>>>>        If (bIsSame = False) Begin
90396>>>>>>>            Function_Return False
90397>>>>>>>        End 
90397>>>>>>>>
90397>>>>>>>
90397>>>>>>>        Move (APITableInfoCompare.bIsAliasFrom = APITableInfoCompare.bIsAliasTo) to bIsSame
90398>>>>>>>        If (bIsSame = False) Begin
90400>>>>>>>            Function_Return False
90401>>>>>>>        End 
90401>>>>>>>>
90401>>>>>>>
90401>>>>>>>        Move (APITableInfoCompare.bIsSQLFrom = APITableInfoCompare.bIsSQLTo) to bIsSame
90402>>>>>>>        If (bIsSame = False) Begin
90404>>>>>>>            Function_Return False
90405>>>>>>>        End 
90405>>>>>>>>
90405>>>>>>>
90405>>>>>>>        Move (APITableInfoCompare.bIsSystemFileFrom = APITableInfoCompare.bIsSystemFileTo) to bIsSame
90406>>>>>>>        If (bIsSame = False) Begin
90408>>>>>>>            Function_Return False
90409>>>>>>>        End 
90409>>>>>>>>
90409>>>>>>>
90409>>>>>>>        Function_Return bIsSame
90410>>>>>>>    End_Function
90411>>>>>>>
90411>>>>>>>    Function UtilTableCompare tAPITable APITableFrom tAPITable APITableTo Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
90413>>>>>>>        Handle hTableFrom hTableTo
90413>>>>>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
90413>>>>>>>        Boolean bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase
90413>>>>>>>        String sRootName sDriverIDFrom sDriverIDTo
90413>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
90413>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
90414>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
90414>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
90415>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
90415>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
90416>>>>>>>
90416>>>>>>>        Move (IsSameStruct(APITableFrom, APITableTo)) to bIsSame
90417>>>>>>>        If (bIsSame = True) Begin
90419>>>>>>>            Function_Return True
90420>>>>>>>        End
90420>>>>>>>>
90420>>>>>>>
90420>>>>>>>        Move False to bFilelistError
90421>>>>>>>        Move True to bIsSame
90422>>>>>>>        Get pbCompareDate_DateTime  to bCompareDate_DateTime
90423>>>>>>>        Get pbCompareIndexAscending to bCompareIndexAscending
90424>>>>>>>        Get pbCompareIndexUppercase to bCompareIndexUppercase
90425>>>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
90426>>>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
90427>>>>>>>
90427>>>>>>>        Move APITableFrom.ApiTableInfo.sRootName to sRootName
90428>>>>>>>        Get _TableNameOnly sRootName             to sRootName
90429>>>>>>>        Move sRootName to APITableTo.ApiTableInfo.sRootName
90430>>>>>>>
90430>>>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg is the same).
90430>>>>>>>        // bCodeGenerateMode = True = Code Generation mode.
90430>>>>>>>        If (bCodeGenerateMode = True) Begin
90432>>>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
90432>>>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
90434>>>>>>>                Function_Return False
90435>>>>>>>            End
90435>>>>>>>>
90435>>>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
90436>>>>>>>            If (bIsSame = False) Begin
90438>>>>>>>                Send UserError ("Yikes! There is a serious problem with the Filelist.cfg slot number:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * ".\nThis needs to be fixed before you can generate code for this table number.")
90439>>>>>>>                Move True to bFilelistError
90440>>>>>>>                Function_Return False
90441>>>>>>>            End
90441>>>>>>>>
90441>>>>>>>        End
90441>>>>>>>>
90441>>>>>>>
90441>>>>>>>        If (bCodeGenerateMode = False) Begin
90443>>>>>>>            // Then we want to create this table
90443>>>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
90445>>>>>>>                Function_Return False
90446>>>>>>>            End
90446>>>>>>>>
90446>>>>>>>
90446>>>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
90447>>>>>>>            If (bIsSame = False) Begin
90449>>>>>>>                Error DFERR_PROGRAM ("'UtilTableCompare function' problem in Filelist.cfg! Table No:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * "No changes was made for this entry.")
90450>>>>>>>>
90450>>>>>>>                Move True to bFilelistError
90451>>>>>>>                Function_Return False
90452>>>>>>>            End
90452>>>>>>>>
90452>>>>>>>        End
90452>>>>>>>>
90452>>>>>>>
90452>>>>>>>        // Check columns:
90452>>>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
90453>>>>>>>        Move APITableFrom.ApiTableInfo.bIsSQL       to bIsSQLFrom
90454>>>>>>>        Move APITableFrom.ApiTableInfo.sDriverID    to sDriverIDFrom
90455>>>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
90456>>>>>>>        Move APITableTo.ApiTableInfo.bIsSQL         to bIsSQLTo
90457>>>>>>>        Move APITableTo.ApiTableInfo.sDriverID      to sDriverIDTo
90458>>>>>>>        Get UtilColumnsStructFill hTableTo          to APITableTo.aApiColumns
90459>>>>>>>        Get UtilColumnCombineFromAndToArrays APITableFrom.aApiColumns APITableTo.aApiColumns to aAPIColumnCompare
90460>>>>>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
90461>>>>>>>        If (bIsSame = False) Begin
90463>>>>>>>            Function_Return False
90464>>>>>>>        End
90464>>>>>>>>
90464>>>>>>>
90464>>>>>>>        // ...then check indexes:
90464>>>>>>>        Get UtilIndexesStructFill hTableFrom to APITableTo.aApiIndexes
90465>>>>>>>        Get UtilIndexCombineFromAndToArrays APITableFrom.aApiIndexes APITableTo.aApiIndexes to aAPIIndexCompare
90466>>>>>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
90467>>>>>>>        If (bIsSame = False) Begin
90469>>>>>>>            Function_Return False
90470>>>>>>>        End
90470>>>>>>>>
90470>>>>>>>
90470>>>>>>>        // ...and finally relationships:
90470>>>>>>>        Get UtilRelationsStructFill hTableFrom to APITableTo.aApiRelations
90471>>>>>>>        Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations to aAPIRelationCompare
90472>>>>>>>        Move (IsSameArray(APITableFrom.aApiRelations, APITableTo.aApiRelations)) to bIsSame
90473>>>>>>>        Get UtilRelationsCompare hTableFrom aAPIRelationCompare to bIsSame
90474>>>>>>>
90474>>>>>>>        Function_Return (bIsSame = True)
90475>>>>>>>    End_Function
90476>>>>>>>
90476>>>>>>>    // Similar to UtilTableCompare, but takes a tAPITableCompare struct array and a tAPITableBooleans struct as params.
90476>>>>>>>    Function UtilTableCompare_Ex tAPITableCompare APITableCompare tAPITableBooleans CompareTableBooleans Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
90478>>>>>>>        Handle hTable
90478>>>>>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
90478>>>>>>>        String sRootName sDriverIDFrom sDriverIDTo
90478>>>>>>>
90478>>>>>>>        If (APITableCompare.APITableNameInfoCompare.bExistsFrom = False and APITableCompare.APITableNameInfoCompare.bExistsTo = False) Begin
90480>>>>>>>            Move True to bFilelistError
90481>>>>>>>            Function_Return False
90482>>>>>>>        End
90482>>>>>>>>
90482>>>>>>>
90482>>>>>>>        Move APITableCompare.hTable to hTable
90483>>>>>>>        Move True  to bIsSame
90484>>>>>>>        Move False to bFilelistError
90485>>>>>>>
90485>>>>>>>        If (APITableCompare.bExistsFrom = True) Begin
90487>>>>>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameFrom to sRootName
90488>>>>>>>        End
90488>>>>>>>>
90488>>>>>>>        Else Begin
90489>>>>>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameTo   to sRootName
90490>>>>>>>        End
90490>>>>>>>>
90490>>>>>>>        Get _TableNameOnly sRootName                                   to sRootName
90491>>>>>>>
90491>>>>>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDFrom     to sDriverIDFrom
90492>>>>>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDTo       to sDriverIDTo
90493>>>>>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLFrom        to bIsSQLFrom
90494>>>>>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLTo          to bIsSQLTo
90495>>>>>>>
90495>>>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg are the same).
90495>>>>>>>        // bCodeGenerateMode = True = Code Generation mode.
90495>>>>>>>        If (bCodeGenerateMode = True) Begin
90497>>>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
90497>>>>>>>            If (APITableCompare.bExistsTo = False) Begin
90499>>>>>>>                Function_Return False
90500>>>>>>>            End
90500>>>>>>>>
90500>>>>>>>            Move (Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) = Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameTo)) to bIsSame
90501>>>>>>>            If (bIsSame = False) Begin
90503>>>>>>>                Send UserError ("Yikes! There is a problem with the Filelist.cfg slot number:" * String(hTable) + ;                    ".\nThe FROM table logical name is:" * String(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) * "\nwhile the TO table logical name is:" * ;                    String(APITableCompare.APITableNameInfoCompare.sLogicalNameTo) * ".\nThis needs to be fixed before you can generate code for this table number.")
90504>>>>>>>                Move True to bFilelistError
90505>>>>>>>                Function_Return False
90506>>>>>>>            End
90506>>>>>>>>
90506>>>>>>>        End
90506>>>>>>>>
90506>>>>>>>
90506>>>>>>>        If (bCodeGenerateMode = False) Begin
90508>>>>>>>            If (APITableCompare.bExistsTo = False) Begin
90510>>>>>>>                // Then we might want to create this table
90510>>>>>>>                Function_Return False
90511>>>>>>>            End
90511>>>>>>>>
90511>>>>>>>
90511>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsAliasFrom = APITableCompare.APITableNameInfoCompare.bIsAliasTo) to bIsSame
90512>>>>>>>            If (bIsSame = False) Begin
90514>>>>>>>                Function_Return False
90515>>>>>>>            End 
90515>>>>>>>>
90515>>>>>>>    
90515>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSQLFrom = APITableCompare.APITableNameInfoCompare.bIsSQLTo) to bIsSame
90516>>>>>>>            If (bIsSame = False) Begin
90518>>>>>>>                Function_Return False
90519>>>>>>>            End 
90519>>>>>>>>
90519>>>>>>>    
90519>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSystemFileFrom = APITableCompare.APITableNameInfoCompare.bIsSystemFileTo) to bIsSame
90520>>>>>>>            If (bIsSame = False) Begin
90522>>>>>>>                Function_Return False
90523>>>>>>>            End 
90523>>>>>>>>
90523>>>>>>>
90523>>>>>>>            // Check table names et al.
90523>>>>>>>            Get UtilTableInfoCompare CompareTableBooleans.bCompareFilelistUppercase APITableCompare.APITableNameInfoCompare to bIsSame
90524>>>>>>>            If (bIsSame = False) Begin
90526>>>>>>>                Function_Return False
90527>>>>>>>            End
90527>>>>>>>>
90527>>>>>>>        End
90527>>>>>>>>
90527>>>>>>>
90527>>>>>>>        // Check Columns:
90527>>>>>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo APITableCompare.aAPIColumnsCompare CompareTableBooleans.bCompareDate_DateTime to bIsSame
90528>>>>>>>        If (bIsSame = False) Begin
90530>>>>>>>            Function_Return False
90531>>>>>>>        End
90531>>>>>>>>
90531>>>>>>>
90531>>>>>>>        // ...then check Indexes:
90531>>>>>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo APITableCompare.aAPIIndexesCompare CompareTableBooleans.bCompareIndexUppercase CompareTableBooleans.bCompareIndexAscending to bIsSame
90532>>>>>>>        If (bIsSame = False) Begin
90534>>>>>>>            Function_Return False
90535>>>>>>>        End
90535>>>>>>>>
90535>>>>>>>
90535>>>>>>>        // ...and finally Relationships:
90535>>>>>>>        Get UtilRelationsCompare hTable APITableCompare.aAPIRelationsCompare to bIsSame
90536>>>>>>>
90536>>>>>>>        Function_Return (bIsSame = True)
90537>>>>>>>    End_Function
90538>>>>>>>
90538>>>>>>>    // To fill a complete Table array structure (tAPITable[]) with data.
90538>>>>>>>    // The data + filelist.cfg path, login et al must have been setup properly first.
90538>>>>>>>    // Pass a True as first parameter if the ghoStatusPanel is active and progress info should be shown.
90538>>>>>>>    // Pass a second True if this is a comparison and the text should either reflect "FROM" or "TO" database.
90538>>>>>>>    Function UtilTablesStructArrayFill Boolean bStatusPanel Boolean bCompareUtil Boolean bFromTables Returns tAPITable[]
90540>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90540>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90540>>>>>>>        tAPITable[]     aApiTables aApiTablesEmpty
90540>>>>>>>        tAPITable[]     aApiTables aApiTablesEmpty
90542>>>>>>>        tAPIColumn[]    aApiColumns
90542>>>>>>>        tAPIColumn[]    aApiColumns
90543>>>>>>>        tAPIIndex[]     aApiIndexes
90543>>>>>>>        tAPIIndex[]     aApiIndexes
90544>>>>>>>        tAPIRelation[]  aApiRelations
90544>>>>>>>        tAPIRelation[]  aApiRelations
90545>>>>>>>        Handle hTable
90545>>>>>>>        Integer iCount iPos
90545>>>>>>>        Boolean bIsAlias bUserCancel bIsSQL bIsOpen
90545>>>>>>>        String sLogicalName sMessageText
90545>>>>>>>
90545>>>>>>>        Move 0 to hTable
90546>>>>>>>        If (bFromTables = True) Begin
90548>>>>>>>            Move "Reading 'FROM' Table Structure:" to sMessageText
90549>>>>>>>            If (bCompareUtil = True) Begin
90551>>>>>>>                Move (sMessageText * "(1 of 3)") to sMessageText
90552>>>>>>>            End
90552>>>>>>>>
90552>>>>>>>        End
90552>>>>>>>>
90552>>>>>>>        Else Begin
90553>>>>>>>            Move "Reading 'TO' Table Structure:" to sMessageText
90554>>>>>>>            If (bCompareUtil = True) Begin
90556>>>>>>>                Move (sMessageText * "(2 of 3)") to sMessageText
90557>>>>>>>            End
90557>>>>>>>>
90557>>>>>>>        End
90557>>>>>>>>
90557>>>>>>>        Set Message_Text of ghoStatusPanel to sMessageText
90558>>>>>>>
90558>>>>>>>        Get UtilFilelistNoOfTables to iCount
90559>>>>>>>        Set piMaximum of ghoProgressBar to iCount
90560>>>>>>>        Move 0 to iCount
90561>>>>>>>
90561>>>>>>>        Repeat
90561>>>>>>>>
90561>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90564>>>>>>>            If (hTable > 0 and hTable <> 50) Begin
90566>>>>>>>            
90566>>>>>>>                Open hTable
90568>>>>>>>                Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90571>>>>>>>                If (bIsOpen = False) Begin
90573>>>>>>>                    Move True to aApiTablesEmpty[0].bError
90574>>>>>>>                    Move hTable to aApiTablesEmpty[0].ApiTableInfo.iTableNumber
90575>>>>>>>                    Function_Return aApiTablesEmpty
90576>>>>>>>                End
90576>>>>>>>>
90576>>>>>>>
90576>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName 
90579>>>>>>>                Set piPosition of ghoProgressBar to iCount
90580>>>>>>>                Send DoAdvance of ghoProgressBarOverall
90581>>>>>>>                Set Action_Text of ghoStatusPanel to ("Number:" * String(hTable) * String(sLogicalName))
90582>>>>>>>
90582>>>>>>>                Get UtilTableStructFill hTable bFromTables to aApiTables[iCount]
90583>>>>>>>//                // Table Name Info
90583>>>>>>>//                Get UtilTableNameInfoStructFill hTable to ApiTableNameInfo
90583>>>>>>>//                
90583>>>>>>>//                // Fill columns
90583>>>>>>>//                Get UtilColumnsStructFill hTable to aApiColumns
90583>>>>>>>//                If (aApiColumns[0].bCancel = True) Begin
90583>>>>>>>//                    Move True to aApiTablesEmpty[0].bError
90583>>>>>>>//                    Move hTable to aApiTablesEmpty[0].ApiTableInfo.iTableNumber
90583>>>>>>>//                    Function_Return aApiTablesEmpty
90583>>>>>>>//                End
90583>>>>>>>//
90583>>>>>>>//                // Fill indexes
90583>>>>>>>//                Get UtilIndexesStructFill hTable to aApiIndexes
90583>>>>>>>//                If (aApiIndexes[0].bCancel = True) Begin
90583>>>>>>>//                    Move True to aApiTablesEmpty[0].bError
90583>>>>>>>//                    Move hTable to aApiTablesEmpty[0].ApiTableInfo.iTableNumber
90583>>>>>>>//                    Function_Return aApiTablesEmpty
90583>>>>>>>//                End
90583>>>>>>>//
90583>>>>>>>//                // Fill relationships
90583>>>>>>>//                Get UtilRelationsStructFill hTable to aApiRelations
90583>>>>>>>//                If (aApiRelations[0].bCancel = True) Begin
90583>>>>>>>//                    Move True to aApiTablesEmpty[0].bError
90583>>>>>>>//                    Move hTable to aApiTablesEmpty[0].ApiTableInfo.iTableNumber
90583>>>>>>>//                    Function_Return aApiTablesEmpty
90583>>>>>>>//                End
90583>>>>>>>
90583>>>>>>>                Close hTable DF_PERMANENT
90585>>>>>>>
90585>>>>>>>//                Move hTable             to aApiTables[iCount].hTable
90585>>>>>>>//                Move bFromTables        to aApiTables[iCount].bFromTable
90585>>>>>>>//                Move (not(bFromTables)) to aApiTables[iCount].bToTable   
90585>>>>>>>//                Move ApiTableNameInfo   to aApiTables[iCount].ApiTableInfo
90585>>>>>>>//                Move aApiColumns        to aApiTables[iCount].aApiColumns
90585>>>>>>>//                Move aApiIndexes        to aApiTables[iCount].aApiIndexes
90585>>>>>>>//                Move aApiRelations      to aApiTables[iCount].aApiRelations
90585>>>>>>>                Increment iCount
90586>>>>>>>            End
90586>>>>>>>>
90586>>>>>>>
90586>>>>>>>            If (bStatusPanel = True) Begin
90588>>>>>>>                Get Check_StatusPanel of ghoStatusPanel to bUserCancel
90589>>>>>>>                If (bUserCancel = True) Begin
90591>>>>>>>                    Move True to aApiTablesEmpty[0].bCancel
90592>>>>>>>                    Function_Return aApiTablesEmpty
90593>>>>>>>                End
90593>>>>>>>>
90593>>>>>>>            End
90593>>>>>>>>
90593>>>>>>>
90593>>>>>>>        Until (hTable = 0)
90595>>>>>>>
90595>>>>>>>        Function_Return aApiTables
90596>>>>>>>    End_Function
90597>>>>>>>    
90597>>>>>>>    // Returns a 'single' table APITable struct.
90597>>>>>>>    Function UtilTableStructFill Handle hTable Boolean bFromTables Returns tAPITable
90599>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90599>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90599>>>>>>>        tAPITable         ApiTable ApiTableEmpty
90599>>>>>>>        tAPITable         ApiTable ApiTableEmpty
90599>>>>>>>        tAPIColumn[]     aApiColumns
90599>>>>>>>        tAPIColumn[]     aApiColumns
90600>>>>>>>        tAPIIndex[]      aApiIndexes
90600>>>>>>>        tAPIIndex[]      aApiIndexes
90601>>>>>>>        tAPIRelation[]   aApiRelations
90601>>>>>>>        tAPIRelation[]   aApiRelations
90602>>>>>>>        Integer iCount iPos
90602>>>>>>>        Boolean bIsAlias bUserCancel bIsSQL bIsOpen
90602>>>>>>>        String sLogicalName sRootName sDisplayName sTableName sDriverID sMessageText
90602>>>>>>>
90602>>>>>>>        Open hTable
90604>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90607>>>>>>>        If (bIsOpen = False) Begin
90609>>>>>>>            Move True to ApiTableEmpty.bError
90610>>>>>>>            Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
90611>>>>>>>            Function_Return ApiTableEmpty
90612>>>>>>>        End
90612>>>>>>>>
90612>>>>>>>        
90612>>>>>>>        // Fill Table Name Info
90612>>>>>>>        Get UtilTableNameInfoStructFill hTable to ApiTableNameInfo
90613>>>>>>>                
90613>>>>>>>        // Fill columns
90613>>>>>>>        Get UtilColumnsStructFill hTable to aApiColumns
90614>>>>>>>        If (SizeOfArray(aApiColumns)) Begin
90616>>>>>>>            If (aApiColumns[0].bCancel = True) Begin
90618>>>>>>>                Move True to ApiTableEmpty.bError
90619>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
90620>>>>>>>                Function_Return ApiTableEmpty
90621>>>>>>>            End
90621>>>>>>>>
90621>>>>>>>        End
90621>>>>>>>>
90621>>>>>>>        
90621>>>>>>>        // Fill indexes
90621>>>>>>>        Get UtilIndexesStructFill hTable to aApiIndexes
90622>>>>>>>        If (SizeOfArray(aApiIndexes)) Begin
90624>>>>>>>            If (aApiIndexes[0].bCancel = True) Begin
90626>>>>>>>                Move True to ApiTableEmpty.bError
90627>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
90628>>>>>>>                Function_Return ApiTableEmpty
90629>>>>>>>            End
90629>>>>>>>>
90629>>>>>>>        End
90629>>>>>>>>
90629>>>>>>>        
90629>>>>>>>
90629>>>>>>>        // Fill relationships
90629>>>>>>>        Get UtilRelationsStructFill hTable to aApiRelations
90630>>>>>>>        If (SizeOfArray(aApiRelations)) Begin
90632>>>>>>>            If (aApiRelations[0].bCancel = True) Begin
90634>>>>>>>                Move True to ApiTableEmpty.bError
90635>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
90636>>>>>>>                Function_Return ApiTableEmpty
90637>>>>>>>            End
90637>>>>>>>>
90637>>>>>>>        End
90637>>>>>>>>
90637>>>>>>>        
90637>>>>>>>        Move hTable             to ApiTable.hTable
90638>>>>>>>        Move bFromTables        to ApiTable.bFromTable
90639>>>>>>>        Move (not(bFromTables)) to ApiTable.bToTable   
90640>>>>>>>
90640>>>>>>>        Move ApiTableNameInfo   to ApiTable.ApiTableInfo
90641>>>>>>>        Move aApiColumns        to ApiTable.aApiColumns
90642>>>>>>>        Move aApiIndexes        to ApiTable.aApiIndexes
90643>>>>>>>        Move aApiRelations      to ApiTable.aApiRelations
90644>>>>>>>
90644>>>>>>>        Function_Return ApiTable
90645>>>>>>>    End_Function
90646>>>>>>>
90646>>>>>>>
90646>>>>>>>    Function UtilTableNameInfoStructFill Handle hTable Returns tAPITableNameInfo
90648>>>>>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty                                      
90648>>>>>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty                                      
90648>>>>>>>        Boolean bIsOpen
90648>>>>>>>        
90648>>>>>>>        Open hTable
90650>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90653>>>>>>>        If (bIsOpen = False) Begin
90655>>>>>>>            Move True   to APITableNameInfoEmpty.bError
90656>>>>>>>            Move hTable to APITableNameInfoEmpty.iTableNumber
90657>>>>>>>            Function_Return APITableNameInfoEmpty
90658>>>>>>>        End
90658>>>>>>>>
90658>>>>>>>
90658>>>>>>>        Move hTable                                  to APITableNameInfo.iTableNumber
90659>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to APITableNameInfo.sRootName
90662>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to APITableNameInfo.sLogicalName
90665>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to APITableNameInfo.sDisplayName
90668>>>>>>>        Get_Attribute DF_FILE_DRIVER       of hTable to APITableNameInfo.sDriverID
90671>>>>>>>        
90671>>>>>>>        Get UtilTableIsAlias                  hTable to APITableNameInfo.bIsAlias
90672>>>>>>>        Get UtilTableIsSQL                    hTable to APITableNameInfo.bIsSQL
90673>>>>>>>
90673>>>>>>>        Close hTable
90674>>>>>>>
90674>>>>>>>        Function_Return APITableNameInfo
90675>>>>>>>    End_Function 
90676>>>>>>>    
90676>>>>>>>    Function UtilFindTableArrayItem tAPITable[] ByRef aTableStructure String sLogicalTableName Returns Integer
90678>>>>>>>        Integer iSize iCount iTable iItem
90678>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90678>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90678>>>>>>>
90678>>>>>>>        Move -1 to iItem
90679>>>>>>>        Move (SizeOfArray(aTableStructure)) to iSize
90680>>>>>>>        Decrement iSize
90681>>>>>>>        for iCount from 0 to iSize
90687>>>>>>>>
90687>>>>>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
90688>>>>>>>            If (Uppercase(ApiTableNameInfo.sLogicalName) = Uppercase(sLogicalTableName)) Begin
90690>>>>>>>                Move iCount to iItem
90691>>>>>>>                Move iSize  to iCount // We're done.
90692>>>>>>>            End
90692>>>>>>>>
90692>>>>>>>        Loop
90693>>>>>>>>
90693>>>>>>>
90693>>>>>>>        Function_Return iItem
90694>>>>>>>    End_Function
90695>>>>>>>
90695>>>>>>>    Function UtilTableArrayCompare tAPITable APITableFrom tAPITable APITableTo Returns Integer
90697>>>>>>>        If (APITableFrom.hTable  > APITableTo.hTable) ;            Function_Return (GT)
90700>>>>>>>        If (APITableFrom.hTable  < APITableTo.hTable) ;            Function_Return (LT)
90703>>>>>>>
90703>>>>>>>        If (APITableFrom.bFromTable = True)  ;            Function_Return (LT)
90706>>>>>>>        If (APITableFrom.bFromTable = False) ;            Function_Return (GT)
90709>>>>>>>
90709>>>>>>>        Function_Return (EQ)
90710>>>>>>>    End_Function
90711>>>>>>>
90711>>>>>>>    Function UtilTableCombineFromAndToArrays tAPITable[] aAPITableFrom tAPITable[] aAPITableTo Returns tAPITableCompare[]
90713>>>>>>>        Integer iCount iSize iSizeFrom iSizeTo iItemFrom iItemTo iItem
90713>>>>>>>        Handle hTable
90713>>>>>>>        tAPITable[] aAPITableFromAndTo aAPITableEmpty
90713>>>>>>>        tAPITable[] aAPITableFromAndTo aAPITableEmpty
90715>>>>>>>        tAPITable   APITableFrom APITableTo
90715>>>>>>>        tAPITable   APITableFrom APITableTo
90715>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
90715>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
90715>>>>>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
90715>>>>>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
90716>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
90716>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
90717>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
90717>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
90718>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
90718>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
90719>>>>>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
90719>>>>>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
90719>>>>>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
90719>>>>>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
90722>>>>>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
90722>>>>>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
90725>>>>>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
90725>>>>>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
90728>>>>>>>
90728>>>>>>>        Move (SizeOfArray(aAPITableFrom)) to iSizeFrom
90729>>>>>>>        Move (SizeOfArray(aAPITableTo))   to iSizeTo
90730>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
90732>>>>>>>            Function_Return aAPITableCompare
90733>>>>>>>        End
90733>>>>>>>>
90733>>>>>>>
90733>>>>>>>        Move (AppendArray(aAPITableFrom, aAPITableTo)) to aAPITableFromAndTo
90734>>>>>>>        Move (SortArray(aAPITableFromAndTo, Self, RefFunc(UtilTableArrayCompare))) to aAPITableFromAndTo
90735>>>>>>>
90735>>>>>>>        Move 0 to iItem
90736>>>>>>>        Move (SizeOfArray(aAPITableFromAndTo)) to iSize
90737>>>>>>>        Decrement iSize
90738>>>>>>>        for iCount from 0 to iSize
90744>>>>>>>>
90744>>>>>>>
90744>>>>>>>            Move iCount to iItemFrom
90745>>>>>>>            Move iCount to iItemTo
90746>>>>>>>            Move aAPITableEmpty to APITableFrom
90747>>>>>>>            Move aAPITableEmpty to APITableTo
90748>>>>>>>
90748>>>>>>>            If (aAPITableFromAndTo[iCount].bFromTable = True) Begin
90750>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
90751>>>>>>>            End
90751>>>>>>>>
90751>>>>>>>            If (aAPITableFromAndTo[iCount].bToTable = True) Begin
90753>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableTo
90754>>>>>>>            End
90754>>>>>>>>
90754>>>>>>>            If (aAPITableFromAndTo[iCount].hTable = aAPITableFromAndTo[iCount + 1].hTable) Begin
90756>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
90757>>>>>>>                Move (iCount + 1) to iItemTo
90758>>>>>>>                Move aAPITableFromAndTo[iItemTo]    to APITableTo
90759>>>>>>>            End
90759>>>>>>>>
90759>>>>>>>
90759>>>>>>>            Move APITableFrom.ApiTableInfo  to ApiTableInfoFrom
90760>>>>>>>            Move APITableFrom.aApiColumns   to aApiColumnsFrom
90761>>>>>>>            Move APITableFrom.aApiIndexes   to aApiIndexFrom
90762>>>>>>>            Move APITableFrom.aApiRelations to aApiRelationFrom
90763>>>>>>>
90763>>>>>>>            Move APITableTo.ApiTableInfo    to ApiTableInfoTo
90764>>>>>>>            Move APITableTo.aApiColumns     to aApiColumnsTo
90765>>>>>>>            Move APITableTo.aApiIndexes     to aApiIndexTo
90766>>>>>>>            Move APITableTo.aApiRelations   to aApiRelationTo
90767>>>>>>>
90767>>>>>>>            Move aAPITableFromAndTo[iCount].hTable to hTable
90768>>>>>>>
90768>>>>>>>            If (hTable > 0) Begin
90770>>>>>>>
90770>>>>>>>                // Table info:
90770>>>>>>>                Get UtilTableINFOCombineFromAndToArrays ApiTableInfoFrom ApiTableInfoTo to APITableNameInfoCompare
90771>>>>>>>                Move APITableNameInfoCompare.iTableNumber                               to aAPITableCompare[iItem].hTable
90772>>>>>>>                Move APITableNameInfoCompare.bExistsFrom                                to aAPITableCompare[iItem].bExistsFrom
90773>>>>>>>                Move APITableNameInfoCompare.bExistsTo                                  to aAPITableCompare[iItem].bExistsTo
90774>>>>>>>                Move APITableNameInfoCompare                                            to aAPITableCompare[iItem].APITableNameInfoCompare
90775>>>>>>>
90775>>>>>>>                // Column info:
90775>>>>>>>                Get UtilColumnCombineFromAndToArrays aApiColumnsFrom aApiColumnsTo      to aAPIColumnCompare
90776>>>>>>>                Move aAPIColumnCompare                                                  to aAPITableCompare[iItem].aAPIColumnsCompare
90777>>>>>>>
90777>>>>>>>                // Index info:
90777>>>>>>>                Get UtilIndexCombineFromAndToArrays aApiIndexFrom aApiIndexTo           to aAPIIndexCompare
90778>>>>>>>                Move aAPIIndexCompare                                                   to aAPITableCompare[iItem].aAPIIndexesCompare
90779>>>>>>>
90779>>>>>>>                // Relation info:
90779>>>>>>>                Get UtilRelationCombineFromAndToArrays aApiRelationFrom aApiRelationTo  to aAPIRelationCompare
90780>>>>>>>                Move aAPIRelationCompare                                                to aAPITableCompare[iItem].aAPIRelationsCompare
90781>>>>>>>
90781>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bShouldChange
90782>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bCancel
90783>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bError
90784>>>>>>>                If (iItemTo > iItemFrom) Begin
90786>>>>>>>                    Increment iCount
90787>>>>>>>                End
90787>>>>>>>>
90787>>>>>>>                Increment iItem
90788>>>>>>>            End
90788>>>>>>>>
90788>>>>>>>
90788>>>>>>>        Loop
90789>>>>>>>>
90789>>>>>>>
90789>>>>>>>        Function_Return aAPITableCompare
90790>>>>>>>    End_Function
90791>>>>>>>
90791>>>>>>>    Function UtilTableInfoCombineFromAndToArrays tAPITableNameInfo APITableNameInfoFrom tAPITableNameInfo APITableNameInfoTo Returns tAPITableNameInfoCompare
90793>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
90793>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
90793>>>>>>>
90793>>>>>>>        // FROM database info:
90793>>>>>>>        If (APITableNameInfoFrom.iTableNumber > 0) Begin
90795>>>>>>>            Move APITableNameInfoFrom.iTableNumber  to APITableNameInfoCompare.iTableNumber
90796>>>>>>>            Move APITableNameInfoFrom.sRootName     to APITableNameInfoCompare.sRootNameFrom
90797>>>>>>>            Move APITableNameInfoFrom.sLogicalName  to APITableNameInfoCompare.sLogicalNameFrom
90798>>>>>>>            Move APITableNameInfoFrom.sDisplayName  to APITableNameInfoCompare.sDisplayNameFrom
90799>>>>>>>            Move APITableNameInfoFrom.sDriverID     to APITableNameInfoCompare.sDriverIDFrom
90800>>>>>>>            Move APITableNameInfoFrom.bIsAlias      to APITableNameInfoCompare.bIsAliasFrom
90801>>>>>>>            Move APITableNameInfoFrom.bIsSQL        to APITableNameInfoCompare.bIsSQLFrom
90802>>>>>>>            Move True                               to APITableNameInfoCompare.bExistsFrom
90803>>>>>>>        End
90803>>>>>>>>
90803>>>>>>>
90803>>>>>>>        // TO database info:
90803>>>>>>>        If (APITableNameInfoTo.iTableNumber > 0) Begin
90805>>>>>>>            Move APITableNameInfoTo.iTableNumber    to APITableNameInfoCompare.iTableNumber
90806>>>>>>>            Move APITableNameInfoTo.sRootName       to APITableNameInfoCompare.sRootNameTo
90807>>>>>>>            Move APITableNameInfoTo.sLogicalName    to APITableNameInfoCompare.sLogicalNameTo
90808>>>>>>>            Move APITableNameInfoTo.sDisplayName    to APITableNameInfoCompare.sDisplayNameTo
90809>>>>>>>            Move APITableNameInfoTo.sDriverID       to APITableNameInfoCompare.sDriverIDTo
90810>>>>>>>            Move APITableNameInfoTo.bIsAlias        to APITableNameInfoCompare.bIsAliasTo
90811>>>>>>>            Move APITableNameInfoTo.bIsSQL          to APITableNameInfoCompare.bIsSQLTo
90812>>>>>>>            Move True                               to APITableNameInfoCompare.bExistsTo
90813>>>>>>>        End
90813>>>>>>>>
90813>>>>>>>
90813>>>>>>>        Function_Return APITableNameInfoCompare
90814>>>>>>>    End_Function
90815>>>>>>>
90815>>>>>>>    // Note:
90815>>>>>>>    // The DF_FILE_TABLE_NAME attribute holds the name of the table at the back end. Depending on the back end, table
90815>>>>>>>    // names may be case sensitive, contain spaces or other special characters. This attribute is used to determine a table's
90815>>>>>>>    // back end name when using Embedded SQL. Since Embedded SQL works on the back end directly, the back end's name must be used.
90815>>>>>>>    // In most cases the back end name will be the same as the table name used in DataFlex.
90815>>>>>>>    // To do the opposite; To get the file handle from a table name string use the UtilTableNameToHandle function.
90815>>>>>>>    Function UtilTableHandleToString Handle hTable Returns String
90817>>>>>>>        String sTableName
90817>>>>>>>        Boolean bOpen bExists bOK
90817>>>>>>>
90817>>>>>>>        Get UtilTableNumberIsInUse hTable to bExists
90818>>>>>>>        If (bExists = False) Begin
90820>>>>>>>            Function_Return ""
90821>>>>>>>        End
90821>>>>>>>>
90821>>>>>>>
90821>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90822>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
90825>>>>>>>        If (bOpen = False) Begin
90827>>>>>>>            Get AutoConnectionIDLogin to bOK
90828>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90829>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
90830>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
90831>>>>>>>            Open hTable
90833>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90834>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
90835>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
90836>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
90839>>>>>>>        End
90839>>>>>>>>
90839>>>>>>>        If (bOpen = True) Begin
90841>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90842>>>>>>>            Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName
90845>>>>>>>            // If blank it is an embedded table:
90845>>>>>>>            If (sTableName = "") Begin
90847>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
90850>>>>>>>                Move 0 to LastErr
90851>>>>>>>                Move False to Err
90852>>>>>>>            End
90852>>>>>>>>
90852>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90853>>>>>>>        End
90853>>>>>>>>
90853>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90854>>>>>>>
90854>>>>>>>        Function_Return sTableName
90855>>>>>>>    End_Function
90856>>>>>>>
90856>>>>>>>    // Returns the filenumber for the passed Table name from Filelist.cfg.
90856>>>>>>>    // Returns 0 if unsuccessful.
90856>>>>>>>    // To do the opposite; To get the string value from a table handle string use the UtilTableHandleToString function.
90856>>>>>>>    Function UtilTableNameToHandle String sTableName Returns Integer
90858>>>>>>>        String sValue sPrefixTableName sDriverID
90858>>>>>>>        Handle hTable hRetval
90858>>>>>>>
90858>>>>>>>        Get psDriverID to sDriverID
90859>>>>>>>        If (sDriverID <> DATAFLEX_ID and not(sTableName contains ":")) Begin
90861>>>>>>>            Move (sDriverID + ":" + sTableName) to sPrefixTableName
90862>>>>>>>        End
90862>>>>>>>>
90862>>>>>>>        Move 0 to hTable
90863>>>>>>>        Move 0 to hRetval
90864>>>>>>>        Repeat
90864>>>>>>>>
90864>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90867>>>>>>>            If (hTable <> 0) Begin
90869>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sValue
90872>>>>>>>                If (Uppercase(sValue) = Uppercase(sTableName) or Uppercase(sValue) = Uppercase(sPrefixTableName)) Begin
90874>>>>>>>                    Move hTable to hRetval
90875>>>>>>>                    Move 0 to hTable
90876>>>>>>>                End
90876>>>>>>>>
90876>>>>>>>            End
90876>>>>>>>>
90876>>>>>>>        Until (hTable = 0)
90878>>>>>>>
90878>>>>>>>        Function_Return hRetval
90879>>>>>>>    End_Function
90880>>>>>>>
90880>>>>>>>    // * Dummy function for the Studio's Code Explorer *
90880>>>>>>>    Function API_COLUMN_UTILITY_FUNCTIONS Returns Boolean
90882>>>>>>>        Function_Return False
90883>>>>>>>    End_Function
90884>>>>>>>
90884>>>>>>>    // Compare multiple columns. (For 'FROM' & 'TO' tables)
90884>>>>>>>    Function UtilColumnsCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare[] aAPIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
90886>>>>>>>        Boolean bIsSame
90886>>>>>>>        Integer iCount iSize iColumn
90886>>>>>>>
90886>>>>>>>        Move True to bIsSame
90887>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
90888>>>>>>>        Set piMaximum of ghoProgressBar  to iSize
90889>>>>>>>
90889>>>>>>>        Decrement iSize
90890>>>>>>>        for iCount from 0 to iSize
90896>>>>>>>>
90896>>>>>>>            Set piPosition of ghoProgressBar to iCount
90897>>>>>>>            Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare[iCount] bCompareDate_DataTime to bIsSame
90898>>>>>>>            If (bIsSame = False) Begin
90900>>>>>>>                Function_Return False
90901>>>>>>>            End
90901>>>>>>>>
90901>>>>>>>        Loop
90902>>>>>>>>
90902>>>>>>>
90902>>>>>>>        Function_Return (bIsSame = True)
90903>>>>>>>    End_Function
90904>>>>>>>
90904>>>>>>>    // Compares a single column (For 'FROM' & 'TO' tables)
90904>>>>>>>    Function UtilColumnCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare APIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
90906>>>>>>>        Integer iFromType iToType iDbType
90906>>>>>>>        tColumnType ColumnType 
90906>>>>>>>        tColumnType ColumnType 
90906>>>>>>>        Boolean bIsDateTypeFrom bIsDateTypeTo
90906>>>>>>>        
90906>>>>>>>        If (APIColumnCompare.bCancelFrom = True or APIColumnCompare.bCancelTo = True) Begin
90908>>>>>>>            Function_Return False
90909>>>>>>>        End
90909>>>>>>>>
90909>>>>>>>        If (APIColumnCompare.bExistsFrom = False or APIColumnCompare.bExistsTo = False) Begin
90911>>>>>>>            Function_Return False
90912>>>>>>>        End
90912>>>>>>>>
90912>>>>>>>        If (Uppercase(APIColumnCompare.sFieldNameFrom) <> Uppercase(APIColumnCompare.sFieldNameTo)) Begin
90914>>>>>>>            Function_Return False
90915>>>>>>>        End  
90915>>>>>>>>
90915>>>>>>>        If (APIColumnCompare.bAllowNULLFrom <> APIColumnCompare.bAllowNULLTo) Begin
90917>>>>>>>            Function_Return False
90918>>>>>>>        End                      
90918>>>>>>>>
90918>>>>>>>        If (APIColumnCompare.sDefaultValueFrom <> APIColumnCompare.sDefaultValueTo) Begin
90920>>>>>>>            Function_Return False
90921>>>>>>>        End                      
90921>>>>>>>>
90921>>>>>>>
90921>>>>>>>        Get piDbType                       to iDbType
90922>>>>>>>        Move APIColumnCompare.iTypeFrom    to iFromType
90923>>>>>>>        Move APIColumnCompare.iTypeTo      to iToType 
90924>>>>>>>
90924>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
90924>>>>>>>        // data types between Embedded and SQL.
90924>>>>>>>        If (bIsSQLFrom = True and bIsSQLTo = False) Begin
90926>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iFromType APIColumnCompare.iLengthFrom to iFromType
90927>>>>>>>        End
90927>>>>>>>>
90927>>>>>>>        If (bIsSQLFrom = False and bIsSQLTo = True) Begin
90929>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iToType APIColumnCompare.iLengthTo to iToType
90930>>>>>>>        End
90930>>>>>>>>
90930>>>>>>>
90930>>>>>>>        Get UtilColumnIsDateType iFromType bIsSQLFrom to bIsDateTypeFrom
90931>>>>>>>        Get UtilColumnIsDateType iToType   bIsSQLTo   to bIsDateTypeTo
90932>>>>>>>
90932>>>>>>>        // Make Date and DateTime comparison?
90932>>>>>>>        If (bCompareDate_DataTime = True) Begin
90934>>>>>>>            If (iFromType <> iToType) Begin
90936>>>>>>>                Function_Return False
90937>>>>>>>            End
90937>>>>>>>>
90937>>>>>>>        End
90937>>>>>>>>
90937>>>>>>>
90937>>>>>>>        // This is when not checking for Date/DateTime differences but all other other field types...
90937>>>>>>>        If (bCompareDate_DataTime = False and bIsDateTypeFrom = False) Begin
90939>>>>>>>            If (iFromType <> iToType) Begin
90941>>>>>>>                Function_Return False
90942>>>>>>>            End
90942>>>>>>>>
90942>>>>>>>        End
90942>>>>>>>>
90942>>>>>>>
90942>>>>>>>        // Only if the field is not a Date type (any of them) we compare length & precision.
90942>>>>>>>        If (bIsDateTypeFrom = False) Begin
90944>>>>>>>            If (APIColumnCompare.iLengthFrom <> APIColumnCompare.iLengthTo) Begin
90946>>>>>>>                Function_Return False
90947>>>>>>>            End
90947>>>>>>>>
90947>>>>>>>            If (APIColumnCompare.iPrecisionFrom <> APIColumnCompare.iPrecisionTo) Begin
90949>>>>>>>                Function_Return False
90950>>>>>>>            End
90950>>>>>>>>
90950>>>>>>>        End
90950>>>>>>>>
90950>>>>>>>
90950>>>>>>>        If (APIColumnCompare.iOptionsFrom <> APIColumnCompare.iOptionsTo) Begin
90952>>>>>>>            Function_Return False
90953>>>>>>>        End
90953>>>>>>>>
90953>>>>>>>
90953>>>>>>>        Function_Return True
90954>>>>>>>    End_Function
90955>>>>>>>
90955>>>>>>>    Function UtilColumnsStructFill Handle hTable Returns tAPIColumn[]
90957>>>>>>>        Integer iNumColumns iColumn iCount iOptions iDbType iType iLength iPrecision iCheckFieldNumber
90957>>>>>>>        Boolean bIdentityKey bDawSqlDriver bSqlDriver bIsOpen bExists bIsSqlTable bUserCancel bState
90957>>>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
90957>>>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
90959>>>>>>>        String sDriverID sFieldName sRootName sLogicalName sValue
90959>>>>>>>
90959>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90960>>>>>>>        Get piDbType to iDbType
90961>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
90964>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
90967>>>>>>>
90967>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90970>>>>>>>        If (bIsOpen = False) Begin
90972>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90973>>>>>>>            Open hTable
90975>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90976>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90979>>>>>>>            If (bIsOpen = False) Begin
90981>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
90982>>>>>>>                Move True to APIColumnsEmpty[0].bError
90983>>>>>>>                Function_Return APIColumnsEmpty
90984>>>>>>>            End
90984>>>>>>>>
90984>>>>>>>        End
90984>>>>>>>>
90984>>>>>>>
90984>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
90987>>>>>>>        Get IsSQLDriver    sDriverID to bSqlDriver
90988>>>>>>>        Get IsDAWSQLDriver sDriverID to bDawSqlDriver
90989>>>>>>>
90989>>>>>>>        Get UtilTableIsSQLByRootName sRootName to bIsSqlTable
90990>>>>>>>        If (bIsSqlTable = True) Begin
90992>>>>>>>            Get UtilTableExists hTable to bExists
90993>>>>>>>            If (bExists = False) Begin
90995>>>>>>>                Move True to APIColumnsEmpty[0].bError
90996>>>>>>>                Function_Return APIColumnsEmpty
90997>>>>>>>            End
90997>>>>>>>>
90997>>>>>>>        End
90997>>>>>>>>
90997>>>>>>>
90997>>>>>>>        Move 0 to iCount
90998>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
91001>>>>>>>        Set piMaximum of ghoProgressBar to iNumColumns
91002>>>>>>>
91002>>>>>>>        for iColumn from 1 to iNumColumns
91008>>>>>>>>
91008>>>>>>>            Move 0 to iOptions
91009>>>>>>>            Move False to bIdentityKey
91010>>>>>>>            Move False to Err
91011>>>>>>>            Move 0     to LastErr
91012>>>>>>>            Move bIsSqlTable to APIColumns[iCount].bIsSQLType
91013>>>>>>>            Set piPosition of ghoProgressBar to iColumn
91014>>>>>>>            If (bDawSqlDriver = True) Begin
91016>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
91017>>>>>>>                If (bIsSqlTable = True) Begin
91019>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iType
91022>>>>>>>                    Move iType                                                to APIColumns[iCount].iType
91023>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE_NAME of hTable iColumn to APIColumns[iCount].sType
91026>>>>>>>                    Get_Attribute DF_FIELD_NULL_ALLOWED     of hTable iColumn to APIColumns[iCount].bAllowNULL
91029>>>>>>>                    Get_Attribute DF_FIELD_DEFAULT_VALUE    of hTable iColumn to APIColumns[iCount].sDefaultValue 
91032>>>>>>>                End
91032>>>>>>>>
91032>>>>>>>                Else Begin
91033>>>>>>>                    Get_Attribute DF_FIELD_TYPE             of hTable iColumn to APIColumns[iCount].iType
91036>>>>>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
91037>>>>>>>                End
91037>>>>>>>>
91037>>>>>>>
91037>>>>>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
91037>>>>>>>                Get_Attribute DF_Field_Number of hTable iColumn to iCheckFieldNumber
91040>>>>>>>                Move (iCheckFieldNumber >= 0) to bExists
91041>>>>>>>                If (bExists = False) Begin
91043>>>>>>>                    Move 0 to APIColumns[iCount].iType
91044>>>>>>>                End
91044>>>>>>>>
91044>>>>>>>                If (bExists = True) Begin
91046>>>>>>>                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
91049>>>>>>>                End
91049>>>>>>>>
91049>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
91050>>>>>>>                If (bIdentityKey = True) Begin
91052>>>>>>>                    Move C_tAPIColumn_Identity to APIColumns[iCount].iOptions
91053>>>>>>>                End
91053>>>>>>>>
91053>>>>>>>            End
91053>>>>>>>>
91053>>>>>>>            Else Begin
91054>>>>>>>                Move False to Err
91055>>>>>>>                Move 0     to LastErr
91056>>>>>>>                If (bIsSqlTable = True) Begin
91058>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to APIColumns[iCount].iType
91061>>>>>>>                End
91061>>>>>>>>
91061>>>>>>>                Else Begin
91062>>>>>>>                    Get_Attribute DF_FIELD_TYPE        of hTable iColumn to APIColumns[iCount].iType
91065>>>>>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
91066>>>>>>>                End
91066>>>>>>>>
91066>>>>>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
91066>>>>>>>                Move (LastErr <> DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) to bExists
91067>>>>>>>                If (bExists = False) Begin
91069>>>>>>>                    Move 0 to APIColumns[iCount].iType
91070>>>>>>>                End
91070>>>>>>>>
91070>>>>>>>            End
91070>>>>>>>>
91070>>>>>>>
91070>>>>>>>            If (bExists = True) Begin
91072>>>>>>>                Move iColumn to APIColumns[iCount].iFieldNumber
91073>>>>>>>                Get_Attribute DF_FIELD_NAME        of hTable iColumn to APIColumns[iCount].sFieldName
91076>>>>>>>                // ToDo: Can't use native_size as it can get way to big and causes "out of memory" problems.
91076>>>>>>>//                If (bIsSqlTable = True) Begin
91076>>>>>>>//                    Get_Attribute DF_FIELD_NATIVE_SIZE of hTable iColumn to APIColumns[iCount].iLength
91076>>>>>>>//                    Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
91076>>>>>>>//                End
91076>>>>>>>                Get_Attribute DF_FIELD_LENGTH      of hTable iColumn to APIColumns[iCount].iLength
91079>>>>>>>                Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
91082>>>>>>>
91082>>>>>>>                // If the length was zero we might have an Overlap(!) field.
91082>>>>>>>                // We then need check the DF_FIELD_TYPE if it really is and reset data for this array item.
91082>>>>>>>                If (APIColumns[iCount].iLength = 0) Begin
91084>>>>>>>                    Get_Attribute DF_FIELD_TYPE    of hTable iColumn to iType
91087>>>>>>>                    If (iType = DF_OVERLAP) Begin
91089>>>>>>>                        Move 0 to APIColumns[iCount].iFieldNumber
91090>>>>>>>                        Move 0 to APIColumns[iCount].iLength
91091>>>>>>>                        Move 0 to APIColumns[iCount].iOptions
91092>>>>>>>                        Move 0 to APIColumns[iCount].iPrecision
91093>>>>>>>                        Move DF_OVERLAP to APIColumns[iCount].iType
91094>>>>>>>                        Move "" to APIColumns[iCount].sFieldName
91095>>>>>>>                        Decrement iCount
91096>>>>>>>                    End
91096>>>>>>>>
91096>>>>>>>                End
91096>>>>>>>>
91096>>>>>>>            End
91096>>>>>>>>
91096>>>>>>>            Get Check_StatusPanel of ghoStatusPanel to bUserCancel
91097>>>>>>>            If (bUserCancel = True) Begin
91099>>>>>>>                Move True to APIColumnsEmpty[0].bCancel
91100>>>>>>>                Function_Return APIColumnsEmpty
91101>>>>>>>            End
91101>>>>>>>>
91101>>>>>>>            Increment iCount
91102>>>>>>>        Loop
91103>>>>>>>>
91103>>>>>>>
91103>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91104>>>>>>>        Function_Return APIColumns
91105>>>>>>>    End_Function
91106>>>>>>>
91106>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
91106>>>>>>>    // The combined data will be sorted on the first struct member: iIndexNumber
91106>>>>>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
91106>>>>>>>    // have "holes" in the series of index numbers.
91106>>>>>>>    Function UtilColumnCombineFromAndToArrays tAPIColumn[] APIColumnFrom tAPIColumn[] APIColumnTo Returns tAPIIndexCompare[]
91108>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
91108>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
91109>>>>>>>        tAPIColumnCompare   APIColumnCompare
91109>>>>>>>        tAPIColumnCompare   APIColumnCompare
91109>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem iColumnFrom iColumnTo
91109>>>>>>>
91109>>>>>>>        Move (SizeOfArray(APIColumnFrom)) to iSizeFrom
91110>>>>>>>        Decrement iSizeFrom
91111>>>>>>>        for iCount from 0 to iSizeFrom
91117>>>>>>>>
91117>>>>>>>            Move APIColumnFrom[iCount].iFieldNumber     to aAPIColumnCompare[iCount].iFieldNumber
91118>>>>>>>            Move APIColumnFrom[iCount].sFieldName       to aAPIColumnCompare[iCount].sFieldNameFrom
91119>>>>>>>            Move APIColumnFrom[iCount].iType            to aAPIColumnCompare[iCount].iTypeFrom
91120>>>>>>>            Move APIColumnFrom[iCount].sType            to aAPIColumnCompare[iCount].sTypeFrom
91121>>>>>>>            Move APIColumnFrom[iCount].iLength          to aAPIColumnCompare[iCount].iLengthFrom
91122>>>>>>>            Move APIColumnFrom[iCount].iPrecision       to aAPIColumnCompare[iCount].iPrecisionFrom
91123>>>>>>>            Move APIColumnFrom[iCount].iOptions         to aAPIColumnCompare[iCount].iOptionsFrom
91124>>>>>>>            Move APIColumnFrom[iCount].bIsSQLType       to aAPIColumnCompare[iCount].bIsSQLTypeFrom  
91125>>>>>>>            Move APIColumnFrom[iCount].bAllowNULL       to aAPIColumnCompare[iCount].bAllowNULLFrom
91126>>>>>>>            Move APIColumnFrom[iCount].sDefaultValue    to aAPIColumnCompare[iCount].sDefaultValueFrom
91127>>>>>>>            Move APIColumnFrom[iCount].bShouldChange    to aAPIColumnCompare[iCount].bShouldChangeFrom
91128>>>>>>>            Move APIColumnFrom[iCount].bCancel          to aAPIColumnCompare[iCount].bCancelFrom
91129>>>>>>>            Move APIColumnFrom[iCount].bError           to aAPIColumnCompare[iCount].bErrorFrom
91130>>>>>>>            Move True                                   to aAPIColumnCompare[iCount].bExistsFrom
91131>>>>>>>        Loop
91132>>>>>>>>
91132>>>>>>>
91132>>>>>>>        Move (SizeOfArray(APIColumnTo)) to iSizeTo
91133>>>>>>>        Decrement iSizeTo
91134>>>>>>>        for iCount from 0 to iSizeTo
91140>>>>>>>>
91140>>>>>>>            Move APIColumnTo[iCount].iFieldNumber       to APIColumnCompare.iFieldNumber
91141>>>>>>>            // Search if the field number already exists in the array; else add it.
91141>>>>>>>            Move (SearchArray(APIColumnCompare, aAPIColumnCompare)) to iItem
91142>>>>>>>            If (iItem = -1) Begin
91144>>>>>>>                Move (SizeOfArray(aAPIColumnCompare))   to iItem
91145>>>>>>>            End
91145>>>>>>>>
91145>>>>>>>
91145>>>>>>>            Move APIColumnCompare.iFieldNumber          to aAPIColumnCompare[iItem].iFieldNumber
91146>>>>>>>            Move APIColumnTo[iCount].iFieldNumber       to aAPIColumnCompare[iItem].iFieldNumberTo
91147>>>>>>>            Move APIColumnTo[iCount].sFieldName         to aAPIColumnCompare[iItem].sFieldNameTo
91148>>>>>>>            Move APIColumnTo[iCount].iType              to aAPIColumnCompare[iItem].iTypeTo
91149>>>>>>>            Move APIColumnTo[iCount].sType              to aAPIColumnCompare[iItem].sTypeTo
91150>>>>>>>            Move APIColumnTo[iCount].iLength            to aAPIColumnCompare[iItem].iLengthTo
91151>>>>>>>            Move APIColumnTo[iCount].iPrecision         to aAPIColumnCompare[iItem].iPrecisionTo
91152>>>>>>>            Move APIColumnTo[iCount].iOptions           to aAPIColumnCompare[iItem].iOptionsTo
91153>>>>>>>            Move APIColumnTo[iCount].bIsSQLType         to aAPIColumnCompare[iItem].bIsSQLTypeTo
91154>>>>>>>            Move APIColumnTo[iCount].bAllowNULL         to aAPIColumnCompare[iItem].bAllowNULLTo
91155>>>>>>>            Move APIColumnTo[iCount].sDefaultValue      to aAPIColumnCompare[iItem].sDefaultValueTo
91156>>>>>>>            Move APIColumnTo[iCount].bShouldChange      to aAPIColumnCompare[iItem].bShouldChangeTo
91157>>>>>>>            Move APIColumnTo[iCount].bCancel            to aAPIColumnCompare[iItem].bCancelTo
91158>>>>>>>            Move APIColumnTo[iCount].bError             to aAPIColumnCompare[iItem].bErrorTo
91159>>>>>>>            Move True                                   to aAPIColumnCompare[iItem].bExistsTo
91160>>>>>>>        Loop
91161>>>>>>>>
91161>>>>>>>
91161>>>>>>>        Move (SortArray(aAPIColumnCompare)) to aAPIColumnCompare
91162>>>>>>>
91162>>>>>>>        Function_Return aAPIColumnCompare
91163>>>>>>>    End_Function
91164>>>>>>>
91164>>>>>>>    // Checks if a field name exists in a table definition
91164>>>>>>>    // Returns True if it does
91164>>>>>>>    // Sample:
91164>>>>>>>    //   Get UtilColumnExists MyTable.File_Number "MyColumnName" to iExists
91164>>>>>>>    Function UtilColumnExists Handle hTable String sFieldName Returns Boolean
91166>>>>>>>        Integer iNumColumns iColumn
91166>>>>>>>        String sColumn
91166>>>>>>>        Boolean bExists bOK bOpen
91166>>>>>>>
91166>>>>>>>        Get AutoConnectionIDLogin to bOK
91167>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91168>>>>>>>        Open hTable
91170>>>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91171>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
91174>>>>>>>        If (bOpen = False) Begin
91176>>>>>>>            Function_Return False
91177>>>>>>>        End
91177>>>>>>>>
91177>>>>>>>
91177>>>>>>>        Move False to bExists
91178>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
91181>>>>>>>        for iColumn from 1 to iNumColumns
91187>>>>>>>>
91187>>>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
91190>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
91192>>>>>>>                Move iNumColumns to iColumn
91193>>>>>>>                Move True to bExists
91194>>>>>>>            End
91194>>>>>>>>
91194>>>>>>>        Loop
91195>>>>>>>>
91195>>>>>>>        Close hTable
91196>>>>>>>
91196>>>>>>>        Function_Return bExists
91197>>>>>>>    End_Function
91198>>>>>>>
91198>>>>>>>    // Returns the field/column number for the passed FieldName as an integer.
91198>>>>>>>    Function UtilColumnNameToColumnNumber Handle hTable String sFieldName Returns Integer
91200>>>>>>>        Integer iNumColumns iColumn iRetval
91200>>>>>>>        String sColumn
91200>>>>>>>        Boolean bOK bOpen
91200>>>>>>>
91200>>>>>>>        Get AutoConnectionIDLogin to bOK
91201>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91202>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91203>>>>>>>        Open hTable
91205>>>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91206>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
91209>>>>>>>        If (bOpen = False) Begin
91211>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
91212>>>>>>>            Function_Return False
91213>>>>>>>        End
91213>>>>>>>>
91213>>>>>>>
91213>>>>>>>        Move 0 to iColumn
91214>>>>>>>        Move 0 to iRetval
91215>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
91218>>>>>>>        for iColumn from 1 to iNumColumns
91224>>>>>>>>
91224>>>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
91227>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
91229>>>>>>>                Move iColumn to iRetval
91230>>>>>>>                Move iNumColumns to iColumn
91231>>>>>>>            End
91231>>>>>>>>
91231>>>>>>>        Loop
91232>>>>>>>>
91232>>>>>>>        Close hTable
91233>>>>>>>
91233>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91234>>>>>>>        Function_Return iRetval
91235>>>>>>>    End_Function
91236>>>>>>>
91236>>>>>>>    // To convert between a data type string name and its integer constant declaration. E.g."VarChar" -> SQL_VarChar
91236>>>>>>>    // The reciprocal function is UtilColumnTypeToInteger.
91236>>>>>>>    Function UtilColumnTypeToInteger String sDriverID Integer iDbType String sDataType Returns Integer
91238>>>>>>>        tColumnType RetvalType
91238>>>>>>>        tColumnType RetvalType
91238>>>>>>>
91238>>>>>>>        Get _UtilColumnType sDriverID iDbType 0 sDataType False to RetvalType
91239>>>>>>>        Function_Return RetvalType.iSQLType
91240>>>>>>>    End_Function
91241>>>>>>>
91241>>>>>>>    // To convert between an integer data type constant and its string value. E.g. SQL_VarChar -> "VarChar".
91241>>>>>>>    // The reciprocal function is UtilColumnTypeToString.
91241>>>>>>>    Function UtilColumnTypeToString String sDriverID Integer iDbType Integer iDataType Returns String
91243>>>>>>>        tColumnType RetvalType
91243>>>>>>>        tColumnType RetvalType
91243>>>>>>>
91243>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91244>>>>>>>        Function_Return RetvalType.sSQLType
91245>>>>>>>    End_Function
91246>>>>>>>
91246>>>>>>>    Function UtilColumnTypePrecision String sDriverID Integer iDbType Integer iDataType Returns String
91248>>>>>>>        tColumnType RetvalType
91248>>>>>>>        tColumnType RetvalType
91248>>>>>>>
91248>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91249>>>>>>>        Function_Return RetvalType.sPrecision
91250>>>>>>>    End_Function
91251>>>>>>>
91251>>>>>>>    Function UtilColumnTypeFixed String sDriverID Integer iDbType Integer iDataType Returns Boolean
91253>>>>>>>        tColumnType RetvalType
91253>>>>>>>        tColumnType RetvalType
91253>>>>>>>
91253>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91254>>>>>>>        Function_Return RetvalType.bCanEditSize
91255>>>>>>>    End_Function
91256>>>>>>>
91256>>>>>>>    Function UtilColumnTypePrecisionSize String sDriverID Integer iDbType Integer iDataType Returns Integer
91258>>>>>>>        tColumnType RetvalType
91258>>>>>>>        tColumnType RetvalType
91258>>>>>>>        String sValue
91258>>>>>>>        Integer iRetval iPos
91258>>>>>>>
91258>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91259>>>>>>>        Move RetvalType.sPrecision to sValue
91260>>>>>>>        Move (Pos(".", sValue)) to iPos
91261>>>>>>>        If (iPos <> 0) Begin
91263>>>>>>>            Move (Left(sValue, (iPos -1))) to iRetval
91264>>>>>>>        End
91264>>>>>>>>
91264>>>>>>>        Else Begin
91265>>>>>>>            Move sValue to iRetval
91266>>>>>>>        End
91266>>>>>>>>
91266>>>>>>>        Function_Return iRetval
91267>>>>>>>    End_Function
91268>>>>>>>
91268>>>>>>>    Function UtilColumnTypePrecisionDec String sDriverID Integer iDbType Integer iDataType Returns Integer
91270>>>>>>>        tColumnType RetvalType
91270>>>>>>>        tColumnType RetvalType
91270>>>>>>>        String sValue
91270>>>>>>>        Integer iRetval iPos
91270>>>>>>>
91270>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91271>>>>>>>        Move RetvalType.sPrecision to sValue
91272>>>>>>>        Move (Pos(".", sValue)) to iPos
91273>>>>>>>        If (iPos = 0) Begin
91275>>>>>>>            Function_Return 0
91276>>>>>>>        End
91276>>>>>>>>
91276>>>>>>>        Move (Mid(sValue, 99, (iPos + 1))) to iRetval
91277>>>>>>>
91277>>>>>>>        Function_Return iRetval
91278>>>>>>>    End_Function
91279>>>>>>>
91279>>>>>>>    // * Dummy function for the Studio's Code Explorer *
91279>>>>>>>    Function API_INDEX_UTILITY_FUNCTIONS Returns Boolean
91281>>>>>>>        Function_Return False
91282>>>>>>>    End_Function
91283>>>>>>>
91283>>>>>>>    // Compares multiple indexes for a 'FROM' and a 'TO' table.
91283>>>>>>>    Function UtilIndexesCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare[] aAPIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
91285>>>>>>>        Boolean bIsSame
91285>>>>>>>        Integer iCount iSize
91285>>>>>>>
91285>>>>>>>        Move True to bIsSame
91286>>>>>>>        Move (SizeOfArray(aAPIIndexCompare)) to iSize
91287>>>>>>>        Decrement iSize
91288>>>>>>>        For iCount from 0 to iSize
91294>>>>>>>>
91294>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91295>>>>>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
91296>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
91297>>>>>>>            If (bIsSame = False) Begin
91299>>>>>>>                Function_Return False
91300>>>>>>>            End
91300>>>>>>>>
91300>>>>>>>        Loop
91301>>>>>>>>
91301>>>>>>>
91301>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91302>>>>>>>        Function_Return bIsSame
91303>>>>>>>    End_Function
91304>>>>>>>
91304>>>>>>>    // Compares a single index for a 'FROM' and a 'TO' table.
91304>>>>>>>    // ToDo: ReDo; remove table handles! And add bIsSQLtablefrom/to
91304>>>>>>>    Function UtilIndexCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare APIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
91306>>>>>>>        Boolean bIsSame
91306>>>>>>>        Integer iSegment
91306>>>>>>>
91306>>>>>>>        Move (APIIndexCompare.bExistsFrom = APIIndexCompare.bExistsTo) to bIsSame
91307>>>>>>>        If (bIsSame = False) Begin
91309>>>>>>>            Function_Return False
91310>>>>>>>        End
91310>>>>>>>>
91310>>>>>>>        Move (APIIndexCompare.iPrimaryIndexFrom = APIIndexCompare.iPrimaryIndexTo) to bIsSame
91311>>>>>>>        If (bIsSame = False) Begin
91313>>>>>>>            Function_Return False
91314>>>>>>>        End
91314>>>>>>>>
91314>>>>>>>
91314>>>>>>>        If (bIsSqlTableFrom = True and bIsSqlTableTo = True) Begin
91316>>>>>>>            // * We should probably not compare SQL index names?
91316>>>>>>>            // Move (Uppercase(aIndexFrom.sSQLIndexName) = Uppercase(aIndexTo.sSQLIndexName)) to bIsSame
91316>>>>>>>            // If (bIsSame = False) Begin   DF_INDEX_SERVER_ONLY
91316>>>>>>>            //     Function_Return False
91316>>>>>>>            // End
91316>>>>>>>            Move (APIIndexCompare.bIsSQLPrimaryKeyFrom = APIIndexCompare.bIsSQLPrimaryKeyTo) to bIsSame
91317>>>>>>>            If (bIsSame = False) Begin
91319>>>>>>>                Function_Return False
91320>>>>>>>            End
91320>>>>>>>>
91320>>>>>>>            Move (APIIndexCompare.bIsSQLClusteredFrom = APIIndexCompare.bIsSQLClusteredTo) to bIsSame
91321>>>>>>>            If (bIsSame = False) Begin
91323>>>>>>>                Function_Return False
91324>>>>>>>            End
91324>>>>>>>>
91324>>>>>>>            Move (APIIndexCompare.iSQLIndexTypeFrom = APIIndexCompare.iSQLIndexTypeTo) to bIsSame
91325>>>>>>>            If (bIsSame = False) Begin
91327>>>>>>>                Function_Return False
91328>>>>>>>            End
91328>>>>>>>>
91328>>>>>>>        End
91328>>>>>>>>
91328>>>>>>>
91328>>>>>>>        Get UtilIndexSegmentsCompare APIIndexCompare.IndexSegmentArrayFrom APIIndexCompare.IndexSegmentArrayTo bCompareIndexUppercase bCompareIndexAscending to iSegment
91329>>>>>>>        Move (iSegment = -1) to bIsSame
91330>>>>>>>
91330>>>>>>>        Function_Return (bIsSame = True)
91331>>>>>>>    End_Function
91332>>>>>>>
91332>>>>>>>    // Compares each segment for the passed index.
91332>>>>>>>    // Returns -1 if same; else returns the index segment that differs.
91332>>>>>>>    Function UtilIndexSegmentsCompare tAPIIndexSegment[] aIndexSegmentFrom tAPIIndexSegment[] aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
91334>>>>>>>        Integer iNumSegmentsFrom iNumSegmentsTo iNumSegments iSegment
91334>>>>>>>        Boolean bIsSame
91334>>>>>>>
91334>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91335>>>>>>>        Move (SizeOfArray(aIndexSegmentFrom))      to iNumSegmentsFrom
91336>>>>>>>        Move (SizeOfArray(aIndexSegmentTo))        to iNumSegmentsTo
91337>>>>>>>        Move (iNumSegmentsFrom max iNumSegmentsTo) to iNumSegments
91338>>>>>>>
91338>>>>>>>        Decrement iNumSegments
91339>>>>>>>        for iSegment from 0 to iNumSegments
91345>>>>>>>>
91345>>>>>>>            Move False to bIsSame
91346>>>>>>>            If (iSegment <= iNumSegmentsFrom and iSegment <= iNumSegmentsTo) Begin
91348>>>>>>>                Get UtilIndexSegmentCompare aIndexSegmentFrom[iSegment] aIndexSegmentTo[iSegment] bCompareIndexUppercase bCompareIndexAscending to bIsSame
91349>>>>>>>            End
91349>>>>>>>>
91349>>>>>>>            If (bIsSame = False) Begin
91351>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
91352>>>>>>>                Function_Return iSegment
91353>>>>>>>            End
91353>>>>>>>>
91353>>>>>>>        Loop
91354>>>>>>>>
91354>>>>>>>
91354>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91355>>>>>>>        Function_Return -1 // This means bIsSame = True
91356>>>>>>>    End_Function
91357>>>>>>>
91357>>>>>>>    Function UtilIndexSegmentCompare tAPIIndexSegment aIndexSegmentFrom tAPIIndexSegment aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
91359>>>>>>>        Boolean bIsSame
91359>>>>>>>
91359>>>>>>>        Move (aIndexSegmentFrom.iFieldNumber = aIndexSegmentTo.iFieldNumber) to bIsSame
91360>>>>>>>        If (bIsSame = False) Begin
91362>>>>>>>            Function_Return False
91363>>>>>>>        End
91363>>>>>>>>
91363>>>>>>>        If (bCompareIndexUppercase = True) Begin
91365>>>>>>>            Move (aIndexSegmentFrom.bUppercase = aIndexSegmentTo.bUppercase) to bIsSame
91366>>>>>>>            If (bIsSame = False) Begin
91368>>>>>>>                Function_Return False
91369>>>>>>>            End
91369>>>>>>>>
91369>>>>>>>        End
91369>>>>>>>>
91369>>>>>>>        If (bCompareIndexAscending = True) Begin
91371>>>>>>>            Move (aIndexSegmentFrom.bAscending = aIndexSegmentTo.bAscending) to bIsSame
91372>>>>>>>            If (bIsSame = False) Begin
91374>>>>>>>                Function_Return False
91375>>>>>>>            End
91375>>>>>>>>
91375>>>>>>>        End
91375>>>>>>>>
91375>>>>>>>
91375>>>>>>>        Function_Return True
91376>>>>>>>    End_Function
91377>>>>>>>
91377>>>>>>>    Function UtilIndexesUpdate Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndex[] aIndexesFrom tAPIIndex[] aIndexesTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
91379>>>>>>>        Boolean bIsSame bOK bExists
91379>>>>>>>        Integer iSize iSizeFrom iSizeTo iCount iIndexSegment               
91379>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
91379>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
91380>>>>>>>
91380>>>>>>>        Move (SizeOfArray(aIndexesFrom)) to iSize
91381>>>>>>>        If (iSize = 0) Begin
91383>>>>>>>            Function_Return True
91384>>>>>>>        End                     
91384>>>>>>>>
91384>>>>>>>        Move (SizeOfArray(aIndexesTo)) to iSizeTo  
91385>>>>>>>        Get UtilTableIsSql hTable to bIsSQLTableTo
91386>>>>>>>        Get UtilIndexCombineFromAndToArrays aIndexesFrom aIndexesTo to aAPIIndexCompare
91387>>>>>>>        
91387>>>>>>>        for iCount from 0 to (iSize - 1) 
91393>>>>>>>>
91393>>>>>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
91394>>>>>>>            If (bIsSame = False) Begin
91396>>>>>>>                Get APIIndexCreateByFieldNames hTable aIndexesFrom[iCount] aIndexesTo aIndexesFrom[iCount].IndexSegmentArray to bOK
91397>>>>>>>            End
91397>>>>>>>>
91397>>>>>>>        Loop  
91398>>>>>>>>
91398>>>>>>>        
91398>>>>>>>        // We probably should delete other indexes if they exists.
91398>>>>>>>        for iCount from (iSize +1) to iSizeTo
91404>>>>>>>>
91404>>>>>>>            Get ApiIndexRemove hTable iCount to bOK
91405>>>>>>>        Loop
91406>>>>>>>>
91406>>>>>>>
91406>>>>>>>        Function_Return bOK
91407>>>>>>>    End_Function
91408>>>>>>>
91408>>>>>>>//    Function UtilIsSameColumnDefinitions Handle hTable tAPIColumn[] aColumns Returns Boolean
91408>>>>>>>//        Boolean bEqual bIdentityKey bSqlDriver bDawSqlDriver bIsOpen
91408>>>>>>>//        Integer iCount iColumn iSize iOptions iLength iPrecision iType
91408>>>>>>>//        String sFieldName sDriverID
91408>>>>>>>//
91408>>>>>>>//        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
91408>>>>>>>//        If (bIsOpen = False) Begin
91408>>>>>>>//            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91408>>>>>>>//            Open hTable
91408>>>>>>>//            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91408>>>>>>>//            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
91408>>>>>>>//            If (bIsOpen = False) Begin
91408>>>>>>>//                Function_Return False
91408>>>>>>>//            End
91408>>>>>>>//        End
91408>>>>>>>//
91408>>>>>>>//        Move True to bEqual
91408>>>>>>>//        Get psDriverID to sDriverID
91408>>>>>>>//        Get IsSQLDriver    sDriverID to bSqlDriver
91408>>>>>>>//        Get IsDAWSQLDriver sDriverID to bDawSqlDriver
91408>>>>>>>//        Move (SizeOfArray(aColumns)) to iSize
91408>>>>>>>//        Decrement iSize
91408>>>>>>>//
91408>>>>>>>//        For iCount from 0 to iSize
91408>>>>>>>//            Move 0 to iOptions
91408>>>>>>>//            Move False to bIdentityKey
91408>>>>>>>//            Move aColumns[iCount].sFieldName to sFieldName
91408>>>>>>>//
91408>>>>>>>//            // We need to use the column name - not the column integer as
91408>>>>>>>//            // the order does not need to be the same, and the logic should still work.
91408>>>>>>>//            Get UtilColumnNameToColumnNumber hTable sFieldName to iColumn
91408>>>>>>>//            If (iColumn > 0) Begin
91408>>>>>>>//                If (bDawSqlDriver = True) Begin
91408>>>>>>>//                    Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
91408>>>>>>>//                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iType
91408>>>>>>>//                    If (iType <> aColumns[iCount].iSQLType) Begin
91408>>>>>>>//                        Move False to bEqual
91408>>>>>>>//                    End
91408>>>>>>>//                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
91408>>>>>>>//                    If (bIdentityKey = True) Begin
91408>>>>>>>//                        Move C_tAPIColumn_Identity to iOptions
91408>>>>>>>//                    End
91408>>>>>>>//                    If (iOptions <> aColumns[iCount].iOptions) Begin
91408>>>>>>>//                        Move False to bEqual
91408>>>>>>>//                    End
91408>>>>>>>//                    Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
91408>>>>>>>//                End
91408>>>>>>>//                Else Begin
91408>>>>>>>//                    Get_Attribute DF_FIELD_TYPE     of hTable iColumn to iType
91408>>>>>>>//                    If (iType <> aColumns[iCount].iSQLType) Begin
91408>>>>>>>//                        Move False to bEqual
91408>>>>>>>//                    End
91408>>>>>>>//                End
91408>>>>>>>//                Get_Attribute DF_FIELD_LENGTH       of hTable iColumn to iLength
91408>>>>>>>//                If (iLength <> aColumns[iCount].iLength) Begin
91408>>>>>>>//                    Move False to bEqual
91408>>>>>>>//                End
91408>>>>>>>//                Get_Attribute DF_FIELD_PRECISION    of hTable iColumn to iPrecision
91408>>>>>>>//                If (iPrecision <> aColumns[iCount].iPrecision) Begin
91408>>>>>>>//                    Move False to bEqual
91408>>>>>>>//                End
91408>>>>>>>//                If (bEqual = False) Begin
91408>>>>>>>//                    Function_Return False
91408>>>>>>>//                End
91408>>>>>>>//            End
91408>>>>>>>//
91408>>>>>>>//            Else Begin
91408>>>>>>>//                Function_Return False
91408>>>>>>>//            End
91408>>>>>>>//        Loop
91408>>>>>>>//
91408>>>>>>>//        Function_Return bEqual
91408>>>>>>>//    End_Function
91408>>>>>>>
91408>>>>>>>    Function UtilIndexesStructFill Handle hTable Returns tAPIIndex[]
91410>>>>>>>        tAPIIndex[] APIIndexes
91410>>>>>>>        tAPIIndex[] APIIndexes
91411>>>>>>>        Integer iCount iIndex iIndexes iSegment iSegmentCount iNumSegments iColumn
91411>>>>>>>        String sDriverID
91411>>>>>>>        Boolean bDAWSQLDriver bIsOpen bIsSQLTable bIsSQLPrimaryKey
91411>>>>>>>
91411>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91412>>>>>>>        Get psDriverID to sDriverID
91413>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
91414>>>>>>>        Get UtilTableIsSQL hTable to bIsSQLTable
91415>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
91418>>>>>>>        If (bIsOpen = False) Begin
91420>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91421>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91422>>>>>>>            Open hTable
91424>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
91425>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91426>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
91429>>>>>>>            If (bIsOpen = False) Begin
91431>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
91432>>>>>>>                Move True to APIIndexes[0].bError
91433>>>>>>>                Function_Return APIIndexes
91434>>>>>>>            End
91434>>>>>>>>
91434>>>>>>>        End
91434>>>>>>>>
91434>>>>>>>
91434>>>>>>>        Move 0 to iCount
91435>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iIndexes
91438>>>>>>>        for iIndex from 1 to iIndexes
91444>>>>>>>>
91444>>>>>>>            // This is a test that the index exists as there might be "holes" aka the index
91444>>>>>>>            // numbers doesn't not need to be consequitive:
91444>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
91447>>>>>>>            If (iNumSegments > 0) Begin
91449>>>>>>>
91449>>>>>>>                Move iIndex                                                     to APIIndexes[iCount].iIndexNumber
91450>>>>>>>                Get_Attribute DF_FILE_PRIMARY_INDEX of hTable                   to APIIndexes[iCount].iPrimaryIndex
91453>>>>>>>                If (bIsSQLTable = True) Begin
91455>>>>>>>                    Get_Attribute DF_INDEX_NAME         of hTable iIndex        to APIIndexes[iCount].sSQLIndexName
91458>>>>>>>                        Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to APIIndexes[iCount].bIsSQLPrimaryKey
91461>>>>>>>                        Get_Attribute DF_INDEX_CLUSTERED of hTable iIndex       to APIIndexes[iCount].bIsSQLClustered
91464>>>>>>>                        Get_Attribute DF_INDEX_SQL_TYPE of hTable iIndex        to APIIndexes[iCount].iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
91467>>>>>>>                End
91467>>>>>>>>
91467>>>>>>>
91467>>>>>>>                Move 0 to iSegmentCount
91468>>>>>>>                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
91471>>>>>>>                For iSegment from 1 to iNumSegments
91477>>>>>>>>
91477>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iSegment to iColumn
91480>>>>>>>                    Move iColumn                                                       to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].iFieldNumber
91481>>>>>>>                    Get_Attribute DF_FIELD_NAME              of hTable iColumn         to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].sFieldName
91484>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bUppercase
91487>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bAscending
91490>>>>>>>                    Increment iSegmentCount
91491>>>>>>>                Loop
91492>>>>>>>>
91492>>>>>>>                Increment iCount
91493>>>>>>>            End
91493>>>>>>>>
91493>>>>>>>        Loop
91494>>>>>>>>
91494>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91495>>>>>>>
91495>>>>>>>        Function_Return APIIndexes
91496>>>>>>>    End_Function
91497>>>>>>>
91497>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
91497>>>>>>>    // The combined data will be sorted on the first struct member: iIndexNumber
91497>>>>>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
91497>>>>>>>    // have "holes" in the series of index numbers.
91497>>>>>>>    Function UtilIndexCombineFromAndToArrays tAPIIndex[] APIIndexFrom tAPIIndex[] APIIndexTo Returns tAPIIndexCompare[]
91499>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
91499>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
91500>>>>>>>        tAPIIndexCompare   APIIndexCompare
91500>>>>>>>        tAPIIndexCompare   APIIndexCompare
91500>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem iIndexFrom iIndexTo
91500>>>>>>>
91500>>>>>>>        Move (SizeOfArray(APIIndexFrom)) to iSizeFrom
91501>>>>>>>        Move (SizeOfArray(APIIndexTo)) to iSizeTo
91502>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
91504>>>>>>>            Function_Return aAPIIndexCompare
91505>>>>>>>        End
91505>>>>>>>>
91505>>>>>>>
91505>>>>>>>        Decrement iSizeFrom
91506>>>>>>>        for iCount from 0 to iSizeFrom
91512>>>>>>>>
91512>>>>>>>            Move APIIndexFrom[iCount].iIndexNumber      to aAPIIndexCompare[iCount].iIndexNumber
91513>>>>>>>            Move APIIndexFrom[iCount].iPrimaryIndex     to aAPIIndexCompare[iCount].iPrimaryIndexFrom
91514>>>>>>>            Move APIIndexFrom[iCount].sSQLIndexName     to aAPIIndexCompare[iCount].sSQLIndexNameFrom
91515>>>>>>>            Move APIIndexFrom[iCount].iSQLIndexType     to aAPIIndexCompare[iCount].iSQLIndexTypeFrom
91516>>>>>>>            Move APIIndexFrom[iCount].bIsSQLClustered   to aAPIIndexCompare[iCount].bIsSQLClusteredFrom
91517>>>>>>>            Move APIIndexFrom[iCount].bIsSQLPrimaryKey  to aAPIIndexCompare[iCount].bIsSQLPrimaryKeyFrom
91518>>>>>>>            Move APIIndexFrom[iCount].IndexSegmentArray to aAPIIndexCompare[iCount].IndexSegmentArrayFrom
91519>>>>>>>            Move APIIndexFrom[iCount].bShouldChange     to aAPIIndexCompare[iCount].bShouldChangeFrom
91520>>>>>>>            Move APIIndexFrom[iCount].bCancel           to aAPIIndexCompare[iCount].bCancelFrom
91521>>>>>>>            Move APIIndexFrom[iCount].bError            to aAPIIndexCompare[iCount].bErrorFrom
91522>>>>>>>            Move True                                   to aAPIIndexCompare[iCount].bExistsFrom
91523>>>>>>>        Loop
91524>>>>>>>>
91524>>>>>>>
91524>>>>>>>        Decrement iSizeTo
91525>>>>>>>        for iCount from 0 to iSizeTo
91531>>>>>>>>
91531>>>>>>>            Move APIIndexTo[iCount].iIndexNumber        to APIIndexCompare.iIndexNumber
91532>>>>>>>            // Search if the Index number already exists in the array; else add it.
91532>>>>>>>            Move (SearchArray(APIIndexCompare, aAPIIndexCompare)) to iItem
91533>>>>>>>            If (iItem = -1) Begin
91535>>>>>>>                Move (SizeOfArray(aAPIIndexCompare))    to iItem
91536>>>>>>>            End
91536>>>>>>>>
91536>>>>>>>
91536>>>>>>>            Move APIIndexCompare.iIndexNumber           to aAPIIndexCompare[iItem].iIndexNumber
91537>>>>>>>            Move APIIndexTo[iCount].iPrimaryIndex       to aAPIIndexCompare[iItem].iPrimaryIndexTo
91538>>>>>>>            Move APIIndexTo[iCount].sSQLIndexName       to aAPIIndexCompare[iItem].sSQLIndexNameTo
91539>>>>>>>            Move APIIndexTo[iCount].iSQLIndexType       to aAPIIndexCompare[iItem].iSQLIndexTypeTo
91540>>>>>>>            Move APIIndexTo[iCount].bIsSQLClustered     to aAPIIndexCompare[iItem].bIsSQLClusteredTo
91541>>>>>>>            Move APIIndexTo[iCount].bIsSQLPrimaryKey    to aAPIIndexCompare[iItem].bIsSQLPrimaryKeyTo
91542>>>>>>>            Move APIIndexTo[iCount].IndexSegmentArray   to aAPIIndexCompare[iItem].IndexSegmentArrayTo
91543>>>>>>>            Move APIIndexTo[iCount].bShouldChange       to aAPIIndexCompare[iItem].bShouldChangeTo
91544>>>>>>>            Move APIIndexTo[iCount].bCancel             to aAPIIndexCompare[iItem].bCancelTo
91545>>>>>>>            Move APIIndexTo[iCount].bError              to aAPIIndexCompare[iItem].bErrorTo
91546>>>>>>>            Move True                                   to aAPIIndexCompare[iItem].bExistsTo
91547>>>>>>>        Loop
91548>>>>>>>>
91548>>>>>>>
91548>>>>>>>        Move (SortArray(aAPIIndexCompare)) to aAPIIndexCompare
91549>>>>>>>
91549>>>>>>>        Function_Return aAPIIndexCompare
91550>>>>>>>    End_Function
91551>>>>>>>
91551>>>>>>>    // This is the same as the UtilIndexCompare function but it takes tAPIIndex structs as params.
91551>>>>>>>    Function UtilIndexTypeNumberCompare Handle hTable tAPIIndex aIndexFrom tAPIIndex aIndexTo Returns Boolean
91553>>>>>>>        Boolean bIsSame bDAWSQLDriver bIsSqlTable
91553>>>>>>>        String sDriverID
91553>>>>>>>        Integer iSegment
91553>>>>>>>        
91553>>>>>>>        Get psDriverID to sDriverID
91554>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
91555>>>>>>>        Get IsSQLDriver sDriverID to bIsSqlTable
91556>>>>>>>        If (bIsSqlTable = True) Begin
91558>>>>>>>            Get UtilTableIsSQL hTable to bIsSqlTable
91559>>>>>>>        End
91559>>>>>>>>
91559>>>>>>>
91559>>>>>>>        Move (aIndexFrom.iIndexNumber = aIndexTo.iIndexNumber) to bIsSame
91560>>>>>>>        If (bIsSame = False) Begin
91562>>>>>>>            Function_Return False
91563>>>>>>>        End
91563>>>>>>>>
91563>>>>>>>
91563>>>>>>>        If (bDAWSQLDriver = True and bIsSqlTable = True) Begin
91565>>>>>>>            // Don't think we should do this. Or should we?
91565>>>>>>>            // Move (aIndexesFrom[iCount].sSQLIndexName = aIndexesTo[iCount].sSQLIndexName) to bIsSame
91565>>>>>>>
91565>>>>>>>            Move (aIndexFrom.iSQLIndexType = aIndexTo.iSQLIndexType) to bIsSame
91566>>>>>>>            If (bIsSame = False) Begin
91568>>>>>>>                Function_Return False
91569>>>>>>>            End    
91569>>>>>>>>
91569>>>>>>>            Move (aIndexFrom.iPrimaryIndex = aIndexTo.iPrimaryIndex) to bIsSame
91570>>>>>>>            If (bIsSame = False) Begin
91572>>>>>>>                Function_Return False
91573>>>>>>>            End
91573>>>>>>>>
91573>>>>>>>            Move (aIndexFrom.bIsSQLPrimaryKey = aIndexTo.bIsSQLPrimaryKey) to bIsSame
91574>>>>>>>            If (bIsSame = False) Begin
91576>>>>>>>                Function_Return False
91577>>>>>>>            End                      
91577>>>>>>>>
91577>>>>>>>            Move (aIndexFrom.bIsSQLClustered = aIndexTo.bIsSQLClustered) to bIsSame
91578>>>>>>>            If (bIsSame = False) Begin
91580>>>>>>>                Function_Return False
91581>>>>>>>            End                      
91581>>>>>>>>
91581>>>>>>>        End
91581>>>>>>>>
91581>>>>>>>        
91581>>>>>>>        Function_Return bIsSame
91582>>>>>>>    End_Function
91583>>>>>>>
91583>>>>>>>    // DF_INDEX_SQL_TYPE values
91583>>>>>>>    // Pass one of the DF_INDEX_XXX integer constants and the function
91583>>>>>>>    // returns a string with the name.
91583>>>>>>>    Function UtilIndexTypeToString Integer iIndexType Returns String
91585>>>>>>>        String sRetval
91585>>>>>>>        Case Begin
91585>>>>>>>            Case (iIndexType = DF_INDEX_CLIENT)
91587>>>>>>>                Move "DF_INDEX_CLIENT" to sRetval
91588>>>>>>>                Case Break
91589>>>>>>>            Case (iIndexType = DF_INDEX_SERVER)
91592>>>>>>>                Move "DF_INDEX_SERVER" to sRetval
91593>>>>>>>                Case Break
91594>>>>>>>            Case (iIndexType = DF_INDEX_SERVER_ONLY)
91597>>>>>>>                Move "DF_INDEX_SERVER_ONLY" to sRetval
91598>>>>>>>                Case Break
91599>>>>>>>            Case (iIndexType = DF_INDEX_TEMPORARY)
91602>>>>>>>                Move "DF_INDEX_TEMPORARY" to sRetval
91603>>>>>>>                Case Break
91604>>>>>>>            Case Else
91604>>>>>>>                Move "UNKNOWN INDEX TYPE" to sRetval
91605>>>>>>>        Case End
91605>>>>>>>        Function_Return sRetval
91606>>>>>>>    End_Function
91607>>>>>>>
91607>>>>>>>    // * Dummy function for the Studio's Code Explorer *
91607>>>>>>>    Function API_RELATION_UTILITY_FUNCTIONS Returns Boolean
91609>>>>>>>        Function_Return False
91610>>>>>>>    End_Function
91611>>>>>>>
91611>>>>>>>    // Compares multiple relationships for a 'FROM' and a 'TO' databases
91611>>>>>>>    Function UtilRelationsCompare Handle hTable tAPIRelationCompare[] aAPIRelationCompare Returns Boolean
91613>>>>>>>        Boolean bIsSame
91613>>>>>>>        Integer iSize iCount
91613>>>>>>>
91613>>>>>>>        Move True to bIsSame
91614>>>>>>>        Move (SizeOfArray(aAPIRelationCompare)) to iSize
91615>>>>>>>        Decrement iSize
91616>>>>>>>        For iCount from 0 to iSize
91622>>>>>>>>
91622>>>>>>>            Get UtilRelationCompare hTable aAPIRelationCompare[iCount] to bIsSame
91623>>>>>>>            If (bIsSame = False) Begin
91625>>>>>>>                Function_Return False
91626>>>>>>>            End
91626>>>>>>>>
91626>>>>>>>        Loop
91627>>>>>>>>
91627>>>>>>>
91627>>>>>>>        Function_Return bIsSame
91628>>>>>>>    End_Function
91629>>>>>>>
91629>>>>>>>    // Compares a single relationship for a 'FROM' and a 'TO' table
91629>>>>>>>    Function UtilRelationCompare Handle hTable tAPIRelationCompare APIRelationCompare Returns Boolean
91631>>>>>>>        Boolean bIsSame
91631>>>>>>>
91631>>>>>>>        Move True to bIsSame
91632>>>>>>>        If (APIRelationCompare.bExistsFrom <> APIRelationCompare.bExistsTo) Begin
91634>>>>>>>            Function_Return False
91635>>>>>>>        End
91635>>>>>>>>
91635>>>>>>>        If (APIRelationCompare.hTableFrom = 0 or APIRelationCompare.hTableTo = 0) Begin
91637>>>>>>>            Function_Return False
91638>>>>>>>        End
91638>>>>>>>>
91638>>>>>>>
91638>>>>>>>        // We could also compare field names, but I don't think that is necessary...
91638>>>>>>>
91638>>>>>>>        Function_Return bIsSame
91639>>>>>>>    End_Function
91640>>>>>>>
91640>>>>>>>    // This message is different from ApiTableCreate in that it will not do a function_return if the table
91640>>>>>>>    // already exists. 
91640>>>>>>>    Function UtilRelationsUpdate Handle hTable tAPIRelation[] aRelationsFrom tAPIRelation[] aRelationsTo Returns Boolean
91642>>>>>>>        Boolean bIsSame bOK
91642>>>>>>>        Integer iSizeTo iSize iCount iColumn
91642>>>>>>>        String sDriverID
91642>>>>>>>        
91642>>>>>>>        Move True to bOK                                                                                
91643>>>>>>>        Move (SizeOfArray(aRelationsTo))   to iSizeTo
91644>>>>>>>        If (iSizeTo > 0) Begin
91646>>>>>>>            Get AutoConnectionIDLogin to bOK
91647>>>>>>>            Move False to Err
91648>>>>>>>            Open hTable Mode DF_EXCLUSIVE
91650>>>>>>>            Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
91653>>>>>>>            Decrement iSizeTo
91654>>>>>>>
91654>>>>>>>            // We should probably not make any comparison between "FROM" and "TO" database; instead just create all "FROM" relations
91654>>>>>>>            // for the "TO" database. But start by deleting all current "TO" relations:
91654>>>>>>>            Structure_Start hTable sDriverID            
91655>>>>>>>                for iCount from 0 to iSizeTo                                                
91661>>>>>>>>
91661>>>>>>>                    Move aRelationsTo[iCount].iColumnFrom to iColumn
91662>>>>>>>                    Set_Attribute DF_FIELD_RELATED_FILE  of hTable iColumn to 0
91665>>>>>>>                    Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn to 0
91668>>>>>>>                End
91669>>>>>>>>
91669>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
91670>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
91672>>>>>>>            Set Action_Text of ghoStatusPanel to ""
91673>>>>>>>        End
91673>>>>>>>>
91673>>>>>>>
91673>>>>>>>        Move (SizeOfArray(aRelationsFrom)) to iSize
91674>>>>>>>        Decrement iSize
91675>>>>>>>        for iCount from 0 to iSize
91681>>>>>>>>
91681>>>>>>>            Get ApiTableRelate aRelationsFrom[iCount].hTableFrom aRelationsFrom[iCount].hTableTo aRelationsFrom[iCount].iColumnFrom aRelationsFrom[iCount].iColumnTo aRelationsTo to bOK
91682>>>>>>>        Loop
91683>>>>>>>>
91683>>>>>>>
91683>>>>>>>        Function_Return bOK
91684>>>>>>>    End_Function
91685>>>>>>>
91685>>>>>>>    Function UtilRelationsStructFill Handle hTable Returns tAPIRelation[]
91687>>>>>>>        tAPIRelation[] APIRelations
91687>>>>>>>        tAPIRelation[] APIRelations
91688>>>>>>>        Integer iColumn iColumnTo iNumColumns iCount
91688>>>>>>>        Handle hParent
91688>>>>>>>        Boolean bIsOpen
91688>>>>>>>
91688>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91689>>>>>>>        Move 0 to iCount
91690>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
91693>>>>>>>        If (bIsOpen = False) Begin
91695>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91696>>>>>>>            Open hTable
91698>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91699>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
91702>>>>>>>            If (bIsOpen = False) Begin
91704>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
91705>>>>>>>                Move True to APIRelations[0].bError
91706>>>>>>>                Function_Return APIRelations
91707>>>>>>>            End
91707>>>>>>>>
91707>>>>>>>        End
91707>>>>>>>>
91707>>>>>>>
91707>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
91710>>>>>>>        For iColumn from 1 to iNumColumns
91716>>>>>>>>
91716>>>>>>>            Get_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to hParent
91719>>>>>>>            If (hParent <> 0) Begin
91721>>>>>>>                Open hParent
91723>>>>>>>                Move hTable                                             to APIRelations[iCount].hTableFrom
91724>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable            to APIRelations[iCount].sLogicalNameFrom
91727>>>>>>>                Move iColumn                                            to APIRelations[iCount].iColumnFrom
91728>>>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn           to APIRelations[iCount].sFieldNameFrom
91731>>>>>>>
91731>>>>>>>                Move hParent                                            to APIRelations[iCount].hTableTo
91732>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hParent           to APIRelations[iCount].sLogicalNameTo
91735>>>>>>>                Get_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn  to iColumnTo
91738>>>>>>>                Move iColumnTo                                          to APIRelations[iCount].iColumnTo
91739>>>>>>>                Get_Attribute DF_FIELD_NAME of hParent iColumnTo        to APIRelations[iCount].sFieldNameTo
91742>>>>>>>                Move False                                              to APIRelations[iCount].bShouldChange
91743>>>>>>>                Move False                                              to APIRelations[iCount].bCancel
91744>>>>>>>                Move False                                              to APIRelations[iCount].bError
91745>>>>>>>                Close hParent
91746>>>>>>>                Increment iCount
91747>>>>>>>            End
91747>>>>>>>>
91747>>>>>>>        Loop
91748>>>>>>>>
91748>>>>>>>
91748>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91749>>>>>>>        Function_Return APIRelations
91750>>>>>>>    End_Function
91751>>>>>>>
91751>>>>>>>    Function UtilRelationArrayCompare tAPIRelation RelationCurrent tAPIRelation RelationNew Returns Integer
91753>>>>>>>        If (RelationCurrent.hTableFrom  = RelationNew.hTableFrom and ;            RelationCurrent.iColumnFrom = RelationNew.iColumnFrom and ;            RelationCurrent.hTableTo    = RelationNew.hTableTo and ;            RelationCurrent.iColumnTo   = RelationNew.iColumnTo) Begin
91755>>>>>>>            Function_Return (EQ)
91756>>>>>>>        End
91756>>>>>>>>
91756>>>>>>>
91756>>>>>>>        Function_Return (GT)
91757>>>>>>>    End_Function
91758>>>>>>>
91758>>>>>>>    Function SearchRelationCompare tAPIRelationCompare RelationCompareCurrent tAPIRelationCompare RelationCompareNew Returns Integer
91760>>>>>>>        If (RelationCompareCurrent.hTableFrom  = RelationCompareNew.hTableFrom and ;            RelationCompareCurrent.iColumnFrom = RelationCompareNew.iColumnFrom and ;            RelationCompareCurrent.hTableTo    = RelationCompareNew.hTableTo and ;            RelationCompareCurrent.iColumnTo   = RelationCompareNew.iColumnTo) ;            Function_Return (EQ)
91763>>>>>>>
91763>>>>>>>        Function_Return (GT)
91764>>>>>>>    End_Function
91765>>>>>>>
91765>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
91765>>>>>>>    // The combined data will be sorted on the first 4 struct members: hTableFrom, iColumnFrom, hTableTo and iColumnTo
91765>>>>>>>    Function UtilRelationCombineFromAndToArrays tAPIRelation[] aAPIRelationFrom tAPIRelation[] aAPIRelationTo Returns tAPIIndexCompare[]
91767>>>>>>>        tAPIRelation[] aAPIRelationFromAndTo
91767>>>>>>>        tAPIRelation[] aAPIRelationFromAndTo
91768>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
91768>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
91769>>>>>>>        tAPIRelationCompare   APIRelationCompare
91769>>>>>>>        tAPIRelationCompare   APIRelationCompare
91769>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
91769>>>>>>>
91769>>>>>>>        Move (SizeOfArray(aAPIRelationFrom)) to iSizeFrom
91770>>>>>>>        Move (SizeOfArray(aAPIRelationTo))   to iSizeTo
91771>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
91773>>>>>>>            Function_Return aAPIRelationCompare
91774>>>>>>>        End
91774>>>>>>>>
91774>>>>>>>
91774>>>>>>>        Move (AppendArray(aAPIRelationFrom, aAPIRelationTo)) to aAPIRelationFromAndTo
91775>>>>>>>        Move (SortArray(aAPIRelationFromAndTo, Self, RefFunc(UtilRelationArrayCompare))) to aAPIRelationFromAndTo
91776>>>>>>>
91776>>>>>>>        Decrement iSizeFrom
91777>>>>>>>        for iCount from 0 to iSizeFrom
91783>>>>>>>>
91783>>>>>>>            Move aAPIRelationFrom[iCount].hTableFrom        to aAPIRelationCompare[iCount].hTableFrom
91784>>>>>>>            Move aAPIRelationFrom[iCount].iColumnFrom       to aAPIRelationCompare[iCount].iColumnFrom
91785>>>>>>>            Move aAPIRelationFrom[iCount].hTableTo          to aAPIRelationCompare[iCount].hTableTo
91786>>>>>>>            Move aAPIRelationFrom[iCount].iColumnTo         to aAPIRelationCompare[iCount].iColumnTo
91787>>>>>>>            Move aAPIRelationFrom[iCount].sLogicalNameFrom  to aAPIRelationCompare[iCount].sLogicalNameFrom_From
91788>>>>>>>            Move aAPIRelationFrom[iCount].sLogicalNameTo    to aAPIRelationCompare[iCount].sLogicalNameTo_From
91789>>>>>>>            Move aAPIRelationFrom[iCount].sFieldNameFrom    to aAPIRelationCompare[iCount].sFieldNameFrom_From
91790>>>>>>>            Move aAPIRelationFrom[iCount].sFieldNameTo      to aAPIRelationCompare[iCount].sFieldNameTo_From
91791>>>>>>>            Move aAPIRelationFrom[iCount].bShouldChange     to aAPIRelationCompare[iCount].bShouldChange_From
91792>>>>>>>            Move aAPIRelationFrom[iCount].bCancel           to aAPIRelationCompare[iCount].bCancel_From
91793>>>>>>>            Move aAPIRelationFrom[iCount].bError            to aAPIRelationCompare[iCount].bError_From
91794>>>>>>>            Move True                                       to aAPIRelationCompare[iCount].bExistsFrom
91795>>>>>>>        Loop
91796>>>>>>>>
91796>>>>>>>
91796>>>>>>>        Decrement iSizeTo
91797>>>>>>>        for iCount from 0 to iSizeTo
91803>>>>>>>>
91803>>>>>>>            Move aAPIRelationTo[iCount].hTableFrom          to APIRelationCompare.hTableFrom
91804>>>>>>>            Move aAPIRelationTo[iCount].iColumnFrom         to APIRelationCompare.iColumnFrom
91805>>>>>>>            Move aAPIRelationTo[iCount].hTableTo            to APIRelationCompare.hTableTo
91806>>>>>>>            Move aAPIRelationTo[iCount].iColumnTo           to APIRelationCompare.iColumnTo
91807>>>>>>>
91807>>>>>>>            // Search if the relation already exists in the array; else add it.
91807>>>>>>>            Move (SearchArray(APIRelationCompare, aAPIRelationCompare, Self, RefFunc(SearchRelationCompare))) to iItem
91808>>>>>>>            If (iItem = -1) Begin
91810>>>>>>>                Move (SizeOfArray(aAPIRelationCompare))     to iItem
91811>>>>>>>            End
91811>>>>>>>>
91811>>>>>>>
91811>>>>>>>            Move APIRelationCompare.hTableFrom              to aAPIRelationCompare[iItem].hTableFrom
91812>>>>>>>            Move APIRelationCompare.iColumnFrom             to aAPIRelationCompare[iItem].iColumnFrom
91813>>>>>>>            Move APIRelationCompare.hTableTo                to aAPIRelationCompare[iItem].hTableTo
91814>>>>>>>            Move APIRelationCompare.iColumnTo               to aAPIRelationCompare[iItem].iColumnTo
91815>>>>>>>            Move aAPIRelationTo[iCount].sLogicalNameFrom    to aAPIRelationCompare[iItem].sLogicalNameFrom_To
91816>>>>>>>            Move aAPIRelationTo[iCount].sLogicalNameTo      to aAPIRelationCompare[iItem].sLogicalNameTo_To
91817>>>>>>>            Move aAPIRelationTo[iCount].sFieldNameFrom      to aAPIRelationCompare[iItem].sFieldNameFrom_To
91818>>>>>>>            Move aAPIRelationTo[iCount].sFieldNameTo        to aAPIRelationCompare[iItem].sFieldNameTo_To
91819>>>>>>>            Move aAPIRelationTo[iCount].bShouldChange       to aAPIRelationCompare[iItem].bShouldChange_To
91820>>>>>>>            Move aAPIRelationTo[iCount].bCancel             to aAPIRelationCompare[iItem].bCancel_To
91821>>>>>>>            Move aAPIRelationTo[iCount].bError              to aAPIRelationCompare[iItem].bError_To
91822>>>>>>>            Move True                                       to aAPIRelationCompare[iItem].bExistsTo
91823>>>>>>>        Loop
91824>>>>>>>>
91824>>>>>>>
91824>>>>>>>        Move (SortArray(aAPIRelationCompare, Self, RefFunc(SearchRelationCompare))) to aAPIRelationCompare
91825>>>>>>>
91825>>>>>>>        Function_Return aAPIRelationCompare
91826>>>>>>>    End_Function
91827>>>>>>>
91827>>>>>>>    // * Dummy function for the Studio's Code Explorer *
91827>>>>>>>    Function CODEMAST_UTILITY_FUNCTIONS Returns Boolean
91829>>>>>>>        Function_Return False
91830>>>>>>>    End_Function
91831>>>>>>>
91831>>>>>>>    // To add a value to the CodeMast & CodeType tables. Pass; a) bCodeType if it is CodeType that should be updated.
91831>>>>>>>    // Else it is CodeMast. b) sTypeValue; either to be added If bCodeType = True, or it will be used to find the correct
91831>>>>>>>    // CodeType record. c) sValue1 and d) sValue2 is the CodeType Description & Comment, or CodeMast Type and Code values.
91831>>>>>>>    Function UtilCodeMasterAddValue Boolean bCodeType String sTypeValue String sValue2 String sValue3 Returns Boolean
91833>>>>>>>        Boolean bFound
91833>>>>>>>
91833>>>>>>>        Move False to Err
91834>>>>>>>        Open CodeMast
91836>>>>>>>        Open CodeType
91838>>>>>>>
91838>>>>>>>        If (bCodeType = True) Begin
91840>>>>>>>            Clear CodeType
91841>>>>>>>            Move sTypeValue to CODETYPE.Type
91842>>>>>>>            Find eq CODETYPE.Type
91843>>>>>>>>
91843>>>>>>>            Move (Found = True) to bFound
91844>>>>>>>            If (bFound = True) Begin
91846>>>>>>>                Reread CodeType
91850>>>>>>>            End
91850>>>>>>>>
91850>>>>>>>            If (bFound = False) Begin
91852>>>>>>>                Clear CodeType
91853>>>>>>>            End
91853>>>>>>>>
91853>>>>>>>                Move sTypeValue to CODETYPE.Type
91854>>>>>>>                Move sValue2    to CODETYPE.Description
91855>>>>>>>                Move sValue3    to CODETYPE.Comment
91856>>>>>>>                SaveRecord CODETYPE
91857>>>>>>>            If (bFound = True) Begin
91859>>>>>>>                Unlock
91860>>>>>>>>
91860>>>>>>>            End
91860>>>>>>>>
91860>>>>>>>        End
91860>>>>>>>>
91860>>>>>>>
91860>>>>>>>        If (bCodeType = False) Begin
91862>>>>>>>            Clear CODEMAST
91863>>>>>>>            Move sTypeValue to CODEMAST.Type
91864>>>>>>>            Move sValue2    to CODEMAST.Code
91865>>>>>>>            Find eq CODEMAST.Code
91866>>>>>>>>
91866>>>>>>>            Move (Found = True) to bFound
91867>>>>>>>            If (bFound = True) Begin
91869>>>>>>>                Reread CODEMAST
91873>>>>>>>            End
91873>>>>>>>>
91873>>>>>>>            If (bFound = False) Begin
91875>>>>>>>                Clear CODEMAST
91876>>>>>>>            End
91876>>>>>>>>
91876>>>>>>>                Move sTypeValue to CODEMAST.Type
91877>>>>>>>                Move sValue2    to CODEMAST.Code
91878>>>>>>>                Move sValue3    to CODEMAST.Description
91879>>>>>>>                SaveRecord CODEMAST
91880>>>>>>>            If (bFound = True) Begin
91882>>>>>>>            Unlock
91883>>>>>>>>
91883>>>>>>>            End
91883>>>>>>>>
91883>>>>>>>        End
91883>>>>>>>>
91883>>>>>>>
91883>>>>>>>        Close CodeMast
91884>>>>>>>        Close CodeType
91885>>>>>>>
91885>>>>>>>        Function_Return (Err = False)
91886>>>>>>>    End_Function
91887>>>>>>>
91887>>>>>>>    // Changes values in CodeType & CodeMast - From type value To type value. It first changes the type value in
91887>>>>>>>    // CodeType and then spins through all CodeMast records to change all related records.
91887>>>>>>>    Function UtilCodeMasterChangeValue String sFromValue String sToValue Returns Boolean
91889>>>>>>>        Boolean bFound
91889>>>>>>>
91889>>>>>>>        Move False to Err
91890>>>>>>>        Open CodeMast
91892>>>>>>>        Open CodeType
91894>>>>>>>
91894>>>>>>>        Clear CodeType
91895>>>>>>>        Move sFromValue to CODETYPE.Type
91896>>>>>>>        Find eq CODETYPE.Type
91897>>>>>>>>
91897>>>>>>>        If (Found = True) Begin
91899>>>>>>>            Reread CODETYPE
91903>>>>>>>                Move sToValue to CODETYPE.Type
91904>>>>>>>                SaveRecord CODETYPE
91905>>>>>>>            Unlock
91906>>>>>>>>
91906>>>>>>>        End
91906>>>>>>>>
91906>>>>>>>
91906>>>>>>>        Clear CODEMAST
91907>>>>>>>        Find gt CODEMAST by Recnum
91908>>>>>>>>
91908>>>>>>>        While (Found = True)
91912>>>>>>>            Move (Trim(Uppercase(CODEMAST.Type) = Trim(Uppercase(sFromValue)))) to bFound
91913>>>>>>>            If (bFound = True) Begin
91915>>>>>>>                Reread CODEMAST
91919>>>>>>>                    Move sToValue to CODEMAST.Type
91920>>>>>>>                    SaveRecord CODEMAST
91921>>>>>>>                Unlock
91922>>>>>>>>
91922>>>>>>>            End
91922>>>>>>>>
91922>>>>>>>            Find gt CODEMAST by Recnum
91923>>>>>>>>
91923>>>>>>>        Loop
91924>>>>>>>>
91924>>>>>>>
91924>>>>>>>        Close CodeMast
91925>>>>>>>        Close CodeType
91926>>>>>>>
91926>>>>>>>        Function_Return (Err = False)
91927>>>>>>>    End_Function
91928>>>>>>>
91928>>>>>>>    // Removes a value from CodeMast. Pass the sTypeValue and the sValue2 to remove.
91928>>>>>>>    Function UtilCodeMasterRemoveValue String sTypeValue String sValue2 Returns Boolean
91930>>>>>>>        Boolean bFound
91930>>>>>>>
91930>>>>>>>        Move False to Err
91931>>>>>>>        Open CodeMast
91933>>>>>>>
91933>>>>>>>        Clear CODEMAST
91934>>>>>>>        Move sTypeValue to CODEMAST.Type
91935>>>>>>>        Move sValue2    to CODEMAST.Code
91936>>>>>>>        Find eq CODEMAST.Code
91937>>>>>>>>
91937>>>>>>>        Move (Found = True) to bFound
91938>>>>>>>        If (bFound = True) Begin
91940>>>>>>>            Delete CODEMAST
91941>>>>>>>        End
91941>>>>>>>>
91941>>>>>>>
91941>>>>>>>        Close CodeMast
91942>>>>>>>
91942>>>>>>>        Function_Return (Err = False)
91943>>>>>>>    End_Function
91944>>>>>>>
91944>>>>>>>    Function UtilTableCreateCodeMastCodeTypeIntFiles String sDataPath Returns Boolean
91946>>>>>>>        Boolean bRecnum bToAnsi
91946>>>>>>>        Integer iCh
91946>>>>>>>        String sFileName sDriverID sConnectionID sSchemaName sANSI_OEM
91946>>>>>>>
91946>>>>>>>        If (Trim(sDataPath) = "") Begin
91948>>>>>>>            Function_Return False
91949>>>>>>>        End
91949>>>>>>>>
91949>>>>>>>
91949>>>>>>>        Move False to Err
91950>>>>>>>        Get psDriverID     to sDriverID
91951>>>>>>>        Get psConnectionID to sConnectionID
91952>>>>>>>        Get psSchema       to sSchemaName
91953>>>>>>>        Get True           to bRecnum
91954>>>>>>>        Get pbToANSI       to bToAnsi
91955>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
91956>>>>>>>        If (bToAnsi = False) Begin
91958>>>>>>>            Move CS_OEM_Txt to sANSI_OEM
91959>>>>>>>        End
91959>>>>>>>>
91959>>>>>>>
91959>>>>>>>        Get vFolderFormat sDataPath to sDataPath
91960>>>>>>>        Move "CodeMast.int"         to sFileName
91961>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
91962>>>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
91965>>>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
91968>>>>>>>            Writeln channel iCh ("DATABASE_NAME CODEMAST")
91971>>>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
91974>>>>>>>            Writeln channel iCh ("")
91977>>>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
91980>>>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
91983>>>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
91986>>>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
91989>>>>>>>            Writeln channel iCh ("")
91992>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
91995>>>>>>>            Writeln channel iCh ("INDEX_NAME CODEMAST001_PK")
91998>>>>>>>            Writeln channel iCh ("")
92001>>>>>>>        Send Seq_Close_Channel iCh
92002>>>>>>>
92002>>>>>>>        Get vFolderFormat sDataPath to sDataPath
92003>>>>>>>        Move "CodeType.int"         to sFileName
92004>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
92005>>>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
92008>>>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
92011>>>>>>>            Writeln channel iCh ("DATABASE_NAME CODETYPE")
92014>>>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
92017>>>>>>>            Writeln channel iCh ("")
92020>>>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
92023>>>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
92026>>>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
92029>>>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
92032>>>>>>>            Writeln channel iCh ("")
92035>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 0")
92038>>>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE000")
92041>>>>>>>            Writeln channel iCh ("")
92044>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
92047>>>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE001_PK")
92050>>>>>>>            Writeln channel iCh ("")
92053>>>>>>>        Send Seq_Close_Channel iCh
92054>>>>>>>
92054>>>>>>>        Function_Return (Err = False)
92055>>>>>>>    End_Function
92056>>>>>>>
92056>>>>>>>    // * Dummy function for the Studio's Code Explorer *
92056>>>>>>>    Function OTHER_UTILITY_FUNCTIONS Returns Boolean
92058>>>>>>>        Function_Return False
92059>>>>>>>    End_Function
92060>>>>>>>
92060>>>>>>>    // Check if the file exists in the Data folder,
92060>>>>>>>    // else creates it from memory as it has been compiled into the program as a resource:
92060>>>>>>>    Function UtilCheckCreateIfFileExists String sFileName String sResourceName Boolean bDataFile Returns Boolean
92062>>>>>>>        String sPath sDataPath
92062>>>>>>>        Boolean bExists
92062>>>>>>>
92062>>>>>>>        Get psDataPathFirstPart to sPath
92063>>>>>>>        Move (sPath + sFileName) to sFileName
92064>>>>>>>        Get vFilePathExists sFileName to bExists
92065>>>>>>>
92065>>>>>>>        If (bExists = False) Begin
92067>>>>>>>            // Read from memory & create file on disk.
92067>>>>>>>            Send SqlUtilCreateFileFromMemory sResourceName sFileName
92068>>>>>>>            Get vFilePathExists sFileName to bExists
92069>>>>>>>        End
92069>>>>>>>>
92069>>>>>>>        Function_Return bExists
92070>>>>>>>    End_Function
92071>>>>>>>
92071>>>>>>>    Function UtilSqlColumnTypeToDataFlexType String sDriverID Integer iDbType Integer iDataType Integer iLength Returns Integer
92073>>>>>>>        tColumnType RetvalType
92073>>>>>>>        tColumnType RetvalType
92073>>>>>>>        Integer iRetval
92073>>>>>>>
92073>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
92074>>>>>>>        Move RetvalType.iDataFlexType to iRetval
92075>>>>>>>        If (RetvalType.iDataFlexType = DF_TEXT) Begin
92077>>>>>>>            If (iLength <= 255) Begin
92079>>>>>>>                Move DF_ASCII to iRetval
92080>>>>>>>            End
92080>>>>>>>>
92080>>>>>>>        End
92080>>>>>>>>
92080>>>>>>>        Function_Return iRetval
92081>>>>>>>    End_Function       
92082>>>>>>>    
92082>>>>>>>    Function UtilDataFlexDataTypeToString Integer iDataType Returns String
92084>>>>>>>        String sRetval 
92084>>>>>>>
92084>>>>>>>        Case Begin
92084>>>>>>>            Case (iDataType = DF_ASCII)
92086>>>>>>>                Move "DF_ASCII" to sRetval
92087>>>>>>>                Case Break
92088>>>>>>>            Case (iDataType = DF_BCD)
92091>>>>>>>                Move "DF_BCD" to sRetval
92092>>>>>>>                Case Break
92093>>>>>>>            Case (iDataType = DF_BINARY)
92096>>>>>>>                Move "DF_BINARY" to sRetval
92097>>>>>>>                Case Break
92098>>>>>>>            Case (iDataType = DF_DATE)
92101>>>>>>>                Move "DF_DATE" to sRetval
92102>>>>>>>                Case Break
92103>>>>>>>            Case (iDataType = DF_DATETIME)
92106>>>>>>>                Move "DF_DATETIME" to sRetval
92107>>>>>>>                Case Break
92108>>>>>>>            Case (iDataType = DF_TEXT)
92111>>>>>>>                Move "DF_TEXT" to sRetval
92112>>>>>>>                Case Break
92113>>>>>>>            Case Else
92113>>>>>>>                Move "" to sRetval
92114>>>>>>>        Case End
92114>>>>>>>
92114>>>>>>>        Function_Return sRetval
92115>>>>>>>    End_Function
92116>>>>>>>
92116>>>>>>>    // The default value used for a datatype as specified in the driver int file.
92116>>>>>>>    Function UtilDataTypeDefaultValue String sDriverID Integer iDbType Integer iDataType Returns String
92118>>>>>>>        String sRetval sServer
92118>>>>>>>        tColumnType RetvalType
92118>>>>>>>        tColumnType RetvalType
92118>>>>>>>        Integer iDriver iDataFlexType
92118>>>>>>>        Handle hDatabase
92118>>>>>>>
92118>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
92119>>>>>>>        Move RetvalType.iDataFlexType to iDataFlexType
92120>>>>>>>        Get DriverIndex sDriverID to iDriver
92121>>>>>>>        Get psServer to sServer
92122>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
92123>>>>>>>        If (hDatabase = 0) Begin
92125>>>>>>>            Function_Return ""
92126>>>>>>>        End
92126>>>>>>>>
92126>>>>>>>
92126>>>>>>>        Case Begin
92126>>>>>>>            Case (iDataFlexType = DF_ASCII)
92128>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_ASCII     of iDriver hDatabase to sRetval
92131>>>>>>>                Case Break
92132>>>>>>>            Case (iDataFlexType = DF_BCD)
92135>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_NUMERIC   of iDriver hDatabase to sRetval
92138>>>>>>>                Case Break
92139>>>>>>>            Case (iDataFlexType = DF_BINARY)
92142>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_BINARY    of iDriver hDatabase to sRetval
92145>>>>>>>                Case Break
92146>>>>>>>            Case (iDataFlexType = DF_DATE)
92149>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE      of iDriver hDatabase to sRetval
92152>>>>>>>                Case Break
92153>>>>>>>            Case (iDataFlexType = DF_DATETIME)
92156>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME  of iDriver hDatabase to sRetval
92159>>>>>>>                Case Break
92160>>>>>>>            Case (iDataFlexType = DF_TEXT)
92163>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_TEXT      of iDriver hDatabase to sRetval
92166>>>>>>>                Case Break
92167>>>>>>>            Case Else
92167>>>>>>>                Move "" to sRetval
92168>>>>>>>        Case End
92168>>>>>>>
92168>>>>>>>        Function_Return sRetval
92169>>>>>>>    End_Function
92170>>>>>>>
92170>>>>>>>    Procedure Set Df_Database_Default_Default_Date_DUF String sDateValue
92172>>>>>>>        String sDriverID sServer
92172>>>>>>>        tColumnType RetvalType
92172>>>>>>>        tColumnType RetvalType
92172>>>>>>>        Integer iDbType iDriver
92172>>>>>>>        Handle hDatabase
92172>>>>>>>
92172>>>>>>>        Get psDriverID to sDriverID
92173>>>>>>>        Get piDbType   to iDbType
92174>>>>>>>        Get DriverIndex sDriverID to iDriver
92175>>>>>>>        Get psServer to sServer
92176>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
92177>>>>>>>        If (hDatabase = 0) Begin
92179>>>>>>>            Error DFERR_PROGRAM "Could not change the Default Date Value. Could not get a handle to the database."
92180>>>>>>>>
92180>>>>>>>            Procedure_Return
92181>>>>>>>        End
92181>>>>>>>>
92181>>>>>>>
92181>>>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE of iDriver hDatabase to sDateValue
92184>>>>>>>
92184>>>>>>>    End_Procedure
92185>>>>>>>
92185>>>>>>>    Procedure Set Df_Database_Default_Default_Datetime_DUF String sDateValue
92187>>>>>>>        String sDriverID sServer
92187>>>>>>>        tColumnType RetvalType
92187>>>>>>>        tColumnType RetvalType
92187>>>>>>>        Integer iDbType iDriver
92187>>>>>>>        Handle hDatabase
92187>>>>>>>
92187>>>>>>>        Get psDriverID to sDriverID
92188>>>>>>>        Get piDbType   to iDbType
92189>>>>>>>        Get DriverIndex sDriverID to iDriver
92190>>>>>>>        Get psServer to sServer
92191>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
92192>>>>>>>        If (hDatabase = 0) Begin
92194>>>>>>>            Error DFERR_PROGRAM "Could not change the Default DateTime Value. Could not get a handle to the database."
92195>>>>>>>>
92195>>>>>>>            Procedure_Return
92196>>>>>>>        End
92196>>>>>>>>
92196>>>>>>>
92196>>>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME of iDriver hDatabase to sDateValue
92199>>>>>>>
92199>>>>>>>    End_Procedure
92200>>>>>>>
92200>>>>>>>    // Returns a struct array with the default column types for the SQL back-end and how they
92200>>>>>>>    // are mapped to the standard DataFlex data types.
92200>>>>>>>    // The DataFlex data types are: "ASCII", "BINARY", "DATE", "DATETIME", "NUMERIC" and "TEXT".
92200>>>>>>>    Function UtilDefaultSqlTypeMappings String sDriverID Integer iDbType Returns tColumnType[]
92202>>>>>>>        tColumnType[] ColumnTypeArray EmptyArray
92202>>>>>>>        tColumnType[] ColumnTypeArray EmptyArray
92204>>>>>>>        String sDataType
92204>>>>>>>        Integer iDataType iDriverID iCount
92204>>>>>>>        Boolean bSQLDriver
92204>>>>>>>
92204>>>>>>>        Move 0 to iCount
92205>>>>>>>        Get DriverIndex sDriverID to iDriverID
92206>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
92207>>>>>>>        If (bSQLDriver = False) Begin
92209>>>>>>>            Function_Return EmptyArray
92210>>>>>>>        End
92210>>>>>>>>
92210>>>>>>>
92210>>>>>>>        // DF_ASCII
92210>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
92212>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
92215>>>>>>>        End
92215>>>>>>>>
92215>>>>>>>        Else Begin
92216>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
92219>>>>>>>        End
92219>>>>>>>>
92219>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
92220>>>>>>>        Move DF_ASCII    to ColumnTypeArray[iCount].iDataFlexType
92221>>>>>>>        Move "ASCII"     to ColumnTypeArray[iCount].sDataFlexType
92222>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
92223>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
92224>>>>>>>        Increment iCount
92225>>>>>>>
92225>>>>>>>        // DF_BINARY
92225>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
92227>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
92230>>>>>>>        End
92230>>>>>>>>
92230>>>>>>>        Else Begin
92231>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
92234>>>>>>>        End
92234>>>>>>>>
92234>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
92235>>>>>>>        Move DF_BINARY   to ColumnTypeArray[iCount].iDataFlexType
92236>>>>>>>        Move "Binary"    to ColumnTypeArray[iCount].sDataFlexType
92237>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
92238>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
92239>>>>>>>        Increment iCount
92240>>>>>>>
92240>>>>>>>        // DF_DATE
92240>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
92242>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
92245>>>>>>>        End
92245>>>>>>>>
92245>>>>>>>        Else Begin
92246>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
92249>>>>>>>        End
92249>>>>>>>>
92249>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
92250>>>>>>>        Move DF_DATE     to ColumnTypeArray[iCount].iDataFlexType
92251>>>>>>>        Move "Date"      to ColumnTypeArray[iCount].sDataFlexType
92252>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
92253>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
92254>>>>>>>        Increment iCount
92255>>>>>>>
92255>>>>>>>        // DF_DATETIME
92255>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
92257>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
92260>>>>>>>        End
92260>>>>>>>>
92260>>>>>>>        Else Begin
92261>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
92264>>>>>>>        End
92264>>>>>>>>
92264>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
92265>>>>>>>        Move DF_DATETIME to ColumnTypeArray[iCount].iDataFlexType
92266>>>>>>>        Move "DateTime"  to ColumnTypeArray[iCount].sDataFlexType
92267>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
92268>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
92269>>>>>>>        Increment iCount
92270>>>>>>>
92270>>>>>>>        // DF_NUMERIC
92270>>>>>>>        // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
92270>>>>>>>        // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
92270>>>>>>>        // we make them here all "Numeric"...
92270>>>>>>>        Case Begin
92270>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
92272>>>>>>>                Move SQL_NUMERIC to iDataType
92273>>>>>>>                Move "numeric"   to sDataType
92274>>>>>>>                Case Break
92275>>>>>>>            Case (sDriverID = DB2_DRV_ID)
92278>>>>>>>                Move SQL_NUMERIC to iDataType
92279>>>>>>>                Move "NUMERIC"   to sDataType
92280>>>>>>>                Case Break
92281>>>>>>>            Case (sDriverID = SQLFLEX)
92284>>>>>>>                Move eSQLServer_NUMERIC to iDataType
92285>>>>>>>                Move "numeric"   to sDataType
92286>>>>>>>                Case Break
92287>>>>>>>            Case (sDriverID = MDSMySQL)
92290>>>>>>>                Move eMySQL_DECIMAL to iDataType
92291>>>>>>>                Move "decimal"   to sDataType
92292>>>>>>>                Case Break
92293>>>>>>>            Case (sDriverID = ORAFLEX)
92296>>>>>>>                Move eOracle_NUMBER to iDataType
92297>>>>>>>                Move "NUMBER"   to sDataType
92298>>>>>>>                Case Break
92299>>>>>>>            Case (sDriverID = MDSPgSQL)
92302>>>>>>>                Move ePgSQL_FLOAT4 to iDataType
92303>>>>>>>                Move "decimal"   to sDataType
92304>>>>>>>                Case Break
92305>>>>>>>            Case Else
92305>>>>>>>                Move DF_BCD      to iDataType
92306>>>>>>>                Move "Numeric"   to sDataType
92307>>>>>>>        Case End
92307>>>>>>>        Move DF_BCD      to ColumnTypeArray[iCount].iDataFlexType
92308>>>>>>>        Move "Numeric"   to ColumnTypeArray[iCount].sDataFlexType
92309>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
92310>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
92311>>>>>>>        Increment iCount
92312>>>>>>>
92312>>>>>>>        // DF_TEXT
92312>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
92314>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
92317>>>>>>>        End
92317>>>>>>>>
92317>>>>>>>        Else Begin
92318>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
92321>>>>>>>        End
92321>>>>>>>>
92321>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
92322>>>>>>>        Move DF_TEXT     to ColumnTypeArray[iCount].iDataFlexType
92323>>>>>>>        Move "Text"      to ColumnTypeArray[iCount].sDataFlexType
92324>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
92325>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
92326>>>>>>>
92326>>>>>>>        Function_Return ColumnTypeArray
92327>>>>>>>    End_Function
92328>>>>>>>
92328>>>>>>>    Function UtilDFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
92330>>>>>>>        tColumnType[] ColumnTypeArray
92330>>>>>>>        tColumnType[] ColumnTypeArray
92331>>>>>>>        tColumnType   ColumnType
92331>>>>>>>        tColumnType   ColumnType
92331>>>>>>>        Integer iCount iSize
92331>>>>>>>
92331>>>>>>>        Get UtilDefaultSqlTypeMappings sDriverID iDbType iType to ColumnTypeArray
92332>>>>>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
92333>>>>>>>        Decrement iSize
92334>>>>>>>
92334>>>>>>>        for iCount from 0 to iSize
92340>>>>>>>>
92340>>>>>>>            If (iType = ColumnTypeArray[iCount].iDataFlexType) Begin
92342>>>>>>>                Move ColumnTypeArray[iCount].bCanEditSize   to ColumnType.bCanEditSize
92343>>>>>>>                Move ColumnTypeArray[iCount].iDataFlexType  to ColumnType.iDataFlexType
92344>>>>>>>                Move ColumnTypeArray[iCount].iSQLType       to ColumnType.iSQLType
92345>>>>>>>                Move ColumnTypeArray[iCount].sDataFlexType  to ColumnType.sDataFlexType
92346>>>>>>>                Move ColumnTypeArray[iCount].sPrecision     to ColumnType.sPrecision
92347>>>>>>>                Move ColumnTypeArray[iCount].sSQLType       to ColumnType.sSQLType
92348>>>>>>>                Move iSize to iCount
92349>>>>>>>            End
92349>>>>>>>>
92349>>>>>>>        Loop
92350>>>>>>>>
92350>>>>>>>
92350>>>>>>>        Function_Return ColumnType
92351>>>>>>>    End_Function
92352>>>>>>>
92352>>>>>>>    // Returns a struct with the default column types for the SQL back-end and how they
92352>>>>>>>    // are mapped to a DUF data type.
92352>>>>>>>    Function UtilDUFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
92354>>>>>>>        tColumnType ColumnType
92354>>>>>>>        tColumnType ColumnType
92354>>>>>>>        String sDataType
92354>>>>>>>        Integer iDriverID iCount
92354>>>>>>>
92354>>>>>>>        Move 0 to iCount
92355>>>>>>>        Get DriverIndex sDriverID to iDriverID
92356>>>>>>>
92356>>>>>>>        Case Begin
92356>>>>>>>            // DF_ASCII
92356>>>>>>>            Case (iType = DF_ASCII_DUF)
92358>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
92360>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
92363>>>>>>>                End
92363>>>>>>>>
92363>>>>>>>                Else Begin
92364>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
92367>>>>>>>                End
92367>>>>>>>>
92367>>>>>>>                Move DF_ASCII    to ColumnType.iDataFlexType
92368>>>>>>>                Move "ASCII"     to ColumnType.sDataFlexType
92369>>>>>>>                Move sDataType   to ColumnType.sSQLType
92370>>>>>>>                Move DF_ASCII    to ColumnType.iSQLType
92371>>>>>>>                Move False       to ColumnType.bCanEditSize
92372>>>>>>>                Case Break
92373>>>>>>>
92373>>>>>>>            // DF_BINARY
92373>>>>>>>            Case (iType = DF_BINARY_DUF)
92376>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
92378>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
92381>>>>>>>                End
92381>>>>>>>>
92381>>>>>>>                Else Begin
92382>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
92385>>>>>>>                End
92385>>>>>>>>
92385>>>>>>>                Move DF_BINARY   to ColumnType.iDataFlexType
92386>>>>>>>                Move "Binary"    to ColumnType.sDataFlexType
92387>>>>>>>                Move sDataType   to ColumnType.sSQLType
92388>>>>>>>                Move DF_BINARY   to ColumnType.iSQLType
92389>>>>>>>                Move False       to ColumnType.bCanEditSize
92390>>>>>>>                Case Break
92391>>>>>>>
92391>>>>>>>            // DF_DATE
92391>>>>>>>            Case (iType = DF_DATE_DUF)
92394>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
92396>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
92399>>>>>>>                End
92399>>>>>>>>
92399>>>>>>>                Else Begin
92400>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
92403>>>>>>>                End
92403>>>>>>>>
92403>>>>>>>                Move DF_DATE     to ColumnType.iDataFlexType
92404>>>>>>>                Move "Date"      to ColumnType.sDataFlexType
92405>>>>>>>                Move sDataType   to ColumnType.sSQLType
92406>>>>>>>                Move DF_DATE     to ColumnType.iSQLType
92407>>>>>>>                Move True        to ColumnType.bCanEditSize
92408>>>>>>>                Case Break
92409>>>>>>>
92409>>>>>>>            // DF_DATETIME
92409>>>>>>>            Case (iType = DF_DATETIME_DUF)
92412>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
92414>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
92417>>>>>>>                End
92417>>>>>>>>
92417>>>>>>>                Else Begin
92418>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
92421>>>>>>>                End
92421>>>>>>>>
92421>>>>>>>                Move DF_DATETIME to ColumnType.iDataFlexType
92422>>>>>>>                Move "DateTime"  to ColumnType.sDataFlexType
92423>>>>>>>                Move sDataType   to ColumnType.sSQLType
92424>>>>>>>                Move DF_DATETIME to ColumnType.iSQLType
92425>>>>>>>                Move True        to ColumnType.bCanEditSize
92426>>>>>>>                Case Break
92427>>>>>>>
92427>>>>>>>            // DF_NUMERIC
92427>>>>>>>            // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
92427>>>>>>>            // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
92427>>>>>>>            // we make them here all "Numeric"...
92427>>>>>>>            // If (sDriverID = ODBC_DRV_ID) Begin
92427>>>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
92427>>>>>>>            // End
92427>>>>>>>            // Else Begin
92427>>>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
92427>>>>>>>            // End
92427>>>>>>>            // ToDo: How should we find the best "Numeric" data type here?
92427>>>>>>>            Case (iType = DF_BCD_DUF)
92430>>>>>>>                Move DF_BCD      to ColumnType.iDataFlexType
92431>>>>>>>                Move "Numeric"   to ColumnType.sDataFlexType
92432>>>>>>>                Move "Numeric"   to ColumnType.sSQLType
92433>>>>>>>                Move SQL_NUMERIC to ColumnType.iSQLType
92434>>>>>>>                Move False       to ColumnType.bCanEditSize
92435>>>>>>>                Case Break
92436>>>>>>>
92436>>>>>>>            // DF_TEXT
92436>>>>>>>            Case (iType = DF_TEXT_DUF)
92439>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
92441>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
92444>>>>>>>                End
92444>>>>>>>>
92444>>>>>>>                Else Begin
92445>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
92448>>>>>>>                End
92448>>>>>>>>
92448>>>>>>>                Move DF_TEXT     to ColumnType.iDataFlexType
92449>>>>>>>                Move "Text"      to ColumnType.sDataFlexType
92450>>>>>>>                Move sDataType   to ColumnType.sSQLType
92451>>>>>>>                Move DF_TEXT     to ColumnType.iSQLType
92452>>>>>>>                Move False       to ColumnType.bCanEditSize
92453>>>>>>>                Case Break
92454>>>>>>>
92454>>>>>>>            Case Else
92454>>>>>>>                Move -1999       to ColumnType.iDataFlexType
92455>>>>>>>                Move "Undefined" to ColumnType.sDataFlexType
92456>>>>>>>                Move "Undefined" to ColumnType.sSQLType
92457>>>>>>>                Move -1999       to ColumnType.iSQLType
92458>>>>>>>                Move True        to ColumnType.bCanEditSize
92459>>>>>>>
92459>>>>>>>        Case End
92459>>>>>>>
92459>>>>>>>        Function_Return ColumnType
92460>>>>>>>    End_Function
92461>>>>>>>
92461>>>>>>>    Function UtilDeleteCacheFile String sTableName Returns Boolean
92463>>>>>>>        String sDataPath sDriverID
92463>>>>>>>        Boolean bMertechDriver bOK
92463>>>>>>>        Integer iPos
92463>>>>>>>
92463>>>>>>>        If (sTableName contains ".") Begin
92465>>>>>>>            Move (Pos(".", sTableName)) to iPos
92466>>>>>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
92467>>>>>>>        End
92467>>>>>>>>
92467>>>>>>>
92467>>>>>>>        Get psDriverID to sDriverID
92468>>>>>>>        Get psDataPathFirstPart to sDataPath
92469>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
92470>>>>>>>        // First delete the cache file:
92470>>>>>>>        If (bMertechDriver = False) Begin
92472>>>>>>>            Get vDeleteFile (sDataPath + sTableName + ".cch") to bOK
92473>>>>>>>        End
92473>>>>>>>>
92473>>>>>>>        Else Begin
92474>>>>>>>            Get _MertechDeleteTDFile sTableName to bOK
92475>>>>>>>        End
92475>>>>>>>>
92475>>>>>>>
92475>>>>>>>        Function_Return bOK
92476>>>>>>>    End_Function
92477>>>>>>>
92477>>>>>>>    // Changes source code files.
92477>>>>>>>    // Pass a file name with full path and a value to search for, together with the value
92477>>>>>>>    // to change to. Can e.g. be used for changing all .int files from using a fixed server name,
92477>>>>>>>    // to use a Connection ID.
92477>>>>>>>    // Sample: Get UtilChangeSourceCodeLine "C:\DataFlex 18.2 Examples\Order Entry\Data\Order.int" "SERVER_NAME SERVER=(local)\SQLEXPRESS1" "SERVER_NAME DFCONNID=ChinookDb"
92477>>>>>>>    // Pass "True" for the bShowResult if you want to see the result while it works. Showln will then be used for output
92477>>>>>>>    // Returns True if no errors occured.
92477>>>>>>>    Function UtilChangeSourceCodeLine String sFileName String sChangeFrom String sChangeTo Boolean bShowResult Returns Boolean
92479>>>>>>>        Integer iCh iRow iItems iCount
92479>>>>>>>        String sValue sRow
92479>>>>>>>        String[] sFileArray
92480>>>>>>>        Boolean bExists bIsActive
92480>>>>>>>
92480>>>>>>>        Move False to Err
92481>>>>>>>        Move 0 to iRow
92482>>>>>>>
92482>>>>>>>        If (ghoStatusPanel <> 0) Begin
92484>>>>>>>            Get Active_state of ghoStatusPanel to bIsActive
92485>>>>>>>        End
92485>>>>>>>>
92485>>>>>>>
92485>>>>>>>        Get vFilePathExists sFileName to bExists
92486>>>>>>>        If (bExists = False) Begin
92488>>>>>>>            If (bShowResult = True) Begin
92490>>>>>>>                If (bIsActive = True) Begin
92492>>>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("File does not exist:" * String(sFileName))
92493>>>>>>>                End
92493>>>>>>>>
92493>>>>>>>                Else Begin
92494>>>>>>>                    Showln "File does not exist: " sFileName
92497>>>>>>>                End
92497>>>>>>>>
92497>>>>>>>            End
92497>>>>>>>>
92497>>>>>>>            Function_Return False
92498>>>>>>>        End
92498>>>>>>>>
92498>>>>>>>
92498>>>>>>>        Get Seq_Open_Input_Channel sFileName to iCh
92499>>>>>>>        If (iCh < 1) Begin
92501>>>>>>>            Function_Return False
92502>>>>>>>        End
92502>>>>>>>>
92502>>>>>>>
92502>>>>>>>        If (bShowResult = True) Begin
92504>>>>>>>            If (ghoStatusPanel <> 0) Begin
92506>>>>>>>                Get Active_state of ghoStatusPanel to bIsActive
92507>>>>>>>                If (bIsActive = True) Begin
92509>>>>>>>                    Set Message_Text of ghoStatusPanel to sFileName
92510>>>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("sChangeFrom =" * String(sChangeFrom) * "sChangeTo =" * String(sChangeTo))
92511>>>>>>>                    Send DoAdvance of ghoProgressBar
92512>>>>>>>                End
92512>>>>>>>>
92512>>>>>>>            End
92512>>>>>>>>
92512>>>>>>>            Else Begin
92513>>>>>>>                Showln ""
92515>>>>>>>                Showln "sFileName = " sFileName
92518>>>>>>>                Showln "sChangeFrom = " sChangeFrom " sChangeTo = " sChangeTo
92523>>>>>>>            End
92523>>>>>>>>
92523>>>>>>>        End
92523>>>>>>>>
92523>>>>>>>
92523>>>>>>>        While (not(SeqEof))
92527>>>>>>>            Readln channel iCh sRow
92529>>>>>>>            If (Uppercase(sRow) contains Uppercase(sChangeFrom)) Begin
92531>>>>>>>//                If (bShowResult = True) Begin
92531>>>>>>>//                    If (bIsActive = True) Begin
92531>>>>>>>//                        Send Update_StatusPanel of ghoStatusPanel ("Changed from:" * String(sRow) * "to:" * String(sChangeTo))
92531>>>>>>>//                    End
92531>>>>>>>//                    Else Begin
92531>>>>>>>//                        Showln "Changed from: " sRow " to: " sChangeTo
92531>>>>>>>//                    End
92531>>>>>>>//                End
92531>>>>>>>                // Change the whole line to the new connection id:
92531>>>>>>>                Move sChangeTo to sRow
92532>>>>>>>                // Move (Replaces(sChangeFrom, sRow, sChangeTo)) to sValue
92532>>>>>>>            End
92532>>>>>>>>
92532>>>>>>>            Move sRow to sFileArray[iRow]
92533>>>>>>>            Increment iRow
92534>>>>>>>        End
92535>>>>>>>>
92535>>>>>>>        Send Seq_Close_Channel iCh
92536>>>>>>>
92536>>>>>>>        Sleep 1 // Wait for Windows to close the file
92537>>>>>>>
92537>>>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
92538>>>>>>>        If (iCh < 1) Begin
92540>>>>>>>            Function_Return False
92541>>>>>>>        End
92541>>>>>>>>
92541>>>>>>>        Move (SizeOfArray(sFileArray)) to iItems
92542>>>>>>>        Decrement iItems
92543>>>>>>>
92543>>>>>>>        For iCount from 0 to iItems
92549>>>>>>>>
92549>>>>>>>            Move sFileArray[iCount] to sValue
92550>>>>>>>            Writeln channel iCh sValue
92553>>>>>>>        Loop
92554>>>>>>>>
92554>>>>>>>        Send Seq_Close_Channel iCh
92555>>>>>>>
92555>>>>>>>        Function_Return (Err = False)
92556>>>>>>>    End_Function
92557>>>>>>>
92557>>>>>>>    // This might be needed by API-methods when a connection id is to be used and
92557>>>>>>>    // the connection ID hasn't been established with the driver's CLI interface.
92557>>>>>>>    // NOTE: Only applicable for DAW drivers, as Mertech drivers doesn't use connection ID's.
92557>>>>>>>    Function UtilCreateConnectionID String sConnectionID Returns Boolean
92559>>>>>>>        String sConnectionString sDriverID
92559>>>>>>>        Boolean bOK bSilent bDawDriver
92559>>>>>>>        Handle hoCLI
92559>>>>>>>
92559>>>>>>>        Move False to bOK
92560>>>>>>>        Get psDriverID to sDriverID
92561>>>>>>>        Get IsDAWSQLDriver sDriverID to bDawDriver
92562>>>>>>>        If (bDawDriver = False) Begin
92564>>>>>>>            Error DFERR_PROGRAM "The UtilCreateConnectionID function is only available for DAW drivers. (Not Mertech)."
92565>>>>>>>>
92565>>>>>>>            Function_Return False
92566>>>>>>>        End
92566>>>>>>>>
92566>>>>>>>
92566>>>>>>>        Get psConnectionString to sConnectionString
92567>>>>>>>        Get pbSilentLogin      to bSilent
92568>>>>>>>
92568>>>>>>>        Get phoCLIHandler to hoCLI
92569>>>>>>>        If (hoCLI <> 0) Begin
92571>>>>>>>            Set psDriverID of hoCLI to sDriverID
92572>>>>>>>            Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to bOK
92573>>>>>>>        End
92573>>>>>>>>
92573>>>>>>>
92573>>>>>>>        Function_Return (bOK = False)
92574>>>>>>>    End_Function
92575>>>>>>>
92575>>>>>>>    // This message creates an error log in the "Home" folder named "SQLErrorLog.txt",
92575>>>>>>>    // and opens it in "notepad.exe".
92575>>>>>>>    // Note: This is _not_ used by the cDbUpdateHandler & cDbUpdateVersion classes!
92575>>>>>>>    //       Instead the cDbUpdateLogFile's WriteErrorLog & ShowErrorLog are used.
92575>>>>>>>    Procedure UtilShowErrorList
92577>>>>>>>        tSqlErrorArray aSqlErrorArray
92577>>>>>>>        tSqlErrorArray aSqlErrorArray
92577>>>>>>>        Integer iRows iCount iCh iErrorNum
92577>>>>>>>        String sPath sFileName sErrorTxt sStatement
92577>>>>>>>
92577>>>>>>>        Get psHome of (phoWorkspace(ghoApplication)) to sPath
92578>>>>>>>        Get vFolderFormat sPath to sPath
92579>>>>>>>        Move "SQLErrorLog.txt"  to sFileName
92580>>>>>>>        Get Seq_Open_Output_Channel (sPath + sFileName) to iCh
92581>>>>>>>            Get paSqlErrorArray to aSqlErrorArray
92582>>>>>>>            Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iRows
92583>>>>>>>            If (iRows > 0) Begin
92585>>>>>>>                Decrement iRows
92586>>>>>>>                for iCount from 0 to iRows
92592>>>>>>>>
92592>>>>>>>                    Move aSqlErrorArray.sSqlErrorArray[iCount]      to sErrorTxt
92593>>>>>>>                    Move aSqlErrorArray.sSqlStatementArray[iCount]  to sStatement
92594>>>>>>>                    Move aSqlErrorArray.iSqlErrorArray[iCount]      to iErrorNum
92595>>>>>>>                    Writeln channel iCh "Error No: " iErrorNum " Error Text: " sErrorTxt
92601>>>>>>>                    Writeln channel iCh "SQL Statement: " sStatement
92605>>>>>>>                Loop
92606>>>>>>>>
92606>>>>>>>            End
92606>>>>>>>>
92606>>>>>>>        Send Seq_Close_Channel iCh
92607>>>>>>>
92607>>>>>>>        If (iRows > 0) Begin
92609>>>>>>>            Runprogram Shell Background (sPath + sFileName)
92610>>>>>>>        End
92610>>>>>>>>
92610>>>>>>>    End_Procedure
92611>>>>>>>
92611>>>>>>>    // For this to be returning a True value, the table number needs to be in the Filelist.cfg,
92611>>>>>>>    // and the table needs to exist as an SQL table.
92611>>>>>>>    Function UtilTableIsSql Handle hTable Returns Boolean
92613>>>>>>>        String sRootName sDriverID
92613>>>>>>>        Boolean bIsSQL
92613>>>>>>>
92613>>>>>>>        Move False to bIsSQL
92614>>>>>>>        If (hTable > 0) Begin
92616>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
92619>>>>>>>            Move (sRootName contains ":") to bIsSQL
92620>>>>>>>            If (bIsSQL = True) Begin
92622>>>>>>>                Get psDriverID to sDriverID
92623>>>>>>>                Get _TableNameOnly sRootName to sRootName
92624>>>>>>>                Get SqlUtilCheckIfTableNameExists sRootName sDriverID to bIsSQL
92625>>>>>>>            End
92625>>>>>>>>
92625>>>>>>>        End
92625>>>>>>>>
92625>>>>>>>
92625>>>>>>>        Function_Return bIsSQL
92626>>>>>>>    End_Function
92627>>>>>>>
92627>>>>>>>    Function UtilTableIsSqlByRootName String sRootName Returns Boolean
92629>>>>>>>        Boolean bIsSQL
92629>>>>>>>        Move (sRootName contains ":") to bIsSQL
92630>>>>>>>        Function_Return bIsSQL
92631>>>>>>>    End_Function
92632>>>>>>>
92632>>>>>>>
92632>>>>>>>    // Returns True if the passed hTable (filelist slot number) is an Alias table.
92632>>>>>>>    // An Alias file/table is a filelist number that share the same Physical filename
92632>>>>>>>    // but the Logical name is different.
92632>>>>>>>    // Note: If the table cannot be opened; the table is not considered to be an Alias.
92632>>>>>>>//    Function UtilTableIsAlias Handle hTable Returns Boolean
92632>>>>>>>//        String sPhysicalName sPhysicalNameCompare
92632>>>>>>>//        Boolean bWasOpen bOpened bOK
92632>>>>>>>//        Integer iCount
92632>>>>>>>//
92632>>>>>>>//        Move 0 to iCount
92632>>>>>>>//        Get_Attribute DF_FILE_OPENED of hTable to bWasOpen
92632>>>>>>>//        If (bWasOpen = False) Begin
92632>>>>>>>//            Open hTable
92632>>>>>>>//            Get_Attribute DF_FILE_OPENED of hTable to bOpened
92632>>>>>>>//            If (bOpened = False) Begin
92632>>>>>>>//                Function_Return False
92632>>>>>>>//            End
92632>>>>>>>//        End
92632>>>>>>>//
92632>>>>>>>//        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName
92632>>>>>>>//        Get _TableNameOnly sPhysicalName to sPhysicalName
92632>>>>>>>//        If (bWasOpen = False and bOpened = True) Begin
92632>>>>>>>//            Close hTable
92632>>>>>>>//        End
92632>>>>>>>//
92632>>>>>>>//        Move 0 to hTable
92632>>>>>>>//        Repeat
92632>>>>>>>//            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92632>>>>>>>//            If (hTable > 0 and hTable <> 50) Begin
92632>>>>>>>//                Open hTable
92632>>>>>>>//                Get_Attribute DF_FILE_OPENED of hTable to bOpened
92632>>>>>>>//                If (bOpened = True) Begin
92632>>>>>>>//                    Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalNameCompare
92632>>>>>>>//                    Close hTable
92632>>>>>>>//                    Get _TableNameOnly sPhysicalNameCompare to sPhysicalNameCompare
92632>>>>>>>//                    If (Uppercase(sPhysicalName) = Uppercase(sPhysicalNameCompare)) Begin
92632>>>>>>>//                        Increment iCount
92632>>>>>>>//                    End
92632>>>>>>>//                End
92632>>>>>>>//            End
92632>>>>>>>//        Until (hTable = 0)
92632>>>>>>>//
92632>>>>>>>//        If (iCount > 1) Begin
92632>>>>>>>//            Function_Return True
92632>>>>>>>//        End
92632>>>>>>>//
92632>>>>>>>//        Function_Return False
92632>>>>>>>//    End_Function
92632>>>>>>>
92632>>>>>>>    Function UtilTableIsAlias Handle hTable Returns Boolean
92634>>>>>>>        String sPhysicalName sPhysicalNameCompare
92634>>>>>>>        Integer iCount iMaster iAlias iInTable
92634>>>>>>>
92634>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sPhysicalName
92637>>>>>>>        Get _TableNameOnly sPhysicalName to sPhysicalName
92638>>>>>>>        Move hTable to iInTable
92639>>>>>>>        Move 0 to hTable
92640>>>>>>>        Move 0 to iCount
92641>>>>>>>
92641>>>>>>>        Repeat
92641>>>>>>>>
92641>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92644>>>>>>>            If (hTable > 0 and hTable <> 50) Begin
92646>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sPhysicalNameCompare
92649>>>>>>>                Get _TableNameOnly sPhysicalNameCompare to sPhysicalNameCompare
92650>>>>>>>                If (Uppercase(sPhysicalName) = Uppercase(sPhysicalNameCompare)) Begin
92652>>>>>>>
92652>>>>>>>                    If (iCount = 0) Begin
92654>>>>>>>                        Move hTable to iMaster
92655>>>>>>>                    End
92655>>>>>>>>
92655>>>>>>>                    If (iCount > 0) Begin
92657>>>>>>>                        Move hTable to iAlias
92658>>>>>>>                    End
92658>>>>>>>>
92658>>>>>>>                    Increment iCount
92659>>>>>>>                End
92659>>>>>>>>
92659>>>>>>>            End
92659>>>>>>>>
92659>>>>>>>        Until (hTable = 0)
92661>>>>>>>
92661>>>>>>>        If (iCount > 1) Begin
92663>>>>>>>            Function_Return (iInTable >= iAlias and iAlias > iMaster)
92664>>>>>>>        End
92664>>>>>>>>
92664>>>>>>>
92664>>>>>>>        Function_Return False
92665>>>>>>>    End_Function
92666>>>>>>>
92666>>>>>>>//    Function UtilTableIsAliasFdFile Handle hTable Returns Boolean
92666>>>>>>>//        String sDDSrcPath sDataPath sLogicalName
92666>>>>>>>//        Boolean bOK bExists
92666>>>>>>>//
92666>>>>>>>//        Get psDataPath  of (phoWorkspace(ghoApplication)) to sDataPath
92666>>>>>>>//        If (Right(sDataPath, 1) = "\") Begin
92666>>>>>>>//            Move (Left(sDataPath, (Length(sDataPath) -1))) to sDataPath
92666>>>>>>>//        End
92666>>>>>>>//        Move (StringFromRightOfChar(sDataPath, "\")) to sDDSrcPath
92666>>>>>>>//        Move (Replace(sDDSrcPath, sDataPath, ""))    to sDDSrcPath
92666>>>>>>>//        Move (sDDSrcPath + "DDSrc")                  to sDDSrcPath
92666>>>>>>>//        Get vFolderFormat sDDSrcPath                 to sDDSrcPath
92666>>>>>>>//
92666>>>>>>>//        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
92666>>>>>>>//        Get vFilePathExists (sDDSrcPath + sLogicalName + ".fd") to bExists
92666>>>>>>>//
92666>>>>>>>//        Function_Return bExists
92666>>>>>>>//    End_Function
92666>>>>>>>
92666>>>>>>>    // To Open a table with any driver.
92666>>>>>>>    // Note: If the driver is <> DATAFLEX_ID  - login credentials are used; it is then assumed
92666>>>>>>>    //       that the proper login properties has been setup properly with the cSQLConnections object.
92666>>>>>>>    //
92666>>>>>>>    // If the open command fails the Err flag will be reset to false, at the end of the function!
92666>>>>>>>    // The found flag is still used to indicate if the open was successful or not. The function
92666>>>>>>>    // returns a True if successful (table could be opened).
92666>>>>>>>    //
92666>>>>>>>    // Using the "Open As" syntax with drivers means that we don't need to rely on .int file settings.
92666>>>>>>>    // This is good because with DFConnectionID's those credentials doesn't need to be available in
92666>>>>>>>    // the .int file (and probably aren't). As long as the login properties of this object have been
92666>>>>>>>    // set properly we can open the table.
92666>>>>>>>    //
92666>>>>>>>    // DAW Driver Syntax:
92666>>>>>>>    //  <CKId>:<Schema>#<Table>@<ConnectString>|<Filename>.int
92666>>>>>>>    //  Now the @<ConnectString> can be followed by a pipe character '|' followed by the name of the INT file.
92666>>>>>>>    //  Doing so, the driver will apply the information from the .INT file to the passed direct Open String.
92666>>>>>>>    //  Note that when an INT file has been passed, it will skip the keyword DRIVER_NAME, SERVER_NAME,
92666>>>>>>>    //  DATABASE_NAME and SCHEMA_NAME from the INT file because those are supposed to be supplied in the String already.
92666>>>>>>>    //  Open mode; iMode = DF_SHARE or DF_EXCLUSIVE.
92666>>>>>>>    //
92666>>>>>>>    // DAW Driver Sample:
92666>>>>>>>    //   Open "MSSQLDRV:dbo#MyFile@SERVER=(local)\SQLEXPRESS;Trusted_Connection=yes;DATABASE=OrderEntry|options|intfile=MyFile.int"
92666>>>>>>>    //
92666>>>>>>>    // Mertech Driver Samples:
92666>>>>>>>    //   SQLFlex:   Open "sql_drv:\\<serverName>\<database>*<owner>*<tableName>=<numberFieds>" as table
92666>>>>>>>    //   MySQLFlex: Open "mdsmysql:\\<serverName>\<database>*<tableName>=<numberFieds>" as table
92666>>>>>>>    //   PgFlex:    Open "mdspgsql:\\<serverName>\<database>*<schema>*<tableName>=<numberFieds>" as table
92666>>>>>>>    //   ORAFlex:   Open "ora_drv:\\<serverName>\<owner>*<tableName>=<numberFieds>" as table
92666>>>>>>>    Function UtilTableOpen Integer hTable String sTableName Integer iMode Returns Boolean
92668>>>>>>>        String sDriverID sConnection sSchema sExt sTableNameShort sTableNameOrg
92668>>>>>>>        Boolean bOpen bMertechDriver bOK
92668>>>>>>>        tSQLConnection SQLConnection
92668>>>>>>>        tSQLConnection SQLConnection
92668>>>>>>>
92668>>>>>>>        Move sTableName to sTableNameOrg
92669>>>>>>>        If (hTable > 0) Begin
92671>>>>>>>            Send Ignore_Error of Error_Object_Id 20529
92672>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
92673>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
92674>>>>>>>            Open hTable
92676>>>>>>>            Send Trap_Error of Error_Object_Id 20529
92677>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
92678>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
92679>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
92682>>>>>>>            If (bOpen = True) Begin
92684>>>>>>>                Function_Return True
92685>>>>>>>            End
92685>>>>>>>>
92685>>>>>>>        End
92685>>>>>>>>
92685>>>>>>>
92685>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
92686>>>>>>>        Move SQLConnection.sDriverID to sDriverID
92687>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
92688>>>>>>>        Move SQLConnection.sConnectionString to sConnection
92689>>>>>>>        Move SQLConnection.sSchema to sSchema
92690>>>>>>>        If (sSchema = "") Begin
92692>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
92693>>>>>>>        End
92693>>>>>>>>
92693>>>>>>>
92693>>>>>>>        // We need to remove the ".int" part of the table name because
92693>>>>>>>        // the table name after the "#" in the connection syntax below wants the
92693>>>>>>>        // "bare" table name without any extension.
92693>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
92695>>>>>>>            If (Lowercase(sTableName) contains ".int") Begin
92697>>>>>>>                Get ParseFileExtension sTableName to sExt
92698>>>>>>>                Move (Replace(("." + sExt), sTableName, "")) to sTableNameShort
92699>>>>>>>            End
92699>>>>>>>>
92699>>>>>>>            Else Begin
92700>>>>>>>                Move sTableName to sTableNameShort
92701>>>>>>>                Move (Append(sTableName, ".int")) to sTableName
92702>>>>>>>            End
92702>>>>>>>>
92702>>>>>>>            If (bMertechDriver = False) Begin
92704>>>>>>>                Move (sDriverID + ":" + sSchema + "#" + sTableNameShort + "@" + sConnection + "|options|intfile=" + sTableName) to sConnection
92705>>>>>>>                Move sConnection to sTableName
92706>>>>>>>            End
92706>>>>>>>>
92706>>>>>>>        End
92706>>>>>>>>
92706>>>>>>>
92706>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
92707>>>>>>>        Send Ignore_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
92708>>>>>>>        If (hTable = 0) Begin
92710>>>>>>>            Get NextFreeFilelistSlot to hTable
92711>>>>>>>        End
92711>>>>>>>>
92711>>>>>>>
92711>>>>>>>        Case Begin
92711>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
92713>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
92713>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
92715>>>>>>>                    Open sTableName as hTable
92717>>>>>>>                End
92717>>>>>>>>
92717>>>>>>>                Else Begin
92718>>>>>>>                    Get OpenTableExclusive hTable to bOK
92719>>>>>>>                    If (bOK = False) Begin
92721>>>>>>>                        Function_Return False
92722>>>>>>>                    End
92722>>>>>>>>
92722>>>>>>>                End
92722>>>>>>>>
92722>>>>>>>                Case Break
92723>>>>>>>
92723>>>>>>>            Case (sDriverID = DB2_DRV_ID)
92726>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
92726>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
92728>>>>>>>                    Open sTableName as hTable
92730>>>>>>>                End
92730>>>>>>>>
92730>>>>>>>                Else Begin
92731>>>>>>>                    Get OpenTableExclusive hTable to bOK
92732>>>>>>>                    If (bOK = False) Begin
92734>>>>>>>                        Function_Return False
92735>>>>>>>                    End
92735>>>>>>>>
92735>>>>>>>                End
92735>>>>>>>>
92735>>>>>>>                Case Break
92736>>>>>>>
92736>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
92739>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
92739>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
92741>>>>>>>                    Open sTableName as hTable
92743>>>>>>>                End
92743>>>>>>>>
92743>>>>>>>                Else Begin
92744>>>>>>>                    Get OpenTableExclusive hTable to bOK
92745>>>>>>>                    If (bOK = False) Begin
92747>>>>>>>                        Function_Return False
92748>>>>>>>                    End
92748>>>>>>>>
92748>>>>>>>                End
92748>>>>>>>>
92748>>>>>>>                Case Break
92749>>>>>>>
92749>>>>>>>            Case (sDriverID = SQLFLEX)
92752>>>>>>>                // ToDo: What is the <owner>? Same as Schema?
92752>>>>>>>                // SQLFlex:   Open "sql_drv:\\<serverName>\<database>*<owner>*<tableName>=<numberFieds>" as table
92752>>>>>>>                Move (SQLFLEX + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + SQLConnection.sSchema + "*" + sTableNameOrg) to sTableName
92753>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
92753>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
92755>>>>>>>                    Open sTableName as hTable
92757>>>>>>>                End
92757>>>>>>>>
92757>>>>>>>                Else Begin
92758>>>>>>>                    Get OpenTableExclusive hTable to bOK
92759>>>>>>>                    If (bOK = False) Begin
92761>>>>>>>                        Function_Return False
92762>>>>>>>                    End
92762>>>>>>>>
92762>>>>>>>                End
92762>>>>>>>>
92762>>>>>>>                Case Break
92763>>>>>>>
92763>>>>>>>            Case (sDriverID = MDSMySQL)
92766>>>>>>>                // MySQLFlex: Open "mdsmysql:\\<serverName>\<database>*<tableName>=<numberFieds>" as table
92766>>>>>>>                Move (MDSMySQL + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + "*" + sTableNameOrg) to sTableName
92767>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
92767>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
92769>>>>>>>                    Open sTableName as hTable
92771>>>>>>>                End
92771>>>>>>>>
92771>>>>>>>                Else Begin
92772>>>>>>>                    Get OpenTableExclusive hTable to bOK
92773>>>>>>>                    If (bOK = False) Begin
92775>>>>>>>                        Function_Return False
92776>>>>>>>                    End
92776>>>>>>>>
92776>>>>>>>                End
92776>>>>>>>>
92776>>>>>>>                Case Break
92777>>>>>>>
92777>>>>>>>            Case (sDriverID = MDSPgSQL)
92780>>>>>>>                // PgFlex: Open "mdspgsql:\\<serverName>\<database>*<schema>*<tableName>=<numberFieds>" as table
92780>>>>>>>                Move (MDSPgSQL + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + "*" + SQLConnection.sSchema + "*" + sTableNameOrg) to sTableName
92781>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
92781>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
92783>>>>>>>                    Open sTableName as hTable
92785>>>>>>>                End
92785>>>>>>>>
92785>>>>>>>                Else Begin
92786>>>>>>>                    Get OpenTableExclusive hTable to bOK
92787>>>>>>>                    If (bOK = False) Begin
92789>>>>>>>                        Function_Return False
92790>>>>>>>                    End
92790>>>>>>>>
92790>>>>>>>                End
92790>>>>>>>>
92790>>>>>>>                Case Break
92791>>>>>>>
92791>>>>>>>            Case (sDriverID = ORAFLEX)
92794>>>>>>>                // ToDo: What is the <owner>? Same as Schema?
92794>>>>>>>                // ORAFlex: Open "ora_drv:\\<serverName>\<owner>*<tableName>=<numberFieds>" as table
92794>>>>>>>                Move (ORAFLEX + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sSchema + "*" + sTableName) to sTableName
92795>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
92795>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
92797>>>>>>>                    Open sTableName as hTable
92799>>>>>>>                End
92799>>>>>>>>
92799>>>>>>>                Else Begin
92800>>>>>>>                    Get OpenTableExclusive hTable to bOK
92801>>>>>>>                    If (bOK = False) Begin
92803>>>>>>>                        Function_Return False
92804>>>>>>>                    End
92804>>>>>>>>
92804>>>>>>>                End
92804>>>>>>>>
92804>>>>>>>                Case Break
92805>>>>>>>
92805>>>>>>>            Case (sDriverID = DATAFLEX_ID)
92808>>>>>>>                If (sTableName <> "" and iMode <> DF_EXCLUSIVE) Begin
92810>>>>>>>                    Open sTableName as hTable
92812>>>>>>>                End
92812>>>>>>>>
92812>>>>>>>                Else If (iMode = DF_EXCLUSIVE) Begin
92815>>>>>>>                    Get OpenTableExclusive hTable to bOK
92816>>>>>>>                    If (bOK = False) Begin
92818>>>>>>>                        Function_Return False
92819>>>>>>>                    End
92819>>>>>>>>
92819>>>>>>>                End
92819>>>>>>>>
92819>>>>>>>                Else Begin
92820>>>>>>>                    Open hTable
92822>>>>>>>                End
92822>>>>>>>>
92822>>>>>>>                Case Break
92823>>>>>>>
92823>>>>>>>            // ToDo: Logic needs to be expanded for Mertech drivers!
92823>>>>>>>
92823>>>>>>>            Case Else
92823>>>>>>>                Error DFERR_PROGRAM ("Invalid driver:" * sDriverID)
92824>>>>>>>>
92824>>>>>>>        Case End
92824>>>>>>>
92824>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
92825>>>>>>>        Send Trap_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
92826>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
92828>>>>>>>            Move False to Found
92829>>>>>>>        End
92829>>>>>>>>
92829>>>>>>>        // If open failed, the Err is set to true,
92829>>>>>>>        // but we don't want that because it could end our loop.
92829>>>>>>>        Move False to Err
92830>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
92833>>>>>>>
92833>>>>>>>        Function_Return bOpen
92834>>>>>>>    End_Function
92835>>>>>>>
92835>>>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
92835>>>>>>>    // that the embedded .dat file exists on disk _or_ that the SQL table exists
92835>>>>>>>    // if it is an SQL table
92835>>>>>>>    Function UtilTableExists Handle hTable Returns Boolean
92837>>>>>>>        Boolean bExists bIsSQLTable
92837>>>>>>>        String sDataPath sRootName
92837>>>>>>>
92837>>>>>>>        Get UtilTableNumberIsInUse hTable to bExists
92838>>>>>>>        If (bExists = False) Begin
92840>>>>>>>            Function_Return False
92841>>>>>>>        End
92841>>>>>>>>
92841>>>>>>>
92841>>>>>>>        Move False to bIsSQLTable
92842>>>>>>>        If (hTable > 0) Begin
92844>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
92847>>>>>>>            Move (sRootName contains ":") to bIsSQLTable
92848>>>>>>>        End
92848>>>>>>>>
92848>>>>>>>        If (bIsSQLTable = True) Begin
92850>>>>>>>            Get UtilTableIsSQL hTable to bExists
92851>>>>>>>            Function_Return bExists
92852>>>>>>>        End
92852>>>>>>>>
92852>>>>>>>        Else Begin
92853>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
92854>>>>>>>            Get vFolderFormat sDataPath to sDataPath
92855>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
92856>>>>>>>        End
92856>>>>>>>>
92856>>>>>>>
92856>>>>>>>        Function_Return bExists
92857>>>>>>>    End_Function
92858>>>>>>>
92858>>>>>>>    // Pass a table handle
92858>>>>>>>    // Returns True if the table exists in filelist.cfg.
92858>>>>>>>    Function UtilTableNumberIsInUse Handle hCheckTable Returns Boolean
92860>>>>>>>        Handle hTable
92860>>>>>>>        Boolean bFound
92860>>>>>>>
92860>>>>>>>        Move False to bFound
92861>>>>>>>        Move 0 to hTable
92862>>>>>>>        Repeat
92862>>>>>>>>
92862>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92865>>>>>>>            If (hTable > 0) Begin
92867>>>>>>>                If (hTable = hCheckTable) Begin
92869>>>>>>>                    Move True to bFound
92870>>>>>>>                End
92870>>>>>>>>
92870>>>>>>>            End
92870>>>>>>>>
92870>>>>>>>            If (bFound = True) ;                Break
92873>>>>>>>        Until (hTable = 0)
92875>>>>>>>
92875>>>>>>>        Function_Return (bFound = True)
92876>>>>>>>    End_Function
92877>>>>>>>
92877>>>>>>>    Function UtilDriverFromTableNumber Handle hTable Returns String
92879>>>>>>>        Boolean bOK bExists                              
92879>>>>>>>        String sDriverID
92879>>>>>>>        
92879>>>>>>>        Get UtilTableExists hTable to bExists
92880>>>>>>>        If (bExists = False) Begin
92882>>>>>>>            Function_Return ""
92883>>>>>>>        End
92883>>>>>>>>
92883>>>>>>>        Get OpenTableExclusive hTable to bOK
92884>>>>>>>        If (bOK = False) Begin
92886>>>>>>>            Function_Return ""
92887>>>>>>>        End 
92887>>>>>>>>
92887>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
92890>>>>>>>        
92890>>>>>>>        Function_Return sDriverID
92891>>>>>>>    End_Function        
92892>>>>>>>    
92892>>>>>>>    // Number of tables in Filelist.cfg. Returns integger
92892>>>>>>>    Function UtilFilelistNoOfTables Returns Integer
92894>>>>>>>        Handle hTable
92894>>>>>>>        Integer iRetval
92894>>>>>>>
92894>>>>>>>        Move 0 to hTable
92895>>>>>>>        Move 0 to iRetval
92896>>>>>>>
92896>>>>>>>        Repeat
92896>>>>>>>>
92896>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92899>>>>>>>            If (hTable > 0) Begin
92901>>>>>>>                Increment iRetval
92902>>>>>>>            End
92902>>>>>>>>
92902>>>>>>>        Until (hTable = 0)
92904>>>>>>>
92904>>>>>>>        Function_Return iRetval
92905>>>>>>>    End_Function
92906>>>>>>>
92906>>>>>>>    Function UtilFilelistIsDataFlexTablesOnly Returns Boolean
92908>>>>>>>        String sRootName
92908>>>>>>>        Boolean bIsSQL
92908>>>>>>>        Handle hTable
92908>>>>>>>
92908>>>>>>>        Move False to bIsSQL
92909>>>>>>>        Move 0 to hTable
92910>>>>>>>        Repeat
92910>>>>>>>>
92910>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92913>>>>>>>            If (hTable > 0) Begin
92915>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
92918>>>>>>>                Move (sRootName contains ":") to bIsSQL
92919>>>>>>>                If (bIsSQL = True) Begin
92921>>>>>>>                    Move 0 to hTable
92922>>>>>>>                End
92922>>>>>>>>
92922>>>>>>>            End
92922>>>>>>>>
92922>>>>>>>        Until (hTable = 0)
92924>>>>>>>
92924>>>>>>>        Function_Return (bIsSQL = False)
92925>>>>>>>    End_Function
92926>>>>>>>
92926>>>>>>>    // Pass a table's logical name
92926>>>>>>>    // Returns True if the table exists in filelist.cfg.
92926>>>>>>>    Function UtilTableLogicalNameIsInUse String sCheckTable Returns Boolean
92928>>>>>>>        Handle hTable
92928>>>>>>>        Boolean bFound
92928>>>>>>>        String sCompareTable
92928>>>>>>>
92928>>>>>>>        Move False to bFound
92929>>>>>>>        Move 0 to hTable
92930>>>>>>>        Repeat
92930>>>>>>>>
92930>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92933>>>>>>>            If (hTable > 0) Begin
92935>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sCompareTable
92938>>>>>>>                If (Uppercase(sCompareTable) = Uppercase(sCheckTable)) Begin
92940>>>>>>>                    Move True to bFound
92941>>>>>>>                End
92941>>>>>>>>
92941>>>>>>>            End
92941>>>>>>>>
92941>>>>>>>            If (bFound = True) ;                Break
92944>>>>>>>        Until (hTable = 0)
92946>>>>>>>
92946>>>>>>>        Function_Return (bFound = True)
92947>>>>>>>    End_Function
92948>>>>>>>
92948>>>>>>>    // * Dummy function for the Studio's Code Explorer *
92948>>>>>>>    Function UTIL_ENUMERATION_FUNCTIONS Returns Boolean
92950>>>>>>>        Function_Return False
92951>>>>>>>    End_Function
92952>>>>>>>
92952>>>>>>>    Function UtilEnumerateOverlapFields Integer hTable Integer iField Returns String[]
92954>>>>>>>        String  sRetval
92954>>>>>>>        String[] sOverlapFieldsArray
92955>>>>>>>        Integer iType iColumn iColumns
92955>>>>>>>        Boolean bOpen bOverlap
92955>>>>>>>
92955>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
92958>>>>>>>        If (bOpen = False) Begin
92960>>>>>>>            Open hTable
92962>>>>>>>        End
92962>>>>>>>>
92962>>>>>>>
92962>>>>>>>        Move "" to sRetval
92963>>>>>>>
92963>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iColumns
92966>>>>>>>
92966>>>>>>>        for iColumn from 0 to iColumns
92972>>>>>>>>
92972>>>>>>>            Get_Attribute DF_FIELD_TYPE of hTable iColumn to iType
92975>>>>>>>            If (iField <> iColumn and iType <> DF_OVERLAP) Begin
92977>>>>>>>                Get_Attribute DF_FIELD_OVERLAP of hTable iField iColumn to bOverlap
92980>>>>>>>                If (bOverlap) Begin
92982>>>>>>>                    If (sRetval <> "") Begin
92984>>>>>>>                        Append sRetval ","
92985>>>>>>>                    End
92985>>>>>>>>
92985>>>>>>>                    Append sRetval iColumn
92986>>>>>>>                End
92986>>>>>>>>
92986>>>>>>>            End
92986>>>>>>>>
92986>>>>>>>        Loop
92987>>>>>>>>
92987>>>>>>>
92987>>>>>>>        If (bOpen = False) Begin
92989>>>>>>>            Close hTable
92990>>>>>>>        End
92990>>>>>>>>
92990>>>>>>>
92990>>>>>>>        Get StrSplitToArray sRetval "," to sOverlapFieldsArray
92991>>>>>>>
92991>>>>>>>        Function_Return sOverlapFieldsArray
92992>>>>>>>    End_Function
92993>>>>>>>
92993>>>>>>>    // Returns a struct array with all data types for the passed driver & dbtype.
92993>>>>>>>    Function UtilEnumerateColumnTypes String sDriverID Integer iDbType Returns tColumnType[]
92995>>>>>>>        tColumnType[] ColumnType
92995>>>>>>>        tColumnType[] ColumnType
92996>>>>>>>
92996>>>>>>>        Case Begin
92996>>>>>>>            Case (iDbType = EN_dbTypeDataFlex)
92998>>>>>>>                Get _UtilEnumerateDataFlexTypes to ColumnType
92999>>>>>>>                Case Break
93000>>>>>>>
93000>>>>>>>            Case (iDbType = EN_DbTypeDB2)
93003>>>>>>>                Get _UtilEnumerateDB2Types to ColumnType
93004>>>>>>>                Case Break
93005>>>>>>>
93005>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
93008>>>>>>>                Get _UtilEnumerateMSSQLTypes sDriverID to ColumnType
93009>>>>>>>                Case Break
93010>>>>>>>
93010>>>>>>>            Case (sDriverID = MDSMySQL)
93013>>>>>>>                Get _UtilEnumerateMySQLTypes to ColumnType
93014>>>>>>>                Case Break
93015>>>>>>>
93015>>>>>>>            Case (sDriverID = ORAFLEX)
93018>>>>>>>                Get _UtilEnumerateOracleTypes to ColumnType
93019>>>>>>>                Case Break
93020>>>>>>>
93020>>>>>>>            Case (sDriverID = MDSPgSQL)
93023>>>>>>>                Get _UtilEnumeratePostgreSQLTypes to ColumnType
93024>>>>>>>                Case Break
93025>>>>>>>        Case End
93025>>>>>>>
93025>>>>>>>        Function_Return ColumnType
93026>>>>>>>    End_Function
93027>>>>>>>
93027>>>>>>>    Function UtilEnumerateMSSQLODBCDrivers Returns String
93029>>>>>>>        Handle hoRegistry hoODBCDriverNames
93029>>>>>>>        Boolean bExists bKeyOpened
93029>>>>>>>        String sKey
93029>>>>>>>        String[] sDrivers
93030>>>>>>>        Integer iDriverNames iDriverName
93030>>>>>>>
93030>>>>>>>        Get Create (RefClass (cRegistry)) to hoRegistry
93031>>>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
93032>>>>>>>        Set pfAccessRights of hoRegistry to Key_Read
93033>>>>>>>        Move "SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers" to sKey
93034>>>>>>>        Get KeyExists of hoRegistry sKey to bExists
93035>>>>>>>        If (bExists) Begin
93037>>>>>>>            Get OpenKey of hoRegistry sKey to bKeyOpened
93038>>>>>>>            If (bKeyOpened) Begin
93040>>>>>>>                Get Create (RefClass (Array)) to hoODBCDriverNames
93041>>>>>>>                Get GetValues of hoRegistry hoODBCDriverNames to iDriverNames
93042>>>>>>>                If (iDriverNames > 0) Begin
93044>>>>>>>                    Move (ResizeArray (sDrivers, iDriverNames)) to sDrivers
93045>>>>>>>                    Decrement iDriverNames
93046>>>>>>>                    for iDriverName from 0 to iDriverNames
93052>>>>>>>>
93052>>>>>>>                        Get Value of hoODBCDriverNames iDriverName to sDrivers[iDriverName]
93053>>>>>>>                      Loop
93054>>>>>>>>
93054>>>>>>>                End
93054>>>>>>>>
93054>>>>>>>                Send CloseKey of hoRegistry
93055>>>>>>>            End
93055>>>>>>>>
93055>>>>>>>        End
93055>>>>>>>>
93055>>>>>>>        Send Destroy of hoRegistry
93056>>>>>>>
93056>>>>>>>        Function_Return sDrivers
93057>>>>>>>    End_Function
93058>>>>>>>
93058>>>>>>>    // DataFlex Embedded Database Data Types:
93058>>>>>>>    // Helper function for UtilEnumerateColumnTypes
93058>>>>>>>    Function _UtilEnumerateDataFlexTypes Returns tColumnType[]
93060>>>>>>>        tColumnType[] ColumnType
93060>>>>>>>        tColumnType[] ColumnType
93061>>>>>>>        Integer i
93061>>>>>>>
93061>>>>>>>        Move DF_ASCII           to ColumnType[i].iSQLType
93062>>>>>>>        Move "ASCII"            to ColumnType[i].sSQLType
93063>>>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
93064>>>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
93065>>>>>>>        Move "254"              to ColumnType[i].sPrecision
93066>>>>>>>        Increment i
93067>>>>>>>
93067>>>>>>>        Move DF_BCD             to ColumnType[i].iSQLType
93068>>>>>>>        Move "Numeric"          to ColumnType[i].sSQLType
93069>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
93070>>>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
93071>>>>>>>        Move "14.8"             to ColumnType[i].sPrecision
93072>>>>>>>        Increment i
93073>>>>>>>
93073>>>>>>>        Move DF_DATE            to ColumnType[i].iSQLType
93074>>>>>>>        Move "Date"             to ColumnType[i].sSQLType
93075>>>>>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
93076>>>>>>>        Move "Date"             to ColumnType[i].sDataFlexType
93077>>>>>>>        Move "6.0"              to ColumnType[i].sPrecision
93078>>>>>>>        Move True               to ColumnType[i].bCanEditSize
93079>>>>>>>        Increment i
93080>>>>>>>
93080>>>>>>>        Move DF_TEXT            to ColumnType[i].iSQLType
93081>>>>>>>        Move "Text"             to ColumnType[i].sSQLType
93082>>>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
93083>>>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
93084>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
93085>>>>>>>        Increment i
93086>>>>>>>
93086>>>>>>>        Move DF_BINARY          to ColumnType[i].iSQLType
93087>>>>>>>        Move "Binary"           to ColumnType[i].sSQLType
93088>>>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
93089>>>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
93090>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
93091>>>>>>>        Increment i
93092>>>>>>>
93092>>>>>>>        Move DF_DATETIME        to ColumnType[i].iSQLType
93093>>>>>>>        Move "DateTime"         to ColumnType[i].sSQLType
93094>>>>>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
93095>>>>>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
93096>>>>>>>        Move "23"               to ColumnType[i].sPrecision
93097>>>>>>>        Move True               to ColumnType[i].bCanEditSize
93098>>>>>>>        Increment i
93099>>>>>>>
93099>>>>>>>        Move DF_OVERLAP         to ColumnType[i].iSQLType
93100>>>>>>>        Move "Overlap"          to ColumnType[i].sSQLType
93101>>>>>>>        Move DF_OVERLAP         to ColumnType[i].iDataFlexType
93102>>>>>>>        Move "Overlap"          to ColumnType[i].sDataFlexType
93103>>>>>>>        Move "0.0"              to ColumnType[i].sPrecision
93104>>>>>>>
93104>>>>>>>        Function_Return ColumnType
93105>>>>>>>    End_Function
93106>>>>>>>
93106>>>>>>>    Function _UtilEnumerateDB2Types Returns tColumnType[]
93108>>>>>>>        tColumnType[] aColumnType
93108>>>>>>>        tColumnType[] aColumnType
93109>>>>>>>        Integer i
93109>>>>>>>
Including file: DB2_DRV_DriverDef.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\DB2_DRV_DriverDef.inc)
93109>>>>>>>>// Generated By The Database Update Framework
93109>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\DB2_DRV_DriverDef.xml
93109>>>>>>>>// Driver COLUMN DATA TYPES
93109>>>>>>>>//
93109>>>>>>>>// Created: 2018-03-14 23:46:34.033
93109>>>>>>>>
93109>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
93110>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
93111>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93112>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93113>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93114>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93115>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
93116>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93117>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93118>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
93119>>>>>>>>            Increment i
93120>>>>>>>>
93120>>>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
93121>>>>>>>>            Move -98                                     to aColumnType[i].iSQLType
93122>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93123>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93124>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
93125>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93126>>>>>>>>            Move 2147483647                              to aColumnType[i].nMaxSize
93127>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
93128>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
93129>>>>>>>>            Move 2147483647                              to aColumnType[i].sPrecision
93130>>>>>>>>            Increment i
93131>>>>>>>>
93131>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
93132>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
93133>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93134>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93135>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93136>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93137>>>>>>>>            Move 254                                     to aColumnType[i].nMaxSize
93138>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93139>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93140>>>>>>>>            Move 254                                     to aColumnType[i].sPrecision
93141>>>>>>>>            Increment i
93142>>>>>>>>
93142>>>>>>>>            Move "char for bit data"                     to aColumnType[i].sSQLType
93143>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
93144>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93145>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93146>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93147>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93148>>>>>>>>            Move 254                                     to aColumnType[i].nMaxSize
93149>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93150>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93151>>>>>>>>            Move 254                                     to aColumnType[i].sPrecision
93152>>>>>>>>            Increment i
93153>>>>>>>>
93153>>>>>>>>            Move "clob"                                  to aColumnType[i].sSQLType
93154>>>>>>>>            Move -99                                     to aColumnType[i].iSQLType
93155>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93156>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93157>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
93158>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93159>>>>>>>>            Move 2147483647                              to aColumnType[i].nMaxSize
93160>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
93161>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
93162>>>>>>>>            Move 2147483647                              to aColumnType[i].sPrecision
93163>>>>>>>>            Increment i
93164>>>>>>>>
93164>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
93165>>>>>>>>            Move 91                                      to aColumnType[i].iSQLType
93166>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
93167>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93168>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
93169>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
93170>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
93171>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93172>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93173>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
93174>>>>>>>>            Increment i
93175>>>>>>>>
93175>>>>>>>>            Move "dbclob"                                to aColumnType[i].sSQLType
93176>>>>>>>>            Move -350                                    to aColumnType[i].iSQLType
93177>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93178>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93179>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93180>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93181>>>>>>>>            Move 1073741823                              to aColumnType[i].nMaxSize
93182>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93183>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93184>>>>>>>>            Move 1073741823                              to aColumnType[i].sPrecision
93185>>>>>>>>            Increment i
93186>>>>>>>>
93186>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
93187>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
93188>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93189>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93190>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93191>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93192>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
93193>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93194>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93195>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
93196>>>>>>>>            Increment i
93197>>>>>>>>
93197>>>>>>>>            Move "double"                                to aColumnType[i].sSQLType
93198>>>>>>>>            Move 8                                       to aColumnType[i].iSQLType
93199>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93200>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93201>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93202>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93203>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
93204>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93205>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93206>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
93207>>>>>>>>            Increment i
93208>>>>>>>>
93208>>>>>>>>            Move "graphic"                               to aColumnType[i].sSQLType
93209>>>>>>>>            Move -95                                     to aColumnType[i].iSQLType
93210>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93211>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93212>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93213>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93214>>>>>>>>            Move 127                                     to aColumnType[i].nMaxSize
93215>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93216>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93217>>>>>>>>            Move 127                                     to aColumnType[i].sPrecision
93218>>>>>>>>            Increment i
93219>>>>>>>>
93219>>>>>>>>            Move "integer"                               to aColumnType[i].sSQLType
93220>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
93221>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93222>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93223>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93224>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93225>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
93226>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93227>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93228>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
93229>>>>>>>>            Increment i
93230>>>>>>>>
93230>>>>>>>>            Move "long varchar"                          to aColumnType[i].sSQLType
93231>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
93232>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93233>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93234>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93235>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93236>>>>>>>>            Move 32000                                   to aColumnType[i].nMaxSize
93237>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93238>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93239>>>>>>>>            Move 32000                                   to aColumnType[i].sPrecision
93240>>>>>>>>            Increment i
93241>>>>>>>>
93241>>>>>>>>            Move "long varchar for bit data"             to aColumnType[i].sSQLType
93242>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
93243>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93244>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93245>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93246>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93247>>>>>>>>            Move 32700                                   to aColumnType[i].nMaxSize
93248>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93249>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93250>>>>>>>>            Move 32700                                   to aColumnType[i].sPrecision
93251>>>>>>>>            Increment i
93252>>>>>>>>
93252>>>>>>>>            Move "long vargraphic"                       to aColumnType[i].sSQLType
93253>>>>>>>>            Move -97                                     to aColumnType[i].iSQLType
93254>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93255>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93256>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93257>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93258>>>>>>>>            Move 16350                                   to aColumnType[i].nMaxSize
93259>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93260>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93261>>>>>>>>            Move 16350                                   to aColumnType[i].sPrecision
93262>>>>>>>>            Increment i
93263>>>>>>>>
93263>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
93264>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
93265>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93266>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93267>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93268>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93269>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
93270>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93271>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93272>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
93273>>>>>>>>            Increment i
93274>>>>>>>>
93274>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
93275>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
93276>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93277>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93278>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93279>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93280>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
93281>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93282>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93283>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
93284>>>>>>>>            Increment i
93285>>>>>>>>
93285>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
93286>>>>>>>>            Move 92                                      to aColumnType[i].iSQLType
93287>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
93288>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93289>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
93290>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
93291>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
93292>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93293>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93294>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
93295>>>>>>>>            Increment i
93296>>>>>>>>
93296>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
93297>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
93298>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
93299>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93300>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
93301>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
93302>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
93303>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93304>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93305>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
93306>>>>>>>>            Increment i
93307>>>>>>>>
93307>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
93308>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
93309>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93310>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93311>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93312>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93313>>>>>>>>            Move 32672                                   to aColumnType[i].nMaxSize
93314>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93315>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93316>>>>>>>>            Move 32672                                   to aColumnType[i].sPrecision
93317>>>>>>>>            Increment i
93318>>>>>>>>
93318>>>>>>>>            Move "varchar for bit data"                  to aColumnType[i].sSQLType
93319>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
93320>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93321>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93322>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93323>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93324>>>>>>>>            Move 32672                                   to aColumnType[i].nMaxSize
93325>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93326>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93327>>>>>>>>            Move 32672                                   to aColumnType[i].sPrecision
93328>>>>>>>>            Increment i
93329>>>>>>>>
93329>>>>>>>>            Move "vargraphic"                            to aColumnType[i].sSQLType
93330>>>>>>>>            Move -96                                     to aColumnType[i].iSQLType
93331>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93332>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93333>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93334>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93335>>>>>>>>            Move 16336                                   to aColumnType[i].nMaxSize
93336>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93337>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93338>>>>>>>>            Move 16336                                   to aColumnType[i].sPrecision
93339>>>>>>>>            Increment i
93340>>>>>>>>
93340>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
93341>>>>>>>>            Move -370                                    to aColumnType[i].iSQLType
93342>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93343>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93344>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
93345>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93346>>>>>>>>            Move 2147483647                              to aColumnType[i].nMaxSize
93347>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
93348>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
93349>>>>>>>>            Move 2147483647                              to aColumnType[i].sPrecision
93350>>>>>>>>            Increment i
93351>>>>>>>>
93351>>>>>>>>
93351>>>>>>>//        Move SQL_DBCLOB         to ColumnType[i].iSQLType
93351>>>>>>>//        Move "DBCLOB"           to ColumnType[i].sSQLType
93351>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
93351>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
93351>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
93351>>>>>>>//        Increment i
93351>>>>>>>//
93351>>>>>>>//        Move SQL_BIGINT         to ColumnType[i].iSQLType
93351>>>>>>>//        Move "BIGINT"           to ColumnType[i].sSQLType
93351>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
93351>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
93351>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
93351>>>>>>>//        Increment i
93351>>>>>>>//
93351>>>>>>>//        Move SQL_BLOB           to ColumnType[i].iSQLType
93351>>>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
93351>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
93351>>>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
93351>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
93351>>>>>>>//        Increment i
93351>>>>>>>//
93351>>>>>>>//        Move SQL_CHAR           to ColumnType[i].iSQLType
93351>>>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
93351>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
93351>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
93351>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
93351>>>>>>>//        Increment i
93351>>>>>>>//
93351>>>>>>>//        // ToDo: We need to change the sType when using this!
93351>>>>>>>//        Move SQL_CHARBIT            to ColumnType[i].iSQLType
93351>>>>>>>//        Move "CHAR FOR BIT DATA"    to ColumnType[i].sSQLType
93351>>>>>>>//        Move DF_BINARY              to ColumnType[i].iDataFlexType
93351>>>>>>>//        Move "Binary"               to ColumnType[i].sDataFlexType
93351>>>>>>>//        Move "254"                  to ColumnType[i].sPrecision
93351>>>>>>>//        Increment i
93351>>>>>>>//
93351>>>>>>>//        Move SQL_DATE           to ColumnType[i].iSQLType
93351>>>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
93351>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
93351>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
93351>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
93351>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
93351>>>>>>>//        Increment i
93351>>>>>>>//
93351>>>>>>>//        Move SQL_CLOB           to ColumnType[i].iSQLType
93351>>>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
93351>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
93351>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
93351>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
93351>>>>>>>//        Increment i
93351>>>>>>>//
93351>>>>>>>//        Move SQL_DECIMAL        to ColumnType[i].iSQLType
93351>>>>>>>//        Move "DECIMAL"          to ColumnType[i].sSQLType
93351>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
93351>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
93351>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
93351>>>>>>>//        Increment i
93351>>>>>>>//
93351>>>>>>>//        Move SQL_DOUBLE         to ColumnType[i].iSQLType
93351>>>>>>>//        Move "DOUBLE"           to ColumnType[i].sSQLType
93351>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
93351>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
93351>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
93351>>>>>>>//        Increment i
93351>>>>>>>//
93351>>>>>>>//        Move SQL_FLOAT          to ColumnType[i].iSQLType
93351>>>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
93351>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
93351>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
93351>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
93351>>>>>>>//        Increment i
93351>>>>>>>//
93351>>>>>>>//        Move SQL_GRAPHIC        to ColumnType[i].iSQLType
93351>>>>>>>//        Move "GRAPHIC"          to ColumnType[i].sSQLType
93351>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
93351>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
93351>>>>>>>//        Move "255"              to ColumnType[i].sPrecision
93351>>>>>>>//        Increment i
93351>>>>>>>//
93351>>>>>>>//        Move SQL_INTEGER        to ColumnType[i].iSQLType
93351>>>>>>>//        Move "INTEGER"          to ColumnType[i].sSQLType
93351>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
93351>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
93351>>>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
93351>>>>>>>//        Increment i
93351>>>>>>>//
93351>>>>>>>//        Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
93351>>>>>>>//        Move "LONG VARCHAR"     to ColumnType[i].sSQLType
93351>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
93351>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
93351>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
93351>>>>>>>//        Increment i
93351>>>>>>>//
93351>>>>>>>//        Move SQL_LONGVARCHARBIT to ColumnType[i].iSQLType
93351>>>>>>>//        Move "LONG VARCHAR BIT" to ColumnType[i].sSQLType
93351>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
93351>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
93351>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
93351>>>>>>>//        Increment i
93351>>>>>>>//
93351>>>>>>>//        Move SQL_LONGVARGRAPHIC to ColumnType[i].iSQLType
93351>>>>>>>//        Move "LONG VARGRAPHIC"  to ColumnType[i].sSQLType
93351>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
93351>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
93351>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
93351>>>>>>>//        Increment i
93351>>>>>>>//
93351>>>>>>>//        Move SQL_NUMERIC        to ColumnType[i].iSQLType
93351>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sSQLType
93351>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
93351>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
93351>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
93351>>>>>>>//        Increment i
93351>>>>>>>//
93351>>>>>>>//        Move SQL_REAL           to ColumnType[i].iSQLType
93351>>>>>>>//        Move "REAL"             to ColumnType[i].sSQLType
93351>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
93351>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
93351>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
93351>>>>>>>//        Increment i
93351>>>>>>>//
93351>>>>>>>//        Move SQL_SMALLINT       to ColumnType[i].iSQLType
93351>>>>>>>//        Move "SMALLINT"         to ColumnType[i].sSQLType
93351>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
93351>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
93351>>>>>>>//        Move "5.0"              to ColumnType[i].sPrecision
93351>>>>>>>//        Increment i
93351>>>>>>>//
93351>>>>>>>//        Move SQL_TIME           to ColumnType[i].iSQLType
93351>>>>>>>//        Move "TIME"             to ColumnType[i].sSQLType
93351>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
93351>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
93351>>>>>>>//        Move "19.0"             to ColumnType[i].sPrecision
93351>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
93351>>>>>>>//        Increment i
93351>>>>>>>//
93351>>>>>>>//        Move SQL_TIMESTAMP      to ColumnType[i].iSQLType
93351>>>>>>>//        Move "TIMESTAMP"        to ColumnType[i].sSQLType
93351>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
93351>>>>>>>//        Move "DATETIME"         to ColumnType[i].sDataFlexType
93351>>>>>>>//        Move "23.6"             to ColumnType[i].sPrecision
93351>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
93351>>>>>>>//        Increment i
93351>>>>>>>//
93351>>>>>>>//        Move SQL_VARCHAR        to ColumnType[i].iSQLType
93351>>>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
93351>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
93351>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
93351>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
93351>>>>>>>//        Increment i
93351>>>>>>>//
93351>>>>>>>//        // ToDo: We need to change the sType when using this!
93351>>>>>>>//        Move SQL_VARCHARBIT         to ColumnType[i].iSQLType
93351>>>>>>>//        Move "VARCHAR FOR BIT DATA" to ColumnType[i].sSQLType
93351>>>>>>>//        Move DF_TEXT                to ColumnType[i].iDataFlexType
93351>>>>>>>//        Move "TEXT"                 to ColumnType[i].sDataFlexType
93351>>>>>>>//        Move "16384"                to ColumnType[i].sPrecision
93351>>>>>>>//        Increment i
93351>>>>>>>//
93351>>>>>>>//        Move SQL_VARGRAPHIC     to ColumnType[i].iSQLType
93351>>>>>>>//        Move "VARGRAPHIC"       to ColumnType[i].sSQLType
93351>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
93351>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
93351>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
93351>>>>>>>//
93351>>>>>>>//        Move SQL_XML            to ColumnType[i].iSQLType
93351>>>>>>>//        Move "XML"              to ColumnType[i].sSQLType
93351>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
93351>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
93351>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
93351>>>>>>>
93351>>>>>>>        Function_Return aColumnType
93352>>>>>>>    End_Function
93353>>>>>>>
93353>>>>>>>    // Microsoft SQL Server Database Data Types:
93353>>>>>>>    // Helper function for UtilEnumerateColumnTypes
93353>>>>>>>    Function _UtilEnumerateMSSQLTypes String sDriverID Returns tColumnType[]
93355>>>>>>>        tColumnType[] aColumnType
93355>>>>>>>        tColumnType[] aColumnType
93356>>>>>>>        Integer i
93356>>>>>>>
93356>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
Including file: MSSQLDRV_DriverDef.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\MSSQLDRV_DriverDef.inc)
93358>>>>>>>>// Generated By The Database Update Framework
93358>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\bin\MSSQLDRV_DriverDef.xml
93358>>>>>>>>// Driver COLUMN DATA TYPES
93358>>>>>>>>//
93358>>>>>>>>// Created: 2018-03-15 00:00:57.024
93358>>>>>>>>
93358>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
93359>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
93360>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93361>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93362>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93363>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93364>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
93365>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93366>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93367>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
93368>>>>>>>>            Increment i
93369>>>>>>>>
93369>>>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
93370>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
93371>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93372>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93373>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93374>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93375>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
93376>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
93377>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
93378>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
93379>>>>>>>>            Increment i
93380>>>>>>>>
93380>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
93381>>>>>>>>            Move -7                                      to aColumnType[i].iSQLType
93382>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
93383>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93384>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
93385>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
93386>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
93387>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93388>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93389>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
93390>>>>>>>>            Increment i
93391>>>>>>>>
93391>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
93392>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
93393>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93394>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93395>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93396>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93397>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
93398>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93399>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93400>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
93401>>>>>>>>            Increment i
93402>>>>>>>>
93402>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
93403>>>>>>>>            Move 91                                      to aColumnType[i].iSQLType
93404>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
93405>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93406>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
93407>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
93408>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
93409>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
93410>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
93411>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
93412>>>>>>>>            Increment i
93413>>>>>>>>
93413>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
93414>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
93415>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
93416>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93417>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93418>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
93419>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
93420>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
93421>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
93422>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
93423>>>>>>>>            Increment i
93424>>>>>>>>
93424>>>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
93425>>>>>>>>            Move -200                                    to aColumnType[i].iSQLType
93426>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93427>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93428>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
93429>>>>>>>>            Move 23                                      to aColumnType[i].iMinSize
93430>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
93431>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
93432>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
93433>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
93434>>>>>>>>            Increment i
93435>>>>>>>>
93435>>>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
93436>>>>>>>>            Move -155                                    to aColumnType[i].iSQLType
93437>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93438>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93439>>>>>>>>            Move 34                                      to aColumnType[i].iDefaultSize
93440>>>>>>>>            Move 34                                      to aColumnType[i].iMinSize
93441>>>>>>>>            Move 34                                      to aColumnType[i].nMaxSize
93442>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
93443>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
93444>>>>>>>>            Move 34                                      to aColumnType[i].sPrecision
93445>>>>>>>>            Increment i
93446>>>>>>>>
93446>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
93447>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
93448>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93449>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93450>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93451>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93452>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
93453>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93454>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93455>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
93456>>>>>>>>            Increment i
93457>>>>>>>>
93457>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
93458>>>>>>>>            Move 6                                       to aColumnType[i].iSQLType
93459>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93460>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93461>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93462>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93463>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
93464>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93465>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93466>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
93467>>>>>>>>            Increment i
93468>>>>>>>>
93468>>>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
93469>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
93470>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93471>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93472>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
93473>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93474>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
93475>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
93476>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
93477>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
93478>>>>>>>>            Increment i
93479>>>>>>>>
93479>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
93480>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
93481>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93482>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93483>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
93484>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93485>>>>>>>>            Move 10                                      to aColumnType[i].nMaxSize
93486>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93487>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93488>>>>>>>>            Move 10                                      to aColumnType[i].sPrecision
93489>>>>>>>>            Increment i
93490>>>>>>>>
93490>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
93491>>>>>>>>            Move -204                                    to aColumnType[i].iSQLType
93492>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
93493>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93494>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
93495>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
93496>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
93497>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93498>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93499>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
93500>>>>>>>>            Increment i
93501>>>>>>>>
93501>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
93502>>>>>>>>            Move -8                                      to aColumnType[i].iSQLType
93503>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93504>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93505>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93506>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93507>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
93508>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93509>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93510>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
93511>>>>>>>>            Increment i
93512>>>>>>>>
93512>>>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
93513>>>>>>>>            Move -10                                     to aColumnType[i].iSQLType
93514>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93515>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93516>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
93517>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93518>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
93519>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
93520>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
93521>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
93522>>>>>>>>            Increment i
93523>>>>>>>>
93523>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
93524>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
93525>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93526>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93527>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93528>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93529>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
93530>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93531>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93532>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
93533>>>>>>>>            Increment i
93534>>>>>>>>
93534>>>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
93535>>>>>>>>            Move -9                                      to aColumnType[i].iSQLType
93536>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93537>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93538>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93539>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93540>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
93541>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93542>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93543>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
93544>>>>>>>>            Increment i
93545>>>>>>>>
93545>>>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
93546>>>>>>>>            Move -202                                    to aColumnType[i].iSQLType
93547>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93548>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93549>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
93550>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93551>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
93552>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93553>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93554>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
93555>>>>>>>>            Increment i
93556>>>>>>>>
93556>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
93557>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
93558>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93559>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93560>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93561>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93562>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
93563>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93564>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93565>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
93566>>>>>>>>            Increment i
93567>>>>>>>>
93567>>>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
93568>>>>>>>>            Move -206                                    to aColumnType[i].iSQLType
93569>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
93570>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93571>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
93572>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
93573>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
93574>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
93575>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
93576>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
93577>>>>>>>>            Increment i
93578>>>>>>>>
93578>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
93579>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
93580>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93581>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93582>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
93583>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93584>>>>>>>>            Move 5                                       to aColumnType[i].nMaxSize
93585>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93586>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93587>>>>>>>>            Move 5                                       to aColumnType[i].sPrecision
93588>>>>>>>>            Increment i
93589>>>>>>>>
93589>>>>>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
93590>>>>>>>>            Move -205                                    to aColumnType[i].iSQLType
93591>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
93592>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93593>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
93594>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
93595>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
93596>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93597>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93598>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
93599>>>>>>>>            Increment i
93600>>>>>>>>
93600>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
93601>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
93602>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93603>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93604>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
93605>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93606>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
93607>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
93608>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
93609>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
93610>>>>>>>>            Increment i
93611>>>>>>>>
93611>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
93612>>>>>>>>            Move -154                                    to aColumnType[i].iSQLType
93613>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93614>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93615>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
93616>>>>>>>>            Move 10                                      to aColumnType[i].iMinSize
93617>>>>>>>>            Move 19                                      to aColumnType[i].nMaxSize
93618>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93619>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93620>>>>>>>>            Move 19                                      to aColumnType[i].sPrecision
93621>>>>>>>>            Increment i
93622>>>>>>>>
93622>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
93623>>>>>>>>            Move -6                                      to aColumnType[i].iSQLType
93624>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93625>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93626>>>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
93627>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93628>>>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
93629>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93630>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93631>>>>>>>>            Move 3                                       to aColumnType[i].sPrecision
93632>>>>>>>>            Increment i
93633>>>>>>>>
93633>>>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
93634>>>>>>>>            Move -11                                     to aColumnType[i].iSQLType
93635>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
93636>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93637>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
93638>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
93639>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
93640>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93641>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93642>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
93643>>>>>>>>            Increment i
93644>>>>>>>>
93644>>>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
93645>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
93646>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93647>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93648>>>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
93649>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93650>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
93651>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
93652>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
93653>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
93654>>>>>>>>            Increment i
93655>>>>>>>>
93655>>>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
93656>>>>>>>>            Move -203                                    to aColumnType[i].iSQLType
93657>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93658>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93659>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
93660>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93661>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
93662>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93663>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93664>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
93665>>>>>>>>            Increment i
93666>>>>>>>>
93666>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
93667>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
93668>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93669>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93670>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93671>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93672>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
93673>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93674>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93675>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
93676>>>>>>>>            Increment i
93677>>>>>>>>
93677>>>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
93678>>>>>>>>            Move -201                                    to aColumnType[i].iSQLType
93679>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93680>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93681>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
93682>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93683>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
93684>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
93685>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
93686>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
93687>>>>>>>>            Increment i
93688>>>>>>>>
93688>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
93689>>>>>>>>            Move -152                                    to aColumnType[i].iSQLType
93690>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93691>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93692>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
93693>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93694>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
93695>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
93696>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
93697>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
93698>>>>>>>>            Increment i
93699>>>>>>>>
93699>>>>>>>>
93699>>>>>>>            
93699>>>>>>>//            Move SQL_BIGINT         to ColumnType[i].iSQLType
93699>>>>>>>//            Move "bigint"           to ColumnType[i].sSQLType
93699>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93699>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
93699>>>>>>>//            Move "14.0"             to ColumnType[i].sPrecision
93699>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
93699>>>>>>>//            Increment i
93699>>>>>>>//
93699>>>>>>>//            Move SQL_BINARY         to ColumnType[i].iSQLType
93699>>>>>>>//            Move "binary"           to ColumnType[i].sSQLType
93699>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
93699>>>>>>>//            Move "Binary"           to ColumnType[i].sDataFlexType
93699>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
93699>>>>>>>//            Increment i
93699>>>>>>>//
93699>>>>>>>//            Move SQL_BIT            to ColumnType[i].iSQLType
93699>>>>>>>//            Move "bit"              to ColumnType[i].sSQLType
93699>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
93699>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
93699>>>>>>>//            Move "1.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
93699>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
93699>>>>>>>//            Increment i
93699>>>>>>>//
93699>>>>>>>//            Move SQL_CHAR           to ColumnType[i].iSQLType
93699>>>>>>>//            Move "char"             to ColumnType[i].sSQLType
93699>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
93699>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
93699>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
93699>>>>>>>//            Increment i
93699>>>>>>>//
93699>>>>>>>//            Move SQL_DATE           to ColumnType[i].iSQLType
93699>>>>>>>//            Move "date"             to ColumnType[i].sSQLType
93699>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
93699>>>>>>>//            Move "Date"             to ColumnType[i].sDataFlexType
93699>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
93699>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
93699>>>>>>>//            Increment i
93699>>>>>>>//
93699>>>>>>>//            Move SQL_DATETIME       to ColumnType[i].iSQLType
93699>>>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
93699>>>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
93699>>>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
93699>>>>>>>//            Move "23.3"             to ColumnType[i].sPrecision
93699>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
93699>>>>>>>//            Increment i
93699>>>>>>>//
93699>>>>>>>//            Move SQL_TYPE_TIMESTAMP2 to ColumnType[i].iSQLType
93699>>>>>>>//            Move "datetime2"         to ColumnType[i].sSQLType
93699>>>>>>>//            Move DF_DATETIME         to ColumnType[i].iDataFlexType
93699>>>>>>>//            Move "DateTime"          to ColumnType[i].sDataFlexType
93699>>>>>>>//            Move "23.6"              to ColumnType[i].sPrecision
93699>>>>>>>//            Move True                to ColumnType[i].bCanEditSize
93699>>>>>>>//            Increment i
93699>>>>>>>//
93699>>>>>>>//            Move SQL_SS_TIMESTAMPOFFSET to ColumnType[i].iSQLType
93699>>>>>>>//            Move "datetimeoffset"       to ColumnType[i].sSQLType
93699>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
93699>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
93699>>>>>>>//            Move "34.0"                 to ColumnType[i].sPrecision
93699>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
93699>>>>>>>//            Increment i
93699>>>>>>>//
93699>>>>>>>//            Move SQL_DECIMAL        to ColumnType[i].iSQLType
93699>>>>>>>//            Move "decimal"          to ColumnType[i].sSQLType
93699>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93699>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
93699>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
93699>>>>>>>//            Increment i
93699>>>>>>>//
93699>>>>>>>//            Move SQL_FLOAT          to ColumnType[i].iSQLType
93699>>>>>>>//            Move "float"            to ColumnType[i].sSQLType
93699>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93699>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
93699>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
93699>>>>>>>//            Increment i
93699>>>>>>>//
93699>>>>>>>//            Move SQL_INTEGER        to ColumnType[i].iSQLType
93699>>>>>>>//            Move "int"              to ColumnType[i].sSQLType
93699>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93699>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
93699>>>>>>>//            Move "8.0"              to ColumnType[i].sPrecision
93699>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
93699>>>>>>>//            Increment i
93699>>>>>>>//
93699>>>>>>>//            Move SQL_TYPE_MONEY     to ColumnType[i].iSQLType
93699>>>>>>>//            Move "money"            to ColumnType[i].sSQLType
93699>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93699>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
93699>>>>>>>//            Move "15.4"             to ColumnType[i].sPrecision // Studio 18.0 (!)
93699>>>>>>>//            Increment i
93699>>>>>>>//
93699>>>>>>>//            Move SQL_WCHAR          to ColumnType[i].iSQLType
93699>>>>>>>//            Move "nchar"            to ColumnType[i].sSQLType
93699>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
93699>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
93699>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
93699>>>>>>>//            Increment i
93699>>>>>>>//
93699>>>>>>>//            Move SQL_WLONGVARCHAR   to ColumnType[i].iSQLType
93699>>>>>>>//            Move "ntext"            to ColumnType[i].sSQLType
93699>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
93699>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
93699>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
93699>>>>>>>//            Increment i
93699>>>>>>>//
93699>>>>>>>//            Move SQL_NUMERIC        to ColumnType[i].iSQLType
93699>>>>>>>//            Move "numeric"          to ColumnType[i].sSQLType
93699>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93699>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
93699>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
93699>>>>>>>//            Increment i
93699>>>>>>>//
93699>>>>>>>//            Move SQL_WVARCHAR       to ColumnType[i].iSQLType
93699>>>>>>>//            Move "nvarchar"         to ColumnType[i].sSQLType
93699>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
93699>>>>>>>//            Move "Text"             to ColumnType[i].sDataFlexType
93699>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
93699>>>>>>>//            Increment i
93699>>>>>>>//
93699>>>>>>>//            Move SQL_VARCHARMAX     to ColumnType[i].iSQLType
93699>>>>>>>//            Move "nvarchar(max)"    to ColumnType[i].sSQLType
93699>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
93699>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
93699>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
93699>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
93699>>>>>>>//            Increment i
93699>>>>>>>//
93699>>>>>>>//            Move SQL_REAL           to ColumnType[i].iSQLType
93699>>>>>>>//            Move "real"             to ColumnType[i].sSQLType
93699>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93699>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
93699>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
93699>>>>>>>//            Increment i
93699>>>>>>>//
93699>>>>>>>//            Move SQL_TYPE_SMALLDATETIME to ColumnType[i].iSQLType
93699>>>>>>>//            Move "smalldatetime"        to ColumnType[i].sSQLType
93699>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
93699>>>>>>>//            Move "DATETIME"             to ColumnType[i].sDataFlexType
93699>>>>>>>//            Move "23.0"                 to ColumnType[i].sPrecision
93699>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
93699>>>>>>>//            Increment i
93699>>>>>>>//
93699>>>>>>>//            Move SQL_SMALLINT       to ColumnType[i].iSQLType
93699>>>>>>>//            Move "smallint"         to ColumnType[i].sSQLType
93699>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93699>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
93699>>>>>>>//            Move "4.0"              to ColumnType[i].sPrecision
93699>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
93699>>>>>>>//            Increment i
93699>>>>>>>//
93699>>>>>>>//            Move SQL_TYPE_SMALLMONEY to ColumnType[i].iSQLType
93699>>>>>>>//            Move "smallmoney"        to ColumnType[i].sSQLType
93699>>>>>>>//            Move DF_BCD              to ColumnType[i].iDataFlexType
93699>>>>>>>//            Move "NUMERIC"           to ColumnType[i].sDataFlexType
93699>>>>>>>//            Move "10.0"              to ColumnType[i].sPrecision
93699>>>>>>>//            Increment i
93699>>>>>>>//
93699>>>>>>>//            Move SQL_TEXT           to ColumnType[i].iSQLType
93699>>>>>>>//            Move "text"             to ColumnType[i].sSQLType
93699>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
93699>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
93699>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
93699>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
93699>>>>>>>//            Increment i
93699>>>>>>>//
93699>>>>>>>//            Move SQL_TIME           to ColumnType[i].iSQLType
93699>>>>>>>//            Move "time"             to ColumnType[i].sSQLType
93699>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
93699>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
93699>>>>>>>//            Move "19.0"             to ColumnType[i].sPrecision
93699>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
93699>>>>>>>//            Increment i
93699>>>>>>>//
93699>>>>>>>//            Move SQL_TINYINT        to ColumnType[i].iSQLType
93699>>>>>>>//            Move "tinyint"          to ColumnType[i].sSQLType
93699>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93699>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
93699>>>>>>>//            Move "2.0"              to ColumnType[i].sPrecision
93699>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
93699>>>>>>>//            Increment i
93699>>>>>>>//
93699>>>>>>>//            Move SQL_GUID           to ColumnType[i].iSQLType
93699>>>>>>>//            Move "uniqueidentifier" to ColumnType[i].sSQLType
93699>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
93699>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
93699>>>>>>>//            Move "36"               to ColumnType[i].sPrecision
93699>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
93699>>>>>>>//            Increment i
93699>>>>>>>//
93699>>>>>>>//            Move SQL_VARBINARY      to ColumnType[i].iSQLType
93699>>>>>>>//            Move "varbinary"        to ColumnType[i].sSQLType
93699>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
93699>>>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
93699>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
93699>>>>>>>//            Increment i
93699>>>>>>>//
93699>>>>>>>//            Move SQL_LONGVARBINARY  to ColumnType[i].iSQLType
93699>>>>>>>//            Move "varbinary(max)"   to ColumnType[i].sSQLType
93699>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
93699>>>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
93699>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
93699>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
93699>>>>>>>//            Increment i
93699>>>>>>>//
93699>>>>>>>//            Move SQL_VARCHAR        to ColumnType[i].iSQLType
93699>>>>>>>//            Move "varchar"          to ColumnType[i].sSQLType
93699>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
93699>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
93699>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
93699>>>>>>>//            Increment i
93699>>>>>>>//
93699>>>>>>>//            Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
93699>>>>>>>//            Move "varchar(max)"     to ColumnType[i].sSQLType
93699>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
93699>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
93699>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
93699>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
93699>>>>>>>//            Increment i
93699>>>>>>>//
93699>>>>>>>//            Move SQL_SS_XML         to ColumnType[i].iSQLType
93699>>>>>>>//            Move "xml"              to ColumnType[i].sSQLType
93699>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
93699>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
93699>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
93699>>>>>>>//            Increment i
93699>>>>>>>//
93699>>>>>>>//            Move SQL_TYPE_DATE      to ColumnType[i].iSQLType
93699>>>>>>>//            Move "DATE"             to ColumnType[i].sSQLType
93699>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
93699>>>>>>>//            Move "date"             to ColumnType[i].sDataFlexType
93699>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
93699>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
93699>>>>>>>//            Increment i
93699>>>>>>>//
93699>>>>>>>//            Move SQL_TYPE_TIME      to ColumnType[i].iSQLType
93699>>>>>>>//            Move "time"             to ColumnType[i].sSQLType
93699>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
93699>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
93699>>>>>>>//            Move "8.7"              to ColumnType[i].sPrecision
93699>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
93699>>>>>>>//            Increment i
93699>>>>>>>//
93699>>>>>>>//            Move SQL_TYPE_TIMESTAMP to ColumnType[i].iSQLType
93699>>>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
93699>>>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
93699>>>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
93699>>>>>>>//            Move "23.6"             to ColumnType[i].sPrecision
93699>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
93699>>>>>>>//            Increment i
93699>>>>>>>
93699>>>>>>>        End
93699>>>>>>>>
93699>>>>>>>
93699>>>>>>>        // Mertech SQLFlex driver
93699>>>>>>>        If (sDriverID = SQLFLEX) Begin
93701>>>>>>>
Including file: sql_drv_DriverDef.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\sql_drv_DriverDef.inc)
93701>>>>>>>>// Generated By The Database Update Framework
93701>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\sql_drv_DriverDef.xml
93701>>>>>>>>// Driver COLUMN DATA TYPES
93701>>>>>>>>//
93701>>>>>>>>// Created: 2018-03-14 23:47:46.885
93701>>>>>>>>
93701>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
93702>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
93703>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93704>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93705>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93706>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93707>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
93708>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93709>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93710>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
93711>>>>>>>>            Increment i
93712>>>>>>>>
93712>>>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
93713>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
93714>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93715>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93716>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93717>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93718>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
93719>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
93720>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
93721>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
93722>>>>>>>>            Increment i
93723>>>>>>>>
93723>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
93724>>>>>>>>            Move -7                                      to aColumnType[i].iSQLType
93725>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
93726>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93727>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
93728>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
93729>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
93730>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93731>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93732>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
93733>>>>>>>>            Increment i
93734>>>>>>>>
93734>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
93735>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
93736>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93737>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93738>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93739>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93740>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
93741>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93742>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93743>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
93744>>>>>>>>            Increment i
93745>>>>>>>>
93745>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
93746>>>>>>>>            Move 40                                      to aColumnType[i].iSQLType
93747>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
93748>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93749>>>>>>>>            Move 12                                      to aColumnType[i].iDefaultSize
93750>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
93751>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
93752>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93753>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93754>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
93755>>>>>>>>            Increment i
93756>>>>>>>>
93756>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
93757>>>>>>>>            Move 11                                      to aColumnType[i].iSQLType
93758>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93759>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93760>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
93761>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
93762>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
93763>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93764>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93765>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
93766>>>>>>>>            Increment i
93767>>>>>>>>
93767>>>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
93768>>>>>>>>            Move 42                                      to aColumnType[i].iSQLType
93769>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93770>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93771>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
93772>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
93773>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
93774>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93775>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93776>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
93777>>>>>>>>            Increment i
93778>>>>>>>>
93778>>>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
93779>>>>>>>>            Move 43                                      to aColumnType[i].iSQLType
93780>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93781>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93782>>>>>>>>            Move 12                                      to aColumnType[i].iDefaultSize
93783>>>>>>>>            Move 12                                      to aColumnType[i].iMinSize
93784>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
93785>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93786>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93787>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
93788>>>>>>>>            Increment i
93789>>>>>>>>
93789>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
93790>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
93791>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93792>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93793>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93794>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93795>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
93796>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93797>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93798>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
93799>>>>>>>>            Increment i
93800>>>>>>>>
93800>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
93801>>>>>>>>            Move 6                                       to aColumnType[i].iSQLType
93802>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93803>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93804>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93805>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93806>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
93807>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93808>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93809>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
93810>>>>>>>>            Increment i
93811>>>>>>>>
93811>>>>>>>>            Move "geography"                             to aColumnType[i].sSQLType
93812>>>>>>>>            Move 130                                     to aColumnType[i].iSQLType
93813>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
93814>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93815>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93816>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
93817>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
93818>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93819>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93820>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
93821>>>>>>>>            Increment i
93822>>>>>>>>
93822>>>>>>>>            Move "geometry"                              to aColumnType[i].sSQLType
93823>>>>>>>>            Move 129                                     to aColumnType[i].iSQLType
93824>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
93825>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93826>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93827>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
93828>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
93829>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93830>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93831>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
93832>>>>>>>>            Increment i
93833>>>>>>>>
93833>>>>>>>>            Move "hierarchyid"                           to aColumnType[i].sSQLType
93834>>>>>>>>            Move 128                                     to aColumnType[i].iSQLType
93835>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
93836>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93837>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93838>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
93839>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
93840>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93841>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93842>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
93843>>>>>>>>            Increment i
93844>>>>>>>>
93844>>>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
93845>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
93846>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93847>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93848>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93849>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93850>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93851>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
93852>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
93853>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
93854>>>>>>>>            Increment i
93855>>>>>>>>
93855>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
93856>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
93857>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93858>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93859>>>>>>>>            Move 11                                      to aColumnType[i].iDefaultSize
93860>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93861>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
93862>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93863>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93864>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
93865>>>>>>>>            Increment i
93866>>>>>>>>
93866>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
93867>>>>>>>>            Move -8                                      to aColumnType[i].iSQLType
93868>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93869>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93870>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93871>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93872>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
93873>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93874>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93875>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
93876>>>>>>>>            Increment i
93877>>>>>>>>
93877>>>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
93878>>>>>>>>            Move -10                                     to aColumnType[i].iSQLType
93879>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93880>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93881>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93882>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93883>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93884>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
93885>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
93886>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
93887>>>>>>>>            Increment i
93888>>>>>>>>
93888>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
93889>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
93890>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93891>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93892>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93893>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93894>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
93895>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93896>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93897>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
93898>>>>>>>>            Increment i
93899>>>>>>>>
93899>>>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
93900>>>>>>>>            Move -9                                      to aColumnType[i].iSQLType
93901>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93902>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93903>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
93904>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93905>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
93906>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93907>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93908>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
93909>>>>>>>>            Increment i
93910>>>>>>>>
93910>>>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
93911>>>>>>>>            Move -100                                    to aColumnType[i].iSQLType
93912>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93913>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93914>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93915>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93916>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93917>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93918>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93919>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
93920>>>>>>>>            Increment i
93921>>>>>>>>
93921>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
93922>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
93923>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93924>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93925>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93926>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93927>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
93928>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93929>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93930>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
93931>>>>>>>>            Increment i
93932>>>>>>>>
93932>>>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
93933>>>>>>>>            Move 58                                      to aColumnType[i].iSQLType
93934>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93935>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93936>>>>>>>>            Move 12                                      to aColumnType[i].iDefaultSize
93937>>>>>>>>            Move 12                                      to aColumnType[i].iMinSize
93938>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
93939>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93940>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93941>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
93942>>>>>>>>            Increment i
93943>>>>>>>>
93943>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
93944>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
93945>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93946>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93947>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
93948>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
93949>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
93950>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93951>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93952>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
93953>>>>>>>>            Increment i
93954>>>>>>>>
93954>>>>>>>>            Move "sql_variant"                           to aColumnType[i].sSQLType
93955>>>>>>>>            Move -150                                    to aColumnType[i].iSQLType
93956>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
93957>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93958>>>>>>>>            Move 8016                                    to aColumnType[i].iDefaultSize
93959>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
93960>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
93961>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93962>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93963>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
93964>>>>>>>>            Increment i
93965>>>>>>>>
93965>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
93966>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
93967>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93968>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93969>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93970>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93971>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93972>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
93973>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
93974>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
93975>>>>>>>>            Increment i
93976>>>>>>>>
93976>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
93977>>>>>>>>            Move 41                                      to aColumnType[i].iSQLType
93978>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93979>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93980>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
93981>>>>>>>>            Move 8                                       to aColumnType[i].iMinSize
93982>>>>>>>>            Move 16                                      to aColumnType[i].nMaxSize
93983>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93984>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93985>>>>>>>>            Move 16                                      to aColumnType[i].sPrecision
93986>>>>>>>>            Increment i
93987>>>>>>>>
93987>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
93988>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
93989>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
93990>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93991>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
93992>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
93993>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
93994>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
93995>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
93996>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
93997>>>>>>>>            Increment i
93998>>>>>>>>
93998>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
93999>>>>>>>>            Move -6                                      to aColumnType[i].iSQLType
94000>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94001>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94002>>>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
94003>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
94004>>>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
94005>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
94006>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
94007>>>>>>>>            Move 3                                       to aColumnType[i].sPrecision
94008>>>>>>>>            Increment i
94009>>>>>>>>
94009>>>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
94010>>>>>>>>            Move -11                                     to aColumnType[i].iSQLType
94011>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
94012>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94013>>>>>>>>            Move 38                                      to aColumnType[i].iDefaultSize
94014>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
94015>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
94016>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94017>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94018>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
94019>>>>>>>>            Increment i
94020>>>>>>>>
94020>>>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
94021>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
94022>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94023>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94024>>>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
94025>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94026>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
94027>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
94028>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
94029>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
94030>>>>>>>>            Increment i
94031>>>>>>>>
94031>>>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
94032>>>>>>>>            Move -98                                     to aColumnType[i].iSQLType
94033>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94034>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94035>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
94036>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94037>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94038>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94039>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94040>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
94041>>>>>>>>            Increment i
94042>>>>>>>>
94042>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
94043>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
94044>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94045>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94046>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94047>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94048>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
94049>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94050>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94051>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
94052>>>>>>>>            Increment i
94053>>>>>>>>
94053>>>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
94054>>>>>>>>            Move -99                                     to aColumnType[i].iSQLType
94055>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94056>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94057>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
94058>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94059>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94060>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94061>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94062>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
94063>>>>>>>>            Increment i
94064>>>>>>>>
94064>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
94065>>>>>>>>            Move -370                                    to aColumnType[i].iSQLType
94066>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94067>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94068>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
94069>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94070>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94071>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94072>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94073>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
94074>>>>>>>>            Increment i
94075>>>>>>>>
94075>>>>>>>>
94075>>>>>>>            
94075>>>>>>>//            Move eSQLServer_BIGINT  to ColumnType[i].iSQLType
94075>>>>>>>//            Move "BigInt"           to ColumnType[i].sSQLType
94075>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
94075>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
94075>>>>>>>//            Move "14.0"             to ColumnType[i].sPrecision
94075>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
94075>>>>>>>//            Increment i
94075>>>>>>>//
94075>>>>>>>//            Move eSQLServer_BINARY  to ColumnType[i].iSQLType
94075>>>>>>>//            Move "Binary"           to ColumnType[i].sSQLType
94075>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
94075>>>>>>>//            Move "Binary"           to ColumnType[i].sDataFlexType
94075>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
94075>>>>>>>//            Increment i
94075>>>>>>>//
94075>>>>>>>//            Move eSQLServer_BIT     to ColumnType[i].iSQLType
94075>>>>>>>//            Move "Bit"              to ColumnType[i].sSQLType
94075>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
94075>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
94075>>>>>>>//            Move "1.0"              to ColumnType[i].sPrecision
94075>>>>>>>//            Move True               to ColumnType[i].bCanEditSize // In SQL allows 1, 0, or "NULL"
94075>>>>>>>//            Increment i
94075>>>>>>>//
94075>>>>>>>//            Move eSQLServer_CHAR    to ColumnType[i].iSQLType
94075>>>>>>>//            Move "Char"             to ColumnType[i].sSQLType
94075>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
94075>>>>>>>//            Move "Text"             to ColumnType[i].sDataFlexType
94075>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
94075>>>>>>>//            Increment i
94075>>>>>>>//
94075>>>>>>>//            Move eSQLServer_DATE    to ColumnType[i].iSQLType
94075>>>>>>>//            Move "Date"             to ColumnType[i].sSQLType
94075>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
94075>>>>>>>//            Move "Date"             to ColumnType[i].sDataFlexType
94075>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
94075>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
94075>>>>>>>//            Increment i
94075>>>>>>>//
94075>>>>>>>//            Move eSQLServer_DATETIME    to ColumnType[i].iSQLType
94075>>>>>>>//            Move "DateTime"             to ColumnType[i].sSQLType
94075>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
94075>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
94075>>>>>>>//            Move "23.3"                 to ColumnType[i].sPrecision
94075>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
94075>>>>>>>//            Increment i
94075>>>>>>>//
94075>>>>>>>//            Move eSQLServer_DATETIME2   to ColumnType[i].iSQLType
94075>>>>>>>//            Move "DateTime2"            to ColumnType[i].sSQLType
94075>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
94075>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
94075>>>>>>>//            Move "23.6"                 to ColumnType[i].sPrecision
94075>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
94075>>>>>>>//            Increment i
94075>>>>>>>//
94075>>>>>>>//            Move eSQLServer_DATETIMEOFFSET  to ColumnType[i].iSQLType
94075>>>>>>>//            Move "DateTimeOffest"           to ColumnType[i].sSQLType
94075>>>>>>>//            Move DF_DATETIME                to ColumnType[i].iDataFlexType
94075>>>>>>>//            Move "DateTime"                 to ColumnType[i].sDataFlexType
94075>>>>>>>//            Move "23.0"                     to ColumnType[i].sPrecision
94075>>>>>>>//            Move True                       to ColumnType[i].bCanEditSize
94075>>>>>>>//            Increment i
94075>>>>>>>//
94075>>>>>>>//            Move eSQLServer_DECIMAL to ColumnType[i].iSQLType
94075>>>>>>>//            Move "Decimal"          to ColumnType[i].sSQLType
94075>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
94075>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
94075>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
94075>>>>>>>//            Increment i
94075>>>>>>>//
94075>>>>>>>//            Move eSQLServer_DOUBLE  to ColumnType[i].iSQLType
94075>>>>>>>//            Move "Double"           to ColumnType[i].sSQLType
94075>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
94075>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
94075>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
94075>>>>>>>//            Increment i
94075>>>>>>>//
94075>>>>>>>//            Move eSQLServer_FLOAT   to ColumnType[i].iSQLType
94075>>>>>>>//            Move "Float"            to ColumnType[i].sSQLType
94075>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
94075>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
94075>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
94075>>>>>>>//            Increment i
94075>>>>>>>//
94075>>>>>>>//            Move eSQLServer_INT     to ColumnType[i].iSQLType
94075>>>>>>>//            Move "Int"              to ColumnType[i].sSQLType
94075>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
94075>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
94075>>>>>>>//            Move "11.0"             to ColumnType[i].sPrecision
94075>>>>>>>//            Increment i
94075>>>>>>>//
94075>>>>>>>//            Move eSQLServer_NCHAR   to ColumnType[i].iSQLType
94075>>>>>>>//            Move "Nchar"            to ColumnType[i].sSQLType
94075>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
94075>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
94075>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
94075>>>>>>>//            Increment i
94075>>>>>>>//
94075>>>>>>>//            Move eSQLServer_NTEXT   to ColumnType[i].iSQLType
94075>>>>>>>//            Move "Ntext"            to ColumnType[i].sSQLType
94075>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
94075>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
94075>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
94075>>>>>>>//            Increment i
94075>>>>>>>//
94075>>>>>>>//            Move eSQLServer_NUMERIC to ColumnType[i].iSQLType
94075>>>>>>>//            Move "Numeric"          to ColumnType[i].sSQLType
94075>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
94075>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
94075>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
94075>>>>>>>//            Increment i
94075>>>>>>>//
94075>>>>>>>//            Move eSQLServer_NVARCHAR    to ColumnType[i].iSQLType
94075>>>>>>>//            Move "NvarChar"             to ColumnType[i].sSQLType
94075>>>>>>>//            Move DF_TEXT                to ColumnType[i].iDataFlexType
94075>>>>>>>//            Move "Text"                 to ColumnType[i].sDataFlexType
94075>>>>>>>//            Move "4000"                 to ColumnType[i].sPrecision
94075>>>>>>>//            Increment i
94075>>>>>>>//
94075>>>>>>>//            Move eSQLServer_NVARCHARMAX to ColumnType[i].iSQLType
94075>>>>>>>//            Move "NvarCharMax"          to ColumnType[i].sSQLType
94075>>>>>>>//            Move DF_TEXT                to ColumnType[i].iDataFlexType
94075>>>>>>>//            Move "Text"                 to ColumnType[i].sDataFlexType
94075>>>>>>>//            Move "16384"                to ColumnType[i].sPrecision
94075>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
94075>>>>>>>//            Increment i
94075>>>>>>>//
94075>>>>>>>//            Move eSQLServer_REAL    to ColumnType[i].iSQLType
94075>>>>>>>//            Move "Real"             to ColumnType[i].sSQLType
94075>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
94075>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
94075>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
94075>>>>>>>//            Increment i
94075>>>>>>>//
94075>>>>>>>//            Move eSQLServer_SMALLDATETIME   to ColumnType[i].iSQLType
94075>>>>>>>//            Move "SmallDateTime"            to ColumnType[i].sSQLType
94075>>>>>>>//            Move DF_DATETIME                to ColumnType[i].iDataFlexType
94075>>>>>>>//            Move "DATETIME"                 to ColumnType[i].sDataFlexType
94075>>>>>>>//            Move "23.0"                     to ColumnType[i].sPrecision
94075>>>>>>>//            Move True                       to ColumnType[i].bCanEditSize
94075>>>>>>>//            Increment i
94075>>>>>>>//
94075>>>>>>>//            Move eSQLServer_SMALLINT    to ColumnType[i].iSQLType
94075>>>>>>>//            Move "SmallInt"             to ColumnType[i].sSQLType
94075>>>>>>>//            Move DF_BCD                 to ColumnType[i].iDataFlexType
94075>>>>>>>//            Move "NUMERIC"              to ColumnType[i].sDataFlexType
94075>>>>>>>//            Move "6.0"                  to ColumnType[i].sPrecision
94075>>>>>>>//            Increment i
94075>>>>>>>//
94075>>>>>>>//            Move eSQLServer_TEXT    to ColumnType[i].iSQLType
94075>>>>>>>//            Move "Text"             to ColumnType[i].sSQLType
94075>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
94075>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
94075>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
94075>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
94075>>>>>>>//            Increment i
94075>>>>>>>//
94075>>>>>>>//            Move eSQLServer_TIME    to ColumnType[i].iSQLType
94075>>>>>>>//            Move "Time"             to ColumnType[i].sSQLType
94075>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
94075>>>>>>>//            Move "Date"             to ColumnType[i].sDataFlexType
94075>>>>>>>//            Move "16.0"             to ColumnType[i].sPrecision
94075>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
94075>>>>>>>//            Increment i
94075>>>>>>>//
94075>>>>>>>//            Move eSQLServer_TIMESTAMP   to ColumnType[i].iSQLType
94075>>>>>>>//            Move "TimeStamp"            to ColumnType[i].sSQLType
94075>>>>>>>//            Move DF_ASCII               to ColumnType[i].iDataFlexType
94075>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
94075>>>>>>>//            Move "8.0"                  to ColumnType[i].sPrecision
94075>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
94075>>>>>>>//            Increment i
94075>>>>>>>//
94075>>>>>>>//            Move eSQLServer_TINYINT to ColumnType[i].iSQLType
94075>>>>>>>//            Move "TinyInt"          to ColumnType[i].sSQLType
94075>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
94075>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
94075>>>>>>>//            Move "3.0"              to ColumnType[i].sPrecision
94075>>>>>>>//            Increment i
94075>>>>>>>//
94075>>>>>>>//            Move eSQLServer_GUID    to ColumnType[i].iSQLType
94075>>>>>>>//            Move "UniqueIdentifier" to ColumnType[i].sSQLType
94075>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
94075>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
94075>>>>>>>//            Move "38"               to ColumnType[i].sPrecision
94075>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
94075>>>>>>>//            Increment i
94075>>>>>>>//
94075>>>>>>>//            Move eSQLServer_VARBINARY   to ColumnType[i].iSQLType
94075>>>>>>>//            Move "VarBinary"            to ColumnType[i].sSQLType
94075>>>>>>>//            Move DF_BINARY              to ColumnType[i].iDataFlexType
94075>>>>>>>//            Move "BINARY"               to ColumnType[i].sDataFlexType
94075>>>>>>>//            Move "8000"                 to ColumnType[i].sPrecision
94075>>>>>>>//            Increment i
94075>>>>>>>//
94075>>>>>>>//            Move eSQLServer_VARBINARYMAX to ColumnType[i].iSQLType
94075>>>>>>>//            Move "VarBinary(Max)"        to ColumnType[i].sSQLType
94075>>>>>>>//            Move DF_BINARY               to ColumnType[i].iDataFlexType
94075>>>>>>>//            Move "BINARY"                to ColumnType[i].sDataFlexType
94075>>>>>>>//            Move "16384"                 to ColumnType[i].sPrecision
94075>>>>>>>//            Move True                    to ColumnType[i].bCanEditSize
94075>>>>>>>//            Increment i
94075>>>>>>>//
94075>>>>>>>//            Move eSQLServer_VARCHAR to ColumnType[i].iSQLType
94075>>>>>>>//            Move "VarChar"          to ColumnType[i].sSQLType
94075>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
94075>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
94075>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
94075>>>>>>>//            Increment i
94075>>>>>>>//
94075>>>>>>>//            Move eSQLServer_VARCHARMAX  to ColumnType[i].iSQLType
94075>>>>>>>//            Move "VarChar(Max)"         to ColumnType[i].sSQLType
94075>>>>>>>//            Move DF_TEXT                to ColumnType[i].iDataFlexType
94075>>>>>>>//            Move "TEXT"                 to ColumnType[i].sDataFlexType
94075>>>>>>>//            Move "16384"                to ColumnType[i].sPrecision
94075>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
94075>>>>>>>//            Increment i
94075>>>>>>>//
94075>>>>>>>//            Move eSQLServer_SQLVARIANT  to ColumnType[i].iSQLType
94075>>>>>>>//            Move "SQL_Variant"          to ColumnType[i].sSQLType
94075>>>>>>>//            Move DF_BINARY              to ColumnType[i].iDataFlexType
94075>>>>>>>//            Move "Binary"               to ColumnType[i].sDataFlexType
94075>>>>>>>//            Move "8016"                 to ColumnType[i].sPrecision
94075>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
94075>>>>>>>//            Increment i
94075>>>>>>>//
94075>>>>>>>//            Move eSQLServer_XML     to ColumnType[i].iSQLType
94075>>>>>>>//            Move "XML"              to ColumnType[i].sSQLType
94075>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
94075>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
94075>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
94075>>>>>>>        End
94075>>>>>>>>
94075>>>>>>>
94075>>>>>>>        Function_Return aColumnType
94076>>>>>>>    End_Function
94077>>>>>>>
94077>>>>>>>    // MySQL Data Types
94077>>>>>>>    Function _UtilEnumerateMySQLTypes Returns tColumnType[]
94079>>>>>>>        tColumnType[] aColumnType
94079>>>>>>>        tColumnType[] aColumnType
94080>>>>>>>        Integer i
94080>>>>>>>        
Including file: mdsmysql_DriverDef.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\mdsmysql_DriverDef.inc)
94080>>>>>>>>// Generated By The Database Update Framework
94080>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdsmysql_DriverDef.xml
94080>>>>>>>>// Driver COLUMN DATA TYPES
94080>>>>>>>>//
94080>>>>>>>>// Created: 2018-03-14 23:46:49.593
94080>>>>>>>>
94080>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
94081>>>>>>>>            Move 8                                       to aColumnType[i].iSQLType
94082>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94083>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94084>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
94085>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94086>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
94087>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
94088>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
94089>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
94090>>>>>>>>            Increment i
94091>>>>>>>>
94091>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
94092>>>>>>>>            Move 16                                      to aColumnType[i].iSQLType
94093>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94094>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94095>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
94096>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
94097>>>>>>>>            Move 64                                      to aColumnType[i].nMaxSize
94098>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94099>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94100>>>>>>>>            Move 64                                      to aColumnType[i].sPrecision
94101>>>>>>>>            Increment i
94102>>>>>>>>
94102>>>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
94103>>>>>>>>            Move 252                                     to aColumnType[i].iSQLType
94104>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94105>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94106>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
94107>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94108>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94109>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
94110>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
94111>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
94112>>>>>>>>            Increment i
94113>>>>>>>>
94113>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
94114>>>>>>>>            Move 254                                     to aColumnType[i].iSQLType
94115>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94116>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94117>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94118>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94119>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
94120>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94121>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94122>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
94123>>>>>>>>            Increment i
94124>>>>>>>>
94124>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
94125>>>>>>>>            Move 10                                      to aColumnType[i].iSQLType
94126>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
94127>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94128>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
94129>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
94130>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
94131>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
94132>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
94133>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
94134>>>>>>>>            Increment i
94135>>>>>>>>
94135>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
94136>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
94137>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94138>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94139>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
94140>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
94141>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
94142>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
94143>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
94144>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
94145>>>>>>>>            Increment i
94146>>>>>>>>
94146>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
94147>>>>>>>>            Move 246                                     to aColumnType[i].iSQLType
94148>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94149>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94150>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
94151>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
94152>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
94153>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94154>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94155>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
94156>>>>>>>>            Increment i
94157>>>>>>>>
94157>>>>>>>>            Move "decimal-MySQL4"                        to aColumnType[i].sSQLType
94158>>>>>>>>            Move 0                                       to aColumnType[i].iSQLType
94159>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94160>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94161>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
94162>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
94163>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
94164>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
94165>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
94166>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
94167>>>>>>>>            Increment i
94168>>>>>>>>
94168>>>>>>>>            Move "double"                                to aColumnType[i].sSQLType
94169>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
94170>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94171>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94172>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
94173>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
94174>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
94175>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
94176>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
94177>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
94178>>>>>>>>            Increment i
94179>>>>>>>>
94179>>>>>>>>            Move "enum"                                  to aColumnType[i].sSQLType
94180>>>>>>>>            Move 247                                     to aColumnType[i].iSQLType
94181>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94182>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94183>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
94184>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
94185>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
94186>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94187>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94188>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
94189>>>>>>>>            Increment i
94190>>>>>>>>
94190>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
94191>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
94192>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94193>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94194>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
94195>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
94196>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
94197>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
94198>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
94199>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
94200>>>>>>>>            Increment i
94201>>>>>>>>
94201>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
94202>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
94203>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94204>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94205>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
94206>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
94207>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
94208>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
94209>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
94210>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
94211>>>>>>>>            Increment i
94212>>>>>>>>
94212>>>>>>>>            Move "longblob"                              to aColumnType[i].sSQLType
94213>>>>>>>>            Move 251                                     to aColumnType[i].iSQLType
94214>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94215>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94216>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
94217>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94218>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94219>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
94220>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
94221>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
94222>>>>>>>>            Increment i
94223>>>>>>>>
94223>>>>>>>>            Move "longtext"                              to aColumnType[i].sSQLType
94224>>>>>>>>            Move -251                                    to aColumnType[i].iSQLType
94225>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94226>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94227>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
94228>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94229>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94230>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
94231>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
94232>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
94233>>>>>>>>            Increment i
94234>>>>>>>>
94234>>>>>>>>            Move "mediumblob"                            to aColumnType[i].sSQLType
94235>>>>>>>>            Move 250                                     to aColumnType[i].iSQLType
94236>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94237>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94238>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
94239>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94240>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94241>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
94242>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
94243>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
94244>>>>>>>>            Increment i
94245>>>>>>>>
94245>>>>>>>>            Move "mediumint"                             to aColumnType[i].sSQLType
94246>>>>>>>>            Move 9                                       to aColumnType[i].iSQLType
94247>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94248>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94249>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
94250>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94251>>>>>>>>            Move 9                                       to aColumnType[i].nMaxSize
94252>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
94253>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
94254>>>>>>>>            Move 9                                       to aColumnType[i].sPrecision
94255>>>>>>>>            Increment i
94256>>>>>>>>
94256>>>>>>>>            Move "mediumtext"                            to aColumnType[i].sSQLType
94257>>>>>>>>            Move -250                                    to aColumnType[i].iSQLType
94258>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94259>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94260>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
94261>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94262>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94263>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
94264>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
94265>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
94266>>>>>>>>            Increment i
94267>>>>>>>>
94267>>>>>>>>            Move "set"                                   to aColumnType[i].sSQLType
94268>>>>>>>>            Move 248                                     to aColumnType[i].iSQLType
94269>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94270>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94271>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
94272>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
94273>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
94274>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94275>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94276>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
94277>>>>>>>>            Increment i
94278>>>>>>>>
94278>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
94279>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
94280>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94281>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94282>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
94283>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94284>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
94285>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
94286>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
94287>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
94288>>>>>>>>            Increment i
94289>>>>>>>>
94289>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
94290>>>>>>>>            Move -252                                    to aColumnType[i].iSQLType
94291>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94292>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94293>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
94294>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94295>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94296>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
94297>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
94298>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
94299>>>>>>>>            Increment i
94300>>>>>>>>
94300>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
94301>>>>>>>>            Move 11                                      to aColumnType[i].iSQLType
94302>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
94303>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94304>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
94305>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
94306>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
94307>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94308>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94309>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
94310>>>>>>>>            Increment i
94311>>>>>>>>
94311>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
94312>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
94313>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94314>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94315>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
94316>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
94317>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
94318>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
94319>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
94320>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
94321>>>>>>>>            Increment i
94322>>>>>>>>
94322>>>>>>>>            Move "tinyblob"                              to aColumnType[i].sSQLType
94323>>>>>>>>            Move 249                                     to aColumnType[i].iSQLType
94324>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94325>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94326>>>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
94327>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94328>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
94329>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
94330>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
94331>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
94332>>>>>>>>            Increment i
94333>>>>>>>>
94333>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
94334>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
94335>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94336>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94337>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
94338>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94339>>>>>>>>            Move 4                                       to aColumnType[i].nMaxSize
94340>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
94341>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
94342>>>>>>>>            Move 4                                       to aColumnType[i].sPrecision
94343>>>>>>>>            Increment i
94344>>>>>>>>
94344>>>>>>>>            Move "tinytext"                              to aColumnType[i].sSQLType
94345>>>>>>>>            Move -249                                    to aColumnType[i].iSQLType
94346>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94347>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94348>>>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
94349>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94350>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
94351>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94352>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94353>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
94354>>>>>>>>            Increment i
94355>>>>>>>>
94355>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
94356>>>>>>>>            Move 253                                     to aColumnType[i].iSQLType
94357>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94358>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94359>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
94360>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
94361>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94362>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94363>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94364>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
94365>>>>>>>>            Increment i
94366>>>>>>>>
94366>>>>>>>>            Move "year"                                  to aColumnType[i].sSQLType
94367>>>>>>>>            Move 13                                      to aColumnType[i].iSQLType
94368>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
94369>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94370>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
94371>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
94372>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
94373>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
94374>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
94375>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
94376>>>>>>>>            Increment i
94377>>>>>>>>
94377>>>>>>>>
94377>>>>>>>        
94377>>>>>>>//        Move eMySQL_LONGLONG    to ColumnType[i].iSQLType
94377>>>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
94377>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94377>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
94377>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
94377>>>>>>>//        Increment i
94377>>>>>>>//
94377>>>>>>>//        Move eMySQL_BIT         to ColumnType[i].iSQLType
94377>>>>>>>//        Move "bit"              to ColumnType[i].sSQLType
94377>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
94377>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
94377>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
94377>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
94377>>>>>>>//        Increment i
94377>>>>>>>//
94377>>>>>>>//        Move eMySQL_BLOB        to ColumnType[i].iSQLType
94377>>>>>>>//        Move "blob"             to ColumnType[i].sSQLType
94377>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
94377>>>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
94377>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
94377>>>>>>>//        Increment i
94377>>>>>>>//
94377>>>>>>>//        Move eMySQL_STRING      to ColumnType[i].iSQLType
94377>>>>>>>//        Move "char"             to ColumnType[i].sSQLType
94377>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
94377>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
94377>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
94377>>>>>>>//        Increment i
94377>>>>>>>//
94377>>>>>>>//        Move eMySQL_DATE        to ColumnType[i].iSQLType
94377>>>>>>>//        Move "date"             to ColumnType[i].sSQLType
94377>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
94377>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
94377>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
94377>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
94377>>>>>>>//        Increment i
94377>>>>>>>//
94377>>>>>>>//        Move eMySQL_DATETIME    to ColumnType[i].iSQLType
94377>>>>>>>//        Move "datetime"         to ColumnType[i].sSQLType
94377>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
94377>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
94377>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
94377>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
94377>>>>>>>//        Increment i
94377>>>>>>>//
94377>>>>>>>//        Move eMySQL_DECIMAL     to ColumnType[i].iSQLType
94377>>>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
94377>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94377>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
94377>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
94377>>>>>>>//        Increment i
94377>>>>>>>//
94377>>>>>>>//        Move eMySQL_DOUBLE      to ColumnType[i].iSQLType
94377>>>>>>>//        Move "double"           to ColumnType[i].sSQLType
94377>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94377>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
94377>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
94377>>>>>>>//        Increment i
94377>>>>>>>//
94377>>>>>>>//        Move eMySQL_ENUM        to ColumnType[i].iSQLType
94377>>>>>>>//        Move "enum"             to ColumnType[i].sSQLType
94377>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
94377>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
94377>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
94377>>>>>>>//        Increment i
94377>>>>>>>//
94377>>>>>>>//        Move eMySQL_FLOAT       to ColumnType[i].iSQLType
94377>>>>>>>//        Move "float"            to ColumnType[i].sSQLType
94377>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94377>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
94377>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
94377>>>>>>>//        Increment i
94377>>>>>>>//
94377>>>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
94377>>>>>>>//        Move "int"              to ColumnType[i].sSQLType
94377>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94377>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
94377>>>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
94377>>>>>>>//        Increment i
94377>>>>>>>//
94377>>>>>>>//        Move eMySQL_LONG_BLOB   to ColumnType[i].iSQLType
94377>>>>>>>//        Move "longblob"         to ColumnType[i].sSQLType
94377>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
94377>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
94377>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
94377>>>>>>>//        Increment i
94377>>>>>>>//
94377>>>>>>>//        Move eMySQL_LONG_TEXT   to ColumnType[i].iSQLType
94377>>>>>>>//        Move "longtext"         to ColumnType[i].sSQLType
94377>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
94377>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
94377>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
94377>>>>>>>//        Increment i
94377>>>>>>>//
94377>>>>>>>//        Move eMySQL_MEDIUM_BLOB to ColumnType[i].iSQLType
94377>>>>>>>//        Move "mediumblob"       to ColumnType[i].sSQLType
94377>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
94377>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
94377>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
94377>>>>>>>//        Increment i
94377>>>>>>>//
94377>>>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
94377>>>>>>>//        Move "mediumint"        to ColumnType[i].sSQLType
94377>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94377>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
94377>>>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
94377>>>>>>>//
94377>>>>>>>//        Move eMySQL_MEDIUM_TEXT to ColumnType[i].iSQLType
94377>>>>>>>//        Move "mediumtext"       to ColumnType[i].sSQLType
94377>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
94377>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
94377>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
94377>>>>>>>//        Increment i
94377>>>>>>>//
94377>>>>>>>//        Move eMySQL_SET         to ColumnType[i].iSQLType
94377>>>>>>>//        Move "set"              to ColumnType[i].sSQLType
94377>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
94377>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
94377>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
94377>>>>>>>//        Increment i
94377>>>>>>>//
94377>>>>>>>//        Move eMySQL_SHORT       to ColumnType[i].iSQLType
94377>>>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
94377>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94377>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
94377>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
94377>>>>>>>//        Increment i
94377>>>>>>>//
94377>>>>>>>//        Move eMySQL_TEXT        to ColumnType[i].iSQLType
94377>>>>>>>//        Move "text"             to ColumnType[i].sSQLType
94377>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
94377>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
94377>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
94377>>>>>>>//        Increment i
94377>>>>>>>//
94377>>>>>>>//        Move eMySQL_TIME        to ColumnType[i].iSQLType
94377>>>>>>>//        Move "time"             to ColumnType[i].sSQLType
94377>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
94377>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
94377>>>>>>>//        Move "10.0"             to ColumnType[i].sPrecision
94377>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
94377>>>>>>>//        Increment i
94377>>>>>>>//
94377>>>>>>>//        Move eMySQL_TIMESTAMP   to ColumnType[i].iSQLType
94377>>>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
94377>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
94377>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
94377>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
94377>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
94377>>>>>>>//        Increment i
94377>>>>>>>//
94377>>>>>>>//        Move eMySQL_TINY_BLOB   to ColumnType[i].iSQLType
94377>>>>>>>//        Move "tinyblob"         to ColumnType[i].sSQLType
94377>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
94377>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
94377>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
94377>>>>>>>//        Increment i
94377>>>>>>>//
94377>>>>>>>//        Move eMySQL_TINY        to ColumnType[i].iSQLType
94377>>>>>>>//        Move "tinyint"          to ColumnType[i].sSQLType
94377>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94377>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
94377>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
94377>>>>>>>//        Increment i
94377>>>>>>>//
94377>>>>>>>//        Move eMySQL_TINY_TEXT   to ColumnType[i].iSQLType
94377>>>>>>>//        Move "tinytext"         to ColumnType[i].sSQLType
94377>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
94377>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
94377>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
94377>>>>>>>//        Increment i
94377>>>>>>>//
94377>>>>>>>//        Move eMySQL_VAR_STRING  to ColumnType[i].iSQLType
94377>>>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
94377>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
94377>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
94377>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
94377>>>>>>>//        Increment i
94377>>>>>>>//
94377>>>>>>>//        Move eMySQL_YEAR        to ColumnType[i].iSQLType
94377>>>>>>>//        Move "year"             to ColumnType[i].sSQLType
94377>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94377>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
94377>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
94377>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
94377>>>>>>>//        Increment i
94377>>>>>>>
94377>>>>>>>        Function_Return aColumnType
94378>>>>>>>    End_Function
94379>>>>>>>
94379>>>>>>>    // Oracle Data Types
94379>>>>>>>    Function _UtilEnumerateOracleTypes Returns tColumnType[]
94381>>>>>>>        tColumnType[] aColumnType
94381>>>>>>>        tColumnType[] aColumnType
94382>>>>>>>        Integer i
94382>>>>>>>        
Including file: ora_drv_DriverDef.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\ora_drv_DriverDef.inc)
94382>>>>>>>>// Generated By The Database Update Framework
94382>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\ora_drv_DriverDef.xml
94382>>>>>>>>// Driver COLUMN DATA TYPES
94382>>>>>>>>//
94382>>>>>>>>// Created: 2018-03-14 23:47:34.82
94382>>>>>>>>
94382>>>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
94383>>>>>>>>            Move 113                                     to aColumnType[i].iSQLType
94384>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94385>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94386>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
94387>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94388>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94389>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
94390>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
94391>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
94392>>>>>>>>            Increment i
94393>>>>>>>>
94393>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
94394>>>>>>>>            Move 96                                      to aColumnType[i].iSQLType
94395>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94396>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94397>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94398>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94399>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
94400>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94401>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94402>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
94403>>>>>>>>            Increment i
94404>>>>>>>>
94404>>>>>>>>            Move "clob"                                  to aColumnType[i].sSQLType
94405>>>>>>>>            Move 112                                     to aColumnType[i].iSQLType
94406>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94407>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94408>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
94409>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94410>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94411>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
94412>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
94413>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
94414>>>>>>>>            Increment i
94415>>>>>>>>
94415>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
94416>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
94417>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94418>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94419>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
94420>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
94421>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
94422>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
94423>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
94424>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
94425>>>>>>>>            Increment i
94426>>>>>>>>
94426>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
94427>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
94428>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94429>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94430>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94431>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94432>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
94433>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
94434>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
94435>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
94436>>>>>>>>            Increment i
94437>>>>>>>>
94437>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
94438>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
94439>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94440>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94441>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
94442>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94443>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
94444>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
94445>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
94446>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
94447>>>>>>>>            Increment i
94448>>>>>>>>
94448>>>>>>>>            Move "intervalds"                            to aColumnType[i].sSQLType
94449>>>>>>>>            Move 190                                     to aColumnType[i].iSQLType
94450>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
94451>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94452>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
94453>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
94454>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
94455>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
94456>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
94457>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
94458>>>>>>>>            Increment i
94459>>>>>>>>
94459>>>>>>>>            Move "intervalym"                            to aColumnType[i].sSQLType
94460>>>>>>>>            Move 189                                     to aColumnType[i].iSQLType
94461>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
94462>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94463>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
94464>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
94465>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
94466>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
94467>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
94468>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
94469>>>>>>>>            Increment i
94470>>>>>>>>
94470>>>>>>>>            Move "long"                                  to aColumnType[i].sSQLType
94471>>>>>>>>            Move 8                                       to aColumnType[i].iSQLType
94472>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94473>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94474>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
94475>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94476>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94477>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94478>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94479>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
94480>>>>>>>>            Increment i
94481>>>>>>>>
94481>>>>>>>>            Move "longraw"                               to aColumnType[i].sSQLType
94482>>>>>>>>            Move 24                                      to aColumnType[i].iSQLType
94483>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94484>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94485>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
94486>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94487>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94488>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
94489>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
94490>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
94491>>>>>>>>            Increment i
94492>>>>>>>>
94492>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
94493>>>>>>>>            Move 286                                     to aColumnType[i].iSQLType
94494>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94495>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94496>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94497>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94498>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
94499>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94500>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94501>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
94502>>>>>>>>            Increment i
94503>>>>>>>>
94503>>>>>>>>            Move "nclob"                                 to aColumnType[i].sSQLType
94504>>>>>>>>            Move 288                                     to aColumnType[i].iSQLType
94505>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94506>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94507>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
94508>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94509>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94510>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
94511>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
94512>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
94513>>>>>>>>            Increment i
94514>>>>>>>>
94514>>>>>>>>            Move "number"                                to aColumnType[i].sSQLType
94515>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
94516>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94517>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94518>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94519>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94520>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
94521>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
94522>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
94523>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
94524>>>>>>>>            Increment i
94525>>>>>>>>
94525>>>>>>>>            Move "nvarchar2"                             to aColumnType[i].sSQLType
94526>>>>>>>>            Move 287                                     to aColumnType[i].iSQLType
94527>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94528>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94529>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94530>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94531>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
94532>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94533>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94534>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
94535>>>>>>>>            Increment i
94536>>>>>>>>
94536>>>>>>>>            Move "raw"                                   to aColumnType[i].sSQLType
94537>>>>>>>>            Move 23                                      to aColumnType[i].iSQLType
94538>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94539>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94540>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94541>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94542>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
94543>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
94544>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
94545>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
94546>>>>>>>>            Increment i
94547>>>>>>>>
94547>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
94548>>>>>>>>            Move 187                                     to aColumnType[i].iSQLType
94549>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
94550>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94551>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
94552>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
94553>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
94554>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
94555>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
94556>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
94557>>>>>>>>            Increment i
94558>>>>>>>>
94558>>>>>>>>            Move "timestampltz"                          to aColumnType[i].sSQLType
94559>>>>>>>>            Move 232                                     to aColumnType[i].iSQLType
94560>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
94561>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94562>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
94563>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
94564>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
94565>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
94566>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
94567>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
94568>>>>>>>>            Increment i
94569>>>>>>>>
94569>>>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
94570>>>>>>>>            Move 188                                     to aColumnType[i].iSQLType
94571>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
94572>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94573>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
94574>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
94575>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
94576>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
94577>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
94578>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
94579>>>>>>>>            Increment i
94580>>>>>>>>
94580>>>>>>>>            Move "varchar2"                              to aColumnType[i].sSQLType
94581>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
94582>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94583>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94584>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94585>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94586>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
94587>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94588>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94589>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
94590>>>>>>>>            Increment i
94591>>>>>>>>
94591>>>>>>>>
94591>>>>>>>        
94591>>>>>>>//        Move eOracle_BLOB       to ColumnType[i].iSQLType
94591>>>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
94591>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
94591>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
94591>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
94591>>>>>>>//        Increment i
94591>>>>>>>//
94591>>>>>>>//        Move eOracle_CHAR       to ColumnType[i].iSQLType
94591>>>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
94591>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
94591>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
94591>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
94591>>>>>>>//        Increment i
94591>>>>>>>//
94591>>>>>>>//        Move eOracle_CLOB       to ColumnType[i].iSQLType
94591>>>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
94591>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
94591>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
94591>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
94591>>>>>>>//        Increment i
94591>>>>>>>//
94591>>>>>>>//        Move eOracle_DATE       to ColumnType[i].iSQLType
94591>>>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
94591>>>>>>>//        Move DF_Date            to ColumnType[i].iDataFlexType
94591>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
94591>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
94591>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
94591>>>>>>>//        Increment i
94591>>>>>>>//
94591>>>>>>>//        Move eOracle_FLOAT      to ColumnType[i].iSQLType
94591>>>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
94591>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94591>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
94591>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
94591>>>>>>>//        Increment i
94591>>>>>>>//
94591>>>>>>>//        Move eOracle_INT        to ColumnType[i].iSQLType
94591>>>>>>>//        Move "INT"              to ColumnType[i].sSQLType
94591>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94591>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
94591>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
94591>>>>>>>//        Increment i
94591>>>>>>>//
94591>>>>>>>//        Move eOracle_INTERVALDS to ColumnType[i].iSQLType
94591>>>>>>>//        Move "INTERVALDAYTOSEC" to ColumnType[i].sSQLType
94591>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
94591>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
94591>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
94591>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
94591>>>>>>>//        Increment i
94591>>>>>>>//
94591>>>>>>>//        Move eOracle_INTERVALYM  to ColumnType[i].iSQLType
94591>>>>>>>//        Move "INTERVALYEARTOMON" to ColumnType[i].sSQLType
94591>>>>>>>//        Move DF_DATETIME         to ColumnType[i].iDataFlexType
94591>>>>>>>//        Move "DateTime"          to ColumnType[i].sDataFlexType
94591>>>>>>>//        Move "23.0"              to ColumnType[i].sPrecision
94591>>>>>>>//        Move True                to ColumnType[i].bCanEditSize
94591>>>>>>>//        Increment i
94591>>>>>>>//
94591>>>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
94591>>>>>>>//        Move "LONG"             to ColumnType[i].sSQLType
94591>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
94591>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
94591>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
94591>>>>>>>//        Increment i
94591>>>>>>>//
94591>>>>>>>//        Move eOracle_LONGRAW    to ColumnType[i].iSQLType
94591>>>>>>>//        Move "LONG RAW"         to ColumnType[i].sSQLType
94591>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
94591>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
94591>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
94591>>>>>>>//        Increment i
94591>>>>>>>//
94591>>>>>>>//        Move eOracle_NCHAR      to ColumnType[i].iSQLType
94591>>>>>>>//        Move "NCHAR"            to ColumnType[i].sSQLType
94591>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
94591>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
94591>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
94591>>>>>>>//        Increment i
94591>>>>>>>//
94591>>>>>>>//        Move eOracle_NCLOB      to ColumnType[i].iSQLType
94591>>>>>>>//        Move "NCLOB"            to ColumnType[i].sSQLType
94591>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
94591>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
94591>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
94591>>>>>>>//        Increment i
94591>>>>>>>//
94591>>>>>>>//        Move eOracle_NUMBER     to ColumnType[i].iSQLType
94591>>>>>>>//        Move "NUMBER"           to ColumnType[i].sSQLType
94591>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94591>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
94591>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
94591>>>>>>>//        Increment i
94591>>>>>>>//
94591>>>>>>>//        Move eOracle_NVARCHAR2  to ColumnType[i].iSQLType
94591>>>>>>>//        Move "NVARCHAR2"        to ColumnType[i].sSQLType
94591>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
94591>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
94591>>>>>>>//        Move "4000"             to ColumnType[i].sPrecision
94591>>>>>>>//        Increment i
94591>>>>>>>//
94591>>>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
94591>>>>>>>//        Move "RAW"              to ColumnType[i].sSQLType
94591>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
94591>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
94591>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
94591>>>>>>>//        Increment i
94591>>>>>>>//
94591>>>>>>>//        Move eOracle_ROWID      to ColumnType[i].iSQLType
94591>>>>>>>//        Move "ROWID"            to ColumnType[i].sSQLType
94591>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
94591>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
94591>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
94591>>>>>>>//        Increment i
94591>>>>>>>//
94591>>>>>>>//        Move eOracle_TIMESTAMP  to ColumnType[i].iSQLType
94591>>>>>>>//        Move "TimeStamp"        to ColumnType[i].sSQLType
94591>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
94591>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
94591>>>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
94591>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
94591>>>>>>>//        Increment i
94591>>>>>>>//
94591>>>>>>>//        Move eOracle_TIMESTAMPLTZ   to ColumnType[i].iSQLType
94591>>>>>>>//        Move "TIMESTAMPLOCALTZ"     to ColumnType[i].sSQLType
94591>>>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
94591>>>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
94591>>>>>>>//        Move "13.0"                 to ColumnType[i].sPrecision
94591>>>>>>>//        Move True                   to ColumnType[i].bCanEditSize
94591>>>>>>>//        Increment i
94591>>>>>>>//
94591>>>>>>>//        Move eOracle_TIMESTAMPTZ    to ColumnType[i].iSQLType
94591>>>>>>>//        Move "TIMEZONETIMEZONE"     to ColumnType[i].sSQLType
94591>>>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
94591>>>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
94591>>>>>>>//        Move "11.0"                 to ColumnType[i].sPrecision
94591>>>>>>>//        Move True                   to ColumnType[i].bCanEditSize
94591>>>>>>>//        Increment i
94591>>>>>>>//
94591>>>>>>>//        Move eOracle_VARCHAR2   to ColumnType[i].iSQLType
94591>>>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
94591>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
94591>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
94591>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
94591>>>>>>>
94591>>>>>>>        Function_Return aColumnType
94592>>>>>>>    End_Function
94593>>>>>>>
94593>>>>>>>    // PostgreSQL Data Types
94593>>>>>>>    Function _UtilEnumeratePostgreSQLTypes Returns tColumnType[]
94595>>>>>>>        tColumnType[] aColumnType
94595>>>>>>>        tColumnType[] aColumnType
94596>>>>>>>        Integer i
94596>>>>>>>        
Including file: mdspgsql_DriverDef.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\mdspgsql_DriverDef.inc)
94596>>>>>>>>// Generated By The Database Update Framework
94596>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdspgsql_DriverDef.xml
94596>>>>>>>>// Driver COLUMN DATA TYPES
94596>>>>>>>>//
94596>>>>>>>>// Created: 2018-03-14 23:47:02.984
94596>>>>>>>>
94596>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
94597>>>>>>>>            Move 20                                      to aColumnType[i].iSQLType
94598>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94599>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94600>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
94601>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94602>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
94603>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
94604>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
94605>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
94606>>>>>>>>            Increment i
94607>>>>>>>>
94607>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
94608>>>>>>>>            Move 1560                                    to aColumnType[i].iSQLType
94609>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94610>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94611>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94612>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94613>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94614>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
94615>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
94616>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
94617>>>>>>>>            Increment i
94618>>>>>>>>
94618>>>>>>>>            Move "boolean"                               to aColumnType[i].sSQLType
94619>>>>>>>>            Move 16                                      to aColumnType[i].iSQLType
94620>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
94621>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94622>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94623>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
94624>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
94625>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94626>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94627>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
94628>>>>>>>>            Increment i
94629>>>>>>>>
94629>>>>>>>>            Move "bytea"                                 to aColumnType[i].sSQLType
94630>>>>>>>>            Move 17                                      to aColumnType[i].iSQLType
94631>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94632>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94633>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94634>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94635>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94636>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
94637>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
94638>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
94639>>>>>>>>            Increment i
94640>>>>>>>>
94640>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
94641>>>>>>>>            Move 18                                      to aColumnType[i].iSQLType
94642>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94643>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94644>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94645>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94646>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94647>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94648>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94649>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
94650>>>>>>>>            Increment i
94651>>>>>>>>
94651>>>>>>>>            Move "citext"                                to aColumnType[i].sSQLType
94652>>>>>>>>            Move -25                                     to aColumnType[i].iSQLType
94653>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94654>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94655>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94656>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94657>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94658>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94659>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94660>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
94661>>>>>>>>            Increment i
94662>>>>>>>>
94662>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
94663>>>>>>>>            Move 1082                                    to aColumnType[i].iSQLType
94664>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
94665>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94666>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
94667>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
94668>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
94669>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
94670>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
94671>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
94672>>>>>>>>            Increment i
94673>>>>>>>>
94673>>>>>>>>            Move "double"                                to aColumnType[i].sSQLType
94674>>>>>>>>            Move 701                                     to aColumnType[i].iSQLType
94675>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94676>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94677>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
94678>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94679>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
94680>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94681>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94682>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
94683>>>>>>>>            Increment i
94684>>>>>>>>
94684>>>>>>>>            Move "integer"                               to aColumnType[i].sSQLType
94685>>>>>>>>            Move 23                                      to aColumnType[i].iSQLType
94686>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94687>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94688>>>>>>>>            Move 11                                      to aColumnType[i].iDefaultSize
94689>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94690>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
94691>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
94692>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
94693>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
94694>>>>>>>>            Increment i
94695>>>>>>>>
94695>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
94696>>>>>>>>            Move 790                                     to aColumnType[i].iSQLType
94697>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94698>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94699>>>>>>>>            Move 30                                      to aColumnType[i].iDefaultSize
94700>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94701>>>>>>>>            Move 30                                      to aColumnType[i].nMaxSize
94702>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
94703>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
94704>>>>>>>>            Move 30                                      to aColumnType[i].sPrecision
94705>>>>>>>>            Increment i
94706>>>>>>>>
94706>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
94707>>>>>>>>            Move 1700                                    to aColumnType[i].iSQLType
94708>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94709>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94710>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
94711>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94712>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
94713>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94714>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94715>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
94716>>>>>>>>            Increment i
94717>>>>>>>>
94717>>>>>>>>            Move "oid"                                   to aColumnType[i].sSQLType
94718>>>>>>>>            Move 26                                      to aColumnType[i].iSQLType
94719>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
94720>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94721>>>>>>>>            Move 20                                      to aColumnType[i].iDefaultSize
94722>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
94723>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
94724>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
94725>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
94726>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
94727>>>>>>>>            Increment i
94728>>>>>>>>
94728>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
94729>>>>>>>>            Move 700                                     to aColumnType[i].iSQLType
94730>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94731>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94732>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
94733>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94734>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
94735>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
94736>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
94737>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
94738>>>>>>>>            Increment i
94739>>>>>>>>
94739>>>>>>>>            Move "regproc"                               to aColumnType[i].sSQLType
94740>>>>>>>>            Move 24                                      to aColumnType[i].iSQLType
94741>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
94742>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94743>>>>>>>>            Move 64                                      to aColumnType[i].iDefaultSize
94744>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
94745>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
94746>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94747>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94748>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
94749>>>>>>>>            Increment i
94750>>>>>>>>
94750>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
94751>>>>>>>>            Move 21                                      to aColumnType[i].iSQLType
94752>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94753>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94754>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
94755>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94756>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
94757>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
94758>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
94759>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
94760>>>>>>>>            Increment i
94761>>>>>>>>
94761>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
94762>>>>>>>>            Move 25                                      to aColumnType[i].iSQLType
94763>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94764>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94765>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94766>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94767>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94768>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94769>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94770>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
94771>>>>>>>>            Increment i
94772>>>>>>>>
94772>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
94773>>>>>>>>            Move 1083                                    to aColumnType[i].iSQLType
94774>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94775>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94776>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
94777>>>>>>>>            Move 8                                       to aColumnType[i].iMinSize
94778>>>>>>>>            Move 15                                      to aColumnType[i].nMaxSize
94779>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94780>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94781>>>>>>>>            Move 15                                      to aColumnType[i].sPrecision
94782>>>>>>>>            Increment i
94783>>>>>>>>
94783>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
94784>>>>>>>>            Move 1114                                    to aColumnType[i].iSQLType
94785>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
94786>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94787>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
94788>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
94789>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
94790>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
94791>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
94792>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
94793>>>>>>>>            Increment i
94794>>>>>>>>
94794>>>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
94795>>>>>>>>            Move 1184                                    to aColumnType[i].iSQLType
94796>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
94797>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94798>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
94799>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
94800>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
94801>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94802>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94803>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
94804>>>>>>>>            Increment i
94805>>>>>>>>
94805>>>>>>>>            Move "uuid"                                  to aColumnType[i].sSQLType
94806>>>>>>>>            Move 2950                                    to aColumnType[i].iSQLType
94807>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
94808>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94809>>>>>>>>            Move 40                                      to aColumnType[i].iDefaultSize
94810>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
94811>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
94812>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94813>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94814>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
94815>>>>>>>>            Increment i
94816>>>>>>>>
94816>>>>>>>>            Move "varbit"                                to aColumnType[i].sSQLType
94817>>>>>>>>            Move 1562                                    to aColumnType[i].iSQLType
94818>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94819>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94820>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94821>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94822>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94823>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94824>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94825>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
94826>>>>>>>>            Increment i
94827>>>>>>>>
94827>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
94828>>>>>>>>            Move 1043                                    to aColumnType[i].iSQLType
94829>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94830>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94831>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94832>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94833>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94834>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94835>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94836>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
94837>>>>>>>>            Increment i
94838>>>>>>>>
94838>>>>>>>>
94838>>>>>>>        
94838>>>>>>>//        Move ePgSQL_INT8        to ColumnType[i].iSQLType
94838>>>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
94838>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94838>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
94838>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
94838>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
94838>>>>>>>//        Increment i
94838>>>>>>>//
94838>>>>>>>//        Move ePgSQL_BIT         to ColumnType[i].iSQLType
94838>>>>>>>//        Move "bit"              to ColumnType[i].sSQLType
94838>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
94838>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
94838>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
94838>>>>>>>//        Increment i
94838>>>>>>>//
94838>>>>>>>//        Move ePgSQL_BOOL        to ColumnType[i].iSQLType
94838>>>>>>>//        Move "boolean"          to ColumnType[i].sSQLType
94838>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
94838>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
94838>>>>>>>//        Move "1"                to ColumnType[i].sPrecision
94838>>>>>>>//        Increment i
94838>>>>>>>//
94838>>>>>>>//        Move ePgSQL_BYTEA       to ColumnType[i].iSQLType
94838>>>>>>>//        Move "bytea"            to ColumnType[i].sSQLType
94838>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
94838>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
94838>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
94838>>>>>>>//        Increment i
94838>>>>>>>//
94838>>>>>>>//        Move ePgSQL_CHAR        to ColumnType[i].iSQLType
94838>>>>>>>//        Move "char"             to ColumnType[i].sSQLType
94838>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
94838>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
94838>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
94838>>>>>>>//        Increment i
94838>>>>>>>//
94838>>>>>>>//        Move ePgSQL_CITEXT      to ColumnType[i].iSQLType
94838>>>>>>>//        Move "citext"           to ColumnType[i].sSQLType
94838>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
94838>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
94838>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
94838>>>>>>>//        Increment i
94838>>>>>>>//
94838>>>>>>>//        Move ePgSQL_DATE        to ColumnType[i].iSQLType
94838>>>>>>>//        Move "date"             to ColumnType[i].sSQLType
94838>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
94838>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
94838>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
94838>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
94838>>>>>>>//        Increment i
94838>>>>>>>//
94838>>>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
94838>>>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
94838>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94838>>>>>>>//        Move "Decimal"          to ColumnType[i].sDataFlexType
94838>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
94838>>>>>>>//        Increment i
94838>>>>>>>//
94838>>>>>>>//        Move ePgSQL_FLOAT8      to ColumnType[i].iSQLType
94838>>>>>>>//        Move "double"           to ColumnType[i].sSQLType
94838>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
94838>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
94838>>>>>>>//        Move "22"               to ColumnType[i].sPrecision
94838>>>>>>>//        Increment i
94838>>>>>>>//
94838>>>>>>>//        Move ePgSQL_INT4        to ColumnType[i].iSQLType
94838>>>>>>>//        Move "integer"          to ColumnType[i].sSQLType
94838>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94838>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
94838>>>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
94838>>>>>>>//        Increment i
94838>>>>>>>//
94838>>>>>>>//        Move ePgSQL_MONEY       to ColumnType[i].iSQLType
94838>>>>>>>//        Move "money"            to ColumnType[i].sSQLType
94838>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94838>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
94838>>>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
94838>>>>>>>//        Increment i
94838>>>>>>>//
94838>>>>>>>//        Move ePgSQL_OID         to ColumnType[i].iSQLType
94838>>>>>>>//        Move "oid"              to ColumnType[i].sSQLType
94838>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
94838>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
94838>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
94838>>>>>>>//        Increment i
94838>>>>>>>//
94838>>>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
94838>>>>>>>//        Move "real"             to ColumnType[i].sSQLType
94838>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94838>>>>>>>//        Move "Real"             to ColumnType[i].sDataFlexType
94838>>>>>>>//        Move "6.6"              to ColumnType[i].sPrecision
94838>>>>>>>//        Increment i
94838>>>>>>>//
94838>>>>>>>//        Move ePgSQL_REGPROC     to ColumnType[i].iSQLType
94838>>>>>>>//        Move "regproc"          to ColumnType[i].sSQLType
94838>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
94838>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
94838>>>>>>>//        Move "64"               to ColumnType[i].sPrecision
94838>>>>>>>//        Increment i
94838>>>>>>>//
94838>>>>>>>//        Move ePgSQL_INT2        to ColumnType[i].iSQLType
94838>>>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
94838>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94838>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
94838>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
94838>>>>>>>//        Increment i
94838>>>>>>>//
94838>>>>>>>//        Move ePgSQL_TEXT        to ColumnType[i].iSQLType
94838>>>>>>>//        Move "text"             to ColumnType[i].sSQLType
94838>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
94838>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
94838>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
94838>>>>>>>//        Increment i
94838>>>>>>>//
94838>>>>>>>//        Move ePgSQL_TIME        to ColumnType[i].iSQLType
94838>>>>>>>//        Move "time"             to ColumnType[i].sSQLType
94838>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
94838>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
94838>>>>>>>//        Move "15.0"             to ColumnType[i].sPrecision
94838>>>>>>>//        Increment i
94838>>>>>>>//
94838>>>>>>>//        Move ePgSQL_TIMESTAMP   to ColumnType[i].iSQLType
94838>>>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
94838>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
94838>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
94838>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
94838>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
94838>>>>>>>//        Increment i
94838>>>>>>>//
94838>>>>>>>//        Move ePgSQL_UUID        to ColumnType[i].iSQLType
94838>>>>>>>//        Move "uuid"             to ColumnType[i].sSQLType
94838>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
94838>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
94838>>>>>>>//        Move "40"               to ColumnType[i].sPrecision
94838>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
94838>>>>>>>//        Increment i
94838>>>>>>>//
94838>>>>>>>//        Move ePgSQL_VARCHAR     to ColumnType[i].iSQLType
94838>>>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
94838>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
94838>>>>>>>//        Move "DF_TEXT"          to ColumnType[i].sDataFlexType
94838>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
94838>>>>>>>//        Increment i
94838>>>>>>>
94838>>>>>>>        Function_Return aColumnType
94839>>>>>>>    End_Function
94840>>>>>>>
94840>>>>>>>    // Internal usage. Use the UtilColumnTypeXXX functions instead.
94840>>>>>>>    Function _UtilColumnType String sDriverID Integer iDbType Integer iType String sType Boolean bIntegerInputType Returns tColumnType
94842>>>>>>>        Integer iValue iSize iCount iStart
94842>>>>>>>        tColumnType[] ColumnTypeArray
94842>>>>>>>        tColumnType[] ColumnTypeArray
94843>>>>>>>        tColumnType RetvalType
94843>>>>>>>        tColumnType RetvalType
94843>>>>>>>        String sValue
94843>>>>>>>        Boolean bFrameworkDataFlexType
94843>>>>>>>
94843>>>>>>>        Move "Undefined" to RetvalType.sSQLType
94844>>>>>>>        Move -1999       to RetvalType.iSQLType
94845>>>>>>>
94845>>>>>>>        Move 0 to iStart
94846>>>>>>>        Move (Uppercase(sType)) to sType
94847>>>>>>>        Move (iType <= -1490) to bFrameworkDataFlexType
94848>>>>>>>        If (bFrameworkDataFlexType = True) Begin
94850>>>>>>>            Get UtilDUFDataTypeToSqlTypeMapping sDriverID iDbType iType to RetvalType
94851>>>>>>>            Function_Return RetvalType
94852>>>>>>>        End
94852>>>>>>>>
94852>>>>>>>
94852>>>>>>>        Get UtilEnumerateColumnTypes sDriverID iDbType to ColumnTypeArray
94853>>>>>>>
94853>>>>>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
94854>>>>>>>        Decrement iSize
94855>>>>>>>
94855>>>>>>>        for iCount from iStart to iSize
94861>>>>>>>>
94861>>>>>>>            Move ColumnTypeArray[iCount].iSQLType to iValue
94862>>>>>>>            Move ColumnTypeArray[iCount].sSQLType to sValue
94863>>>>>>>            If (bIntegerInputType = True) Begin
94865>>>>>>>                If (iValue = iType) Begin
94867>>>>>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
94868>>>>>>>                    Move iType                                  to RetvalType.iSQLType
94869>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
94870>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
94871>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
94872>>>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
94873>>>>>>>                    Move iSize to iCount // We're done!
94874>>>>>>>                End
94874>>>>>>>>
94874>>>>>>>            End
94874>>>>>>>>
94874>>>>>>>            Else Begin
94875>>>>>>>                Move (Uppercase(sValue)) to sValue
94876>>>>>>>                If (sValue = sType) Begin
94878>>>>>>>                    Move sType                                  to RetvalType.sSQLType
94879>>>>>>>                    Move ColumnTypeArray[iCount].iSQLType       to RetvalType.iSQLType
94880>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
94881>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
94882>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
94883>>>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
94884>>>>>>>                    Move iSize to iCount // We're done!
94885>>>>>>>                End
94885>>>>>>>>
94885>>>>>>>            End
94885>>>>>>>>
94885>>>>>>>        Loop
94886>>>>>>>>
94886>>>>>>>
94886>>>>>>>        // If no match was found it was probably because it was a DataFlex standard type that was passed.
94886>>>>>>>        // In which case we search for a match in DataFlex standard types:
94886>>>>>>>        If (RetvalType.sSQLType = "Undefined") Begin
94888>>>>>>>            Get _UtilEnumerateDataFlexTypes to ColumnTypeArray
94889>>>>>>>            Move (SizeOfArray(ColumnTypeArray)) to iSize
94890>>>>>>>            Decrement iSize
94891>>>>>>>
94891>>>>>>>            for iCount from iStart to iSize
94897>>>>>>>>
94897>>>>>>>                Move ColumnTypeArray[iCount].iSQLType to iValue
94898>>>>>>>                Move ColumnTypeArray[iCount].sSQLType to sValue
94899>>>>>>>                If (iValue = iType) Begin
94901>>>>>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
94902>>>>>>>                    Move iType                                  to RetvalType.iSQLType
94903>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
94904>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
94905>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
94906>>>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
94907>>>>>>>                    Move iSize to iCount // We're done!
94908>>>>>>>                End
94908>>>>>>>>
94908>>>>>>>            Loop
94909>>>>>>>>
94909>>>>>>>        End
94909>>>>>>>>
94909>>>>>>>
94909>>>>>>>        Function_Return RetvalType
94910>>>>>>>    End_Function
94911>>>>>>>
94911>>>>>>>    Function _AllTablesToConvert Returns Integer[]
94913>>>>>>>        Integer[] aTableConvertExceptions iTablesArray
94915>>>>>>>        Handle hTable
94915>>>>>>>        Integer iIndex
94915>>>>>>>        String sTableName
94915>>>>>>>        Boolean bFlexErrs
94915>>>>>>>
94915>>>>>>>        // a) Get the exception table array the developer has specified
94915>>>>>>>        Get paTableConvertExceptions to aTableConvertExceptions
94916>>>>>>>
94916>>>>>>>        // b) Add CodeMast, CodeType & DbVersion to exceptions
94916>>>>>>>        Repeat
94916>>>>>>>>
94916>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
94919>>>>>>>            If (hTable <> 0) Begin
94921>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
94924>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
94925>>>>>>>                If (bFlexErrs = False) Begin
94927>>>>>>>                    If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "DBVERSION") Begin
94929>>>>>>>                        Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
94930>>>>>>>                        If (iIndex = -1) Begin
94932>>>>>>>                            Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
94933>>>>>>>                        End
94933>>>>>>>>
94933>>>>>>>                    End
94933>>>>>>>>
94933>>>>>>>                End
94933>>>>>>>>
94933>>>>>>>            End
94933>>>>>>>>
94933>>>>>>>        Until (hTable = 0)
94935>>>>>>>
94935>>>>>>>        Move 0 to hTable
94936>>>>>>>
94936>>>>>>>        // c) Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
94936>>>>>>>        Repeat
94936>>>>>>>>
94936>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
94939>>>>>>>            If (hTable > 0) Begin
94941>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
94944>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
94945>>>>>>>                If (bFlexErrs = False) Begin
94947>>>>>>>                    Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
94948>>>>>>>                    If (iIndex = -1) Begin
94950>>>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
94951>>>>>>>                    End
94951>>>>>>>>
94951>>>>>>>                End
94951>>>>>>>>
94951>>>>>>>            End
94951>>>>>>>>
94951>>>>>>>        Until (hTable = 0)
94953>>>>>>>
94953>>>>>>>        Function_Return iTablesArray
94954>>>>>>>    End_Function
94955>>>>>>>
94955>>>>>>>    Function _AllTablesDateCorrections Returns Integer[]
94957>>>>>>>        Integer[] aTableDateCorrectionExceptions iTablesArray
94959>>>>>>>        Handle hTable
94959>>>>>>>        Integer iIndex
94959>>>>>>>        String sTableName
94959>>>>>>>        Boolean bFlexErrs
94959>>>>>>>
94959>>>>>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
94960>>>>>>>        Move 0 to hTable
94961>>>>>>>
94961>>>>>>>        // Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
94961>>>>>>>        Repeat
94961>>>>>>>>
94961>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
94964>>>>>>>            If (hTable > 0) Begin
94966>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
94969>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
94970>>>>>>>                If (bFlexErrs = False) Begin
94972>>>>>>>                    Move (SearchArray(hTable, aTableDateCorrectionExceptions)) to iIndex
94973>>>>>>>                    If (iIndex = -1) Begin
94975>>>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
94976>>>>>>>                    End
94976>>>>>>>>
94976>>>>>>>                End
94976>>>>>>>>
94976>>>>>>>            End
94976>>>>>>>>
94976>>>>>>>        Until (hTable = 0)
94978>>>>>>>
94978>>>>>>>        Function_Return iTablesArray
94979>>>>>>>    End_Function
94980>>>>>>>
94980>>>>>>>    Function _AppendAPIColumn tAPIColumn[] aCurrent String sFieldName Integer iType Integer iLength Integer iPrecision Integer iOptions Returns tAPIColumn[]
94982>>>>>>>        tAPIColumn NewAPIColumn
94982>>>>>>>        tAPIColumn NewAPIColumn
94982>>>>>>>
94982>>>>>>>        Move sFieldName to NewAPIColumn.sFieldName
94983>>>>>>>        Move iType      to NewAPIColumn.iType
94984>>>>>>>        Move iLength    to NewAPIColumn.iLength
94985>>>>>>>        Move iPrecision to NewAPIColumn.iPrecision
94986>>>>>>>        Move iOptions   to NewAPIColumn.iOptions
94987>>>>>>>
94987>>>>>>>        Move NewAPIColumn to aCurrent[SizeOfArray(aCurrent)]
94988>>>>>>>
94988>>>>>>>        Function_Return aCurrent
94989>>>>>>>    End_Function
94990>>>>>>>
94990>>>>>>>    Function _UtilIndexAppendSegmentFieldNames tAPIIndexSegment[] APIIndexSegment Returns String
94992>>>>>>>        String sRetval sFieldName
94992>>>>>>>        Integer iCount iSize
94992>>>>>>>
94992>>>>>>>        Move (SizeOfArray(APIIndexSegment)) to iSize
94993>>>>>>>        Decrement iSize
94994>>>>>>>        for iCount from 0 to iSize
95000>>>>>>>>
95000>>>>>>>            Move APIIndexSegment[iCount].sFieldName to sFieldName
95001>>>>>>>            Move (sRetval * (String(sFieldName))) to sRetval
95002>>>>>>>        Loop
95003>>>>>>>>
95003>>>>>>>        Move (Trim(sRetval)) to sRetval
95004>>>>>>>
95004>>>>>>>        Function_Return sRetval
95005>>>>>>>    End_Function
95006>>>>>>>
95006>>>>>>>    // *** Miscellaneous other functions ***
95006>>>>>>>    // Some of which can be used by both "Sqlxxx" and "Apixxx" functions.
95006>>>>>>>    //
95006>>>>>>>
95006>>>>>>>    // Callback functionality used when e.g. calling driver functions directly.
95006>>>>>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
95008>>>>>>>        Integer iPerc
95008>>>>>>>        Number nReady nTotal
95008>>>>>>>
95008>>>>>>>        Send DoAdvance of ghoProgressBar
95009>>>>>>>
95009>>>>>>>        If (sCallback_Text contains "Copy records") Begin
95011>>>>>>>            Move CS_SQLCopyingData to sCallback_Text
95012>>>>>>>        End
95012>>>>>>>>
95012>>>>>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
95014>>>>>>>            Move (Replace("Dropping index", sCallback_Text, CS_SQLDeletingIndex)) to sCallback_Text
95015>>>>>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_SQLDeletingIndex)) to sCallback_Text
95016>>>>>>>        End
95016>>>>>>>>
95016>>>>>>>        If (sCallback_Text contains "Creating index") Begin
95018>>>>>>>            Move (Replace("Creating index", sCallback_Text, CS_SQLCreatingIndex)) to sCallback_Text
95019>>>>>>>        End
95019>>>>>>>>
95019>>>>>>>
95019>>>>>>>        Case Begin
95019>>>>>>>            Case (iCallback_Type = DF_Message_Text)
95021>>>>>>>//                Set Message_Text of ghoStatusPanel to sCallback_Text
95021>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
95022>>>>>>>                Case Break
95023>>>>>>>            Case (iCallback_Type = DF_Message_Heading_1)
95026>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
95027>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
95028>>>>>>>                Case Break
95029>>>>>>>            Case (iCallback_Type = DF_Message_Heading_2)
95032>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
95033>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
95034>>>>>>>                Case Break
95035>>>>>>>            Case (iCallback_Type = DF_Message_Heading_3)
95038>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
95039>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
95040>>>>>>>                Case Break
95041>>>>>>>            Case (iCallback_Type = DF_Message_Heading_4)
95044>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
95045>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
95046>>>>>>>                Case Break
95047>>>>>>>            Case (iCallback_Type = DF_Message_Heading_5)
95050>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
95051>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
95052>>>>>>>                Case Break
95053>>>>>>>            Case (iCallback_Type = DF_Message_Warning)
95056>>>>>>>                Send None
95057>>>>>>>                Case Break
95058>>>>>>>            Case (iCallback_Type = DF_Message_Progress_Title)
95061>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
95062>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
95063>>>>>>>                Case Break
95064>>>>>>>            Case (iCallback_Type = DF_Message_Progress_Value)
95067>>>>>>>                //*** Interpret numbers
95067>>>>>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
95068>>>>>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
95069>>>>>>>                Move ((nReady / nTotal) * 100)                                                    to iPerc
95070>>>>>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% Done (Total Number of Records:") * String(nTotal) + ")")
95071>>>>>>>                Case Break
95072>>>>>>>            Case Else
95072>>>>>>>                Set Message_Text to ""
95073>>>>>>>                Set Action_Text  to ""
95074>>>>>>>        Case End
95074>>>>>>>
95074>>>>>>>        Send ProcessEvents of ghoStatusPanel
95075>>>>>>>        Function_Return False
95076>>>>>>>    End_Function
95077>>>>>>>
95077>>>>>>>    Procedure IncreaseSortBufferSize
95079>>>>>>>        String sNull
95079>>>>>>>        Integer iSortBufferSize
95079>>>>>>>        Boolean bBufferSet
95079>>>>>>>
95079>>>>>>>        Move "" to sNull
95080>>>>>>>        Move (1024 * 128) to iSortBufferSize
95081>>>>>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_SET_MAX_SORT_BUFFER Callback ghoDbUpdateHandler Passing sNull sNull iSortBufferSize Result bBufferSet
95086>>>>>>>
95086>>>>>>>    End_Procedure
95087>>>>>>>
95087>>>>>>>    Procedure SetAllIndexesToBatch Handle hTable Boolean bSetToBatch
95089>>>>>>>        Integer iLastIndex iIndex iNumSegments
95089>>>>>>>        Boolean bOK    
95089>>>>>>>        String sDriverID
95089>>>>>>>
95089>>>>>>>        If (hTable > 0) Begin
95091>>>>>>>            Get UtilDriverFromTableNumber hTable to sDriverID
95092>>>>>>>            Close hTable
95093>>>>>>>            Get OpenTableExclusive hTable to bOK
95094>>>>>>>            If (bOK = False) Begin
95096>>>>>>>                Function_Return False
95097>>>>>>>            End
95097>>>>>>>>
95097>>>>>>>            Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex   
95100>>>>>>>            Structure_Start hTable sDriverID
95101>>>>>>>                for iIndex from 1 to iLastIndex
95107>>>>>>>>
95107>>>>>>>                    Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
95110>>>>>>>                    If (iNumSegments > 0) Begin                     
95112>>>>>>>                        If (bSetToBatch = True) Begin
95114>>>>>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_BATCH
95117>>>>>>>                        End                 
95117>>>>>>>>
95117>>>>>>>                        Else Begin
95118>>>>>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_ONLINE
95121>>>>>>>                        End
95121>>>>>>>>
95121>>>>>>>                    End
95121>>>>>>>>
95121>>>>>>>                Loop
95122>>>>>>>>
95122>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
95124>>>>>>>        End
95124>>>>>>>>
95124>>>>>>>    End_Procedure
95125>>>>>>>
95125>>>>>>>    Function NextFreeFilelistSlot Returns Handle
95127>>>>>>>        Handle hTable
95127>>>>>>>
95127>>>>>>>        Move 0 to hTable
95128>>>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of hTable to hTable
95131>>>>>>>
95131>>>>>>>        Function_Return hTable
95132>>>>>>>    End_Function
95133>>>>>>>
95133>>>>>>>    // For debugging purposes. To print Sql statements as they are build...
95133>>>>>>>    Procedure DebugPrint String sStmt String sFileName
95135>>>>>>>        Integer iCh
95135>>>>>>>        Get Seq_Append_Output_Channel sFileName to iCh
95136>>>>>>>            Write channel iCh sStmt
95138>>>>>>>        Send Seq_Close_Channel iCh
95139>>>>>>>    End_Procedure
95140>>>>>>>
95140>>>>>>>    // Returns the integer number for the passed Driver ID that is
95140>>>>>>>    // needed by some database API calls.
95140>>>>>>>    Function DriverIndex String sDriverID Returns Integer
95142>>>>>>>        String  sCurrentDriver
95142>>>>>>>        Integer iNumberOfDrivers iDriver iCount
95142>>>>>>>
95142>>>>>>>        Move 0 to iDriver
95143>>>>>>>
95143>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
95146>>>>>>>        for iCount from 1 to iNumberOfDrivers
95152>>>>>>>>
95152>>>>>>>
95152>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
95155>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
95157>>>>>>>                Move iCount to iDriver
95158>>>>>>>            End
95158>>>>>>>>
95158>>>>>>>        Loop
95159>>>>>>>>
95159>>>>>>>
95159>>>>>>>        // In case it was not found, it wasn't loaded so we do that now.
95159>>>>>>>        If (iDriver = 0) Begin
95161>>>>>>>            Move False to Err
95162>>>>>>>            Load_Driver sDriverID
95163>>>>>>>            If (Err = False) Begin
95165>>>>>>>                Move 1 to iDriver
95166>>>>>>>            End
95166>>>>>>>>
95166>>>>>>>        End
95166>>>>>>>>
95166>>>>>>>
95166>>>>>>>        Function_Return iDriver
95167>>>>>>>    End_Function
95168>>>>>>>
95168>>>>>>>    // Returns TRUE if table is opened exclusive, otherwise FALSE
95168>>>>>>>    // Note: If run from the Studio, CodeMast & CodeType _is_ open by the Studio,
95168>>>>>>>    //       so in that case we "cheat" and report those tables were opened OK.
95168>>>>>>>    Function OpenTableExclusive Handle hTable Returns Boolean
95170>>>>>>>        Integer iMode
95170>>>>>>>        Boolean bOpened
95170>>>>>>>        String sTableName
95170>>>>>>>
95170>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
95171>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
95174>>>>>>>        If (bOpened) Begin
95176>>>>>>>            If (IsDebuggerPresent()) Begin
95178>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
95181>>>>>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
95183>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
95184>>>>>>>                    Function_Return True
95185>>>>>>>                End
95185>>>>>>>>
95185>>>>>>>            End
95185>>>>>>>>
95185>>>>>>>            Get_Attribute DF_FILE_OPEN_MODE of hTable to iMode
95188>>>>>>>            If (iMode=DF_EXCLUSIVE) Begin
95190>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
95191>>>>>>>                Function_Return True
95192>>>>>>>            End
95192>>>>>>>>
95192>>>>>>>            Close hTable
95193>>>>>>>        End
95193>>>>>>>>
95193>>>>>>>        Else Begin
95194>>>>>>>            Open hTable
95196>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
95199>>>>>>>            If (bOpened and IsDebuggerPresent()) Begin
95201>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
95204>>>>>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
95206>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
95207>>>>>>>                    Function_Return True
95208>>>>>>>                End
95208>>>>>>>>
95208>>>>>>>            End
95208>>>>>>>>
95208>>>>>>>
95208>>>>>>>        End
95208>>>>>>>>
95208>>>>>>>        
95208>>>>>>>        Close hTable
95209>>>>>>>        Open hTable Mode DF_EXCLUSIVE
95211>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
95214>>>>>>>
95214>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
95215>>>>>>>        Function_Return bOpened
95216>>>>>>>    End_Function
95217>>>>>>>
95217>>>>>>>    Function AutoConnectionIDLogin Returns Boolean
95219>>>>>>>        String sConnectionID sConnectionString sDriverID
95219>>>>>>>        Boolean bExists bOK bSQLDriver
95219>>>>>>>        Handle hoCLI hoDriver
95219>>>>>>>        Integer iRetval
95219>>>>>>>        tSQLConnection SQLConnection
95219>>>>>>>        tSQLConnection SQLConnection
95219>>>>>>>
95219>>>>>>>        Get psDriverID to sDriverID
95220>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
95221>>>>>>>        If (bSQLDriver = False) Begin
95223>>>>>>>            Function_Return True
95224>>>>>>>        End
95224>>>>>>>>
95224>>>>>>>
95224>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
95225>>>>>>>        Move SQLConnection.sDriverID                  to sDriverID
95226>>>>>>>        Move SQLConnection.sConnectionString          to sConnectionString
95227>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
95228>>>>>>>        If (bOK = True) Begin
95230>>>>>>>//            Get SQLLogin of ghoSQLConnectionHandler SQLConnection to bOK
95230>>>>>>>        End
95230>>>>>>>>
95230>>>>>>>        If (bOK = False) Begin
95232>>>>>>>            Get _MertechSQLManagerHandle to hoCLI
95233>>>>>>>            Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
95234>>>>>>>            Set psDriverID of hoDriver to SQLConnection.sDriverID
95235>>>>>>>            If (SQLConnection.sDriverID <> DATAFLEX_ID) Begin
95237>>>>>>>                Get DbLogin  of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
95238>>>>>>>                Send Destroy of hoDriver
95239>>>>>>>            End
95239>>>>>>>>
95239>>>>>>>            Function_Return False
95240>>>>>>>        End
95240>>>>>>>>
95240>>>>>>>
95240>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
95241>>>>>>>
95241>>>>>>>        Get IsConnectionID sConnectionID sDriverID to bExists
95242>>>>>>>        If (bExists = False) Begin
95244>>>>>>>            // We always start by deleting the current connection - if any - because the
95244>>>>>>>            // login details my have changed.
95244>>>>>>>            Get phoCLIHandler to hoCLI
95245>>>>>>>            Set psDriverID    of hoCLI to sDriverID
95246>>>>>>>            Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
95247>>>>>>>            Get UtilCreateConnectionID sConnectionID to bOk
95248>>>>>>>            If (bOk = False) Begin
95250>>>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be changed.")
95251>>>>>>>>
95251>>>>>>>                Function_Return False
95252>>>>>>>            End
95252>>>>>>>>
95252>>>>>>>            Move bOK to bExists
95253>>>>>>>        End
95253>>>>>>>>
95253>>>>>>>
95253>>>>>>>        Function_Return (bExists = True)
95254>>>>>>>    End_Function
95255>>>>>>>
95255>>>>>>>    // Scans to see if all tables can be opened exclusivly. I.e. that nobody else is running the application.
95255>>>>>>>    // Returns: False if nobody else is running
95255>>>>>>>    //          True if at least one table is open by another process (e.g. another user is running the application)
95255>>>>>>>    // N.B! Only works for Embedded DataFlex Tables! It will _not_ work for Sql tables because; these
95255>>>>>>>    //      tables are not locked as DataFlex tables are.
95255>>>>>>>    Function IsDatabaseInUse Returns Boolean
95257>>>>>>>        Handle  hTable
95257>>>>>>>        String  sRootName
95257>>>>>>>        Boolean bOpen bErr bAlias bOK bIsSQLTable bFlexErrs
95257>>>>>>>        Integer iCount iTables
95257>>>>>>>        
95257>>>>>>>        Move 0 to iTables
95258>>>>>>>        Set Action_Text of ghoStatusPanel to "Database in use check..."
95259>>>>>>>        Get AutoConnectionIDLogin to bOK
95260>>>>>>>        Get UtilFilelistNoOfTables to iTables
95261>>>>>>>        Set piPosition   of ghoProgressBar to 0
95262>>>>>>>        Set piAdvanceBy  of ghoProgressBar to 1      
95263>>>>>>>        Set piMaximum    of ghoProgressBar to iTables
95264>>>>>>>        Move 0 to hTable
95265>>>>>>>        Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
95268>>>>>>>        Move False to bErr
95269>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
95270>>>>>>>
95270>>>>>>>        Repeat
95270>>>>>>>>
95270>>>>>>>            Set piPosition of ghoProgressBar to iCount
95271>>>>>>>            Increment iCount
95272>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
95275>>>>>>>            Move (Uppercase(sRootName) = "FLEXERRS")  to bFlexErrs
95276>>>>>>>
95276>>>>>>>            // This test is only applicable for DataFlex embedded tables; so skip test if driver based table.
95276>>>>>>>            Get UtilTableIsSQLByRootName sRootName to bIsSQLTable
95277>>>>>>>            Move False to bOpen
95278>>>>>>>
95278>>>>>>>            // Don't bother about FlexErrs (Normally table 50)
95278>>>>>>>            If (bIsSQLTable = False and hTable <> 0 and bFlexErrs = False) Begin
95280>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
95281>>>>>>>                Open hTable
95283>>>>>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
95286>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
95287>>>>>>>                If (bOpen = True) Begin
95289>>>>>>>                    // We cannot open an Alias file exclusive as it will generate an error (4177 - "File in use")
95289>>>>>>>                    Get UtilTableIsAlias hTable to bAlias
95290>>>>>>>                    If (bAlias = False) Begin
95292>>>>>>>                        Close hTable
95293>>>>>>>                        Get OpenTableExclusive hTable to bOpen
95294>>>>>>>                        If (bOpen = False) Begin
95296>>>>>>>                            Move True to bErr
95297>>>>>>>                        End
95297>>>>>>>>
95297>>>>>>>                    End
95297>>>>>>>>
95297>>>>>>>                End
95297>>>>>>>>
95297>>>>>>>                Close hTable
95298>>>>>>>            End
95298>>>>>>>>
95298>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
95301>>>>>>>            If (bErr = True ) ;                Break
95304>>>>>>>        Until (not(hTable))
95306>>>>>>>
95306>>>>>>>        Set Action_Text of ghoStatusPanel to ""
95307>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
95308>>>>>>>        Move False to Err
95309>>>>>>>
95309>>>>>>>        Function_Return bErr
95310>>>>>>>    End_Function
95311>>>>>>>
95311>>>>>>>    // Checks if the passed connection id exists in the CLI interface.
95311>>>>>>>    // This might be needed by API-methods when a connection id is to be used and
95311>>>>>>>    // the connection id hasn't been established with the driver's CLI interface.
95311>>>>>>>    // NOTE: Only applicable for DAW drivers.
95311>>>>>>>    Function IsConnectionID String sConnectionID String sDriverID Returns Boolean
95313>>>>>>>        String sID sConnString
95313>>>>>>>        Integer iDriver iNumConn iCount
95313>>>>>>>        Handle hoCLI
95313>>>>>>>        Boolean bOK
95313>>>>>>>
95313>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
95314>>>>>>>        If (bOK = False) Begin
95316>>>>>>>            Error DFERR_PROGRAM "Connection ID's can only be used with DAW drivers (not Mertech)."
95317>>>>>>>>
95317>>>>>>>            Function_Return False
95318>>>>>>>        End
95318>>>>>>>>
95318>>>>>>>
95318>>>>>>>        Move False to bOK
95319>>>>>>>        Get phoCLIHandler to hoCLI
95320>>>>>>>        If (hoCLI <> 0) Begin
95322>>>>>>>            Set psDriverID of hoCLI to sDriverID
95323>>>>>>>            Get DriverIndex of hoCLI sDriverID to iDriver
95324>>>>>>>
95324>>>>>>>            // If driver not loaded; load it.
95324>>>>>>>            If (iDriver = 0) Begin
95326>>>>>>>                Load_Driver sDriverID
95327>>>>>>>                Get DriverIndex sDriverID to iDriver
95328>>>>>>>            End
95328>>>>>>>>
95328>>>>>>>            If (iDriver <> 0) Begin
95330>>>>>>>                Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
95333>>>>>>>                Decrement iNumConn
95334>>>>>>>                for iCount from 0 to iNumConn
95340>>>>>>>>
95340>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iCount to sConnString
95343>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iCount to sID
95346>>>>>>>                    If (sID = sConnectionID) Begin
95348>>>>>>>                        Move True to bOK
95349>>>>>>>                    End
95349>>>>>>>>
95349>>>>>>>                Loop
95350>>>>>>>>
95350>>>>>>>            End
95350>>>>>>>>
95350>>>>>>>        End
95350>>>>>>>>
95350>>>>>>>
95350>>>>>>>        Function_Return bOK
95351>>>>>>>    End_Function
95352>>>>>>>
95352>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
95354>>>>>>>        Boolean bOK
95354>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
95355>>>>>>>        Function_Return bOK
95356>>>>>>>    End_Function
95357>>>>>>>
95357>>>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
95359>>>>>>>        Boolean bOK
95359>>>>>>>        Move False to bOK
95360>>>>>>>        Move (sDriverID = SQLFLEX or sDriverID = ORAFLEX or sDriverID = MDSPgSQL or sDriverID = MDSMySQL) to bOK
95361>>>>>>>        Function_Return bOK
95362>>>>>>>    End_Function
95363>>>>>>>
95363>>>>>>>    Function IsMSSQLDriver Returns Boolean
95365>>>>>>>        Integer iDriverIndex
95365>>>>>>>
95365>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriverIndex
95366>>>>>>>
95366>>>>>>>        Function_Return (iDriverIndex <> 0)
95367>>>>>>>    End_Function
95368>>>>>>>
95368>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
95368>>>>>>>    // attempt to load the driver.
95368>>>>>>>    // Returns true if the passed driver is SQL based.
95368>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
95370>>>>>>>        Boolean bOK
95370>>>>>>>
95370>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
95371>>>>>>>
95371>>>>>>>        If (bOK = False) Begin
95373>>>>>>>            Get IsMertechDriver sDriverID to bOK
95374>>>>>>>        End
95374>>>>>>>>
95374>>>>>>>
95374>>>>>>>        Function_Return bOK
95375>>>>>>>    End_Function
95376>>>>>>>
95376>>>>>>>    // *** Error Handler ***
95376>>>>>>>    //
95376>>>>>>>    // Note: If the cDbUpdateHandler & cDbUpdateVersion classes are used this error handler is _not_
95376>>>>>>>    //       used. Instead the Error_Report in the cDbUpdateHandler i used.
95376>>>>>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
95378>>>>>>>        Integer iSize iErrorMode
95378>>>>>>>        tSqlErrorArray aSqlErrorArray
95378>>>>>>>        tSqlErrorArray aSqlErrorArray
95378>>>>>>>
95378>>>>>>>        If (pbProcessingError(Self)) Begin
95380>>>>>>>            Procedure_Return
95381>>>>>>>        End
95381>>>>>>>>
95381>>>>>>>
95381>>>>>>>        Get Error_Report_Mode to iErrorMode
95382>>>>>>>        If (iErrorMode = DUF_ERROR_NO_REPORT) Begin
95384>>>>>>>            Procedure_Return
95385>>>>>>>        End
95385>>>>>>>>
95385>>>>>>>
95385>>>>>>>        Set pbProcessingError to True
95386>>>>>>>        Set pbSqlError to True
95387>>>>>>>        Get paSqlErrorArray      to aSqlErrorArray
95388>>>>>>>        Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iSize
95389>>>>>>>        Move sErrorText          to aSqlErrorArray.sSqlErrorArray[iSize]
95390>>>>>>>        Get psSQLStatementString to aSqlErrorArray.sSqlStatementArray[iSize]
95391>>>>>>>        Move iErrorNumber        to aSqlErrorArray.iSqlErrorArray[iSize]
95392>>>>>>>        Set paSqlErrorArray      to aSqlErrorArray
95393>>>>>>>        Set pbProcessingError to False
95394>>>>>>>    End_Procedure
95395>>>>>>>
95395>>>>>>>    // *** Miscellanous Helper Functions ***
95395>>>>>>>    //
95395>>>>>>>    // Helper function. Takes a DF_FILE_XXXX_NAME value as parameter and
95395>>>>>>>    // returns the table name only; stripped of any path or filename extension.
95395>>>>>>>    Function _TableNameOnly String sName Returns String
95397>>>>>>>        String sPath sExt
95397>>>>>>>
95397>>>>>>>        Get ParseFolderName sName to sPath
95398>>>>>>>        If (sPath <> "") Begin
95400>>>>>>>            Move (Replace(sPath, sName, "")) to sName
95401>>>>>>>        End
95401>>>>>>>>
95401>>>>>>>        Get ParseFileExtension sName to sExt
95402>>>>>>>        If (sExt <> "") Begin
95404>>>>>>>            Move (Replace(("." + sExt), sName, "")) to sName
95405>>>>>>>        End
95405>>>>>>>>
95405>>>>>>>
95405>>>>>>>        Function_Return sName
95406>>>>>>>    End_Function
95407>>>>>>>
95407>>>>>>>    // Removes any prefix to a table name.
95407>>>>>>>    // Example mssqldrv:mytable returns mytable
95407>>>>>>>    //         dbo.mytable returns mytable
95407>>>>>>>    Function _TableNoPrefix String sName Returns String
95409>>>>>>>        Integer iPos
95409>>>>>>>
95409>>>>>>>        Move (Pos(":", sName)) to iPos
95410>>>>>>>        If (iPos <> 0) Begin
95412>>>>>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
95413>>>>>>>        End
95413>>>>>>>>
95413>>>>>>>        Move (Pos(".", sName)) to iPos
95414>>>>>>>        If (iPos <> 0) Begin
95416>>>>>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
95417>>>>>>>        End
95417>>>>>>>>
95417>>>>>>>
95417>>>>>>>        Function_Return sName
95418>>>>>>>    End_Function
95419>>>>>>>
95419>>>>>>>    // Returns the first datapath found in the psDataPath property.
95419>>>>>>>    // The returned path always ends with a "\"
95419>>>>>>>    Function psDataPathFirstPart Returns String
95421>>>>>>>        String sDataPath
95421>>>>>>>        Integer iCount
95421>>>>>>>
95421>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
95422>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
95423>>>>>>>        If (iCount > 1) Begin
95425>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
95426>>>>>>>        End
95426>>>>>>>>
95426>>>>>>>        If (sDataPath <> "") Begin
95428>>>>>>>            Get vFolderFormat sDataPath to sDataPath
95429>>>>>>>        End
95429>>>>>>>>
95429>>>>>>>
95429>>>>>>>        Function_Return sDataPath
95430>>>>>>>    End_Function
95431>>>>>>>
95431>>>>>>>    Function psLogTextFileWithPath Returns String
95433>>>>>>>        String sFileName 
95433>>>>>>>        Handle hoLogFile
95433>>>>>>>        Get phoLogFile to hoLogFile
95434>>>>>>>        Get psLogTextFileWithPath of hoLogFile to sFileName
95435>>>>>>>        Function_Return sFileName
95436>>>>>>>    End_Function                     
95437>>>>>>>    
95437>>>>>>>    // *** Property Messages ***
95437>>>>>>>    //
95437>>>>>>>    // These "properties" are settings for the cSQLConnectionHandler class, but have been
95437>>>>>>>    // "duplicated" here so connection properties can be relayed to the ghoSQLConnectionHandler object
95437>>>>>>>    //
95437>>>>>>>
95437>>>>>>>    Function pSQLConnection Returns tSQLConnection
95439>>>>>>>        tSQLConnection SQLConnection
95439>>>>>>>        tSQLConnection SQLConnection
95439>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95441>>>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
95441>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95442>>>>>>>>
95442>>>>>>>            Function_Return
95443>>>>>>>        End
95443>>>>>>>>
95443>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
95444>>>>>>>        Function_Return SQLConnection
95445>>>>>>>    End_Function
95446>>>>>>>
95446>>>>>>>    // * Dummy function for the Studio's Code Explorer *
95446>>>>>>>    Function OTHER_CLASS_PROPERTIES Returns Boolean
95448>>>>>>>        Function_Return False
95449>>>>>>>    End_Function
95450>>>>>>>
95450>>>>>>>    Procedure Set psServer String sValue
95452>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95454>>>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
95454>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95455>>>>>>>>
95455>>>>>>>            Procedure_Return
95456>>>>>>>        End
95456>>>>>>>>
95456>>>>>>>        Set psServer of ghoSQLConnectionHandler to sValue
95457>>>>>>>    End_Procedure
95458>>>>>>>
95458>>>>>>>    Function psServer Returns String
95460>>>>>>>        String sValue
95460>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95462>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95463>>>>>>>>
95463>>>>>>>            Function_Return
95464>>>>>>>        End
95464>>>>>>>>
95464>>>>>>>        Get psServer of ghoSQLConnectionHandler to sValue
95465>>>>>>>        Function_Return sValue
95466>>>>>>>    End_Function
95467>>>>>>>
95467>>>>>>>    Procedure Set psDatabase String sValue
95469>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95471>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95472>>>>>>>>
95472>>>>>>>            Procedure_Return
95473>>>>>>>        End
95473>>>>>>>>
95473>>>>>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
95474>>>>>>>    End_Procedure
95475>>>>>>>
95475>>>>>>>    Function psDatabase Returns String
95477>>>>>>>        String sValue
95477>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95479>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95480>>>>>>>>
95480>>>>>>>            Function_Return
95481>>>>>>>        End
95481>>>>>>>>
95481>>>>>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
95482>>>>>>>        Function_Return sValue
95483>>>>>>>    End_Function
95484>>>>>>>
95484>>>>>>>    Procedure Set psUserID String sValue
95486>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95488>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95489>>>>>>>>
95489>>>>>>>            Function_Return
95490>>>>>>>        End
95490>>>>>>>>
95490>>>>>>>        Set psUserID of ghoSQLConnectionHandler to sValue
95491>>>>>>>    End_Procedure
95492>>>>>>>
95492>>>>>>>    Function psUserID Returns String
95494>>>>>>>        String sValue
95494>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95496>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95497>>>>>>>>
95497>>>>>>>            Function_Return
95498>>>>>>>        End
95498>>>>>>>>
95498>>>>>>>        Get psUserID of ghoSQLConnectionHandler to sValue
95499>>>>>>>        Function_Return sValue
95500>>>>>>>    End_Function
95501>>>>>>>
95501>>>>>>>    Procedure Set psPassword String sValue
95503>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95505>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95506>>>>>>>>
95506>>>>>>>            Procedure_Return
95507>>>>>>>        End
95507>>>>>>>>
95507>>>>>>>        Set psPassword of ghoSQLConnectionHandler to sValue
95508>>>>>>>    End_Procedure
95509>>>>>>>
95509>>>>>>>    Function psPassword Returns String
95511>>>>>>>        String sValue
95511>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95513>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95514>>>>>>>>
95514>>>>>>>            Function_Return
95515>>>>>>>        End
95515>>>>>>>>
95515>>>>>>>        Get psPassword of ghoSQLConnectionHandler to sValue
95516>>>>>>>        Function_Return sValue
95517>>>>>>>    End_Function
95518>>>>>>>
95518>>>>>>>    Procedure Set pbTrusted Boolean bValue
95520>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95522>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95523>>>>>>>>
95523>>>>>>>            Procedure_Return
95524>>>>>>>        End
95524>>>>>>>>
95524>>>>>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
95525>>>>>>>    End_Procedure
95526>>>>>>>
95526>>>>>>>    Function pbTrusted Returns Boolean
95528>>>>>>>        Boolean bValue
95528>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95530>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95531>>>>>>>>
95531>>>>>>>            Function_Return
95532>>>>>>>        End
95532>>>>>>>>
95532>>>>>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
95533>>>>>>>        Function_Return bValue
95534>>>>>>>    End_Function
95535>>>>>>>
95535>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
95537>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95539>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95540>>>>>>>>
95540>>>>>>>            Procedure_Return
95541>>>>>>>        End
95541>>>>>>>>
95541>>>>>>>        Set pbSilentLogin of ghoSQLConnectionHandler to bValue
95542>>>>>>>    End_Procedure
95543>>>>>>>
95543>>>>>>>    Function pbSilentLogin Returns Boolean
95545>>>>>>>        Boolean bValue
95545>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95547>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95548>>>>>>>>
95548>>>>>>>            Function_Return
95549>>>>>>>        End
95549>>>>>>>>
95549>>>>>>>        Get pbSilentLogin of ghoSQLConnectionHandler to bValue
95550>>>>>>>        Function_Return bValue
95551>>>>>>>    End_Function
95552>>>>>>>
95552>>>>>>>    Procedure Set psConnectionID String sValue
95554>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95556>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95557>>>>>>>>
95557>>>>>>>            Procedure_Return
95558>>>>>>>        End
95558>>>>>>>>
95558>>>>>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
95559>>>>>>>    End_Procedure
95560>>>>>>>
95560>>>>>>>    Function psConnectionID Returns String
95562>>>>>>>        String sValue
95562>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95564>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95565>>>>>>>>
95565>>>>>>>            Function_Return
95566>>>>>>>        End
95566>>>>>>>>
95566>>>>>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
95567>>>>>>>        Function_Return sValue
95568>>>>>>>    End_Function
95569>>>>>>>
95569>>>>>>>    Procedure Set psConnectionString String sValue
95571>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95573>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95574>>>>>>>>
95574>>>>>>>            Procedure_Return
95575>>>>>>>        End
95575>>>>>>>>
95575>>>>>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
95576>>>>>>>    End_Procedure
95577>>>>>>>
95577>>>>>>>    Function psConnectionString Returns String
95579>>>>>>>        String sValue
95579>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95581>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95582>>>>>>>>
95582>>>>>>>            Function_Return
95583>>>>>>>        End
95583>>>>>>>>
95583>>>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
95584>>>>>>>        Function_Return sValue
95585>>>>>>>    End_Function
95586>>>>>>>
95586>>>>>>>    // The normal connection string looks something like this;
95586>>>>>>>    // SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
95586>>>>>>>    // ...and the full connection string looks like this;
95586>>>>>>>    // DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
95586>>>>>>>    Function psFullConnectionString Returns String
95588>>>>>>>        String sConnectionID sConnectionString
95588>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95590>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95591>>>>>>>>
95591>>>>>>>            Function_Return
95592>>>>>>>        End
95592>>>>>>>>
95592>>>>>>>        Get psConnectionID     of ghoSQLConnectionHandler to sConnectionID
95593>>>>>>>        Move (Trim(sConnectionID)) to sConnectionID
95594>>>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sConnectionString
95595>>>>>>>        Function_Return (CS_SQLConnectionIDText * sConnectionID + "," * String(sConnectionString))
95596>>>>>>>    End_Function
95597>>>>>>>
95597>>>>>>>    Function piConnectionOptions Returns Integer
95599>>>>>>>        Integer iValue
95599>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95601>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95602>>>>>>>>
95602>>>>>>>            Function_Return
95603>>>>>>>        End
95603>>>>>>>>
95603>>>>>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
95604>>>>>>>        Function_Return iValue
95605>>>>>>>    End_Function
95606>>>>>>>
95606>>>>>>>    Procedure Set psSchema String sValue
95608>>>>>>>        tSQLConnection SQLConnection
95608>>>>>>>        tSQLConnection SQLConnection
95608>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95610>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95611>>>>>>>>
95611>>>>>>>            Procedure_Return
95612>>>>>>>        End
95612>>>>>>>>
95612>>>>>>>        Set psSchema of ghoSQLConnectionHandler to sValue
95613>>>>>>>    End_Procedure
95614>>>>>>>
95614>>>>>>>    Function psSchema Returns String
95616>>>>>>>        String sRetval
95616>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95618>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95619>>>>>>>>
95619>>>>>>>            Function_Return
95620>>>>>>>        End
95620>>>>>>>>
95620>>>>>>>        Get psSchema of ghoSQLConnectionHandler to sRetval
95621>>>>>>>        Function_Return sRetval
95622>>>>>>>    End_Function
95623>>>>>>>
95623>>>>>>>    Procedure Set psBaseTableSpace String sValue
95625>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95627>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95628>>>>>>>>
95628>>>>>>>            Procedure_Return
95629>>>>>>>        End
95629>>>>>>>>
95629>>>>>>>        Set psBaseTableSpace of ghoSQLConnectionHandler to sValue
95630>>>>>>>    End_Procedure
95631>>>>>>>
95631>>>>>>>    Function psBaseTableSpace Returns String
95633>>>>>>>        String sRetval
95633>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95635>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95636>>>>>>>>
95636>>>>>>>            Function_Return
95637>>>>>>>        End
95637>>>>>>>>
95637>>>>>>>        Get psBaseTableSpace of ghoSQLConnectionHandler to sRetval
95638>>>>>>>        Function_Return sRetval
95639>>>>>>>    End_Function
95640>>>>>>>
95640>>>>>>>    Procedure Set psLongTableSpace String sValue
95642>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95644>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95645>>>>>>>>
95645>>>>>>>            Procedure_Return
95646>>>>>>>        End
95646>>>>>>>>
95646>>>>>>>        Set psLongTableSpace of ghoSQLConnectionHandler to sValue
95647>>>>>>>    End_Procedure
95648>>>>>>>
95648>>>>>>>    Function psLongTableSpace Returns String
95650>>>>>>>        String sRetval
95650>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95652>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95653>>>>>>>>
95653>>>>>>>            Function_Return
95654>>>>>>>        End
95654>>>>>>>>
95654>>>>>>>        Get psLongTableSpace of ghoSQLConnectionHandler to sRetval
95655>>>>>>>        Function_Return sRetval
95656>>>>>>>    End_Function
95657>>>>>>>
95657>>>>>>>    Procedure Set psIndexTableSpace String sValue
95659>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95661>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95662>>>>>>>>
95662>>>>>>>            Procedure_Return
95663>>>>>>>        End
95663>>>>>>>>
95663>>>>>>>        Set psIndexTableSpace of ghoSQLConnectionHandler to sValue
95664>>>>>>>    End_Procedure
95665>>>>>>>
95665>>>>>>>    Function psIndexTableSpace Returns String
95667>>>>>>>        String sRetval
95667>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95669>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95670>>>>>>>>
95670>>>>>>>            Function_Return
95671>>>>>>>        End
95671>>>>>>>>
95671>>>>>>>        Get psIndexTableSpace of ghoSQLConnectionHandler to sRetval
95672>>>>>>>        Function_Return sRetval
95673>>>>>>>    End_Function
95674>>>>>>>
95674>>>>>>>    Procedure Set pbUseConnectionID Boolean bState
95676>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95678>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95679>>>>>>>>
95679>>>>>>>            Procedure_Return
95680>>>>>>>        End
95680>>>>>>>>
95680>>>>>>>        Set pbUseConnectionID of ghoSQLConnectionHandler to bState
95681>>>>>>>    End_Procedure
95682>>>>>>>
95682>>>>>>>    Function pbUseConnectionID Returns Boolean
95684>>>>>>>        Boolean bState
95684>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95686>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95687>>>>>>>>
95687>>>>>>>            Function_Return
95688>>>>>>>        End
95688>>>>>>>>
95688>>>>>>>        Get pbUseConnectionID of ghoSQLConnectionHandler to bState
95689>>>>>>>        Function_Return bState
95690>>>>>>>    End_Function
95691>>>>>>>
95691>>>>>>>    Procedure Set pbToANSI Boolean bState
95693>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95695>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95696>>>>>>>>
95696>>>>>>>            Procedure_Return
95697>>>>>>>        End
95697>>>>>>>>
95697>>>>>>>        Set pbToANSI of ghoSQLConnectionHandler to bState
95698>>>>>>>    End_Procedure
95699>>>>>>>
95699>>>>>>>    Function pbToANSI Returns Boolean
95701>>>>>>>        Boolean bState
95701>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95703>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95704>>>>>>>>
95704>>>>>>>            Function_Return
95705>>>>>>>        End
95705>>>>>>>>
95705>>>>>>>        Get pbToANSI of ghoSQLConnectionHandler to bState
95706>>>>>>>        Function_Return bState
95707>>>>>>>    End_Function
95708>>>>>>>
95708>>>>>>>    Procedure Set pbRecnum Boolean bState
95710>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95712>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95713>>>>>>>>
95713>>>>>>>            Procedure_Return
95714>>>>>>>        End
95714>>>>>>>>
95714>>>>>>>        Set pbRecnum of ghoSQLConnectionHandler to bState
95715>>>>>>>    End_Procedure
95716>>>>>>>
95716>>>>>>>    Function pbRecnum Returns Boolean
95718>>>>>>>        Boolean bState
95718>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95720>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95721>>>>>>>>
95721>>>>>>>            Function_Return
95722>>>>>>>        End
95722>>>>>>>>
95722>>>>>>>        Get pbRecnum of ghoSQLConnectionHandler to bState
95723>>>>>>>        Function_Return bState
95724>>>>>>>    End_Function
95725>>>>>>>
95725>>>>>>>    Procedure Set pbCopyData Boolean bState
95727>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95729>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95730>>>>>>>>
95730>>>>>>>            Procedure_Return
95731>>>>>>>        End
95731>>>>>>>>
95731>>>>>>>        Set pbCopyData of ghoSQLConnectionHandler to bState
95732>>>>>>>    End_Procedure
95733>>>>>>>
95733>>>>>>>    Function pbCopyData Returns Boolean
95735>>>>>>>        Boolean bState
95735>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95737>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95738>>>>>>>>
95738>>>>>>>            Function_Return
95739>>>>>>>        End
95739>>>>>>>>
95739>>>>>>>        Get pbCopyData of ghoSQLConnectionHandler to bState
95740>>>>>>>        Function_Return bState
95741>>>>>>>    End_Function
95742>>>>>>>
95742>>>>>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
95744>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95746>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95747>>>>>>>>
95747>>>>>>>            Procedure_Return
95748>>>>>>>        End
95748>>>>>>>>
95748>>>>>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
95749>>>>>>>    End_Procedure
95750>>>>>>>
95750>>>>>>>    Function pbApiTableUpdateAuto Returns Boolean
95752>>>>>>>        Boolean bState
95752>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95754>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95755>>>>>>>>
95755>>>>>>>            Function_Return
95756>>>>>>>        End
95756>>>>>>>>
95756>>>>>>>        Get pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
95757>>>>>>>        Function_Return bState
95758>>>>>>>    End_Function
95759>>>>>>>
95759>>>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
95761>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95763>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95764>>>>>>>>
95764>>>>>>>            Procedure_Return
95765>>>>>>>        End
95765>>>>>>>>
95765>>>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
95766>>>>>>>    End_Procedure
95767>>>>>>>
95767>>>>>>>    Function pbCompareDate_DateTime Returns Boolean
95769>>>>>>>        Boolean bState
95769>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95771>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95772>>>>>>>>
95772>>>>>>>            Function_Return
95773>>>>>>>        End
95773>>>>>>>>
95773>>>>>>>        Get pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
95774>>>>>>>        Function_Return bState
95775>>>>>>>    End_Function
95776>>>>>>>
95776>>>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
95778>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95780>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95781>>>>>>>>
95781>>>>>>>            Procedure_Return
95782>>>>>>>        End
95782>>>>>>>>
95782>>>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
95783>>>>>>>    End_Procedure
95784>>>>>>>
95784>>>>>>>    Function pbCompareIndexAscending Returns Boolean
95786>>>>>>>        Boolean bState
95786>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95788>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95789>>>>>>>>
95789>>>>>>>            Function_Return
95790>>>>>>>        End
95790>>>>>>>>
95790>>>>>>>        Get pbCompareIndexAscending of ghoSQLConnectionHandler to bState
95791>>>>>>>        Function_Return bState
95792>>>>>>>    End_Function
95793>>>>>>>
95793>>>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
95795>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95797>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95798>>>>>>>>
95798>>>>>>>            Procedure_Return
95799>>>>>>>        End
95799>>>>>>>>
95799>>>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
95800>>>>>>>    End_Procedure
95801>>>>>>>
95801>>>>>>>    Function pbCompareIndexUppercase Returns Boolean
95803>>>>>>>        Boolean bState
95803>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95805>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95806>>>>>>>>
95806>>>>>>>            Function_Return
95807>>>>>>>        End
95807>>>>>>>>
95807>>>>>>>        Get pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
95808>>>>>>>        Function_Return bState
95809>>>>>>>    End_Function
95810>>>>>>>
95810>>>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
95812>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95814>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95815>>>>>>>>
95815>>>>>>>            Procedure_Return
95816>>>>>>>        End
95816>>>>>>>>
95816>>>>>>>        Set psDriverDefaultValueASCII of ghoSQLConnectionHandler to sValue
95817>>>>>>>    End_Procedure
95818>>>>>>>
95818>>>>>>>    Function psDriverDefaultValueASCII Returns String
95820>>>>>>>        String sRetval
95820>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95822>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95823>>>>>>>>
95823>>>>>>>            Function_Return
95824>>>>>>>        End
95824>>>>>>>>
95824>>>>>>>        Get psDriverDefaultValueASCII of ghoSQLConnectionHandler to sRetval
95825>>>>>>>        Function_Return sRetval
95826>>>>>>>    End_Function
95827>>>>>>>
95827>>>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
95829>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95831>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95832>>>>>>>>
95832>>>>>>>            Procedure_Return
95833>>>>>>>        End
95833>>>>>>>>
95833>>>>>>>        Set psDriverDefaultValueBinary of ghoSQLConnectionHandler to sValue
95834>>>>>>>    End_Procedure
95835>>>>>>>
95835>>>>>>>    Function psDriverDefaultValueBinary Returns String
95837>>>>>>>        String sRetval
95837>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95839>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95840>>>>>>>>
95840>>>>>>>            Function_Return
95841>>>>>>>        End
95841>>>>>>>>
95841>>>>>>>        Get psDriverDefaultValueBinary of ghoSQLConnectionHandler to sRetval
95842>>>>>>>        Function_Return sRetval
95843>>>>>>>    End_Function
95844>>>>>>>
95844>>>>>>>    Procedure Set psDriverDefaultValueDate String sValue
95846>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95848>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95849>>>>>>>>
95849>>>>>>>            Procedure_Return
95850>>>>>>>        End
95850>>>>>>>>
95850>>>>>>>        Set psDriverDefaultValueDate of ghoSQLConnectionHandler to sValue
95851>>>>>>>    End_Procedure
95852>>>>>>>
95852>>>>>>>    Function psDriverDefaultValueDate Returns String
95854>>>>>>>        String sRetval
95854>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95856>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95857>>>>>>>>
95857>>>>>>>            Function_Return
95858>>>>>>>        End
95858>>>>>>>>
95858>>>>>>>        Get psDriverDefaultValueDate of ghoSQLConnectionHandler to sRetval
95859>>>>>>>        Function_Return sRetval
95860>>>>>>>    End_Function
95861>>>>>>>
95861>>>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
95863>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95865>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95866>>>>>>>>
95866>>>>>>>            Procedure_Return
95867>>>>>>>        End
95867>>>>>>>>
95867>>>>>>>        Set psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sValue
95868>>>>>>>    End_Procedure
95869>>>>>>>
95869>>>>>>>    Function psDriverDefaultValueDateTime Returns String
95871>>>>>>>        String sRetval
95871>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95873>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95874>>>>>>>>
95874>>>>>>>            Function_Return
95875>>>>>>>        End
95875>>>>>>>>
95875>>>>>>>        Get psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sRetval
95876>>>>>>>        Function_Return sRetval
95877>>>>>>>    End_Function
95878>>>>>>>
95878>>>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
95880>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95882>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95883>>>>>>>>
95883>>>>>>>            Procedure_Return
95884>>>>>>>        End
95884>>>>>>>>
95884>>>>>>>        Set psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sValue
95885>>>>>>>    End_Procedure
95886>>>>>>>
95886>>>>>>>    Function psDriverDefaultValueNumeric Returns String
95888>>>>>>>        String sRetval
95888>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95890>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95891>>>>>>>>
95891>>>>>>>            Function_Return
95892>>>>>>>        End
95892>>>>>>>>
95892>>>>>>>        Get psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sRetval
95893>>>>>>>        Function_Return sRetval
95894>>>>>>>    End_Function
95895>>>>>>>
95895>>>>>>>    Procedure Set psDriverDefaultValueText String sValue
95897>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95899>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95900>>>>>>>>
95900>>>>>>>            Procedure_Return
95901>>>>>>>        End
95901>>>>>>>>
95901>>>>>>>        Set psDriverDefaultValueText of ghoSQLConnectionHandler to sValue
95902>>>>>>>    End_Procedure
95903>>>>>>>
95903>>>>>>>    Function psDriverDefaultValueText Returns String
95905>>>>>>>        String sRetval
95905>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95907>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95908>>>>>>>>
95908>>>>>>>            Function_Return
95909>>>>>>>        End
95909>>>>>>>>
95909>>>>>>>        Get psDriverDefaultValueText of ghoSQLConnectionHandler to sRetval
95910>>>>>>>        Function_Return sRetval
95911>>>>>>>    End_Function
95912>>>>>>>
95912>>>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
95914>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95916>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95917>>>>>>>>
95917>>>>>>>            Procedure_Return
95918>>>>>>>        End
95918>>>>>>>>
95918>>>>>>>        Set pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
95919>>>>>>>    End_Procedure
95920>>>>>>>
95920>>>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
95922>>>>>>>        Boolean bState
95922>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95924>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95925>>>>>>>>
95925>>>>>>>            Function_Return
95926>>>>>>>        End
95926>>>>>>>>
95926>>>>>>>        Get pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
95927>>>>>>>        Function_Return bState
95928>>>>>>>    End_Function
95929>>>>>>>
95929>>>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
95931>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95933>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95934>>>>>>>>
95934>>>>>>>            Procedure_Return
95935>>>>>>>        End
95935>>>>>>>>
95935>>>>>>>        Set pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
95936>>>>>>>    End_Procedure
95937>>>>>>>
95937>>>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
95939>>>>>>>        Boolean bState
95939>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95941>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95942>>>>>>>>
95942>>>>>>>            Function_Return
95943>>>>>>>        End
95943>>>>>>>>
95943>>>>>>>        Get pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
95944>>>>>>>        Function_Return bState
95945>>>>>>>    End_Function
95946>>>>>>>
95946>>>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
95948>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95950>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95951>>>>>>>>
95951>>>>>>>            Procedure_Return
95952>>>>>>>        End
95952>>>>>>>>
95952>>>>>>>        Set pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
95953>>>>>>>    End_Procedure
95954>>>>>>>
95954>>>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
95956>>>>>>>        Boolean bState
95956>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95958>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95959>>>>>>>>
95959>>>>>>>            Function_Return
95960>>>>>>>        End
95960>>>>>>>>
95960>>>>>>>        Get pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
95961>>>>>>>        Function_Return bState
95962>>>>>>>    End_Function
95963>>>>>>>
95963>>>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
95965>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95967>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95968>>>>>>>>
95968>>>>>>>            Procedure_Return
95969>>>>>>>        End
95969>>>>>>>>
95969>>>>>>>        Set pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
95970>>>>>>>    End_Procedure
95971>>>>>>>
95971>>>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
95973>>>>>>>        Boolean bState
95973>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95975>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95976>>>>>>>>
95976>>>>>>>            Function_Return
95977>>>>>>>        End
95977>>>>>>>>
95977>>>>>>>        Get pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
95978>>>>>>>        Function_Return bState
95979>>>>>>>    End_Function
95980>>>>>>>
95980>>>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
95982>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95984>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95985>>>>>>>>
95985>>>>>>>            Procedure_Return
95986>>>>>>>        End
95986>>>>>>>>
95986>>>>>>>        Set pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
95987>>>>>>>    End_Procedure
95988>>>>>>>
95988>>>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
95990>>>>>>>        Boolean bState
95990>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95992>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95993>>>>>>>>
95993>>>>>>>            Function_Return
95994>>>>>>>        End
95994>>>>>>>>
95994>>>>>>>        Get pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
95995>>>>>>>        Function_Return bState
95996>>>>>>>    End_Function
95997>>>>>>>
95997>>>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
95999>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
96001>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
96002>>>>>>>>
96002>>>>>>>            Procedure_Return
96003>>>>>>>        End
96003>>>>>>>>
96003>>>>>>>        Set pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
96004>>>>>>>    End_Procedure
96005>>>>>>>
96005>>>>>>>    Function pbDriverDefaultNullableText Returns Boolean
96007>>>>>>>        Boolean bState
96007>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
96009>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
96010>>>>>>>>
96010>>>>>>>            Function_Return
96011>>>>>>>        End
96011>>>>>>>>
96011>>>>>>>        Get pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
96012>>>>>>>        Function_Return bState
96013>>>>>>>    End_Function
96014>>>>>>>
96014>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
96014>>>>>>>    //       the psDriverID *must* be the first property that gets changed!
96014>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
96014>>>>>>>    //       for a connection string has the wrong format for that driver.
96014>>>>>>>    Procedure Set psDriverID String sValue
96016>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96017>>>>>>>        Delegate Set psDriverID to sValue
96019>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96020>>>>>>>        Set psDriverID of ghoSQLConnectionHandler to sValue
96021>>>>>>>    End_Procedure
96022>>>>>>>
96022>>>>>>>    Function psDriverID Returns String
96024>>>>>>>        String sDriverID
96024>>>>>>>
96024>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96025>>>>>>>        // This should get it from the parent object (when using the cDbUpdateHandler class)
96025>>>>>>>        Delegate Get psDriverID to sDriverID
96027>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96028>>>>>>>        Move False to Err
96029>>>>>>>
96029>>>>>>>        // ...and in case it didn't use property of this class. Then the library is
96029>>>>>>>        // probably used as "utilites" from a special made program and
96029>>>>>>>        // the ghoSQLConnectionHandler must have been setup
96029>>>>>>>        If (sDriverID = "") Begin
96031>>>>>>>            Get psDriverID of ghoSQLConnectionHandler to sDriverID
96032>>>>>>>        End
96032>>>>>>>>
96032>>>>>>>        Function_Return sDriverID
96033>>>>>>>    End_Function
96034>>>>>>>
96034>>>>>>>    Procedure Set piDbType Integer iValue
96036>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96037>>>>>>>        Delegate Set piDbType to iValue
96039>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96040>>>>>>>        Set piDbType of ghoSQLConnectionHandler to iValue
96041>>>>>>>    End_Procedure
96042>>>>>>>
96042>>>>>>>    Function piDbType Returns String
96044>>>>>>>        Integer iRetval
96044>>>>>>>
96044>>>>>>>//        Move False to Err
96044>>>>>>>//        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96044>>>>>>>        // This should get it from the parent object (when using the cDbUpdateHandler class)
96044>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
96044>>>>>>>//        Delegate Get piDbType to iRetval
96044>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
96044>>>>>>>//        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96044>>>>>>>
96044>>>>>>>        // ...and in case it didn't use property of this class. Then the library is
96044>>>>>>>        // probably used as "utilites" from a special made program and
96044>>>>>>>        // the ghoSQLConnectionHandler must have been setup
96044>>>>>>>//        If (Err = True) Begin
96044>>>>>>>            Get piDbType of ghoSQLConnectionHandler to iRetval
96045>>>>>>>//        End
96045>>>>>>>
96045>>>>>>>//        Move False to Err
96045>>>>>>>        Function_Return iRetval
96046>>>>>>>    End_Function
96047>>>>>>>
96047>>>>>>>    Function phoLogFile Returns Handle
96049>>>>>>>        Handle hoLogFile
96049>>>>>>>
96049>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
96050>>>>>>>        Delegate Get phoLogFile to hoLogFile
96052>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
96053>>>>>>>
96053>>>>>>>        Function_Return hoLogFile
96054>>>>>>>    End_Function
96055>>>>>>>
96055>>>>>>>    Function pnCurrentVersionUpdate Returns Number
96057>>>>>>>        Number nCurrentVersionUpdate
96057>>>>>>>
96057>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
96058>>>>>>>        Delegate Get pnCurrentVersionUpdate to nCurrentVersionUpdate
96060>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
96061>>>>>>>
96061>>>>>>>        Function_Return nCurrentVersionUpdate
96062>>>>>>>    End_Function
96063>>>>>>>
96063>>>>>>>    Procedure LogError String sText Boolean bError
96065>>>>>>>        Handle hoLogFile
96065>>>>>>>        Number nCurrentVersionUpdate
96065>>>>>>>
96065>>>>>>>        Get phoLogFile to hoLogFile
96066>>>>>>>        If (hoLogFile = 0) Begin
96068>>>>>>>            Procedure_Return
96069>>>>>>>        End
96069>>>>>>>>
96069>>>>>>>        Get pnCurrentVersionUpdate to nCurrentVersionUpdate
96070>>>>>>>
96070>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
96071>>>>>>>        Send LogError of hoLogFile nCurrentVersionUpdate 0 sText 0 bError
96072>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
96073>>>>>>>    End_Procedure
96074>>>>>>>
96074>>>>>>>    Function pbContinueOnError Returns Boolean
96076>>>>>>>        Boolean bContinueOnError
96076>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
96078>>>>>>>            Get pbContinueOnError of ghoDbUpdateHandler to bContinueOnError
96079>>>>>>>        End
96079>>>>>>>>
96079>>>>>>>        Function_Return bContinueOnError
96080>>>>>>>    End_Function
96081>>>>>>>
96081>>>>>>>    Function psCollation Returns String
96083>>>>>>>        String sCollation
96083>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
96085>>>>>>>            Get psCollation of ghoDbUpdateHandler to sCollation
96086>>>>>>>        End
96086>>>>>>>>
96086>>>>>>>        Function_Return sCollation
96087>>>>>>>    End_Function
96088>>>>>>>
96088>>>>>>>
96088>>>>>>>    Function StrToFieldNumber Integer iFile String sField Returns Integer
96090>>>>>>>        Integer iMax iPos
96090>>>>>>>        String sName
96090>>>>>>>
96090>>>>>>>        Move (Lowercase(sField)) to sField
96091>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iMax
96094>>>>>>>        for iPos from 0 to iMax
96100>>>>>>>>
96100>>>>>>>            Get_Attribute DF_FIELD_NAME of iFile iPos to sName
96103>>>>>>>            Move (Lowercase(sName)) to sName
96104>>>>>>>            If (sName = sField) Begin
96106>>>>>>>                Function_Return iPos
96107>>>>>>>            End
96107>>>>>>>>
96107>>>>>>>        Loop
96108>>>>>>>>
96108>>>>>>>        Function_Return -1
96109>>>>>>>    End_Function
96110>>>>>>>
96110>>>>>>>
96110>>>>>>>    // * Dummy function for the Studio's Code Explorer *
96110>>>>>>>    Function PRIVATE_SUB_FUNCTIONS Returns Boolean
96112>>>>>>>        Function_Return False
96113>>>>>>>    End_Function
96114>>>>>>>
96114>>>>>>>    // When dropping columns on some SQL back-ends they doesn't reclaim the space taken up by the columns dropped.
96114>>>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
96114>>>>>>>    // the new rows added after the alter statement. to get around this you need to create a clustered
96114>>>>>>>    // index on the table _or_ rebuild the clustered Index if it already has one. Rebuilding the index
96114>>>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
96114>>>>>>>    //   ALTER TABLE MyTable
96114>>>>>>>    //       REBUILD
96114>>>>>>>    Function _SqlUtilRemoveTableColumnMSSQL String sTableName String sColumnName Returns Boolean
96116>>>>>>>        Boolean bOK
96116>>>>>>>
96116>>>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
96118>>>>>>>            Function_Return False
96119>>>>>>>        End
96119>>>>>>>>
96119>>>>>>>
96119>>>>>>>        SQLIncludeScriptFile ..\Scripts\DropConstraintAndColumnNameMSSQL.sql as DropConstraintAndColumnNameMSSQL.sql
96119>>>>>>>        Get _SqlUtilRemoveTableColumnByScript "DropConstraintAndColumnNameMSSQL.sql" sTableName sColumnName to bOK
96120>>>>>>>
96120>>>>>>>        Function_Return (bOK = True)
96121>>>>>>>    End_Function
96122>>>>>>>
96122>>>>>>>
96122>>>>>>>    // *** Helper functions with compiled sql script code ***
96122>>>>>>>    //
96122>>>>>>>    // When dropping columns SQL Sever does not reclaim the space taken up by the columns dropped.
96122>>>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
96122>>>>>>>    // the new rows added after the alter statement. To get around this you need to create a clustered
96122>>>>>>>    // index on the table or rebuild the clustered Index if it already has one. Rebuilding the index
96122>>>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
96122>>>>>>>    //   ALTER TABLE MyTable
96122>>>>>>>    //       REBUILD
96122>>>>>>>    Function _SqlUtilRemoveTableColumnByScript String sMemScriptFile String sTableName String sColumnName Returns Boolean
96124>>>>>>>        tSQLScriptArray SQLScriptArray
96124>>>>>>>        tSQLScriptArray SQLScriptArray
96124>>>>>>>        String sDriverID
96124>>>>>>>        Boolean bOK
96124>>>>>>>        Integer iSize iCount
96124>>>>>>>
96124>>>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
96126>>>>>>>            Function_Return False
96127>>>>>>>        End
96127>>>>>>>>
96127>>>>>>>
96127>>>>>>>        Get psDriverID to sDriverID
96128>>>>>>>        Get SqlUtilReadResource sMemScriptFile to SQLScriptArray
96129>>>>>>>        If (SQLScriptArray.bError = True) Begin
96131>>>>>>>            Function_Return False
96132>>>>>>>        End
96132>>>>>>>>
96132>>>>>>>
96132>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
96133>>>>>>>        Decrement iSize
96134>>>>>>>
96134>>>>>>>        for iCount from 0 to iSize
96140>>>>>>>>
96140>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "TABLE_NAME_XXX") Begin
96142>>>>>>>                Move (Replaces("TABLE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sTableName))) to SQLScriptArray.sSQLScriptArray[iCount]
96143>>>>>>>            End
96143>>>>>>>>
96143>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLUMN_NAME_XXX") Begin
96145>>>>>>>                Move (Replaces("COLUMN_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sColumnName))) to SQLScriptArray.sSQLScriptArray[iCount]
96146>>>>>>>            End
96146>>>>>>>>
96146>>>>>>>        Loop
96147>>>>>>>>
96147>>>>>>>
96147>>>>>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
96148>>>>>>>
96148>>>>>>>        Function_Return (bOK = True)
96149>>>>>>>    End_Function
96150>>>>>>>
96150>>>>>>>    // *** Helper functions for Mertech Drivers ***
96150>>>>>>>    // Created to not clutter up the standard function code with lots of #IFDEF's
96150>>>>>>>    // and commands that the Studio editor knows nothing about.
96150>>>>>>>    Function _MertechDeleteTDFile String sTableName Returns Integer
96152>>>>>>>        Integer iRetval
96152>>>>>>>        String sPath
96152>>>>>>>
96152>>>>>>>        If (sPath = "" or sTableName = "") Begin
96154>>>>>>>            Function_Return 0
96155>>>>>>>        End
96155>>>>>>>>
96155>>>>>>>
96155>>>>>>>        Get vFolderFormat sPath to sPath
96156>>>>>>>        Get vDeleteFile (sPath + String(sTableName) + ".td") to iRetval
96157>>>>>>>        Function_Return iRetval
96158>>>>>>>    End_Function
96159>>>>>>>
96159>>>>>>>    Function _MertechSqlUtilCreateIntFile Handle hTable String sDataPath String sPhysicalFileName Returns Boolean
96161>>>>>>>        Move False to Err
96162>>>>>>>        Function_Return (Err = False)
96163>>>>>>>    End_Function
96164>>>>>>>
96164>>>>>>>    Function _MertechEnumerateSQLFlexServers Returns String[]
96166>>>>>>>        Integer iNumItems iCount
96166>>>>>>>        String[] sReturnArray
96167>>>>>>>        String sServer
96167>>>>>>>
96167>>>>>>>
96167>>>>>>>        Function_Return sReturnArray
96168>>>>>>>    End_Function
96169>>>>>>>
96169>>>>>>>    Function _MertechEnumerateORAFLEXServers Returns String[]
96171>>>>>>>        String[] sReturnArray
96172>>>>>>>        String sServer
96172>>>>>>>
96172>>>>>>>
96172>>>>>>>        Function_Return sReturnArray
96173>>>>>>>    End_Function
96174>>>>>>>
96174>>>>>>>    Function _MertechSQLConnect String sDriverID String sServer String sUserID String sPassword Returns Handle
96176>>>>>>>        Handle hoSQLHandler hoSQLConnect
96176>>>>>>>
96176>>>>>>>        Move 0 to hoSQLConnect
96177>>>>>>>
96177>>>>>>>        Function_Return hoSQLConnect
96178>>>>>>>    End_Function
96179>>>>>>>
96179>>>>>>>    // Returns the handle of the Mertech SQL handler.
96179>>>>>>>    // It also ensures that the correct Server & Database attributes are set both for
96179>>>>>>>    // embedded SQL calls and "normal" database commands like e.g. "Open".
96179>>>>>>>    Function _MertechSQLManagerHandle Returns Handle
96181>>>>>>>        Handle hoSQLHandler
96181>>>>>>>        String sDriverID sServer sDatabase
96181>>>>>>>
96181>>>>>>>        Move 0 to hoSQLHandler
96182>>>>>>>        Get psDriverID to sDriverID
96183>>>>>>>        Get psServer   to sServer
96184>>>>>>>        Get psDatabase to sDatabase
96185>>>>>>>
96185>>>>>>>        Function_Return hoSQLHandler
96186>>>>>>>    End_Function
96187>>>>>>>
96187>>>>>>>    // For Mertech drivers we cannot use Structure_Start/End. Instead we must use
96187>>>>>>>    // macro-commands <sigh!>
96187>>>>>>>    // Note: The function sets the Err flag.
96187>>>>>>>    Function _MertechApiTableConvertToSQL Handle hTable String sRootName String sDatabase String sDriverID String sBaseTableSpace String sIndexTableSpace Boolean bCopyData Returns Boolean
96189>>>>>>>        Move False to Err
96190>>>>>>>
96190>>>>>>>
96190>>>>>>>        Function_Return (Err = False)
96191>>>>>>>    End_Function
96192>>>>>>>
96192>>>>>>>End_Class
96193>>>>>Use for_all.pkg // Handy to have available in the OnUpdate event.
Including file: for_all.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\for_all.pkg)
96193>>>>>>>//************************************************************************
96193>>>>>>>//
96193>>>>>>>// Confidential Trade Secret.
96193>>>>>>>// Copyright 1987-1992 Data Access Corporation, Miami FL, USA
96193>>>>>>>// All Rights reserved
96193>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.
96193>>>>>>>//
96193>>>>>>>//
96193>>>>>>>//     $Source: k:\RCS\.\pkg\for_all.pkg,v $
96193>>>>>>>//     $Revision: 1 $
96193>>>>>>>//     $State: Exp $
96193>>>>>>>//     $Author: james $
96193>>>>>>>//     $Date: Jun 05 14:37:09 1995 $
96193>>>>>>>//     $Locker:  $
96193>>>>>>>//
96193>>>>>>>//     $Log: for_all.pkg,v $
96193>>>>>>>//Revision 2.1  1993/08/25  17:48:09  james
96193>>>>>>>//Adding new main branch
96193>>>>>>>//
96193>>>>>>>//Revision 1.2  1993/04/28  00:20:34  james
96193>>>>>>>//Initializing 3.04 source code.
96193>>>>>>>//
96193>>>>>>>//Revision 1.1  1992/09/08  14:43:05  james
96193>>>>>>>//Initial revision
96193>>>>>>>//
96193>>>>>>>//Revision 1.4  92/05/14  16:49:32  SWM
96193>>>>>>>//Updated Copyright slug.
96193>>>>>>>//
96193>>>>>>>//Revision 1.3  92/03/09  19:02:09  james
96193>>>>>>>//Added #CHKSUB directive to insure source
96193>>>>>>>//only compiled with correct revision of
96193>>>>>>>//compiler.
96193>>>>>>>//
96193>>>>>>>//Revision 1.2  92/02/18  20:04:39  steve-l
96193>>>>>>>//altered main command to permit use of file.field instead of index.#
96193>>>>>>>//
96193>>>>>>>//Revision 1.1  91/10/23  10:20:51  elsa
96193>>>>>>>//Initial revision
96193>>>>>>>//
96193>>>>>>>//************************************************************************/
96193>>>>>>>
96193>>>>>>>//************************************************************************
96193>>>>>>>//     File Name: For_All.Pkg
96193>>>>>>>// Creation Date: January 1, 1991
96193>>>>>>>// Modified Date: May 23, 1991
96193>>>>>>>//     Author(s): Steven A. Lowe
96193>>>>>>>//
96193>>>>>>>// This module contains the command definitions for the FOR_ALL construct.
96193>>>>>>>//
96193>>>>>>>// FOR_ALL is used to select and process a set of records in a database file;
96193>>>>>>>// FOR_ALL constructs may be nested. FOR_ALL is intended to work in
96193>>>>>>>// conjunction with constraint-clauses.
96193>>>>>>>//
96193>>>>>>>// SYNTAX:
96193>>>>>>>//
96193>>>>>>>//  For_All <File> BY|DOWN <Index> {AS QUE|QUEUE} {DO}
96193>>>>>>>//    <Constraints...>
96193>>>>>>>//    {DO}
96193>>>>>>>//      <loop body>
96193>>>>>>>//  End_For_All
96193>>>>>>>//
96193>>>>>>>// This set of macros implements a constraint-oriented file enumeration
96193>>>>>>>// syntax.  For example, to list all Customers by name in reverse order:
96193>>>>>>>//
96193>>>>>>>//   For_All Customer DOWN Customer.Customer_Name DO
96193>>>>>>>//     showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
96193>>>>>>>//   End_For_All
96193>>>>>>>//
96193>>>>>>>// To list only Customers with a Balance greater than their credit limit:
96193>>>>>>>//
96193>>>>>>>//   For_All Customer BY Index.1
96193>>>>>>>//     CONSTRAIN Customer.Balance GT Customer.Credit_Limit
96193>>>>>>>//     DO
96193>>>>>>>//       showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
96193>>>>>>>//   End_For_All
96193>>>>>>>//
96193>>>>>>>// Constraint clauses are:
96193>>>>>>>//
96193>>>>>>>//   CONSTRAIN <File> RELATES TO <File> ...
96193>>>>>>>//   CONSTRAIN <File> AS <Expression>
96193>>>>>>>//   CONSTRAIN <File.Field> AS <Expression>
96193>>>>>>>//   CONSTRAIN <File.Field> BETWEEN <lowBound> AND <highBound>
96193>>>>>>>//
96193>>>>>>>// For example, to list all customers with a bad status whose names start
96193>>>>>>>// with "A" and which have not made a payment in thirty days:
96193>>>>>>>//
96193>>>>>>>//    For_All Customer BY Index.2       //Index.2 = <Status>+<Name>
96193>>>>>>>//      CONSTRAIN Customer.Status EQ BAD
96193>>>>>>>//      CONSTRAIN Customer.Customer_Name GE "A"
96193>>>>>>>//      CONSTRAIN Customer.Customer_Name LT "B"
96193>>>>>>>//      CONSTRAIN Customer.Last_Pymt_Date LE (Today - 30)
96193>>>>>>>//      DO
96193>>>>>>>//        showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
96193>>>>>>>//    End_For_All
96193>>>>>>>//
96193>>>>>>>//************************************************************************/
96193>>>>>>>
96193>>>>>>>
96193>>>>>>>
96193>>>>>>>//
96193>>>>>>>//DO
96193>>>>>>>//
96193>>>>>>>//This command starts the loop process body when constraints are used;
96193>>>>>>>//If no constraints are required, DO should be specified on the FOR_ALL
96193>>>>>>>//command line, and not on a line by itself
96193>>>>>>>//
96193>>>>>>>
96193>>>>>>>//
96193>>>>>>>//END_FOR_ALL
96193>>>>>>>//
96193>>>>>>>//Ends a For_All loop
96193>>>>>>>//
96193>>>>>>>
96193>>>>>
96193>>>>>
96193>>>>>
96193>>>>>Class cDbUpdateVersion is a cObject
96194>>>>>
96194>>>>>    Procedure Construct_Object
96196>>>>>        String[] aSQLQueryMessages
96197>>>>>        Forward Send Construct_Object
96199>>>>>
96199>>>>>        // Don't touch! It is used by class logic to indicate if the OnUpdate
96199>>>>>        // event was triggered, thus an actual change of the database was made.
96199>>>>>        Property Boolean pbVersionUpdate False
96200>>>>>
96200>>>>>        // This property must be manually set within each cDbUpdateVersion object
96200>>>>>        // by the programmer, to a consecutive number.
96200>>>>>        Property Number pnVersionNumber
96201>>>>>
96201>>>>>        Property Boolean pbUseConnectionID True
96202>>>>>        Property Boolean private.pbToANSI   True
96203>>>>>        Property Boolean private.pbRecnum   True
96204>>>>>        Property Boolean private.pbCopyData True
96205>>>>>        Property Boolean private.pbApiTableUpdateAuto False
96206>>>>>        Property Boolean private.pbCompareDate_DateTime False
96207>>>>>        Property Boolean private.pbCompareIndexAscending False
96208>>>>>        Property Boolean private.pbCompareIndexUppercase False
96209>>>>>        Property String private.psSchema
96210>>>>>        Property String private.psBaseTableSpace
96211>>>>>        Property String private.psLongTableSpace
96212>>>>>        Property String private.psIndexTableSpace
96213>>>>>
96213>>>>>        // Driver default value settings:
96213>>>>>        Property String private.psDriverDefaultValueASCII    ""
96214>>>>>        Property String private.psDriverDefaultValueBinary   ""
96215>>>>>        Property String private.psDriverDefaultValueDate     ""
96216>>>>>        Property String private.psDriverDefaultValueDateTime ""
96217>>>>>        Property String private.psDriverDefaultValueNumeric  ""
96218>>>>>        Property String private.psDriverDefaultValueText     ""
96219>>>>>
96219>>>>>        // Driver "nullability" settings:
96219>>>>>        Property Boolean private.pbDriverDefaultNullableASCII    False
96220>>>>>        Property Boolean private.pbDriverDefaultNullableBinary   False
96221>>>>>        Property Boolean private.pbDriverDefaultNullableDate     False
96222>>>>>        Property Boolean private.pbDriverDefaultNullableDateTime False
96223>>>>>        Property Boolean private.pbDriverDefaultNullableNumeric  False
96224>>>>>        Property Boolean private.pbDriverDefaultNullableText     False
96225>>>>>
96225>>>>>        // paSQLQueryMessages is a property of the container class cDbUpdateHandler.
96225>>>>>        // It is being used to gather ESQL message replies, and is output to the log file
96225>>>>>        // if pbVerboseState = True in the cDbUpdateHandler object.
96225>>>>>        // (See: Procedure Set pbDatabaseWasUpdated in the cDbUpdateHandler class)
96225>>>>>        // We reset it here for each cDbUpdateVersion object
96225>>>>>        Delegate Set paSQLQueryMessages to aSQLQueryMessages
96227>>>>>    End_Procedure
96228>>>>>
96228>>>>>    // *** Main hook event message ***
96228>>>>>    // Place your database update logic here!
96228>>>>>    Procedure OnUpdate
96230>>>>>    End_Procedure
96231>>>>>
96231>>>>>    // These properties also exists in the cDbUpdateFunctionLibray that is
96231>>>>>    // imported to the cDbUpdateHandler container class which should be a
96231>>>>>    // parent object to this object. To have the Studio's Property Panel
96231>>>>>    // "behave" aka show these properties we need to duplicate them in this
96231>>>>>    // class and "relay" them to the parent object.
96231>>>>>    Procedure Set pbToANSI Boolean bState
96233>>>>>        Set private.pbToANSI  to bState
96234>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96235>>>>>        Delegate Set pbToANSI to bState
96237>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96238>>>>>    End_Procedure
96239>>>>>
96239>>>>>    Function pbToANSI Returns Boolean
96241>>>>>        Function_Return (private.pbToAnsi(Self))
96242>>>>>    End_Function
96243>>>>>
96243>>>>>    Procedure Set pbRecnum Boolean bState
96245>>>>>        Set private.pbRecnum  to bState
96246>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96247>>>>>        Delegate Set pbRecnum to bState
96249>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96250>>>>>    End_Procedure
96251>>>>>
96251>>>>>    Function pbRecnum Returns Boolean
96253>>>>>        Function_Return (private.pbRecnum(Self))
96254>>>>>    End_Function
96255>>>>>
96255>>>>>    Procedure Set pbCopyData Boolean bState
96257>>>>>        Set private.pbCopyData  to bState
96258>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96259>>>>>        Delegate Set pbCopyData to bState
96261>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96262>>>>>    End_Procedure
96263>>>>>
96263>>>>>    Function pbCopyData Returns Boolean
96265>>>>>        Function_Return (private.pbCopyData(Self))
96266>>>>>    End_Function
96267>>>>>
96267>>>>>    // ToDo: Should we put these three properties under another "Property Panel" section?
96267>>>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
96269>>>>>        Set private.pbApiTableUpdateAuto  to bState
96270>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96271>>>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
96272>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96273>>>>>    End_Procedure
96274>>>>>
96274>>>>>    Function pbApiTableUpdateAuto Returns Boolean
96276>>>>>        Function_Return (private.pbApiTableUpdateAuto(Self))
96277>>>>>    End_Function
96278>>>>>
96278>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
96280>>>>>        Set private.pbCompareDate_DateTime  to bState
96281>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96282>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
96283>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96284>>>>>    End_Procedure
96285>>>>>
96285>>>>>    Function pbCompareDate_DateTime Returns Boolean
96287>>>>>        Function_Return (private.pbCompareDate_DateTime(Self))
96288>>>>>    End_Function
96289>>>>>
96289>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
96291>>>>>        Set private.pbCompareIndexAscending  to bState
96292>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96293>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
96294>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96295>>>>>    End_Procedure
96296>>>>>
96296>>>>>    Function pbCompareIndexAscending Returns Boolean
96298>>>>>        Function_Return (private.pbCompareIndexAscending(Self))
96299>>>>>    End_Function
96300>>>>>
96300>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
96302>>>>>        Set private.pbCompareIndexUppercase  to bState
96303>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96304>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
96305>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96306>>>>>    End_Procedure
96307>>>>>
96307>>>>>    Function pbCompareIndexUppercase Returns Boolean
96309>>>>>        Function_Return (private.pbCompareIndexUppercase(Self))
96310>>>>>    End_Function
96311>>>>>
96311>>>>>    Procedure Set psSchema String sValue
96313>>>>>        Set private.psSchema  to sValue
96314>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96315>>>>>        Delegate Set psSchema to sValue
96317>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96318>>>>>    End_Procedure
96319>>>>>
96319>>>>>    // First retrieve the private value that might have been set in the object.
96319>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
96319>>>>>    // it might have been specified in the SQLConnections.ini file.
96319>>>>>    Function psSchema Returns String
96321>>>>>        String sValue
96321>>>>>        Get private.psSchema to sValue
96322>>>>>        If (sValue = "") Begin
96324>>>>>            Get psSchema of ghoSQLConnectionHandler to sValue
96325>>>>>        End
96325>>>>>>
96325>>>>>        Function_Return sValue
96326>>>>>    End_Function
96327>>>>>
96327>>>>>    Procedure Set psBaseTableSpace String sValue
96329>>>>>        Set private.psBaseTableSpace  to sValue
96330>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96331>>>>>        Delegate Set psBaseTableSpace to sValue
96333>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96334>>>>>    End_Procedure
96335>>>>>
96335>>>>>    // First retrieve the private value that might have been set in the object.
96335>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
96335>>>>>    // it might have been specified in the SQLConnections.ini file.
96335>>>>>    Function psBaseTableSpace Returns String
96337>>>>>        String sValue
96337>>>>>        Get private.psBaseTableSpace to sValue
96338>>>>>        If (sValue = "") Begin
96340>>>>>            Get psBaseTableSpace of ghoSQLConnectionHandler to sValue
96341>>>>>        End
96341>>>>>>
96341>>>>>        Function_Return sValue
96342>>>>>    End_Function
96343>>>>>
96343>>>>>    Procedure Set psLongTableSpace String sValue
96345>>>>>        Set private.psLongTableSpace  to sValue
96346>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96347>>>>>        Delegate Set psLongTableSpace to sValue
96349>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96350>>>>>    End_Procedure
96351>>>>>
96351>>>>>    // First retrieve the private value that might have been set in the object.
96351>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
96351>>>>>    // it might have been specified in the SQLConnections.ini file.
96351>>>>>    Function psLongTableSpace Returns String
96353>>>>>        String sValue
96353>>>>>        Get private.psLongTableSpace to sValue
96354>>>>>        If (sValue = "") Begin
96356>>>>>            Get psLongTableSpace of ghoSQLConnectionHandler to sValue
96357>>>>>        End
96357>>>>>>
96357>>>>>        Function_Return sValue
96358>>>>>    End_Function
96359>>>>>
96359>>>>>    Procedure Set psIndexTableSpace String sValue
96361>>>>>        Set private.psIndexTableSpace  to sValue
96362>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96363>>>>>        Delegate Set psIndexTableSpace to sValue
96365>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96366>>>>>    End_Procedure
96367>>>>>
96367>>>>>    // First retrieve the private value that might have been set in the object.
96367>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
96367>>>>>    // it might have been specified in the SQLConnections.ini file.
96367>>>>>    Function psIndexTableSpace Returns String
96369>>>>>        String sValue
96369>>>>>        Get private.psIndexTableSpace to sValue
96370>>>>>        If (sValue = "") Begin
96372>>>>>            Get psIndexTableSpace of ghoSQLConnectionHandler to sValue
96373>>>>>        End
96373>>>>>>
96373>>>>>        Function_Return sValue
96374>>>>>    End_Function
96375>>>>>
96375>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
96377>>>>>        Set private.psDriverDefaultValueASCII  to sValue
96378>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96379>>>>>        Delegate Set psDriverDefaultValueASCII to sValue
96381>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96382>>>>>    End_Procedure
96383>>>>>
96383>>>>>    // First retrieve the private value that might have been set in the object.
96383>>>>>    // If blank; get it from the parent object
96383>>>>>    Function psDriverDefaultValueASCII Returns String
96385>>>>>        String sValue
96385>>>>>        Get private.psDriverDefaultValueASCII to sValue
96386>>>>>        If (sValue = "") Begin
96388>>>>>            Delegate Get psDriverDefaultValueASCII to sValue
96390>>>>>        End
96390>>>>>>
96390>>>>>        Function_Return sValue
96391>>>>>    End_Function
96392>>>>>
96392>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
96394>>>>>        Set private.psDriverDefaultValueBinary  to sValue
96395>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96396>>>>>        Delegate Set psDriverDefaultValueBinary to sValue
96398>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96399>>>>>    End_Procedure
96400>>>>>
96400>>>>>    // First retrieve the private value that might have been set in the object.
96400>>>>>    // If blank; get it from the parent object
96400>>>>>    Function psDriverDefaultValueBinary Returns String
96402>>>>>        String sValue
96402>>>>>        Get private.psDriverDefaultValueBinary to sValue
96403>>>>>        If (sValue = "") Begin
96405>>>>>            Delegate Get psDriverDefaultValueBinary to sValue
96407>>>>>        End
96407>>>>>>
96407>>>>>        Function_Return sValue
96408>>>>>    End_Function
96409>>>>>
96409>>>>>    Procedure Set psDriverDefaultValueDate String sValue
96411>>>>>        Set private.psDriverDefaultValueDate  to sValue
96412>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96413>>>>>        Delegate Set psDriverDefaultValueDate to sValue
96415>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96416>>>>>    End_Procedure
96417>>>>>
96417>>>>>    // First retrieve the private value that might have been set in the object.
96417>>>>>    // If blank; get it from the parent object
96417>>>>>    Function psDriverDefaultValueDate Returns String
96419>>>>>        String sValue
96419>>>>>        Get private.psDriverDefaultValueDate to sValue
96420>>>>>        If (sValue = "") Begin
96422>>>>>            Delegate Get psDriverDefaultValueDate to sValue
96424>>>>>        End
96424>>>>>>
96424>>>>>        Function_Return sValue
96425>>>>>    End_Function
96426>>>>>
96426>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
96428>>>>>        Set private.psDriverDefaultValueDateTime  to sValue
96429>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96430>>>>>        Delegate Set psDriverDefaultValueDateTime to sValue
96432>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96433>>>>>    End_Procedure
96434>>>>>
96434>>>>>    // First retrieve the private value that might have been set in the object.
96434>>>>>    // If blank; get it from the parent object
96434>>>>>    Function psDriverDefaultValueDateTime Returns String
96436>>>>>        String sValue
96436>>>>>        Get private.psDriverDefaultValueDateTime to sValue
96437>>>>>        If (sValue = "") Begin
96439>>>>>            Delegate Get psDriverDefaultValueDateTime to sValue
96441>>>>>        End
96441>>>>>>
96441>>>>>        Function_Return sValue
96442>>>>>    End_Function
96443>>>>>
96443>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
96445>>>>>        Set private.psDriverDefaultValueNumeric  to sValue
96446>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96447>>>>>        Delegate Set psDriverDefaultValueNumeric to sValue
96449>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96450>>>>>    End_Procedure
96451>>>>>
96451>>>>>    // First retrieve the private value that might have been set in the object.
96451>>>>>    // If blank; get it from the parent object
96451>>>>>    Function psDriverDefaultValueNumeric Returns String
96453>>>>>        String sValue
96453>>>>>        Get private.psDriverDefaultValueNumeric to sValue
96454>>>>>        If (sValue = "") Begin
96456>>>>>            Delegate Get psDriverDefaultValueNumeric to sValue
96458>>>>>        End
96458>>>>>>
96458>>>>>        Function_Return sValue
96459>>>>>    End_Function
96460>>>>>
96460>>>>>    Procedure Set psDriverDefaultValueText String sValue
96462>>>>>        Set private.psDriverDefaultValueText  to sValue
96463>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96464>>>>>        Delegate Set psDriverDefaultValueText to sValue
96466>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96467>>>>>    End_Procedure
96468>>>>>
96468>>>>>    // First retrieve the private value that might have been set in the object.
96468>>>>>    // If blank; get it from the parent object
96468>>>>>    Function psDriverDefaultValueText Returns String
96470>>>>>        String sValue
96470>>>>>        Get private.psDriverDefaultValueText to sValue
96471>>>>>        If (sValue = "") Begin
96473>>>>>            Delegate Get psDriverDefaultValueText to sValue
96475>>>>>        End
96475>>>>>>
96475>>>>>        Function_Return sValue
96476>>>>>    End_Function
96477>>>>>
96477>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
96479>>>>>        Set private.pbDriverDefaultNullableASCII  to bState
96480>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96481>>>>>        Delegate Set pbDriverDefaultNullableASCII to bState
96483>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96484>>>>>    End_Procedure
96485>>>>>
96485>>>>>    // First retrieve the private value that might have been set in the object.
96485>>>>>    // If blank; get it from the parent object
96485>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
96487>>>>>        Boolean bState
96487>>>>>        Get private.pbDriverDefaultNullableASCII to bState
96488>>>>>        If (bState = False) Begin
96490>>>>>            Delegate Get pbDriverDefaultNullableASCII to bState
96492>>>>>        End
96492>>>>>>
96492>>>>>        Function_Return bState
96493>>>>>    End_Function
96494>>>>>
96494>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
96496>>>>>        Set private.pbDriverDefaultNullableBinary  to bState
96497>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96498>>>>>        Delegate Set pbDriverDefaultNullableBinary to bState
96500>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96501>>>>>    End_Procedure
96502>>>>>
96502>>>>>    // First retrieve the private value that might have been set in the object.
96502>>>>>    // If blank; get it from the parent object
96502>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
96504>>>>>        Boolean bState
96504>>>>>        Get private.pbDriverDefaultNullableBinary to bState
96505>>>>>        If (bState = False) Begin
96507>>>>>            Delegate Get pbDriverDefaultNullableBinary to bState
96509>>>>>        End
96509>>>>>>
96509>>>>>        Function_Return bState
96510>>>>>    End_Function
96511>>>>>
96511>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
96513>>>>>        Set private.pbDriverDefaultNullableDate  to bState
96514>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96515>>>>>        Delegate Set pbDriverDefaultNullableDate to bState
96517>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96518>>>>>    End_Procedure
96519>>>>>
96519>>>>>    // First retrieve the private value that might have been set in the object.
96519>>>>>    // If blank; get it from the parent object
96519>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
96521>>>>>        Boolean bState
96521>>>>>        Get private.pbDriverDefaultNullableDate to bState
96522>>>>>        If (bState = False) Begin
96524>>>>>            Delegate Get pbDriverDefaultNullableDate to bState
96526>>>>>        End
96526>>>>>>
96526>>>>>        Function_Return bState
96527>>>>>    End_Function
96528>>>>>
96528>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
96530>>>>>        Set private.pbDriverDefaultNullableDateTime  to bState
96531>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96532>>>>>        Delegate Set pbDriverDefaultNullableDateTime to bState
96534>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96535>>>>>    End_Procedure
96536>>>>>
96536>>>>>    // First retrieve the private value that might have been set in the object.
96536>>>>>    // If blank; get it from the parent object
96536>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
96538>>>>>        Boolean bState
96538>>>>>        Get private.pbDriverDefaultNullableDateTime to bState
96539>>>>>        If (bState = False) Begin
96541>>>>>            Delegate Get pbDriverDefaultNullableDateTime to bState
96543>>>>>        End
96543>>>>>>
96543>>>>>        Function_Return bState
96544>>>>>    End_Function
96545>>>>>
96545>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
96547>>>>>        Set private.pbDriverDefaultNullableNumeric  to bState
96548>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96549>>>>>        Delegate Set pbDriverDefaultNullableNumeric to bState
96551>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96552>>>>>    End_Procedure
96553>>>>>
96553>>>>>    // First retrieve the private value that might have been set in the object.
96553>>>>>    // If blank; get it from the parent object
96553>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
96555>>>>>        Boolean bState
96555>>>>>        Get private.pbDriverDefaultNullableNumeric to bState
96556>>>>>        If (bState = False) Begin
96558>>>>>            Delegate Get pbDriverDefaultNullableNumeric to bState
96560>>>>>        End
96560>>>>>>
96560>>>>>        Function_Return bState
96561>>>>>    End_Function
96562>>>>>
96562>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
96564>>>>>        Set private.pbDriverDefaultNullableText  to bState
96565>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96566>>>>>        Delegate Set pbDriverDefaultNullableText to bState
96568>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96569>>>>>    End_Procedure
96570>>>>>
96570>>>>>    // First retrieve the private value that might have been set in the object.
96570>>>>>    // If blank; get it from the parent object
96570>>>>>    Function pbDriverDefaultNullableText Returns Boolean
96572>>>>>        Boolean bState
96572>>>>>        Get private.pbDriverDefaultNullableText to bState
96573>>>>>        If (bState = False) Begin
96575>>>>>            Delegate Get pbDriverDefaultNullableText to bState
96577>>>>>        End
96577>>>>>>
96577>>>>>        Function_Return bState
96578>>>>>    End_Function
96579>>>>>
96579>>>>>    Function ApiTableConvertToSQL Handle hTable Returns Boolean
96581>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK
96581>>>>>        String sDriverID sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace
96581>>>>>
96581>>>>>        Get psDriverID to sDriverID
96582>>>>>        Get psSchema to sSchema
96583>>>>>
96583>>>>>        Get psBaseTableSpace to sBaseTableSpace
96584>>>>>        If (sBaseTableSpace <> "") Begin
96586>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96587>>>>>            Delegate Set psBaseTableSpace to sBaseTableSpace
96589>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96590>>>>>        End
96590>>>>>>
96590>>>>>
96590>>>>>        Get psLongTableSpace to sLongTableSpace
96591>>>>>        If (sLongTableSpace <> "") Begin
96593>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96594>>>>>            Delegate Set psLongTableSpace to sLongTableSpace
96596>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96597>>>>>        End
96597>>>>>>
96597>>>>>
96597>>>>>        Get psIndexTableSpace to sIndexTableSpace
96598>>>>>        If (sIndexTableSpace <> "") Begin
96600>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96601>>>>>            Delegate Set psIndexTableSpace to sIndexTableSpace
96603>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96604>>>>>        End
96604>>>>>>
96604>>>>>
96604>>>>>        Get pbUseConnectionID to bUseConnectionID
96605>>>>>        Get pbToANSI          to bToANSI
96606>>>>>//ToDo: Why was this changed?
96606>>>>>//        Move True             to bRecnum
96606>>>>>//        Move True             to bCopyData
96606>>>>>        Get pbRecnum          to bRecnum
96607>>>>>        Get pbCopyData        to bCopyData
96608>>>>>
96608>>>>>        Get ApiTableConvertToSQL_Ex hTable sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
96609>>>>>
96609>>>>>        Function_Return bOK
96610>>>>>    End_Function
96611>>>>>
96611>>>>>    Function ApiTableMoveAllToBackupFolder Returns Boolean
96613>>>>>        Boolean bOK bExists
96613>>>>>        String sDataPath sBackupFolder
96613>>>>>        
96613>>>>>        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
96614>>>>>        Move "BackupData" to sBackupFolder
96615>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
96616>>>>>        Get vFolderFormat sDataPath to sDataPath
96617>>>>>        
96617>>>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
96618>>>>>        If (bExists = False) Begin
96620>>>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
96621>>>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
96622>>>>>            If (bExists = False) Begin
96624>>>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
96625>>>>>>
96625>>>>>                Function_Return False
96626>>>>>            End                                                                                                                                            
96626>>>>>>
96626>>>>>            Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
96627>>>>>            Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
96628>>>>>            Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
96629>>>>>            Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
96630>>>>>        End
96630>>>>>>
96630>>>>>        
96630>>>>>        Set Message_Text of ghoStatusPanel to ""
96631>>>>>        Function_Return bOK
96632>>>>>    End_Function
96633>>>>>
96633>>>>>    // This is automatically called after the OnUpdate
96633>>>>>    // event has been executed. It will automatically update the
96633>>>>>    // version database field/column with the "pnVersionNumber"
96633>>>>>    // value of the parent cDbUpdateHandler class - if it has been changed.
96633>>>>>    Procedure UpdateVersionColumnValue
96635>>>>>        Number nVersion nCurrentValue
96635>>>>>        Integer hTable iColumn
96635>>>>>        Boolean bVersionUpdate bDbUpdateErrorHasOccured
96635>>>>>
96635>>>>>        // This is a property of the container class; cDbUpdateHandler that gets set when
96635>>>>>        // an error occurres when processing ESQL or database API messages of the cDbUpdateFunctionLibrary.
96635>>>>>        Delegate Get pbDbUpdateErrorHasOccured to bDbUpdateErrorHasOccured
96637>>>>>        Get pbVersionUpdate to bVersionUpdate
96638>>>>>
96638>>>>>        If (bVersionUpdate = True and bDbUpdateErrorHasOccured = False) Begin
96640>>>>>            Get pnVersionNumber    to nVersion
96641>>>>>            Get Private.Data_File  to hTable
96642>>>>>            Get Private.Data_Field to iColumn
96643>>>>>            // NB! We need to permanently close tables as they e.g. now might no longer be embedded
96643>>>>>            // but instead SQL tables. If we don't the "old" embedded table will be opened instead.
96643>>>>>            Close DF_ALL DF_PERMANENT
96644>>>>>
96644>>>>>            Open hTable
96646>>>>>
96646>>>>>            // It is then the developer responsibility to take care of finding
96646>>>>>            // the correct record that is to be updated (The DbVersion table is not used).
96646>>>>>
96646>>>>>            Get_Field_Value hTable iColumn to nCurrentValue
96649>>>>>            If (nCurrentValue < nVersion) Begin
96651>>>>>                Lock
96652>>>>>>
96652>>>>>                        Vfind hTable Recnum GE
96654>>>>>                    Set_Field_Value hTable iColumn to nVersion
96657>>>>>                    SaveRecord hTable
96658>>>>>                Unlock
96659>>>>>>
96659>>>>>            End
96659>>>>>>
96659>>>>>            Close hTable
96660>>>>>        End
96660>>>>>>
96660>>>>>    End_Procedure
96661>>>>>
96661>>>>>// Property of the container object (cDbUpdateHandler)
96661>>>>>Register_Function piCurrentErrorHandlerID Returns Integer
96661>>>>>
96661>>>>>    Procedure End_Construct_Object
96663>>>>>        Number nVersion nCurrentValue
96663>>>>>        Integer hTable iColumn iSize
96663>>>>>        Boolean bStopOnFirstError bDbUpdateErrorHasOccured bContinueOnError bOpened bSystemTable
96663>>>>>        String sObjectName
96663>>>>>        tDbVersionInfo[] dbVersionInfoArray
96663>>>>>        tDbVersionInfo[] dbVersionInfoArray
96664>>>>>
96664>>>>>        Forward Send End_Construct_Object
96666>>>>>
96666>>>>>        Delegate Set Private.pbUpdateVersionObjectError to False
96668>>>>>
96668>>>>>        // If the programmer forgot to set the version number we do not allow for the application
96668>>>>>        // to continue to run, as this potentially could endanger the integrity of the database. E.g. if
96668>>>>>        // one database update is depended on an earlier update and that earlier version
96668>>>>>        // update was never executed it could lead to disastrous results.
96668>>>>>        // This is a programmer error and should be discovered before any customer sees it. Thus no point in translating...
96668>>>>>        Get pnVersionNumber to nVersion
96669>>>>>        If (nVersion = 0) Begin
96671>>>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
96672>>>>>            Move (Name(Self)) to sObjectName
96673>>>>>            Error DFERR_PROGRAM ("The pnVersionNumber property was not set properly by the programmer for the following object; Program will now exit!\n\n" + sObjectName)
96674>>>>>>
96674>>>>>            Send Exit_Application
96675>>>>>        End
96675>>>>>>
96675>>>>>
96675>>>>>        // These are send to the parent container object (cDbUpdateHandler). The order is very sensitive!
96675>>>>>        // Hook event for the developer to e.g. create a database before the update events starts.
96675>>>>>        Delegate Send OnPreUpdate
96677>>>>>        Delegate Send CheckAutoCreateDbVersionTable
96679>>>>>
96679>>>>>        // We now check that two or more cDbVersion objects does not have the same pnVersionNumber.
96679>>>>>        // Note that the paDbVersionInfoArray is a property of the container object (cDbUpdateHandler)
96679>>>>>        Delegate Get paDbVersionInfoArray to dbVersionInfoArray
96681>>>>>        Move (SizeOfArray(dbVersionInfoArray)) to iSize
96682>>>>>        Move nVersion to dbVersionInfoArray[iSize].nVersionNumber
96683>>>>>        Move (Self)   to dbVersionInfoArray[iSize].hObject
96684>>>>>        Delegate Set paDbVersionInfoArray to dbVersionInfoArray
96686>>>>>        Delegate Send CheckForDuplicates nVersion
96688>>>>>
96688>>>>>        Get Private.Data_File  to hTable
96689>>>>>        Get Private.Data_Field to iColumn
96690>>>>>
96690>>>>>        // If no table & field/column name has been explicitly set as:
96690>>>>>        //   "Set Data_File_Field to (RefTable(OrdSys)) (RefTable(OrdSys.DbUpdateVersion))"
96690>>>>>        // we try to use the default "DbVersion" table.
96690>>>>>        If (hTable = 0) Begin
96692>>>>>            // And get the table/column properties from parent class (cDbUpdateHandler)
96692>>>>>            Get Data_File  to hTable
96693>>>>>            Get Data_Field to iColumn
96694>>>>>        End
96694>>>>>>
96694>>>>>
96694>>>>>        Open hTable
96696>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
96699>>>>>        If (bOpened = False) Begin
96701>>>>>            Send Stop_Box CS_DbUpdateTableMissing
96702>>>>>            Send Exit_Application
96703>>>>>        End
96703>>>>>>
96703>>>>>
96703>>>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemTable
96706>>>>>        If (bSystemTable = True) Begin
96708>>>>>            Get_Field_Value hTable iColumn to nCurrentValue
96711>>>>>        End
96711>>>>>>
96711>>>>>        Else Begin
96712>>>>>        End
96712>>>>>>
96712>>>>>
96712>>>>>        Close hTable
96713>>>>>
96713>>>>>        // We also guard from missing 'DatabaseVersionInfoTable' and column properties settings.
96713>>>>>        // If not set we do nothing.
96713>>>>>        If (nCurrentValue < nVersion) Begin
96715>>>>>
96715>>>>>            // If pbStopOnFirstError is True in the parent, the idea is that we do _no_ further
96715>>>>>            // execution of database update code. So if true _and_ one error
96715>>>>>            // has already occured; we're out of here.
96715>>>>>            Delegate Get pbStopOnFirstError        to bStopOnFirstError
96717>>>>>            Delegate Get pbDbUpdateErrorHasOccured to bDbUpdateErrorHasOccured
96719>>>>>            If (bStopOnFirstError = True) Begin
96721>>>>>                If (bDbUpdateErrorHasOccured = True) Begin
96723>>>>>                    Procedure_Return
96724>>>>>                End
96724>>>>>>
96724>>>>>            End
96724>>>>>>
96724>>>>>
96724>>>>>           // This is send to the parent container object (cDbUpdateHandler)
96724>>>>>             Delegate Send InitDatabaseUpdate (Self)
96726>>>>>
96726>>>>>            // If the parent property pbContinueOnError = False, an update
96726>>>>>            // of a following cDbUpdateVersion object should not take place and we're out of here.
96726>>>>>            Delegate Get pbContinueOnError to bContinueOnError
96728>>>>>            If (bContinueOnError = False and bDbUpdateErrorHasOccured = True) Begin
96730>>>>>                Procedure_Return
96731>>>>>            End
96731>>>>>>
96731>>>>>
96731>>>>>            Delegate Set pnCurrentVersionUpdate to nVersion
96733>>>>>
96733>>>>>            Set Title_Text of ghoStatusPanel to (CS_UpdateVersion * CS_UpdateFromVersion * String(nCurrentValue) * CS_UpdateToVersion * String(nVersion))
96734>>>>>
96734>>>>>            // *** Programmer's main hook message:
96734>>>>>            Send OnUpdate
96735>>>>>
96735>>>>>            Set pbVersionUpdate to True
96736>>>>>            Send UpdateVersionColumnValue
96737>>>>>            Delegate Set pbDatabaseWasUpdated to True
96739>>>>>        End
96739>>>>>>
96739>>>>>
96739>>>>>    End_Procedure
96740>>>>>
96740>>>>>End_Class
96741>>>Use cDbUpdateUserCount.pkg
Including file: cDbUpdateUserCount.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateUserCount.pkg)
96741>>>>>//****************************************************************************
96741>>>>>// $Module type: Class
96741>>>>>// $Module name: cDbUpdateUserCount.pkg
96741>>>>>// $Author     : Emil Stojanov Quantaris B.V.
96741>>>>>//
96741>>>>>//               Collected from DAW's newsgroups.
96741>>>>>//
96741>>>>>// Description : It uses the windows API to lock bytes in a file.
96741>>>>>//               If the application or PC craches it will release the lock
96741>>>>>//               automatically.
96741>>>>>//
96741>>>>>// Note 1      : It will count the number of running app's, so if a
96741>>>>>//               user starts the app twice on one machine it will count as two users.
96741>>>>>// Note 2      : The class was originally named cUserCount by Emil Stojanov.
96741>>>>>//               However, to not conflict with any other usage of this class it was
96741>>>>>//               renamed to "fit" into the "Database Update Framework" (cDbUpdateHandler
96741>>>>>//               and cDbUpdateVersion classes)
96741>>>>>//
96741>>>>>// $Rev History:
96741>>>>>//    2008-10-17  Module header created (Militaty data format)
96741>>>>>//    2008-10-17  Minor changes by Nils G Svedmyr. Created UI text constants
96741>>>>>//                for easy translation to other languages.
96741>>>>>//                Added the tUserCount struct for easier passing of parameters.
96741>>>>>//                Added the ApplicationPath message.
96741>>>>>//****************************************************************************
96741>>>>>Use LanguageText.pkg
96741>>>>>Use cDbUpdateUserCount.inc
Including file: cDbUpdateUserCount.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateUserCount.inc)
96741>>>>>>>Use GlobalFunctionsProcedures.pkg
96741>>>>>>>// Sample:
96741>>>>>>>// Get DoSetDefaultPrinter "HP LaserJet 4" to bVoid
96741>>>>>>>
96741>>>>>>>
96741>>>>>>>// Symbols used by UserCounting
96741>>>>>>>    Define GENERIC_READ         for |CI$80000000
96741>>>>>>>    Define GENERIC_WRITE        for |CI$40000000
96741>>>>>>>    Define GENERIC_EXECUTE      for |CI$20000000
96741>>>>>>>    Define GENERIC_ALL          for |CI$10000000
96741>>>>>>>    Define CREATE_NEW           for 1
96741>>>>>>>    Define CREATE_ALWAYS        for 2
96741>>>>>>>    Define OPEN_EXISTING        for 3
96741>>>>>>>    Define OPEN_ALWAYS          for 4
96741>>>>>>>    Define TRUNCATE_EXISTING    for 5
96741>>>>>>>    Define FILE_BEGIN           for 0
96741>>>>>>>    Define FILE_CURRENT         for 1
96741>>>>>>>    Define FILE_END             for 2
96741>>>>>>>    Define FILE_SHARE_READ      for |CI$00000001
96741>>>>>>>    Define FILE_SHARE_WRITE     for |CI$00000002
96741>>>>>>>    Define FILE_SHARE_DELETE    for |CI$00000004
96741>>>>>>>    Define FILE_FLAG_WRITE_THROUGH            for |CI$80000000
96741>>>>>>>    Define _MAX_PATH  for 260
96741>>>>>>>    Define _MAX_DRIVE for 3
96741>>>>>>>    Define _MAX_DIR   for 256
96741>>>>>>>    Define _MAX_FNAME for 256
96741>>>>>>>    Define _MAX_EXT   for 256
96741>>>>>>>
96741>>>>>>>External_Function Win32_CreateFile "CreateFileA" KERNEL32.DLL ;    Pointer lpFileName ;              // file name    DWord dwDesiredAccess ;           // access mode    DWord dwShareMode ;               // share mode    Pointer lpSecurityAttributes ;    // SD    DWord dwCreationDisposition ;     // how to create    DWord dwFlagsAndAttributes ;      // file attributes    Handle hTemplateFile ;            // handle to template file    Returns Handle
96742>>>>>>>
96742>>>>>>>External_Function Win32_ReadFile "ReadFile" KERNEL32.DLL ;    Handle hFile ;                  // handle to file    Pointer lpBuffer ;              // pointer to the buffer that receives the data    dWord nNumberOfBytesToRead ;    // number of bytes to read    Pointer lpNumberOfBytesRead ;   // number of bytes read    Pointer lpOverlapped ;          // pointer to an overlapped structure    Returns Integer
96743>>>>>>>
96743>>>>>>>External_Function Win32_WriteFile "WriteFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    Pointer lpBuffer ;                  // pointer to buffer containing data to write    dWord nNumberOfBytesToWrite ;       // number of bytes to write    Pointer lpNumberOfBytesWritten ;    // number of bytes written    Pointer lpOverlapped ;              // pointer to an overlapped structure    Returns Integer
96744>>>>>>>
96744>>>>>>>External_Function Win32_LockFile "LockFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    dWord dwFileOffsetLow ;             // low-order word of startposition    dWord dwFileOffsetHigh ;            // high-order word of startposition    dWord nNumberOfBytesToLockLow ;     // low-order word of length    dWord nNumberOfBytesToLockHigh ;    // high-order word of length    Returns Integer
96745>>>>>>>
96745>>>>>>>External_Function Win32_UnlockFile "UnlockFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    dWord dwFileOffsetLow ;             // low-order word of startposition    dWord dwFileOffsetHigh ;            // high-order word of startposition    dWord nNumberOfBytesToUnLockLow ;   // low-order word of length    dWord nNumberOfBytesToUnLockHigh ;  // high-order word of length    Returns Integer
96746>>>>>>>
96746>>>>>>>External_Function Win32_SetFilePointer "SetFilePointer" KERNEL32.DLL ;    Handle hFile ;                  // handle to file    Integer lDistanceToMove ;       // bytes to move pointer (low-order 32-bits)    Pointer lpDistanceToMoveHigh ;  // bytes to move pointer (high-order 32-bits)    dWord dwMoveMethod ;            // starting point    Returns dWord
96747>>>>>>>
96747>>>>>>>External_Function Win32_CloseHandle "CloseHandle" KERNEL32.DLL ;    Handle hObject ;    // handle to object    Returns Integer
96748>>>>>>>
96748>>>>>>>External_Function SetDefaultPrinterEf "SetDefaultPrinterA" winspool.drv Pointer lpPrinter Returns Boolean
96749>>>>>>>// Sample:
96749>>>>>>>// Get DoSetDefaultPrinter "HP LaserJet 4" to bVoid
96749>>>>>>>Function DoSetDefaultPrinter String sPrinter Returns Boolean
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
96751>>>>>>>    Boolean bReturn
96751>>>>>>>    Move (ToANSI(sPrinter)) to sPrinter
96752>>>>>>>    Move (sPrinter + (Character(0))) to sPrinter
96753>>>>>>>    Move (SetDefaultPrinterEf(AddressOf(sPrinter))) to bReturn
96754>>>>>>>    Function_Return bReturn
96755>>>>>>>End_Function
96756>>>>>Use vWin32fh.pkg
96756>>>>>Use seq_chnl.pkg
96756>>>>>
96756>>>>>// User interface constant strings:
96756>>>>>    Define CS_UserCountError            for "User count error:"
96756>>>>>    Define CS_UnableToInitUserCountSys  for "Unable to initialize user counting system!"
96756>>>>>    Define CS_UnableResetUserCountSys   for "Error resetting usercounting system!"
96756>>>>>    Define CS_ErrorAdvancingPointer     for "Error advancing file pointer!"
96756>>>>>    Define CS_MaxNoOfUserExceeded       for "Maximum number of users exceeded!"
96756>>>>>
96756>>>>>
96756>>>>>
96756>>>>>
96756>>>>>
96756>>>>>
96756>>>>>
96756>>>>>
96756>>>>>
96756>>>>>
96756>>>>>
96756>>>>>
96756>>>>>
96756>>>>>    Struct tUserCount
96756>>>>>        Integer iUserCount
96756>>>>>        Integer iError
96756>>>>>        String  sErrorTxt
96756>>>>>    End_Struct
96756>>>>>
96756>>>>>    Define CI_UserCountMaxUsers for 9999
96756>>>>>
96756>>>>>Class cDbUpdateUserCount is a cObject
96757>>>>>    Procedure Construct_Object
96759>>>>>        Forward Send Construct_Object
96761>>>>>
96761>>>>>        Property String  psLockFileName
96762>>>>>        Property Integer piMaxUsers
96763>>>>>        Property Boolean pbCheckDataFlexUserCount True
96764>>>>>
96764>>>>>        Property Handle  phUserCountFile
96765>>>>>        Property Integer pdwLockPosition
96766>>>>>    End_Procedure
96767>>>>>
96767>>>>>    Function IsProgramRunning Returns Boolean
96769>>>>>        tUserCount UserCount
96769>>>>>        tUserCount UserCount
96769>>>>>
96769>>>>>        Get CheckUserCount to UserCount
96770>>>>>
96770>>>>>        Function_Return (UserCount.iUserCount > 1)
96771>>>>>    End_Function
96772>>>>>
96772>>>>>    // Returns the full path of the Application (no trailing "\")
96772>>>>>    Function ApplicationPath Returns String
96774>>>>>        String sApplicationFileName sPath
96774>>>>>        Integer iNumChars iRetval
96774>>>>>
96774>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
96775>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
96776>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
96777>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
96778>>>>>        Move (CString(sApplicationFileName)) to sPath
96779>>>>>
96779>>>>>        Function_Return sPath
96780>>>>>    End_Function
96781>>>>>
96781>>>>>    Function OpenUserCountFile String sFileName Returns Handle
96783>>>>>        Handle  hFile
96783>>>>>        Pointer pFileName
96783>>>>>        String sPath sFile
96783>>>>>        Integer iCh
96783>>>>>
96783>>>>>        Move (Addressof(sFileName)) to pFileName
96784>>>>>        Move (Win32_CreateFile(pFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (FILE_ATTRIBUTE_NORMAL ior FILE_FLAG_WRITE_THROUGH), 0)) to hFile
96785>>>>>
96785>>>>>        // If lock file doesn't exist, create it.
96785>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
96787>>>>>            Get ApplicationPath to sPath
96788>>>>>            Get vFolderFormat sPath to sPath
96789>>>>>            Move (sPath + psLockFileName(Self)) to sFile
96790>>>>>            Get Seq_Open_Output_Channel sFile to iCh
96791>>>>>            If (iCh = DF_SEQ_CHANNEL_ERROR) Begin
96793>>>>>                Function_Return 0
96794>>>>>            End
96794>>>>>>
96794>>>>>            Direct_Output channel iCh sFile
96796>>>>>                Write channel iCh ""
96798>>>>>            Send Seq_Close_Channel iCh
96799>>>>>            Move (Win32_CreateFile(pFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (FILE_ATTRIBUTE_NORMAL ior FILE_FLAG_WRITE_THROUGH), 0)) to hFile
96800>>>>>        End
96800>>>>>>
96800>>>>>
96800>>>>>        Function_Return hFile
96801>>>>>    End_Function
96802>>>>>
96802>>>>>    Function CloseUserCountFile Handle hFile Returns Integer
96804>>>>>        Integer iReturnValue
96804>>>>>
96804>>>>>        Move (Win32_CloseHandle(hFile)) to iReturnValue
96805>>>>>        If (iReturnValue = 0) Begin
96807>>>>>            Function_Return False
96808>>>>>        End
96808>>>>>>
96808>>>>>        Else Begin
96809>>>>>            Function_Return True
96810>>>>>        End
96810>>>>>>
96810>>>>>    End_Function
96811>>>>>
96811>>>>>    Function UnlockUserCountFile Handle hFile dWord dwLockPos Returns Integer
96813>>>>>        Integer iReturnValue
96813>>>>>
96813>>>>>        Move (Win32_UnLockFile(hFile, dwLockPos, 0, 1, 0)) to iReturnValue
96814>>>>>        If (iReturnValue = 0) Begin
96816>>>>>            Function_Return False
96817>>>>>        End
96817>>>>>>
96817>>>>>        Else Begin
96818>>>>>            Function_Return True
96819>>>>>        End
96819>>>>>>
96819>>>>>    End_Function
96820>>>>>
96820>>>>>    Function ReSetUserCountPointer Handle hFile Returns dWord
96822>>>>>        dWord dwCurrPos
96822>>>>>
96822>>>>>        Move (Win32_SetFilePointer(hFile, 0, 0, FILE_BEGIN)) to dwCurrPos
96823>>>>>        Function_Return dwCurrPos
96824>>>>>    End_Function
96825>>>>>
96825>>>>>    Function SetUserCountPointer Handle hFile Integer iAdvance Returns dWord
96827>>>>>        DWord dwCurrPos
96827>>>>>
96827>>>>>        Move (Win32_SetFilePointer(hFile, iAdvance, 0, FILE_CURRENT)) to dwCurrPos
96828>>>>>        Function_Return dwCurrPos
96829>>>>>    End_Function
96830>>>>>
96830>>>>>    Function ReadUserCountFile Handle hFile Returns Integer
96832>>>>>        Integer iReturnValue
96832>>>>>        String  sBuffer
96832>>>>>        Pointer pBuffer
96832>>>>>        String  sSize
96832>>>>>        Pointer pSize
96832>>>>>
96832>>>>>        Move (Repeat((Character(0)),5)) to sBuffer
96833>>>>>        Move (AddressOf(sBuffer)) to pBuffer
96834>>>>>
96834>>>>>        Move (Repeat((Character(0)),4)) to sSize
96835>>>>>        Move (AddressOf(sSize)) to pSize
96836>>>>>
96836>>>>>        Move (Win32_ReadFile(hFile, pBuffer, 1, pSize, 0)) To iReturnValue
96837>>>>>        If (iReturnValue = 0) Begin
96839>>>>>            Function_Return False
96840>>>>>        End
96840>>>>>>
96840>>>>>        Else Begin
96841>>>>>            Function_Return True
96842>>>>>        End
96842>>>>>>
96842>>>>>    End_Function
96843>>>>>
96843>>>>>    Function LockUserCountFile Handle hFile dWord dwFilePos Returns Integer
96845>>>>>        Integer iReturnValue
96845>>>>>
96845>>>>>        Move (Win32_LockFile(hFile, dwFilePos, 0, 1, 0)) To iReturnValue
96846>>>>>        Function_Return iReturnValue
96847>>>>>    End_Function
96848>>>>>
96848>>>>>    Procedure DoCheckUserCount
96850>>>>>        tUserCount UserCount
96850>>>>>        tUserCount UserCount
96850>>>>>
96850>>>>>        Get CheckUserCount to UserCount
96851>>>>>        // If all is fine, we're done.
96851>>>>>        If (UserCount.iError = 0) Begin
96853>>>>>            Procedure_Return
96854>>>>>        End
96854>>>>>>
96854>>>>>
96854>>>>>        Send UserError (CS_UserCountError * String(UserCount.iError) + "\n" + UserCount.sErrorTxt)
96855>>>>>
96855>>>>>        If (UserCount.iUserCount = CI_UserCountMaxUsers) Begin
96857>>>>>            Abort
96858>>>>>>
96858>>>>>        End
96858>>>>>>
96858>>>>>    End_Procedure
96859>>>>>
96859>>>>>    Function CheckUserCount Returns tUserCount
96861>>>>>        Handle  hFile
96861>>>>>        String  sPath sFile
96861>>>>>        Integer iResult
96861>>>>>        DWord   dwFilePos
96861>>>>>        Integer bLocked
96861>>>>>        Integer iMaxUsers
96861>>>>>        Integer iCurUser
96861>>>>>        tUserCount UserCount
96861>>>>>        tUserCount UserCount
96861>>>>>
96861>>>>>        Move 0 to UserCount.iError
96862>>>>>
96862>>>>>        Get phUserCountFile to hFile
96863>>>>>        If (not(hFile)) Begin
96865>>>>>            Get ApplicationPath to sPath
96866>>>>>            Get vFolderFormat sPath to sPath
96867>>>>>            Move (sPath + psLockFileName(Self)) to sFile
96868>>>>>            Get OpenUserCountFile sFile to hFile
96869>>>>>            If (hFile = INVALID_HANDLE_VALUE) Begin
96871>>>>>                Move 1 to UserCount.iUserCount
96872>>>>>                Move 1 to UserCount.iError
96873>>>>>                Move CS_UnableToInitUserCountSys to UserCount.sErrorTxt
96874>>>>>                Function_Return UserCount
96875>>>>>            End
96875>>>>>>
96875>>>>>            Else Begin
96876>>>>>                Move False to bLocked
96877>>>>>                Set phUserCountFile to hFile
96878>>>>>                Get piMaxUsers to iMaxUsers
96879>>>>>
96879>>>>>                // Set Filepointer to beginning of the file
96879>>>>>                Get ResetUserCountPointer hFile to dwFilePos
96880>>>>>                If (dwFilePos = -1) Begin
96882>>>>>                    Move 1 to UserCount.iUserCount
96883>>>>>                    Move 2 to UserCount.iError
96884>>>>>                    Move CS_UnableResetUserCountSys to UserCount.sErrorTxt
96885>>>>>                    Function_Return UserCount
96886>>>>>                End
96886>>>>>>
96886>>>>>                For iCurUser from 1 to iMaxUsers
96892>>>>>>
96892>>>>>                    Get LockUserCountFile hFile dwFilePos to iResult
96893>>>>>                    If (not(iResult)) Begin  // byte is locked
96895>>>>>                        Get SetUserCountPointer hFile 10 to dwFilePos
96896>>>>>                        If (dwFilePos = -1) Begin
96898>>>>>                            Move 1 to UserCount.iUserCount
96899>>>>>                            Move 3 to UserCount.iError
96900>>>>>                            Move CS_ErrorAdvancingPointer to UserCount.sErrorTxt
96901>>>>>                            Function_Return UserCount
96902>>>>>                        End
96902>>>>>>
96902>>>>>                    End
96902>>>>>>
96902>>>>>                    Else Begin  // byte is not locked
96903>>>>>                        Set pdwLockPosition to dwFilePos
96904>>>>>                        Move True to bLocked
96905>>>>>                        Move iMaxUsers to iCurUser
96906>>>>>                    End
96906>>>>>>
96906>>>>>                Loop
96907>>>>>>
96907>>>>>                If (not(bLocked)) Begin
96909>>>>>                    Move CI_UserCountMaxUsers to UserCount.iUserCount
96910>>>>>                    Move 4 to UserCount.iError
96911>>>>>                    Move CS_MaxNoOfUserExceeded to UserCount.sErrorTxt
96912>>>>>                    Function_Return UserCount
96913>>>>>                End
96913>>>>>>
96913>>>>>            End
96913>>>>>>
96913>>>>>        End
96913>>>>>>
96913>>>>>
96913>>>>>        Function_Return UserCount
96914>>>>>    End_Function
96915>>>>>
96915>>>>>
96915>>>>>    Procedure DoReleaseUserCount
96917>>>>>        Integer iResult
96917>>>>>        Handle  hFile
96917>>>>>        DWord   dwLockPos
96917>>>>>
96917>>>>>        Get phUserCountFile to hFile
96918>>>>>        Get pdwLockPosition to dwLockPos
96919>>>>>        If (hFile) Begin
96921>>>>>            If (dwLockPos) Begin
96923>>>>>                Get UnlockUserCountFile hFile dwLockPos to iResult
96924>>>>>            End
96924>>>>>>
96924>>>>>            Get CloseUserCountFile hFile to iResult
96925>>>>>        End
96925>>>>>>
96925>>>>>    End_Procedure
96926>>>>>
96926>>>>>    Function CurrentNumberOfUsers Returns Integer
96928>>>>>        Handle  hFile
96928>>>>>        Integer iMaxUsers
96928>>>>>        DWord   dwFilePos
96928>>>>>        Integer iCurUser
96928>>>>>        Integer iResult
96928>>>>>        Integer iNumberOfLocks
96928>>>>>        String  sPath sFile
96928>>>>>
96928>>>>>        Move 0 to iNumberOfLocks
96929>>>>>
96929>>>>>        Get ApplicationPath to sPath
96930>>>>>        Get vFolderFormat sPath to sPath
96931>>>>>        Move (sPath + psLockFileName(Self)) to sFile
96932>>>>>        Get OpenUserCountFile sFile to hFile
96933>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
96935>>>>>            Send UserError CS_UnableToInitUserCountSys
96936>>>>>            Abort
96937>>>>>>
96937>>>>>        End
96937>>>>>>
96937>>>>>
96937>>>>>        If (hFile > 0) Begin
96939>>>>>            Get piMaxUsers To iMaxUsers
96940>>>>>
96940>>>>>            // Set Filepointer to beginning of the file
96940>>>>>            Get ResetUserCountPointer hFile to dwFilePos
96941>>>>>            If (dwFilePos = -1) Begin
96943>>>>>                Send UserError CS_UnableResetUserCountSys
96944>>>>>                Abort
96945>>>>>>
96945>>>>>            End
96945>>>>>>
96945>>>>>            For iCurUser from 1 to iMaxUsers
96951>>>>>>
96951>>>>>                Get LockUserCountFile hFile dwFilePos to iResult
96952>>>>>                If (Not(iResult)) Begin  // byte is locked
96954>>>>>                    Increment iNumberOfLocks
96955>>>>>                End
96955>>>>>>
96955>>>>>                Else Begin  // byte is not locked
96956>>>>>                    Get UnlockUserCountFile hFile dwFilePos to iResult
96957>>>>>                End
96957>>>>>>
96957>>>>>                Get SetUserCountPointer hFile 10 to dwFilePos
96958>>>>>                If (dwFilePos = -1) Begin
96960>>>>>                    Send UserError CS_ErrorAdvancingPointer
96961>>>>>                    Abort
96962>>>>>>
96962>>>>>                End
96962>>>>>>
96962>>>>>            Loop
96963>>>>>>
96963>>>>>        End
96963>>>>>>
96963>>>>>        Get CloseUserCountFile hFile to iResult
96964>>>>>        Function_Return iNumberOfLocks
96965>>>>>    End_Function
96966>>>>>
96966>>>>>End_Class
96967>>>Use cDbUpdateFunctionLibrary.pkg
96967>>>
96967>>>// ToDo: *** We need a way to set the SQL collation order for the database to be created!
96967>>>
96967>>>Class cDbUpdateHandler is a cObject
96968>>>    // Note: We import all functionality of the DatabaseFunctionLibrary into the class:
96968>>>    Import_Class_Protocol cDbUpdateFunctionLibrary
96969>>>    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
96970>>>
96970>>>    Procedure Construct_Object
96972>>>        tUserCount UserCount
96972>>>        tUserCount UserCount
96972>>>        Integer iUserCount
96972>>>        Handle ho
96972>>>
96972>>>        Forward Send Construct_Object
96974>>>        Move Self to ghoDbUpdateHandler  
96975>>>        
96975>>>        // Latin1_General_CI_AS = General Insensitive collation
96975>>>        // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.   
96975>>>        // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
96975>>>        // Good read about which collation to select:
96975>>>        // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
96975>>>        Property String psCollation "Latin1_General_CS_AS" //"SQL_Latin1_General_Cp1_CS_AS"
96976>>>
96976>>>        // Struct array that will contain pnVersionNumbers & object id's of
96976>>>        // all child cDbVersion objects.
96976>>>        Property tDbVersionInfo[] paDbVersionInfoArray
96977>>>
96977>>>        Property Boolean Private.pbUseCustomDbVersion False
96978>>>        Property Boolean Private.pbDbVersionCheckDone False
96979>>>
96979>>>        // If this property = True _and_ Private.pbUseCustomDbVersion = False,
96979>>>        // _and_ no DbVersion table exists when the framework is started,
96979>>>        // a DbVersion table will be created automatically.
96979>>>        Property Boolean pbAutoCreateDbVersionTable True
96980>>>        // Connected to the pbAutoCreateDbVersionTable property. If it is true,
96980>>>        // the Filelist.cfg slot number indicated by this property will be used
96980>>>        // if a DbVersion table is to be created. If this value = -1
96980>>>        // an Unhandled Exception Error will be genereted and the program halted. So
96980>>>        // this property _must_ be set in the cDbUpdateHandler object if pbAutoCreateDbVersionTable = True,
96980>>>        // to a value that corresponds to a free Filelist.cfg slot number.
96980>>>        Property Integer piDbVersionFileSlotNumber -1
96981>>>
96981>>>        // This is a message of the cDbUpdateFunctionLibrary_Mixin class
96981>>>        // that creates all library properties
96981>>>        Send CreateDbUpdateLibraryProperties
96982>>>
96982>>>        Property tDbUpdateHandlerMasterAlias[] paDbUpdateHandlerMasterAlias
96983>>>
96983>>>        // Error handling:
96983>>>        Property Boolean Private.pbProcessingError False
96984>>>        Property Boolean pbDbUpdateErrorHasOccured False
96985>>>        // Don't touch. It is being used by the cDbUpdateVersion
96985>>>        // subclass to tell if that particular update went OK or not.
96985>>>        Property Boolean Private.pbUpdateVersionObjectError False
96986>>>        Property String[] paSQLQueryMessages
96987>>>
96987>>>        // Error handling:
96987>>>        // We temporarily redirect all errors to this object so we can
96987>>>        // log and write errors to the log file. It will be reset after
96987>>>        // the database updates have been finished.
96987>>>        Property Integer piCurrentErrorHandlerID Error_Object_Id
96988>>>        // Temporarily redirect all errors to this object so we can silently
96988>>>        // log all errors that might appear while updating the database.
96988>>>        Move Self to Error_Object_Id
96989>>>
96989>>>        Property Handle phoLogFile (Create(Self,RefClass(cDbUpdateLogFile)))
96990>>>
96990>>>        // Error Reporting Related
96990>>>        // If DUF_ERROR_NO_REPORT errors are supressed (only ERR gets set)
96990>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
96991>>>
96991>>>        // If the pbContinueOnError = False, an update
96991>>>        // of another cDbUpdateVersion object will _not_ be
96991>>>        // performed if an error occured in a previous
96991>>>        // cDbUpdateVersion object.
96991>>>        Property Boolean pbContinueOnError False
96992>>>        // Stops execution in other cDbUpdateVersion objecs,
96992>>>        // if errors occurred in one cDbUpdateVersion object.
96992>>>        Property Boolean pbStopOnFirstError False
96993>>>        // If True errors that occured while updating the database
96993>>>        // will be shown in the default app for .txt files when done.
96993>>>        // Note: The log file will _always_ be created in the Data folder.
96993>>>        Property Boolean pbShowErrorLogPostRun True
96994>>>
96994>>>        // Be _very_ careful to set this property to true!
96994>>>        // If = True, no question will be asked if the update
96994>>>        // should begin. Also, even if the pbShowErrorLogPostRun=True,
96994>>>        // the error log won't be shown. The logfile itself will still be created though.
96994>>>        // You have to know what you're doing!
96994>>>        Property Boolean pbSilentMode False
96995>>>
96995>>>        // Don't touch! Very private. The value is used by the error log to write for which
96995>>>        // cDbUpdateVersion object an error occured.
96995>>>        Property Number pnCurrentVersionUpdate 0
96996>>>
96996>>>        // The user counting logic is used to safe-guard agains anybody else is
96996>>>        // using the application when a database update is to be performed.
96996>>>        // (Garters & suspenders!)
96996>>>        Property Handle phoUserCountSystem (Create(Self,RefClass(cDbUpdateUserCount)))
96997>>>        Set psLockFileName of (phoUserCountSystem(Self)) to "DbUpdateUserCount.ucf"
96998>>>        Set piMaxUsers     of (phoUserCountSystem(Self)) to (CI_UserCountMaxUsers -1) // Large number!
96999>>>
96999>>>        // This lock file is used to guard against somebody else tries to start the
96999>>>        // application while updates are in progress.
96999>>>        Property Handle phoDatabaseUpdateLock (Create(Self,RefClass(cDbUpdateUserCount)))
97000>>>        Set psLockFileName of (phoDatabaseUpdateLock(Self)) to "DbUpdateLock.ucf"
97001>>>        Set piMaxUsers     of (phoDatabaseUpdateLock(Self)) to 1
97002>>>                                                                                      // Only the current user allowed.
97002>>>        // Properties for the table & column of a system file field/column where
97002>>>        // the database version update number gets saved.
97002>>>        Property Integer Private.Data_File  0
97003>>>        Property Integer Private.Data_Field 0
97004>>>
97004>>>        // Property that is used to indicate that we have already
97004>>>        // started the database update.
97004>>>        Property Boolean Private.pbDatabaseUpdateStarted False
97005>>>
97005>>>        // Don't touch! It is used by the child class cDbUpdateVersion logic to indicate that
97005>>>        // at least one OnUpdate child event has been triggered. Thus at least one active
97005>>>        // change of the database has been made.
97005>>>        Property Boolean Private.pbDatabaseWasUpdated False
97006>>>
97006>>>        // We need to trigger the user counting system so that a bit in the
97006>>>        // user counting file is locked. This is to guard that not more than one user
97006>>>        // is currently runnning the program.
97006>>>        Get CheckUserCount of (phoUserCountSystem(Self)) to UserCount
97007>>>
97007>>>        Get CurrentNumberOfUsers of (phoDatabaseUpdateLock(Self)) to iUserCount
97008>>>        If (iUserCount > 0) Begin
97010>>>            Send Stop_Box CS_UpdateInProgressTxt
97011>>>            Send Exit_Application
97012>>>        End
97012>>>>
97012>>>
97012>>>        Set pbHandleQueryErrors to False
97013>>>
97013>>>        If (ghoDbUpdateFunctionLibrary = 0) Begin
97015>>>            Move Self to ghoDbUpdateFunctionLibrary
97016>>>        End
97016>>>>
97016>>>
97016>>>        Property Handle phoSQLConnectionHandler 0
97017>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
97017>>>        // we will create one as it is used for all ConnectionID, ConnectionString
97017>>>        // etc information.
97017>>>        If (ghoSQLConnectionHandler = 0) Begin
97019>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
97020>>>            Set phoSQLConnectionHandler to ho
97021>>>        End
97021>>>>
97021>>>
97021>>>        Set Icon to "Default.ico"
97022>>>    End_Procedure
97023>>>
97023>>>    Procedure End_Construct_Object
97025>>>        Forward Send End_Construct_Object
97027>>>        Send Cleanup
97028>>>    End_Procedure
97029>>>
97029>>>    Procedure CheckAutoCreateDbVersionTable
97031>>>        Boolean bDbVersionCheckDone bUseCustomDbVersion bAutoCreateDbVersionTable bTableExists
97031>>>        Integer iDbVersionFileSlotNumber iRetval
97031>>>
97031>>>        Get Private.pbDbVersionCheckDone to bDbVersionCheckDone
97032>>>        If (bDbVersionCheckDone = True) Begin
97034>>>            Procedure_Return
97035>>>        End
97035>>>>
97035>>>        Get Private.pbUseCustomDbVersion to bUseCustomDbVersion
97036>>>        If (bUseCustomDbVersion = True) Begin
97038>>>            Procedure_Return
97039>>>        End
97039>>>>
97039>>>
97039>>>        Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary "DbVersion" to iRetval
97040>>>        If (iRetval <> 0) Begin
97042>>>            Procedure_Return
97043>>>        End
97043>>>>
97043>>>
97043>>>        Get pbAutoCreateDbVersionTable to bAutoCreateDbVersionTable
97044>>>        Get piDbVersionFileSlotNumber  to iDbVersionFileSlotNumber
97045>>>        If (bAutoCreateDbVersionTable = True and iDbVersionFileSlotNumber = -1) Begin
97047>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
97048>>>            Error DFERR_PROGRAM "The iDbVersionFileSlotNumber = -1. It MUST be set to a free Filelist.cfg slot in the cDbUpdateHandler object. Could not auto-create the DbVersion table.\nProgram will now exit!"
97049>>>>
97049>>>            Send Exit_Application
97050>>>        End
97050>>>>
97050>>>
97050>>>        Get UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary iDbVersionFileSlotNumber to bTableExists
97051>>>        If (bTableExists = True) Begin
97053>>>            Set Private.pbDbVersionCheckDone to True
97054>>>            Procedure_Return
97055>>>        End
97055>>>>
97055>>>
97055>>>        // Note: If the piDbVersionFileSlotNumber has not been set in the object code,
97055>>>        //       we default to the first free slot in the Filelist.cfg
97055>>>//        If (iDbVersionFileSlotNumber = -1) Begin
97055>>>//            Get_Attribute DF_FILE_NEXT_EMPTY of 0 to iDbVersionFileSlotNumber
97055>>>//        End
97055>>>        Send CreateDbVersionTable iDbVersionFileSlotNumber
97056>>>
97056>>>        // We only need to these DbVersion checks once, but because this message is called
97056>>>        // from each child cDbUpdateVersion object (and it needs to be called from there),
97056>>>        // we use a property to only run these tests once.
97056>>>        Set Private.pbDbVersionCheckDone to True
97057>>>    End_Procedure
97058>>>
97058>>>    Procedure CreateDbVersionTable Handle hTable
97060>>>        String sTableName sColumnName sInfoTxt sDriverID
97060>>>        Integer iLength
97060>>>        Boolean bTableExists bOK bUseConnectionID
97060>>>        tAPIColumn[] APIColumn
97060>>>        tAPIColumn[] APIColumn
97061>>>
97061>>>        Get UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bTableExists
97062>>>        If (bTableExists = True) Begin
97064>>>            Procedure_Return
97065>>>        End
97065>>>>
97065>>>
97065>>>        Get psDriverID to sDriverID
97066>>>        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bUseConnectionID
97067>>>
97067>>>        Move "DbVersion"        to sTableName
97068>>>        Move 1                  to APIColumn[0].iFieldNumber
97069>>>        Move "DatabaseVersion"  to APIColumn[0].sFieldName
97070>>>        Move DF_BCD             to APIColumn[0].iType
97071>>>        Move False              to APIColumn[0].bIsSQLType
97072>>>        Move 4                  to APIColumn[0].iLength
97073>>>        Move 2                  to APIColumn[0].iPrecision
97074>>>
97074>>>        Move False to Err
97075>>>        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True APIColumn to bOk
97076>>>        Get ApiTableChangeAttribute of ghoDbUpdateFunctionLibrary hTable DF_FILE_IS_SYSTEM_FILE True to bOK
97077>>>
97077>>>        If (bOK = True and Err = False) Begin
97079>>>            Move ("Column '" + APIColumn[0].sFieldName + "'" * "NUMERIC" * String(APIColumn[0].iLength) + ", was successfully added to '" + sTableName + "'" * "(at filelist slot:" * String(hTable) + ")") to sInfoTxt
97080>>>        End
97080>>>>
97080>>>        Else Begin
97081>>>            Move ("The column could NOT be added. Either column" * sColumnName * "already exists or the Table name is incorrect?") to sInfoTxt
97082>>>        End
97082>>>>
97082>>>
97082>>>        Send LogError of (phoLogFile(Self)) 0 0 sInfoTxt 0 False
97083>>>    End_Procedure
97084>>>
97084>>>    Procedure Set pbVerboseState Boolean bVerboseState
97086>>>        Handle ho
97086>>>        Get phoLogFile to ho
97087>>>        Set pbVerboseState of ho to bVerboseState
97088>>>    End_Procedure
97089>>>
97089>>>    Function pbVerboseState Returns Boolean
97091>>>        Boolean bVerboseState
97091>>>        Handle ho
97091>>>        Get phoLogFile to ho
97092>>>        Get pbVerboseState of ho to bVerboseState
97093>>>        Function_Return bVerboseState
97094>>>    End_Function
97095>>>
97095>>>    // Callback functionality used when e.g. calling driver functions directly.
97095>>>    // Note that this overrules the callback function of the cDbUpdateFunctionLibrary class.
97095>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
97097>>>        Integer iPerc
97097>>>        Number nReady nTotal nVersion
97097>>>        Boolean bVerboseState
97097>>>        Handle hoLogFile
97097>>>
97097>>>        Get pbVerboseState to bVerboseState
97098>>>        Get pnCurrentVersionUpdate to nVersion
97099>>>        Get phoLogFile     to hoLogFile
97100>>>        Send DoAdvance of ghoProgressBar
97101>>>
97101>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
97103>>>            Move (Replace("Dropping index", sCallback_Text, CS_SQLDeletingIndex)) to sCallback_Text
97104>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_SQLDeletingIndex)) to sCallback_Text
97105>>>        End
97105>>>>
97105>>>        If (sCallback_Text contains "Creating index") Begin
97107>>>            Move (Replace("Creating index", sCallback_Text, CS_SQLCreatingIndex)) to sCallback_Text
97108>>>        End
97108>>>>
97108>>>
97108>>>        Case Begin
97108>>>            Case (iCallback_Type = DF_Message_Text)
97110>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
97111>>>                Set Action_Text  of ghoStatusPanel to ""
97112>>>                If (bVerboseState = True) Begin
97114>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
97115>>>                End
97115>>>>
97115>>>                Case Break
97116>>>            Case (iCallback_Type = DF_Message_Heading_1)
97119>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
97120>>>//                Set Action_Text  of ghoStatusPanel to ""
97120>>>                If (bVerboseState = True) Begin
97122>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
97123>>>                End
97123>>>>
97123>>>                Case Break
97124>>>            Case (iCallback_Type = DF_Message_Heading_2)
97127>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
97128>>>                Set Action_Text  of ghoStatusPanel to ""
97129>>>                If (bVerboseState = True) Begin
97131>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
97132>>>                End
97132>>>>
97132>>>                Case Break
97133>>>            Case (iCallback_Type = DF_Message_Heading_3)
97136>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
97137>>>                Set Action_Text  of ghoStatusPanel to ""
97138>>>                If (bVerboseState = True) Begin
97140>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
97141>>>                End
97141>>>>
97141>>>                Case Break
97142>>>            Case (iCallback_Type = DF_Message_Heading_4)
97145>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
97146>>>                Set Action_Text  of ghoStatusPanel to ""
97147>>>                If (bVerboseState = True) Begin
97149>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
97150>>>                End
97150>>>>
97150>>>                Case Break
97151>>>            Case (iCallback_Type = DF_Message_Heading_5)
97154>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
97155>>>                Set Action_Text  of ghoStatusPanel to ""
97156>>>                If (bVerboseState = True) Begin
97158>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
97159>>>                End
97159>>>>
97159>>>                Case Break
97160>>>            Case (iCallback_Type = DF_Message_Warning)
97163>>>                If (bVerboseState = True) Begin
97165>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
97166>>>                End
97166>>>>
97166>>>                Case Break
97167>>>            Case (iCallback_Type = DF_Message_Progress_Title)
97170>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
97171>>>                Set Action_Text  of ghoStatusPanel to ""
97172>>>                If (bVerboseState = True) Begin
97174>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
97175>>>                End
97175>>>>
97175>>>                Case Break
97176>>>            Case (iCallback_Type = DF_Message_Progress_Value)
97179>>>                //*** Interpret numbers
97179>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
97180>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
97181>>>                Move ((nReady/nTotal) * 100)                                                      to iPerc
97182>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% (Total:") * String(nTotal) + ")")
97183>>>                Set piPosition of ghoProgressBar to iPerc
97184>>>                Case Break
97185>>>            Case Else
97185>>>                Set Message_Text to ""
97186>>>                Set Action_Text  to ""
97187>>>        Case End
97187>>>
97187>>>        Send ProcessEvents of ghoStatusPanel
97188>>>        Function_Return False
97189>>>    End_Function
97190>>>
97190>>>    // This was made to be a procedure/function pair so we
97190>>>    // at the same time can set the property of the cDbUpdateFunctionLibrary
97190>>>    Procedure Set psDriverID String sDriverID
97192>>>        If (ghoSQLConnectionHandler = 0) Begin
97194>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
97195>>>>
97195>>>            Procedure_Return
97196>>>        End
97196>>>>
97196>>>        Set psDriverID of ghoSQLConnectionHandler to sDriverID
97197>>>    End_Procedure
97198>>>
97198>>>    Function psDriverID Returns String
97200>>>        String sValue
97200>>>        If (ghoSQLConnectionHandler = 0) Begin
97202>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
97203>>>>
97203>>>            Procedure_Return
97204>>>        End
97204>>>>
97204>>>        Get psDriverID of ghoSQLConnectionHandler to sValue
97205>>>        Function_Return sValue
97206>>>    End_Function
97207>>>
97207>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent
97209>>>        If (ghoSQLConnectionHandler = 0) Begin
97211>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
97212>>>>
97212>>>            Procedure_Return
97213>>>        End
97213>>>>
97213>>>        Send CreateSQLConnection of ghoSQLConnectionHandler sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent
97214>>>    End_Procedure
97215>>>
97215>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
97217>>>        Integer iRetval
97217>>>        If (ghoSQLConnectionHandler = 0) Begin
97219>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
97220>>>>
97220>>>            Function_Return 2
97221>>>        End
97221>>>>
97221>>>
97221>>>        Get RedirectConnection of ghoSQLConnectionHandler to iRetval
97222>>>        Function_Return iRetval
97223>>>    End_Function
97224>>>
97224>>>    Procedure Set psConnectionID String sValue
97226>>>        If (ghoSQLConnectionHandler = 0) Begin
97228>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
97229>>>>
97229>>>            Procedure_Return
97230>>>        End
97230>>>>
97230>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
97231>>>    End_Procedure
97232>>>
97232>>>    Function psConnectionID Returns String
97234>>>        String sValue
97234>>>        If (ghoSQLConnectionHandler = 0) Begin
97236>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
97237>>>>
97237>>>            Procedure_Return
97238>>>        End
97238>>>>
97238>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
97239>>>
97239>>>        Function_Return sValue
97240>>>    End_Function
97241>>>
97241>>>    // These "properties" are settings of the cCLIHandler class, but are being
97241>>>    // relayed to the ghoSQLConnectionHandler object
97241>>>    // simply by changing one of its parameters.
97241>>>    Procedure Set psServer String sValue
97243>>>        If (ghoSQLConnectionHandler = 0) Begin
97245>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
97246>>>>
97246>>>            Procedure_Return
97247>>>        End
97247>>>>
97247>>>        Set psServer of ghoSQLConnectionHandler to sValue
97248>>>    End_Procedure
97249>>>
97249>>>    Function psServer Returns String
97251>>>        String sValue
97251>>>        If (ghoSQLConnectionHandler = 0) Begin
97253>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
97254>>>>
97254>>>            Procedure_Return
97255>>>        End
97255>>>>
97255>>>        Get psServer of ghoSQLConnectionHandler to sValue
97256>>>
97256>>>        Function_Return sValue
97257>>>    End_Function
97258>>>
97258>>>    Procedure Set psDatabase String sValue
97260>>>        If (ghoSQLConnectionHandler = 0) Begin
97262>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
97263>>>>
97263>>>            Procedure_Return
97264>>>        End
97264>>>>
97264>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
97265>>>    End_Procedure
97266>>>
97266>>>    Function psDatabase Returns String
97268>>>        String sValue
97268>>>        If (ghoSQLConnectionHandler = 0) Begin
97270>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
97271>>>>
97271>>>            Procedure_Return
97272>>>        End
97272>>>>
97272>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
97273>>>
97273>>>        Function_Return sValue
97274>>>    End_Function
97275>>>
97275>>>    Procedure Set psUserID String sValue
97277>>>        If (ghoSQLConnectionHandler = 0) Begin
97279>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
97280>>>>
97280>>>            Procedure_Return
97281>>>        End
97281>>>>
97281>>>        Set psUserID of ghoSQLConnectionHandler to sValue
97282>>>    End_Procedure
97283>>>
97283>>>    Function psUserID Returns String
97285>>>        String sValue
97285>>>        If (ghoSQLConnectionHandler = 0) Begin
97287>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
97288>>>>
97288>>>            Procedure_Return
97289>>>        End
97289>>>>
97289>>>        Get psUserID of ghoSQLConnectionHandler to sValue
97290>>>
97290>>>        Function_Return sValue
97291>>>    End_Function
97292>>>
97292>>>    Procedure Set psPassword String sValue
97294>>>        If (ghoSQLConnectionHandler = 0) Begin
97296>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
97297>>>>
97297>>>            Procedure_Return
97298>>>        End
97298>>>>
97298>>>        Set psPassword of ghoSQLConnectionHandler to sValue
97299>>>    End_Procedure
97300>>>
97300>>>    Function psPassword Returns String
97302>>>        String sValue
97302>>>        If (ghoSQLConnectionHandler = 0) Begin
97304>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
97305>>>>
97305>>>            Procedure_Return
97306>>>        End
97306>>>>
97306>>>        Get psPassword of ghoSQLConnectionHandler to sValue
97307>>>
97307>>>        Function_Return sValue
97308>>>    End_Function
97309>>>
97309>>>    Procedure Set pbTrusted Boolean bValue
97311>>>        If (ghoSQLConnectionHandler = 0) Begin
97313>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
97314>>>>
97314>>>            Procedure_Return
97315>>>        End
97315>>>>
97315>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
97316>>>    End_Procedure
97317>>>
97317>>>    Function pbTrusted Returns Boolean
97319>>>        Boolean bValue
97319>>>        If (ghoSQLConnectionHandler = 0) Begin
97321>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
97322>>>>
97322>>>            Procedure_Return
97323>>>        End
97323>>>>
97323>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
97324>>>
97324>>>        Function_Return bValue
97325>>>    End_Function
97326>>>
97326>>>    Procedure Set psConnectionString String sValue
97328>>>        If (ghoSQLConnectionHandler = 0) Begin
97330>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
97331>>>>
97331>>>            Procedure_Return
97332>>>        End
97332>>>>
97332>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
97333>>>    End_Procedure
97334>>>
97334>>>    Function psConnectionString Returns String
97336>>>        String sValue
97336>>>        If (ghoSQLConnectionHandler = 0) Begin
97338>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
97339>>>>
97339>>>            Procedure_Return
97340>>>        End
97340>>>>
97340>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
97341>>>
97341>>>        Function_Return sValue
97342>>>    End_Function
97343>>>
97343>>>    Function piConnectionOptions Returns Integer
97345>>>        Integer iValue
97345>>>        If (ghoSQLConnectionHandler = 0) Begin
97347>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
97348>>>>
97348>>>            Procedure_Return
97349>>>        End
97349>>>>
97349>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
97350>>>
97350>>>        Function_Return iValue
97351>>>    End_Function
97352>>>
97352>>>
97352>>>    Procedure Set pbCheckDataFlexUserCount Boolean bState
97354>>>        Set pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
97355>>>    End_Procedure
97356>>>
97356>>>    Function pbCheckDataFlexUserCount Returns Boolean
97358>>>        Boolean bState
97358>>>        Get pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
97359>>>        Function_Return bState
97360>>>    End_Function
97361>>>
97361>>>    Procedure Set psLogTextFile String sValue
97363>>>        Set psLogTextFile of (phoLogFile(Self)) to sValue
97364>>>    End_Procedure
97365>>>
97365>>>    Function psLogTextFile Returns String
97367>>>        String sValue
97367>>>        Get psLogTextFile of (phoLogFile(Self)) to sValue
97368>>>        Function_Return sValue
97369>>>    End_Procedure
97370>>>
97370>>>    Procedure Set psEditorProgram String sValue
97372>>>        Set psEditorProgram of (phoLogFile(Self)) to sValue
97373>>>    End_Procedure
97374>>>
97374>>>    Function psEditorProgram Returns String
97376>>>        String sValue
97376>>>        Get psEditorProgram of (phoLogFile(Self)) to sValue
97377>>>        Function_Return sValue
97378>>>    End_Procedure
97379>>>
97379>>>    Procedure Set pbUseDataTable Boolean bState
97381>>>        Set pbUseDataTable of (phoLogFile(Self)) to bState
97382>>>    End_Procedure
97383>>>
97383>>>    Function pbUseDataTable Returns Boolean
97385>>>        Boolean bState
97385>>>        Get pbUseDataTable of (phoLogFile(Self)) to bState
97386>>>        Function_Return bState
97387>>>    End_Function
97388>>>
97388>>>    Procedure Set pbQuickWrite Boolean bState
97390>>>        Set pbQuickWrite of (phoLogFile(Self)) to bState
97391>>>    End_Procedure
97392>>>
97392>>>    Function pbQuickWrite Returns Boolean
97394>>>        Boolean bState
97394>>>        Get pbQuickWrite of (phoLogFile(Self)) to bState
97395>>>        Function_Return bState
97396>>>    End_Function
97397>>>
97397>>>    Procedure Set pbDatabaseWasUpdated Boolean bState
97399>>>        Boolean bUpdateVersionObjectError bVerboseState
97399>>>        Integer iSize iCount
97399>>>        Number nVersion
97399>>>        String[] aSQLQueryMessages
97400>>>
97400>>>        Get Private.pbUpdateVersionObjectError to bUpdateVersionObjectError
97401>>>        Set Private.pbDatabaseWasUpdated to bState
97402>>>        // If no errors occurred in the current cDbUpdateVersion object - write
97402>>>        // to the log that it was OK.
97402>>>        If (bUpdateVersionObjectError = False) Begin
97404>>>            Get pnCurrentVersionUpdate to nVersion
97405>>>            Send LogError of (phoLogFile(Self)) nVersion 0 CS_SuccessfulUpdate 0 False
97406>>>        End
97406>>>>
97406>>>
97406>>>        Get pbVerboseState to bVerboseState
97407>>>        If (bVerboseState = True) Begin
97409>>>            Get paSQLQueryMessages to aSQLQueryMessages
97410>>>            Move (SizeOfArray(aSQLQueryMessages)) to iSize
97411>>>            Decrement iSize
97412>>>            For iCount from 0 to iSize
97418>>>>
97418>>>                Send LogError of (phoLogFile(Self)) nVersion 0 aSQLQueryMessages[iCount] 0 False
97419>>>            Loop
97420>>>>
97420>>>        End
97420>>>>
97420>>>
97420>>>    End_Procedure
97421>>>
97421>>>    Function pbDatabaseWasUpdated Returns Boolean
97423>>>        Function_Return (Private.pbDatabaseWasUpdated(Self))
97424>>>    End_Function
97425>>>
97425>>>    Procedure Bind_Data Integer iFile Integer iField
97427>>>        Set Data_File  to iFile
97428>>>        Set Data_Field to iField
97429>>>    End_Procedure
97430>>>
97430>>>    // ToDo: Is this possible to show in the Studio's Property panel?
97430>>>    Procedure Set Data_File_Field Integer iFile Integer iField
97432>>>        Set Private.Data_File  to iFile
97433>>>        Set Private.Data_Field to iField
97434>>>    End_Procedure
97435>>>
97435>>>//    { Visibility=Public MethodType=Property Category="Data" }
97435>>>    Procedure Set DataFile Integer iFile
97437>>>        Set Private.Data_File to iFile
97438>>>    End_Procedure
97439>>>
97439>>>//    { Visibility=Public MethodType=Property Category="Data" }
97439>>>    Function DataFile Integer iFile Returns Integer
97441>>>        Function_Return (Private.Data_File(Self))
97442>>>    End_Function
97443>>>
97443>>>//    { Visibility=Public MethodType=Property Category="Data" }
97443>>>    Procedure Set DataField Integer iField
97445>>>        Set Private.Data_Field to iField
97446>>>    End_Procedure
97447>>>
97447>>>//    { Visibility=Public MethodType=Property Category="Data" }
97447>>>    Function DataField Integer iField Returns Integer
97449>>>        Function_Return (Private.Data_Field(Self))
97450>>>    End_Function
97451>>>
97451>>>    // This event is triggered by the cDbUpdateVersion child class when
97451>>>    // a database change is to be started, and is considered private.
97451>>>    // It is only executed once for the first cDbUpateVersion object!
97451>>>    Procedure InitDatabaseUpdate Handle hDbUpdateVersionObject
97453>>>        Boolean bDatabaseUpdateStarted bInUse bExists bCheckDataFlexUserCount
97453>>>        Integer iRetval iDataFlexUsers iUserCount
97453>>>        Handle hoUserCountSystem
97453>>>        tUserCount UserCount
97453>>>        tUserCount UserCount
97453>>>        DateTime dtUpdateStarted
97453>>>        tSQLConnection SQLConnection
97453>>>        tSQLConnection SQLConnection
97453>>>        String sDriverID
97453>>>
97453>>>        // *Important:* If we already started the update; we do no further checking.
97453>>>        Get Private.pbDatabaseUpdateStarted to bDatabaseUpdateStarted
97454>>>        If (bDatabaseUpdateStarted = True) Begin
97456>>>            Procedure_Return
97457>>>        End
97457>>>>
97457>>>
97457>>>        // If not silent mode; Ask user if OK to start database update.
97457>>>        If (pbSilentMode(Self) = False) Begin
97459>>>            Get YesNo_Box CS_DatabaseNeedsUpdate CS_HeaderUpdateText to iRetval
97460>>>            If (iRetval <> MBR_Yes) Begin
97462>>>                Send Exit_Application
97463>>>            End
97463>>>>
97463>>>        End
97463>>>>
97463>>>        
97463>>>        Send EnableCancelButton     of ghoStatusPanel False
97464>>>        Send Initialize_StatusPanel of ghoStatusPanel ("   " + CS_WorkingUpdateText) CS_WorkingHeaderText ""
97465>>>        Send Start_StatusPanel      of ghoStatusPanel
97466>>>
97466>>>        Move 0 to iDataFlexUsers
97467>>>        // Make various tests to check that the database is not in use.
97467>>>        Get IsDatabaseInUse of hDbUpdateVersionObject to bInUse
97468>>>        // We also use our own user counting mechanism to guard against the
97468>>>        // database isn't opened already as we need exclusive access to the tables.:
97468>>>        Get phoUserCountSystem to hoUserCountSystem
97469>>>        Get CheckUserCount of hoUserCountSystem to UserCount
97470>>>        Get CurrentNumberOfUsers of hoUserCountSystem to iUserCount
97471>>>
97471>>>        Get pbCheckDataFlexUserCount of hoUserCountSystem to bCheckDataFlexUserCount
97472>>>        // Check DataFlex user count to see if anybody else is using the DataFlex license...
97472>>>        If (bCheckDataFlexUserCount = True) Begin
97474>>>            Get_Current_User_Count to iDataFlexUsers
97475>>>            // For some reason DataFlex - in some cases - might think that 2 users
97475>>>            // are in use while debugging from the Studio.
97475>>>            If (IsDebuggerPresent() and iDataFlexUsers = 2) Begin
97477>>>                Decrement iDataFlexUsers
97478>>>            End
97478>>>>
97478>>>        End
97478>>>>
97478>>>
97478>>>        If (pbSilentMode(Self) = False and iDataFlexUsers > 1) Begin
97480>>>            Get YesNo_Box CS_DatabaseInUseShort to iRetval
97481>>>            If (iRetval <> MBR_Yes) Begin
97483>>>                Send Exit_Application
97484>>>            End
97484>>>>
97484>>>        End
97484>>>>
97484>>>
97484>>>        If (bInUse = True or (UserCount.iError <> 0) or (iUserCount > 1)) Begin
97486>>>            Send Stop_Box CS_DatabaseInUseText
97487>>>            Send Exit_Application
97488>>>        End
97488>>>>
97488>>>
97488>>>        // This will put a look on the DbUpdateLock.ucf file.
97488>>>        // It is released when the update process is finished
97488>>>        Get CheckUserCount of (phoDatabaseUpdateLock(Self)) to UserCount
97489>>>
97489>>>        Move (CurrentDateTime()) to dtUpdateStarted
97490>>>        Set pdtUpdateStart of (phoLogFile(Self)) to dtUpdateStarted
97491>>>        Set Private.pbDatabaseUpdateStarted to True
97492>>>
97492>>>        // This will save the status of all open tables including Master/Alias settings,
97492>>>        // so we can restore them later;
97492>>>        Send SaveOpenTables
97493>>>
97493>>>        // We need to close all tables before starting to make changes.
97493>>>        Close DF_ALL DF_PERMANENT
97494>>>
97494>>>        // If these properties has not exclicitly been set in the object, set them
97494>>>        // to settings from the SQLConnections.ini file;
97494>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
97495>>>        If (psSchema(Self) = "") Begin
97497>>>            Set psSchema            to SQLConnection.sSchema
97498>>>        End
97498>>>>
97498>>>        If (psBaseTableSpace(Self) = "") Begin
97500>>>            Set psBaseTableSpace    to SQLConnection.sBaseTableSpace
97501>>>        End
97501>>>>
97501>>>        If (psLongTableSpace(Self) = "") Begin
97503>>>            Set psLongTableSpace    to SQLConnection.sLongTableSpace
97504>>>        End
97504>>>>
97504>>>        If (psIndexTableSpace(Self) = "") Begin
97506>>>            Set psIndexTableSpace   to SQLConnection.sIndexTableSpace
97507>>>        End
97507>>>>
97507>>>
97507>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
97508>>>        If (SQLConnection.sDriverID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
97510>>>            Procedure_Return
97511>>>        End
97511>>>>
97511>>>        Get SQLUtilCheckIfDatabaseExists of hDbUpdateVersionObject SQLConnection.sDatabase to bExists
97512>>>        If (SQLConnection.sDatabase <> "" and bExists = False) Begin
97514>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
97515>>>            Send Stop_StatusPanel of ghoStatusPanel
97516>>>            Error DFERR_PROGRAM ("The database specified in the connection string: '" + SQLConnection.sDatabase + "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit.")
97517>>>>
97517>>>            Send Exit_Application
97518>>>        End
97518>>>>
97518>>>    End_Procedure
97519>>>
97519>>>    // *** Hook message for pre-processing ***
97519>>>    // The programmer can use this event for putting code that
97519>>>    // needs to be executed _before_ code in any of the cDbUpdateVersion
97519>>>    // child objects are executed.
97519>>>    Procedure OnPreUpdate
97521>>>    End_Procedure
97522>>>
97522>>>    // *** Hook message for post-processing ***
97522>>>    // The programmer should use this event for putting code that
97522>>>    // needs to be executed _after_ all database updates have finished.
97522>>>    Procedure OnPostUpdate
97524>>>    End_Procedure
97525>>>
97525>>>    // *** Hook message for custom DbVersion record find ***
97525>>>    // The programmer can use this event for putting code that
97525>>>    // needs to be executed to find a *custom* DbVersion table record.
97525>>>    // By default the DbVersion table is used but this can be
97525>>>    // customized by adding this line to the code;
97525>>>    // "Define DUF_Use_Custom_DbVersion" before the line "Use cDbUpdateHandler.pkg"
97525>>>    // Note: You do _not_ need to use this event if the DbVersion table is used
97525>>>    //       to save the current database version to. Only if you use your own
97525>>>    //       table _and_ it is not a system table (contains only one record).
97525>>>    Procedure OnFindVersionRecord
97527>>>        // Open MyTable
97527>>>        // Move xx to MyTable.Field1
97527>>>        // Move yy to MyTable.Field2
97527>>>        // Find le MyTable by Index.x
97527>>>    End_Procedure
97528>>>
97528>>>    // Hook event for writing header error text (pre-update) to
97528>>>    // a datatable. Only called if the pbUseDataTable property = True.
97528>>>    // Don't forget to Open the table first (!) as all
97528>>>    // tables have been closed at this stage.
97528>>>    // The start date & time is passed.
97528>>>    Procedure OnErrorWriteHeader_DataTable DateTime dtUpdateStart
97530>>>    End_Procedure
97531>>>
97531>>>    // Hook event to log errors to a database table.
97531>>>    // Only called if the pbUseDataTable = True.
97531>>>    // Don't forget to Open the table first (!) as all
97531>>>    // tables have been closed at this stage.
97531>>>    // If pbQuickWrite = True the DbUpdateErrorArray
97531>>>    // will contain just one row, as it is called for each error
97531>>>    // that occurred. Else it is called once at the end after all updates
97531>>>    // have run and contains all errors.
97531>>>    Procedure OnErrorWriteRow_DataTable tDbUpdateError[] DbUpdateErrorArray
97533>>>    End_Procedure
97534>>>
97534>>>    // Automatically send after all processing is done, but before the OnPostUpdate event.
97534>>>    Procedure Cleanup
97536>>>        Integer[] iFileMasterArray iFileAliasArray
97538>>>        Boolean bDatabaseWasUpdated bError
97538>>>
97538>>>        Send RestoreOpenTables
97539>>>
97539>>>        // The function library have two purposes; one is to use it in the
97539>>>        // Database Update Framework, but it can also be used on its own.
97539>>>        // If that is the case it has its own error handling system, which
97539>>>        // we temporarily disbled when running updates because we have
97539>>>        // error handling/logging here too... We now restore its setting.
97539>>>        If (ghoDbUpdateFunctionLibrary > 0) Begin
97541>>>            Set pbHandleQueryErrors of ghoDbUpdateFunctionLibrary to True
97542>>>        End
97542>>>>
97542>>>        Set pbHandleQueryErrors to True
97543>>>
97543>>>        Get pbDatabaseWasUpdated to bDatabaseWasUpdated
97544>>>        Get pbDbUpdateErrorHasOccured to bError
97545>>>        If (bDatabaseWasUpdated = True or bError = True) Begin
97547>>>
97547>>>            // We should always create the log as it also contains info about
97547>>>            // the update being successful.
97547>>>            Send WriteErrorLog of (phoLogFile(Self))
97548>>>
97548>>>            // This is a programmer's hook message:
97548>>>            Send OnPostUpdate
97549>>>
97549>>>            Send Stop_StatusPanel of ghoStatusPanel
97550>>>
97550>>>            If (pbSilentMode(Self) = False) Begin
97552>>>                If (bError = True) Begin
97554>>>                    If (pbShowErrorLogPostRun(Self) = True) Begin
97556>>>                        Send ShowErrorLog of (phoLogFile(Self))
97557>>>                    End
97557>>>>
97557>>>                    Send Info_Box CS_DbUpdatedErrorText
97558>>>                    Send Exit_Application
97559>>>                End
97559>>>>
97559>>>                Else Begin
97560>>>                    If (Private.pbDatabaseWasUpdated(Self) = True) Begin
97562>>>                        Send Info_Box CS_DatabaseUpdatedText
97563>>>                    End
97563>>>>
97563>>>                    Else Begin
97564>>>                        Send Info_Box CS_DatabaseCheckedText
97565>>>                    End
97565>>>>
97565>>>
97565>>>                End
97565>>>>
97565>>>            End
97565>>>>
97565>>>        End
97565>>>>
97565>>>
97565>>>        // Restore the standard error handler:
97565>>>        Get piCurrentErrorHandlerID to Error_Object_Id
97566>>>    End_Procedure
97567>>>
97567>>>    // We do this _before_ we close the database to make changes, and save
97567>>>    // all 'Master' & 'Alias' tables settings so we can restore when
97567>>>    // we reopen the database.
97567>>>    Procedure SaveOpenTables
97569>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
97569>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
97570>>>        Get _MasterAndAliasFiles to aDbUpdateHandlerMasterAlias
97571>>>        Set paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
97572>>>    End_Procedure
97573>>>
97573>>>    // Returns a struct array with all currently open tables and a "state" that indicates if the table
97573>>>    // was opened DF_FILE_ALIAS_DEFAULT, DF_FILE_IS_MASTER or DF_FILE_IS_ALIAS
97573>>>    Function _MasterAndAliasFiles Returns tDbUpdateHandlerMasterAlias[]
97575>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
97575>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
97576>>>        Integer hTable iMasterAliasType iSize
97576>>>        Boolean bOpen
97576>>>
97576>>>        Move 0 to hTable
97577>>>        Repeat
97577>>>>
97577>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
97580>>>            If (hTable <> 0) Begin
97582>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
97585>>>                If (bOpen = True) Begin
97587>>>                    Get_Attribute DF_FILE_ALIAS of hTable to iMasterAliasType
97590>>>                    Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
97591>>>                    Move hTable to aDbUpdateHandlerMasterAlias[iSize].hTable
97592>>>                    Move iMasterAliasType to aDbUpdateHandlerMasterAlias[iSize].iMode
97593>>>                End
97593>>>>
97593>>>            End
97593>>>>
97593>>>        Until (hTable = 0)
97595>>>
97595>>>        Function_Return aDbUpdateHandlerMasterAlias
97596>>>    End_Function
97597>>>
97597>>>    // Message that re-opens all files in the filelist.cfg and restores any master & alias attributes.
97597>>>    // Takes one parameter:
97597>>>    //   A struct array with all master & alias
97597>>>    Procedure RestoreOpenTables
97599>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
97599>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
97600>>>        Integer hTable iFileAlias iSize iCount
97600>>>        Boolean bOpen
97600>>>        String sRootName
97600>>>
97600>>>        Move 0 to hTable
97601>>>        Get paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
97602>>>        Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
97603>>>        Decrement iSize
97604>>>        For iCount from 0 to iSize
97610>>>>
97610>>>            Move aDbUpdateHandlerMasterAlias[iSize].hTable to hTable
97611>>>            // We also need to check that the table hasn't been removed...
97611>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
97614>>>            If (hTable <> 0 and sRootName <> "") Begin
97616>>>                Open hTable
97618>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
97621>>>                If (bOpen = True) Begin
97623>>>                    Move aDbUpdateHandlerMasterAlias[iSize].iMode to iFileAlias
97624>>>                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
97626>>>                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_MASTER
97629>>>                    End
97629>>>>
97629>>>                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
97632>>>                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_ALIAS
97635>>>                    End
97635>>>>
97635>>>                End
97635>>>>
97635>>>            End
97635>>>>
97635>>>        Loop
97636>>>>
97636>>>    End_Procedure
97637>>>
97637>>>    // This checks for both duplicate pnVersionNumbers _and_ that
97637>>>    // the cDbVersion object pnVersionNumber's all are consecutive (higher than the previous).
97637>>>    Procedure CheckForDuplicates Number nVersion
97639>>>        tDbVersionInfo[] DbVersionInfoArray
97639>>>        tDbVersionInfo[] DbVersionInfoArray
97640>>>        Integer iCount iSize iHits iDuplicateIndex
97640>>>        Number nCompare
97640>>>        Handle hObject1 hObject2
97640>>>        String sObjectName1 sObjectName2
97640>>>        Boolean bObjectOrderError
97640>>>
97640>>>        Get paDbVersionInfoArray to DbVersionInfoArray
97641>>>        Move (SizeOfArray(DbVersionInfoArray)) to iSize
97642>>>        Decrement iSize
97643>>>        Move 0 to iHits
97644>>>        Move 0 to nCompare
97645>>>        Move False to bObjectOrderError
97646>>>        For iCount from 0 to iSize
97652>>>>
97652>>>            If (nVersion = DbVersionInfoArray[iCount].nVersionNumber) Begin
97654>>>                Increment iHits
97655>>>                If (iHits > 1) Begin
97657>>>                    Move iCount to iDuplicateIndex
97658>>>                    If (nCompare <> 0) Begin
97660>>>                        Move (nCompare >= DbVersionInfoArray[iCount].nVersionNumber) to bObjectOrderError
97661>>>                    End
97661>>>>
97661>>>                End
97661>>>>
97661>>>            End
97661>>>>
97661>>>            Move DbVersionInfoArray[iCount].nVersionNumber to nCompare
97662>>>        Loop
97663>>>>
97663>>>        If (iHits > 1) Begin
97665>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
97666>>>            Move DbVersionInfoArray[(iDuplicateIndex   )].hObject to hObject1
97667>>>            Move DbVersionInfoArray[(iDuplicateIndex -1)].hObject to hObject2
97668>>>            Move (Name(hObject1)) to sObjectName1
97669>>>            Move (Name(hObject2)) to sObjectName2
97670>>>            Error DFERR_PROGRAM ("Duplicate version numbers! The SAME pnVersionNumber value was set for the following two objects; Program will now exit!\n\n" + sObjectName1 + "\n" + sObjectName2)
97671>>>>
97671>>>            Send Exit_Application
97672>>>        End
97672>>>>
97672>>>        Else If (bObjectOrderError = True) Begin
97675>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
97676>>>            Error DFERR_PROGRAM ("cDbVersion objects out of order! One or more of the cDbVersion objects has been placed out of order. This means that at least one pnVersionNumber is HIGHER than the following object's pnVersionNumber.\nProgram will now exit!")
97677>>>>
97677>>>            Send Exit_Application
97678>>>        End
97678>>>>
97678>>>    End_Procedure
97679>>>
97679>>>    // We take care of all errors in the Error_Report below and
97679>>>    // collect them all to an array property. So just ignore any
97679>>>    // "Ignore_Error" & "Trap_Error" messages that might be send/used
97679>>>    // in some other package.
97679>>>    Procedure Ignore_Error Integer iError
97681>>>    End_Procedure
97682>>>
97682>>>    Procedure Trap_Error Integer iError
97684>>>    End_Procedure
97685>>>
97685>>>    // While we update the database we collect all errors in
97685>>>    // the struct array paDbUpdateErrorArray.
97685>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
97687>>>        Number nVersion
97687>>>        Handle hoLogFile 
97687>>>        
97687>>>        If (Private.pbProcessingError(Self)) Begin
97689>>>            Procedure_Return
97690>>>        End
97690>>>>
97690>>>
97690>>>        // The UtilTableNameFromHandleToString function does a:
97690>>>        // "Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName" call
97690>>>        // and it generates an error if the table is of the embedded type.
97690>>>        // As we don't want to trigger an error in that very specific case,
97690>>>        // we just ignore it here.
97690>>>        //
97690>>>        // If no report mode, just set the err indicator to true.
97690>>>        If (Error_Report_Mode(Self) = DUF_ERROR_NO_REPORT) Begin
97692>>>            Move False to Err
97693>>>            Procedure_Return
97694>>>        End
97694>>>>
97694>>>
97694>>>        If (iErrorNumber = DFERR_UNSUPPORTED_ATTRIBUTE) Begin
97696>>>            Procedure_Return
97697>>>        End
97697>>>>
97697>>>
97697>>>        Set Private.pbProcessingError to True
97698>>>        Set Private.pbUpdateVersionObjectError to True
97699>>>
97699>>>        Set pbDbUpdateErrorHasOccured to True
97700>>>        Get pnCurrentVersionUpdate to nVersion
97701>>>        Get phoLogFile to hoLogFile
97702>>>        Send LogError of hoLogFile nVersion iErrorNumber sErrorText iErrorLine True
97703>>>
97703>>>        Set Private.pbProcessingError to False
97704>>>    End_Procedure
97705>>>
97705>>>End_Class
97706>Use vWin32fh.pkg
97706>
97706>Object oHtmlHelp is a cHtmlHelp
97708>End_Object
97709>
97709>
97709>Object oApplication is a cApplication
97711>    Set psCompany to "RDC Tools International"
97712>    Set psProduct to "The Database Update Framework - Database Compare and Code Generator"
97713>    Set peHelpType to htHtmlHelp
97714>    // Note: The help file settings gets changed by the Help toolbar button(s).
97714>    Set psHelpFile to "DataFlex.chm"
97715>
97715>    Property Handle phoDbUpdateHandler
97717>    Property Handle phoTableDUFCodeGenerator_vw 0
97719>    Property String psFilelistFrom ""
97721>    Property Integer[] piaDifferences
97723>    Property String psOrgOpenPath
97725>
97725>    Object oConnection is a cConnection
97727>        Use LoginEncryption.pkg
Including file: LoginEncryption.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\LoginEncryption.pkg)
97727>>>Use cLoginEncryption.pkg
Including file: cLoginEncryption.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cLoginEncryption.pkg)
97727>>>>>Use cCryptographer.pkg
97727>>>>>
97727>>>>>Class cLoginEncryption is a cObject
97728>>>>>    
97728>>>>>    Procedure Construct_Object
97730>>>>>        Forward Send Construct_Object
97732>>>>>        // this must be set to a multi (40ish) character random key
97732>>>>>        Property String psEncryptPassword ""
97733>>>>>    
97733>>>>>        Object oDataCrypter is a cCryptographer
97735>>>>>            Set piHash to CALG_SHA_256
97736>>>>>            Set piCipher to CALG_AES_256
97737>>>>>            Set psProvider to "" //  Not providing a specific provider gives the default provider for the provider type
97738>>>>>            Set piProvider to PROV_RSA_AES
97739>>>>>        End_Object
97740>>>>>    End_Procedure
97741>>>>>        
97741>>>>>    // This can be augmented to return a password encryption key using any
97741>>>>>    // hidden mechanism desired.    
97741>>>>>    Function GetEncryptionPassword Returns String
97743>>>>>        String sPassword
97743>>>>>        Get psEncryptPassword to sPassword    
97744>>>>>        Function_Return sPassword
97745>>>>>    End_Function
97746>>>>>    
97746>>>>>    // EncryptPassword:
97746>>>>>    
97746>>>>>    // Encrypts a string into an unreadable hash that can later be decrypted using DecryptKey.
97746>>>>>    //
97746>>>>>    // Params:
97746>>>>>    //   sPlainText     String to encrypt.
97746>>>>>    // Returns:
97746>>>>>    //   Base64 encoded hash.
97746>>>>>    Function EncryptPassword String sPlainText Returns String
97748>>>>>        String sEncryptPassword sBinary sBase64
97748>>>>>        Address pBase64
97748>>>>>        Integer iVoid
97748>>>>>        
97748>>>>>        //  Encrypt Key
97748>>>>>        Get GetEncryptionPassword to sEncryptPassword
97749>>>>>        If (sEncryptPassword = "") Begin
97751>>>>>            Error DFERR_PROGRAM "No encryption password set" 
97752>>>>>>
97752>>>>>        End
97752>>>>>>
97752>>>>>        
97752>>>>>        Get Encrypt of oDataCrypter sEncryptPassword sPlainText to sBinary
97753>>>>>        
97753>>>>>        If (sPlainText = sBinary or sBinary = "") Begin
97755>>>>>            Error DFERR_PROGRAM "Unable to encrypt database login password"
97756>>>>>>
97756>>>>>            Function_Return ""
97757>>>>>        End
97757>>>>>>
97757>>>>>        
97757>>>>>        //  Encode binary hash to Base64
97757>>>>>        Move (Base64Encode(AddressOf(sBinary), Length(sBinary))) to pBase64
97758>>>>>        Move pBase64 to sBase64
97759>>>>>        Move (Free(pBase64)) to iVoid
97760>>>>>        
97760>>>>>        Function_Return sBase64
97761>>>>>    End_Function
97762>>>>>    
97762>>>>>    
97762>>>>>    // DecryptPassword:
97762>>>>>    
97762>>>>>    // Decrypts the unreadable hash generated by EncryptKey into a readable string.
97762>>>>>    //
97762>>>>>    // Params:
97762>>>>>    //   sBase64EncryptedPassword       Base64 Encrypted password
97762>>>>>    // Returns:
97762>>>>>    //   Readable plain text password
97762>>>>>    Function DecryptPassword String sBase64EncryptedPassword Returns String
97764>>>>>        String sEncryptPassword sPlainText sBinary
97764>>>>>        Boolean bIsHex
97764>>>>>        Integer iLen iVoid
97764>>>>>        Address pBinary
97764>>>>>        
97764>>>>>        If (sBase64EncryptedPassword <> "") Begin
97766>>>>>            //  Decode from Base64
97766>>>>>            Move (Base64Decode(AddressOf(sBase64EncryptedPassword), &iLen)) to pBinary
97767>>>>>            
97767>>>>>            Move (Repeat(Character(0), iLen)) to sBinary
97768>>>>>            Move (CopyMemory(AddressOf(sBinary), pBinary, iLen)) to iVoid
97769>>>>>            
97769>>>>>            Move (Free(pBinary)) to iVoid
97770>>>>>    
97770>>>>>            //  Encrypted binary hash to string
97770>>>>>            Get GetEncryptionPassword to sEncryptPassword
97771>>>>>            Get Decrypt of oDataCrypter sEncryptPassword sBinary to sPlainText
97772>>>>>        End
97772>>>>>>
97772>>>>>        
97772>>>>>        Function_Return sPlainText
97773>>>>>    End_Function
97774>>>>>End_Class
97775>>>>>    
97775>>>
97775>>>Object oLoginEncryption is a cLoginEncryption
97777>>>
97777>>>    // this must be created in your appsrc directory and must contain an encryption
97777>>>    // key that is set to psEncryptPassword. It will look something like this
97777>>>    //
97777>>>    // Set psEncryptPassword to "JchUAo7W@r.b{<Yk~OONi0nq=sMi[*Rn[A-`Vo)q"
97777>>>    //  
Including file: LoginEncryptionKey.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\LoginEncryptionKey.inc)
97777>>>>// Studio generated login encryption key
97777>>>>Set psEncryptPassword to "%sLm*XHVF>f0yB.:.PHrBx6L)8x70i7zAN{q._WC"
97778>>>>
97778>>>    
97778>>>    // use this to register this object to your cConnection Object. This object
97778>>>    // must be created after the cConnection object
97778>>>    Move Self to ghoLoginEncryption
97779>>>End_Object
97780>        Use DatabaseLoginDialog.dg
Including file: DatabaseLoginDialog.dg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\DatabaseLoginDialog.dg)
97780>>>
97780>>>Use Windows.pkg
97780>>>Use cConnection.pkg
97780>>>Use dfLine.pkg
97780>>>
97780>>>Object oDatabaseLoginDialog is a ModalPanel
97782>>>    Set Label to "Database Login"
97783>>>    Set Location to 2 2
97784>>>    Set Size to 110 211
97785>>>
97785>>>    Property String psId
97787>>>    Property Boolean pbOk False
97789>>>    Property Boolean pbChanged False
97791>>>    Property Boolean pbAllowRemember True
97793>>>
97793>>>    // this registers this object with the cConnection object.
97793>>>    Move Self to ghoLoginConnectDialog
97794>>>
97794>>>    Object oUserIDForm is a Form
97796>>>        Set Label to "User Name"
97797>>>        Set Size to 13 85
97798>>>        Set Location to 34 79
97799>>>        Set Label_Col_Offset to 64
97800>>>                Set peAnchors to anTopLeftRight
97801>>>    End_Object
97802>>>
97802>>>    Object oPwdForm is a Form
97804>>>        Set Size to 13 85
97805>>>        Set Location to 49 79
97806>>>        Set Label_Col_Offset to 64
97807>>>        Set Password_State to True
97808>>>                Set peAnchors to anTopLeftRight
97809>>>        Set Label to "Password"
97810>>>    End_Object
97811>>>
97811>>>    Object oTrustedConnection is a CheckBox
97813>>>        Set Size to 10 50
97814>>>        Set Location to 65 79
97815>>>        Set Label to "Trusted Connection"
97816>>>    End_Object
97817>>>
97817>>>    Object oRemember is a CheckBox
97819>>>        Set Size to 10 50
97820>>>        Set Location to 79 14
97821>>>        Set Label to "Remember and don't ask again"
97822>>>        Set Checked_State to True
97823>>>    End_Object
97824>>>
97824>>>    Object oLogin_btn is a Button
97826>>>        Set Label to "&Login"
97827>>>        Set Location to 92 102
97828>>>        Set peAnchors to anBottomRight
97829>>>        Set Default_State to True
97830>>>
97830>>>        Procedure OnClick
97833>>>            Boolean bTrust
97833>>>            String sUser sPwd sConn sErr sId
97833>>>            Integer iError
97833>>>            Get psId to sId
97834>>>            Get Value of oUserIDForm to sUser
97835>>>            Get Value of oPwdForm to sPwd
97836>>>            Get Checked_State of oTrustedConnection to bTrust
97837>>>            
97837>>>            Get LoginConnectIdNewCredentials of ghoConnection sId sUser sPwd bTrust to iError
97838>>>            If (iError=0) Begin
97840>>>                Set pbOk to True
97841>>>                Set pbChanged to True
97842>>>                // using Stop_UI instead of close_panel keeps it running when the dialog
97842>>>                // is the only dialog and it closes
97842>>>                Send Stop_UI
97843>>>//                Send Close_Panel
97843>>>            End
97843>>>>
97843>>>            Else Begin
97844>>>                Get psErrorText of ghoConnection to sErr
97845>>>                Send UserError sErr "Login Error"
97846>>>            End
97846>>>>
97846>>>        End_Procedure
97847>>>    End_Object
97848>>>
97848>>>    Object oCancel_btn is a Button
97850>>>        Set Label to "&Cancel"
97851>>>        Set Location to 92 157
97852>>>        Set peAnchors to anBottomRight
97853>>>
97853>>>        Procedure OnClick
97856>>>            Send Stop_UI
97857>>>//            Send Close_Panel
97857>>>        End_Procedure
97858>>>    End_Object
97859>>>
97859>>>    Object oConnectionIdInfo is a TextBox
97861>>>        Set Size to 10 50
97862>>>        Set Location to 4 14
97863>>>        Set Label to 'Connection Id='
97864>>>    End_Object
97865>>>
97865>>>    Object oConnectionServerInfo is a TextBox
97867>>>        Set Size to 10 50
97868>>>        Set Location to 16 14
97869>>>        Set Label to 'Server'
97870>>>    End_Object
97871>>>
97871>>>    Object oLineControl1 is a LineControl
97873>>>        Set Size to 2 202
97874>>>        Set Location to 29 5
97875>>>    End_Object
97876>>>
97876>>>    Function LoginConnectIdDialog String sId Returns Boolean
97879>>>         Boolean bOk bChanged bTrusted bAllowRemember bRemember
97879>>>         String sUser sPwd sDescription
97879>>>         tConnection Connect
97879>>>         tConnection Connect
97879>>>         
97879>>>         Get pbAllowRemember to bAllowRemember
97880>>>         
97880>>>
97880>>>         If not bAllowRemember Begin
97882>>>            Set Enabled_State of oRemember to bRemember
97883>>>            Set Visible_State of oRemember to bRemember
97884>>>         End
97884>>>>
97884>>>         
97884>>>         Get ConnectionIdInfo of ghoConnection sId to Connect
97885>>>         Set Value of oConnectionIdInfo to ("Connection ID="+Connect.sId)
97886>>>         Set Value of oConnectionServerInfo to Connect.sString
97887>>>
97887>>>         Set psId to sId
97888>>>         Set pbOk to False
97889>>>         Set pbChanged to False
97890>>>         Set Value of oUserIDForm to Connect.sUID
97891>>>         Set Value of oPwdForm to ""
97892>>>         
97892>>>         Send Popup
97893>>>         
97893>>>         Get pbOk to bOk
97894>>>         Get pbChanged to bChanged
97895>>>         If (bChanged and bOk) Begin
97897>>>            If bAllowRemember Begin
97899>>>                Get Checked_State of oRemember to bRemember
97900>>>                If bRemember Begin
97902>>>                    Get Checked_State of oTrustedConnection to bTrusted
97903>>>                    If not (bTrusted) Begin
97905>>>                        Get Value of oUserIDForm to sUser
97906>>>                        Get Value of oPwdForm to sPwd
97907>>>                    End
97907>>>>
97907>>>                    Get StoreConnectionIdCredentials of ghoConnection sId sUser sPwd bTrusted to bOk
97908>>>                 End
97908>>>>
97908>>>             End
97908>>>>
97908>>>         End
97908>>>>
97908>>>         Function_Return bOk
97909>>>    End_Function
97910>>>    
97910>>>    
97910>>>    On_Key Key_Alt+Key_O Send KeyAction of oLogin_btn
97911>>>    On_Key Key_Alt+Key_L Send KeyAction of oCancel_btn
97912>>>End_Object
97913>>>
97913>    End_Object
97914>
97914>    // Set psOrgOpenPath at startup
97914>    Procedure Save_DF_OPEN_PATH
97917>        String sOrgOpenPath sDataPath
97917>        Get_Attribute DF_OPEN_PATH to sOrgOpenPath
97920>        // First remove the current Data folder path
97920>        Get PathAtIndex of (phoWorkspace(ghoApplication)) sOrgOpenPath 1 to sDataPath
97921>        Move (Replace(sDataPath, sOrgOpenPath, "")) to sOrgOpenPath
97922>        If (Left(sOrgOpenPath, 2) = "\;") Begin
97924>            Move (Replace("\;", sOrgOpenPath, "")) to sOrgOpenPath
97925>        End
97925>        Set psOrgOpenPath to sOrgOpenPath
97926>    End_Procedure
97927>
97927>    Procedure OnWorkspaceOpened
97930>        Forward Send OnWorkspaceOpened
97932>        Send Save_DF_OPEN_PATH
97933>    End_Procedure
97934>
97934>    Procedure Restore_DF_OPEN_PATH
97937>        String sOrgOpenpath
97937>        Get psOrgOpenPath to sOrgOpenpath
97938>        Set_Attribute DF_OPEN_PATH to sOrgOpenPath
97941>    End_Procedure
97942>
97942>    Function ChangeFilelistPathing String sFileList Returns Boolean
97945>        String sPath sSQLConnectionsIniName sDataPath sDriverID sServer sOrgOpenPath
97945>        Boolean bExists bEmbedded
97945>        Handle hoDbUpdateHandler hoSQLConnectionHandler hoSQLConnectionIniFile
97945>        tSQLConnection SQLConnection
97945>        tSQLConnection SQLConnection
97945>        Integer iRetval
97945>
97945>        Move False to Err
97946>        Move (Trim(sFileList)) to sFileList
97947>        Get vFilePathExists sFileList to bExists
97948>        If (bExists = False) Begin
97950>            Function_Return False
97951>        End
97951>
97951>        Send Cursor_Wait of Cursor_Control
97952>        Send Restore_DF_OPEN_PATH
97953>        Close DF_ALL DF_PERMANENT
97954>        Logout sDriverID sServer
97955>        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
97956>        Get psServer   of ghoDbUpdateFunctionLibrary to sServer
97957>
97957>        Get ParseFolderName sFileList                      to sDataPath
97958>        If (Right(sDataPath, 1) = "\") Begin
97960>            Move (Left(sDataPath, (Length(sDataPath) -1))) to sDataPath
97961>        End
97961>        Set psDataPath of (phoWorkspace(ghoApplication))   to sDataPath
97962>        Set psFileList of (phoWorkspace(ghoApplication))   to sFileList
97963>
97963>        // Temporarily "redirect" the Open path to the current Data folder
97963>        Get psOrgOpenPath to sOrgOpenPath
97964>        Set_Attribute DF_OPEN_PATH to (sDataPath + ";" + sOrgOpenPath)
97967>        Set_Attribute DF_FILELIST_NAME                     to sFileList
97970>
97970>        Get vFolderFormat sDataPath to sPath
97971>        // Note: We delete all cache files (*.cch) before
97971>        // attempting to open any tables as a precausion, in case the table has been changed at the SQL end:
97971>        Get vDeleteFile (sPath + "*.cch") to iRetval
97972>
97972>        // Try to make a database driver connection:
97972>        Get vParentPath sDataPath to sPath
97973>        Get vFolderFormat sPath   to sPath
97974>        Move (sPath + "Programs") to sPath
97975>        Get vFolderFormat sPath   to sPath
97976>        Move CS_SQLIniFileName to sSQLConnectionsIniName
97977>        Get vFilePathExists (sPath + sSQLConnectionsIniName) to bExists
97978>        If (bExists = False) Begin
97980>            Get UtilFilelistIsDataFlexTablesOnly of ghoDbUpdateFunctionLibrary to bEmbedded
97981>            If (bEmbedded = False) Begin
97983>                Send Cursor_Ready of Cursor_Control
97984>                Get YesNo_Box ("Couldn't find the DUF SQLConnections.ini file in the workspace Programs folder. Is there a DataFlex DFConnId.ini file in the Data folder that you want to open instead?") to iRetval
97985>                If (iRetval = MBR_Yes) Begin
97987>                    Send Cursor_Wait of Cursor_Control
97988>                    Move "DFConnId.ini" to sSQLConnectionsIniName
97989>                    Send UnRegisterAllConnections of ghoConnection
97990>                    Get AddAllConnections of ghoConnection to bExists
97991>                    Set psIniFileName of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sSQLConnectionsIniName
97992>                    Set psIniFilePath of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sPath
97993>                    Get SetupSQLConnection of ghoSQLConnectionHandler True False to SQLConnection
97994>                End
97994>            End
97994>        End
97994>        Else Begin
97995>            Get phoDbUpdateHandler of ghoApplication to hoDbUpdateHandler
97996>            Get phoSQLConnectionHandler of hoDbUpdateHandler to hoSQLConnectionHandler
97997>            Get phoSQLConnectionIniFile of hoSQLConnectionHandler to hoSQLConnectionIniFile
97998>            Set psIniFilePath of hoSQLConnectionIniFile to sPath
97999>            Set psIniFileName of hoSQLConnectionIniFile to sSQLConnectionsIniName
98000>
98000>            Get SetupSQLConnection of hoSQLConnectionHandler True True to SQLConnection
98001>            Set pSQLConnection     of hoSQLConnectionHandler to SQLConnection
98002>        End
98002>
98002>        Send Cursor_Ready of Cursor_Control
98003>        Function_Return (Err = False)
98004>    End_Function
98005>
98005>End_Object
98006>
98006>Object oDbUpdateHandler is a cDbUpdateHandler
98008>    Set Data_File_Field to File_Field DbVersion.DatabaseVersion
98009>    Set phoDbUpdateHandler of ghoApplication to Self
98010>End_Object
98011>
98011>Object oToolTipController is a cToolTipController
98013>    Move Self to ghoToolTipController
98014>    Set pbBalloonStyle to False
98015>    Set piIcon to TTI_INFO
98016>    Set psTitle to "Information"
98017>    Set piMaxWidth to 400
98018>    Set piDurationPopup to 14000    // 14 seconds, needed for long tooltips.
98019>End_Object
98020>
98020>Use oEditContextMenu.pkg
Including file: oEditContextMenu.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\oEditContextMenu.pkg)
98020>>>Use cCJStandardMenuItemClasses.pkg
98020>>>
98020>>>Object oEditContextMenu is a cCJContextMenu
98022>>>    
98022>>>    Move Self to Default_Form_Floating_Menu_ID
98023>>>    
98023>>>    Object oUndoMenuItem is a cCJUndoMenuItem
98025>>>    End_Object
98026>>>    
98026>>>    Object oCutMenuItem is a cCJCutMenuItem
98028>>>        Set pbControlBeginGroup to True
98029>>>    End_Object
98030>>>    
98030>>>    Object oCopyMenuItem is a cCJCopyMenuItem
98032>>>    End_Object
98033>>>
98033>>>    Object oPasteMenuItem is a cCJPasteMenuItem
98035>>>    End_Object
98036>>>
98036>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
98038>>>    End_Object
98039>>>
98039>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
98041>>>        Set pbControlBeginGroup to True
98042>>>    End_Object
98043>>>
98043>>>End_Object
98044>>>
98044>Use oDEOEditContextMenu17.pkg
Including file: oDEOEditContextMenu17.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\oDEOEditContextMenu17.pkg)
98044>>>Use Windows.pkg
98044>>>Use cCJStandardMenuItemClasses.pkg
98044>>>Use cCJDeoMenuItemClasses.pkg
98044>>>
98044>>>
98044>>>Object oDEOEditContextMenu17 is a cCJContextMenu
98046>>>    
98046>>>    Move Self to Default_dbFloating_Menu_ID
98047>>>    
98047>>>    Object oUndoMenuItem is a cCJUndoMenuItem
98049>>>    End_Object
98050>>>    
98050>>>    Object oCutMenuItem is a cCJCutMenuItem
98052>>>        Set pbControlBeginGroup to True
98053>>>    End_Object
98054>>>    
98054>>>    Object oCopyMenuItem is a cCJCopyMenuItem
98056>>>    End_Object
98057>>>
98057>>>    Object oPasteMenuItem is a cCJPasteMenuItem
98059>>>    End_Object
98060>>>
98060>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
98062>>>    End_Object
98063>>>
98063>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
98065>>>        Set pbControlBeginGroup to True
98066>>>    End_Object
98067>>>
98067>>>    Object oPromptMenuItem is a cCJPromptMenuItem
98069>>>        Set pbControlBeginGroup to True
98070>>>    End_Object
98071>>>
98071>>>    Object oFindNextMenu is a cCJFindNextMenuItem
98073>>>        Set pbControlBeginGroup to True
98074>>>    End_Object
98075>>>
98075>>>    Object oFindPreviousMenu is a cCJFindPreviousMenuItem
98077>>>    End_Object
98078>>>
98078>>>    Object oClearMenuItem is a cCJClearMenuItem
98080>>>        Set pbControlBeginGroup to True
98081>>>    End_Object
98082>>>
98082>>>    Object oClearAllMenu is a cCJClearAllMenuItem
98084>>>    End_Object
98085>>>
98085>>>    Object oSaveMenu is a cCJSaveMenuItem
98087>>>    End_Object
98088>>>    
98088>>>    Object oDeleteMenu is a cCJDeleteMenuItem
98090>>>    End_Object
98091>>>
98091>>>    Object oRememberitem is a cCJRememberFieldMenuItem
98093>>>        Set pbControlBeginGroup to True
98094>>>    End_Object
98095>>>
98095>>>    Object oRetainItem is a cCJRememberLastFieldMenuItem
98097>>>    End_Object
98098>>>
98098>>>    Object oUnRememberitem is a cCJUnRememberFieldMenuItem
98100>>>    End_Object
98101>>>
98101>>>    Object oCJClearAllDynamicDefaults is a cCJUnRememberFieldAllMenuItem
98103>>>    End_Object
98104>>>
98104>>>End_Object
98105>
98105>Object oMain is a Panel
98107>    Set Label to (psProduct(ghoApplication))
98108>    Set Location to 4 3
98109>    Set Size to 350 602
98110>    Set piMinSize to 350 573
98111>    Set Icon to "DUFUpdateCodeGenerator.ico"
98112>
98112>    Object oCommandBarSystem is a cCJCommandBarSystem
98114>        Set pbTimerUpdate to True
98115>            Set pbAutoResizeIcons to True
98116>            Set pbTabbedWorkspaces to True
98117>        Set pbLargeIcons to True
98118>        Set peVisualTheme to xtpThemeVisualStudio2008
98119>
98119>        Procedure OnCreateCommandBars
98122>            Integer eTheme
98122>            Forward Send OnCreateCommandBars
98124>//            #IF (Required_RT_Version < 19)
98124>                Send DisplayTabWorkspace
98125>//            #ENDIF
98125>            Get peVisualTheme to eTheme
98126>            Send SetTheTheme eTheme
98127>        End_Procedure
98128>
98128>//        #IF (Required_RT_Version < 19)
98128>        Procedure DisplayTabWorkspace
98131>            Variant vTab vPaintManager
98131>            Handle hoTab hoPaintManager hoOptions
98131>            Integer iSize
98131>
98131>            If (not(IsComObjectCreated(Self))) Begin
98133>                Procedure_Return
98134>            End
98134>
98134>            Get OptionsObject to hoOptions
98135>
98135>            // Create the tab workspace object. It will get created for the Client_Area so
98135>            // each view will be displayd on a separate tab-page (instead of the standard VDF MDI-interface)
98135>            Get Create (RefClass(cCJTabWorkspace)) to hoTab
98136>            Get ComShowTabWorkspace True to vTab
98137>            // Connect the CodeJock side to the DataFlex proxy object.
98137>            Set pvComObject  of hoTab to vTab
98138>
98138>            // We don't allow to close tabs as we have no menu system.
98138>            Set ComFlags of hoTab to xtpWorkspaceHideAll
98139>            Send ComEnableGroups of hoTab
98140>
98140>            // Create a paint manager object that is needed to set some
98140>            // of the tab-workspace properties.
98140>            Get Create (RefClass(cCJTabPaintManager)) to hoPaintManager
98141>            Get ComPaintManager of hoTab          to vPaintManager
98142>            Set pvComObject     of hoPaintManager to vPaintManager
98143>
98143>            // This will truncate the middle part of long items
98143>            Set ComDrawTextPathEllipsis of hoPaintManager to True
98144>            Set ComLayout               of hoPaintManager to xtpTabLayoutMultiRow
98145>
98145>//#ELSE
98145>            Get Create (RefClass(cCJPaintManager)) to hoPaintManager
98146>            Get ComPaintManager of hoPaintManager  to vPaintManager
98147>            Set pvComObject     of hoPaintManager  to vPaintManager
98148>            Set ComAutoResizeIcons of hoPaintManager to True
98149>//#ENDIF
98149>            Send Destroy of hoPaintManager
98150>            Send ComRecalcLayout
98151>            Send Destroy of hoTab
98152>        End_Procedure
98153>//        #ENDIF
98153>
98153>        Procedure OnCreateTabbedWorkspace Handle hoTabWorkspace Handle hoTabPaintManager
98156>            Set ComShowIcons of hoTabPaintManager to True
98157>            Send ComSetIconSize of hoTabPaintManager 24 24
98158>
98158>            // This will truncate the middle part of long items
98158>            Set ComDrawTextPathEllipsis of hoTabPaintManager to True
98159>        End_Procedure
98160>
98160>        Procedure SetTheTheme Integer eTheme
98163>            Integer iColor
98163>            Set peVisualTheme of ghoCommandBars to eTheme
98164>            Send ComRecalcLayout of ghoCommandBars
98165>            Get ComGetSpecialColor of ghoCommandBars XPCOLOR_TOOLBAR_FACE to iColor
98166>            Broadcast Recursive Set Color of (Client_Id(phoMainPanel(ghoApplication))) to iColor
98168>        End_Procedure
98169>
98169>        // This is needed to get the "Key_Shift+Key_Tab" key combination to activate
98169>        // the previous tab workspace view.
98169>        Object oPreviousTabAction is a cCJAction
98171>            Set piShortCutKey to (xtpKey_Shift + xtpKey_Ctrl) VK_TAB
98172>            Procedure OnExecute Variant vCommandBarControl
98175>                Handle hoCommandBars hoClientArea
98175>                Forward Send OnExecute vCommandBarControl
98177>                Get CommandBarSystemObject to hoCommandBars
98178>                Get ClientAreaObject of hoCommandBars to hoClientArea
98179>                If hoClientArea Begin
98181>                    Send Switch_Next_View of hoClientArea
98182>                End
98182>            End_Procedure
98183>        End_Object
98184>
98184>        Object oEditToolBar is a cCJToolbar
98186>            Set psTitle to "Edit Toolbar"
98187>            Set peStretched to stStretch
98188>            Set pbGripper to False
98189>
98189>            Object oCutToolbarItem is a cCJCutMenuItem
98191>                Set psImage to "ActionCutBlack.ico"
98192>            End_Object
98193>
98193>            Object oCopyToolbarItem is a cCJCopyMenuItem
98195>                Set psImage to "ActionCopyBlack.ico"
98196>
98196>            End_Object
98197>
98197>            Object oPasteToolbarItem is a cCJPasteMenuItem
98199>                Set psImage to "ActionPasteBlack.ico"
98200>            End_Object
98201>
98201>            Object oDeleteEditToolbarItem is a cCJDeleteEditMenuItem
98203>                Set psImage to "ActionDeleteBlack.ico"
98204>                Set pbControlBeginGroup to True
98205>            End_Object
98206>
98206>            Object oPromptToolItem is a cCJPromptMenuItem
98208>                Set psImage to "ActionPromptBlack.ico"
98209>                Set pbControlBeginGroup to True
98210>            End_Object
98211>
98211>            Object oClearToolItem is a cCJClearMenuItem
98213>                Set peControlStyle to xtpButtonIconAndCaption
98214>                Set psCaption      to "Clear/Add"
98215>                Set pbControlBeginGroup to True
98216>                Set psImage to "ActionClearBlack.ico"
98217>                Function IsEnabled Returns Boolean
98220>                    Function_Return True
98221>                End_Function
98222>
98222>            End_Object
98223>
98223>//Register_Procedure ChangeFilelistPathing String sFilelistPath
98223>
98223>            Object oCompareToolItem is a cCJMenuItem
98225>                Set peControlStyle to xtpButtonIconAndCaption
98226>                Set psCaption to "&Settings"
98227>                Set psImage to "SQLBlack2.ico"
98228>                Set piShortCutKey to xtpKey_Alt VK_S
98229>                Set pbControlBeginGroup to True
98230>
98230>                Procedure OnExecute Variant vCommandBarControl
98233>                    tSQLConnection Connection
98233>                    tSQLConnection Connection
98233>                    String sFileListFrom sCurrentFilelist
98233>                    Handle hoFocus
98233>                    Boolean bExists bOK
98233>
98233>                    Move (Focus(Desktop)) to hoFocus
98234>                    Forward Send OnExecute vCommandBarControl
98236>
98236>                    // First change the "current" filelist depending on which
98236>                    // Filelist form is active.
98236>                    Get Value of hoFocus to sCurrentFilelist
98237>                    Get vFilePathExists sCurrentFilelist to bExists
98238>                    Get psFilelistFrom of ghoApplication to sFileListFrom
98239>                    If (bExists = True and sCurrentFilelist <> "") Begin
98241>                        Get ChangeFilelistPathing of ghoApplication sCurrentFilelist to bOK
98242>                        Get psFilelistFrom of ghoApplication to sFileListFrom
98243>                    End
98243>
98243>                    If (sFileListFrom <> "") Begin
98245>                        Get pSQLConnection of ghoSQLConnectionHandler to Connection
98246>                    End
98246>                    Send Activate_ReadOnlySQLMaintainConnections_dg of (Client_Id(ghoCommandBars)) Connection
98247>
98247>                End_Procedure
98248>
98248>            End_Object
98249>
98249>            Object oAddToStudio_MenuItem is a cCJMenuItem
98251>                Set psCaption to "Add to Studio"
98252>                Set psDescription to "Add to Studio"
98253>                Set psToolTip to "Add this tool to the DataFlex Studio's 'Tools' menu"
98254>                Set psImage to "ActionAddBlack.ico"
98255>                Set pbControlBeginGroup to True
98256>                Procedure OnExecute Variant vCommandBarControl
98259>                    Forward Send OnExecute vCommandBarControl
98261>                    Send Popup of (oAddToStudio_dg(Client_Id(phoMainPanel(ghoApplication))))
98262>                End_Procedure
98263>            End_Object
98264>
98264>            Object oTheme_MenuItem is a cCJMenuItem
98266>                Set peControlType to xtpControlLabel
98267>                Set pbControlBeginGroup to True
98268>                Set psCaption to "Theme:"
98269>//                Set psImage to "ActionThemes.ico"
98269>            End_Object
98270>
98270>            Object oThemeItem is a cCJMenuItem
98272>                Set peControlType to xtpControlComboBox
98273>                Set psToolTip to "Select a theme to change the appearance."
98274>
98274>                Procedure OnCreateControl Handle hoObj
98277>                    Integer iItem eTheme
98277>                    Set ComWidth of hoObj to 250
98278>                    Send FillComboList hoObj
98279>                    Get peVisualTheme to eTheme
98280>                    Get FindDataItem hoObj eTheme to iItem
98281>                    Set ComListIndex of hoObj to (If(iItem,iItem,1))
98282>                End_Procedure
98283>
98283>                Function FindDataItem Handle hoCombo Integer eVal Returns Integer
98286>                    Integer iCount i eTheme
98286>                    Get ComListCount of hoCombo to iCount
98287>                    For i from 1 to iCount
98293>                        Get ComItemData of hoCombo i to eTheme
98294>                        If (eTheme=eVal) Begin
98296>                            Send SetTheTheme eTheme
98297>                            Function_Return i
98298>                        End
98298>                    Loop
98299>                    Function_Return 0
98300>                End_Function
98301>
98301>                Procedure AddTheme Handle hoCombo String sText Integer eTheme
98304>                    Integer iCount
98304>                    Get ComListCount of hoCombo to iCount
98305>                    Increment iCount
98306>                    Send ComAddItem  of hoCombo sText iCount
98307>                    Set ComItemData  of hoCombo iCount to  eTheme
98308>                End_Procedure
98309>
98309>                Procedure FillComboList Handle hoCombo
98312>                    Send ComClear     of hoCombo
98313>
98313>                    Send AddTheme hoCombo "xtpThemeOffice2013Word" xtpThemeOffice2013Word
98314>                    Send AddTheme hoCombo "xtpThemeOffice2013Outlook" xtpThemeOffice2013Outlook
98315>                    Send AddTheme hoCombo "xtpThemeOffice2013Excel" xtpThemeOffice2013Excel
98316>                    Send AddTheme hoCombo "xtpThemeOffice2013PowerPoint" xtpThemeOffice2013PowerPoint
98317>                    Send AddTheme hoCombo "xtpThemeOffice2013Publisher" xtpThemeOffice2013Publisher
98318>                    Send AddTheme hoCombo "xtpThemeOffice2013OneNote" xtpThemeOffice2013OneNote
98319>                    Send AddTheme hoCombo "xtpThemeOffice2013Access" xtpThemeOffice2013Access
98320>                    Send AddTheme hoCombo "xtpThemeOffice2003" xtpThemeOffice2003
98321>                    Send AddTheme hoCombo "xtpThemeOffice2000" xtpThemeOffice2000
98322>                    Send AddTheme hoCombo "xtpThemeOfficeXP" xtpThemeOfficeXP
98323>
98323>                    Send AddTheme hoCombo "xtpThemeOffice2010Blue" xtpThemeOffice2010Blue
98324>                    Send AddTheme hoCombo "xtpThemeOffice2010Black" xtpThemeOffice2010Black
98325>                    Send AddTheme hoCombo "xtpThemeOffice2010Silver" xtpThemeOffice2010Silver
98326>
98326>                    Send AddTheme hoCombo "xtpThemeOffice2007Aqua" xtpThemeOffice2007Aqua
98327>                    Send AddTheme hoCombo "xtpThemeOffice2007Black" xtpThemeOffice2007Black
98328>                    Send AddTheme hoCombo "xtpThemeOffice2007Blue" xtpThemeOffice2007Blue
98329>                    Send AddTheme hoCombo "xtpThemeOffice2007Silver" xtpThemeOffice2007Silver
98330>
98330>                    Send AddTheme hoCombo "xtpThemeVisualStudio2015Blue" xtpThemeVisualStudio2015Blue
98331>                    Send AddTheme hoCombo "xtpThemeVisualStudio2015Light" xtpThemeVisualStudio2015Light
98332>                    Send AddTheme hoCombo "xtpThemeVisualStudio2015Dark" xtpThemeVisualStudio2015Dark
98333>
98333>                    Send AddTheme hoCombo "xtpThemeVisualStudio2012Light" xtpThemeVisualStudio2012Light
98334>                    Send AddTheme hoCombo "xtpThemeVisualStudio2012Dark" xtpThemeVisualStudio2012Dark
98335>
98335>                    Send AddTheme hoCombo "xtpThemeVisualStudio2008" xtpThemeVisualStudio2008
98336>                    Send AddTheme hoCombo "xtpThemeVisualStudio6" xtpThemeVisualStudio6
98337>
98337>                    Send AddTheme hoCombo "xtpThemeWindows7" xtpThemeWindows7
98338>
98338>                    Send AddTheme hoCombo "xtpThemeWhidbey" xtpThemeWhidbey
98339>
98339>                    Send AddTheme hoCombo "xtpThemeNativeWinXP" xtpThemeNativeWinXP
98340>                End_Procedure
98341>
98341>                Function CurrentTheme Handle vCommandBarControl Returns Integer
98344>                    Handle hMessage hoCombo
98344>                    Integer iIndex
98344>                    // create and bind  proxy control
98344>                    Get CreateProxyControl vCommandBarControl to hoCombo
98345>                    // get the current selection
98345>                    Get ComListIndex of hoCombo to iIndex
98346>                    // note the index selections are 1 based
98346>                    If (iIndex > 0) Begin
98348>                        // get the ItemData for the selected item and send that message
98348>                        Get ComItemData of hoCombo iIndex to hMessage
98349>                        Function_Return hMessage
98350>                    End
98350>                    // dispose of the proxy control
98350>                    Send Destroy of hoCombo
98351>                End_Function
98352>
98352>                Procedure OnExecute Variant vCommandBarControl
98355>                    Integer eTheme
98355>                    Integer iColor
98355>                    Get CurrentTheme vCommandBarControl to eTheme
98356>                    Set peVisualTheme of ghoCommandBars to eTheme
98357>                    Send ComRecalcLayout of ghoCommandBars
98358>                    Get ComGetSpecialColor of ghoCommandBars XPCOLOR_TOOLBAR_FACE to iColor
98359>                    Broadcast Recursive Set Color of (Client_Id(phoMainPanel(ghoApplication))) to iColor
98361>                End_Procedure
98362>
98362>                Procedure SetTheTheme Integer eTheme
98365>                    Integer iColor
98365>                    Set peVisualTheme of ghoCommandBars to eTheme
98366>                    Send ComRecalcLayout of ghoCommandBars
98367>                    Get ComGetSpecialColor of ghoCommandBars XPCOLOR_TOOLBAR_FACE to iColor
98368>                    Broadcast Recursive Set Color of (Client_Id(phoMainPanel(ghoApplication))) to iColor
98370>                End_Procedure
98371>
98371>                Function ConvertSystemColor Integer iColor Returns Integer
98374>                    Integer iSysColor
98374>                    If (iColor = clDefault or iColor = clNone) Begin    // If default color then use -1
98376>                        Move clNone to iColor
98377>                    End
98377>                    Else If (iColor < 0) Begin    // If it is a system color (<0) then convert this into an RGB value
98380>                        Move (iColor iand |CI$7FFFFFFF) to iSysColor    // extract the system color constant
98381>                        Move (GetSysColor(iSysColor)) to iColor
98382>                    End
98382>                    Function_Return iColor
98383>                End_Function
98384>
98384>            End_Object
98385>
98385>            Object oColorSelection_TextItem is a cCJMenuItem
98387>                Set peControlType to xtpControlLabel
98388>                Set pbControlBeginGroup to True
98389>                Set psCaption to "Hotspot Color:"
98390>            End_Object
98391>
98391>            Object oColorSelection_Item is a cCJMenuItem
98393>                Set psImage to "ColorSelectorBlack.ico"
98394>
98394>                Object oColorDialog is a ColorDialog
98396>                    Function SelectColor Returns Integer
98399>                        Integer iRgbColor
98399>                        Boolean bColorSelected
98399>
98399>                        Move -1 to iRgbColor
98400>                        Get Show_Dialog to bColorSelected
98401>                        If (bColorSelected) Begin
98403>                            Get SelectedColor to iRgbColor
98404>                        End
98404>
98404>                        Function_Return iRgbColor
98405>                    End_Function
98406>                End_Object
98407>
98407>                Procedure OnExecute Variant vCommandBarControl
98410>                    Integer iColor
98410>                    Forward Send OnExecute vCommandBarControl
98412>                    Get SelectColor of oColorDialog to iColor
98413>                    If (iColor <> -1) Begin
98415>                        Broadcast Recursive Set piHeaderHotspotColor of (Client_Id(phoMainPanel(ghoApplication))) to iColor
98417>                    End
98417>                End_Procedure
98418>
98418>            End_Object
98419>
98419>            Object oAbout_MenuItem is a cCJMenuItem
98421>                Set psCaption to "About"
98422>                Set psToolTip to "About Info"
98423>                Set psDescription to "About the program"
98424>                Set psImage to "ActionAboutBlack.ico"
98425>                Set pbControlBeginGroup to True
98426>                Procedure OnExecute Variant vCommandBarControl
98429>                    Forward Send OnExecute vCommandBarControl
98431>                    Send Activate_About of (Client_Id(ghoCommandBars))
98432>                End_Procedure
98433>            End_Object
98434>
98434>            Object oHelpMenuItem is a cCJHelpMenuItem
98436>                Set peControlType to xtpControlSplitButtonPopup
98437>                Set psImage to "ActionHelpBlack.ico"
98438>
98438>                Procedure OnExecute Variant vCommandBarControl
98441>                    Forward Send OnExecute vCommandBarControl
98443>                    Set psHelpFile of ghoApplication to "DataFlex.chm"
98444>                    Send ShowProgramHelp
98445>                End_Procedure
98446>
98446>                Object oHelpMenuItemLocal is a cCJMenuItem
98448>                    Set psCaption to "Local HTML Help"
98449>                    Set psImage to "ActionHelpBlack.ico"
98450>                    Procedure OnExecute Variant vCommandBarControl
98453>                        Set psHelpFile of ghoApplication to "DataFlex.chm"
98454>                        Send ShowProgramHelp
98455>                    End_Procedure
98456>                End_Object
98457>
98457>                Object oHelpMenuItemInternetBrowser is a cCJMenuItem
98459>                    Set psCaption to "Online HTML Help"
98460>                    Set psImage to "ActionHelpBlack.ico"
98461>                    Procedure OnExecute Variant vCommandBarControl
98464>                        Runprogram Shell Background "http://www.rdctools.com/HTMLHelp/Developer5.htm"
98465>                    End_Procedure
98466>
98466>                End_Object
98467>
98467>            End_Object
98468>
98468>            Object oExitMenuItem is a cCJExitMenuItem
98470>                Set psToolTip to "Exit application"
98471>                Set psDescription to "Exit the program (Alt+F4)"
98472>                Set psImage to "ActionExitBlack.ico"
98473>                Set pbControlBeginGroup to True
98474>            End_Object
98475>
98475>        End_Object
98476>
98476>        Object oStatusBar is a cCJStatusBar
98478>
98478>            Object oStatusPane1 is a cCJStatusBarPane
98480>                Set piID to sbpIDIdlePane
98481>                Set pbStyleStretch to True
98482>            End_Object
98483>
98483>            Object oStatusPane2 is a cCJStatusBarPane
98485>                Set phoViewPane to Self
98486>                Set pbStyleStretch to True
98487>            End_Object
98488>
98488>        End_Object
98489>
98489>//        Object oSpacerBar is a cCJToolbar
98489>//            Set pbDockNextTo to False
98489>//            Set pbShowExpandButton to False
98489>//            Set pbGripper to False
98489>//            Set peStretched to stStretch
98489>//            Set pbCustomizable to False
98489>//            Set pbCloseable to False
98489>//            Set pbEnableDocking to False
98489>//            Set pbHideWrap to True
98489>//
98489>//            Object oFiller is a cCJMenuItem
98489>//            End_Object
98489>//
98489>//        End_Object
98489>
98489>    End_Object
98490>
98490>    Object oClientArea is a ClientArea
98492>        Use ManageSQLConnections.dg
Including file: ManageSQLConnections.dg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\ManageSQLConnections.dg)
98492>>>Use Windows.pkg
98492>>>Use Cursor.pkg
98492>>>Use cButtonDPI.pkg
Including file: cButtonDPI.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cButtonDPI.pkg)
98492>>>>>Use cButton.pkg
Including file: cButton.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cButton.pkg)
98492>>>>>>>//****************************************************************************
98492>>>>>>>// $Module type: Package
98492>>>>>>>// $Module name: cButton.pkg
98492>>>>>>>//
98492>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
98492>>>>>>>// Copyright (c) 2012 RDC Tools International
98492>>>>>>>// E-mail      : support@rdctools.com
98492>>>>>>>// Web-site    : http://www.rdctools.com
98492>>>>>>>//
98492>>>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
98492>>>>>>>//
98492>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
98492>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
98492>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
98492>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
98492>>>>>>>// in the help folder for more details.
98492>>>>>>>//
98492>>>>>>>//****************************************************************************
98492>>>>>>>Use Windows.pkg
98492>>>>>>>Use Enclient.pkg
98492>>>>>>>Use errornum.inc
98492>>>>>>>
98492>>>>>>>Class cButtonIdleHandler is a cIdleHandler
98493>>>>>>>    Procedure Construct_Object
98495>>>>>>>        Forward Send Construct_Object
98497>>>>>>>
98497>>>>>>>    End_Procedure
98498>>>>>>>
98498>>>>>>>    Procedure OnIdle
98500>>>>>>>        Delegate Send DoEnable
98502>>>>>>>    End_Procedure
98503>>>>>>>
98503>>>>>>>End_Class
98504>>>>>>>
98504>>>>>>>Class cButton is a Button
98505>>>>>>>
98505>>>>>>>    Procedure Construct_Object
98507>>>>>>>        Forward Send Construct_Object
98509>>>>>>>
98509>>>>>>>//#IF (Required_FMAC_Version < 17)
98509>>>>>>>//        Set Typeface to "Segoe UI"
98509>>>>>>>//        Set FontSize to 18 0
98509>>>>>>>//#ENDIF
98509>>>>>>>
98509>>>>>>>        Property Boolean pbAutoEnable False
98510>>>>>>>
98510>>>>>>>        Object oButtonIdleHandler is a cButtonIdleHandler
98512>>>>>>>        End_Object
98513>>>>>>>    End_Procedure
98514>>>>>>>
98514>>>>>>>    Procedure End_Construct_Object
98516>>>>>>>        String sTooltip sStatus_Help
98516>>>>>>>
98516>>>>>>>        Forward Send End_Construct_Object
98518>>>>>>>
98518>>>>>>>        Get psToolTip   to sTooltip
98519>>>>>>>        Get Status_Help to sStatus_Help
98520>>>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
98522>>>>>>>            Set psToolTip to sStatus_Help
98523>>>>>>>        End
98523>>>>>>>>
98523>>>>>>>        Set pbEnabled of oButtonIdleHandler to (pbAutoEnable(Self))
98524>>>>>>>    End_Procedure
98525>>>>>>>
98525>>>>>>>    Procedure DoEnable
98527>>>>>>>        Boolean bAutoEnable bHasRecord
98527>>>>>>>        Handle hoDD
98527>>>>>>>        Get pbAutoEnable to bAutoEnable
98528>>>>>>>        If (bAutoEnable = False) Begin
98530>>>>>>>            Procedure_Return
98531>>>>>>>        End
98531>>>>>>>>
98531>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
98532>>>>>>>        Move (Main_DD(Self)) to hoDD
98533>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
98534>>>>>>>        If (hoDD <> 0) Begin
98536>>>>>>>            Get HasRecord of hoDD to bHasRecord
98537>>>>>>>        End
98537>>>>>>>>
98537>>>>>>>        Set Enabled_State to (bHasRecord = True)
98538>>>>>>>    End_Procedure
98539>>>>>>>
98539>>>>>>>    // Enable the idle handler timer when the button is activated
98539>>>>>>>    Procedure Activating
98541>>>>>>>       Forward Send Activating
98543>>>>>>>       Set pbEnabled of oButtonIdleHandler to True
98544>>>>>>>    End_Procedure
98545>>>>>>>
98545>>>>>>>    // Disable the idle handler when the button is deactivated
98545>>>>>>>    Procedure Deactivating
98547>>>>>>>       Set pbEnabled of oButtonIdleHandler to False
98548>>>>>>>       Forward Send Deactivating
98550>>>>>>>    End_Procedure
98551>>>>>>>
98551>>>>>>>End_Class
98552>>>>>
98552>>>>>// Button class that automatically shows the correct icon size for the current DPI-setting:
98552>>>>>Class cButtonDPI is a cButton
98553>>>>>    Procedure Construct_Object
98555>>>>>        Integer iIconSize
98555>>>>>        Forward Send Construct_Object
98557>>>>>        Get GetCorrectIconSize to iIconSize
98558>>>>>        Set piImageSize to iIconSize
98559>>>>>        Set piImageMarginLeft to 10
98560>>>>>    End_Procedure
98561>>>>>
98561>>>>>    // Returns: DPI setting as an integer.
98561>>>>>    //  Normal DPI setting: iDPI=96  is "Normal setting" 100%
98561>>>>>    //                      iDPI=120 is "Medium setting" 125%
98561>>>>>    //                      iDPI= 144 is "Large setting" 150%
98561>>>>>    Function GetCurrentDPI Returns Integer
98563>>>>>        Handle hDC
98563>>>>>        Integer iPixelsX
98563>>>>>        Move (GetDC(0)) to hDC
98564>>>>>        Move (GetDeviceCaps(hDC, LOGPIXELSX)) to iPixelsX
98565>>>>>        Move (ReleaseDC(0, hDC)) to hDC
98566>>>>>        Function_Return iPixelsX
98567>>>>>    End_Function
98568>>>>>
98568>>>>>    Function GetCorrectIconSize Returns Integer
98570>>>>>        Integer iPixelsX iIndex iSize
98570>>>>>        Integer[] iaSizes
98571>>>>>
98571>>>>>        Move 16 to iaSizes[0]
98572>>>>>        Move 24 to iaSizes[1]
98573>>>>>        Move 32 to iaSizes[2]
98574>>>>>        Move 48 to iaSizes[3]
98575>>>>>        Move 64 to iaSizes[4]
98576>>>>>
98576>>>>>        Get piImageSize to iSize  // the "100%" size
98577>>>>>        Move (SearchArray(iSize,iaSizes)) to iIndex
98578>>>>>        Move (0 max iIndex) to iIndex
98579>>>>>        Get GetCurrentDPI to iPixelsX
98580>>>>>        // Use a Case Statement here. Wherever we jump in we will continue onwards, regardless of whether
98580>>>>>        // we match the remaining Case statements or not. So list our Cases in reverse order, meaning we
98580>>>>>        // will increment iIndex as many times as we need here.
98580>>>>>        Case Begin
98580>>>>>            Case (iPixelsX > 144)
98582>>>>>                Increment iIndex
98583>>>>>            Case (iPixelsX = 144)
98586>>>>>                Increment iIndex
98587>>>>>            Case (iPixelsX = 120)
98590>>>>>                Increment iIndex
98591>>>>>        Case End
98591>>>>>        Move (iIndex min 4) to iIndex
98592>>>>>        Function_Return iaSizes[iIndex]
98593>>>>>    End_Function
98594>>>>>
98594>>>>>    Procedure Set psToolTip String sToolTip
98596>>>>>        String sStatusHelp
98596>>>>>
98596>>>>>        Get Status_Help to sStatusHelp
98597>>>>>        If (sStatusHelp = "") Begin
98599>>>>>            Set Status_Help to sToolTip
98600>>>>>        End
98600>>>>>>
98600>>>>>
98600>>>>>        Forward Set psToolTip to sToolTip
98602>>>>>    End_Function
98603>>>>>
98603>>>>>End_Class
98604>>>Use cSQLCheckBox.pkg
Including file: cSQLCheckBox.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cSQLCheckBox.pkg)
98604>>>>>Use Windows.pkg
98604>>>>>
98604>>>>>// Used by the "Page" message below to show
98604>>>>>// a rectangle around ComboForm and Checkbox objects.
98604>>>>>    Define WM_CHANGEUISTATE for |CI$0127
98604>>>>>    Define WM_UPDATEUISTATE for |CI$0128
98604>>>>>    Define WM_QUERYUISTATE  for |CI$0129
98604>>>>>    Define UIS_SET          for 1
98604>>>>>    Define UIS_CLEAR        for 2
98604>>>>>    Define UIS_INITIALIZE   for 3
98604>>>>>    Define UISF_HIDEFOCUS   for |CI$1
98604>>>>>    Define UISF_HIDEACCEL   for |CI$2
98604>>>>>    Define UISF_ACTIVE      for |CI$4
98604>>>>>
98604>>>>>Class cSQLCheckBox is a CheckBox
98605>>>>>    Procedure Construct_Object
98607>>>>>        Forward Send Construct_Object
98609>>>>>        // The piItem should be set to the object's corresponding tSQLConnection member (One based)
98609>>>>>        Property Integer piItem
98610>>>>>    End_Procedure
98611>>>>>
98611>>>>>    Procedure DbTypeUpdate Integer iDbType String sDriverID
98613>>>>>    End_Procedure
98614>>>>>
98614>>>>>    Procedure ReadConnectionData String[] sConnectionData
98616>>>>>        Integer iItem
98616>>>>>        Get piItem to iItem
98617>>>>>        Set Checked_State to (sConnectionData[iItem] = "1")
98618>>>>>    End_Procedure
98619>>>>>
98619>>>>>    Procedure WriteConnectionData String[] ByRef sConnectionData
98621>>>>>        Boolean bState
98621>>>>>        Integer iItem
98621>>>>>        Get piItem to iItem
98622>>>>>        Get Checked_State to bState
98623>>>>>        Move bState to sConnectionData[iItem]
98624>>>>>    End_Procedure
98625>>>>>
98625>>>>>    Procedure Set psToolTip String sToolTip
98627>>>>>        String sStatusHelp
98627>>>>>
98627>>>>>        Get Status_Help to sStatusHelp
98628>>>>>        If (sStatusHelp = "") Begin
98630>>>>>            Set Status_Help to sToolTip
98631>>>>>        End
98631>>>>>>
98631>>>>>
98631>>>>>        Forward Set psToolTip to sToolTip
98633>>>>>    End_Function
98634>>>>>
98634>>>>>    // Fix for a bug when using manifest files & running Vista and above.
98634>>>>>    // The bug being that the focus rectangle doesn't show.
98634>>>>>    Procedure Page Integer iPageObject
98636>>>>>        Handle hWnd
98636>>>>>        Integer iRet iState
98636>>>>>
98636>>>>>        Forward Send Page iPageObject
98638>>>>>
98638>>>>>        If (iPageObject) Begin
98640>>>>>            Get Window_Handle to hWnd
98641>>>>>            If (hWnd) Begin
98643>>>>>                Move (SendMessage(hWnd, WM_QUERYUISTATE, 0, 0)) to iRet
98644>>>>>                If (iRet iand UISF_HIDEFOCUS) Begin
98646>>>>>                    Move (UIS_CLEAR + (UISF_HIDEFOCUS * 65536)) to iState
98647>>>>>                    Move (SendMessage(hWnd, WM_UPDATEUISTATE, iState, 0)) to iRet
98648>>>>>                End
98648>>>>>>
98648>>>>>            End
98648>>>>>>
98648>>>>>        End
98648>>>>>>
98648>>>>>    End_Procedure
98649>>>>>
98649>>>>>End_Class
98650>>>Use cSQLComboForm.pkg
Including file: cSQLComboForm.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cSQLComboForm.pkg)
98650>>>>>Use Windows.pkg
98650>>>>>
98650>>>>>// Used by the "Page" message below to show
98650>>>>>// a rectangle around ComboForm and Checkbox objects.
98650>>>>>
98650>>>>>Class cSQLComboForm is a ComboForm
98651>>>>>    Procedure Construct_Object
98653>>>>>        Forward Send Construct_Object
98655>>>>>
98655>>>>>        // This will shadow the label if the form itself has its Enabled_State=False
98655>>>>>        Property Boolean pbAutoShadowLabelObject True
98656>>>>>
98656>>>>>        // The piItem should be set to the object's corresponding tSQLConnection member (One based)
98656>>>>>        Property Integer piItem
98657>>>>>    End_Procedure
98658>>>>>
98658>>>>>    Procedure End_Construct_Object
98660>>>>>        Boolean bAutoShadowLabelObject
98660>>>>>        Get pbAutoShadowLabelObject to bAutoShadowLabelObject
98661>>>>>        If (bAutoShadowLabelObject = True) Begin
98663>>>>>            Set Private.Label_Shadow_Display_Mode to TBSHADOW_ON_LOCAL
98664>>>>>        End
98664>>>>>>
98664>>>>>        Forward Send End_Construct_Object
98666>>>>>    End_Procedure
98667>>>>>
98667>>>>>    Procedure DbTypeUpdate Integer iDbType String sDriverID
98669>>>>>    End_Procedure
98670>>>>>
98670>>>>>    Procedure ReadConnectionData String[] sConnectionData
98672>>>>>        Integer iItem
98672>>>>>        Get piItem to iItem
98673>>>>>        Set Value to sConnectionData[iItem]
98674>>>>>    End_Procedure
98675>>>>>
98675>>>>>    Procedure WriteConnectionData String[] ByRef sConnectionData
98677>>>>>        String sValue
98677>>>>>        Integer iItem
98677>>>>>        Get piItem to iItem
98678>>>>>        Get Value to sValue
98679>>>>>        Move sValue to sConnectionData[iItem]
98680>>>>>    End_Procedure
98681>>>>>
98681>>>>>    Procedure Set psToolTip String sToolTip
98683>>>>>        String sStatusHelp
98683>>>>>
98683>>>>>        Get Status_Help to sStatusHelp
98684>>>>>        If (sStatusHelp = "") Begin
98686>>>>>            Set Status_Help to sToolTip
98687>>>>>        End
98687>>>>>>
98687>>>>>
98687>>>>>        Forward Set psToolTip to sToolTip
98689>>>>>    End_Function
98690>>>>>
98690>>>>>    // Fix for a bug when using manifest files & running Vista and above.
98690>>>>>    // The bug being that the focus rectangle doesn't show.
98690>>>>>    Procedure Page Integer iPageObject
98692>>>>>        Handle hWnd
98692>>>>>        Integer iRet iState
98692>>>>>
98692>>>>>        Forward Send Page iPageObject
98694>>>>>
98694>>>>>        If (iPageObject) Begin
98696>>>>>            Get Window_Handle to hWnd
98697>>>>>            If (hWnd) Begin
98699>>>>>                Move (SendMessage(hWnd, WM_QUERYUISTATE, 0, 0)) to iRet
98700>>>>>                If (iRet iand UISF_HIDEFOCUS) Begin
98702>>>>>                    Move (UIS_CLEAR + (UISF_HIDEFOCUS * 65536)) to iState
98703>>>>>                    Move (SendMessage(hWnd, WM_UPDATEUISTATE, iState, 0)) to iRet
98704>>>>>                End
98704>>>>>>
98704>>>>>            End
98704>>>>>>
98704>>>>>        End
98704>>>>>>
98704>>>>>    End_Procedure
98705>>>>>
98705>>>>>End_Class
98706>>>Use cSQLForm.pkg
Including file: cSQLForm.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cSQLForm.pkg)
98706>>>>>Use Windows.pkg
98706>>>>>
98706>>>>>Class cSQLForm is a Form
98707>>>>>    Procedure Construct_Object
98709>>>>>        Forward Send Construct_Object
98711>>>>>
98711>>>>>        // This will shadow the label if the form itself has its Enabled_State=False
98711>>>>>        Property Boolean pbAutoShadowLabelObject True
98712>>>>>
98712>>>>>        // The piItem should be set to the object's corresponding tSQLConnection member (One based)
98712>>>>>        Property Integer piItem
98713>>>>>    End_Procedure
98714>>>>>
98714>>>>>    Procedure End_Construct_Object
98716>>>>>        Boolean bAutoShadowLabelObject
98716>>>>>        Get pbAutoShadowLabelObject to bAutoShadowLabelObject
98717>>>>>        If (bAutoShadowLabelObject = True) Begin
98719>>>>>            Set Private.Label_Shadow_Display_Mode to TBSHADOW_ON_LOCAL
98720>>>>>        End
98720>>>>>>
98720>>>>>        Forward Send End_Construct_Object
98722>>>>>    End_Procedure
98723>>>>>
98723>>>>>    Procedure DbTypeUpdate Integer iDbType String sDriverID
98725>>>>>    End_Procedure
98726>>>>>
98726>>>>>    Procedure ReadConnectionData String[] sConnectionData
98728>>>>>        Integer iItem
98728>>>>>        Get piItem to iItem
98729>>>>>        Set Value to sConnectionData[iItem]
98730>>>>>    End_Procedure
98731>>>>>
98731>>>>>    Procedure WriteConnectionData String[] ByRef sConnectionData
98733>>>>>        String sValue
98733>>>>>        Integer iItem
98733>>>>>        Get piItem to iItem
98734>>>>>        Get Value to sValue
98735>>>>>        Move sValue to sConnectionData[iItem]
98736>>>>>    End_Procedure
98737>>>>>
98737>>>>>    Procedure Set psToolTip String sToolTip
98739>>>>>        String sStatusHelp
98739>>>>>
98739>>>>>        Get Status_Help to sStatusHelp
98740>>>>>        If (sStatusHelp = "") Begin
98742>>>>>            Set Status_Help to sToolTip
98743>>>>>        End
98743>>>>>>
98743>>>>>
98743>>>>>        Forward Set psToolTip to sToolTip
98745>>>>>    End_Function
98746>>>>>
98746>>>>>End_Class
98747>>>Use cSQLConnectionHandler.pkg
98747>>>Use cDbUpdateFunctionLibrary.pkg
98747>>>Use cDbUpdateDatabaseDriver.pkg
98747>>>Use DatabaseSelection.dg
Including file: DatabaseSelection.dg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\DatabaseSelection.dg)
98747>>>>>Use Windows.pkg
98747>>>>>Use cCJGridPromptList.pkg
Including file: cCJGridPromptList.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJGridPromptList.pkg)
98747>>>>>>>Use Windows.pkg
98747>>>>>>>Use cCJGrid.pkg
98747>>>>>>>
98747>>>>>>>
98747>>>>>>>
98747>>>>>>>Class cCJGridPromptList is a cCJGrid
98748>>>>>>>
98748>>>>>>>    Procedure Construct_Object
98750>>>>>>>        Forward Send Construct_Object
98752>>>>>>>
98752>>>>>>>        Property Boolean pbAutoSeed True     // if we should seed list from invoking data
98753>>>>>>>        Property Boolean Private_pbAutoOrdering True
98754>>>>>>>        Property Boolean pbAutoSearch True  // pops up search window
98755>>>>>>>        Property Integer peUpdateMode umPromptValue
98756>>>>>>>        Property Integer piUpdateColumn 0
98757>>>>>>>        Property Integer piInitialColumn -1
98758>>>>>>>        Property String  psSeedValue ''
98759>>>>>>>        Property Handle phmPromptUpdateCallback 0
98760>>>>>>>        Property Integer phoInvokingObject
98761>>>>>>>        
98761>>>>>>>        Property Boolean pbStoredAutoSeed
98762>>>>>>>        Property Boolean pbStoredAutoOrdering
98763>>>>>>>        Property Boolean pbStoredAutoSearch
98764>>>>>>>        Property Integer peStoredUpdateMode
98765>>>>>>>        Property Integer piStoredUpdateColumn
98766>>>>>>>        Property Integer piStoredInitialColumn
98767>>>>>>>        Property Handle  phmStoredPromptUpdateCallback
98768>>>>>>>        Property Boolean pbStoredSelectionEnable
98769>>>>>>>        Property Boolean pbStoredMultipleSelection
98770>>>>>>>
98770>>>>>>>        // internally set by list
98770>>>>>>>        // these must be set upon closing the list and can be used for manual list updates
98770>>>>>>>        Property Boolean pbCanceled
98771>>>>>>>        Property Integer[] pSelectedRows
98772>>>>>>>
98772>>>>>>>        Property Boolean pbNeedsNewOrdering
98773>>>>>>>        Property Boolean pbRequestSearch
98774>>>>>>>        Property tGridKeyPair[] pSearchKeys
98775>>>>>>>        
98775>>>>>>>        // these properties makes a prompt list a prompt list
98775>>>>>>>        // and should not be changed.
98775>>>>>>>        Set pbEditOnKeyNavigation to False
98776>>>>>>>        Set pbEditOnClick to False
98777>>>>>>>        Set pbReadOnly to True
98778>>>>>>>        Set pbFocusSubItems to True
98779>>>>>>>        
98779>>>>>>>        // these could maybe be changed
98779>>>>>>>        Set pbShadeSortColumn to True
98780>>>>>>>        Set pbHeaderReorders to True
98781>>>>>>>        Set pbHeaderTogglesDirection to True
98782>>>>>>>        Set pbHeaderSelectsColumn to True
98783>>>>>>>        Set peHorizontalGridStyle to xtpGridNoLines
98784>>>>>>>        Set piFocusCellBackColor to clNone
98785>>>>>>>        Set piFocusCellForeColor to clNone
98786>>>>>>>        Set piFocusCellRectangleColor to clBlack
98787>>>>>>>        Set pbUseFocusCellRectangle to False
98788>>>>>>>        Set pbSelectionEnable to True
98789>>>>>>>        
98789>>>>>>>        On_Key kEnter Send Ok
98790>>>>>>>        On_Key kCancel Send Cancel
98791>>>>>>>
98791>>>>>>>    End_Procedure
98792>>>>>>>    
98792>>>>>>>    // reorder list automatically on column change
98792>>>>>>>    // this also set pbFocusSubItems which is required to make the two states work
98792>>>>>>>    Procedure Set pbAutoOrdering Boolean bAutoOrder
98794>>>>>>>        Set Private_pbAutoOrdering to bAutoOrder
98795>>>>>>>        Set pbFocusSubItems to bAutoOrder
98796>>>>>>>    End_Procedure
98797>>>>>>>    
98797>>>>>>>    Function pbAutoOrdering Returns Boolean
98799>>>>>>>        Boolean bAutoOrder
98799>>>>>>>        Get Private_pbAutoOrdering to bAutoOrder
98800>>>>>>>        Function_Return bAutoOrder
98801>>>>>>>    End_Function
98802>>>>>>>
98802>>>>>>>    // augmented to handle auto-ordering and invoking the search popup list
98802>>>>>>>    Procedure OnIdle
98804>>>>>>>        Boolean bNeedsReorder bSearch bOldToggle
98804>>>>>>>        Handle hoCol
98804>>>>>>>        Integer iKy1 iKy2 iCol
98804>>>>>>>
98804>>>>>>>        Get pbNeedsNewOrdering to bNeedsReorder
98805>>>>>>>        If bNeedsReorder Begin
98807>>>>>>>            Get SelectedColumn to iCol
98808>>>>>>>            If (iCol<>-1) Begin
98810>>>>>>>                
98810>>>>>>>                Get pbHeaderTogglesDirection to bOldToggle
98811>>>>>>>                Set pbHeaderTogglesDirection to False
98812>>>>>>>                Send HeaderReorder iCol
98813>>>>>>>                Set pbHeaderTogglesDirection to bOldToggle
98814>>>>>>>                
98814>>>>>>>                Set pbNeedsNewOrdering to False
98815>>>>>>>            End
98815>>>>>>>>
98815>>>>>>>        End
98815>>>>>>>>
98815>>>>>>>        
98815>>>>>>>        Get pbRequestSearch to bSearch
98816>>>>>>>        If bSearch Begin
98818>>>>>>>            Send Request_SearchEx // will use the keys pSearchKeys as eed
98819>>>>>>>        End
98819>>>>>>>>
98819>>>>>>>        
98819>>>>>>>        Forward Send OnIdle
98821>>>>>>>    End_Procedure
98822>>>>>>>    
98822>>>>>>>    Procedure OnStoreDefaults
98824>>>>>>>        Integer iVal
98824>>>>>>>        Boolean bVal
98824>>>>>>>
98824>>>>>>>        Get pbAutoSeed to bVal           
98825>>>>>>>        Set pbStoredAutoSeed to bVal           
98826>>>>>>>        
98826>>>>>>>        Get pbAutoOrdering to bVal        
98827>>>>>>>        Set pbStoredAutoOrdering to bVal      
98828>>>>>>>        
98828>>>>>>>        Get pbAutoSearch to bVal         
98829>>>>>>>        Set pbStoredAutoSearch to bVal         
98830>>>>>>>        
98830>>>>>>>        Get peUpdateMode to iVal
98831>>>>>>>        Set peStoredUpdateMode to iVal
98832>>>>>>>        
98832>>>>>>>        Get piUpdateColumn to iVal       
98833>>>>>>>        Set piStoredUpdateColumn to iVal       
98834>>>>>>>
98834>>>>>>>        Get piInitialColumn to iVal       
98835>>>>>>>        Set piStoredInitialColumn to iVal       
98836>>>>>>>
98836>>>>>>>        Get phmPromptUpdateCallback to iVal       
98837>>>>>>>        Set phmStoredPromptUpdateCallback to iVal       
98838>>>>>>>
98838>>>>>>>        Get pbSelectionEnable to bVal
98839>>>>>>>        Set pbStoredSelectionEnable to bVal
98840>>>>>>>        
98840>>>>>>>        Get pbMultipleSelection to bVal
98841>>>>>>>        Set pbStoredMultipleSelection to bVal
98842>>>>>>>        
98842>>>>>>>    End_Procedure
98843>>>>>>>
98843>>>>>>>    Procedure OnRestoreDefaults
98845>>>>>>>        Integer iVal
98845>>>>>>>        Boolean bVal
98845>>>>>>>
98845>>>>>>>        Get pbStoredAutoSeed to bVal           
98846>>>>>>>        Set pbAutoSeed to bVal           
98847>>>>>>>        
98847>>>>>>>        Get pbStoredAutoOrdering to bVal        
98848>>>>>>>        Set pbAutoOrdering to bVal      
98849>>>>>>>        
98849>>>>>>>        Get pbStoredAutoSearch to bVal         
98850>>>>>>>        Set pbAutoSearch to bVal         
98851>>>>>>>        
98851>>>>>>>        Get peStoredUpdateMode to iVal
98852>>>>>>>        Set peUpdateMode to iVal
98853>>>>>>>        
98853>>>>>>>        Get piStoredInitialColumn to iVal       
98854>>>>>>>        Set piInitialColumn to iVal       
98855>>>>>>>        
98855>>>>>>>        Get phmStoredPromptUpdateCallback to iVal       
98856>>>>>>>        Set phmPromptUpdateCallback to iVal       
98857>>>>>>>
98857>>>>>>>        Get pbStoredSelectionEnable to bVal
98858>>>>>>>        Set pbSelectionEnable to bVal
98859>>>>>>>        
98859>>>>>>>        Get pbStoredMultipleSelection to bVal
98860>>>>>>>        Set pbMultipleSelection to bVal
98861>>>>>>>
98861>>>>>>>    End_Procedure
98862>>>>>>>    
98862>>>>>>>    // finds the target seed value in the updatecolumn. If we autoseed and there is a
98862>>>>>>>    // seed value (psSeedValue), attempt to find GE that value, else move to first row
98862>>>>>>>    // Suitable for augmentation
98862>>>>>>>    Procedure OnSeedData
98864>>>>>>>        Integer iUpdateColumn iSortColumn
98864>>>>>>>        Boolean bSeed bAuto
98864>>>>>>>        String sValue
98864>>>>>>>        Handle hoCol
98864>>>>>>>
98864>>>>>>>        Get piUpdateColumn to iUpdateColumn
98865>>>>>>>        Get psSeedValue to sValue
98866>>>>>>>        Get pbAutoSeed to bSeed
98867>>>>>>>        Get piSortColumn to iSortColumn
98868>>>>>>>        Get pbAutoOrdering to bAuto
98869>>>>>>>        // if not yet sorted and this is auto ordering we will
98869>>>>>>>        // sort the data for the search column. We do this to make the
98869>>>>>>>        // column search GE logic work properly. 
98869>>>>>>>        If (bSeed and bAuto and iUpdateColumn<>-1 and iSortColumn<>iUpdateColumn) Begin
98871>>>>>>>            Get ColumnObject iUpdateColumn to hoCol
98872>>>>>>>            Send SortGridByColumn hoCol False
98873>>>>>>>        End
98873>>>>>>>>
98873>>>>>>>
98873>>>>>>>        If (bSeed and sValue<>"" and iUpdateColumn<>-1) Begin
98875>>>>>>>            Send RequestFindColumnValue iUpdateColumn sValue True 0  
98876>>>>>>>        End
98876>>>>>>>>
98876>>>>>>>        Else Begin
98877>>>>>>>            Send MovetoFirstRow
98878>>>>>>>        End
98878>>>>>>>>
98878>>>>>>>
98878>>>>>>>    End_Function
98879>>>>>>>
98879>>>>>>>    Procedure OnMoveValueOutByValue
98881>>>>>>>        String sValue
98881>>>>>>>        Handle hoInvokingObject hoCol  hoDataSource
98881>>>>>>>        Integer iRow iCol
98881>>>>>>>        Integer[] SelRowsIndexes
98882>>>>>>>
98882>>>>>>>        Get phoInvokingObject to hoInvokingObject
98883>>>>>>>        Get pSelectedRows to SelRowsIndexes
98884>>>>>>>        If (SizeOfArray(SelRowsIndexes)>0) Begin
98886>>>>>>>            Get piUpdateColumn to iCol
98887>>>>>>>            Get ColumnObject iCol to hoCol
98888>>>>>>>            Get RowValue of hoCol SelRowsIndexes[0] to sValue
98889>>>>>>>            Set Value of hoInvokingObject to sValue
98890>>>>>>>            Set Item_Changed_State of hoInvokingObject to True
98891>>>>>>>        End
98891>>>>>>>>
98891>>>>>>>    End_Procedure
98892>>>>>>>
98892>>>>>>>    Procedure OnMoveValueOutByCustom
98894>>>>>>>    End_Procedure
98895>>>>>>>
98895>>>>>>>    // augment to popup a search window when allowed
98895>>>>>>>    Procedure OnComKeyDown Short ByRef llKeyCode Short llShift
98897>>>>>>>        Boolean bSubFocus bAutoSearch bChar
98897>>>>>>>        Integer iVal
98897>>>>>>>        
98897>>>>>>>        Get pbFocusSubItems to bSubFocus
98898>>>>>>>        Get pbAutoSearch to bAutoSearch
98899>>>>>>>        Forward Send OnComKeyDown llKeyCode llShift
98901>>>>>>>        If (bAutoSearch and not(bSubFocus)) Begin
98903>>>>>>>            If ((llShift iand 6)=0) Begin // skip alt and ctrl
98905>>>>>>>                Get GetVKeyToAnsi llKeyCode llShift to iVal
98906>>>>>>>                Move (iVal<>0) to bChar
98907>>>>>>>            End
98907>>>>>>>>
98907>>>>>>>            If bChar Begin
98909>>>>>>>                // this can get called multiple times before a search dialog pops up
98909>>>>>>>                Send AddToSearchKeys llKeyCode llShift
98910>>>>>>>            End
98910>>>>>>>>
98910>>>>>>>        End
98910>>>>>>>>
98910>>>>>>>    End_Procedure
98911>>>>>>>    
98911>>>>>>>    Procedure OnComRequestEdit Variant llRow Variant llColumn Variant llItem Boolean ByRef llCancel
98913>>>>>>>        Boolean bAutoSearch
98913>>>>>>>        Integer iKeyCode iShiftCode
98913>>>>>>>        Get pbAutoSearch to bAutoSearch
98914>>>>>>>        If bAutoSearch Begin
98916>>>>>>>            // this can get called multiple times before a search dialog pops up
98916>>>>>>>            Get piLastKey to iKeyCode
98917>>>>>>>            Get piLastKey2 to iShiftCode
98918>>>>>>>            Send AddToSearchKeys iKeyCode iShiftCode
98919>>>>>>>        End
98919>>>>>>>>
98919>>>>>>>        Move True to llCancel
98920>>>>>>>    End_Procedure  // OnComRequestEdit
98921>>>>>>>    
98921>>>>>>>    Procedure OnComRowDblClick Variant llRow Variant llItem
98923>>>>>>>        Send ClearSearchRequest // kill any deferred search popup
98924>>>>>>>        Forward Send OnComRowDblClick llRow llItem
98926>>>>>>>    End_Procedure
98927>>>>>>>    
98927>>>>>>>    Procedure OnRowDoubleClick Integer iRow Integer iCol
98929>>>>>>>        Send Ok
98930>>>>>>>    End_Procedure
98931>>>>>>>    
98931>>>>>>>    
98931>>>>>>>    // we don't want a menu for prompt lists
98931>>>>>>>    Function CreateContextMenu Returns Handle
98933>>>>>>>        Function_Return 0
98934>>>>>>>    End_Function
98935>>>>>>>
98935>>>>>>>    // if we use auto-ordering, change the order when the column changes
98935>>>>>>>    Procedure ColumnChanged Integer iOld Integer iNew
98937>>>>>>>        Boolean bAutoOrder
98937>>>>>>>        Forward Send ColumnChanged iOld iNew
98939>>>>>>>        Get pbAutoOrdering to bAutoOrder
98940>>>>>>>        If bAutoOrder Begin
98942>>>>>>>            // will be reordered in idle event
98942>>>>>>>            Set pbNeedsNewOrdering to True
98943>>>>>>>        End
98943>>>>>>>>
98943>>>>>>>    End_Procedure
98944>>>>>>>    
98944>>>>>>>
98944>>>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
98946>>>>>>>        Integer eMode
98946>>>>>>>        Integer[] SelRowsIndexes
98947>>>>>>>        Set pbCanceled to True // assume cancel unless changed
98948>>>>>>>        Set pSelectedRows to SelRowsIndexes // empty
98949>>>>>>>        Get peUpdateMode to eMode
98950>>>>>>>        If (eMode<>umPromptNonInvoking) Begin
98952>>>>>>>            Send OnStoreDefaults
98953>>>>>>>        End
98953>>>>>>>>
98953>>>>>>>        Send InitializePromptList
98954>>>>>>>        Forward Send Add_Focus hoParent
98956>>>>>>>        Send LoadData
98957>>>>>>>        Set psSeedValue to ""
98958>>>>>>>    End_Procedure
98959>>>>>>>    
98959>>>>>>>    // called before the list is activated. 
98959>>>>>>>    Procedure InitializePromptList
98961>>>>>>>        Integer hoInvokingObject
98961>>>>>>>        Boolean bAutoColumn bAutoSeed 
98961>>>>>>>        Integer i iOldMode eUpdateMode
98961>>>>>>>        String sValue
98961>>>>>>>        
98961>>>>>>>        Get peUpdateMode to eUpdateMode
98962>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
98964>>>>>>>            Get Focus of Desktop to hoInvokingObject
98965>>>>>>>            If (hoInvokingObject<=Desktop) Begin
98967>>>>>>>                Error DFERR_PROGRAM "Prompt list has no invoking object"
98968>>>>>>>>
98968>>>>>>>                Procedure_Return
98969>>>>>>>            End
98969>>>>>>>>
98969>>>>>>>
98969>>>>>>>            Set phoInvokingObject to hoInvokingObject
98970>>>>>>>
98970>>>>>>>            Send Prompt_Callback to hoInvokingObject Self
98971>>>>>>>            Get peUpdateMode to eUpdateMode
98972>>>>>>>        End
98972>>>>>>>>
98972>>>>>>>
98972>>>>>>>        Send ClearSearchRequest // clear the search keys
98973>>>>>>>        Set pbNeedsNewOrdering to False
98974>>>>>>>
98974>>>>>>>        Get pbAutoSeed to bAutoSeed
98975>>>>>>>
98975>>>>>>>        If (eUpdateMode=umPromptValue) Begin // else not used here intentionally
98977>>>>>>>            Get Value of hoInvokingObject to sValue
98978>>>>>>>            Set psSeedValue to sValue
98979>>>>>>>        End
98979>>>>>>>>
98979>>>>>>>        
98979>>>>>>>    End_Procedure
98980>>>>>>>    
98980>>>>>>>    // called after list is created and active. Load Data, seed list, select start column, etc.
98980>>>>>>>    Procedure LoadData
98982>>>>>>>        Handle hoInvokingObject hoDataSource hoInitialColumn
98982>>>>>>>        Integer iUpdateColumn iRows iInitialColumn iInitialOrder
98982>>>>>>>        Integer eUpdateMode
98982>>>>>>>        Boolean bAutoSeed bAutoColumn bCancel bSubFocus bAutoOrder 
98982>>>>>>>        
98982>>>>>>>        Get phoDataSource to hoDataSource
98983>>>>>>>        Get peUpdateMode to eUpdateMode
98984>>>>>>>        Get phoInvokingObject to hoInvokingObject
98985>>>>>>>        Get pbAutoSeed to bAutoSeed
98986>>>>>>>        Get piInitialColumn to iInitialColumn
98987>>>>>>>        Get piUpdateColumn to iUpdateColumn
98988>>>>>>>        Get RowCount of hoDataSource to iRows
98989>>>>>>>        
98989>>>>>>>        // We need an initial column. if you specified an initial column that will get used for the start column
98989>>>>>>>        // and the initial sort order. If you did not, which is typical, it will use the update column
98989>>>>>>>        If (iInitialColumn=-1) Begin
98991>>>>>>>            Move iUpdateColumn to iInitialColumn
98992>>>>>>>        End
98992>>>>>>>>
98992>>>>>>>        If (iInitialColumn>=0) Begin
98994>>>>>>>            Get ColumnObject iInitialColumn to hoInitialColumn
98995>>>>>>>            Set pbVisible of hoInitialColumn to True // initial column should be visible
98996>>>>>>>        End
98996>>>>>>>>
98996>>>>>>>        Send OnSeedData // find a good starting place for the row
98997>>>>>>>        Get pbFocusSubItems to bSubFocus
98998>>>>>>>        If bSubFocus Begin
99000>>>>>>>            // if column focus, which is normal, go to initialcolumn       
99000>>>>>>>            If hoInitialColumn Begin
99002>>>>>>>                Get MoveToColumnObject hoInitialColumn to bCancel
99003>>>>>>>            End
99003>>>>>>>>
99003>>>>>>>            Else Begin
99004>>>>>>>                Send MoveToFirstEnterableColumn
99005>>>>>>>            End
99005>>>>>>>>
99005>>>>>>>        End
99005>>>>>>>>
99005>>>>>>>
99005>>>>>>>    End_Procedure
99006>>>>>>>    
99006>>>>>>>    // This is only called in a successful close
99006>>>>>>>    Procedure ClosePromptList
99008>>>>>>>        Handle hoDataSource hoInvokingObject
99008>>>>>>>        Handle hmCallBack
99008>>>>>>>        Integer iRow eUpdateMode
99008>>>>>>>        Integer[] SelRowsIndexes
99009>>>>>>>        
99009>>>>>>>        Get phoDataSource to hoDataSource
99010>>>>>>>        Get phoInvokingObject to hoInvokingObject
99011>>>>>>>        
99011>>>>>>>        If (pbMultipleSelection(Self)) Begin
99013>>>>>>>            Get GetIndexesForSelectedRows to SelRowsIndexes
99014>>>>>>>        End
99014>>>>>>>>
99014>>>>>>>        Else Begin
99015>>>>>>>            Get SelectedRow of hoDataSource to iRow
99016>>>>>>>            If (iRow<>-1) Begin
99018>>>>>>>                Move iRow to SelRowsIndexes[0]
99019>>>>>>>            End
99019>>>>>>>>
99019>>>>>>>        End
99019>>>>>>>>
99019>>>>>>>        
99019>>>>>>>        Set pbCanceled to False
99020>>>>>>>        Set pSelectedRows to SelRowsIndexes
99021>>>>>>>        
99021>>>>>>>        Get peUpdateMode to eUpdateMode
99022>>>>>>>        // if non-invoking there is by definition, no move value out
99022>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
99024>>>>>>>            
99024>>>>>>>            If (eUpdateMode=umPromptValue) Begin
99026>>>>>>>                Send OnMoveValueOutByValue
99027>>>>>>>            End
99027>>>>>>>>
99027>>>>>>>            Else If (eUpdateMode=umPromptCustom) Begin
99030>>>>>>>                Send OnMoveValueOutByCustom
99031>>>>>>>            End
99031>>>>>>>>
99031>>>>>>>                Get phmPromptUpdateCallback to hmCallBack
99032>>>>>>>                If hmCallBack Begin
99034>>>>>>>                    Send hmCallBack of hoInvokingObject Self
99035>>>>>>>                End
99035>>>>>>>>
99035>>>>>>>        End
99035>>>>>>>>
99035>>>>>>>
99035>>>>>>>        Send Close_Panel
99036>>>>>>>    End_Procedure
99037>>>>>>>
99037>>>>>>>    // augment to send OnRestoreDefaults.
99037>>>>>>>    Procedure Release_Focus
99039>>>>>>>        Integer eUpdateMode
99039>>>>>>>        Get peUpdateMode to eUpdateMode
99040>>>>>>>        Forward Send Release_Focus
99042>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
99044>>>>>>>            Send OnRestoreDefaults
99045>>>>>>>        End
99045>>>>>>>>
99045>>>>>>>    End_Procedure
99046>>>>>>>    
99046>>>>>>>    Function SelectedRowIds Returns RowID[]
99048>>>>>>>        RowID[] SelectedRowids
99049>>>>>>>        Integer[] SelectedRows
99050>>>>>>>        Integer i iRows
99050>>>>>>>        Handle hoDataSource
99050>>>>>>>        Get phoDataSource to hoDataSource
99051>>>>>>>        Get pSelectedRows to SelectedRows
99052>>>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
99053>>>>>>>        For i from 0 to (iRows-1)
99059>>>>>>>>
99059>>>>>>>            Get RowTag of hoDataSource SelectedRows[i] to SelectedRowIds[i]
99060>>>>>>>        Loop
99061>>>>>>>>
99061>>>>>>>        Function_Return SelectedRowids
99062>>>>>>>    End_Function
99063>>>>>>>
99063>>>>>>>    Function SelectedColumnValues Integer iCol Returns String[]
99065>>>>>>>        String[] SelectedValues
99066>>>>>>>        Integer[] SelectedRows
99067>>>>>>>        Integer i iRows
99067>>>>>>>        Handle hoCol
99067>>>>>>>        Get ColumnObject iCol to hoCol
99068>>>>>>>        Get pSelectedRows to SelectedRows
99069>>>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
99070>>>>>>>        For i from 0 to (iRows-1)
99076>>>>>>>>
99076>>>>>>>            Get RowValue of hoCol SelectedRows[i] to SelectedValues[i]
99077>>>>>>>        Loop
99078>>>>>>>>
99078>>>>>>>        Function_Return SelectedValues
99079>>>>>>>    End_Function
99080>>>>>>>
99080>>>>>>>    Procedure Ok Returns Integer
99082>>>>>>>        Send ClosePromptList
99083>>>>>>>    End_Procedure
99084>>>>>>>
99084>>>>>>>    Procedure Cancel Returns Integer
99086>>>>>>>        Send Close_Panel
99087>>>>>>>    End_Procedure
99088>>>>>>>        
99088>>>>>>>    Procedure Search
99090>>>>>>>        Send Activate // give focus back to list so focus things are correct
99091>>>>>>>        Send Request_Search 0 0
99092>>>>>>>    End_Procedure
99093>>>>>>>    
99093>>>>>>>    // do a search using the current keys in the search key buffer for the sort column.
99093>>>>>>>    // Becaue this is called via an OnIdle it is possible to have multiple keys pressed before
99093>>>>>>>    // the OnIdle. These have been stored in pSearchKeys and will be passed to the popup dialog
99093>>>>>>>    Procedure Request_SearchEx
99095>>>>>>>        tGridKeyPair[] Keys
99095>>>>>>>        tGridKeyPair[] Keys
99096>>>>>>>        Integer iCol
99096>>>>>>>        Handle hoCol hoSearchDialog 
99096>>>>>>>        Boolean bOk
99096>>>>>>>        String sValue
99096>>>>>>>
99096>>>>>>>        Get piSortColumn to iCol
99097>>>>>>>        If (iCol<>-1) Begin
99099>>>>>>>            Get ColumnObject iCol to hoCol
99100>>>>>>>                Get pSearchKeys to Keys
99101>>>>>>>            Get CreateGridSearchDialogObject to hoSearchDialog
99102>>>>>>>            Get RequestGridSearchEx of hoSearchDialog Keys hoCol (&sValue) to bOk
99103>>>>>>>            If bOk Begin
99105>>>>>>>               Send RequestFindColumnValue iCol sValue True 0  
99106>>>>>>>            End
99106>>>>>>>>
99106>>>>>>>            Send Destroy of hoSearchDialog
99107>>>>>>>        End
99107>>>>>>>>
99107>>>>>>>        Send ClearSearchRequest // clear the search keys
99108>>>>>>>    End_Procedure
99109>>>>>>>    
99109>>>>>>>    // set pbRequestSearch to true and add the keys to the search buffer.
99109>>>>>>>    Procedure AddToSearchKeys Integer iKeyCode Integer iShiftCode
99111>>>>>>>        tGridKeyPair[] Keys
99111>>>>>>>        tGridKeyPair[] Keys
99112>>>>>>>        tGridKeyPair KeyPair
99112>>>>>>>        tGridKeyPair KeyPair
99112>>>>>>>        Set pbRequestSearch to True
99113>>>>>>>        Move iKeyCode to KeyPair.KeyCode
99114>>>>>>>        Move iShiftCode to KeyPair.ShiftCode
99115>>>>>>>        Get pSearchKeys to Keys                
99116>>>>>>>        Move KeyPair to Keys[SizeOfArray(Keys)]
99117>>>>>>>        Set pSearchKeys to Keys                
99118>>>>>>>    End_Procedure
99119>>>>>>>
99119>>>>>>>    Procedure ClearSearchRequest
99121>>>>>>>        tGridKeyPair[] SearchKeys
99121>>>>>>>        tGridKeyPair[] SearchKeys
99122>>>>>>>        Set pSearchKeys to SearchKeys
99123>>>>>>>        Set pbRequestSearch to False
99124>>>>>>>    End_Procedure
99125>>>>>>>    
99125>>>>>>>End_Class
99126>>>>>Use cDbUpdateFunctionLibrary.pkg
99126>>>>>Use MSSqldrv.pkg
99126>>>>>Use db2_drv.pkg
99126>>>>>Use odbc_drv.pkg
99126>>>>>
99126>>>>>Object oDatabaseSelection_sl is a ModalPanel
99128>>>>>    Set Label to "SQL Database Selection"
99129>>>>>    Set Size to 121 183
99130>>>>>    Set piMinSize to 89 170
99131>>>>>    Set Location to 2 2
99132>>>>>    Set Border_Style to Border_Thick
99133>>>>>
99133>>>>>    Property String[] psTheData
99135>>>>>
99135>>>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
99137>>>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
99139>>>>>        End_Object
99140>>>>>    End
99140>>>>>>
99140>>>>>
99140>>>>>    Object oSelList is a cCJGridPromptList
99142>>>>>        Set Size to 89 167
99143>>>>>        Set Location to 6 6
99144>>>>>        Set peAnchors to anAll
99145>>>>>        Set pbAllowColumnRemove to False
99146>>>>>        Set pbUseAlternateRowBackgroundColor to True
99147>>>>>        Set pbGrayIfDisable to False
99148>>>>>        Set pbHeaderReorders to False
99149>>>>>        Set pbHeaderSelectsColumn to False
99150>>>>>        Set pbHeaderTogglesDirection to False
99151>>>>>        Set pbShadeSortColumn to False
99152>>>>>        Set piFocusCellBackColor to clDkGray
99153>>>>>
99153>>>>>        Object oName is a cCJGridColumn
99155>>>>>            Set piWidth to 334
99156>>>>>            Set psCaption to "Database Name"
99157>>>>>        End_Object
99158>>>>>
99158>>>>>        Procedure Activating
99161>>>>>            tDataSourceRow[] MyData
99161>>>>>            tDataSourceRow[] MyData
99162>>>>>            Handle hoDataSource
99162>>>>>            String[] sTheData
99163>>>>>            Integer iCount iSize
99163>>>>>
99163>>>>>            Send Cursor_Wait of Cursor_Control
99164>>>>>            Forward Send Activating
99166>>>>>
99166>>>>>            Get psTheData to sTheData
99167>>>>>            Move (SizeOfArray(sTheData)) to iSize
99168>>>>>            Decrement iSize
99169>>>>>            For iCount from 0 to iSize
99175>>>>>>
99175>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
99176>>>>>            Loop
99177>>>>>>
99177>>>>>
99177>>>>>            Get phoDataSource to hoDataSource
99178>>>>>            Send InitializeData of hoDataSource MyData
99179>>>>>            Send Cursor_Ready of Cursor_Control
99180>>>>>        End_Procedure
99181>>>>>
99181>>>>>    End_Object
99182>>>>>
99182>>>>>    Object oOK_Btn is a Button
99184>>>>>        Set Label    to "&OK"
99185>>>>>        Set Location to 100 68
99186>>>>>        Set peAnchors To anBottomRight
99187>>>>>
99187>>>>>        Procedure OnClick
99190>>>>>            Send Ok of oSelList
99191>>>>>        End_Procedure
99192>>>>>
99192>>>>>    End_Object
99193>>>>>
99193>>>>>    Object oCancel_Btn is a Button
99195>>>>>        Set Label    to "&Cancel"
99196>>>>>        Set Location to 100 123
99197>>>>>        Set peAnchors to anBottomRight
99198>>>>>
99198>>>>>        Procedure OnClick
99201>>>>>            Send Close_Panel
99202>>>>>        End_Procedure
99203>>>>>
99203>>>>>    End_Object
99204>>>>>
99204>>>>>    Procedure Page Integer iPageObject
99207>>>>>        Set Icon to "DatabaseLookup.ico"
99208>>>>>        Forward Send Page iPageObject
99210>>>>>    End_Procedure
99211>>>>>
99211>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
99212>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
99213>>>>>End_Object
99214>>>Use ServerSelection.dg
Including file: ServerSelection.dg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\ServerSelection.dg)
99214>>>>>Use Windows.pkg
99214>>>>>Use cCJGridPromptList.pkg
99214>>>>>Use cDbUpdateFunctionLibrary.pkg
99214>>>>>Use MSSqldrv.pkg
99214>>>>>Use db2_drv.pkg
99214>>>>>Use odbc_drv.pkg
99214>>>>>
99214>>>>>Object oServerSelection_sl is a ModalPanel
99216>>>>>    Set Size to 148 274
99217>>>>>    Set Label to "Database Server/DSN Selection"
99218>>>>>    Set piMinSize to 89 211
99219>>>>>    Set Location to 2 2
99220>>>>>    Set Border_Style to Border_Thick
99221>>>>>
99221>>>>>    Property String[] psTheData
99223>>>>>
99223>>>>>    Object oSelList is a cCJGridPromptList
99225>>>>>        Set Size to 115 264
99226>>>>>        Set Location to 6 6
99227>>>>>        Set peAnchors to anAll
99228>>>>>        Set pbAllowColumnRemove to False
99229>>>>>        Set pbUseAlternateRowBackgroundColor to True
99230>>>>>        Set pbGrayIfDisable to False
99231>>>>>        Set pbHeaderReorders to False
99232>>>>>        Set pbHeaderSelectsColumn to False
99233>>>>>        Set pbHeaderTogglesDirection to False
99234>>>>>        Set pbShadeSortColumn to False
99235>>>>>        Set piFocusCellBackColor to clDkGray
99236>>>>>
99236>>>>>        Object oName is a cCJGridColumn
99238>>>>>            Set piWidth to 528
99239>>>>>            Set psCaption to "Name"
99240>>>>>        End_Object
99241>>>>>
99241>>>>>        Procedure Activating
99244>>>>>            tDataSourceRow[] MyData
99244>>>>>            tDataSourceRow[] MyData
99245>>>>>            Handle hoDataSource
99245>>>>>            String[] sTheData
99246>>>>>            Integer iCount iSize
99246>>>>>
99246>>>>>            Send Cursor_Wait of Cursor_Control
99247>>>>>            Get psTheData to sTheData
99248>>>>>            Move (SizeOfArray(sTheData)) to iSize
99249>>>>>            Decrement iSize
99250>>>>>            For iCount from 0 to iSize
99256>>>>>>
99256>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
99257>>>>>            Loop
99258>>>>>>
99258>>>>>
99258>>>>>            Forward Send Activating
99260>>>>>
99260>>>>>            Get phoDataSource to hoDataSource
99261>>>>>            Send InitializeData of hoDataSource MyData
99262>>>>>            Send Cursor_Ready of Cursor_Control
99263>>>>>        End_Procedure
99264>>>>>
99264>>>>>    End_Object
99265>>>>>
99265>>>>>    Object oOK_Btn is a Button
99267>>>>>        Set Label    to "&OK"
99268>>>>>        Set Location to 130 165
99269>>>>>        Set peAnchors To anBottomRight
99270>>>>>
99270>>>>>        Procedure OnClick
99273>>>>>            Send Ok of oSelList
99274>>>>>        End_Procedure
99275>>>>>
99275>>>>>    End_Object
99276>>>>>
99276>>>>>    Object oCancel_Btn is a Button
99278>>>>>        Set Label    to "&Cancel"
99279>>>>>        Set Location to 130 220
99280>>>>>        Set peAnchors to anBottomRight
99281>>>>>
99281>>>>>        Procedure OnClick
99284>>>>>            Send Close_Panel
99285>>>>>        End_Procedure
99286>>>>>
99286>>>>>    End_Object
99287>>>>>
99287>>>>>    Procedure Page Integer iPageObject
99290>>>>>        Set Icon to "ServerLookup.ico"
99291>>>>>        Forward Send Page iPageObject
99293>>>>>    End_Procedure
99294>>>>>
99294>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
99295>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
99296>>>>>End_Object
99297>>>Use TableSpaceSelection.dg
Including file: TableSpaceSelection.dg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\TableSpaceSelection.dg)
99297>>>>>Use Windows.pkg
99297>>>>>Use cCJGridPromptList.pkg
99297>>>>>Use cDbUpdateFunctionLibrary.pkg
99297>>>>>
99297>>>>>Object oTableSpaceSelection_sl is a ModalPanel
99299>>>>>    Set Size to 118 177
99300>>>>>    Set Label to "SQL Tablespace Selection"
99301>>>>>    Set piMinSize to 89 177
99302>>>>>    Set Location to 2 2
99303>>>>>    Set Border_Style to Border_Thick
99304>>>>>
99304>>>>>    Property String[] psTheData
99306>>>>>
99306>>>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
99308>>>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
99310>>>>>        End_Object
99311>>>>>    End
99311>>>>>>
99311>>>>>
99311>>>>>    Object oSelList is a cCJGridPromptList
99313>>>>>        Set Size to 89 167
99314>>>>>        Set Location to 6 6
99315>>>>>        Set peAnchors to anAll
99316>>>>>        Set pbAllowColumnRemove to False
99317>>>>>        Set pbUseAlternateRowBackgroundColor to True
99318>>>>>        Set pbGrayIfDisable to False
99319>>>>>        Set pbHeaderReorders to False
99320>>>>>        Set pbHeaderSelectsColumn to False
99321>>>>>        Set pbHeaderTogglesDirection to False
99322>>>>>        Set pbShadeSortColumn to False
99323>>>>>        Set piFocusCellBackColor to clDkGray
99324>>>>>
99324>>>>>        Object oName is a cCJGridColumn
99326>>>>>            Set piWidth to 334
99327>>>>>            Set psCaption to "Table Space Name"
99328>>>>>        End_Object
99329>>>>>
99329>>>>>        Procedure Activating
99332>>>>>            tDataSourceRow[] MyData
99332>>>>>            tDataSourceRow[] MyData
99333>>>>>            Handle hoDataSource
99333>>>>>            String[] sTheData
99334>>>>>            Integer iCount iSize
99334>>>>>
99334>>>>>            Send Cursor_Wait of Cursor_Control
99335>>>>>            Forward Send Activating
99337>>>>>
99337>>>>>            Get psTheData to sTheData
99338>>>>>            Move (SizeOfArray(sTheData)) to iSize
99339>>>>>            Decrement iSize
99340>>>>>            For iCount from 0 to iSize
99346>>>>>>
99346>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
99347>>>>>            Loop
99348>>>>>>
99348>>>>>
99348>>>>>            Get phoDataSource to hoDataSource
99349>>>>>            Send InitializeData of hoDataSource MyData
99350>>>>>            Send Cursor_Ready of Cursor_Control
99351>>>>>        End_Procedure
99352>>>>>
99352>>>>>    End_Object
99353>>>>>
99353>>>>>    Object oOK_Btn is a Button
99355>>>>>        Set Label    to "&OK"
99356>>>>>        Set Location to 100 68
99357>>>>>        Set peAnchors To anBottomRight
99358>>>>>
99358>>>>>        Procedure OnClick
99361>>>>>            Send Ok of oSelList
99362>>>>>        End_Procedure
99363>>>>>
99363>>>>>    End_Object
99364>>>>>
99364>>>>>    Object oCancel_Btn is a Button
99366>>>>>        Set Label    to "&Cancel"
99367>>>>>        Set Location to 100 123
99368>>>>>        Set peAnchors to anBottomRight
99369>>>>>
99369>>>>>        Procedure OnClick
99372>>>>>            Send Close_Panel
99373>>>>>        End_Procedure
99374>>>>>
99374>>>>>    End_Object
99375>>>>>
99375>>>>>    Procedure Page Integer iPageObject
99378>>>>>        Set Icon to "DatabaseLookup.ico"
99379>>>>>        Forward Send Page iPageObject
99381>>>>>    End_Procedure
99382>>>>>
99382>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
99383>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
99384>>>>>End_Object
99385>>>Use SchemasSelection.dg
Including file: SchemasSelection.dg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\SchemasSelection.dg)
99385>>>>>Use Windows.pkg
99385>>>>>Use cCJGridPromptList.pkg
99385>>>>>Use cDbUpdateFunctionLibrary.pkg
99385>>>>>
99385>>>>>Object oSchemasSelection_sl is a ModalPanel
99387>>>>>    Set Size to 118 177
99388>>>>>    Set Label to "SQL Schemas Selection"
99389>>>>>    Set piMinSize to 89 177
99390>>>>>    Set Location to 2 2
99391>>>>>    Set Border_Style to Border_Thick
99392>>>>>
99392>>>>>    Property String[] psTheData
99394>>>>>
99394>>>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
99396>>>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
99398>>>>>        End_Object
99399>>>>>    End
99399>>>>>>
99399>>>>>
99399>>>>>    Object oSelList is a cCJGridPromptList
99401>>>>>        Set Size to 89 167
99402>>>>>        Set Location to 6 6
99403>>>>>        Set peAnchors to anAll
99404>>>>>        Set pbAllowColumnRemove to False
99405>>>>>        Set pbUseAlternateRowBackgroundColor to True
99406>>>>>        Set pbGrayIfDisable to False
99407>>>>>        Set pbHeaderReorders to False
99408>>>>>        Set pbHeaderSelectsColumn to False
99409>>>>>        Set pbHeaderTogglesDirection to False
99410>>>>>        Set pbShadeSortColumn to False
99411>>>>>        Set piFocusCellBackColor to clDkGray
99412>>>>>
99412>>>>>        Object oName is a cCJGridColumn
99414>>>>>            Set piWidth to 334
99415>>>>>            Set psCaption to "Schema Name"
99416>>>>>        End_Object
99417>>>>>
99417>>>>>        Procedure Activating
99420>>>>>            tDataSourceRow[] MyData
99420>>>>>            tDataSourceRow[] MyData
99421>>>>>            Handle hoDataSource
99421>>>>>            String[] sTheData
99422>>>>>            Integer iCount iSize
99422>>>>>
99422>>>>>            Send Cursor_Wait of Cursor_Control
99423>>>>>            Forward Send Activating
99425>>>>>
99425>>>>>            Get psTheData to sTheData
99426>>>>>
99426>>>>>            Move (SizeOfArray(sTheData)) to iSize
99427>>>>>            Decrement iSize
99428>>>>>            For iCount from 0 to iSize
99434>>>>>>
99434>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
99435>>>>>            Loop
99436>>>>>>
99436>>>>>
99436>>>>>            Get phoDataSource to hoDataSource
99437>>>>>            Send InitializeData of hoDataSource MyData
99438>>>>>            Send Cursor_Ready of Cursor_Control
99439>>>>>        End_Procedure
99440>>>>>
99440>>>>>    End_Object
99441>>>>>
99441>>>>>    Object oOK_Btn is a Button
99443>>>>>        Set Label    to "&OK"
99444>>>>>        Set Location to 100 68
99445>>>>>        Set peAnchors To anBottomRight
99446>>>>>
99446>>>>>        Procedure OnClick
99449>>>>>            Send Ok of oSelList
99450>>>>>        End_Procedure
99451>>>>>
99451>>>>>    End_Object
99452>>>>>
99452>>>>>    Object oCancel_Btn is a Button
99454>>>>>        Set Label    to "&Cancel"
99455>>>>>        Set Location to 100 123
99456>>>>>        Set peAnchors to anBottomRight
99457>>>>>
99457>>>>>        Procedure OnClick
99460>>>>>            Send Close_Panel
99461>>>>>        End_Procedure
99462>>>>>
99462>>>>>    End_Object
99463>>>>>
99463>>>>>    Procedure Page Integer iPageObject
99466>>>>>        Set Icon to "DatabaseLookup.ico"
99467>>>>>        Forward Send Page iPageObject
99469>>>>>    End_Procedure
99470>>>>>
99470>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
99471>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
99472>>>>>End_Object
99473>>>Use cHeaderGroup.pkg
Including file: cHeaderGroup.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cHeaderGroup.pkg)
99473>>>>>Use Windows.pkg
99473>>>>>
99473>>>>>Use cCommandLinkButton.pkg
Including file: cCommandLinkButton.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCommandLinkButton.pkg)
99473>>>>>>>// cCommandLinkButton class
99473>>>>>>>
99473>>>>>>>// This requires version 6 of common controls (vista or windows server 2008). If used with
99473>>>>>>>// older versions you will just get a regular great big button.
99473>>>>>>> 
99473>>>>>>>Use Windows.pkg
99473>>>>>>>Use CharTranslate.pkg
99473>>>>>>>
99473>>>>>>>Class cCommandLinkButton is a Button
99474>>>>>>>
99474>>>>>>>        Procedure Construct_Object
99476>>>>>>>            Forward Send Construct_Object
99478>>>>>>>            Property String psPrivateNote
99479>>>>>>>        End_Procedure
99480>>>>>>>        
99480>>>>>>>        Procedure Set psNote String sNote
99482>>>>>>>            Boolean bSupported
99482>>>>>>>            Set psPrivateNote to sNote
99483>>>>>>>            Get IsExControlSupported to bSupported
99484>>>>>>>            If bSupported Begin
99486>>>>>>>                Send SetWinNote
99487>>>>>>>            End
99487>>>>>>>>
99487>>>>>>>        End_Procedure
99488>>>>>>>        
99488>>>>>>>        Procedure SetWinNote
99490>>>>>>>            String sNote
99490>>>>>>>            Handle hWnd
99490>>>>>>>            Integer i
99490>>>>>>>            Address aVar
99490>>>>>>>            Get Form_Window_Handle 0 to hWnd
99491>>>>>>>            If hWnd Begin
99493>>>>>>>                Get psNote to sNote
99494>>>>>>>                Move (OemToUtf16Buffer(AddressOf(sNote),Length(sNote))) to aVar
99495>>>>>>>                Move (SendMessage(hwnd, BCM_SETNOTE, 0, aVar)) to i
99496>>>>>>>                Move (Free(aVar)) to i 
99497>>>>>>>            End
99497>>>>>>>>
99497>>>>>>>        End_Procedure
99498>>>>>>>        
99498>>>>>>>        
99498>>>>>>>        Function psNote Returns String
99500>>>>>>>            Function_Return (psPrivateNote(Self))
99501>>>>>>>        End_Function
99502>>>>>>>        
99502>>>>>>>
99502>>>>>>>        Procedure Page Integer iState
99504>>>>>>>            Integer i hWnd
99504>>>>>>>            Boolean bSupported
99504>>>>>>>            Get IsExControlSupported to bSupported
99505>>>>>>>            If (iState=1 and bSupported) Begin
99507>>>>>>>                Get form_style i to i
99508>>>>>>>                Set Form_Style 0 to (i ior (BS_COMMANDLINK + BS_FLAT))
99509>>>>>>>                Forward Send Page iState
99511>>>>>>>                Send SetWinNote
99512>>>>>>>            End
99512>>>>>>>>
99512>>>>>>>            Else Begin
99513>>>>>>>                Forward Send Page iState
99515>>>>>>>            End
99515>>>>>>>>
99515>>>>>>>        End_Procedure        
99516>>>>>>>
99516>>>>>>>End_Class
99517>>>>>Class cHeaderGroupImage is a cCommandLinkButton
99518>>>>>    Procedure Construct_Object
99520>>>>>        Forward Send Construct_Object
99522>>>>>            Set piImageSize to 24
99523>>>>>        Set Focus_Mode to NonFocusable
99524>>>>>    End_Procedure
99525>>>>>
99525>>>>>
99525>>>>>    Procedure OnClick
99527>>>>>        Broadcast Send Prompt of (Parent(Self))
99529>>>>>    End_Procedure
99530>>>>>
99530>>>>>    Procedure Set Bitmap String sBitmapName
99532>>>>>        Forward Set psImage to sBitmapName
99534>>>>>    End_Procedure
99535>>>>>
99535>>>>>    Procedure End_Construct_Object
99537>>>>>        Forward Send End_Construct_Object
99539>>>>>    End_Procedure
99540>>>>>
99540>>>>>End_Class
99541>>>>>
99541>>>>>// Intermediate class - don't use.
99541>>>>>Class _cHeaderGroup is a Container3d
99542>>>>>
99542>>>>>    Register_Object oInfo_tb
99542>>>>>
99542>>>>>    Procedure Construct_Object
99544>>>>>        Forward Send Construct_Object
99546>>>>>
99546>>>>>        Property String private.psImage
99547>>>>>        Property String private.psLabel
99548>>>>>    End_Procedure
99549>>>>>
99549>>>>>    Procedure Set psImage String sImage
99551>>>>>        Set private.psImage to sImage
99552>>>>>    End_Procedure
99553>>>>>
99553>>>>>    Function psImage Returns String
99555>>>>>        Function_Return (private.psImage(Self))
99556>>>>>    End_Function
99557>>>>>
99557>>>>>    Procedure Set psLabel String sLabel
99559>>>>>        Set private.psLabel to sLabel
99560>>>>>    End_Procedure
99561>>>>>
99561>>>>>    Function psLabel Returns String
99563>>>>>        Function_Return (private.psLabel(Self))
99564>>>>>    End_Function
99565>>>>>
99565>>>>>    // Don't display but allow to use old "Label" syntax to set the value of the oInfo_tb object (header text)
99565>>>>>    Procedure Set Label String sLabel
99567>>>>>        Set private.psLabel to sLabel
99568>>>>>        Set Label of oInfo_tb to sLabel
99569>>>>>    End_Procedure
99570>>>>>
99570>>>>>    Function Label Returns String
99572>>>>>        Function_Return (private.psLabel(Self))
99573>>>>>    End_Function
99574>>>>>
99574>>>>>End_Class
99575>>>>>
99575>>>>>Class cHeaderGroup is a _cHeaderGroup
99576>>>>>
99576>>>>>    Procedure Construct_Object
99578>>>>>        Forward Send Construct_Object
99580>>>>>
99580>>>>>        Set peAnchors to anTopLeftRight
99581>>>>>        //Set Color to clWhite
99581>>>>>        Set pbAcceptDropFiles to True
99582>>>>>        Set Border_Style to Border_Normal
99583>>>>>
99583>>>>>        Property Integer private.piColorOrg
99584>>>>>        Property Boolean private.pbIsHeaderGroup True // Don't touch!
99585>>>>>
99585>>>>>            Property Integer piBitmapColOffset 4
99586>>>>>            Property Integer piBitmapRowOffset 1
99587>>>>>
99587>>>>>        Property Boolean pbUseHotspotColor True
99588>>>>>        Property Integer piHeaderHotspotColor clAqua
99589>>>>>        Property String psLabel ""
99590>>>>>        Property Integer piLabelColor clBlack
99591>>>>>        Property Boolean pbLabelFontItalics False
99592>>>>>        Property Integer piLabelFontPointHeight False
99593>>>>>        Property Integer piLabelFontPointWeight fw_Bold
99594>>>>>        Property Integer piLabelColOffset 25
99595>>>>>        Property Integer piLabelRowOffset 3 //4
99596>>>>>
99596>>>>>    End_Procedure
99597>>>>>
99597>>>>>    Procedure End_Construct_Object
99599>>>>>
99599>>>>>        Object oImage_bmp is a cHeaderGroupImage
99601>>>>>            Set Location to (piBitmapRowOffset(Self)) (piBitmapColOffset(Self))
99602>>>>>                Set Size to 14 18
99603>>>>>            Set Bitmap to (private.psImage(Self))
99604>>>>>        End_Object
99605>>>>>
99605>>>>>        Object oInfo_tb is a TextBox
99607>>>>>            Set Auto_Size_State to False
99608>>>>>            Set Size to 10 150
99609>>>>>            Set Location to (piLabelRowOffset(Self)) (piLabelColOffset(Self))
99610>>>>>            Set FontWeight to (piLabelFontPointWeight(Self))
99611>>>>>            Set FontItalics to (pbLabelFontItalics(Self))
99612>>>>>            Set FontPointHeight to (piLabelFontPointHeight(Self))
99613>>>>>            Set Label to (psLabel(Self))
99614>>>>>            Set TextColor to (piLabelColor(Self))
99615>>>>>        End_Object
99616>>>>>
99616>>>>>        Forward Send End_Construct_Object
99618>>>>>    End_Procedure
99619>>>>>
99619>>>>>    Procedure OnEnterArea Handle hoFrom
99621>>>>>        Integer iColor
99621>>>>>        Forward Send OnEnterArea hoFrom
99623>>>>>        // ToDo: Not perfect, but works most of the time.
99623>>>>>        //       When navigating to i.e a popup we don't want
99623>>>>>        //       the coloring to appear. Else there will be 2
99623>>>>>        //       cHeaderGroup's with the highlight color...
99623>>>>>        // Is there a better way?
99623>>>>>        If (hoFrom <> Desktop and hoFrom < Parent(Self)) Begin
99625>>>>>            Procedure_Return
99626>>>>>        End
99626>>>>>>
99626>>>>>        If (pbUseHotspotColor(Self) = True) Begin
99628>>>>>            Get Color to iColor
99629>>>>>            Set private.piColorOrg to iColor
99630>>>>>            Get piHeaderHotspotColor to iColor
99631>>>>>            Set Color to iColor
99632>>>>>            Broadcast Recursive Set Color to iColor
99634>>>>>        End
99634>>>>>>
99634>>>>>    End_Procedure
99635>>>>>
99635>>>>>    Procedure OnExitArea Handle hoFrom
99637>>>>>        Integer iColor
99637>>>>>        Forward Send OnExitArea hoFrom
99639>>>>>        If (pbUseHotspotColor(Self) = True) Begin
99641>>>>>            Get private.piColorOrg to iColor
99642>>>>>            Set Color to iColor
99643>>>>>            Broadcast Recursive Set Color to iColor
99645>>>>>        End
99645>>>>>>
99645>>>>>    End_Procedure
99646>>>>>
99646>>>>>    // Public access message to change the group header text color at runtime.
99646>>>>>    Procedure Set Label_Color Integer iColor
99648>>>>>        Set TextColor of oInfo_tb to iColor
99649>>>>>    End_Procedure
99650>>>>>
99650>>>>>    Procedure NavigatePrevious
99652>>>>>        Integer iMulti ivoid
99652>>>>>        Handle hWnd
99652>>>>>
99652>>>>>        Move False to Err
99653>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
99654>>>>>        Get Select_Mode of (Focus(Self)) to iMulti
99655>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
99656>>>>>        If (Err) Begin
99658>>>>>            Procedure_Return
99659>>>>>        End
99659>>>>>>
99659>>>>>
99659>>>>>        If (iMulti = Multi_Select) Begin
99661>>>>>            Send Previous
99662>>>>>        End
99662>>>>>>
99662>>>>>        Else Begin
99663>>>>>            Get Form_Window_Handle of (Focus(Self)) to hWnd
99664>>>>>            Move (Sendmessage(hWnd,WM_KEYDOWN,Ascii(VK_LEFT),0)) to iVoid
99665>>>>>        End
99665>>>>>>
99665>>>>>    End_Procedure
99666>>>>>
99666>>>>>    Procedure NavigateNext
99668>>>>>        Integer iMulti ivoid
99668>>>>>        Handle hWnd
99668>>>>>
99668>>>>>        Move False to Err
99669>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
99670>>>>>        Get Select_Mode of (Focus(Self)) to iMulti
99671>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
99672>>>>>        If (Err) Begin
99674>>>>>            Procedure_Return
99675>>>>>        End
99675>>>>>>
99675>>>>>
99675>>>>>        If (iMulti = Multi_Select) Begin
99677>>>>>            Send Next
99678>>>>>        End
99678>>>>>>
99678>>>>>        Else Begin
99679>>>>>            Get Form_Window_Handle of (Focus(Self)) to hWnd
99680>>>>>            Move (Sendmessage(hWnd,WM_KEYDOWN,Ascii(VK_LEFT),0)) to iVoid
99681>>>>>        End
99681>>>>>>
99681>>>>>
99681>>>>>    End_Procedure
99682>>>>>
99682>>>>>    On_Key kLeftArrow  Send NavigatePrevious
99683>>>>>    On_Key kRightArrow Send NavigateNext
99684>>>>>End_Class
99685>>>>>
99685>>>>>// We don't want the broadcast of setting color to set the background
99685>>>>>// color for forms that are within a cHeaderGroup object.
99685>>>>>Procedure Set Color for Form Integer eColor
99687>>>>>    Boolean bIsHeaderGroup
99687>>>>>    Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
99688>>>>>    Delegate Get private.pbIsHeaderGroup to bIsHeaderGroup
99690>>>>>    Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
99691>>>>>    If (bIsHeaderGroup = False) Begin
99693>>>>>        Forward Set Color to eColor
99695>>>>>    End
99695>>>>>>
99695>>>>>End_Procedure
99696>>>>>
99696>>>
99696>>>Define CS_LoadingServers        for "Enumerating servers..."
99696>>>Define CS_LoadingDatabases      for "Enumerating databases..."
99696>>>Define CS_LoadingTableSpaces    for "Enumerating table spaces..."
99696>>>Define CS_LoadingSchemas        for "Enumerating schemas..."
99696>>>Define CS_LoginAttempt          for "Connecting..."
99696>>>Define CS_LoginSuccessful       for "Login successful!"
99696>>>Define CS_LoginFailed           for "Login failed!"
99696>>>Define CS_DF_File_Schema        for "Schema"
99696>>>Define CS_DF_File_Owner         for "Owner"
99696>>>
99696>>>Object oSQLMaintainConnections_dg is a ModalPanel
99698>>>    Set Label to "Edit SQL Connection"
99699>>>    Set Size to 291 410
99700>>>    Set Location to 4 6
99701>>>    Set Locate_Mode to Center_On_Parent
99702>>>    Set Border_Style to Border_Thick
99703>>>    Set piMaxSize to (Hi(Size(Self))) (Low(Size(Self)) + 300)
99704>>>    Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
99705>>>
99705>>>    Property Boolean pbReadOnly  False
99707>>>    Property Boolean pbNew       False // First time for a workspace, which means the .ini-file is empty.
99709>>>    Property Integer piCurrentRow -1   // The current row of the grid that was passed to this dialog.
99711>>>    Property Boolean pbChanged   False // If any change was made to the data.
99713>>>    Property Handle phoDialogCommandbar
99715>>>    Property tSQLConnection pSQLConnectionData
99717>>>    Property tDataSourceRow[] pTheData
99719>>>    Property Boolean pbDFConnId  False // Is set to True if this is a DAW "DFConnId.ini" file; in which case we warn to not encrypt/decrypt password. (different algorithms and don't touch password)
99721>>>    Property String psUncryptedPw     // Used if  pbDFConnId = True to temporary save the un-encrypted password.
99723>>>
99723>>>    Object oConnectionType_grp is a cHeaderGroup
99725>>>        Set Size to 70 389
99726>>>        Set Location to 2 11
99727>>>        Set psImage to "SelectTablesBlack24.bmp"
99728>>>        Set psLabel to "Connection Type"
99729>>>
99729>>>        Object oDbType_cf is a cSQLComboForm
99731>>>            Set Size to 11 120
99732>>>            Set Location to 23 86
99733>>>            Set Label_Col_Offset to 2
99734>>>            Set Label_Justification_Mode to JMode_Right
99735>>>            Set Label to "Database Type"
99736>>>            Set Entry_State to False
99737>>>            Set Combo_Sort_State to False
99738>>>            Set piItem to 3
99739>>>
99739>>>            Procedure Combo_Fill_List
99742>>>                Send Combo_Add_Item CS_dbTypeMSSQL
99743>>>                Send Combo_Add_Item CS_dbTypeMySQL
99744>>>                Send Combo_Add_Item CS_dbTypeOracle
99745>>>                Send Combo_Add_Item CS_dbTypeDB2
99746>>>                Send Combo_Add_Item CS_dbTypePostgre
99747>>>            End_Procedure
99748>>>
99748>>>        Procedure OnChange
99751>>>            Integer iDbType
99751>>>            String sDriverID
99751>>>
99751>>>            Get SelectedDbType to iDbType
99752>>>            Send Refill_Comboform of oDriverID_cf iDbType
99753>>>            Get Value of oDriverID_cf to sDriverID
99754>>>            If (sDriverID = "") Begin
99756>>>                Move MSSQLDRV_ID to sDriverID
99757>>>            End
99757>>>>
99757>>>            Send DbTypeUpdate of oSettings_grp iDbType sDriverID
99758>>>        End_Procedure
99759>>>
99759>>>        Function SelectedDbType Returns Integer
99762>>>            Integer iRetval
99762>>>            String sDbType
99762>>>
99762>>>            Get Value to sDbType
99763>>>            Get SqlUtilDbTypeToInteger of ghoDbUpdateFunctionLibrary sDbType to iRetval
99764>>>
99764>>>            Function_Return iRetval
99765>>>        End_Function
99766>>>
99766>>>        End_Object
99767>>>
99767>>>        Object oDriverID_cf is a cSQLComboForm
99769>>>            Set Size to 11 120
99770>>>            Set Location to 36 86
99771>>>            Set Label_Col_Offset to 2
99772>>>            Set Label_Justification_Mode to JMode_Right
99773>>>            Set Label to "Driver ID"
99774>>>            Set psToolTip to "Depending on the database type selected and if Mertech drivers have been installed, the comboform list will vary."
99775>>>            Set Entry_State to False
99776>>>            Set Combo_Sort_State to False
99777>>>            Set piItem to 4
99778>>>
99778>>>            Procedure Refill_Comboform Integer iDbType
99781>>>                String sValue
99781>>>                Send Combo_Delete_Data
99782>>>                Case Begin
99782>>>                    Case (iDbType = EN_dbTypeMSSQL)
99784>>>                        Send Combo_Add_Item MSSQLDRV_ID
99785>>>                        Send Combo_Add_Item SQLFLEX
99786>>>                        Move MSSQLDRV_ID to sValue
99787>>>                        Case Break
99788>>>                    Case (iDbType = EN_dbTypeMySQL)
99791>>>                        Send Combo_Add_Item ODBC_DRV_ID
99792>>>                        Send Combo_Add_Item MDSMySQL
99793>>>                        Move MDSMySQL to sValue
99794>>>                        Case Break
99795>>>                    Case (iDbType = EN_dbTypeOracle)
99798>>>                        Send Combo_Add_Item ODBC_DRV_ID
99799>>>                        Send Combo_Add_Item ORAFLEX
99800>>>                        Move ORAFLEX to sValue
99801>>>                        Case Break
99802>>>                    Case (iDbType = EN_dbTypeDB2)
99805>>>                        Send Combo_Add_Item DB2_DRV_ID
99806>>>                        Move DB2_DRV_ID to sValue
99807>>>                        Case Break
99808>>>                    Case (iDbType = EN_dbTypePostgre)
99811>>>                        Send Combo_Add_Item ODBC_DRV_ID
99812>>>                        Send Combo_Add_Item MDSPgSQL
99813>>>                        Move MDSPgSQL to sValue
99814>>>                        Case Break
99815>>>                    Case Else
99815>>>                        Send Combo_Add_Item DATAFLEX_ID
99816>>>                        Move DATAFLEX_ID to sValue
99817>>>    //                Case (iDbType = EN_dbTypeMSSQL)
99817>>>    //                    Send Combo_Add_Item (MSSQLDRV_ID * "- (DAW)")
99817>>>    //                    Send Combo_Add_Item (SQLFLEX * "- (Mertech)")
99817>>>    //                    Move (MSSQLDRV_ID * "- (DAW)") to sValue
99817>>>    //                    Case Break
99817>>>    //                Case (iDbType = EN_dbTypeMySQL)
99817>>>    //                    Send Combo_Add_Item (ODBC_DRV_ID * "- (DAW)")
99817>>>    //                    Send Combo_Add_Item (MDSMySQL * "- (Mertech)")
99817>>>    //                    Move (MDSMySQL * "- (Mertech)") to sValue
99817>>>    //                    Case Break
99817>>>    //                Case (iDbType = EN_dbTypeOracle)
99817>>>    //                    Send Combo_Add_Item (ODBC_DRV_ID * "- (DAW)")
99817>>>    //                    Send Combo_Add_Item (ORAFLEX * "- (Mertech)")
99817>>>    //                    Move (ORAFLEX * "- (Mertech)") to sValue
99817>>>    //                    Case Break
99817>>>    //                Case (iDbType = EN_dbTypeDB2)
99817>>>    //                    Send Combo_Add_Item (DB2_DRV_ID * "- (DAW)")
99817>>>    //                    Move (DB2_DRV_ID * "- (DAW)") to sValue
99817>>>    //                    Case Break
99817>>>    //                Case (iDbType = EN_dbTypePostgre)
99817>>>    //                    Send Combo_Add_Item (ODBC_DRV_ID * "- (DAW)")
99817>>>    //                    Send Combo_Add_Item (MDSPgSQL * "- (Mertech)")
99817>>>    //                    Move (MDSPgSQL * "- (Mertech)") to sValue
99817>>>    //                    Case Break
99817>>>    //                Case Else
99817>>>    //                    Send Combo_Add_Item (DATAFLEX_ID * "- (DAW)")
99817>>>    //                    Move (DATAFLEX_ID * "- (DAW)") to sValue
99817>>>                Case End
99817>>>                Set Value to sValue
99818>>>            End_Procedure
99819>>>
99819>>>            Procedure OnChange
99822>>>                String sDriverID
99822>>>                Integer iDbType iPos
99822>>>
99822>>>                Get Value to sDriverID
99823>>>                Move (Pos("-", sDriverID)) to iPos
99824>>>                Move (Left(sDriverID, (iPos - 2))) to sDriverID
99825>>>                If (sDriverID = "") Begin
99827>>>                    Move MSSQLDRV_ID to sDriverID
99828>>>                End
99828>>>>
99828>>>                Get SelectedDbType of oDbType_cf to iDbType
99829>>>                Broadcast Recursive Send DbTypeUpdate of oSettings_grp iDbType sDriverID
99831>>>            End_Procedure
99832>>>
99832>>>        End_Object
99833>>>
99833>>>        Object oConnectionID_fm is a cSQLForm
99835>>>            Set Size to 13 120
99836>>>            Set Location to 49 86
99837>>>            Set Label to "Connection ID"
99838>>>            Set Label_Col_Offset to 2
99839>>>            Set Label_Justification_Mode to JMode_Right
99840>>>            Set psToolTip to "The DFConnectionID keyword to set a default connection id for the driver. This is the connection ID that appear in database table .int files with the format; 'SERVER_NAME DFCONNID=MyConnID'"
99841>>>            Set piItem to 2
99842>>>        End_Object
99843>>>
99843>>>        Object oEnabled_cb is a cSQLCheckBox
99845>>>            Set Auto_Size_State to False
99846>>>            Set Size to 9 38
99847>>>            Set Location to 51 216
99848>>>            Set Label to "Enabled"
99849>>>            Set psToolTip to "Check to indicate that this is the enabled connection. Note: There can only be one enabled connection at a time."
99850>>>            Set piItem to 1
99851>>>
99851>>>            Procedure OnChange
99854>>>                Boolean bChecked bNew
99854>>>                tSQLConnection SQLConnection
99854>>>                tSQLConnection SQLConnection
99854>>>
99854>>>                Get pbNew to bNew
99855>>>                Get Checked_State to bChecked
99856>>>                If (bNew = False and bChecked = True) Begin
99858>>>                    Get pSQLConnectionData to SQLConnection
99859>>>                    Move True to SQLConnection.bEnabled
99860>>>                End
99860>>>>
99860>>>
99860>>>            End_Procedure
99861>>>
99861>>>        End_Object
99862>>>
99862>>>    End_Object
99863>>>
99863>>>    Object oSettings_grp is a cHeaderGroup
99865>>>        Set Size to 178 389
99866>>>        Set Location to 81 11
99867>>>        Set Label to "SQL Server Details"
99868>>>        Set peAnchors to anTopLeftRight
99869>>>        Set psImage to "SettingsBlack24.bmp"
99870>>>        Set psLabel to "SQL Connection Settings"
99871>>>
99871>>>        Object oServer_fm is a cSQLForm
99873>>>            Set Size to 13 120
99874>>>            Set Location to 24 74
99875>>>            Set Label to "Server"
99876>>>            Set Label_Col_Offset to 2
99877>>>            Set Label_Justification_Mode to JMode_Right
99878>>>            Set psToolTip to "Server/DSN: Depending on the selected database type the label can either display as 'Server' or 'DSN'. Either enter the name - if you know it - or by using the selection list (F4). Tip: If you are using Microsoft SQL Server and you are testing on the same machine as the MS SQL Server instance is running and you are using SQLEXPRESS you can enter e.g. '.\SQLEXPRESS'. That will mean use the SQLEXPRESS instance of Microsoft SQL Server running on this machine. If you press [F4] and the selection list comes up empty for Microsoft SQL Server it probably is because the service hasn't been started. Type 'Services' in Windows menu system to start Windows Services app. Type 'SQL' to jump to the SQL Server services. Check that the 'SQL Server Browser' service is started and set to 'Automatic'."
99879>>>            Set peAnchors to anTopLeftRight
99880>>>            Set piItem to 5
99881>>>
99881>>>            Property Handle phoPromptObject (oServerSelection_sl(Self))
99883>>>
99883>>>            Procedure Prompt
99886>>>                String sDriverID sValue
99886>>>                String[] sTheData
99887>>>                Integer iDbType iODBCType iRadio iPos
99887>>>                Handle ho
99887>>>
99887>>>                Get Prompt_Object to ho
99888>>>                If (ho = 0) Begin
99890>>>                    Procedure_Return
99891>>>                End
99891>>>>
99891>>>
99891>>>                Set Label of oServersInfo_tb to CS_LoadingServers
99892>>>                Send Cursor_Wait of Cursor_Control
99893>>>                Get SelectedDbType of oDbType_cf to iDbType
99894>>>                Get Value of oDriverID_cf to sDriverID
99895>>>                Get Current_Radio of oODBC_rgp to iRadio
99896>>>                If (iRadio = 0) Begin
99898>>>                    Move SQL_FETCH_USER     to iODBCType
99899>>>                End
99899>>>>
99899>>>                If (iRadio = 1) Begin
99901>>>                    Move SQL_FETCH_SYSTEM   to iODBCType
99902>>>                End
99902>>>>
99902>>>                If (iRadio = 2) Begin
99904>>>                    Move SQL_FETCH_ALL      to iODBCType
99905>>>                End
99905>>>>
99905>>>
99905>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
99906>>>                Load_Driver sDriverID
99907>>>                Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
99908>>>                If (LastErr = 4255) Begin
99910>>>                    Send Cursor_Ready of Cursor_Control
99911>>>                    Send Info_Box ("Can't display any items because the database driver could not be loaded. (" + sDriverID + ")")
99912>>>                    Procedure_Return
99913>>>                End
99913>>>>
99913>>>
99913>>>                Get SqlUtilEnumerateServers of ghoDbUpdateFunctionLibrary sDriverID iODBCType to sTheData
99914>>>                Set psTheData  of ho to sTheData
99915>>>                Set Label of oServersInfo_tb to ""
99916>>>
99916>>>                Forward Send Prompt
99918>>>
99918>>>                // The selection list will show the ODBC DataSource name + a comma (,) + a description.
99918>>>                // We need to remove those parts from the comma and to the end of string.
99918>>>                If (sDriverID = ODBC_DRV_ID) Begin
99920>>>                    Get Value to sValue
99921>>>                    Move (Pos(",", sValue)) to iPos
99922>>>                    Move (Left(sValue, (iPos - 1))) to sValue
99923>>>                    Set Value to sValue
99924>>>                End
99924>>>>
99924>>>            End_Procedure
99925>>>
99925>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
99928>>>                String sLabel
99928>>>                Handle ho
99928>>>
99928>>>                Get phoPromptObject to ho
99929>>>                Set Prompt_Button_Mode to PB_PromptOn
99930>>>                Case Begin
99930>>>                    Case (iDbType = EN_dbTypeDB2)
99932>>>                        Move "DSN" to sLabel
99933>>>                        Case Break
99934>>>                    Case (iDbType = EN_dbTypeMSSQL)
99937>>>                        Move "Server" to sLabel
99938>>>                        Case Break
99939>>>                    Case (iDbType = EN_dbTypeMySQL)
99942>>>                        If (sDriverID = ODBC_DRV_ID) Begin
99944>>>                            Move "ODBC Data Source" to sLabel
99945>>>                        End
99945>>>>
99945>>>                        Else Begin
99946>>>                            Move "DSN" to sLabel
99947>>>                        End
99947>>>>
99947>>>                        Case Break
99948>>>                    Case (iDbType = EN_dbTypeOracle)
99951>>>                        If (sDriverID = ODBC_DRV_ID) Begin
99953>>>                            Move "ODBC Data Source" to sLabel
99954>>>                        End
99954>>>>
99954>>>                        Else Begin
99955>>>                            Move "Server" to sLabel
99956>>>                        End
99956>>>>
99956>>>                        Case Break
99957>>>                    Case (iDbType = EN_dbTypePostgre)
99960>>>                        If (sDriverID = ODBC_DRV_ID) Begin
99962>>>                            Move "ODBC Data Source" to sLabel
99963>>>                        End
99963>>>>
99963>>>                        Else Begin
99964>>>                            Move "Server" to sLabel
99965>>>                        End
99965>>>>
99965>>>                        Case Break
99966>>>                    Case Else
99966>>>                Case End
99966>>>
99966>>>                Set Prompt_Object to ho
99967>>>                Set Label to sLabel
99968>>>            End_Procedure
99969>>>
99969>>>        End_Object
99970>>>
99970>>>        Object oSilentLogin_fm is a cSQLCheckBox
99972>>>            Set Auto_Size_State to False
99973>>>            Set Size to 9 51
99974>>>            Set Location to 27 205
99975>>>            Set Label to "Silent Login"
99976>>>            Set psToolTip to "Silent login to database is to not show error if login was unsuccessive."
99977>>>            Set peAnchors to anTopRight
99978>>>            Set piItem to 15
99979>>>        End_Object
99980>>>
99980>>>        Object oServersInfo_tb is a TextBox
99982>>>            Set Auto_Size_State to False
99983>>>            Set Size to 9 100
99984>>>            Set Location to 28 262
99985>>>            Set TextColor to clGreen
99986>>>            Set Justification_Mode to JMode_Right
99987>>>            Set peAnchors to anTopRight
99988>>>        End_Object
99989>>>
99989>>>        Object oODBCInfo_tb is a TextBox
99991>>>            Set Size to 9 63
99992>>>            Set Location to 51 7
99993>>>            Set Label to "ODBC Source Type"
99994>>>            Set Label_Shadow_Display_Mode to TBShadow_On_All
99995>>>        End_Object
99996>>>
99996>>>        Object oODBC_rgp is a RadioGroup
99998>>>            Set Location to 41 75
99999>>>            Set Size to 25 298
100000>>>//            Set psToolTip to "Only available if the ODBC_DRV has been selected. Depending on the radio button that is selected the 'Server/DSN' selection list shows different values."
100000>>>
100000>>>            Object oRadio1 is a Radio
100002>>>                Set Label to "User data"
100003>>>                Set Size to 10 49
100004>>>                Set Location to 10 5
100005>>>            End_Object
100006>>>
100006>>>            Object oRadio2 is a Radio
100008>>>                Set Label to "System data"
100009>>>                Set Size to 10 55
100010>>>                Set Location to 10 64
100011>>>            End_Object
100012>>>
100012>>>            Object oRadio3 is a Radio
100014>>>                Set Label to "Both"
100015>>>                Set Size to 10 28
100016>>>                Set Location to 11 130
100017>>>            End_Object
100018>>>
100018>>>            Procedure Notify_Select_State Integer iToItem Integer iFromItem
100021>>>                Forward Send Notify_Select_State iToItem iFromItem
100023>>>            End_Procedure
100024>>>
100024>>>            Object oFileDSN_btn is a cButtonDPI
100026>>>                Set Size to 13 62
100027>>>                Set Location to 8 168
100028>>>                Set Label to "Select File DSN..."
100029>>>
100029>>>                Procedure OnClick
100032>>>                    String sFileName
100032>>>                    Get vSelect_File ("Data Sources (*.dsn)|*.dsn|All Files (*.*)|*.*") "Select a file data source" "" to sFileName
100033>>>                    If (sFileName <> "") Begin
100035>>>                        Set Value of oServer_fm to sFileName
100036>>>                    End
100036>>>>
100036>>>                End_Procedure
100037>>>
100037>>>                Set Current_Radio to 2
100038>>>            End_Object
100039>>>
100039>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
100042>>>                Set Enabled_State to (sDriverID = ODBC_DRV_ID)
100043>>>                Set Enabled_State of oODBCInfo_tb to (sDriverID = ODBC_DRV_ID)
100044>>>            End_Procedure
100045>>>
100045>>>            Object oODBCAdmin_btn is a cButtonDPI
100047>>>                Set Size to 13 55
100048>>>                Set Location to 8 234
100049>>>                Set Label to "ODBC Admin"
100050>>>                Procedure OnClick
100053>>>                    Handle hWnd
100053>>>                    Get Window_Handle to hWnd
100054>>>                    If (hWnd <> 0) Begin
100056>>>                        Call_Driver 0 ODBC_DRV_ID Function ODBC_MANAGE_DATA_SOURCES Callback 0 Passing CLI$StrDummy CLI$StrDummy !1 Result CLI$IntDummy
100061>>>                    End
100061>>>>
100061>>>                    Else Begin
100062>>>                        Send Stop_Box "Could not get a Windows handle.."
100063>>>                    End
100063>>>>
100063>>>                End_Procedure
100064>>>            End_Object
100065>>>
100065>>>        End_Object
100066>>>
100066>>>        Object oTrusted_cb is a cSQLCheckBox
100068>>>            Set Size to 10 50
100069>>>            Set Location to 75 74
100070>>>            Set Label to "Use Trusted Connection"
100071>>>            Set psToolTip to "(Windows Authentication) When selected, SQL Server uses integrated login (Windows login information) security to establish connections using this data source, regardless of the current login security mode at the server."
100072>>>            Set piItem to 8
100073>>>
100073>>>            Procedure OnChange
100076>>>                Boolean bChecked
100076>>>                Get Checked_State to bChecked
100077>>>                Set Enabled_State of oUserID_fm   to (bChecked = False)
100078>>>                Set Enabled_State of oPassword_fm to (bChecked = False)
100079>>>                Set Enabled_State of oViewPassword_btn to (bChecked = False)
100080>>>            End_Procedure
100081>>>
100081>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
100084>>>                Boolean bChecked
100084>>>
100084>>>                Get Checked_State to bChecked
100085>>>                If (iDbType <> EN_dbTypeMSSQL) Begin
100087>>>                    Set Enabled_State to (iDbType = EN_dbTypeMSSQL)
100088>>>                    If (bChecked = True) Begin
100090>>>                        Set Checked_State to False
100091>>>                    End
100091>>>>
100091>>>                End
100091>>>>
100091>>>                Else Begin
100092>>>                    Set Enabled_State to True
100093>>>                End
100093>>>>
100093>>>
100093>>>                Send OnChange
100094>>>            End_Procedure
100095>>>
100095>>>        End_Object
100096>>>
100096>>>        Object oUserID_fm is a cSQLForm
100098>>>            Set Size to 13 120
100099>>>            Set Location to 86 74
100100>>>            Set Label to "User ID"
100101>>>            Set Label_Col_Offset to 2
100102>>>            Set Label_Justification_Mode to JMode_Right
100103>>>            Set psToolTip to "Enter the user name to use for authentication when you log on to the database."
100104>>>            Set piItem to 9
100105>>>        End_Object
100106>>>
100106>>>        Object oPassword_fm is a cSQLForm
100108>>>            Set Size to 13 80
100109>>>            Set Location to 86 270
100110>>>            Set Label to "Password"
100111>>>            Set Label_Col_Offset to 2
100112>>>            Set Label_Justification_Mode to JMode_Right
100113>>>            Set psToolTip to "Enter the password for your user name. The password will automatically be encrypted & decrypted when writing/reading from the ini file. Of Special Note: If the cConnection class is used with DataFlex 19 or later and such an .ini file is edited with this program you will get a question if you would like the program to 'touch' the password or not. If you answer No, the ini-file will keep working with the DataFlex tools. You should probably never try to change the password with this program for a DFConnid.ini file as the two programs uses different encryption/decryption algorithms."
100114>>>            Set piItem to 10
100115>>>            Set Password_State to True
100116>>>        End_Object
100117>>>
100117>>>        Object oViewPassword_btn is a cButtonDPI
100119>>>            Set Size to 13 19
100120>>>            Set Location to 86 354
100121>>>            Set psToolTip to "Toggle password"
100122>>>            Set psImage to "PasswordViewBlack.ico"
100123>>>            Set piImageMarginLeft to 3
100124>>>
100124>>>            Procedure OnClick
100127>>>                Handle ho
100127>>>                Boolean bState
100127>>>
100127>>>                Move (oPassword_fm(Self)) to ho
100128>>>                Get Password_State of ho item 0 to bState
100129>>>                Send Deactivate of ho
100130>>>                Set Password_State of ho item 0 to (not(bState))
100131>>>                // Finally we need to re-add the object to the focus tree or it will be invisible.
100131>>>                Send Activate of ho (Parent(Self))
100132>>>            End_Procedure
100133>>>
100133>>>        End_Object
100134>>>
100134>>>        Object oLoginInfo_tb is a TextBox
100136>>>            Set Auto_Size_State to False
100137>>>            Set Size to 9 64
100138>>>            Set Location to 105 203
100139>>>            Set TextColor to clGreen
100140>>>            Set Justification_Mode to JMode_Right
100141>>>        End_Object
100142>>>
100142>>>        Object oCheckLogin_btn is a cButtonDPI
100144>>>            Set Size to 13 64
100145>>>            Set Location to 102 270
100146>>>            Set Label to "Check &Login"
100147>>>            Set psImage to "ActionLoginBlack.ico"
100148>>>            Set psToolTip to "You should always use this button when adding a new SQL Connection to ensure that the entered credentials are correct. (Ctrl+L)"
100149>>>            Set piImageMarginLeft to 3
100150>>>
100150>>>            Procedure OnClick
100153>>>                String sConnectionString sServer sDatabase sUserId sPassword sDriverID
100153>>>                Boolean bTrusted bLoginSuccessful bMertechDriver
100153>>>                Integer iDriverID
100153>>>                Handle hoErrorObj hoDriver
100153>>>
100153>>>                Send Cursor_Wait of Cursor_Control // Note: The Cursor_Wait changes the Err flag!
100154>>>                Move Error_Object_Id to hoErrorObj
100155>>>                Move Self to Error_Object_Id
100156>>>                Move False to Err
100157>>>
100157>>>                Set Value of oLoginInfo_tb to CS_LoginAttempt
100158>>>                Send PumpMsgQueue
100159>>>
100159>>>                Get Checked_State of oTrusted_cb to bTrusted
100160>>>                Get Value of oDriverID_cf to sDriverID
100161>>>                Get Value of oServer_fm   to sServer
100162>>>                Get Value of oDatabase_fm to sDatabase
100163>>>                Get Value of oUserID_fm   to sUserId
100164>>>                Get Value of oPassword_fm to sPassword
100165>>>
100165>>>                If (sServer = "") Begin
100167>>>                    Send Info_Box "Please enter a server first, then try again."
100168>>>                    Procedure_Return
100169>>>                End
100169>>>>
100169>>>
100169>>>                Get ConstructConnectionString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverID sServer sDatabase bTrusted sUserId sPassword to sConnectionString
100170>>>
100170>>>                Get DriverIndex of ghoSQLConnectionHandler sDriverID to iDriverID
100171>>>                If (iDriverID = 0) Begin
100173>>>                    Set TextColor of oLoginInfo_tb to clRed
100174>>>                    Set Value of oLoginInfo_tb to CS_LoginFailed
100175>>>                    Send Info_Box ("The driver" * sDriverID * "could not be loaded. Is the driver installed? And equally imporant; Is the corresponding database server or client software installed?")
100176>>>                    Procedure_Return
100177>>>                End
100177>>>>
100177>>>
100177>>>                Get IsMertechDriver of ghoSQLConnectionHandler sDriverID to bMertechDriver
100178>>>                If (bMertechDriver = False) Begin
100180>>>                    Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to True
100183>>>                End
100183>>>>
100183>>>
100183>>>                Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
100184>>>                Set psDriverID of hoDriver to sDriverID
100185>>>                Get DbLogin    of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
100186>>>                Send Destroy   of hoDriver
100187>>>
100187>>>                If bLoginSuccessful Begin
100189>>>                    Set TextColor of oLoginInfo_tb to clGreen
100190>>>                    Set Value of oLoginInfo_tb to CS_LoginSuccessful
100191>>>                End
100191>>>>
100191>>>                Else Begin
100192>>>                    Set TextColor of oLoginInfo_tb to clRed
100193>>>                    Set Value of oLoginInfo_tb to CS_LoginFailed
100194>>>                End
100194>>>>
100194>>>
100194>>>                Move hoErrorObj to Error_Object_Id
100195>>>                Send Cursor_Ready of Cursor_Control
100196>>>            End_Procedure
100197>>>
100197>>>            // This method is here simply to intercept any error that may occur while logging in
100197>>>            // it does not have to do anything with the error, but it suppresses the normal error display
100197>>>            Procedure Error_Report Integer iErrNum Integer iErrLine String sErrMsg
100200>>>            End_Procedure
100201>>>
100201>>>        End_Object
100202>>>
100202>>>        Object oTableSpaceInfo_tb is a TextBox
100204>>>            Set Auto_Size_State to False
100205>>>            Set Size to 9 118
100206>>>            Set Location to 112 75
100207>>>            Set TextColor to clGreen
100208>>>            Set Justification_Mode to JMode_Right
100209>>>            Set peAnchors to anNone
100210>>>        End_Object
100211>>>
100211>>>        Object oBaseTableSpace_fm is a cSQLForm
100213>>>            Set Size to 13 120
100214>>>            Set Location to 125 74
100215>>>            Set Label to "Table Space"
100216>>>            Set Label_Col_Offset to 2
100217>>>            Set Label_Justification_Mode to JMode_Right
100218>>>            Set piItem to 12
100219>>>            Set psToolTip to "Sets the name of the table space where the data will be stored. Applicable for IBM DB2, Oracle and PostgreSQL databases. Table spaces allow you to assign a physical location to logical objects (tables). They can be used to improve performance or to increase the page size, thus increasing the maximum size of a record that can be stored in the table space. You can specify what table space must be used to store table, index or long data. The index and long data table space will only be set when the table tables pace is also set."
100220>>>            Set Prompt_Button_Mode to PB_PromptOn
100221>>>            Set Prompt_Object to (oTableSpaceSelection_sl(Self))
100222>>>
100222>>>            Procedure Prompt
100225>>>                String[] sTheData
100226>>>                Handle ho
100226>>>                tSQLConnection SQLConnection
100226>>>                tSQLConnection SQLConnection
100226>>>
100226>>>                Set Label of oTableSpaceInfo_tb to CS_LoadingTableSpaces
100227>>>                Get ReadCurrentSQLSettings to SQLConnection
100228>>>                Get SqlUtilEnumerateTableSpaces of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
100229>>>
100229>>>                Get Prompt_Object to ho
100230>>>                Set psTheData  of ho to sTheData
100231>>>                Set Label of oTableSpaceInfo_tb to ""
100232>>>
100232>>>                Forward Send Prompt
100234>>>            End_Procedure
100235>>>
100235>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
100238>>>                Set Enabled_State to ((iDbType = EN_dbTypeDB2 or iDbType = EN_dbTypeOracle or iDbType = EN_dbTypePostgre) and sDriverID <> ODBC_DRV_ID)
100239>>>            End_Procedure
100240>>>
100240>>>        End_Object
100241>>>
100241>>>        Object oIndexTableSpace_fm is a cSQLForm
100243>>>            Set Size to 13 80
100244>>>            Set Location to 125 270
100245>>>            Set Label to "Index Table Space"
100246>>>            Set Label_Col_Offset to 2
100247>>>            Set Label_Justification_Mode to JMode_Right
100248>>>            Set piItem to 14
100249>>>            Set psToolTip to "To set the name of the table space where indexes will be stored. Only applicable for IBM DB2, Oracle and PostgreSQL databases."
100250>>>            Set Prompt_Button_Mode to PB_PromptOn
100251>>>            Set Prompt_Object to (oTableSpaceSelection_sl(Self))
100252>>>
100252>>>            Procedure Prompt
100255>>>                String[] sTheData
100256>>>                Handle ho
100256>>>                Integer iDbType
100256>>>                tSQLConnection SQLConnection
100256>>>                tSQLConnection SQLConnection
100256>>>
100256>>>                Set Label of oTableSpaceInfo_tb to CS_LoadingTableSpaces
100257>>>                Get ReadCurrentSQLSettings to SQLConnection
100258>>>
100258>>>                Get SqlUtilEnumerateTableSpaces of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
100259>>>
100259>>>                Get Prompt_Object to ho
100260>>>                Set psTheData     of ho to sTheData
100261>>>                Set Label of oTableSpaceInfo_tb to ""
100262>>>
100262>>>                Forward Send Prompt
100264>>>            End_Procedure
100265>>>
100265>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
100268>>>                Set Enabled_State to ((iDbType = EN_dbTypeDB2 or iDbType = EN_dbTypeOracle or iDbType = EN_dbTypePostgre) and sDriverID <> ODBC_DRV_ID)
100269>>>            End_Procedure
100270>>>
100270>>>        End_Object
100271>>>
100271>>>        Object oLongTableSpace_fm is a cSQLForm
100273>>>            Set Size to 13 120
100274>>>            Set Location to 140 74
100275>>>            Set Label to "Long Table Space"
100276>>>            Set Label_Col_Offset to 2
100277>>>            Set Label_Justification_Mode to JMode_Right
100278>>>            Set piItem to 13
100279>>>            Set psToolTip to "Only applicable for IBM DB2 databases. If you are unsure on what to enter your best bet is to use the same value as for the 'Table Space' above."
100280>>>            Set Prompt_Button_Mode to PB_PromptOn
100281>>>            Set Prompt_Object to (oTableSpaceSelection_sl(Self))
100282>>>
100282>>>            Procedure Prompt
100285>>>                String[] sTheData
100286>>>                Handle ho
100286>>>                Integer iDbType
100286>>>                tSQLConnection SQLConnection
100286>>>                tSQLConnection SQLConnection
100286>>>
100286>>>                Set Label of oTableSpaceInfo_tb to CS_LoadingTableSpaces
100287>>>                Get ReadCurrentSQLSettings to SQLConnection
100288>>>
100288>>>                Get SqlUtilEnumerateTableSpaces of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
100289>>>
100289>>>                Get Prompt_Object to ho
100290>>>                Set psTheData     of ho to sTheData
100291>>>                Set Label of oTableSpaceInfo_tb to ""
100292>>>
100292>>>                Forward Send Prompt
100294>>>            End_Procedure
100295>>>
100295>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
100298>>>                Set Enabled_State to (iDbType = EN_dbTypeDB2)
100299>>>            End_Procedure
100300>>>
100300>>>        End_Object
100301>>>
100301>>>        Object oSchema_fm is a cSQLForm
100303>>>            Set Size to 13 80
100304>>>            Set Location to 140 270
100305>>>            Set Label to "Schema"
100306>>>            Set psToolTip to "The name of the schema the table belongs to. A schema is a collection of names or objects. A schema can contain tables, views, and triggers. Schemas provide a logical classification of objects in the database. It can have a slightly different meaning depending on the selected database type. Please consult your database manager to ensure the correct value is selected. Applicable for IBM DB2, Oracle and PostgreSQL databases. For IBM DB2 not specifying a schema will result in the user name being used. Microsoft SQL Server has a completely different approach to security and privileges and uses owners instead."
100307>>>            Set Label_Col_Offset to 2
100308>>>            Set Label_Justification_Mode to JMode_Right
100309>>>            Set piItem to 11
100310>>>            Set Enabled_State to False
100311>>>
100311>>>            Property String psSchemaToolTip "The name of the schema the table belongs to. A schema is a collection of names or objects. A schema can contain tables, views, and triggers. Schemas provide a logical classification of objects in the database. It can have a slightly different meaning depending on the selected database type. Please consult a database manager to ensure the correct value is selected. Applicable for IBM DB2, Oracle and PostgreSQL databases. For IBM DB2 not specifying a schema will result in the user name being used. Microsoft SQL Server has a completely different approach to security and privileges and uses owners instead."
100313>>>            Property String psOwnerTooltip  "The owner name to use within the database where the tables must be placed. If you want to specify an owner of the table that will be converted you can do so, not specifying an owner will result in the default owner being used. The suggested owner name to use is 'dbo'"
100315>>>
100315>>>            Procedure Prompt
100318>>>                String[] sTheData
100319>>>                Handle ho
100319>>>                Integer iDbType
100319>>>                tSQLConnection SQLConnection
100319>>>                tSQLConnection SQLConnection
100319>>>
100319>>>                Set Label of oTableSpaceInfo_tb to CS_LoadingSchemas
100320>>>                Get ReadCurrentSQLSettings to SQLConnection
100321>>>
100321>>>                Get SqlUtilEnumerateSchemas of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
100322>>>
100322>>>                Get Prompt_Object to ho
100323>>>                Set psTheData     of ho to sTheData
100324>>>                Set Label of oTableSpaceInfo_tb to ""
100325>>>
100325>>>                Forward Send Prompt
100327>>>            End_Procedure
100328>>>
100328>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
100331>>>                String sValue
100331>>>
100331>>>                Set Enabled_State to ((iDbType = EN_dbTypeMSSQL or iDbType = EN_dbTypeDB2 or iDbType = EN_dbTypeOracle or iDbType = EN_dbTypePostgre) and sDriverID <> ODBC_DRV_ID)
100332>>>                If (iDbType = EN_dbTypeMSSQL) Begin
100334>>>                    Set Label to CS_DF_File_Owner
100335>>>                    Set Prompt_Button_Mode to PB_PromptOff
100336>>>                    Set Prompt_Object to 0
100337>>>                    Set psToolTip to (psOwnerTooltip(Self))
100338>>>                    Get Value to sValue
100339>>>                    If (Trim(sValue) = "") Begin
100341>>>                        Set Value to "dbo"
100342>>>                    End
100342>>>>
100342>>>                End
100342>>>>
100342>>>                Else Begin
100343>>>                    Set Label to CS_DF_File_Schema
100344>>>                    Set Prompt_Button_Mode to PB_PromptOn
100345>>>                    Set Prompt_Object to (oSchemasSelection_sl(Self))
100346>>>                    Set psToolTip to (psSchemaToolTip(Self))
100347>>>                    If (Trim(sValue) = "dbo") Begin
100349>>>                        Set Value to ""
100350>>>                    End
100350>>>>
100350>>>                End
100350>>>>
100350>>>                If (Enabled_State(Self) = False) Begin
100352>>>                    Set Value to ""
100353>>>                End
100353>>>>
100353>>>            End_Procedure
100354>>>
100354>>>        End_Object
100355>>>
100355>>>        Object oDatabase_fm is a cSQLForm
100357>>>            Set Size to 13 120
100358>>>            Set Location to 156 74
100359>>>            Set Label to "Database"
100360>>>            Set Label_Col_Offset to 2
100361>>>            Set Label_Justification_Mode to JMode_Right
100362>>>            Set peAnchors to anTopLeftRight
100363>>>            Set psToolTip to "Name of the SQL database. Note: If you are setting up your first connection for a workspace and your SQL database doesn't exist yet, leave the default 'Master' as it is always available. The 'SqlDatabaseCreate' function will take care of the rest when creating your new SQL database."
100364>>>            Set piItem to 6
100365>>>
100365>>>            Procedure Prompt
100368>>>                String[] sTheData
100369>>>                Handle ho
100369>>>                tSQLConnection SQLConnection
100369>>>                tSQLConnection SQLConnection
100369>>>
100369>>>                Set Label of oTableSpaceInfo_tb to CS_LoadingDatabases
100370>>>                Get ReadCurrentSQLSettings to SQLConnection
100371>>>
100371>>>                Get SqlUtilEnumerateDatabases of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID to sTheData
100372>>>
100372>>>                Get Prompt_Object to ho
100373>>>                Set psTheData     of ho to sTheData
100374>>>                Set Label of oTableSpaceInfo_tb to ""
100375>>>
100375>>>                Forward Send Prompt
100377>>>            End_Procedure
100378>>>
100378>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
100381>>>                Boolean bAdd
100381>>>                String sValue
100381>>>
100381>>>                If (sDriverID <> "") Begin
100383>>>                    Set Enabled_State to (sDriverID = MSSQLDRV_ID or sDriverID = SQLFLEX or sDriverID = MDSMySQL or sDriverID = MDSPgSQL or sDriverID = ORAFLEX)
100384>>>                    If (Enabled_State(Self) = True) Begin
100386>>>                        Move (piCurrentRow(Self) = -1) to bAdd
100387>>>                        Get Value to sValue
100388>>>                        If (bAdd = True and sValue = "" and iDbType = EN_dbTypeMSSQL) Begin
100390>>>                            Set Value to "master"
100391>>>                        End
100391>>>>
100391>>>                        Else Begin
100392>>>                            Set Prompt_Button_Mode to PB_PromptOn
100393>>>                            Set Prompt_Object to (oDatabaseSelection_sl(Self))
100394>>>                            If (Value(Self) = "master") Begin
100396>>>                                Set Value to ""
100397>>>                            End
100397>>>>
100397>>>                        End
100397>>>>
100397>>>                    End
100397>>>>
100397>>>                    If (Enabled_State(Self) = False) Begin
100399>>>                        Set Value to ""
100400>>>                    End
100400>>>>
100400>>>                End
100400>>>>
100400>>>            End_Procedure
100401>>>
100401>>>        End_Object
100402>>>
100402>>>        Function ReadCurrentSQLSettings Returns tSQLConnection
100405>>>            tSQLConnection SQLConnection
100405>>>            tSQLConnection SQLConnection
100405>>>
100405>>>            Get Value of oDriverID_cf to SQLConnection.sDriverID
100406>>>            Get SelectedDbType of oDbType_cf to SQLConnection.iDbType
100407>>>
100407>>>            Get Checked_State of oTrusted_cb to SQLConnection.bTrusted
100408>>>            Get Value of oDriverID_cf        to SQLConnection.sDriverID
100409>>>            Get Value of oServer_fm          to SQLConnection.sServer
100410>>>            Get Value of oUserID_fm          to SQLConnection.sUserID
100411>>>            Get Value of oPassword_fm        to SQLConnection.sPassword
100412>>>            Get ConstructConnectionString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) ;                SQLConnection.sDriverID SQLConnection.sServer "" SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
100413>>>            Set pSQLConnection of ghoSQLConnectionHandler to SQLConnection
100414>>>
100414>>>            Function_Return SQLConnection
100415>>>        End_Function
100416>>>
100416>>>        Procedure DbTypeUpdate Integer iDbType String sDriverID
100419>>>            String sDbType
100419>>>            Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary iDbType to sDbType
100420>>>            Set Label to (sDbType * "Connection Details")
100421>>>        End_Procedure
100422>>>
100422>>>    End_Object
100423>>>
100423>>>    Object oOK_Btn is a cButtonDPI
100425>>>        Set Label    to "OK"
100426>>>        Set Location to 264 296
100427>>>        Set peAnchors to anBottomRight
100428>>>
100428>>>        Procedure OnClick
100431>>>            String sConnectionID sLoginText
100431>>>            String[] sConnectionData
100432>>>            tSQLConnection SQLIniFileConnection
100432>>>            tSQLConnection SQLIniFileConnection
100432>>>            Boolean bTrusted bNew bOK bShouldSave
100432>>>            Handle ho
100432>>>            Integer iRetval
100432>>>
100432>>>            Delegate Get Should_Save to bShouldSave
100434>>>            If (bShouldSave = False) Begin
100436>>>                Set pbChanged to False
100437>>>                Send Close_Panel
100438>>>                Procedure_Return
100439>>>            End
100439>>>>
100439>>>
100439>>>            Broadcast Recursive Send WriteConnectionData of (Parent(Self)) (&sConnectionData)
100441>>>
100441>>>            Get pbNew to bNew
100442>>>            Get MoveStringArrayToSQLConnection sConnectionData to SQLIniFileConnection
100443>>>            Case Begin
100443>>>                Case (SQLIniFileConnection.sDriverID = DB2_DRV_ID or SQLIniFileConnection.sDriverID = ODBC_DRV_ID)
100445>>>                    If (SQLIniFileConnection.sDriverID = DB2_DRV_ID) Begin
100447>>>                        Move "" to SQLIniFileConnection.sDatabase
100448>>>                    End
100448>>>>
100448>>>                    If (SQLIniFileConnection.bTrusted = True) Begin
100450>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "") to bOK
100451>>>                    End
100451>>>>
100451>>>                    Else Begin
100452>>>                        // It should probably be allowed to use an UID but no password...
100452>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
100453>>>                    End
100453>>>>
100453>>>                    Case Break
100454>>>                Case (SQLIniFileConnection.sDriverID = MSSQLDRV_ID or SQLIniFileConnection.sDriverID = SQLFLEX)
100457>>>                    If (SQLIniFileConnection.bTrusted = True) Begin
100459>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sDatabase <> "") to bOK
100460>>>                    End
100460>>>>
100460>>>                    Else Begin
100461>>>                        // It should probably be allowed to use an UID but no password...
100461>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sDatabase <> "" and SQLIniFileConnection.sUserID <> "") to bOK
100462>>>                    End
100462>>>>
100462>>>                    Case Break
100463>>>                Case (SQLIniFileConnection.sDriverID = ORAFLEX or SQLIniFileConnection.sDriverID = MDSPgSQL)
100466>>>                    // It should probably be allowed to use an UID but no password...
100466>>>                    Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
100467>>>                    Case Break
100468>>>                Case (SQLIniFileConnection.sDriverID = MDSPgSQL)
100471>>>                    // It should probably be allowed to use an UID but no password...
100471>>>                    Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
100472>>>                    Case Break
100473>>>                Case (SQLIniFileConnection.sDriverID = MDSMySQL)
100476>>>                    // It should probably be allowed to use an UID but no password...
100476>>>                    Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
100477>>>                    Case Break
100478>>>            Case End
100478>>>
100478>>>            If (bOK = False) Begin
100480>>>                Send Info_Box "Please fill in all connection data."
100481>>>                Procedure_Return
100482>>>            End
100482>>>>
100482>>>
100482>>>            // Oct 28 2017 NGS. Don't think this restriction is needed!
100482>>>            // As long as only one connection can be active, we should be fine.
100482>>>            // Check that the connection ID is unique:
100482>>>//            Get IsConnectionIDDuplicate SQLIniFileConnection to bOK
100482>>>//            If (bOK = True) Begin
100482>>>//                Get Message_Box (CS_DUF_DuplicateConnectionIDPre * "'" + SQLIniFileConnection.sConnectionID + "'." * CS_DUF_DuplicateConnectionIDPost) ""  MB_OK MB_ICONEXCLAMATION to bOK
100482>>>//                Procedure_Return
100482>>>//            End
100482>>>
100482>>>            Move MBR_Yes to iRetval
100483>>>            Get Label of oLoginInfo_tb to sLoginText
100484>>>            If (sLoginText = CS_LoginFailed) Begin
100486>>>                Get YesNo_Box "The login failed. Are you sure you want to use these connection settings?" to iRetval
100487>>>            End
100487>>>>
100487>>>            Else If (sLoginText = "") Begin
100490>>>                Get YesNo_Box "The login has not been tested. Are you sure you want to use these connection settings?" to iRetval
100491>>>            End
100491>>>>
100491>>>            If (iRetval <> MBR_Yes) Begin
100493>>>                Procedure_Return
100494>>>            End
100494>>>>
100494>>>
100494>>>            Set pSQLConnectionData to SQLIniFileConnection
100495>>>            Set pbChanged to True
100496>>>            Send Close_Panel
100497>>>        End_Procedure
100498>>>
100498>>>    End_Object
100499>>>
100499>>>    Object oCancel_Btn is a cButtonDPI
100501>>>        Set Label    to "Cancel"
100502>>>        Set Location to 264 350
100503>>>        Set peAnchors to anBottomRight
100504>>>
100504>>>        Procedure OnClick
100507>>>            Set pbChanged to False
100508>>>            Send Close_Panel
100509>>>        End_Procedure
100510>>>
100510>>>    End_Object
100511>>>
100511>>>    Object oHelp_Btn is a cButtonDPI
100513>>>        Set Label to "Help"
100514>>>        Set Location to 264 11
100515>>>        Set peAnchors to anBottomLeft
100516>>>        Set psImage to "ActionHelp.ico"
100517>>>
100517>>>        Procedure OnClick
100520>>>            Send DoDisplayKeyword of ghoHtmlHelp "SQLConnections Tool"
100521>>>        End_Procedure
100522>>>    End_Object
100523>>>
100523>>>    // Returns True if anything has changed.
100523>>>    Function Should_Save Returns Boolean
100526>>>        String[] sConnectionData sConnectionData2
100528>>>        tSQLConnection SQLConnectionData
100528>>>        tSQLConnection SQLConnectionData
100528>>>        Boolean bState
100528>>>
100528>>>        Broadcast Recursive Send WriteConnectionData (&sConnectionData)
100530>>>        Get pSQLConnectionData to SQLConnectionData
100531>>>        Get MoveSQLConnectionToStringArray SQLConnectionData to sConnectionData2
100532>>>        // We don't have a form here for the sConnectionString, so we "blank it out"
100532>>>        // to be able to compare properly.
100532>>>        Move "" to sConnectionData2[7]
100533>>>
100533>>>        Move (IsSameArray(sConnectionData, sConnectionData2)) to bState
100534>>>        Function_Return (bState = False)
100535>>>    End_Function
100536>>>
100536>>>    Function IsConnectionIDDuplicate tSQLConnection SQLConnection Returns Boolean
100539>>>        Integer iCount iSize iItems iCurrentRow
100539>>>        String sValue sConnectionID
100539>>>        Boolean bExists
100539>>>        tDataSourceRow[] TheData
100539>>>        tDataSourceRow[] TheData
100540>>>        tDataSourceRow TheRow
100540>>>        tDataSourceRow TheRow
100540>>>
100540>>>        Move 0 to iItems
100541>>>        Get piCurrentRow to iCurrentRow
100542>>>        Move SQLConnection.sConnectionID to sConnectionID
100543>>>        Get MoveSQLConnectionToGridRow SQLConnection to TheRow
100544>>>        Get pTheData to TheData
100545>>>        Move (SizeOfArray(TheData)) to iSize
100546>>>        If (iCurrentRow <> -1) Begin
100548>>>            // This is the sConnectionID:
100548>>>            Move TheRow.sValue[2] to TheData[iCurrentRow].sValue[2]
100549>>>        End
100549>>>>
100549>>>        Else Begin
100550>>>            Move TheRow to TheData[iSize]
100551>>>        End
100551>>>>
100551>>>        Move (SizeOfArray(TheData)) to iSize
100552>>>        Decrement iSize
100553>>>        For iCount from 0 to iSize
100559>>>>
100559>>>            Move TheData[iCount].sValue[2] to sValue
100560>>>            Move (sValue = sConnectionID) to bExists
100561>>>            If (bExists) Begin
100563>>>                Increment iItems
100564>>>            End
100564>>>>
100564>>>        Loop
100565>>>>
100565>>>
100565>>>        Function_Return (iItems > 1)
100566>>>    End_Function
100567>>>
100567>>>    // Transfers data between a tSQLConnection struct and a grid data row.
100567>>>    Function MoveSQLConnectionToGridRow tSQLConnection SQLConnection Returns tDataSourceRow
100570>>>        tDataSourceRow TheRow
100570>>>        tDataSourceRow TheRow
100570>>>        Integer iDbType
100570>>>        String sValue
100570>>>
100570>>>        Move 0                                  to TheRow.sValue[0]
100571>>>        Move SQLConnection.bEnabled             to TheRow.sValue[1]
100572>>>        Move SQLConnection.sConnectionID        to TheRow.sValue[2]
100573>>>        Move SQLConnection.sDriverID            to TheRow.sValue[3]
100574>>>
100574>>>        // We only show three asterisks ("***") instead of the password in the grid.
100574>>>        Move (Replace(SQLConnection.sPassword, SQLConnection.sConnectionString, "***")) to sValue
100575>>>        Move sValue                             to TheRow.sValue[4]
100576>>>
100576>>>        Move SQLConnection.iDbType to iDbType
100577>>>        Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary iDbType to sValue
100578>>>        Move sValue                             to TheRow.sValue[5]
100579>>>        Move SQLConnection.sServer              to TheRow.sValue[6]
100580>>>        Move SQLConnection.sDatabase            to TheRow.sValue[7]
100581>>>
100581>>>        // Hidden columns (to make Should_Save function work)
100581>>>        Move SQLConnection.sConnectionString    to TheRow.sValue[8] // "Untouched" connection string.
100582>>>        Move SQLConnection.bTrusted             to TheRow.sValue[9]
100583>>>        Move SQLConnection.sUserID              to TheRow.sValue[10]
100584>>>        Move SQLConnection.sPassword            to TheRow.sValue[11]
100585>>>        Move SQLConnection.sSchema              to TheRow.sValue[12]
100586>>>        Move SQLConnection.sBaseTableSpace      to TheRow.sValue[13]
100587>>>        Move SQLConnection.sLongTableSpace      to TheRow.sValue[14]
100588>>>        Move SQLConnection.sIndexTableSpace     to TheRow.sValue[15]
100589>>>        Move SQLConnection.bSilentLogin         to TheRow.sValue[16]
100590>>>//        Move SQLConnection.bDisabled            to TheRow.sValue[17]
100590>>>//        Move SQLConnection.iDriverIndex         to TheRow.sValue[18]
100590>>>
100590>>>        Function_Return TheRow
100591>>>    End_Function
100592>>>
100592>>>    Function MoveSQLConnectionToStringArray tSQLConnection SQLConnection Returns String[]
100595>>>        String[] sConnectionData
100596>>>        Integer iRetval
100596>>>
100596>>>        Move SQLConnection.bEnabled          to sConnectionData[1]
100597>>>        Move SQLConnection.sConnectionID     to sConnectionData[2]
100598>>>        Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary SQLConnection.iDbType to sConnectionData[3]
100599>>>        Move SQLConnection.sDriverID         to sConnectionData[4]
100600>>>        Move SQLConnection.sServer           to sConnectionData[5]
100601>>>        Move SQLConnection.sDatabase         to sConnectionData[6]
100602>>>        Move SQLConnection.sConnectionString to sConnectionData[7]
100603>>>        Move SQLConnection.bTrusted          to sConnectionData[8]
100604>>>        Move SQLConnection.sUserID           to sConnectionData[9]
100605>>>
100605>>>        If (SQLConnection.sPassword <> "") Begin
100607>>>            Move MBR_Yes to iRetval
100608>>>            If (pbDFConnId(Self) = True) Begin
100610>>>                Get YesNo_Box "You are working with a DAW 'DFConnId.ini' file. Although this program can both read/write to such a file, the password encryption/decryption algorithms are (obviously) different. This password will not be touched. Continue?" to iRetval
100611>>>                If (iRetval = MBR_Yes) Begin
100613>>>                    Set psUncryptedPw to SQLConnection.sPassword
100614>>>                    Move "" to SQLConnection.sPassword
100615>>>                End
100615>>>>
100615>>>                Else Begin
100616>>>                    Send Stop_UI
100617>>>                End
100617>>>>
100617>>>            End
100617>>>>
100617>>>            Else Begin
100618>>>                Move SQLConnection.sPassword to sConnectionData[10]
100619>>>            End
100619>>>>
100619>>>        End
100619>>>>
100619>>>
100619>>>        Move SQLConnection.sSchema           to sConnectionData[11]
100620>>>        Move SQLConnection.sBaseTableSpace   to sConnectionData[12]
100621>>>        Move SQLConnection.sLongTableSpace   to sConnectionData[13]
100622>>>        Move SQLConnection.sIndexTableSpace  to sConnectionData[14]
100623>>>        Move SQLConnection.bSilentLogin      to sConnectionData[15]
100624>>>
100624>>>        Function_Return sConnectionData
100625>>>    End_Function
100626>>>
100626>>>    Function MoveStringArrayToSQLConnection String[] sConnectionData Returns tSQLConnection
100629>>>        tSQLConnection SQLConnection
100629>>>        tSQLConnection SQLConnection
100629>>>
100629>>>        Move sConnectionData[1]  to SQLConnection.bEnabled
100630>>>        Move sConnectionData[2]  to SQLConnection.sConnectionID
100631>>>        Get SqlUtilDbTypeToInteger of ghoDbUpdateFunctionLibrary sConnectionData[3] to SQLConnection.iDbType
100632>>>        Move sConnectionData[4]  to SQLConnection.sDriverID
100633>>>        Move sConnectionData[5]  to SQLConnection.sServer
100634>>>        Move sConnectionData[6]  to SQLConnection.sDatabase
100635>>>
100635>>>        Move sConnectionData[8]  to SQLConnection.bTrusted
100636>>>        Move sConnectionData[9]  to SQLConnection.sUserID
100637>>>
100637>>>        If (sConnectionData[10] <> "" and pbDFConnId(Self) = False) Begin
100639>>>            Move sConnectionData[10] to SQLConnection.sPassword
100640>>>        End
100640>>>>
100640>>>        // In case of we're dealing with a DfConnID.ini file (DF 19+) we don't want to change the password
100640>>>        // as DAW's 'Managed Connections' program has a different password encryption/decryption algorithm.
100640>>>        If (pbDFConnId(Self) = True) Begin
100642>>>            Get psUncryptedPw to SQLConnection.sPassword
100643>>>        End
100643>>>>
100643>>>
100643>>>        Move sConnectionData[11] to SQLConnection.sSchema
100644>>>        Move sConnectionData[12] to SQLConnection.sBaseTableSpace
100645>>>        Move sConnectionData[13] to SQLConnection.sLongTableSpace
100646>>>        Move sConnectionData[14] to SQLConnection.sIndexTableSpace
100647>>>        Move sConnectionData[15] to SQLConnection.bSilentLogin
100648>>>
100648>>>        // Connection string:
100648>>>        Get ConstructConnectionString of ghoSQLConnectionHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase ;                                                                 SQLConnection.bTrusted  SQLConnection.sUserID SQLConnection.sPassword ;                                      to SQLConnection.sConnectionString
100649>>>
100649>>>        Function_Return SQLConnection
100650>>>    End_Function
100651>>>
100651>>>    Procedure Popup
100654>>>        tSQLConnection SQLIniFileConnection
100654>>>        tSQLConnection SQLIniFileConnection
100654>>>        String[] sConnectionData
100655>>>        String sDriverID
100655>>>        Integer iDbType
100655>>>        Boolean bAdd
100655>>>
100655>>>        Move (piCurrentRow(Self) = -1) to bAdd
100656>>>        Get pSQLConnectionData to SQLIniFileConnection
100657>>>        If (SQLIniFileConnection.bEnabled = False and bAdd = True) Begin
100659>>>            Move True to SQLIniFileConnection.bEnabled
100660>>>        End
100660>>>>
100660>>>        Get MoveSQLConnectionToStringArray SQLIniFileConnection to sConnectionData
100661>>>
100661>>>        Broadcast Recursive Send ReadConnectionData sConnectionData
100663>>>
100663>>>        // We need this message to "auto-default" certain fields.
100663>>>        If (bAdd = True) Begin
100665>>>            Get SelectedDbType of oDbType_cf to iDbType
100666>>>            Get Value of oDriverID_cf to sDriverID
100667>>>            If (sDriverID = "") Begin
100669>>>                Move MSSQLDRV_ID to sDriverID
100670>>>            End
100670>>>>
100670>>>            Broadcast Recursive Send DbTypeUpdate of oSettings_grp iDbType sDriverID
100672>>>        End
100672>>>>
100672>>>
100672>>>        Set Password_State of oPassword_fm to True
100673>>>        Set Value of oLoginInfo_tb to ""
100674>>>        Set Statusbar_Id to (phoDialogCommandbar(Self))
100675>>>
100675>>>        Forward Send Popup
100677>>>    End_Procedure
100678>>>
100678>>>    Procedure Page Integer iPageObject
100681>>>        Boolean bNew bReadOnly
100681>>>        String sText
100681>>>        Handle hWnd
100681>>>
100681>>>        Send Cursor_Ready of Cursor_Control
100682>>>        Forward Send Page iPageObject
100684>>>
100684>>>        Set Icon to "SQLConnections.ico"
100685>>>        Get pbNew to bNew
100686>>>        If (bNew = True) Begin
100688>>>            Move ("The" * CS_SQLIniFileName * "file doesn't exist yet for this workspace and needs to be created. Here's what you need to do:\n\n") to sText
100689>>>            Move (sText * "1. Enter a Connection ID (the same that is being used by your workspace .int files) and other data that is used to login to the database.\n") to sText
100690>>>            Move (sText * "2. Press the 'Test Login' button to ensure entered details are correct.\n") to sText
100691>>>            Move (sText * "3. Press the 'OK' button and then save your changes.\n") to sText
100692>>>            Send Info_Box sText
100693>>>        End
100693>>>>
100693>>>
100693>>>        If (ghoSkinFramework <> 0 and hWnd <> 0) Begin
100695>>>            Send ComRemoveWindow to ghoSkinFramework hWnd
100696>>>            Send ComApplyWindow  to ghoSkinFramework hWnd
100697>>>        End
100697>>>>
100697>>>
100697>>>        Get pbReadOnly to bReadOnly
100698>>>        If (bReadOnly = True) Begin
100700>>>            Broadcast Recursive Set Enabled_State    to (not(bReadOnly))
100702>>>            Set Enabled_State of oSettings_grp       to True
100703>>>            Set Enabled_State of oPassword_fm        to True
100704>>>            Set Enabled_State of oViewPassword_btn   to True
100705>>>            Set Enabled_State of oCheckLogin_btn     to True
100706>>>            Set Enabled_State of oCancel_Btn         to True
100707>>>            Send Activate of oCancel_Btn
100708>>>        End
100708>>>>
100708>>>    End_Procedure
100709>>>
100709>>>    Function IniFileName Returns String
100712>>>        String sRetval
100712>>>        Function_Return sRetval
100713>>>    End_Function
100714>>>
100714>>>    // Put a status bar at the bottom of the panel, which makes
100714>>>    // status_help work and puts a gripper in the lower right corner.
100714>>>    Procedure End_Construct_Object
100717>>>        Integer iStyle iSize iOffset
100717>>>
100717>>>        Forward Send End_Construct_Object
100719>>>
100719>>>        Get Border_Style to iStyle
100720>>>        Move 8 to iOffset
100721>>>        If (iStyle = Border_Thick) Begin
100723>>>            Object oDialogCommandbar is a cCJCommandBarSystem
100725>>>                Object oStatusBar is a cCJStatusBar
100727>>>                    Set phoDialogCommandbar to Self
100728>>>                    Object oStatusIdle is a cCJStatusBarPane
100730>>>                        Set piId to sbpIDIdlePane
100731>>>                        Set pbStyleStretch to True
100732>>>                    End_Object
100733>>>                End_Object
100734>>>            End_Object
100735>>>
100735>>>            Get Size to iSize
100736>>>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
100737>>>        End
100737>>>>
100737>>>    End_Procedure
100738>>>
100738>>>    Procedure ShowProgramHelp
100741>>>        Send DoDisplayKeyword of ghoHtmlHelp "SQLConnections Tool"
100742>>>    End_Procedure
100743>>>
100743>>>    On_Key Key_F1         Send ShowProgramHelp
100744>>>    On_Key Key_Ctrl+Key_L Send KeyAction of oCheckLogin_btn
100745>>>    On_Key kCancel        Send KeyAction of oCancel_Btn
100746>>>End_Object
100747>>>
100747>>>// General purpose edit-mode message                                                                                                                        // If ini-file= "DFConnId.ini" (DAW file)
100747>>>Procedure Activate_SQLMaintainConnections_dg Boolean bNew Integer iCurrentRow tSQLConnection ByRef SQLConnectionData Boolean ByRef bChanged Boolean bDFConnId tDataSourceRow[] TheData
100750>>>    Handle ho
100750>>>    String sPath sSQLConnectionsFileName
100750>>>
100750>>>    Send Cursor_Wait of Cursor_Control
100751>>>    Move (oSQLMaintainConnections_dg(Self)) to ho
100752>>>    Set pbReadOnly              of ho to False
100753>>>    Set pbNew                   of ho to bNew
100754>>>    Set piCurrentRow            of ho to iCurrentRow
100755>>>    Set pbDFConnId              of ho to bDFConnId
100756>>>    Set pSQLConnectionData      of ho to SQLConnectionData
100757>>>    If (SQLConnectionData.sConnectionString <> "") Begin
100759>>>        Get psIniFilePath of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sPath
100760>>>        Get psIniFileName of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sSQLConnectionsFileName
100761>>>    End
100761>>>>
100761>>>    Set Label  of ho to ("Connection Properties" * "[" + String(sPath) + String(sSQLConnectionsFileName) + "]")
100762>>>    Set pTheData                of ho to TheData
100763>>>
100763>>>    Send Popup                  of ho
100764>>>
100764>>>    Get pSQLConnectionData      of ho to SQLConnectionData
100765>>>    Get pbChanged               of ho to bChanged
100766>>>End_Procedure
100767>>>
100767>>>// Read-only access message
100767>>>Procedure Activate_ReadOnlySQLMaintainConnections_dg tSQLConnection SQLConnectionData
100770>>>    Handle ho
100770>>>    String sPath sSQLConnectionsFileName
100770>>>
100770>>>    Send Cursor_Wait of Cursor_Control
100771>>>    Move (oSQLMaintainConnections_dg(Self)) to ho
100772>>>    Set pbReadOnly              of ho to True
100773>>>    Set pSQLConnectionData      of ho to SQLConnectionData
100774>>>    If (SQLConnectionData.sConnectionString <> "") Begin
100776>>>        Get psIniFilePath of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sPath
100777>>>        Get psIniFileName of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sSQLConnectionsFileName
100778>>>    End
100778>>>>
100778>>>    Set Label  of ho to ("Connection Properties (Read-Only)" * "[" + String(sPath) + String(sSQLConnectionsFileName) + "]")
100779>>>
100779>>>    Send Popup of ho
100780>>>End_Procedure
100781>>>
100781>        Use AddToStudio.dg
Including file: AddToStudio.dg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\AddToStudio.dg)
100781>>>Use Windows.pkg
100781>>>Use Dfspnfrm.pkg
100781>>>Use cRegistry.pkg
100781>>>Use vWin32fh.pkg
100781>>>
100781>>>Enum_List
100781>>>    Define cx_RegKeyAlreadyExist
100781>>>    Define cx_RegKeyCreated
100781>>>    Define cx_RegkeyFailed
100781>>>    Define cx_RegKeyVDFKeyDoesNotExist
100781>>>    Define CX_InstalledOkVdfUnder16
100781>>>End_Enum_List
100781>>>
100781>>>// Note: The "Visual" part will automatically be removed if
100781>>>// the current DataFlex version is above 17.
100781>>>Define CS_StudioPath        for "Software\Data Access Worldwide\Visual DataFlex Tools\"
100781>>>Define CS_StudioTools       for "\Studio\Tools"
100781>>>Define CS_RegApplication    for "<application>"
100781>>>Define CS_RegWorkspace      for "<workspace>"
100781>>>Define CS_CommandLine       for "CommandLine"
100781>>>Define CS_Name              for "Name"
100781>>>Define CS_Separator         for "Separator"
100781>>>Define CS_Command           for "Command"
100781>>>
100781>>>
100781>>>Object oAddToStudio_dg is a ModalPanel
100783>>>    Set Size to 81 330
100784>>>    Set Label to "Add Program To DataFlex Studio's Tools Menu"
100785>>>    Set piMinSize to 79 211
100786>>>    Set Location to 5 4
100787>>>    Set Locate_Mode to Center_On_Parent
100788>>>
100788>>>    Property String psTag CS_RegApplication
100790>>>
100790>>>    Object oStudioIntegration_grp is a Group
100792>>>        Set Size to 45 299
100793>>>        Set Location to 8 15
100794>>>        Set Label to "DataFlex Studio Integration"
100795>>>
100795>>>        Object oStudioMajorVersion_sf is a SpinForm
100797>>>            Set Size to 12 27
100798>>>            Set Location to 18 168
100799>>>            Set Maximum_Position to 30
100800>>>            Set Minimum_Position to 14
100801>>>            Set Label_Col_Offset to 2
100802>>>            Set Label_Justification_Mode to JMode_Right
100803>>>            Set Label to "Add to Studio's Tools Menu:     Major Version"
100804>>>            Set Status_Help to "DataFlex main version - e.g. '18'"
100805>>>            Set Value to FMAC_VERSION
100806>>>            Set peAnchors to anNone
100807>>>        End_Object
100808>>>
100808>>>        Object oStudioMinorVersion_sf is a SpinForm
100810>>>            Set Size to 12 27
100811>>>            Set Location to 18 254
100812>>>            Set Label_Col_Offset to 2
100813>>>            Set Label to "Minor Version"
100814>>>            Set Status_Help to "DataFlex minor version - e.g. '0'"
100815>>>            Set Maximum_Position to 9
100816>>>            Set Minimum_Position to 0
100817>>>            Set Value to FMAC_REVISION
100818>>>            Set Label_Justification_Mode to JMode_Right
100819>>>            Set peAnchors to anNone
100820>>>        End_Object
100821>>>
100821>>>    End_Object
100822>>>
100822>>>    Object oOK_btn is a Button
100824>>>        Set Size to 14 50
100825>>>        Set Location to 59 207
100826>>>        Set Label to "Add Now"
100827>>>        Set Status_Help to "Add to DataFlex Studios 'Tools' menu. The Studio version can be selected with the two spinforms. The COMManifestStudio program gets added to the Studios Tools menu. When selected from the Studio it will pass the current project name on the command line so that the current program's manifest file is automatically loaded by the COMManifestStudio program."
100828>>>        Set peAnchors to anTopRight
100829>>>
100829>>>        Procedure OnClick
100832>>>            Integer iRetval iMajorVersion iMinorVersion
100832>>>            String sText sStudioVersion
100832>>>            Get Value of oStudioMajorVersion_sf to iMajorVersion
100833>>>            Get Value of oStudioMinorVersion_sf to iMinorVersion
100834>>>            Move (String(iMajorVersion) + "." + String(iMinorVersion)) to sStudioVersion
100835>>>            Get AddProgramToStudioToolsMenu sStudioVersion to iRetval
100836>>>            Case Begin
100836>>>                Case (iRetval = cx_RegKeyAlreadyExist)
100838>>>                    Move ("The program already exists in the" * sStudioVersion * "DataFlex Studios Tools menu.") to sText
100839>>>                    Break
100840>>>                Case (iRetval = cx_RegKeyCreated)
100843>>>                    Move ("Success. The tool was added to the" * sStudioVersion *  "DataFlex Studios Tools menu.") to sText
100844>>>                    Break
100845>>>                Case (iRetval = cx_RegkeyFailed)
100848>>>                    Move "Failed. Could not create the registry key for adding the program to the DataFlex Studio's Tools menu." to sText
100849>>>                    Break
100850>>>                Case (iRetval = cx_RegKeyVDFKeyDoesNotExist)
100853>>>                    Move ("Could not find the Studio registry key. Is DataFlex Studio version" * sStudioVersion * "really installed on this machine?") to sText
100854>>>                    Break
100855>>>                Case (iRetval = CX_InstalledOkVdfUnder16)
100858>>>                    Move ("The program was added to the" * sStudioVersion * "Studios Tools menu successfully, but because you installed for an earlier version of the Studio than 16.0 you need to compile the program under that same VDF version, else the Studio can't start the program properly. (Sorry, just a 'feature' of earlier versions of the Studio)") to sText
100859>>>                    Break
100860>>>            Case End
100860>>>
100860>>>            Send Info_Box sText
100861>>>        End_Procedure
100862>>>    End_Object
100863>>>
100863>>>    Object oCancel_Btn is a Button
100865>>>        Set Label to "&Close"
100866>>>        Set Location to 59 264
100867>>>        Set peAnchors to anBottomRight
100868>>>
100868>>>        Procedure OnClick
100871>>>            Send Close_Panel
100872>>>        End_Procedure
100873>>>
100873>>>    End_Object
100874>>>
100874>>>    Function AddProgramToStudioToolsMenu String sStudioVersion Returns Integer
100877>>>        Boolean bOk bExists bOpen
100877>>>        String sKey sValue sProgramPath sProgram sProduct sStudioPath
100877>>>        Handle hoReg hoArray
100877>>>        Integer i iItems iCreated iRetval
100877>>>
100877>>>        Move False to bOk
100878>>>        Move (CS_StudioPath + (Trim(sStudioVersion)))  to sStudioPath
100879>>>        If (sStudioVersion > "17.1") Begin
100881>>>            Move (Replace("Visual ", sStudioPath, "")) to sStudioPath
100882>>>        End
100882>>>>
100882>>>
100882>>>        Get psProgramPath of (phoWorkspace(ghoApplication)) to sProgramPath
100883>>>        Get PathAtIndex of (phoWorkspace(ghoApplication)) sProgramPath 1 to sProgramPath
100884>>>        Get vFolderFormat sProgramPath to sProgramPath
100885>>>        Get Module_Name to sProgram
100886>>>//        Get psProduct     of (phoWorkspace(ghoApplication)) to sProduct
100886>>>        Move sProgram to sProduct
100887>>>        Get Create U_cRegistry to hoReg
100888>>>        Set phRootKey of hoReg to HKEY_CURRENT_USER
100889>>>
100889>>>        // First check if the DataFlex version is installed
100889>>>        Get KeyExists of hoReg sStudioPath to bExists
100890>>>        If (bExists = False) Begin
100892>>>            Send Destroy of hoReg
100893>>>            Function_Return cx_RegKeyVDFKeyDoesNotExist
100894>>>        End
100894>>>>
100894>>>
100894>>>        // Then check if any tools have been installed in the Tools Menu.
100894>>>        // If no tools created yet, create the Tools registry key.
100894>>>        Move (sStudioPath + CS_StudioTools) to sStudioPath
100895>>>        Get KeyExists of hoReg sStudioPath to bExists
100896>>>        If (bExists = False) Begin
100898>>>            Set pfAccessRights of hoReg to KEY_ALL_ACCESS
100899>>>            Get CreateKey of hoReg sStudioPath to iCreated
100900>>>            If (iCreated <> 0) Begin
100902>>>                Move cx_RegkeyFailed to iRetval
100903>>>            End
100903>>>>
100903>>>            Else Begin
100904>>>                Move True to bExists
100905>>>            End
100905>>>>
100905>>>        End
100905>>>>
100905>>>
100905>>>        If (bExists = True) Begin
100907>>>            Get OpenKey of hoReg sStudioPath to bOk
100908>>>            If (bOk = True) Begin
100910>>>                Get Create U_Array to hoArray
100911>>>                Get GetSubkeys of hoReg hoArray to iItems
100912>>>                Decrement iItems
100913>>>                Move False to bExists
100914>>>                Set pfAccessRights of hoReg to KEY_READ
100915>>>                // Check if the key already exists:
100915>>>                For i from 0 to iItems
100921>>>>
100921>>>                    Get Value of hoArray item i to sKey
100922>>>                    Move (sStudioPath + "\" + sKey) to sKey
100923>>>                    Get OpenKey of hoReg sKey to bOpen
100924>>>                    If (bOpen = True) Begin
100926>>>                        Get ReadString of hoReg CS_Name to sValue
100927>>>                        If (sValue = sProduct) Begin
100929>>>                            Move True to bExists
100930>>>                        End
100930>>>>
100930>>>                    End
100930>>>>
100930>>>                Loop
100931>>>>
100931>>>                Send Destroy of hoArray
100932>>>                If (bExists = False) Begin
100934>>>                    Set pfAccessRights of hoReg to KEY_ALL_ACCESS
100935>>>                    // We need to create the next key number:
100935>>>                    // The studio expect tools menu items to be numbered 1,2,3...n
100935>>>                    Increment iItems
100936>>>                    Increment iItems
100937>>>                    Get CreateKey of hoReg (sStudioPath + "\" + String(iItems)) to iCreated
100938>>>                    If (iCreated = 0) Begin
100940>>>                        Send WriteString of hoReg CS_Name sProduct
100941>>>                        // From DataFlex 16 and up the params for the Studio's Tools menu changed slightly:
100941>>>                        If (sStudioVersion >= "16.0") Begin
100943>>>                            Send WriteString of hoReg CS_Command (sProgramPath + sProgram)
100944>>>                            Send WriteString of hoReg CS_CommandLine (psTag(Self))
100945>>>                        End
100945>>>>
100945>>>                        Else Begin
100946>>>                            Send WriteString of hoReg CS_CommandLine ('"' + sProgramPath + sProgram + ".exe" + '"' * psTag(Self))
100947>>>                            Move CX_InstalledOkVdfUnder16 to iRetval
100948>>>                        End
100948>>>>
100948>>>                        Send WriteDword  of hoReg CS_Separator 1
100949>>>                        Move cx_RegKeyCreated to iRetval
100950>>>                    End
100950>>>>
100950>>>                    Else Begin
100951>>>                        Move cx_RegkeyFailed to iRetval
100952>>>                    End
100952>>>>
100952>>>                End
100952>>>>
100952>>>                Else Begin
100953>>>                    Move cx_RegKeyAlreadyExist to iRetval
100954>>>                End
100954>>>>
100954>>>                Send CloseKey of hoReg
100955>>>            End
100955>>>>
100955>>>        End
100955>>>>
100955>>>
100955>>>        Send Destroy of hoReg
100956>>>        Function_Return iRetval
100957>>>    End_Function
100958>>>
100958>>>    Procedure Page Integer iPageObject
100961>>>        Forward Send Page iPageObject
100963>>>        Set Icon to "ActionAdd.ico"
100964>>>    End_Procedure
100965>>>
100965>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
100966>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
100967>>>    On_Key kCancel       Send KeyAction of oCancel_Btn
100968>>>End_Object
100969>        Use CompareDatabases.vw
Including file: CompareDatabases.vw    (C:\Projects\DF18\DbUpdateFramework\AppSrc\CompareDatabases.vw)
100969>>>Use Windows.pkg
100969>>>Use Dfclient.pkg
100969>>>Use Cursor.pkg
100969>>>Use Batchdd.pkg
100969>>>Use cButton.pkg
100969>>>Use cDbUpdateFunctionLibrary.pkg
100969>>>Use DUFStatusPanel.pkg
100969>>>Use seq_chnl.pkg
100969>>>Use vWin32fh.pkg
100969>>>Use cHeaderGroup.pkg
100969>>>Use cSuggestionIniForm.pkg
Including file: cSuggestionIniForm.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cSuggestionIniForm.pkg)
100969>>>>>Use Windows.pkg
100969>>>>>Use Windows.pkg
100969>>>>>Use WinSuggestion.pkg
Including file: WinSuggestion.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\WinSuggestion.pkg)
100969>>>>>>>// 
100969>>>>>>>
100969>>>>>>>Use Windows.pkg
100969>>>>>>>Use tWinStructs.pkg
100969>>>>>>>Use tSuggestion.pkg
Including file: tSuggestion.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\tSuggestion.pkg)
100969>>>>>>>>>// struct used for suggestion forms, representing an item of data
100969>>>>>>>>>Enum_List 
100969>>>>>>>>>    Define smFind
100969>>>>>>>>>    Define smValidationTable
100969>>>>>>>>>    Define smCustom
100969>>>>>>>>>End_Enum_List
100969>>>>>>>>>
100969>>>>>>>>>Struct tSuggestion
100969>>>>>>>>>    String sRowId
100969>>>>>>>>>    String[] aValues
100969>>>>>>>>>End_Struct
100969>>>>>>>>>
100969>>>>>>>Use cTimer.pkg
Including file: cTimer.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cTimer.pkg)
100969>>>>>>>>>// cTimer class
100969>>>>>>>>>//
100969>>>>>>>>>// This supercedes the DFTimer class. 
100969>>>>>>>>>// It is simpler and more flexible
100969>>>>>>>>>
100969>>>>>>>>>Use Dftimer.pkg // we still use the Timer Manager classes and global objects
Including file: Dftimer.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\Dftimer.pkg)
100969>>>>>>>>>>>//************************************************************************
100969>>>>>>>>>>>//--- DFTimer   Timer package for DataFlex programs
100969>>>>>>>>>>>//
100969>>>>>>>>>>>// Copyright (c) 1983-2002 Data Access Corporation, Miami Florida,
100969>>>>>>>>>>>// All rights reserved.
100969>>>>>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.
100969>>>>>>>>>>>//
100969>>>>>>>>>>>//************************************************************************
100969>>>>>>>>>>>//  Description:
100969>>>>>>>>>>>//      This package contains all components needed to implement timers
100969>>>>>>>>>>>//      in a DataFlex 4 program.
100969>>>>>>>>>>>//
100969>>>>>>>>>>>//
100969>>>>>>>>>>>//  Author: Eddy Kleinjan, Data Access Nederland
100969>>>>>>>>>>>//************************************************************************
100969>>>>>>>>>>>// 03/03/2001 EK  Fixed Timer_Active_State to check for valid windows
100969>>>>>>>>>>>//                handle before trying to set or kill a timer.
100969>>>>>>>>>>>//                Fixed Kill_All_Timers to check for valid windows
100969>>>>>>>>>>>//                handle before trying to kill a timer.
100969>>>>>>>>>>>//                The windows handle might not exist anymore when the
100969>>>>>>>>>>>//                program is being exited using Exit_Application.
100969>>>>>>>>>>>// 12/13/2001 JJT fixed Timer_Active_State to check for -1 (not 0). Fixed a
100969>>>>>>>>>>>//                a bug where set Timeout started inactive timers.
100969>>>>>>>>>>>//                Added code to force timer object to desktop
100969>>>>>>>>>>>//************************************************************************
100969>>>>>>>>>>>// CLASS DFTimer
100969>>>>>>>>>>>//
100969>>>>>>>>>>>// Usage:
100969>>>>>>>>>>>//    Object MyTimer is a DFTimer
100969>>>>>>>>>>>//
100969>>>>>>>>>>>//        Set Timeout to 2000                             // Default 1000
100969>>>>>>>>>>>//        Set Auto_Start_State to TRUE|FALSE              // Default TRUE
100969>>>>>>>>>>>//        Set Auto_Stop_State to TRUE|FALSE               // Default TRUE
100969>>>>>>>>>>>//        Set Timer_Message to MyMessage                  // Default 0
100969>>>>>>>>>>>//        Set Timer_Object to (MyObject(self))            // Default 0
100969>>>>>>>>>>>//        Set Timer_Active_State to TRUE|FALSE            // Default FALSE
100969>>>>>>>>>>>//
100969>>>>>>>>>>>//        // Augment when no Timer_Message
100969>>>>>>>>>>>//        Procedure OnTimer
100969>>>>>>>>>>>//            Send Info_Box "HEY, WAKE UP!"
100969>>>>>>>>>>>//        End_Procedure
100969>>>>>>>>>>>//
100969>>>>>>>>>>>//    End_Object
100969>>>>>>>>>>>//
100969>>>>>>>>>>>// DESCRIPTION
100969>>>>>>>>>>>//      Objects of this class can be used to trigger an event after a
100969>>>>>>>>>>>//      certain amount of time has passed. You can specify this time
100969>>>>>>>>>>>//      by setting the Timeout property of the object. This timeout
100969>>>>>>>>>>>//      is in miliseconds.
100969>>>>>>>>>>>//
100969>>>>>>>>>>>//      Whenever a timer event happens, it will notify the object by
100969>>>>>>>>>>>//      sending an OnTimer event. You can trap this event to do whatever
100969>>>>>>>>>>>//      you want the timer to do. By default this OnTimer event
100969>>>>>>>>>>>//      will send the Timer_Message to Timer_Object, when these have
100969>>>>>>>>>>>//      been specified.
100969>>>>>>>>>>>//
100969>>>>>>>>>>>//      By default, you have to activate a timer by setting its
100969>>>>>>>>>>>//      Timer_Active_State to TRUE. When the timer has been placed
100969>>>>>>>>>>>//      inside a user-interface object, it can also be activated
100969>>>>>>>>>>>//      automatically when this user-interface object is being
100969>>>>>>>>>>>//      activated. This only happes when it Auto_Start_State is TRUE,
100969>>>>>>>>>>>//      which is the default setting. In such a case, the timer will
100969>>>>>>>>>>>//      also automatically being stopped when the user-interface
100969>>>>>>>>>>>//      object is taken of the screen. This depends on the
100969>>>>>>>>>>>//      Auto_Stop_Timer state to happen.
100969>>>>>>>>>>>//
100969>>>>>>>>>>>//      When you need to set a new timeout value, you can do so
100969>>>>>>>>>>>//      even when the timer is active. It will adjust the timeout
100969>>>>>>>>>>>//      immediately.
100969>>>>>>>>>>>//
100969>>>>>>>>>>>//      Note that timer events depend on Windows for the delivery of
100969>>>>>>>>>>>//      the event. Since timer events get a low priority in Windows,
100969>>>>>>>>>>>//      it might put your program on hold when other programs are very
100969>>>>>>>>>>>//      busy. In such a case, you will only receive one timer event
100969>>>>>>>>>>>//      after the process stopped. There is no way, other than
100969>>>>>>>>>>>//      calculating it yourself, to determine how many time has passed
100969>>>>>>>>>>>//      or how many timer event should have happened since the last
100969>>>>>>>>>>>//      timer event or timer activation.
100969>>>>>>>>>>>//
100969>>>>>>>>>>>// PUBLIC INTERFACE
100969>>>>>>>>>>>//
100969>>>>>>>>>>>//    PROPERTIES
100969>>>>>>>>>>>//
100969>>>>>>>>>>>//    Auto_Start_State When TRUE (default) the timer will be activated
100969>>>>>>>>>>>//                     automatically when the object will be (virtually)
100969>>>>>>>>>>>//                     paged on the screen.
100969>>>>>>>>>>>//                     Example: When a timer object has been placed
100969>>>>>>>>>>>//                     inside a view, then the timer will be activated
100969>>>>>>>>>>>//                     when the view is activated.
100969>>>>>>>>>>>//
100969>>>>>>>>>>>//    Auto_Stop_State  When TRUE (default) the timer will be deactivated
100969>>>>>>>>>>>//                     automatically when the object will be (virtually)
100969>>>>>>>>>>>//                     taken off the screen.
100969>>>>>>>>>>>//
100969>>>>>>>>>>>//    Timeout          The timeout value for the timer to fire. The
100969>>>>>>>>>>>//                     timeout value must be set in miliseconds.
100969>>>>>>>>>>>//                     This property may be set even when the timer is
100969>>>>>>>>>>>//                     active. The new timeout value will be applied
100969>>>>>>>>>>>//                     immediately.
100969>>>>>>>>>>>//                     NOTE: The timeout set here is never precise. It
100969>>>>>>>>>>>//                     depends on Windows to deliver the message to our
100969>>>>>>>>>>>//                     application.
100969>>>>>>>>>>>//                     Default 1000.
100969>>>>>>>>>>>//
100969>>>>>>>>>>>//    Timer_Active_State
100969>>>>>>>>>>>//                     Set to TRUE to activate the timer, to FALSE to
100969>>>>>>>>>>>//                     deactivate the timer.
100969>>>>>>>>>>>//
100969>>>>>>>>>>>//
100969>>>>>>>>>>>//    Timer_Message    This property can be set to a messageID which has
100969>>>>>>>>>>>//                     to be sent whenever a timer event occurs. Default
100969>>>>>>>>>>>//                     this message will be send to the object itself
100969>>>>>>>>>>>//                     unless a Timer_Object as been specified.
100969>>>>>>>>>>>//
100969>>>>>>>>>>>//    Timer_Object     This property can be set to an objectID which has
100969>>>>>>>>>>>//                     to receive the Timer_Message whenever a timer
100969>>>>>>>>>>>//                     event occurs. This value has no meaning when
100969>>>>>>>>>>>//                     no Timer_Message has been set.
100969>>>>>>>>>>>//
100969>>>>>>>>>>>//    METHODS
100969>>>>>>>>>>>//
100969>>>>>>>>>>>//    OnTimer          This event will happen whenever the specified
100969>>>>>>>>>>>//                     amount of time has passed and the timer is
100969>>>>>>>>>>>//                     active. By default it sends the message in
100969>>>>>>>>>>>//                     the Timer_Message property to the object in
100969>>>>>>>>>>>//                     the Timer_Object when these have been specified.
100969>>>>>>>>>>>//                     When you don't need this, you can just override
100969>>>>>>>>>>>//                     the OnTimer event.
100969>>>>>>>>>>>//
100969>>>>>>>>>>>// PUBLIC INTERFACE
100969>>>>>>>>>>>//
100969>>>>>>>>>>>//    Page_Object      Has been augmented to auto_start the timer when
100969>>>>>>>>>>>//                     it becomes active as part or a user-interface
100969>>>>>>>>>>>//                     object.
100969>>>>>>>>>>>//
100969>>>>>>>>>>>//    Page_Delete      Has been augmented to auto_stop the timer when
100969>>>>>>>>>>>//                     it is deactivated as part or a user-interface
100969>>>>>>>>>>>//                     object.
100969>>>>>>>>>>>//
100969>>>>>>>>>>>//    Destroy_Object   Has been augmented to deactivate the timer.
100969>>>>>>>>>>>//
100969>>>>>>>>>>>Use LanguageText.pkg
100969>>>>>>>>>>>Use Windows.pkg
100969>>>>>>>>>>>Use WinUser.pkg
100969>>>>>>>>>>>
100969>>>>>>>>>>>External_Function SetTimer "SetTimer" User32.DLL ;    Integer hWnd ;    Integer idTimer ;    Integer idTimeout ;    Pointer tmprc ;    Returns Integer
100970>>>>>>>>>>>
100970>>>>>>>>>>>External_Function KillTimer "KillTimer" User32.DLL ;    Integer hWnd ;    Integer idTimer ;    Returns Integer
100971>>>>>>>>>>>
100971>>>>>>>>>>>// This global integer holds the ID of the object
100971>>>>>>>>>>>// that manages all timers.
100971>>>>>>>>>>>Integer giTimerManager
100971>>>>>>>>>>>
100971>>>>>>>>>>>// This class is used to store the object IDs
100971>>>>>>>>>>>// of the active timer objects. It augments
100971>>>>>>>>>>>// the Destroy_Object procedure to notify
100971>>>>>>>>>>>// the DFTimerManager to kill all its active
100971>>>>>>>>>>>// timers.
100971>>>>>>>>>>>// NOTE: This class looks very much like the
100971>>>>>>>>>>>// Set class. I didn't want to use Set because
100971>>>>>>>>>>>// Remove_Element shifts items which I don't
100971>>>>>>>>>>>// want to happen because item numbers are used
100971>>>>>>>>>>>// as timerIDs.
100971>>>>>>>>>>>
100971>>>>>>>>>>>Class TimersArray is an Array
100972>>>>>>>>>>>
100972>>>>>>>>>>>    Function Find_Object Integer iObj Returns Integer
100974>>>>>>>>>>>        Integer iMax
100974>>>>>>>>>>>        Integer iItem
100974>>>>>>>>>>>        Integer iValue
100974>>>>>>>>>>>        Get Item_count to iMax
100975>>>>>>>>>>>        Decrement iMax
100976>>>>>>>>>>>        For iItem from 1 to iMax
100982>>>>>>>>>>>>
100982>>>>>>>>>>>            Get Integer_Value item iItem to iValue
100983>>>>>>>>>>>            If iValue EQ iObj;                Function_Return iItem
100986>>>>>>>>>>>        Loop
100987>>>>>>>>>>>>
100987>>>>>>>>>>>        Function_Return -1
100988>>>>>>>>>>>    End_Function
100989>>>>>>>>>>>
100989>>>>>>>>>>>    Procedure Add_Object Integer iObj Returns Integer
100991>>>>>>>>>>>        Integer iItem
100991>>>>>>>>>>>        Get Find_Object iObj to iItem
100992>>>>>>>>>>>        If iItem LT 0 Begin
100994>>>>>>>>>>>            Get Find_Object 0 to iItem
100995>>>>>>>>>>>            If iItem LT 0 ;                Get Item_Count to iItem
100998>>>>>>>>>>>        End
100998>>>>>>>>>>>>
100998>>>>>>>>>>>        Set Array_Value item iItem to iObj
100999>>>>>>>>>>>        Procedure_Return iItem
101000>>>>>>>>>>>    End_Procedure
101001>>>>>>>>>>>
101001>>>>>>>>>>>    Procedure Remove_Object Integer iObj
101003>>>>>>>>>>>        Integer iItem
101003>>>>>>>>>>>        Get Find_Object iObj to iItem
101004>>>>>>>>>>>        If iItem GT 0 ;            Set Array_Value item iItem to 0
101007>>>>>>>>>>>    End_Procedure
101008>>>>>>>>>>>
101008>>>>>>>>>>>    Procedure Destroy_Object
101010>>>>>>>>>>>        Delegate Send Kill_All_Timers
101012>>>>>>>>>>>        Forward Send Destroy_Object
101014>>>>>>>>>>>    End_Procedure
101015>>>>>>>>>>>
101015>>>>>>>>>>>End_Class // TimersArray
101016>>>>>>>>>>>
101016>>>>>>>>>>>// This class is the actual timer manager
101016>>>>>>>>>>>// A timer will be created when Message Set_Timer_Active_State
101016>>>>>>>>>>>// has been send. This message needs two arguments. The first
101016>>>>>>>>>>>// is the objectID of the object to receive the timer event,
101016>>>>>>>>>>>// and the second is state. The object which ID has been passed,
101016>>>>>>>>>>>// needs to have a Timeout property to return the timeout for the
101016>>>>>>>>>>>// timer and it also needs to handle the MSG_OnTimer whenever a
101016>>>>>>>>>>>// timer event occurs.
101016>>>>>>>>>>>// The objectID of the Object will be placed in an array which contains
101016>>>>>>>>>>>// the objectIDs of all active timers. The Windows timer ID of a timer
101016>>>>>>>>>>>// is the itemnumber of the object in the array.
101016>>>>>>>>>>>//
101016>>>>>>>>>>>Class DFTimerManager is a DfBaseControl
101017>>>>>>>>>>>
101017>>>>>>>>>>>    Procedure Construct_Object
101019>>>>>>>>>>>
101019>>>>>>>>>>>        Forward Send Construct_Object
101021>>>>>>>>>>>
101021>>>>>>>>>>>        Set Visible_State to FALSE
101022>>>>>>>>>>>
101022>>>>>>>>>>>        Set External_Class_Name "cVdfTimer" to "static"
101023>>>>>>>>>>>        Set External_Message WM_TIMER to OnTimer
101024>>>>>>>>>>>
101024>>>>>>>>>>>        Object TimersArray is a TimersArray
101026>>>>>>>>>>>            Set Array_Value item 0 to -9999 // So we don't use item 0
101027>>>>>>>>>>>        End_Object
101028>>>>>>>>>>>
101028>>>>>>>>>>>        Move self to giTimerManager
101029>>>>>>>>>>>
101029>>>>>>>>>>>    End_Procedure
101030>>>>>>>>>>>
101030>>>>>>>>>>>    Procedure Set Timer_Active_State Integer iObj Integer iState
101032>>>>>>>>>>>        Integer iTimerID
101032>>>>>>>>>>>        Integer iTimeout
101032>>>>>>>>>>>        Integer iResult
101032>>>>>>>>>>>        Integer iSet
101032>>>>>>>>>>>        Dword   nResult
101032>>>>>>>>>>>        Handle  hWnd
101032>>>>>>>>>>>
101032>>>>>>>>>>>        // Get the handle of this object
101032>>>>>>>>>>>        Get Window_Handle to hWnd
101033>>>>>>>>>>>        If (Not(hWnd)) Begin
101035>>>>>>>>>>>            Error DFERR_DFTIMER C_$TimerNoHandle
101036>>>>>>>>>>>>
101036>>>>>>>>>>>            Procedure_Return
101037>>>>>>>>>>>        End
101037>>>>>>>>>>>>
101037>>>>>>>>>>>
101037>>>>>>>>>>>        // Test if handle is valid. If not, we leave.
101037>>>>>>>>>>>        If (Not(IsWindow(hWnd))) ;            Procedure_Return
101040>>>>>>>>>>>
101040>>>>>>>>>>>        Move (TimersArray(self)) to iSet
101041>>>>>>>>>>>
101041>>>>>>>>>>>        If (iSet) Begin
101043>>>>>>>>>>>
101043>>>>>>>>>>>            // Let's create or modify a timer
101043>>>>>>>>>>>            If iState Begin
101045>>>>>>>>>>>
101045>>>>>>>>>>>                // Get the exising to new TimerID
101045>>>>>>>>>>>                Get MSG_Add_Object of iSet iObj to iTimerID
101046>>>>>>>>>>>
101046>>>>>>>>>>>                // Set/Modify the timer
101046>>>>>>>>>>>                Get Timeout of iObj to iTimeout
101047>>>>>>>>>>>                Move (SetTimer(hWnd, iTimerID, iTimeout, 0)) to iResult
101048>>>>>>>>>>>                If Not iResult Begin
101050>>>>>>>>>>>                    Error DFERR_DFTIMER C_$TooManyTimers
101051>>>>>>>>>>>>
101051>>>>>>>>>>>                    Procedure_Return
101052>>>>>>>>>>>                End
101052>>>>>>>>>>>>
101052>>>>>>>>>>>
101052>>>>>>>>>>>            End
101052>>>>>>>>>>>>
101052>>>>>>>>>>>
101052>>>>>>>>>>>            // Let's kill an existing timer
101052>>>>>>>>>>>            Else Begin
101053>>>>>>>>>>>
101053>>>>>>>>>>>                // Look up the object in the set
101053>>>>>>>>>>>                Get Find_Object of iSet iObj to iTimerID
101054>>>>>>>>>>>
101054>>>>>>>>>>>                If iTimerID EQ -1 ;                    Procedure_Return
101057>>>>>>>>>>>
101057>>>>>>>>>>>                // Kill the timer
101057>>>>>>>>>>>                Move (KillTimer(hWnd, iTimerID)) to iResult
101058>>>>>>>>>>>                If Not iResult Begin
101060>>>>>>>>>>>                    Move (GetLastError()) to nResult
101061>>>>>>>>>>>                    Error DFERR_DFTIMER (C_$CantKillTimer * string(nResult) - "!")
101062>>>>>>>>>>>>
101062>>>>>>>>>>>                    Procedure_Return
101063>>>>>>>>>>>                End
101063>>>>>>>>>>>>
101063>>>>>>>>>>>
101063>>>>>>>>>>>                // Remove the objectID
101063>>>>>>>>>>>                Send Remove_Object to iSet iObj
101064>>>>>>>>>>>            End
101064>>>>>>>>>>>>
101064>>>>>>>>>>>        End
101064>>>>>>>>>>>>
101064>>>>>>>>>>>    End_Procedure
101065>>>>>>>>>>>
101065>>>>>>>>>>>    Function Timer_Active_State Integer iObj Returns Integer
101067>>>>>>>>>>>        Integer iResult
101067>>>>>>>>>>>        Get Find_Object of (TimersArray(self)) iObj to iResult
101068>>>>>>>>>>>        Function_Return (iResult<>-1) // note: -1= not found
101069>>>>>>>>>>>    End_Function
101070>>>>>>>>>>>
101070>>>>>>>>>>>    // Will be called by the Set when it is being destroyed.
101070>>>>>>>>>>>    Procedure Kill_All_Timers
101072>>>>>>>>>>>        Integer iMax
101072>>>>>>>>>>>        Integer iSet
101072>>>>>>>>>>>        Integer iItem
101072>>>>>>>>>>>        Integer iObj
101072>>>>>>>>>>>        Integer iResult
101072>>>>>>>>>>>        Handle  hWnd
101072>>>>>>>>>>>
101072>>>>>>>>>>>        // Get the handle of this object
101072>>>>>>>>>>>        Get Window_Handle to hWnd
101073>>>>>>>>>>>        If (Not(hWnd)) Begin
101075>>>>>>>>>>>            Error DFERR_DFTIMER C_$TimerNoHandle
101076>>>>>>>>>>>>
101076>>>>>>>>>>>            Procedure_Return
101077>>>>>>>>>>>        End
101077>>>>>>>>>>>>
101077>>>>>>>>>>>
101077>>>>>>>>>>>        // If the window handle is no longer valid, we
101077>>>>>>>>>>>        // leave this procedure. This can happen when the
101077>>>>>>>>>>>        // program is begin aborted using Exit_Application
101077>>>>>>>>>>>        If (Not(IsWindow(hWnd))) ;            Procedure_Return
101080>>>>>>>>>>>
101080>>>>>>>>>>>        // Scan the set and kill all known timers
101080>>>>>>>>>>>        Move (TimersArray(self)) to iSet
101081>>>>>>>>>>>        If (iSet) Begin
101083>>>>>>>>>>>            Get Item_Count of iSet to iMax
101084>>>>>>>>>>>            Decrement iMax
101085>>>>>>>>>>>            For iItem From 1 to iMax
101091>>>>>>>>>>>>
101091>>>>>>>>>>>                Get Integer_Value of iSet item iItem to iObj
101092>>>>>>>>>>>                If iObj Begin
101094>>>>>>>>>>>                    Move (KillTimer(hWnd, iItem)) to iResult
101095>>>>>>>>>>>                    Set Array_Value of iSet item iItem to 0
101096>>>>>>>>>>>                End
101096>>>>>>>>>>>>
101096>>>>>>>>>>>            Loop
101097>>>>>>>>>>>>
101097>>>>>>>>>>>        End
101097>>>>>>>>>>>>
101097>>>>>>>>>>>
101097>>>>>>>>>>>    End_Procedure
101098>>>>>>>>>>>
101098>>>>>>>>>>>    Procedure OnTimer Integer wParam Integer lParam
101100>>>>>>>>>>>        Integer iObj
101100>>>>>>>>>>>        Get Integer_Value of (TimersArray(self)) item wParam to iObj
101101>>>>>>>>>>>        If Not iObj Begin
101103>>>>>>>>>>>            Error DFERR_DFTIMER C_$TimerWithoutObject
101104>>>>>>>>>>>>
101104>>>>>>>>>>>            Procedure_Return
101105>>>>>>>>>>>        End
101105>>>>>>>>>>>>
101105>>>>>>>>>>>        Send OnTimer to iObj wParam lParam
101106>>>>>>>>>>>    End_Procedure
101107>>>>>>>>>>>
101107>>>>>>>>>>>    Procedure Destroy_Object
101109>>>>>>>>>>>        Send Kill_All_Timers
101110>>>>>>>>>>>        Forward Send Destroy_Object
101112>>>>>>>>>>>        Move 0 to giTimerManager
101113>>>>>>>>>>>    End_Procedure
101114>>>>>>>>>>>
101114>>>>>>>>>>>End_Class // DFTimerManger
101115>>>>>>>>>>>
101115>>>>>>>>>>>
101115>>>>>>>>>>>
101115>>>>>>>>>>>
101115>>>>>>>>>>>// This class acts as a container for the
101115>>>>>>>>>>>// timer manager object. This is needed because
101115>>>>>>>>>>>// A DFTimerManager object created directly at the
101115>>>>>>>>>>>// desktop doesn't have a Window_Handle which we
101115>>>>>>>>>>>// need to create a Windoows timer. By placing
101115>>>>>>>>>>>// this non-visual container around the timer
101115>>>>>>>>>>>// manager, it does get a Window_Handle.
101115>>>>>>>>>>>// The procedure End_Construct_Object has been
101115>>>>>>>>>>>// augmented to create a window and also
101115>>>>>>>>>>>// automatically page all children, which will
101115>>>>>>>>>>>// be the timer manager.
101115>>>>>>>>>>>//
101115>>>>>>>>>>>Class DFTimerManagerPanel is a dfBasePanel
101116>>>>>>>>>>>
101116>>>>>>>>>>>    Procedure Construct_Object
101118>>>>>>>>>>>        Forward Send Construct_Object
101120>>>>>>>>>>>        Set Visible_State to FALSE
101121>>>>>>>>>>>        Object DFTimerManager is a DFTimerManager
101123>>>>>>>>>>>        End_Object
101124>>>>>>>>>>>    End_Procedure
101125>>>>>>>>>>>
101125>>>>>>>>>>>    Procedure End_Construct_Object
101127>>>>>>>>>>>        Forward Send End_Construct_Object
101129>>>>>>>>>>>        Send Page_Object TRUE
101130>>>>>>>>>>>        Broadcast Send Page_Object TRUE
101132>>>>>>>>>>>    End_Procedure
101133>>>>>>>>>>>
101133>>>>>>>>>>>End_Class
101134>>>>>>>>>>>
101134>>>>>>>>>>>// This is the class the user uses to create DFTimer objects
101134>>>>>>>>>>>
101134>>>>>>>>>>>
101134>>>>>>>>>>>//{ OverrideProperty=Skip_State DesignTime=False }
101134>>>>>>>>>>>//{ OverrideProperty=TypeFace DesignTime=False }
101134>>>>>>>>>>>Class DFTimer is a Textbox
101135>>>>>>>>>>>
101135>>>>>>>>>>>    Procedure Construct_Object
101137>>>>>>>>>>>        Forward Send Construct_Object
101139>>>>>>>>>>>
101139>>>>>>>>>>>        // Make sure this object never appears
101139>>>>>>>>>>>        Set Visible_State to FALSE
101140>>>>>>>>>>>
101140>>>>>>>>>>>        Property Integer Private.Timeout    1000
101141>>>>>>>>>>>
101141>>>>>>>>>>>        Property Integer Timer_Message      0
101142>>>>>>>>>>>        Property Integer Timer_Object       0
101143>>>>>>>>>>>        Property Integer Auto_Start_State   True
101144>>>>>>>>>>>        Property Integer Auto_Stop_State    True
101145>>>>>>>>>>>    End_Procedure
101146>>>>>>>>>>>
101146>>>>>>>>>>>    Procedure Set Timer_Active_State Integer iState
101148>>>>>>>>>>>        Integer iObj
101148>>>>>>>>>>>        Move self to iObj
101149>>>>>>>>>>>        If giTimerManager ;            Set Timer_Active_State of giTimerManager iObj to iState
101152>>>>>>>>>>>    End_Procedure
101153>>>>>>>>>>>
101153>>>>>>>>>>>    Function Timer_Active_State Returns Integer
101155>>>>>>>>>>>        Integer iState
101155>>>>>>>>>>>        Integer iObj
101155>>>>>>>>>>>        Move self to iObj
101156>>>>>>>>>>>        If giTimerManager ;            Get Timer_Active_State of giTimerManager iObj to iState
101159>>>>>>>>>>>        Function_Return iState
101160>>>>>>>>>>>    End_Function
101161>>>>>>>>>>>
101161>>>>>>>>>>>    Procedure Set Timeout Integer iTimeout
101163>>>>>>>>>>>        Integer iActive
101163>>>>>>>>>>>        Set Private.Timeout to iTimeout
101164>>>>>>>>>>>        Get Timer_Active_State to iActive
101165>>>>>>>>>>>        If iActive ;            Set Timer_Active_State to TRUE
101168>>>>>>>>>>>    End_Procedure
101169>>>>>>>>>>>
101169>>>>>>>>>>>    Function Timeout Returns Integer
101171>>>>>>>>>>>        Integer iTimeout
101171>>>>>>>>>>>        Get Private.Timeout to iTimeout
101172>>>>>>>>>>>        Function_Return iTimeout
101173>>>>>>>>>>>    End_Function
101174>>>>>>>>>>>
101174>>>>>>>>>>>    Procedure OnTimer Integer iwParam Integer ilParam
101176>>>>>>>>>>>        Integer iMsg
101176>>>>>>>>>>>        Integer iObj
101176>>>>>>>>>>>        Get Timer_Message to iMsg
101177>>>>>>>>>>>        If (iMsg) Begin
101179>>>>>>>>>>>            Get Timer_Object  to iObj
101180>>>>>>>>>>>            If iObj ;                Send iMsg to iObj iwParam ilParam
101183>>>>>>>>>>>            Else ;                Send iMsg iwParam ilParam
101185>>>>>>>>>>>        End
101185>>>>>>>>>>>>
101185>>>>>>>>>>>    End_Procedure
101186>>>>>>>>>>>
101186>>>>>>>>>>>    // Augmented to Auto_Start a timer
101186>>>>>>>>>>>    //
101186>>>>>>>>>>>    Procedure Page_Object Integer iState
101188>>>>>>>>>>>        Forward Send Page_Object iState
101190>>>>>>>>>>>        If (iState AND Auto_Start_State(self)) ;            Set Timer_Active_State to TRUE
101193>>>>>>>>>>>    End_Procedure
101194>>>>>>>>>>>
101194>>>>>>>>>>>    // Augmented to Auto_Stop a timer
101194>>>>>>>>>>>    //
101194>>>>>>>>>>>    Procedure Page_Delete
101196>>>>>>>>>>>        If (Auto_Stop_State(self)) ;            Set Timer_Active_State to FALSE
101199>>>>>>>>>>>        Forward Send Page_Delete
101201>>>>>>>>>>>    End_Procedure
101202>>>>>>>>>>>
101202>>>>>>>>>>>    // Augmented to stop the timer
101202>>>>>>>>>>>    //
101202>>>>>>>>>>>    Procedure Destroy_Object
101204>>>>>>>>>>>        Set Timer_Active_State to FALSE
101205>>>>>>>>>>>        Forward Send Destroy_Object
101207>>>>>>>>>>>    End_Procedure
101208>>>>>>>>>>>
101208>>>>>>>>>>>End_Class // DFTimer
101209>>>>>>>>>>>
101209>>>>>>>>>>>//
101209>>>>>>>>>>>// This was moved into a method so it can be reliable created
101209>>>>>>>>>>>// at the desktop. Note that cDesktop adds method to cDesktop class (class of desktop)
101209>>>>>>>>>>>//
101209>>>>>>>>>>>Procedure CreateDfTimerManagerPanel FOR cDesktop
101211>>>>>>>>>>>    // Create the Desktop Timer Manager Object.
101211>>>>>>>>>>>    Object DFTimerManagerPanel is a DFTimerManagerPanel
101213>>>>>>>>>>>    End_Object
101214>>>>>>>>>>>End_Procedure
101215>>>>>>>>>>>
101215>>>>>>>>>>>Send CreateDfTimerManagerPanel of DESKTOP
101216>>>>>>>>>>>
101216>>>>>>>>>
101216>>>>>>>>>Class cTimer is a cObject
101217>>>>>>>>>
101217>>>>>>>>>    Procedure Construct_Object
101219>>>>>>>>>        Forward Send Construct_Object
101221>>>>>>>>>        Property Integer piPrivate_Timeout 1000
101222>>>>>>>>>    End_Procedure
101223>>>>>>>>>
101223>>>>>>>>>    Procedure Set pbEnabled Boolean bEnabled
101225>>>>>>>>>        If giTimerManager Begin
101227>>>>>>>>>            Set Timer_Active_State of giTimerManager Self to bEnabled
101228>>>>>>>>>        End
101228>>>>>>>>>>
101228>>>>>>>>>    End_Procedure
101229>>>>>>>>>
101229>>>>>>>>>    Function pbEnabled Returns Boolean
101231>>>>>>>>>        Boolean bEnabled
101231>>>>>>>>>        If giTimerManager Begin
101233>>>>>>>>>            Get Timer_Active_State of giTimerManager Self to bEnabled
101234>>>>>>>>>        End
101234>>>>>>>>>>
101234>>>>>>>>>        Function_Return bEnabled
101235>>>>>>>>>    End_Function
101236>>>>>>>>>
101236>>>>>>>>>    Procedure Set piTimeout Integer iTimeout
101238>>>>>>>>>        Boolean bEnabled
101238>>>>>>>>>        Set piPrivate_Timeout to iTimeout
101239>>>>>>>>>        Get pbEnabled to bEnabled
101240>>>>>>>>>        If bEnabled Begin
101242>>>>>>>>>            Set pbEnabled to True
101243>>>>>>>>>        End
101243>>>>>>>>>>
101243>>>>>>>>>    End_Procedure
101244>>>>>>>>>
101244>>>>>>>>>    Function piTimeout Returns Integer
101246>>>>>>>>>        Integer iTimeout
101246>>>>>>>>>        Get piPrivate_Timeout to iTimeout
101247>>>>>>>>>        Function_Return iTimeout
101248>>>>>>>>>    End_Function
101249>>>>>>>>>
101249>>>>>>>>>    Procedure OnTimer
101251>>>>>>>>>    End_Procedure
101252>>>>>>>>>    
101252>>>>>>>>>    // this is needed by the timer manager 
101252>>>>>>>>>    Function Timeout Returns Integer
101254>>>>>>>>>        Integer iTimeout
101254>>>>>>>>>        Get piPrivate_Timeout to iTimeout
101255>>>>>>>>>        Function_Return iTimeout
101256>>>>>>>>>    End_Function
101257>>>>>>>>>
101257>>>>>>>>>    Procedure Destroy_Object
101259>>>>>>>>>        Set pbEnabled to False
101260>>>>>>>>>        Forward Send Destroy_Object
101262>>>>>>>>>    End_Procedure
101263>>>>>>>>>
101263>>>>>>>>>End_Class
101264>>>>>>>Use cRichEdit.pkg
Including file: cRichEdit.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cRichEdit.pkg)
101264>>>>>>>>>use Windows.pkg
101264>>>>>>>>>Use cEdit_Mixin.pkg
101264>>>>>>>>>
101264>>>>>>>>>// DFO: cRichEdit.Dfo
101264>>>>>>>>>// DFC: cRichEdit.Dfc
101264>>>>>>>>>
101264>>>>>>>>>// constants used for RichEdit Properties
101264>>>>>>>>>// peAlignment 
101264>>>>>>>>>Enum_List 
101264>>>>>>>>>    Define alLeft   for 1 
101264>>>>>>>>>    Define alRight  for 2 
101264>>>>>>>>>    Define alCenter for 3 
101264>>>>>>>>>End_Enum_List 
101264>>>>>>>>>
101264>>>>>>>>>// peBullets 
101264>>>>>>>>>Enum_List 
101264>>>>>>>>>    Define buNone 
101264>>>>>>>>>    Define buBullets 
101264>>>>>>>>>    Define buArabicNumbers 
101264>>>>>>>>>    Define buLowerLetters 
101264>>>>>>>>>    Define buUpperLetters 
101264>>>>>>>>>    Define buLowerRomans 
101264>>>>>>>>>    Define buUpperRomans 
101264>>>>>>>>>End_Enum_List 
101264>>>>>>>>>
101264>>>>>>>>>// peBulletStyle 
101264>>>>>>>>>Enum_List 
101264>>>>>>>>>    Define busRightParen   for 0 
101264>>>>>>>>>    Define busEncloseParen for 256 
101264>>>>>>>>>    Define busPeriod       for 512 
101264>>>>>>>>>    Define busNumberOnly   for 768 
101264>>>>>>>>>    Define busNoDisplay    for 1024 
101264>>>>>>>>>End_Enum_List
101264>>>>>>>>>    
101264>>>>>>>>>// peLineSpacingType
101264>>>>>>>>>Enum_List 
101264>>>>>>>>>    Define lstSingle
101264>>>>>>>>>    Define lstSingleAndOneHalf
101264>>>>>>>>>    Define lstDouble
101264>>>>>>>>>End_Enum_List
101264>>>>>>>>>
101264>>>>>>>>>Class cRichEdit Is A DFBaseRichEdit
101265>>>>>>>>>
101265>>>>>>>>>    Procedure Construct_Object
101267>>>>>>>>>        Forward Send Construct_Object
101269>>>>>>>>>        Send Define_cEdit_Mixin
101270>>>>>>>>>
101270>>>>>>>>>        On_key Key_Ctrl+Key_B send ToggleBold
101271>>>>>>>>>        On_key Key_Ctrl+Key_I send ToggleItalics
101272>>>>>>>>>        On_key Key_Ctrl+Key_U send ToggleUnderline
101273>>>>>>>>>
101273>>>>>>>>>    End_Procedure // Construct_Object
101274>>>>>>>>>
101274>>>>>>>>>    Import_Class_Protocol cEdit_Mixin
101275>>>>>>>>>    
101275>>>>>>>>>    Procedure ToggleBold
101277>>>>>>>>>        Set pbBold to (not(pbBold(self))) 
101278>>>>>>>>>    end_procedure
101279>>>>>>>>>    
101279>>>>>>>>>    Procedure ToggleItalics
101281>>>>>>>>>        Set pbItalics to (not(pbItalics(self))) 
101282>>>>>>>>>    end_procedure
101283>>>>>>>>>    
101283>>>>>>>>>    Procedure ToggleUnderline
101285>>>>>>>>>       Set pbUnderLine to (not(pbUnderLine(self))) 
101286>>>>>>>>>    end_procedure
101287>>>>>>>>>
101287>>>>>>>>>End_Class
101288>>>>>>>>>
101288>>>>>>>Use sql.pkg
101288>>>>>>>
101288>>>>>>>// defines interface for cWindowMesageHook - currently a private runtime class
101288>>>>>>>Define     U_DFWINDOWSMESSAGEHOOK  for |CI0106
101288>>>>>>>Define     GET_ENABLEWINDOWSHOOK   for |CI$0542
101288>>>>>>>Define     MSG_DISABLEWINDOWSHOOK  for |CI$0543
101288>>>>>>>Define     GET_ONWINDOWSHOOK       for |CI$0544
101288>>>>>>>Define     WH_MOUSE for 7
101288>>>>>>>Define     WH_KEYBOARD for 2
101288>>>>>>>
101288>>>>>>>
101288>>>>>>>// suggestion lists use a global timer and a global suggestion list
101288>>>>>>>Global_Variable Handle ghoSuggestionList 
101288>>>>>>>Move 0 to ghoSuggestionList
101289>>>>>>>
101289>>>>>>>Global_Variable Handle ghoSuggestionTimer
101289>>>>>>>Move 0 to ghoSuggestionTimer
101290>>>>>>>
101290>>>>>>>// this will get created the first time it is needed. 
101290>>>>>>>Class cSuggestionTimer is a cTimer
101291>>>>>>>
101291>>>>>>>    Procedure Construct_Object
101293>>>>>>>        Forward Send Construct_Object
101295>>>>>>>        Property Handle phoTimerOwner 0
101296>>>>>>>        Set piTimeout to 50
101297>>>>>>>    End_Procedure
101298>>>>>>>  
101298>>>>>>>    Procedure OnTimer 
101300>>>>>>>        Handle hoOwner
101300>>>>>>>        Get phoTimerOwner to hoOwner
101301>>>>>>>        // do this in case progam close destroys owner before timer
101301>>>>>>>        Get Object_Id of hoOwner to hoOwner
101302>>>>>>>        If hoOwner Begin
101304>>>>>>>            Send OnSuggestionTimer to hoOwner
101305>>>>>>>        End
101305>>>>>>>>
101305>>>>>>>        Else Begin
101306>>>>>>>            // something wrong, shut off timer
101306>>>>>>>            Set pbEnabled to False   
101307>>>>>>>        End                                
101307>>>>>>>>
101307>>>>>>>    End_Procedure
101308>>>>>>>    
101308>>>>>>>End_Class
101309>>>>>>>
101309>>>>>>>Class cSuggestionHookMouse is a DFWindowsMessageHook
101310>>>>>>>    
101310>>>>>>>    // If mouse not in suggestion list or form, close suggestionlist
101310>>>>>>>    Function OnWindowsHook Integer i1 Integer i2 Integer i3 Returns Integer
101312>>>>>>>        tWinMouseHookStruct MouseHook
101312>>>>>>>        tWinMouseHookStruct MouseHook
101312>>>>>>>        Integer ivoid hObj
101312>>>>>>>        Handle hoOwner hoParent
101312>>>>>>>        If (i1=0 and (i2=WM_LBUTTONDOWN or i2=WM_RBUTTONDOWN or i2=WM_MBUTTONDOWN or ;                      i2=WM_NCLBUTTONDOWN or i2=WM_NCRBUTTONDOWN or i2=WM_NCMBUTTONDOWN)) Begin
101314>>>>>>>            Move (CopyMemory(AddressOf(MouseHook), i3, SizeOfType(tWinMouseHookStruct))) to iVoid
101315>>>>>>>            GET_OBJECT_FROM_WINDOW MouseHook.hwnd to hObj
101316>>>>>>>            Get Parent to hoParent
101317>>>>>>>            Get phoOwner of hoParent to hoOwner
101318>>>>>>>            If (not(hObj) or (hObj<>hoParent and hObj<>hoOwner)) Begin
101320>>>>>>>                Send DisableWindowsHook
101321>>>>>>>                Send DeActivateSuggestionList of hoOwner
101322>>>>>>>            End
101322>>>>>>>>
101322>>>>>>>        End
101322>>>>>>>>
101322>>>>>>>    End_Function
101323>>>>>>>
101323>>>>>>>    Procedure End_Construct_Object
101325>>>>>>>        Boolean bOk
101325>>>>>>>        Forward Send End_Construct_Object
101327>>>>>>>        Get EnableWindowsHook WH_MOUSE to bOk 
101328>>>>>>>    End_Procedure
101329>>>>>>>
101329>>>>>>>End_Class
101330>>>>>>>
101330>>>>>>>Class cSuggestionHookKbd is a DFWindowsMessageHook
101331>>>>>>>    
101331>>>>>>>    // If menu key, close suggestionlist
101331>>>>>>>    Function OnWindowsHook Integer i1 Integer i2 Integer i3 Returns Integer
101333>>>>>>>        Handle hoOwner
101333>>>>>>>        If (i1=0 and i2=VK_MENU) Begin
101335>>>>>>>            Delegate Get phoOwner to hoOwner
101337>>>>>>>            Send DisableWindowsHook
101338>>>>>>>            Send DeActivateSuggestionList of hoOwner
101339>>>>>>>        End
101339>>>>>>>>
101339>>>>>>>    End_Function
101340>>>>>>>    
101340>>>>>>>    Procedure End_Construct_Object
101342>>>>>>>        Boolean bOk
101342>>>>>>>        Forward Send End_Construct_Object
101344>>>>>>>        Get EnableWindowsHook WH_KEYBOARD  to bOk  
101345>>>>>>>    End_Procedure
101346>>>>>>>
101346>>>>>>>End_Class
101347>>>>>>>
101347>>>>>>>Class cSuggestionList is a cRichEdit
101348>>>>>>>    
101348>>>>>>>    Procedure Construct_Object
101350>>>>>>>        Handle hoObj
101350>>>>>>>        Forward Send Construct_Object
101352>>>>>>>        Property Handle phoOwner
101353>>>>>>>        Set Focus_Mode to NonFocusable
101354>>>>>>>        Set Attach_Parent_State to True
101355>>>>>>>        Set pbWrap to False
101356>>>>>>>        If (ghoSuggestionList) Begin
101358>>>>>>>            Send Destroy of ghoSuggestionList
101359>>>>>>>        End
101359>>>>>>>>
101359>>>>>>>        Get CreateNamed (RefClass(cSuggestionHookMouse)) "oMouseHook" to hoObj
101360>>>>>>>        Get CreateNamed (RefClass(cSuggestionHookKbd))"oKbdHook" to hoObj
101361>>>>>>>    End_Procedure
101362>>>>>>>    
101362>>>>>>>    Procedure Destroy_Object
101364>>>>>>>        Forward Send Destroy_Object
101366>>>>>>>        Move 0 to ghoSuggestionList
101367>>>>>>>    End_Procedure
101368>>>>>>>    
101368>>>>>>>    Procedure DeactivateList
101370>>>>>>>        Set pbEnabled of ghoSuggestionTimer to False
101371>>>>>>>        Send Deactivate
101372>>>>>>>        Send Destroy
101373>>>>>>>    End_Procedure
101374>>>>>>>    
101374>>>>>>>    Procedure InitList Handle hoForm
101376>>>>>>>        Integer iSize iLoc iLoc2
101376>>>>>>>        Get GuiSize of hoForm to iSize
101377>>>>>>>        Set GuiSize to (Hi(iSize)) (1000)
101378>>>>>>>        Get Absolute_GUIOrigin of hoForm to iLoc
101379>>>>>>>        Delegate Get Absolute_GUIOrigin to iLoc2
101381>>>>>>>        Set GuiLocation to (Hi(iLoc)-Hi(iLoc2)+Hi(iSize)+2) (Low(iLoc)+2-Low(iLoc2))
101382>>>>>>>        Set Visible_State to False
101383>>>>>>>    End_Procedure
101384>>>>>>>    
101384>>>>>>>    // scroll up one line
101384>>>>>>>    Procedure ScrollUp
101386>>>>>>>        Integer iLine
101386>>>>>>>        Get SelectedRow to iLine
101387>>>>>>>        If (iLine) Begin
101389>>>>>>>            Send SelectRow (iLine-1)
101390>>>>>>>        End
101390>>>>>>>>
101390>>>>>>>    End_Procedure
101391>>>>>>>    
101391>>>>>>>    // scroll down one line
101391>>>>>>>    Procedure ScrollDown
101393>>>>>>>        Integer iLine iLines
101393>>>>>>>        Get Line_Count to iLines
101394>>>>>>>        Get SelectedRow to iLine
101395>>>>>>>        // there can be an extra line at the end
101395>>>>>>>        If (iLine<iLines-1) Begin
101397>>>>>>>            Send SelectRow (iLine+1)
101398>>>>>>>        End
101398>>>>>>>>
101398>>>>>>>    End_Procedure
101399>>>>>>>    
101399>>>>>>>    // sets the current line to iLine and highlights it
101399>>>>>>>    Procedure SelectRow Integer iLine
101401>>>>>>>        Integer iPos iLen
101401>>>>>>>        Get FirstCharInLinePos iLine to iPos
101402>>>>>>>        Get LineLength iLine to iLen
101403>>>>>>>        Send SetSel iPos (iPos+iLen)
101404>>>>>>>    End_Procedure
101405>>>>>>>    
101405>>>>>>>    // get the current selected Line
101405>>>>>>>    Function SelectedRow Returns Integer
101407>>>>>>>        Integer iLine
101407>>>>>>>        Get LineFromChar -1 to iLine
101408>>>>>>>        Function_Return iLine
101409>>>>>>>    End_Function
101410>>>>>>>
101410>>>>>>>    // select the current row 
101410>>>>>>>    Procedure Mouse_Up Integer hCell Integer iPos
101412>>>>>>>        Handle hoObj
101412>>>>>>>        Get phoOwner to hoObj
101413>>>>>>>        Send Activate of hoObj // move focus to owner, which will close the list
101414>>>>>>>        Send SelectSuggestion of hoObj
101415>>>>>>>    End_Procedure // Mouse_Up
101416>>>>>>>      
101416>>>>>>>End_Class
101417>>>>>>>
101417>>>>>>>// This contains mixin support for suggestion logic and contains the interface that
101417>>>>>>>// is accessed publicly. This should be mixed into the form or column DEO object
101417>>>>>>>Class cSuggestion_mixin is a Mixin
101418>>>>>>>    
101418>>>>>>>    Procedure Define_cSuggestion_mixin
101420>>>>>>>        
101420>>>>>>>        Property Integer peSuggestionMode smFind
101421>>>>>>>        Property Boolean pbFullText False
101422>>>>>>>        Property Boolean pbCaseSensitive False
101423>>>>>>>        Property Integer piMaxResults 15
101424>>>>>>>        Property Integer piStartAtChar 2
101425>>>>>>>        Property Boolean pbFullWidth True
101426>>>>>>>        Property Integer piFindIndex 0
101427>>>>>>>        Property Boolean pbFindOnSelect True
101428>>>>>>>        Property Integer piPopupTimeout 50
101429>>>>>>>        
101429>>>>>>>        Property tSuggestion[] pSearchResults
101430>>>>>>>
101430>>>>>>>        Property Handle phcSuggestionListClass (RefClass(cSuggestionList))
101431>>>>>>>        
101431>>>>>>>    End_Procedure
101432>>>>>>>    
101432>>>>>>>    // Display one Suggestion Line in Suggestion List. Good for augmentation although
101432>>>>>>>    // this must be done carefully as you must know the suggestionlist interface, which
101432>>>>>>>    // if private
101432>>>>>>>    Procedure ShowSuggestion tSuggestion SuggestionData String sSearch
101434>>>>>>>        Integer i iCols iPos
101434>>>>>>>        String sValue
101434>>>>>>>        Integer eSuggestionMode
101434>>>>>>>        Boolean bFullText
101434>>>>>>>        
101434>>>>>>>        Get peSuggestionMode to eSuggestionMode
101435>>>>>>>        Get pbFullText to bFullText
101436>>>>>>>        
101436>>>>>>>        Move SuggestionData.aValues[0] to sValue
101437>>>>>>>        If (not(bFullText)) Begin
101439>>>>>>>            Set pbBold of ghoSuggestionList to True
101440>>>>>>>            Send AppendText of ghoSuggestionList (Left(sValue,Length(sSearch))) 
101441>>>>>>>            Set pbBold of ghoSuggestionList to False
101442>>>>>>>            Send AppendText of ghoSuggestionList (Mid(sValue,255,Length(sSearch)+1)) 
101443>>>>>>>        End
101443>>>>>>>>
101443>>>>>>>        Else Begin
101444>>>>>>>            Set pbBold of ghoSuggestionList to False
101445>>>>>>>            Move (Pos(Uppercase(sSearch),Uppercase(sValue))) to iPos
101446>>>>>>>            If (iPos) Begin
101448>>>>>>>                Send AppendText of ghoSuggestionList (Left(sValue,iPos-1)) 
101449>>>>>>>                Set pbBold of ghoSuggestionList to True
101450>>>>>>>                Send AppendText of ghoSuggestionList (Mid(sValue,Length(sSearch),iPos)) 
101451>>>>>>>                Set pbBold of ghoSuggestionList to False
101452>>>>>>>            End
101452>>>>>>>>
101452>>>>>>>            Send AppendText of ghoSuggestionList (Mid(sValue,255,iPos+Length(sSearch))) 
101453>>>>>>>        End
101453>>>>>>>>
101453>>>>>>>        
101453>>>>>>>        // if addiitonal columns (usually validation) we assume the first value is the one that is
101453>>>>>>>        // matched and we display all other values (usually just one) to the
101453>>>>>>>        // right of it. 
101453>>>>>>>        Move (SizeOfArray(SuggestionData.aValues)) to iCols
101454>>>>>>>        If (iCols>1) Begin
101456>>>>>>>            Move "" to sValue
101457>>>>>>>            For i from 1 to (iCols-1)
101463>>>>>>>>
101463>>>>>>>                Move (sValue + If(i=1," - ","  ") + SuggestionData.aValues[i]) to sValue
101464>>>>>>>            Loop
101465>>>>>>>>
101465>>>>>>>            Send AppendText of ghoSuggestionList sValue
101466>>>>>>>        End
101466>>>>>>>>
101466>>>>>>>    End_Procedure
101467>>>>>>>    
101467>>>>>>>    // used to catch a set_field_value_Error
101467>>>>>>>    Procedure Error_Report Integer iError Integer iLine String sErr
101469>>>>>>>    End_Procedure
101470>>>>>>>    
101470>>>>>>>    // does a Set_Field_Value with error testing around it.
101470>>>>>>>    Function SafeSetFieldValue Integer iFile Integer iField String sValue Returns Boolean
101472>>>>>>>        Handle hoOldError
101472>>>>>>>        Boolean bErr
101472>>>>>>>        Move Error_Object_Id to hoOldError
101473>>>>>>>        Move Self to Error_Object_Id
101474>>>>>>>        Move False to Err 
101475>>>>>>>        Set_Field_Value iFile iField to sValue
101478>>>>>>>        Move Err to bErr
101479>>>>>>>        Move hoOldError to Error_Object_Id
101480>>>>>>>        Function_Return bErr        
101481>>>>>>>    End_Function
101482>>>>>>>
101482>>>>>>>
101482>>>>>>>    Procedure SuggestionsFindIncremental String sSearch tSuggestion[] ByRef aSuggestions
101484>>>>>>>        Integer iFile iField iIndex iLen iRow iMax eType iLength iDec
101484>>>>>>>        Handle hoServer
101484>>>>>>>        Boolean bContinue bCase bOldRelate bNeedsRelate bInvalid
101484>>>>>>>        String sVal sLowSearch
101484>>>>>>>        RowID riTest
101484>>>>>>>        
101484>>>>>>>        Get Server to hoServer
101485>>>>>>>        Get Data_File  to iFile
101486>>>>>>>        Get Data_Field to iField       
101487>>>>>>>        
101487>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
101489>>>>>>>            Get piFindIndex to iIndex
101490>>>>>>>            Get piMaxResults to iMax
101491>>>>>>>            Get pbCaseSensitive to bCase
101492>>>>>>>            
101492>>>>>>>            Get_Attribute DF_FIELD_TYPE of iFile iField to eType
101495>>>>>>>            Get_Attribute DF_FIELD_LENGTH of iFile iField to iLength
101498>>>>>>>            Get_Attribute DF_FIELD_PRECISION of iFile iField to iDec
101501>>>>>>>            
101501>>>>>>>            Move (iLength - iDec) to iLength
101502>>>>>>>            
101502>>>>>>>            If (iIndex <= 0) Begin
101504>>>>>>>                Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex
101507>>>>>>>            End
101507>>>>>>>>
101507>>>>>>>            
101507>>>>>>>            
101507>>>>>>>            
101507>>>>>>>            If (iIndex > 0) Begin
101509>>>>>>>                Get No_Relate_State of hoServer to bOldRelate
101510>>>>>>>                Get DDOConstraintNeedsRelate of hoServer iIndex to bNeedsRelate
101511>>>>>>>                Set No_Relate_State of hoServer to (not(bNeedsRelate))
101512>>>>>>>                                
101512>>>>>>>                Move True to bContinue
101513>>>>>>>                Move (Length(sSearch)) to iLen
101514>>>>>>>                Move (Lowercase(sSearch)) to sLowSearch
101515>>>>>>>                Move 0 to iRow
101516>>>>>>>                
101516>>>>>>>                //  Find first record
101516>>>>>>>                Send Request_Read of hoServer FIRST_RECORD iFile iIndex
101517>>>>>>>                Get SafeSetFieldValue iFile iField sSearch to bInvalid
101518>>>>>>>                If bInvalid Begin
101520>>>>>>>                    Move False to bContinue
101521>>>>>>>                End
101521>>>>>>>>
101521>>>>>>>                
101521>>>>>>>                If (bContinue) Begin
101523>>>>>>>                    Send Request_Read of hoServer GE iFile iIndex
101524>>>>>>>                End
101524>>>>>>>>
101524>>>>>>>                
101524>>>>>>>                While (Found and bContinue)
101528>>>>>>>                    Get_Field_Value iFile iField to sVal
101531>>>>>>>                    
101531>>>>>>>                    If ((not(bCase) and Lowercase(Left(sVal, iLen)) = sLowSearch) or (bCase and Left(sVal, iLen) = sSearch)) Begin
101533>>>>>>>
101533>>>>>>>                        Move (SerializeRowID(GetRowID(iFile)))  to aSuggestions[iRow].sRowId
101534>>>>>>>                        Move (Trim(sVal))                       to aSuggestions[iRow].aValues[0]
101535>>>>>>>                        Increment iRow
101536>>>>>>>                        
101536>>>>>>>                        Move (iRow < iMax) to bContinue
101537>>>>>>>                       
101537>>>>>>>                        Send Request_Read of hoServer GT iFile iIndex  
101538>>>>>>>                    End
101538>>>>>>>>
101538>>>>>>>                    Else Begin
101539>>>>>>>                        If (eType = DF_BCD and Length(sSearch) < iLength) Begin
101541>>>>>>>                            //  For numeric fields we'll jump in the index to the next possible value (for example from 40 to 400)
101541>>>>>>>                            
101541>>>>>>>                            Move (GetRowID(iFile)) to riTest
101542>>>>>>>                            
101542>>>>>>>                            Move (sSearch * 10) to sSearch
101543>>>>>>>                            
101543>>>>>>>                            Get SafeSetFieldValue iFile iField sSearch to bInvalid
101544>>>>>>>                            If bInvalid Begin
101546>>>>>>>                                Move False to bContinue
101547>>>>>>>                            End
101547>>>>>>>>
101547>>>>>>>                            Else Begin
101548>>>>>>>                                Send Request_Read of hoServer GE iFile iIndex
101549>>>>>>>                                Move (not(IsSameRowID(riTest, GetRowID(iFile)))) to bContinue
101550>>>>>>>                            End 
101550>>>>>>>>
101550>>>>>>>                        End
101550>>>>>>>>
101550>>>>>>>                        Else Begin
101551>>>>>>>                            Move False to bContinue
101552>>>>>>>                        End
101552>>>>>>>>
101552>>>>>>>                    End
101552>>>>>>>>
101552>>>>>>>                    
101552>>>>>>>                Loop
101553>>>>>>>>
101553>>>>>>>                Set No_Relate_State of hoServer to bOldRelate
101554>>>>>>>            End
101554>>>>>>>>
101554>>>>>>>        End
101554>>>>>>>>
101554>>>>>>>    End_Procedure
101555>>>>>>>    
101555>>>>>>>    Procedure SuggestionsFindFullText String sSearch tSuggestion[] ByRef aSuggestions
101557>>>>>>>        Integer iFile iField iIndex iRow iMax
101557>>>>>>>        Handle hoServer
101557>>>>>>>        Boolean bContinue bCase  bOldRelate bNeedsRelate
101557>>>>>>>        String sVal sLowSearch
101557>>>>>>>        
101557>>>>>>>        Get Server to hoServer
101558>>>>>>>        Get Data_File  to iFile
101559>>>>>>>        Get Data_Field to iField       
101560>>>>>>>        
101560>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
101562>>>>>>>            Get piMaxResults to iMax
101563>>>>>>>            Get pbCaseSensitive to bCase
101564>>>>>>>            
101564>>>>>>>            Get piFindIndex to iIndex
101565>>>>>>>            If (iIndex <= 0) Begin
101567>>>>>>>                Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex
101570>>>>>>>            End
101570>>>>>>>>
101570>>>>>>>            
101570>>>>>>>            Get No_Relate_State of hoServer to bOldRelate
101571>>>>>>>            Get DDOConstraintNeedsRelate of hoServer iIndex to bNeedsRelate
101572>>>>>>>            Set No_Relate_State of hoServer to (not(bNeedsRelate))
101573>>>>>>>            
101573>>>>>>>            
101573>>>>>>>            Move (Lowercase(sSearch)) to sLowSearch
101574>>>>>>>            Move True to bContinue
101575>>>>>>>            Move 0 to iRow
101576>>>>>>>                
101576>>>>>>>            //  Find first record
101576>>>>>>>            Send Request_Read of hoServer FIRST_RECORD iFile iIndex
101577>>>>>>>            
101577>>>>>>>            While (Found and (iRow < iMax))
101581>>>>>>>                Get_Field_Value iFile iField to sVal
101584>>>>>>>                
101584>>>>>>>                If ((bCase and sVal contains sSearch) or (not(bCase) and Lowercase(sVal) contains sLowSearch)) Begin
101586>>>>>>>                    Move (SerializeRowID(GetRowID(iFile)))  to aSuggestions[iRow].sRowId
101587>>>>>>>                    Move (Trim(sVal))                       to aSuggestions[iRow].aValues[0]
101588>>>>>>>                    Increment iRow
101589>>>>>>>                End
101589>>>>>>>>
101589>>>>>>>                
101589>>>>>>>                Send Request_Read of hoServer GT iFile iIndex 
101590>>>>>>>            Loop
101591>>>>>>>>
101591>>>>>>>            Set No_Relate_State of hoServer to bOldRelate
101592>>>>>>>        End
101592>>>>>>>>
101592>>>>>>>    End_Procedure
101593>>>>>>>    
101593>>>>>>>    Procedure SuggestionsSQLFullText String sSearch tSuggestion[] ByRef aSuggestions
101595>>>>>>>        Integer iFile iField iIndex iRow iMax
101595>>>>>>>        Handle hoServer
101595>>>>>>>        Boolean bContinue bOrigActive  bOldRelate bNeedsRelate
101595>>>>>>>        String sVal sOrigFilter sFilter sFile sField
101595>>>>>>>        
101595>>>>>>>        Get Server to hoServer
101596>>>>>>>        Get Data_File  to iFile
101597>>>>>>>        Get Data_Field to iField       
101598>>>>>>>        
101598>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
101600>>>>>>>            
101600>>>>>>>            // make sure we send DD messages to owner DDO
101600>>>>>>>            Get Which_Data_Set of hoServer iFile to hoServer
101601>>>>>>>            If (hoServer=0) Begin
101603>>>>>>>                Procedure_Return
101604>>>>>>>            End
101604>>>>>>>>
101604>>>>>>>            
101604>>>>>>>            Get piMaxResults to iMax
101605>>>>>>>            Get piFindIndex to iIndex
101606>>>>>>>            If (iIndex <= 0) Begin
101608>>>>>>>                Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex
101611>>>>>>>            End
101611>>>>>>>>
101611>>>>>>>            
101611>>>>>>>            //  Determine current filter settings
101611>>>>>>>            Get psSQLFilter of hoServer to sOrigFilter
101612>>>>>>>            Get pbUseDDSqlFilters of hoServer to bOrigActive
101613>>>>>>>            
101613>>>>>>>            // generate the Like filter string
101613>>>>>>>            Get SQLStrLike of hoServer iField sSearch to sFilter
101614>>>>>>>            // If filtering was active append this to what's there
101614>>>>>>>            If (bOrigActive) Begin
101616>>>>>>>                Get SQLStrAppend of hoServer sOrigFilter sFilter to sFilter
101617>>>>>>>            End
101617>>>>>>>>
101617>>>>>>>            
101617>>>>>>>            //  Set filter
101617>>>>>>>            Set psSQLFilter of hoServer to sFilter
101618>>>>>>>            Set pbUseDDSqlFilters of hoServer to True
101619>>>>>>>            
101619>>>>>>>            
101619>>>>>>>            // this will optimize No_relate. If your DF constraint does not
101619>>>>>>>            // need a post-relate test, we will disabled relates for this
101619>>>>>>>            Get No_Relate_State of hoServer to bOldRelate
101620>>>>>>>            Get DDOConstraintNeedsRelate of hoServer iIndex to bNeedsRelate
101621>>>>>>>            Set No_Relate_State of hoServer to (not(bNeedsRelate))
101622>>>>>>>
101622>>>>>>>            //  Find records
101622>>>>>>>            Move True to bContinue
101623>>>>>>>            Move 0 to iRow
101624>>>>>>>            
101624>>>>>>>            Send Request_Read of hoServer FIRST_RECORD iFile iIndex
101625>>>>>>>            
101625>>>>>>>            While (bContinue)
101629>>>>>>>                Get_Field_Value iFile iField to sVal
101632>>>>>>>                
101632>>>>>>>                If (Found) Begin // and ((bCase and sVal contains sSearch) or (not(bCase) and Lowercase(sVal) contains sLowSearch))) Begin
101634>>>>>>>                    Move (SerializeRowID(GetRowID(iFile)))  to aSuggestions[iRow].sRowId
101635>>>>>>>                    Move (Trim(sVal))                       to aSuggestions[iRow].aValues[0]
101636>>>>>>>                    Increment iRow
101637>>>>>>>                    
101637>>>>>>>                    Move (iRow < iMax) to bContinue
101638>>>>>>>                   
101638>>>>>>>                    Send Request_Read of hoServer GT iFile iIndex 
101639>>>>>>>                End
101639>>>>>>>>
101639>>>>>>>                Else Begin
101640>>>>>>>                    Move False to bContinue
101641>>>>>>>                End
101641>>>>>>>>
101641>>>>>>>                
101641>>>>>>>            Loop
101642>>>>>>>>
101642>>>>>>>            
101642>>>>>>>            //  Restore filters
101642>>>>>>>            Set psSQLFilter of hoServer to sOrigFilter
101643>>>>>>>            Set pbUseDDSqlFilters of hoServer to bOrigActive
101644>>>>>>>            Set No_Relate_State of hoServer to bOldRelate
101645>>>>>>>        End
101645>>>>>>>>
101645>>>>>>>    End_Procedure
101646>>>>>>>    
101646>>>>>>>    Procedure SuggestionsValidation String sSearch tSuggestion[] ByRef aSuggestions Boolean bFullText
101648>>>>>>>        Handle hoServer hoTable
101648>>>>>>>        Integer iFile iField iRow iCount iFound iMax iLen
101648>>>>>>>        Variant[][] aData
101649>>>>>>>        Boolean bCaseSensitive bContinue
101649>>>>>>>        String sDescr sVal
101649>>>>>>>        
101649>>>>>>>        Get Server to hoServer
101650>>>>>>>        Get Data_File  to iFile
101651>>>>>>>        Get Data_Field to iField       
101652>>>>>>>        
101652>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
101654>>>>>>>            Get File_Field_Table_Object of hoServer iFile iField to hoTable
101655>>>>>>>            If (hoTable <> 0) Begin
101657>>>>>>>                Get tabledata of hoTable to aData
101658>>>>>>>        
101658>>>>>>>                Get piMaxResults to iMax
101659>>>>>>>                Get pbCaseSensitive to bCaseSensitive  
101660>>>>>>>            
101660>>>>>>>                If (not(bCaseSensitive)) Begin
101662>>>>>>>                    Move (Lowercase(sSearch)) to sSearch
101663>>>>>>>                End
101663>>>>>>>>
101663>>>>>>>                
101663>>>>>>>                
101663>>>>>>>                Move (SizeOfArray(aData)) to iCount
101664>>>>>>>                Move 0 to iRow
101665>>>>>>>                Move (Length(sSearch)) to iLen
101666>>>>>>>                Move True to bContinue
101667>>>>>>>                
101667>>>>>>>            
101667>>>>>>>                While (iFound < iMax and iRow < iCount and bContinue)
101671>>>>>>>                    If (not(bCaseSensitive)) Begin
101673>>>>>>>                        Move (Lowercase(aData[iRow][0])) to sVal
101674>>>>>>>                        Move (Lowercase(aData[iRow][1])) to sDescr
101675>>>>>>>                    End
101675>>>>>>>>
101675>>>>>>>                    Else Begin
101676>>>>>>>                        Move aData[iRow][0] to sVal
101677>>>>>>>                        Move aData[iRow][1] to sDescr
101678>>>>>>>                    End
101678>>>>>>>>
101678>>>>>>>                    
101678>>>>>>>                    If ((bFullText and (sVal contains sSearch)) or (not(bFullText) and (Left(sVal, iLen) = sSearch))) Begin
101680>>>>>>>                        Move aData[iRow][0] to aSuggestions[iFound].sRowId
101681>>>>>>>                        Move aData[iRow][0] to aSuggestions[iFound].aValues[0]
101682>>>>>>>                        Move aData[iRow][1] to aSuggestions[iFound].aValues[1]
101683>>>>>>>                        Increment iFound
101684>>>>>>>                    End
101684>>>>>>>>
101684>>>>>>>                    Else Begin
101685>>>>>>>                        Move (bFullText or iFound = 0) to bContinue
101686>>>>>>>                    End
101686>>>>>>>>
101686>>>>>>>                    
101686>>>>>>>                    Increment iRow
101687>>>>>>>                Loop
101688>>>>>>>>
101688>>>>>>>            End
101688>>>>>>>>
101688>>>>>>>        End
101688>>>>>>>>
101688>>>>>>>         
101688>>>>>>>    End_Procedure
101689>>>>>>>    
101689>>>>>>>    
101689>>>>>>>    Procedure OnFindSuggestions String sSearch tSuggestion[] ByRef aSuggestions
101691>>>>>>>        Integer iMode iFile
101691>>>>>>>        Boolean bFullText bResult bSupportsSQL
101691>>>>>>>        Handle hoServer
101691>>>>>>>        
101691>>>>>>>        Get Server to hoServer
101692>>>>>>>        Get Data_File  to iFile
101693>>>>>>>        
101693>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
101695>>>>>>>            
101695>>>>>>>            Get peSuggestionMode to iMode
101696>>>>>>>            Get pbFullText to bFullText
101697>>>>>>>            
101697>>>>>>>            If (iMode = smFind) Begin
101699>>>>>>>                If (not(bFullText)) Begin
101701>>>>>>>                    Send SuggestionsFindIncremental sSearch (&aSuggestions)
101702>>>>>>>                End
101702>>>>>>>>
101702>>>>>>>                Else Begin
101703>>>>>>>                    Get SupportsSQLFilters of hoServer to bSupportsSQL
101704>>>>>>>                    If (bSupportsSQL) Begin
101706>>>>>>>                        Send SuggestionsSQLFullText sSearch (&aSuggestions)
101707>>>>>>>                    End
101707>>>>>>>>
101707>>>>>>>                    Else Begin
101708>>>>>>>                        Send SuggestionsFindFullText sSearch (&aSuggestions)
101709>>>>>>>                    End
101709>>>>>>>>
101709>>>>>>>                End
101709>>>>>>>>
101709>>>>>>>            End
101709>>>>>>>>
101709>>>>>>>            Else If (iMode = smValidationTable) Begin
101712>>>>>>>                Send SuggestionsValidation sSearch (&aSuggestions) bFullText
101713>>>>>>>            End
101713>>>>>>>>
101713>>>>>>>        End
101713>>>>>>>>
101713>>>>>>>    End_Procedure
101714>>>>>>>    
101714>>>>>>>    Procedure OnSelectSuggestion String sSearch tSuggestion Suggestion
101716>>>>>>>        Handle hoServer
101716>>>>>>>        Integer iFile iField iMode
101716>>>>>>>        Boolean bFind
101716>>>>>>>        RowID rRowId
101716>>>>>>>        
101716>>>>>>>        Get Server to hoServer
101717>>>>>>>        Get Data_File  to iFile
101718>>>>>>>        Get Data_Field to iField       
101719>>>>>>>        
101719>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
101721>>>>>>>            Get peSuggestionMode to iMode
101722>>>>>>>            
101722>>>>>>>            If (iMode = smFind) Begin
101724>>>>>>>                Get pbFindOnSelect to bFind
101725>>>>>>>                If (bFind) Begin
101727>>>>>>>                    Move (DeserializeRowID(Suggestion.sRowId)) to rRowId    
101728>>>>>>>                    
101728>>>>>>>                    If (not(IsNullRowID(rRowId))) Begin
101730>>>>>>>                        Send FindByRowId of hoServer iFile rRowId
101731>>>>>>>                    End
101731>>>>>>>>
101731>>>>>>>                End
101731>>>>>>>>
101731>>>>>>>                Else Begin
101732>>>>>>>                    Set Value to Suggestion.aValues[0]
101733>>>>>>>                    Set Item_Changed_State to True
101734>>>>>>>                End
101734>>>>>>>>
101734>>>>>>>            End
101734>>>>>>>>
101734>>>>>>>            Else If (imode = smValidationTable) Begin
101737>>>>>>>                Set Value to Suggestion.sRowId
101738>>>>>>>                Set Item_Changed_State to True
101739>>>>>>>            End
101739>>>>>>>>
101739>>>>>>>            
101739>>>>>>>        End
101739>>>>>>>>
101739>>>>>>>    End_Procedure
101740>>>>>>>    
101740>>>>>>>    // Return true if Suggestion should be invoked. Can be augmented
101740>>>>>>>    Function ShouldSuggestion String sValue Boolean bChanged Returns Boolean
101742>>>>>>>        Integer iStartAtChar
101742>>>>>>>        Get piStartAtChar to iStartAtChar
101743>>>>>>>        Function_Return (bChanged and Length(sValue)>=iStartAtChar)
101744>>>>>>>    End_Function
101745>>>>>>>    
101745>>>>>>>    
101745>>>>>>>End_Class
101746>>>>>>>
101746>>>>>>>
101746>>>>>>>// This contains logic that deals with the Windows object. It relies on the interface in 
101746>>>>>>>// sSuggestion_mixin, which means it must be mixed in as a sibling of this object (as is done
101746>>>>>>>// in dbSuggestionForm or as a child of this object (as is done in cDbCJGridColumnSuggestion), which
101746>>>>>>>// means messages are resolved via delegation. sSuggestion_mixin does not send messages to this class.
101746>>>>>>>// Note that cSuggestion_mixin and cSuggestionControl_mixin are designed so they can be mixed in at
101746>>>>>>>// the same level or mixed in such that cSuggestionControl_mixin is in the child object and cSuggestion_mixin
101746>>>>>>>// is in the parent
101746>>>>>>> 
101746>>>>>>>Class cSuggestionControl_mixin is a Mixin
101747>>>>>>>    
101747>>>>>>>    Procedure Define_cSuggestionControl_mixin
101749>>>>>>>        
101749>>>>>>>        Property Integer piTimeOutTicks 0
101750>>>>>>>        
101750>>>>>>>        On_Key kEnter Send SelectSuggestion
101751>>>>>>>        On_Key Key_Escape Send DeActivateSuggestionList
101752>>>>>>>        On_Key Key_Up_Arrow Send Up
101753>>>>>>>        On_Key Key_Down_Arrow Send Down
101754>>>>>>>
101754>>>>>>>    End_Procedure
101755>>>>>>>
101755>>>>>>>    Procedure AdjustSuggestionListSize Integer iLines
101757>>>>>>>        Integer i  iX iMax iY
101757>>>>>>>        String sTxt
101757>>>>>>>        Boolean bFullWidth
101757>>>>>>>        For i from 0 to (iLines-1)
101763>>>>>>>>
101763>>>>>>>            Get Line of ghoSuggestionList i to sTxt
101764>>>>>>>            Get Text_Extent of ghoSuggestionList sTxt to iX
101765>>>>>>>            Move (Low(iX) max iMax) to iMax
101766>>>>>>>            Move (Hi(iX)) to iY
101767>>>>>>>        Loop
101768>>>>>>>>
101768>>>>>>>        Move (iMax + 20) to imax
101769>>>>>>>        Get pbFullWidth to bFullWidth
101770>>>>>>>        If bFullWidth Begin
101772>>>>>>>            Move (iMax max (Low(GuiSize(Self)))) to iMax
101773>>>>>>>        End
101773>>>>>>>>
101773>>>>>>>        If (iLines) Begin
101775>>>>>>>            Set GuiSize of ghoSuggestionList to (iY*(iLines)+8) iMax
101776>>>>>>>            Send SelectRow of ghoSuggestionList 0 // go to first line
101777>>>>>>>        End
101777>>>>>>>>
101777>>>>>>>        Else Begin
101778>>>>>>>            Set GuiSize of ghoSuggestionList to (Hi(GuiSize(Self))) (low(GuiSize(Self)))
101779>>>>>>>        End
101779>>>>>>>>
101779>>>>>>>    End_Procedure
101780>>>>>>>    
101780>>>>>>>    // show all suggestions
101780>>>>>>>    Procedure ShowSuggestions
101782>>>>>>>        tSuggestion[] aResults
101782>>>>>>>        tSuggestion[] aResults
101783>>>>>>>        Integer i iLines
101783>>>>>>>        String sSearch 
101783>>>>>>>        Get pSearchResults to aResults
101784>>>>>>>        Get Value to sSearch
101785>>>>>>>        Send Delete_Data of ghoSuggestionList
101786>>>>>>>        Move (SizeOfArray(aResults)) to iLines
101787>>>>>>>        For i from 0 to (iLines-1)
101793>>>>>>>>
101793>>>>>>>            Send ShowSuggestion aResults[i] sSearch
101794>>>>>>>            If ((iLines-1)<>i) Begin
101796>>>>>>>                Send AppendTextLn of ghoSuggestionList ""
101797>>>>>>>            End
101797>>>>>>>>
101797>>>>>>>        Loop
101798>>>>>>>>
101798>>>>>>>        Send AdjustSuggestionListSize iLines
101799>>>>>>>    End_Procedure
101800>>>>>>>
101800>>>>>>>    Procedure FindSuggestions 
101802>>>>>>>        String sSearch
101802>>>>>>>        tSuggestion[] aResults
101802>>>>>>>        tSuggestion[] aResults
101803>>>>>>>        String[] aParams
101804>>>>>>>        Get Value to sSearch
101805>>>>>>>        Send OnFindSuggestions sSearch (&aResults)
101806>>>>>>>        Set pSearchResults to aResults
101807>>>>>>>        // if an error was raised, the suggestion list will be gone
101807>>>>>>>        If (ghoSuggestionList) Begin
101809>>>>>>>            Send ShowSuggestions
101810>>>>>>>        End
101810>>>>>>>>
101810>>>>>>>    End_Procedure
101811>>>>>>>
101811>>>>>>>    Procedure SelectSuggestion 
101813>>>>>>>        String sSearch
101813>>>>>>>        tSuggestion[] aData
101813>>>>>>>        tSuggestion[] aData
101814>>>>>>>        Integer iSelRow
101814>>>>>>>        If ghoSuggestionList Begin
101816>>>>>>>            Get SelectedRow of ghoSuggestionList to iSelRow
101817>>>>>>>            Get Value to sSearch
101818>>>>>>>            Get pSearchResults to aData        
101819>>>>>>>            Send DeActivateSuggestionList
101820>>>>>>>            Send CancelEditIfGrid
101821>>>>>>>            If (iSelRow>=0 and SizeOfArray(aData)>iSelRow) Begin
101823>>>>>>>                Send OnSelectSuggestion sSearch aData[iSelRow] 
101824>>>>>>>            End
101824>>>>>>>>
101824>>>>>>>        End
101824>>>>>>>>
101824>>>>>>>        Else Begin
101825>>>>>>>            Send Default_Action
101826>>>>>>>        End
101826>>>>>>>>
101826>>>>>>>    End_Procedure
101827>>>>>>>    
101827>>>>>>>    Procedure CancelEditIfGrid
101829>>>>>>>        // do nothing with forms, remember
101829>>>>>>>        // to replace or augment with grid to
101829>>>>>>>        // cancel the edit control
101829>>>>>>>    End_Procedure
101830>>>>>>>
101830>>>>>>>    
101830>>>>>>>    Function ParentForSuggestion Returns Handle
101832>>>>>>>        Handle hoMain hoMainPanel
101832>>>>>>>
101832>>>>>>>        // we must have an application object and a main panel object
101832>>>>>>>        If ghoApplication Begin
101834>>>>>>>            Get phoMainPanel of ghoApplication to hoMainPanel
101835>>>>>>>        End
101835>>>>>>>>
101835>>>>>>>        If (hoMainPanel=0 or Self<=Desktop) Begin
101837>>>>>>>            Function_Return 0
101838>>>>>>>        End
101838>>>>>>>>
101838>>>>>>>
101838>>>>>>>        Move Self to hoMain
101839>>>>>>>        Repeat
101839>>>>>>>>
101839>>>>>>>            Get Parent of hoMain to hoMain
101840>>>>>>>        Until (hoMain=Desktop or Block_Mouse_State(hoMain) or hoMainPanel=hoMain)
101842>>>>>>>
101842>>>>>>>        Function_Return (If(hoMain>Desktop,hoMain,0))
101843>>>>>>>        
101843>>>>>>>    End_Function
101844>>>>>>>    
101844>>>>>>>    Procedure ActivateSuggestionList
101846>>>>>>>        Handle hoView hcSuggest
101846>>>>>>>        Get ParentForSuggestion to hoView
101847>>>>>>>        If hoView Begin
101849>>>>>>>            Get phcSuggestionListClass to hcSuggest
101850>>>>>>>            Get CreateNamed of hoView hcSuggest "oSuggestList" to ghoSuggestionList
101851>>>>>>>            Send InitList of ghoSuggestionList Self
101852>>>>>>>            Set Focus_Mode of ghoSuggestionList to Focusable
101853>>>>>>>            Set phoOwner of ghoSuggestionList to Self
101854>>>>>>>            Send Add_Focus of ghoSuggestionList hoView
101855>>>>>>>        End
101855>>>>>>>>
101855>>>>>>>    End_Procedure
101856>>>>>>>    
101856>>>>>>>    Procedure DeActivateSuggestionList
101858>>>>>>>        If ghoSuggestionList Begin
101860>>>>>>>            Send DeactivateList of ghoSuggestionList
101861>>>>>>>        End
101861>>>>>>>>
101861>>>>>>>    End_Procedure
101862>>>>>>>    
101862>>>>>>>    // augment to kill suggest list if focus is not moving to it  
101862>>>>>>>    // customized for grid
101862>>>>>>>    Procedure OnKillFocus
101864>>>>>>>        // note focus has already changed here
101864>>>>>>>        If (ghoSuggestionList) Begin
101866>>>>>>>            If (Focus(Self)<>ghoSuggestionList) Begin
101868>>>>>>>                Send DeActivateSuggestionList
101869>>>>>>>                Forward Send OnKillFocus
101871>>>>>>>            End
101871>>>>>>>>
101871>>>>>>>            Else Begin
101872>>>>>>>                // giving focus to the suggestion list here
101872>>>>>>>            End
101872>>>>>>>>
101872>>>>>>>        End
101872>>>>>>>>
101872>>>>>>>        Else Begin
101873>>>>>>>            Forward Send OnKillFocus
101875>>>>>>>        End
101875>>>>>>>>
101875>>>>>>>    End_Procedure
101876>>>>>>>    
101876>>>>>>>    Procedure Up
101878>>>>>>>        If (Focus(Desktop) = Self and ghoSuggestionList) Begin
101880>>>>>>>           Send ScrollUp of ghoSuggestionList
101881>>>>>>>        End
101881>>>>>>>>
101881>>>>>>>    End_Procedure
101882>>>>>>>
101882>>>>>>>    Procedure Down
101884>>>>>>>        If (Focus(Desktop) = Self and ghoSuggestionList) Begin
101886>>>>>>>           Send ScrollDown of ghoSuggestionList
101887>>>>>>>        End
101887>>>>>>>>
101887>>>>>>>    End_Procedure
101888>>>>>>>    
101888>>>>>>>
101888>>>>>>>    Procedure Key Integer iKey
101890>>>>>>>        Integer iEndTicks
101890>>>>>>>        
101890>>>>>>>        If (Focus(Desktop) <> Self) Begin
101892>>>>>>>          Forward Send Key iKey
101894>>>>>>>          Procedure_Return
101895>>>>>>>        End
101895>>>>>>>>
101895>>>>>>>        
101895>>>>>>>        Send DeActivateSuggestionList
101896>>>>>>>        Move (GetTickCount()) to iEndTicks
101897>>>>>>>        // record the time of key press
101897>>>>>>>        If (piTimeOutTicks(Self) = 0) Begin
101899>>>>>>>         
101899>>>>>>>            If (ghoSuggestionTimer=0) Begin
101901>>>>>>>               Send CreateSuggestionTimer
101902>>>>>>>            End
101902>>>>>>>>
101902>>>>>>>         
101902>>>>>>>            Set pbEnabled of ghoSuggestionTimer to True
101903>>>>>>>            Set phoTimerOwner of ghoSuggestionTimer to Self
101904>>>>>>>        End
101904>>>>>>>>
101904>>>>>>>        Set piTimeOutTicks to iEndTicks
101905>>>>>>>        
101905>>>>>>>        Forward Send Key iKey
101907>>>>>>>    End_Procedure
101908>>>>>>>    
101908>>>>>>>    Procedure CreateSuggestionTimer
101910>>>>>>>        Handle hoMainPanel
101910>>>>>>>        // we must have an application object and a main panel object
101910>>>>>>>        If ghoApplication Begin
101912>>>>>>>            Get phoMainPanel of ghoApplication to hoMainPanel
101913>>>>>>>        End
101913>>>>>>>>
101913>>>>>>>        If (hoMainPanel=0) Begin
101915>>>>>>>            Error DFERR_PROGRAM "Auto-suggest requires an application object and a main panel object"
101916>>>>>>>>
101916>>>>>>>            Procedure_Return
101917>>>>>>>        End
101917>>>>>>>>
101917>>>>>>>        Get CreateNamed of hoMainPanel (RefClass(cSuggestionTimer)) "oSuggestionTimer" to ghoSuggestionTimer
101918>>>>>>>    End_Procedure
101919>>>>>>>  
101919>>>>>>>    // sent by Auto Suggest Timer. Invoke suggestion list as needed
101919>>>>>>>    Procedure OnSuggestionTimer
101921>>>>>>>        Boolean bDoIt
101921>>>>>>>        Integer iEndTicks iStartTicks iTicks iTimeOut iChanged
101921>>>>>>>        String sValue
101921>>>>>>>        
101921>>>>>>>        If (Focus(Desktop) <> Self) Begin
101923>>>>>>>            // focus out of whack. Stop the timer
101923>>>>>>>            Set pbEnabled of ghoSuggestionTimer to False
101924>>>>>>>            Send DeActivateSuggestionList   
101925>>>>>>>            Procedure_Return
101926>>>>>>>        End                                
101926>>>>>>>>
101926>>>>>>>
101926>>>>>>>        Get piTimeOutTicks to iStartTicks
101927>>>>>>>        If (iStartTicks <> 0) Begin           
101929>>>>>>>            Move (GetTickCount()) to iEndTicks 
101930>>>>>>>            Move (iEndTicks - iStartTicks) to iTicks
101931>>>>>>>            // If tick count rolled over
101931>>>>>>>            If (iTicks < 0) Begin
101933>>>>>>>                Move (-iTicks) to iTicks 
101934>>>>>>>            End
101934>>>>>>>>
101934>>>>>>>        End
101934>>>>>>>>
101934>>>>>>>        Get piPopupTimeout to iTimeOut
101935>>>>>>>        If (iTicks >= iTimeOut) Begin
101937>>>>>>>            // If time delay has been met, launch autocomplete
101937>>>>>>>            Set pbEnabled  of ghoSuggestionTimer to False
101938>>>>>>>            Get Value to sValue
101939>>>>>>>            Get Item_Changed_State 0 to iChanged
101940>>>>>>>            Get ShouldSuggestion sValue iChanged to bDoIt
101941>>>>>>>            If bDoIt Begin
101943>>>>>>>                Send ActivateSuggestionList
101944>>>>>>>                Send FindSuggestions
101945>>>>>>>                Set Visible_State of ghoSuggestionList to True
101946>>>>>>>            End
101946>>>>>>>>
101946>>>>>>>            Set piTimeOutTicks to 0
101947>>>>>>>        End
101947>>>>>>>>
101947>>>>>>>    End_Procedure
101948>>>>>>>
101948>>>>>>>End_Class
101949>>>>>>>
101949>>>>>Use cIniFile.pkg
101949>>>>>Use vWin32fh.pkg
101949>>>>>
101949>>>>>    Define CS_cSuggestionFormList       for "Suggestion Form List"  // [Section Name]
101949>>>>>    Define CS_cSuggestionSaveItem       for "Saved Item"            // Key=Value
101949>>>>>    Define CS_cSuggestionFormTooltip    for "This is a suggestion form - start typing what you're looking for. Previously entered values are saved automatically."
101949>>>>>
101949>>>>>Class cSuggestionIniForm is a Form
101950>>>>>
101950>>>>>    Import_Class_Protocol cSuggestionControl_mixin
101951>>>>>    Import_Class_Protocol cSuggestion_mixin
101952>>>>>
101952>>>>>    Procedure Construct_Object
101954>>>>>        Forward Send Construct_Object
101956>>>>>        Send Define_cSuggestionControl_mixin
101957>>>>>        Send Define_cSuggestion_mixin
101958>>>>>
101958>>>>>        Set peSuggestionMode to smCustom
101959>>>>>        Set pbFullText to True
101960>>>>>        Set piStartAtChar to 1
101961>>>>>
101961>>>>>        Property String[] psSavedFormValues
101962>>>>>        Property String psIniFileSection
101963>>>>>        Property Integer piSuggestionListMaxItems 99 // Max no of values saved/read to ini file
101964>>>>>        Property Boolean pbUseWorkspaceIniFile True
101965>>>>>        Property Boolean pbAutoCheckValueExistsAsFile True
101966>>>>>        Property Boolean pbAskToRemoveMissingFile True
101967>>>>>        // Note: pbUseWorkspaceIniFile has presedence over the psIniFileName setting.
101967>>>>>        //       That means that if pbUseWorkspaceIniFile=True, psIniFilename will be set to the
101967>>>>>        //       worspace .ws file on program startup.
101967>>>>>        Property String psIniFileName ""
101968>>>>>    End_Procedure
101969>>>>>
101969>>>>>    Procedure Define_cSuggestionControl_mixin
101971>>>>>
101971>>>>>        Property Integer piTimeOutTicks 0
101972>>>>>
101972>>>>>        On_Key kEnter            Send SelectSuggestion
101973>>>>>        On_Key Key_Escape        Send DeActivateSuggestionList
101974>>>>>        On_Key Key_Up_Arrow      Send Up
101975>>>>>        On_Key Key_Down_Arrow    Send Down
101976>>>>>
101976>>>>>        // Added 'Home' & 'End' navigation keys for the drop-down list and the form object (and Ctrl+Home & Ctrl+End).
101976>>>>>        On_Key Key_Home          Send Home
101977>>>>>        On_Key Key_Ctrl+Key_Home Send Home
101978>>>>>        On_Key Key_End           Send End
101979>>>>>        On_Key Key_Ctrl+Key_End  Send End // Need this as well; else the Ctrl+Home/End keys generates a runtime error (always has).
101980>>>>>
101980>>>>>        // Just can't seem to get the popup of the suggestion list with F4 to work.
101980>>>>>        //On_Key kPrompt          Send LocalPrompt
101980>>>>>    End_Procedure
101981>>>>>
101981>>>>>    Procedure LocalPrompt
101983>>>>>        Handle ho iVoid hWnd
101983>>>>>        String sValue
101983>>>>>
101983>>>>>        Get Value to sValue
101984>>>>>        Get Prompt_Object to ho
101985>>>>>        If (ho <> 0 and Length(sValue) = 0) Begin
101987>>>>>            Send Prompt
101988>>>>>            Procedure_Return
101989>>>>>        End
101989>>>>>>
101989>>>>>
101989>>>>>        // Note: This only works as long as one character has already been entered in the form <Sigh!>
101989>>>>>        Get Form_Window_Handle 0 to hWnd
101990>>>>>        // Simulate press down [Spacebar]
101990>>>>>        Move (SendMessage(hWnd,WM_KEYDOWN, VK_SPACE, EXTKEY)) to iVoid
101991>>>>>        // Simulate release of [Spacebar]
101991>>>>>        Move (SendMessage(hWnd,WM_KEYUP,   VK_SPACE, EXTKEY)) to iVoid
101992>>>>>    End_Procedure
101993>>>>>
101993>>>>>    Procedure ShowSuggestions
101995>>>>>        tSuggestion[] aResults
101995>>>>>        tSuggestion[] aResults
101996>>>>>        Integer i iLines
101996>>>>>        String sSearch
101996>>>>>
101996>>>>>
101996>>>>>        Get pSearchResults to aResults
101997>>>>>        Get Value to sSearch
101998>>>>>
101998>>>>>        If (ghoSuggestionList <> 0) Begin
102000>>>>>            Send Delete_Data of ghoSuggestionList
102001>>>>>            Move (SizeOfArray(aResults)) to iLines
102002>>>>>            For i from 0 to (iLines-1)
102008>>>>>>
102008>>>>>                Send ShowSuggestion aResults[i] sSearch
102009>>>>>                If ((iLines-1)<>i) Begin
102011>>>>>                    Send AppendTextLn of ghoSuggestionList ""
102012>>>>>                End
102012>>>>>>
102012>>>>>            Loop
102013>>>>>>
102013>>>>>            Send AdjustSuggestionListSize iLines
102014>>>>>        End
102014>>>>>>
102014>>>>>
102014>>>>>//        Set Cursor of Cursor_Control to IDC_ARROW
102014>>>>>//        Send Activate of (Self)
102014>>>>>//        Send Release_Mouse_Capture
102014>>>>>    End_Procedure
102015>>>>>
102015>>>>>    Procedure Home
102017>>>>>        If (Focus(Desktop) = Self and ghoSuggestionList) Begin
102019>>>>>           Send ScrollHome
102020>>>>>        End
102020>>>>>>
102020>>>>>        Else Begin
102021>>>>>            Send Key VK_HOME
102022>>>>>        End
102022>>>>>>
102022>>>>>    End_Procedure
102023>>>>>
102023>>>>>    Procedure ScrollHome
102025>>>>>        Send SelectRow of ghoSuggestionList 0
102026>>>>>    End_Procedure
102027>>>>>
102027>>>>>    Procedure End
102029>>>>>        If (Focus(Desktop) = Self and ghoSuggestionList) Begin
102031>>>>>           Send ScrollEnd
102032>>>>>        End
102032>>>>>>
102032>>>>>        Else Begin
102033>>>>>            Send Key VK_END
102034>>>>>        End
102034>>>>>>
102034>>>>>    End_Procedure
102035>>>>>
102035>>>>>    Procedure ScrollEnd
102037>>>>>        Integer iLine iLines
102037>>>>>        Get Line_Count of ghoSuggestionList  to iLines
102038>>>>>        Get SelectedRow of ghoSuggestionList to iLine
102039>>>>>        // there can be an extra line at the end
102039>>>>>        If (iLine < iLines - 1) Begin
102041>>>>>            Send SelectRow of ghoSuggestionList (iLines - 1)
102042>>>>>        End
102042>>>>>>
102042>>>>>    End_Procedure
102043>>>>>
102043>>>>>    Procedure Activating
102045>>>>>        String[] sSavedFormValues
102046>>>>>        If (pbUseWorkspaceIniFile(Self) = True) Begin
102048>>>>>            Get ReadWorkspaceIniFile to sSavedFormValues
102049>>>>>            Set psSavedFormValues    to sSavedFormValues
102050>>>>>        End
102050>>>>>>
102050>>>>>    End_Procedure
102051>>>>>
102051>>>>>    Procedure Set psToolTip String sToolTip
102053>>>>>        String sStatusHelp
102053>>>>>
102053>>>>>        Get Status_Help to sStatusHelp
102054>>>>>        If (sStatusHelp = "") Begin
102056>>>>>            Set Status_Help to sToolTip
102057>>>>>        End
102057>>>>>>
102057>>>>>
102057>>>>>        Move (sToolTip + String(Character(10)) + String(CS_cSuggestionFormTooltip)) to sToolTip
102058>>>>>        Forward Set psToolTip to sToolTip
102060>>>>>    End_Function
102061>>>>>
102061>>>>>    Function ReadWorkspaceIniFile Returns String[]
102063>>>>>        String sWorkspaceFile sObjectName sValue
102063>>>>>        String[] sSavedFormValues
102064>>>>>        Handle hoIniFile
102064>>>>>        Integer iItem iCount iSize
102064>>>>>        Boolean bExists
102064>>>>>
102064>>>>>        If (pbUseWorkspaceIniFile(Self) = False) Begin
102066>>>>>            Function_Return sSavedFormValues
102067>>>>>        End
102067>>>>>>
102067>>>>>
102067>>>>>        Move 0 to iItem
102068>>>>>        Get Object_Label to sObjectName
102069>>>>>        Move (psWorkspaceWSFile(phoWorkspace(ghoApplication))) to sWorkspaceFile
102070>>>>>        Set psIniFileName to sWorkspaceFile
102071>>>>>        Get Create (RefClass(cIniFile)) to hoIniFile
102072>>>>>        Set psFileName of hoIniFile to sWorkspaceFile
102073>>>>>        Get piSuggestionListMaxItems to iSize
102074>>>>>
102074>>>>>        For iCount from 0 to iSize
102080>>>>>>
102080>>>>>            Get KeyExists of hoIniFile (CS_cSuggestionFormList * String(sObjectName)) (CS_cSuggestionSaveItem + String(iCount)) to bExists
102081>>>>>            // We need to loop through all possible values because the list of items may not start at zero.
102081>>>>>            Get ReadString of hoIniFile (CS_cSuggestionFormList * String(sObjectName)) (CS_cSuggestionSaveItem + String(iCount)) "" to sValue
102082>>>>>            If (Trim(sValue) <> "") Begin
102084>>>>>                Move sValue to sSavedFormValues[iItem]
102085>>>>>                Increment iItem
102086>>>>>            End
102086>>>>>>
102086>>>>>        Loop
102087>>>>>>
102087>>>>>
102087>>>>>        Send Destroy of hoIniFile
102088>>>>>        Function_Return sSavedFormValues
102089>>>>>    End_Function
102090>>>>>
102090>>>>>    Procedure WriteWorkspaceIniFile
102092>>>>>        String sWorkspaceFile sObjectName sValue
102092>>>>>        String[] sSavedFormValues
102093>>>>>        Handle hoIniFile
102093>>>>>        Integer iSize iCount
102093>>>>>        Boolean bExists
102093>>>>>
102093>>>>>        If (pbUseWorkspaceIniFile(Self) = False) Begin
102095>>>>>            Procedure_Return
102096>>>>>        End
102096>>>>>>
102096>>>>>
102096>>>>>        Get Object_Label  to sObjectName
102097>>>>>        Get psIniFileName to sWorkspaceFile
102098>>>>>        Get Create (RefClass(cIniFile)) to hoIniFile
102099>>>>>        Set psFileName    of hoIniFile to sWorkspaceFile
102100>>>>>        Get SectionExists of hoIniFile (CS_cSuggestionFormList * String(sObjectName)) to bExists
102101>>>>>        If (bExists = True) Begin
102103>>>>>            Send DeleteSection of hoIniFile (CS_cSuggestionFormList * String(sObjectName))
102104>>>>>        End
102104>>>>>>
102104>>>>>
102104>>>>>        Get psSavedFormValues to sSavedFormValues
102105>>>>>        Move (SizeOfArray(sSavedFormValues)) to iSize
102106>>>>>        Decrement iSize
102107>>>>>
102107>>>>>        For iCount from 0 to iSize
102113>>>>>>
102113>>>>>            Move sSavedFormValues[iCount] to sValue
102114>>>>>            Move (Trim(sValue)) to sValue
102115>>>>>            Get vFilePathExists sValue to bExists
102116>>>>>            If (bExists = True) Begin
102118>>>>>                Send WriteString of hoIniFile (CS_cSuggestionFormList * String(sObjectName)) (CS_cSuggestionSaveItem + String(iCount)) sSavedFormValues[iCount]
102119>>>>>            End
102119>>>>>>
102119>>>>>        Loop
102120>>>>>>
102120>>>>>
102120>>>>>        Send Destroy of hoIniFile
102121>>>>>    End_Procedure
102122>>>>>
102122>>>>>    Procedure OnExitObject
102124>>>>>        String sValue
102124>>>>>        Boolean bExists
102124>>>>>        String[] sSavedFormValues
102125>>>>>        Integer iSize iIndex
102125>>>>>
102125>>>>>        Forward Send OnExitObject
102127>>>>>
102127>>>>>        If (pbUseWorkspaceIniFile(Self) = False) Begin
102129>>>>>            Procedure_Return
102130>>>>>        End
102130>>>>>>
102130>>>>>
102130>>>>>        Get Value to sValue
102131>>>>>        Move (Trim(sValue)) to sValue
102132>>>>>        Get psSavedFormValues to sSavedFormValues
102133>>>>>        Move (SearchArray(sValue, sSavedFormValues)) to iIndex
102134>>>>>        // Does it exist in the array already?
102134>>>>>        If (iIndex <> -1) Begin
102136>>>>>            Procedure_Return
102137>>>>>        End
102137>>>>>>
102137>>>>>        Get vFilePathExists sValue to bExists
102138>>>>>        If (bExists = False) Begin
102140>>>>>            Procedure_Return
102141>>>>>        End
102141>>>>>>
102141>>>>>        Move (SizeOfArray(sSavedFormValues)) to iSize
102142>>>>>        Move sValue to sSavedFormValues[iSize]
102143>>>>>        Set psSavedFormValues to sSavedFormValues
102144>>>>>        Send WriteWorkspaceIniFile
102145>>>>>    End_Procedure
102146>>>>>
102146>>>>>    // Custom code to find all matches for the search
102146>>>>>    Procedure OnFindSuggestions String sSearch tSuggestion[] ByRef aSuggestions
102148>>>>>        String[] sSavedFormValues
102149>>>>>        Integer i iLen iSize iCount
102149>>>>>
102149>>>>>        Move (Lowercase(sSearch)) to sSearch
102150>>>>>        Move (Length(sSearch)) to iLen
102151>>>>>        Get psSavedFormValues to sSavedFormValues
102152>>>>>        Move (SizeOfArray(sSavedFormValues)) to iSize
102153>>>>>        Decrement iSize
102154>>>>>        For i from 0 to iSize
102160>>>>>>
102160>>>>>            If (Lowercase(sSavedFormValues[i]) contains sSearch) Begin
102162>>>>>                Move sSavedFormValues[i] to aSuggestions[iCount].sRowId
102163>>>>>                Move sSavedFormValues[i] to aSuggestions[iCount].aValues[0]
102164>>>>>                Increment iCount
102165>>>>>            End
102165>>>>>>
102165>>>>>        Loop
102166>>>>>>
102166>>>>>    End_Procedure
102167>>>>>
102167>>>>>    Procedure OnSelectSuggestion String sSearch tSuggestion Suggestion
102169>>>>>        Boolean bExists bAutoCheckValueExistsAsFile bAskToRemoveMissingFile
102169>>>>>        Integer iRetval iIndex
102169>>>>>        String[] sSavedFormValues
102170>>>>>        String sValue
102170>>>>>
102170>>>>>//        Send Release_Mouse_Capture
102170>>>>>        Move Suggestion.sRowId to sValue
102171>>>>>        Move (Trim(sValue)) to sValue
102172>>>>>        Get pbAutoCheckValueExistsAsFile to bAutoCheckValueExistsAsFile
102173>>>>>
102173>>>>>        If (bAutoCheckValueExistsAsFile = True) Begin
102175>>>>>            Get pbAskToRemoveMissingFile to bAskToRemoveMissingFile
102176>>>>>            Get vFilePathExists sValue to bExists
102177>>>>>            If (bExists = False) Begin
102179>>>>>                If (bAskToRemoveMissingFile = True) Begin
102181>>>>>                    Get YesNo_Box ("The file" * String(sValue) + "\nDoesn't exist. Do you want to remove it from the suggestion list?") to iRetval
102182>>>>>                End
102182>>>>>>
102182>>>>>                // This will happen if bAskToRemoveMissingFile = False, and bAutoCheckValueExistsAsFile = True.
102182>>>>>                // Then the missing file will just be removed from the saved list.
102182>>>>>                Else Begin
102183>>>>>                    Move MBR_Yes to iRetval
102184>>>>>                End
102184>>>>>>
102184>>>>>
102184>>>>>                If (iRetval = MBR_Yes) Begin
102186>>>>>                    Get psSavedFormValues to sSavedFormValues
102187>>>>>                    Move (SearchArray(sValue, sSavedFormValues)) to iIndex
102188>>>>>                    If (iIndex <> -1) Begin
102190>>>>>                        Move (RemoveFromArray(sSavedFormValues, iIndex)) to sSavedFormValues
102191>>>>>                        Set psSavedFormValues to sSavedFormValues
102192>>>>>                        Send WriteWorkspaceIniFile
102193>>>>>                        Set Value to ""
102194>>>>>                        Procedure_Return
102195>>>>>                    End
102195>>>>>>
102195>>>>>                End
102195>>>>>>
102195>>>>>            End
102195>>>>>>
102195>>>>>        End
102195>>>>>>
102195>>>>>
102195>>>>>        Set Value to Suggestion.sRowId
102196>>>>>        Set Item_Changed_State to False
102197>>>>>    End_Procedure
102198>>>>>
102198>>>>>//    { MethodType=Event  NoDoc=True }
102198>>>>>//    Procedure Mouse_Click Integer i1 Integer i2
102198>>>>>//        Send Release_Mouse_Capture
102198>>>>>//        Forward Send Mouse_click i1 i2
102198>>>>>//    End_Procedure
102198>>>>>
102198>>>>>End_Class
102199>>>>>
102199>>>>>//    Procedure Mouse_Up for cSuggestionList Integer iWindowNumber Integer iPosition
102199>>>>>//        Handle hoObj
102199>>>>>//        Send Release_Mouse_Capture
102199>>>>>//        Get phoOwner to hoObj
102199>>>>>//        Send Activate of hoObj // move focus to owner, which will close the list
102199>>>>>//        Send SelectSuggestion of hoObj
102199>>>>>//    End_Procedure // Mouse_Up
102199>>>>>
102199>>>>>//    Function OnWindowsHook for cSuggestionHookMouse Integer i1 Integer i2 Integer i3 Returns Integer
102199>>>>>//        tWinMouseHookStruct MouseHook
102199>>>>>//        Integer ivoid hObj
102199>>>>>//        Handle hoOwner hoParent
102199>>>>>//        If (i1=0 and (i2=WM_LBUTTONDOWN or i2=WM_RBUTTONDOWN or i2=WM_MBUTTONDOWN or ;
102199>>>>>//                      i2=WM_NCLBUTTONDOWN or i2=WM_NCRBUTTONDOWN or i2=WM_NCMBUTTONDOWN)) Begin
102199>>>>>//            Send Release_Mouse_Capture
102199>>>>>//            Move (CopyMemory(AddressOf(MouseHook), i3, SizeOfType(tWinMouseHookStruct))) to iVoid
102199>>>>>//            GET_OBJECT_FROM_WINDOW MouseHook.hwnd to hObj
102199>>>>>//            If (hObj = Cursor_Control) Begin
102199>>>>>//                Move (Focus(Desktop)) to hObj
102199>>>>>//            End
102199>>>>>//            Get Parent to hoParent
102199>>>>>//            Get phoOwner of hoParent to hoOwner
102199>>>>>//            If (not(hObj) or (hObj<>hoParent and hObj<>hoOwner)) Begin
102199>>>>>//                Send DisableWindowsHook
102199>>>>>//                Send DeActivateSuggestionList of hoOwner
102199>>>>>//            End
102199>>>>>//        End
102199>>>>>//    End_Function
102199>>>>>
102199>>>Use cSQLCheckBox.pkg
102199>>>
102199>>>Define CS_ReportFileName                for "DUFCompareReport"
102199>>>Define CS_ReportFileNameExtenstion      for ".txt"
102199>>>Define CS_ReportDifferenceNote          for "(*)"
102199>>>Define CS_ReportTableNotFound           for "Table doesn't exist!"
102199>>>Define CS_ReportFieldNotFound           for "Field doesn't exist!"
102199>>>Define CS_ReportIndexNotFound           for "Index doesn't exist!"
102199>>>Define CS_ReportIndexSegmentNotFound    for "Index segment doesn't exist!"
102199>>>Define CS_ReportIndexNotApplicable      for "N/A"
102199>>>Define CS_ReportRelationNotFound        for "Relationship doesn't exist!"
102199>>>Define CS_ReportHeaderUnderWrite        for "===================================================================================="
102199>>>
102199>>>Define CI_ReportColumn1                 for 17
102199>>>Define CI_ReportColumn2                 for 65
102199>>>//Define CI_ReportColumn3                 for 75
102199>>>//Define CI_ReportColumn4                 for 90
102199>>>
102199>>>Struct tRelationDiffs
102199>>>    String sFromFieldsRight
102199>>>    String sFromFields
102199>>>    String sToFields
102199>>>    String sFrom
102199>>>    String sTo
102199>>>End_Struct
102199>>>
102199>>>Global_Variable Integer giDifferenceTables
102199>>>
102199>>>Activate_View Activate_oCompareDatabases_vw for oCompareDatabases_vw
102209>>>>
102209>>>Object oCompareDatabases_vw is a dbView
102211>>>    Set Size to 311 492
102212>>>    Set Label to "Compare Databases"
102213>>>    Set piMinSize to 89 211
102214>>>    Set Location to 2 2
102215>>>    Set Border_Style To Border_Thick
102216>>>    Set pbAutoActivate to True
102217>>>    Set Icon to "DbCompareBlack2.ico"
102218>>>    Set Color to clWhite
102219>>>
102219>>>    Object oFromFilelist_grp is a cHeaderGroup
102221>>>        Set Size to 43 462
102222>>>        Set Location to 8 19
102223>>>        Set psImage to "ActionOpenBlack.ico"
102224>>>        Set psLabel to "Select FROM Filelist.cfg"
102225>>>
102225>>>        Object oFilelistPathFrom_fm is a cSuggestionIniForm
102227>>>            Set Size to 13 413
102228>>>            Set Location to 21 25
102229>>>            Set Label_Col_Offset to 0
102230>>>            Set Label_Row_Offset to 1
102231>>>            Set Label_Justification_Mode to JMode_Top
102232>>>            Set Prompt_Button_Mode to PB_PromptOn
102233>>>            Set peAnchors to anTopLeftRight
102234>>>            Set psToolTip to "Select the FROM database Filelist.cfg. This should be the development workspace Data folder's Filelist.cfg"
102235>>>            // This is needed for the toolbar's prompt icon to be active
102235>>>            Set Prompt_Object to Self
102236>>>
102236>>>            Procedure Prompt
102239>>>                String sFileName sPath sFileMask sRetval
102239>>>
102239>>>                Get Value to sFileName
102240>>>                Get ParseFolderName sFileName to sPath
102241>>>                Move "Filelist.cfg files (*.cfg)|*.cfg" to sFileMask
102242>>>                Get vSelect_File sFileMask "Please select a Filelist.cfg file" sPath to sRetval
102243>>>                If (sRetval <> "") Begin
102245>>>                    Set Value to sRetval
102246>>>                End
102246>>>>
102246>>>            End_Procedure
102247>>>
102247>>>            Procedure OnChange
102250>>>                String sValue
102250>>>                Boolean bOK bCfgFile
102250>>>
102250>>>                Get Value to sValue
102251>>>                Get vFilePathExists sValue to bOK
102252>>>                Move (Lowercase(sValue) contains ".cfg") to bCfgFile
102253>>>                If (bOK = True and bCfgFile) Begin
102255>>>                    Get ChangeFilelistPathing of ghoApplication sValue to bOK
102256>>>                    If (bOK = True) Begin
102258>>>                        Set psFilelistFrom of ghoApplication to sValue
102259>>>                    End
102259>>>>
102259>>>                End
102259>>>>
102259>>>
102259>>>            End_Procedure
102260>>>
102260>>>            On_Key Key_Ctrl+Key_W Send None
102261>>>            On_Key Key_Ctrl+Key_Q Send None
102262>>>        End_Object
102263>>>
102263>>>    End_Object
102264>>>
102264>>>    Object oToFilelist_grp is a cHeaderGroup
102266>>>        Set Size to 43 462
102267>>>        Set Location to 60 19
102268>>>        Set psImage to "ActionOpenBlack.ico"
102269>>>        Set psLabel to "Select TO Filelist.cfg"
102270>>>
102270>>>        Object oFilelistPathTo_fm is a cSuggestionIniForm
102272>>>            Set Size to 13 413
102273>>>            Set Location to 21 25
102274>>>            Set Label_Col_Offset to 0
102275>>>            Set Label_Row_Offset to 1
102276>>>            Set Label_Justification_Mode to JMode_Top
102277>>>            Set Prompt_Button_Mode to PB_PromptOn
102278>>>            Set peAnchors to anTopLeftRight
102279>>>            Set psToolTip to "Select the TO database Filelist.cfg"
102280>>>            Set Prompt_Object to Self
102281>>>
102281>>>            Procedure Prompt
102284>>>                String sFileName sPath sFileMask sRetval
102284>>>
102284>>>                Get Value to sFileName
102285>>>                Get ParseFolderName sFileName to sPath
102286>>>                Move "Filelist.cfg files (*.cfg)|*.cfg" to sFileMask
102287>>>                Get vSelect_File sFileMask "Please select a Filelist.cfg file" sPath to sRetval
102288>>>                If (sRetval <> "") Begin
102290>>>                    Set Value to sRetval
102291>>>                End
102291>>>>
102291>>>            End_Procedure
102292>>>
102292>>>            Procedure OnChange
102295>>>                String sValue sPath sReportName sToday
102295>>>                Date dToday
102295>>>                Boolean bOK bCfgFile
102295>>>
102295>>>                Get Value to sValue
102296>>>                Get vFilePathExists sValue to bOK
102297>>>                Move (Lowercase(sValue) contains ".cfg") to bCfgFile
102298>>>                If (bOK = False or bCfgFile = False) Begin
102300>>>                    Procedure_Return
102301>>>                End
102301>>>>
102301>>>
102301>>>                Set psFilelistFrom of ghoApplication to sValue
102302>>>                Sysdate dToday
102303>>>                Move (Replaces("/", dToday, "-")) to sToday
102304>>>                Move (Replaces(".", dToday, "-")) to sToday
102305>>>                Get Value to sPath
102306>>>                Get ParseFolderName sPath to sPath
102307>>>                Get vFolderFormat   sPath to sPath
102308>>>                Move (sPath + CS_ReportFileName + String(sToday) + CS_ReportFileNameExtenstion) to sReportName
102309>>>                Set Value of oReportFileName_fm to sReportName
102310>>>            End_Procedure
102311>>>
102311>>>            On_Key Key_Ctrl+Key_W Send None
102312>>>            On_Key Key_Ctrl+Key_Q Send None
102313>>>        End_Object
102314>>>
102314>>>    End_Object
102315>>>
102315>>>    Object oCompareProperties_grp is a cHeaderGroup
102317>>>        Set Size to 56 462
102318>>>        Set Location to 112 19
102319>>>        Set psImage to "SettingsBlack.ico"
102320>>>        Set psLabel to "Compare Options"
102321>>>
102321>>>        Object oCompareDate_DataTime_cb is a cSQLCheckBox
102323>>>            Set Auto_Size_State to False
102324>>>            Set Size to 9 123
102325>>>            Set Location to 25 26
102326>>>            Set Label to "Check Date/DataTime difference"
102327>>>            Set psToolTip to "Check Date to DateTime column differences"
102328>>>            Set Checked_State to False
102329>>>            Set Color to clWhite
102330>>>        End_Object
102331>>>
102331>>>        Object oCompareIndexAscending_cb is a cSQLCheckBox
102333>>>            Set Auto_Size_State to False
102334>>>            Set Size to 9 134
102335>>>            Set Location to 25 153
102336>>>            Set Label to "Check Index Ascending/Descending"
102337>>>            Set Checked_State to False
102338>>>            Set psToolTip to "Compare if Index is Ascending/Descending. (In SQL this setting is set for the whole database by selecting a 'Collation', so then checking this per table doesn't make sense)"
102339>>>            Set Color to clWhite
102340>>>        End_Object
102341>>>
102341>>>        Object oCompareIndexUppercase_cb is a cSQLCheckBox
102343>>>            Set Auto_Size_State to False
102344>>>            Set Size to 9 117
102345>>>            Set Location to 25 292
102346>>>            Set Label to "Check Index Lower/Uppercase"
102347>>>            Set Checked_State to False
102348>>>            Set psToolTip to "Compare if Index is Uppercase/Lowercase. (In SQL this setting is set for the whole database by selecting a 'Collation', so then checking this per table doesn't make sense)"
102349>>>            Set Color to clWhite
102350>>>        End_Object
102351>>>
102351>>>        Object oIgnoreFilelistUppercase_cb is a cSQLCheckBox
102353>>>            Set Auto_Size_State to False
102354>>>            Set Size to 9 210
102355>>>            Set Location to 38 26
102356>>>            Set Label to "Ignore Filelist Entries Uppercase/Lowercase"
102357>>>            Set Checked_State to True
102358>>>            Set psToolTip to "Check Filelist.cfg RootName, LogicalName and DisplayName uppercase/lowercase differences"
102359>>>            Set Color to clWhite
102360>>>        End_Object
102361>>>
102361>>>    End_Object
102362>>>
102362>>>    Object oReportFilename_grp is a cHeaderGroup
102364>>>        Set Size to 43 462
102365>>>        Set Location to 178 19
102366>>>        Set psImage to "ActionPrintBlack.ico"
102367>>>        Set psLabel to "Compare Report File Name"
102368>>>
102368>>>        Object oReportFileName_fm is a Form
102370>>>            Set Size to 13 413
102371>>>            Set Location to 21 25
102372>>>            Set Label_Col_Offset to 0
102373>>>            Set Label_Row_Offset to 1
102374>>>            Set Label_Justification_Mode to JMode_Top
102375>>>            Set Prompt_Button_Mode to PB_PromptOn
102376>>>            Set peAnchors to anTopLeftRight
102377>>>            Set psToolTip to "The name of the output text file for database differences that will be generated"
102378>>>            Set Status_Help to "The name of the output text file for database differences that will be generated"
102379>>>            Set Prompt_Object to Self
102380>>>
102380>>>            Procedure Prompt
102383>>>                String sFileName sPath sFileMask sRetval
102383>>>
102383>>>                Get Value to sFileName
102384>>>                Get ParseFolderName sFileName to sPath
102385>>>                Move "Text files (*.txt)|*.txt" to sFileMask
102386>>>                Get vSelect_File sFileMask "Please select a text file for the report" sPath to sRetval
102387>>>                If (sRetval <> "") Begin
102389>>>                    Set Value to sRetval
102390>>>                End
102390>>>>
102390>>>            End_Procedure
102391>>>
102391>>>            On_Key Key_Ctrl+Key_W Send None
102392>>>            On_Key Key_Ctrl+Key_Q Send None
102393>>>        End_Object
102394>>>
102394>>>    End_Object
102395>>>
102395>>>    Procedure MainProcess
102398>>>        String sFilelistFrom sFilelistTo
102398>>>        Integer[] iaDifferences
102399>>>        Integer iSize iRetval hTable
102399>>>        Boolean bFromExists bToExists
102399>>>        tAPITableBooleans CompareCheckBoxes
102399>>>        tAPITableBooleans CompareCheckBoxes
102399>>>        DateTime dtExecStart dtExecEnd
102399>>>        TimeSpan tsTotalTime
102399>>>
102399>>>        Move (CurrentDateTime()) to dtExecStart
102400>>>        Get Value of oFilelistPathFrom_fm to sFilelistFrom
102401>>>        Get vFilePathExists sFilelistFrom to bFromExists
102402>>>        Get Value of oFilelistPathTo_fm   to sFilelistTo
102403>>>        Get vFilePathExists sFilelistTo   to bToExists
102404>>>
102404>>>        If (bFromExists = False or bToExists = False) Begin
102406>>>            Send Info_Box "You first need to select a 'FROM' and a 'TO' Filelist.cfg."
102407>>>            Procedure_Return
102408>>>        End
102408>>>>
102408>>>
102408>>>        Move 0 to giDifferenceTables
102409>>>        Get Checked_State of oCompareDate_DataTime_cb    to CompareCheckBoxes.bCompareDate_DateTime
102410>>>        Get Checked_State of oCompareIndexAscending_cb   to CompareCheckBoxes.bCompareIndexAscending
102411>>>        Get Checked_State of oCompareIndexUppercase_cb   to CompareCheckBoxes.bCompareIndexUppercase
102412>>>        Get Checked_State of oIgnoreFilelistUppercase_cb to CompareCheckBoxes.bCompareFilelistUppercase
102413>>>
102413>>>        Get CompareAndOutputDiffs sFilelistFrom sFilelistTo CompareCheckBoxes dtExecStart to iaDifferences
102414>>>        Set piaDifferences of ghoApplication to iaDifferences
102415>>>
102415>>>        Send Stop_StatusPanel of ghoStatusPanel
102416>>>        Move (CurrentDateTime()) to dtExecEnd
102417>>>        Move (dtExecEnd - dtExecStart) to tsTotalTime
102418>>>        Move (SizeOfArray(iaDifferences)) to iSize
102419>>>
102419>>>        Case Begin
102419>>>            Case (iSize = 0)
102421>>>                Send Info_Box "No differences found. The two databases should be identical."
102422>>>                Case Break
102423>>>            Case (iaDifferences[0] >= 1)
102426>>>                Get YesNo_Box ("Ready! (Time elapsed:" * String(tsTotalTime) + ")\n" + String(iSize) * "Differences found. View the report now?") to iRetval
102427>>>                If (iRetval = MBR_Yes) Begin
102429>>>                    Send KeyAction of oViewReport_Btn
102430>>>                End
102430>>>>
102430>>>                Case Break
102431>>>            Case (iaDifferences[0] = -1)
102434>>>                Send Info_Box "Process interrupted."
102435>>>                Case Break
102436>>>            Case (iaDifferences[0] < -1)
102439>>>                Move iaDifferences[0]  to hTable
102440>>>                Move (999999 + hTable * -1) to hTable
102441>>>                Send Info_Box ("Process stopped. Couldn't open table number:" * String(hTable))
102442>>>                Case Break
102443>>>            Case Else
102443>>>                Send Info_Box "An unknown error occured. Process interrupted."
102444>>>        Case End
102444>>>
102444>>>        Send Activate of oFilelistPathFrom_fm
102445>>>    End_Procedure
102446>>>
102446>>>    Function CompareAndOutputDiffs String sFilelistFrom String sFilelistTo tAPITableBooleans CompareCheckBoxes DateTime dtExecStart Returns Integer[]
102449>>>        Integer iSize iCount iNoOfTablesFrom iNoOfTablesTo iCh
102449>>>        Boolean bIsSame bFilelistError bUserCancel bOK bCollationDiff
102449>>>        Handle hTable
102449>>>        String sLogicalName sDatabaseCollationFrom sDatabaseCollationTo sDatabase
102449>>>        tAPITable[] aFromStructure aToStructure
102449>>>        tAPITable[] aFromStructure aToStructure
102451>>>        tAPITableCompare[] aAPITableCompare
102451>>>        tAPITableCompare[] aAPITableCompare
102452>>>        Integer[] iaDifferences iaDifferencesEmpty 
102454>>>
102454>>>        Set Message_Text of ghoStatusPanel to ""
102455>>>        // Set up the pathing correctly for the 'FROM' Filelist.cfg so we can open tables:
102455>>>        Get ChangeFilelistPathing of ghoApplication sFilelistFrom to bOK
102456>>>        If (bOK = False) Begin
102458>>>            Move -1 to iaDifferencesEmpty[0]
102459>>>            Function_Return iaDifferencesEmpty
102460>>>        End
102460>>>>
102460>>>        Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase
102461>>>        Get SqlDatabaseCollationQuery of ghoDbUpdateFunctionLibrary sDatabase to sDatabaseCollationFrom
102462>>>
102462>>>        Get UtilFilelistNoOfTables of ghoDbUpdateFunctionLibrary to iNoOfTablesFrom
102463>>>        Set pbVisible   of ghoProgressBar        to True
102464>>>        Set piPosition  of ghoProgressBar        to 0
102465>>>        Set piAdvanceBy of ghoProgressBar        to 1
102466>>>        Set pbVisible   of ghoProgressBarOverall to True
102467>>>        Set piPosition  of ghoProgressBarOverall to 0
102468>>>        Set piAdvanceBy of ghoProgressBarOverall to 1
102469>>>        Set piMaximum   of ghoProgressBarOverall to iNoOfTablesFrom
102470>>>        
102470>>>        // *** Fill the 'FROM' structure with data: (1 of 3)
102470>>>        Get UtilTablesStructArrayFill of ghoDbUpdateFunctionLibrary True True True to aFromStructure
102471>>>        // Process cancelled by user?
102471>>>        If (aFromStructure[0].bCancel = True) Begin
102473>>>            Move -1 to iaDifferencesEmpty[0]
102474>>>            Function_Return iaDifferencesEmpty
102475>>>        End
102475>>>>
102475>>>        // Error while filling struct array (Table could not be opened)?
102475>>>        If (aFromStructure[0].bError = True) Begin
102477>>>            Move aFromStructure[0].ApiTableInfo.iTableNumber to hTable
102478>>>            Move (-999999 - hTable) to iaDifferencesEmpty[0]
102479>>>            Function_Return iaDifferencesEmpty
102480>>>        End
102480>>>>
102480>>>
102480>>>        // Set up the pathing correctly for the 'TO' Filelist.cfg so we can open tables from the other workspace:
102480>>>        Get ChangeFilelistPathing of ghoApplication sFilelistTo to bOK
102481>>>        If (bOK = False) Begin
102483>>>            Move -1 to iaDifferencesEmpty[0]
102484>>>            Function_Return iaDifferencesEmpty
102485>>>        End
102485>>>>
102485>>>        Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase
102486>>>        Get SqlDatabaseCollationQuery of ghoDbUpdateFunctionLibrary sDatabase to sDatabaseCollationTo
102487>>>
102487>>>        Get UtilFilelistNoOfTables of ghoDbUpdateFunctionLibrary to iNoOfTablesTo
102488>>>        Set piMaximum of ghoProgressBarOverall to iNoOfTablesTo
102489>>>        Set piAdvanceBy of ghoProgressBarOverall to 1
102490>>>
102490>>>        // *** Fill the 'TO' structure with data: (2 of 3)
102490>>>        Get UtilTablesStructArrayFill of ghoDbUpdateFunctionLibrary True True False to aToStructure
102491>>>        // Process cancelled by user?
102491>>>        If (aToStructure[0].bCancel = True) Begin
102493>>>            Move -1 to iaDifferencesEmpty[0]
102494>>>            Function_Return iaDifferencesEmpty
102495>>>        End
102495>>>>
102495>>>        // Error while filling struct array (Table could not be opened)?
102495>>>        If (aToStructure[0].bError = True) Begin
102497>>>            Move aToStructure[0].ApiTableInfo.iTableNumber to hTable
102498>>>            Move (-999999 - hTable) to iaDifferencesEmpty[0]
102499>>>            Function_Return iaDifferencesEmpty
102500>>>        End
102500>>>>
102500>>>
102500>>>        Set Message_Text of ghoStatusPanel to "Comparing and Writing Differences: (3 of 3)"
102501>>>        Move 0 to hTable
102502>>>        Move 0 to iCount
102503>>>        Get WriteReportHeader sDatabaseCollationFrom sDatabaseCollationTo to iCh
102504>>>
102504>>>        Get UtilTableCombineFromAndToArrays of ghoDbUpdateFunctionLibrary aFromStructure aToStructure to aAPITableCompare
102505>>>        Move (SizeOfArray(aAPITableCompare))   to iSize
102506>>>        Set piMaximum of ghoProgressBar        to iSize
102507>>>        Set piMaximum of ghoProgressBarOverall to iSize
102508>>>        Decrement iSize
102509>>>
102509>>>        For iCount from 0 to iSize
102515>>>>
102515>>>            Move True to bIsSame
102516>>>            Set piPosition of ghoProgressBarOverall to iCount
102517>>>            Move aAPITableCompare[iCount].hTable to hTable
102518>>>
102518>>>            If (aAPITableCompare[iCount].bExistsFrom = True) Begin
102520>>>                Move aAPITableCompare[iCount].APITableNameInfoCompare.sLogicalNameFrom to sLogicalName
102521>>>            End
102521>>>>
102521>>>            Else Begin
102522>>>                Move aAPITableCompare[iCount].APITableNameInfoCompare.sLogicalNameTo   to sLogicalName
102523>>>            End
102523>>>>
102523>>>            Set Action_Text of ghoStatusPanel to ("Name:" * sLogicalName * String("Number:") * String(hTable))
102524>>>
102524>>>            Get UtilTableCompare_Ex of ghoDbUpdateFunctionLibrary aAPITableCompare[iCount] CompareCheckBoxes False (&bFilelistError) to bIsSame
102525>>>
102525>>>            If (bIsSame = False) Begin
102527>>>                Send MainReport (&aAPITableCompare[iCount]) (&CompareCheckBoxes) iCh
102528>>>                Move hTable to iaDifferences[SizeOfArray(iaDifferences)]
102529>>>            End
102529>>>>
102529>>>
102529>>>            Get Check_StatusPanel of ghoStatusPanel to bUserCancel
102530>>>            If (bUserCancel = True) Begin
102532>>>                Move -1 to iaDifferencesEmpty[0]
102533>>>                Function_Return iaDifferencesEmpty
102534>>>            End
102534>>>>
102534>>>        Until (hTable = 0)
102536>>>        
102536>>>        Move False to bCollationDiff
102537>>>        If (Uppercase(sDatabaseCollationFrom) <> Uppercase(sDatabaseCollationTo)) Begin
102539>>>            Move True to bCollationDiff
102540>>>        End
102540>>>>
102540>>>        Send WriteReportFooter (SizeOfArray(iaDifferences)) bCollationDiff iCh dtExecStart
102541>>>        Close DF_ALL DF_PERMANENT
102542>>>
102542>>>        Function_Return iaDifferences
102543>>>    End_Function
102544>>>
102544>>>    Procedure MainReport tAPITableCompare ByRef aAPITableCompare tAPITableBooleans ByRef CompareCheckBoxes Integer iCh
102547>>>        String sDriverIDFrom sDriverIDTo sLogicalName sFrom sTo
102547>>>        Handle hTable
102547>>>        Boolean bCompareDate_DateTime bCompareIndexUppercase bCompareIndexAscending bCompareFilelistUppercase
102547>>>        Boolean bExistsFrom bExistsTo bIsSQLFrom bIsSQLTo
102547>>>
102547>>>        Move CompareCheckBoxes.bCompareDate_DateTime     to bCompareDate_DateTime
102548>>>        Move CompareCheckBoxes.bCompareIndexAscending    to bCompareIndexAscending
102549>>>        Move CompareCheckBoxes.bCompareIndexUppercase    to bCompareIndexUppercase
102550>>>        Move CompareCheckBoxes.bCompareFilelistUppercase to bCompareFilelistUppercase
102551>>>
102551>>>        Move aAPITableCompare.bExistsFrom                            to bExistsFrom
102552>>>        Move aAPITableCompare.bExistsTo                              to bExistsTo
102553>>>        Move aAPITableCompare.APITableNameInfoCompare.bIsSQLFrom     to bIsSQLFrom
102554>>>        Move aAPITableCompare.APITableNameInfoCompare.bIsSQLTo       to bIsSQLTo
102555>>>        Move aAPITableCompare.APITableNameInfoCompare.sDriverIDFrom  to sDriverIDFrom
102556>>>        Move aAPITableCompare.APITableNameInfoCompare.sDriverIDTo    to sDriverIDTo
102557>>>        Move aAPITableCompare.APITableNameInfoCompare.iTableNumber   to hTable
102558>>>
102558>>>        If (aAPITableCompare.bExistsFrom = True) Begin
102560>>>            Move aAPITableCompare.APITableNameInfoCompare.sLogicalNameFrom to sLogicalName
102561>>>        End
102561>>>>
102561>>>        Else Begin
102562>>>            Move (aAPITableCompare.APITableNameInfoCompare.sLogicalNameTo) to sLogicalName
102563>>>        End
102563>>>>
102563>>>
102563>>>        Send WriteTableInfoDiff aAPITableCompare.APITableNameInfoCompare bCompareFilelistUppercase iCh
102564>>>        If (aAPITableCompare.bExistsFrom = True and aAPITableCompare.bExistsTo = True) Begin
102566>>>            Send WriteColumnDiffs sDriverIDFrom sDriverIDTo hTable sLogicalName bIsSQLFrom bIsSQLTo aAPITableCompare.aAPIColumnsCompare bCompareDate_DateTime iCh
102567>>>            Send WriteIndexDiffs hTable bIsSQLFrom bIsSQLTo sLogicalName aAPITableCompare.aAPIIndexesCompare bCompareIndexUppercase bCompareIndexAscending iCh
102568>>>            Send WriteRelationDiffs hTable aAPITableCompare.aAPIRelationsCompare iCh
102569>>>        End
102569>>>>
102569>>>
102569>>>    End_Procedure
102570>>>
102570>>>    Function WriteReportHeader String sDatabaseCollationFrom String sDatabaseCollationTo Returns Integer
102573>>>        Integer iCh
102573>>>        String sFilelistFrom sFilelistTo sReportName //sDriverIDFrom sDriverIDTo sLogicalName sFrom sTo sRootName sTableName
102573>>>        DateTime dtCreationTime    
102573>>>
102573>>>        Get Value of oReportFileName_fm to sReportName
102574>>>        Get Seq_Open_Output_Channel sReportName to iCh
102575>>>        If (iCh = DF_SEQ_CHANNEL_ERROR) Begin
102577>>>            Send Stop_Box "Sorry, couldn't retrieve a free channel number."
102578>>>            Procedure_Return
102579>>>        End                   
102579>>>>
102579>>>        
102579>>>        If (Uppercase(sDatabaseCollationFrom) <> Uppercase(sDatabaseCollationTo)) Begin
102581>>>            Move (sDatabaseCollationTo * String("(*)")) to sDatabaseCollationTo
102582>>>        End
102582>>>>
102582>>>
102582>>>        Get Value of oFilelistPathFrom_fm to sFilelistFrom
102583>>>        Get Value of oFilelistPathTo_fm   to sFilelistTo
102584>>>        Move (CurrentDateTime()) to dtCreationTime
102585>>>
102585>>>        Writeln channel iCh CS_ReportHeaderUnderWrite
102588>>>        Writeln channel iCh CS_DatabaseUpdateFramework
102591>>>        Writeln channel iCh (" ***  DATABASE DIFFERENCES REPORT  ***")
102594>>>        Writeln channel iCh ""
102597>>>        Writeln channel iCh ("      Date & Time Printed       :" * String(dtCreationTime))
102600>>>        Writeln channel iCh ("      FROM Database Filelist.cfg:" * String(sFilelistFrom))
102603>>>        Writeln channel iCh ("      TO   Database Filelist.cfg:" * String(sFilelistTo))
102606>>>        Writeln channel iCh ("      FROM Database Collation   :" * String(sDatabaseCollationFrom))
102609>>>        Writeln channel iCh ("      TO   Database Collation   :" * String(sDatabaseCollationTo))
102612>>>        Writeln channel iCh ""
102615>>>        Writeln channel iCh ("      Note: An asterisk in parenthesis (*) denotes a difference!")
102618>>>        Writeln channel iCh CS_ReportHeaderUnderWrite
102621>>>        Writeln channel iCh
102623>>>
102623>>>        Function_Return iCh
102624>>>    End_Function
102625>>>
102625>>>    // Note: The rootname will be first be stripped if it contains any driver id prefix.
102625>>>    Procedure WriteTableInfoDiff tAPITableNameInfoCompare APITableNameInfoCompare Boolean bCompareFilelistUppercase Integer iCh
102628>>>        String sLogicalName  sFrom sTo
102628>>>        Boolean bExistsFrom bExistsTo bIsSame
102628>>>        Handle hTable
102628>>>
102628>>>        Get UtilTableInfoCompare of ghoDbUpdateFunctionLibrary bCompareFilelistUppercase APITableNameInfoCompare to bIsSame
102629>>>        If (bIsSame = True) Begin
102631>>>            Procedure_Return
102632>>>        End
102632>>>>
102632>>>
102632>>>        Move APITableNameInfoCompare.iTableNumber to hTable
102633>>>        Move APITableNameInfoCompare.bExistsFrom  to bExistsFrom
102634>>>        Move APITableNameInfoCompare.bExistsTo    to bExistsTo
102635>>>        If (bExistsFrom = True) Begin
102637>>>            Move APITableNameInfoCompare.sLogicalNameFrom to sLogicalName
102638>>>        End
102638>>>>
102638>>>        If (bExistsTo = True) Begin
102640>>>            Move APITableNameInfoCompare.sLogicalNameTo   to sLogicalName
102641>>>        End
102641>>>>
102641>>>
102641>>>        Writeln channel iCh
102643>>>        Writeln channel iCh "Table Name Difference(s) Table Number: " hTable " - " sLogicalName
102649>>>        Writeln channel iCh CS_ReportHeaderUnderWrite
102652>>>
102652>>>        Move "FROM Database:" to sFrom
102653>>>        Get MakeStringLength sFrom CI_ReportColumn2 to sFrom
102654>>>        Move (sFrom + "TO Database:") to sFrom
102655>>>        Writeln channel iCh sFrom
102658>>>        Move (Repeat("-", Length(sFrom))) to sFrom
102659>>>        Writeln channel iCh sFrom
102662>>>
102662>>>        Move "Logical Name:"                                                to sFrom
102663>>>        Get MakeStringLength sFrom CI_ReportColumn1                         to sFrom
102664>>>        If (bExistsFrom = True) Begin
102666>>>            Move (sFrom + String(APITableNameInfoCompare.sLogicalNameFrom)) to sFrom
102667>>>        End
102667>>>>
102667>>>        If (bExistsFrom = False) Begin
102669>>>            Move (sFrom + CS_ReportTableNotFound * String(CS_ReportDifferenceNote)) to sFrom
102670>>>        End
102670>>>>
102670>>>        Get MakeStringLength sFrom CI_ReportColumn2                         to sFrom
102671>>>        If (bExistsTo = True) Begin
102673>>>            Move APITableNameInfoCompare.sLogicalNameTo                     to sTo
102674>>>        End
102674>>>>
102674>>>        If (bExistsTo = False)Begin
102676>>>            Move ""                                                         to sTo
102677>>>            Move (CS_ReportTableNotFound * String(CS_ReportDifferenceNote)) to sTo
102678>>>        End
102678>>>>
102678>>>        Writeln channel iCh sFrom sTo
102682>>>
102682>>>        Move "Root Name:"                                                   to sFrom
102683>>>        Get MakeStringLength sFrom CI_ReportColumn1                         to sFrom
102684>>>        If (bExistsFrom = True) Begin
102686>>>            Move (sFrom + String(APITableNameInfoCompare.sRootNameFrom))    to sFrom
102687>>>        End
102687>>>>
102687>>>        If (bExistsFrom = False) Begin
102689>>>            Move (sFrom + CS_ReportTableNotFound * String(CS_ReportDifferenceNote)) to sFrom
102690>>>        End
102690>>>>
102690>>>        Get MakeStringLength sFrom CI_ReportColumn2                         to sFrom
102691>>>        If (bExistsTo = True) Begin
102693>>>            Move APITableNameInfoCompare.sRootNameTo                        to sTo
102694>>>        End
102694>>>>
102694>>>        If (bExistsTo = False)Begin
102696>>>            Move ""                                                         to sTo
102697>>>            Move (CS_ReportTableNotFound * String(CS_ReportDifferenceNote)) to sTo
102698>>>        End
102698>>>>
102698>>>        Writeln channel iCh sFrom sTo
102702>>>
102702>>>        Move "Display Name:"                                                to sFrom
102703>>>        Get MakeStringLength sFrom CI_ReportColumn1                         to sFrom
102704>>>        If (bExistsFrom = True) Begin
102706>>>            Move (sFrom + String(APITableNameInfoCompare.sDisplayNameFrom)) to sFrom
102707>>>        End
102707>>>>
102707>>>        If (bExistsFrom = False) Begin
102709>>>            Move (sFrom + CS_ReportTableNotFound * String(CS_ReportDifferenceNote)) to sFrom
102710>>>        End
102710>>>>
102710>>>        Get MakeStringLength sFrom CI_ReportColumn2                         to sFrom
102711>>>        If (bExistsTo = True) Begin
102713>>>            Move APITableNameInfoCompare.sDisplayNameTo                     to sTo
102714>>>        End
102714>>>>
102714>>>        If (bExistsTo = False)Begin
102716>>>            Move ""                                                         to sTo
102717>>>            Move (CS_ReportTableNotFound * String(CS_ReportDifferenceNote)) to sTo
102718>>>        End
102718>>>>
102718>>>        Writeln channel iCh sFrom sTo
102722>>>
102722>>>        If (bExistsFrom = False or bExistsTo = False) Begin
102724>>>            Writeln channel iCh
102726>>>        End
102726>>>>
102726>>>        Writeln channel iCh
102728>>>    End_Procedure
102729>>>
102729>>>    Procedure WriteColumnDiffs String sDriverIDFrom String sDriverIDTo Handle hTable String sLogicalTableName Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare[] aAPIColumnCompare Boolean bCompareDate_DateTime Integer iCh
102732>>>        Integer iSize iCount
102732>>>        Boolean bIsSame bHeader
102732>>>        String sFrom sTo sTypeFrom sTypeTo
102732>>>
102732>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
102733>>>        If (iSize = 0) Begin
102735>>>            Procedure_Return
102736>>>        End
102736>>>>
102736>>>
102736>>>        Decrement iSize
102737>>>        For iCount from 0 to iSize
102743>>>>
102743>>>            Get UtilColumnCompare of ghoDbUpdateFunctionLibrary sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare[iCount] bCompareDate_DateTime to bIsSame
102744>>>            If (bIsSame = False) Begin
102746>>>
102746>>>                If (bHeader = False) Begin
102748>>>                    Writeln channel iCh "Field Difference(s) for Table Number: " (String(hTable)) " - " sLogicalTableName
102754>>>                    Writeln channel iCh CS_ReportHeaderUnderWrite
102757>>>                    Move "FROM Database:" to sFrom
102758>>>                    Get MakeStringLength sFrom CI_ReportColumn2 to sFrom
102759>>>                    Move (sFrom + "TO Database:") to sFrom
102760>>>                    Writeln channel iCh sFrom
102763>>>                    Move (Repeat("-", Length(sFrom))) to sFrom
102764>>>                    Writeln channel iCh sFrom
102767>>>                    Move True to bHeader
102768>>>                End
102768>>>>
102768>>>
102768>>>                Get MakeFromString "Field Number:" aAPIColumnCompare[iCount].iFieldNumber (CS_ReportFieldNotFound * CS_ReportDifferenceNote) ;                                 aAPIColumnCompare[iCount].bExistsFrom to sFrom
102769>>>                Get MakeToString aAPIColumnCompare[iCount].iFieldNumber "" (CS_ReportFieldNotFound * CS_ReportDifferenceNote) ;                                 aAPIColumnCompare[iCount].bExistsTo to sTo
102770>>>                Writeln channel iCh sFrom sTo
102774>>>
102774>>>                Get MakeFromString "Name" aAPIColumnCompare[iCount].sFieldNameFrom CS_ReportDifferenceNote aAPIColumnCompare[iCount].bExistsTo to sFrom
102775>>>                Get MakeToString aAPIColumnCompare[iCount].sFieldNameTo "" CS_ReportDifferenceNote (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) = ;                                 Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) to sTo
102776>>>                Writeln channel iCh sFrom sTo
102780>>>
102780>>>                Get MakeFromString "Type:" aAPIColumnCompare[iCount].sTypeFrom CS_ReportDifferenceNote aAPIColumnCompare[iCount].bExistsFrom to sFrom
102781>>>                Get MakeToString aAPIColumnCompare[iCount].sTypeTo "" CS_ReportDifferenceNote (Uppercase(aAPIColumnCompare[iCount].sTypeFrom) = ;                                 Uppercase(aAPIColumnCompare[iCount].sTypeTo)) to sTo
102782>>>                Writeln channel iCh sFrom sTo
102786>>>
102786>>>                Get MakeFromString "Length:" aAPIColumnCompare[iCount].iLengthFrom CS_ReportDifferenceNote aAPIColumnCompare[iCount].bExistsFrom to sFrom
102787>>>                Get MakeToString aAPIColumnCompare[iCount].iLengthTo "" CS_ReportDifferenceNote (aAPIColumnCompare[iCount].iLengthFrom = ;                                 aAPIColumnCompare[iCount].iLengthTo) to sTo
102788>>>                Writeln channel iCh sFrom sTo
102792>>>
102792>>>                Get MakeFromString "Precision:" aAPIColumnCompare[iCount].iPrecisionFrom CS_ReportDifferenceNote aAPIColumnCompare[iCount].bExistsFrom to sFrom
102793>>>                Get MakeToString aAPIColumnCompare[iCount].iPrecisionTo "" CS_ReportDifferenceNote (aAPIColumnCompare[iCount].iPrecisionFrom = ;                                 aAPIColumnCompare[iCount].iPrecisionTo) to sTo
102794>>>                Writeln channel iCh sFrom sTo
102798>>>
102798>>>                Get MakeFromString "Default Value:" aAPIColumnCompare[iCount].sDefaultValueFrom CS_ReportDifferenceNote aAPIColumnCompare[iCount].bExistsFrom to sFrom
102799>>>                Get MakeToString aAPIColumnCompare[iCount].sDefaultValueTo "" CS_ReportDifferenceNote (aAPIColumnCompare[iCount].sDefaultValueFrom = ;                                 aAPIColumnCompare[iCount].sDefaultValueTo) to sTo
102800>>>                Writeln channel iCh sFrom sTo
102804>>>
102804>>>                Get MakeFromString "Allow NULL:" (If(aAPIColumnCompare[iCount].bAllowNULLFrom = True, "Yes", "No")) CS_ReportDifferenceNote ;                                 aAPIColumnCompare[iCount].bExistsTo to sFrom
102805>>>                Get MakeToString (If(aAPIColumnCompare[iCount].bAllowNULLTo = True, "Yes", "No")) "" CS_ReportDifferenceNote ;                                 aAPIColumnCompare[iCount].bExistsTo to sTo
102806>>>                Writeln channel iCh sFrom sTo
102810>>>
102810>>>                Get MakeFromString "Identity Field:" (If(aAPIColumnCompare[iCount].iOptionsFrom = C_tAPIColumn_Identity, "Yes", "No")) CS_ReportDifferenceNote ;                                 aAPIColumnCompare[iCount].bExistsTo to sFrom
102811>>>                Get MakeToString (If(aAPIColumnCompare[iCount].iOptionsTo = C_tAPIColumn_Identity, "Yes", "No")) "" CS_ReportDifferenceNote ;                                 aAPIColumnCompare[iCount].bExistsTo to sTo
102812>>>                Writeln channel iCh sFrom sTo
102816>>>                Writeln channel iCh
102818>>>            End
102818>>>>
102818>>>        Loop
102819>>>>
102819>>>
102819>>>        If (bHeader = True) Begin
102821>>>            Writeln channel iCh ""
102824>>>        End
102824>>>>
102824>>>    End_Procedure
102825>>>
102825>>>    Procedure WriteIndexDiffs Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo String sLogicalTableName tAPIIndexCompare[] aAPIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Integer iCh
102828>>>        Integer iSize iCount iSegmentSizeFrom iSegmentSizeTo iCount2 iSize2 iFieldNumberFrom iFieldNumberTo
102828>>>        Integer iIndexNumberFrom iIndexNumberTo iPrimaryIndexFrom iPrimaryIndexTo
102828>>>        tAPIIndexSegment[] aApiIndexSegmentsFrom aApiIndexSegmentsTo aApiIndexSegmentsEmpty
102828>>>        tAPIIndexSegment[] aApiIndexSegmentsFrom aApiIndexSegmentsTo aApiIndexSegmentsEmpty
102831>>>        String sFrom sTo sSQLIndexTypeFrom sSQLIndexTypeTo sSQLIndexNameFrom sSQLIndexNameTo sFieldNameFrom sFieldNameTo
102831>>>        Boolean bIsSame bIsSQLPrimaryFrom bIsSQLPrimaryTo bIsSQLClusteredFrom bIsSQLClusteredTo bHeader
102831>>>
102831>>>        Move (SizeOfArray(aAPIIndexCompare)) to iSize
102832>>>        Decrement iSize
102833>>>
102833>>>        For iCount from 0 to iSize
102839>>>>
102839>>>            Get UtilIndexCompare of ghoDbUpdateFunctionLibrary bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexAscending bCompareIndexUppercase to bIsSame
102840>>>            If (bIsSame = False) Begin
102842>>>                If (bHeader = False) Begin
102844>>>                    Writeln channel iCh "Index Difference(s) for Table Number: " (String(hTable)) " - " sLogicalTableName
102850>>>                    Writeln channel iCh CS_ReportHeaderUnderWrite
102853>>>                    Move "FROM Database:" to sFrom
102854>>>                    Get MakeStringLength sFrom CI_ReportColumn2 to sFrom
102855>>>                    Move (sFrom + "TO Database:") to sFrom
102856>>>                    Writeln channel iCh sFrom
102859>>>                    Move (Repeat("-", Length(sFrom))) to sFrom
102860>>>                    Writeln channel iCh sFrom
102863>>>                    Move True to bHeader
102864>>>                End
102864>>>>
102864>>>
102864>>>                // FROM Index:
102864>>>                If (aAPIIndexCompare[iCount].bExistsFrom = True) Begin
102866>>>                    Move aAPIIndexCompare[iCount].iIndexNumber              to iIndexNumberFrom
102867>>>                    Move aAPIIndexCompare[iCount].iPrimaryIndexFrom         to iPrimaryIndexFrom
102868>>>                    Move aAPIIndexCompare[iCount].sSQLIndexNameFrom         to sSQLIndexNameFrom
102869>>>                    Move aAPIIndexCompare[iCount].bIsSQLPrimaryKeyFrom      to bIsSQLPrimaryFrom
102870>>>                    Move aAPIIndexCompare[iCount].bIsSQLClusteredFrom       to bIsSQLClusteredFrom
102871>>>                    Get UtilIndexTypeToString of ghoDbUpdateFunctionLibrary ;                         aAPIIndexCompare[iCount].iSQLIndexTypeFrom         to sSQLIndexTypeFrom
102872>>>                    Move aAPIIndexCompare[iCount].IndexSegmentArrayFrom     to aApiIndexSegmentsFrom
102873>>>                End
102873>>>>
102873>>>                Else Begin
102874>>>                    Move -1                                                 to iIndexNumberFrom
102875>>>                    Move -1                                                 to iPrimaryIndexFrom
102876>>>                    Move (String(CS_ReportDifferenceNote))                  to sSQLIndexNameFrom
102877>>>                    Move False                                              to bIsSQLPrimaryFrom
102878>>>                    Move False                                              to bIsSQLClusteredFrom
102879>>>                    Move (String(CS_ReportDifferenceNote))                  to sSQLIndexTypeFrom
102880>>>                    Move aApiIndexSegmentsEmpty                             to aApiIndexSegmentsFrom
102881>>>                End
102881>>>>
102881>>>
102881>>>                If (aAPIIndexCompare[iCount].bExistsTo = True) Begin
102883>>>                    Move aAPIIndexCompare[iCount].iIndexNumber              to iIndexNumberTo
102884>>>                    Move aAPIIndexCompare[iCount].iPrimaryIndexTo           to iPrimaryIndexTo
102885>>>                    Move aAPIIndexCompare[iCount].sSQLIndexNameTo           to sSQLIndexNameTo
102886>>>                    Move aAPIIndexCompare[iCount].bIsSQLPrimaryKeyTo        to bIsSQLPrimaryTo
102887>>>                    Move aAPIIndexCompare[iCount].bIsSQLClusteredTo         to bIsSQLClusteredTo
102888>>>                    Get UtilIndexTypeToString of ghoDbUpdateFunctionLibrary ;                        aAPIIndexCompare[iCount].iSQLIndexTypeTo            to sSQLIndexTypeTo
102889>>>                    Move aAPIIndexCompare[iCount].IndexSegmentArrayTo       to aApiIndexSegmentsTo
102890>>>                End
102890>>>>
102890>>>                Else Begin
102891>>>                    Move -1                                                 to iIndexNumberTo
102892>>>                    Move -1                                                 to iPrimaryIndexTo
102893>>>                    Move (String(CS_ReportDifferenceNote))                  to sSQLIndexNameTo
102894>>>                    Move (String(CS_ReportDifferenceNote))                  to bIsSQLPrimaryTo
102895>>>                    Move (String(CS_ReportDifferenceNote))                  to bIsSQLClusteredTo
102896>>>                    Move (String(CS_ReportDifferenceNote))                  to sSQLIndexTypeTo
102897>>>                    Move (String(CS_ReportDifferenceNote))                  to bIsSQLPrimaryTo
102898>>>                    Move aApiIndexSegmentsEmpty                             to aApiIndexSegmentsTo
102899>>>                End
102899>>>>
102899>>>
102899>>>                Get MakeFromString "Index Number:" iIndexNumberFrom CS_ReportIndexNotFound (iIndexNumberFrom <> -1) to sFrom
102900>>>                Get MakeToString iIndexNumberTo "" (CS_ReportIndexNotFound * String(CS_ReportDifferenceNote)) (iIndexNumberTo <> -1) to sTo
102901>>>                Writeln channel iCh sFrom sTo
102905>>>
102905>>>                Get MakeFromString "Primary Idx #:" iPrimaryIndexFrom CS_ReportDifferenceNote (iPrimaryIndexFrom <> -1) to sFrom
102906>>>                Get MakeToString iPrimaryIndexTo "" CS_ReportDifferenceNote (iPrimaryIndexTo <> -1) to sTo
102907>>>                Writeln channel iCh sFrom sTo
102911>>>
102911>>>                // SQL Index info:
102911>>>                If (bIsSqlTableFrom = True and bIsSqlTableTo = True) Begin
102913>>>                    Get MakeFromString "SQL Name:" sSQLIndexNameFrom CS_ReportDifferenceNote (sSQLIndexNameFrom <> "") to sFrom
102914>>>                    Get MakeToString sSQLIndexNameTo "" CS_ReportDifferenceNote (iIndexNumberFrom <> -1 and Uppercase(sSQLIndexNameFrom) = Uppercase(sSQLIndexNameTo)) to sTo
102915>>>                    Writeln channel iCh sFrom sTo
102919>>>
102919>>>                    Get MakeFromString "SQL Primary:" (If(bIsSQLPrimaryFrom = True, "Yes", "No")) CS_ReportDifferenceNote aAPIIndexCompare[iCount].bExistsFrom to sFrom
102920>>>                    Get MakeToString (If(bIsSQLPrimaryTo = True, "Yes", "No")) "" CS_ReportDifferenceNote (iIndexNumberFrom <> -1 and bIsSQLPrimaryFrom = bIsSQLPrimaryTo) to sTo
102921>>>                    Writeln channel iCh sFrom sTo
102925>>>
102925>>>                    Get MakeFromString "SQL Clustered:" (If(bIsSQLClusteredFrom = True, "Yes", "No")) CS_ReportDifferenceNote aAPIIndexCompare[iCount].bExistsFrom to sFrom
102926>>>                    Get MakeToString (If(bIsSQLClusteredTo = True, "Yes", "No")) "" CS_ReportDifferenceNote (iIndexNumberFrom <> -1 and bIsSQLClusteredFrom = bIsSQLClusteredTo) to sTo
102927>>>                    Writeln channel iCh sFrom sTo
102931>>>
102931>>>                    Get MakeFromString "SQL Type:" sSQLIndexTypeFrom CS_ReportDifferenceNote True to sFrom
102932>>>                    Get MakeToString sSQLIndexTypeTo "" CS_ReportDifferenceNote True to sTo
102933>>>                    Writeln channel iCh sFrom sTo
102937>>>                End
102937>>>>
102937>>>
102937>>>                // Index Segments:
102937>>>                Move (SizeOfArray(aApiIndexSegmentsFrom)) to iSegmentSizeFrom
102938>>>                Move (SizeOfArray(aApiIndexSegmentsTo))   to iSegmentSizeTo
102939>>>
102939>>>                Move (iSegmentSizeFrom max iSegmentSizeTo)  to iSize2
102940>>>                Decrement iSize2
102941>>>                If (iSize2 > -1) Begin
102943>>>                    Writeln channel iCh
102945>>>                End
102945>>>>
102945>>>
102945>>>                For iCount2 from 0 to iSize2
102951>>>>
102951>>>                    Move "" to sFieldNameFrom
102952>>>                    Move "" to sFieldNameTo
102953>>>                    Get MakeStringLength "Field# & Name:" CI_ReportColumn1               to sFrom
102954>>>                    If (iCount2 < iSegmentSizeFrom) Begin
102956>>>                        Move aApiIndexSegmentsFrom[iCount2].iFieldNumber                 to iFieldNumberFrom
102957>>>                        Move (sFrom + String(iFieldNumberFrom))                          to sFrom
102958>>>                        Move (String(aApiIndexSegmentsFrom[iCount2].sFieldName))         to sFieldNameFrom
102959>>>                        Move (sFrom * String(sFieldNameFrom))                            to sFrom
102960>>>                    End
102960>>>>
102960>>>                    Else Begin
102961>>>                        Move 0                                                           to iFieldNumberFrom
102962>>>                        Move (sFrom + CS_ReportIndexSegmentNotFound)                     to sFrom
102963>>>                    End
102963>>>>
102963>>>                    Get MakeStringLength sFrom CI_ReportColumn2                          to sFrom
102964>>>
102964>>>                    Move ""                                                              to sTo
102965>>>                    If (iIndexNumberTo <> -1) Begin
102967>>>                        Move aApiIndexSegmentsTo[iCount2].iFieldNumber                   to iFieldNumberTo
102968>>>                        Move (String(iFieldNumberTo))                                    to sTo
102969>>>                        Move (String(aApiIndexSegmentsTo[iCount2].sFieldName))           to sFieldNameTo
102970>>>                        Move (sTo * String(sFieldNameTo))                                to sTo
102971>>>                    End
102971>>>>
102971>>>                    If (iFieldNumberFrom <> iFieldNumberTo or Uppercase(sFieldNameFrom) <> Uppercase(sFieldNameTo)) Begin
102973>>>                        Move (sTo + String(CS_ReportDifferenceNote))                     to sTo
102974>>>                    End
102974>>>>
102974>>>                    Writeln channel iCh sFrom sTo
102978>>>
102978>>>                    // Uppercase Index:
102978>>>                    If (bCompareIndexUppercase = True) Begin
102980>>>                        Get MakeStringLength "Uppercase:" CI_ReportColumn1                                        to sFrom
102981>>>                        If (bIsSqlTableFrom = True) Begin
102983>>>                            Move (sFrom + CS_ReportIndexNotApplicable)                                            to sFrom
102984>>>                        End
102984>>>>
102984>>>                        Else If (iCount <= iSegmentSizeFrom) Begin
102987>>>                            Move (sFrom + String(If(aApiIndexSegmentsFrom[iCount2].bUppercase = 1, "Yes","No")))  to sFrom
102988>>>                        End
102988>>>>
102988>>>                        Get MakeStringLength sFrom CI_ReportColumn2                                               to sFrom
102989>>>                        Move "" to sTo
102990>>>                        If (bIsSqlTableFrom = True) Begin
102992>>>                            Move CS_ReportIndexNotApplicable                                                      to sTo
102993>>>                        End
102993>>>>
102993>>>                        Else If (iCount <= iSegmentSizeTo) Begin
102996>>>                            Move (String(If(aApiIndexSegmentsTo[iCount2].bUppercase = 1, "Yes", "No")))           to sTo
102997>>>                        End
102997>>>>
102997>>>                        Writeln channel iCh sFrom sTo
103001>>>                    End
103001>>>>
103001>>>
103001>>>                    // Ascending/Descending Index:
103001>>>                    If (bCompareIndexAscending = True) Begin
103003>>>                        Get MakeStringLength "Ascending:" CI_ReportColumn1                                        to sFrom
103004>>>                        If (bIsSqlTableFrom = True) Begin
103006>>>                            Move (sFrom + CS_ReportIndexNotApplicable)                                            to sFrom
103007>>>                        End
103007>>>>
103007>>>                        Else If (iCount <= iSegmentSizeFrom) Begin
103010>>>                            Move (sFrom + String(If(aApiIndexSegmentsFrom[iCount2].bAscending = 1, "Yes", "No"))) to sFrom
103011>>>                        End
103011>>>>
103011>>>                        Get MakeStringLength sFrom CI_ReportColumn2                                               to sFrom
103012>>>                        Move "" to sTo
103013>>>                        If (bIsSqlTableFrom = True) Begin
103015>>>                            Move CS_ReportIndexNotApplicable                                                      to sTo
103016>>>                        End
103016>>>>
103016>>>                        Else If (iCount <= iSegmentSizeTo) Begin
103019>>>                            Move (String(If(aApiIndexSegmentsTo[iCount2].bAscending = 1, "Yes", "No")))           to sTo
103020>>>                        End
103020>>>>
103020>>>                        Writeln channel iCh sFrom sTo
103024>>>                    End
103024>>>>
103024>>>                Loop
103025>>>>
103025>>>                Writeln channel iCh ""
103028>>>            End
103028>>>>
103028>>>        Loop
103029>>>>
103029>>>
103029>>>        If (bHeader = True) Begin
103031>>>            Writeln channel iCh ""
103034>>>        End
103034>>>>
103034>>>    End_Procedure
103035>>>
103035>>>    Procedure WriteRelationDiffs Handle hTable tAPIRelationCompare[] aAPIRelationCompare Integer iCh
103038>>>        Integer iSizeFrom iSize iCount iRow iItem
103038>>>        Boolean bExists bIsSame bHeader
103038>>>        String sFrom sTo sFromFieldsRight sFromFields sToFields sLogicalNameFrom
103038>>>        tRelationDiffs[] asRelationDiffs
103038>>>        tRelationDiffs[] asRelationDiffs
103039>>>
103039>>>
103039>>>        Move (SizeOfArray(aAPIRelationCompare)) to iSize
103040>>>        Decrement iSize
103041>>>        For iCount from 0 to iSize
103047>>>>
103047>>>            Get UtilRelationCompare of ghoDbUpdateFunctionLibrary hTable aAPIRelationCompare[iCount] to bIsSame
103048>>>            If (bIsSame = False) Begin
103050>>>                If (bHeader = False) Begin
103052>>>                    Move aAPIRelationCompare[iCount].sLogicalNameFrom_From   to sLogicalNameFrom
103053>>>                    If (sLogicalNameFrom = "") Begin
103055>>>                        Move aAPIRelationCompare[iCount].sLogicalNameFrom_To to sLogicalNameFrom
103056>>>                    End
103056>>>>
103056>>>                    Writeln channel iCh ""
103059>>>                    Writeln channel iCh "Relation Difference(s) for Table Number: " (String(hTable)) " - " sLogicalNameFrom
103065>>>                    Writeln channel iCh CS_ReportHeaderUnderWrite
103068>>>                    Move "FROM Database:" to sFrom
103069>>>                    Get MakeStringLength sFrom CI_ReportColumn2 to sFrom
103070>>>                    Move (sFrom + "TO Database:") to sFrom
103071>>>                    Writeln channel iCh sFrom
103074>>>                    Move (Repeat("-", Length(sFrom))) to sFrom
103075>>>                    Writeln channel iCh sFrom
103078>>>                    Move True to bHeader
103079>>>                End
103079>>>>
103079>>>
103079>>>                // FROM Relation:
103079>>>                Get MakeStringLength "Table.Field:" CI_ReportColumn1                            to sFrom
103080>>>                If (aAPIRelationCompare[iCount].bExistsFrom = True) Begin
103082>>>                    Move (sFrom + String(aAPIRelationCompare[iCount].hTableFrom)   + "." ;                                + String(aAPIRelationCompare[iCount].iColumnFrom)  * "->")      to sFrom
103083>>>                    Move (sFrom * String(aAPIRelationCompare[iCount].hTableTo)     + "." ;                                + String(aAPIRelationCompare[iCount].iColumnTo))                to sFrom
103084>>>                    Get MakeStringLength sFrom CI_ReportColumn2                                 to sFrom
103085>>>                    Move (String(aAPIRelationCompare[iCount].sLogicalNameFrom_From) + "." ;                        + String(aAPIRelationCompare[iCount].sFieldNameFrom_From)   * "->")     to sFromFields
103086>>>                    Move (String(aAPIRelationCompare[iCount].sLogicalNameTo_From)   + "." ;                        + String(aAPIRelationCompare[iCount].sFieldNameTo_From))                to sFromFieldsRight
103087>>>                End
103087>>>>
103087>>>                Else Begin
103088>>>                    Move (String(CS_ReportRelationNotFound) * String(CS_ReportDifferenceNote))  to sFrom
103089>>>                    Get MakeStringLength sFrom CI_ReportColumn2                                 to sFrom
103090>>>                    Move (String(CS_ReportDifferenceNote))                                      to sFromFields
103091>>>                    Move ""                                                                     to sFromFieldsRight
103092>>>                    Move iCount                                                                 to iItem
103093>>>                End
103093>>>>
103093>>>                Move (sFromFields * String(sFromFieldsRight))                                   to sFromFields
103094>>>                Get MakeStringLength sFromFields CI_ReportColumn2                               to sFromFields
103095>>>
103095>>>                // TO Relation:
103095>>>                If (aAPIRelationCompare[iCount].bExistsTo = True) Begin
103097>>>                    Move (String(aAPIRelationCompare[iCount].hTableFrom)           + "." ;                        + String(aAPIRelationCompare[iCount].iColumnFrom)          * "->")      to sTo
103098>>>                    Move (sTo * String(aAPIRelationCompare[iCount].hTableTo)       + "." ;                        + String(aAPIRelationCompare[iCount].iColumnTo))                        to sTo
103099>>>                    Move (String(aAPIRelationCompare[iCount].sLogicalNameFrom_To)  + "." ;                        + String(aAPIRelationCompare[iCount].sFieldNameFrom_To)    * "->")      to sToFields
103100>>>                    Move (sToFields * String(aAPIRelationCompare[iCount].sLogicalNameTo_To) + "." ;                        + String(aAPIRelationCompare[iCount].sFieldNameTo_To))                  to sToFields
103101>>>                End
103101>>>>
103101>>>                Else Begin
103102>>>                    Move (CS_ReportRelationNotFound * String(CS_ReportDifferenceNote))          to sTo
103103>>>                    Move (String(CS_ReportDifferenceNote))                                      to sToFields
103104>>>                End
103104>>>>
103104>>>
103104>>>                Move sFromFieldsRight to asRelationDiffs[iRow].sFromFieldsRight
103105>>>                Move sFrom to asRelationDiffs[iRow].sFrom
103106>>>                Move sTo   to asRelationDiffs[iRow].sTo
103107>>>                Move sFromFields to asRelationDiffs[iRow].sFromFields
103108>>>                Move sToFields   to asRelationDiffs[iRow].sToFields
103109>>>                If (iCount < iSize) Begin
103111>>>                    Increment iRow
103112>>>                    Move "" to asRelationDiffs[iRow].sFrom
103113>>>                    Move "" to asRelationDiffs[iRow].sTo
103114>>>                End
103114>>>>
103114>>>                Else Begin
103115>>>                    Increment iRow
103116>>>                End
103116>>>>
103116>>>            End
103116>>>>
103116>>>        Loop
103117>>>>
103117>>>
103117>>>        // We put all relations in an array struct so we can sort it alphatically.
103117>>>        // This is to show multiple field relations from one table to another next to each other, just as the Studio does.
103117>>>        Move (SortArray(asRelationDiffs))   to asRelationDiffs
103118>>>        Move (SizeOfArray(asRelationDiffs)) to iSizeFrom
103119>>>        Decrement iSizeFrom
103120>>>        For iCount from 0 to iSizeFrom
103126>>>>
103126>>>            Writeln channel iCh asRelationDiffs[iCount].sFrom       asRelationDiffs[iCount].sTo
103130>>>            Writeln channel iCh asRelationDiffs[iCount].sFromFields asRelationDiffs[iCount].sToFields
103134>>>            Writeln channel iCh
103136>>>        Loop
103137>>>>
103137>>>
103137>>>        If (bHeader = True) Begin
103139>>>            Writeln channel iCh ""
103142>>>        End
103142>>>>
103142>>>    End_Procedure
103143>>>
103143>>>    Procedure WriteReportFooter Integer iSize Boolean bCollationDiff Integer iCh DateTime dtExecStart
103146>>>        DateTime dtExecEnd
103146>>>        TimeSpan tsTotalTime
103146>>>
103146>>>        Move (CurrentDateTime()) to dtExecEnd
103147>>>        Move (dtExecEnd - dtExecStart) to tsTotalTime
103148>>>
103148>>>        Writeln channel iCh
103150>>>        Writeln channel iCh "SUMMARY:  [Total Elapsed Time: " tsTotalTime "]"
103155>>>        Writeln channel iCh CS_ReportHeaderUnderWrite               
103158>>>        If (bCollationDiff = False) Begin
103160>>>            Writeln channel iCh "Number of Tables with differences: " (String(iSize))
103164>>>        End 
103164>>>>
103164>>>        Else Begin
103165>>>            If (iSize <> 0) Begin
103167>>>                Writeln channel iCh "Number of Tables with differences: " (String(iSize))
103171>>>            End
103171>>>>
103171>>>            Writeln channel iCh "*** IMPORTANT: The SQL collation used for the 'FROM' and 'TO' database are different! ***"
103174>>>            Writeln channel iCh 
103176>>>        End
103176>>>>
103176>>>        
103176>>>        If (iSize = 0) Begin
103178>>>            Writeln channel iCh "*** No table differences found. All tables should be identical! ***"
103181>>>        End
103181>>>>
103181>>>
103181>>>        Send Seq_Close_Channel iCh
103182>>>    End_Procedure
103183>>>
103183>>>    Function MakeStringLength String sValue Integer iReportColumnPos Returns String
103186>>>        Move (Pad(sValue, (Length(sValue) + (iReportColumnPos - Length(sValue))))) to sValue
103187>>>
103187>>>        Function_Return sValue
103188>>>    End_Function
103189>>>
103189>>>    Function MakeFromString String sStartText String sText String sMissingText Boolean bExists Returns String
103192>>>        String sFrom
103192>>>
103192>>>        Get MakeStringLength sStartText CI_ReportColumn1 to sFrom
103193>>>        If (bExists = True) Begin
103195>>>            Move (sFrom + String(sText)) to sFrom
103196>>>        End
103196>>>>
103196>>>        Else Begin
103197>>>            Move (sFrom + String(sMissingText)) to sFrom
103198>>>        End
103198>>>>
103198>>>        Get MakeStringLength sFrom CI_ReportColumn2 to sFrom
103199>>>
103199>>>        Function_Return sFrom
103200>>>    End_Function
103201>>>
103201>>>    Function MakeToString String sStartText String sText String sMissingText Boolean bSame Returns String
103204>>>        String sTo
103204>>>
103204>>>        Move (String(sStartText) * String(sText)) to sTo
103205>>>        If (bSame = False) Begin
103207>>>            If (sTo <> "-1") Begin
103209>>>                Move (sTo * String(sMissingText)) to sTo
103210>>>            End
103210>>>>
103210>>>            Else Begin
103211>>>                Move (String(sMissingText)) to sTo
103212>>>            End
103212>>>>
103212>>>        End
103212>>>>
103212>>>
103212>>>        Function_Return sTo
103213>>>    End_Function
103214>>>
103214>>>    Function FindArrayItem tAPITable[] aFromStructure tAPITable[] aToStructure Integer iCount Handle ByRef hTable Integer ByRef iItemFrom Integer ByRef iItemTo Returns String
103217>>>        Integer iSizeFrom iSizeTo
103217>>>        Handle hTableFrom hTableTo
103217>>>        String sLogicalName
103217>>>
103217>>>        Move (SizeOfArray(aFromStructure)) to iSizeFrom
103218>>>        Move (SizeOfArray(aToStructure))   to iSizeTo
103219>>>
103219>>>        Move -1 to hTableFrom
103220>>>        Move -1 to hTableTo
103221>>>        Move iCount to iItemFrom
103222>>>        Move iCount to iItemTo
103223>>>
103223>>>        // The two struct arrays may be different in size (contain different number of items/tables).
103223>>>        //
103223>>>        // To avoid "Referenced Array Index Out of Bounds" error.
103223>>>        If (iCount < iSizeFrom) Begin
103225>>>            Move aFromStructure[iCount].ApiTableInfo.iTableNumber to hTableFrom
103226>>>        End
103226>>>>
103226>>>        If (iCount < iSizeTo) Begin
103228>>>            Move aToStructure[iCount].ApiTableInfo.iTableNumber   to hTableTo
103229>>>        End
103229>>>>
103229>>>        If (hTableFrom <> -1 and hTableTo <> -1) Begin
103231>>>            Move (hTableFrom min hTableTo)                to hTable
103232>>>        End
103232>>>>
103232>>>        Else Begin
103233>>>            Move (hTableFrom max hTableTo)                to hTable
103234>>>        End
103234>>>>
103234>>>
103234>>>        If (iCount < iSizeFrom and hTableFrom <= hTableTo) Begin
103236>>>            Move aFromStructure[iCount].ApiTableInfo.sLogicalName to sLogicalName
103237>>>            Get FindTableNumber (&aToStructure) hTable to iItemTo
103238>>>        End
103238>>>>
103238>>>
103238>>>        // If the 'TO' table number is lower than 'FROM'
103238>>>        Else If (iCount < iSizeTo) Begin
103241>>>            Move aToStructure[iCount].ApiTableInfo.sLogicalName to sLogicalName
103242>>>            Get FindTableNumber (&aFromStructure) hTable to iItemFrom
103243>>>        End
103243>>>>
103243>>>        Else If (iCount = iSizeTo) Begin
103246>>>            Get FindTableNumber (&aToStructure) hTable to iItemTo
103247>>>        End
103247>>>>
103247>>>
103247>>>        Function_Return sLogicalName
103248>>>    End_Function
103249>>>
103249>>>    Function FindTableNumber tAPITable[] ByRef aTableStructure Handle hTable Returns Integer
103252>>>        Integer iSize iCount iTable iItem
103252>>>        tAPITableNameInfo ApiTableNameInfo
103252>>>        tAPITableNameInfo ApiTableNameInfo
103252>>>
103252>>>        Move -1 to iItem
103253>>>        Move (SizeOfArray(aTableStructure)) to iSize
103254>>>        Decrement iSize
103255>>>        For iCount from 0 to iSize
103261>>>>
103261>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
103262>>>            If (ApiTableNameInfo.iTableNumber = hTable) Begin
103264>>>                Move iCount to iItem
103265>>>                Move iSize  to iCount // We're done.
103266>>>            End
103266>>>>
103266>>>        Loop
103267>>>>
103267>>>
103267>>>        Function_Return iItem
103268>>>    End_Function
103269>>>
103269>>>    // Pass one tAPIRelation for the FROM database and a struct array with relations for the TO database
103269>>>    // Returns the item number in the aAPIRelationsTO that equals the FROM relation struct data.
103269>>>    // If not found returns -1.
103269>>>//    Function FindEqualRelation tAPIRelation APIRelationFrom tAPIRelation[] aAPIRelationsTO Returns Integer
103269>>>//        Integer iRetval iSize iCount
103269>>>//
103269>>>//        Move -1 to iRetval
103269>>>//        Move (SizeOfArray(aAPIRelationsTO)) to iSize
103269>>>//        Decrement iSize
103269>>>//        For iCount from 0 to iSize
103269>>>//            If (APIRelationFrom.hTableFrom  = aAPIRelationsTO[iCount].hTableFrom  and ;
103269>>>//                APIRelationFrom.iColumnFrom = aAPIRelationsTO[iCount].iColumnFrom and ;
103269>>>//                APIRelationFrom.hTableTo    = aAPIRelationsTO[iCount].hTableTo    and ;
103269>>>//                APIRelationFrom.iColumnTo   = aAPIRelationsTO[iCount].iColumnTo) Begin
103269>>>//                    Move iCount to iRetval
103269>>>//                End
103269>>>//        Loop
103269>>>//
103269>>>//        Function_Return iRetval
103269>>>//    End_Function
103269>>>
103269>>>    // Returns a value <> -1 if the passed iIndex was found in the APIIndex struct array.
103269>>>    // The value returned is the item number, else a -1.
103269>>>//    Function FindIndexInArray Integer iIndex tAPIIndex[] APIIndex Returns Integer
103269>>>//        Integer iRetval iSize iCount iCompareIndex
103269>>>//
103269>>>//        Move -1 to iRetval
103269>>>//        Move (SizeOfArray(APIIndex)) to iSize
103269>>>//        Decrement iSize
103269>>>//        For iCount from 0 to iSize
103269>>>//            If (iIndex = APIIndex[iCount].iIndexNumber) Begin
103269>>>//                Move iCount to iRetval
103269>>>//            End
103269>>>//        Loop
103269>>>//        Function_Return iRetval
103269>>>//    End_Function
103269>>>
103269>>>    Procedure Request_Clear
103272>>>        Integer[] iDifferencesEmpty
103273>>>
103273>>>        Set Value of oFilelistPathFrom_fm   to ""
103274>>>        Set Value of oFilelistPathTo_fm     to ""
103275>>>        Set Value of oReportFileName_fm     to ""
103276>>>        Set psFilelistFrom of ghoApplication to ""
103277>>>        Set piaDifferences of ghoApplication to iDifferencesEmpty
103278>>>
103278>>>        Send Activate of oFilelistPathFrom_fm
103279>>>    End_Procedure
103280>>>
103280>>>    Object oBusinessProcess is a BusinessProcess
103282>>>        Set Status_Panel_Id to ghoStatusPanel
103283>>>        Set Allow_Cancel_State to True
103284>>>        Set Process_Caption to "The Database Update Framework"
103285>>>        Set Process_Title to "Comparing Database Structures..."
103286>>>//        Set Display_Error_State to True // Temp!
103286>>>
103286>>>        Procedure OnProcess
103289>>>            Send MainProcess
103290>>>        End_Procedure
103291>>>
103291>>>        Procedure Ignore_Error Integer iError
103294>>>        End_Procedure
103295>>>        Procedure Trap_Error Integer iError
103298>>>        End_Procedure
103299>>>
103299>>>    End_Object
103300>>>
103300>>>    Object oCompare_btn is a cButtonDPI
103302>>>        Set Size to 23 58
103303>>>        Set Label to "Co&mpare Databases"
103304>>>        Set Location to 284 278
103305>>>        Set peAnchors to anBottomRight
103306>>>        Set FontWeight to fw_Bold
103307>>>        Set Default_State to True
103308>>>        Set psImage to "DbCompareBlack2.ico"
103309>>>        Set MultiLineState to True
103310>>>        Set psToolTip to "Start the compare process"
103311>>>
103311>>>        Procedure OnClick
103314>>>            String sFilelistFrom sFilelistTo
103314>>>            Integer[] iaDifferences
103315>>>            Boolean bFromExists bToExists
103315>>>
103315>>>            Get Value of oFilelistPathFrom_fm to sFilelistFrom
103316>>>            Get vFilePathExists sFilelistFrom to bFromExists
103317>>>            Get Value of oFilelistPathTo_fm   to sFilelistTo
103318>>>            Get vFilePathExists sFilelistTo   to bToExists
103319>>>            If (bFromExists = False or bToExists = False) Begin
103321>>>                Send Info_Box "You need to both select a FROM and a TO database Filelist.cfg. Please adjust and try again."
103322>>>                Procedure_Return
103323>>>            End
103323>>>>
103323>>>
103323>>>            Send DoProcess of oBusinessProcess
103324>>>            Send Restore_DF_OPEN_PATH of ghoApplication
103325>>>        End_Procedure
103326>>>
103326>>>        Procedure DoEnable
103329>>>            String sFileListFrom sFileListTo
103329>>>            Boolean bExists bState
103329>>>
103329>>>            Get Value of oFilelistPathFrom_fm to sFileListFrom
103330>>>            Get vFilePathExists sFileListFrom to bExists
103331>>>            If (bExists = False) Begin
103333>>>                Set Enabled_State to False
103334>>>                Procedure_Return
103335>>>            End
103335>>>>
103335>>>            Get Value of oFilelistPathTo_fm to sFileListTo
103336>>>            Get vFilePathExists sFileListTo to bExists
103337>>>            Get Enabled_State to bState
103338>>>            If (bState = False and bExists = False) Begin
103340>>>                Procedure_Return
103341>>>            End
103341>>>>
103341>>>            Set Enabled_State to bExists
103342>>>        End_Procedure
103343>>>
103343>>>    End_Object
103344>>>
103344>>>    Object oViewReport_Btn is a cButtonDPI
103346>>>        Set Size to 23 65
103347>>>        Set Label to "View &Report"
103348>>>        Set Location to 284 348
103349>>>        Set peAnchors to anBottomRight
103350>>>        Set MultiLineState to True
103351>>>        Set psImage to "ViewReportBlack.ico"
103352>>>        Set psToolTip to "Open the folder where the report was generated."
103353>>>
103353>>>        Procedure OnClick
103356>>>            String sReportName
103356>>>            Get Value of oReportFileName_fm to sReportName
103357>>>            Runprogram Shell Background sReportName
103358>>>        End_Procedure
103359>>>
103359>>>        Procedure DoEnable
103362>>>            String sReportName
103362>>>            Boolean bExists
103362>>>
103362>>>            Get Value of oReportFileName_fm to sReportName
103363>>>            Get vFilePathExists sReportName to bExists
103364>>>            Set Enabled_State to (bExists = True)
103365>>>        End_Procedure
103366>>>
103366>>>    End_Object
103367>>>
103367>>>    Object oTagFilelist_Btn is a cButtonDPI
103369>>>        Set Size to 23 65
103370>>>        Set Label     to "&Tag Filelist Diff's"
103371>>>        Set Location to 284 418
103372>>>        Set peAnchors to anBottomRight
103373>>>        Set MultiLineState to True
103374>>>        Set psImage to "SelectInvertBlack.ico"
103375>>>        Set psToolTip to "Tag Tables for the 'FROM' Filelist.cfg with differences - for code generation on the 'Code Generator' view page."
103376>>>
103376>>>        Procedure OnClick
103379>>>            String sFileListFrom
103379>>>            Get Value of oFilelistPathFrom_fm    to sFileListFrom
103380>>>            Set psFilelistFrom of ghoApplication to sFileListFrom
103381>>>            Send TagFileNamesForCodeGeneration
103382>>>        End_Procedure
103383>>>
103383>>>        Procedure DoEnable
103386>>>            Integer[] iaDifferences
103387>>>
103387>>>            Get piaDifferences of ghoApplication to iaDifferences
103388>>>            Set Enabled_State to (SizeOfArray(iaDifferences))
103389>>>        End_Procedure
103390>>>
103390>>>    End_Object
103391>>>
103391>>>    On_Key Key_Ctrl+Key_M  Send KeyAction of oCompare_btn
103392>>>    On_Key Key_Ctrl+Key_R  Send KeyAction of oViewReport_Btn
103393>>>    On_Key Key_Ctrl+Key_T  Send KeyAction of oTagFilelist_Btn
103394>>>    On_Key kClear          Send Request_Clear
103395>>>    On_Key kClear_All      Send Request_Clear
103396>>>    On_Key Key_Ctrl+Key_F4 Send None
103397>>>End_Object
103398>        Use TableDUFCodeGenerator.vw
Including file: TableDUFCodeGenerator.vw    (C:\Projects\DF18\DbUpdateFramework\AppSrc\TableDUFCodeGenerator.vw)
103398>>>Use Windows.pkg
103398>>>Use DFClient.pkg
103398>>>Use Cursor.pkg
103398>>>Use Batchdd.pkg
103398>>>Use cCJGrid.pkg
103398>>>Use cCJGridColumnRowIndicator.pkg
Including file: cCJGridColumnRowIndicator.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJGridColumnRowIndicator.pkg)
103398>>>>>Use cCJGridColumn.pkg
103398>>>>>
103398>>>>>Class cCJGridColumnRowIndicator is a cCJGridColumn
103399>>>>>    
103399>>>>>    Procedure Construct_Object
103401>>>>>        Forward Send Construct_Object
103403>>>>>    
103403>>>>>        Property Integer piImage 0
103404>>>>>        
103404>>>>>        Set psCaption to ""
103405>>>>>        Set piWidth to 20
103406>>>>>        Set pbResizable to False
103407>>>>>        Set pbEditable to False
103408>>>>>        Set pbFocusable to False
103409>>>>>        Set pbAllowDrag to False
103410>>>>>        Set psToolTip to "Row Indicator"
103411>>>>>//        Set Color to (RGB(217,222,243))   //JVH
103411>>>>>    End_Procedure
103412>>>>>    
103412>>>>>    Procedure OnCreateColumn
103414>>>>>        Integer iImage
103414>>>>>        Delegate Get AddImage "GridColumnRowIndicator.bmp" 0 to iImage
103416>>>>>        Set piImage to iImage
103417>>>>>    End_Procedure
103418>>>>>            
103418>>>>>    Procedure OnSetDisplayMetrics Handle hoGridItemMetrics Integer iRow String ByRef sValue
103420>>>>>        Integer iImage iFocusedRow
103420>>>>>        Handle hoDataSource
103420>>>>>        
103420>>>>>        Get phoDataSource to hoDataSource
103421>>>>>        Get SelectedRow of hoDataSource to iFocusedRow
103422>>>>>        Move -1 to iImage
103423>>>>>        If (iRow = iFocusedRow) Begin
103425>>>>>            Get piImage to iImage
103426>>>>>            Set ComItemIcon of hoGridItemMetrics to iImage
103427>>>>>        End
103427>>>>>>
103427>>>>>    End_Procedure
103428>>>>>
103428>>>>>End_Class
103429>>>Use cCJGridColumn.pkg
103429>>>Use dfLine.pkg
103429>>>Use cButton.pkg
103429>>>Use cDbUpdateFunctionLibrary.pkg
103429>>>Use DUFStatusPanel.pkg
103429>>>Use seq_chnl.pkg
103429>>>Use vWin32fh.pkg
103429>>>Use cHeaderGroup.pkg
103429>>>Use cSuggestionIniForm.pkg
103429>>>Use cSQLCheckBox.pkg
103429>>>
103429>>>Enum_List
103429>>>    Define cx_Select_All
103429>>>    Define cx_Select_None
103429>>>    Define cx_Select_Invert
103429>>>End_Enum_List
103429>>>
103429>>>Enum_List
103429>>>    Define GenerateOK
103429>>>    Define GenerateUserCancel
103429>>>    Define GenerateError
103429>>>    Define GenerateChannelError
103429>>>    Define GenerateUserInputError
103429>>>    Define GenerateOpenTableError
103429>>>End_Enum_List
103429>>>
103429>>>Struct tGeneratorRow
103429>>>    Handle hTable
103429>>>    String sLogicalName
103429>>>    String sRootName
103429>>>    String sDisplayName
103429>>>    Boolean bIsAlias
103429>>>    Boolean bSelected
103429>>>End_Struct
103429>>>
103429>>>Activate_View Activate_oTableDUFCodeGenerator for oTableDUFCodeGenerator
103439>>>>
103439>>>Object oTableDUFCodeGenerator is a dbView
103441>>>    Set Size to 311 492
103442>>>    Set Location to 0 1
103443>>>    Set Label to "Code Generator"
103444>>>    Set Icon to "SqlScriptBlack2.ico"
103445>>>    Set Border_Style to Border_Thick
103446>>>    Set Color to clWhite
103447>>>    Set pbAcceptDropFiles to True
103448>>>    Set pbAutoActivate to True
103449>>>    Set phoTableDUFCodeGenerator_vw of ghoApplication to Self
103450>>>
103450>>>    Property String psOrgOpenPath
103452>>>    Property Handle phtable
103454>>>    Property String psTableName
103456>>>
103456>>>    // Set psOrgOpenPath at startup
103456>>>    Procedure StartUp
103459>>>        String sOrgOpenPath sDataPath
103459>>>        Get_Attribute DF_OPEN_PATH to sOrgOpenPath
103462>>>        // First remove the current Data folder path
103462>>>        Get PathAtIndex of (phoWorkspace(ghoApplication)) sOrgOpenPath 1 to sDataPath
103463>>>        Move (Replace(sDataPath, sOrgOpenPath, "")) to sOrgOpenPath
103464>>>        If (Left(sOrgOpenPath, 2) = "\;") Begin
103466>>>            Move (Replace("\;", sOrgOpenPath, "")) to sOrgOpenPath
103467>>>        End
103467>>>>
103467>>>        Set psOrgOpenPath to sOrgOpenPath
103468>>>    End_Procedure
103469>>>    Send StartUp
103470>>>
103470>>>    Object oFromFilelist_grp is a cHeaderGroup
103472>>>        Set Size to 43 462
103473>>>        Set Location to 8 19
103474>>>        Set pbAcceptDropFiles to True
103475>>>        Set psImage to "ActionOpenBlack.ico"
103476>>>        Set psLabel to "Select Filelist.cfg"
103477>>>
103477>>>        // Work around; we need to get the container_handle of the parent, else drag & drop doesn't work.
103477>>>//        Function Container_Handle Returns Integer
103477>>>//            Integer rVal
103477>>>//            Delegate Get Container_Handle to rVal
103477>>>//            Delegate Get Window_Handle to rVal
103477>>>//            Function_Return rVal
103477>>>//        End_Function
103477>>>
103477>>>        Object oFilelistPath_fm is a cSuggestionIniForm
103479>>>            Set Size to 13 413
103480>>>            Set Location to 21 25
103481>>>            Set Label_Col_Offset to 0
103482>>>            Set Label_Row_Offset to 1
103483>>>            Set Label_Justification_Mode to JMode_Top
103484>>>            Set Prompt_Button_Mode to PB_PromptOn
103485>>>            Set peAnchors to anTopLeftRight
103486>>>            Set psToolTip to "Select the FROM database Filelist.cfg. This should be the development workspace Data folder's Filelist.cfg"
103487>>>            Set Prompt_Object to Self
103488>>>
103488>>>            Procedure Prompt
103491>>>                String sFileName sPath sFileMask sRetval
103491>>>
103491>>>                Get Value to sFileName
103492>>>                Get ParseFolderName sFileName to sPath
103493>>>                Move "Filelist.cfg files (*.cfg)|*.cfg" to sFileMask
103494>>>                Get vSelect_File sFileMask "Please select a Filelist.cfg file" sPath to sRetval
103495>>>                If (sRetval <> "") Begin
103497>>>                    Set Value to sRetval
103498>>>                End
103498>>>>
103498>>>            End_Procedure
103499>>>
103499>>>            Procedure OnChange
103502>>>                String sFileList
103502>>>                Boolean bOK bExists bCfgFile bHasRecords
103502>>>                Handle hTable
103502>>>                Number nVersionNumber
103502>>>
103502>>>                Get Value to sFileList
103503>>>                Get vFilePathExists sFileList to bExists
103504>>>                Move (Lowercase(sFileList) contains ".cfg") to bCfgFile
103505>>>                If (bExists = True and bCfgFile) Begin
103507>>>                    // A little trick to show the filelist.cfg in the form before we start filling the grid.
103507>>>                    Send PumpMsgQueue of Desktop
103508>>>                    Get ChangeFilelistPathing of ghoApplication sFileList to bOK
103509>>>
103509>>>                    If (bOK = True) Begin
103511>>>                        Set psFilelistFrom of ghoApplication to sFileList
103512>>>
103512>>>                        // *** LOAD DATA ***
103512>>>                        Send LoadData to oFilelist_grd
103513>>>
103513>>>                        // It just seem logical to activate the grid after populating it.
103513>>>                        // At this point there is little use of still having the oFilelist_fm active.
103513>>>                        Get HasRecords of oFilelist_grd to bHasRecords
103514>>>                        If (bHasRecords = True) Begin
103516>>>                            Send Activate of oFilelist_grd
103517>>>                        End
103517>>>>
103517>>>
103517>>>                        If (bExists = True) Begin
103519>>>                            Get phDbVersion of oFilelist_grd to hTable
103520>>>                            If (hTable <> 0) Begin
103522>>>                                Open hTable
103524>>>                                Get_Field_Value hTable 1 to nVersionNumber
103527>>>                                Close hTable
103528>>>                            End
103528>>>>
103528>>>                        End
103528>>>>
103528>>>                        Else Begin
103529>>>                            // Send Info_Box ("This workspace has not been setup to use the DUF DbVersion table and thus the current database version can't be retrieved.\nYou need to manually set the 'Next pnVersionNumber' entry window below to an apropriate number before pressing the 'Generate Code' button.")
103529>>>                            Move 1 to nVersionNumber
103530>>>                        End
103530>>>>
103530>>>                        Move (nVersionNumber + .1) to nVersionNumber
103531>>>                        Set Value of oPnVersionNumber_fm to nVersionNumber
103532>>>                    End
103532>>>>
103532>>>                End
103532>>>>
103532>>>            End_Procedure
103533>>>
103533>>>            Function Window_Handle Returns Handle
103536>>>                Integer rVal
103536>>>                Get Window_Handle of (Parent(Self)) to rVal
103537>>>                Function_Return rVal
103538>>>            End_Function
103539>>>
103539>>>            Function Next_Object_Id Boolean bNoDescend Returns Integer
103542>>>                Function_Return (oFilelist_grd(Self))
103543>>>            End_Function
103544>>>
103544>>>            On_Key Key_Ctrl+Key_W Send None
103545>>>            On_Key Key_Ctrl+Key_Q Send None
103546>>>        End_Object
103547>>>
103547>>>    End_Object
103548>>>
103548>>>    Object oSelectTables_grp is a cHeaderGroup
103550>>>        Set Size to 102 462
103551>>>        Set Location to 60 19
103552>>>        Set peAnchors to anAll
103553>>>        Set psImage to "SelectTablesBlack.ico"
103554>>>        Set psLabel to "Select Tables"
103555>>>
103555>>>        Object oFilelist_grd is a cCJGrid
103557>>>            Set Size to 72 412
103558>>>            Set Location to 21 25
103559>>>            Set pbUseAlternateRowBackgroundColor to True
103560>>>            Set psNoItemsText to "No Filelist.cfg selected yet..."
103561>>>            Set pbRestoreLayout to True
103562>>>            Set psLayoutSection to (Name(Self) + "_grid")
103563>>>            Set pbHeaderReorders to True
103564>>>            Set pbHeaderPrompts to False
103565>>>            Set pbHeaderTogglesDirection to True
103566>>>            Set pbSelectionEnable to True
103567>>>            Set pbAllowInsertRow to False
103568>>>            Set pbAllowAppendRow to False
103569>>>            Set pbShowRowFocus to True
103570>>>            Set pbShowFooter to True
103571>>>            Set pbAllowDeleteRow to False
103572>>>            Set pbMultipleSelection to True
103573>>>            Set pbHotTracking to True
103574>>>            Set pbEditOnClick to True
103575>>>            Set peAnchors to anAll
103576>>>            Set piLayoutBuild to 3
103577>>>            Set Status_Help to "Select with the spacebar, or use the selection buttons above the grid"
103578>>>            Set peVisualTheme to xtpReportThemeVisualStudio2012Light
103579>>>
103579>>>            Property Handle phDbVersion
103581>>>            Property Integer piCurrentRow -1
103583>>>
103583>>>            Object oCJGridColumnRowIndicator is a cCJGridColumnRowIndicator
103585>>>                Set piWidth to 26
103586>>>            End_Object
103587>>>
103587>>>            Object oFilelistNumber_col is a cCJGridColumn
103589>>>                Set piWidth to 73
103590>>>                Set psCaption to "Filelist No"
103591>>>                Set psToolTip to (psCaption(Self) * "(Read-Only)")
103592>>>                Set peDataType to Mask_Numeric_Window
103593>>>                Set pbEditable to False
103594>>>            End_Object
103595>>>
103595>>>            Object oLogicalName_col is a cCJGridColumn
103597>>>                Set piWidth to 119
103598>>>                Set psCaption to "Logical Name"
103599>>>                Set psToolTip to (psCaption(Self) * "(Read-Only)")
103600>>>                Set pbEditable to False
103601>>>            End_Object
103602>>>
103602>>>            Object oRootName_col is a cCJGridColumn
103604>>>                Set piWidth to 187
103605>>>                Set psCaption to "Table Name (Rootname)"
103606>>>                Set psToolTip to (psCaption(Self) * "(Read-Only)")
103607>>>                Set pbEditable to False
103608>>>            End_Object
103609>>>
103609>>>            Object oDisplayName_col is a cCJGridColumn
103611>>>                Set piWidth to 260
103612>>>                Set psCaption to "Display Name"
103613>>>                Set psToolTip to (psCaption(Self) * "(Read-Only)")
103614>>>                Set psFooterText to "No of Tables:"
103615>>>                Set pbEditable to False
103616>>>            End_Object
103617>>>
103617>>>            Object oIsAlias_Col is a cCJGridColumn
103619>>>                Set piWidth to 83
103620>>>                Set psCaption to "Is Alias"
103621>>>                Set pbCheckbox to True
103622>>>                Set peHeaderAlignment to xtpAlignmentCenter
103623>>>                Set peFooterAlignment to xtpAlignmentCenter
103624>>>                Set psFooterText to "Count:"
103625>>>                Set pbVDFEditControl to False
103626>>>                Set psToolTip to "Is table an alias table? (Read-Only)"
103627>>>                // Set pbEditable to False
103627>>>            End_Object
103628>>>
103628>>>            // We want oIsAlias_Col to not be editable. But setting
103628>>>            // pbEditable = False makes it very hard to read.
103628>>>            // So we disable it here instead.
103628>>>            Function CanEditColumn Integer iCol Returns Boolean
103631>>>                Handle hoIsAlias_Col
103631>>>                Boolean bRetval
103631>>>
103631>>>                Forward Get CanEditColumn iCol to bRetval
103633>>>                Get piColumnId of oIsAlias_Col to hoIsAlias_Col
103634>>>                If (iCol = hoIsAlias_Col) Begin
103636>>>                    Function_Return False
103637>>>                End
103637>>>>
103637>>>
103637>>>                Function_Return bRetval
103638>>>            End_Function
103639>>>
103639>>>            Object oCheckbox_Col is a cCJGridColumn
103641>>>                Set piWidth to 79
103642>>>                Set psCaption to "Select"
103643>>>                Set psToolTip to "Select with the spacebar, or use the selection buttons above the grid"
103644>>>                Set pbCheckbox to True
103645>>>                Set peHeaderAlignment to xtpAlignmentCenter
103646>>>                Set peFooterAlignment to xtpAlignmentCenter
103647>>>                Set psFooterText to "Selected:"
103648>>>                Set peDataType to Mask_Numeric_Window
103649>>>            End_Object
103650>>>
103650>>>            Procedure LoadData
103653>>>                String sFileList sLogicalName
103653>>>                Handle hoDataSource hTable
103653>>>                tDataSourceRow[] TheData TheDataEmpty
103653>>>                tDataSourceRow[] TheData TheDataEmpty
103655>>>                Integer iRow iTableNo iRoot iLogical iDisplay iIsAlias iChecked iAliasCount iNoOfTables iCount
103655>>>                Boolean bExists bIsAlias bUserCancel
103655>>>
103655>>>                Get_Attribute DF_FILELIST_NAME to sFilelist
103658>>>                Get vFilePathExists sFileList to bExists
103659>>>                If (bExists = False) Begin
103661>>>                    Procedure_Return
103662>>>                End
103662>>>>
103662>>>
103662>>>                Send Initialize_StatusPanel of ghoStatusPanel "The Database Update Framework" "Loading Filelist.cfg data" "...and checking for Alias tables"
103663>>>                Send Start_StatusPanel of ghoStatusPanel
103664>>>                Get UtilFilelistNoOfTables of ghoDbUpdateFunctionLibrary to iNoOfTables
103665>>>                Set pbVisible of ghoProgressBar to True
103666>>>                Set pbVisible of ghoProgressBarOverall to False
103667>>>                Set piMaximum of ghoProgressBar to iNoOfTables
103668>>>                Move 0 to iCount
103669>>>                Get phoDataSource to hoDataSource
103670>>>                Get DataSource of hoDataSource to TheData
103671>>>                Move TheDataEmpty to TheData
103672>>>                Get piColumnId of oFilelistNumber_col to iTableNo
103673>>>                Get piColumnId of oRootName_col       to iRoot
103674>>>                Get piColumnid of oLogicalName_col    to iLogical
103675>>>                Get piColumnId of oDisplayName_col    to iDisplay
103676>>>                Get piColumnId of oIsAlias_Col        to iIsAlias
103677>>>                Get piColumnId of oCheckbox_Col       to iChecked
103678>>>
103678>>>                Move 0 to hTable
103679>>>                Move 0 to iRow
103680>>>                Repeat
103680>>>>
103680>>>                    Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
103683>>>                    Set piPosition of ghoProgressBar to iCount
103684>>>
103684>>>                    If (hTable > 0 and hTable <> 50) Begin
103686>>>                        Move hTable                                   to TheData[iRow].sValue[iTableNo]
103687>>>                        Get_Attribute DF_FILE_ROOT_NAME     of hTable to TheData[iRow].sValue[iRoot]
103690>>>                        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
103693>>>                        Move sLogicalName                             to TheData[iRow].sValue[iLogical]
103694>>>                        If (Uppercase(sLogicalName) = "DBVERSION") Begin
103696>>>                            Set phDbVersion to hTable
103697>>>                        End
103697>>>>
103697>>>                        Get_Attribute DF_FILE_DISPLAY_NAME  of hTable to TheData[iRow].sValue[iDisplay]
103700>>>                        Get UtilTableIsAlias of ghoDbUpdateFunctionLibrary hTable to bIsAlias
103701>>>                        Move bIsAlias                                 to TheData[iRow].sValue[iIsAlias]
103702>>>                        If (bIsAlias = True) Begin
103704>>>                            Increment iAliasCount
103705>>>                        End
103705>>>>
103705>>>                        Move False to TheData[iRow].sValue[iChecked]
103706>>>                        Increment iRow
103707>>>                    End
103707>>>>
103707>>>                    Increment iCount
103708>>>                    Get Check_StatusPanel of ghoStatusPanel to bUserCancel
103709>>>                    If (bUserCancel = True) Begin
103711>>>                        Move TheDataEmpty to TheData
103712>>>                        Move 0 to iRow
103713>>>                        Move 0 to iAliasCount
103714>>>                        Move 0 to hTable
103715>>>                    End
103715>>>>
103715>>>                Until (hTable = 0)
103717>>>
103717>>>                If (iRow <> 0) Begin
103719>>>                    Send ReInitializeData TheData False
103720>>>                    Send MoveToFirstRow
103721>>>                End
103721>>>>
103721>>>                Else Begin
103722>>>                    Send InitializeData TheDataEmpty
103723>>>                End
103723>>>>
103723>>>                Set psFooterText of oDisplayName_col to ("No of Tables:" * String(iRow))
103724>>>                Set psFooterText of oIsAlias_Col     to ("Count:" * String(iAliasCount))
103725>>>                Send Stop_StatusPanel of ghoStatusPanel
103726>>>            End_Procedure
103727>>>
103727>>>            Function SelectedTableNumber Returns Handle
103730>>>                Integer hTable iTableNo iRowNo
103730>>>                Handle hoDataSource
103730>>>                tDataSourceRow[] TheData
103730>>>                tDataSourceRow[] TheData
103731>>>
103731>>>                Get phoDataSource to hoDataSource
103732>>>                Get piColumnId of oFilelistNumber_col to iTableNo
103733>>>                Get DataSource of hoDataSource to TheData
103734>>>                Get SelectedRow of hoDataSource to iRowNo
103735>>>                Move TheData[iRowNo].sValue[iTableNo] to hTable
103736>>>
103736>>>                Function_Return hTable
103737>>>            End_Function
103738>>>
103738>>>            Function GenerateSourceFileName Returns String
103741>>>                String sRetval sPath sFileListName sTableName sVersionNumber
103741>>>                Boolean bExists
103741>>>                Integer iLogical iRowNo iSelected iPos
103741>>>                tDataSourceRow[] TheData
103741>>>                tDataSourceRow[] TheData
103742>>>                Handle hoDataSource
103742>>>                Number nVersionNumber
103742>>>
103742>>>                Get Value of oFilelistPath_fm to sFileListName
103743>>>                Get vFilePathExists sFileListName to bExists
103744>>>                If (bExists = False) Begin
103746>>>                    Function_Return ""
103747>>>                End
103747>>>>
103747>>>
103747>>>                Get Value of oPnVersionNumber_fm to nVersionNumber
103748>>>                Move nVersionNumber to sVersionNumber
103749>>>                Move (Pos(".", sVersionNumber)) to iPos
103750>>>                If (iPos = 0) Begin
103752>>>                    Move (sVersionNumber + String(".0")) to sVersionNumber
103753>>>                End
103753>>>>
103753>>>                Move (Replaces(".", sVersionNumber, "_")) to sVersionNumber
103754>>>
103754>>>                Get ParseFolderName sFileListName to sPath
103755>>>                Get vParentPath sPath   to sPath
103756>>>                Get vFolderFormat sPath to sPath
103757>>>                Move (sPath + "AppSrc") to sPath
103758>>>                Get vFolderFormat sPath to sPath
103759>>>
103759>>>                Get phoDataSource to hoDataSource
103760>>>                Get piColumnid of oLogicalName_col to iLogical
103761>>>                Get DataSource of hoDataSource to TheData
103762>>>                Get CheckedItems to iSelected
103763>>>                If (iSelected > 1) Begin
103765>>>                    Move "MultipleTables" to sTableName
103766>>>                End
103766>>>>
103766>>>                Else Begin
103767>>>                    If (SizeOfArray(TheData) <> 0) Begin
103769>>>                        Get SelectedRow of hoDataSource to iRowNo
103770>>>                        Move TheData[iRowNo].sValue[iLogical] to sTableName
103771>>>                    End
103771>>>>
103771>>>                End
103771>>>>
103771>>>                Move ("DUF_" + sTableName + String(sVersionNumber) + ".pkg") to sTableName
103772>>>
103772>>>                Move (sPath + sTableName) to sRetval
103773>>>
103773>>>                Function_Return sRetval
103774>>>            End_Function
103775>>>
103775>>>            Function piCheckboxCol Returns Integer
103778>>>                Integer iIndex
103778>>>                Get piColumnId of oCheckbox_Col to iIndex
103779>>>                Function_Return iIndex
103780>>>            End_Function
103781>>>
103781>>>            // Returns the checked state for the checkbox column
103781>>>            // and the passed row number.
103781>>>            Function FindCheckedState Integer iRow Returns Boolean
103784>>>                Integer iCol
103784>>>                Handle hoDataSource
103784>>>                tDataSourceRow[] TheData
103784>>>                tDataSourceRow[] TheData
103785>>>                Boolean bChecked
103785>>>
103785>>>                Get piCheckboxCol to iCol
103786>>>                If (iCol < 0) Begin
103788>>>                    Send UserError "No piCheckboxCol has been set. Cannot return value"
103789>>>                    Procedure_Return
103790>>>                End
103790>>>>
103790>>>                Get phoDataSource               to hoDataSource
103791>>>                Get DataSource of hoDataSource  to TheData
103792>>>                Move TheData[iRow].sValue[iCol] to bChecked
103793>>>
103793>>>                Function_Return bChecked
103794>>>            End_Function
103795>>>
103795>>>            Procedure DoSetCheckboxFooterText
103798>>>                Integer iCol iSelected
103798>>>                Handle hoCol
103798>>>                Get piCheckboxCol to iCol
103799>>>                Get ColumnObject iCol to hoCol
103800>>>                Get CheckedItems to iSelected
103801>>>                Set psFooterText of hoCol to ("Selected:" * String(iSelected))
103802>>>            End_Procedure
103803>>>
103803>>>            // Set checkboxes of the first column as selected.
103803>>>            // iState can be one of the following:
103803>>>            // cx_Select_All, cx_Select_None or cx_Select_Invert
103803>>>            Procedure Set SelectItems Integer iState
103806>>>                Integer i iItems
103806>>>                Integer iCheckbox_Col
103806>>>                Boolean bChecked
103806>>>                Handle hoDataSource
103806>>>                tDataSourceRow[] TheData
103806>>>                tDataSourceRow[] TheData
103807>>>                String[] sFilesArray
103808>>>                String sSourceFile
103808>>>
103808>>>                Get piColumnId of oCheckbox_Col to iCheckbox_Col
103809>>>                Get phoDataSource                to hoDataSource
103810>>>                Get DataSource of hoDataSource   to TheData
103811>>>                Move (SizeOfArray(TheData))      to iItems
103812>>>                Decrement iItems
103813>>>                For i from 0 to iItems
103819>>>>
103819>>>                    Case Begin
103819>>>                        Case (iState = cx_Select_All)
103821>>>                            Move True to TheData[i].sValue[iCheckbox_Col]
103822>>>                            Break
103823>>>                        Case (iState = cx_Select_None)
103826>>>                            Move False to TheData[i].sValue[iCheckbox_Col]
103827>>>                            Break
103828>>>                        Case (iState = cx_Select_Invert)
103831>>>                            Move TheData[i].sValue[iCheckbox_Col] to bChecked
103832>>>                            Move (not(bChecked)) to  TheData[i].sValue[iCheckbox_Col]
103833>>>                            Break
103834>>>                    Case End
103834>>>                Loop
103835>>>>
103835>>>
103835>>>                Send ReInitializeData TheData False
103836>>>                Send DoSetCheckboxFooterText
103837>>>                Get GenerateSourceFileName  to sSourceFile
103838>>>                Set Value of oSourceName_fm to sSourceFile
103839>>>            End_Procedure
103840>>>
103840>>>            // Selects all items
103840>>>            Procedure SelectAll
103843>>>                Set SelectItems to cx_Select_All
103844>>>            End_Procedure
103845>>>
103845>>>            // Deselects all items
103845>>>            Procedure SelectNone
103848>>>                Set SelectItems to cx_Select_None
103849>>>            End_Procedure
103850>>>
103850>>>            // Inverts the current selections
103850>>>            Procedure SelectInvert
103853>>>                Set SelectItems to cx_Select_Invert
103854>>>            End_Procedure
103855>>>
103855>>>            // Returns a string array with the selected items.
103855>>>            Function SelectedItems Returns tGeneratorRow[]
103858>>>                Integer[] SelRows
103859>>>                Integer i iItems iSize iCheckbox_Col iFilelistNo_Col iLogical_Col iRoot_Col iDisplay_Col iIsAlias_Col
103859>>>                String sFileName
103859>>>                String[] sFilesArray
103860>>>                Handle hoDataSource
103860>>>                tDataSourceRow[] TheData
103860>>>                tDataSourceRow[] TheData
103861>>>                Boolean bChecked bIsAlias
103861>>>                tGeneratorRow[] GeneratorRowArray
103861>>>                tGeneratorRow[] GeneratorRowArray
103862>>>
103862>>>                Get piColumnId of oFilelistNumber_col to iFilelistNo_Col
103863>>>                Get piColumnId of oLogicalName_col    to iLogical_Col
103864>>>                Get piColumnId of oRootName_col       to iRoot_Col
103865>>>                Get piColumnId of oDisplayName_col    to iDisplay_Col
103866>>>                Get piColumnId of oIsAlias_Col        to iIsAlias_Col
103867>>>                Get piColumnId of oCheckbox_Col       to iCheckbox_Col
103868>>>
103868>>>                Get phoDataSource to hoDataSource
103869>>>                Get DataSource of hoDataSource to TheData
103870>>>                Move (SizeOfArray(TheData)) to iItems
103871>>>                Decrement iItems
103872>>>
103872>>>                For i from 0 to iItems
103878>>>>
103878>>>                    Move TheData[i].sValue[iCheckbox_Col] to bChecked
103879>>>                    If (bChecked = True) Begin
103881>>>                        Move (SizeOfArray(GeneratorRowArray)) to iSize
103882>>>                        Move TheData[i].sValue[iFilelistNo_Col] to GeneratorRowArray[iSize].hTable
103883>>>                        Move TheData[i].sValue[iLogical_Col]    to GeneratorRowArray[iSize].sLogicalName
103884>>>                        Move TheData[i].sValue[iRoot_Col]       to GeneratorRowArray[iSize].sRootName
103885>>>                        Move TheData[i].sValue[iDisplay_Col]    to GeneratorRowArray[iSize].sDisplayName
103886>>>                        Move TheData[i].sValue[iIsAlias_Col]    to GeneratorRowArray[iSize].bIsAlias
103887>>>                        Move TheData[i].sValue[iCheckbox_Col]   to GeneratorRowArray[iSize].bSelected
103888>>>                        Move sFileName to sFilesArray[iSize]
103889>>>                    End
103889>>>>
103889>>>                Loop
103890>>>>
103890>>>
103890>>>                Function_Return GeneratorRowArray
103891>>>            End_Function
103892>>>
103892>>>            // Returns the number of items that has been selected.
103892>>>            // It is a bit confusing with the SelectedItems function above,
103892>>>            // but it is how it was designed from the beginning. The
103892>>>            // SelectedItems function returns an array of all selected files,
103892>>>            // while this function returns the number of selected items only.
103892>>>            // The purpose is to use it in e.g. a checkbox grid column object
103892>>>            // to show the current no of selected items.
103892>>>            Function CheckedItems Returns Integer
103895>>>                Integer iCount iItems iCheckbox_Col iRetval
103895>>>                Handle hoDataSource
103895>>>                tDataSourceRow[] TheData
103895>>>                tDataSourceRow[] TheData
103896>>>                Boolean bChecked
103896>>>
103896>>>                Get piCheckboxCol to iCheckbox_Col
103897>>>                Get phoDataSource to hoDataSource
103898>>>                Get DataSource of hoDataSource to TheData
103899>>>                Move (SizeOfArray(TheData)) to iItems
103900>>>                Decrement iItems
103901>>>
103901>>>                For iCount from 0 to iItems
103907>>>>
103907>>>                    Move TheData[iCount].sValue[iCheckbox_Col] to bChecked
103908>>>                    If (bChecked = True) Begin
103910>>>                        Increment iRetval
103911>>>                    End
103911>>>>
103911>>>                Loop
103912>>>>
103912>>>
103912>>>                Function_Return iRetval
103913>>>            End_Function
103914>>>
103914>>>            // Toggles the current row on/off (the checkbox)
103914>>>            Procedure ToggleCurrentItem
103917>>>                Boolean bChecked
103917>>>                Integer iCol
103917>>>                Handle hoCol
103917>>>                String sSourceFile
103917>>>
103917>>>                Get piCheckboxCol       to iCol
103918>>>                Get ColumnObject iCol   to hoCol
103919>>>                Get SelectedRowValue    of hoCol to bChecked
103920>>>                Send UpdateCurrentValue of hoCol (not(bChecked))
103921>>>                Send Request_Save
103922>>>                Get GenerateSourceFileName  to sSourceFile
103923>>>                Set Value of oSourceName_fm to sSourceFile
103924>>>                Send DoSetCheckboxFooterText
103925>>>            End_Procedure
103926>>>
103926>>>            Procedure Request_Clear
103929>>>                Delegate Send Request_Clear
103931>>>            End_Procedure
103932>>>
103932>>>            Procedure OnComMouseUp Short llButton Short llShift Integer llx Integer lly
103935>>>                Forward Send OnComMouseUp llButton llShift llx lly
103937>>>                Send Request_Save
103938>>>                Send DoSetCheckboxFooterText
103939>>>            End_Procedure
103940>>>
103940>>>            Procedure OnRowChanged Integer iOldRow Integer iNewSelectedRow
103943>>>                String sSourceFile
103943>>>                Handle hTable
103943>>>
103943>>>                Forward Send OnRowChanged iOldRow iNewSelectedRow
103945>>>
103945>>>                Get SelectedTableNumber to hTable
103946>>>                Get GenerateSourceFileName  to sSourceFile
103947>>>                Set Value of oSourceName_fm to sSourceFile
103948>>>                Set piCurrentRow to iNewSelectedRow
103949>>>            End_Procedure
103950>>>
103950>>>            Procedure MoveToNextGroup
103953>>>                Send Activate of oSelectAll_btn
103954>>>            End_Procedure
103955>>>
103955>>>            Procedure MoveToPreviousGroup
103958>>>                Send Activate of oFilelistPath_fm
103959>>>            End_Procedure
103960>>>
103960>>>            Function HasRecords Returns Boolean
103963>>>                Handle hoDataSource
103963>>>                tDataSourceRow[] TheData
103963>>>                tDataSourceRow[] TheData
103964>>>                Integer iItems
103964>>>
103964>>>                Get phoDataSource to hoDataSource
103965>>>                Get DataSource of hoDataSource to TheData
103966>>>                Move (SizeOfArray(TheData)) to iItems
103967>>>                Function_Return (iItems <> 0)
103968>>>            End_Function
103969>>>
103969>>>            On_Key Key_Space         Send ToggleCurrentItem
103970>>>            On_Key Key_Tab           Send MoveToNextGroup
103971>>>            On_Key Key_Shift+Key_Tab Send MoveToPreviousGroup
103972>>>        End_Object
103973>>>
103973>>>        Object oSelectAll_btn is a cButtonDPI
103975>>>            Set Size to 14 45
103976>>>            Set Location to 4 294
103977>>>            Set Label to "&All"
103978>>>            Set MultiLineState to True
103979>>>            Set peAnchors to anTopRight
103980>>>            Set psImage to "SelectAllBlack.ico"
103981>>>            Set psToolTip to "Select all"
103982>>>
103982>>>            Procedure OnClick
103985>>>                Set SelectItems of oFilelist_grd to cx_Select_All
103986>>>            End_Procedure
103987>>>
103987>>>        End_Object
103988>>>
103988>>>        Object oDeSelectAll_btn is a cButtonDPI
103990>>>            Set Size to 14 45
103991>>>            Set Location to 4 343
103992>>>            Set Label to "&None"
103993>>>            Set peAnchors to anTopRight
103994>>>            Set psImage to "SelectNoneBlack.ico"
103995>>>            Set psToolTip to "Select none"
103996>>>
103996>>>            Procedure OnClick
103999>>>                Set SelectItems of oFilelist_grd to cx_Select_None
104000>>>            End_Procedure
104001>>>
104001>>>        End_Object
104002>>>
104002>>>        Object oInvertSelection_btn is a cButtonDPI
104004>>>            Set Size to 14 45
104005>>>            Set Location to 4 392
104006>>>            Set Label to "&Invert"
104007>>>            Set peAnchors to anTopRight
104008>>>            Set psImage to "SelectInvertBlack.ico"
104009>>>            Set psToolTip to "Invert selection"
104010>>>            Procedure OnClick
104013>>>                Set SelectItems of oFilelist_grd to cx_Select_Invert
104014>>>            End_Procedure
104015>>>        End_Object
104016>>>
104016>>>        // Needed to not close the view when Esc is hit in the grid.
104016>>>        On_Key kCancel Send None
104017>>>    End_Object
104018>>>
104018>>>    Object oConfigureGeneration_grp is a cHeaderGroup
104020>>>        Set Size to 52 462
104021>>>        Set Location to 172 19
104022>>>        Set peAnchors to anBottomLeftRight
104023>>>        Set psImage to "SettingsBlack.ico"
104024>>>        Set psLabel to "Configure Code Generation"
104025>>>
104025>>>        Object oUseConnectionID_cb is a cSQLCheckBox
104027>>>            Set Auto_Size_State to False
104028>>>            Set Size to 9 78
104029>>>            Set Location to 23 26
104030>>>            Set Label to "Use Connection ID"
104031>>>            Set Checked_State to True
104032>>>            Set psToolTip to "If True (the default); uses the Connection ID of the connection string as defined by the SQLConnection.ini setting"
104033>>>        End_Object
104034>>>
104034>>>        Object oANSI_cb is a cSQLCheckBox
104036>>>            Set Auto_Size_State to False
104037>>>            Set Size to 9 73
104038>>>            Set Location to 23 131
104039>>>            Set Label to "ANSI/OEM"
104040>>>            Set Checked_State to True
104041>>>            Set psToolTip to "DataFlex data is stored in OEM format. Non-DataFlex back ends may expect the data to be stored in ANSI format. When defining the conversion options you can define the table character format to be used in the converted table."
104042>>>        End_Object
104043>>>
104043>>>        Object oRecnum_cb is a cSQLCheckBox
104045>>>            Set Auto_Size_State to False
104046>>>            Set Size to 9 75
104047>>>            Set Location to 23 219
104048>>>            Set Label to "Use Recnum"
104049>>>            Set Checked_State to True
104050>>>            Set psToolTip to "If the program that is using the source database uses the recnum programming style, the tables should be converted to recnum tables. If the program uses the RowId programming style, converting to standard tables is recommended."
104051>>>        End_Object
104052>>>
104052>>>        Object oApiTableUpdateAuto_cb is a cSQLCheckBox
104054>>>            Set Auto_Size_State to False
104055>>>            Set Size to 9 93
104056>>>            Set Location to 23 321
104057>>>            Set Label to "Auto Update Table"
104058>>>            Set Checked_State to True
104059>>>            Set psToolTip to "When set to True, 'TO' tables will get converted to the same database format as the 'FROM' tables. So if a 'FROM' table is an SQL table and the 'TO' table is in the embedded format (DataFlex table), it will be converted to SQL."
104060>>>        End_Object
104061>>>
104061>>>        Object oCompareDate_DataTime_cb is a cSQLCheckBox
104063>>>            Set Auto_Size_State to False
104064>>>            Set Size to 9 101
104065>>>            Set Location to 36 26
104066>>>            Set Label to "Compare Date/DataTime"
104067>>>            Set Checked_State to False
104068>>>            Set psToolTip to "Check Date to DateTime column differences"
104069>>>        End_Object
104070>>>
104070>>>        Object oCompareIndexAscending_cb is a cSQLCheckBox
104072>>>            Set Auto_Size_State to False
104073>>>            Set Size to 9 84
104074>>>            Set Location to 36 131
104075>>>            Set Label to "Compare Ascending"
104076>>>            Set Checked_State to False
104077>>>            Set psToolTip to "Compare if Index is Ascending/Descending. (In SQL this setting is set for the whole database by selecting a 'Collation', so then checking this per table doesn't make sense)"
104078>>>        End_Object
104079>>>
104079>>>        Object oCompareIndexUppercase_cb is a cSQLCheckBox
104081>>>            Set Auto_Size_State to False
104082>>>            Set Size to 9 98
104083>>>            Set Location to 36 219
104084>>>            Set Label to "Compare Uppercase"
104085>>>            Set Checked_State to False
104086>>>            Set psToolTip to "Compare if Index is Uppercase/Lowercase. (In SQL this setting is set for the whole database by selecting a 'Collation', so then checking this per table doesn't make sense)"
104087>>>        End_Object
104088>>>
104088>>>        Object oIgnoreFilelistUppercase_cb is a cSQLCheckBox
104090>>>            Set Auto_Size_State to False
104091>>>            Set Size to 9 135
104092>>>            Set Location to 36 321
104093>>>            Set Label to "Uppercase/Lowercase Table Names"
104094>>>            Set Checked_State to True
104095>>>            Set psToolTip to "Check Filelist.cfg RootName, LogicalName and DisplayName uppercase/lowercase differences"
104096>>>        End_Object
104097>>>
104097>>>        Procedure ToggleCurrentItem
104100>>>            Boolean bChecked
104100>>>            Handle hObject
104100>>>
104100>>>            Get Focus to hObject
104101>>>            Get Checked_State of hObject to bChecked
104102>>>            Set Checked_State of hObject to (not(bChecked))
104103>>>        End_Procedure
104104>>>
104104>>>    End_Object
104105>>>
104105>>>    Object oGenerateFilename_grp is a cHeaderGroup
104107>>>        Set Size to 43 462
104108>>>        Set Location to 234 19
104109>>>        Set peAnchors to anBottomLeftRight
104110>>>        Set psImage to "ActionSaveBlack.ico"
104111>>>        Set psLabel to "Configure Generated File Name"
104112>>>
104112>>>        Object oPnVersionNumber_fm is a Form
104114>>>            Set Size to 13 22
104115>>>            Set Location to 21 108
104116>>>            Set Label to "Next pnVersionNumber"
104117>>>            Set psToolTip to "This value is the current DbVersion.DatabaseVersion value, with a value of 0.1 added to it."
104118>>>            Set Status_Help to "The current DbVersion.DatabaseVersion value, with a value of 0.1 added to it."
104119>>>            Set Value to 0
104120>>>            Set peAnchors to anBottomLeft
104121>>>            Set Label_Justification_Mode to JMode_Right
104122>>>            Set Label_Col_Offset to 2
104123>>>            Set Form_Datatype to Mask_Numeric_Window
104124>>>            Set Numeric_Mask 0 to 4 1
104125>>>
104125>>>            Procedure OnChange
104128>>>                String sSourceFile
104128>>>                Get GenerateSourceFileName of oFilelist_grd  to sSourceFile
104129>>>                Set Value of oSourceName_fm to sSourceFile
104130>>>            End_Procedure
104131>>>
104131>>>        End_Object
104132>>>
104132>>>        Object oSourceName_fm is a Form
104134>>>            Set Size to 13 304
104135>>>            Set Location to 21 134
104136>>>            Set peAnchors to anBottomLeftRight
104137>>>            Set Label_Col_Offset to 0
104138>>>            Set Label_Justification_Mode to JMode_Top
104139>>>            Set Label_Row_Offset to 1
104140>>>            Set psToolTip to "The name of the output file to be generated."
104141>>>            Set Status_Help to "The name of the output file to be generated."
104142>>>        End_Object
104143>>>
104143>>>    End_Object
104144>>>
104144>>>    Object oBusinessProcess is a BusinessProcess
104146>>>        Set Status_Panel_Id to ghoStatusPanel
104147>>>        Set Allow_Cancel_State to True
104148>>>        Set Process_Caption to "The Database Update Framework"
104149>>>        Set Process_Title to "Generating Database Update Code..."
104150>>>        Set Process_Message to "For table:"
104151>>>
104151>>>        Procedure OnProcess
104154>>>            Send StartGenerateCode
104155>>>        End_Procedure
104156>>>
104156>>>        Procedure Ignore_Error Integer iError
104159>>>        End_Procedure
104160>>>        Procedure Trap_Error Integer iError
104163>>>        End_Procedure
104164>>>
104164>>>    End_Object
104165>>>
104165>>>    Object oGenerateCode_btn is a cButtonDPI
104167>>>        Set Size to 23 58
104168>>>        Set Location to 284 348
104169>>>        Set Label to "&Generate Code!"
104170>>>        Set FontWeight to fw_Bold
104171>>>        Set peAnchors to anBottomRight
104172>>>        Set psToolTip to "Start generating Database Update Framework code for the selected table(s)."
104173>>>        Set Default_State to True
104174>>>        Set MultiLineState to True
104175>>>        Set psImage to "SqlScriptBlack2.ico"
104176>>>
104176>>>        Procedure OnClick
104179>>>            Boolean bExists
104179>>>            String sSourceFile
104179>>>            Integer iSelected iRetval
104179>>>
104179>>>            Get Value of oSourceName_fm to sSourceFile
104180>>>            Get vFilePathExists sSourceFile to bExists
104181>>>            If (bExists = True) Begin
104183>>>                Get YesNo_Box ("Oops, the source file" * sSourceFile * "already exists!\n\nDo you want to overwrite it?") to iRetval
104184>>>                If (iRetval <> MBR_Yes) Begin
104186>>>                    Procedure_Return
104187>>>                End
104187>>>>
104187>>>            End
104187>>>>
104187>>>
104187>>>            Get CheckedItems  of oFilelist_grd to iSelected
104188>>>            If (iSelected = 0) Begin
104190>>>                Send Info_Box "No tables selected. Please adjust and try again."
104191>>>                Procedure_Return
104192>>>            End
104192>>>>
104192>>>
104192>>>            Send DoProcess of oBusinessProcess
104193>>>            Send Restore_DF_OPEN_PATH of ghoApplication
104194>>>        End_Procedure
104195>>>
104195>>>        Procedure DoEnable
104198>>>            String sSourceName
104198>>>            Integer iSelected
104198>>>
104198>>>            Get Value of oSourceName_fm to sSourceName
104199>>>            If (sSourceName = "") Begin
104201>>>                Set Enabled_State to False
104202>>>                Procedure_Return
104203>>>            End
104203>>>>
104203>>>
104203>>>            Get CheckedItems  of oFilelist_grd to iSelected
104204>>>            Set Enabled_State to (iSelected <> 0)
104205>>>        End_Procedure
104206>>>
104206>>>    End_Object
104207>>>
104207>>>    Object oOpenAppSrcFolder_btn is a cButtonDPI
104209>>>        Set Size to 23 65
104210>>>        Set Location to 284 418
104211>>>        Set Label to "&Open Location"
104212>>>        Set peAnchors to anBottomRight
104213>>>        Set psToolTip to "Open the source location in Windows Explorer"
104214>>>        Set MultiLineState to True
104215>>>        Set psImage to "ActionOpenBlack.ico"
104216>>>
104216>>>        Procedure OnClick
104219>>>            String sPath sSourceName
104219>>>            Get Value of oSourceName_fm to sSourceName
104220>>>            Get ParseFolderName sSourceName to sPath
104221>>>            Runprogram Shell Background "Explorer.exe" sPath
104222>>>        End_Procedure
104223>>>
104223>>>        Procedure DoEnable
104226>>>            String sPath sSourceName
104226>>>            Boolean bExists
104226>>>
104226>>>            Get Value of oSourceName_fm to sSourceName
104227>>>            Get ParseFolderName sSourceName to sPath
104228>>>            Get vFolderExists sPath to bExists
104229>>>            Set Enabled_State to (bExists = True)
104230>>>        End_Procedure
104231>>>
104231>>>    End_Object
104232>>>
104232>>>    Procedure StartGenerateCode
104235>>>        String sSourceFile
104235>>>        Boolean bUseConnectionID bANSI bRecnum bCompareIndexUppercase bCompareIndexAscending
104235>>>        Handle hTable
104235>>>        Integer iErrors
104235>>>        Number nVersionNumber
104235>>>        tGeneratorRow[] TheData
104235>>>        tGeneratorRow[] TheData
104236>>>        tAPITableBooleans CompareTableBooleans
104236>>>        tAPITableBooleans CompareTableBooleans
104236>>>
104236>>>        Get Value of oSourceName_fm                      to sSourceFile
104237>>>        Get Checked_State of oUseConnectionID_cb         to bUseConnectionID
104238>>>        Get Checked_State of oANSI_cb                    to bANSI
104239>>>        Get Checked_State of oRecnum_cb                  to bRecnum
104240>>>        Get Checked_State of oApiTableUpdateAuto_cb      to CompareTableBooleans.bApiTableUpdateAuto
104241>>>        Get Checked_State of oCompareDate_DataTime_cb    to CompareTableBooleans.bCompareDate_DateTime
104242>>>        Get Checked_State of oCompareIndexAscending_cb   to CompareTableBooleans.bCompareIndexAscending
104243>>>        Get Checked_State of oCompareIndexUppercase_cb   to CompareTableBooleans.bCompareIndexUppercase
104244>>>        Get Checked_State of oIgnoreFilelistUppercase_cb to CompareTableBooleans.bCompareFilelistUppercase
104245>>>
104245>>>        Get SelectedItems of oFilelist_grd to TheData
104246>>>        Get Value of oPnVersionNumber_fm to nVersionNumber
104247>>>        Get GenerateDUFSourceCode sSourceFile TheData nVersionNumber bUseConnectionID bANSI bRecnum CompareTableBooleans to iErrors
104248>>>
104248>>>        If (iErrors = GenerateChannelError) Begin
104250>>>            Send Info_Box "Sorry, couldn't retrieve a free channel number. Process halted."
104251>>>        End
104251>>>>
104251>>>        If (iErrors = GenerateUserInputError) Begin
104253>>>            Send Info_Box "Table number and pnVersionNumber both needs to be > 0. Please adjust and try again."
104254>>>        End
104254>>>>
104254>>>
104254>>>        Send Stop_StatusPanel of ghoStatusPanel
104255>>>        If (iErrors = GenerateOK) Begin
104257>>>            Send Info_Box "Ready!"
104258>>>        End
104258>>>>
104258>>>        If (iErrors = GenerateError) Begin
104260>>>            Send Info_Box ("Ready! But the code contains ERRORS because there were fields with length = 0! Search the generated code for the word 'ERROR!' to see those fields.")
104261>>>        End
104261>>>>
104261>>>        If (iErrors = GenerateOpenTableError) Begin
104263>>>            Send Info_Box ("Sorry, couldn't open the table! (Table No:" * String(phTable(Self)) * String(psFileName(Self)) + ") Process halted.")
104264>>>        End
104264>>>>
104264>>>        If (iErrors = GenerateUserCancel) Begin
104266>>>            Send Info_Box "Process cancelled by user."
104267>>>        End
104267>>>>
104267>>>    End_Procedure
104268>>>
104268>>>    Function GenerateDUFSourceCode String sSourceFile tGeneratorRow[] TheData Number nVersionNumber Boolean bUseConnectionID Boolean bANSI Boolean bRecnum tAPITableBooleans CompareTableBooleans Returns Integer
104271>>>        Boolean bApiTableUpdateAuto bCompare_DateTime bCompareIndexAscending bCompareIndexUppercase bCompareFilelistUppercase
104271>>>        Integer iCh iColumn iLength iPrecision iOptions iCount iSize iTable iTables
104271>>>        Integer iIndex iIndexes iSegment iNumSegments iType iErrors iStatus
104271>>>        Boolean bOpened bOK bDawSqlDriver bIsAlias bSqlDriver bSkipTable
104271>>>        String sRootName sLogicalName sDisplayName sTableName sFieldName sDataType sDriverID
104271>>>        Handle hTable
104271>>>        tAPITableNameInfo  APITableNameInfo
104271>>>        tAPITableNameInfo  APITableNameInfo
104271>>>        tAPIColumn[]   APIColumns
104271>>>        tAPIColumn[]   APIColumns
104272>>>        tAPIRelation[] APIRelations
104272>>>        tAPIRelation[] APIRelations
104273>>>        tAPIIndex[]    APIIndexes
104273>>>        tAPIIndex[]    APIIndexes
104274>>>        DateTime dtCreationTime
104274>>>
104274>>>        Move (CurrentDateTime()) to dtCreationTime
104275>>>        Move 0 to iErrors
104276>>>        Move (SizeOfArray(TheData)) to iTables
104277>>>        Decrement iTables
104278>>>        Move 0 to iTable
104279>>>        Move TheData[iTable].hTable to hTable
104280>>>
104280>>>        Get Seq_Open_Output_Channel sSourceFile to iCh
104281>>>        If (iCh = DF_SEQ_CHANNEL_ERROR) Begin
104283>>>            Function_Return GenerateChannelError
104284>>>        End
104284>>>>
104284>>>
104284>>>        If (hTable < 1 or nVersionNumber <= 0) Begin
104286>>>            Function_Return GenerateUserInputError
104287>>>        End
104287>>>>
104287>>>
104287>>>        Send Initialize_StatusPanel of ghoStatusPanel "The Database Update Framework" "Generating Update Code" ""
104288>>>        Send Start_StatusPanel of ghoStatusPanel
104289>>>        Set pbVisible of ghoProgressBar to True
104290>>>        Set pbVisible of ghoProgressBarOverall to True
104291>>>        Set piMaximum of ghoProgressBarOverall to iTables
104292>>>        
104292>>>        Move CompareTableBooleans.bApiTableUpdateAuto       to bApiTableUpdateAuto
104293>>>        Move CompareTableBooleans.bCompareDate_DateTime     to bCompare_DateTime
104294>>>        Move CompareTableBooleans.bCompareFilelistUppercase to bCompareFilelistUppercase
104295>>>        Move CompareTableBooleans.bCompareIndexAscending    to bCompareIndexAscending
104296>>>        Move CompareTableBooleans.bCompareIndexUppercase    to bCompareIndexUppercase
104297>>>
104297>>>        Get UtilTableOpen of ghoDbUpdateFunctionLibrary hTable "" DF_SHARE to bOpened
104298>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
104301>>>        If (bOpened = False) Begin
104303>>>            Send Seq_Close_Channel iCh
104304>>>            Set phTable to hTable
104305>>>            Set psFileName to TheData[iTable].sLogicalName
104306>>>            Function_Return GenerateOpenTableError
104307>>>        End
104307>>>>
104307>>>
104307>>>        Writeln channel iCh "/" "/ " CS_DatabaseUpdateFramework
104312>>>        Writeln channel iCh ("/" + "/ Created by: 'DUF Update Code Generator'. Created:" * String(dtCreationTime))
104315>>>        Writeln channel iCh ("Use cDbUpdateVersion.pkg")
104318>>>        Writeln channel iCh
104320>>>        Writeln channel iCh ("Object oDbUdpateVersion" + String(nVersionNumber) * "is a cDbUpdateVersion")
104323>>>        Writeln channel iCh ("    Set pnVersionNumber to" * String(nVersionNumber))
104326>>>        Writeln channel iCh ("    Procedure OnUpdate")
104329>>>        Writeln channel iCh ("        Boolean bOK")
104332>>>        Writeln channel iCh ("        tAPITableNameInfo APITableNameInfo")
104335>>>        Writeln channel iCh ("        tAPIColumn[]   APIColumns APIColumnEmpty")
104338>>>        Writeln channel iCh ("        tAPIIndex[]    APIIndexes APIIndexEmpty")
104341>>>        Writeln channel iCh ("        tAPIRelation[] APIRelations APIRelationEmpty")
104344>>>        Writeln channel iCh ("        Integer iCount iSegment")
104347>>>        Writeln channel iCh ("        Handle hTable")
104350>>>        Writeln channel iCh
104352>>>        Writeln channel iCh ("        Set pbUseConnectionID       to" * If(bUseConnectionID, "True", "False"))
104355>>>        Writeln channel iCh ("        Set pbToAnsi                to" * If(bANSI, "True", "False"))
104358>>>        Writeln channel iCh ("        Set pbRecnum                to" * If(bRecnum, "True", "False"))
104361>>>        Writeln channel iCh ("        Set pbApiTableUpdateAuto    to" * If(bApiTableUpdateAuto, "True", "False"))
104364>>>        Writeln channel iCh ("        Set pbCompareDate_DateTime  to" * If(bCompare_DateTime, "True", "False"))
104367>>>        Writeln channel iCh ("        Set pbCompareIndexAscending to" * If(bCompareIndexAscending, "True", "False"))
104370>>>        Writeln channel iCh ("        Set pbCompareIndexUppercase to" * If(bCompareIndexUppercase, "True", "False"))
104373>>>        Writeln channel iCh
104375>>>        Writeln channel iCh ("        Set Allow_Cancel_State of ghoStatusPanel  to False")
104378>>>        Writeln channel iCh ("        Set pbVisible    of ghoProgressBarOverall to True")
104381>>>        Writeln channel iCh ("        Set piPosition   of ghoProgressBarOverall to 0")
104384>>>        Writeln channel iCh ("        Set piMaximum    of ghoProgressBarOverall to" * String(iTables))
104387>>>        Writeln channel iCh ("        Set piAdvanceBy  of ghoProgressBarOverall to 1")
104390>>>        Writeln channel iCh ("        Send DoAdvance   of ghoProgressBarOverall")   
104393>>>        Writeln channel iCh ("        Move 0 to iCount")
104396>>>        Writeln channel iCh
104398>>>
104398>>>        // Create Definitions:
104398>>>        Move 0 to iTable
104399>>>        For iTable from 0 to iTables
104405>>>>
104405>>>            Set piPosition of ghoProgressBarOverall to iTable
104406>>>            Move TheData[iTable].hTable to hTable
104407>>>            Get UtilTableOpen of ghoDbUpdateFunctionLibrary hTable "" DF_SHARE to bOpened
104408>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
104411>>>            If (bOpened = False) Begin
104413>>>                Send Seq_Close_Channel iCh
104414>>>                Set phTable to hTable
104415>>>                Set psTableName to TheData[iTable].sLogicalName
104416>>>                Function_Return GenerateOpenTableError
104417>>>            End
104417>>>>
104417>>>            
104417>>>            Move (Uppercase(TheData[iTable].sLogicalName) = "DBVERSION") to bSkipTable
104418>>>
104418>>>            If (bSkipTable = False) Begin
104420>>>                Move TheData[iTable].sLogicalName to APITableNameInfo.sLogicalName
104421>>>                Set Action_Text of ghoStatusPanel to ("Number:" * String(APITableNameInfo.iTableNumber) * String(sLogicalName))
104422>>>
104422>>>                Move hTable                       to APITableNameInfo.iTableNumber
104423>>>                Move TheData[iTable].sRootName    to sRootName
104424>>>                Get _TableNameOnly of ghoDbUpdateFunctionLibrary sRootName to sTableName
104425>>>                Move sRootName                    to APITableNameInfo.sRootName
104426>>>
104426>>>                Move TheData[iTable].sDisplayName to APITableNameInfo.sDisplayName
104427>>>                Move TheData[iTable].bIsAlias     to bIsAlias
104428>>>                Move bIsAlias                     to APITableNameInfo.bIsAlias
104429>>>                Get UtilTableIsSQL of ghoDbUpdateFunctionLibrary hTable to APITableNameInfo.bIsSQL
104430>>>
104430>>>                // Get the Driver ID
104430>>>                Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
104433>>>                Get IsDAWSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bDawSqlDriver
104434>>>                Get IsSQLDriver    of ghoDbUpdateFunctionLibrary sDriverID to bSqlDriver
104435>>>
104435>>>                If (bIsAlias = False) Begin
104437>>>                    Set Action_Text of ghoStatusPanel to ("Number:" * String(APITableNameInfo.iTableNumber) * String(APITableNameInfo.sLogicalName))
104438>>>                    Get UtilColumnsStructFill of ghoDbUpdateFunctionLibrary hTable to APIColumns
104439>>>                    If (APIColumns[0].bError = True) Begin
104441>>>                        Function_Return GenerateError
104442>>>                    End
104442>>>>
104442>>>                    If (APIColumns[0].bCancel = True) Begin
104444>>>                        Function_Return GenerateUserCancel
104445>>>                    End
104445>>>>
104445>>>                    Move (SizeOfArray(APIColumns)) to iSize
104446>>>                    Decrement iSize
104447>>>                    If (iSize >= 0) Begin
104449>>>                        Writeln channel iCh ("        // Logical Table Name:" * '"' + APITableNameInfo.sLogicalName + '"' * "Filelist.cfg Number:" * String(APITableNameInfo.iTableNumber))
104452>>>                        Writeln channel iCh ("        Move" * String(APITableNameInfo.iTableNumber)                    * "to APITableNameInfo.iTableNumber")
104455>>>                        Writeln channel iCh ("        Move" * '"' + String(APITableNameInfo.sRootName)    + '"'        * "to APITableNameInfo.sRootName")
104458>>>                        Writeln channel iCh ("        Move" * '"' + String(APITableNameInfo.sLogicalName) + '"'        * "to APITableNameInfo.sLogicalName")
104461>>>                        Writeln channel iCh ("        Move" * '"' + String(APITableNameInfo.sDisplayName) + '"'        * "to APITableNameInfo.sDisplayName")
104464>>>                        Writeln channel iCh ("        Move" * '"' + String(sDriverID)                     + '"'        * "to APITableNameInfo.sDriverID")
104467>>>                        Writeln channel iCh ("        Move" * String(If(APITableNameInfo.bIsAlias,      "True", "False")) * "to APITableNameInfo.bIsAlias")
104470>>>                        Writeln channel iCh ("        Move" * String(If(APITableNameInfo.bIsSQL,        "True", "False")) * "to APITableNameInfo.bIsSQL")
104473>>>                        Writeln channel iCh ("        Move" * String(If(APITableNameInfo.bIsSystemFile, "True", "False")) * "to APITableNameInfo.bIsSystemFile")
104476>>>                        Writeln channel iCh
104478>>>                        Writeln channel iCh ("        // Table:" * '"' + APITableNameInfo.sLogicalName + '"' * "Column: 1")
104481>>>                    End
104481>>>>
104481>>>
104481>>>                    For iCount from 0 to iSize
104487>>>>
104487>>>                        Writeln channel iCh ("        Move" *       String(APIColumns[iCount].iFieldNumber)       * "to APIColumns[iCount].iFieldNumber")
104490>>>                        Writeln channel iCh ("        Move" * '"' + String(APIColumns[iCount].sFieldName)   + '"' * "to APIColumns[iCount].sFieldName")
104493>>>                        Writeln channel iCh ("        Move" *       String(APIColumns[iCount].iType)              * "to APIColumns[iCount].iType")
104496>>>                        Writeln channel iCh ("        Move" * String(If(APIColumns[iCount].bIsSQLType, "True", "False")) * "to APIColumns[iCount].bIsSQLType")
104499>>>                        Writeln channel iCh ("        Move" * String(If(APIColumns[iCount].bAllowNULL, "True", "False")) * "to APIColumns[iCount].bAllowNULL")
104502>>>                        Writeln channel iCh ("        Move" * '"' + String(APIColumns[iCount].sDefaultValue) + '"'       * "to APIColumns[iCount].sDefaultValue")
104505>>>                        If (APIColumns[iCount].iFieldNumber = 0 and APIColumns[iCount].iLength = 0) Begin
104507>>>                            Writeln channel iCh ("        ERROR! This field has a length = 0! It must be corrected before running this code")
104510>>>                            Increment iErrors
104511>>>                        End
104511>>>>
104511>>>                        Move APIColumns[iCount].sType to sDataType
104512>>>                        If (Lowercase(sDataType) contains "identity") Begin
104514>>>                            Move (Replace("identity",sDataType, "")) to sDataType
104515>>>                            Move (Trim(sDataType)) to sDataType
104516>>>                        End
104516>>>>
104516>>>                        Writeln channel iCh ("        Move" * '"' + sDataType                               + '"' * "to APIColumns[iCount].sType")
104519>>>                        Writeln channel iCh ("        Move" *       String(APIColumns[iCount].iLength)            * "to APIColumns[iCount].iLength")
104522>>>                        Writeln channel iCh ("        Move" *       String(APIColumns[iCount].iPrecision)         * "to APIColumns[iCount].iPrecision")
104525>>>                        Writeln channel iCh ("        Move" *       String(APIColumns[iCount].iOptions)           * "to APIColumns[iCount].iOptions")
104528>>>
104528>>>                        If (iCount < iSize) Begin
104530>>>                            Writeln channel iCh ("        Increment iCount")
104533>>>                            Writeln channel iCh
104535>>>                            Writeln channel iCh ("        // Table:" * '"' + APITableNameInfo.sLogicalName + '"' * "Column:" * String(iCount + 2))
104538>>>                        End
104538>>>>
104538>>>                    Loop
104539>>>>
104539>>>
104539>>>                    // Create Index Definitions:
104539>>>                    Get UtilIndexesStructFill of ghoDbUpdateFunctionLibrary hTable to APIIndexes
104540>>>                    If (APIIndexes[0].bError = True) Begin
104542>>>                        Function_Return GenerateError
104543>>>                    End
104543>>>>
104543>>>                    If (APIIndexes[0].bCancel = True) Begin
104545>>>                        Function_Return GenerateUserCancel
104546>>>                    End
104546>>>>
104546>>>                    Move (SizeOfArray(APIIndexes)) to iIndexes
104547>>>                    Decrement iIndexes
104548>>>                    If (iIndexes >= 0) Begin
104550>>>                        Writeln channel iCh
104552>>>                        Writeln channel iCh ("        // Table:" * '"' + APITableNameInfo.sLogicalName + '"' * "Index: 1")
104555>>>                        Writeln channel iCh ("        Move 0 to iCount")
104558>>>                        Writeln channel iCh ("        Move 0 to iSegment")
104561>>>                    End
104561>>>>
104561>>>                    For iIndex from 0 to iIndexes
104567>>>>
104567>>>                        Writeln channel     iCh ("        Move" *       String(APIIndexes[iIndex].iIndexNumber)        * "to APIIndexes[iCount].iIndexNumber")
104570>>>                        Writeln channel     iCh ("        Move" *       String(APIIndexes[iIndex].iPrimaryIndex)       * "to APIIndexes[iCount].iPrimaryIndex")
104573>>>                        Writeln channel     iCh ("        Move" *       String(APIIndexes[iIndex].iSQLIndexType)       * "to APIIndexes[iCount].iSQLIndexType")
104576>>>                        Writeln channel     iCh ("        Move" *       If((APIIndexes[iIndex].bIsSQLClustered),  "True", "False") * "to APIIndexes[iCount].bIsSQLClustered")
104579>>>                        Writeln channel     iCh ("        Move" *       If((APIIndexes[iIndex].bIsSQLPrimaryKey), "True", "False") * "to APIIndexes[iCount].bIsSQLPrimaryKey")
104582>>>                        If (APIIndexes[iIndex].sSQLIndexName <> "") Begin
104584>>>                            Writeln channel iCh ("        Move" * '"' + String(APIIndexes[iIndex].sSQLIndexName) + '"' * "to APIIndexes[iCount].sSQLIndexName")
104587>>>                        End
104587>>>>
104587>>>
104587>>>                        Move (SizeOfArray(APIIndexes[iIndex].IndexSegmentArray)) to iNumSegments
104588>>>                        Decrement iNumSegments
104589>>>                        For iSegment from 0 to iNumSegments
104595>>>>
104595>>>                            Writeln channel iCh ("        Move" *       String(APIIndexes[iIndex].IndexSegmentArray[iSegment].iFieldNumber)              * "to APIIndexes[iCount].IndexSegmentArray[iSegment].iFieldNumber")
104598>>>                            Writeln channel iCh ("        Move" * '"' + String(APIIndexes[iIndex].IndexSegmentArray[iSegment].sFieldName)          + '"' * "to APIIndexes[iCount].IndexSegmentArray[iSegment].sFieldName")
104601>>>                            Writeln channel iCh ("        Move" *       If((APIIndexes[iIndex].IndexSegmentArray[iSegment].bUppercase), "True", "False") * "to APIIndexes[iCount].IndexSegmentArray[iSegment].bUppercase")
104604>>>                            Writeln channel iCh ("        Move" *       If((APIIndexes[iIndex].IndexSegmentArray[iSegment].bAscending), "True", "False") * "to APIIndexes[iCount].IndexSegmentArray[iSegment].bAscending")
104607>>>                            If (iSegment < iNumSegments) Begin
104609>>>                                Writeln channel iCh ("        Increment iSegment")
104612>>>                            End
104612>>>>
104612>>>                        Loop
104613>>>>
104613>>>
104613>>>                        If (iIndex < iIndexes) Begin
104615>>>                            Writeln channel iCh ("        Increment iCount")
104618>>>                            Writeln channel iCh
104620>>>                            Writeln channel iCh ("        // Table:" * '"' + APITableNameInfo.sLogicalName + '"' * "Index:" * String(iIndex + 2))
104623>>>                            Writeln channel iCh ("        Move 0 to iSegment")
104626>>>                        End
104626>>>>
104626>>>                    Loop
104627>>>>
104627>>>
104627>>>                    // Create Relation Definitions:
104627>>>                    Get UtilRelationsStructFill of ghoDbUpdateFunctionLibrary hTable to APIRelations
104628>>>                    If (APIRelations[0].bError = True) Begin
104630>>>                        Function_Return GenerateError
104631>>>                    End
104631>>>>
104631>>>                    If (APIRelations[0].bCancel = True) Begin
104633>>>                        Function_Return GenerateUserCancel
104634>>>                    End
104634>>>>
104634>>>                    Move (SizeOfArray(APIRelations)) to iSize
104635>>>                    Decrement iSize
104636>>>                    If (iSize >= 0) Begin
104638>>>                        Writeln channel iCh
104640>>>                        Writeln channel iCh ("        // Table:" * '"' + APITableNameInfo.sLogicalName + '"' * "Relation: 1")
104643>>>                        Writeln channel iCh ("        Move 0 to iCount")
104646>>>                    End
104646>>>>
104646>>>                    For iCount from 0 to iSize
104652>>>>
104652>>>                        Writeln channel iCh ("        Move" * String(APIRelations[iCount].hTableFrom)  * "to APIRelations[iCount].hTableFrom")
104655>>>                        Writeln channel iCh ("        Move" * String(APIRelations[iCount].iColumnFrom) * "to APIRelations[iCount].iColumnFrom")
104658>>>                        Writeln channel iCh ("        Move" * String(APIRelations[iCount].hTableTo)    * "to APIRelations[iCount].hTableTo")
104661>>>                        Writeln channel iCh ("        Move" * String(APIRelations[iCount].iColumnTo)   * "to APIRelations[iCount].iColumnTo")
104664>>>                        If (iCount < iSize) Begin
104666>>>                            Writeln channel iCh ("        Increment iCount")
104669>>>                            Writeln channel iCh
104671>>>                            Writeln channel iCh ("        // Table:" * '"' + APITableNameInfo.sLogicalName + '"' * "Relation:" * String(iCount + 2))
104674>>>                        End
104674>>>>
104674>>>                    Loop
104675>>>>
104675>>>
104675>>>                    // Create Table Update Definition:
104675>>>                    Writeln channel iCh
104677>>>                    Writeln channel iCh ("        Get ApiTableUpdate APITableNameInfo APIColumns APIIndexes APIRelations to bOK")
104680>>>                    Writeln channel iCh
104682>>>
104682>>>                    Writeln channel iCh ("        Move APIColumnEmpty   to APIColumns")
104685>>>                    Writeln channel iCh ("        Move APIRelationEmpty to APIRelations")
104688>>>                    Writeln channel iCh ("        Move APIIndexEmpty    to APIIndexes")
104691>>>                    Writeln channel iCh ("        Move 0 to iCount")
104694>>>                    Writeln channel iCh ("        Send DoAdvance of ghoProgressBarOverall")
104697>>>                    Writeln channel iCh
104699>>>                End
104699>>>>
104699>>>
104699>>>                If (bIsAlias = True) Begin
104701>>>                    // Create Alias Table Definition:
104701>>>                    Writeln channel iCh ("        // Create Alias Table Definition:")
104704>>>                    Writeln channel iCh ("        Move" * String(hTable) * "to hTable")
104707>>>                    If (bSqlDriver = True and not(APITableNameInfo.sRootName contains sDriverID)) Begin
104709>>>                        Writeln channel iCh ("        Set_Attribute DF_FILE_ROOT_NAME    of hTable to" * '"' + sDriverID + ":" + APITableNameInfo.sRootName    + '"')
104712>>>                    End
104712>>>>
104712>>>                    Else Begin
104713>>>                        Writeln channel iCh ("        Set_Attribute DF_FILE_ROOT_NAME    of hTable to" * '"' + APITableNameInfo.sRootName    + '"')
104716>>>                    End
104716>>>>
104716>>>
104716>>>                    Writeln channel iCh ("        Set_Attribute DF_FILE_LOGICAL_NAME of hTable to" * '"' + APITableNameInfo.sLogicalName + '"')
104719>>>                    Writeln channel iCh ("        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to" * '"' + APITableNameInfo.sDisplayName + '"')
104722>>>                    Writeln channel iCh
104724>>>                End
104724>>>>
104724>>>            End
104724>>>>
104724>>>            Get Check_StatusPanel of ghoStatusPanel to iStatus
104725>>>            If (iStatus <> 0) Begin
104727>>>                Send Seq_Close_Channel iCh
104728>>>                Function_Return GenerateUserCancel
104729>>>            End         
104729>>>>
104729>>>            
104729>>>            Close hTable
104730>>>        Loop // Main TheData loop
104731>>>>
104731>>>
104731>>>        Writeln channel iCh ("    End_Procedure")
104734>>>        Writeln channel iCh ("End_Object")
104737>>>
104737>>>        Send Seq_Close_Channel iCh
104738>>>        Function_Return GenerateOK
104739>>>    End_Function
104740>>>
104740>>>    Function DFTypeToDUFType Integer iDataFlexDataType Returns String
104743>>>        String sRetval
104743>>>        Case Begin
104743>>>            Case (iDataFlexDataType = DF_ASCII)
104745>>>                Move DF_ASCII_DUF to sRetval
104746>>>                Case Break
104747>>>            Case (iDataFlexDataType = DF_BCD)
104750>>>                Move "DF_BCD_DUF" to sRetval
104751>>>                Case Break
104752>>>            Case (iDataFlexDataType = DF_BINARY)
104755>>>                Move "DF_BINARY_DUF" to sRetval
104756>>>                Case Break
104757>>>            Case (iDataFlexDataType = DF_DATE)
104760>>>                Move "DF_DATE_DUF" to sRetval
104761>>>                Case Break
104762>>>            Case (iDataFlexDataType = DF_DATETIME)
104765>>>                Move "DF_DATETIME_DUF" to sRetval
104766>>>                Case Break
104767>>>            Case (iDataFlexDataType = DF_TEXT)
104770>>>                Move "DF_TEXT_DUF" to sRetval
104771>>>                Case Break
104772>>>            Case Else
104772>>>                Move iDataFlexDataType to sRetval
104773>>>        Case End
104773>>>
104773>>>        Function_Return sRetval
104774>>>    End_Function
104775>>>
104775>>>    Procedure OnFileDropped String sFilename Boolean bLast
104778>>>        String sTest
104778>>>        Forward Send OnFileDropped sFilename bLast
104780>>>        If (bLast = True) Begin
104782>>>            Get ParseFileName sFilename to sTest
104783>>>            If (Uppercase(sTest) <> "FILELIST.CFG") Begin
104785>>>                Send Info_Box "Sorry, only Filist.cfg files can be dropped here..."
104786>>>                Procedure_Return
104787>>>            End
104787>>>>
104787>>>            Set Value of oFilelistPath_fm to sFilename
104788>>>        End
104788>>>>
104788>>>    End_Procedure
104789>>>
104789>>>    Procedure Request_Clear
104792>>>        tDataSourceRow[] EmptyData
104792>>>        tDataSourceRow[] EmptyData
104793>>>        Handle hoGrid hoDataSource
104793>>>        Integer[] iDifferencesEmpty
104794>>>
104794>>>        Move (oFilelist_grd(Self))  to hoGrid
104795>>>        Get phoDataSource of hoGrid to hoDataSource
104796>>>        Send InitializeData of hoGrid EmptyData
104797>>>        Set Value of oFilelistPath_fm    to ""
104798>>>        Set Value of oPnVersionNumber_fm to ""
104799>>>        Set Value of oSourceName_fm      to ""
104800>>>        Set psFilelistFrom of ghoApplication to ""
104801>>>        Send Activate of oFilelistPath_fm
104802>>>    End_Procedure
104803>>>
104803>>>    Procedure TagChangedTables String sFromFilelist Integer[] iaDifferences
104806>>>        Integer iSize iCount iItem iItems iTableNo iTableNo_Col iCheckbox_Col
104806>>>        Handle hoGrid hoDataSource
104806>>>        tDataSourceRow[] TheData
104806>>>        tDataSourceRow[] TheData
104807>>>
104807>>>        Set Value of oFilelistPath_fm to sFromFilelist
104808>>>        Move (oFilelist_grd(Self)) to hoGrid
104809>>>
104809>>>        Get piColumnId of (oFilelistNumber_col(hoGrid)) to iTableNo_Col
104810>>>        Get piColumnId of (oCheckbox_Col(hoGrid))       to iCheckbox_Col
104811>>>        Get phoDataSource of hoGrid to hoDataSource
104812>>>        Get DataSource of hoDataSource to TheData
104813>>>        Move (SizeOfArray(TheData)) to iItems
104814>>>        Decrement iItems
104815>>>
104815>>>        Move (SizeOfArray(iaDifferences)) to iSize
104816>>>        If (iSize = 0) Begin
104818>>>            Procedure_Return
104819>>>        End
104819>>>>
104819>>>        Decrement iSize
104820>>>        If (iSize > 0) Begin
104822>>>            Send KeyAction of oDeSelectAll_btn
104823>>>        End
104823>>>>
104823>>>
104823>>>        For iCount from 0 to iSize
104829>>>>
104829>>>            Move iaDifferences[iCount] to iTableNo
104830>>>            If (iTableNo > 0) Begin
104832>>>                For iItem from 0 to iItems
104838>>>>
104838>>>                    If (TheData[iItem].sValue[iTableNo_Col] = iTableNo) Begin
104840>>>                        Move True to TheData[iItem].sValue[iCheckbox_Col]
104841>>>                        Move iItems to iItem // We found it and we're out of this loop.
104842>>>                    End
104842>>>>
104842>>>                Loop
104843>>>>
104843>>>            End
104843>>>>
104843>>>        Loop
104844>>>>
104844>>>
104844>>>        Send ReInitializeData of hoGrid TheData False
104845>>>        Send DoSetCheckboxFooterText of hoGrid
104846>>>    End_Procedure
104847>>>
104847>>>    On_Key Key_Ctrl+Key_A  Send KeyAction of oSelectAll_btn
104848>>>    On_Key Key_Ctrl+Key_N  Send KeyAction of oDeSelectAll_btn
104849>>>    On_Key Key_Ctrl+Key_I  Send KeyAction of oInvertSelection_btn
104850>>>    On_Key Key_Ctrl+Key_G  Send KeyAction of oGenerateCode_btn
104851>>>    On_Key Key_Ctrl+Key_O  Send KeyAction of oOpenAppSrcFolder_btn
104852>>>    On_Key kClear          Send Request_Clear
104853>>>    On_Key kClear_All      Send Request_Clear
104854>>>    On_Key Key_Ctrl+Key_F4 Send None
104855>>>End_Object
104856>>>
104856>>>// General purpose access message to auto-fill grid with tables with
104856>>>// differences (after "Compare Databases" has been run).
104856>>>Procedure TagFileNamesForCodeGeneration
104859>>>    String sFileListFrom sCurrentFilelist
104859>>>    Integer[] iaDifferences
104860>>>    Handle ho
104860>>>
104860>>>    Send Activate_oTableDUFCodeGenerator
104861>>>    Move (oTableDUFCodeGenerator(Self)) to ho
104862>>>    Get Value of (oFilelistPath_fm(ho)) to sCurrentFilelist
104863>>>    If (sCurrentFilelist <> "") Begin
104865>>>        Send Request_Clear of ho
104866>>>    End
104866>>>>
104866>>>
104866>>>    Get psFilelistFrom of ghoApplication to sFileListFrom
104867>>>    Get piaDifferences of ghoApplication to iaDifferences
104868>>>    Send TagChangedTables of ho sFileListFrom iaDifferences
104869>>>    Send Info_Box ("Ready marking tables. Number of different tables:" * (String(SizeOfArray(iaDifferences))))
104870>>>End_Procedure
104871>
104871>        Use StdAbout.pkg
Including file: StdAbout.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\StdAbout.pkg)
104871>>>//************************************************************************
104871>>>// Confidential Trade Secret.
104871>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
104871>>>// as an unpublished work.  All rights reserved.
104871>>>// DataFlex is a registered trademark of Data Access Corporation.
104871>>>//
104871>>>//************************************************************************
104871>>>//************************************************************************
104871>>>//
104871>>>// $File name  : StdAbout.pkg
104871>>>// $File title : Standard about object package for VDF
104871>>>// Notice      :
104871>>>// $Author(s)  : John Tuohy
104871>>>//
104871>>>// $Rev History
104871>>>//
104871>>>// JT 06/27/97   File created
104871>>>//************************************************************************
104871>>>
104871>>>// This provides a quick and simple way to create an about package for a program.
104871>>>// You need to create a message inside you client area called Activate_About.
104871>>>// Within this message you should send the message DoAbout passing needed
104871>>>// string information.
104871>>>//
104871>>>//       Procedure Activate_About
104871>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
104871>>>//       End_Procedure
104871>>>//    where: sTitle =     Name of application. If none provided, uses caption
104871>>>//                        bar title
104871>>>//           sVersion   = Version Line. If none provided, will be blank
104871>>>//           sCopyRight = Copyright Line. If none provided, will be blank
104871>>>//           sAuthor    = Author name, blank if none provided
104871>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
104871>>>//                        is used.
104871>>>// It is expected that you will place this in your own object package. For
104871>>>// example an order about package may look like this:
104871>>>//
104871>>>//   // OrderAbout.pkg
104871>>>//   Use StdAbout.pkg
104871>>>//   Procedure Activate_About
104871>>>//      String sTitle sCopyright sVersion sAuthor
104871>>>//      Move "My Order Entry System" to sTitle
104871>>>//      Move "Version 2.1" to sVersion
104871>>>//      Move "Copyright 1997, Super Software Inc." to sCopyright
104871>>>//      Move "John Smith"  to sAuthor
104871>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
104871>>>//   end_procedure
104871>>>//   // end of file.
104871>>>
104871>>>Use DfAbout.pkg
Including file: DfAbout.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\DfAbout.pkg)
104871>>>>>//************************************************************************
104871>>>>>// Confidential Trade Secret.
104871>>>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
104871>>>>>// as an unpublished work.  All rights reserved.
104871>>>>>// DataFlex Is A registered trademark Of Data Access Corporation.
104871>>>>>//
104871>>>>>//************************************************************************
104871>>>>>//************************************************************************
104871>>>>>//
104871>>>>>// $File name  : DfAbout.pkg
104871>>>>>// $File title : About class support
104871>>>>>// Notice      :
104871>>>>>// $Author(s)  : Vincent Oorsprong, Ken Ross
104871>>>>>//
104871>>>>>// $Rev History
104871>>>>>//
104871>>>>>// NGS 08/16/2013 Improved by using a cRichEdit object were the params gets added to.
104871>>>>>//                The objects that previously were popupated with values from the params,
104871>>>>>//                and their corresponding "Procedure Set..." messages, were removed as
104871>>>>>//                the edit object is used instead.
104871>>>>>//                The number of params to the DoAbout procedure was increased to ten, so
104871>>>>>//                it is easier to add whatever extra text strings needed/wanted.
104871>>>>>//                The StdAbout.pkg was also changed for this to work. It allows for an extra
104871>>>>>//                five new params to be passed, but these new params are all optional.
104871>>>>>//                So the interface will work exactly as before - if no extra parameters are passed.
104871>>>>>//                Also added an extra bitmap object to show the "Powered By Visual DataFlex" logo, in
104871>>>>>//                the lower left corner of the About object, beneath the "main" About bitmap.
104871>>>>>//                Note: It is assumed that the bitmap "PoweredByVisualDataFlex.bmp" exists.
104871>>>>>//                The background was changed to clWhite for easier usage of bitmaps. Just set the background
104871>>>>>//                color of your bitmap to white and the bitmap will not look jagged.
104871>>>>>//                If an Internet address is passed as one of the params, it will be underlined and clickable.
104871>>>>>//                An e-mail address can also be passed; e.g. "E-mail: mailto:mail@myemailaccount.com" and will
104871>>>>>//                also be clickable.
104871>>>>>// VOO 02/22/2012 Replaced obsolete code, improved Network_User_Name by asking
104871>>>>>//                Windows for the size first.
104871>>>>>// VOO 07/25/2003 Removed OnResize procedure for sysinfo dialog. Replaced logic
104871>>>>>//                with anchor technique. Removed unnessary property in the
104871>>>>>//                sysinfo dialog. Changed the size Of the about & sysinfo dialog
104871>>>>>//                object To better look in Windows XP. Repositioned the close
104871>>>>>//                button in the sysinfo dialog To line up with the display area
104871>>>>>//                Replaced obsolete code and techniques. Removed dead code.
104871>>>>>// JJT 10/23/2001 removed all ghoworkspace support. Uses app object or nothing
104871>>>>>// SWB 07/19/01   Added support Of the Application object in preference to
104871>>>>>//                the global Workspace object, if it is present
104871>>>>>// JJT 11/05/98   Added version information
104871>>>>>// VOO 29/10/98   Replaced the GetFreeSystemResources for the Win32 variant
104871>>>>>// JJT 7/31/97    Registered Enumerate Workspace so dfabout can exist without
104871>>>>>//                workspace package.
104871>>>>>// JJT 6/27/97    Turned the sysinfo objects into classes so the AboutDialog
104871>>>>>//                class can create this object.
104871>>>>>//                Cleaned up the interface (used correct classes and messages)
104871>>>>>//                Added workspace reporting support To sys-info.
104871>>>>>//                Turned off wrapping in the sys-info editor.
104871>>>>>// KR  ??/??/96   File created
104871>>>>>//************************************************************************
104871>>>>>Use LanguageText.pkg
104871>>>>>Use Windows.pkg
104871>>>>>Use DFbitmap.pkg
104871>>>>>Use GlobalFunctionsProcedures.pkg
104871>>>>>Use cRichEdit.pkg
104871>>>>>Use cTextEdit.pkg
104871>>>>>Use gFormatNumbers.pkg
Including file: gFormatNumbers.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\gFormatNumbers.pkg)
104871>>>>>>>//****************************************************************************//
104871>>>>>>>//                                                                            //
104871>>>>>>>// $File name  : gFormatNumbers.pkg                                           //
104871>>>>>>>// $File title : Globals for formating numbers and currency                   //
104871>>>>>>>// Notice      :                                                              //
104871>>>>>>>// $Author(s)  : John Tuohy                                                   //
104871>>>>>>>//                                                                            //
104871>>>>>>>// Confidential Trade Secret.                                                 //
104871>>>>>>>// Copyright 1999 Data Access Corporation, Miami FL, USA                      //
104871>>>>>>>// All Rights reserved                                                        //
104871>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.             //
104871>>>>>>>// $Rev History                                                               //
104871>>>>>>>//                                                                            //
104871>>>>>>>// 25.08.99 Created                                                           //
104871>>>>>>>//****************************************************************************//
104871>>>>>>>
104871>>>>>>>Use cFormatter.pkg
Including file: cFormatter.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cFormatter.pkg)
104871>>>>>>>>>//****************************************************************************//
104871>>>>>>>>>//                                                                            //
104871>>>>>>>>>// $File name  : cFormatter.pkg                                               //
104871>>>>>>>>>// $File title : cFormatter class (private class)                             //
104871>>>>>>>>>// $Author(s)  : John Tuohy                                                   //
104871>>>>>>>>>//                                                                            //
104871>>>>>>>>>// Confidential Trade Secret.                                                 //
104871>>>>>>>>>// Copyright 1999 Data Access Corporation, Miami FL, USA                      //
104871>>>>>>>>>// All Rights reserved                                                        //
104871>>>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.             //
104871>>>>>>>>>//                                                                            //
104871>>>>>>>>>// $Rev History                                                               //
104871>>>>>>>>>//                                                                            //
104871>>>>>>>>>// 25.08.99 Created                                                           //
104871>>>>>>>>>//****************************************************************************//
104871>>>>>>>>>use VDFBase.pkg
104871>>>>>>>>>
104871>>>>>>>>>Class cFormatter is an cObject
104872>>>>>>>>>
104872>>>>>>>>>    Procedure Construct_object
104874>>>>>>>>>        Integer iCh
104874>>>>>>>>>        forward send construct_object
104876>>>>>>>>>        Property String  psCurrencySymbol
104877>>>>>>>>>        Set psCurrencySymbol to (Default_Currency_Symbol())
104878>>>>>>>>>
104878>>>>>>>>>        Property string  psLeft
104879>>>>>>>>>        Property string  psright
104880>>>>>>>>>        Property integer pbThousandsSep
104881>>>>>>>>>        Property integer piPoints
104882>>>>>>>>>
104882>>>>>>>>>        Property string  psCurPosLeft
104883>>>>>>>>>        Property string  psCurPosright
104884>>>>>>>>>        Property integer pbCurPosThousandsSep
104885>>>>>>>>>        Property integer piCurPosPoints
104886>>>>>>>>>
104886>>>>>>>>>        Property string  psCurNegLeft
104887>>>>>>>>>        Property string  psCurNegright
104888>>>>>>>>>        Property integer pbCurNegThousandsSep
104889>>>>>>>>>        Property integer piCurNegPoints
104890>>>>>>>>>
104890>>>>>>>>>        Property string  psNumPosLeft
104891>>>>>>>>>        Property string  psNumPosright
104892>>>>>>>>>        Property integer pbNumPosThousandsSep
104893>>>>>>>>>        Property integer piNumPosPoints
104894>>>>>>>>>
104894>>>>>>>>>        Property string  psNumNegLeft
104895>>>>>>>>>        Property string  psNumNegright
104896>>>>>>>>>        Property integer pbNumNegThousandsSep
104897>>>>>>>>>        Property integer piNumNegPoints
104898>>>>>>>>>
104898>>>>>>>>>        Send SetFormat "$,#.##;($,#.##)" true  // currency
104899>>>>>>>>>        Send SetFormat  ",#.*"           false // numeric
104900>>>>>>>>>
104900>>>>>>>>>    end_procedure
104901>>>>>>>>>
104901>>>>>>>>>    // internal
104901>>>>>>>>>    // parse passed format string and set temporary properties with result
104901>>>>>>>>>    //
104901>>>>>>>>>    Procedure ParseFormat string sFmt
104903>>>>>>>>>
104903>>>>>>>>>        string sLeft sRight sDigit
104903>>>>>>>>>        integer bSep iPos i iDigits
104903>>>>>>>>>
104903>>>>>>>>>        // replace any literals. A "/" followed by anything.
104903>>>>>>>>>        // some literals are special. $ . , / #
104903>>>>>>>>>        Move (Replaces("/$",sFmt,Character(1)))    to sFmt
104904>>>>>>>>>        Move (Replaces("/.",sFmt,Character(2)))    to sFmt
104905>>>>>>>>>        Move (Replaces("/,",sFmt,Character(3)))    to sFmt
104906>>>>>>>>>        Move (Replaces("/"+"/",sFmt,Character(4))) to sFmt
104907>>>>>>>>>        Move (Replaces("/#",sFmt,Character(5)))    to sFmt
104908>>>>>>>>>        Move (Character(9)) to sDigit
104909>>>>>>>>>        Move (Replaces("#",sFmt,sDigit))           to sFmt
104910>>>>>>>>>        Move (Replaces("/",sFmt,""))               to sFmt // replace all others
104911>>>>>>>>>
104911>>>>>>>>>        Move (Pos(",",sFmt))                 to bSep // if we have any , we use thousand seps
104912>>>>>>>>>        If bSep Move (Replaces(",",sFmt,"")) to sFmt // remove all ,
104915>>>>>>>>>
104915>>>>>>>>>        Move (Replaces("$",sFmt,psCurrencySymbol(self))) to sFmt // replace any $ with currency symbol
104916>>>>>>>>>
104916>>>>>>>>>        Move (Pos(".",sFmt)) to iPos                 // position of decimal
104917>>>>>>>>>
104917>>>>>>>>>        // Move all the special literals back into place before parsing
104917>>>>>>>>>        Move (Replaces(Character(1),sFmt,"$")) to sFmt
104918>>>>>>>>>        Move (Replaces(Character(2),sFmt,".")) to sFmt
104919>>>>>>>>>        Move (Replaces(Character(3),sFmt,",")) to sFmt
104920>>>>>>>>>        Move (Replaces(Character(4),sFmt,"/")) to sFmt
104921>>>>>>>>>        Move (Replaces(Character(5),sFmt,"#")) to sFmt
104922>>>>>>>>>
104922>>>>>>>>>        If (iPos>0) Begin                      // if we have a decimanl point
104924>>>>>>>>>            Move 1 to i                        // look for first non # to right and count the #s
104925>>>>>>>>>            If (mid(sFmt,1,iPos+i)="*") Begin  // the "*" is special. It means as many as you want
104927>>>>>>>>>               Move -2 to iDigits
104928>>>>>>>>>               increment i
104929>>>>>>>>>            end
104929>>>>>>>>>>
104929>>>>>>>>>            While (mid(sFmt,1,iPos+i)=sDigit)
104933>>>>>>>>>                 Increment i
104934>>>>>>>>>            end
104935>>>>>>>>>>
104935>>>>>>>>>            Move (Mid(sFmt,255,iPos+i)) to sRight // everything to the right of the last # is format stuff
104936>>>>>>>>>            If (iDigits=0) Move (i-1) to iDigits
104939>>>>>>>>>            //
104939>>>>>>>>>            Move 1 to i                           // find the first non-# to the left of the point
104940>>>>>>>>>            While (mid(sFmt,1,iPos-i)=sDigit)     // everything to the left is format stuff
104944>>>>>>>>>                 increment i
104945>>>>>>>>>            end
104946>>>>>>>>>>
104946>>>>>>>>>            Move (left(sFmt,iPos-i)) to sLeft
104947>>>>>>>>>        end
104947>>>>>>>>>>
104947>>>>>>>>>        else begin                             // we have no decinal
104948>>>>>>>>>            Move 0 to iDigits                  // so points is none
104949>>>>>>>>>            Move (Pos(sDigit,sFmt)) to iPos    // find first #.
104950>>>>>>>>>            If (iPos=0) Begin                  // if none, entire string is left format stuff..wierd!
104952>>>>>>>>>                Move sFmt to sLeft
104953>>>>>>>>>                Move ""   to sRight
104954>>>>>>>>>            end
104954>>>>>>>>>>
104954>>>>>>>>>            else begin
104955>>>>>>>>>                Move (left(sFmt,iPos-1)) to sLeft // all char to left of first # is left format stuff
104956>>>>>>>>>                Move 1 to i
104957>>>>>>>>>                While (mid(sFmt,1,iPos+i)=sDigit) // find last #, all char to right is right format
104961>>>>>>>>>                    Increment i
104962>>>>>>>>>                end
104963>>>>>>>>>>
104963>>>>>>>>>                Move (Mid(sFmt,255,i+iPos)) to sRight
104964>>>>>>>>>            end
104964>>>>>>>>>>
104964>>>>>>>>>        end
104964>>>>>>>>>>
104964>>>>>>>>>        // set temporary format properties and exit
104964>>>>>>>>>        Set pbThousandsSep to bSep
104965>>>>>>>>>        set psLeft         to sLeft
104966>>>>>>>>>        set psRight        to sRight
104967>>>>>>>>>        Set piPoints       to iDigits
104968>>>>>>>>>     End_procedure
104969>>>>>>>>>
104969>>>>>>>>>    // Public: Sets a format string. Pass full format for Positve and negative in sFmt. Pass
104969>>>>>>>>>    //         bCurrency true is this is a currency format, false if a numeric format
104969>>>>>>>>>    //
104969>>>>>>>>>    //  e.g. Send SetFormat "$,#.##;($,#.##)" True
104969>>>>>>>>>    //
104969>>>>>>>>>    Procedure SetFormat string sFmt integer bCurrency
104971>>>>>>>>>        string sPos sNeg
104971>>>>>>>>>        integer iPos
104971>>>>>>>>>
104971>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
104972>>>>>>>>>        If iPos begin
104974>>>>>>>>>            Move (left(sFmt,iPos-1))    to sPos
104975>>>>>>>>>            Move (mid(sFmt,255,iPos+1)) to sNeg
104976>>>>>>>>>        end
104976>>>>>>>>>>
104976>>>>>>>>>        else Begin
104977>>>>>>>>>            Move sFmt         to sPos
104978>>>>>>>>>            Move ("-" + sFmt) to sNeg
104979>>>>>>>>>        end
104979>>>>>>>>>>
104979>>>>>>>>>        Send ParseFormat sPos
104980>>>>>>>>>        If bCurrency begin
104982>>>>>>>>>            Set pbCurPosThousandsSep to (pbThousandsSep(self))
104983>>>>>>>>>            set psCurPosLeft         to (psLeft(self))
104984>>>>>>>>>            set psCurPosRight        to (psRight(self))
104985>>>>>>>>>            Set piCurPosPoints       to (piPoints(self))
104986>>>>>>>>>        End
104986>>>>>>>>>>
104986>>>>>>>>>        else Begin
104987>>>>>>>>>            Set pbNumPosThousandsSep to (pbThousandsSep(self))
104988>>>>>>>>>            set psNumPosLeft         to (psLeft(self))
104989>>>>>>>>>            set psNumPosRight        to (psRight(self))
104990>>>>>>>>>            Set piNumPosPoints       to (piPoints(self))
104991>>>>>>>>>        end
104991>>>>>>>>>>
104991>>>>>>>>>
104991>>>>>>>>>        Send ParseFormat sNeg
104992>>>>>>>>>        If bCurrency begin
104994>>>>>>>>>            Set pbCurNegThousandsSep to (pbThousandsSep(self))
104995>>>>>>>>>            set psCurNegLeft         to (psLeft(self))
104996>>>>>>>>>            set psCurNegRight        to (psRight(self))
104997>>>>>>>>>            Set piCurNegPoints       to (piPoints(self))
104998>>>>>>>>>        End
104998>>>>>>>>>>
104998>>>>>>>>>        else Begin
104999>>>>>>>>>            Set pbNumNegThousandsSep to (pbThousandsSep(self))
105000>>>>>>>>>            set psNumNegLeft         to (psLeft(self))
105001>>>>>>>>>            set psNumNegRight        to (psRight(self))
105002>>>>>>>>>            Set piNumNegPoints       to (piPoints(self))
105003>>>>>>>>>        end
105003>>>>>>>>>>
105003>>>>>>>>>    End_procedure
105004>>>>>>>>>
105004>>>>>>>>>    // low level formatting. Pass parameters
105004>>>>>>>>>    Function Format_Num number nNumber integer iPoints integer bSep ;                       string sPrefix string sSuffix returns string
105006>>>>>>>>>        string  sLeft sRight sNumber sSep sDec
105006>>>>>>>>>        integer bIsNegative iDec iLen iCh
105006>>>>>>>>>
105006>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iCh
105009>>>>>>>>>        Move (Character(iCh)) to sDec
105010>>>>>>>>>
105010>>>>>>>>>        Move (abs(nNumber)) to sNumber
105011>>>>>>>>>        Move (Pos(sDec,sNumber)) to iDec
105012>>>>>>>>>        Move (If(iDec=0, sNumber, left(sNumber,iDec-1))) to sLeft
105013>>>>>>>>>        Move (If(iDec=0, "", mid(sNumber,255,iDec+1)))   to sRight
105014>>>>>>>>>        // format for decimal separator
105014>>>>>>>>>        If (iPoints>=0) ; // if -2, leave it alone, it should not be -1            Move (left(sRight+repeat("0",iPoints),iPoints)) to sRight
105017>>>>>>>>>
105017>>>>>>>>>        // format for thousand sep.
105017>>>>>>>>>        If bSep Begin
105019>>>>>>>>>            Get_Attribute DF_THOUSANDS_SEPARATOR to iCh
105022>>>>>>>>>            Move (Character(iCh)) to sSep
105023>>>>>>>>>            Move (Length(sLeft)) to iLen
105024>>>>>>>>>            While (iLen>3)
105028>>>>>>>>>                Move (insert(sSep,sLeft,iLen-2)) to sLeft
105029>>>>>>>>>                Move (iLen-3) to iLen
105030>>>>>>>>>            End
105031>>>>>>>>>>
105031>>>>>>>>>        End
105031>>>>>>>>>>
105031>>>>>>>>>        // if decimal points or -2 (allow anything) and there are points to show
105031>>>>>>>>>        If (iPoints>0 OR (iPoints=-2 AND sRight<>"")) ;            Move (sLeft + sDec + sright) to sLeft
105034>>>>>>>>>        Function_return (sPrefix + sLeft+ sSuffix)
105035>>>>>>>>>    End_Function
105036>>>>>>>>>
105036>>>>>>>>>    // Public: Format for currency
105036>>>>>>>>>    //
105036>>>>>>>>>    Function FormatCur number nNumber integer iPoints returns string
105038>>>>>>>>>        string  sLeft sRight
105038>>>>>>>>>        integer bSep
105038>>>>>>>>>        If (nNumber<0) Begin
105040>>>>>>>>>            get pbCurNegThousandsSep to bSep
105041>>>>>>>>>            get psCurNegLeft         to sLeft
105042>>>>>>>>>            get psCurNegRight        to sRight
105043>>>>>>>>>            If (iPoints=-1) get piCurNegPoints       to iPoints
105046>>>>>>>>>        end
105046>>>>>>>>>>
105046>>>>>>>>>        Else Begin
105047>>>>>>>>>            get pbCurPosThousandsSep to bSep
105048>>>>>>>>>            get psCurPosLeft         to sLeft
105049>>>>>>>>>            get psCurPosRight        to sRight
105050>>>>>>>>>            If (iPoints=-1) get piCurPosPoints       to iPoints
105053>>>>>>>>>        end
105053>>>>>>>>>>
105053>>>>>>>>>        Function_return (Format_Num(self, nNumber,iPoints,bSep,sLeft,sRight))
105054>>>>>>>>>    End_function
105055>>>>>>>>>
105055>>>>>>>>>    // Public: Format for numeric
105055>>>>>>>>>    //
105055>>>>>>>>>    Function FormatNum number nNumber integer iPoints returns string
105057>>>>>>>>>        string  sLeft sRight
105057>>>>>>>>>        integer bSep
105057>>>>>>>>>        If (nNumber<0) Begin
105059>>>>>>>>>            get pbNumNegThousandsSep to bSep
105060>>>>>>>>>            get psNumNegLeft         to sLeft
105061>>>>>>>>>            get psNumNegRight        to sRight
105062>>>>>>>>>            If (iPoints=-1) get piNumNegPoints       to iPoints
105065>>>>>>>>>        end
105065>>>>>>>>>>
105065>>>>>>>>>        Else Begin
105066>>>>>>>>>            get pbNumPosThousandsSep to bSep
105067>>>>>>>>>            get psNumPosLeft         to sLeft
105068>>>>>>>>>            get psNumPosRight        to sRight
105069>>>>>>>>>            If (iPoints=-1) get piNumPosPoints       to iPoints
105072>>>>>>>>>        end
105072>>>>>>>>>>
105072>>>>>>>>>        Function_return (Format_Num(self, nNumber,iPoints,bSep,sLeft,sRight))
105073>>>>>>>>>    End_function
105074>>>>>>>>>
105074>>>>>>>>>
105074>>>>>>>>>    // Public: Format passing format string
105074>>>>>>>>>    //
105074>>>>>>>>>    Function FormatVal number nNumber string sFmt returns string
105076>>>>>>>>>        integer iPos bIsNeg
105076>>>>>>>>>        string  sLeft sRight
105076>>>>>>>>>        integer iPoints bSep
105076>>>>>>>>>        Move (nNumber<0) to bIsNeg
105077>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
105078>>>>>>>>>        Case Begin
105078>>>>>>>>>            Case (iPos and Not(bIsNeg))      Move (left(sFmt,iPos-1))    to sFmt
105081>>>>>>>>>            Case (iPos and bIsNeg)           Move (mid(sFmt,255,iPos+1)) to sFmt
105085>>>>>>>>>            Case (not(iPos) and not(bIsNeg)) Move sFmt                   to sFmt
105089>>>>>>>>>            Case else                        Move ("-" + sFmt)           to sFmt
105091>>>>>>>>>        case end
105091>>>>>>>>>        Send ParseFormat sFmt
105092>>>>>>>>>        get pbThousandsSep to bSep
105093>>>>>>>>>        get psLeft         to sLeft
105094>>>>>>>>>        get psRight        to sRight
105095>>>>>>>>>        get piPoints       to iPoints
105096>>>>>>>>>        Function_return (Format_Num(self, nNumber,iPoints,bSep,sLeft,sRight))
105097>>>>>>>>>    end_function
105098>>>>>>>>>
105098>>>>>>>>>End_Class
105099>>>>>>>
105099>>>>>>>// for now, this object is private. All access is through the following
105099>>>>>>>// global functions
105099>>>>>>>
105099>>>>>>>//Object oFmt is a cFormatter
105099>>>>>>>//end_object
105099>>>>>>>
105099>>>>>>>Global_variable handle ghoFormatter
105099>>>>>>>Get Create of desktop U_cFormatter to ghoFormatter
105100>>>>>>>
105100>>>>>>>Function FormatNumber Global number nNum integer iPoints returns string
105102>>>>>>>    Function_return (FormatNum(ghoFormatter, nNum,iPoints))
105103>>>>>>>end_function
105104>>>>>>>
105104>>>>>>>Function FormatCurrency Global number nNum integer iPoints returns string
105106>>>>>>>    Function_return (FormatCur(ghoFormatter, nNum,iPoints))
105107>>>>>>>end_function
105108>>>>>>>
105108>>>>>>>Function FormatValue Global number nNum string sFmt returns string
105110>>>>>>>    Function_return (FormatVal(ghoFormatter, nNum,sFmt))
105111>>>>>>>end_function
105112>>>>>>>
105112>>>>>>>Procedure SetCurrencyFormat Global string sFmt
105114>>>>>>>    Send SetFormat of ghoFormatter sFmt True
105115>>>>>>>end_function
105116>>>>>>>
105116>>>>>>>Procedure SetNumberFormat Global string sFmt
105118>>>>>>>    Send SetFormat of ghoFormatter sFmt False
105119>>>>>>>end_function
105120>>>>>>>
105120>>>>>Use MapiDllCalls.Pkg
Including file: MapiDllCalls.Pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\MapiDllCalls.Pkg)
105120>>>>>>>Use MapiConstants.Pkg
Including file: MapiConstants.Pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\MapiConstants.Pkg)
105120>>>>>>>>>Type MapiSession
105120>>>>>>>>>   Field MapiSession.SessionID As Integer
105120>>>>>>>>>End_type // MapiSession
105120>>>>>>>>>
105120>>>>>>>>>Type MapiMessagePointer
105120>>>>>>>>>   Field MapiMessagePointer.lppMessage As Pointer
105120>>>>>>>>>End_Type // MapiMessagePointer
105120>>>>>>>>>
105120>>>>>>>>>Type MapiRecipPointer
105120>>>>>>>>>   Field MapiRecipPointer.lppRecip As Pointer
105120>>>>>>>>>End_Type // MapiRecipPointer
105120>>>>>>>>>
105120>>>>>>>>>Type MapiNewRecipsPointer
105120>>>>>>>>>   Field MapiNewRecipsPointer.lppNewRecips As Pointer
105120>>>>>>>>>End_Type // MapiNewRecipsPointer
105120>>>>>>>>>
105120>>>>>>>>>Type MapiNewRecipsCounter
105120>>>>>>>>>   Field MapiNewRecipsCounter.lpnNewRecips As Integer
105120>>>>>>>>>End_Type // MapiNewRecipsCounter
105120>>>>>>>>>
105120>>>>>>>>>Type MapiFileDesc
105120>>>>>>>>>   Field MapiFileDesc.ulReserved As Integer      // Reserved for future use (must be 0)
105120>>>>>>>>>   Field MapiFileDesc.flFlags As Integer         // Flags
105120>>>>>>>>>   Field MapiFileDesc.nPosition As Integer       // character in text to be replaced by attachment
105120>>>>>>>>>   Field MapiFileDesc.lpszPathName As Pointer    // Full path name of attachment file
105120>>>>>>>>>   Field MapiFileDesc.lpszFileName As Pointer    // Original file name (optional)
105120>>>>>>>>>   Field MapiFileDesc.lpFileType As Pointer     // Attachment file type (can be lpMapiFileTagExt)
105120>>>>>>>>>End_Type // MapiFileDesc
105120>>>>>>>>>
105120>>>>>>>>>Define MAPI_OLE        For |CI$00000001
105120>>>>>>>>>Define MAPI_OLE_STATIC For |CI$00000002
105120>>>>>>>>>
105120>>>>>>>>>Define MAPI_NOATTACHMENT_POSITION For |CI$FFFFFFFF
105120>>>>>>>>>
105120>>>>>>>>>Type MapiFileTagExt
105120>>>>>>>>>   Field MapiFileTagExt.ulReserved As Integer  // Reserved, must be zero.
105120>>>>>>>>>   Field MapiFileTagExt.cbTag As Integer       // Size (in bytes) of
105120>>>>>>>>>   Field MapiFileTagExt.lpTag As Pointer       // X.400 OID for this attachment type
105120>>>>>>>>>   Field MapiFileTagExt.cbEncoding As Integer  // Size (in bytes) of
105120>>>>>>>>>   Field MapiFileTagExt.lpEncoding As Pointer  // X.400 OID for this attachment's encoding
105120>>>>>>>>>End_Type // MapiFileTagExt
105120>>>>>>>>>
105120>>>>>>>>>Type MapiRecipDesc
105120>>>>>>>>>   Field MapiRecipDesc.ulReserved As Integer   // Reserved for future use
105120>>>>>>>>>   Field MapiRecipDesc.ulRecipClass As Integer // Recipient class
105120>>>>>>>>>                                               // MAPI_TO, MAPI_CC, MAPI_BCC, MAPI_ORIG
105120>>>>>>>>>   Field MapiRecipDesc.lpszName As Pointer     // Recipient name
105120>>>>>>>>>   Field MapiRecipDesc.lpszAddress As Pointer  // Recipient address (optional)
105120>>>>>>>>>   Field MapiRecipDesc.ulEIDSize As Pointer    // Count in bytes of size of pEntryID
105120>>>>>>>>>   Field MapiRecipDesc.lpEntryID As Pointer    // System-specific recipient reference
105120>>>>>>>>>End_Type // MapiRecipDesc
105120>>>>>>>>>
105120>>>>>>>>>Define MAPI_ORIG   For 0 // Recipient is message originator
105120>>>>>>>>>Define MAPI_TO     For 1 // Recipient is a primary recipient
105120>>>>>>>>>Define MAPI_CC     For 2 // Recipient is a copy recipient
105120>>>>>>>>>Define MAPI_BCC    For 3 // Recipient is blind copy recipient
105120>>>>>>>>>
105120>>>>>>>>>Type MapiMessage
105120>>>>>>>>>   Field MapiMessage.ulReserved As Integer                   // Reserved for future use (M.B. 0)
105120>>>>>>>>>   Field MapiMessage.lpszSubject As Pointer                  // Message Subject
105120>>>>>>>>>   Field MapiMessage.lpszNoteText As Pointer                 // Message Text
105120>>>>>>>>>   Field MapiMessage.lpszMessageType As Pointer              // Message Class
105120>>>>>>>>>   Field MapiMessage.lpszDateReceived As Pointer             // in YYYY/MM/DD HH:MM format
105120>>>>>>>>>   Field MapiMessage.lpszConversationID As Pointer           // conversation thread ID
105120>>>>>>>>>   Field MapiMessage.flFlags As Integer                      // unread,return receipt
105120>>>>>>>>>   Field MapiMessage.lpOriginator As Pointer                 // Originator descriptor
105120>>>>>>>>>   Field MapiMessage.nRecipCount As Integer                  // Number of recipients
105120>>>>>>>>>   Field MapiMessage.lpRecips As Pointer                     // Recipient descriptors
105120>>>>>>>>>   Field MapiMessage.nFileCount As Integer                   // # of file attachments
105120>>>>>>>>>   Field MapiMessage.lpFiles As Pointer                      // Attachment descriptors
105120>>>>>>>>>End_Type // MapiMessage
105120>>>>>>>>>
105120>>>>>>>>>Define MAPI_UNREAD            For |CI$00000001
105120>>>>>>>>>Define MAPI_RECEIPT_REQUESTED For |CI$00000002
105120>>>>>>>>>Define MAPI_SENT              For |CI$00000004
105120>>>>>>>>>
105120>>>>>>>>>// MAPILogon() flags.
105120>>>>>>>>>Define MAPI_LOGON_UI         For |CI$00000001 // Display logon UI
105120>>>>>>>>>Define MAPI_PASSWORD_UI      For |CI$00020000 // prompt for password only
105120>>>>>>>>>Define MAPI_NEW_SESSION      For |CI$00000002 // Don't use shared session
105120>>>>>>>>>Define MAPI_FORCE_DOWNLOAD   For |CI$00001000 // Get new mail before return
105120>>>>>>>>>Define MAPI_ALLOW_OTHERS     For |CI$00000008 // Make this a shared session
105120>>>>>>>>>Define MAPI_EXPLICIT_PROFILE For |CI$00000010 // Don't use default profile
105120>>>>>>>>>Define MAPI_EXTENDED         For |CI$00000020 // Extended MAPI Logon
105120>>>>>>>>>Define MAPI_USE_DEFAULT      For |CI$00000040 // Use default profile in logon
105120>>>>>>>>>
105120>>>>>>>>>Define MAPI_SIMPLE_DEFAULT  For (MAPI_LOGON_UI + MAPI_FORCE_DOWNLOAD + MAPI_ALLOW_OTHERS)
105120>>>>>>>>>Define MAPI_SIMPLE_EXPLICIT For (MAPI_NEW_SESSION + MAPI_FORCE_DOWNLOAD + MAPI_EXPLICIT_PROFILE)
105120>>>>>>>>>
105120>>>>>>>>>// MAPILogoff() flags.
105120>>>>>>>>>Define MAPI_LOGOFF_SHARED For |CI$00000001 // Close all shared sessions
105120>>>>>>>>>Define MAPI_LOGOFF_UI     For |CI$00000002 // It's OK to present UI
105120>>>>>>>>>
105120>>>>>>>>>// MAPISendMail() flags.
105120>>>>>>>>>Define MAPI_LOGON_UI    For |CI$00000001 // Display logon UI
105120>>>>>>>>>Define MAPI_NEW_SESSION For |CI$00000002 // Don't use shared session
105120>>>>>>>>>
105120>>>>>>>>>Define MAPI_DIALOG      For |CI$00000008 // Display a send note UI
105120>>>>>>>>>Define MAPI_USE_DEFAULT For |CI$00000040 // Use default profile in logon
105120>>>>>>>>>
105120>>>>>>>>>// MAPIFindNext() flags.
105120>>>>>>>>>Define MAPI_UNREAD_ONLY    For |CI$00000020 // Only unread messages
105120>>>>>>>>>Define MAPI_GUARANTEE_FIFO For |CI$00000100 // use date order
105120>>>>>>>>>Define MAPI_LONG_MSGID     For |CI$00004000 // allow 512 char returned ID
105120>>>>>>>>>
105120>>>>>>>>>// MAPIReadMail() flags.
105120>>>>>>>>>Define MAPI_PEEK            For |CI$00000080 // Do not mark as read.
105120>>>>>>>>>Define MAPI_SUPPRESS_ATTACH For |CI$00000800 // header + body, no files
105120>>>>>>>>>Define MAPI_ENVELOPE_ONLY   For |CI$00000040 // Only header information
105120>>>>>>>>>Define MAPI_BODY_AS_FILE    For |CI$00000200
105120>>>>>>>>>
105120>>>>>>>>>// MAPISaveMail() flags.
105120>>>>>>>>>Define MAPI_LOGON_UI    For |CI$00000001 // Display logon UI
105120>>>>>>>>>Define MAPI_NEW_SESSION For |CI$00000002 // Don't use shared session
105120>>>>>>>>>Define MAPI_LONG_MSGID  For |CI$00004000 // allow 512 char returned ID
105120>>>>>>>>>
105120>>>>>>>>>// MAPIAddress() flags.
105120>>>>>>>>>Define MAPI_LOGON_UI    For |CI$00000001 // Display logon UI
105120>>>>>>>>>Define MAPI_NEW_SESSION For |CI$00000002 // Don't use shared session
105120>>>>>>>>>
105120>>>>>>>>>// MAPIDetails() flags.
105120>>>>>>>>>Define MAPI_LOGON_UI    For |CI$00000001 // Display logon UI
105120>>>>>>>>>Define MAPI_NEW_SESSION For |CI$00000002 // Don't use shared session
105120>>>>>>>>>Define MAPI_AB_NOMODIFY For |CI$00000400 // Don't allow mods of AB entries
105120>>>>>>>>>
105120>>>>>>>>>// MAPIResolveName() flags.
105120>>>>>>>>>Define MAPI_LOGON_UI    For |CI$00000001 // Display logon UI
105120>>>>>>>>>Define MAPI_NEW_SESSION For |CI$00000002 // Don't use shared session
105120>>>>>>>>>Define MAPI_DIALOG      For |CI$00000008 // Prompt for choices if ambiguous
105120>>>>>>>>>Define MAPI_AB_NOMODIFY For |CI$00000400 // Don't allow mods of AB entries
105120>>>>>>>>>
105120>>>>>>>>>Define SUCCESS_SUCCESS                 For 0
105120>>>>>>>>>Define MAPI_USER_ABORT                 For 1
105120>>>>>>>>>Define MAPI_E_USER_ABORT               For MAPI_USER_ABORT
105120>>>>>>>>>Define MAPI_E_FAILURE                  For 2
105120>>>>>>>>>Define MAPI_E_LOGON_FAILURE            For 3
105120>>>>>>>>>Define MAPI_E_LOGIN_FAILURE            For MAPI_E_LOGON_FAILURE
105120>>>>>>>>>Define MAPI_E_DISK_FULL                For 4
105120>>>>>>>>>Define MAPI_E_INSUFFICIENT_MEMORY      For 5
105120>>>>>>>>>Define MAPI_E_ACCESS_DENIED            For 6
105120>>>>>>>>>Define MAPI_E_TOO_MANY_SESSIONS        For 8
105120>>>>>>>>>Define MAPI_E_TOO_MANY_FILES           For 9
105120>>>>>>>>>Define MAPI_E_TOO_MANY_RECIPIENTS      For 10
105120>>>>>>>>>Define MAPI_E_ATTACHMENT_NOT_FOUND     For 11
105120>>>>>>>>>Define MAPI_E_ATTACHMENT_OPEN_FAILURE  For 12
105120>>>>>>>>>Define MAPI_E_ATTACHMENT_WRITE_FAILURE For 13
105120>>>>>>>>>Define MAPI_E_UNKNOWN_RECIPIENT        For 14
105120>>>>>>>>>Define MAPI_E_BAD_RECIPTYPE            For 15
105120>>>>>>>>>Define MAPI_E_NO_MESSAGES              For 16
105120>>>>>>>>>Define MAPI_E_INVALID_MESSAGE          For 17
105120>>>>>>>>>Define MAPI_E_TEXT_TOO_LARGE           For 18
105120>>>>>>>>>Define MAPI_E_INVALID_SESSION          For 19
105120>>>>>>>>>Define MAPI_E_TYPE_NOT_SUPPORTED       For 20
105120>>>>>>>>>Define MAPI_E_AMBIGUOUS_RECIPIENT      For 21
105120>>>>>>>>>Define MAPI_E_AMBIG_RECIP              For MAPI_E_AMBIGUOUS_RECIPIENT
105120>>>>>>>>>Define MAPI_E_MESSAGE_IN_USE           For 22
105120>>>>>>>>>Define MAPI_E_NETWORK_FAILURE          For 23
105120>>>>>>>>>Define MAPI_E_INVALID_EDITFIELDS       For 24
105120>>>>>>>>>Define MAPI_E_INVALID_RECIPS           For 25
105120>>>>>>>>>Define MAPI_E_NOT_SUPPORTED            For 26
105120>>>>>>>Use WinKern.pkg
105120>>>>>>>
105120>>>>>>>External_Function MAPILogon "MAPILogon" Mapi32.Dll ;   Integer ulUIParam ;   Pointer lpszProfileName ;   Pointer lpszPassword ;   Integer flFlags ;   Integer ulReserved ;   Pointer lplhSession ;   Returns Integer
105121>>>>>>>External_Function MAPILogoff "MAPILogoff" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Integer flFlags ;   Integer ulReserved ;   Returns Integer
105122>>>>>>>External_Function MAPIFindNext "MAPIFindNext" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpszMessageType ;   Pointer lpszSeedMessageID ;   Integer flFlags ;   Integer ulReserved ;   Pointer lpszMessageID ;   Returns Integer
105123>>>>>>>External_Function MAPIFreeBuffer "MAPIFreeBuffer" Mapi32.Dll ;   Pointer pv ;   Returns Integer
105124>>>>>>>External_Function MAPIReadMail "MAPIReadMail" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpszMessageID ;   Integer flFlags ;   Integer ulReserved ;   Pointer lppMessage ;   Returns Integer
105125>>>>>>>External_Function MAPIAddress "MAPIAddress" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpszCaption ;   Integer nEditFields ;   Pointer lpszLabels ;   Integer nRecips ;   Pointer lpRecips ;   Integer flFlags ;   Integer ulReserved ;   Pointer lpnNewRecips ;   Pointer lppNewRecips ;   Returns Integer
105126>>>>>>>External_Function MAPIResolveName "MAPIResolveName" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpszName ;   Integer flFlags ;   Integer ulReserved ;   Pointer lppRecip ;   Returns Integer
105127>>>>>>>External_Function MAPISendMail "MAPISendMail" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpMessage ;   Integer flFlags ;   Integer ulReserved ;   Returns Integer
105128>>>>>>>External_Function MAPISaveMail "MAPISaveMail" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpMessage ;   Integer flFlags ;   Integer ulReserved ;   Pointer lpszMessageID ;   Returns Integer
105129>>>>>>>External_Function MAPIDeleteMail "MAPIDeleteMail" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpszMessageID ;   Integer flFlags ;   Integer ulReserved ;   Returns Integer
105130>>>>>>>External_Function MAPISendDocuments "MAPISendDocuments" Mapi32.Dll ;   Integer ulUIParam ;   Pointer lpszDelimChar ;   Pointer lpszFullPaths ;   Pointer lpszFileNames ;   Integer ulReserved ;   Returns Integer
105131>>>>>>>External_Function MAPIDetails "MAPIDetails" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpRecip ;   Integer flFlags ;   Integer ulReserved ;   Returns Integer
105132>>>>>>>
105132>>>>>>>External_Function ShellExecute "ShellExecuteA" Shell32.Dll ;   Handle hwnd ;   String sOperation ;   String sFile ;   String sParameters ;   String sDirectory ;   Integer nShowCmd ;   Returns VOID_TYPE
105133>>>>>Use DFBTRDRV.PKG
105133>>>>>Use MSSqldrv.pkg
105133>>>>>Use db2_drv.pkg
105133>>>>>Use odbc_drv.pkg
105133>>>>>Use seq_chnl.pkg
105133>>>>>//Use Std_help.pkg
105133>>>>>
105133>>>>>Register_Function phoWorkspace Returns Handle
105133>>>>>Register_Function Help_filename Returns String
105133>>>>>Register_Function GetHelpFile Returns String
105133>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
105133>>>>>
105133>>>>>// Use of Mertech drivers:
105133>>>>>// Ad the line "Define DUF_Use_Mertech_Drivers" prior "Use" of this package to your source code if using Mertech drivers!
105133>>>>>
105133>>>>>
105133>>>>>
105133>>>>>
105133>>>>>
105133>>>>>// *** Constant Declarations: ***
105133>>>>>//
105133>>>>>
105133>>>>>// NOTE: These text constants should be added to the various "Language_xxx.inc" files:
105133>>>>>
105133>>>>>
105133>>>>>
105133>>>>>
105133>>>>>
105133>>>>>// 2016-12-12, Samuel:  Added section for Portuguese
105133>>>>>
105133>>>>>
105133>>>>>
105133>>>>>
105133>>>>>
105133>>>>>
105133>>>>>
105133>>>>>
105133>>>>>
105133>>>>>// System icon menu constants. If the upper left hand
105133>>>>>// icon in dialogs is clicked, shadow all menu items except Move & Close.
105133>>>>>    Define SC_RESTORE  for |CI$F120
105133>>>>>    Define SC_MOVE     for |CI$F010
105133>>>>>    Define SC_SIZE     for |CI$F000
105133>>>>>    Define SC_MINIMIZE for |CI$F020
105133>>>>>    Define SC_MAXIMIZE for |CI$F030
105133>>>>>    Define SC_CLOSE    for |CI$F060
105133>>>>>    Define SC_KEYMENU  for |CI$F100
105133>>>>>    Define SC_NEXTWINDOW for |CI$F040
105133>>>>>    Define SC_PREVWINDOW for |CI$F050
105133>>>>>
105133>>>>>// *** Struct Declarations: ***
105133>>>>>//#IF (Required_RT_Version > 18) // Temp! Should be "19". Fix after 19.1 beta phase1
105133>>>>>//#ELSE
105133>>>>>Struct tWinMemoryStatusEx
105133>>>>>    UInteger dwLength
105133>>>>>    UInteger dwMemoryLoad
105133>>>>>    UBigInt ullTotalPhys
105133>>>>>    UBigInt ullAvailPhys
105133>>>>>    UBigInt ullTotalPageFile
105133>>>>>    UBigInt ullAvailPageFile
105133>>>>>    UBigInt ullTotalVirtual
105133>>>>>    UBigInt ullAvailVirtual
105133>>>>>    UBigInt ullAvailExtendedVirtual
105133>>>>>End_Struct
105133>>>>>//#ENDIF
105133>>>>>
105133>>>>>// OBSOLETE STRUCTURE AND WINDOWS API CALL. KEPT FOR BACKWARDS COMPATIBILITY
105133>>>>>//Type MEMORYSTATUS
105133>>>>>//   Field MEMORYSTATUS.dwLength         as DWord // sizeof(MEMORYSTATUS)
105133>>>>>//   Field MEMORYSTATUS.dwMemoryLoad     as DWord // percent Of memory in use
105133>>>>>//   Field MEMORYSTATUS.dwTotalPhys      as DWord // bytes Of physical memory
105133>>>>>//   Field MEMORYSTATUS.dwAvailPhys      as DWord // free physical memory bytes
105133>>>>>//   Field MEMORYSTATUS.dwTotalPageFile  as DWord // bytes Of paging file
105133>>>>>//   Field MEMORYSTATUS.dwAvailPageFile  as DWord // free bytes Of paging file
105133>>>>>//   Field MEMORYSTATUS.dwTotalVirtual   as DWord // user bytes Of address space
105133>>>>>//   Field MEMORYSTATUS.dwAvailVirtual   as DWord // free user bytes
105133>>>>>//End_Type
105133>>>>>
105133>>>>>// *** External Function calls: ***
105133>>>>>//
105133>>>>>    External_Function GetSystemMenu "GetSystemMenu" User32.dll Handle hWnd Boolean bRevert Returns Handle
105134>>>>>
105134>>>>>    External_Function GetRemoveMenu "RemoveMenu" user32.dll Handle hWnd UInteger uPosition UInteger uFlags Returns Handle
105135>>>>>
105135>>>>>    External_Function WNetGetUser "WNetGetUserA" MPR.DLL Pointer lpName Pointer lpUser_Name Pointer lpLength Returns DWord
105136>>>>>
105136>>>>>    External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
105137>>>>>
105137>>>>>    External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
105138>>>>>
105138>>>>>// *** Global/Desktop Function Declarations: ***
105138>>>>>
105138>>>>>Function ComputerName for Desktop Returns String
105140>>>>>    String sName
105140>>>>>    Get_Environment "COMPUTERNAME" to sName
105141>>>>>>
105141>>>>>    Function_Return sName
105142>>>>>End_Function
105143>>>>>
105143>>>>>Function Network_User_Name for cDesktop Returns String
105145>>>>>    String sName
105145>>>>>    Get_Environment "USERNAME" to sName
105146>>>>>>
105146>>>>>    Function_Return sName
105147>>>>>End_Function
105148>>>>>
105148>>>>>// *** Class Declarations: ***
105148>>>>>//
105148>>>>>Class cBitmapContainerVDFLink is a BitmapContainer
105149>>>>>    Procedure Mouse_Click Integer iWindowNumber Integer iPosition
105151>>>>>        Send Mouse_Up iWindowNumber iPosition
105152>>>>>    End_Procedure
105153>>>>>    Procedure Mouse_Up Integer iWindowNumber Integer iPosition
105155>>>>>        Forward Send Mouse_Up iWindowNumber iPosition
105157>>>>>        Send Show_HomePage "http://www.dataaccess.com/"
105158>>>>>    End_Procedure
105159>>>>>End_Class
105160>>>>>
105160>>>>>Class cCopyEditorContentButton is a Button
105161>>>>>    Procedure Construct_Object
105163>>>>>        Forward Send Construct_Object
105165>>>>>        Property Handle phoEditorHandle
105166>>>>>        Set psToolTip to C_$DescCopy
105167>>>>>    End_Procedure
105168>>>>>
105168>>>>>    Procedure CopyToWindowsClipboard
105170>>>>>        String sValue
105170>>>>>        Handle hoEditor
105170>>>>>        Boolean bCanCopy
105170>>>>>        Address aEditorAddress
105170>>>>>
105170>>>>>        Get phoEditorHandle to hoEditor
105171>>>>>        Send Select_All of hoEditor
105172>>>>>        Get CanCopy of hoEditor to bCanCopy
105173>>>>>        If (bCanCopy = True) Begin
105175>>>>>            Get paValue of hoEditor to aEditorAddress
105176>>>>>            Move aEditorAddress to sValue
105177>>>>>            Send Copy   of hoEditor
105178>>>>>            // Remove the selection after text is copied to the clipboard.
105178>>>>>            Send Beginning_of_Data of hoEditor
105179>>>>>            Send Info_Box C_$CopyToClipboard_Text
105180>>>>>        End
105180>>>>>>
105180>>>>>    End_Procedure
105181>>>>>End_Class
105182>>>>>
105182>>>>>Class SysinfoDisplay is a cTextEdit
105183>>>>>    Procedure Construct_Object
105185>>>>>        Forward Send Construct_Object
105187>>>>>
105187>>>>>        Set Size to 104 247
105188>>>>>        Set Location to 4 6
105189>>>>>        Set Border_Style to Border_None
105190>>>>>        Set peAnchors to anAll
105191>>>>>        Set Read_Only_State to True
105192>>>>>        Set pbWrap to True
105193>>>>>    End_Procedure
105194>>>>>
105194>>>>>    // Augmented class message to adjust certain text strings that are wrong...
105194>>>>>
105194>>>>>    Procedure AppendTextLn String sText
105196>>>>>        String sWorkspaceWSFile
105196>>>>>
105196>>>>>        // Only works for English:
105196>>>>>        If (ghoApplication > 0) Begin
105198>>>>>            If (sText contains "Workspace Name") Begin
105200>>>>>                Move "Workspace Config Filename:" to sText
105201>>>>>                Get psWorkspaceWSFile of (phoWorkspace(ghoApplication)) to sWorkspaceWSFile
105202>>>>>                Move (sText * sWorkspaceWSFile) to sText
105203>>>>>            End
105203>>>>>>
105203>>>>>        End
105203>>>>>>
105203>>>>>        Send AppendText sText
105204>>>>>        Send AppendText (character(10))
105205>>>>>    End_Procedure
105206>>>>>
105206>>>>>    //****************************************************************************
105206>>>>>    // $Module type: PROCEDURE
105206>>>>>    // $Module name: Show_Current_Directory
105206>>>>>    // $Author     : VOO
105206>>>>>    // Created     : 06-10-96 @ 15:24
105206>>>>>    //
105206>>>>>    // Description
105206>>>>>    //    This method will show the name Of the current directory in the system
105206>>>>>    //    information box
105206>>>>>    //
105206>>>>>    // $Rev History
105206>>>>>    //    06-10-96  Module header created
105206>>>>>    //****************************************************************************
105206>>>>>    Procedure Show_Current_Directory
105208>>>>>        String sDir
105208>>>>>
105208>>>>>        Get_Current_Directory To sDir
105209>>>>>
105209>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
105210>>>>>    End_Procedure
105211>>>>>
105211>>>>>    Procedure Show_Windows_Directory
105213>>>>>        String sWindir
105213>>>>>
105213>>>>>        Get_Windows_Directory To sWindir
105214>>>>>
105214>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
105215>>>>>    End_Procedure
105216>>>>>
105216>>>>>    Procedure Show_Current_User
105218>>>>>        Send AppendTextLn (SFormat (C_$Computer_Name, ComputerName (Self)))
105219>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
105220>>>>>    End_Procedure
105221>>>>>
105221>>>>>    Procedure Show_Number_Format
105223>>>>>        Integer iFormat
105223>>>>>        String sFormatText
105223>>>>>
105223>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
105226>>>>>        Move (Character (iFormat)) To sFormatText
105227>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
105228>>>>>
105228>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
105231>>>>>        Move (Character (iFormat)) to sFormatText
105232>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
105233>>>>>    End_Procedure
105234>>>>>
105234>>>>>    Procedure Show_Filelist_Name
105236>>>>>        String sFilename
105236>>>>>
105236>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
105239>>>>>
105239>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
105240>>>>>    End_Procedure
105241>>>>>
105241>>>>>    Procedure Show_Lock_Delay
105243>>>>>        Integer iLockdelay
105243>>>>>
105243>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
105246>>>>>
105246>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
105247>>>>>    End_Procedure
105248>>>>>
105248>>>>>    Procedure Show_Lock_Timeout
105250>>>>>        Integer iLockTimeout
105250>>>>>
105250>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
105253>>>>>
105253>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
105254>>>>>    End_Procedure
105255>>>>>
105255>>>>>    Procedure Show_Screen_Size
105257>>>>>        Integer iYscreensize iXscreensize
105257>>>>>
105257>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) To iXscreensize
105258>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) To iYscreensize
105259>>>>>
105259>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
105260>>>>>    End_Procedure
105261>>>>>
105261>>>>>    Procedure Show_Page_Size
105263>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
105264>>>>>    End_procedure
105265>>>>>
105265>>>>>    Procedure Show_Date
105267>>>>>        Date dToday
105267>>>>>
105267>>>>>        Sysdate dToday
105268>>>>>
105268>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
105269>>>>>    End_procedure
105270>>>>>
105270>>>>>    Procedure Show_Date_Format
105272>>>>>        Integer iDateFormat
105272>>>>>        String sDateFormat
105272>>>>>
105272>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
105275>>>>>        Case Begin
105275>>>>>            Case (iDateFormat = DF_DATE_USA)
105277>>>>>                Move C_$USA To sDateFormat
105278>>>>>                Case Break
105279>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
105282>>>>>                Move C_$European To sDateFormat
105283>>>>>                Case Break
105284>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
105287>>>>>                Move C_$Military To sDateFormat
105288>>>>>                Case Break
105289>>>>>            Case Else
105289>>>>>                Move C_$UnknownDateType To sDateFormat
105290>>>>>                Case Break
105291>>>>>        Case End
105291>>>>>
105291>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
105292>>>>>    End_Procedure
105293>>>>>
105293>>>>>    // 2013-08-14 NGS
105293>>>>>    // Unformatted numeric values shown doesn't look good. These looks much better.
105293>>>>>    Procedure Show_Systemresources
105295>>>>>        tWinMemoryStatusEx MemoryStatusInfo
105295>>>>>        tWinMemoryStatusEx MemoryStatusInfo
105295>>>>>        Integer iRetval
105295>>>>>        Number nValue
105295>>>>>        String sValue
105295>>>>>
105295>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
105296>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
105297>>>>>        If (iRetval = 0) Begin
105299>>>>>            Move (ShowLastError ()) to iRetval
105300>>>>>            Procedure_Return
105301>>>>>        End
105301>>>>>>
105301>>>>>
105301>>>>>        Send AppendTextLn ""
105302>>>>>        Move MemoryStatusInfo.ullTotalPhys to nValue
105303>>>>>
105303>>>>>        // Show memory in Gigabytes:
105303>>>>>        Move (nValue/1024/1024/1024) to nValue
105304>>>>>        Move (Round(nValue)) to nValue
105305>>>>>        Get FormatNumber nValue 2 to sValue
105306>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, (sValue * "GB")))
105307>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, String(MemoryStatusInfo.dwMemoryLoad) * "%"))
105308>>>>>
105308>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0))
105308>>>>>        Move (Real(MemoryStatusInfo.ullAvailPhys) / Real(MemoryStatusInfo.ullTotalPhys) * 100.0) to nValue
105309>>>>>        Move (Round(nValue)) to nValue
105310>>>>>        Get FormatNumber nValue 0 to sValue
105311>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, (sValue * "%")))
105312>>>>>
105312>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0))
105312>>>>>        Move (Real(MemoryStatusInfo.ullAvailPageFile) / Real(MemoryStatusInfo.ullTotalPageFile) * 100.0) to nValue
105313>>>>>        Move (Round(nValue)) to nValue
105314>>>>>        Get FormatNumber nValue 0 to sValue
105315>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, (sValue * "%")))
105316>>>>>
105316>>>>>//        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0))
105316>>>>>        Move (Real(MemoryStatusInfo.ullAvailVirtual) / Real(MemoryStatusInfo.ullTotalVirtual) * 100.0) to nValue
105317>>>>>        Move (Round(nValue)) to nValue
105318>>>>>        Get FormatNumber nValue 0 to sValue
105319>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, (sValue * "%")))
105320>>>>>
105320>>>>>        // Add an empty row after the memory information:
105320>>>>>        Send AppendTextLn ""
105321>>>>>    End_Procedure
105322>>>>>
105322>>>>>    Procedure Show_Registration
105324>>>>>        String sRegName
105324>>>>>        Integer iSN iUsersMax iUserCount
105324>>>>>
105324>>>>>        Registration sRegName iSN
105325>>>>>>
105325>>>>>        Get_Licensed_Max_Users to iUsersMax
105326>>>>>        Get_Current_User_Count to iUserCount
105327>>>>>
105327>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
105328>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
105329>>>>>        Send AppendTextLn (SFormat (C_$Current_User_Count, iUserCount))
105330>>>>>        Send AppendTextLn (SFormat (C_$Max_Licensed_User_Count, iUsersMax))
105331>>>>>    End_Procedure
105332>>>>>
105332>>>>>    //****************************************************************************
105332>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
105332>>>>>    // To the workspace object passing the an object and message To send back
105332>>>>>    // To this object. It is expected that the workspace object will send this
105332>>>>>    // message for every line Of information it wants displayed (passing the
105332>>>>>    // information To be displayed
105332>>>>>    //****************************************************************************
105332>>>>>    Register_Procedure EnumerateWorkspaceData Integer hObjId Integer hmMessId
105332>>>>>
105332>>>>>    Procedure Show_ServicePack
105334>>>>>        String sKey sVersion sDataFlex
105334>>>>>        Handle hoRegistry
105334>>>>>        Boolean bExists bOpened
105334>>>>>
105334>>>>>        Move "DataFlex"        to sDataFlex
105335>>>>>
105335>>>>>        Get Create U_cRegistry to hoRegistry
105336>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
105337>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
105338>>>>>        Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
105339>>>>>
105339>>>>>        If (bExists) Begin
105341>>>>>            Move ("SOFTWARE\Wow6432Node\Data Access Worldwide\" + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
105342>>>>>        End
105342>>>>>>
105342>>>>>        Else Begin
105343>>>>>            Move ("SOFTWARE\Data Access Worldwide\"             + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
105344>>>>>        End
105344>>>>>>
105344>>>>>        Get KeyExists of hoRegistry sKey to bExists
105345>>>>>        If (bExists) Begin
105347>>>>>            Get OpenKey of hoRegistry sKey to bOpened
105348>>>>>            If (bOpened) Begin
105350>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
105351>>>>>                If (bExists) Begin
105353>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersion
105354>>>>>                End
105354>>>>>>
105354>>>>>                Send CloseKey of hoRegistry
105355>>>>>            End
105355>>>>>>
105355>>>>>        End
105355>>>>>>
105355>>>>>        Send Destroy of hoRegistry
105356>>>>>
105356>>>>>        If (sVersion <> "") Begin
105358>>>>>           Send AppendTextLn sVersion
105359>>>>>           Send AppendTextLn ""
105360>>>>>        End
105360>>>>>>
105360>>>>>    End_Procedure
105361>>>>>
105361>>>>>    Procedure Show_WorkspaceInformation
105363>>>>>        Integer hoWorkspace
105363>>>>>
105363>>>>>        If (ghoApplication <> 0) Begin
105365>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
105366>>>>>            If (hoWorkspace <> 0) Begin
105368>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self msg_AppendTextLn
105369>>>>>            End
105369>>>>>>
105369>>>>>        End
105369>>>>>>
105369>>>>>    End_Procedure
105370>>>>>
105370>>>>>    //****************************************************************************
105370>>>>>    // If connection ids are used, we will send the message EnumerateConnections
105370>>>>>    // to the connection manager object passing the an object and message to send
105370>>>>>    // back to this object. It is expected that the connection manager object will
105370>>>>>    // send this message for every line Of information it wants displayed (passing
105370>>>>>    // the information To be displayed
105370>>>>>    //****************************************************************************
105370>>>>>    Register_Procedure EnumerateConnections Integer hObjId Integer hmMessId
105370>>>>>
105370>>>>>    Procedure Show_ConnectionIdInformation
105372>>>>>        If (ghoConnection > 0) Begin
105374>>>>>            Send EnumerateConnections of ghoConnection Self (RefProc(AppendTextLn))
105375>>>>>            Send AppendTextLn ""
105376>>>>>        End
105376>>>>>>
105376>>>>>    End_Procedure
105377>>>>>
105377>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
105379>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
105380>>>>>    End_Function
105381>>>>>
105381>>>>>    Procedure Show_Versions
105383>>>>>        Integer iVersion iRevision iBuild
105383>>>>>
105383>>>>>        Version_information iVersion iRevision iBuild
105385>>>>>
105385>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(self,iVersion,iRevision,iBuild) ))
105386>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
105387>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
105388>>>>>    End_Procedure
105389>>>>>
105389>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
105391>>>>>        Boolean bOK
105391>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
105392>>>>>        Function_Return bOK
105393>>>>>    End_Function
105394>>>>>
105394>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
105396>>>>>        Boolean bOK
105396>>>>>        Function_Return bOK
105397>>>>>    End_Function
105398>>>>>
105398>>>>>    //***
105398>>>>>    //*** BW
105398>>>>>    //*** Procedure: Show_Drivers
105398>>>>>    //*** Purpose  : Show loaded database drivers
105398>>>>>    //***
105398>>>>>
105398>>>>>    Procedure Show_Drivers
105400>>>>>        String sDriverID sVersion sClient sValue
105400>>>>>        Integer iNumberOfDrivers iDriver iClient iUsersMax iSerialNo iNumServers iCount
105400>>>>>        Handle hoCLIHandler hoBtrvHandler
105400>>>>>        Boolean bStudioLicense bIsDAWDriver bIsMertechDriver
105400>>>>>
105400>>>>>        Move False to bStudioLicense
105401>>>>>
105401>>>>>        Get Create U_cCLIHandler      to hoCLIHandler
105402>>>>>        Get Create U_cDFBtrDrvHandler to hoBtrvHandler
105403>>>>>
105403>>>>>        // For testing purposes:
105403>>>>>//        Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
105403>>>>>//        Load_Driver MSSQLDRV_ID
105403>>>>>//        Load_Driver ODBC_DRV_ID
105403>>>>>//        Load_Driver DB2_DRV_ID
105403>>>>>//        Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
105403>>>>>//
105403>>>>>//        #IFDEF DUF_Use_Mertech_Drivers
105403>>>>>//            Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
105403>>>>>//            Load_Driver SQLFLEX
105403>>>>>//            Load_Driver MDSPgSQL
105403>>>>>//            Load_Driver MDSMySQL
105403>>>>>//            Load_Driver ORAFLEX
105403>>>>>//            Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
105403>>>>>//        #ENDIF
105403>>>>>        Move False to Err
105404>>>>>
105404>>>>>        // Loop through all loaded drivers.
105404>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
105407>>>>>        If (iNumberOfDrivers > 1) Begin
105409>>>>>            Send AppendTextLn ""
105410>>>>>        End
105410>>>>>>
105410>>>>>        For iDriver from 1 to iNumberOfDrivers
105416>>>>>>
105416>>>>>            // For some weird reason it can happen that - when using Mertech drivers - that the driver index
105416>>>>>            // was increased in the CLI array, but it has no value. In that case a "Bad parameter..." error
105416>>>>>            // would be thrown, so we safeguard from that here.
105416>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
105417>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
105420>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
105421>>>>>            Get IsDAWSQLDriver sDriverID to bIsDAWDriver
105422>>>>>            Get IsMertechDriver sDriverID to bIsMertechDriver
105423>>>>>
105423>>>>>            If (sDriverID = DFBTRDRV_ID or bIsDAWDriver = True or bIsMertechDriver = True) Begin
105425>>>>>
105425>>>>>                // Pervasive/Btrieve database
105425>>>>>                If (sDriverID = DFBTRDRV_ID) Begin
105427>>>>>                    Get CKRevision of hoBtrvHandler to sVersion
105428>>>>>                    Get PSQLLocalEngineVersionInfo of hoBtrvHandler 0 to sClient
105429>>>>>                    If (sClient <> "0.0.0") Begin
105431>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Local_Engine_Version, sClient))
105432>>>>>                    End
105432>>>>>>
105432>>>>>                    Get PSQLServerEngineVersionInfo of hoBtrvHandler 0 to sClient
105433>>>>>                    If (sClient <> "0.0.0") Begin
105435>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Server_Engine_Version, sClient))
105436>>>>>                    End
105436>>>>>>
105436>>>>>                End
105436>>>>>>
105436>>>>>
105436>>>>>                Else Begin
105437>>>>>                    Set psDriverID of hoCLIHandler to sDriverID
105438>>>>>                    Move 0 to iNumServers
105439>>>>>                    If (sDriverID <> DATAFLEX_ID) Begin
105441>>>>>                        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iNumServers
105444>>>>>                    End
105444>>>>>>
105444>>>>>
105444>>>>>                    If (bIsDAWDriver = True) Begin
105446>>>>>                        If (sDriverID = MSSQLDRV_ID) Begin
105448>>>>>                            // This info is only available for the MS SQL driver:
105448>>>>>                            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClient
105451>>>>>                            If (iClient = 13) Begin
105453>>>>>                                Move C_$SQLSERVER2016DRVRSTR              to sClient
105454>>>>>                            End
105454>>>>>>
105454>>>>>                            If (iClient = 12) Begin
105456>>>>>                                Move C_$SQLSERVER2014DRVRSTR              to sClient
105457>>>>>                            End
105457>>>>>>
105457>>>>>                            If (iClient = 11) Begin
105459>>>>>                                Move C_$SQL_Server_Native_Client_11_0     to sClient
105460>>>>>                            End
105460>>>>>>
105460>>>>>                            If (iClient = 10) Begin
105462>>>>>                                Move C_$SQL_Server_Native_Client_10_0     to sClient
105463>>>>>                            End
105463>>>>>>
105463>>>>>                            If (iClient = 9) Begin
105465>>>>>                                Move C_$SQL_Native_Client                 to sClient
105466>>>>>                            End
105466>>>>>>
105466>>>>>                            If (iClient = 8) Begin
105468>>>>>                                Move C_$SQL_Server_SQL_Server_2000_client to sClient
105469>>>>>                            End
105469>>>>>>
105469>>>>>                            If (sClient <> "") Begin
105471>>>>>                                Move ("    " + sClient) to sClient
105472>>>>>                            End
105472>>>>>>
105472>>>>>                        End
105472>>>>>>
105472>>>>>
105472>>>>>                        Get CKRevision of hoCLIHandler to sVersion
105473>>>>>                    End
105473>>>>>>
105473>>>>>
105473>>>>>                    If (bIsMertechDriver = True) Begin
105475>>>>>                    End
105475>>>>>>
105475>>>>>
105475>>>>>                    // If the serialnumber is = 0, it means that the
105475>>>>>                    // Studio licens is in use and there is no
105475>>>>>                    // number of max users defined because the driver is
105475>>>>>                    // relying on the info from the VDF license.
105475>>>>>                    If (bStudioLicense = False) Begin
105477>>>>>                        Get SerialNumber of hoCLIHandler to iSerialNo
105478>>>>>                        Move (iSerialNo = 0) to bStudioLicense
105479>>>>>                    End
105479>>>>>>
105479>>>>>                End
105479>>>>>>
105479>>>>>                Send AppendTextLn (SFormat (C_$DatabaseDriver, (sDriverID * "-" * (C_$Version + ": " + sVersion))))
105480>>>>>                If (iNumServers <> 0) Begin
105482>>>>>                    For iCount from 1 to iNumServers
105488>>>>>>
105488>>>>>                        Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
105491>>>>>                        Send AppendTextLn ("    " + "Server/DSN:" * sValue)
105492>>>>>                    Loop
105493>>>>>>
105493>>>>>                End
105493>>>>>>
105493>>>>>                If (sClient <> "" and sDriverID = MSSQLDRV_ID) Begin
105495>>>>>                    Send AppendTextLn sClient
105496>>>>>                End
105496>>>>>>
105496>>>>>            End
105496>>>>>>
105496>>>>>        Loop
105497>>>>>>
105497>>>>>
105497>>>>>        Send AppendTextLn ""
105498>>>>>        If (bStudioLicense = False) Begin
105500>>>>>            Get MaxUsers of hoCLIHandler to iUsersMax
105501>>>>>            Send AppendTextLn (SFormat (C_$Max_DbDriver_Licensed_User_Count, iUsersMax))
105502>>>>>        End
105502>>>>>>
105502>>>>>        Else Begin
105503>>>>>            Send AppendTextLn C_$VDF_Studio_License_Text
105504>>>>>        End
105504>>>>>>
105504>>>>>        Send Destroy of hoCLIHandler
105505>>>>>        Send Destroy of hoBtrvHandler
105506>>>>>    End_Procedure
105507>>>>>
105507>>>>>    Procedure Show_HelpFile
105509>>>>>        String sHelpFile
105509>>>>>        Integer eHelpType
105509>>>>>
105509>>>>>        If (ghoApplication <> 0) Begin
105511>>>>>            Get peHelpType Of ghoApplication To eHelpType
105512>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
105514>>>>>                Get GetHelpFile Of ghoHtmlHelp To sHelpFile
105515>>>>>            End
105515>>>>>>
105515>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
105518>>>>>                Get Help_filename Of Help_object_id To sHelpFile
105519>>>>>            End
105519>>>>>>
105519>>>>>            Else Begin
105520>>>>>                Move C_$ThereIsNoHelpfileDefined To sHelpFile
105521>>>>>            End
105521>>>>>>
105521>>>>>
105521>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
105522>>>>>        End
105522>>>>>>
105522>>>>>    End_Procedure
105523>>>>>
105523>>>>>    Procedure Show_EnterAsTab
105525>>>>>        Boolean bEnterKeyAsTabKey
105525>>>>>        String sText
105525>>>>>
105525>>>>>        If (ghoApplication <> 0) Begin
105527>>>>>            Get pbEnterKeyAsTabKey Of ghoApplication To bEnterKeyAsTabKey
105528>>>>>            If (bEnterKeyAsTabKey) Begin
105530>>>>>                Move "True" To sText
105531>>>>>            End
105531>>>>>>
105531>>>>>            Else Begin
105532>>>>>                Move "False" To sText
105533>>>>>            End
105533>>>>>>
105533>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
105534>>>>>        End
105534>>>>>>
105534>>>>>    End_Procedure
105535>>>>>
105535>>>>>    //****************************************************************************
105535>>>>>    // $Module type: PROCEDURE
105535>>>>>    // $Module name: Add_Focus
105535>>>>>    // $Author     : VOO
105535>>>>>    // Created     : 24-09-96 @ 19:43
105535>>>>>    //
105535>>>>>    // Description
105535>>>>>    //    During activation we will remove the old information and add the newly
105535>>>>>    //    found systeminformation
105535>>>>>    //
105535>>>>>    // $Rev History
105535>>>>>    //    24-09-96  Module header created
105535>>>>>    //****************************************************************************
105535>>>>>    Procedure Add_Focus Integer hoRoot
105537>>>>>        Forward Send Add_Focus hoRoot
105539>>>>>
105539>>>>>        Send Delete_Data
105540>>>>>
105540>>>>>        Set Changed_State To False
105541>>>>>        Set Read_Only_State To True
105542>>>>>
105542>>>>>        Send Show_Registration
105543>>>>>        Send Show_Drivers
105544>>>>>        Send AppendTextLn ""
105545>>>>>
105545>>>>>        Send Show_ServicePack
105546>>>>>        If (ghoApplication <> 0) Begin
105548>>>>>            Send Show_WorkSpaceInformation
105549>>>>>            Send Show_HelpFile
105550>>>>>            Send AppendTextLn ""
105551>>>>>        End
105551>>>>>>
105551>>>>>        Else Begin
105552>>>>>            Send AppendTextLn ""
105553>>>>>        End
105553>>>>>>
105553>>>>>
105553>>>>>        If (ghoConnection <> 0) Begin
105555>>>>>            Send Show_ConnectionIdInformation
105556>>>>>        End
105556>>>>>>
105556>>>>>
105556>>>>>        Send Show_Current_User
105557>>>>>        Send Show_Windows_Directory
105558>>>>>        Send Show_Current_Directory
105559>>>>>
105559>>>>>        // This is already shown in the workspace details,
105559>>>>>        // unless no workspace object is present:
105559>>>>>        If (ghoApplication = 0) Begin
105561>>>>>            Send Show_Filelist_Name
105562>>>>>        End
105562>>>>>>
105562>>>>>
105562>>>>>        If (ghoApplication <> 0) Begin
105564>>>>>            Send AppendTextLn ""
105565>>>>>            Send Show_EnterAsTab
105566>>>>>        End
105566>>>>>>
105566>>>>>
105566>>>>>        Send Show_Versions
105567>>>>>        Send Show_Screen_Size
105568>>>>>        Send Show_Page_Size
105569>>>>>        Send Show_Number_Format
105570>>>>>        Send Show_Date_Format
105571>>>>>        Send Show_Lock_Delay
105572>>>>>        Send Show_Lock_Timeout
105573>>>>>        Send Show_Date
105574>>>>>        Send Show_Systemresources
105575>>>>>        Send Beginning_of_Data
105576>>>>>
105576>>>>>        Set Icon to 'default.ico'
105577>>>>>    End_Procedure
105578>>>>>End_Class
105579>>>>>
105579>>>>>//****************************************************************************
105579>>>>>// $Module type: OBJECT
105579>>>>>// $Module name: Sysinfo_Dialog
105579>>>>>// $Author     : VOO
105579>>>>>// Created     : 24-09-96 @ 18:47
105579>>>>>//
105579>>>>>// Description
105579>>>>>//    This object shows the systeminformation on the screen
105579>>>>>//
105579>>>>>// $Rev History
105579>>>>>//    24-09-96  Module header created
105579>>>>>//****************************************************************************
105579>>>>>Class SysInfoDialog is a ModalPanel
105580>>>>>    Procedure Construct_Object
105582>>>>>        Forward Send Construct_Object
105584>>>>>
105584>>>>>        Set Label to C_$SystemInformation
105585>>>>>        Set Size to 140 267
105586>>>>>        Set Locate_Mode to CENTER_ON_PARENT
105587>>>>>        Set Border_Style to Border_Thick
105588>>>>>        Set Sysmenu_Icon to False
105589>>>>>
105589>>>>>        // "+1" will make the panel to paint correctly.
105589>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)) +1)
105590>>>>>
105590>>>>>        // 2014-09-14 NGS
105590>>>>>        // Added a container object around the cTexteditor
105590>>>>>        // object to get a border around the text.
105590>>>>>        Object oSysinfoDisplayContainer is a Container3d
105592>>>>>            Set Location to 2 4
105593>>>>>            Set Size to 110 255
105594>>>>>            Set Border_Style to Border_ClientEdge
105595>>>>>            Set Color to clWhite
105596>>>>>            Set peAnchors to anAll
105597>>>>>
105597>>>>>            Object oSysinfoDisplay is a SysInfoDisplay
105599>>>>>            End_Object
105600>>>>>
105600>>>>>        End_Object
105601>>>>>
105601>>>>>        Object oCloseButton is a Button
105603>>>>>            Set Label to C_$Close
105604>>>>>            Set Location to 120 210
105605>>>>>            Set Message item 0 to msg_Close_Panel
105606>>>>>            Set Default_State To True
105607>>>>>            // In case someone likes to make the AboutDialog's Border_Style to thick,
105607>>>>>            // and changes its peAnchors, we might as well prepare this object
105607>>>>>            // for that situation.
105607>>>>>            Set peAnchors to anBottomRight
105608>>>>>        End_Object
105609>>>>>
105609>>>>>        Object oCopyButton is a cCopyEditorContentButton
105611>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
105612>>>>>            Set Size to 14 50
105613>>>>>            Set Location to 120 158
105614>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
105614>>>>>            // we might as well prepare the object for it.
105614>>>>>            Set peAnchors to anBottomRight
105615>>>>>            Set phoEditorHandle to (oSysinfoDisplay(Self))
105616>>>>>        End_Object
105617>>>>>
105617>>>>>        On_Key kCancel Send Close_Panel
105618>>>>>    End_Procedure
105619>>>>>
105619>>>>>    Procedure Page Integer iPageObject
105621>>>>>        Handle hMenu
105621>>>>>        Integer iPrevState
105621>>>>>
105621>>>>>        Forward Send Page iPageObject
105623>>>>>
105623>>>>>        // Ok, this seems to have been fixed in VDF 17.1!
105623>>>>>        //
105623>>>>>    End_Procedure
105624>>>>>
105624>>>>>End_Class
105625>>>>>
105625>>>>>Class cAboutEdit is an cRichEdit
105626>>>>>    Procedure Construct_Object
105628>>>>>        Forward Send Construct_Object
105630>>>>>
105630>>>>>        Set Size to 57 153
105631>>>>>        Set Location to 8 60
105632>>>>>
105632>>>>>        Set Read_Only_State to True
105633>>>>>        Set Skip_State to True
105634>>>>>        // Font size is calculated in "Twips", which are 1/1440 of an inch,
105634>>>>>        // or 1/20 of a printer's point.
105634>>>>>//        Set piFontSize    to (9 * 20)
105634>>>>>        Set piRightMargin to (0.1 * 1440)
105635>>>>>        Set Border_Style  to Border_None
105636>>>>>    End_Procedure
105637>>>>>
105637>>>>>    // Adds a line of text to the edit object
105637>>>>>    Procedure Add_Line String sVal
105639>>>>>        String sText
105639>>>>>        Address aAddress
105639>>>>>        Get paValue to aAddress
105640>>>>>        Move aAddress to sText
105641>>>>>        Move (sText + String(sVal)) to sVal
105642>>>>>        Move (AddressOf(sVal)) to aAddress
105643>>>>>        Set paValue to aAddress
105644>>>>>    End_Procedure
105645>>>>>
105645>>>>>    // Compared to Add_Line above, this adds an extra empty line after the passed value.
105645>>>>>    // Note that we use the paValue interface,
105645>>>>>    // because the object isn't paged yet when we add the
105645>>>>>    // values and the COM edit object needs to be paged
105645>>>>>    // for the "Set Value" interface to be used.
105645>>>>>    Procedure Add_LineLn String sVal
105647>>>>>        String sText
105647>>>>>        Address aAddress
105647>>>>>        Get paValue to aAddress
105648>>>>>        Move aAddress to sText
105649>>>>>        Move (sText + String(sVal) + Character(10) + Character(13)) to sVal
105650>>>>>        Move (AddressOf(sVal)) to aAddress
105651>>>>>        Set paValue to aAddress
105652>>>>>    End_Procedure
105653>>>>>
105653>>>>>    Procedure OnLinkClicked Integer iPositionStart Integer iPositionEnd
105655>>>>>        String sLinkText
105655>>>>>        Get TextRange iPositionStart iPositionEnd to sLinkText
105656>>>>>        Send Show_HomePage sLinkText
105657>>>>>    End_Procedure
105658>>>>>
105658>>>>>End_Class
105659>>>>>
105659>>>>>// Purpose:
105659>>>>>//
105659>>>>>// Ken Ross 12/17/96 5:16PM
105659>>>>>//
105659>>>>>Class AboutDialog is a ModalPanel
105660>>>>>    Procedure Construct_Object
105662>>>>>
105662>>>>>        Forward Send Construct_Object
105664>>>>>
105664>>>>>        Set Label to C_$About
105665>>>>>        Set Size to 96 230
105666>>>>>        Set Locate_Mode To CENTER_ON_PARENT
105667>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
105668>>>>>//        Set Sysmenu_Icon to True
105668>>>>>
105668>>>>>        Object oSysInfoDialog is a SysInfoDialog
105670>>>>>        End_Object
105671>>>>>
105671>>>>>        Object oBox is a Container3d
105673>>>>>            Set Border_Style to Border_Normal
105674>>>>>            Set Size to 70 220
105675>>>>>            Set Location to 4 5
105676>>>>>            Set Color to clWhite
105677>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
105677>>>>>            // we might as well prepare the object for it.
105677>>>>>            Set peAnchors to anAll
105678>>>>>
105678>>>>>            Object oAboutGraphic is a BitmapContainer
105680>>>>>                Set Border_Style To Border_None
105681>>>>>                Set Bitmap_Style to Bitmap_Center
105682>>>>>                Set Color to clWhite
105683>>>>>                Set Size to 45 50
105684>>>>>                Set Location to 0 3
105685>>>>>            End_Object
105686>>>>>
105686>>>>>            Object oPoweredByVDFGraphic is a cBitmapContainerVDFLink
105688>>>>>                Set Border_Style to Border_None
105689>>>>>                Set Bitmap_Style to Bitmap_Center
105690>>>>>                Set Color to clWhite
105691>>>>>                Set Size to 30 55 //28 50
105692>>>>>                Set Location to 44 3
105693>>>>>            End_Object
105694>>>>>
105694>>>>>            Object oInfoList_Editor is an cAboutEdit
105696>>>>>                // In case someone wants to set the AboutDialog's Border_Style to thick,
105696>>>>>                // we might as well prepare the object for it.
105696>>>>>                Set peAnchors to anAll
105697>>>>>            End_Object
105698>>>>>
105698>>>>>            // These objects are here for backwards compatability only.
105698>>>>>            // They are not used.
105698>>>>>            Object oProductName is a TextBox
105700>>>>>                Set Label To C_$ProductName
105701>>>>>                Set Size To 10 45
105702>>>>>                Set Location To 8 53
105703>>>>>                Set Visible_State to False
105704>>>>>                Set Focus_Mode to NonFocusable
105705>>>>>            End_Object
105706>>>>>
105706>>>>>            Object oVersion is a TextBox
105708>>>>>                Set Label To C_$Version
105709>>>>>                Set Size To 10 25
105710>>>>>                Set Location To 21 53
105711>>>>>                Set Visible_State to False
105712>>>>>                Set Focus_Mode to NonFocusable
105713>>>>>            End_Object
105714>>>>>
105714>>>>>            Object oCopyright is a TextBox
105716>>>>>                Set Label To C_$Copyright
105717>>>>>                Set Size To 10 31
105718>>>>>                Set Location To 34 53
105719>>>>>                Set Visible_State to False
105720>>>>>                Set Focus_Mode to NonFocusable
105721>>>>>            End_Object
105722>>>>>
105722>>>>>            Object oAuthor is a TextBox
105724>>>>>                Set Label To C_$Author
105725>>>>>                Set Size To 10 22
105726>>>>>                Set Location To 46 53
105727>>>>>                Set Visible_State to False
105728>>>>>                Set Focus_Mode to NonFocusable
105729>>>>>            End_Object
105730>>>>>
105730>>>>>        End_Object
105731>>>>>
105731>>>>>        Object oOKButton Is A Button
105733>>>>>            On_Item C_$Close Send Close_Panel
105734>>>>>            Set Location to 78 176
105735>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
105735>>>>>            // we might as well prepare the object for it.
105735>>>>>            Set peAnchors to anBottomRight
105736>>>>>        End_Object
105737>>>>>
105737>>>>>        Object oSysInfoButton Is A Button
105739>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
105740>>>>>            Set Location to 78 123
105741>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
105741>>>>>            // we might as well prepare the object for it.
105741>>>>>            Set peAnchors to anBottomRight
105742>>>>>        End_Object
105743>>>>>
105743>>>>>        Object oCopyButton is a cCopyEditorContentButton
105745>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
105746>>>>>            Set Size to 14 50
105747>>>>>            Set Location to 78 70
105748>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
105748>>>>>            // we might as well prepare the object for it.
105748>>>>>            Set peAnchors to anBottomRight
105749>>>>>            Set phoEditorHandle to (oInfoList_Editor(Self))
105750>>>>>        End_Object
105751>>>>>
105751>>>>>        On_Key Kcancel Send KeyAction of oOKButton
105752>>>>>        Set Logo    to "DacAbout.bmp"  // Square bitmaps of 80x80 work best
105753>>>>>//        Set LogoVDF to "PoweredByDataFlex.bmp"
105753>>>>>        Set LogoVDF to "PoweredByOrange.bmp"
105754>>>>>    End_Procedure
105755>>>>>
105755>>>>>    Procedure Page Integer iPageObject
105757>>>>>        Handle hMenu
105757>>>>>        Integer iPrevState
105757>>>>>
105757>>>>>        Forward Send Page iPageObject
105759>>>>>        // Due to a bug in the ModalPanel class, we need to set the icon here:
105759>>>>>//        Set Icon to "ActionAbout.ico"
105759>>>>>
105759>>>>>        // Shadow upper left corner menu items: (icon menu items)
105759>>>>>        Move (GetSystemMenu(Window_Handle(Self), False)) to hMenu
105760>>>>>        Move (EnableMenuItem(hMenu, SC_RESTORE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
105761>>>>>        // The "Move" menu command may come in handy to have.
105761>>>>>        // Move (EnableMenuItem(hMenu, SC_MOVE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
105761>>>>>        Move (EnableMenuItem(hMenu, SC_SIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
105762>>>>>        Move (EnableMenuItem(hMenu, SC_MINIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
105763>>>>>        Move (EnableMenuItem(hMenu, SC_MAXIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
105764>>>>>        // The "Close" menu command may be good to have.
105764>>>>>        // Move (EnableMenuItem(hMenu, SC_CLOSE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
105764>>>>>    End_Procedure
105765>>>>>
105765>>>>>    Procedure Set ProductName String sText
105767>>>>>        Set Value of oProductName to sText
105768>>>>>    End_Procedure
105769>>>>>
105769>>>>>    Procedure Set Copyright String sText
105771>>>>>        Set Value of oCopyright to sText
105772>>>>>    End_Procedure
105773>>>>>
105773>>>>>    Procedure Set Author String sText
105775>>>>>        Set Value of oAuthor to sText
105776>>>>>    End_Procedure
105777>>>>>
105777>>>>>    Procedure Set Version String sVersion
105779>>>>>        Handle hoVersionInfo
105779>>>>>        Boolean bIncluded
105779>>>>>        Integer iMajor iMinor iRelease iBuild
105779>>>>>        Date dCompileDate
105779>>>>>
105779>>>>>        If (sVersion = "") Begin
105781>>>>>            // This automatically shows the program version of the program, if available.
105781>>>>>            // It will be displayed as the second item in the edit object.
105781>>>>>            If (ghoApplication <> 0) Begin
105783>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
105784>>>>>                If (hoVersionInfo <> 0) Begin
105786>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
105787>>>>>                    If (bIncluded) Begin
105789>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
105790>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
105791>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
105792>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
105793>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sVersion
105794>>>>>                    End
105794>>>>>>
105794>>>>>                End
105794>>>>>>
105794>>>>>            End
105794>>>>>>
105794>>>>>        End
105794>>>>>>
105794>>>>>
105794>>>>>        // Display the compiled date as the next row in the edit object, after the program version.
105794>>>>>        Get GetCompileDate to dCompileDate
105795>>>>>        If (sVersion <> "") Begin
105797>>>>>            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(dCompileDate))
105798>>>>>        End
105798>>>>>>
105798>>>>>    End_Procedure
105799>>>>>
105799>>>>>    Function GetCompileDate Returns Date
105801>>>>>        Date dCompileDate
105801>>>>>        String sAppFilename sData sCompileDate
105801>>>>>        Integer iChannel iPos iDateFormat
105801>>>>>
105801>>>>>        // Get full path to the current running executable
105801>>>>>        Get GetApplicationFileName of ghoApplication to sAppFilename
105802>>>>>
105802>>>>>        //Read the current file  up to where the data we're interesting in is (this was hand calced and so could vary)
105802>>>>>        Get Seq_Open_Input_Channel ("binary:" * sAppFilename) to iChannel
105803>>>>>        Read_Block channel iChannel sData (8 * 1024)    // First 8K is .exe header skip it
105805>>>>>        Read_Block channel iChannel sData 75            // The compile information we're interested in
105807>>>>>        Send Seq_Close_Channel iChannel
105808>>>>>
105808>>>>>        // The data is padded with Character(0)s. Strip them out
105808>>>>>        Move (CString(sData)) to sData
105809>>>>>
105809>>>>>        // The compile date is after the first ", ", so string parsing is required
105809>>>>>        Move (Pos(", ", sData)) to iPos
105810>>>>>        Move (Mid(sData, 10, (iPos + 2) ))  to sCompileDate // In US format
105811>>>>>        // If the current date format is non US, we need to temporary
105811>>>>>        // change the format and then move the string to the date variable.
105811>>>>>        Get_Attribute DF_DATE_FORMAT        to iDateFormat
105814>>>>>        Set_Attribute DF_DATE_FORMAT        to DF_DATE_USA
105817>>>>>        Move (Date(sCompileDate))           to dCompileDate
105818>>>>>        Set_Attribute DF_DATE_FORMAT        to iDateFormat // Reset date format
105821>>>>>
105821>>>>>        Function_Return dCompileDate
105822>>>>>    End_Function
105823>>>>>
105823>>>>>    Procedure Add_LineLn String sValue
105825>>>>>        Send Add_LineLn of oInfoList_Editor sValue
105826>>>>>    End_Procedure
105827>>>>>
105827>>>>>    Procedure Add_Line String sValue
105829>>>>>        Send Add_Line of oInfoList_Editor sValue
105830>>>>>    End_Procedure
105831>>>>>
105831>>>>>    Procedure Set Logo string sLogo
105833>>>>>        // Square bitmaps of 80x80 work best
105833>>>>>        Set Bitmap of oAboutGraphic to sLogo
105834>>>>>    End_Procedure
105835>>>>>
105835>>>>>    Procedure Set LogoVDF String sLogo
105837>>>>>        Set Bitmap of oPoweredByVDFGraphic to sLogo
105838>>>>>    End_Procedure
105839>>>>>
105839>>>>>    Procedure Show_Sysinfo
105841>>>>>        Send Popup_Modal of oSysinfoDialog
105842>>>>>    End_Procedure
105843>>>>>
105843>>>>>    Procedure Show_HomePage String sWebpage
105845>>>>>        Handle hWnd hInstance
105845>>>>>        Get Window_Handle to hWnd
105846>>>>>        Move (ShellExecute(hWnd, "open", (Trim(sWebpage)), "", "", 1)) to hInstance
105847>>>>>    End_Procedure
105848>>>>>
105848>>>>>//    Procedure End_Construct_Object
105848>>>>>//        Handle hoVersionInfo
105848>>>>>//        Boolean bIncluded
105848>>>>>//        Integer iMajor iMinor iRelease iBuild
105848>>>>>//        String sLabel sVersion
105848>>>>>//
105848>>>>>//        If (sVersion = "") Begin
105848>>>>>//            // This automatically shows the program version of the program, if available.
105848>>>>>//            // It will be displayed as the last item in the edit object.
105848>>>>>//            If (ghoApplication <> 0) Begin
105848>>>>>//                Get phoVersionInfo of ghoApplication to hoVersionInfo
105848>>>>>//                If (hoVersionInfo <> 0) Begin
105848>>>>>//                    Get pbIncluded of hoVersionInfo to bIncluded
105848>>>>>//                    If (bIncluded) Begin
105848>>>>>//                        Get piVersionMajor of hoVersionInfo to iMajor
105848>>>>>//                        Get piVersionMinor of hoVersionInfo to iMinor
105848>>>>>//                        Get piVersionRelease of hoVersionInfo to iRelease
105848>>>>>//                        Get piVersionBuild of hoVersionInfo to iBuild
105848>>>>>//                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sLabel
105848>>>>>//                        Set Version to sLabel
105848>>>>>//                    End
105848>>>>>//                End
105848>>>>>//            End
105848>>>>>//        End
105848>>>>>//
105848>>>>>//        Forward Send End_Construct_Object
105848>>>>>//    End_Procedure
105848>>>>>
105848>>>>>End_Class
105849>>>
105849>>>// *************************************************************************
105849>>>//  Public message. This is the default message. It is expected that you will
105849>>>//   create your own message to override this
105849>>>// *************************************************************************
105849>>>
105849>>>Procedure Activate_About
105852>>>   Send DoAbout "" "" "" "" ""
105853>>>End_Procedure
105854>>>
105854>>>// *************************************************************************
105854>>>//  Public message. It is expected that you will send this message (most
105854>>>//  likely from Activate_About. This creates an about object, activates it
105854>>>//  and destroys it when done. It is not exepected that you will augment this.
105854>>>// *************************************************************************
105854>>>// Sample usage:
105854>>>//   The first two params will automatically be filled from the application settings if not provided.
105854>>>//   Send DoAbout "" "" ("Copyright: 2013" * psCompany(ghoApplication)) "Created by: Your Name" "YourAppBitmap.bmp" "Internet: http://www.YourWebAddress.com" "E-mail: mailto:support@YourEmailAddress.com" "Some other description of choice" "9th param" "and last param"
105854>>>
105854>>>Procedure DoAbout String sTitle String sVersion String sCopyRight String sAuthor String sBitmap ;                  String sParam6 String sParam7 String sParam8 String sParam9 String sParam10
105857>>>        Integer hoObj hoMain iArgs
105857>>>        String sValue
105857>>>
105857>>>        // Create object
105857>>>        Object About is an AboutDialog
105859>>>            // Uncomment these two lines if you would like to have a resizable About object.
105859>>>//            Set Border_Style to Border_Thick
105859>>>//            Set peAnchors to anAll
105859>>>
105859>>>            // Add checking for the number of arguments passed to avoid runtime errors
105859>>>            // if one of them is not passed. This makes the interface
105859>>>            // more flexible.
105859>>>            Move num_arguments to iArgs
105860>>>
105860>>>            // If no title is passed use the label of the main panel (if a main panel exists).
105860>>>            If (iArgs > 0 and sTitle = "") Begin
105862>>>                Get Main_Window of Desktop to hoMain
105863>>>                If hoMain Begin
105865>>>                    Get Label of hoMain to sValue
105866>>>                End
105866>>>>
105866>>>            End
105866>>>>
105866>>>            Else If (iArgs > 0 and sTitle <> "") Begin
105869>>>                Move sTitle to sValue
105870>>>            End
105870>>>>
105870>>>            Else If (iArgs = 0) Begin
105873>>>                Get Main_Window of Desktop to hoMain
105874>>>                If hoMain Begin
105876>>>                    Get Label of hoMain to sValue
105877>>>                End
105877>>>>
105877>>>            End
105877>>>>
105877>>>
105877>>>            If (sValue <> "") Begin
105879>>>                Send Add_LineLn sValue
105880>>>            End
105880>>>>
105880>>>            Move "" to sValue
105881>>>
105881>>>            // If the passed sVersion value is blank, the info will be retrieved from the cApplication object.
105881>>>            // For this to work the Project Properties Version must have been set in the Studio.
105881>>>            If (iArgs < 2) Begin
105883>>>                Move "" to sValue
105884>>>            End
105884>>>>
105884>>>            Else Begin
105885>>>                Move sVersion to sValue
105886>>>            End
105886>>>>
105886>>>            Set Version to sValue
105887>>>
105887>>>            If (iArgs > 2 and sCopyRight <> "") Begin
105889>>>                Send Add_LineLn sCopyRight
105890>>>            End
105890>>>>
105890>>>
105890>>>            // If only the five "standard" params were passed we don't add an extra linefeed;
105890>>>            // else we do.
105890>>>            If (iArgs > 3 and iArgs < 6 and sAuthor <> "") Begin
105892>>>                Send Add_Line sAuthor
105893>>>            End
105893>>>>
105893>>>            Else If (iArgs > 5 and sAuthor <> "") Begin
105896>>>                Send Add_LineLn sAuthor
105897>>>            End
105897>>>>
105897>>>
105897>>>            // Square bitmaps of 80x80 works best
105897>>>            If (iArgs > 4 and sBitmap <> "") Begin
105899>>>               Set Logo to sBitMap
105900>>>            End
105900>>>>
105900>>>
105900>>>            // Here starts handling of the five optional params:
105900>>>            If (iArgs = 6 and sParam6  <> "") Begin
105902>>>                Send Add_Line sParam6
105903>>>            End
105903>>>>
105903>>>            Else If (iArgs > 6 and sParam6  <> "") Begin
105906>>>                Send Add_LineLn sParam6
105907>>>            End
105907>>>>
105907>>>
105907>>>            If (iArgs = 7 and sParam7  <> "") Begin
105909>>>                Send Add_Line sParam7
105910>>>            End
105910>>>>
105910>>>            Else If (iArgs > 7 and sParam7  <> "") Begin
105913>>>                Send Add_LineLn sParam7
105914>>>            End
105914>>>>
105914>>>
105914>>>            If (iArgs = 8 and sParam8  <> "") Begin
105916>>>                Send Add_Line sParam8
105917>>>            End
105917>>>>
105917>>>            Else If (iArgs > 8 and sParam8  <> "") Begin
105920>>>                Send Add_LineLn sParam8
105921>>>            End
105921>>>>
105921>>>
105921>>>            If (iArgs = 9 and sParam9  <> "") Begin
105923>>>                Send Add_Line sParam9
105924>>>            End
105924>>>>
105924>>>            Else If (iArgs > 9 and sParam9  <> "") Begin
105927>>>                Send Add_LineLn sParam9
105928>>>            End
105928>>>>
105928>>>
105928>>>            If (iArgs = 10 and sParam10 <> "") Begin
105930>>>                Send Add_Line sParam10
105931>>>            End
105931>>>>
105931>>>
105931>>>            Move Self to hoObj
105932>>>        End_Object
105933>>>
105933>>>        Send Popup   of hoObj // Popup the about object
105934>>>        Send Destroy of hoObj // When done, it will be destroyed
105935>>>End_Procedure
105936>        Use CompareDatabases.rv
Including file: CompareDatabases.rv    (C:\Projects\DF18\DbUpdateFramework\AppSrc\CompareDatabases.rv)
105936>>>Use Windows.pkg
105936>>>Use DFRptVw.pkg
105936>>>Use DFRpt.pkg
105936>>>Use File_Dlg.Pkg
105936>>>Use CompareDatabases.img
Including file: CompareDatabases.img    (C:\Projects\DF18\DbUpdateFramework\AppSrc\CompareDatabases.img)
105936>>>>>// CompareDatabases Basic Report
105936>>>>>// Since report images, such as the one used here, are not fully supported by
105936>>>>>// the Studio, the images for this report are placed in a separate package.
105936>>>>>//
/HEADER
Image 2, HEADER
 ***  The Database Update Framework (DUF) DATABASE DIFFERENCES REPORT  ***
     
      Date & Time Printed       : ____________________
      FROM Database Filelist.cfg: ________________________________________________________________________________________________________________________
      TO   Database Filelist.cfg: ________________________________________________________________________________________________________________________
/Top
Image 3, TOP
                                                                           Page:___.
/SubHeader
Image 4, SUBHEADER
________ Difference(s) for Table: ____ - ______________________________    
====================================================================================
FROM Database:                                              TO Database:
------------------------------------------------------------------------
/BodyFields
Image 5, BODYFIELDS
Field Number:  ____                                         ____
Name:          ____________________________________________ ____________________________________________
Type:          ____________________________________________ ____________________________________________
Length:        ____                                         ____
Precision:     ____                                         ____
Identity Field:___                                          ___   
/Footer
Image 6, FOOTER
SUMMARY:
====================================================================================
Number of Tables with differences: ____
/*
105936>>>
105936>>>Activate_View Activate_oCompareDatabases for oCompareDatabases
105946>>>>
105946>>>Object oCompareDatabases is a ReportView
105948>>>    Set Location to 6 6
105949>>>    Set Size to 84 181
105950>>>    Set Label to "Compare Databases"
105951>>>
105951>>>    Property String psFilelistFrom
105953>>>    Property String psFilelistTo
105955>>>    Property Integer piDifferences
105957>>>
105957>>>    Object oDestination is a RadioGroup
105959>>>        Set Size to 59 171
105960>>>        Set Location to 5 5
105961>>>        Set Label to "Output Device:"
105962>>>
105962>>>        Object oScreen is a Radio
105964>>>            Set Label to "Screen"
105965>>>            Set Size to 10 39
105966>>>            Set Location to 15 10
105967>>>            Set Status_Help to "Preview the report to screen"
105968>>>        End_Object
105969>>>
105969>>>        Object oPrinter is a Radio
105971>>>            Set Label to "Printer"
105972>>>            Set Size to 10 37
105973>>>            Set Location to 30 10
105974>>>            Set Status_Help to "Send the report to the default printer"
105975>>>        End_Object
105976>>>
105976>>>        Object oFile is a Radio
105978>>>            Set Label to "File"
105979>>>            Set Size to 10 27
105980>>>            Set Location to 42 10
105981>>>            Set Status_Help to "Send the report to a file"
105982>>>        End_Object
105983>>>
105983>>>        Object oFileNameForm is a Form
105985>>>            Set Label to "FileName:"
105986>>>            Set Size to 13 116
105987>>>            Set Location to 40 50
105988>>>            Set Label_Col_Offset to 0
105989>>>            Set Label_Justification_Mode to jMode_Top
105990>>>            Set Prompt_Button_Mode to pb_PromptOn
105991>>>
105991>>>            Procedure Prompt
105994>>>                Boolean bOk
105994>>>                String sFileName sFilePath sDataPath
105994>>>                Integer hoWorkspace
105994>>>
105994>>>                Get Value To sFileName
105995>>>                If (sFileName <> "") Begin
105997>>>                    Set File_Name Of oSaveAsDialog to sFileName
105998>>>                    Get ExtractFilePath sFileName to sFilePath
105999>>>                End
105999>>>>
105999>>>                If (sFilePath = "") Begin
106001>>>                    Get phoWorkspace Of ghoApplication to hoWorkspace
106002>>>                    Get psDataPath Of hoWorkspace to sDataPath
106003>>>                    Get PathAtIndex Of hoWorkspace sDataPath 1 to sFilePath
106004>>>                End
106004>>>>
106004>>>
106004>>>                Set Initial_Folder Of oSaveAsDialog to sFilePath
106005>>>
106005>>>                Get Show_Dialog Of oSaveAsDialog to bOk
106006>>>                If (bOk) Begin
106008>>>                    Get File_Name Of oSaveAsDialog to sFileName
106009>>>                    Set Value To sFileName
106010>>>                End
106010>>>>
106010>>>            End_Procedure
106011>>>
106011>>>        End_Object
106012>>>
106012>>>        Procedure Notify_Select_State Integer iNewItem Integer iOldItem
106015>>>            Forward Send Notify_Select_State iNewItem iOldItem
106017>>>
106017>>>            Case Begin
106017>>>                Case (iNewItem = 0)
106019>>>                    Set Output_Device_Mode to PRINT_TO_WINDOW
106020>>>                    Case Break
106021>>>                Case (iNewItem = 1)
106024>>>                    Set Output_Device_Mode to PRINT_TO_PRINTER
106025>>>                    Case Break
106026>>>                Case (iNewItem = 2)
106029>>>                    Set Output_Device_Mode to PRINT_TO_FILE
106030>>>                    Case Break
106031>>>            Case End
106031>>>
106031>>>            Set Enabled_State Of oFileNameForm to (iNewItem = 2)
106032>>>        End_Procedure
106033>>>
106033>>>    End_Object
106034>>>
106034>>>    Object oOkButton is a Button
106036>>>        Set Label to "&OK"
106037>>>        Set Location to 66 71
106038>>>        Set Default_State to TRUE
106039>>>
106039>>>        Procedure OnClick
106042>>>            Send StartReport
106043>>>        End_Procedure
106044>>>
106044>>>    End_Object
106045>>>
106045>>>    Object oCancelButton is a Button
106047>>>        Set Label to "&Cancel"
106048>>>        Set Location to 66 126
106049>>>
106049>>>        Procedure OnClick
106052>>>            Send Request_Cancel
106053>>>        End_Procedure
106054>>>
106054>>>    End_Object
106055>>>
106055>>>    Object oSaveAsDialog is a SaveAsDialog
106057>>>    End_Object
106058>>>
106058>>>    Procedure StartReport
106061>>>        Integer iOutputDevice
106061>>>        Handle hoWorkspace
106061>>>        String sFileName sCurrentDirectory sDataPath
106061>>>
106061>>>        Get Output_Device_Mode to iOutputDevice
106062>>>
106062>>>        Case Begin
106062>>>            Case (iOutputDevice = PRINT_TO_WINDOW)
106064>>>                Get_Current_Directory to sCurrentDirectory
106065>>>                Get phoWorkspace Of ghoApplication to hoWorkspace
106066>>>                Get psDataPath Of hoWorkspace to sDataPath
106067>>>                Get PathAtIndex Of hoWorkspace sDataPath 1 to sDataPath
106068>>>                Set_Directory sDataPath
106069>>>                Make_Temp_File "TXT" sFileName
106070>>>                Set_Directory sCurrentDirectory
106071>>>                If (Right(sDataPath, 1) <> Sysconf(SYSCONF_DIR_SEPARATOR)) Begin
106073>>>                    Move (sDataPath - Sysconf(SYSCONF_DIR_SEPARATOR)) To sDataPath
106074>>>                End
106074>>>>
106074>>>                Move (sDataPath - sFileName) to sFileName
106075>>>                Set Output_Device_Name to sFileName
106076>>>                Case Break
106077>>>            Case (iOutputDevice = PRINT_TO_PRINTER)
106080>>>                Set Output_Device_Name to "WinLST:"
106081>>>                Case Break
106082>>>            Case (iOutputDevice = PRINT_TO_FILE)
106085>>>                Get Value Of oFileNameForm to sFileName
106086>>>                Set Output_Device_Name to sFileName
106087>>>                Case Break
106088>>>        Case End
106088>>>
106088>>>        Send Run_Report
106089>>>
106089>>>        If (iOutputDevice = PRINT_TO_WINDOW) Begin
106091>>>            //Runprogram Background "NotePad" sFileName
106091>>>            Runprogram Shell Background sFileName
106092>>>            EraseFile sFileName
106093>>>>
106093>>>        End
106093>>>>
106093>>>    End_Procedure
106094>>>
106094>>>    Object oBasicReport is a BasicReport
106096>>>
106096>>>        Function Starting_Main_Report Returns Integer
106099>>>            Integer iRetval
106099>>>
106099>>>            Forward Get Starting_Main_Report to iRetval
106101>>>
106101>>>            Function_Return iRetval
106102>>>        End_Function
106103>>>
106103>>>        Procedure_Section Report_Header as Header
106108>>>            DateTime dtCreationTime
106108>>>            String sFilelistFrom sFilelistTo
106108>>>
106108>>>            Get psFilelistFrom to sFilelistFrom
106109>>>            Get psFilelistTo   to sFilelistTo
106110>>>            Move (CurrentDateTime()) to dtCreationTime
106111>>>
106111>>>            Print sFilelistFrom
106112>>>            Print sFilelistTo
106113>>>            Print dtCreationTime
106114>>>            Output_PageCheck Header
106115>>>        End_Procedure
106116>>>
106116>>>        Procedure_Section Page_Top as Top
106121>>>            Integer iPage
106121>>>
106121>>>            Get Page_Count to iPage
106122>>>            Print iPage
106123>>>            OutPut_PageCheck
106124>>>        End_Procedure
106125>>>
106125>>>        Procedure_Section SubHeaderFields as SubHeader
106130>>>            Print "Field"
106131>>>            Print "Table#"
106132>>>            Print "Table Name"
106133>>>        End_Procedure
106134>>>
106134>>>        Procedure_Section Body as BodyFields
106139>>>            Forward Send Body
106141>>>            // Print File.Field // Gets printed at BodySection.1
106141>>>            // Print Variable // Gets printed at BodySection.2
106141>>>            // Output_PageCheck // Without this nothing gets printed
106141>>>        End_Procedure
106142>>>
106142>>>//        Procedure_Section Page_Bottom as FooterSection
106142>>>//            Forward Send Page_Bottom
106142>>>//            // Output_PageCheck // Without this nothing gets printed
106142>>>//        End_Procedure
106142>>>
106142>>>        Procedure_Section Total as Footer
106147>>>            Integer iDifferences
106147>>>            Get piDifferences to iDifferences
106148>>>            Print iDifferences
106149>>>        End_Procedure
106150>>>
106150>>>    End_Object
106151>>>
106151>>>    On_Key Key_Alt+Key_O Send KeyAction of oOkButton
106152>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancelButton
106153>>>
106153>>>End_Object
106154>        Procedure Activate_About
106157>            Send DoAbout "" "" ("Copyright 2016-2018" * psCompany(ghoApplication)) "Author: Nils Svedmyr" "DUFUpdateCodeGenerator.bmp" "E-mail: mailto:support@rdctools.com" "Web-site: www.rdctools.com"
106158>        End_Procedure
106159>
106159>        On_Key Key_Ctrl+Key_Tab           Send Switch_Next_View
106160>        On_Key Key_Ctrl+Key_Shift+Key_Tab Send Switch_Prior_View
106161>    End_Object
106162>
106162>    // Note that we have overriden the cHtmlHelp "GetHelpFile" function
106162>    // in the oHtmlHelp object, so we need to explitetly send the message
106162>    // to that object.
106162>    Procedure ShowProgramHelp
106165>        Send DoDisplayKeyword of oHtmlHelp "The Database Update Framework"
106166>    End_Procedure
106167>
106167>End_Object
106168>
106168>// Because we want to display the compare databases view first.
106168>Send Activate_oCompareDatabases_vw of (Client_Id(phoMainPanel(ghoApplication)))
106169>Start_UI
106170>
Including Resources...
Summary
Memory Available: 2147483646
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 56067
Total Resources: 4
Total Commands : 106169
Total Windows  : 21
Total Pages    : 6
Static Data    : 829701
Message area   : 676426
Total Blocks   : 37972
