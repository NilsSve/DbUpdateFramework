Compiling Program: C:\Projects\DF18\DbUpdateFramework\AppSrc\flx2sql.src
Memory Available: 2147483646
1>//==============================================================================
1>//           P R O G R A M   D O C U M E N T A T I O N
1>//==============================================================================
1>//
1>// Package Name: flx2sql.src
1>//
1>// Proof of concept to migrate embedded tables to a MS-SQL demonstrating the
1>// following:
1>//   - create a database
1>//   - API's structure_copy
1>//   - Driver's bluk copy command (CLI_BCP)
1>//
1>//==============================================================================
1>//           E D I T   H I S T O R Y
1>//==============================================================================
1>//
1>//Ref.  Date        Who Type    Defect No.
1>//      Comments
1>//
1>//[02]  20-Oct-16   apc Upd
1>//      Include changes from Raveen to help support DB2.
1>//
1>//[01]  12-Oct-16   apc Upd
1>//      Modified for DAPCON presentation.
1>//
1>//[00]  9-Dec-15    apc New     
1>//      Proof of concept.
1>//
1>
1>Use Windows.pkg
Using pre-compiled package WINDOWS.PKG
Including file: windows.pkd    (C:\Program Files (x86)\DataFlex 18.2\Pkg\windows.pkd)
7438>Use cApplication.pkg
Including file: cApplication.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cApplication.pkg)
7438>>>// cApplication.pkg
7438>>>// Author: SWB
7438>>>
7438>>>// Mar  1, 2002 SWB changed the order of the DoOpenWorkspace method to try to load the file from the path before looking in the Registered list
7438>>>// Mar 13, 2000 SWB changed the GetApplicationFileName method to use a safer method of retrieving the filename from the OS
7438>>>// Mar 13, 2000 SWB changed the default of psProgram to use Module_Name, as this works across chained-to programs
7438>>>
7438>>>Use Windows.pkg
7438>>>Use LanguageText.pkg
7438>>>Use WinUser.pkg
7438>>>Use WinShell.pkg
Including file: WinShell.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\WinShell.pkg)
7438>>>>>// Shell API functions
7438>>>>>Use Windows.pkg
7438>>>>>Use DLL.pkg
7438>>>>>
7438>>>>>External_Function PathFileExists "PathFileExistsA" shlwapi.dll ;    String sPath ;Returns Integer // Boolean
7439>>>>>
7439>>>>>External_Function PathIsRelative "PathIsRelativeA" shlwapi.dll ;    String sPath ;Returns Integer // Boolean
7440>>>>>
7440>>>>>External_Function PathRemoveExtension "PathRemoveExtensionA" shlwapi.dll ;    Address aPath ;Returns Integer // void
7441>>>>>
7441>>>>>External_Function PathRemoveFileSpec "PathRemoveFileSpecA" shlwapi.dll ;    Address aPath ;Returns Integer
7442>>>>>
7442>>>>>
7442>>>>>Define URL_UNESCAPE_INPLACE                    for |CI$00100000
7442>>>>>Define URL_ESCAPE_SEGMENT_ONLY                 for |CI$00002000
7442>>>>>
7442>>>>>External_Function UrlUnescape "UrlUnescapeA" shlwapi.dll;    Pointer pszURL;    Pointer pszUnescaped;    Pointer pcchUnescaped;    DWord dwFlags;Returns Integer // S_OK if succesfull
7443>>>>>
7443>>>>>External_Function UrlEscape "UrlEscapeA" shlwapi.dll;    Pointer pszUrl;    Pointer pszEscaped;    Pointer pcchEscaped;    DWord dwFlags;Returns Integer
7444>>>Use cWorkspace.pkg
Including file: cWorkspace.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cWorkspace.pkg)
7444>>>>>// cWorkspace.pkg
7444>>>>>// Author: SWB
7444>>>>>Use Windows.pkg
7444>>>>>Use LanguageText.pkg
7444>>>>>Use WinShell.pkg // Shell API functions
7444>>>>>Use seq_chnl.pkg
Including file: seq_chnl.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\seq_chnl.pkg)
7444>>>>>>>//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
7444>>>>>>>// Confidential Trade Secret.
7444>>>>>>>// Copyright 1987-1994 Data Access Corporation, Miami FL, USA
7444>>>>>>>// All Rights reserved
7444>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.
7444>>>>>>>//
7444>>>>>>>// Module:
7444>>>>>>>//      seq_chnl.pkg
7444>>>>>>>//
7444>>>>>>>// Purpose:
7444>>>>>>>//      Defines global sequential device management operations.
7444>>>>>>>//
7444>>>>>>>// Author:
7444>>>>>>>//      Lee Smith
7444>>>>>>>//
7444>>>>>>>// Date:
7444>>>>>>>//      11/2/94
7444>>>>>>>//
7444>>>>>>>//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
7444>>>>>>>// 12/13/2001 JJT: If channel not open, don't declare error during close
7444>>>>>>>//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
7444>>>>>>>Use LanguageText.pkg
7444>>>>>>>use VDFBase.pkg
Including file: errornum.inc    (C:\Program Files (x86)\DataFlex 18.2\Pkg\errornum.inc)
7444>>>>>>>>// DataFlex Source Code
7444>>>>>>>>// Copyright 1987-1992 Data Access Corporation, Miami FL, USA
7444>>>>>>>>// All Rights reserved
7444>>>>>>>>//
7444>>>>>>>>// JR 2/7/92
7444>>>>>>>>
7444>>>>>>>>
7444>>>>>>>>
7444>>>>>>>>//
7444>>>>>>>>// these will get defined in fmac
7444>>>>>>>>//
7444>>>>>>>>// already defined
7444>>>>>>>>//    #REPLACE DFERR_COMP_BAD_IMAGE_NAME                 |CI4293
7444>>>>>>>>//    #REPLACE DFERR_COMP_CONSTANT_EXPECTED              |CI4299
7444>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_RETURN_TYPE            |CI4310
7444>>>>>>>>//    #REPLACE DFERR_COMP_IMAGE_NOT_FOUND                |CI4311
7444>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_DATATYPE               |CI4315
7444>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_TYPE                   |CI4317
7444>>>>>>>>//    #REPLACE DFERR_COMP_MISSING_ARGUMENT               |CI4320
7444>>>>>>>>//    #REPLACE DFERR_COMP_MISSING_END_OBJECT             |CI4323
7444>>>>>>>>//    #REPLACE DFERR_COMP_UNDEFINED_SYMBOL_IN_ARGUMENT   |CI4328
7444>>>>>>>>//    #REPLACE DFERR_COMP_SYMBOL_ALREADY_DEFINED         |CI4332
7444>>>>>>>>//    #REPLACE DFERR_COMP_TOO_MANY_MESSAGES              |CI4339
7444>>>>>>>>//    #REPLACE DFERR_COMP_UNRESOVLED_CONTROL_BLOCK       |CI4348
7444>>>>>>>>// new compiler errors used by fmac
7444>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_OBJECT_DEFINTION       |CI4388 // object name used is not valid
7444>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_PROPERTY_DEFINTION     |CI4389 // property name cannot be used
7444>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_METHOD_DEFINTION       |CI4390 // method name cannot be used
7444>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_CODE_PLACEMENT         |CI4391 // Location of code, nesting, is wrong
7444>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_METHOD_SYNTAX          |CI4392 // syntax is incorrect for method definition
7444>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_MESSAGE_SYNTAX         |CI4393 // sysntax is incorrect for sending message
7444>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_OBJECT_REFERENCE       |CI4394 // object named in message is invalid
7444>>>>>>>>//    #REPLACE DFERR_COMP_OBSOLETE_UNSUPPORTED_FEATURE   |CI4395 // Obsolete - was 101 (Moveused by fmac)
7444>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_ARGUMENT               |CI4396 // Agument in line is incorrect
7444>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_EXTERNAL_FUNCTION_DEFINITION |CI4397 // name cannot be used
7444>>>>>>>>//    #REPLACE DFERR_COMP_MISSING_DEBUG_INFORMATION      |CI4500 // debug information is not provided
7444>>>>>>>>//    #REPLACE DFERR_COMP_INCOMPATIBLE_DEBUG_INFORMATION |CI4501 // debug inforamtion is is not correct
7444>>>>>>>>//    #REPLACE DFERR_COMP_RECURSIVE_STRUCT_DECLARATION   |CI4513 // recursive struct definition
7444>>>>>>>>//    #REPLACE DFERR_COMP_AMBIGUOUS_SYNTAX               |CI4514 // either Left of "'[' is not array, use '(' if indicator" or "Left of '.' is not of type struct or table" 
7444>>>>>>>>
7444>>>>>>>>
7444>>>>>>>
7444>>>>>>>define DF_SEQ_CHANNEL_NOT_AVAILABLE for -2
7444>>>>>>>define DF_SEQ_CHANNEL_ERROR         for -1
7444>>>>>>>define DF_SEQ_CHANNEL_MIN           for 0
7444>>>>>>>define DF_SEQ_CHANNEL_MAX           for 9
7444>>>>>>>define DF_SEQ_START_CHANNEL         for 2 // leave 0 and 1 til last
7444>>>>>>>                            // so that programs that use direct_input/output
7444>>>>>>>                            // w/o specifying a channel will work.
7444>>>>>>>enum_list
7444>>>>>>>    define DF_SEQ_CHANNEL_MODE_CLOSED
7444>>>>>>>    define DF_SEQ_CHANNEL_MODE_OPEN
7444>>>>>>>    define DF_SEQ_CHANNEL_MODE_OUTPUT
7444>>>>>>>    define DF_SEQ_CHANNEL_MODE_INPUT
7444>>>>>>>end_enum_list
7444>>>>>>>
7444>>>>>>>enum_list
7444>>>>>>>    define DF_SEQ_CHANNEL_ERROR_MODE_NONE
7444>>>>>>>    define DF_SEQ_CHANNEL_ERROR_MODE_ALL
7444>>>>>>>end_enum_list
7444>>>>>>>
7444>>>>>>>integer Seq$Channel$Error$Mode
7444>>>>>>>
7444>>>>>>>procedure set Seq_Channel_Error_Mode GLOBAL integer Mode
7446>>>>>>>    move Mode to Seq$Channel$Error$Mode
7447>>>>>>>end_procedure
7448>>>>>>>
7448>>>>>>>function Seq_Channel_Error_Mode GLOBAL returns integer
7450>>>>>>>    function_return Seq$Channel$Error$Mode
7451>>>>>>>end_procedure
7452>>>>>>>
7452>>>>>>>object Seq_Channel_List is an Array
7454>>>>>>>    procedure Initialize
7457>>>>>>>        integer Itm
7457>>>>>>>
7457>>>>>>>        move DF_SEQ_CHANNEL_MIN to Itm
7458>>>>>>>
7458>>>>>>>        while Itm LE DF_SEQ_CHANNEL_MAX
7462>>>>>>>            set Array_Value item Itm to DF_SEQ_CHANNEL_MODE_CLOSED
7463>>>>>>>            increment Itm
7464>>>>>>>        end
7465>>>>>>>>
7465>>>>>>>    end_procedure
7466>>>>>>>
7466>>>>>>>    send Initialize
7467>>>>>>>end_object
7468>>>>>>>
7468>>>>>>>set Seq_Channel_Error_Mode to DF_SEQ_CHANNEL_ERROR_MODE_ALL
7469>>>>>>>
7469>>>>>>>function Seq_Channel_Mode GLOBAL integer Chnl returns integer
7471>>>>>>>    function_return (Integer_Value(Seq_Channel_List(self), Chnl))
7472>>>>>>>end_function
7473>>>>>>>
7473>>>>>>>procedure set Seq_Channel_Mode GLOBAL integer Chnl integer Mode
7475>>>>>>>    set Array_Value of (Seq_Channel_List(self)) item Chnl to Mode
7476>>>>>>>end_procedure
7477>>>>>>>
7477>>>>>>>function Seq_New_Channel GLOBAL returns integer
7479>>>>>>>    integer Obj Chnl
7479>>>>>>>
7479>>>>>>>    move DF_SEQ_START_CHANNEL to Chnl
7480>>>>>>>
7480>>>>>>>    while Chnl LE DF_SEQ_CHANNEL_MAX
7484>>>>>>>        if (Seq_Channel_Mode(Chnl)) EQ DF_SEQ_CHANNEL_MODE_CLOSED begin
7486>>>>>>>            set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OPEN
7487>>>>>>>            function_return Chnl
7488>>>>>>>        end
7488>>>>>>>>
7488>>>>>>>
7488>>>>>>>        increment Chnl
7489>>>>>>>    end
7490>>>>>>>>
7490>>>>>>>
7490>>>>>>>    // wrap back to beginning
7490>>>>>>>    move 0 to Chnl
7491>>>>>>>
7491>>>>>>>    while Chnl LT DF_SEQ_START_CHANNEL
7495>>>>>>>        if (Seq_Channel_Mode(Chnl)) EQ DF_SEQ_CHANNEL_MODE_CLOSED begin
7497>>>>>>>            set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OPEN
7498>>>>>>>            function_return Chnl
7499>>>>>>>        end
7499>>>>>>>>
7499>>>>>>>
7499>>>>>>>        increment Chnl
7500>>>>>>>    end
7501>>>>>>>>
7501>>>>>>>
7501>>>>>>>    function_return DF_SEQ_CHANNEL_NOT_AVAILABLE
7502>>>>>>>end_procedure
7503>>>>>>>
7503>>>>>>>procedure Seq_Release_Channel GLOBAL integer Chnl
7505>>>>>>>    if ((Chnl >= DF_SEQ_CHANNEL_MIN) and (Chnl <= DF_SEQ_CHANNEL_MAX)) ;        set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_CLOSED
7508>>>>>>>end_procedure
7509>>>>>>>
7509>>>>>>>function Seq_Open_Input_Channel GLOBAL string Dvc returns integer
7511>>>>>>>    integer Chnl
7511>>>>>>>
7511>>>>>>>    get Seq_New_Channel to Chnl
7512>>>>>>>
7512>>>>>>>    if Chnl LE DF_SEQ_CHANNEL_ERROR begin
7514>>>>>>>        if (Seq_Channel_Error_Mode()) EQ DF_SEQ_CHANNEL_ERROR_MODE_ALL ;            error DFERR_CANT_OPEN_INPUT_FILE (Dvc + ":" *C_$NoOpenChannels)
7517>>>>>>>        function_return Chnl
7518>>>>>>>    end
7518>>>>>>>>
7518>>>>>>>
7518>>>>>>>    indicate Err FALSE
7519>>>>>>>    direct_input channel Chnl Dvc
7521>>>>>>>
7521>>>>>>>    [Err] begin
7523>>>>>>>>
7523>>>>>>>        send Seq_Release_Channel Chnl
7524>>>>>>>        function_return DF_SEQ_CHANNEL_ERROR
7525>>>>>>>    end
7525>>>>>>>>
7525>>>>>>>
7525>>>>>>>    set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_INPUT
7526>>>>>>>
7526>>>>>>>    function_return Chnl
7527>>>>>>>end_function
7528>>>>>>>
7528>>>>>>>function Seq_Open_Output_Channel GLOBAL string Dvc returns integer
7530>>>>>>>    integer Chnl
7530>>>>>>>
7530>>>>>>>    get Seq_New_Channel to Chnl
7531>>>>>>>
7531>>>>>>>    if Chnl LE DF_SEQ_CHANNEL_ERROR begin
7533>>>>>>>        if (Seq_Channel_Error_Mode()) EQ DF_SEQ_CHANNEL_ERROR_MODE_ALL begin
7535>>>>>>>            error DFERR_CANT_OPEN_OUTPUT_FILE (Dvc + ":" *C_$ChannelNotAvailable)
7536>>>>>>>>
7536>>>>>>>            move DF_SEQ_CHANNEL_ERROR to Chnl
7537>>>>>>>        end
7537>>>>>>>>
7537>>>>>>>
7537>>>>>>>        function_return Chnl
7538>>>>>>>    end
7538>>>>>>>>
7538>>>>>>>
7538>>>>>>>    indicate Err FALSE
7539>>>>>>>    direct_output channel Chnl Dvc
7541>>>>>>>
7541>>>>>>>    [Err] begin
7543>>>>>>>>
7543>>>>>>>        send Seq_Release_Channel Chnl
7544>>>>>>>        function_return DF_SEQ_CHANNEL_ERROR
7545>>>>>>>    end
7545>>>>>>>>
7545>>>>>>>
7545>>>>>>>    set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OUTPUT
7546>>>>>>>
7546>>>>>>>    function_return Chnl
7547>>>>>>>end_function
7548>>>>>>>
7548>>>>>>>function Seq_Append_Output_Channel GLOBAL string Dvc returns integer
7550>>>>>>>    integer Chnl
7550>>>>>>>
7550>>>>>>>    get Seq_New_Channel to Chnl
7551>>>>>>>
7551>>>>>>>    if Chnl LE DF_SEQ_CHANNEL_ERROR begin
7553>>>>>>>        if (Seq_Channel_Error_Mode()) EQ DF_SEQ_CHANNEL_ERROR_MODE_ALL begin
7555>>>>>>>            error DFERR_CANT_OPEN_OUTPUT_FILE (Dvc + ":" *C_$ChannelNotAvailable)
7556>>>>>>>>
7556>>>>>>>            move DF_SEQ_CHANNEL_ERROR to Chnl
7557>>>>>>>        end
7557>>>>>>>>
7557>>>>>>>
7557>>>>>>>        function_return Chnl
7558>>>>>>>    end
7558>>>>>>>>
7558>>>>>>>
7558>>>>>>>    indicate Err FALSE
7559>>>>>>>    append_output channel Chnl Dvc
7561>>>>>>>
7561>>>>>>>    [Err] begin
7563>>>>>>>>
7563>>>>>>>        send Seq_Release_Channel Chnl
7564>>>>>>>        function_return DF_SEQ_CHANNEL_ERROR
7565>>>>>>>    end
7565>>>>>>>>
7565>>>>>>>
7565>>>>>>>    set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OUTPUT
7566>>>>>>>
7566>>>>>>>    function_return Chnl
7567>>>>>>>end_function
7568>>>>>>>
7568>>>>>>>procedure Seq_Close_Channel GLOBAL integer Chnl
7570>>>>>>>    integer Mode
7570>>>>>>>
7570>>>>>>>    if ((Chnl >= DF_SEQ_CHANNEL_MIN) and (Chnl <= DF_SEQ_CHANNEL_MAX)) begin
7572>>>>>>>        get Seq_Channel_Mode Chnl to Mode
7573>>>>>>>
7573>>>>>>>        if Mode EQ DF_SEQ_CHANNEL_MODE_OUTPUT ;            close_output channel Chnl
7577>>>>>>>        else if Mode EQ DF_SEQ_CHANNEL_MODE_INPUT ;            close_input channel Chnl
7582>>>>>>>        // 12/13/2001 - If channel not open, release it! No (fatal) Error.
7582>>>>>>>        //else begin
7582>>>>>>>        //    Error DFERR_FILE_NOT_OPEN ("Channel: " + string(Chnl))
7582>>>>>>>        //    procedure_return
7582>>>>>>>        //end
7582>>>>>>>
7582>>>>>>>        send Seq_Release_Channel Chnl
7583>>>>>>>    end
7583>>>>>>>>
7583>>>>>>>end_procedure
7584>>>>>
7584>>>>>Register_Function IsRegistered String sWorkspace Returns Boolean
7584>>>>>Register_Function VdfSystemDfPath   Returns String
7584>>>>>Register_Function VdfSystemMakePath Returns String
7584>>>>>
7584>>>>>Enum_List
7584>>>>>    Define wsWorkspaceOpened       // WS opened ok
7584>>>>>    Define wsWorkspaceNotFound     // the named WS was not found in the global list
7584>>>>>    Define wsWorkspaceFileNotFound // the WS file was not found
7584>>>>>    Define wsDataPathEmpty         // the DataPath entry was empty
7584>>>>>    Define wsFileListEmpty         // The FileList entry was empty
7584>>>>>    Define wsFileListNotExist      // The FileList.cfg file could not be found
7584>>>>>End_Enum_List
7584>>>>>
7584>>>>>
7584>>>>>Define INVALID_HANDLE_VALUE for -1
7584>>>>>DEFINE MAX_PATH For 260   // Symbol for maximum length of a path
7584>>>>>
7584>>>>>Type tWin32FindData
7584>>>>>    Field tWin32FindData.dwFileAttributes                as Dword
7584>>>>>    Field tWin32FindData.ftCreationTime.dwLowDateTime    as Dword
7584>>>>>    Field tWin32FindData.ftCreationTime.dwHighDateTime   as Dword
7584>>>>>    Field tWin32FindData.ftLastAccessTime.dwLowDateTime  as Dword
7584>>>>>    Field tWin32FindData.ftLastAccessTime.dwHighDateTime as Dword
7584>>>>>    Field tWin32FindData.ftLastWriteTime.dwLowDateTime   as Dword
7584>>>>>    Field tWin32FindData.ftLastWriteTime.dwHighDateTime  as Dword
7584>>>>>    Field tWin32FindData.nFileSizeHigh                   as Dword
7584>>>>>    Field tWin32FindData.nFileSizeLow                    as Dword
7584>>>>>    Field tWin32FindData.dwReserved0                     as Dword
7584>>>>>    Field tWin32FindData.dwReserved1                     as Dword
7584>>>>>    Field tWin32FindData.cFileName                       as Char MAX_PATH
7584>>>>>    Field tWin32FindData.cAlternateFileName              as Char 14
7584>>>>>End_Type
7584>>>>>
7584>>>>>External_Function winFindFirstFile "FindFirstFileA" Kernel32.dll ;    String sFileSpec Pointer lpsWin32FindData Returns Handle
7585>>>>>
7585>>>>>External_Function winFindNextFile "FindNextFileA" Kernel32.dll ;    Handle hFindFile Pointer lpsWin32FindData Returns Handle
7586>>>>>
7586>>>>>External_Function winFindClose "FindClose" Kernel32.dll ;    Handle hOpenFile Returns Integer
7587>>>>>
7587>>>>>Function DoesFileExist GLOBAL String sFilename Returns Boolean
7589>>>>>        String sWin32FindData sMask
7589>>>>>        Pointer lpsWin32FindData
7589>>>>>        Integer iVoid
7589>>>>>        Handle hFileFind
7589>>>>>
7589>>>>>        ZeroType tWin32FindData To sWin32FindData
7590>>>>>        GetAddress of sWin32FindData To lpsWin32FindData
7591>>>>>        Move (winFindFirstFile(ToAnsi(sFilename), lpsWin32FindData)) To hFileFind   // JVH 8.3.8.0 must pass Ansi filename
7592>>>>>        If (hFileFind <> INVALID_HANDLE_VALUE) Begin
7594>>>>>            Move (winFindClose(hFileFind)) To iVoid
7595>>>>>        End
7595>>>>>>
7595>>>>>
7595>>>>>    Function_Return (hFileFind <> INVALID_HANDLE_VALUE)
7596>>>>>End_Function
7597>>>>>
7597>>>>>
7597>>>>>Use cIniFile.pkg
Including file: cIniFile.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cIniFile.pkg)
7597>>>>>>>// cIniFile.pkg
7597>>>>>>>// Author: SWB
7597>>>>>>>Use LanguageText.pkg
7597>>>>>>>Use windows.pkg
7597>>>>>>>
7597>>>>>>>// it is important that psFileName is defined. If blank, the registry may be accessed. We will check all WritePrivateProfileString
7597>>>>>>>// and GetPrivateProfileString to make sure that a file is defined.
7597>>>>>>>External_Function WritePrivateProfileString "WritePrivateProfileStringA" Kernel32.dll ;    String sSection String sKeyName String sValue String sFileName Returns Integer
7598>>>>>>>
7598>>>>>>>External_Function GetPrivateProfileString "GetPrivateProfileStringA" Kernel32.dll ;    Address aSection Address aKeyName Address aDefault Pointer lpsValue Integer nSize String sFileName Returns Integer
7599>>>>>>>
7599>>>>>>>Class cIniFile is a cObject
7600>>>>>>>    Procedure Construct_Object
7602>>>>>>>        Forward Send Construct_Object
7604>>>>>>>
7604>>>>>>>        Property String psFileName
7605>>>>>>>    End_Procedure
7606>>>>>>>
7606>>>>>>>    Procedure WriteString String sSection String sKey String sValue
7608>>>>>>>        Boolean bSuccess
7608>>>>>>>
7608>>>>>>>        //Showln "WriteString "
7608>>>>>>>        //Showln sSection ' - ' sKey ' - ' (psFileName(self))
7608>>>>>>>        //Showln sSection ' - ' sKey ' - ' (ToAnsi(psFileName(self)))
7608>>>>>>>        If (trim(psFileName(self))="") Begin
7610>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
7611>>>>>>>>
7611>>>>>>>            Procedure_return
7612>>>>>>>        end
7612>>>>>>>>
7612>>>>>>>        Move (WritePrivateProfileString(ToAnsi(sSection), ToAnsi(sKey), ToAnsi(sValue), ToAnsi(psFilename(self)))) To bSuccess
7613>>>>>>>        If (bSuccess = False) Error DFERR_INI_FILE C_$CannotWriteToTheIniFile
7616>>>>>>>    End_Procedure
7617>>>>>>>
7617>>>>>>>    Function ReadString String sSection String sKey String sDefault Returns String
7619>>>>>>>        Integer iNumChars iSizeValue
7619>>>>>>>        Pointer lpsValue
7619>>>>>>>        String sValue
7619>>>>>>>
7619>>>>>>>        Move (ToAnsi(sSection)) To sSection
7620>>>>>>>        Move (ToAnsi(sKey))     To sKey
7621>>>>>>>        Move (ToAnsi(sDefault)) To sDefault
7622>>>>>>>
7622>>>>>>>        Move 2047 to iSizeValue
7623>>>>>>>
7623>>>>>>>        Pad " " To sValue iSizeValue
7625>>>>>>>>
7625>>>>>>>        GetAddress of sValue to lpsValue
7626>>>>>>>
7626>>>>>>>        If (trim(psFileName(self))="") Begin
7628>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
7629>>>>>>>>
7629>>>>>>>            Function_return ''
7630>>>>>>>        end
7630>>>>>>>>
7630>>>>>>>        Move (GetPrivateProfileString(AddressOf(sSection), AddressOf(sKey), AddressOf(sDefault), lpsValue, iSizeValue, ToAnsi(psFilename(self)))) To iNumChars
7631>>>>>>>        Function_Return  (ToOem(CString(sValue)))
7632>>>>>>>    End_Function
7633>>>>>>>
7633>>>>>>>    Function SectionExists String sSection Returns Boolean
7635>>>>>>>        // A section exists only if it has at least one Key. A section with no keys is said not to exist
7635>>>>>>>        Handle hoKeys
7635>>>>>>>        Integer icKey iKey
7635>>>>>>>
7635>>>>>>>        Get Create U_ARRAY To hoKeys
7636>>>>>>>        Send ReadSection sSection hoKeys
7637>>>>>>>        Get Item_Count of hoKeys To icKey
7638>>>>>>>        Send Destroy of hoKeys
7639>>>>>>>
7639>>>>>>>        Function_Return (icKey >0)
7640>>>>>>>    End_Function
7641>>>>>>>
7641>>>>>>>    Procedure ReadSection String sSection Handle hoArray
7643>>>>>>>        Integer iNumChars iSizeValue iPos
7643>>>>>>>        Pointer lpsKeys
7643>>>>>>>        String sKeys sKey
7643>>>>>>>
7643>>>>>>>        Move 16384 to iSizeValue
7644>>>>>>>        Move (Repeat(character(0),  iSizeValue)) To sKeys
7645>>>>>>>
7645>>>>>>>        GetAddress of sKeys to lpsKeys
7646>>>>>>>
7646>>>>>>>        Move (ToAnsi(sSection)) To sSection
7647>>>>>>>
7647>>>>>>>        If (trim(psFileName(self))="") Begin
7649>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
7650>>>>>>>>
7650>>>>>>>            Procedure_return
7651>>>>>>>        end
7651>>>>>>>>
7651>>>>>>>        Move (GetPrivateProfileString(AddressOf(sSection), 0, 0, lpsKeys, Length(sKeys), ToAnsi(psFilename(self)))) To iNumChars
7652>>>>>>>        If (iNumChars >0) Begin
7654>>>>>>>            Repeat
7654>>>>>>>>
7654>>>>>>>                Pos (Character(0)) in sKeys To iPos
7656>>>>>>>>
7656>>>>>>>                If (iPos >1) Begin
7658>>>>>>>                    Left sKeys To sKey (iPos -1)
7660>>>>>>>>
7660>>>>>>>                    Right sKeys To sKeys (Length(sKeys) - iPos)
7662>>>>>>>>
7662>>>>>>>                    Set Value of hoArray (Item_Count(hoArray)) To (ToOem(sKey))
7663>>>>>>>                End
7663>>>>>>>>
7663>>>>>>>            Until (iPos <=1)
7665>>>>>>>        End
7665>>>>>>>>
7665>>>>>>>    End_Procedure
7666>>>>>>>
7666>>>>>>>    Procedure ReadSections Handle hoArray
7668>>>>>>>        Integer iNumChars iSizeValue iPos
7668>>>>>>>        Pointer lpsSections
7668>>>>>>>        String sSections sSection
7668>>>>>>>
7668>>>>>>>        Move 16384 to iSizeValue
7669>>>>>>>
7669>>>>>>>        Move (Repeat(character(0),  iSizeValue)) To sSections
7670>>>>>>>        GetAddress of sSections to lpsSections
7671>>>>>>>
7671>>>>>>>        If (trim(psFileName(self))="") Begin
7673>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
7674>>>>>>>>
7674>>>>>>>            Procedure_return
7675>>>>>>>        end
7675>>>>>>>>
7675>>>>>>>        Move (GetPrivateProfileString(0, 0, 0, lpsSections, Length(sSections), ToAnsi(psFilename(self)))) To iNumChars
7676>>>>>>>        If (iNumChars >0) Begin
7678>>>>>>>            Repeat
7678>>>>>>>>
7678>>>>>>>                Pos (Character(0)) in sSections To iPos
7680>>>>>>>>
7680>>>>>>>                If (iPos >1) Begin
7682>>>>>>>                    Left sSections To sSection (iPos -1)
7684>>>>>>>>
7684>>>>>>>                    Right sSections To sSections (Length(sSections) - iPos)
7686>>>>>>>>
7686>>>>>>>                    Set Value of hoArray (Item_Count(hoArray)) To (ToOem(sSection))
7687>>>>>>>                End
7687>>>>>>>>
7687>>>>>>>            Until (iPos <=1)
7689>>>>>>>        End
7689>>>>>>>>
7689>>>>>>>
7689>>>>>>>    End_Procedure
7690>>>>>>>
7690>>>>>>>    Procedure DeleteSection String sSection
7692>>>>>>>        //Showln "delete section:"
7692>>>>>>>        //Showln sSection ' - ' (psFileName(self))
7692>>>>>>>        //Showln sSection ' - ' (ToAnsi(psFileName(self)))
7692>>>>>>>
7692>>>>>>>        If (trim(psFileName(self))="") Begin
7694>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
7695>>>>>>>>
7695>>>>>>>            Procedure_return
7696>>>>>>>        end
7696>>>>>>>>
7696>>>>>>>        If (WritePrivateProfileString(ToAnsi(sSection), "", "", ToAnsi(psFilename(self))) = 0) Error DFERR_INI_FILE C_$CanNotDeleteSection
7699>>>>>>>    End_Procedure
7700>>>>>>>
7700>>>>>>>    Procedure DeleteKey String sSection String sKey
7702>>>>>>>        Integer iVoid
7702>>>>>>>        //Showln "delete key:"
7702>>>>>>>        //Showln sSection ' - ' sKey ' - ' (psFileName(self))
7702>>>>>>>        //Showln sSection ' - ' skey ' - ' (ToAnsi(psFileName(self)))
7702>>>>>>>        If (trim(psFileName(self))="") Begin
7704>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
7705>>>>>>>>
7705>>>>>>>            Procedure_return
7706>>>>>>>        end
7706>>>>>>>>
7706>>>>>>>        Move (WritePrivateProfileString(ToAnsi(sSection), ToAnsi(sKey), "", ToAnsi(psFilename(self)))) To iVoid
7707>>>>>>>        //Move (WritePrivateProfileString(ToAnsi(sSection), ToAnsi(sKey), "", psFilename(self))) To iVoid
7707>>>>>>>    End_Procedure
7708>>>>>>>
7708>>>>>>>    Function KeyExists String sSection String sKey Returns Boolean
7710>>>>>>>        Handle hoKeys
7710>>>>>>>        Integer iKey
7710>>>>>>>        Boolean bExists
7710>>>>>>>
7710>>>>>>>        Move (False) To bExists
7711>>>>>>>
7711>>>>>>>        Move (ToAnsi(Uppercase(sKey))) To sKey
7712>>>>>>>
7712>>>>>>>        Get Create U_ARRAY To hoKeys
7713>>>>>>>
7713>>>>>>>        Send ReadSection sSection hoKeys
7714>>>>>>>        For iKey from 0 To (Item_Count(hoKeys) -1)
7720>>>>>>>>
7720>>>>>>>            If (sKey = Uppercase(Value(hoKeys, iKey))) Begin
7722>>>>>>>                Move (True) To bExists
7723>>>>>>>            End
7723>>>>>>>>
7723>>>>>>>        Loop
7724>>>>>>>>
7724>>>>>>>
7724>>>>>>>        Send Destroy of hoKeys
7725>>>>>>>
7725>>>>>>>        Function_Return bExists
7726>>>>>>>    End_Function
7727>>>>>>>
7727>>>>>>>End_Class
7728>>>>>
7728>>>>>Class cWorkspace is a cObject
7729>>>>>
7729>>>>>    Procedure Construct_Object
7731>>>>>        Forward Send Construct_Object
7733>>>>>
7733>>>>>
7733>>>>>        Property String psAppSrcPath
7734>>>>>        Property String psBitmapPath
7735>>>>>        Property String psDataPath
7736>>>>>        Property String psDdSrcPath
7737>>>>>        Property String psDescription
7738>>>>>        Property String psFileList
7739>>>>>        Property String psHelpPath
7740>>>>>        Property String psHome
7741>>>>>        Property String psIdeSrcPath
7742>>>>>        Property String psProgramPath
7743>>>>>        Property String psAppHtmlPath
7744>>>>>        Property String psWorkspaceName
7745>>>>>        Property String psWorkspaceWSFile
7746>>>>>
7746>>>>>        Property String psSystemDfPath // took from the Registry!
7747>>>>>        Property String psSystemMakePath // took from the Registry!
7748>>>>>        Property String psDfPath        // Calculated
7749>>>>>
7749>>>>>        Property Boolean pbWorkspaceOpened False // used internally to tell if we are switching workspaces
7750>>>>>
7750>>>>>    End_Procedure
7751>>>>>
7751>>>>>    Function FullPathNames String sShortPathNames Returns String
7753>>>>>        String sFileName
7753>>>>>        String sFullPathNames sFullPathName sShortPathName
7753>>>>>        Pointer lpsFullPathName
7753>>>>>        Pointer lpsFilePart
7753>>>>>        Integer icChar // the number of characters returned
7753>>>>>        Integer iPos
7753>>>>>
7753>>>>>        Move (Pos(";", sShortPathNames)) To iPos
7754>>>>>        While (length(sShortPathNames) >0)
7758>>>>>            If (iPos =0) Begin
7760>>>>>                Move sShortPathNames To sShortPathName
7761>>>>>                Move "" To sShortPathNames
7762>>>>>            End
7762>>>>>>
7762>>>>>            Else Begin // multiple paths
7763>>>>>                Move (Left(sShortPathNames, iPos -1)) To sShortPathName
7764>>>>>                Move (Right(sShortPathNames, length(sShortPathNames) -iPos)) To sShortPathNames // remove this path from the paths
7765>>>>>            End
7765>>>>>>
7765>>>>>            Move (Repeat(character(0), 4096)) To sFullPathName
7766>>>>>            GetAddress of sFullPathName to lpsFullPathName
7767>>>>>            move -1 to lpsFilePart
7768>>>>>            Move (GetFullPathName(sShortPathName, 4096, lpsFullPathName, AddressOf(lpsFilePart))) To icChar
7769>>>>>            Append sFullPathNames (CString(sFullPathName))
7770>>>>>            If (sShortPathNames <>"") Append sFullPathNames ";"
7773>>>>>            Move (Pos(";", sShortPathNames)) To iPos
7774>>>>>        Loop
7775>>>>>>
7775>>>>>
7775>>>>>        Function_Return sFullPathNames
7776>>>>>    End_Function
7777>>>>>
7777>>>>>    Function GetApplicationPath Returns String
7779>>>>>        // Returns the path of the Application (no trailing "\")
7779>>>>>        String sApplicationFileName sPath
7779>>>>>        Boolean bRemoved
7779>>>>>        Integer iNumChars
7779>>>>>        String sFilename
7779>>>>>
7779>>>>>        Move (Repeat(Character(0), 1024)) to sApplicationFileName
7780>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
7781>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
7782>>>>>
7782>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to bRemoved
7783>>>>>        Move (CString(sApplicationFileName)) to sPath
7784>>>>>
7784>>>>>        If (Right(sPath, 1) ="\") Move (Left(sPath, Length(sPath) -1)) to sPath
7787>>>>>        Function_Return sPath
7788>>>>>    End_Function
7789>>>>>
7789>>>>>    Procedure DoClearPaths
7791>>>>>        // Call this prior to changing from one WorkspAce to another
7791>>>>>        // if you don't, OpenWorkspaceFile will ignore the new paths.
7791>>>>>        Set psHome           To ""
7792>>>>>        Set psAppSrcPath     To ""
7793>>>>>        Set psBitmapPath     To ""
7794>>>>>        Set psDataPath       To ""
7795>>>>>        Set psDdSrcPath      To ""
7796>>>>>        Set psDescription    To ""
7797>>>>>        Set psFileList       To ""
7798>>>>>        Set psHelpPath       To ""
7799>>>>>        Set psIdeSrcPath     To ""
7800>>>>>        Set psAppHtmlPath    To ""
7801>>>>>        Set psProgramPath    To ""
7802>>>>>        Set psWorkspaceName  To ""
7803>>>>>        Set psSystemDfPath   To ""
7804>>>>>        Set psSystemMakePath To ""
7805>>>>>        Set psWorkspaceWSFile to ""
7806>>>>>    End_Procedure
7807>>>>>
7807>>>>>    Function OpenWorkspaceFile String sWorkspaceFile Returns Integer
7809>>>>>        String sApplicationStartPath
7809>>>>>        String sWsName // name of Workspace is inferred from the Workspacefile name
7809>>>>>        Pointer lpsApplicationStartPath
7809>>>>>        Boolean bRemoved
7809>>>>>        Handle hoIniFile
7809>>>>>        Boolean bSuccess // call succeeded?
7809>>>>>        String sOldDirectory
7809>>>>>        String sSystemDfPath sSystemMakePath
7809>>>>>        Boolean bExist // does the WS file exist?
7809>>>>>        Boolean bChangingWorkspace
7809>>>>>
7809>>>>>        String sHome sAppSrcPath sBitmapPath sDataPath sDdSrcPath sDescription sAppHtmlPath
7809>>>>>        String sFileList sHelpPath sIdeSrcPath sProgramPath sWorkspaceName
7809>>>>>        
7809>>>>>        Set psWorkspaceWSFile to ""
7810>>>>>        If (sWorkspaceFile ="") Function_Return wsWorkspaceFileNotFound
7813>>>>>
7813>>>>>        // Append extension if not supplied...
7813>>>>>        If (Uppercase(Right(Trim(sWorkspaceFile),3)) <> ".WS") Begin
7815>>>>>            Move (sWorkspaceFile-".ws") To sWorkspaceFile
7816>>>>>        End
7816>>>>>>
7816>>>>>
7816>>>>>        Get pbWorkspaceOpened To bChangingWorkspace // if we had an existing workspace. We are changing
7817>>>>>
7817>>>>>        If (IsFilenameQualified(sWorkspaceFile) = False) Begin
7819>>>>>            // Set the properties to the paths of the Workspace
7819>>>>>            // Find the WS file (with program)...
7819>>>>>            Get GetApplicationPath to sApplicationStartPath
7820>>>>>
7820>>>>>            Move sWorkspaceFile To sWsName
7821>>>>>            Move (sApplicationStartPath +"\" +sWorkspaceFile) To sWorkspaceFile
7822>>>>>        End
7822>>>>>>
7822>>>>>        Else Begin
7823>>>>>            Move (ExtractFileName(sWorkspaceFile)) To sWsName
7824>>>>>
7824>>>>>            Move sWorkspaceFile To sApplicationStartPath
7825>>>>>            GetAddress of sApplicationStartPath To lpsApplicationStartPath
7826>>>>>            Move (PathRemoveFileSpec(lpsApplicationStartPath)) To bRemoved
7827>>>>>        End
7827>>>>>>
7827>>>>>
7827>>>>>        // Ensure that the file can be found...
7827>>>>>        //File_Exist (ToAnsi(sWorkspaceFile)) bExist        // [JVH] 8.3.8.0 Convert filename to Ansi
7827>>>>>        // [JVH] 8.3.8.0 - Temporarily turn off support for
7827>>>>>        // Ansi extended characters in workspace until we can
7827>>>>>        // resolve all open issues..........................
7827>>>>>        Set psWorkspaceWSFile to sWorkspaceFile
7828>>>>>        File_Exist sWorkspaceFile bExist
7829>>>>>        If (bExist = False) Function_Return wsWorkspaceFileNotFound
7832>>>>>
7832>>>>>        Get psHome           To sHome
7833>>>>>        Get psAppSrcPath     To sAppSrcPath
7834>>>>>        Get psAppHtmlPath    To sAppHtmlPath
7835>>>>>        Get psBitmapPath     To sBitmapPath
7836>>>>>        Get psDataPath       To sDataPath
7837>>>>>        Get psDdSrcPath      To sDdSrcPath
7838>>>>>        Get psDescription    To sDescription
7839>>>>>        Get psFileList       To sFileList
7840>>>>>        Get psHelpPath       To sHelpPath
7841>>>>>        Get psIdeSrcPath     To sIdeSrcPath
7842>>>>>        Get psProgramPath    To sProgramPath
7843>>>>>        Get psSystemDfPath   To sSystemDfPath
7844>>>>>        Get psSystemMakePath To sSystemMakePath
7845>>>>>        Get psWorkspaceName  To sWorkspaceName
7846>>>>>
7846>>>>>        Get_Current_Directory To sOldDirectory
7847>>>>>        // Note- this conversion is temporarily rolled back
7847>>>>>        //Move (SetCurrentDirectory(ToAnsi(CString(sApplicationStartPath)))) To bSuccess    // [JVH] 8.3.8.0 Convert AppStartPath to ANSI
7847>>>>>        Move (SetCurrentDirectory(CString(sApplicationStartPath))) To bSuccess
7848>>>>>
7848>>>>>        Get Create U_cIniFile To hoIniFile
7849>>>>>        Set psFilename of hoIniFile To sWorkspaceFile
7850>>>>>
7850>>>>>        If (sHome ="")          Get ReadString of hoIniFile "Workspace" "Home" ""          To sHome
7853>>>>>        If (sAppSrcPath ="")    Get ReadString of hoIniFile "Workspace" "AppSrcPath" ""    To sAppSrcPath
7856>>>>>        If (sAppHtmlPath ="")   Get ReadString of hoIniFile "Workspace" "AppHtmlPath" ""   To sAppHtmlPath
7859>>>>>        If (sBitmapPath ="")    Get ReadString of hoIniFile "Workspace" "BitmapPath" ""    To sBitmapPath
7862>>>>>        If (sDataPath ="")      Get ReadString of hoIniFile "Workspace" "DataPath" ""      To sDataPath
7865>>>>>        If (sDdSrcPath ="")     Get ReadString of hoIniFile "Workspace" "DdSrcPath" ""     To sDdSrcPath
7868>>>>>        If (sDescription ="")   Get ReadString of hoIniFile "Workspace" "Description" ""   To sDescription
7871>>>>>        If (sFileList ="")      Get ReadString of hoIniFile "Workspace" "FileList" ""      To sFileList
7874>>>>>        If (sHelpPath ="")      Get ReadString of hoIniFile "Workspace" "HelpPath" ""      To sHelpPath
7877>>>>>        If (sIdeSrcPath ="")    Get ReadString of hoIniFile "Workspace" "IdeSrcPath" ""    To sIdeSrcPath
7880>>>>>        If (sProgramPath ="")   Get ReadString of hoIniFile "Workspace" "ProgramPath" ""   To sProgramPath
7883>>>>>        If (sWorkspaceName ="") Move (Left(sWsName, Length(sWsName) -3))                   To sWorkspaceName
7886>>>>>
7886>>>>>        If (sSystemDfPath ="")   Set psSystemDfPath   To (VdfSystemDfPath(self))
7889>>>>>        If (sSystemMakePath ="") Set psSystemMakePath To (VdfSystemMakePath(self))
7892>>>>>
7892>>>>>        Set psHome          To (FullPathNames(self, sHome))
7893>>>>>
7893>>>>>        // Set CWD to Home...
7893>>>>>        Move (SetCurrentDirectory(sHome)) To bSuccess
7894>>>>>        Set psAppSrcPath    To (FullPathNames(self, sAppSrcPath))
7895>>>>>        Set psAppHtmlPath   To (FullPathNames(self, sAppHtmlPath))
7896>>>>>        Set psBitmapPath    To (FullPathNames(self, sBitmapPath))
7897>>>>>        Set psDataPath      To (FullPathNames(self, sDataPath))
7898>>>>>        Set psDdSrcPath     To (FullPathNames(self, sDdSrcPath))
7899>>>>>        Set psFileList      To (FullPathNames(self, sFileList))
7900>>>>>        Set psHelpPath      To (FullPathNames(self, sHelpPath))
7901>>>>>        Set psIdeSrcPath    To (FullPathNames(self, sIdeSrcPath))
7902>>>>>        Set psProgramPath   To (FullPathNames(self, sProgramPath))
7903>>>>>
7903>>>>>        Set psWorkspaceName To sWorkspaceName
7904>>>>>        Set psDescription   To sDescription
7905>>>>>
7905>>>>>        Send Destroy of hoIniFile // destroy dynaically created inifile object
7906>>>>>
7906>>>>>        // Restore CWD...
7906>>>>>        Move (SetCurrentDirectory(sOldDirectory)) To sOldDirectory
7907>>>>>
7907>>>>>        // Check for error conditions:
7907>>>>>        // DataPath and FileList must be defined; the FileList entry must point to a valid FileList.cfg
7907>>>>>        If (psDataPath(self) = "") Function_Return wsDataPathEmpty
7910>>>>>        If (psFileList(self) = "") Function_Return wsFileListEmpty
7913>>>>>
7913>>>>>        //File_Exist (psFileList(self)) bExist
7913>>>>>        Move (DoesFileExist(psFileList(self))) To bExist
7914>>>>>        If (bExist = False) Function_Return wsFileListNotExist
7917>>>>>
7917>>>>>        If bChangingWorkspace Close DF_ALL // if there is a WS open, we must close all the files
7920>>>>>
7920>>>>>        Send DoAssignPaths // set psDfPath
7921>>>>>        Send DoSetPaths    // Set the application's Attributes of Filelist_Name and Open_Path
7922>>>>>        Set pbWorkspaceOpened To True
7923>>>>>
7923>>>>>        Function_Return wsWorkspaceOpened
7924>>>>>    End_Function
7925>>>>>
7925>>>>>    Function OpenWorkspace String sWorkspace Returns Integer
7927>>>>>        // Look in the Workspaces.ini file for the name, then open it by path
7927>>>>>
7927>>>>>        Handle hoSections hoIniFile
7927>>>>>        Integer iWorkspace eOpened
7927>>>>>        String sWorkspaceName sPath
7927>>>>>        String sVdfRootDir
7927>>>>>
7927>>>>>        Get Create U_Array    To hoSections
7928>>>>>        Get Create U_cIniFile To hoIniFile
7929>>>>>
7929>>>>>        Get_Profile_String "Defaults" "VdfRootDir" To sVdfRootDir
7932>>>>>        If (Right(sVdfRootDir,1) <>"\") Move (sVdfRootDir +"\") To sVdfRootDir
7935>>>>>
7935>>>>>        Set psFilename of hoIniFile To (sVdfRootDir +"bin\Workspaces.ini")
7936>>>>>
7936>>>>>        Send ReadSections of hoIniFile hoSections
7937>>>>>
7937>>>>>        For iWorkspace from 0 to (Item_Count(hoSections) -1)
7943>>>>>>
7943>>>>>            Get Value of hoSections iWorkspace To sWorkspaceName
7944>>>>>            If (Uppercase(sWorkspaceName) = Uppercase(sWorkspace)) Begin
7946>>>>>                Get ReadString of hoIniFile sWorkspace "Path" "" To sPath
7947>>>>>                If (Right(sPath,1) <>"\") Move (sPath +"\") To sPath
7950>>>>>
7950>>>>>                Get OpenWorkspaceFile (sPath + sWorkspace) To eOpened
7951>>>>>                Send Destroy of hoSections
7952>>>>>                Send Destroy of hoIniFile
7953>>>>>                Function_Return eOpened
7954>>>>>            End
7954>>>>>>
7954>>>>>        Loop
7955>>>>>>
7955>>>>>
7955>>>>>        Send Destroy of hoSections
7956>>>>>        Send Destroy of hoIniFile
7957>>>>>        Function_Return wsWorkspaceNotFound
7958>>>>>    End_Function
7959>>>>>
7959>>>>>    Function IsRegistered String sWorkspace Returns Boolean
7961>>>>>        Boolean bRegistered
7961>>>>>        Handle hoIniFile
7961>>>>>        String sVdfRootDir
7961>>>>>
7961>>>>>        Get Create U_cIniFile To hoIniFile
7962>>>>>
7962>>>>>        Get_Profile_String "Defaults" "VdfRootDir" To sVdfRootDir
7965>>>>>        If (Right(sVdfRootDir,1) <>"\") Move (sVdfRootDir +"\") To sVdfRootDir
7968>>>>>        Set psFilename of hoIniFile To (sVdfRootDir +"bin\Workspaces.ini")
7969>>>>>        Move (SectionExists(hoIniFile, sWorkspace)) To bRegistered
7970>>>>>
7970>>>>>        Send Destroy of hoIniFile
7971>>>>>
7971>>>>>        Function_Return bRegistered
7972>>>>>    End_Function
7973>>>>>
7973>>>>>    Function VdfSystemDfPath Returns String
7975>>>>>        String sSystemDfPath
7975>>>>>        Get_Profile_String "Workspaces" "SystemDfPath" To sSystemDfPath
7978>>>>>
7978>>>>>        Function_Return sSystemDfPath
7979>>>>>    End_Function
7980>>>>>
7980>>>>>    Function VdfSystemMakePath Returns String
7982>>>>>        String sSystemMakePath
7982>>>>>        Get_Profile_String "Workspaces" "SystemMakePath" To sSystemMakePath
7985>>>>>
7985>>>>>        Function_Return sSystemMakePath
7986>>>>>    End_Function
7987>>>>>
7987>>>>>    Procedure DoAssignPaths
7989>>>>>        String sDataPath sBitmapPath sHelpPath sProgramPath sSystemDfPath
7989>>>>>
7989>>>>>        Get psDataPath     To sDataPath
7990>>>>>        Get psBitmapPath   To sBitmapPath
7991>>>>>        Get psHelpPath     To sHelpPath
7992>>>>>        Get psProgramPath  To sProgramPath
7993>>>>>        Get psSystemDfPath To sSystemDfPath
7994>>>>>
7994>>>>>        Set psDfPath To (sDataPath +';' + sBitmapPath +';' + sHelpPath +';' + sProgramPath +';' + sSystemDfPath)
7995>>>>>
7995>>>>>    End_Procedure
7996>>>>>
7996>>>>>    Procedure DoSetPaths
7998>>>>>        // [JVH] 8.3.8.0 - must convert paths to Ansi before setting these values
7998>>>>>        // Note- this conversion is temporarily rolled back
7998>>>>>        //Set_Attribute DF_FILELIST_NAME To (ToAnsi(psFileList(self)))
7998>>>>>        //Set_Attribute DF_OPEN_PATH     To (ToAnsi(psDfPath(self)))
7998>>>>>        Set_Attribute DF_FILELIST_NAME To (psFileList(self))
8001>>>>>        Set_Attribute DF_OPEN_PATH     To (psDfPath(self))
8004>>>>>    End_Procedure
8005>>>>>
8005>>>>>    Procedure EnumerateWorkspaceData Handle hoCallBack Handle hmGeneric
8007>>>>>         String sPath
8007>>>>>
8007>>>>>         If (psWorkspaceName(self)="") Send hmGeneric to hoCallBack C_$WorkspaceNotUsed
8010>>>>>         Else Begin
8011>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$WorkspaceDesc, psDescription(self)))
8012>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$WorkspaceName, psWorkspaceName(self)))
8013>>>>>            Send hmGeneric to hoCallBack ""
8014>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$Filelist, psFileList(self)))
8015>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$DataPath, psDataPath(self)))
8016>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$ProgramPath, psProgramPath(self)))
8017>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$HelpPath, psHelpPath(self)))
8018>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$BitmapsPath, psBitmapPath(self)))
8019>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$SystemPaths, psSystemDfPath(self)))
8020>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$FullDFPath, psDfPath(self)))
8021>>>>>         End
8021>>>>>>
8021>>>>>    End_Procedure
8022>>>>>
8022>>>>>    Function OpenWorkspaceErrorMessage Integer eErrorCode Returns String
8024>>>>>        // Decodes the enumerated integer returned by OpenWorkspace and
8024>>>>>        // returns a corresponding message string.
8024>>>>>        String sError
8024>>>>>
8024>>>>>        Case Begin
8024>>>>>            Case (eErrorCode = wsWorkspaceOpened)
8026>>>>>                Move C_$NoErrors To sError
8027>>>>>                Case Break
8028>>>>>            Case (eErrorCode = wsWorkspaceNotFound)
8031>>>>>                Move C_$NoWsName To sError
8032>>>>>                Case Break
8033>>>>>            Case (eErrorCode = wsWorkspaceFileNotFound)
8036>>>>>                Move C_$NoWsFileFound To sError
8037>>>>>                Case Break
8038>>>>>            Case (eErrorCode = wsDataPathEmpty)
8041>>>>>                Move C_$NoWsDataPath To sError
8042>>>>>                Case Break
8043>>>>>            Case (eErrorCode = wsFileListEmpty)
8046>>>>>                Move C_$NoWsFileList To sError
8047>>>>>                Case Break
8048>>>>>            Case (eErrorCode = wsFileListNotExist)
8051>>>>>                Move C_$NoFileListCfg To sError
8052>>>>>                Case Break
8053>>>>>            Case Else
8053>>>>>                Move C_$UnknownError To sError
8054>>>>>                Case Break
8055>>>>>        Case End
8055>>>>>
8055>>>>>        Function_Return (sError-".")
8056>>>>>    End_Function    // OpenWorkspaceErrorMessage
8057>>>>>
8057>>>>>    Function GetWorkspaceFileName String sWorkspace Returns String
8059>>>>>        // Returns the name of the physical Workspace file for the passed Workspace name.
8059>>>>>        String sVdfRootDir
8059>>>>>        Handle hoIniFile
8059>>>>>        String sPath
8059>>>>>        String sFileName
8059>>>>>        String sWorkspacePath
8059>>>>>
8059>>>>>        Move "" To sFileName
8060>>>>>
8060>>>>>        Get_Profile_String "Defaults" "VdfRootDir" To sVdfRootDir
8063>>>>>        If (Right(sVdfRootDir,1) <>"\") Move (sVdfRootDir +"\") To sVdfRootDir
8066>>>>>
8066>>>>>        Get Create U_cIniFile To hoIniFile
8067>>>>>        Set psFilename of hoIniFile To (sVdfRootDir +"bin\Workspaces.ini")
8068>>>>>        Get ReadString of hoIniFile sWorkspace "Path" "" To sWorkspacePath
8069>>>>>        If (sWorkspacePath <>"") Begin
8071>>>>>            If (Right(sWorkspacePath,1) <>"\") Move (sWorkspacePath +"\") To sWorkspacePath
8074>>>>>            Move (sWorkspacePath +sWorkspace +".ws") To sFileName
8075>>>>>        End
8075>>>>>>
8075>>>>>        Send Destroy of hoIniFile
8076>>>>>
8076>>>>>        Function_Return sFileName
8077>>>>>    End_Function
8078>>>>>
8078>>>>>    Function CountOfPaths String sPaths Returns Integer
8080>>>>>        // Returns the number of paths defined in a string of paths
8080>>>>>        Integer iChar icChar icPath
8080>>>>>
8080>>>>>        If (sPaths ="") Function_Return 0
8083>>>>>
8083>>>>>        Move (Length(sPaths) -1) To icChar
8084>>>>>        For iChar from 1 To icChar
8090>>>>>>
8090>>>>>            If (Mid(sPaths, 1, iChar) =";") Increment icPath
8093>>>>>        Loop
8094>>>>>>
8094>>>>>
8094>>>>>        Function_Return (icPath +1)
8095>>>>>    End_Function
8096>>>>>
8096>>>>>    Function PathAtIndex String sPaths Integer iIndex Returns String
8098>>>>>        // Returns the path at the 1-based index of passed paths.
8098>>>>>        // If the path contains a trailing "\", it will be removed
8098>>>>>        Integer iChar icPath iPath iPos
8098>>>>>        String sPath
8098>>>>>
8098>>>>>        Move (sPaths +";") To sPaths
8099>>>>>        For iPath From 1 To iIndex
8105>>>>>>
8105>>>>>            Move (Pos(";", sPaths)) To iPos
8106>>>>>            If iPos Begin
8108>>>>>                Move (Left(sPaths, iPos -1)) To sPath
8109>>>>>                If (Right(sPath,1) = '\') Move (Left(sPath, Length(sPath) -1)) To sPath
8112>>>>>                Move (Right(sPaths, Length(sPaths) -iPos)) To sPaths
8113>>>>>            End
8113>>>>>>
8113>>>>>            Else Function_Return "" // index past number of paths
8115>>>>>        Loop
8116>>>>>>
8116>>>>>
8116>>>>>        Function_Return sPath
8117>>>>>    End_Function
8118>>>>>
8118>>>>>End_Class
8119>>>>>
8119>>>Use cCommandLine.pkg
Including file: cCommandLine.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cCommandLine.pkg)
8119>>>>>// CLASS: cCommandLine
8119>>>>>// Author: SWB
8119>>>>>
8119>>>>>use VDFBase.pkg
8119>>>>>
8119>>>>>Class cCommandLine is a cObject
8120>>>>>
8120>>>>>    Procedure Construct_Object
8122>>>>>        Forward Send Construct_Object
8124>>>>>
8124>>>>>        Property Handle phoArgs // private object-handle of internal array of arguments
8125>>>>>    End_Procedure
8126>>>>>
8126>>>>>    Procedure Private_DoCreateArgsArray
8128>>>>>        // creates the array for holding the arguments. Created upon demand only!
8128>>>>>        Integer icArg
8128>>>>>        String sArg
8128>>>>>
8128>>>>>        Object oArgs is an Array
8130>>>>>            Delegate Set phoArgs To self
8132>>>>>            Repeat
8132>>>>>>
8132>>>>>                CmdLine sArg
8133>>>>>>
8133>>>>>                If (sArg <> "") Begin
8135>>>>>                    Increment icArg
8136>>>>>                    Set Value  (icArg -1) To sArg
8137>>>>>                End
8137>>>>>>
8137>>>>>            Until (sArg = "")
8139>>>>>        End_Object
8140>>>>>    End_Procedure
8141>>>>>
8141>>>>>    Function CountOfArgs Returns Integer
8143>>>>>        //Returns the number of arguments passed
8143>>>>>        If (phoArgs(self) =0) Send Private_DoCreateArgsArray
8146>>>>>        Function_Return (Item_Count(phoArgs(self)))
8147>>>>>    End_Function
8148>>>>>
8148>>>>>    Function Argument Integer iIndex Returns String
8150>>>>>        //Returns the one-based argument string
8150>>>>>        If (phoArgs(self) =0) Send Private_DoCreateArgsArray
8153>>>>>        Function_Return (Value(phoArgs(self), iIndex -1))
8154>>>>>    End_Function
8155>>>>>
8155>>>>>End_Class
8156>>>Use cRegistry.pkg
Including file: cRegistry.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cRegistry.pkg)
8156>>>>>// cRegistry.pkg
8156>>>>>// Author: SWB
8156>>>>>
8156>>>>>//  Registry Access Package
8156>>>>>
8156>>>>>Use Windows.pkg
8156>>>>>Use RegistryAPI.pkg
8156>>>>>
8156>>>>>Enum_List // Registry Data types
8156>>>>>    Define rdString
8156>>>>>    Define rdDword
8156>>>>>    Define rdBinary
8156>>>>>    Define rdUnknown
8156>>>>>End_Enum_List
8156>>>>>
8156>>>>>//Prototypes
8156>>>>>Register_Function phRootKey      Returns Handle // HKEY_CURRENT_USER
8156>>>>>Register_Function pfAccessRights Returns Integer // KEY_ALL_ACCESS - what access level should be used to open a Key?
8156>>>>>Register_Function phCurrentKey   Returns Handle // low-level key
8156>>>>>Register_Function pbLazyWrite    Returns Boolean // True
8156>>>>>
8156>>>>>Register_Function CountOfSubkeys      Returns Integer
8156>>>>>Register_Function CountOfValues       Returns Integer
8156>>>>>Register_Function CreateKey           String sKeyName Returns Integer   // return=error code
8156>>>>>Register_Function DeleteKey           String sKeyName Returns Boolean       // Deleted successfully?
8156>>>>>Register_Function DeleteValue         String sValueName Returns Boolean // Deleted successfully?
8156>>>>>Register_Function GetSubkeys          Handle hoArray Returns Integer    // count of Subkeys
8156>>>>>Register_Function GetValues           Handle hoArray Returns Integer    // count of Values
8156>>>>>Register_Function KeyExists           String sKeyName Returns Boolean   // does the key exist?
8156>>>>>Register_Function LongestDataLength   Returns Integer
8156>>>>>Register_Function LongestSubkeyLength Returns Integer
8156>>>>>Register_Function LongestValueLength  Returns Integer
8156>>>>>Register_Function OpenKey             string sKeyName Returns Integer
8156>>>>>Register_Function ReadBinary          String sValueName Address aValueData Integer iDataLength Returns Boolean
8156>>>>>Register_Function ReadDword           String sValueName Returns DWord
8156>>>>>Register_Function ReadString          String sValueName Returns String
8156>>>>>Register_Function ValueExists         String sValueName Returns Integer // does the Value exist?
8156>>>>>Register_Function ValueLength         String sValueName Returns Integer
8156>>>>>Register_Function ValueType           String sValueName Returns Integer // what is the datatype of the Value?
8156>>>>>Register_Procedure CloseKey
8156>>>>>Register_Procedure WriteBinary        String sValueName Address aValueData Integer iDataLength
8156>>>>>Register_Procedure WriteDword         String sValue DWord dwValueData
8156>>>>>Register_Procedure WriteString        String sValue String sValueData
8156>>>>>
8156>>>>>
8156>>>>>Class cRegistry is a cObject
8157>>>>>    Procedure Construct_Object
8159>>>>>        Forward Send Construct_Object
8161>>>>>
8161>>>>>        Property Handle phRootKey HKEY_CURRENT_USER
8162>>>>>        Property UInteger pfAccessRights  KEY_ALL_ACCESS // what access level should be used to open a Key?
8163>>>>>        Property Handle phCurrentKey
8164>>>>>        Property Boolean pbLazyWrite True
8165>>>>>    End_Procedure
8166>>>>>
8166>>>>>    Function CountOfSubkeys Returns Integer
8168>>>>>        DWord dwCountOfSubkeys
8168>>>>>        Integer iError
8168>>>>>        String sError
8168>>>>>
8168>>>>>        Move 0 To dwCountOfSubkeys
8169>>>>>        Move (RegQueryInfoKey(phCurrentKey(self), 0, 0, 0, AddressOf(dwCountOfSubkeys), 0, 0, 0, 0, 0, 0, 0)) To iError
8170>>>>>        If iError Begin
8172>>>>>            Move (FormatWinError(iError)) To sError // raise an error if the Query failed
8173>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8174>>>>>>
8174>>>>>        End
8174>>>>>>
8174>>>>>        Function_Return dwCountOfSubkeys
8175>>>>>    End_Function
8176>>>>>
8176>>>>>    Function CountOfValues Returns Integer
8178>>>>>        DWord dwCountOfValues
8178>>>>>        Integer iError
8178>>>>>        String sError
8178>>>>>
8178>>>>>        Move 0 To dwCountOfValues
8179>>>>>        Move (RegQueryInfoKey(phCurrentKey(self), 0, 0, 0, 0, 0, 0, AddressOf(dwCountOfValues), 0, 0, 0, 0)) To iError
8180>>>>>        If iError Begin
8182>>>>>            Move (FormatWinError(iError)) To sError // raise an error if the Query failed
8183>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8184>>>>>>
8184>>>>>        End
8184>>>>>>
8184>>>>>
8184>>>>>        Function_Return dwCountOfValues
8185>>>>>    End_Function
8186>>>>>
8186>>>>>    Function LongestSubkeyLength Returns Integer
8188>>>>>        DWord dwLongestSubkeyLength
8188>>>>>        Integer iError
8188>>>>>        String sError
8188>>>>>
8188>>>>>        Move 0 To dwLongestSubkeyLength
8189>>>>>        Move (RegQueryInfoKey(phCurrentKey(self), 0, 0, 0, 0, AddressOf(dwLongestSubkeyLength), 0, 0, 0, 0, 0, 0)) To iError
8190>>>>>        If iError Begin
8192>>>>>            Move (FormatWinError(iError)) To sError // raise an error if the Query failed
8193>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8194>>>>>>
8194>>>>>        End
8194>>>>>>
8194>>>>>
8194>>>>>        Function_Return dwLongestSubkeyLength
8195>>>>>    End_Function
8196>>>>>
8196>>>>>    Function LongestValueLength Returns Integer
8198>>>>>        DWord dwLongestValueLength
8198>>>>>        Integer iError
8198>>>>>        String sError
8198>>>>>
8198>>>>>        Move 0 To dwLongestValueLength
8199>>>>>        Move (RegQueryInfoKey(phCurrentKey(self), 0, 0, 0, 0, 0, 0, 0, AddressOf(dwLongestValueLength), 0, 0, 0)) To iError
8200>>>>>        If iError Begin
8202>>>>>            Move (FormatWinError(iError)) To sError // raise an error if the Query failed
8203>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8204>>>>>>
8204>>>>>        End
8204>>>>>>
8204>>>>>
8204>>>>>        Function_Return dwLongestValueLength
8205>>>>>    End_Function
8206>>>>>
8206>>>>>    Function LongestDataLength Returns Integer
8208>>>>>        DWord dwLongestDataLength
8208>>>>>        Integer iError
8208>>>>>        String sError
8208>>>>>
8208>>>>>        Move 0 To dwLongestDataLength
8209>>>>>        Move (RegQueryInfoKey(phCurrentKey(self), 0, 0, 0, 0, 0, 0, 0, 0, AddressOf(dwLongestDataLength), 0, 0)) To iError
8210>>>>>        If iError Begin
8212>>>>>            Move (FormatWinError(iError)) To sError // raise an error if the Query failed
8213>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8214>>>>>>
8214>>>>>        End
8214>>>>>>
8214>>>>>
8214>>>>>        Function_Return dwLongestDataLength
8215>>>>>    End_Function
8216>>>>>
8216>>>>>    Function ValueType String sValueName Returns Integer
8218>>>>>        DWord dwType
8218>>>>>        Integer iError eType
8218>>>>>        String sError
8218>>>>>
8218>>>>>        Move 0 To dwType
8219>>>>>        Move (RegQueryValueEx(phCurrentKey(self), ToAnsi(sValueName), 0, AddressOf(dwType), 0, 0)) To iError
8220>>>>>        If iError Begin
8222>>>>>            Move (FormatWinError(iError)) To sError // raise an error if the Query failed
8223>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8224>>>>>>
8224>>>>>        End
8224>>>>>>
8224>>>>>
8224>>>>>        If (dwType = REG_SZ)          Move rdString To eType
8227>>>>>        Else If (dwType = REG_DWORD)  Move rdDword To eType
8231>>>>>        Else If (dwType = REG_BINARY) Move rdBinary To eType
8235>>>>>        Else                          Move rdUnknown To eType
8237>>>>>
8237>>>>>        Function_Return eType
8238>>>>>    End_Function
8239>>>>>
8239>>>>>    Function ValueLength String sValueName Returns Integer
8241>>>>>        DWord dwSize
8241>>>>>        Integer iError
8241>>>>>        String sError
8241>>>>>
8241>>>>>        Move 0 To dwSize
8242>>>>>        Move (RegQueryValueEx(phCurrentKey(self), ToAnsi(sValueName), 0, 0, 0, AddressOf(dwSize))) To iError
8243>>>>>        If iError Begin
8245>>>>>            Move (FormatWinError(iError)) To sError // raise an error if the Query failed
8246>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8247>>>>>>
8247>>>>>        End
8247>>>>>>
8247>>>>>
8247>>>>>        Function_Return dwSize
8248>>>>>    End_Function
8249>>>>>
8249>>>>>    Function CreateKey string sKeyName Returns Integer // return=error code
8251>>>>>        // Calling CreateKey for an existing Key, merely opens it without error.
8251>>>>>        Handle hKey hKeyOpened
8251>>>>>        Integer iError
8251>>>>>        String sError
8251>>>>>
8251>>>>>        Move 0 To hKeyOpened // initialize it so we can get its address
8252>>>>>
8252>>>>>        Get phRootKey To hKey
8253>>>>>
8253>>>>>        Move (RegCreateKeyEx(hKey, ToAnsi(sKeyName), 0, 0, REG_OPTION_NON_VOLATILE, pfAccessRights(self), 0, AddressOf(hKeyOpened), 0)) To iError
8254>>>>>        If (iError =0) Set phCurrentKey To hKeyOpened
8257>>>>>        Else Begin
8258>>>>>            Move (FormatWinError(iError)) To sError // raise an error if the Query failed
8259>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8260>>>>>>
8260>>>>>        End
8260>>>>>>
8260>>>>>        Function_Return iError
8261>>>>>    End_Function
8262>>>>>
8262>>>>>    Procedure CloseKey
8264>>>>>        Integer iError
8264>>>>>        Handle hKey
8264>>>>>
8264>>>>>        Get phCurrentKey To hKey
8265>>>>>
8265>>>>>        If (hKey <>0) Begin
8267>>>>>            If (pbLazyWrite(self)) Move (RegCloseKey(hKey)) To iError
8270>>>>>            Else Move (RegFlushKey(hKey)) To iError
8272>>>>>
8272>>>>>            Set phCurrentKey To 0
8273>>>>>        End
8273>>>>>>
8273>>>>>    End_Procedure
8274>>>>>
8274>>>>>    Function OpenKey string sKeyName Returns Boolean
8276>>>>>        Handle hKey hKeyOpened
8276>>>>>        Integer iError
8276>>>>>
8276>>>>>        Move 0 To hKeyOpened // initialize it so we can get its address
8277>>>>>
8277>>>>>        Get phRootKey To hKey
8278>>>>>        Move (RegOpenKeyEx(hKey, ToAnsi(sKeyName), 0, pfAccessRights(self), AddressOf(hKeyOpened))) To iError
8279>>>>>        If (iError =0) Set phCurrentKey To hKeyOpened
8282>>>>>
8282>>>>>        Function_Return (iError=0)
8283>>>>>    End_Function
8284>>>>>
8284>>>>>    Procedure WriteDword String sValue DWord dwValueData
8286>>>>>        Handle hKey
8286>>>>>        Integer iError
8286>>>>>        Pointer lpsDWord
8286>>>>>        String sDWord
8286>>>>>        String sError
8286>>>>>
8286>>>>>        ZeroType tDWord To sDWord
8287>>>>>        Put dwValueData To sDWord At tDWord.dword
8288>>>>>        GetAddress of sDWord To lpsDWord
8289>>>>>
8289>>>>>        Get phCurrentKey To hKey
8290>>>>>        Move (RegSetValueEx(hKey, ToAnsi(sValue), 0, REG_DWORD, lpsDWord, 4)) To iError
8291>>>>>        If iError Begin
8293>>>>>            Move (FormatWinError(iError)) To sError // raise an error if the Query failed
8294>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8295>>>>>>
8295>>>>>        End
8295>>>>>>
8295>>>>>    End_Procedure
8296>>>>>
8296>>>>>    Procedure WriteString String sValue String sValueData
8298>>>>>        Handle hKey
8298>>>>>        Integer iError cbData
8298>>>>>        Pointer lpsValueData
8298>>>>>        String sError
8298>>>>>
8298>>>>>        If (sValueData = "") Begin
8300>>>>>             Move (Character(0)) To sValueData
8301>>>>>             Move 1 To cbData
8302>>>>>        End
8302>>>>>>
8302>>>>>        Else Begin
8303>>>>>             Move (Length(sValueData) +1) To cbData
8304>>>>>        End
8304>>>>>>
8304>>>>>        Move (ToAnsi(sValueData)) To sValueData
8305>>>>>        GetAddress of sValueData To lpsValueData
8306>>>>>
8306>>>>>        Get phCurrentKey To hKey
8307>>>>>        Move (RegSetValueEx(hKey, ToAnsi(sValue), 0, REG_SZ, lpsValueData, cbData)) To iError
8308>>>>>        If iError Begin
8310>>>>>            Move (FormatWinError(iError)) To sError // raise an error if the Query failed
8311>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8312>>>>>>
8312>>>>>        End
8312>>>>>>
8312>>>>>    End_Procedure
8313>>>>>
8313>>>>>    Procedure WriteBinary String sValueName Address aValueData Integer iDataLength
8315>>>>>        Handle hKey
8315>>>>>        Integer iError
8315>>>>>        String sError
8315>>>>>
8315>>>>>        Get phCurrentKey To hKey
8316>>>>>        Move (RegSetValueEx(hKey, ToAnsi(sValueName), 0, REG_BINARY, aValueData, iDataLength)) To iError
8317>>>>>        If iError Begin
8319>>>>>            Move (FormatWinError(iError)) To sError // raise an error if the Query failed
8320>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8321>>>>>>
8321>>>>>        End
8321>>>>>>
8321>>>>>    End_Procedure
8322>>>>>
8322>>>>>    Function ReadDword String sValueName Returns DWord
8324>>>>>        Handle hKey
8324>>>>>        Integer iError
8324>>>>>        DWord dwValueData dwValueDataLength
8324>>>>>        String sError
8324>>>>>
8324>>>>>        Move 0           To dwValueData
8325>>>>>        Move tDWord_Size To dwValueDataLength
8326>>>>>
8326>>>>>        Get phCurrentKey To hKey
8327>>>>>        Move (RegQueryValueEx(hKey, ToAnsi(sValueName), 0, 0, AddressOf(dwValueData), AddressOf(dwValueDataLength))) To iError
8328>>>>>        If iError Begin
8330>>>>>            Move (FormatWinError(iError)) To sError // raise an error if the Query failed
8331>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8332>>>>>>
8332>>>>>        End
8332>>>>>>
8332>>>>>
8332>>>>>        Function_Return dwValueData
8333>>>>>    End_Function
8334>>>>>
8334>>>>>    Function ReadString String sValueName Returns String
8336>>>>>        Handle hKey
8336>>>>>        Integer iError
8336>>>>>        String sValueData
8336>>>>>        DWord dwValueDataLength
8336>>>>>        Pointer lpsValueData
8336>>>>>        String sError
8336>>>>>
8336>>>>>        Move (Repeat(character(0), ValueLength(self, sValueName))) To sValueData
8337>>>>>        GetAddress of sValueData To lpsValueData
8338>>>>>
8338>>>>>        Move (Length(sValueData)) To dwValueDataLength
8339>>>>>
8339>>>>>        Get phCurrentKey To hKey
8340>>>>>        Move (RegQueryValueEx(hKey, ToAnsi(sValueName), 0, 0, lpsValueData, AddressOf(dwValueDataLength))) To iError
8341>>>>>        If iError Begin
8343>>>>>            Move (FormatWinError(iError)) To sError // raise an error if the Query failed
8344>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8345>>>>>>
8345>>>>>        End
8345>>>>>>
8345>>>>>
8345>>>>>        Function_Return (ToOem(CString(sValueData)))
8346>>>>>    End_Function
8347>>>>>
8347>>>>>    Function ReadBinary String sValueName Address aValueData Integer iDataLength Returns Boolean
8349>>>>>        Handle hKey
8349>>>>>        Integer iError
8349>>>>>        String sError
8349>>>>>
8349>>>>>        Get phCurrentKey To hKey
8350>>>>>        Move (RegQueryValueEx(hKey, ToAnsi(sValueName), 0, 0, aValueData, AddressOf(iDataLength))) To iError
8351>>>>>        If iError Begin
8353>>>>>            Move (FormatWinError(iError)) To sError // raise an error if the Query failed
8354>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8355>>>>>>
8355>>>>>        End
8355>>>>>>
8355>>>>>
8355>>>>>        Function_Return (iDataLength >0)
8356>>>>>    End_Function
8357>>>>>
8357>>>>>
8357>>>>>    // Private....
8357>>>>>    Function GetBaseKey Returns Handle
8359>>>>>        Handle hBaseKey
8359>>>>>        If (phCurrentKey(self) = 0)  Get phRootKey To hBaseKey
8362>>>>>        Else Get phCurrentKey To hBaseKey
8364>>>>>
8364>>>>>        Function_Return hBaseKey
8365>>>>>    End_Function
8366>>>>>
8366>>>>>    Function GetKey String sKeyName Returns Handle
8368>>>>>        Handle hKeyOpened
8368>>>>>        Integer iError
8368>>>>>
8368>>>>>        MOve 0 To hKeyOpened // initialize so we can get its address
8369>>>>>
8369>>>>>        Move (RegOpenKeyEx(GetBaseKey(self), ToAnsi(sKeyName), 0, pfAccessRights(self), AddressOf(hKeyOpened))) To iError
8370>>>>>
8370>>>>>        If (iError =0) Function_Return hKeyOpened
8373>>>>>        Else           Function_Return 0
8375>>>>>    End_Function
8376>>>>>
8376>>>>>    // Public
8376>>>>>    Function KeyExists String sKeyName Returns Boolean
8378>>>>>        Handle hKey
8378>>>>>        Integer iVoid
8378>>>>>
8378>>>>>        Get GetKey sKeyName To hKey
8379>>>>>        If hKey Move (RegCloseKey(hKey)) To iVoid
8382>>>>>        Function_Return (hKey <>0)
8383>>>>>    End_Function
8384>>>>>
8384>>>>>    Function ValueExists String sValueName Returns Boolean
8386>>>>>        // Determines whether a Value exists for the currently-opened Key.
8386>>>>>        Integer iError
8386>>>>>        Dword dwDataType
8386>>>>>        Move 0 To dwDataType // must initialize the variable to get its address
8387>>>>>
8387>>>>>        Move (RegQueryValueEx(phCurrentKey(self), ToAnsi(sValueName), 0, AddressOf(dwDataType), 0, 0)) To iError
8388>>>>>
8388>>>>>        Function_Return (iError=0)
8389>>>>>    End_Function
8390>>>>>
8390>>>>>    Function DeleteKey String sKeyName Returns Boolean // Deleted successfully?
8392>>>>>        Function_Return (ShDeleteKey(phRootKey(self), ToAnsi(sKeyName)) =0)
8393>>>>>    End_Function
8394>>>>>
8394>>>>>    Function DeleteValue String sValueName Returns Boolean // Deleted successfully?
8396>>>>>        Function_Return (RegDeleteValue(phCurrentKey(self), ToAnsi(sValueName)) =0)
8397>>>>>    End_Function
8398>>>>>
8398>>>>>    Function GetSubkeys Handle hoArray Returns Integer // count of Values
8400>>>>>        Integer iError
8400>>>>>        Integer icValue iLongestSubkey
8400>>>>>        Handle hKey
8400>>>>>        DWord dwSubkeyNameLength
8400>>>>>        String sSubkeyName sFileTime
8400>>>>>        Pointer lpsSubkeyName lpsFileTime
8400>>>>>
8400>>>>>        Get LongestSubkeyLength To iLongestSubkey
8401>>>>>        Move (Repeat(character(0), iLongestSubkey +1)) To sSubkeyName
8402>>>>>        GetAddress of sSubkeyName To lpsSubkeyName
8403>>>>>
8403>>>>>        ZeroType tFileTime To sFileTime
8404>>>>>        GetAddress of sFileTime To lpsFileTime
8405>>>>>
8405>>>>>        Get phCurrentKey To hKey
8406>>>>>        Repeat
8406>>>>>>
8406>>>>>            Move (iLongestSubkey +1) To dwSubkeyNameLength
8407>>>>>
8407>>>>>            Move (RegEnumKeyEx(hKey, icValue, lpsSubkeyName, AddressOf(dwSubkeyNameLength), 0, 0, 0, lpsFileTime)) To iError
8408>>>>>            If (iError =0) Begin
8410>>>>>                Increment icValue
8411>>>>>                Set Value of hoArray (Item_Count(hoArray)) To (ToOem(CString(sSubkeyName)))
8412>>>>>            End
8412>>>>>>
8412>>>>>        Until (iError)
8414>>>>>        Function_Return icValue
8415>>>>>
8415>>>>>    End_Function
8416>>>>>
8416>>>>>    Function GetValues Handle hoArray Returns Integer // count of Values
8418>>>>>        Integer iError
8418>>>>>        Integer icValue iLongestValue
8418>>>>>        Handle hKey
8418>>>>>        DWord dwValueNameLength
8418>>>>>        String sValueName sValueNameSize
8418>>>>>        Pointer lpsValueName
8418>>>>>
8418>>>>>        Get LongestValueLength To iLongestValue
8419>>>>>        Move (Repeat(character(0), iLongestValue +1)) To sValueName
8420>>>>>        GetAddress of sValueName To lpsValueName
8421>>>>>
8421>>>>>        Get phCurrentKey To hKey
8422>>>>>        Repeat
8422>>>>>>
8422>>>>>            Move (iLongestValue +1) To dwValueNameLength
8423>>>>>            Move (RegEnumValue(hKey, icValue, lpsValueName, AddressOf(dwValueNameLength), 0, 0, 0, 0)) To iError
8424>>>>>            If (iError =0) Begin
8426>>>>>                Increment icValue
8427>>>>>                Set Value of hoArray (Item_Count(hoArray)) To (ToOem(CString(sValueName)))
8428>>>>>            End
8428>>>>>>
8428>>>>>        Until (iError)
8430>>>>>        Function_Return icValue
8431>>>>>
8431>>>>>    End_Function
8432>>>>>
8432>>>>>End_Class
8433>>>Use cVersionInfo.pkg
Including file: cVersionInfo.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cVersionInfo.pkg)
8433>>>>>// Class cVersionInfo
8433>>>>>//
8433>>>>>// Stores version information about the EXE
8433>>>>>// Designed to be instantiated as a child of the Application object
8433>>>>>//
8433>>>>>// Created: Mar 12, 2002   SWB
8433>>>>>
8433>>>>>
8433>>>>>Use Windows.pkg
8433>>>>>Use DLL.pkg
8433>>>>>Use WinKern.pkg
8433>>>>>
8433>>>>>Define VS_FF_DEBUG         for |CI$00000001
8433>>>>>Define VS_FF_PRERELEASE    for |CI$00000002
8433>>>>>Define VS_FF_PATCHED       for |CI$00000004
8433>>>>>Define VS_FF_PRIVATEBUILD  for |CI$00000008
8433>>>>>Define VS_FF_INFOINFERRED  for |CI$00000010
8433>>>>>Define VS_FF_SPECIALBUILD  for |CI$00000020
8433>>>>>
8433>>>>>External_Function GetFileVersionInfoSize "GetFileVersionInfoSizeA" version.dll ;    Pointer aFilename ;    Pointer lpdwHandle ;Returns Dword
8434>>>>>
8434>>>>>External_Function GetFileVersionInfo "GetFileVersionInfoA" version.dll ;    Pointer sFilename ;    Dword dwHandle ;    Dword dwLen ;    Address aData ;Returns Integer
8435>>>>>
8435>>>>>External_Function VerQueryValue "VerQueryValueA" version.dll ;    Address aBlock ;    Address aSubBlock ;    Address aaBuffer ;    Address puLen ;Returns Integer
8436>>>>>
8436>>>>>Type tVsFixedFileInfo
8436>>>>>    Field tVsFixedFileInfo.dwSignature        as Dword
8436>>>>>    Field tVsFixedFileInfo.dwStrucVersion     as Dword
8436>>>>>    Field tVsFixedFileInfo.dwFileVersionMS    as Dword
8436>>>>>    Field tVsFixedFileInfo.dwFileVersionLS    as Dword
8436>>>>>    Field tVsFixedFileInfo.dwProductVersionMS as Dword
8436>>>>>    Field tVsFixedFileInfo.dwProductVersionLS as Dword
8436>>>>>    Field tVsFixedFileInfo.dwFileFlagsMask    as Dword
8436>>>>>    Field tVsFixedFileInfo.dwFileFlags        as Dword
8436>>>>>    Field tVsFixedFileInfo.dwFileOS           as Dword
8436>>>>>    Field tVsFixedFileInfo.dwFileType         as Dword
8436>>>>>    Field tVsFixedFileInfo.dwFileSubtype      as Dword
8436>>>>>    Field tVsFixedFileInfo.dwFileDateMS       as Dword
8436>>>>>    Field tVsFixedFileInfo.dwFileDateLS       as Dword
8436>>>>>End_Type
8436>>>>>
8436>>>>>Class cVersionInfo is a cObject
8437>>>>>    Procedure Construct_Object
8439>>>>>        Forward Send Construct_Object
8441>>>>>
8441>>>>>
8441>>>>>        Property Integer piVersionMajor
8442>>>>>        Property Integer piVersionMinor
8443>>>>>        Property Integer piVersionRelease
8444>>>>>        Property Integer piVersionBuild
8445>>>>>
8445>>>>>        Property Boolean pbIncluded
8446>>>>>        Property Boolean pbSpecialBuild
8447>>>>>        Property Boolean pbPrivateBuild
8448>>>>>
8448>>>>>    End_Procedure
8449>>>>>
8449>>>>>    Procedure DoCreate String sFileName
8451>>>>>        Dword dwHandle
8451>>>>>        Integer iInfoSize iVerSize iSuccess iVersion iVoid iFlags
8451>>>>>        String sData
8451>>>>>        String sVersionBuffer
8451>>>>>        String sVsFixedFileInfo
8451>>>>>        String sSubBlock
8451>>>>>        Address aVsFixedFileInfo
8451>>>>>
8451>>>>>        move 0 To aVsFixedFileInfo
8452>>>>>        Move 0 To dwHandle
8453>>>>>        Move 0 To iVerSize
8454>>>>>
8454>>>>>        Move (GetFileVersionInfoSize(AddressOf(sFilename), AddressOf(dwHandle))) To iInfoSize
8455>>>>>        Set pbIncluded To (iInfoSize <>0)
8456>>>>>
8456>>>>>        If (pbIncluded(self)) Begin
8458>>>>>            Move (Repeat(Character(0), iInfoSize)) To sData
8459>>>>>            Move (GetFileVersionInfo(AddressOf(sFilename), 0, iInfoSize, AddressOf(sData))) To iSuccess
8460>>>>>
8460>>>>>            If (iSuccess <>0) Begin
8462>>>>>                Move "\" To sSubBlock
8463>>>>>                If (VerQueryValue(AddressOf(sData), AddressOf(sSubBlock), AddressOf(aVsFixedFileInfo), AddressOf(iVerSize))) Begin
8465>>>>>                    ZeroType tVsFixedFileInfo To sVsFixedFileInfo
8466>>>>>                    Move (memcopy(AddressOf(sVsFixedFileInfo), aVsFixedFileInfo, iVerSize)) to iVoid // copy the structure
8467>>>>>
8467>>>>>                    GetBuff from sVsFixedFileInfo at tVsFixedFileInfo.dwFileVersionMS To iVersion
8468>>>>>                    Set piVersionMajor To (Hi(iVersion))
8469>>>>>                    Set piVersionMinor To (Low(iVersion))
8470>>>>>
8470>>>>>                    GetBuff from sVsFixedFileInfo at tVsFixedFileInfo.dwFileVersionLS To iVersion
8471>>>>>                    Set piVersionRelease To (Hi(iVersion))
8472>>>>>                    Set piVersionBuild   To (Low(iVersion))
8473>>>>>
8473>>>>>                    GetBuff from sVsFixedFileInfo at tVsFixedFileInfo.dwFileFlags To iFlags
8474>>>>>                    Set pbSpecialBuild    To (iFlags IAND VS_FF_SPECIALBUILD)
8475>>>>>                    Set pbPrivateBuild    To (iFlags IAND VS_FF_PRIVATEBUILD)
8476>>>>>                End
8476>>>>>>
8476>>>>>            End
8476>>>>>>
8476>>>>>
8476>>>>>        End
8476>>>>>>
8476>>>>>    End_Procedure
8477>>>>>
8477>>>>>End_Class
8478>>>>>
8478>>>>>
8478>>>Use GlobalFunctionsProcedures.pkg
8478>>>Use Dferror.pkg
Including file: Dferror.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\Dferror.pkg)
8478>>>>>//************************************************************************
8478>>>>> //
8478>>>>> //* Copyright (c) 1997 Data Access Corporation, Miami Florida,
8478>>>>> //* All rights reserved.
8478>>>>> //* DataFlex is a registered trademark of Data Access Corporation.
8478>>>>> //*
8478>>>>> //*  Module Name:
8478>>>>> //*      DFERROR.PKG
8478>>>>>//************************************************************************
8478>>>>>
8478>>>>>
8478>>>>>
8478>>>>>Use LanguageText.pkg
8478>>>>>
8478>>>>>
8478>>>>>Use Windows.pkg
8478>>>>>Use msgbox.pkg
8478>>>>>Use GlobalFunctionsProcedures.pkg
8478>>>>>
8478>>>>>//integer ghoErrorSource
8478>>>>>//Move 0 to ghoErrorSource
8478>>>>>//// ghoErrorSource object is expected to support this message
8478>>>>>//Register_Function Extended_Error_Message returns string
8478>>>>>
8478>>>>>// Include or define all useful symbols.
8478>>>>>Use ERRORNUM.INC
8478>>>>>// these are kept for compatibility. Don't use them
8478>>>>>
8478>>>>>// used by error handler and UserError to pull a caption out of the error string
8478>>>>>Define C_ErrorCaption for "*CAPTION*="
8478>>>>>
8478>>>>>// This array stores the set of trapped errors as toggled ranges starting
8478>>>>>// with the errors that are trapped. The array should always contain 0 and
8478>>>>>// MAX_ERROR_NUMBER + 1, which are the limits. If an array contained the
8478>>>>>// following items...
8478>>>>>//
8478>>>>>// { 0, 5, 10, MAX_ERROR_NUMBER + 1 }.
8478>>>>>//
8478>>>>>// This would mean that errors 1 - 4 are trapped, 5 - 9 are ignored, and
8478>>>>>// 10 through the rest are trapped.
8478>>>>>//
8478>>>>>Class Trapped_Errors_Array is an array
8479>>>>>
8479>>>>>    // Find largest error LE targetError. Assumes array is sorted.
8479>>>>>    Function findErrorLE Integer targetError Returns Integer
8481>>>>>
8481>>>>>        Integer lowIndex hiIndex midIndex currError
8481>>>>>
8481>>>>>        // If error is outside of boudary conditions, use
8481>>>>>        // value of closest valid error# instead.
8481>>>>>        If targetError le 0;            Move 1 to targetError
8484>>>>>        Else If targetError ge MAX_ERROR_NUMBER ;            Move ( MAX_ERROR_NUMBER - 1 ) to targetError
8488>>>>>
8488>>>>>        Move 0 to lowIndex
8489>>>>>        Move ( item_count( Self ) - 1 ) to hiIndex
8490>>>>>
8490>>>>>        // midIndex will contain the closest error LE to target upon exit.
8490>>>>>        Repeat
8490>>>>>>
8490>>>>>
8490>>>>>            Move ( ( lowIndex + hiIndex ) / 2 ) to midIndex
8491>>>>>            Move ( integer_value( Self, midIndex ) )  to currError
8492>>>>>
8492>>>>>            // midIndex is targetIndex if a match occurs
8492>>>>>            If currError eq targetError ;                Function_Return midIndex
8495>>>>>
8495>>>>>            // We are either on it or just below it.
8495>>>>>            If ( lowIndex eq midIndex ) Begin
8497>>>>>
8497>>>>>                If ( integer_value( Self, hiIndex ) le targetError ) ;                    Move hiIndex to midIndex
8500>>>>>
8500>>>>>                Function_Return midIndex
8501>>>>>
8501>>>>>            End
8501>>>>>>
8501>>>>>
8501>>>>>            // No match, so move the boundaries.
8501>>>>>            If currError gt targetError ;                Move ( midIndex - 1 ) to hiIndex
8504>>>>>            Else ;                Move midIndex to lowIndex
8506>>>>>
8506>>>>>        Until lowIndex gt hiIndex
8508>>>>>
8508>>>>>        Function_Return midIndex
8509>>>>>
8509>>>>>    End_Function
8510>>>>>
8510>>>>>    // Boundaries of the table are assumed to hold error limits.
8510>>>>>    Procedure initArray
8512>>>>>        Send delete_data
8513>>>>>        Set array_value item 0 to 0
8514>>>>>        Set array_value item 1 to ( MAX_ERROR_NUMBER + 1 )
8515>>>>>    End_Procedure
8516>>>>>
8516>>>>>    // Return 1 if Error is trapped, 0 otherwise.
8516>>>>>    Function IsTrapped Integer Error# Returns Integer
8518>>>>>        Function_Return ( not ( mod( findErrorLE( Self, Error# ), 2 ) ) )
8519>>>>>    End_Function
8520>>>>>
8520>>>>>    // Add the error as long as it doesn't violate boundary conditions.
8520>>>>>    // This routine leaves the array unsorted.
8520>>>>>    Procedure addError Integer Error#
8522>>>>>        If ( ( Error# lt MAX_ERROR_NUMBER ) and ( Error# gt 0 ) ) ;            Set array_value item ( item_count( Self ) ) to ( Integer( Error# ) )
8525>>>>>    End_Procedure
8526>>>>>
8526>>>>>    // Set error to flagged state.
8526>>>>>    Procedure handleError Integer Error# Integer trapFlag
8528>>>>>
8528>>>>>        Integer prevErrIndex prevErrFlag prevErrValue nextErrValue
8528>>>>>
8528>>>>>        If ( ( Error# gt MAX_ERROR_NUMBER ) or ( Error# lt 0 ) ) Begin
8530>>>>>            Error DFERR_ERROR_NUMBER_OUT_OF_RANGE
8531>>>>>>
8531>>>>>            Procedure_Return
8532>>>>>        End
8532>>>>>>
8532>>>>>
8532>>>>>        Get findErrorLE Error# to prevErrIndex
8533>>>>>        Get isTrapped   Error# to prevErrFlag
8534>>>>>
8534>>>>>        // if eq, Error already handled in some range.
8534>>>>>        If PrevErrFlag NE trapFlag Begin
8536>>>>>
8536>>>>>          // This is kind of complicated. If we are adding an error,
8536>>>>>          // we have to account for the error already being in the
8536>>>>>          // array as well as rejoining ranges that have been previously
8536>>>>>          // split and splitting ranges when adding a new flag.
8536>>>>>
8536>>>>>          Get integer_value item ( prevErrIndex + 1 ) to nextErrValue
8537>>>>>          Get integer_value item prevErrIndex         to prevErrValue
8538>>>>>
8538>>>>>          // Do this first so prevErrIndex stays valid.
8538>>>>>          If nextErrValue eq ( Error# + 1 ) ;              Send delete_item ( prevErrIndex + 1 )
8541>>>>>          Else ;              Send addError ( Error# + 1 )
8543>>>>>
8543>>>>>          If ( prevErrValue lt Error# ) ;              Send addError Error#
8546>>>>>          Else ;              Send delete_item prevErrIndex
8548>>>>>        End
8548>>>>>>
8548>>>>>        Send sort_items UPWARD_DIRECTION
8549>>>>>
8549>>>>>    End_Procedure
8550>>>>>
8550>>>>>    //*** Flag error as trappable
8550>>>>>    Procedure Trap_Error Integer Error#
8552>>>>>        Send handleError Error# 1
8553>>>>>    End_Procedure
8554>>>>>
8554>>>>>    //*** Flag error as non-trappable
8554>>>>>    Procedure Ignore_Error Integer Error#
8556>>>>>        Send handleError Error# 0
8557>>>>>    End_Procedure
8558>>>>>
8558>>>>>    //*** Flag all errors as trappable
8558>>>>>    Procedure Trap_All
8560>>>>>        Send initArray
8561>>>>>    End_Procedure
8562>>>>>
8562>>>>>    //*** Flag all errors as non-trappable
8562>>>>>    Procedure Ignore_All
8564>>>>>        Send delete_data
8565>>>>>        Set array_value item 0 to 0
8566>>>>>        Set array_value item 1 to 1
8567>>>>>        Set array_value item 2 to ( MAX_ERROR_NUMBER + 1 )
8568>>>>>    End_Procedure
8569>>>>>
8569>>>>>End_Class
8570>>>>>
8570>>>>>
8570>>>>>Class ErrorSystem is a cObject
8571>>>>>
8571>>>>>    Procedure construct_object
8573>>>>>        Forward Send construct_object
8575>>>>>
8575>>>>>        Set delegation_mode to no_delegate_or_error
8576>>>>>
8576>>>>>        Property Integer Verbose_State            True
8577>>>>>        Property Integer Current_Error_Number     0
8578>>>>>        Property Integer Error_Line_Number        0
8579>>>>>        
8579>>>>>        // If set false, this makes the error handler work the old way which
8579>>>>>        // does not use the new unhandled dialog. Only exists for compatibility reasons
8579>>>>>        Property Boolean pbUnhandledErrorSupport       True
8580>>>>>
8580>>>>>        // shows error numbers with user errors. Only set this true if your
8580>>>>>        // application has meaningful numbers that helps the end user. Note that
8580>>>>>        // unhandled errors always show numbers.
8580>>>>>        // this is ignored if pbUnhandledErrorSupport is false
8580>>>>>        Property Boolean pbShowErrorNumber        False
8581>>>>>        
8581>>>>>        
8581>>>>>        // This is the caption that appears for unhandled errors dialog box
8581>>>>>        Property String psUnhandledErrorCaption C_$UnhandledProgramError
8582>>>>>
8582>>>>>        // This is the caption that appears for standard user errors
8582>>>>>        Property String psUserErrorCaption C_$Error
8583>>>>>
8583>>>>>        // Flag which is sent when error is being processed. This
8583>>>>>        // stops error recursion.
8583>>>>>        Property Integer Error_Processing_State  False
8584>>>>>
8584>>>>>        // array of errors that we consider User Errors
8584>>>>>        Property Integer[] pUserErrorsArray
8585>>>>>
8585>>>>>        //  This allows us to skip find errors (GT & LT) and to only
8585>>>>>        //  ring a bell when these occur.
8585>>>>>        //
8585>>>>>        Property Integer Bell_on_Find_Error_State True
8586>>>>>        
8586>>>>>        Object TrappedErrors is a Trapped_Errors_Array
8588>>>>>            Send initArray
8589>>>>>        End_Object
8590>>>>>
8590>>>>>        Send Trap_All
8591>>>>>
8591>>>>>        // define the standard user error numbers
8591>>>>>        Send AddUserError 0
8592>>>>>        Send AddUserError DFERR_NUMBER_TOO_LARGE             
8593>>>>>        Send AddUserError DFERR_WINDOW_RANGE                 
8594>>>>>        Send AddUserError DFERR_ENTRY_REQUIRED               
8595>>>>>        Send AddUserError DFERR_ENTER_A_NUMBER               
8596>>>>>        Send AddUserError DFERR_BAD_ENTRY                    
8597>>>>>        Send AddUserError DFERR_ENTER_VALID_DATE             
8598>>>>>        Send AddUserError DFERR_NUMERIC_RANGE                
8599>>>>>        Send AddUserError DFERR_DUPLICATE_REC
8600>>>>>        Send AddUserError DFERR_TEXT_FIELD_TOO_LONG          
8601>>>>>        Send AddUserError DFERR_FIND_PRIOR_BEG_OF_FILE       
8602>>>>>        Send AddUserError DFERR_FIND_PAST_END_OF_FILE        
8603>>>>>        Send AddUserError DFERR_NO_REC_TO_DELETE
8604>>>>>        Send AddUserError DFERR_FIELD_NOT_INDEXED // can be invoked w/ find keys       
8605>>>>>        Send AddUserError DFERR_REC_NUMBER_RANGE             
8606>>>>>        Send AddUserError DFERR_ENTER_VALID_REC_ID           
8607>>>>>        Send AddUserError DFERR_OPERATOR_ERROR               
8608>>>>>        Send AddUserError DFERR_CANT_CHANGE_KEY_FIELD        
8609>>>>>        Send AddUserError DFERR_NO_DELETE_RELATED_RECORDS_EXIST
8610>>>>>        Send AddUserError DFERR_OPERATION_NOT_ALLOWED        
8611>>>>>        Send AddUserError DFERR_OPERATOR                     
8612>>>>>        Send AddUserError DFERR_XML_HTTP              
8613>>>>>        Send AddUserError DFERR_CLIENT_SOAP_TRANSFER  
8614>>>>>        Send AddUserError DFERR_CLIENT_SOAP_FAULT     
8615>>>>>        Send AddUserError DFERR_TEXT_TOO_LARGE_FOR_FIELD     
8616>>>>>        Send AddUserError DFERR_WINPRINT
8617>>>>>        Send AddUserError DFERR_CRYSTAL_REPORT
8618>>>>>        Send AddUserError DFERR_MAPI
8619>>>>>        Send AddUserError DFERR_FILE_ACCESS_VIOLATION
8620>>>>>        Send AddUserError DFERR_DATAFLEX_REPORTS
8621>>>>>        Send AddUserError DFERR_CANT_REFIND_RECORD
8622>>>>>        Send AddUserError 999 // This is defined as DD_DEFAULT_ERROR_NUMBER in DataDict.pkg and is the default Field_error
8623>>>>>                              // number of DDs. 
8623>>>>>        Move Self to Error_Object_Id
8624>>>>>    End_Procedure
8625>>>>>
8625>>>>>    Function Help_Context Integer Context_Type Returns String
8627>>>>>       Function_Return (Current_Error_Number(Self))
8628>>>>>    End_Function
8629>>>>>
8629>>>>>    //*** Catch and display error Error#.
8629>>>>>    Procedure Trap_Error Integer Error#
8631>>>>>        Send Trap_Error to ( trappedErrors( Self ) ) Error#
8632>>>>>    End_Procedure
8633>>>>>
8633>>>>>    //*** Pass error Error# on to the regular DataFlex error handler.
8633>>>>>    Procedure Ignore_Error Integer Error#
8635>>>>>        Send Ignore_Error to ( trappedErrors( Self ) ) Error#
8636>>>>>    End_Procedure
8637>>>>>
8637>>>>>    //*** Catch and display all errors.
8637>>>>>    Procedure Trap_All
8639>>>>>        Send Trap_All to ( trappedErrors( Self ) )
8640>>>>>    End_Procedure
8641>>>>>
8641>>>>>    //*** Forward all error to regular DataFlex error handler.
8641>>>>>    Procedure Ignore_All
8643>>>>>        Send Ignore_All to ( trappedErrors( Self ) )
8644>>>>>    End_Procedure
8645>>>>>
8645>>>>>    //*** Build complete error description from Flexerrs and user error message.
8645>>>>>    Function Error_Description Integer Error# String ErrMsg Returns String
8647>>>>>       String Full_Error_Text
8647>>>>>
8647>>>>>       trim ErrMsg to ErrMsg
8648>>>>>>
8648>>>>>       Move (trim(error_text(DESKTOP,Error#))) to Full_Error_Text
8649>>>>>
8649>>>>>       If (ErrMsg<>"") Begin
8651>>>>>
8651>>>>>         If ( ( Full_Error_Text<>"" ) and ;                 error_text_available( DESKTOP, Error# ) ) Begin
8653>>>>>             // Make sure last character of error text is a separating symbol.
8653>>>>>             // if not, add a "." So we have format of "error-text. error-detail"
8653>>>>>             If ( pos(right(Full_error_text,1),".,:;")=0 ) ;                 Move (Full_Error_Text - ".") to Full_Error_Text
8656>>>>>             Move (Full_Error_Text * ErrMsg) to Full_Error_Text
8657>>>>>        End
8657>>>>>>
8657>>>>>            Else ;             Move ErrMsg to Full_Error_Text
8659>>>>>
8659>>>>>          End
8659>>>>>>
8659>>>>>
8659>>>>>       Function_Return Full_Error_Text
8660>>>>>    End_Function
8661>>>>>
8661>>>>>    //** return true if an error number is critical
8661>>>>>    Function Is_Critical Integer Error# Returns Integer
8663>>>>>       Function_Return (".3.10.18.19.20.21.22.43.70.72.74.75.78.80.97.";             contains ("."+String(Error#)+"."))
8664>>>>>    End_Function
8665>>>>>    
8665>>>>>    // adds a user error to the array
8665>>>>>    Procedure AddUserError Integer iError
8667>>>>>        Integer[] UserErrors
8668>>>>>        Get pUserErrorsArray to UserErrors
8669>>>>>        // We assume that there are few enough user errors to worry about speed of finding
8669>>>>>        // the an array item. It always does a linear seach, which should be plenty fast.
8669>>>>>        If (SearchArray(iError,UserErrors)=-1) Begin
8671>>>>>            Move iError to UserErrors[SizeOfArray(UserErrors)]
8672>>>>>            Set pUserErrorsArray to UserErrors
8673>>>>>        End
8673>>>>>>
8673>>>>>    End_Procedure
8674>>>>>    
8674>>>>>    // removes an error from the user array
8674>>>>>    Procedure RemoveUserError Integer iError
8676>>>>>        Integer[] UserErrors
8677>>>>>        Integer iIndex iSize
8677>>>>>        Get pUserErrorsArray to UserErrors
8678>>>>>        Move (SearchArray(iError,UserErrors)) to iIndex
8679>>>>>        If (iIndex<>-1) Begin
8681>>>>>            // replace the removed error with the last error and resize the array
8681>>>>>            Move (SizeOfArray(UserErrors)) to iSize
8682>>>>>            Move UserErrors[iSize-1] to UserErrors[iIndex]
8683>>>>>            Set pUserErrorsArray to (ResizeArray(UserErrors,iSize-1))
8684>>>>>        End
8684>>>>>>
8684>>>>>    End_Procedure
8685>>>>>
8685>>>>>    // removes all user errors
8685>>>>>    Procedure RemoveAllUserErrors
8687>>>>>        Integer[] UserErrors
8688>>>>>        Set pUserErrorsArray to UserErrors
8689>>>>>    End_Procedure
8690>>>>>
8690>>>>>    // returns true if this is an unhandled error (i.e., not a user error
8690>>>>>    Function IsUnhandledError Integer iError Returns Boolean
8692>>>>>        Integer[] UserErrors
8693>>>>>        Get pUserErrorsArray to UserErrors
8694>>>>>        Function_Return (SearchArray(iError,UserErrors)=-1)
8695>>>>>    End_Function
8696>>>>>    
8696>>>>>    Procedure UnhandledErrorDisplay Integer iErrorLine String sMessage 
8698>>>>>        String sCaption sCRLF
8698>>>>>        Move (Character(13)+Character(10)) to sCRLF
8699>>>>>        Get psUnhandledErrorCaption to sCaption
8700>>>>>        Move (Replaces("\n",sMessage,sCRLF)) to sMessage
8701>>>>>        Move (Replaces("\"+sCRLF, sMessage, "\n")) to sMessage
8702>>>>>        ErrorDisplay iErrorLine sMessage sCaption C_$OK C_$Copy
8703>>>>>    End_Procedure
8704>>>>>
8704>>>>>    //*** Handle error event, displaying error info to user.
8704>>>>>    Procedure Error_Report Integer ErrNum Integer Err_Line String ErrMsg
8706>>>>>       Integer iReply iIcon
8706>>>>>       String  sErrorText sMess
8706>>>>>       String  sSource sCaption
8706>>>>>       Integer iSrcPos iSrc iTxtLen
8706>>>>>       Boolean bIsUnhandled bUnhandledSupport bCritical bVerbose
8706>>>>>       
8706>>>>>       If (Error_processing_State(Self)) Begin // don't allow error
8708>>>>>          Procedure_Return                     // recursion
8709>>>>>       End
8709>>>>>>
8709>>>>>
8709>>>>>       Set Error_Processing_State to True // we are now in an error reporting state
8710>>>>>
8710>>>>>       Set Current_Error_Number to ErrNum
8711>>>>>       Set Error_Line_Number    to Err_Line
8712>>>>>
8712>>>>>       // if this is false, this will work old-style -- all errors go through message box
8712>>>>>       Get pbUnhandledErrorSupport to bUnhandledSupport
8713>>>>>       
8713>>>>>       Get Is_Critical errnum to bCritical
8714>>>>>       Get IsUnhandledError ErrNum to bIsUnhandled
8715>>>>>
8715>>>>>       
8715>>>>>       //
8715>>>>>       //   Changes made so find errors don't report - just beep
8715>>>>>       //
8715>>>>>
8715>>>>>       If ( Bell_On_find_Error_State(Self) and ;            ErrNum=DFERR_FIND_PRIOR_BEG_OF_FILE or ErrNum=DFERR_FIND_PAST_END_OF_FILE) Begin
8717>>>>>          Send Bell
8718>>>>>       End
8718>>>>>>
8718>>>>>       Else If not ( isTrapped( TrappedErrors( Self ), ErrNum ) ) Begin
8721>>>>>          // if trapped do nothing
8721>>>>>
8721>>>>>          // We used to forward send. Since this is based on array, it does not understand this message, the forward was
8721>>>>>          // not understood. Since arrays don't delegate or error, nothing happened.
8721>>>>>          // An easier way to do nothing, is to do nothing, hence this line if removed
8721>>>>>          //forward send Error_Report ErrNum Err_Line ErrMsg
8721>>>>>       End
8721>>>>>>
8721>>>>>       Else Begin
8722>>>>>
8722>>>>>         // See if source information is provided (Source = module.function). If so remove
8722>>>>>         // as detail. Must find last instance of this in string
8722>>>>>         Move (pos(C_ErrorContextSourceText,ErrMsg)) to iSrc
8723>>>>>         If iSrc Begin
8725>>>>>            Move (iSrc-1) to iSrcPos
8726>>>>>            Move (length(C_ErrorContextSourceText)) to  iTxtLen
8727>>>>>            Move ErrMsg to sSource
8728>>>>>            Repeat // this makes sure we find last instance of this
8728>>>>>>
8728>>>>>                Move (remove(sSource, 1, iSrc-1 + iTxtLen )) to sSource // right part of string
8729>>>>>                Move (pos(C_ErrorContextSourceText,sSource)) to iSrc           // see if it was the last
8730>>>>>                If iSrc ;                                               // if not, track length                   Move (iSrcPos + iTxtLen + iSrc-1) to iSrcPos
8733>>>>>            Until (iSrc=0)
8735>>>>>            Move (trim(left(ErrMsg,iSrcPos))) to ErrMsg
8736>>>>>            If (right(ErrMsg,1)=',') ;               Move (left(ErrMsg,length(ErrMsg)-1)) to ErrMsg
8739>>>>>         End
8739>>>>>>
8739>>>>>         
8739>>>>>         // the caption normally used for handled user errors
8739>>>>>         Get psUserErrorCaption to sCaption
8740>>>>>         // if an operator error this may be a Procedure UserError situation where the
8740>>>>>         // caption is passed in the error text. If so, get the caption
8740>>>>>         If (ErrNum=DFERR_OPERATOR) Begin
8742>>>>>             Move (pos(C_ErrorCaption,ErrMsg)) to iSrc
8743>>>>>             If iSrc Begin
8745>>>>>                Move (length(C_ErrorCaption)) to  iTxtLen
8746>>>>>                Move (remove(ErrMsg, 1, iSrc-1 + iTxtLen )) to sCaption
8747>>>>>                Move (Left(ErrMsg,iSrc-1)) to ErrMsg
8748>>>>>             End
8748>>>>>>
8748>>>>>         End
8748>>>>>>
8748>>>>>
8748>>>>>         Get Error_Description ErrNum ErrMsg to sErrorText
8749>>>>>
8749>>>>>         // if the error source is identified we can get extended error
8749>>>>>         // text for our error message
8749>>>>>         If ghoErrorSource Begin
8751>>>>>            Get extended_error_Message of ghoErrorSource to sMess
8752>>>>>            If sMess ne '' ;               Move (sErrorText + "\n\n" + sMess ) to sErrorText
8755>>>>>         End
8755>>>>>>
8755>>>>>         
8755>>>>>         If (bUnhandledSupport) Begin
8757>>>>>             // as of 14.1, this is the preferred way to do errors
8757>>>>>             If ( bCritical or bIsUnhandled) Begin
8759>>>>>                 Move ( sErrorText + "\n\n" + C_$Error + ":" * String(ErrNum) ) to sErrorText
8760>>>>>                 If (sSource<>"") Begin
8762>>>>>                    Move (sErrorText + "\n" + C_$ErrorSource +" =" * sSource) to sErrorText
8763>>>>>                 End
8763>>>>>>
8763>>>>>             End
8763>>>>>>
8763>>>>>             Else If (pbShowErrorNumber(Self)) Begin
8766>>>>>                  // if a user error, we provide a way to see error numbers.
8766>>>>>                  Move ( sErrorText + "\n\n" + C_$Error + ":" * String(ErrNum) ) to sErrorText
8767>>>>>             End
8767>>>>>>
8767>>>>>         End
8767>>>>>>
8767>>>>>         Else Begin
8768>>>>>             // we get here if we want it to work the old (less good) way. This is provided
8768>>>>>             // only for backwards compatibility. All errors go through the message box
8768>>>>>             Get Verbose_State to bVerbose
8769>>>>>             If (bVerbose)  Begin
8771>>>>>                 Move ( sErrorText + "\n\n" + SFormat(C_$TechnicalDetails, ErrNum, Err_Line) ) to sErrorText
8772>>>>>                 If (sSource<>"") Begin
8774>>>>>                    Move (sErrorText + "\n" + C_$ErrorSource +" =" * sSource) to sErrorText
8775>>>>>                 End
8775>>>>>>
8775>>>>>             End
8775>>>>>>
8775>>>>>         End
8775>>>>>>
8775>>>>>         
8775>>>>>         If ( (bCritical or bIsUnhandled) and bUnhandledSupport) Begin
8777>>>>>             Send UnhandledErrorDisplay Err_Line sErrorText
8778>>>>>         End
8778>>>>>>
8778>>>>>         Else Begin
8779>>>>>             Move (If(bCritical,MB_IconHand,MB_IconExclamation)) to iIcon
8780>>>>>             Get Message_Box sErrorText sCaption MB_Ok iIcon to iReply
8781>>>>>         End
8781>>>>>>
8781>>>>>
8781>>>>>         // abort on critical errors
8781>>>>>         If bCritical Abort
8784>>>>>
8784>>>>>       End
8784>>>>>>
8784>>>>>       Move 0 to ghoErrorSource
8785>>>>>       Set Error_Processing_State to False // no longer reporting an error
8786>>>>>    End_Procedure
8787>>>>>
8787>>>>>
8787>>>>>    // JJT- Note if you are using the WINDAF windows help system
8787>>>>>    //      the following functions are not used.
8787>>>>>
8787>>>>>    // The functions below are used to construct a general help
8787>>>>>    // name for errors that are generated by the system.  If processing
8787>>>>>    // comes here, then there was no module specific help found.  These
8787>>>>>    // functions will provide a more general help name that appears in
8787>>>>>    // the form of SYSTEM..ERROR:#.  All global errors should be
8787>>>>>    // places in the help file under this application and module name.
8787>>>>>
8787>>>>>    //*** Returns "ERROR:errornum" to supply error help.
8787>>>>>    Function Help_Name Returns String
8789>>>>>       Function_Return (Append("ERROR:",lastErr))
8790>>>>>    End_Function
8791>>>>>
8791>>>>>    Function Application_Name Returns String
8793>>>>>       Function_Return 'SYSTEM'
8794>>>>>    End_Function
8795>>>>>
8795>>>>>    Function Module_Name Returns String
8797>>>>>       Function_Return ''
8798>>>>>    End_Function
8799>>>>>End_Class
8800>>>>>
8800>>>>>Object Error_Info_Object is a ErrorSystem
8802>>>>>End_Object
8803>>>>>
8803>>>>>
8803>>>>>Procedure UserError Global String sMessage String sCaption
8805>>>>>    String sCapt
8805>>>>>    If (Error_Object_Id=0) Begin
8807>>>>>        Error DFERR_PROGRAM "No Error Handler"
8808>>>>>>
8808>>>>>        Procedure_Return
8809>>>>>    End
8809>>>>>>
8809>>>>>    
8809>>>>>    // Accept not passing a caption in which case the error handler's
8809>>>>>    // default caption. It had been the intention to require a caption ("" if none)
8809>>>>>    // but having no caption kind of worked where the caption would be "0". Since it
8809>>>>>    // kind of worked, I don't want to remove this which might generate runtime errors.
8809>>>>>    If (num_arguments>1) Begin
8811>>>>>        Move sCaption to sCapt
8812>>>>>    End
8812>>>>>>
8812>>>>>    
8812>>>>>    Error DFERR_OPERATOR (sMessage + If(sCapt<>"",C_ErrorCaption + sCapt,""))
8813>>>>>>
8813>>>>>    
8813>>>>>End_Procedure
8814>>>Use tWinStructs.pkg
8814>>>
8814>>>Register_Function phoWorkspace Returns Handle
8814>>>Register_Function phoCommandLine Returns Handle
8814>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
8814>>>Register_Function GetApplicationName Returns String
8814>>>Register_Function GetApplicationFileName Returns String
8814>>>
8814>>>Register_Function Statusbar_State Returns Integer
8814>>>Register_Function Toolbar_State Returns Integer
8814>>>Register_Procedure Set Statusbar_State
8814>>>Register_Procedure Set Toolbar_State
8814>>>
8814>>>Class cApplication is a cObject
8815>>>    Procedure Construct_Object
8817>>>        Forward Send Construct_Object
8819>>>
8819>>>        Move self To ghoApplication
8820>>>
8820>>>        Property Handle phoVersionInfo
8821>>>        Property Handle phoWorkspace
8822>>>        Property Handle phoCommandLine
8823>>>        Property Handle phoMainPanel       // main panel will set this for us.
8824>>>        Property String psHelpFile         // type of file is determined by peHelpType
8825>>>        Property Integer peHelpType htWinHelp // htNoHelp htHtmlHelp htWinHelp
8826>>>
8826>>>        Property String psCompany "Data Access Worldwide"
8827>>>        Property String psProduct "DataFlex Applications"
8828>>>        Property String psVersion C_DFVersion
8829>>>        Property String psProgram (Module_Name(desktop))
8830>>>        
8830>>>        // set to '' to stop the auto open workspace behavior
8830>>>        Property String psAutoOpenWorkspace 'Config.ws' 
8831>>>
8831>>>
8831>>>        Property Boolean pbPreserveEnvironment True
8832>>>
8832>>>        Object oCommandLine is a cCommandLine
8834>>>            delegate Set phoCommandLine To self
8836>>>        End_Object
8837>>>
8837>>>        Object oWorkspace is a cWorkspace
8839>>>            delegate Set phoWorkspace To self
8841>>>        End_Object
8842>>>
8842>>>        Object oVersionInfo is a cVersionInfo
8844>>>            delegate Set phoVersionInfo To self
8846>>>            Send DoCreate (GetApplicationFileName(parent(self)))
8847>>>        End_Object
8848>>>        
8848>>>        Set pbUseWindowsFont to True
8849>>>
8849>>>    End_Procedure
8850>>>    
8850>>>    Procedure Destroy_Object
8852>>>        If (ghoApplication=Self) Begin
8854>>>            Move 0 to ghoApplication
8855>>>        End
8855>>>>
8855>>>        Forward Send Destroy_Object
8857>>>    End_Procedure
8858>>>
8858>>>    //************************************************************************************
8858>>>    // Get/Set pbEnterKeyAsTabKey
8858>>>    // Determines if the Enter key should act like the Tab key (and send msg_Next)
8858>>>    // The use of a global variable, gbKEnterNext, makes this an application-wide property
8858>>>    //************************************************************************************
8858>>>    Procedure Set pbEnterKeyAsTabKey Boolean bNext
8860>>>        Move bNext to gbKEnterNext
8861>>>    End_Procedure
8862>>>
8862>>>    Function pbEnterKeyAsTabKey Returns Boolean
8864>>>        Function_Return gbKEnterNext
8865>>>    End_Function
8866>>>
8866>>>    Procedure DoLoadEnvironment Handle hoContainer Boolean bProgram
8868>>>// not used with webapp
8868>>>        Handle hoRegistry hoCommandBars
8868>>>        Handle hMonitor
8868>>>        Integer iError cxy
8868>>>        tWinWindowPlacement WindowPlacement
8868>>>        tWinWindowPlacement WindowPlacement
8868>>>        String sKey
8868>>>        Boolean bSuccess
8868>>>        String sObjectName
8868>>>
8868>>>        If (pbPreserveEnvironment(self)) Begin
8870>>>            Get Create U_cRegistry To hoRegistry
8871>>>            Set pfAccessRights of hoRegistry To KEY_READ
8872>>>
8872>>>            Get RegistryKeyString To sKey
8873>>>
8873>>>            If (bProgram = False) Begin
8875>>>                Move (sKey +"\WINDOWS") To sKey
8876>>>                Get Object_Label of hoContainer To sObjectName  // just get the local name
8877>>>                Move (sKey +"\" +sObjectName) To sKey
8878>>>            End
8878>>>>
8878>>>            Else ;                Move (sKey + "\Preferences") To sKey
8880>>>
8880>>>            Get OpenKey of hoRegistry sKey To bSuccess
8881>>>
8881>>>            If bSuccess Begin
8883>>>                If (ValueExists(hoRegistry, 'Placement')) Begin
8885>>>                    Get ReadBinary of hoRegistry "Placement" (AddressOf(WindowPlacement)) (SizeOfType(tWinWindowPlacement)) to bSuccess
8886>>>                    If bSuccess Begin
8888>>>                        // Do not restore size if the window is not resizable
8888>>>                        If (Border_Style(hoContainer) <> BORDER_THICK) Begin
8890>>>                            // restore always works with outer size
8890>>>                            Get GuiWindowSize     of hoContainer to cxy
8891>>>                            Move (WindowPlacement.NormalPosition.left + Low(cxy)) to WindowPlacement.NormalPosition.right 
8892>>>                            Move (WindowPlacement.NormalPosition.top + Hi(cxy)) to WindowPlacement.NormalPosition.bottom
8893>>>                        End
8893>>>>
8893>>>                        
8893>>>                        // Test that the main window's placement location will appear on some connected monitor. If none
8893>>>                        // of the main window is visible then set the location to 0,0 and adjust the size....
8893>>>                        If (bProgram) Begin
8895>>>                            // Test the top left point
8895>>>                            Move (MonitorFromPoint(WindowPlacement.NormalPosition.left, WindowPlacement.NormalPosition.top, MONITOR_DEFAULTONNULL)) to hMonitor
8896>>>                            
8896>>>                            If (hMonitor = 0) Begin
8898>>>                                // test the bottom right point
8898>>>                                Move (MonitorFromPoint(WindowPlacement.NormalPosition.right, WindowPlacement.NormalPosition.bottom, MONITOR_DEFAULTONNULL)) to hMonitor
8899>>>                            End
8899>>>>
8899>>>                            
8899>>>                            // hMonitor = 0 means that the window location is not in any current monitor (probably the monitor layout has changed)
8899>>>                            // or that the window begins and ends outside all monitors (even though it may span across some monitor). We will adjust!
8899>>>                            If (hMonitor = 0) Begin   
8901>>>                                Send ResetWindowPos (&WindowPlacement.NormalPosition)
8902>>>                            End
8902>>>>
8902>>>                        End
8902>>>>
8902>>>
8902>>>                        // Set the placement
8902>>>                        Move (SetWindowPlacement(Window_Handle(hoContainer), AddressOf(WindowPlacement))) to bSuccess
8903>>>                    End
8903>>>>
8903>>>                End
8903>>>>
8903>>>                If bProgram Begin
8905>>>                    Get phoCommandBars of hoContainer to hoCommandBars
8906>>>                    If not hoCommandBars Begin
8908>>>                        If (ValueExists(hoRegistry, 'IsStatusBarVisible')) ;                            Set Statusbar_State of hoContainer to (ReadDword(hoRegistry, 'IsStatusBarVisible'))
8911>>>                        If (ValueExists(hoRegistry, 'IsToolBarVisible'))   ;                            Set Toolbar_State   of hoContainer to (ReadDword(hoRegistry, 'IsToolBarVisible'))
8914>>>                    End
8914>>>>
8914>>>                End
8914>>>>
8914>>>
8914>>>                Send CloseKey of hoRegistry
8915>>>            End
8915>>>>
8915>>>
8915>>>            Send Destroy of hoRegistry
8916>>>        End
8916>>>>
8916>>>    End_Procedure
8917>>>
8917>>>    Procedure DoSaveEnvironment Handle hoContainer Boolean bProgram
8919>>>// not used with webapp
8919>>>        Handle hoRegistry 
8919>>>        Integer iError
8919>>>        tWinWindowPlacement WindowPlacement
8919>>>        tWinWindowPlacement WindowPlacement
8919>>>        String sKey
8919>>>        Boolean bSuccess
8919>>>        Integer eShowCmd
8919>>>        String sObjectName
8919>>>
8919>>>        If (pbPreserveEnvironment(self)) Begin
8921>>>            Get Create U_cRegistry To hoRegistry
8922>>>            Get RegistryKeyString To sKey
8923>>>
8923>>>            If (bProgram = False) Begin
8925>>>                Move (sKey +"\WINDOWS") To sKey
8926>>>                Get Object_Label of hoContainer To sObjectName  // just get the local name
8927>>>                Move (sKey +"\" +sObjectName) To sKey
8928>>>            End
8928>>>>
8928>>>            Else ;                Move (sKey +"\Preferences") To sKey
8930>>>
8930>>>            Get CreateKey of hoRegistry sKey To iError
8931>>>            If (iError = 0) Begin
8933>>>                Move (SizeOfType(tWinWindowPlacement)) to WindowPlacement.length
8934>>>                Move (GetWindowPlacement(Window_Handle(hoContainer), AddressOf(WindowPlacement))) to bSuccess
8935>>>                If bSuccess Begin
8937>>>                    // if minimized, assume restored, as we don't want to restart minimized!
8937>>>                    If (WindowPlacement.showCmd = SW_SHOWMINIMIZED) Begin
8939>>>                        Move SW_SHOWNORMAL to WindowPlacement.showCmd
8940>>>                    End
8940>>>>
8940>>>                    Send WriteBinary of hoRegistry "Placement" (AddressOf(WindowPlacement)) WindowPlacement.length
8941>>>                End
8941>>>>
8941>>>
8941>>>                If bProgram Begin
8943>>>                    Send WriteDword of hoRegistry 'IsStatusBarVisible' (Statusbar_State(hoContainer))
8944>>>                    Send WriteDword of hoRegistry 'IsToolBarVisible'   (Toolbar_State(hoContainer))
8945>>>                End
8945>>>>
8945>>>
8945>>>
8945>>>                Send CloseKey of hoRegistry
8946>>>            End
8946>>>>
8946>>>
8946>>>            Send Destroy of hoRegistry
8947>>>        End
8947>>>>
8947>>>    End_Procedure
8948>>>    
8948>>>
8948>>>    Procedure ResetWindowPos tWinRect ByRef WindowPos
8950>>>        Integer ixySize ixSize iySize
8950>>>        Integer ixOffset iyOffset
8950>>>        
8950>>>        // first calculate the offset needed to move onto the main monitor at 0,0
8950>>>        Move (0 - WindowPos.left) to ixOffset
8951>>>        Move (0 - WindowPos.top) to iyOffset
8952>>>         
8952>>>        Move 0 to WindowPos.left
8953>>>        Move 0 to WindowPos.top
8954>>>        
8954>>>        Move (WindowPos.right + ixOffset) to WindowPos.right
8955>>>        Move (WindowPos.bottom + iyOffset) to WindowPos.bottom
8956>>>    
8956>>>        // also make sure that the size of the window is <= the size of the main monitor
8956>>>        Move (GUIScreen_Size(1)) to ixySize    // parameter of 1 means return "available" screen size
8957>>>        Move (low(ixySize))      to ixSize
8958>>>        Move (hi(ixySize))       to iySize
8959>>>        
8959>>>        Move (ixSize min WindowPos.right) to WindowPos.right
8960>>>        Move (iySize min WindowPos.bottom) to WindowPos.bottom
8961>>>    End_Procedure
8962>>>
8962>>>
8962>>>    Function RegistryKeyString Returns String
8964>>>        String sCompany sProduct sVersion sProgram
8964>>>
8964>>>        Get psCompany To sCompany
8965>>>        Get psProduct To sProduct
8966>>>        Get psVersion To sVersion
8967>>>        Get psProgram To sProgram
8968>>>
8968>>>        If (sCompany = "") Move "Data Access Worldwide" to sCompany
8971>>>        If (sProduct = "") Move "DataFlex Applications" to sProduct
8974>>>        If (sVersion = "") Move C_DFVersion             to sVersion
8977>>>        If (sProgram ="") Move (Module_Name(desktop))   to sProgram
8980>>>
8980>>>        Function_Return ("SOFTWARE\" +sCompany +"\" +sProduct +"\" +sVersion +"\" +sProgram)
8981>>>    End_Function
8982>>>
8982>>>    Procedure WriteString String sSubKey String sValueName String sValueData
8984>>>        String sKey
8984>>>        Handle hoRegistry
8984>>>        Integer iError
8984>>>
8984>>>        Get Create U_cRegistry To hoRegistry
8985>>>        Get RegistryKeyString To sKey
8986>>>        If (sSubKey <>"") Move (sKey +'\' +sSubKey) To sKey
8989>>>        Get CreateKey of hoRegistry sKey To iError
8990>>>        If (iError = 0) Begin
8992>>>            Send WriteString of hoRegistry sValueName sValueData
8993>>>            Send CloseKey of hoRegistry
8994>>>        End
8994>>>>
8994>>>
8994>>>        Send Destroy of hoRegistry
8995>>>    End_Procedure
8996>>>    Procedure WriteDword String sSubKey String sValueName Dword dwValueData
8998>>>        String sKey
8998>>>        Handle hoRegistry
8998>>>        Integer iError
8998>>>
8998>>>        Get Create U_cRegistry To hoRegistry
8999>>>        Get RegistryKeyString To sKey
9000>>>        If (sSubKey <>"") Move (sKey +'\' +sSubKey) To sKey
9003>>>        Get CreateKey of hoRegistry sKey To iError
9004>>>        If (iError = 0) Begin
9006>>>            Send WriteDword of hoRegistry sValueName dwValueData
9007>>>            Send CloseKey of hoRegistry
9008>>>        End
9008>>>>
9008>>>
9008>>>        Send Destroy of hoRegistry
9009>>>    End_Procedure
9010>>>    Procedure WriteBinary String sSubKey String sValueName Address aValueData Integer iDataLength
9012>>>        String sKey
9012>>>        Handle hoRegistry
9012>>>        Integer iError
9012>>>
9012>>>        Get Create U_cRegistry To hoRegistry
9013>>>        Get RegistryKeyString To sKey
9014>>>        If (sSubKey <>"") Move (sKey +'\' +sSubKey) To sKey
9017>>>        Get CreateKey of hoRegistry sKey To iError
9018>>>        If (iError = 0) Begin
9020>>>            Send WriteBinary of hoRegistry sValueName aValueData iDataLength
9021>>>            Send CloseKey of hoRegistry
9022>>>        End
9022>>>>
9022>>>
9022>>>        Send Destroy of hoRegistry
9023>>>    End_Procedure
9024>>>
9024>>>    // returns true if both sub-key and value exists.
9024>>>    Function ValueExists string sSubKey string sValueName returns Boolean
9026>>>        String sKey
9026>>>        Handle hoRegistry
9026>>>        Boolean bOK
9026>>>        Get Create U_cRegistry To hoRegistry
9027>>>        Get RegistryKeyString To sKey
9028>>>        If (sSubKey <>"") Move (sKey +'\' +sSubKey) To sKey
9031>>>        Get OpenKey of hoRegistry sKey To bOk
9032>>>        If (bOK) Begin
9034>>>           Move (ValueExists(hoRegistry, sValueName)) TO bOk
9035>>>           Send CloseKey of hoRegistry
9036>>>        End
9036>>>>
9036>>>        Send Destroy of hoRegistry
9037>>>        Function_Return bOk
9038>>>    End_Function
9039>>>
9039>>>    Function ReadString String sSubKey String sValueName string sDefault Returns String
9041>>>        String sKey sData
9041>>>        Handle hoRegistry
9041>>>        Boolean bOK
9041>>>
9041>>>        Move sDefault to sData
9042>>>        Get Create U_cRegistry To hoRegistry
9043>>>        Get RegistryKeyString To sKey
9044>>>        If (sSubKey <>"") Move (sKey +'\' +sSubKey) To sKey
9047>>>        Get OpenKey of hoRegistry sKey To bOk
9048>>>        If (bOK) Begin
9050>>>            If (ValueExists(hoRegistry, sValueName)) ;                Get ReadString of hoRegistry sValueName To sData
9053>>>            Send CloseKey of hoRegistry
9054>>>        End
9054>>>>
9054>>>
9054>>>        Send Destroy of hoRegistry
9055>>>        Function_Return sData
9056>>>    End_Function
9057>>>
9057>>>    Function ReadDword String sSubKey String sValueName dword dwDefault Returns DWord
9059>>>        String sKey
9059>>>        DWord dwData
9059>>>        Handle hoRegistry
9059>>>        Boolean bOK
9059>>>
9059>>>        Move dwDefault to dwData
9060>>>        Get Create U_cRegistry To hoRegistry
9061>>>        Get RegistryKeyString To sKey
9062>>>        If (sSubKey <>"") Move (sKey +'\' +sSubKey) To sKey
9065>>>        Get OpenKey of hoRegistry sKey To bOk
9066>>>        If bOK Begin
9068>>>            If (ValueExists(hoRegistry, sValueName)) ;                Get ReadDword of hoRegistry sValueName To dwData
9071>>>            Send CloseKey of hoRegistry
9072>>>        End
9072>>>>
9072>>>
9072>>>        Send Destroy of hoRegistry
9073>>>        Function_Return dwData
9074>>>    End_Function
9075>>>
9075>>>    Function ReadBinary String sSubKey String sValueName Address aValueData Integer iDataLength Returns Boolean
9077>>>        String sKey
9077>>>        Handle hoRegistry
9077>>>        Boolean bOK bSuccess
9077>>>
9077>>>        Get Create U_cRegistry To hoRegistry
9078>>>        Get RegistryKeyString To sKey
9079>>>        If (sSubKey <>"") Move (sKey +'\' +sSubKey) To sKey
9082>>>        Get OpenKey of hoRegistry sKey To bOk
9083>>>        If bOK Begin
9085>>>            Get ReadBinary of hoRegistry sValueName aValueData iDataLength To bSuccess
9086>>>            Send CloseKey of hoRegistry
9087>>>        End
9087>>>>
9087>>>
9087>>>        Send Destroy of hoRegistry
9088>>>        Function_Return bSuccess
9089>>>    End_Function
9090>>>
9090>>>    Procedure DoOpenWorkspace String sWorkspace
9092>>>        // Tries to open in this order:
9092>>>        // 1) if absolute path, use that; otherwise
9092>>>        // 2) try to open in the path of the EXE; otherwise
9092>>>        // 3) load it via the Registered list
9092>>>
9092>>>        Integer eOpened
9092>>>        String sError sWSFile
9092>>>        Handle hoWorkspace
9092>>>
9092>>>        // As soon as an open is attempted, the application's object psAutoOpenWorkspace property
9092>>>        // is cleared. This way any attempt to manually open a workspace during its construction,
9092>>>        // which includes OnCreate, will stop the object from attempting to automatically open the
9092>>>        // workspace. This was added to make psAutoOpenWorkspace compatible with older applications.
9092>>>        // Typically these application will open a workspace in OnCreate. If this happens we assume
9092>>>        // that there should be no automatic opening of a worskpace.  
9092>>>        Set psAutoOpenWorkspace to ""
9093>>>        
9093>>>        Get phoWorkspace to hoWorkspace
9094>>>
9094>>>        Get OpenWorkspaceFile of hoWorkspace sWorkspace To eOpened
9095>>>        If (eOpened = wsWorkspaceFileNotFound) Begin
9097>>>            If (IsRegistered(hoWorkspace, sWorkspace) =True) Begin
9099>>>                Get OpenWorkspace of hoWorkspace sWorkspace To eOpened
9100>>>            End
9100>>>>
9100>>>        End
9100>>>>
9100>>>        If (eOpened <> wsWorkspaceOpened) Begin
9102>>>            Get OpenWorkspaceErrorMessage of hoWorkspace eOpened To sError
9103>>>            Get psWorkspaceWSFile of hoWorkspace to sWSFile
9104>>>            Error DFERR_CAPPLICATION (SFormat(C_$TheProgramCannotRun, sWorkspace) + ":\n\n" + if(sWSFile<>"",sWSfile+"\n\n","") +sError)
9105>>>>
9105>>>            Abort
9106>>>>
9106>>>        End
9106>>>>
9106>>>    End_Procedure
9107>>>
9107>>>    Procedure OnCreate
9109>>>        // Event called when the Application object is ready to be used
9109>>>        // to open a Workspace, etc.
9109>>>    End_Procedure
9110>>>
9110>>>    Procedure End_Construct_Object
9112>>>        String sName
9112>>>        Forward Send End_Construct_Object
9114>>>        Send OnCreate
9115>>>        // note that psAutoOpenWorkspace will get cleared of OnCreate attempts to open a workspace
9115>>>        Get psAutoOpenWorkspace to sName
9116>>>        If (sName<>"") Begin
9118>>>            Send DoOpenWorkspace sName
9119>>>        end
9119>>>>
9119>>>    End_Procedure
9120>>>
9120>>>    Function GetApplicationFileName Returns String
9122>>>        // Returns the filename from Windows
9122>>>        Integer iNumChars
9122>>>        String sFilename
9122>>>
9122>>>        Move (Repeat(Character(0), 1024)) To sFileName
9123>>>        Move (GetModuleFileName(0, AddressOf(sFilename), 1024)) To iNumChars
9124>>>
9124>>>        Function_Return (CString(sFilename))
9125>>>    End_Function
9126>>>
9126>>>    Function GetApplicationPath Returns String
9128>>>        // Returns the path of the Application (no trailing "\")
9128>>>        String sApplicationFileName sPath
9128>>>        Boolean bRemoved
9128>>>
9128>>>        Get GetApplicationFileName  To sApplicationFileName
9129>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) To bRemoved
9130>>>        Move (CString(sApplicationFileName)) To sPath
9131>>>
9131>>>        If (Right(sPath, 1) ="\") Move (Left(sPath, Length(sPath) -1)) To sPath
9134>>>        Function_Return sPath
9135>>>    End_Function
9136>>>
9136>>>    Function GetApplicationName Returns String
9138>>>        // Returns the name of the Application (without its Path or Extension)
9138>>>        String sApplicationFileName sApplicationName
9138>>>        Boolean bRemoved
9138>>>        Integer iVoid
9138>>>
9138>>>        Get GetApplicationFileName To sApplicationFileName
9139>>>        Move (ExtractFileName(sApplicationFileName)) To sApplicationName
9140>>>        Move (PathRemoveExtension(AddressOf(sApplicationName))) To iVoid
9141>>>        Function_Return (CString(sApplicationName))
9142>>>    End_Function
9143>>>    
9143>>>    // this just directs to the desktop property. If you are using an application object you are
9143>>>    // encouraged to set this here.
9143>>>    Procedure Set pbUseWindowsFont Boolean bUseWindowsFont
9145>>>        Set pbUseWindowsFont of Desktop to bUseWindowsFont
9146>>>    End_Procedure
9147>>>    
9147>>>    Function pbUseWindowsFont Returns Boolean
9149>>>        Boolean bUseWindowsFont
9149>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
9150>>>        Function_Return bUseWindowsFont
9151>>>    End_Function
9152>>>
9152>>>End_Class
9153>>>
9153>Use MSSqldrv.pkg
Including file: MSSqldrv.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\MSSqldrv.pkg)
9153>>>//*****************************************************************************
9153>>>//*** MSSQLDRV.PKG                                                          ***
9153>>>//***                                                                       ***
9153>>>//*** Author: Ben Weijers                                                   ***
9153>>>//***         Data Access Nederland                                         ***
9153>>>//***         29 June 1998                                                  ***
9153>>>//***                                                                       ***
9153>>>//***                                                                       ***
9153>>>//*** Purpose:                                                              ***
9153>>>//***   Package that declares MS SQL driver constants and functions.        ***
9153>>>//****                                                                      ***
9153>>>//***   This package can be used by developers who want to add Data Access  ***
9153>>>//***   MS SQL Client specific code to a DataFlex application.              ***
9153>>>//***   Updated:  June 4th 2012 (Current CK build: 5.1.0.96)                ***
9153>>>//***             Changed EnumerateServers function to use the highest      ***
9153>>>//***             available SQL Server client driver.                       ***
9153>>>//***             Moved SQL Server client constants from cli.pkg to         ***
9153>>>//***             mssqldrv.pkg                                              ***
9153>>>//***   Updated:  November 6th 2013 (Current CK build: 6.0.0.19)            ***
9153>>>//***             Added constants for SQL Server specific native types      ***
9153>>>//***             ( var...(max) types, money types, datetime types)         ***
9153>>>//*****************************************************************************
9153>>>
9153>>>Use Cli.pkg
Including file: cli.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cli.pkg)
9153>>>>>//*****************************************************************************
9153>>>>>//*** CLI.PKG                                                               ***
9153>>>>>//***                                                                       ***
9153>>>>>//*** Author: Ben Weijers                                                   ***
9153>>>>>//***         Data Access Nederland                                         ***
9153>>>>>//***         10 September 1998                                             ***
9153>>>>>//***                                                                       ***
9153>>>>>//*** Purpose:                                                              ***
9153>>>>>//***   CLI specific functionality. There are several connectivity kits     ***
9153>>>>>//***   based on  SQL/92 CLI. Those are:                                    ***
9153>>>>>//***    - ODBC_DRV  The Data Access CK for ODBC                            ***
9153>>>>>//***    - DB2_DRV   The Data Access CK for DB2                             ***
9153>>>>>//***    - MSSQLDRV  The Data Access CK for Microsoft SQL Server            ***
9153>>>>>//***                                                                       ***
9153>>>>>//***   This package defines the common functionality for all CLI based     ***
9153>>>>>//***   drivers.                                                            ***
9153>>>>>//***                                                                       ***
9153>>>>>//***   Updated:  May 23rd 2008 (Current CK build: 5.0.0.53 )               ***
9153>>>>>//***             Added NULLABLE and DEFAULT attributes for DATETIME type   ***
9153>>>>>//***   Updated:  Apr  6th 2009 (Current CK build: 5.0.0.61 )               ***
9153>>>>>//***             Added DF_DRIVER_MATCH_CLIENT_SERVER_VERSION attribute     ***
9153>>>>>//***                   DF_DRIVER_SQLSERVER_CLIENT_VERSION    attribute     ***
9153>>>>>//***   Updated:  Mar 30th 2012 (Current CK build: 5.1.0.93 )               ***
9153>>>>>//***             Added SQLSERVER2012CLIENT return value for                ***
9153>>>>>//***             DF_DRIVER_SQLSERVER_CLIENT_VERSION attribute              ***
9153>>>>>//***   Updated:  June 4th 2012 (Current CK build: 5.1.0.96)                ***
9153>>>>>//***             Moved SQL Server client constants from cli.pkg to         ***
9153>>>>>//***             mssqldrv.pkg                                              ***
9153>>>>>//***   Updated:  april 23, 2013 (Current CK build: 6.0.0.4)                ***
9153>>>>>//***             Added type mappings attributes                            ***
9153>>>>>//***   Updated:  october 11, 2013 (Current CK build: 6.0.0.18)             ***
9153>>>>>//***             Added DF_FILE_SQL_FILTER_EQ attribute                     ***
9153>>>>>//*****************************************************************************
9153>>>>>
9153>>>>>//*** We are not using ifndef below because that is not supported in Character Mode
9153>>>>>//*** Driver attributes
9153>>>>>
9153>>>>>
9153>>>>>
9153>>>>>
9153>>>>>
9153>>>>>
9153>>>>>
9153>>>>>
9153>>>>>
9153>>>>>//------------------------------------------------------------
9153>>>>>
9153>>>>>
9153>>>>>//-------------------------------------
9153>>>>>
9153>>>>>
9153>>>>>
9153>>>>>//*** Replacement for logical column number that indicates all columns
9153>>>>>
9153>>>>>//*** Possible DF_FILE_GENERATE_RECORD_ID_METHOD values
9153>>>>>
9153>>>>>//*** Possible DF_FIELD_READ_ONLY values
9153>>>>>
9153>>>>>
9153>>>>>//*** Possible DF_DRIVER_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA values
9153>>>>>// #Replace MAP_DF_TO_SQL_TYPE_CK5        1       
9153>>>>>// #Replace MAP_DF_TO_SQL_TYPE_CK6        2   
9153>>>>>
9153>>>>>
9153>>>>>// Moved to Mssqldrv.pkg
9153>>>>>//*** Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
9153>>>>>//#REPLACE SQLSERVERUNKNOWNCLIENT  0
9153>>>>>//#REPLACE SQLSERVER2000CLIENT     8          //   "SQL Server"
9153>>>>>//#REPLACE SQLSERVER2005CLIENT     9          //   "SQL Native Client"
9153>>>>>//#REPLACE SQLSERVER2008CLIENT    10          //   "SQL Server Native Client 10.0"
9153>>>>>//#Replace SQLSERVER2012CLIENT    11          //   "SQL Server Native Client 11.0"
9153>>>>>
9153>>>>>//*** Possible SQL Column type values
9153>>>>>Define SQL_UNKNOWN_TYPE   For    0
9153>>>>>Define SQL_CHAR           For    1
9153>>>>>Define SQL_NUMERIC        For    2
9153>>>>>Define SQL_DECIMAL        For    3
9153>>>>>Define SQL_INTEGER        For    4
9153>>>>>Define SQL_SMALLINT       For    5
9153>>>>>Define SQL_FLOAT          For    6
9153>>>>>Define SQL_REAL           For    7
9153>>>>>Define SQL_DOUBLE         For    8
9153>>>>>Define SQL_DATETIME       For    9
9153>>>>>Define SQL_VARCHAR        For   12
9153>>>>>Define SQL_TYPE_DATE      For   91
9153>>>>>Define SQL_TYPE_TIME      For   92
9153>>>>>Define SQL_TYPE_TIMESTAMP for   93
9153>>>>>// Moved to mssqldrv.pkg
9153>>>>>//Define SQL_TYPE_TIMESTAMP2 for   (-200) //SQL server datetime2 type */
9153>>>>>
9153>>>>>
9153>>>>>Define SQL_DATE           For    9
9153>>>>>Define SQL_INTERVAL       For   10
9153>>>>>Define SQL_TIME           For   10
9153>>>>>Define SQL_TIMESTAMP      For   11
9153>>>>>Define SQL_LONGVARCHAR    For  (-1)
9153>>>>>Define SQL_BINARY         For  (-2)
9153>>>>>Define SQL_VARBINARY      For  (-3)
9153>>>>>Define SQL_LONGVARBINARY  For  (-4)
9153>>>>>Define SQL_BIGINT         For  (-5)
9153>>>>>Define SQL_TINYINT        For  (-6)
9153>>>>>Define SQL_BIT            For  (-7)
9153>>>>>Define SQL_WCHAR          For  (-8)
9153>>>>>Define SQL_WVARCHAR       For  (-9)
9153>>>>>Define SQL_WLONGVARCHAR   For (-10)
9153>>>>>Define SQL_GUID           For (-11)
9153>>>>>
9153>>>>>//*** Driver level attributes
9153>>>>>
9153>>>>>
9153>>>>>//*** Error number constants
9153>>>>>
9153>>>>>
9153>>>>>//*** Call driver function identifiers
9153>>>>>
9153>>>>>
9153>>>>>//*** Init data source types
9153>>>>>
9153>>>>>
9153>>>>>//*** Dummy strings used in the commands
9153>>>>>    String  CLI$StrDummy 255
9153>>>>>    Integer CLI$IntDummy
9153>>>>>
9153>>>>>
9153>>>>>//*****************************************************************************
9153>>>>>//*** CLI_SetConstraint <FileNum> <NewState>                                ***
9153>>>>>//***                                                                       ***
9153>>>>>//***   Setup a constraint for a file.                                      ***
9153>>>>>//*****************************************************************************
9153>>>>>
9153>>>>>
9153>>>>>
9153>>>>>
9153>>>>>//*****************************************************************************
9153>>>>>//*** CLI_Set_Driver_Atrtribute / CLI_Get_Driver_Attribute                  ***
9153>>>>>//***                                                                       ***
9153>>>>>//*** Set or get an attribute at driver level. These attributes, when set,  ***
9153>>>>>//*** will be set for the remainder of the session or until set again. To   ***
9153>>>>>//*** permanently set driver level attributes change the driver             ***
9153>>>>>//*** configuration file.                                                   ***
9153>>>>>//*****************************************************************************
9153>>>>>
9153>>>>>
9153>>>>>
9153>>>>>
9153>>>>>
9153>>>>>
9153>>>>>
9153>>>>>//*****************************************************************************
9153>>>>>//*** Class  : cCLIHandler                                                  ***
9153>>>>>//*** Purpose: An instance of this class can be used as a broker object to  ***
9153>>>>>//***          call several CLI releated methods.                           ***
9153>>>>>//*****************************************************************************
9153>>>>>
9153>>>>>Class cCLIHandler Is An Array
9154>>>>>
9154>>>>>    Procedure Construct_Object Integer iImage
9156>>>>>        Forward Send Construct_object iImage
9158>>>>>
9158>>>>>        Property String  psDriverID       Public ""
9159>>>>>    End_Procedure // Construct_Object
9160>>>>>
9160>>>>>
9160>>>>>
9160>>>>>    //***
9160>>>>>    //*** Fucntion: CKRevsion
9160>>>>>    //*** Purpose : The revsion of a CLI Connectivity Kit
9160>>>>>    //***
9160>>>>>
9160>>>>>    Function CKRevision Returns String
9162>>>>>        Local String  sDriverID
9162>>>>>        Local String  sRevision
9162>>>>>        Local String  sVoid
9162>>>>>        Local Integer iRetval
9162>>>>>
9162>>>>>        Get psDriverID To sDriverID
9163>>>>>        If (sDRiverID <> "") Begin
9165>>>>>            Move (Repeat(" ", 255)) To sRevision
9166>>>>>            Call_Driver 0 sDRiverID Function CLI_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
9171>>>>>        End
9171>>>>>>
9171>>>>>
9171>>>>>        Function_Return sRevision
9172>>>>>    End_Function // CKRevision
9173>>>>>
9173>>>>>
9173>>>>>
9173>>>>>    //***
9173>>>>>    //*** Function: ExtractPartFromRevision
9173>>>>>    //*** Purpose : Extarct the Nth part of a a.b.c.d revsion string.
9173>>>>>    //***
9173>>>>>    //*** Returns : The part version number or -1 if there is no such part number.
9173>>>>>    //***
9173>>>>>
9173>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
9175>>>>>        Local Integer iPartRev
9175>>>>>        Local Integer iCurrentPart
9175>>>>>        Local Integer iSeparatorPos
9175>>>>>
9175>>>>>        If (iPartNum > 4) ;            Function_Return -1
9178>>>>>
9178>>>>>        Move 0 To iCurrentPart
9179>>>>>        Repeat
9179>>>>>>
9179>>>>>            Move (Pos(".", sRevision)) To iSeparatorPos
9180>>>>>            If (iSeparatorPos > 0) Begin
9182>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) To iPartRev
9183>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) To sRevision
9184>>>>>                Increment iCurrentPart
9185>>>>>            End
9185>>>>>>
9185>>>>>            Else If (sRevision <> "") Begin
9188>>>>>                Move sRevision To iPartRev
9189>>>>>                Move "" To sRevision
9190>>>>>                Increment iCurrentPart
9191>>>>>            End
9191>>>>>>
9191>>>>>            Else ;                Move -1 To iPartRev
9193>>>>>        Until (iCurrentPart >= iPartNum Or iPartRev = -1)
9195>>>>>
9195>>>>>        Function_Return iPartRev
9196>>>>>    End_Function // EcxtractPartFromRevision
9197>>>>>
9197>>>>>
9197>>>>>
9197>>>>>    //***
9197>>>>>    //*** Function: CKMajorRevision
9197>>>>>    //*** Purpose : Returns the major revision of the CK
9197>>>>>    //***
9197>>>>>
9197>>>>>    Function CKMajorRevision Returns Integer
9199>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
9200>>>>>    End_Function // CKMajorRevision
9201>>>>>
9201>>>>>
9201>>>>>
9201>>>>>    //***
9201>>>>>    //*** Function: CKMinorRevision
9201>>>>>    //*** Purpose : Returns the minor revision of the CK
9201>>>>>    //***
9201>>>>>
9201>>>>>    Function CKMinorRevision Returns Integer
9203>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
9204>>>>>    End_Function // CKMinorRevision
9205>>>>>
9205>>>>>
9205>>>>>
9205>>>>>    //***
9205>>>>>    //*** Function: CKReleaseRevision
9205>>>>>    //*** Purpose : Returns the release revision of the CK
9205>>>>>    //***
9205>>>>>
9205>>>>>    Function CKReleaseRevision Returns Integer
9207>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
9208>>>>>    End_Function // CKReleaseRevision
9209>>>>>
9209>>>>>
9209>>>>>
9209>>>>>    //***
9209>>>>>    //*** Function: CKBuildRevision
9209>>>>>    //*** Purpose : Returns the major revision of the CK
9209>>>>>    //***
9209>>>>>
9209>>>>>    Function CKBuildRevision Returns Integer
9211>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
9212>>>>>    End_Function // CKBuildRevision
9213>>>>>
9213>>>>>
9213>>>>>
9213>>>>>    //***
9213>>>>>    //*** Function: IsMinimalRevision
9213>>>>>    //*** Purpose : Determines if the CK conforms to a passed minimal revsion.
9213>>>>>    //***
9213>>>>>
9213>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
9215>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_return (TRUE)
9218>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
9221>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_return (TRUE)
9224>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
9227>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_return (TRUE)
9230>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) And iBuild <= CKBuildRevision(Current_object)) ;                    Function_return (TRUE)
9234>>>>>            End
9234>>>>>>
9234>>>>>        End
9234>>>>>>
9234>>>>>
9234>>>>>        Function_Return (FALSE)
9235>>>>>    End_Function // IsMinimalRevision
9236>>>>>
9236>>>>>
9236>>>>>
9236>>>>>    //***
9236>>>>>    //*** Function: RegistrationName
9236>>>>>    //*** Purpose : Returns the Connectiivty Kit registration name.
9236>>>>>    //***
9236>>>>>
9236>>>>>    Function RegistrationName Returns String
9238>>>>>        Local String  sRegistration
9238>>>>>        Local String  sDRiverId
9238>>>>>        Local String  sVoid
9238>>>>>        Local Integer iRetval
9238>>>>>
9238>>>>>        Get psDriverID To sDriverID
9239>>>>>        If (sDRiverID <> "") Begin
9241>>>>>            Move (Repeat(" ", 255)) To sRegistration
9242>>>>>            Call_Driver 0 sDRiverID Function CLI_GETREGNAME Callback 0 Passing sRegistration sVoid 0 Result iRetval
9247>>>>>        End
9247>>>>>>
9247>>>>>
9247>>>>>        Function_Return sRegistration
9248>>>>>    End_Function // RegistrationName
9249>>>>>
9249>>>>>
9249>>>>>
9249>>>>>    //***
9249>>>>>    //*** Function: SerialNumber
9249>>>>>    //*** Purpose : Returns the Connectiivty Kit serial number.
9249>>>>>    //***
9249>>>>>
9249>>>>>    Function SerialNumber Returns Integer
9251>>>>>        Local String  sDRiverId
9251>>>>>        Local String  sVoid
9251>>>>>        Local Integer iRetval
9251>>>>>
9251>>>>>        Get psDriverID To sDriverID
9252>>>>>        If (sDRiverID <> "") Begin
9254>>>>>            Call_Driver 0 sDRiverID Function CLI_GETSERIALNUM Callback 0 Passing sVoid sVoid 0 Result iRetval
9259>>>>>        End
9259>>>>>>
9259>>>>>
9259>>>>>        Function_Return iRetval
9260>>>>>    End_Function // SerialNumber
9261>>>>>
9261>>>>>
9261>>>>>
9261>>>>>    //***
9261>>>>>    //*** Function: MaxUsers
9261>>>>>    //*** Purpose : Returns the Connectiivty Kit maximum number of users.
9261>>>>>    //***
9261>>>>>
9261>>>>>    Function MaxUsers Returns Integer
9263>>>>>        Local String  sDRiverId
9263>>>>>        Local String  sVoid
9263>>>>>        Local Integer iRetval
9263>>>>>
9263>>>>>        Get psDriverID To sDriverID
9264>>>>>        If (sDRiverID <> "") Begin
9266>>>>>            Call_Driver 0 sDRiverID Function CLI_GETMAXUSERS Callback 0 Passing sVoid sVoid 0 Result iRetval
9271>>>>>        End
9271>>>>>>
9271>>>>>
9271>>>>>        Function_Return iRetval
9272>>>>>    End_Function // MaxUsers
9273>>>>>
9273>>>>>
9273>>>>>
9273>>>>>    //***
9273>>>>>    //*** Procedure: DumpStatus
9273>>>>>    //*** Purpose  : Dump the current status of the drver in the passed disk file.
9273>>>>>    //***
9273>>>>>
9273>>>>>    Procedure DumpStatus String sFileName
9275>>>>>        Local String  sVoid
9275>>>>>        Local String  sDriverID
9275>>>>>        Local Integer iVoid
9275>>>>>
9275>>>>>        Get psDriverID To sDriverID
9276>>>>>        If (sDriverID <> "") ;            Call_driver 0 sDriverID Function CLI_DUMPSTATUS Callback 0 Passing sFileName sVoid iVoid Result iVoid
9283>>>>>    End_Procedure // DumpStatus
9284>>>>>
9284>>>>>
9284>>>>>
9284>>>>>    //***
9284>>>>>    //*** Procedure: ReadConfiguration
9284>>>>>    //*** Purpose  : Reset all driver level configurable attributes to the
9284>>>>>    //***            default value and then reread the configuration.
9284>>>>>    //***
9284>>>>>
9284>>>>>    Procedure ReadConfiguration
9286>>>>>        Local String  sVoid
9286>>>>>        Local String  sDriverID
9286>>>>>        Local Integer iVoid
9286>>>>>
9286>>>>>        Get psDriverID To sDriverID
9287>>>>>        If (sDriverID <> "") ;            Call_driver 0 sDriverID Function CLI_READCONFIGURATION Callback 0 Passing sVoid sVoid iVoid Result iVoid
9294>>>>>    End_Procedure // ReadConfiguration
9295>>>>>
9295>>>>>
9295>>>>>
9295>>>>>    //***
9295>>>>>    //*** Function: TextToRIMValue
9295>>>>>    //*** Purpose : Convert a text to the corresponding
9295>>>>>    //***           Generate_Record_ID_Method attribute value
9295>>>>>    //***
9295>>>>>
9295>>>>>    Function TextToRIMValue String sText Returns Integer
9297>>>>>        If (sText = "None") ;            Function_return RIM_NONE
9300>>>>>        Else If (sText = "Identity Column") ;            Function_return RIM_IDENTITY_COLUMN
9304>>>>>        Else If (sText = "Dispenser Table") ;            Function_return RIM_DISPENSER_TABLE
9308>>>>>        Else If (sText = "External") ;            Function_return RIM_EXTERNAL
9312>>>>>    End_Function // TextToRIMValue
9313>>>>>
9313>>>>>
9313>>>>>
9313>>>>>    //***
9313>>>>>    //*** Function: RIMValueTotext
9313>>>>>    //*** Purpose : Convert a Generate_Record_ID_Method attribute value to the
9313>>>>>    //***           corresponding text.
9313>>>>>    //***
9313>>>>>
9313>>>>>    Function RIMValueToText Integer iAttrValue Returns String
9315>>>>>        If (iAttrValue = RIM_NONE) ;            Function_return "None"
9318>>>>>        Else If (iAttrValue = RIM_IDENTITY_COLUMN) ;            Function_return "Identity Column"
9322>>>>>        Else If (iAttrValue = RIM_DISPENSER_TABLE) ;            Function_return "Dispenser Table"
9326>>>>>        Else If (iAttrValue = RIM_EXTERNAL) ;            Function_return "External"
9330>>>>>    End_Function // RIMValueToText
9331>>>>>
9331>>>>>
9331>>>>>
9331>>>>>    //***
9331>>>>>    //*** Function: TextToROValue
9331>>>>>    //*** Purpose : Convert a text to the corresponding
9331>>>>>    //***           Generate_Record_ID_Method attribute value
9331>>>>>    //***
9331>>>>>
9331>>>>>    Function TextToROValue String sText Returns Integer
9333>>>>>        If (sText = "No") ;            Function_return RO_NO
9336>>>>>        Else If (sText = "Ignore Change") ;            Function_return RO_IGNORECHANGE
9340>>>>>        Else If (sText = "Accept Change") ;            Function_return RO_ACCEPTCHANGE
9344>>>>>        Else If (sText = "Error On Change") ;            Function_return RO_ERRORONCHANGE
9348>>>>>    End_Function // TextToRIMValue
9349>>>>>
9349>>>>>
9349>>>>>
9349>>>>>    //***
9349>>>>>    //*** Function: ROValueTotext
9349>>>>>    //*** Purpose : Convert a Generate_Record_ID_Method attribute value to the
9349>>>>>    //***           corresponding text.
9349>>>>>    //***
9349>>>>>
9349>>>>>    Function ROValueToText Integer iAttrValue Returns String
9351>>>>>        If (iAttrValue = RO_NO) ;            Function_return "No"
9354>>>>>        Else If (iAttrValue = RO_IGNORECHANGE) ;            Function_return "Ignore Change"
9358>>>>>        Else If (iAttrValue = RO_ACCEPTCHANGE) ;            Function_return "Accept Change"
9362>>>>>        Else If (iAttrValue = RO_ERRORONCHANGE) ;            Function_return "Error On Change"
9366>>>>>    End_Function // RIMValueToText
9367>>>>>
9367>>>>>
9367>>>>>
9367>>>>>    //***
9367>>>>>    //*** Function: LastDriverError
9367>>>>>    //*** Purpose : Return the text f the last error geneated by the driver.
9367>>>>>    //***
9367>>>>>
9367>>>>>    Function LastDriverError Returns String
9369>>>>>        Local String  sDriverID
9369>>>>>        Local String  sLastError
9369>>>>>        Local String  sLastErrorLength
9369>>>>>        Local Integer iLastErrorLength
9369>>>>>        Local Integer iVoid
9369>>>>>
9369>>>>>        //*** Initialize
9369>>>>>        Move "" To sLastError
9370>>>>>
9370>>>>>        Get psDriverID To sDriverID
9371>>>>>        If (sDriverID <> "") Begin
9373>>>>>            //*** Get the text of the last error
9373>>>>>            Move (Repeat(Character(" "), 14)) To sLastErrorlength
9374>>>>>            Call_driver 0 sDriverID Function CLI_GETDRIVERATTRIBUTE Callback 0 Passing sLastErrorLength iVoid DRVR_LASTERRORTEXTLENGTH Result iVoid
9379>>>>>            Move (Left(sLastErrorLength, Pos(Character(0), sLastErrorLength) - 1)) To iLastErrorLength
9380>>>>>
9380>>>>>            If (iLastErrorLength > 0) Begin
9382>>>>>                Move (Repeat(Character(" "), iLastErrorLength + 1)) To sLastError
9383>>>>>                Call_driver 0 sDriverID Function CLI_GETDRIVERATTRIBUTE Callback 0 Passing sLastError iVoid DRVR_LASTERRORTEXT Result iVoid
9388>>>>>                Move (Left(sLastError, Pos(Character(0), sLastError) - 1)) To sLastError
9389>>>>>            End
9389>>>>>>
9389>>>>>        End
9389>>>>>>
9389>>>>>
9389>>>>>        Function_Return sLastError
9390>>>>>    End_Function // LastDriverError
9391>>>>>
9391>>>>>
9391>>>>>
9391>>>>>    //***
9391>>>>>    //*** Function: EnumerateTables
9391>>>>>    //*** Purpose : Enumerate the tables in a database
9391>>>>>    //***
9391>>>>>
9391>>>>>    Function EnumerateTables String sLogin Returns Integer
9393>>>>>        Local String  sDriver
9393>>>>>        Local String  sVoid
9393>>>>>        Local Integer iNumTables
9393>>>>>        Local Integer iVoid
9393>>>>>
9393>>>>>        Get psDriverID To sDriver
9394>>>>>        If (sDriver <> "") ;            Call_driver 0 sDriver Function CLI_ENUMERATE_TABLES Callback 0 Passing sLogin sVoid iVoid Result iNumTables
9401>>>>>
9401>>>>>        Function_Return iNumTables
9402>>>>>    End_Function // EnumerateTables
9403>>>>>
9403>>>>>
9403>>>>>
9403>>>>>    //***
9403>>>>>    //*** Function: TableName
9403>>>>>    //*** Purpose : Returns the name of the table enumerated at the given position
9403>>>>>    //***
9403>>>>>
9403>>>>>    Function TableName Integer iIndex Returns String
9405>>>>>        Local String  sDriver
9405>>>>>        Local String  sTableName
9405>>>>>        Local String  sVoid
9405>>>>>        Local Integer iVoid
9405>>>>>
9405>>>>>        Get psDriverID To sDriver
9406>>>>>        If (sDriver <> "") Begin
9408>>>>>            Move (Repeat(" ", 255)) To sTableName
9409>>>>>            Call_driver 0 sDriver Function CLI_TABLENAME Callback 0 Passing sTableName sVoid iIndex Result iVoid
9414>>>>>        End
9414>>>>>>
9414>>>>>
9414>>>>>        Function_Return sTableName
9415>>>>>    End_Function // TableName
9416>>>>>
9416>>>>>
9416>>>>>
9416>>>>>    //***
9416>>>>>    //*** Function: SchemaName
9416>>>>>    //*** Purpose : Returns the name of the schema of the table enumerated at the given position
9416>>>>>    //***
9416>>>>>
9416>>>>>    Function SchemaName Integer iIndex Returns String
9418>>>>>        Local String  sDriver
9418>>>>>        Local String  sSchemaName
9418>>>>>        Local String  sVoid
9418>>>>>        Local Integer iVoid
9418>>>>>
9418>>>>>        Get psDriverID To sDriver
9419>>>>>        If (sDriver <> "") Begin
9421>>>>>            Move (Repeat(" ", 255)) To sSchemaName
9422>>>>>            Call_driver 0 sDriver Function CLI_TABLESCHEMA Callback 0 Passing sSchemaName sVoid iIndex Result iVoid
9427>>>>>        End
9427>>>>>>
9427>>>>>
9427>>>>>        Function_Return sSchemaName
9428>>>>>    End_Function // SchemaName
9429>>>>>
9429>>>>>
9429>>>>>
9429>>>>>    //***
9429>>>>>    //*** Function: TableType
9429>>>>>    //*** Purpose : Returns the type of the table enumerated at the given position.
9429>>>>>    //***           Types can be "TABLE", "VIEW", "SYSTEM TABLE", "GLOBAL TEMPORARY",
9429>>>>>    //***           "LOCAL TEMPORARY", "ALIAS", "SYNONYM"
9429>>>>>    //***
9429>>>>>
9429>>>>>    Function TableType Integer iIndex Returns String
9431>>>>>        Local String  sDriver
9431>>>>>        Local String  sTableType
9431>>>>>        Local String  sVoid
9431>>>>>        Local Integer iVoid
9431>>>>>
9431>>>>>        Get psDriverID To sDriver
9432>>>>>        If (sDriver <> "") Begin
9434>>>>>            Move (Repeat(" ", 25)) To sTableType
9435>>>>>            Call_driver 0 sDriver Function CLI_TABLETYPE Callback 0 Passing sTableType sVoid iIndex Result iVoid
9440>>>>>        End
9440>>>>>>
9440>>>>>
9440>>>>>        Function_Return sTableType
9441>>>>>    End_Function // TableType
9442>>>>>
9442>>>>>
9442>>>>>
9442>>>>>    //***
9442>>>>>    //*** Function: TableComment
9442>>>>>    //*** Purpose : Returns the comment of the table enumerated at the given position
9442>>>>>    //***
9442>>>>>
9442>>>>>    Function TableComment Integer iIndex Returns String
9444>>>>>        Local String  sDriver
9444>>>>>        Local String  sTableComment
9444>>>>>        Local String  sVoid
9444>>>>>        Local Integer iVoid
9444>>>>>
9444>>>>>        Get psDriverID To sDriver
9445>>>>>        If (sDriver <> "") Begin
9447>>>>>            Move (Repeat(" ", 255)) To sTableComment
9448>>>>>            Call_driver 0 sDriver Function CLI_TABLECOMMENT Callback 0 Passing sTableComment sVoid iIndex Result iVoid
9453>>>>>        End
9453>>>>>>
9453>>>>>
9453>>>>>        Function_Return sTableComment
9454>>>>>    End_Function // TableComment
9455>>>>>
9455>>>>>
9455>>>>>
9455>>>>>    //***
9455>>>>>    //*** Function: EnumerateColumns
9455>>>>>    //*** Purpose : Enumerate the columns in a table
9455>>>>>    //***
9455>>>>>
9455>>>>>    Function EnumerateColumns String sLogin String sTableName Returns Integer
9457>>>>>        Local String  sDriver
9457>>>>>        Local Integer iNumColumns
9457>>>>>        Local Integer iVoid
9457>>>>>
9457>>>>>        Get psDriverID To sDriver
9458>>>>>        If (sDriver <> "") ;            Call_driver 0 sDriver Function CLI_ENUMERATE_COLUMNS Callback 0 Passing sLogin sTablename iVoid Result iNumColumns
9465>>>>>
9465>>>>>        Function_Return iNumColumns
9466>>>>>    End_Function // EnumerateColumns
9467>>>>>
9467>>>>>
9467>>>>>
9467>>>>>    //***
9467>>>>>    //*** Function: ColumnName
9467>>>>>    //*** Purpose : Returns the name of the column enumerated at the given position
9467>>>>>    //***
9467>>>>>
9467>>>>>    Function ColumnName Integer iIndex Returns String
9469>>>>>        Local String  sDriver
9469>>>>>        Local String  sColumnName
9469>>>>>        Local String  sVoid
9469>>>>>        Local Integer iVoid
9469>>>>>
9469>>>>>        Get psDriverID To sDriver
9470>>>>>        If (sDriver <> "") Begin
9472>>>>>            Move (Repeat(" ", 255)) To sColumnName
9473>>>>>            Call_driver 0 sDriver Function CLI_COLUMNNAME Callback 0 Passing sColumnName sVoid iIndex Result iVoid
9478>>>>>        End
9478>>>>>>
9478>>>>>
9478>>>>>        Function_Return sColumnName
9479>>>>>    End_Function // ColumnName
9480>>>>>
9480>>>>>
9480>>>>>
9480>>>>>    //***
9480>>>>>    //*** Function: CLIDFDateToSQLDate
9480>>>>>    //*** Purpose : Convert a DataFlex date to a SQL date using the dummy zero date value.
9480>>>>>    //***
9480>>>>>
9480>>>>>    Function CLIDFDateToSQLDate String sDRiver Date dDFDate Returns String
9482>>>>>        Local String sSQLDate
9482>>>>>        Local Integer iOrgDateFmt
9482>>>>>        Local Integer iOrgDateSep
9482>>>>>
9482>>>>>        //*** Change date format to military, SQL dates are military dates
9482>>>>>        Get_Attribute DF_DATE_FORMAT To iOrgDateFmt
9485>>>>>        Get_Attribute DF_DATE_SEPARATOR To iOrgDateSep
9488>>>>>        Set_Attribute DF_DATE_FORMAT To DF_DATE_MILITARY
9491>>>>>        Set_Attribute DF_DATE_SEPARATOR To (Ascii('-'))
9494>>>>>
9494>>>>>        //*** We only need to convert if the date is 0
9494>>>>>        If (Integer(dDFDate = 0)) ;            CLI_Get_Driver_Attribute sDRiver DRVR_DUMMY_ZERO_DATE_VALUE To sSQLDate
9503>>>>>        Else ;            Move dDFDate To sSQLDate
9505>>>>>
9505>>>>>        //*** Change date format back to original
9505>>>>>        Set_Attribute DF_DATE_FORMAT To iOrgDateFmt
9508>>>>>        Set_Attribute DF_DATE_SEPARATOR To iOrgDateSep
9511>>>>>
9511>>>>>        Function_Return sSQLDate
9512>>>>>    End_Function // CLIDFDateToSQLDate
9513>>>>>
9513>>>>>
9513>>>>>
9513>>>>>    //***
9513>>>>>    //*** Function: CLISQLDateToDFDate
9513>>>>>    //*** Purpose : Convert a SQL date to a DataFlex date using the dummy zero date value.
9513>>>>>    //***
9513>>>>>
9513>>>>>    Function CLISQLDateToDFDate String sDRiver String sSQLDate Returns Date
9515>>>>>        Local Date dDFDate
9515>>>>>        Local String sDummyDateValue
9515>>>>>        Local Integer iOrgDateFmt
9515>>>>>        Local Integer iOrgDateSep
9515>>>>>
9515>>>>>        //*** Change date format to military, SQL dates are military dates
9515>>>>>        Get_Attribute DF_DATE_FORMAT To iOrgDateFmt
9518>>>>>        Get_Attribute DF_DATE_SEPARATOR To iOrgDateSep
9521>>>>>        Set_Attribute DF_DATE_FORMAT To DF_DATE_MILITARY
9524>>>>>        Set_Attribute DF_DATE_SEPARATOR To (Ascii('-'))
9527>>>>>
9527>>>>>        //*** We only need to convert if the date is the dummy zero date value
9527>>>>>        CLI_Get_Driver_Attribute sDRiver DRVR_DUMMY_ZERO_DATE_VALUE To sDummyDateValue
9534>>>>>        If (sDummyDateValue = sSQLDate) ;            Move 0 To dDFDate
9537>>>>>        Else ;            Move sSQLDate To dDFDate
9539>>>>>
9539>>>>>        //*** Change date format back to original
9539>>>>>        Set_Attribute DF_DATE_FORMAT To iOrgDateFmt
9542>>>>>        Set_Attribute DF_DATE_SEPARATOR To iOrgDateSep
9545>>>>>
9545>>>>>        Function_Return dDFDate
9546>>>>>    End_Function // CLISQLDateToDFDate
9547>>>>>
9547>>>>>
9547>>>>>
9547>>>>>    //***
9547>>>>>    //*** Function: RedirectConnection
9547>>>>>    //*** Purpose : Redirect an exisitng connection. The existing connection
9547>>>>>    //***           will point to another database but all tables will stay
9547>>>>>    //***           open!
9547>>>>>    //***
9547>>>>>
9547>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
9549>>>>>        Local String  sDriver
9549>>>>>        Local String  sVoid
9549>>>>>        Local Integer iResult
9549>>>>>        Local Integer iVoid
9549>>>>>
9549>>>>>        Get psDriverID To sDriver
9550>>>>>        If (sDriver <> "") Begin
9552>>>>>            Call_driver 0 sDriver Function CLI_REDIRECTCONNECTION Callback 0 Passing sOldConnection sNewConnection iVoid Result iResult
9557>>>>>        End
9557>>>>>>
9557>>>>>        Function_Return iResult
9558>>>>>    End_Function // RedirectConnect
9559>>>>>
9559>>>>>
9559>>>>>
9559>>>>>    //***
9559>>>>>    //*** Function: CreateConnectionID
9559>>>>>    //*** Purpose : Create a DataFlex side connection id that can be used later on.
9559>>>>>    //***
9559>>>>>
9559>>>>>    Function CreateConnectionID String sID String sConnStr Integer iOpt Returns Integer
9561>>>>>        Local String  sDriver
9561>>>>>        Local Integer iResult
9561>>>>>        Local Integer iOptions
9561>>>>>
9561>>>>>        Get psDriverID to sDriver
9562>>>>>        If (Num_Arguments = 2) ;            Move 0 to iOptions
9565>>>>>        Else ;            Move iOpt to iOptions
9567>>>>>        If (sDriver <> "") Begin
9569>>>>>            Call_Driver 0 sDriver Function CLI_CREATECONNECTIONID Callback 0 Passing sID sConnStr iOptions Result iResult
9574>>>>>        End
9574>>>>>>
9574>>>>>        Function_Return iResult
9575>>>>>    End_Function // CreateConnectionID
9576>>>>>
9576>>>>>
9576>>>>>
9576>>>>>    //***
9576>>>>>    //*** Function: DeleteConnectionID
9576>>>>>    //*** Purpose : Delete a DataFlex side connection id.
9576>>>>>    //***
9576>>>>>
9576>>>>>    Function DeleteConnectionID String sID Integer iIndex Returns Integer
9578>>>>>        Local String  sDriver
9578>>>>>        Local Integer iResult
9578>>>>>        Local String sVoid
9578>>>>>
9578>>>>>        Get psDriverID To sDriver
9579>>>>>        If (sDriver <> "") Begin
9581>>>>>            Call_Driver 0 sDriver Function CLI_DELETECONNECTIONID Callback 0 Passing sID sVoid iIndex Result iResult
9586>>>>>        End
9586>>>>>>
9586>>>>>        Function_Return iResult
9587>>>>>    End_Function // DeleteConnectionID
9588>>>>>
9588>>>>>End_Class // cCLIHandler
9589>>>Use SQL.pkg
Including file: sql.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\sql.pkg)
9589>>>>>//*****************************************************************************
9589>>>>>//*** SQL.pkg                                                               ***
9589>>>>>//***                                                                       ***
9589>>>>>//*** Author: Ben Weijers                                                   ***
9589>>>>>//***         Data Access Wordwide                                          ***
9589>>>>>//***         14 February 2000                                              ***
9589>>>>>//***                                                                       ***
9589>>>>>//*** Purpose:                                                              ***
9589>>>>>//***       Embedded SQL classes for use with Data Access Worldwide CLI     ***
9589>>>>>//***       Connectivty Kits.                                               ***
9589>>>>>//***                                                                       ***
9589>>>>>//*** Last update:                                                          ***
9589>>>>>//***       February 2014. Current CLI Connectivity Kit 6.0.0.28            ***
9589>>>>>//***                                                                       ***
9589>>>>>//*** !! Please Note !!                                                     ***
9589>>>>>//***       -This version of sql.pkg will only work with CLI Connectivity   ***
9589>>>>>//***        Kits 6.0.0.28 or later.                                        ***
9589>>>>>//***       -This version of sql.pkg will no longer function with DataFlex  ***
9589>>>>>//***        character mode (DataFlex 3.2). To use embedded SQL with        ***
9589>>>>>//**         DataFlex character mode, use sqlold.pkg.                       ***
9589>>>>>//***       -This version of sql.pkg no longer contains the embedded SQL    ***
9589>>>>>//***        command interface. The command interface is still available    ***
9589>>>>>//***        in sqlold.pkg                                                  ***
9589>>>>>//***                                                                       ***
9589>>>>>//*** Changes:                                                              ***
9589>>>>>//***       February 2014. CLI Connectivity Kit 6.0.0.28                    ***
9589>>>>>//***                                                                       ***
9589>>>>>//***       Several performances improvements to speed up SQLColumnValue    ***
9589>>>>>//***       and SQLGetData                                                  ***
9589>>>>>//***                                                                       ***
9589>>>>>//***       New functions:                                                  ***
9589>>>>>//***           Function SQLFetchRowValues Returns String[]                 ***
9589>>>>>//***               Fetches a row and returns all columns in an array.      ***
9589>>>>>//***                                                                       ***
9589>>>>>//***           Function SQLFetchResultsetValues Returns String[][]         ***
9589>>>>>//***               Fetches all rows of a result set and returns the        ***
9589>>>>>//***               result set as a 2-dimensial array.                      ***
9589>>>>>//***                                                                       ***
9589>>>>>//*****************************************************************************
9589>>>>>
9589>>>>>Use CLI.pkg
9589>>>>>
9589>>>>>//*** Global storage for results
9589>>>>>Integer SQLResult
9589>>>>>
9589>>>>>//*** Embedded SQL function constants
9589>>>>>Define FUNC_SQLCONNECT             For 1000000
9589>>>>>Define FUNC_SQLFILECONNECT         For 1000001
9589>>>>>Define FUNC_SQLDISCONNECT          For 1000002
9589>>>>>Define FUNC_SQLOPEN                For 1000003
9589>>>>>Define FUNC_SQLCLOSE               For 1000004
9589>>>>>Define FUNC_SQLPREPARE             For 1000005
9589>>>>>Define FUNC_SQLEXECUTE             For 1000006
9589>>>>>Define FUNC_SQLEXECDIRECT          For 1000007
9589>>>>>Define FUNC_SQLFETCH               For 1000008
9589>>>>>Define FUNC_SQLCOLUMNINFO          For 1000009
9589>>>>>Define FUNC_SQLCOLUMNVALUE         For 1000010
9589>>>>>Define FUNC_SQLBINDFILE            For 1000011
9589>>>>>Define FUNC_SQLGETDATA             For 1000012
9589>>>>>Define FUNC_SQLCOLSTRINGATTRIBLEN  For 1000013
9589>>>>>Define FUNC_SQLCOLSTRINGATTRIB     For 1000014
9589>>>>>Define FUNC_SQLCOLINTATTRIB        For 1000015
9589>>>>>Define FUNC_SQLSTMTINTATTRIB       For 1000016
9589>>>>>Define FUNC_SQLSETPROCNAME         For 1000017
9589>>>>>DEfine FUNC_SQLSETPROCARG          For 1000018
9589>>>>>Define FUNC_SQLCALL                For 1000019
9589>>>>>Define FUNC_SQLGETPROCARGLEN       For 1000020
9589>>>>>Define FUNC_SQLGETPROCARG          For 1000021
9589>>>>>Define FUNC_SQLGETPROCRETVALLEN    For 1000022
9589>>>>>Define FUNC_SQLGETPROCRETVAL       For 1000023
9589>>>>>Define FUNC_SQLNEXTRESULTSET       For 1000024
9589>>>>>Define FUNC_SQLBUFFERSTATUS        For 1000025
9589>>>>>Define FUNC_SQLSETPROCSCHEMA       For 1000026
9589>>>>>Define FUNC_SQLGETMESSAGE          For 1000027
9589>>>>>
9589>>>>>//*** Embedded SQL statement attribute constants
9589>>>>>Define SQLSTMTATTRIB_COLUMNCOUNT    For 1
9589>>>>>Define SQLSTMTATTRIB_ROWCOUNT       For 2
9589>>>>>Define SQLSTMTATTRIB_ROWCOUNT_TYPE  For 3
9589>>>>>Define SQLSTMTATTRIB_NUMMESSAGES    For 4
9589>>>>>
9589>>>>>//*** Embedded SQL column attribute constants
9589>>>>>Define SQLCOLATTRIB_SIZE           For 1
9589>>>>>Define SQLCOLATTRIB_LENGTH         For 1
9589>>>>>Define SQLCOLATTRIB_PRECISION      For 2
9589>>>>>Define SQLCOLATTRIB_LABEL          For 3
9589>>>>>Define SQLCOLATTRIB_BASECOLUMNNAME For 4
9589>>>>>Define SQLCOLATTRIB_BASETABLENAME  For 5
9589>>>>>Define SQLCOLATTRIB_SQLTYPE        For 6
9589>>>>>Define SQLCOLATTRIB_NULLABLE       For 7
9589>>>>>Define SQLCOLATTRIB_DFTYPE         For 8
9589>>>>>
9589>>>>>
9589>>>>>
9589>>>>>//*****************************************************************************
9589>>>>>//*** Class  : cSQLStatement                                                ***
9589>>>>>//*** Purpose: Statement object for embedded sql                            ***
9589>>>>>//***                                                                       ***
9589>>>>>//*** Description:                                                          ***
9589>>>>>//***   An object is created for each statement. These will be children     ***
9589>>>>>//***   of cSQLConnection objects which manage the create and destruction   ***
9589>>>>>//***   of these.                                                           ***
9589>>>>>//*****************************************************************************
9589>>>>>
9589>>>>>// Global variables holding last executed embedded SQL connection and statement handles.
9589>>>>>Integer giLastSQLhdbc
9589>>>>>Integer giLastSQLhstmt
9589>>>>>
9589>>>>>Move -1 to giLastSQLhdbc
9590>>>>>Move -1 to giLastSQLhstmt
9591>>>>>
9591>>>>>Struct tSQLColumn
9591>>>>>    Integer iSQLType
9591>>>>>    Integer iSQLSize
9591>>>>>    Integer iSQLPrecision
9591>>>>>    Integer iVariableDataType
9591>>>>>End_Struct
9591>>>>>
9591>>>>>Class cSQLStatement is a cObject
9592>>>>>
9592>>>>>    Procedure Construct_object 
9594>>>>>        Forward Send Construct_object 
9596>>>>>
9596>>>>>        Property Handle  phCLIStatementHandle   0
9597>>>>>        Property Handle  phCLIConnectionHandle  0
9598>>>>>        Property String  psDriverID             ""
9599>>>>>        
9599>>>>>        Property Integer piLastColumn      0
9600>>>>>        Property Integer piLastArgument    0
9601>>>>>        Property Integer piBindFile        0
9602>>>>>        Property Integer piColumnCount     0
9603>>>>>
9603>>>>>        // Allocated buffer for SQLColumnValue. 
9603>>>>>        // Allocated size is size of the largest (not variable length) column
9603>>>>>        Property String  psMaxColValue     ""
9604>>>>>
9604>>>>>        // True if there is at least 1 column with a variable length data type                 
9604>>>>>        Property Integer piHasVariableDataType  0
9605>>>>>
9605>>>>>        // Max size of buffer for variable length data. Default 16000        
9605>>>>>        Property Integer piMaxVariableBufferLength 16000  
9606>>>>>
9606>>>>>        // Allocated buffer for SQLGetData. 
9606>>>>>        Property String  psVariableBuffer  ""
9607>>>>>
9607>>>>>        // Allocated size of psVariableBuffer
9607>>>>>        Property Integer piVariableBufferLength 0
9608>>>>>
9608>>>>>        // Stores column properties of a result set.
9608>>>>>        Property tSQLColumn[] paSQLColumns
9609>>>>>        
9609>>>>>        // piFetchResult is set by SQLFetchRowValues and SQLFetchResultSetValues
9609>>>>>        //               0    = Fetch returned no data.
9609>>>>>        //               <> 0 = Row fetched
9609>>>>>        Property Integer piFetchResult     0
9610>>>>>
9610>>>>>
9610>>>>>        Property String psDummyZeroDate              '0001-01-01'
9611>>>>>        Property String psDummyZeroDateMssqlDatetime '1753-01-01'        
9612>>>>>
9612>>>>>    End_Procedure 
9613>>>>>
9613>>>>>    //***
9613>>>>>    //*** Procedure: StoreStatementInfo
9613>>>>>    //*** Purpose  : Store basic information about the statement.
9613>>>>>    //***
9613>>>>>    Procedure StoreStatementInfo Handle hCLIStatementHandle String sDrvrId Handle hCLIConnectionHandle
9615>>>>>        
9615>>>>>        Set phCLIStatementHandle   to hCLIStatementHandle
9616>>>>>        Set phCLIConnectionHandle  to hCLIConnectionHandle
9617>>>>>        Set psDriverID             to sDrvrId
9618>>>>>        
9618>>>>>    End_Procedure 
9619>>>>>
9619>>>>>
9619>>>>>    //***
9619>>>>>    //*** Procedure: DestroySQLStatement
9619>>>>>    //*** Purpose  : Destroy the cSQLStatement object
9619>>>>>    //***
9619>>>>>    Procedure DestroySQLStatement
9621>>>>>        Send Destroy
9622>>>>>    End_Procedure 
9623>>>>>
9623>>>>>    //***
9623>>>>>    //*** Procedure: HandleError
9623>>>>>    //*** Puprose  : Handle an error that has occured while checking properties.
9623>>>>>    //***
9623>>>>>
9623>>>>>    Procedure HandleError Integer ihstmt Integer ihdbc String sDrvrId String sOriginMsg
9625>>>>>        Integer iErrHandle
9625>>>>>        Integer iErrNum
9625>>>>>        String  sLocationInfo
9625>>>>>
9625>>>>>        //*** Get the DataFlex statement identifier
9625>>>>>        Move Self To iErrHandle
9626>>>>>
9626>>>>>        //*** Determine error number
9626>>>>>        If (ihstmt = 0) ;            Move CLIERR_SQLINVALID_CLI_STMT_HANDLE To iErrNum
9629>>>>>        Else If (ihdbc = 0) ;            Move CLIERR_SQLINVALID_CLI_CONN_HANDLE To iErrNum
9633>>>>>        Else If (sDrvrId = "") ;            Move CLIERR_SQLINVALID_DRIVER_ID To iErrNum
9637>>>>>        Else ;            Move CLIERR_SQL_ERROR To iErrNum
9639>>>>>
9639>>>>>        //*** Create location ifnormation
9639>>>>>        Move "[" To sLocationInfo
9640>>>>>        If (sOriginMsg <> "") Begin
9642>>>>>            Move (Append(sLocationInfo, sOriginMsg)) To sLocationInfo
9643>>>>>            Move (Append(sLocationInfo, ", "))       To sLocationInfo
9644>>>>>        End
9644>>>>>>
9644>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) To sLocationInfo
9645>>>>>        Move (Append(sLocationInfo, iErrHandle))          To sLocationInfo
9646>>>>>        Move (Append(sLocationInfo, "]"))                 To sLocationInfo
9647>>>>>
9647>>>>>        //*** Generate the error
9647>>>>>        Error iErrNum sLocationInfo
9648>>>>>>
9648>>>>>    End_Procedure
9649>>>>>
9649>>>>>
9649>>>>>
9649>>>>>    //***
9649>>>>>    //*** Procedure: StmtError
9649>>>>>    //*** Purpose  : Handle general error not related to the properties
9649>>>>>    //***
9649>>>>>
9649>>>>>    Procedure StmtError Integer iErrNum String sErrText String sOriginMsg
9651>>>>>        Integer iErrHandle
9651>>>>>        String  sLocationInfo
9651>>>>>
9651>>>>>        //*** Get the DataFlex statement identifier
9651>>>>>        Move Self to iErrHandle
9652>>>>>
9652>>>>>        //*** Create location information
9652>>>>>        Move "[" To sLocationInfo
9653>>>>>        If (sOriginMsg <> "") Begin
9655>>>>>            Move (Append(sLocationInfo, sOriginMsg)) To sLocationInfo
9656>>>>>            Move (Append(sLocationInfo, ", "))       To sLocationInfo
9657>>>>>        End
9657>>>>>>
9657>>>>>        If (sErrtext <> "") Begin
9659>>>>>            Move (Append(sLocationInfo, sErrtext)) To sLocationInfo
9660>>>>>            Move (Append(sLocationInfo, ", "))     To sLocationInfo
9661>>>>>        End
9661>>>>>>
9661>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) To sLocationInfo
9662>>>>>        Move (Append(sLocationInfo, iErrHandle))          To sLocationInfo
9663>>>>>        Move (Append(sLocationInfo, "]"))                 To sLocationInfo
9664>>>>>
9664>>>>>        //*** Generate the error
9664>>>>>        Error iErrNum sLocationInfo
9665>>>>>>
9665>>>>>    End_Procedure 
9666>>>>>
9666>>>>>
9666>>>>>
9666>>>>>    //***
9666>>>>>    //*** Procedure: SQLIllegalAttribute
9666>>>>>    //*** Purpose  : Handle an illegal attribute error
9666>>>>>    //***
9666>>>>>
9666>>>>>    Procedure SQLIllegalAttribute String sErrText String sOriginMsg
9668>>>>>        Integer bReport
9668>>>>>
9668>>>>>        Get_attribute DF_REPORT_UNSUPPORTED_ATTRIBUTES To bReport
9671>>>>>        If (bReport) ;            Send StmtError CLIERR_SQLINVALID_ATTRIBUTE sErrtext sOriginMsg
9674>>>>>    End_Procedure 
9675>>>>>
9675>>>>>
9675>>>>>
9675>>>>>    //***
9675>>>>>    //*** Function: SQLPrivateColumnIsLegal
9675>>>>>    //*** Purpose : Check if a column number is legal
9675>>>>>    //***
9675>>>>>
9675>>>>>    Function SQLPrivateColumnIsLegal Integer ihdbc String sDrvrId Integer ihstmt Integer iCol Returns Integer
9677>>>>>        Integer bLegal
9677>>>>>        Integer iNumColumns
9677>>>>>
9677>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt To iNumColumns
9678>>>>>        If (iCol > 0 And iCol <= iNumColumns) ;            Move DFTRUE To bLegal
9681>>>>>        Else ;            Move DFFALSE To bLegal
9683>>>>>
9683>>>>>        Function_Return bLegal
9684>>>>>    End_Function 
9685>>>>>
9685>>>>>
9685>>>>>
9685>>>>>    //***
9685>>>>>    //*** Procedure: SQLClose
9685>>>>>    //*** Purpose  : Close a statement and free all alllocated resources
9685>>>>>    //***
9685>>>>>
9685>>>>>    Procedure SQLClose
9687>>>>>        Integer ihdbc
9687>>>>>        Integer ihstmt
9687>>>>>        Integer iVoid
9687>>>>>        String  sDrvrId
9687>>>>>        String  sEmpty
9687>>>>>
9687>>>>>        //*** Initialize
9687>>>>>        Move "" To sEmpty
9688>>>>>
9688>>>>>        //*** Get the cli handles
9688>>>>>        Get phCLIStatementHandle  to ihstmt
9689>>>>>        Get phCLIConnectionHandle to ihdbc
9690>>>>>        Get psDriverId            to sDrvrId
9691>>>>>
9691>>>>>        //*** Free the CLI handle
9691>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
9693>>>>>            //*** Call the driver function to close
9693>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLCLOSE ;                        Callback Self ;                        Passing ihdbc sEmpty ihstmt ;                        Result iVoid
9698>>>>>
9698>>>>>            Move -1 to giLastSQLhstmt
9699>>>>>            //*** Free the DataFlex handle
9699>>>>>            Send DestroySQLStatement
9700>>>>>        End
9700>>>>>>
9700>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLClose"
9702>>>>>    End_Procedure
9703>>>>>
9703>>>>>
9703>>>>>
9703>>>>>    //***
9703>>>>>    //*** Procedure: SQLPrepare
9703>>>>>    //*** Purpose  : Prepare a statement for execution
9703>>>>>    //***
9703>>>>>
9703>>>>>    Procedure SQLPrepare String sStatement
9705>>>>>        Integer ihdbc
9705>>>>>        Integer ihstmt
9705>>>>>        Integer iVoid
9705>>>>>        String  sDrvrId
9705>>>>>
9705>>>>>        //*** Get the cli handles
9705>>>>>        Get phCLIStatementHandle  to ihstmt
9706>>>>>        Get phCLIConnectionHandle to ihdbc
9707>>>>>        Get psDriverId            to sDrvrId
9708>>>>>
9708>>>>>        //*** Prepare
9708>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
9710>>>>>            //*** Call the driver function to prepare
9710>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLPREPARE ;                        Callback Self ;                        Passing ihdbc sStatement ihstmt ;                        Result iVoid
9715>>>>>        End
9715>>>>>>
9715>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrepare"
9717>>>>>    End_Procedure
9718>>>>>
9718>>>>>    Procedure SQLGetStatementAttributes
9720>>>>>        Integer ihdbc ihstmt iNumColumns iCol iMaxSize
9720>>>>>        String sMaxValue
9720>>>>>        tSQLColumn[] aSQLColumns
9720>>>>>        tSQLColumn[] aSQLColumns
9721>>>>>        
9721>>>>>        Integer iSqlType
9721>>>>>        Integer iSQLSize
9721>>>>>        Integer iSQLprecision
9721>>>>>        Integer iVariableDataType
9721>>>>>        
9721>>>>>        String  sDrvrId
9721>>>>>
9721>>>>>        Integer iHasVariableDataType
9721>>>>>
9721>>>>>        Move 0 to iHasVariableDataType
9722>>>>>
9722>>>>>
9722>>>>>        //*** Get the cli handles
9722>>>>>        Get phCLIStatementHandle  to ihstmt
9723>>>>>        Get phCLIConnectionHandle to ihdbc
9724>>>>>        Get psDriverId            to sDrvrId
9725>>>>>
9725>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt to iNumColumns
9726>>>>>        
9726>>>>>        Set piColumnCount to iNumColumns
9727>>>>>        
9727>>>>>        // Fill columns array
9727>>>>>        For iCol from 1 to iNumColumns
9733>>>>>>
9733>>>>>            Move 0 to iVariableDataType
9734>>>>>            
9734>>>>>            Get SQLPrivateColAttribute iCol SQLCOLATTRIB_SQLTYPE ihdbc sDrvrId ihstmt to iSQLType
9735>>>>>            Get SQLPrivateColAttribute iCol SQLCOLATTRIB_SIZE ihdbc sDrvrId ihstmt to iSQLSize
9736>>>>>            Get SQLPrivateColAttribute iCol SQLCOLATTRIB_PRECISION ihdbc sDrvrId ihstmt to iSQLPrecision
9737>>>>>            
9737>>>>>            If ( (iSQLType = SQL_LONGVARCHAR) or (iSQLType = SQL_WLONGVARCHAR) ) Begin
9739>>>>>                 // text type 
9739>>>>>                Move 1 to iVariableDataType
9740>>>>>            End
9740>>>>>>
9740>>>>>            Else Begin
9741>>>>>                If (sDrvrId = "MSSQLDRV") Begin
9743>>>>>                    // SQL Server varchar(max) and nvarchar(max) types return Size = 0                   
9743>>>>>                    If ( ((iSQLType = SQL_VARCHAR) and (iSQLSize = 0) ) or ;                         ((iSQLType = SQL_WVARCHAR) and (iSQLSize = 0) ) ) Begin
9745>>>>>                            
9745>>>>>                        Move 1 to iVariableDataType     
9746>>>>>                    End
9746>>>>>>
9746>>>>>                End
9746>>>>>>
9746>>>>>            End
9746>>>>>>
9746>>>>>
9746>>>>>            Move iSqlType           to aSQLColumns[iCol].iSQLType            
9747>>>>>            Move iSQLSize           to aSQLColumns[iCol].iSQLSize
9748>>>>>            Move iSQLPrecision      to aSQLColumns[iCol].iSQLPrecision
9749>>>>>            Move iVariableDataType  to aSQLColumns[iCol].iVariableDataType
9750>>>>>            
9750>>>>>            If (not(iVariableDataType)) Begin
9752>>>>>                If (iSQLSize > iMaxSize) Begin
9754>>>>>                    Move iSQLSize to iMaxSize
9755>>>>>                End
9755>>>>>>
9755>>>>>            End
9755>>>>>>
9755>>>>>            Else Begin
9756>>>>>                Move 1 to iHasVariableDataType
9757>>>>>            End
9757>>>>>>
9757>>>>>            
9757>>>>>        Loop
9758>>>>>>
9758>>>>>        
9758>>>>>        Move (Repeat(' ', iMaxSize + 3)) to sMaxValue
9759>>>>>        Set psMaxColValue to sMaxValue
9760>>>>>        
9760>>>>>        Set paSQLColumns   to aSQLColumns        
9761>>>>>        Set piHasVariableDataType to iHasVariableDataType
9762>>>>>        
9762>>>>>    End_Procedure
9763>>>>>
9763>>>>>    //***
9763>>>>>    //*** Procedure: SQLExecute
9763>>>>>    //*** Purpose  : Execute a prepared statement
9763>>>>>    //***
9763>>>>>
9763>>>>>    Procedure SQLExecute
9765>>>>>        Integer ihdbc
9765>>>>>        Integer ihstmt
9765>>>>>        Integer iVoid
9765>>>>>        String  sDrvrId
9765>>>>>        String  sEmpty
9765>>>>>
9765>>>>>        //*** Initialize
9765>>>>>        Move "" To sEmpty
9766>>>>>
9766>>>>>        //*** Get the cli handles
9766>>>>>        Get phCLIStatementHandle  to ihstmt
9767>>>>>        Get phCLIConnectionHandle to ihdbc
9768>>>>>        Get psDriverId            to sDrvrId
9769>>>>>
9769>>>>>        //*** Execute
9769>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
9771>>>>>            //*** Call the driver function to execute
9771>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLEXECUTE ;                        Callback Self ;                        Passing ihdbc sEmpty ihstmt ;                        Result iVoid
9776>>>>>            Send SQLGetStatementAttributes
9777>>>>>        End
9777>>>>>>
9777>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLExecute"
9779>>>>>    End_Procedure
9780>>>>>
9780>>>>>
9780>>>>>
9780>>>>>    //***
9780>>>>>    //*** Procedure: SQLExecDirect
9780>>>>>    //*** Purpose  : Prepare and execute a statement
9780>>>>>    //***
9780>>>>>
9780>>>>>    Procedure SQLExecDirect String sStatement
9782>>>>>        Integer ihdbc
9782>>>>>        Integer ihstmt
9782>>>>>        Integer iVoid
9782>>>>>        String  sDrvrId
9782>>>>>
9782>>>>>        //*** Get the cli handles
9782>>>>>        Get phCLIStatementHandle  to ihstmt
9783>>>>>        Get phCLIConnectionHandle to ihdbc
9784>>>>>        Get psDriverId            to sDrvrId
9785>>>>>
9785>>>>>        //*** ExecDirect
9785>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
9787>>>>>            //*** Call the driver function to execdirect
9787>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLEXECDIRECT ;                        Callback Self ;                        Passing ihdbc sStatement ihstmt ;                        Result iVoid
9792>>>>>            Send SQLGetStatementAttributes
9793>>>>>        End
9793>>>>>>
9793>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLExecDirect"
9795>>>>>    End_Procedure
9796>>>>>
9796>>>>>
9796>>>>>
9796>>>>>    //***
9796>>>>>    //*** Procedure: SQLFetch
9796>>>>>    //*** Purpose  : Fetch the next row
9796>>>>>    //*** Returns  : 0   = No more data
9796>>>>>    //***            <>0 = Success
9796>>>>>    //***
9796>>>>>    Function SQLFetch Returns Integer
9798>>>>>        Integer ihdbc
9798>>>>>        Integer ihstmt
9798>>>>>        Integer iResult
9798>>>>>        String  sDrvrId
9798>>>>>        String  sEmpty
9798>>>>>
9798>>>>>        //*** Initialize
9798>>>>>        Move "" To sEmpty
9799>>>>>        Move 0  To iResult
9800>>>>>
9800>>>>>        //*** Get the cli handles
9800>>>>>        Get phCLIStatementHandle  to ihstmt
9801>>>>>        Get phCLIConnectionHandle to ihdbc
9802>>>>>        Get psDriverId            to sDrvrId
9803>>>>>
9803>>>>>        //*** Fetch
9803>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
9805>>>>>            Indicate Err False
9806>>>>>
9806>>>>>            //*** Call the driver function to fetch
9806>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback Self Passing ihdbc sEmpty ihstmt Result iResult
9811>>>>>
9811>>>>>            //*** If something went wrong, adjust the result
9811>>>>>            If (Err) Move 0 to iResult
9814>>>>>
9814>>>>>            Set piLastcolumn To 0
9815>>>>>        End
9815>>>>>>
9815>>>>>        Else Send HandleError ihstmt ihdbc sDrvrId "SQLFetch"
9817>>>>>
9817>>>>>        Function_return iResult
9818>>>>>    End_Function
9819>>>>>
9819>>>>>
9819>>>>>    //***
9819>>>>>    //*** Procedure: SQLFetchRowValues
9819>>>>>    //*** Purpose  : Fetch the next row and return an array with all column values
9819>>>>>    //*** Returns  : Array of strings with all column values
9819>>>>>    //***            Sets piFetchResult property 
9819>>>>>    //***               0    = No more data
9819>>>>>    //***               <> 0 = Success
9819>>>>>    //***
9819>>>>>    Function SQLFetchRowValues Returns String[] 
9821>>>>>      
9821>>>>>        String[] asValues
9822>>>>>
9822>>>>>        tSQLColumn[] aSQLColumns        
9822>>>>>        tSQLColumn[] aSQLColumns        
9823>>>>>        
9823>>>>>        Integer ihdbc
9823>>>>>        Integer ihstmt
9823>>>>>        Integer iResult iVoid
9823>>>>>        Integer iColCount iCol
9823>>>>>        String  sDrvrId
9823>>>>>        String  sEmpty 
9823>>>>>        String  sResult
9823>>>>>        String  sVariableResult
9823>>>>>        Integer iHasVariableDataType
9823>>>>>        Integer iLen
9823>>>>>        Integer iVariableBufferLength
9823>>>>>
9823>>>>>        //*** Initialize
9823>>>>>        Move "" to sEmpty
9824>>>>>        Move 0  to iResult
9825>>>>>
9825>>>>>        //*** Get the cli handles
9825>>>>>        Get phCLIStatementHandle  to ihstmt
9826>>>>>        Get phCLIConnectionHandle to ihdbc
9827>>>>>        Get psDriverId            to sDrvrId
9828>>>>>        
9828>>>>>        Get paSQLColumns to aSQLColumns
9829>>>>>        Get piColumnCount to iColCount
9830>>>>>        Get piHasVariableDataType to iHasVariableDataType
9831>>>>>        
9831>>>>>        If (iHasVariableDataType) Begin
9833>>>>>            
9833>>>>>            Get piVariableBufferLength      to iVariableBufferLength
9834>>>>>            Get piMaxVariableBufferLength   to iLen
9835>>>>>            
9835>>>>>            If (iLen > iVariableBufferLength) Begin
9837>>>>>                //*** Allocate
9837>>>>>                Move (Repeat(' ', iLen)) to sVariableResult
9838>>>>>               
9838>>>>>                Set piVariableBufferLength to iLen
9839>>>>>                Set psVariableBuffer       to sVariableResult
9840>>>>>                
9840>>>>>                Get piVariableBufferLength to iVariableBufferLength                
9841>>>>>            End
9841>>>>>>
9841>>>>>        End
9841>>>>>>
9841>>>>>
9841>>>>>        //*** Fetch
9841>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
9843>>>>>            Move (False) to Err
9844>>>>>
9844>>>>>            // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use 
9844>>>>>            // in the next FUNC_SQLCOLUMNVALUE call.
9844>>>>>            // If hdbc and hstmt have not changed since the last call we don't have to set it.
9844>>>>>            If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
9846>>>>>                //*** Setup function arguments
9846>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO Callback 0 Passing ihdbc iCol ihstmt Result iVoid
9851>>>>>                Move ihstmt to giLastSQLhstmt
9852>>>>>                Move ihdbc to giLastSQLhdbc
9853>>>>>            End
9853>>>>>>
9853>>>>>
9853>>>>>            //*** Call the driver function to fetch
9853>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback 0 Passing ihdbc sEmpty ihstmt Result iResult
9858>>>>>
9858>>>>>            //*** If something went wrong, adjust the result
9858>>>>>            If (Err) Move 0 to iResult
9861>>>>>            
9861>>>>>            If (iResult) Begin
9863>>>>>                For iCol from 1 to iColCount
9869>>>>>>
9869>>>>>                    
9869>>>>>                    If (not(aSQLColumns[iCol].iVariableDataType)) Begin
9871>>>>>                        Get psMaxColValue to sResult
9872>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNVALUE Callback 0 Passing sResult sEmpty iCol Result iVoid
9877>>>>>
9877>>>>>                        Move sResult to asValues[iCol - 1]
9878>>>>>                    End
9878>>>>>>
9878>>>>>                    Else Begin
9879>>>>>                        Get psVariableBuffer       to sVariableResult
9880>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLGETDATA ;                                    Callback 0 ;                                    Passing sVariableResult iCol iVariableBufferLength ;                                    Result iVoid
9885>>>>>                                    
9885>>>>>                        Move sVariableResult to asValues[iCol - 1]
9886>>>>>                    End
9886>>>>>>
9886>>>>>                    
9886>>>>>                Loop
9887>>>>>>
9887>>>>>            End
9887>>>>>>
9887>>>>>        End
9887>>>>>>
9887>>>>>        Else Begin    
9888>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLFetchRowValues"
9889>>>>>        End
9889>>>>>>
9889>>>>>
9889>>>>>        Set piFetchResult to iResult
9890>>>>>
9890>>>>>        Function_Return asValues
9891>>>>>        
9891>>>>>    End_Function 
9892>>>>>
9892>>>>>    //***
9892>>>>>    //*** Procedure: SQLFetchResultsetValues
9892>>>>>    //*** Purpose  : Fetch a complete result set. 
9892>>>>>    //*** Returns  : 2-dimensional array of strings with result set
9892>>>>>    //***            Sets piFetchResult property 
9892>>>>>    //***               0    = No more data
9892>>>>>    //***               <> 0 = Success
9892>>>>>    //***
9892>>>>>    Function SQLFetchResultsetValues Returns String[][] 
9894>>>>>        
9894>>>>>        String[][] asValues 
9895>>>>>        
9895>>>>>        Integer ihdbc ihstmt iResult iVoid iColCount iCol iRow
9895>>>>>        String sDrvrId sEmpty sResult sMax
9895>>>>>
9895>>>>>        tSQLColumn[] aSQLColumns        
9895>>>>>        tSQLColumn[] aSQLColumns        
9896>>>>>        String  sVariableResult
9896>>>>>        Integer iHasVariableDataType
9896>>>>>        Integer iLen
9896>>>>>        Integer iVariableBufferLength
9896>>>>>
9896>>>>>        //*** Initialize
9896>>>>>        Move "" to sEmpty
9897>>>>>        Move 0  to iResult
9898>>>>>
9898>>>>>        //*** Get the cli handles
9898>>>>>        Get phCLIStatementHandle  to ihstmt
9899>>>>>        Get phCLIConnectionHandle to ihdbc
9900>>>>>        Get psDriverId            to sDrvrId
9901>>>>>
9901>>>>>        //*** Fetch
9901>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
9903>>>>>            Indicate Err False
9904>>>>>            
9904>>>>>            // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use 
9904>>>>>            // in the next FUNC_SQLCOLUMNVALUE call.
9904>>>>>            // If hdbc and hstmt have not changed since the last call we don't have to set it.
9904>>>>>            If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
9906>>>>>                //*** Setup function arguments
9906>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO Callback 0 Passing ihdbc iCol ihstmt Result iVoid
9911>>>>>                Move ihstmt to giLastSQLhstmt
9912>>>>>                Move ihdbc to giLastSQLhdbc
9913>>>>>            End
9913>>>>>>
9913>>>>>
9913>>>>>
9913>>>>>            Get paSQLColumns to aSQLColumns
9914>>>>>            Get piColumnCount to iColCount
9915>>>>>            Get piHasVariableDataType to iHasVariableDataType
9916>>>>>            If (iHasVariableDataType) Begin
9918>>>>>                Get piVariableBufferLength      to iVariableBufferLength
9919>>>>>                Get piMaxVariableBufferLength   to iLen
9920>>>>>                If (iLen > iVariableBufferLength) Begin
9922>>>>>                    //*** Allocate
9922>>>>>                    Move (Repeat(' ', iLen)) to sVariableResult
9923>>>>>                   
9923>>>>>                    Set piVariableBufferLength to iLen
9924>>>>>                    Set psVariableBuffer       to sVariableResult
9925>>>>>                    
9925>>>>>                    Get piVariableBufferLength to iVariableBufferLength                
9926>>>>>                End
9926>>>>>>
9926>>>>>                Else Begin
9927>>>>>                   Set psVariableBuffer       to sVariableResult
9928>>>>>                End
9928>>>>>>
9928>>>>>            End
9928>>>>>>
9928>>>>>
9928>>>>>            Get psMaxColValue to sMax
9929>>>>>
9929>>>>>            //*** Call the driver function to fetch
9929>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback Self Passing ihdbc sEmpty ihstmt Result iResult
9934>>>>>            If (Err) Move 0 to iResult
9937>>>>>
9937>>>>>            While (iResult <> 0)
9941>>>>>
9941>>>>>                For iCol from 1 to (iColCount)
9947>>>>>>
9947>>>>>                    
9947>>>>>                    If (not(aSQLColumns[iCol].iVariableDataType)) Begin
9949>>>>>                        Move sMax to sResult
9950>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNVALUE ;                                    Callback 0 ;                                    Passing sResult sEmpty iCol ;                                    Result iVoid
9955>>>>>                        Move sResult to asValues[iRow][iCol - 1]
9956>>>>>                    End
9956>>>>>>
9956>>>>>                    Else Begin
9957>>>>>                        //Variable data    
9957>>>>>                        Move sVariableResult to sResult
9958>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLGETDATA ;                                    Callback 0 ;                                    Passing sResult iCol iVariableBufferLength ;                                    Result iVoid
9963>>>>>                                    
9963>>>>>                        Move sResult to asValues[iRow][iCol - 1]
9964>>>>>                    End
9964>>>>>>
9964>>>>>                Loop
9965>>>>>>
9965>>>>>
9965>>>>>                Increment iRow
9966>>>>>
9966>>>>>                //*** Call the driver function to fetch
9966>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback Self Passing ihdbc sEmpty ihstmt Result iResult
9971>>>>>                If (Err) Move 0 to iResult
9974>>>>>
9974>>>>>            Loop
9975>>>>>>
9975>>>>>
9975>>>>>        End
9975>>>>>>
9975>>>>>        Else Send HandleError ihstmt ihdbc sDrvrId "SQLFetchResultsetValues"
9977>>>>>
9977>>>>>        Set piFetchResult to iResult
9978>>>>>
9978>>>>>        Function_Return asValues
9979>>>>>    End_Function 
9980>>>>>
9980>>>>>
9980>>>>>
9980>>>>>    //***
9980>>>>>    //*** Function: SQLNextColumn
9980>>>>>    //*** Purpose : Get the next column
9980>>>>>    //***
9980>>>>>
9980>>>>>    Function SQLNextColumn Returns String
9982>>>>>        Integer iCol
9982>>>>>        String  sResult
9982>>>>>
9982>>>>>        Get piLastColumn To iCol
9983>>>>>        Increment iCol
9984>>>>>        Get SQLColumnValue iCol To sResult
9985>>>>>        Set piLastColumn To iCol
9986>>>>>
9986>>>>>        Function_return sResult
9987>>>>>    End_Function 
9988>>>>>
9988>>>>>
9988>>>>>    //***
9988>>>>>    //*** Function: SQLColumnType
9988>>>>>    //*** Purpose : Returns the native type of a column
9988>>>>>    //***
9988>>>>>    Function SQLColumnType Integer iCol Returns Integer
9990>>>>>        Integer ihdbc
9990>>>>>        Integer ihstmt
9990>>>>>        String  sDrvrId
9990>>>>>        Integer iSQLType
9990>>>>>        Integer iColumns
9990>>>>>        
9990>>>>>        tSQLColumn[] aSQLColumns
9990>>>>>        tSQLColumn[] aSQLColumns
9991>>>>>        
9991>>>>>        //*** Get the cli handles
9991>>>>>        Get phCLIStatementHandle  to ihstmt
9992>>>>>        Get phCLIConnectionHandle to ihdbc
9993>>>>>        Get psDriverId            to sDrvrId
9994>>>>>
9994>>>>>        //*** Get the value
9994>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
9996>>>>>        
9996>>>>>            Get paSQLColumns   to aSQLColumns        
9997>>>>>            Move (SizeOfArray(aSQLColumns)) to iColumns
9998>>>>>            
9998>>>>>            If (iCol >= 1 and iCol <= iColumns) Begin
10000>>>>>                Move aSQLColumns[iCol].iSQLType to iSQLType
10001>>>>>            End
10001>>>>>>
10001>>>>>            Else Begin
10002>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnType"        
10003>>>>>            End
10003>>>>>>
10003>>>>>        End
10003>>>>>>
10003>>>>>        Else Begin
10004>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLColumnType"
10005>>>>>        End
10005>>>>>>
10005>>>>>
10005>>>>>        Function_Return iSQLType
10006>>>>>    End_Function 
10007>>>>>
10007>>>>>    //***
10007>>>>>    //*** Function: SQLColumnSize
10007>>>>>    //*** Purpose : Returns the size (max length) of a column
10007>>>>>    //***
10007>>>>>    Function SQLColumnSize Integer iCol Returns Integer
10009>>>>>        Integer ihdbc
10009>>>>>        Integer ihstmt
10009>>>>>        String  sDrvrId
10009>>>>>        Integer iSQLSize
10009>>>>>        Integer iColumns
10009>>>>>        
10009>>>>>        tSQLColumn[] aSQLColumns
10009>>>>>        tSQLColumn[] aSQLColumns
10010>>>>>        
10010>>>>>        //*** Get the cli handles
10010>>>>>        Get phCLIStatementHandle  to ihstmt
10011>>>>>        Get phCLIConnectionHandle to ihdbc
10012>>>>>        Get psDriverId            to sDrvrId
10013>>>>>
10013>>>>>        //*** Get the value
10013>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
10015>>>>>        
10015>>>>>            Get paSQLColumns   to aSQLColumns        
10016>>>>>            Move (SizeOfArray(aSQLColumns)) to iColumns
10017>>>>>            
10017>>>>>            If (iCol >= 1 and iCol <= iColumns) Begin
10019>>>>>                Move aSQLColumns[iCol].iSQLSize to iSQLSize
10020>>>>>            End
10020>>>>>>
10020>>>>>            Else Begin
10021>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnSize"        
10022>>>>>            End
10022>>>>>>
10022>>>>>        End
10022>>>>>>
10022>>>>>        Else Begin
10023>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLColumnSize"
10024>>>>>        End
10024>>>>>>
10024>>>>>
10024>>>>>        Function_Return iSQLSize
10025>>>>>    End_Function 
10026>>>>>
10026>>>>>    //***
10026>>>>>    //*** Function: SQLColumnVariableDatatype
10026>>>>>    //*** Purpose : Returns 1 for variable length datatypes. 
10026>>>>>    //***           For example SQL Server varchar(max) or text type
10026>>>>>    //***           The data of variable length datatype columns should be retrieved with SQLGetData 
10026>>>>>    Function SQLColumnVariableDatatype Integer iCol Returns Integer
10028>>>>>        Integer ihdbc
10028>>>>>        Integer ihstmt
10028>>>>>        String  sDrvrId
10028>>>>>        Integer iVariableDataType
10028>>>>>        Integer iColumns
10028>>>>>        
10028>>>>>        tSQLColumn[] aSQLColumns
10028>>>>>        tSQLColumn[] aSQLColumns
10029>>>>>        
10029>>>>>        //*** Get the cli handles
10029>>>>>        Get phCLIStatementHandle  to ihstmt
10030>>>>>        Get phCLIConnectionHandle to ihdbc
10031>>>>>        Get psDriverId            to sDrvrId
10032>>>>>
10032>>>>>        //*** Get the value
10032>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
10034>>>>>        
10034>>>>>            Get paSQLColumns   to aSQLColumns        
10035>>>>>            Move (SizeOfArray(aSQLColumns)) to iColumns
10036>>>>>            
10036>>>>>            If (iCol >= 1 and iCol <= iColumns) Begin
10038>>>>>                Move aSQLColumns[iCol].iVariableDataType to iVariableDataType
10039>>>>>            End
10039>>>>>>
10039>>>>>            Else Begin
10040>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnVariableDatatype"        
10041>>>>>            End
10041>>>>>>
10041>>>>>        End
10041>>>>>>
10041>>>>>        Else Begin
10042>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLColumnVariableDatatype"
10043>>>>>        End
10043>>>>>>
10043>>>>>
10043>>>>>        Function_Return iVariableDataType
10044>>>>>    End_Function 
10045>>>>>
10045>>>>>
10045>>>>>
10045>>>>>
10045>>>>>    //***
10045>>>>>    //*** Function: SQLColumnValue
10045>>>>>    //*** Purpose : Return the value of a column in a fetched row of a given
10045>>>>>    //***           statement.
10045>>>>>    //***
10045>>>>>    Function SQLColumnValue Integer iCol Returns String
10047>>>>>        Integer ihdbc
10047>>>>>        Integer ihstmt
10047>>>>>        String  sDrvrId
10047>>>>>        String  sResult
10047>>>>>
10047>>>>>        Integer iVoid
10047>>>>>        Integer iColSize
10047>>>>>        Integer iColPrecision
10047>>>>>        String  sEmpty
10047>>>>>        Integer bLegalColumn
10047>>>>>
10047>>>>>        //*** Initialize
10047>>>>>        Move "" To sResult
10048>>>>>
10048>>>>>        //*** Get the cli handles
10048>>>>>        Get phCLIStatementHandle  to ihstmt
10049>>>>>        Get phCLIConnectionHandle to ihdbc
10050>>>>>        Get psDriverId            to sDrvrId
10051>>>>>
10051>>>>>        // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use 
10051>>>>>        // in the next FUNC_SQLCOLUMNVALUE call.
10051>>>>>        // If hdbc and hstmt have not changed since the last call we don't have to set it.
10051>>>>>        If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
10053>>>>>            //*** Setup function arguments
10053>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                        Callback 0 ;                        Passing ihdbc iCol ihstmt ;                        Result iVoid
10058>>>>>            Move ihstmt to giLastSQLhstmt
10059>>>>>            Move ihdbc to giLastSQLhdbc
10060>>>>>        End
10060>>>>>>
10060>>>>>
10060>>>>>        If (iCol >= 1 and iCol <= piColumnCount(Self)) Begin
10062>>>>>            Get psMaxColValue to sResult
10063>>>>>            //*** Call the driver function to get the value
10063>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNVALUE ;                        Callback 0 ;                        Passing sResult sEmpty iCol ;                        Result iVoid
10068>>>>>        End
10068>>>>>>
10068>>>>>        Else Begin
10069>>>>>            Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnValue"
10070>>>>>        End
10070>>>>>>
10070>>>>>
10070>>>>>        Function_Return sResult
10071>>>>>        
10071>>>>>    End_Function
10072>>>>>
10072>>>>>
10072>>>>>
10072>>>>>    //***
10072>>>>>    //*** Procedure: SQLBindFile
10072>>>>>    //*** Purpose  : Add a file to the files used to place the statement result in.
10072>>>>>    //***
10072>>>>>
10072>>>>>    Procedure SQLBindFile Integer iFileNum
10074>>>>>        Integer ihdbc
10074>>>>>        Integer ihstmt
10074>>>>>        Integer iVoid
10074>>>>>        String  sDrvrId
10074>>>>>        String  sFileType
10074>>>>>        Integer bIsOpen
10074>>>>>
10074>>>>>        //*** Get the cli handles
10074>>>>>        Get phCLIStatementHandle  to ihstmt
10075>>>>>        Get phCLIConnectionHandle to ihdbc
10076>>>>>        Get psDriverId            to sDrvrId
10077>>>>>
10077>>>>>        //*** If a file number is not passed see if we can use the statement's
10077>>>>>        //*** default file number which is usually set with SetFileConnection
10077>>>>>        If (iFileNum = 0) Begin
10079>>>>>            Get piBindFile To iFileNum
10080>>>>>            If (iFileNum = 0) Begin
10082>>>>>                //*** Logic error, if 0 is passed as filenumber, piBindFile should be set.
10082>>>>>                Send StmtError CLIERR_SQLINVALID_BIND_FILE "piBindFile should be set" "SQLBindFile"
10083>>>>>
10083>>>>>                Move 0 to SQLResult
10084>>>>>                Procedure_Return
10085>>>>>            End
10085>>>>>>
10085>>>>>        End
10085>>>>>>
10085>>>>>
10085>>>>>        //*** Bind the file
10085>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
10087>>>>>            //*** Chek if the file is open
10087>>>>>            Get_attribute DF_FILE_OPENED Of iFileNum To bIsOpen
10090>>>>>            If (bIsOpen) Begin
10092>>>>>                //*** Check if the file has the correct type
10092>>>>>                Get_attribute DF_FILE_DRIVER Of iFileNum To sFileType
10095>>>>>                If (sFileType = sDrvrId) Begin
10097>>>>>                    //*** Call the driver function to add a file to a statement
10097>>>>>                    Call_driver 0 sDrvrId Function FUNC_SQLBINDFILE ;                                Callback Self ;                                Passing ihdbc iFileNum ihstmt ;                                Result iVoid
10102>>>>>                End
10102>>>>>>
10102>>>>>                Else ;                    Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File" * String(iFileNum) * "type incompatible with statement ("  + sFileType + ")") "SQLBindFile"
10104>>>>>            End
10104>>>>>>
10104>>>>>            Else ;                Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File not open (number =" * String(iFileNum) + ")") "SQLBindFile"
10106>>>>>        End
10106>>>>>>
10106>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLBindFile"
10108>>>>>    End_Procedure 
10109>>>>>
10109>>>>>
10109>>>>>
10109>>>>>    //*************************************************************************
10109>>>>>    //*** Function: SQLGetData                                              ***
10109>>>>>    //*** Purpose : Get data of a column.                                   ***
10109>>>>>    //*************************************************************************
10109>>>>>
10109>>>>>    Function SQLGetData Integer iCol Integer iLen Returns String
10111>>>>>        Integer ihdbc
10111>>>>>        Integer ihstmt
10111>>>>>        Integer iVoid
10111>>>>>        Integer iColSize
10111>>>>>        Integer iResult
10111>>>>>        String  sDrvrId
10111>>>>>        String  sResult
10111>>>>>        String  sEmpty
10111>>>>>        Integer bLegalColumn
10111>>>>>        
10111>>>>>        Integer iVariableBufferLength
10111>>>>>
10111>>>>>        //*** Initialize
10111>>>>>        Move "" To sEmpty
10112>>>>>        Move 0 To iResult
10113>>>>>
10113>>>>>        //*** Get the cli handles
10113>>>>>        Get phCLIStatementHandle  to ihstmt
10114>>>>>        Get phCLIConnectionHandle to ihdbc
10115>>>>>        Get psDriverId            to sDrvrId
10116>>>>>
10116>>>>>        //*** Get the data
10116>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
10118>>>>>            //*** Check if the column exists
10118>>>>>            If (iCol >= 1 and iCol <= piColumnCount(Self)) Begin
10120>>>>>                If (iLen = 0) Begin
10122>>>>>                    Get SQLColumnValue iCol to sResult
10123>>>>>                End
10123>>>>>>
10123>>>>>                Else Begin
10124>>>>>                    // Add 1 for string terminator
10124>>>>>                    Move (iLen + 1) to iLen
10125>>>>>
10125>>>>>                    Get piVariableBufferLength to iVariableBufferLength
10126>>>>>                    If (iLen > iVariableBufferLength) Begin
10128>>>>>                        //*** Allocate
10128>>>>>                        Move (Repeat(' ', iLen)) to sResult
10129>>>>>                       
10129>>>>>                        Set piVariableBufferLength to iLen
10130>>>>>                        Set psVariableBuffer       to sResult
10131>>>>>                    End
10131>>>>>>
10131>>>>>                    Else Begin
10132>>>>>                        Get psVariableBuffer       to sResult
10133>>>>>                    End
10133>>>>>>
10133>>>>>
10133>>>>>
10133>>>>>                    // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use 
10133>>>>>                    // in the next FUNC_SQLCOLUMNVALUE call.
10133>>>>>                    // If hdbc and hstmt have not changed since the last call we don't have to set it.
10133>>>>>                    If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
10135>>>>>                        //*** Setup function arguments
10135>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                                    Callback 0 ;                                    Passing ihdbc iCol ihstmt ;                                    Result iVoid
10140>>>>>                        Move ihstmt to giLastSQLhstmt
10141>>>>>                        Move ihdbc to giLastSQLhdbc
10142>>>>>                    End
10142>>>>>>
10142>>>>>
10142>>>>>                    Indicate Err False
10143>>>>>                    //*** Call the driver function to get the data
10143>>>>>                    Call_driver 0 sDrvrId Function FUNC_SQLGETDATA ;                                Callback Self ;                                Passing sResult iCol iLen ;                                Result iResult
10148>>>>>
10148>>>>>                    //*** If something went wrong, adjust the result
10148>>>>>                    If (Err) Begin
10150>>>>>                        Move 0 to iResult
10151>>>>>                    End
10151>>>>>>
10151>>>>>                End
10151>>>>>>
10151>>>>>            End
10151>>>>>>
10151>>>>>            Else Begin
10152>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLGetData"
10153>>>>>            End
10153>>>>>>
10153>>>>>        End
10153>>>>>>
10153>>>>>        Else Begin
10154>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLGetData"
10155>>>>>        End
10155>>>>>>
10155>>>>>
10155>>>>>        //*** Fill global result
10155>>>>>        Move iResult To SQLResult
10156>>>>>
10156>>>>>        Function_Return sResult
10157>>>>>    End_Function 
10158>>>>>
10158>>>>>
10158>>>>>
10158>>>>>    //***
10158>>>>>    //*** Function: SQLColumnMap
10158>>>>>    //*** Purpose : Map a column name to a number, if the name id not found no
10158>>>>>    //***           error is generated the returned number will be 0 (zero) in
10158>>>>>    //***           that case
10158>>>>>    //***
10158>>>>>
10158>>>>>    Function SQLColumnMap String sColname Returns Integer
10160>>>>>        Integer ihdbc
10160>>>>>        Integer ihstmt
10160>>>>>        Integer iNumColumns
10160>>>>>        Integer iColCount
10160>>>>>        Integer iColNum
10160>>>>>        String  sDrvrId
10160>>>>>        String  sCurColName
10160>>>>>
10160>>>>>        //*** Get the cli handles
10160>>>>>        Get phCLIStatementHandle  to ihstmt
10161>>>>>        Get phCLIConnectionHandle to ihdbc
10162>>>>>        Get psDriverId            to sDrvrId
10163>>>>>
10163>>>>>        //*** Get the number by looping through the column names
10163>>>>>        Move 0 To iColNum
10164>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt To iNumColumns
10165>>>>>        For iColCount From 1 To iNumColumns
10171>>>>>>
10171>>>>>            Get SQLPrivateColAttribute iColCount SQLCOLATTRIB_LABEL ihdbc sDrvrId ihstmt To sCurColName
10172>>>>>            If (Uppercase(Trim(sColName)) = Uppercase(Trim(sCurColName))) ;                Move iColCount To iColNum
10175>>>>>
10175>>>>>            If (iColNum) ;                Break
10178>>>>>        Loop
10179>>>>>>
10179>>>>>
10179>>>>>        Function_return iColNum
10180>>>>>    End_Function 
10181>>>>>
10181>>>>>
10181>>>>>
10181>>>>>    //***
10181>>>>>    //*** Function: SQLStmtAttribute
10181>>>>>    //*** Purpose : Get a statement attribute
10181>>>>>    //***
10181>>>>>
10181>>>>>    Function SQLStmtAttribute Integer iAttribId Returns String
10183>>>>>        Integer ihdbc
10183>>>>>        Integer ihstmt
10183>>>>>        String  sResult
10183>>>>>        String  sDrvrId
10183>>>>>
10183>>>>>        //*** Initialize
10183>>>>>        Move "" To sResult
10184>>>>>
10184>>>>>        //*** Get the cli handles
10184>>>>>        Get phCLIStatementHandle  to ihstmt
10185>>>>>        Get phCLIConnectionHandle to ihdbc
10186>>>>>        Get psDriverId            to sDrvrId
10187>>>>>
10187>>>>>        //*** Get the attribute
10187>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") ;            Get SQLPrivateStmtAttribute iAttribId ihdbc sDrvrId ihstmt To sResult
10190>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLStmtAttribute"
10192>>>>>
10192>>>>>        Function_Return sResult
10193>>>>>    End_Function 
10194>>>>>
10194>>>>>    Function SQLPrivateStmtAttribute Integer iAttribId Integer ihdbc String sDrvrId Integer ihstmt Returns String
10196>>>>>        String  sResult
10196>>>>>        Integer iLen
10196>>>>>        Integer bLegalAttrib
10196>>>>>
10196>>>>>        //*** Initialize
10196>>>>>        Move ""     To sResult
10197>>>>>
10197>>>>>        //*** Get the attribute
10197>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
10199>>>>>            Case Begin
10199>>>>>                Case (iAttribId = SQLSTMTATTRIB_COLUMNCOUNT)
10201>>>>>                Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT)
10204>>>>>                Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT_TYPE)
10207>>>>>                Case (iAttribId = SQLSTMTATTRIB_NUMMESSAGES)
10210>>>>>                    Move DFTRUE To bLegalAttrib
10211>>>>>                    Break
10212>>>>>
10212>>>>>                Case Else
10212>>>>>                    Move DFFALSE To bLegalAttrib
10213>>>>>                    Send SQLIllegalAttribute ("Attribute is = " + String(iAttribId) + ")") "SQLPrivateStmtAttribute"
10214>>>>>            Case End
10214>>>>>
10214>>>>>            If (bLegalAttrib) Begin
10216>>>>>                //*** Setup function arguments
10216>>>>>                Call_driver 0 sDrvrId Function FUNC_SQLSTMTINTATTRIB ;                            Callback Self ;                            Passing ihdbc iAttribId ihstmt ;                            Result sResult
10221>>>>>            End
10221>>>>>>
10221>>>>>        End
10221>>>>>>
10221>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateStmtAttribute"
10223>>>>>
10223>>>>>        Function_Return sResult
10224>>>>>    End_Function 
10225>>>>>
10225>>>>>
10225>>>>>
10225>>>>>    //***
10225>>>>>    //*** Function: SQLColAttribute
10225>>>>>    //*** Purpose : Get a column's attribute
10225>>>>>    //***
10225>>>>>
10225>>>>>    Function SQLColAttribute Integer iCol Integer iAttribId Returns String
10227>>>>>        Integer ihdbc
10227>>>>>        Integer ihstmt
10227>>>>>        String  sResult
10227>>>>>        String  sDrvrId
10227>>>>>
10227>>>>>        //*** Initialize
10227>>>>>        Move "" To sResult
10228>>>>>
10228>>>>>        //*** Get the cli handles
10228>>>>>        Get phCLIStatementHandle  to ihstmt
10229>>>>>        Get phCLIConnectionHandle to ihdbc
10230>>>>>        Get psDriverId            to sDrvrId
10231>>>>>
10231>>>>>        //*** Get the attribute
10231>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") ;            Get SQLPrivateColAttribute iCol iAttribId ihdbc sDrvrId ihstmt To sResult
10234>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLColAttribute"
10236>>>>>
10236>>>>>        Function_Return sResult
10237>>>>>    End_Function 
10238>>>>>
10238>>>>>    Function SQLPrivateColAttribute Integer iCol Integer iAttribId Integer ihdbc String sDrvrId Integer ihstmt Returns String
10240>>>>>        String  sResult
10240>>>>>        String  sEmpty
10240>>>>>        Integer bIsStringAttribute
10240>>>>>        Integer iLen
10240>>>>>        Integer iVoid
10240>>>>>        Integer bLegalAttrib
10240>>>>>        Integer bLegalColumn
10240>>>>>
10240>>>>>        //*** Initialize
10240>>>>>        Move "" To sResult
10241>>>>>        Move "" To sEmpty
10242>>>>>        MOve 0  To iLen
10243>>>>>
10243>>>>>        //*** Get the attribute
10243>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
10245>>>>>            Get SQLPrivateColumnIsLegal ihdbc sDrvrId ihstmt iCol To bLegalColumn
10246>>>>>            If (bLegalColumn) Begin
10248>>>>>                //*** Determine the atributes type
10248>>>>>                Case Begin
10248>>>>>                    Case (iAttribId = SQLCOLATTRIB_SIZE)
10250>>>>>                    Case (iAttribId = SQLCOLATTRIB_LENGTH)
10253>>>>>                    Case (iAttribId = SQLCOLATTRIB_PRECISION)
10256>>>>>                    Case (iAttribId = SQLCOLATTRIB_SQLTYPE)
10259>>>>>                    Case (iAttribId = SQLCOLATTRIB_NULLABLE)
10262>>>>>                    Case (iAttribId = SQLCOLATTRIB_DFTYPE)
10265>>>>>                        Move DFFALSE To bIsStringAttribute
10266>>>>>                        Move DFTRUE To bLegalAttrib
10267>>>>>                        Break
10268>>>>>
10268>>>>>                    Case (iAttribId = SQLCOLATTRIB_LABEL)
10271>>>>>                    Case (iAttribId = SQLCOLATTRIB_BASECOLUMNNAME)
10274>>>>>                    Case (iAttribId = SQLCOLATTRIB_BASETABLENAME)
10277>>>>>                        Move DFTRUE To bIsStringAttribute
10278>>>>>                        Move DFTRUE To bLegalAttrib
10279>>>>>                        Break
10280>>>>>
10280>>>>>                    Case Else
10280>>>>>                        Move DFFALSE To bLegalAttrib
10281>>>>>                        Send SQLIllegalAttribute ("Attribute is = " + String(iAttribId) + ")") "SQLPrivateColAttribute"
10282>>>>>                Case End
10282>>>>>
10282>>>>>                If (bLegalAttrib) Begin
10284>>>>>                    //*** Setup function arguments
10284>>>>>                    Call_driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                                Callback Self ;                                Passing ihdbc iCol ihstmt ;                                Result iVoid
10289>>>>>
10289>>>>>                    If (bIsStringAttribute) Begin
10291>>>>>                        //*** Call the driver function to get the data length
10291>>>>>                        Call_driver 0 sDrvrId Function FUNC_SQLCOLSTRINGATTRIBLEN ;                                    Callback Self ;                                    Passing sEmpty sEmpty iAttribId ;                                    Result iLen
10296>>>>>
10296>>>>>                        If (iLen) Begin
10298>>>>>                            //*** Allocate
10298>>>>>                            Move (Repeat(' ', iLen)) To sResult
10299>>>>>
10299>>>>>                            //*** Call the driver function to get the name
10299>>>>>                            Call_driver 0 sDrvrId Function FUNC_SQLCOLSTRINGATTRIB ;                                        Callback Self ;                                        Passing sResult sEmpty iAttribId ;                                        Result iVoid
10304>>>>>                        End
10304>>>>>>
10304>>>>>                    End
10304>>>>>>
10304>>>>>                    Else Begin
10305>>>>>                        //*** get the attribute
10305>>>>>                        Call_driver 0 sDrvrId Function FUNC_SQLCOLINTATTRIB ;                                    Callback Self ;                                    Passing sEmpty sEmpty iAttribId ;                                    Result sResult
10310>>>>>                    End
10310>>>>>>
10310>>>>>                End
10310>>>>>>
10310>>>>>            End
10310>>>>>>
10310>>>>>            Else ;                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLPrivateColAttribute"
10312>>>>>        End
10312>>>>>>
10312>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateColAttribute"
10314>>>>>
10314>>>>>        Function_Return sResult
10315>>>>>    End_Function 
10316>>>>>
10316>>>>>
10316>>>>>
10316>>>>>    //***
10316>>>>>    //*** Procedure: SQLSetProcedureName
10316>>>>>    //*** Purpsoe  : Preapre for calling a stored procedure, pass the procedure name.
10316>>>>>    //***
10316>>>>>
10316>>>>>    Procedure SQLSetProcedureName String sProcName String sSchemaArg
10318>>>>>        Integer ihdbc
10318>>>>>        Integer ihstmt
10318>>>>>        String  sDrvrId
10318>>>>>        Integer iVoid
10318>>>>>        String  sSchema
10318>>>>>        String  sEmpty
10318>>>>>
10318>>>>>        //*** Initialize
10318>>>>>        Move "" To sEmpty
10319>>>>>
10319>>>>>        //*** Get the cli handles
10319>>>>>        Get phCLIStatementHandle  to ihstmt
10320>>>>>        Get phCLIConnectionHandle to ihdbc
10321>>>>>        Get psDriverId            to sDrvrId
10322>>>>>
10322>>>>>        //*** Call the procedure
10322>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
10324>>>>>            If (Num_Arguments >= 2) ;                Move sSchemaArg To sSchema
10327>>>>>            Else ;                Move "" To sSchema
10329>>>>>
10329>>>>>            If (sSchema <> "") Begin
10331>>>>>                Call_driver 0 sDrvrId Function FUNC_SQLSETPROCSCHEMA ;                            Callback Self ;                            Passing ihdbc sSchema ihstmt ;                            Result iVoid
10336>>>>>            End
10336>>>>>>
10336>>>>>
10336>>>>>            //*** Call the procedure
10336>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLSETPROCNAME ;                        Callback Self ;                        Passing ihdbc sProcName ihstmt ;                        Result iVoid
10341>>>>>
10341>>>>>            Set piLastArgument To 0
10342>>>>>        End
10342>>>>>>
10342>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLSetProcedurename"
10344>>>>>    End_Procedure 
10345>>>>>
10345>>>>>
10345>>>>>
10345>>>>>    //***
10345>>>>>    //*** Function: SQLSetNextArgument
10345>>>>>    //*** Purpose : Pass the next argument
10345>>>>>    //***
10345>>>>>
10345>>>>>    Procedure SQLSetNextArgument String sArgument
10347>>>>>        Integer iArgnum
10347>>>>>
10347>>>>>        Get piLastArgument To iArgnum
10348>>>>>        Increment iArgnum
10349>>>>>        Send SQLSetArgument iArgnum sArgument
10350>>>>>        Set piLastArgument To iArgnum
10351>>>>>    End_Procedure 
10352>>>>>
10352>>>>>
10352>>>>>
10352>>>>>    //***
10352>>>>>    //*** Procedure: SQLSetArgument
10352>>>>>    //*** Purpose  : Set the next argument
10352>>>>>    //***
10352>>>>>
10352>>>>>    Procedure SQLSetArgument Integer iArgnum String sArgument
10354>>>>>        Integer ihdbc
10354>>>>>        Integer ihstmt
10354>>>>>        String  sDrvrId
10354>>>>>        Integer iVoid
10354>>>>>        String  sEmpty
10354>>>>>
10354>>>>>        //*** Initialize
10354>>>>>        Move "" To sEmpty
10355>>>>>
10355>>>>>        //*** Get the cli handles
10355>>>>>        Get phCLIStatementHandle  to ihstmt
10356>>>>>        Get phCLIConnectionHandle to ihdbc
10357>>>>>        Get psDriverId            to sDrvrId
10358>>>>>
10358>>>>>        //*** Call the procedure
10358>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
10360>>>>>            //*** Pass the information
10360>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                        Callback Self ;                        Passing ihdbc iArgnum ihstmt ;                        Result iVoid
10365>>>>>
10365>>>>>            //*** Pass the argument
10365>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLSETPROCARG ;                        Callback Self ;                        Passing sArgument sEmpty 0 ;                        Result iVoid
10370>>>>>        End
10370>>>>>>
10370>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLSetArgument"
10372>>>>>    End_Procedure
10373>>>>>
10373>>>>>
10373>>>>>
10373>>>>>    //***
10373>>>>>    //*** Procedure: SQLCall
10373>>>>>    //*** Purpose  : Call a stored procedure
10373>>>>>    //***
10373>>>>>
10373>>>>>    Procedure SQLCall
10375>>>>>        Integer ihdbc
10375>>>>>        Integer ihstmt
10375>>>>>        String  sDrvrId
10375>>>>>        Integer iVoid
10375>>>>>        String  sEmpty
10375>>>>>
10375>>>>>        //*** Initialize
10375>>>>>        Move "" To sEmpty
10376>>>>>
10376>>>>>        //*** Get the cli handles
10376>>>>>        Get phCLIStatementHandle  to ihstmt
10377>>>>>        Get phCLIConnectionHandle to ihdbc
10378>>>>>        Get psDriverId            to sDrvrId
10379>>>>>
10379>>>>>        //*** Call the procedure
10379>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
10381>>>>>            //*** Call the procedure
10381>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLCALL ;                        Callback Self ;                        Passing ihdbc sEmpty ihstmt ;                        Result iVoid
10386>>>>>                        
10386>>>>>            Send SQLGetStatementAttributes
10387>>>>>            Set piLastArgument To 0
10388>>>>>        End
10388>>>>>>
10388>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLCall"
10390>>>>>    End_Procedure 
10391>>>>>
10391>>>>>
10391>>>>>
10391>>>>>    //***
10391>>>>>    //*** Function: SQLGetNextArgument
10391>>>>>    //*** Purpose : Get the next argument
10391>>>>>    //***
10391>>>>>
10391>>>>>    Function SQLGetNextArgument Returns String
10393>>>>>        Integer iArgnum
10393>>>>>        String  sResult
10393>>>>>
10393>>>>>        Get piLastArgument To iArgnum
10394>>>>>        Increment iArgnum
10395>>>>>        Get SQLGetArgument iArgnum To sResult
10396>>>>>        Set piLastArgument To iArgnum
10397>>>>>
10397>>>>>        Function_return sResult
10398>>>>>    End_Function 
10399>>>>>
10399>>>>>
10399>>>>>
10399>>>>>    //***
10399>>>>>    //*** Function: SQLGetArgument
10399>>>>>    //*** Purpose : Get the specified argument from a procedure
10399>>>>>    //***
10399>>>>>
10399>>>>>    Function SQLGetArgument Integer iArgnum Returns String
10401>>>>>        Integer ihdbc
10401>>>>>        Integer ihstmt
10401>>>>>        String  sDrvrId
10401>>>>>        Integer iVoid
10401>>>>>        String  sEmpty
10401>>>>>        String  sArgument
10401>>>>>        Integer iLen
10401>>>>>
10401>>>>>        //*** Initialize
10401>>>>>        Move "" To sEmpty
10402>>>>>        Move "" To sArgument
10403>>>>>
10403>>>>>        //*** Get the cli handles
10403>>>>>        Get phCLIStatementHandle  to ihstmt
10404>>>>>        Get phCLIConnectionHandle to ihdbc
10405>>>>>        Get psDriverId            to sDrvrId
10406>>>>>
10406>>>>>        //*** Call the procedure
10406>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
10408>>>>>            //*** Pass the information
10408>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                        Callback Self ;                        Passing ihdbc iArgnum ihstmt ;                        Result iVoid
10413>>>>>
10413>>>>>            //*** Get the length
10413>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLGETPROCARGLEN ;                        Callback Self ;                        Passing sEmpty sEmpty 0 ;                        Result iLen
10418>>>>>
10418>>>>>            If (iLen) Begin
10420>>>>>                //*** Allocate
10420>>>>>                Move (Repeat(' ', iLen)) To sArgument
10421>>>>>
10421>>>>>                //*** Pass the argument
10421>>>>>                Call_driver 0 sDrvrId Function FUNC_SQLGETPROCARG ;                            Callback Self ;                            Passing sArgument sEmpty 0 ;                            Result iVoid
10426>>>>>            End
10426>>>>>>
10426>>>>>        End
10426>>>>>>
10426>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLGetArgument"
10428>>>>>
10428>>>>>        Function_Return sArgument
10429>>>>>    End_Function 
10430>>>>>
10430>>>>>
10430>>>>>
10430>>>>>    //***
10430>>>>>    //*** Function: SQLReturnValue
10430>>>>>    //*** Purpose : Get the return value of a stored function
10430>>>>>    //***
10430>>>>>
10430>>>>>    Function SQLReturnValue Returns String
10432>>>>>        Integer ihdbc
10432>>>>>        Integer ihstmt
10432>>>>>        String  sDrvrId
10432>>>>>        Integer iVoid
10432>>>>>        String  sEmpty
10432>>>>>        String  sRetval
10432>>>>>        Integer iLen
10432>>>>>
10432>>>>>        //*** Initialize
10432>>>>>        Move "" To sEmpty
10433>>>>>        Move "" To sRetval
10434>>>>>
10434>>>>>        //*** Get the cli handles
10434>>>>>        Get phCLIStatementHandle  to ihstmt
10435>>>>>        Get phCLIConnectionHandle to ihdbc
10436>>>>>        Get psDriverId            to sDrvrId
10437>>>>>
10437>>>>>        //*** Call the procedure
10437>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
10439>>>>>            //*** Get the length
10439>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLGETPROCRETVALLEN ;                        Callback Self ;                        Passing ihdbc sEmpty ihstmt  ;                        Result iLen
10444>>>>>
10444>>>>>            If (iLen) Begin
10446>>>>>                //*** Allocate
10446>>>>>                Move (Repeat(' ', iLen)) To sRetval
10447>>>>>
10447>>>>>                //*** Pass the argument
10447>>>>>                Call_driver 0 sDrvrId Function FUNC_SQLGETPROCRETVAL ;                            Callback Self ;                            Passing ihdbc sRetval ihstmt ;                            Result iVoid
10452>>>>>            End
10452>>>>>>
10452>>>>>        End
10452>>>>>>
10452>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLReturnValue"
10454>>>>>
10454>>>>>        Function_Return sRetval
10455>>>>>    End_Function 
10456>>>>>
10456>>>>>
10456>>>>>
10456>>>>>    //***
10456>>>>>    //*** Function: SQLNextResultSet
10456>>>>>    //*** Purpose : Switch to the next set
10456>>>>>    //*** Returns : 0   = No more result sets
10456>>>>>    //***           <>0 = Switched to next set
10456>>>>>    //***
10456>>>>>
10456>>>>>    Function SQLNextResultSet Returns Integer
10458>>>>>        Integer ihdbc
10458>>>>>        Integer ihstmt
10458>>>>>        String  sDrvrId
10458>>>>>        Integer iResult
10458>>>>>        String  sEmpty
10458>>>>>
10458>>>>>        //*** Initialize
10458>>>>>        Move "" To sEmpty
10459>>>>>        Move 0  To iResult
10460>>>>>
10460>>>>>        //*** Get the cli handles
10460>>>>>        Get phCLIStatementHandle  to ihstmt
10461>>>>>        Get phCLIConnectionHandle to ihdbc
10462>>>>>        Get psDriverId            to sDrvrId
10463>>>>>
10463>>>>>        //*** Call the procedure
10463>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
10465>>>>>            //*** Get the length
10465>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLNEXTRESULTSET ;                        Callback Self ;                        Passing ihdbc sEmpty ihstmt  ;                        Result iResult
10470>>>>>                        
10470>>>>>            Send SQLGetStatementAttributes
10471>>>>>            Set piLastArgument to 0
10472>>>>>        End
10472>>>>>>
10472>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLNextResultSet"
10474>>>>>
10474>>>>>        Function_Return iResult
10475>>>>>    End_Function
10476>>>>>
10476>>>>>
10476>>>>>
10476>>>>>    //***
10476>>>>>    //*** Procedure: SQLFetchActivatesBuffer
10476>>>>>    //*** Purpose  : Setup a file that will be acivated after a succesfull
10476>>>>>    //***            fetch on the statement
10476>>>>>    //***
10476>>>>>
10476>>>>>    Procedure SQLFetchActivatesBuffer Integer iFileNum Integer bState
10478>>>>>        Integer ihdbc
10478>>>>>        Integer ihstmt
10478>>>>>        String  sDrvrId
10478>>>>>        Integer iResult
10478>>>>>        Integer bIsOpen
10478>>>>>        Integer iVoid
10478>>>>>        String  sFileType
10478>>>>>
10478>>>>>        //*** Check if file is open
10478>>>>>        Get_attribute DF_FILE_OPENED Of iFileNum To bIsOpen
10481>>>>>        If (bIsOpen) Begin
10483>>>>>            //*** Get the cli handles
10483>>>>>            Get phCLIStatementHandle  to ihstmt
10484>>>>>            Get phCLIConnectionHandle to ihdbc
10485>>>>>            Get psDriverId            to sDrvrId
10486>>>>>
10486>>>>>            //*** Call the procedure
10486>>>>>            If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
10488>>>>>                //*** Check if the file has the correct type
10488>>>>>                Get_attribute DF_FILE_DRIVER Of iFileNum To sFileType
10491>>>>>                If (sFileType = sDrvrId) Begin
10493>>>>>                    //*** Setup the buffer
10493>>>>>                    Call_driver iFileNum sDrvrId Function FUNC_SQLBUFFERSTATUS ;                                Callback Self ;                                Passing ihdbc bState ihstmt  ;                                Result iVoid
10498>>>>>                End
10498>>>>>>
10498>>>>>                Else ;                    Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File" * String(iFileNum) * "type incompatible with statement ("  + sFileType + ")") "SQLBindFile"
10500>>>>>            End
10500>>>>>>
10500>>>>>            Else ;                Send HandleError ihstmt ihdbc sDrvrId "SQLFetchActivatesBuffer"
10502>>>>>        End
10502>>>>>>
10502>>>>>        Else ;            Send StmtError CLIERR_SQLINVALID_BUFFER ("File not open (number =" * String(iFileNum) + ")") "SQLFetchActivatesBuffer"
10504>>>>>    End_Procedure 
10505>>>>>
10505>>>>>
10505>>>>>
10505>>>>>    Function SQLGetMessage Integer iMessageNum Returns String
10507>>>>>        Integer ihdbc
10507>>>>>        Integer ihstmt
10507>>>>>        String  sDrvrId
10507>>>>>        String  sMessage
10507>>>>>        Integer iVoid
10507>>>>>
10507>>>>>        //*** Initialize
10507>>>>>        Move "" To sMessage
10508>>>>>
10508>>>>>        //*** Get the cli handles
10508>>>>>        Get phCLIStatementHandle  to ihstmt
10509>>>>>        Get phCLIConnectionHandle to ihdbc
10510>>>>>        Get psDriverId            to sDrvrId
10511>>>>>
10511>>>>>        //*** Call the procedure
10511>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
10513>>>>>            //*** Setup function arguments
10513>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                        Callback Self ;                        Passing ihdbc iMessageNum ihstmt ;                        Result iVoid
10518>>>>>
10518>>>>>            Move (Repeat(' ', 1024)) To sMessage
10519>>>>>            //*** Get the length
10519>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLGETMESSAGE ;                        Callback Self ;                        Passing iVoid sMessage iVoid ;                        Result iVoid
10524>>>>>        End
10524>>>>>>
10524>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLGetDiagRec"
10526>>>>>
10526>>>>>        Function_Return sMessage
10527>>>>>    End_Function 
10528>>>>>
10528>>>>>
10528>>>>>
10528>>>>>    //***
10528>>>>>    //*** Function: RemoveComponentIdentifier
10528>>>>>    //*** Purpose : Remove the component identifier from a diagnostic message
10528>>>>>    //***
10528>>>>>
10528>>>>>    Function RemoveComponentIdentifier String sDiagMessage Returns String
10530>>>>>        While (Left(sDiagMessage, 1) = "[")
10534>>>>>            Move (Right(sDiagMessage, Length(sDiagMessage) - Pos("]", sDiagMessage))) To sDiagMessage
10535>>>>>        End
10536>>>>>>
10536>>>>>
10536>>>>>        Function_Return sDiagMessage
10537>>>>>    End_Function
10538>>>>>
10538>>>>>
10538>>>>>
10538>>>>>    //***
10538>>>>>    //*** Function: DFDateToSQLDate
10538>>>>>    //*** Purpose : Convert a DataFlex date to a SQL Date. Use dummy zero dates.
10538>>>>>    //***
10538>>>>>    Function DFDateToSQLDate Date dDFDate Integer iSQLType Returns String
10540>>>>>        
10540>>>>>        Integer iType
10540>>>>>        String  sSQLDate
10540>>>>>        Integer iOrgDateFmt
10540>>>>>        Integer iOrgDateSep
10540>>>>>
10540>>>>>        String sDriverId
10540>>>>>        String sDummyZeroDate
10540>>>>>        String sDummyZeroDateMssqlDatetime
10540>>>>>
10540>>>>>        //*** Change date format to military, SQL dates are military dates
10540>>>>>        Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
10543>>>>>        Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
10546>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
10549>>>>>        Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
10552>>>>>
10552>>>>>        //*** We only need to convert if the date is 0
10552>>>>>        If (Integer(dDFDate = 0)) Begin
10554>>>>>
10554>>>>>            If (num_arguments < 2) Begin
10556>>>>>                Move SQL_TYPE_TIMESTAMP to iType
10557>>>>>            End
10557>>>>>>
10557>>>>>            Else Begin
10558>>>>>                Move iSQLType to iType
10559>>>>>            End
10559>>>>>>
10559>>>>>
10559>>>>>            
10559>>>>>            Get psDriverID to sDriverId
10560>>>>>            Get psDummyZeroDate to sDummyZeroDate
10561>>>>>                
10561>>>>>            If ( (iType = SQL_TYPE_TIMESTAMP) and (sDriverID = 'MSSQLDRV') ) Begin
10563>>>>>                Get psDummyZeroDateMssqlDatetime to sDummyZeroDateMssqlDatetime
10564>>>>>                Move sDummyZeroDateMssqlDatetime to sSQLDate
10565>>>>>            End
10565>>>>>>
10565>>>>>            Else Begin
10566>>>>>                Move sDummyZeroDate to sSQLDate
10567>>>>>            End
10567>>>>>>
10567>>>>>            
10567>>>>>            //CLI_Get_Driver_Attribute sDRiver DRVR_DUMMY_ZERO_DATE_VALUE to sSQLDate
10567>>>>>        End
10567>>>>>>
10567>>>>>        Else Begin
10568>>>>>            Move dDFDate to sSQLDate
10569>>>>>        End
10569>>>>>>
10569>>>>>
10569>>>>>        //*** Change date format back to original
10569>>>>>        Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
10572>>>>>        Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
10575>>>>>
10575>>>>>        Function_Return sSQLDate
10576>>>>>    End_Function 
10577>>>>>
10577>>>>>
10577>>>>>    //***
10577>>>>>    //*** Function: SQLDateToDFDate
10577>>>>>    //*** Purpose : Convert a SQL date to a DataFlex Date. Use dummy zero dates.
10577>>>>>    //***
10577>>>>>    Function SQLDateToDFDate String sSQLDate Returns Date
10579>>>>>        
10579>>>>>        Integer iType
10579>>>>>        Date    dDFDate
10579>>>>>        Integer iOrgDateFmt
10579>>>>>        Integer iOrgDateSep
10579>>>>>        
10579>>>>>        String  sDriverId
10579>>>>>        String  sDummyZeroDate
10579>>>>>        String  sDummyZeroDateMssqlDatetime
10579>>>>>        
10579>>>>>        Get psDriverID to sDriverId
10580>>>>>        
10580>>>>>        Get psDummyZeroDate to sDummyZeroDate
10581>>>>>        Get psDummyZeroDateMssqlDatetime to sDummyZeroDateMssqlDatetime
10582>>>>>        
10582>>>>>        Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
10585>>>>>        Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
10588>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
10591>>>>>        Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
10594>>>>>        
10594>>>>>        Move (Left(sSQLDate,10)) to sSQLDate 
10595>>>>>
10595>>>>>        If ( (sSQLDate = sDummyZeroDate) or ;             ( (sDriverId = 'MSSQLDRV') and (sSQLDate = sDummyZeroDateMssqlDatetime) ) )  Begin
10597>>>>>            Move 0 to dDFDate
10598>>>>>        End
10598>>>>>>
10598>>>>>        Else Begin
10599>>>>>            Move sSQLDate to dDFDate
10600>>>>>        End
10600>>>>>>
10600>>>>>
10600>>>>>        //*** Change date format back to original
10600>>>>>        Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
10603>>>>>        Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
10606>>>>>
10606>>>>>        Function_Return dDFDate
10607>>>>>    End_Function 
10608>>>>>
10608>>>>>End_Class 
10609>>>>>
10609>>>>>
10609>>>>>//*****************************************************************************
10609>>>>>//*** Class  : cSQLConnection                                               ***
10609>>>>>//*** Purpose: Connection object for embedded SQL                           ***
10609>>>>>//***                                                                       ***
10609>>>>>//*** Description:                                                          ***
10609>>>>>//***   This provides the ability to create a connection for a driver.      ***
10609>>>>>//***   It will contain child statement objects                             ***
10609>>>>>//*****************************************************************************
10609>>>>>
10609>>>>>Class cSQLConnection is a cObject
10610>>>>>
10610>>>>>    Procedure Construct_object 
10612>>>>>        Forward Send Construct_object 
10614>>>>>
10614>>>>>        Property Integer phCLIConnectionHandle       0
10615>>>>>        
10615>>>>>        Property String  psDriverID        ""
10616>>>>>        Property Integer piBindFile        0
10617>>>>>        
10617>>>>>        Property String psDummyZeroDate              '0001-01-01'
10618>>>>>        Property String psDummyZeroDateMssqlDatetime '1753-01-01'        
10619>>>>>
10619>>>>>    End_Procedure
10620>>>>>
10620>>>>>
10620>>>>>
10620>>>>>    //***
10620>>>>>    //*** Procedure: StoreConnectionInfo
10620>>>>>    //*** Purpose  : Store basic information about the connection
10620>>>>>    //***
10620>>>>>    Procedure StoreConnectionInfo Handle hCLIConnectionHandle String sDrvrId 
10622>>>>>        
10622>>>>>        String sDummyZeroDate
10622>>>>>        
10622>>>>>        Set phCLIConnectionHandle to hCLIConnectionHandle
10623>>>>>        Set psDriverID            to sDrvrId
10624>>>>>        
10624>>>>>        Case Begin
10624>>>>>            Case (sDrvrId = "MSSQLDRV")
10626>>>>>                Set psDummyZeroDate to '0001-01-01'
10627>>>>>                Set psDummyZeroDateMssqlDatetime to '1753-01-01'
10628>>>>>                Break
10629>>>>>            Case (sDrvrId = "DB2_DRV")
10632>>>>>                Set psDummyZeroDate to '0001-01-01'
10633>>>>>                Break
10634>>>>>            Case (sDrvrId = "ODBC_DRV")
10637>>>>>                CLI_Get_Driver_Attribute sDrvrId DRVR_DUMMY_ZERO_DATE_VALUE to sDummyZeroDate
10644>>>>>                Set psDummyZeroDate to sDummyZeroDate
10645>>>>>                Break
10646>>>>>        Case End
10646>>>>>        
10646>>>>>    End_Procedure 
10647>>>>>
10647>>>>>
10647>>>>>    //***
10647>>>>>    //*** Procedure: DestroySQLConnection
10647>>>>>    //*** Purpose : Destroy the SQLConnection object
10647>>>>>    //***
10647>>>>>    Procedure DestroySQLConnection
10649>>>>>        Send Destroy
10650>>>>>    End_Procedure 
10651>>>>>
10651>>>>>
10651>>>>>    //***
10651>>>>>    //*** Function: SQLConnect
10651>>>>>    //*** Purpose : Connect to a database server
10651>>>>>    //*** Returns : 1 Succesfully connected
10651>>>>>    //***           0 Not connected
10651>>>>>    Function SQLConnect String sDrvrID String sConnect Returns Integer
10653>>>>>        Integer ihdbc
10653>>>>>        String  sEmpty
10653>>>>>
10653>>>>>        //*** Initialize
10653>>>>>        Move "" To sEmpty
10654>>>>>        Move 0  To ihdbc
10655>>>>>
10655>>>>>        Indicate Err False
10656>>>>>
10656>>>>>        //*** Call the driver function to connect
10656>>>>>        Call_driver 0 sDrvrId Function FUNC_SQLCONNECT ;                    Callback Self ;                    Passing sConnect sEmpty Self ;                    Result ihdbc
10661>>>>>
10661>>>>>        //*** If there was an error, make result invalid
10661>>>>>        If (Err) ;            Move 0 To ihdbc
10664>>>>>
10664>>>>>        //*** Check result and store it
10664>>>>>        If (ihdbc <> 0) ;            Send StoreConnectionInfo ihdbc sDrvrId
10667>>>>>
10667>>>>>        //*** Return success status
10667>>>>>        Function_Return (ihdbc <> 0)
10668>>>>>    End_Function 
10669>>>>>
10669>>>>>
10669>>>>>
10669>>>>>    //***
10669>>>>>    //*** Function: SQLFileConnect
10669>>>>>    //*** Purpose : Use a connection of an already open file
10669>>>>>    //***
10669>>>>>    Function SQLFileConnect Integer iFileNum Returns Integer
10671>>>>>        Integer ihdbc
10671>>>>>        Integer bIsOpen
10671>>>>>        String  sDrvrId
10671>>>>>        String  sEmpty
10671>>>>>
10671>>>>>        //*** Initialize
10671>>>>>        Move "" To sEmpty
10672>>>>>        Move 0  To ihdbc
10673>>>>>
10673>>>>>        //*** Check if file is open
10673>>>>>        Get_attribute DF_FILE_OPENED Of iFileNum To bIsOpen
10676>>>>>        If (bIsOpen) Begin
10678>>>>>            //*** Fill the driver id, assume longest is 255 characters
10678>>>>>            Move (Repeat(' ', 255)) To sDrvrId
10679>>>>>            Get_attribute DF_FILE_DRIVER Of iFileNum To sDrvrId
10682>>>>>
10682>>>>>            Indicate Err False
10683>>>>>
10683>>>>>            //*** Call the driver function to connect
10683>>>>>            Call_driver iFileNum sDrvrId Function FUNC_SQLFILECONNECT ;                        Callback Self ;                        Passing sEmpty sEmpty 0 ;                        Result ihdbc
10688>>>>>
10688>>>>>            //*** If there was an error, make result invalid
10688>>>>>            If (Err) ;                Move 0 To ihdbc
10691>>>>>
10691>>>>>            //*** Check result and store it
10691>>>>>            If (ihdbc <> 0) Begin
10693>>>>>                //*** Somehow Call_driver overwrites the sDrvrId variable, restore it here
10693>>>>>                Get_attribute DF_FILE_DRIVER Of iFileNum To sDrvrId
10696>>>>>                Send StoreConnectionInfo ihdbc sDrvrId
10697>>>>>
10697>>>>>                //*** Set filenum so it can be used for fetching
10697>>>>>                Set piBindFile To iFileNum
10698>>>>>            End
10698>>>>>>
10698>>>>>        End
10698>>>>>>
10698>>>>>
10698>>>>>        //*** Return success status
10698>>>>>        Function_Return (ihdbc <> 0)
10699>>>>>    End_Function
10700>>>>>
10700>>>>>
10700>>>>>
10700>>>>>    //***
10700>>>>>    //*** Procedure: SQLDisconnect
10700>>>>>    //*** Purpose  : Disconnect from an embedded SQL server and free allocated
10700>>>>>    //***            resources
10700>>>>>    //***
10700>>>>>    Procedure SQLDisconnect
10702>>>>>        Integer ihdbc
10702>>>>>        Integer iVoid
10702>>>>>        String  sDrvrId
10702>>>>>        String  sEmpty
10702>>>>>
10702>>>>>        //*** Initialize
10702>>>>>        Move "" To sEmpty
10703>>>>>
10703>>>>>        //*** Get the cli handle
10703>>>>>        Get phCLIConnectionHandle to ihdbc
10704>>>>>        Get psDriverId To sDrvrId
10705>>>>>
10705>>>>>        //*** Free the CLI handle
10705>>>>>        If (ihdbc <> 0) Begin
10707>>>>>            //*** Call the driver function to disconnect
10707>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLDISCONNECT ;                        Callback Self ;                        Passing sEmpty sEmpty ihdbc ;                        Result iVoid
10712>>>>>
10712>>>>>            Move -1 to giLastSQLhdbc
10713>>>>>
10713>>>>>            //*** Free the DataFlex handle
10713>>>>>            Send DestroySQLConnection
10714>>>>>        End
10714>>>>>>
10714>>>>>    End_Procedure 
10715>>>>>
10715>>>>>
10715>>>>>
10715>>>>>    //***
10715>>>>>    //*** Function: CreateSQLStatement
10715>>>>>    //*** Purpose : Create a cSQLStatement object
10715>>>>>    //***
10715>>>>>    Function CreateSQLStatement Returns Handle
10717>>>>>        
10717>>>>>        Handle hoSQLStatement
10717>>>>>        Get Create (RefClass(cSQLStatement)) to hoSQLStatement
10718>>>>>        
10718>>>>>        //*** If the connection has a default Bind File, assign it to the
10718>>>>>        //*** statement object. The default is set when you open a file with a
10718>>>>>        //*** SetFileConnection command.
10718>>>>>        Set piBindFile of hoSQLStatement to (piBindFile(Self))
10719>>>>>        
10719>>>>>        Function_Return hoSQLStatement
10720>>>>>    End_Function 
10721>>>>>
10721>>>>>
10721>>>>>    //***
10721>>>>>    //*** Function: SQLOpen
10721>>>>>    //*** Prupose : Open a statement for use
10721>>>>>    //***
10721>>>>>    Function SQLOpen Returns Handle
10723>>>>>        Handle  hoSQLStatement
10723>>>>>        Integer ihdbc
10723>>>>>        Integer ihstmt
10723>>>>>        Integer iVoid
10723>>>>>        String  sDrvrId
10723>>>>>        String  sEmpty
10723>>>>>        String  sDummyZeroDate
10723>>>>>        String  sDummyZeroDateMssqlDatetime 
10723>>>>>
10723>>>>>        //*** Initialize
10723>>>>>        Move "" To sEmpty
10724>>>>>
10724>>>>>        //*** Get the cli handle to the connection
10724>>>>>        Get phCLIConnectionHandle to ihdbc
10725>>>>>        Get psDriverId  To sDrvrId
10726>>>>>
10726>>>>>        //*** Allocate a new handle and populate it
10726>>>>>        If (ihdbc <> 0) Begin
10728>>>>>            //**** Create a new cSQLStatement object
10728>>>>>            Get CreateSQLStatement to hoSQLStatement
10729>>>>>
10729>>>>>            //*** Call the driver function to allocate a cli statement handle
10729>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLOPEN ;                        Callback Self ;                        Passing hoSQLStatement sEmpty ihdbc ;                        Result ihstmt
10734>>>>>
10734>>>>>            //*** If unsuccessful destroy hoSQLStatement
10734>>>>>            If (ihstmt = 0) Begin
10736>>>>>                Send DestroySQLStatement of hoSQLStatement
10737>>>>>                Move 0 to hoSQLStatement
10738>>>>>            End
10738>>>>>>
10738>>>>>            Else Begin
10739>>>>>                Send StoreStatementInfo of hoSQLStatement ihstmt sDrvrId ihdbc
10740>>>>>
10740>>>>>                // Store DummyZeroDate of hoSQLConnection in hoSQLStatement
10740>>>>>                Get psDummyZeroDate              to sDummyZeroDate
10741>>>>>                Get psDummyZeroDateMssqlDatetime to sDummyZeroDateMssqlDatetime
10742>>>>>                
10742>>>>>                Set psDummyZeroDate              of hoSQLStatement to sDummyZeroDate
10743>>>>>                Set psDummyZeroDateMssqlDatetime of hoSQLStatement to sDummyZeroDateMssqlDatetime
10744>>>>>                
10744>>>>>            End
10744>>>>>>
10744>>>>>        End
10744>>>>>>
10744>>>>>
10744>>>>>        Function_Return hoSQLStatement
10745>>>>>    End_Function 
10746>>>>>
10746>>>>>End_Class 
10747>>>>>
10747>>>>>
10747>>>>>
10747>>>>>//*****************************************************************************
10747>>>>>//*** Class  : cSQLHandlemanager                                            ***
10747>>>>>//*** Purpose: Manager for embedded SQL handles.                            ***
10747>>>>>//***                                                                       ***
10747>>>>>//*** Description:                                                          ***
10747>>>>>//***   We want to be able to use multiple drivers and multiple             ***
10747>>>>>//***   connections within a driver and multiple statements within a        ***
10747>>>>>//***   connection. To allow this we have placed our own handle logic on    ***
10747>>>>>//***   top of the driver handle logic. This way we can handle the          ***
10747>>>>>//***   situation where two driver handles may be equal.                    ***
10747>>>>>//*****************************************************************************
10747>>>>>
10747>>>>>Class cSQLHandleManager is a cObject
10748>>>>>
10748>>>>>    Procedure Construct_object 
10750>>>>>        Forward Send Construct_object 
10752>>>>>
10752>>>>>        Property String  psDefaultDriver      ""
10753>>>>>        Property String  psDefaultConnection  ""
10754>>>>>
10754>>>>>    End_Procedure 
10755>>>>>
10755>>>>>    //***
10755>>>>>    //*** Function: CreateSQLConnection
10755>>>>>    //*** Purpose : Create a cSQLConnection object
10755>>>>>    //***
10755>>>>>    Function CreateSQLConnection Returns Handle
10757>>>>>        Handle hoSQLConnection
10757>>>>>        Get Create (RefClass(cSQLConnection)) to hoSQLConnection
10758>>>>>        Function_Return hoSQLConnection
10759>>>>>    End_Function 
10760>>>>>
10760>>>>>
10760>>>>>    //***
10760>>>>>    //*** Procedure: SQLSetConnect
10760>>>>>    //*** Purpose  : Store default connection information
10760>>>>>    //***
10760>>>>>
10760>>>>>    Procedure SQLSetConnect String sDriver String sConnect
10762>>>>>        Set psDefaultDriver      To sDriver
10763>>>>>        Set psDefaultConnection  To sConnect
10764>>>>>    End_Procedure 
10765>>>>>
10765>>>>>
10765>>>>>
10765>>>>>    //***
10765>>>>>    //*** Function: SQLConnect
10765>>>>>    //*** Purpose : Make a connection to an embedded SQL server
10765>>>>>    //*** Returns : The DataFlex handle to the connection
10765>>>>>    //***
10765>>>>>    Function SQLConnect String sDrvrID String sConnect Returns integer
10767>>>>>        Handle hoSQLConnection
10767>>>>>        Integer bOK
10767>>>>>
10767>>>>>        //*** Check arguments
10767>>>>>        If (sDrvrID = "" And sConnect = "") Begin
10769>>>>>            Get psDefaultDriver      To sDrvrId
10770>>>>>            Get psDefaultConnection  To sConnect
10771>>>>>        End
10771>>>>>>
10771>>>>>
10771>>>>>        //*** Create a cSQLConnection object
10771>>>>>        Get CreateSQLConnection to hoSQLConnection
10772>>>>>        //*** Connect to the database 
10772>>>>>        Get SQLConnect of hoSQLConnection sDrvrID sConnect to bOK
10773>>>>>
10773>>>>>        //*** If connection to the database failed, destroy the cSQLConnection object and return a 0 handle
10773>>>>>        If (not(bOK)) Begin
10775>>>>>            Send DestroySQLConnection of hoSQLConnection
10776>>>>>            Move 0 to hoSQLConnection
10777>>>>>        End
10777>>>>>>
10777>>>>>
10777>>>>>        Function_Return hoSQLConnection
10778>>>>>    End_Function 
10779>>>>>
10779>>>>>
10779>>>>>
10779>>>>>    //***
10779>>>>>    //*** Function: SQLFileConnect
10779>>>>>    //*** Purpose : Make an existing connection available for use with Embedded SQL.
10779>>>>>    //***           The connection is identified by the number of a file
10779>>>>>    //***           that is open for that connection.
10779>>>>>    //***
10779>>>>>
10779>>>>>    Function SQLFileConnect Integer iFileNum Returns Handle
10781>>>>>        Handle hoSQLConnection
10781>>>>>        Integer bOK
10781>>>>>
10781>>>>>        //*** Create a cSQLConnection object
10781>>>>>        Get CreateSQLConnection to hoSQLConnection
10782>>>>>        Get SQLFileConnect of hoSQLConnection iFileNum To bOK
10783>>>>>
10783>>>>>        //*** If connection to the database failed, destroy the cSQLConnection object and return a 0 handle
10783>>>>>        If (not(bOK)) Begin
10785>>>>>            Send DestroySQLConnection of hoSQLConnection
10786>>>>>            Move 0 to hoSQLConnection
10787>>>>>        End
10787>>>>>>
10787>>>>>
10787>>>>>        Function_Return hoSQLConnection
10788>>>>>    End_Function 
10789>>>>>
10789>>>>>End_Class 
10790>>>>>
10790>>>
10790>>>//*** Driver Indentification
10790>>>
10790>>>//*** Error number constants
10790>>>
10790>>>
10790>>>//*** Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
10790>>>
10790>>>
10790>>>
10790>>>
10790>>>// SQL Server spcific types. 
10790>>>Define SQL_SS_TIMESTAMPOFFSET   for   (-155) //SQL server datetimeoffset type */
10790>>>Define SQL_SS_TIME2             for   (-154) //SQL server time type */
10790>>>Define SQL_SS_XML               for   (-152) //SQL server xml type */
10790>>>Define SQL_SS_VARIANT           for   (-150) //SQL server variant type */
10790>>>
10790>>>// SQL Server spcific types. 
10790>>>Define SQL_TYPE_TIMESTAMP2      for   (-200) //SQL server datetime2 type */
10790>>>Define SQL_VARCHARMAX           for   (-201) //SQL server varchar(max) type */
10790>>>Define SQL_WVARCHARMAX          for   (-202) //SQL server wvarchar(max) type */
10790>>>Define SQL_VARBINARYMAX         for   (-203) //SQL server varbinary(max) type */
10790>>>Define SQL_TYPE_MONEY           for   (-204) //SQL server money type */
10790>>>Define SQL_TYPE_SMALLMONEY      for   (-205) //SQL server smallmoney type */
10790>>>Define SQL_TYPE_SMALLDATETIME   for   (-206) //SQL server smalldatetype type */
10790>>>
10790>>>
10790>>>//*****************************************************************************
10790>>>//*** MSSQL_SetConstraint <FileNum> <ConstraintText>                        ***
10790>>>//***                                                                       ***
10790>>>//***   Setup a constraint for a file.                                      ***
10790>>>//*****************************************************************************
10790>>>
10790>>>
10790>>>
10790>>>Class cMSSQLHandler Is A cCLIHandler
10791>>>
10791>>>    Procedure Construct_Object
10793>>>        Forward Send Construct_Object
10795>>>
10795>>>        Set psDriverID To MSSQLDRV_ID
10796>>>    End_Procedure // Construct_Object
10797>>>
10797>>>
10797>>>
10797>>>    //***
10797>>>    //*** Function: ExtractList
10797>>>    //*** Purpose : Extract the list from the out connect string.
10797>>>    //***
10797>>>
10797>>>    Function ExtractList String sOutConnStr Integer hoStore Returns Integer
10799>>>        Local String  sItem
10799>>>        Local Integer iStart
10799>>>        Local Integer iEnd
10799>>>
10799>>>        If (hoStore = 0) ;            Move Current_object To hoStore
10802>>>
10802>>>        Send Delete_Data To hoStore
10803>>>        Move (Pos("{", sOutConnStr)) To iStart
10804>>>        While (iStart > 0)
10808>>>            Move (Right(sOutConnStr, Length(sOutConnStr) - iStart)) To sOutConnStr
10809>>>            If (Left(sOutConnStr, 1) = "}") ;                Move 0 To iStart
10812>>>            Else Begin
10813>>>                Move (Pos(",", sOutConnStr)) To iStart
10814>>>                Move (Pos("}", sOutConnStr)) To iEnd
10815>>>                If ((iStart = 0) Or (iEnd < iStart)) ;                    Move iEnd To iStart
10818>>>
10818>>>                If (iStart > 0) ;                    Set Value Of hoStore Item (Item_Count(Current_Object)) To (Left(sOutConnStr, iStart - 1))
10821>>>
10821>>>                If (iStart = iEnd) ;                    Move 0 To iStart
10824>>>            End
10824>>>>
10824>>>        Loop
10825>>>>
10825>>>
10825>>>        Function_Return (Item_Count(hoStore))
10826>>>    End_Procedure // ExtractList
10827>>>
10827>>>
10827>>>
10827>>>    //***
10827>>>    //*** Function: BrowseConnect
10827>>>    //*** Purpose : Call the driver's browse connect function
10827>>>    //***
10827>>>
10827>>>    Function BrowseConnect String sInConnStr Returns String
10829>>>        Local String  sDriver
10829>>>        Local String  sOutConnStr
10829>>>        Local Integer iArg
10829>>>        Local Integer iRetval
10829>>>
10829>>>        Get psDriverID To sDriver
10830>>>        If (sDriver <> "") Begin
10832>>>            Move (Repeat(" ", 8192)) To sOutConnStr
10833>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
10838>>>        End
10838>>>>
10838>>>
10838>>>        Function_Return sOutConnStr
10839>>>    End_Function// BrowseConnect
10840>>>
10840>>>    Function DriverIndex String sDriver Returns Integer
10842>>>    
10842>>>        Local String  sCurrentDriver
10842>>>        Local Integer iNumberOfDrivers iDriver iCount
10842>>>    
10842>>>        Move 0 to iDriver
10843>>>    
10843>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
10846>>>        For iCount from 1 to iNumberOfDrivers
10852>>>>
10852>>>    
10852>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
10855>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriver) ) Begin
10857>>>                Move iCount to iDriver
10858>>>            End
10858>>>>
10858>>>        Loop
10859>>>>
10859>>>    
10859>>>        Function_Return iDriver
10860>>>    
10860>>>    End_Function 
10861>>>
10861>>>    //***
10861>>>    //*** Procedure: EnumerateServers
10861>>>    //*** Purpose  : Enumerate the available SQL Server database servers
10861>>>    //***
10861>>>    Function EnumerateServers Returns Integer
10863>>>        Local String  sServerList
10863>>>        Local Integer iNumServers
10863>>>        Local Integer iDriver
10863>>>        Local Integer iClientVersion
10863>>>        Local String  sDriver
10863>>>        
10863>>>        Get DriverIndex MSSQLDRV_ID to iDriver
10864>>>        
10864>>>        Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
10867>>>        
10867>>>        If (iClientVersion = SQLSERVER2012CLIENT) Begin
10869>>>            Move SQLSERVER2012DRVRSTR to sDriver
10870>>>        End
10870>>>>
10870>>>        Else Begin
10871>>>            If (iClientVersion = SQLSERVER2008CLIENT) Begin
10873>>>                Move SQLSERVER2008DRVRSTR to sDriver
10874>>>            End  
10874>>>>
10874>>>            Else Begin
10875>>>                If (iClientVersion = SQLSERVER2005CLIENT) Begin
10877>>>                    Move SQLSERVER2005DRVRSTR to sDriver
10878>>>                End  
10878>>>>
10878>>>                Else Begin
10879>>>                    Move SQLSERVER2000DRVRSTR to sDriver 
10880>>>                End
10880>>>>
10880>>>            End
10880>>>>
10880>>>        End
10880>>>>
10880>>>
10880>>>        Move ("DRIVER={" + sDriver + "};") to sDriver
10881>>>        Get BrowseConnect sDriver to sServerList
10882>>>        Get ExtractList sServerList Current_object To iNumServers
10883>>>        Function_Return iNumServers
10884>>>    End_Function // EnumerateServers
10885>>>
10885>>>    //***
10885>>>    //*** Function: EnumerateDatabases
10885>>>    //*** Purpose : Enumerate database in a given server.
10885>>>    //***
10885>>>
10885>>>    Function EnumerateDatabases String sServer String sUser String sPassWord Returns Integer
10887>>>        Local Integer hoSQL
10887>>>        Local String  sConnect
10887>>>        Local String  sDatabase
10887>>>        Local Integer hdbc
10887>>>        Local Integer hstmt
10887>>>        Local Integer iFetchResult
10887>>>
10887>>>        If (Num_Arguments < 3) ;            Move "" To sPassWord
10890>>>        If (Num_Arguments < 2) ;            Move "" To sUser
10893>>>
10893>>>        If (sUser <> "") ;            Move ("SERVER=" + Trim(sServer) + ";UID=" + Trim(sUser) + ";PWD=" + Trim(sPassword) + ";") To sConnect
10896>>>        Else ;            Move ("SERVER=" + Trim(sServer) + ";Trusted_Connection=yes") To sConnect
10898>>>
10898>>>        Object oEnumDBSQLmanager Is A cSQLHandleManager
10900>>>            Move Current_Object To hoSQL
10901>>>        End_Object // oEnumDBSQLManager
10902>>>
10902>>>        If (hoSQL <> 0) Begin
10904>>>            Get SQLConnect Of hoSQL "MSSQLDRV" sConnect To hdbc
10905>>>            If (hdbc <> 0) Begin
10907>>>                Get SQLOpen Of hdbc To hstmt
10908>>>                If (hstmt <> 0) Begin
10910>>>                    //*** We could do a direct select on the sysdatabases table but we use
10910>>>                    //*** the stored procedure sp_database instead. SQL Server recommends this
10910>>>                    //*** approach in case meta data might change, the stored procedure will
10910>>>                    //*** stay the same.
10910>>>                    Send SQLSetProcedureName To hstmt "sp_databases"
10911>>>                    Send SQLCall To hstmt
10912>>>                    Repeat
10912>>>>
10912>>>                        Get SQLFetch Of hstmt To iFetchResult
10913>>>                        If (iFetchResult <> 0) Begin
10915>>>                            Get SQLColumnValue Of hstmt 1 To sDatabase
10916>>>                            Set Value Item (Item_Count(Current_Object)) To sDatabase
10917>>>                        End
10917>>>>
10917>>>                    Until (iFetchResult = 0)
10919>>>
10919>>>                    Send SQLClose To hstmt
10920>>>                End
10920>>>>
10920>>>                Send SQLDisconnect To hdbc
10921>>>            End
10921>>>>
10921>>>        End
10921>>>>
10921>>>        Send Destroy_Object To hoSQL
10922>>>
10922>>>        Function_return (Item_Count(Current_Object))
10923>>>    End_Function // EnumerateDatabases
10924>>>
10924>>>End_Class // cMSSQLHandler
10925>>>
10925>Use db2_drv.pkg
Including file: db2_drv.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\db2_drv.pkg)
10925>>>//*****************************************************************************
10925>>>//*** DB2_DRV.PKG                                                           ***
10925>>>//***                                                                       ***
10925>>>//*** Author: Ben Weijers                                                   ***
10925>>>//***         Data Access Nederland                                         ***
10925>>>//***         30 July 1998                                                  ***
10925>>>//***                                                                       ***
10925>>>//*** Last updated: May 2, 2007                                                                      ***
10925>>>//***                                                                       ***
10925>>>//*** Purpose:                                                              ***
10925>>>//***   Package that declares DB2 driver constants and functions.           ***
10925>>>//****                                                                      ***
10925>>>//***   This package can be used by developers who want to add DB2 driver   ***
10925>>>//***   specific code to a DataFlex application.                            ***
10925>>>//*****************************************************************************
10925>>>
10925>>>Use Cli.pkg
10925>>>
10925>>>//*** Driver attributes
10925>>>
10925>>>
10925>>>//*** Driver Indentification
10925>>>
10925>>>//*** Error number constants
10925>>>
10925>>>//*** Call driver function identifiers
10925>>>
10925>>>// DB2 specific data types
10925>>>Define SQL_CLOB           for   (-99)  
10925>>>Define SQL_BLOB           for   (-98)  
10925>>>Define SQL_XML            for   (-370) 
10925>>>// DB2 Graphic types are Unicode types
10925>>>Define SQL_GRAPHIC        for   (-95)  
10925>>>Define SQL_VARGRAPHIC     for   (-96)  
10925>>>Define SQL_LONGVARGRAPHIC for   (-97)  
10925>>>Define SQL_DBCLOB         for   (-350) 
10925>>>
10925>>>
10925>>>//*** Extra DB2 commands
10925>>>
10925>>>
10925>>>//*****************************************************************************
10925>>>//*** DB2_CheckTrigger <NewState>                                           ***
10925>>>//***                                                                       ***
10925>>>//*** This command will set the trigger check at open on or off.            ***
10925>>>//*****************************************************************************
10925>>>
10925>>>
10925>>>
10925>>>//*****************************************************************************
10925>>>//*** DB2_SetConstraint <FileNum> <ConstraintText>                          ***
10925>>>//***                                                                       ***
10925>>>//***   Setup a constraint for a file.                                      ***
10925>>>//*****************************************************************************
10925>>>
10925>>>
10925>>>
10925>>>Class cDB2Handler Is A cCLIHandler
10926>>>
10926>>>    Procedure Construct_Object
10928>>>        Forward Send Construct_Object
10930>>>
10930>>>        Set psDriverID To DB2_DRV_ID
10931>>>    End_Procedure // Construct_Object
10932>>>
10932>>>
10932>>>
10932>>>    //***
10932>>>    //*** Procedure: SeedDataSources
10932>>>    //*** Purpose  : Reset the datasource list to the beginning
10932>>>    //***
10932>>>
10932>>>    Procedure SeedDataSources
10934>>>        Local String  sDriver
10934>>>        Local String  sVoid
10934>>>        Local Integer iRetval
10934>>>
10934>>>        Get psDriverID To sDriver
10935>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid SQL_FETCH_ALL Result iRetval
10942>>>    End_Procedure // SeedDataSources
10943>>>
10943>>>
10943>>>
10943>>>    //***
10943>>>    //*** Function: DataSources
10943>>>    //*** Purpose : Call the driver's data sources function
10943>>>    //***
10943>>>
10943>>>    Function DataSources Returns String
10945>>>        Local String  sDriver
10945>>>        Local String  sDataSource
10945>>>        Local String  sDescription
10945>>>        Local Integer iLength
10945>>>        Local Integer iRetval
10945>>>
10945>>>        Get psDriverID To sDriver
10946>>>        If (sDriver <> "") Begin
10948>>>            Move 8192 To iLength
10949>>>            Move (Repeat(" ", iLength)) To sDataSource
10950>>>            Move (Repeat(" ", iLength)) To sDescription
10951>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
10956>>>        End
10956>>>>
10956>>>
10956>>>        If (sDataSource <> "" Or sDescription <> "") ;            Function_Return (sDataSource + "," +  sDescription)
10959>>>        Else ;            Function_Return ""
10961>>>    End_Function// DataSources
10962>>>
10962>>>End_Class // cODBCHandler
10963>>>
10963>>>
10963>
10963>
10963>
10963>Define C_DF_EMBEDDED_DRIVER     for "DATAFLEX"
10963>Declare_Datafile Flexerrs
Including file: FlexErrs.fd    (C:\Projects\DF18\DbUpdateFramework\DDSrc\FlexErrs.fd)
10963>
10963>
10963>Object oApplication is a cApplication
10965>    Set pbPreserveEnvironment to False
10966>    Set peHelpType to htNoHelp
10967>    
10967>    Property String psDatabase_Driver           MSSQLDRV_ID      
10969>    Property String psDatabase_Server           ".\SQLEXPRESS"
10971>    Property String psDatabase_Database         "Order Entry DAPCON"
10973>    Property String psDatabase_Owner            "dbo"
10975>    Property String psDatabase_Connection       (SFormat("SERVER=%1;Trusted_Connection=yes;DATABASE=%2", psDatabase_Server(Self), psDatabase_Database(Self)))
10977>    Property String psTable_Character_Format   "ANSI"
10979>
10979>//ToDo: DB2:
10979>//    Property String psDatabase_Driver           DB2_DRV_ID
10979>//    Property String psDatabase_Server           "db2dev.xls.local"
10979>//    Property String psDatabase_Port             "50004"
10979>//    Property String psDatabase_Database         "ORDER"
10979>//    Property String psDatabase_Owner            "DAW"
10979>//    Property String psDatabase_Connection       (SFormat("Driver={IBM DB2 ODBC DRIVER};Hostname=%1;Port=%2;Database=%3;Protocol=TCPIP;CurrentSchema=%4; UID=%5; PWD=%6", ;
10979>//                                                psDatabase_Server(Self), psDatabase_Port(Self), psDatabase_Database(Self), psDatabase_Owner(Self), ;
10979>//                                                psDatabase_UID(Self), psDatabase_PWD(Self)))
10979>//    Property String psTable_Character_Format   "OEM"
10979>End_Object // oApplication
10980>
10980>
/SQL_CREATE_DATABASE
Image 1, SQL_CREATE_DATABASE
If EXISTS (SELECT  [name]
            FROM   [master].[sys].[databases]
            WHERE  [name] = '%DATABASE%')
BEGIN
    Print '- database already exists.'
END 
Else Begin
    CREATE DATABASE [%DATABASE%]
        If @@ERROR <> 0
                Print 'ERR'
        Else
                Print '- database %DATABASE% created.'
End
/*
10980>
10980>//ToDo: DB2:
10980>// "CREATE DATABASE [%DATABASE%] AUTOMATIC STORAGE YES ON /usr/rp/db2/ USING CODESET ISO8859-1 TERRITORY NZ COLLATE USING SYSTEM PAGESIZE 8192"
10980>
10980>
10980>Object oFlexToSQL is a cObject
10982>    Property Integer piFirst_Empty_Filelist_Slot    0
10984>    
10984>    // Callback:
10984>    //
10984>    Function Callback String sMessage Integer iType Returns Integer
10987>        Showln sMessage
10989>        
10989>        Function_Return DF_SUCCESS
10990>    End_Function // Callback
10991>
10991>    
10991>    // Overlap_Columns:
10991>    // Returns a list of overlap columns and their start / ending columns
10991>    //
10991>    Function Overlap_Columns Handle hTable Integer[][] ByRef irgOverlaps Returns Boolean
10994>        Integer iColumn iNoOfColumns iColumnType iStartColumn iEndColumn
10994>        Integer iOverlap iOverlapColumn
10994>        Boolean bOverlap
10994>        
10994>        Move -1 to iOverlap
10995>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNoOfColumns                                
10998>        For iOverlapColumn from 1 to iNoOfColumns 
11004>            Get_Attribute DF_FIELD_TYPE of hTable iOverlapColumn to iColumnType                                     
11007>            If (iColumnType = DF_OVERLAP) Begin
11009>                
11009>                // For each overlap check which column, or columns, are overlapped
11009>                // and record the starting and end columns.
11009>                
11009>                Move 0 to iStartColumn
11010>                Move 0 to iEndColumn
11011>                For iColumn from 1 to iNoOfColumns
11017>                    Get_Attribute DF_FIELD_TYPE of hTable iColumn to iColumnType                                     
11020>                    If (iColumnType <> DF_OVERLAP) Begin
11022>                        
11022>                        // Does the overlap column overlap a real column
11022>                        
11022>                        Get_Attribute DF_FIELD_OVERLAP of hTable iOverlapColumn iColumn to bOverlap
11025>                        If (bOverlap) Begin
11027>                            If (iStartColumn = 0) Move iColumn to iStartColumn
11030>                            Else Move iColumn to iEndColumn
11032>                        End
11032>                        Else Begin
11033>                            
11033>                            // Reverse check for columns that might be underlaps. 
11033>                            //
11033>                            // NB: While CK can handle underlaps the API does not using
11033>                            //     DF_FIELD_OVERLAP. Final changes must be made manually 
11033>                            //     via editing the table's .int.
11033>                            
11033>                            If (iStartColumn = 0) Begin
11035>                                Get_Attribute DF_FIELD_OVERLAP of hTable iColumn iOverlapColumn to bOverlap
11038>                                If (bOverlap) Move iColumn to iStartColumn
11041>                            End
11041>                        End
11041>                    End
11041>                Loop
11042>                
11042>                // Record the overlap details
11042>                
11042>                If (iStartColumn > 0) Begin
11044>                    
11044>                    // If an overlap has a starting column but no ending column we 
11044>                    // can assume it is an overlap for a single column.
11044>
11044>                    If (iEndColumn = 0) Move iStartColumn to iEndColumn
11047>
11047>                    Increment iOverlap
11048>                    Move iOverlapColumn to irgOverlaps[iOverlap][0]     // overlap column
11049>                    Move iStartColumn to irgOverlaps[iOverlap][1]       // overlap's starting column
11050>                    Move iEndColumn to irgOverlaps[iOverlap][2]         // overlap's ending column
11051>                End
11051>            End
11051>        Loop
11052>
11052>        Move (iOverlap >= 0) to bOverlap
11053>        
11053>        Function_Return bOverlap
11054>    End_Function // Overlap_Columns
11055>
11055>
11055>    // Update_Overlaps_Size_Offset:
11055>    // 0 - overlap column
11055>    // 1 - starts at column
11055>    // 2 - ends at column
11055>    //
11055>    Procedure Update_Overlaps_Size_Offset String sDriver Handle hTable Integer[][] irgOverlaps
11058>        Integer iOverlap iOverlapCount iStartOffset iEndOffset iSize
11058>        
11058>        Move (SizeOfArray(irgOverlaps) - 1) to iOverlapCount
11059>        For iOverlap from 0 to iOverlapCount
11065>            Get_Attribute DF_FIELD_OFFSET of hTable irgOverlaps[iOverlap][1] to iStartOffset
11068>            Get_Attribute DF_FIELD_OFFSET of hTable irgOverlaps[iOverlap][2] to iEndOffset
11071>            If (sDriver = C_DF_EMBEDDED_DRIVER) Get_Attribute DF_FIELD_NATIVE_LENGTH of hTable irgOverlaps[iOverlap][2] to iSize
11076>            Else Get_Attribute DF_FIELD_LENGTH of hTable irgOverlaps[iOverlap][2] to iSize
11080>            Move ((iEndOffset + iSize) - iStartOffset) to iSize
11081>
11081>            Set_Attribute DF_FIELD_OFFSET of hTable irgOverlaps[iOverlap][0] to iStartOffset
11084>            Set_Attribute DF_FIELD_LENGTH of hTable irgOverlaps[iOverlap][0] to iSize
11087>        Loop
11088>    End_Procedure // Update_Overlaps_Size_Offset
11089>
11089>
11089>    // First_Available_Filelist_Slot:
11089>    // We assume there is at least 1 slot available in 4096!
11089>    //
11089>    Function First_Available_Filelist_Slot Returns Handle
11092>        Handle hFirstAvailable
11092>
11092>        Get piFirst_Empty_Filelist_Slot to hFirstAvailable
11093>        If (hFirstAvailable = 0) Get_Attribute DF_FILE_NEXT_EMPTY of hFirstAvailable to hFirstAvailable
11098>
11098>        Function_Return hFirstAvailable
11099>    End_Function // First_Available_Filelist_Slot
11100>    
11100>    
11100>    // DoMigrateTable:
11100>    //
11100>    Procedure DoMigrateTable Handle hFLXTable String sTableName
11103>        Integer[][] irgOverlaps
11104>        String sDriver sOwner sConnection sPhysicalName sEmpty sErrorFile sCharFmt
11104>        Integer iNoOfIdxs iIndex iVoid iUsed iBCPFails iIdxFails iRTFreq
11104>        Boolean bOpen bOverlaps
11104>        Handle hSQLTable
11104>
11104>        Showln sTableName
11106>        
11106>        Open hFLXTable
11108>        Get_Attribute DF_FILE_OPENED of hFLXTable to bOpen
11111>        If (bOpen) Begin
11113>            Get Overlap_Columns hFLXTable (&irgOverlaps) to bOverlaps
11114>            Get_Attribute DF_FILE_RECORDS_USED of hFLXTable to iUsed
11117>
11117>            Get psDatabase_Driver of ghoApplication to sDriver
11118>            Get psDatabase_Owner of ghoApplication to sOwner
11119>            Get psDatabase_Connection of ghoApplication to sConnection
11120>            Get psTable_Character_Format of ghoApplication to sCharFmt
11121>
11121>            Move (sTableName+".int") to sPhysicalName
11122>            Move (sTableName+".err") to sErrorFile
11123>            EraseFile sErrorFile
11124>
11124>            Move 0 to hSQLTable
11125>            Structure_Start hSQLTable sDriver
11126>                Structure_Copy hFLXTable to hSQLTable
11127>
11127>                If (bOverlaps) Begin
11129>                    Send Update_Overlaps_Size_Offset sDriver hSQLTable irgOverlaps
11130>                End
11130>
11130>                // set primary key
11130>                
11130>                Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hFLXTable to iNoOfIdxs
11133>                If (iNoOfIdxs > 0) Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hSQLTable 1 to True
11138>    
11138>                // set table properties
11138>    
11138>                Set_Attribute DF_FILE_PHYSICAL_NAME          of hSQLTable to sPhysicalName
11141>                Set_Attribute DF_FILE_TABLE_NAME             of hSQLTable to sTableName
11144>                Set_Attribute DF_FILE_RECNUM_TABLE           of hSQLTable to False
11147>                Set_Attribute DF_FILE_LOGIN                  of hSQLTable to sConnection
11150>                Set_Attribute DF_FILE_OWNER                  of hSQLTable to sOwner
11153>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hSQLTable to sCharFmt
11156>                Set_Attribute DF_FILE_USE_DUMMY_ZERO_DATE    of hSQLTable to True
11159>                Set_Attribute DF_FILE_JIT_BINDING            of hSQLTable to True
11162>            Structure_End hSQLTable (DF_STRUCTEND_OPT_NONE) "" Self
11164>            
11164>            If (not(ERR)) Begin
11166>                Move 0 to iBCPFails
11167>                Move 0 to iIdxFails
11168>                
11168>                // only transfer the data if there is something to do
11168>                
11168>                If (iUsed > 0) Begin
11170>                    Case Begin
11170>                        Case (sDriver = MSSQLDRV_ID)
11172>                            Get First_Available_Filelist_Slot to hSQLTable
11173>                            Open sPhysicalName as hSQLTable
11175>                            Get_Attribute DF_FILE_OPENED of hSQLTable to bOpen
11178>                            If (bOpen) Begin
11180>         
11180>                                // NB: BCP is done in blocks of 1000 records at a time. So frequency
11180>                                //     must be set relative to this.
11180>                                
11180>                                Get_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iRTFreq
11183>                                If (iUsed <= 10000) Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to 1
11188>                                Else Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to (Round((iUsed / 1000.0) * 0.05))
11192>                    
11192>                                // Temporary delete all indices on the new table to speed up copying data
11192>                                
11192>                                Call_Driver hSQLTable sDriver Function CLI_DROPINDICES ;                                    CallBack Self ;                                    Passing sEmpty sEmpty iVoid ;                                    Result iVoid
11197>                    
11197>                                // Copy data using index 0
11197>                                
11197>                                Move RECNUM to iIndex
11198>                                Call_Driver hSQLTable sDriver Function CLI_BCP ;                                    CallBack Self ;                                    Passing iIndex sErrorFile hFLXTable ;                                    Result iBCPFails
11203>                    
11203>                                // Recreate indices
11203>                                
11203>                                Call_Driver hSQLTable sDriver Function CLI_CREATEINDICES ;                                    CallBack Self ;                                    Passing sEmpty sEmpty iVoid ;                                    Result iIdxFails
11208>                    
11208>                                Close hSQLTable hFLXTable
11210>            
11210>                                // Report & Clean up possible unneed error files
11210>                                
11210>                                If (iBCPFails > 0) Showln (SFormat("Failed to copy all data. Review details in file %1", sErrorFile))
11214>                                Else EraseFile sErrorFile
11216>                                If (iIdxFails > 0) Showln (sFormat("Failed to re-create %1 %2", iIdxFails, If((iIdxFails = 1), "index", "indexes")))
11220>
11220>                                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iRTFreq
11223>                            End
11223>                            Case Break
11224>                        Case (sDriver = DB2_DRV_ID)
11227>//ToDo: DB2: There doesn't seem to be an equivalent to CLI_BCP for DB2.
11227>//ToDo: DB2: Therefore this would need to be handle differently. 
11227>                            Case Break
11228>                    Case End
11228>                End
11228>                Else Begin
11229>                    Close hFLXTable
11230>                    Showln " Copy records skipped. Table is empty."
11232>                End
11232>
11232>                // update filelist
11232>
11232>                Set_Attribute DF_FILE_ROOT_NAME of hFLXTable to (sDriver-":"-sTableName)
11235>            
11235>                // delete the embedded tables
11235>                
11235>                If (iBCPFails = 0 and iIdxFails = 0) Begin
11237>                    EraseFile (sTableName+".dat")
11238>                    EraseFile (sTableName+".hdr")
11239>                    EraseFile (sTableName+".k*")
11240>                    EraseFile (sTableName+".tag")
11241>                    EraseFile (sTableName+".vld")
11242>                    
11242>                    Showln (SFormat("Table: %1, converted.", sTableName))
11244>                End
11244>                Else Showln (SFormat("Table: %1, converted with errors.", sTableName))
11247>            End
11247>            Else Close hFLXTable
11249>        End
11249>
11249>        Showln
11250>    End_Procedure // DoMigrateTable
11251>
11251>
11251>    // SQL_Statement_From_Image:
11251>    //
11251>    Function SQL_Statement_From_Image Integer iSQLImageNo Returns String
11254>        String sDriver sStatement
11254>        Integer iChIn iSize
11254>        
11254>        Move (Seq_New_Channel()) to iChIn
11255>        Move (SFormat("image:%1", iSQLImageNo)) to sDriver
11256>        Direct_Input channel iChIn sDriver
11258>        If (not(SeqEof)) Begin
11260>            Get_Channel_Size iChIn to iSize
11261>            If (iSize > 0) Read_Block channel iChIn sStatement iSize
11265>        End
11265>        Close_Input channel iChIn
11267>        Send Seq_Release_Channel iChIn
11268>        
11268>        Function_Return sStatement
11269>    End_Function // SQL_Statement_From_Image
11270> 
11270>
11270>    // Create_MSSQL_Database:
11270>    //
11270>    Function Create_MSSQL_Database Returns Integer
11273>        String sDriver sServer sDatabase sConnectionString sStatement sMessage
11273>        Handle ohSQLHandler ohConnection ohStatement
11273>        Integer iMessage iNoOfMessages
11273>        Boolean bSuccess
11273>
11273>        Get psDatabase_Driver of ghoApplication to sDriver
11274>        Get psDatabase_Server of ghoApplication to sServer
11275>        Get psDatabase_Database of ghoApplication to sDatabase
11276>
11276>        Showln (SFormat("creating database %1", sDatabase))
11278>       
11278>        Get Create (RefClass(cSQLHandleManager)) to ohSQLHandler
11279>        If (ohSQLHandler > 0) Begin
11281>            Move (SFormat("SERVER=%1;Trusted_Connection=yes;DATABASE=%2", sServer, "master")) to sConnectionString
11282>            Get SQLConnect of ohSQLHandler sDriver sConnectionString to ohConnection
11283>            If (ohConnection <> 0) Begin
11285>                Get SQLOpen of ohConnection to ohStatement
11286>                If (ohStatement <> 0) Begin
11288>                    Get SQL_Statement_From_Image SQL_Create_Database.N to sStatement
11289>                    Move (Replaces('%DATABASE%', sStatement, sDatabase)) to sStatement
11290>                    Send SQLExecDirect of ohStatement sStatement 
11291>                    If (not(ERR)) Begin
11293>                        Get SQLStmtAttribute of ohStatement SQLSTMTATTRIB_NUMMESSAGES to iNoOfMessages
11294>                        For iMessage from 1 to iNoOfMessages
11300>                            Get SQLGetMessage of ohStatement iMessage to sMessage
11301>                            Get RemoveComponentIdentifier of ohStatement sMessage to sMessage
11302>                            If (sMessage = 'ERR') Send UserError "Problem creating the database."
11305>                            Else Showln sMessage
11308>                        Loop
11309>                    End
11309>
11309>                    Send SQLClose of ohStatement
11310>                End
11310>                Else Send UserError "Cannot get a statement handle to the server."
11312>
11312>                Send SQLDisconnect of ohConnection
11313>            End
11313>            Else Send UserError (SFormat("Could not login on to server: %1", sConnectionString))
11315>
11315>            Send Destroy of ohSQLHandler
11316>        End
11316>        Else Error DFERR_PROGRAM "Unable to instantiate SQL handler."
11318>        Showln
11319>    
11319>        If (not(ERR)) Move (True) to bSuccess
11322>        Else Move (False) to bSuccess
11324>     
11324>        Function_Return bSuccess 
11325>    End_Function // Create_MSSQL_Database
11326>
11326>
11326>    // DoMigrateDatabase:
11326>    //
11326>    Procedure DoMigrateDatabase
11329>        String sDriver sDataPath sTableName
11329>        Boolean bContinue
11329>        Handle hTable
11329>
11329>        Get psDatabase_Driver of (phoWorkspace(ghoApplication)) to sDriver
11330>        Case Begin
11330>            Case (sDriver = MSSQLDRV_ID)
11332>                Load_Driver MSSQLDRV_ID
11333>                Get Create_MSSQL_Database to bContinue
11334>                Case Break
11335>            Case (sDriver = DB2_DRV_ID)
11338>//ToDo: DB: 
11338>                Load_Driver DB2_DRV_ID
11339>                Move (False) to bContinue
11340>                Case Break
11341>        Case End
11341>        If (bContinue) Begin 
11343>            
11343>            // switch to the database directory before starting
11343>            
11343>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
11344>            Set_Directory sDataPath
11345>            
11345>            Move 0 to hTable
11346>            Repeat
11346>                Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
11349>                If (hTable > 0 and hTable <> FLEXERRS.File_Number) Begin
11351>                    Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
11354>                    If (sTableName <> "") Begin
11356>                        If (Pos(':', sTableName) = 0) Begin
11358>//ToDo: apc: If an alias table? Update the table's filelist entry by prefixing the rootname with the driver.
11358>//ToDo: apc: No aliases in Order Entry and there doesn't seem to be any existing convention that fits.
11358> 
11358>                            Send DoMigrateTable hTable sTableName
11359>                        End
11359>                        Else Begin
11360>                            Showln (SFormat("Table: %1, is already driver tagged.", sTableName))
11362>                            Showln
11363>                        End
11363>                    End // not blank
11363>                End // table
11363>            Until (hTable = 0 or (ERR))
11365>        End
11365>    End_Procedure // DoMigrateDatabase
11366>
11366>End_Object // oFlexToSQL
11367>
11367>
11367>Send DoMigrateDatabase of oFlexToSQL
11368>
11368>Inkey Windowindex
11369>Abort
11370>
Summary
Memory Available: 2147483646
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 10977
Total Resources: 0
Total Commands : 11369
Total Windows  : 0
Total Pages    : 1
Static Data    : 97877
Message area   : 58786
Total Blocks   : 5615
